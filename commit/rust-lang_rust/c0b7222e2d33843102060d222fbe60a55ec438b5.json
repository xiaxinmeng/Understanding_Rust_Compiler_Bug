{"sha": "c0b7222e2d33843102060d222fbe60a55ec438b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwYjcyMjJlMmQzMzg0MzEwMjA2MGQyMjJmYmU2MGE1NWVjNDM4YjU=", "commit": {"author": {"name": "St\u00e9phane Campinas", "email": "stephane.campinas@gmail.com", "date": "2018-10-08T09:44:23Z"}, "committer": {"name": "St\u00e9phane Campinas", "email": "stephane.campinas@gmail.com", "date": "2018-10-08T22:44:59Z"}, "message": "handle itemized items inside comments", "tree": {"sha": "7a6069a5486b1d1cf558a561abcf8a7491ac21ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a6069a5486b1d1cf558a561abcf8a7491ac21ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0b7222e2d33843102060d222fbe60a55ec438b5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCgAdFiEEipi5pnt+pUplKNfibVYg2QghATMFAlu73esACgkQbVYg2Qgh\nATN8uAf9GQH2OjcAmDIiO/feM/aptjr3vcoWKeNB55fGjWQuuQlfzk1zODKPa5d6\nMCJ8qMIdOvzKLiiN6+x+kTLxYCxU6smUnKmuqfgGUTIHYDG1Nh6YYda3tunxLX58\nItDmTee90i7xYx3d3/9sSxfviwJsbB37PxOd8mI/cMCb5GrmpEmsdCVmkTHAcqJQ\nT3QFgisavoeIbmKqmFUW7tjrQWYMokpbrDB3fBWOPNDwNotaviVEJl/xJNAwbhyx\nb9+4+nEPcbiXQiXI+B+jlvSwXPhvf68QLiOe9JC6J9kHj4DYQH2VVB1u56rY3/UC\nmIl7aVOF2ZW5x44EuGJAbJcFRz16uQ==\n=uq9T\n-----END PGP SIGNATURE-----", "payload": "tree 7a6069a5486b1d1cf558a561abcf8a7491ac21ed\nparent 8b3788d875a921e367c7df014eb2456cdde30eac\nauthor St\u00e9phane Campinas <stephane.campinas@gmail.com> 1538991863 +0200\ncommitter St\u00e9phane Campinas <stephane.campinas@gmail.com> 1539038699 +0200\n\nhandle itemized items inside comments\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0b7222e2d33843102060d222fbe60a55ec438b5", "html_url": "https://github.com/rust-lang/rust/commit/c0b7222e2d33843102060d222fbe60a55ec438b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0b7222e2d33843102060d222fbe60a55ec438b5/comments", "author": {"login": "scampi", "id": 795879, "node_id": "MDQ6VXNlcjc5NTg3OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/795879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scampi", "html_url": "https://github.com/scampi", "followers_url": "https://api.github.com/users/scampi/followers", "following_url": "https://api.github.com/users/scampi/following{/other_user}", "gists_url": "https://api.github.com/users/scampi/gists{/gist_id}", "starred_url": "https://api.github.com/users/scampi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scampi/subscriptions", "organizations_url": "https://api.github.com/users/scampi/orgs", "repos_url": "https://api.github.com/users/scampi/repos", "events_url": "https://api.github.com/users/scampi/events{/privacy}", "received_events_url": "https://api.github.com/users/scampi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scampi", "id": 795879, "node_id": "MDQ6VXNlcjc5NTg3OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/795879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scampi", "html_url": "https://github.com/scampi", "followers_url": "https://api.github.com/users/scampi/followers", "following_url": "https://api.github.com/users/scampi/following{/other_user}", "gists_url": "https://api.github.com/users/scampi/gists{/gist_id}", "starred_url": "https://api.github.com/users/scampi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scampi/subscriptions", "organizations_url": "https://api.github.com/users/scampi/orgs", "repos_url": "https://api.github.com/users/scampi/repos", "events_url": "https://api.github.com/users/scampi/events{/privacy}", "received_events_url": "https://api.github.com/users/scampi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b3788d875a921e367c7df014eb2456cdde30eac", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b3788d875a921e367c7df014eb2456cdde30eac", "html_url": "https://github.com/rust-lang/rust/commit/8b3788d875a921e367c7df014eb2456cdde30eac"}], "stats": {"total": 412, "additions": 371, "deletions": 41}, "files": [{"sha": "41301527653132279f745f2c1eec9eba6e23a085", "filename": "src/comment.rs", "status": "modified", "additions": 134, "deletions": 41, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7222e2d33843102060d222fbe60a55ec438b5/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7222e2d33843102060d222fbe60a55ec438b5/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=c0b7222e2d33843102060d222fbe60a55ec438b5", "patch": "@@ -433,6 +433,58 @@ impl CodeBlockAttribute {\n     }\n }\n \n+/// Block that is formatted as an item.\n+///\n+/// An item starts with either a star `*` or a dash `-`. Different level of indentation are\n+/// handled.\n+struct ItemizedBlock {\n+    /// the number of whitespaces up to the item sigil\n+    indent: usize,\n+    /// the string that marks the start of an item\n+    opener: String,\n+    /// sequence of whitespaces to prefix new lines that are part of the item\n+    line_start: String,\n+}\n+\n+impl ItemizedBlock {\n+    /// Returns true if the line is formatted as an item\n+    fn is_itemized_line(line: &str) -> bool {\n+        let trimmed = line.trim_left();\n+        trimmed.starts_with(\"* \") || trimmed.starts_with(\"- \")\n+    }\n+\n+    /// Creates a new ItemizedBlock described with the given line.\n+    /// The `is_itemized_line` needs to be called first.\n+    fn new(line: &str) -> ItemizedBlock {\n+        let space_to_sigil = line.chars().take_while(|c| c.is_whitespace()).count();\n+        let indent = space_to_sigil + 2;\n+        ItemizedBlock {\n+            indent,\n+            opener: line[..indent].to_string(),\n+            line_start: \" \".repeat(indent),\n+        }\n+    }\n+\n+    /// Returns a `StringFormat` used for formatting the content of an item\n+    fn create_string_format<'a>(&'a self, fmt: &'a StringFormat) -> StringFormat<'a> {\n+        StringFormat {\n+            opener: \"\",\n+            closer: \"\",\n+            line_start: \"\",\n+            line_end: \"\",\n+            shape: Shape::legacy(fmt.shape.width.saturating_sub(self.indent), Indent::empty()),\n+            trim_end: true,\n+            config: fmt.config,\n+        }\n+    }\n+\n+    /// Returns true if the line is part of the current itemized block\n+    fn in_block(&self, line: &str) -> bool {\n+        !ItemizedBlock::is_itemized_line(line)\n+            && self.indent <= line.chars().take_while(|c| c.is_whitespace()).count()\n+    }\n+}\n+\n fn rewrite_comment_inner(\n     orig: &str,\n     block_style: bool,\n@@ -493,15 +545,17 @@ fn rewrite_comment_inner(\n     let mut code_block_buffer = String::with_capacity(128);\n     let mut is_prev_line_multi_line = false;\n     let mut code_block_attr = None;\n+    let mut item_block_buffer = String::with_capacity(128);\n+    let mut item_block: Option<ItemizedBlock> = None;\n     let comment_line_separator = format!(\"{}{}\", indent_str, line_start);\n-    let join_code_block_with_comment_line_separator = |s: &str| {\n+    let join_block = |s: &str, sep: &str| {\n         let mut result = String::with_capacity(s.len() + 128);\n         let mut iter = s.lines().peekable();\n         while let Some(line) = iter.next() {\n             result.push_str(line);\n             result.push_str(match iter.peek() {\n-                Some(next_line) if next_line.is_empty() => comment_line_separator.trim_right(),\n-                Some(..) => &comment_line_separator,\n+                Some(next_line) if next_line.is_empty() => sep.trim_right(),\n+                Some(..) => &sep,\n                 None => \"\",\n             });\n         }\n@@ -511,7 +565,26 @@ fn rewrite_comment_inner(\n     for (i, (line, has_leading_whitespace)) in lines.enumerate() {\n         let is_last = i == count_newlines(orig);\n \n-        if let Some(ref attr) = code_block_attr {\n+        if let Some(ref ib) = item_block {\n+            if ib.in_block(&line) {\n+                item_block_buffer.push_str(&line);\n+                item_block_buffer.push('\\n');\n+                continue;\n+            }\n+            is_prev_line_multi_line = false;\n+            fmt.shape = Shape::legacy(max_chars, fmt_indent);\n+            let item_fmt = ib.create_string_format(&fmt);\n+            result.push_str(&comment_line_separator);\n+            result.push_str(&ib.opener);\n+            match rewrite_string(&item_block_buffer.replace(\"\\n\", \" \"), &item_fmt) {\n+                Some(s) => result.push_str(&join_block(\n+                    &s,\n+                    &format!(\"{}{}\", &comment_line_separator, ib.line_start),\n+                )),\n+                None => result.push_str(&join_block(&item_block_buffer, &comment_line_separator)),\n+            };\n+            item_block_buffer.clear();\n+        } else if let Some(ref attr) = code_block_attr {\n             if line.starts_with(\"```\") {\n                 let code_block = match attr {\n                     CodeBlockAttribute::Ignore | CodeBlockAttribute::Text => {\n@@ -529,7 +602,7 @@ fn rewrite_comment_inner(\n                 };\n                 if !code_block.is_empty() {\n                     result.push_str(&comment_line_separator);\n-                    result.push_str(&join_code_block_with_comment_line_separator(&code_block));\n+                    result.push_str(&join_block(&code_block, &comment_line_separator));\n                 }\n                 code_block_buffer.clear();\n                 result.push_str(&comment_line_separator);\n@@ -538,46 +611,42 @@ fn rewrite_comment_inner(\n             } else {\n                 code_block_buffer.push_str(&hide_sharp_behind_comment(line));\n                 code_block_buffer.push('\\n');\n-\n-                if is_last {\n-                    // There is a code block that is not properly enclosed by backticks.\n-                    // We will leave them untouched.\n-                    result.push_str(&comment_line_separator);\n-                    result.push_str(&join_code_block_with_comment_line_separator(\n-                        &trim_custom_comment_prefix(&code_block_buffer),\n-                    ));\n-                }\n             }\n+            continue;\n+        }\n \n+        code_block_attr = None;\n+        item_block = None;\n+        if line.starts_with(\"```\") {\n+            code_block_attr = Some(CodeBlockAttribute::new(&line[3..]))\n+        } else if config.wrap_comments() && ItemizedBlock::is_itemized_line(&line) {\n+            let ib = ItemizedBlock::new(&line);\n+            item_block_buffer.push_str(&line[ib.indent..]);\n+            item_block_buffer.push('\\n');\n+            item_block = Some(ib);\n             continue;\n-        } else {\n-            code_block_attr = if line.starts_with(\"```\") {\n-                Some(CodeBlockAttribute::new(&line[3..]))\n-            } else {\n-                None\n-            };\n+        }\n \n-            if result == opener {\n-                let force_leading_whitespace = opener == \"/* \" && count_newlines(orig) == 0;\n-                if !has_leading_whitespace && !force_leading_whitespace && result.ends_with(' ') {\n-                    result.pop();\n-                }\n-                if line.is_empty() {\n-                    continue;\n-                }\n-            } else if is_prev_line_multi_line && !line.is_empty() {\n-                result.push(' ')\n-            } else if is_last && line.is_empty() {\n-                // trailing blank lines are unwanted\n-                if !closer.is_empty() {\n-                    result.push_str(&indent_str);\n-                }\n-                break;\n-            } else {\n-                result.push_str(&comment_line_separator);\n-                if !has_leading_whitespace && result.ends_with(' ') {\n-                    result.pop();\n-                }\n+        if result == opener {\n+            let force_leading_whitespace = opener == \"/* \" && count_newlines(orig) == 0;\n+            if !has_leading_whitespace && !force_leading_whitespace && result.ends_with(' ') {\n+                result.pop();\n+            }\n+            if line.is_empty() {\n+                continue;\n+            }\n+        } else if is_prev_line_multi_line && !line.is_empty() {\n+            result.push(' ')\n+        } else if is_last && line.is_empty() {\n+            // trailing blank lines are unwanted\n+            if !closer.is_empty() {\n+                result.push_str(&indent_str);\n+            }\n+            break;\n+        } else {\n+            result.push_str(&comment_line_separator);\n+            if !has_leading_whitespace && result.ends_with(' ') {\n+                result.pop();\n             }\n         }\n \n@@ -631,6 +700,30 @@ fn rewrite_comment_inner(\n             is_prev_line_multi_line = false;\n         }\n     }\n+    if !code_block_buffer.is_empty() {\n+        // There is a code block that is not properly enclosed by backticks.\n+        // We will leave them untouched.\n+        result.push_str(&comment_line_separator);\n+        result.push_str(&join_block(\n+            &trim_custom_comment_prefix(&code_block_buffer),\n+            &comment_line_separator,\n+        ));\n+    }\n+    if !item_block_buffer.is_empty() {\n+        // the last few lines are part of an itemized block\n+        let ib = item_block.unwrap();\n+        fmt.shape = Shape::legacy(max_chars, fmt_indent);\n+        let item_fmt = ib.create_string_format(&fmt);\n+        result.push_str(&comment_line_separator);\n+        result.push_str(&ib.opener);\n+        match rewrite_string(&item_block_buffer.replace(\"\\n\", \" \"), &item_fmt) {\n+            Some(s) => result.push_str(&join_block(\n+                &s,\n+                &format!(\"{}{}\", &comment_line_separator, ib.line_start),\n+            )),\n+            None => result.push_str(&join_block(&item_block_buffer, &comment_line_separator)),\n+        };\n+    }\n \n     result.push_str(closer);\n     if result.ends_with(opener) && opener.ends_with(' ') {"}, {"sha": "dff9ee8a222448149fbdab57cf2de198dd6ba6f8", "filename": "tests/source/itemized-blocks/no_wrap.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7222e2d33843102060d222fbe60a55ec438b5/tests%2Fsource%2Fitemized-blocks%2Fno_wrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7222e2d33843102060d222fbe60a55ec438b5/tests%2Fsource%2Fitemized-blocks%2Fno_wrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fitemized-blocks%2Fno_wrap.rs?ref=c0b7222e2d33843102060d222fbe60a55ec438b5", "patch": "@@ -0,0 +1,46 @@\n+// rustfmt-normalize_comments: true\n+\n+//! This is a list:\n+//!  * Outer\n+//!  * Outer\n+//!   * Inner\n+//!   * Inner with lots of text so that it could be reformatted something something something lots of text so that it could be reformatted something something something\n+//!\n+//! This example shows how to configure fern to output really nicely colored logs\n+//! - when the log level is error, the whole line is red\n+//! - when the log level is warn, the whole line is yellow\n+//! - when the log level is info, the level name is green and the rest of the line is white\n+//! - when the log level is debug, the whole line is white\n+//! - when the log level is trace, the whole line is gray (\"bright black\")\n+\n+/// All the parameters ***except for `from_theater`*** should be inserted as sent by the remote\n+/// theater, ie. as passed to [`Theater::send`] on the remote actor:\n+///  * `from` is the sending (remote) [`ActorId`], as reported by the remote theater by theater-specific means\n+///  * `to` is the receiving (local) [`ActorId`], as requested by the remote theater\n+///  * `tag` is a tag that identifies the message type\n+///  * `msg` is the (serialized) message\n+/// All the parameters ***except for `from_theater`*** should be inserted as sent by the remote\n+/// theater, ie. as passed to [`Theater::send`] on the remote actor\n+fn func1() {}\n+\n+/// All the parameters ***except for `from_theater`*** should be inserted as sent by the remote\n+/// theater, ie. as passed to [`Theater::send`] on the remote actor:\n+///  * `from` is the sending (remote) [`ActorId`], as reported by the remote theater by theater-specific means\n+///  * `to` is the receiving (local) [`ActorId`], as requested by the remote theater\n+///  * `tag` is a tag that identifies the message type\n+///  * `msg` is the (serialized) message\n+/// ```\n+/// let x =     42;\n+/// ```\n+fn func2() {}\n+\n+/// Look:\n+///\n+/// ```\n+/// let x =     42;\n+/// ```\n+///  * `from` is the sending (remote) [`ActorId`], as reported by the remote theater by theater-specific means\n+///  * `to` is the receiving (local) [`ActorId`], as requested by the remote theater\n+///  * `tag` is a tag that identifies the message type\n+///  * `msg` is the (serialized) message\n+fn func3() {}"}, {"sha": "5daba855e6bcc2eaef56147e73aa7d7c999775aa", "filename": "tests/source/itemized-blocks/wrap.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7222e2d33843102060d222fbe60a55ec438b5/tests%2Fsource%2Fitemized-blocks%2Fwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7222e2d33843102060d222fbe60a55ec438b5/tests%2Fsource%2Fitemized-blocks%2Fwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fitemized-blocks%2Fwrap.rs?ref=c0b7222e2d33843102060d222fbe60a55ec438b5", "patch": "@@ -0,0 +1,54 @@\n+// rustfmt-wrap_comments: true\n+// rustfmt-max_width: 50\n+\n+//! This is a list:\n+//!  * Outer\n+//!  * Outer\n+//!   * Inner\n+//!   * Inner with lots of text so that it could be reformatted something something something lots of text so that it could be reformatted something something something\n+//!\n+//! This example shows how to configure fern to output really nicely colored logs\n+//! - when the log level is error, the whole line is red\n+//! - when the log level is warn, the whole line is yellow\n+//! - when the log level is info, the level name is green and the rest of the line is white\n+//! - when the log level is debug, the whole line is white\n+//! - when the log level is trace, the whole line is gray (\"bright black\")\n+\n+// This example shows how to configure fern to output really nicely colored logs\n+// - when the log level is error, the whole line is red\n+//   - when the log level is warn, the whole line is yellow\n+//     - when the log level is info, the level name is green and the rest of the line is white\n+//   - when the log level is debug, the whole line is white\n+//   - when the log level is trace, the whole line is gray (\"bright black\")\n+\n+/// All the parameters ***except for `from_theater`*** should be inserted as sent by the remote\n+/// theater, ie. as passed to [`Theater::send`] on the remote actor:\n+///  * `from` is the sending (remote) [`ActorId`], as reported by the remote theater by theater-specific means\n+///  * `to` is the receiving (local) [`ActorId`], as requested by the remote theater\n+///  * `tag` is a tag that identifies the message type\n+///  * `msg` is the (serialized) message\n+/// All the parameters ***except for `from_theater`*** should be inserted as sent by the remote\n+/// theater, ie. as passed to [`Theater::send`] on the remote actor\n+fn func1() {}\n+\n+/// All the parameters ***except for `from_theater`*** should be inserted as sent by the remote\n+/// theater, ie. as passed to [`Theater::send`] on the remote actor:\n+///  * `from` is the sending (remote) [`ActorId`], as reported by the remote theater by theater-specific means\n+///  * `to` is the receiving (local) [`ActorId`], as requested by the remote theater\n+///  * `tag` is a tag that identifies the message type\n+///  * `msg` is the (serialized) message\n+/// ```\n+/// let x =     42;\n+/// ```\n+fn func2() {}\n+\n+/// Look:\n+///\n+/// ```\n+/// let x =     42;\n+/// ```\n+///  * `from` is the sending (remote) [`ActorId`], as reported by the remote theater by theater-specific means\n+///  * `to` is the receiving (local) [`ActorId`], as requested by the remote theater\n+///  * `tag` is a tag that identifies the message type\n+///  * `msg` is the (serialized) message\n+fn func3() {}"}, {"sha": "c7151cf81ff9fca9f94b28a8b75ebd70e231c511", "filename": "tests/target/itemized-blocks/no_wrap.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7222e2d33843102060d222fbe60a55ec438b5/tests%2Ftarget%2Fitemized-blocks%2Fno_wrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7222e2d33843102060d222fbe60a55ec438b5/tests%2Ftarget%2Fitemized-blocks%2Fno_wrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fitemized-blocks%2Fno_wrap.rs?ref=c0b7222e2d33843102060d222fbe60a55ec438b5", "patch": "@@ -0,0 +1,46 @@\n+// rustfmt-normalize_comments: true\n+\n+//! This is a list:\n+//!  * Outer\n+//!  * Outer\n+//!   * Inner\n+//!   * Inner with lots of text so that it could be reformatted something something something lots of text so that it could be reformatted something something something\n+//!\n+//! This example shows how to configure fern to output really nicely colored logs\n+//! - when the log level is error, the whole line is red\n+//! - when the log level is warn, the whole line is yellow\n+//! - when the log level is info, the level name is green and the rest of the line is white\n+//! - when the log level is debug, the whole line is white\n+//! - when the log level is trace, the whole line is gray (\"bright black\")\n+\n+/// All the parameters ***except for `from_theater`*** should be inserted as sent by the remote\n+/// theater, ie. as passed to [`Theater::send`] on the remote actor:\n+///  * `from` is the sending (remote) [`ActorId`], as reported by the remote theater by theater-specific means\n+///  * `to` is the receiving (local) [`ActorId`], as requested by the remote theater\n+///  * `tag` is a tag that identifies the message type\n+///  * `msg` is the (serialized) message\n+/// All the parameters ***except for `from_theater`*** should be inserted as sent by the remote\n+/// theater, ie. as passed to [`Theater::send`] on the remote actor\n+fn func1() {}\n+\n+/// All the parameters ***except for `from_theater`*** should be inserted as sent by the remote\n+/// theater, ie. as passed to [`Theater::send`] on the remote actor:\n+///  * `from` is the sending (remote) [`ActorId`], as reported by the remote theater by theater-specific means\n+///  * `to` is the receiving (local) [`ActorId`], as requested by the remote theater\n+///  * `tag` is a tag that identifies the message type\n+///  * `msg` is the (serialized) message\n+/// ```\n+/// let x = 42;\n+/// ```\n+fn func2() {}\n+\n+/// Look:\n+///\n+/// ```\n+/// let x = 42;\n+/// ```\n+///  * `from` is the sending (remote) [`ActorId`], as reported by the remote theater by theater-specific means\n+///  * `to` is the receiving (local) [`ActorId`], as requested by the remote theater\n+///  * `tag` is a tag that identifies the message type\n+///  * `msg` is the (serialized) message\n+fn func3() {}"}, {"sha": "08d8ca352612785eeeb074e0ae24e09871b586c7", "filename": "tests/target/itemized-blocks/wrap.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7222e2d33843102060d222fbe60a55ec438b5/tests%2Ftarget%2Fitemized-blocks%2Fwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7222e2d33843102060d222fbe60a55ec438b5/tests%2Ftarget%2Fitemized-blocks%2Fwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fitemized-blocks%2Fwrap.rs?ref=c0b7222e2d33843102060d222fbe60a55ec438b5", "patch": "@@ -0,0 +1,91 @@\n+// rustfmt-wrap_comments: true\n+// rustfmt-max_width: 50\n+\n+//! This is a list:\n+//!  * Outer\n+//!  * Outer\n+//!   * Inner\n+//!   * Inner with lots of text so that it could\n+//!     be reformatted something something\n+//!     something lots of text so that it could be\n+//!     reformatted something something something\n+//!\n+//! This example shows how to configure fern to\n+//! output really nicely colored logs\n+//! - when the log level is error, the whole line\n+//!   is red\n+//! - when the log level is warn, the whole line\n+//!   is yellow\n+//! - when the log level is info, the level name\n+//!   is green and the rest of the line is white\n+//! - when the log level is debug, the whole line\n+//!   is white\n+//! - when the log level is trace, the whole line\n+//!   is gray (\"bright black\")\n+\n+// This example shows how to configure fern to\n+// output really nicely colored logs\n+// - when the log level is error, the whole line\n+//   is red\n+//   - when the log level is warn, the whole line\n+//     is yellow\n+//     - when the log level is info, the level\n+//       name is green and the rest of the line is\n+//       white\n+//   - when the log level is debug, the whole line\n+//     is white\n+//   - when the log level is trace, the whole line\n+//     is gray (\"bright black\")\n+\n+/// All the parameters ***except for\n+/// `from_theater`*** should be inserted as sent\n+/// by the remote theater, ie. as passed to\n+/// [`Theater::send`] on the remote\n+/// actor:\n+///  * `from` is the sending (remote) [`ActorId`],\n+///    as reported by the remote theater by\n+///    theater-specific means\n+///  * `to` is the receiving (local) [`ActorId`],\n+///    as requested by the remote theater\n+///  * `tag` is a tag that identifies the message\n+///    type\n+///  * `msg` is the (serialized) message\n+/// All the parameters ***except for\n+/// `from_theater`*** should be inserted as sent\n+/// by the remote theater, ie. as passed to\n+/// [`Theater::send`] on the remote\n+/// actor\n+fn func1() {}\n+\n+/// All the parameters ***except for\n+/// `from_theater`*** should be inserted as sent\n+/// by the remote theater, ie. as passed to\n+/// [`Theater::send`] on the remote\n+/// actor:\n+///  * `from` is the sending (remote) [`ActorId`],\n+///    as reported by the remote theater by\n+///    theater-specific means\n+///  * `to` is the receiving (local) [`ActorId`],\n+///    as requested by the remote theater\n+///  * `tag` is a tag that identifies the message\n+///    type\n+///  * `msg` is the (serialized) message\n+/// ```\n+/// let x = 42;\n+/// ```\n+fn func2() {}\n+\n+/// Look:\n+///\n+/// ```\n+/// let x = 42;\n+/// ```\n+///  * `from` is the sending (remote) [`ActorId`],\n+///    as reported by the remote theater by\n+///    theater-specific means\n+///  * `to` is the receiving (local) [`ActorId`],\n+///    as requested by the remote theater\n+///  * `tag` is a tag that identifies the message\n+///    type\n+///  * `msg` is the (serialized) message\n+fn func3() {}"}]}