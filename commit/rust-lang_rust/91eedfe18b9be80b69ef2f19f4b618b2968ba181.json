{"sha": "91eedfe18b9be80b69ef2f19f4b618b2968ba181", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxZWVkZmUxOGI5YmU4MGI2OWVmMmYxOWY0YjYxOGIyOTY4YmExODE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-12T17:48:01Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-18T15:24:55Z"}, "message": "Report errors for type parameters that are not constrained, either by\nvariance or an associated type.", "tree": {"sha": "f2b2dd41ed7d1020553b91b145eb0482d9ca2590", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2b2dd41ed7d1020553b91b145eb0482d9ca2590"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91eedfe18b9be80b69ef2f19f4b618b2968ba181", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91eedfe18b9be80b69ef2f19f4b618b2968ba181", "html_url": "https://github.com/rust-lang/rust/commit/91eedfe18b9be80b69ef2f19f4b618b2968ba181", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91eedfe18b9be80b69ef2f19f4b618b2968ba181/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2594d56e32bd5a86befbb9e072b272251bbdfc9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2594d56e32bd5a86befbb9e072b272251bbdfc9f", "html_url": "https://github.com/rust-lang/rust/commit/2594d56e32bd5a86befbb9e072b272251bbdfc9f"}], "stats": {"total": 250, "additions": 180, "deletions": 70}, "files": [{"sha": "503def14fcdeb5168b01048e7144043376043154", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/91eedfe18b9be80b69ef2f19f4b618b2968ba181/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91eedfe18b9be80b69ef2f19f4b618b2968ba181/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=91eedfe18b9be80b69ef2f19f4b618b2968ba181", "patch": "@@ -2955,6 +2955,13 @@ impl<'tcx> TyS<'tcx> {\n         assert_eq!(r, Some(self));\n         walker\n     }\n+\n+    pub fn as_opt_param_ty(&self) -> Option<ty::ParamTy> {\n+        match self.sty {\n+            ty::ty_param(ref d) => Some(d.clone()),\n+            _ => None,\n+        }\n+    }\n }\n \n pub fn walk_ty<'tcx, F>(ty_root: Ty<'tcx>, mut f: F)"}, {"sha": "da5dbb2260803f44c86308b6fa6ebac18ed84cc0", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 139, "deletions": 11, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/91eedfe18b9be80b69ef2f19f4b618b2968ba181/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91eedfe18b9be80b69ef2f19f4b618b2968ba181/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=91eedfe18b9be80b69ef2f19f4b618b2968ba181", "patch": "@@ -10,21 +10,22 @@\n \n use astconv::AstConv;\n use check::{FnCtxt, Inherited, blank_fn_ctxt, vtable, regionck};\n+use constrained_type_params::identify_constrained_type_params;\n use CrateCtxt;\n use middle::region;\n-use middle::subst;\n+use middle::subst::{self, TypeSpace, FnSpace, ParamSpace, SelfSpace};\n use middle::traits;\n use middle::ty::{self, Ty};\n use middle::ty::liberate_late_bound_regions;\n use middle::ty_fold::{TypeFolder, TypeFoldable, super_fold_ty};\n-use util::ppaux::Repr;\n+use util::ppaux::{Repr, UserString};\n \n use std::collections::HashSet;\n use syntax::ast;\n use syntax::ast_util::{local_def};\n use syntax::attr;\n use syntax::codemap::Span;\n-use syntax::parse::token;\n+use syntax::parse::token::{self, special_idents};\n use syntax::visit;\n use syntax::visit::Visitor;\n \n@@ -38,6 +39,10 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         CheckTypeWellFormedVisitor { ccx: ccx, cache: HashSet::new() }\n     }\n \n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n+        self.ccx.tcx\n+    }\n+\n     /// Checks that the field types (in a struct def'n) or argument types (in an enum def'n) are\n     /// well-formed, meaning that they do not require any constraints not declared in the struct\n     /// definition itself. For example, this definition would be illegal:\n@@ -96,23 +101,29 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             ast::ItemConst(..) => {\n                 self.check_item_type(item);\n             }\n-            ast::ItemStruct(ref struct_def, _) => {\n+            ast::ItemStruct(ref struct_def, ref ast_generics) => {\n                 self.check_type_defn(item, |fcx| {\n                     vec![struct_variant(fcx, &**struct_def)]\n                 });\n+\n+                self.check_variances_for_type_defn(item, ast_generics);\n             }\n-            ast::ItemEnum(ref enum_def, _) => {\n+            ast::ItemEnum(ref enum_def, ref ast_generics) => {\n                 self.check_type_defn(item, |fcx| {\n                     enum_variants(fcx, enum_def)\n                 });\n+\n+                self.check_variances_for_type_defn(item, ast_generics);\n             }\n-            ast::ItemTrait(..) => {\n+            ast::ItemTrait(_, ref ast_generics, _, _) => {\n                 let trait_predicates =\n                     ty::lookup_predicates(ccx.tcx, local_def(item.id));\n                 reject_non_type_param_bounds(\n                     ccx.tcx,\n                     item.span,\n                     &trait_predicates);\n+                self.check_variances(item, ast_generics, &trait_predicates,\n+                                     self.tcx().lang_items.phantom_fn());\n             }\n             _ => {}\n         }\n@@ -280,6 +291,123 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             }\n         });\n     }\n+\n+    fn check_variances_for_type_defn(&self,\n+                                     item: &ast::Item,\n+                                     ast_generics: &ast::Generics)\n+    {\n+        let item_def_id = local_def(item.id);\n+        let predicates = ty::lookup_predicates(self.tcx(), item_def_id);\n+        self.check_variances(item,\n+                             ast_generics,\n+                             &predicates,\n+                             self.tcx().lang_items.phantom_data());\n+    }\n+\n+    fn check_variances(&self,\n+                       item: &ast::Item,\n+                       ast_generics: &ast::Generics,\n+                       ty_predicates: &ty::GenericPredicates<'tcx>,\n+                       suggested_marker_id: Option<ast::DefId>)\n+    {\n+        let variance_lang_items = &[\n+            self.tcx().lang_items.phantom_fn(),\n+            self.tcx().lang_items.phantom_data(),\n+        ];\n+\n+        let item_def_id = local_def(item.id);\n+        let is_lang_item = variance_lang_items.iter().any(|n| *n == Some(item_def_id));\n+        if is_lang_item {\n+            return;\n+        }\n+\n+        let variances = ty::item_variances(self.tcx(), item_def_id);\n+\n+        let mut constrained_parameters: HashSet<_> =\n+            variances.types\n+            .iter_enumerated()\n+            .filter(|&(_, _, &variance)| variance != ty::Bivariant)\n+            .map(|(space, index, _)| self.param_ty(ast_generics, space, index))\n+            .collect();\n+\n+        identify_constrained_type_params(self.tcx(),\n+                                         ty_predicates.predicates.as_slice(),\n+                                         None,\n+                                         &mut constrained_parameters);\n+\n+        for (space, index, _) in variances.types.iter_enumerated() {\n+            let param_ty = self.param_ty(ast_generics, space, index);\n+            if constrained_parameters.contains(&param_ty) {\n+                continue;\n+            }\n+            let span = self.ty_param_span(ast_generics, item, space, index);\n+            self.report_bivariance(span, param_ty.name, suggested_marker_id);\n+        }\n+\n+        for (space, index, &variance) in variances.regions.iter_enumerated() {\n+            if variance != ty::Bivariant {\n+                continue;\n+            }\n+\n+            assert_eq!(space, TypeSpace);\n+            let span = ast_generics.lifetimes[index].lifetime.span;\n+            let name = ast_generics.lifetimes[index].lifetime.name;\n+            self.report_bivariance(span, name, suggested_marker_id);\n+        }\n+    }\n+\n+    fn param_ty(&self,\n+                ast_generics: &ast::Generics,\n+                space: ParamSpace,\n+                index: usize)\n+                -> ty::ParamTy\n+    {\n+        let name = match space {\n+            TypeSpace => ast_generics.ty_params[index].ident.name,\n+            SelfSpace => special_idents::type_self.name,\n+            FnSpace => self.tcx().sess.bug(\"Fn space occupied?\"),\n+        };\n+\n+        ty::ParamTy { space: space, idx: index as u32, name: name }\n+    }\n+\n+    fn ty_param_span(&self,\n+                     ast_generics: &ast::Generics,\n+                     item: &ast::Item,\n+                     space: ParamSpace,\n+                     index: usize)\n+                     -> Span\n+    {\n+        match space {\n+            TypeSpace => ast_generics.ty_params[index].span,\n+            SelfSpace => item.span,\n+            FnSpace => self.tcx().sess.span_bug(item.span, \"Fn space occupied?\"),\n+        }\n+    }\n+\n+    fn report_bivariance(&self,\n+                         span: Span,\n+                         param_name: ast::Name,\n+                         suggested_marker_id: Option<ast::DefId>)\n+    {\n+        self.tcx().sess.span_err(\n+            span,\n+            &format!(\"parameter `{}` is never used\",\n+                     param_name.user_string(self.tcx()))[]);\n+\n+        match suggested_marker_id {\n+            Some(def_id) => {\n+                self.tcx().sess.span_help(\n+                    span,\n+                    format!(\"consider removing `{}` or using a marker such as `{}`\",\n+                            param_name.user_string(self.tcx()),\n+                            ty::item_path_str(self.tcx(), def_id)).as_slice());\n+            }\n+            None => {\n+                // no lang items, no help!\n+            }\n+        }\n+    }\n }\n \n // Reject any predicates that do not involve a type parameter.\n@@ -347,9 +475,9 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         match fk {\n             visit::FkFnBlock | visit::FkItemFn(..) => {}\n             visit::FkMethod(..) => {\n-                match ty::impl_or_trait_item(self.ccx.tcx, local_def(id)) {\n+                match ty::impl_or_trait_item(self.tcx(), local_def(id)) {\n                     ty::ImplOrTraitItem::MethodTraitItem(ty_method) => {\n-                        reject_shadowing_type_parameters(self.ccx.tcx, span, &ty_method.generics)\n+                        reject_shadowing_type_parameters(self.tcx(), span, &ty_method.generics)\n                     }\n                     _ => {}\n                 }\n@@ -363,14 +491,14 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             &ast::TraitItem::ProvidedMethod(_) |\n             &ast::TraitItem::TypeTraitItem(_) => {},\n             &ast::TraitItem::RequiredMethod(ref method) => {\n-                match ty::impl_or_trait_item(self.ccx.tcx, local_def(method.id)) {\n+                match ty::impl_or_trait_item(self.tcx(), local_def(method.id)) {\n                     ty::ImplOrTraitItem::MethodTraitItem(ty_method) => {\n                         reject_non_type_param_bounds(\n-                            self.ccx.tcx,\n+                            self.tcx(),\n                             method.span,\n                             &ty_method.predicates);\n                         reject_shadowing_type_parameters(\n-                            self.ccx.tcx,\n+                            self.tcx(),\n                             method.span,\n                             &ty_method.generics);\n                     }"}, {"sha": "32679c8967e7bf85ad3ef23b4347dad45e2010af", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 49, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/91eedfe18b9be80b69ef2f19f4b618b2968ba181/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91eedfe18b9be80b69ef2f19f4b618b2968ba181/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=91eedfe18b9be80b69ef2f19f4b618b2968ba181", "patch": "@@ -87,6 +87,7 @@ There are some shortcomings in this design:\n \n use astconv::{self, AstConv, ty_of_arg, ast_ty_to_ty, ast_region_to_region};\n use middle::def;\n+use constrained_type_params::identify_constrained_type_params;\n use middle::lang_items::SizedTraitLangItem;\n use middle::region;\n use middle::resolve_lifetime;\n@@ -1960,51 +1961,15 @@ fn enforce_impl_ty_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let mut input_parameters: HashSet<_> =\n         impl_trait_ref.iter()\n                       .flat_map(|t| t.input_types().iter()) // Types in trait ref, if any\n-                      .chain(Some(impl_scheme.ty).iter())  // Self type, always\n+                      .chain(Some(impl_scheme.ty).iter())   // Self type, always\n                       .flat_map(|t| t.walk())\n-                      .filter_map(to_opt_param_ty)\n+                      .filter_map(|t| t.as_opt_param_ty())\n                       .collect();\n \n-    loop {\n-        let num_inputs = input_parameters.len();\n-\n-        let projection_predicates =\n-            impl_predicates.predicates\n-                           .iter()\n-                           .filter_map(|predicate| {\n-                               match *predicate {\n-                                   // Ignore higher-ranked binders. For the purposes\n-                                   // of this check, they don't matter because they\n-                                   // only affect named regions, and we're just\n-                                   // concerned about type parameters here.\n-                                   ty::Predicate::Projection(ref data) => Some(data.0.clone()),\n-                                   _ => None,\n-                               }\n-                           });\n-\n-        for projection in projection_predicates {\n-            // Special case: watch out for some kind of sneaky attempt\n-            // to project out an associated type defined by this very trait.\n-            if Some(projection.projection_ty.trait_ref.clone()) == impl_trait_ref {\n-                continue;\n-            }\n-\n-            let relies_only_on_inputs =\n-                projection.projection_ty.trait_ref.input_types().iter()\n-                .flat_map(|t| t.walk())\n-                .filter_map(to_opt_param_ty)\n-                .all(|t| input_parameters.contains(&t));\n-\n-            if relies_only_on_inputs {\n-                input_parameters.extend(\n-                    projection.ty.walk().filter_map(to_opt_param_ty));\n-            }\n-        }\n-\n-        if input_parameters.len() == num_inputs {\n-            break;\n-        }\n-    }\n+    identify_constrained_type_params(tcx,\n+                                     impl_predicates.predicates.as_slice(),\n+                                     impl_trait_ref,\n+                                     &mut input_parameters);\n \n     for (index, ty_param) in ast_generics.ty_params.iter().enumerate() {\n         let param_ty = ty::ParamTy { space: TypeSpace,\n@@ -2025,11 +1990,4 @@ fn enforce_impl_ty_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n             }\n         }\n     }\n-\n-    fn to_opt_param_ty<'tcx>(ty: Ty<'tcx>) -> Option<ty::ParamTy> {\n-        match ty.sty {\n-            ty::ty_param(ref d) => Some(d.clone()),\n-            _ => None,\n-        }\n-    }\n }"}, {"sha": "83d7e98500007318c645114089fd8b54decb032e", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/91eedfe18b9be80b69ef2f19f4b618b2968ba181/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91eedfe18b9be80b69ef2f19f4b618b2968ba181/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=91eedfe18b9be80b69ef2f19f4b618b2968ba181", "patch": "@@ -23,16 +23,16 @@ pub fn identify_constrained_type_params<'tcx>(_tcx: &ty::ctxt<'tcx>,\n \n         let projection_predicates =\n             predicates.iter()\n-            .filter_map(|predicate| {\n-                match *predicate {\n-                    // Ignore higher-ranked binders. For the purposes\n-                    // of this check, they don't matter because they\n-                    // only affect named regions, and we're just\n-                    // concerned about type parameters here.\n-                    ty::Predicate::Projection(ref data) => Some(data.0.clone()),\n-                    _ => None,\n-                }\n-            });\n+                      .filter_map(|predicate| {\n+                          match *predicate {\n+                              // Ignore higher-ranked binders. For the purposes\n+                              // of this check, they don't matter because they\n+                              // only affect named regions, and we're just\n+                              // concerned about type parameters here.\n+                              ty::Predicate::Projection(ref data) => Some(data.0.clone()),\n+                              _ => None,\n+                          }\n+                      });\n \n         for projection in projection_predicates {\n             // Special case: watch out for some kind of sneaky attempt"}, {"sha": "b5dca0bd4f6f42348e2981d23bf079541b91986b", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91eedfe18b9be80b69ef2f19f4b618b2968ba181/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91eedfe18b9be80b69ef2f19f4b618b2968ba181/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=91eedfe18b9be80b69ef2f19f4b618b2968ba181", "patch": "@@ -123,6 +123,7 @@ mod check;\n mod rscope;\n mod astconv;\n mod collect;\n+mod constrained_type_params;\n mod coherence;\n mod variance;\n "}, {"sha": "a33ec23a16a51e592bd11bc14fcea980f09b0576", "filename": "src/test/compile-fail/issue-17904-2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/91eedfe18b9be80b69ef2f19f4b618b2968ba181/src%2Ftest%2Fcompile-fail%2Fissue-17904-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91eedfe18b9be80b69ef2f19f4b618b2968ba181/src%2Ftest%2Fcompile-fail%2Fissue-17904-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17904-2.rs?ref=91eedfe18b9be80b69ef2f19f4b618b2968ba181", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we can parse a unit struct with a where clause, even if\n+// it leads to a error later on since `T` is unused.\n+\n+struct Foo<T> where T: Copy; //~ ERROR parameter `T` is never used\n+\n+fn main() {}"}]}