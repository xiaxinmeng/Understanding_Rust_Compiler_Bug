{"sha": "d89827f9e01d855e9116a0d5276ffe1dad34ed3b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4OTgyN2Y5ZTAxZDg1NWU5MTE2YTBkNTI3NmZmZTFkYWQzNGVkM2I=", "commit": {"author": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2020-07-01T11:32:18Z"}, "committer": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2020-07-01T11:38:42Z"}, "message": "Make less code generic", "tree": {"sha": "455f59bff48a881cce37f0fd39653444f09e1c3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/455f59bff48a881cce37f0fd39653444f09e1c3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d89827f9e01d855e9116a0d5276ffe1dad34ed3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d89827f9e01d855e9116a0d5276ffe1dad34ed3b", "html_url": "https://github.com/rust-lang/rust/commit/d89827f9e01d855e9116a0d5276ffe1dad34ed3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d89827f9e01d855e9116a0d5276ffe1dad34ed3b/comments", "author": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8505f14d4bb8d393ca77ec234dd1c99826a2d79", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8505f14d4bb8d393ca77ec234dd1c99826a2d79", "html_url": "https://github.com/rust-lang/rust/commit/e8505f14d4bb8d393ca77ec234dd1c99826a2d79"}], "stats": {"total": 116, "additions": 47, "deletions": 69}, "files": [{"sha": "3d78f71c1fa8f8d9bf5d4475a16a4d9f5dbae460", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 47, "deletions": 69, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/d89827f9e01d855e9116a0d5276ffe1dad34ed3b/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d89827f9e01d855e9116a0d5276ffe1dad34ed3b/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=d89827f9e01d855e9116a0d5276ffe1dad34ed3b", "patch": "@@ -83,7 +83,7 @@ impl PathResolution {\n /// Primary API to get semantic information, like types, from syntax trees.\n pub struct Semantics<'db, DB> {\n     pub db: &'db DB,\n-    impl_: SemanticsImpl<'db>,\n+    imp: SemanticsImpl<'db>,\n }\n \n pub struct SemanticsImpl<'db> {\n@@ -101,19 +101,22 @@ impl<DB> fmt::Debug for Semantics<'_, DB> {\n impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     pub fn new(db: &DB) -> Semantics<DB> {\n         let impl_ = SemanticsImpl::new(db);\n-        Semantics { db, impl_ }\n+        Semantics { db, imp: impl_ }\n     }\n \n     pub fn parse(&self, file_id: FileId) -> ast::SourceFile {\n-        self.impl_.parse(file_id)\n+        self.imp.parse(file_id)\n     }\n \n     pub fn ast<T: AstDiagnostic + Diagnostic>(&self, d: &T) -> <T as AstDiagnostic>::AST {\n-        self.impl_.ast(d)\n+        let file_id = d.source().file_id;\n+        let root = self.db.parse_or_expand(file_id).unwrap();\n+        self.imp.cache(root, file_id);\n+        d.ast(self.db.upcast())\n     }\n \n     pub fn expand(&self, macro_call: &ast::MacroCall) -> Option<SyntaxNode> {\n-        self.impl_.expand(macro_call)\n+        self.imp.expand(macro_call)\n     }\n \n     pub fn expand_hypothetical(\n@@ -122,39 +125,39 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         hypothetical_args: &ast::TokenTree,\n         token_to_map: SyntaxToken,\n     ) -> Option<(SyntaxNode, SyntaxToken)> {\n-        self.impl_.expand_hypothetical(actual_macro_call, hypothetical_args, token_to_map)\n+        self.imp.expand_hypothetical(actual_macro_call, hypothetical_args, token_to_map)\n     }\n \n     pub fn descend_into_macros(&self, token: SyntaxToken) -> SyntaxToken {\n-        self.impl_.descend_into_macros(token)\n+        self.imp.descend_into_macros(token)\n     }\n \n     pub fn descend_node_at_offset<N: ast::AstNode>(\n         &self,\n         node: &SyntaxNode,\n         offset: TextSize,\n     ) -> Option<N> {\n-        self.impl_.descend_node_at_offset(node, offset)\n+        self.imp.descend_node_at_offset(node, offset).find_map(N::cast)\n     }\n \n     pub fn original_range(&self, node: &SyntaxNode) -> FileRange {\n-        self.impl_.original_range(node)\n+        self.imp.original_range(node)\n     }\n \n     pub fn diagnostics_range(&self, diagnostics: &dyn Diagnostic) -> FileRange {\n-        self.impl_.diagnostics_range(diagnostics)\n+        self.imp.diagnostics_range(diagnostics)\n     }\n \n     pub fn ancestors_with_macros(&self, node: SyntaxNode) -> impl Iterator<Item = SyntaxNode> + '_ {\n-        self.impl_.ancestors_with_macros(node)\n+        self.imp.ancestors_with_macros(node)\n     }\n \n     pub fn ancestors_at_offset_with_macros(\n         &self,\n         node: &SyntaxNode,\n         offset: TextSize,\n     ) -> impl Iterator<Item = SyntaxNode> + '_ {\n-        self.impl_.ancestors_at_offset_with_macros(node, offset)\n+        self.imp.ancestors_at_offset_with_macros(node, offset)\n     }\n \n     /// Find a AstNode by offset inside SyntaxNode, if it is inside *Macrofile*,\n@@ -164,7 +167,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         node: &SyntaxNode,\n         offset: TextSize,\n     ) -> Option<N> {\n-        self.impl_.find_node_at_offset_with_macros(node, offset)\n+        self.imp.ancestors_at_offset_with_macros(node, offset).find_map(N::cast)\n     }\n \n     /// Find a AstNode by offset inside SyntaxNode, if it is inside *MacroCall*,\n@@ -174,86 +177,91 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         node: &SyntaxNode,\n         offset: TextSize,\n     ) -> Option<N> {\n-        self.impl_.find_node_at_offset_with_descend(node, offset)\n+        if let Some(it) = find_node_at_offset(&node, offset) {\n+            return Some(it);\n+        }\n+\n+        self.imp.descend_node_at_offset(node, offset).find_map(N::cast)\n     }\n \n     pub fn type_of_expr(&self, expr: &ast::Expr) -> Option<Type> {\n-        self.impl_.type_of_expr(expr)\n+        self.imp.type_of_expr(expr)\n     }\n \n     pub fn type_of_pat(&self, pat: &ast::Pat) -> Option<Type> {\n-        self.impl_.type_of_pat(pat)\n+        self.imp.type_of_pat(pat)\n     }\n \n     pub fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<Function> {\n-        self.impl_.resolve_method_call(call)\n+        self.imp.resolve_method_call(call)\n     }\n \n     pub fn resolve_field(&self, field: &ast::FieldExpr) -> Option<Field> {\n-        self.impl_.resolve_field(field)\n+        self.imp.resolve_field(field)\n     }\n \n     pub fn resolve_record_field(&self, field: &ast::RecordField) -> Option<(Field, Option<Local>)> {\n-        self.impl_.resolve_record_field(field)\n+        self.imp.resolve_record_field(field)\n     }\n \n     pub fn resolve_record_field_pat(&self, field: &ast::RecordFieldPat) -> Option<Field> {\n-        self.impl_.resolve_record_field_pat(field)\n+        self.imp.resolve_record_field_pat(field)\n     }\n \n     pub fn resolve_macro_call(&self, macro_call: &ast::MacroCall) -> Option<MacroDef> {\n-        self.impl_.resolve_macro_call(macro_call)\n+        self.imp.resolve_macro_call(macro_call)\n     }\n \n     pub fn resolve_path(&self, path: &ast::Path) -> Option<PathResolution> {\n-        self.impl_.resolve_path(path)\n+        self.imp.resolve_path(path)\n     }\n \n     pub fn resolve_variant(&self, record_lit: ast::RecordLit) -> Option<VariantId> {\n-        self.impl_.resolve_variant(record_lit)\n+        self.imp.resolve_variant(record_lit)\n     }\n \n     pub fn lower_path(&self, path: &ast::Path) -> Option<Path> {\n-        self.impl_.lower_path(path)\n+        self.imp.lower_path(path)\n     }\n \n     pub fn resolve_bind_pat_to_const(&self, pat: &ast::BindPat) -> Option<ModuleDef> {\n-        self.impl_.resolve_bind_pat_to_const(pat)\n+        self.imp.resolve_bind_pat_to_const(pat)\n     }\n \n     // FIXME: use this instead?\n     // pub fn resolve_name_ref(&self, name_ref: &ast::NameRef) -> Option<???>;\n \n     pub fn record_literal_missing_fields(&self, literal: &ast::RecordLit) -> Vec<(Field, Type)> {\n-        self.impl_.record_literal_missing_fields(literal)\n+        self.imp.record_literal_missing_fields(literal)\n     }\n \n     pub fn record_pattern_missing_fields(&self, pattern: &ast::RecordPat) -> Vec<(Field, Type)> {\n-        self.impl_.record_pattern_missing_fields(pattern)\n+        self.imp.record_pattern_missing_fields(pattern)\n     }\n \n     pub fn to_def<T: ToDef>(&self, src: &T) -> Option<T::Def> {\n-        self.impl_.to_def(src)\n+        let src = self.imp.find_file(src.syntax().clone()).with_value(src).cloned();\n+        T::to_def(&self.imp, src)\n     }\n \n     pub fn to_module_def(&self, file: FileId) -> Option<Module> {\n-        self.impl_.to_module_def(file)\n+        self.imp.to_module_def(file)\n     }\n \n     pub fn scope(&self, node: &SyntaxNode) -> SemanticsScope<'db> {\n-        self.impl_.scope(node)\n+        self.imp.scope(node)\n     }\n \n     pub fn scope_at_offset(&self, node: &SyntaxNode, offset: TextSize) -> SemanticsScope<'db> {\n-        self.impl_.scope_at_offset(node, offset)\n+        self.imp.scope_at_offset(node, offset)\n     }\n \n     pub fn scope_for_def(&self, def: Trait) -> SemanticsScope<'db> {\n-        self.impl_.scope_for_def(def)\n+        self.imp.scope_for_def(def)\n     }\n \n     pub fn assert_contains_node(&self, node: &SyntaxNode) {\n-        self.impl_.assert_contains_node(node)\n+        self.imp.assert_contains_node(node)\n     }\n }\n \n@@ -268,13 +276,6 @@ impl<'db> SemanticsImpl<'db> {\n         tree\n     }\n \n-    pub fn ast<T: AstDiagnostic + Diagnostic>(&self, d: &T) -> <T as AstDiagnostic>::AST {\n-        let file_id = d.source().file_id;\n-        let root = self.db.parse_or_expand(file_id).unwrap();\n-        self.cache(root, file_id);\n-        d.ast(self.db.upcast())\n-    }\n-\n     pub fn expand(&self, macro_call: &ast::MacroCall) -> Option<SyntaxNode> {\n         let macro_call = self.find_file(macro_call.syntax().clone()).with_value(macro_call);\n         let sa = self.analyze2(macro_call.map(|it| it.syntax()), None);\n@@ -329,15 +330,16 @@ impl<'db> SemanticsImpl<'db> {\n         token.value\n     }\n \n-    pub fn descend_node_at_offset<N: ast::AstNode>(\n+    pub fn descend_node_at_offset(\n         &self,\n         node: &SyntaxNode,\n         offset: TextSize,\n-    ) -> Option<N> {\n+    ) -> impl Iterator<Item = SyntaxNode> + '_ {\n         // Handle macro token cases\n         node.token_at_offset(offset)\n             .map(|token| self.descend_into_macros(token))\n-            .find_map(|it| self.ancestors_with_macros(it.parent()).find_map(N::cast))\n+            .map(|it| self.ancestors_with_macros(it.parent()))\n+            .flatten()\n     }\n \n     pub fn original_range(&self, node: &SyntaxNode) -> FileRange {\n@@ -367,25 +369,6 @@ impl<'db> SemanticsImpl<'db> {\n             .kmerge_by(|node1, node2| node1.text_range().len() < node2.text_range().len())\n     }\n \n-    pub fn find_node_at_offset_with_macros<N: AstNode>(\n-        &self,\n-        node: &SyntaxNode,\n-        offset: TextSize,\n-    ) -> Option<N> {\n-        self.ancestors_at_offset_with_macros(node, offset).find_map(N::cast)\n-    }\n-\n-    pub fn find_node_at_offset_with_descend<N: AstNode>(\n-        &self,\n-        node: &SyntaxNode,\n-        offset: TextSize,\n-    ) -> Option<N> {\n-        if let Some(it) = find_node_at_offset(&node, offset) {\n-            return Some(it);\n-        }\n-        self.descend_node_at_offset(&node, offset)\n-    }\n-\n     pub fn type_of_expr(&self, expr: &ast::Expr) -> Option<Type> {\n         self.analyze(expr.syntax()).type_of(self.db, &expr)\n     }\n@@ -445,11 +428,6 @@ impl<'db> SemanticsImpl<'db> {\n             .unwrap_or_default()\n     }\n \n-    pub fn to_def<T: ToDef>(&self, src: &T) -> Option<T::Def> {\n-        let src = self.find_file(src.syntax().clone()).with_value(src).cloned();\n-        T::to_def(self, src)\n-    }\n-\n     fn with_ctx<F: FnOnce(&mut SourceToDefCtx) -> T, T>(&self, f: F) -> T {\n         let mut cache = self.s2d_cache.borrow_mut();\n         let mut ctx = SourceToDefCtx { db: self.db, cache: &mut *cache };\n@@ -504,7 +482,7 @@ impl<'db> SemanticsImpl<'db> {\n         SourceAnalyzer::new_for_resolver(resolver, src)\n     }\n \n-    fn cache(&self, root_node: SyntaxNode, file_id: HirFileId) {\n+    pub fn cache(&self, root_node: SyntaxNode, file_id: HirFileId) {\n         assert!(root_node.parent().is_none());\n         let mut cache = self.cache.borrow_mut();\n         let prev = cache.insert(root_node, file_id);\n@@ -520,7 +498,7 @@ impl<'db> SemanticsImpl<'db> {\n         cache.get(root_node).copied()\n     }\n \n-    fn find_file(&self, node: SyntaxNode) -> InFile<SyntaxNode> {\n+    pub fn find_file(&self, node: SyntaxNode) -> InFile<SyntaxNode> {\n         let root_node = find_root(&node);\n         let file_id = self.lookup(&root_node).unwrap_or_else(|| {\n             panic!("}]}