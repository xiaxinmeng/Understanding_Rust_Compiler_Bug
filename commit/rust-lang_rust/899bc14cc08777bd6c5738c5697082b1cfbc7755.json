{"sha": "899bc14cc08777bd6c5738c5697082b1cfbc7755", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5OWJjMTRjYzA4Nzc3YmQ2YzU3MzhjNTY5NzA4MmIxY2ZiYzc3NTU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-22T09:27:38Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-22T11:08:40Z"}, "message": "fix validating fat pointers to user-defined unsized types", "tree": {"sha": "c796424e3d1cf1c8bee2d14e5bc99c1a7ee7c2a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c796424e3d1cf1c8bee2d14e5bc99c1a7ee7c2a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/899bc14cc08777bd6c5738c5697082b1cfbc7755", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/899bc14cc08777bd6c5738c5697082b1cfbc7755", "html_url": "https://github.com/rust-lang/rust/commit/899bc14cc08777bd6c5738c5697082b1cfbc7755", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/899bc14cc08777bd6c5738c5697082b1cfbc7755/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14dc780d8978ff796c427290b4e7336c90dfc2e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/14dc780d8978ff796c427290b4e7336c90dfc2e7", "html_url": "https://github.com/rust-lang/rust/commit/14dc780d8978ff796c427290b4e7336c90dfc2e7"}], "stats": {"total": 123, "additions": 56, "deletions": 67}, "files": [{"sha": "91182edc2f5b7ea525e5c702f88ed2e9731ac273", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/899bc14cc08777bd6c5738c5697082b1cfbc7755/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/899bc14cc08777bd6c5738c5697082b1cfbc7755/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=899bc14cc08777bd6c5738c5697082b1cfbc7755", "patch": "@@ -774,6 +774,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let (size, align) = self.read_size_and_align_from_vtable(vtable)?;\n                 assert_eq!(size, layout.size);\n                 assert_eq!(align.abi(), layout.align.abi()); // only ABI alignment is preserved\n+                // FIXME: More checks for the vtable? We could make sure it is exactly\n+                // the one one would expect for this type.\n                 // Done!\n                 layout\n             },"}, {"sha": "5eb32cd7eac774ef20269dc5c5c6a04fb5b7c109", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 26, "deletions": 53, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/899bc14cc08777bd6c5738c5697082b1cfbc7755/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/899bc14cc08777bd6c5738c5697082b1cfbc7755/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=899bc14cc08777bd6c5738c5697082b1cfbc7755", "patch": "@@ -9,7 +9,7 @@ use rustc::mir::interpret::{\n };\n \n use super::{\n-    MPlaceTy, PlaceExtra, Machine, EvalContext\n+    MPlaceTy, Machine, EvalContext\n };\n \n macro_rules! validation_failure{\n@@ -281,59 +281,32 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             },\n             layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n                 // Fat pointers need special treatment.\n-                match dest.layout.ty.builtin_deref(true).map(|tam| &tam.ty.sty) {\n-                    | Some(ty::TyStr)\n-                    | Some(ty::TySlice(_)) => {\n-                        // check the length (for nicer error messages); must be valid even\n-                        // for a raw pointer.\n-                        let len_mplace = self.mplace_field(dest, 1)?;\n-                        let len = self.read_scalar(len_mplace.into())?;\n-                        let len = match len.to_bits(len_mplace.layout.size) {\n-                            Err(_) => return validation_failure!(\"length is not a valid integer\", path),\n-                            Ok(len) => len as u64,\n-                        };\n-                        // for safe ptrs, get the fat ptr, and recursively check it\n-                        if !dest.layout.ty.is_unsafe_ptr() {\n-                            let ptr = self.ref_to_mplace(self.read_value(dest.into())?)?;\n-                            assert_eq!(ptr.extra, PlaceExtra::Length(len));\n-                            let unpacked_ptr = self.unpack_unsized_mplace(ptr)?;\n-                            if seen.insert(unpacked_ptr) {\n-                                todo.push((unpacked_ptr, path_clone_and_deref(path)));\n-                            }\n-                        }\n-                    },\n-                    Some(ty::TyDynamic(..)) => {\n-                        // check the vtable (for nicer error messages); must be valid even for a\n-                        // raw ptr.\n-                        let vtable = self.read_scalar(self.mplace_field(dest, 1)?.into())?;\n-                        let vtable = match vtable.to_ptr() {\n-                            Err(_) => return validation_failure!(\"vtable address is not a pointer\", path),\n-                            Ok(vtable) => vtable,\n-                        };\n-                        // for safe ptrs, get the fat ptr, and recursively check it\n-                        if !dest.layout.ty.is_unsafe_ptr() {\n-                            let ptr = self.ref_to_mplace(self.read_value(dest.into())?)?;\n-                            assert_eq!(ptr.extra, PlaceExtra::Vtable(vtable));\n-                            let unpacked_ptr = self.unpack_unsized_mplace(ptr)?;\n-                            if seen.insert(unpacked_ptr) {\n-                                todo.push((unpacked_ptr, path_clone_and_deref(path)));\n-                            }\n-                            // FIXME: More checks for the vtable... making sure it is exactly\n-                            // the one one would expect for this type.\n-                        }\n-                    },\n-                    Some(ty) =>\n-                        bug!(\"Unexpected fat pointer target type {:?}\", ty),\n-                    None => {\n-                        // Not a pointer, perform regular aggregate handling below\n-                        for i in 0..offsets.len() {\n-                            let field = self.mplace_field(dest, i as u64)?;\n-                            path.push(self.aggregate_field_path_elem(dest.layout.ty, variant, i));\n-                            self.validate_mplace(field, path, seen, todo)?;\n-                            path.truncate(path_len);\n+                if dest.layout.ty.builtin_deref(true).is_some() {\n+                    // This is a fat pointer.\n+                    let ptr = match self.ref_to_mplace(self.read_value(dest.into())?) {\n+                        Ok(ptr) => ptr,\n+                        Err(ReadPointerAsBytes) =>\n+                            return validation_failure!(\"fat pointer length is not a valid integer\", path),\n+                        Err(ReadBytesAsPointer) =>\n+                            return validation_failure!(\"fat pointer vtable is not a valid pointer\", path),\n+                        Err(err) => return Err(err),\n+                    };\n+                    let unpacked_ptr = self.unpack_unsized_mplace(ptr)?;\n+                    // for safe ptrs, recursively check it\n+                    if !dest.layout.ty.is_unsafe_ptr() {\n+                        if seen.insert(unpacked_ptr) {\n+                            todo.push((unpacked_ptr, path_clone_and_deref(path)));\n                         }\n-                        // FIXME: For a TyStr, check that this is valid UTF-8.\n-                    },\n+                    }\n+                } else {\n+                    // Not a pointer, perform regular aggregate handling below\n+                    for i in 0..offsets.len() {\n+                        let field = self.mplace_field(dest, i as u64)?;\n+                        path.push(self.aggregate_field_path_elem(dest.layout.ty, variant, i));\n+                        self.validate_mplace(field, path, seen, todo)?;\n+                        path.truncate(path_len);\n+                    }\n+                    // FIXME: For a TyStr, check that this is valid UTF-8.\n                 }\n             }\n         }"}, {"sha": "ffa824fc6af47ac2a0fc236ccde2d2cecc13d6b0", "filename": "src/test/ui/union-ub-fat-ptr.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/899bc14cc08777bd6c5738c5697082b1cfbc7755/src%2Ftest%2Fui%2Funion-ub-fat-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/899bc14cc08777bd6c5738c5697082b1cfbc7755/src%2Ftest%2Fui%2Funion-ub-fat-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion-ub-fat-ptr.rs?ref=899bc14cc08777bd6c5738c5697082b1cfbc7755", "patch": "@@ -37,6 +37,7 @@ union SliceTransmute {\n     bad: BadSliceRepr,\n     slice: &'static [u8],\n     str: &'static str,\n+    my_str: &'static Str,\n }\n \n #[repr(C)]\n@@ -70,6 +71,8 @@ union DynTransmute {\n trait Trait {}\n impl Trait for bool {}\n \n+struct Str(str);\n+\n // OK\n const A: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 1 } }.str};\n // bad str\n@@ -78,14 +81,17 @@ const B: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 }\n // bad str\n const C: &str = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.str};\n //~^ ERROR this constant likely exhibits undefined behavior\n+// bad str in Str\n+const C2: &Str = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.my_str};\n+//~^ ERROR this constant likely exhibits undefined behavior\n \n // OK\n const A2: &[u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 1 } }.slice};\n // bad slice\n const B2: &[u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.slice};\n //~^ ERROR this constant likely exhibits undefined behavior\n // bad slice\n-const C2: &[u8] = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.slice};\n+const C3: &[u8] = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.slice};\n //~^ ERROR this constant likely exhibits undefined behavior\n \n // bad trait object"}, {"sha": "85a514ea99ea01fa4908439b0ca1931d6f33d94a", "filename": "src/test/ui/union-ub-fat-ptr.stderr", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/899bc14cc08777bd6c5738c5697082b1cfbc7755/src%2Ftest%2Fui%2Funion-ub-fat-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/899bc14cc08777bd6c5738c5697082b1cfbc7755/src%2Ftest%2Fui%2Funion-ub-fat-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion-ub-fat-ptr.stderr?ref=899bc14cc08777bd6c5738c5697082b1cfbc7755", "patch": "@@ -1,75 +1,83 @@\n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:76:1\n+  --> $DIR/union-ub-fat-ptr.rs:79:1\n    |\n LL | const B: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.str};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access at offset N, outside bounds of allocation N which has size N\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:79:1\n+  --> $DIR/union-ub-fat-ptr.rs:82:1\n    |\n LL | const C: &str = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.str};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered length is not a valid integer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered fat pointer length is not a valid integer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/union-ub-fat-ptr.rs:85:1\n    |\n+LL | const C2: &Str = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.my_str};\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered fat pointer length is not a valid integer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/union-ub-fat-ptr.rs:91:1\n+   |\n LL | const B2: &[u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.slice};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access at offset N, outside bounds of allocation N which has size N\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:88:1\n+  --> $DIR/union-ub-fat-ptr.rs:94:1\n    |\n-LL | const C2: &[u8] = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.slice};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered length is not a valid integer\n+LL | const C3: &[u8] = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.slice};\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered fat pointer length is not a valid integer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:92:1\n+  --> $DIR/union-ub-fat-ptr.rs:98:1\n    |\n LL | const D: &Trait = unsafe { DynTransmute { repr: DynRepr { ptr: &92, vtable: &3 } }.rust};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ tried to access memory with alignment N, but alignment N is required\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:95:1\n+  --> $DIR/union-ub-fat-ptr.rs:101:1\n    |\n LL | const E: &Trait = unsafe { DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.rust};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ a memory access tried to interpret some bytes as a pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:98:1\n+  --> $DIR/union-ub-fat-ptr.rs:104:1\n    |\n LL | const F: &Trait = unsafe { DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 3 } }.rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered vtable address is not a pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered fat pointer length is not a valid integer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:102:1\n+  --> $DIR/union-ub-fat-ptr.rs:108:1\n    |\n LL | const G: &Trait = &unsafe { BoolTransmute { val: 3 }.bl };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>, but expected something in the range 0..=1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:106:1\n+  --> $DIR/union-ub-fat-ptr.rs:112:1\n    |\n LL | const H: &[bool] = &[unsafe { BoolTransmute { val: 3 }.bl }];\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>[0], but expected something in the range 0..=1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 10 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}]}