{"sha": "47c50560146fb8deebb3410765f66be4dc87cf81", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3YzUwNTYwMTQ2ZmI4ZGVlYmIzNDEwNzY1ZjY2YmU0ZGM4N2NmODE=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2021-07-24T14:08:11Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2021-08-06T12:22:01Z"}, "message": "Fix highlighting for union keyword", "tree": {"sha": "15ac9b17eabba1377e8b2267356cf493ac335bcc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15ac9b17eabba1377e8b2267356cf493ac335bcc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47c50560146fb8deebb3410765f66be4dc87cf81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47c50560146fb8deebb3410765f66be4dc87cf81", "html_url": "https://github.com/rust-lang/rust/commit/47c50560146fb8deebb3410765f66be4dc87cf81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47c50560146fb8deebb3410765f66be4dc87cf81/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f94abcda6884893d4723304102089198caa0839", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f94abcda6884893d4723304102089198caa0839", "html_url": "https://github.com/rust-lang/rust/commit/1f94abcda6884893d4723304102089198caa0839"}], "stats": {"total": 70, "additions": 65, "deletions": 5}, "files": [{"sha": "930bdf6d3fa2fe7a15bd0bbdc1f1406e33bcc296", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 65, "deletions": 5, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/47c50560146fb8deebb3410765f66be4dc87cf81/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c50560146fb8deebb3410765f66be4dc87cf81/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=47c50560146fb8deebb3410765f66be4dc87cf81", "patch": "@@ -8,8 +8,8 @@\n use crate::html::escape::Escape;\n use crate::html::render::Context;\n \n+use std::collections::VecDeque;\n use std::fmt::{Display, Write};\n-use std::iter::Peekable;\n \n use rustc_lexer::{LiteralKind, TokenKind};\n use rustc_span::edition::Edition;\n@@ -199,10 +199,57 @@ fn get_real_ident_class(text: &str, edition: Edition, allow_path_keywords: bool)\n     })\n }\n \n+/// This iterator comes from the same idea than \"Peekable\" except that it allows to \"peek\" more than\n+/// just the next item by using `peek_next`. The `peek` method always returns the next item after\n+/// the current one whereas `peek_next` will return the next item after the last one peeked.\n+///\n+/// You can use both `peek` and `peek_next` at the same time without problem.\n+struct PeekIter<'a> {\n+    stored: VecDeque<(TokenKind, &'a str)>,\n+    /// This position is reinitialized when using `next`. It is used in `peek_next`.\n+    peek_pos: usize,\n+    iter: TokenIter<'a>,\n+}\n+\n+impl PeekIter<'a> {\n+    fn new(iter: TokenIter<'a>) -> Self {\n+        Self { stored: VecDeque::new(), peek_pos: 0, iter }\n+    }\n+    /// Returns the next item after the current one. It doesn't interfer with `peek_next` output.\n+    fn peek(&mut self) -> Option<&(TokenKind, &'a str)> {\n+        if self.stored.is_empty() {\n+            if let Some(next) = self.iter.next() {\n+                self.stored.push_back(next);\n+            }\n+        }\n+        self.stored.front()\n+    }\n+    /// Returns the next item after the last one peeked. It doesn't interfer with `peek` output.\n+    fn peek_next(&mut self) -> Option<&(TokenKind, &'a str)> {\n+        self.peek_pos += 1;\n+        if self.peek_pos - 1 < self.stored.len() {\n+            self.stored.get(self.peek_pos - 1)\n+        } else if let Some(next) = self.iter.next() {\n+            self.stored.push_back(next);\n+            self.stored.back()\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl Iterator for PeekIter<'a> {\n+    type Item = (TokenKind, &'a str);\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.peek_pos = 0;\n+        if let Some(first) = self.stored.pop_front() { Some(first) } else { self.iter.next() }\n+    }\n+}\n+\n /// Processes program tokens, classifying strings of text by highlighting\n /// category (`Class`).\n struct Classifier<'a> {\n-    tokens: Peekable<TokenIter<'a>>,\n+    tokens: PeekIter<'a>,\n     in_attribute: bool,\n     in_macro: bool,\n     in_macro_nonterminal: bool,\n@@ -216,7 +263,7 @@ impl<'a> Classifier<'a> {\n     /// Takes as argument the source code to HTML-ify, the rust edition to use and the source code\n     /// file span which will be used later on by the `span_correspondance_map`.\n     fn new(src: &str, edition: Edition, file_span: Span) -> Classifier<'_> {\n-        let tokens = TokenIter { src }.peekable();\n+        let tokens = PeekIter::new(TokenIter { src });\n         Classifier {\n             tokens,\n             in_attribute: false,\n@@ -367,7 +414,7 @@ impl<'a> Classifier<'a> {\n             // Assume that '&' or '*' is the reference or dereference operator\n             // or a reference or pointer type. Unless, of course, it looks like\n             // a logical and or a multiplication operator: `&&` or `* `.\n-            TokenKind::Star => match lookahead {\n+            TokenKind::Star => match self.peek() {\n                 Some(TokenKind::Whitespace) => Class::Op,\n                 _ => Class::RefKeyWord,\n             },\n@@ -478,6 +525,9 @@ impl<'a> Classifier<'a> {\n                 None => match text {\n                     \"Option\" | \"Result\" => Class::PreludeTy,\n                     \"Some\" | \"None\" | \"Ok\" | \"Err\" => Class::PreludeVal,\n+                    // \"union\" is a weak keyword and is only considered as a keyword when declaring\n+                    // a union type.\n+                    \"union\" if self.check_if_is_union_keyword() => Class::KeyWord,\n                     _ if self.in_macro_nonterminal => {\n                         self.in_macro_nonterminal = false;\n                         Class::MacroNonTerminal\n@@ -498,7 +548,17 @@ impl<'a> Classifier<'a> {\n     }\n \n     fn peek(&mut self) -> Option<TokenKind> {\n-        self.tokens.peek().map(|(toke_kind, _text)| *toke_kind)\n+        self.tokens.peek().map(|(token_kind, _text)| *token_kind)\n+    }\n+\n+    fn check_if_is_union_keyword(&mut self) -> bool {\n+        while let Some(kind) = self.tokens.peek_next().map(|(token_kind, _text)| token_kind) {\n+            if *kind == TokenKind::Whitespace {\n+                continue;\n+            }\n+            return *kind == TokenKind::Ident;\n+        }\n+        false\n     }\n }\n "}]}