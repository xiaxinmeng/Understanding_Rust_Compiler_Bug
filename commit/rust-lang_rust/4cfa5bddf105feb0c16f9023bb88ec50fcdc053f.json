{"sha": "4cfa5bddf105feb0c16f9023bb88ec50fcdc053f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjZmE1YmRkZjEwNWZlYjBjMTZmOTAyM2JiODhlYzUwZmNkYzA1M2Y=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-10-22T18:57:11Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-11-12T09:09:59Z"}, "message": "BTreeMap: avoid aliasing while handling underfull nodes", "tree": {"sha": "3dabcd3df50462d72022a6e6081fe1d98e438612", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3dabcd3df50462d72022a6e6081fe1d98e438612"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4cfa5bddf105feb0c16f9023bb88ec50fcdc053f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4cfa5bddf105feb0c16f9023bb88ec50fcdc053f", "html_url": "https://github.com/rust-lang/rust/commit/4cfa5bddf105feb0c16f9023bb88ec50fcdc053f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4cfa5bddf105feb0c16f9023bb88ec50fcdc053f/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55794e43960ad3647e78ea5b0cb5ad0c5c0596a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/55794e43960ad3647e78ea5b0cb5ad0c5c0596a8", "html_url": "https://github.com/rust-lang/rust/commit/55794e43960ad3647e78ea5b0cb5ad0c5c0596a8"}], "stats": {"total": 523, "additions": 320, "deletions": 203}, "files": [{"sha": "a4253a732c30f1404b91e3fe7f238dc813d3d1ec", "filename": "library/alloc/src/collections/btree/append.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4cfa5bddf105feb0c16f9023bb88ec50fcdc053f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cfa5bddf105feb0c16f9023bb88ec50fcdc053f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs?ref=4cfa5bddf105feb0c16f9023bb88ec50fcdc053f", "patch": "@@ -89,20 +89,15 @@ impl<K, V> Root<K, V> {\n         let mut cur_node = self.node_as_mut();\n         while let Internal(internal) = cur_node.force() {\n             // Check if right-most child is underfull.\n-            let mut last_edge = internal.last_edge();\n-            let right_child_len = last_edge.reborrow().descend().len();\n+            let mut last_kv = internal.last_kv().consider_for_balancing();\n+            let right_child_len = last_kv.right_child_len();\n             if right_child_len < MIN_LEN {\n                 // We need to steal.\n-                let mut last_kv = match last_edge.left_kv() {\n-                    Ok(left) => left,\n-                    Err(_) => unreachable!(),\n-                };\n                 last_kv.bulk_steal_left(MIN_LEN - right_child_len);\n-                last_edge = last_kv.right_edge();\n             }\n \n             // Go further down.\n-            cur_node = last_edge.descend();\n+            cur_node = last_kv.into_right_child();\n         }\n     }\n }"}, {"sha": "e1363d1ae1f6b4d799f41f52327f4e1a9ea20d77", "filename": "library/alloc/src/collections/btree/mem.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4cfa5bddf105feb0c16f9023bb88ec50fcdc053f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cfa5bddf105feb0c16f9023bb88ec50fcdc053f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmem.rs?ref=4cfa5bddf105feb0c16f9023bb88ec50fcdc053f", "patch": "@@ -6,6 +6,7 @@ use core::ptr;\n /// relevant function.\n ///\n /// If a panic occurs in the `change` closure, the entire process will be aborted.\n+#[allow(dead_code)] // keep as illustration and for future use\n #[inline]\n pub fn take_mut<T>(v: &mut T, change: impl FnOnce(T) -> T) {\n     replace(v, |value| (change(value), ()))"}, {"sha": "ef6f888693fc8285d489322978205a76efc6a449", "filename": "library/alloc/src/collections/btree/navigate.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4cfa5bddf105feb0c16f9023bb88ec50fcdc053f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cfa5bddf105feb0c16f9023bb88ec50fcdc053f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=4cfa5bddf105feb0c16f9023bb88ec50fcdc053f", "patch": "@@ -362,20 +362,6 @@ impl<'a, K, V> Handle<NodeRef<marker::ValMut<'a>, K, V, marker::Leaf>, marker::E\n     }\n }\n \n-impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n-    /// Moves the leaf edge handle to the next leaf edge.\n-    ///\n-    /// # Safety\n-    /// There must be another KV in the direction travelled.\n-    pub unsafe fn move_next_unchecked(&mut self) {\n-        super::mem::take_mut(self, |leaf_edge| {\n-            let kv = leaf_edge.next_kv();\n-            let kv = unsafe { unwrap_unchecked(kv.ok()) };\n-            kv.next_leaf_edge()\n-        })\n-    }\n-}\n-\n impl<K, V> Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge> {\n     /// Moves the leaf edge handle to the next leaf edge and returns the key and value\n     /// in between, deallocating any node left behind while leaving the corresponding"}, {"sha": "5feab9201382ef0156eb8a4edef901100c0ba674", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 181, "deletions": 66, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/4cfa5bddf105feb0c16f9023bb88ec50fcdc053f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cfa5bddf105feb0c16f9023bb88ec50fcdc053f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=4cfa5bddf105feb0c16f9023bb88ec50fcdc053f", "patch": "@@ -498,6 +498,12 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n }\n \n impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n+    /// Unsafely asserts to the compiler the static information that this node is a `Leaf`.\n+    unsafe fn cast_to_leaf_unchecked(self) -> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n+        debug_assert!(self.height == 0);\n+        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n+    }\n+\n     /// Unsafely asserts to the compiler the static information that this node is an `Internal`.\n     unsafe fn cast_to_internal_unchecked(self) -> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         debug_assert!(self.height > 0);\n@@ -922,6 +928,14 @@ impl<BorrowType, K, V, NodeType, HandleType>\n }\n \n impl<'a, K, V, NodeType, HandleType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, HandleType> {\n+    /// Unsafely asserts to the compiler the static information that the handle's node is a `Leaf`.\n+    pub unsafe fn cast_to_leaf_unchecked(\n+        self,\n+    ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, HandleType> {\n+        let node = unsafe { self.node.cast_to_leaf_unchecked() };\n+        Handle { node, idx: self.idx, _marker: PhantomData }\n+    }\n+\n     /// Temporarily takes out another, mutable handle on the same location. Beware, as\n     /// this method is very dangerous, doubly so since it may not immediately appear\n     /// dangerous.\n@@ -961,24 +975,24 @@ impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, mar\n     }\n }\n \n-enum InsertionPlace {\n-    Left(usize),\n-    Right(usize),\n+pub enum LeftOrRight<T> {\n+    Left(T),\n+    Right(T),\n }\n \n /// Given an edge index where we want to insert into a node filled to capacity,\n /// computes a sensible KV index of a split point and where to perform the insertion.\n /// The goal of the split point is for its key and value to end up in a parent node;\n /// the keys, values and edges to the left of the split point become the left child;\n /// the keys, values and edges to the right of the split point become the right child.\n-fn splitpoint(edge_idx: usize) -> (usize, InsertionPlace) {\n+fn splitpoint(edge_idx: usize) -> (usize, LeftOrRight<usize>) {\n     debug_assert!(edge_idx <= CAPACITY);\n     // Rust issue #74834 tries to explain these symmetric rules.\n     match edge_idx {\n-        0..EDGE_IDX_LEFT_OF_CENTER => (KV_IDX_CENTER - 1, InsertionPlace::Left(edge_idx)),\n-        EDGE_IDX_LEFT_OF_CENTER => (KV_IDX_CENTER, InsertionPlace::Left(edge_idx)),\n-        EDGE_IDX_RIGHT_OF_CENTER => (KV_IDX_CENTER, InsertionPlace::Right(0)),\n-        _ => (KV_IDX_CENTER + 1, InsertionPlace::Right(edge_idx - (KV_IDX_CENTER + 1 + 1))),\n+        0..EDGE_IDX_LEFT_OF_CENTER => (KV_IDX_CENTER - 1, LeftOrRight::Left(edge_idx)),\n+        EDGE_IDX_LEFT_OF_CENTER => (KV_IDX_CENTER, LeftOrRight::Left(edge_idx)),\n+        EDGE_IDX_RIGHT_OF_CENTER => (KV_IDX_CENTER, LeftOrRight::Right(0)),\n+        _ => (KV_IDX_CENTER + 1, LeftOrRight::Right(edge_idx - (KV_IDX_CENTER + 1 + 1))),\n     }\n }\n \n@@ -1016,10 +1030,10 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n             let middle = unsafe { Handle::new_kv(self.node, middle_kv_idx) };\n             let (mut left, k, v, mut right) = middle.split();\n             let mut insertion_edge = match insertion {\n-                InsertionPlace::Left(insert_idx) => unsafe {\n+                LeftOrRight::Left(insert_idx) => unsafe {\n                     Handle::new_edge(left.reborrow_mut(), insert_idx)\n                 },\n-                InsertionPlace::Right(insert_idx) => unsafe {\n+                LeftOrRight::Right(insert_idx) => unsafe {\n                     Handle::new_edge(right.leaf_node_as_mut(), insert_idx)\n                 },\n             };\n@@ -1080,10 +1094,10 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n             let middle = unsafe { Handle::new_kv(self.node, middle_kv_idx) };\n             let (mut left, k, v, mut right) = middle.split();\n             let mut insertion_edge = match insertion {\n-                InsertionPlace::Left(insert_idx) => unsafe {\n+                LeftOrRight::Left(insert_idx) => unsafe {\n                     Handle::new_edge(left.reborrow_mut(), insert_idx)\n                 },\n-                InsertionPlace::Right(insert_idx) => unsafe {\n+                LeftOrRight::Right(insert_idx) => unsafe {\n                     Handle::new_edge(right.internal_node_as_mut(), insert_idx)\n                 },\n             };\n@@ -1250,18 +1264,6 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n     }\n }\n \n-impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::KV> {\n-    /// Returns `true` if it is valid to call `.merge()`, i.e., whether there is enough room in\n-    /// a node to hold the combination of the nodes to the left and right of this handle along\n-    /// with the key/value pair at this handle.\n-    pub fn can_merge(&self) -> bool {\n-        (self.reborrow().left_edge().descend().len()\n-            + self.reborrow().right_edge().descend().len()\n-            + 1)\n-            <= CAPACITY\n-    }\n-}\n-\n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::KV> {\n     /// Splits the underlying node into three parts:\n     ///\n@@ -1290,52 +1292,148 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n             (self.node, k, v, right)\n         }\n     }\n+}\n+\n+/// Represents a session for evaluating and performing a balancing operation\n+/// around an internal key/value pair.\n+pub struct BalancingContext<'a, K, V> {\n+    parent: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::KV>,\n+    left_child: NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>,\n+    right_child: NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>,\n+}\n+\n+impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::KV> {\n+    pub fn consider_for_balancing(self) -> BalancingContext<'a, K, V> {\n+        let self1 = unsafe { ptr::read(&self) };\n+        let self2 = unsafe { ptr::read(&self) };\n+        BalancingContext {\n+            parent: self,\n+            left_child: self1.left_edge().descend(),\n+            right_child: self2.right_edge().descend(),\n+        }\n+    }\n+}\n \n-    /// Combines the node immediately to the left of this handle, the key/value pair pointed\n-    /// to by this handle, and the node immediately to the right of this handle into one new\n-    /// child of the underlying node, returning an edge referencing that new child.\n+impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n+    /// Chooses a balancing context involving the node as a child, thus between\n+    /// the KV immediately to the left or to the right in the parent node.\n+    /// Returns an `Err` if there is no parent.\n     ///\n-    /// Panics unless this edge `.can_merge()`.\n+    /// This method optimizes for a node that has fewer elements than its left\n+    /// and right siblings, if they exist, by preferring the left parent KV.\n+    /// Merging with the left sibling is faster, since we only need to move\n+    /// the node's N elements, instead of shifting them to the right and moving\n+    /// more than N elements in front. Stealing from the left sibling is also\n+    /// typically faster, since we only need to shift the node's N elements to\n+    /// the right, instead of shifting at least N of the sibling's elements to\n+    /// the left.\n+    pub fn choose_parent_kv(self) -> Result<LeftOrRight<BalancingContext<'a, K, V>>, Self> {\n+        match unsafe { ptr::read(&self) }.ascend() {\n+            Ok(parent) => match parent.left_kv() {\n+                Ok(left_parent_kv) => Ok(LeftOrRight::Left(BalancingContext {\n+                    parent: unsafe { ptr::read(&left_parent_kv) },\n+                    left_child: left_parent_kv.left_edge().descend(),\n+                    right_child: self,\n+                })),\n+                Err(parent) => match parent.right_kv() {\n+                    Ok(right_parent_kv) => Ok(LeftOrRight::Right(BalancingContext {\n+                        parent: unsafe { ptr::read(&right_parent_kv) },\n+                        left_child: self,\n+                        right_child: right_parent_kv.right_edge().descend(),\n+                    })),\n+                    Err(_) => unreachable!(\"empty non-root node\"),\n+                },\n+            },\n+            Err(root) => Err(root),\n+        }\n+    }\n+}\n+\n+impl<'a, K, V> BalancingContext<'a, K, V> {\n+    pub fn left_child_len(&self) -> usize {\n+        self.left_child.len()\n+    }\n+\n+    pub fn right_child_len(&self) -> usize {\n+        self.right_child.len()\n+    }\n+\n+    pub fn into_left_child(self) -> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n+        self.left_child\n+    }\n+\n+    pub fn into_right_child(self) -> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n+        self.right_child\n+    }\n+\n+    /// Returns `true` if it is valid to call `.merge()` in the balancing context,\n+    /// i.e., whether there is enough room in a node to hold the combination of\n+    /// both adjacent child nodes, along with the key/value pair in the parent.\n+    pub fn can_merge(&self) -> bool {\n+        self.left_child.len() + 1 + self.right_child.len() <= CAPACITY\n+    }\n+}\n+\n+impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n+    /// Merges the parent's key/value pair and both adjacent child nodes into\n+    /// the left node and returns an edge handle in that expanded left node.\n+    /// If `track_edge_idx` is given some value, the returned edge corresponds\n+    /// to where the edge in that child node ended up,\n+    ///\n+    /// Panics unless we `.can_merge()`.\n     pub fn merge(\n         mut self,\n-    ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge> {\n-        let self1 = unsafe { ptr::read(&self) };\n-        let self2 = unsafe { ptr::read(&self) };\n-        let mut left_node = self1.left_edge().descend();\n+        track_edge_idx: Option<LeftOrRight<usize>>,\n+    ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::Edge> {\n+        let mut left_node = self.left_child;\n         let left_len = left_node.len();\n-        let right_node = self2.right_edge().descend();\n+        let right_node = self.right_child;\n         let right_len = right_node.len();\n \n         assert!(left_len + right_len < CAPACITY);\n+        assert!(match track_edge_idx {\n+            None => true,\n+            Some(LeftOrRight::Left(idx)) => idx <= left_len,\n+            Some(LeftOrRight::Right(idx)) => idx <= right_len,\n+        });\n \n         unsafe {\n             *left_node.reborrow_mut().into_len_mut() += right_len as u16 + 1;\n \n-            let parent_key = slice_remove(self.node.reborrow_mut().into_key_area_slice(), self.idx);\n+            let parent_key = slice_remove(\n+                self.parent.node.reborrow_mut().into_key_area_slice(),\n+                self.parent.idx,\n+            );\n             left_node.reborrow_mut().into_key_area_mut_at(left_len).write(parent_key);\n             ptr::copy_nonoverlapping(\n                 right_node.reborrow().key_area().as_ptr(),\n                 left_node.reborrow_mut().into_key_area_slice().as_mut_ptr().add(left_len + 1),\n                 right_len,\n             );\n \n-            let parent_val = slice_remove(self.node.reborrow_mut().into_val_area_slice(), self.idx);\n+            let parent_val = slice_remove(\n+                self.parent.node.reborrow_mut().into_val_area_slice(),\n+                self.parent.idx,\n+            );\n             left_node.reborrow_mut().into_val_area_mut_at(left_len).write(parent_val);\n             ptr::copy_nonoverlapping(\n                 right_node.reborrow().val_area().as_ptr(),\n                 left_node.reborrow_mut().into_val_area_slice().as_mut_ptr().add(left_len + 1),\n                 right_len,\n             );\n \n-            slice_remove(&mut self.node.reborrow_mut().into_edge_area_slice(), self.idx + 1);\n-            let self_len = self.node.len();\n-            self.node.correct_childrens_parent_links(self.idx + 1..self_len);\n-            *self.node.reborrow_mut().into_len_mut() -= 1;\n+            slice_remove(\n+                &mut self.parent.node.reborrow_mut().into_edge_area_slice(),\n+                self.parent.idx + 1,\n+            );\n+            let parent_old_len = self.parent.node.len();\n+            self.parent.node.correct_childrens_parent_links(self.parent.idx + 1..parent_old_len);\n+            *self.parent.node.reborrow_mut().into_len_mut() -= 1;\n \n-            if self.node.height > 1 {\n+            if self.parent.node.height > 1 {\n                 // SAFETY: the height of the nodes being merged is one below the height\n                 // of the node of this edge, thus above zero, so they are internal.\n-                let mut left_node = left_node.cast_to_internal_unchecked();\n+                let mut left_node = left_node.reborrow_mut().cast_to_internal_unchecked();\n                 let right_node = right_node.cast_to_internal_unchecked();\n                 ptr::copy_nonoverlapping(\n                     right_node.reborrow().edge_area().as_ptr(),\n@@ -1350,50 +1448,67 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n                 Global.dealloc(right_node.node.cast(), Layout::new::<LeafNode<K, V>>());\n             }\n \n-            Handle::new_edge(self.node, self.idx)\n+            let new_idx = match track_edge_idx {\n+                None => 0,\n+                Some(LeftOrRight::Left(idx)) => idx,\n+                Some(LeftOrRight::Right(idx)) => left_len + 1 + idx,\n+            };\n+            Handle::new_edge(left_node, new_idx)\n         }\n     }\n \n-    /// This removes a key/value pair from the left child and places it in the key/value storage\n-    /// pointed to by this handle while pushing the old key/value pair of this handle into the right\n-    /// child.\n-    pub fn steal_left(&mut self) {\n+    /// Removes a key/value pair from the left child and places it in the key/value storage\n+    /// of the parent, while pushing the old parent key/value pair into the right child.\n+    /// Returns a handle to the edge in the right child corresponding to where the original\n+    /// edge specified by `track_right_edge_idx` ended up.\n+    pub fn steal_left(\n+        mut self,\n+        track_right_edge_idx: usize,\n+    ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::Edge> {\n         unsafe {\n-            let (k, v, edge) = self.reborrow_mut().left_edge().descend().pop();\n+            let (k, v, edge) = self.left_child.pop();\n \n-            let k = mem::replace(self.kv_mut().0, k);\n-            let v = mem::replace(self.kv_mut().1, v);\n+            let k = mem::replace(self.parent.kv_mut().0, k);\n+            let v = mem::replace(self.parent.kv_mut().1, v);\n \n-            match self.reborrow_mut().right_edge().descend().force() {\n+            match self.right_child.reborrow_mut().force() {\n                 ForceResult::Leaf(mut leaf) => leaf.push_front(k, v),\n                 ForceResult::Internal(mut internal) => internal.push_front(k, v, edge.unwrap()),\n             }\n+\n+            Handle::new_edge(self.right_child, 1 + track_right_edge_idx)\n         }\n     }\n \n-    /// This removes a key/value pair from the right child and places it in the key/value storage\n-    /// pointed to by this handle while pushing the old key/value pair of this handle into the left\n-    /// child.\n-    pub fn steal_right(&mut self) {\n+    /// Removes a key/value pair from the right child and places it in the key/value storage\n+    /// of the parent, while pushing the old parent key/value pair onto the left child.\n+    /// Returns a handle to the edge in the left child specified by `track_left_edge_idx`,\n+    /// which didn't move.\n+    pub fn steal_right(\n+        mut self,\n+        track_left_edge_idx: usize,\n+    ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::Edge> {\n         unsafe {\n-            let (k, v, edge) = self.reborrow_mut().right_edge().descend().pop_front();\n+            let (k, v, edge) = self.right_child.pop_front();\n \n-            let k = mem::replace(self.kv_mut().0, k);\n-            let v = mem::replace(self.kv_mut().1, v);\n+            let k = mem::replace(self.parent.kv_mut().0, k);\n+            let v = mem::replace(self.parent.kv_mut().1, v);\n \n-            match self.reborrow_mut().left_edge().descend().force() {\n+            match self.left_child.reborrow_mut().force() {\n                 ForceResult::Leaf(mut leaf) => leaf.push(k, v),\n                 ForceResult::Internal(mut internal) => internal.push(k, v, edge.unwrap()),\n             }\n+\n+            Handle::new_edge(self.left_child, track_left_edge_idx)\n         }\n     }\n \n     /// This does stealing similar to `steal_left` but steals multiple elements at once.\n     pub fn bulk_steal_left(&mut self, count: usize) {\n         unsafe {\n-            let mut left_node = ptr::read(self).left_edge().descend();\n+            let left_node = &mut self.left_child;\n             let left_len = left_node.len();\n-            let mut right_node = ptr::read(self).right_edge().descend();\n+            let right_node = &mut self.right_child;\n             let right_len = right_node.len();\n \n             // Make sure that we may steal safely.\n@@ -1407,7 +1522,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n                 let left_kv = left_node.reborrow_mut().into_kv_pointers_mut();\n                 let right_kv = right_node.reborrow_mut().into_kv_pointers_mut();\n                 let parent_kv = {\n-                    let kv = self.kv_mut();\n+                    let kv = self.parent.kv_mut();\n                     (kv.0 as *mut K, kv.1 as *mut V)\n                 };\n \n@@ -1428,7 +1543,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n             *left_node.reborrow_mut().into_len_mut() -= count as u16;\n             *right_node.reborrow_mut().into_len_mut() += count as u16;\n \n-            match (left_node.force(), right_node.force()) {\n+            match (left_node.reborrow_mut().force(), right_node.reborrow_mut().force()) {\n                 (ForceResult::Internal(left), ForceResult::Internal(mut right)) => {\n                     // Make room for stolen edges.\n                     let left = left.reborrow();\n@@ -1447,9 +1562,9 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     /// The symmetric clone of `bulk_steal_left`.\n     pub fn bulk_steal_right(&mut self, count: usize) {\n         unsafe {\n-            let mut left_node = ptr::read(self).left_edge().descend();\n+            let left_node = &mut self.left_child;\n             let left_len = left_node.len();\n-            let mut right_node = ptr::read(self).right_edge().descend();\n+            let right_node = &mut self.right_child;\n             let right_len = right_node.len();\n \n             // Make sure that we may steal safely.\n@@ -1463,7 +1578,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n                 let left_kv = left_node.reborrow_mut().into_kv_pointers_mut();\n                 let right_kv = right_node.reborrow_mut().into_kv_pointers_mut();\n                 let parent_kv = {\n-                    let kv = self.kv_mut();\n+                    let kv = self.parent.kv_mut();\n                     (kv.0 as *mut K, kv.1 as *mut V)\n                 };\n \n@@ -1484,7 +1599,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n             *left_node.reborrow_mut().into_len_mut() += count as u16;\n             *right_node.reborrow_mut().into_len_mut() -= count as u16;\n \n-            match (left_node.force(), right_node.force()) {\n+            match (left_node.reborrow_mut().force(), right_node.reborrow_mut().force()) {\n                 (ForceResult::Internal(left), ForceResult::Internal(mut right)) => {\n                     move_edges(right.reborrow(), 0, left, left_len + 1, count);\n "}, {"sha": "ac61c1df8e2e408129dfc313f982f5e10274e28d", "filename": "library/alloc/src/collections/btree/node/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4cfa5bddf105feb0c16f9023bb88ec50fcdc053f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cfa5bddf105feb0c16f9023bb88ec50fcdc053f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs?ref=4cfa5bddf105feb0c16f9023bb88ec50fcdc053f", "patch": "@@ -54,11 +54,11 @@ fn test_splitpoint() {\n         let mut left_len = middle_kv_idx;\n         let mut right_len = CAPACITY - middle_kv_idx - 1;\n         match insertion {\n-            InsertionPlace::Left(edge_idx) => {\n+            LeftOrRight::Left(edge_idx) => {\n                 assert!(edge_idx <= left_len);\n                 left_len += 1;\n             }\n-            InsertionPlace::Right(edge_idx) => {\n+            LeftOrRight::Right(edge_idx) => {\n                 assert!(edge_idx <= right_len);\n                 right_len += 1;\n             }"}, {"sha": "c4253d4221b3b9ebdc6cc849d1fac05c456098fc", "filename": "library/alloc/src/collections/btree/remove.rs", "status": "modified", "additions": 125, "deletions": 105, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/4cfa5bddf105feb0c16f9023bb88ec50fcdc053f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cfa5bddf105feb0c16f9023bb88ec50fcdc053f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs?ref=4cfa5bddf105feb0c16f9023bb88ec50fcdc053f", "patch": "@@ -1,133 +1,153 @@\n use super::map::MIN_LEN;\n-use super::node::{marker, ForceResult, Handle, NodeRef};\n+use super::node::{marker, ForceResult::*, Handle, LeftOrRight::*, NodeRef};\n use super::unwrap_unchecked;\n use core::mem;\n-use core::ptr;\n \n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n-    /// Removes a key/value-pair from the map, and returns that pair, as well as\n-    /// the leaf edge corresponding to that former pair.\n+    /// Removes a key/value-pair from the tree, and returns that pair, as well as\n+    /// the leaf edge corresponding to that former pair. It's possible this empties\n+    /// a root node that is internal, which the caller should pop from the map\n+    /// holding the tree. The caller should also decrement the map's length.\n     pub fn remove_kv_tracking<F: FnOnce()>(\n         self,\n         handle_emptied_internal_root: F,\n     ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n-        let (old_kv, mut pos, was_internal) = match self.force() {\n-            ForceResult::Leaf(leaf) => {\n-                let (old_kv, pos) = leaf.remove();\n-                (old_kv, pos, false)\n-            }\n-            ForceResult::Internal(mut internal) => {\n-                // Replace the location freed in the internal node with an\n-                // adjacent KV, and remove that adjacent KV from its leaf.\n-                // Always choose the adjacent KV on the left side because\n-                // it is typically faster to pop an element from the end\n-                // of the KV arrays without needing to shift other elements.\n-\n-                let key_loc = internal.kv_mut().0 as *mut K;\n-                let val_loc = internal.kv_mut().1 as *mut V;\n-\n-                let to_remove = internal.left_edge().descend().last_leaf_edge().left_kv().ok();\n-                let to_remove = unsafe { unwrap_unchecked(to_remove) };\n-\n-                let (kv, pos) = to_remove.remove();\n-\n-                let old_key = unsafe { mem::replace(&mut *key_loc, kv.0) };\n-                let old_val = unsafe { mem::replace(&mut *val_loc, kv.1) };\n-\n-                ((old_key, old_val), pos, true)\n-            }\n-        };\n-\n-        // Handle underflow\n-        let mut cur_node = unsafe { ptr::read(&pos).into_node().forget_type() };\n-        let mut at_leaf = true;\n-        while cur_node.len() < MIN_LEN {\n-            match handle_underfull_node(cur_node) {\n-                UnderflowResult::AtRoot => break,\n-                UnderflowResult::Merged(edge, merged_with_left, offset) => {\n-                    // If we merged with our right sibling then our tracked\n-                    // position has not changed. However if we merged with our\n-                    // left sibling then our tracked position is now dangling.\n-                    if at_leaf && merged_with_left {\n-                        let idx = pos.idx() + offset;\n-                        let node = match unsafe { ptr::read(&edge).descend().force() } {\n-                            ForceResult::Leaf(leaf) => leaf,\n-                            ForceResult::Internal(_) => unreachable!(),\n-                        };\n-                        pos = unsafe { Handle::new_edge(node, idx) };\n-                    }\n+        match self.force() {\n+            Leaf(node) => node.remove_leaf_kv(handle_emptied_internal_root),\n+            Internal(node) => node.remove_internal_kv(handle_emptied_internal_root),\n+        }\n+    }\n+}\n \n-                    let parent = edge.into_node();\n-                    if parent.len() == 0 {\n-                        // The parent that was just emptied must be the root,\n-                        // because nodes on a lower level would not have been\n-                        // left with a single child.\n-                        handle_emptied_internal_root();\n-                        break;\n+impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {\n+    fn remove_leaf_kv<F: FnOnce()>(\n+        self,\n+        handle_emptied_internal_root: F,\n+    ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n+        let (old_kv, mut pos) = self.remove();\n+        let len = pos.reborrow().into_node().len();\n+        if len < MIN_LEN {\n+            let idx = pos.idx();\n+            // We have to temporarily forget the child type, because there is no\n+            // distinct node type for the immediate parents of a leaf.\n+            let new_pos = match pos.into_node().forget_type().choose_parent_kv() {\n+                Ok(Left(left_parent_kv)) => {\n+                    debug_assert!(left_parent_kv.right_child_len() == MIN_LEN - 1);\n+                    if left_parent_kv.can_merge() {\n+                        left_parent_kv.merge(Some(Right(idx)))\n                     } else {\n-                        cur_node = parent.forget_type();\n-                        at_leaf = false;\n+                        debug_assert!(left_parent_kv.left_child_len() > MIN_LEN);\n+                        left_parent_kv.steal_left(idx)\n                     }\n                 }\n-                UnderflowResult::Stole(stole_from_left) => {\n-                    // Adjust the tracked position if we stole from a left sibling\n-                    if stole_from_left && at_leaf {\n-                        // SAFETY: This is safe since we just added an element to our node.\n-                        unsafe {\n-                            pos.move_next_unchecked();\n-                        }\n+                Ok(Right(right_parent_kv)) => {\n+                    debug_assert!(right_parent_kv.left_child_len() == MIN_LEN - 1);\n+                    if right_parent_kv.can_merge() {\n+                        right_parent_kv.merge(Some(Left(idx)))\n+                    } else {\n+                        debug_assert!(right_parent_kv.right_child_len() > MIN_LEN);\n+                        right_parent_kv.steal_right(idx)\n                     }\n-                    break;\n                 }\n-            }\n-        }\n+                Err(pos) => unsafe { Handle::new_edge(pos, idx) },\n+            };\n+            // SAFETY: `new_pos` is the leaf we started from or a sibling.\n+            pos = unsafe { new_pos.cast_to_leaf_unchecked() };\n \n-        // If we deleted from an internal node then we need to compensate for\n-        // the earlier swap and adjust the tracked position to point to the\n-        // next element.\n-        if was_internal {\n-            pos = unsafe { unwrap_unchecked(pos.next_kv().ok()).next_leaf_edge() };\n+            // Only if we merged, the parent (if any) has shrunk, but skipping\n+            // the following step does not pay off in benchmarks.\n+            //\n+            // SAFETY: We won't destroy or rearrange the leaf where `pos` is at\n+            // by handling its parent recursively; at worst we will destroy or\n+            // rearrange the parent through the grandparent, thus change the\n+            // leaf's parent pointer.\n+            if let Ok(parent) = unsafe { pos.reborrow_mut() }.into_node().ascend() {\n+                parent.into_node().handle_shrunk_node_recursively(handle_emptied_internal_root);\n+            }\n         }\n-\n         (old_kv, pos)\n     }\n }\n \n-enum UnderflowResult<'a, K, V> {\n-    AtRoot,\n-    Merged(Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge>, bool, usize),\n-    Stole(bool),\n-}\n+impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::KV> {\n+    fn remove_internal_kv<F: FnOnce()>(\n+        self,\n+        handle_emptied_internal_root: F,\n+    ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n+        // Remove an adjacent KV from its leaf and then put it back in place of\n+        // the element we were asked to remove. Prefer the left adjacent KV,\n+        // for the reasons listed in `choose_parent_kv`.\n+        let left_leaf_kv = self.left_edge().descend().last_leaf_edge().left_kv();\n+        let left_leaf_kv = unsafe { unwrap_unchecked(left_leaf_kv.ok()) };\n+        let (left_kv, left_hole) = left_leaf_kv.remove_leaf_kv(handle_emptied_internal_root);\n \n-fn handle_underfull_node<'a, K: 'a, V: 'a>(\n-    node: NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>,\n-) -> UnderflowResult<'_, K, V> {\n-    let parent = match node.ascend() {\n-        Ok(parent) => parent,\n-        Err(_) => return UnderflowResult::AtRoot,\n-    };\n+        // The internal node may have been stolen from or merged. Go back right\n+        // to find where the original KV ended up.\n+        let mut internal = unsafe { unwrap_unchecked(left_hole.next_kv().ok()) };\n+        let old_key = mem::replace(internal.kv_mut().0, left_kv.0);\n+        let old_val = mem::replace(internal.kv_mut().1, left_kv.1);\n+        let pos = internal.next_leaf_edge();\n+        ((old_key, old_val), pos)\n+    }\n+}\n \n-    // Prefer the left KV if it exists. Merging with the left side is faster,\n-    // since merging happens towards the left and `node` has fewer elements.\n-    // Stealing from the left side is faster, since we can pop from the end of\n-    // the KV arrays.\n-    let (is_left, mut handle) = match parent.left_kv() {\n-        Ok(left) => (true, left),\n-        Err(parent) => {\n-            let right = unsafe { unwrap_unchecked(parent.right_kv().ok()) };\n-            (false, right)\n+impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n+    /// Stocks up a possibly underfull internal node, recursively.\n+    /// Climbs up until it reaches an ancestor that has elements to spare or the root.\n+    fn handle_shrunk_node_recursively<F: FnOnce()>(mut self, handle_emptied_internal_root: F) {\n+        loop {\n+            self = match self.len() {\n+                0 => {\n+                    // An empty node must be the root, because length is only\n+                    // reduced by one, and non-root underfull nodes are stocked up,\n+                    // so non-root nodes never have fewer than MIN_LEN - 1 elements.\n+                    debug_assert!(self.ascend().is_err());\n+                    handle_emptied_internal_root();\n+                    return;\n+                }\n+                1..MIN_LEN => {\n+                    if let Some(parent) = self.handle_underfull_node_locally() {\n+                        parent\n+                    } else {\n+                        return;\n+                    }\n+                }\n+                _ => return,\n+            }\n         }\n-    };\n+    }\n \n-    if handle.can_merge() {\n-        let offset = if is_left { handle.reborrow().left_edge().descend().len() + 1 } else { 0 };\n-        UnderflowResult::Merged(handle.merge(), is_left, offset)\n-    } else {\n-        if is_left {\n-            handle.steal_left();\n-        } else {\n-            handle.steal_right();\n+    /// Stocks up an underfull internal node, possibly at the cost of shrinking\n+    /// its parent instead, which is then returned.\n+    fn handle_underfull_node_locally(\n+        self,\n+    ) -> Option<NodeRef<marker::Mut<'a>, K, V, marker::Internal>> {\n+        match self.forget_type().choose_parent_kv() {\n+            Ok(Left(left_parent_kv)) => {\n+                debug_assert!(left_parent_kv.right_child_len() == MIN_LEN - 1);\n+                if left_parent_kv.can_merge() {\n+                    let pos = left_parent_kv.merge(None);\n+                    let parent_edge = unsafe { unwrap_unchecked(pos.into_node().ascend().ok()) };\n+                    Some(parent_edge.into_node())\n+                } else {\n+                    debug_assert!(left_parent_kv.left_child_len() > MIN_LEN);\n+                    left_parent_kv.steal_left(0);\n+                    None\n+                }\n+            }\n+            Ok(Right(right_parent_kv)) => {\n+                debug_assert!(right_parent_kv.left_child_len() == MIN_LEN - 1);\n+                if right_parent_kv.can_merge() {\n+                    let pos = right_parent_kv.merge(None);\n+                    let parent_edge = unsafe { unwrap_unchecked(pos.into_node().ascend().ok()) };\n+                    Some(parent_edge.into_node())\n+                } else {\n+                    debug_assert!(right_parent_kv.right_child_len() > MIN_LEN);\n+                    right_parent_kv.steal_right(0);\n+                    None\n+                }\n+            }\n+            Err(_) => None,\n         }\n-        UnderflowResult::Stole(is_left)\n     }\n }"}, {"sha": "cd9615a330df61c25c6f4e1a087843f24de19eac", "filename": "library/alloc/src/collections/btree/split.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4cfa5bddf105feb0c16f9023bb88ec50fcdc053f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cfa5bddf105feb0c16f9023bb88ec50fcdc053f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs?ref=4cfa5bddf105feb0c16f9023bb88ec50fcdc053f", "patch": "@@ -60,17 +60,17 @@ impl<K, V> Root<K, V> {\n             let mut cur_node = self.node_as_mut();\n \n             while let Internal(node) = cur_node.force() {\n-                let mut last_kv = node.last_kv();\n+                let mut last_kv = node.last_kv().consider_for_balancing();\n \n                 if last_kv.can_merge() {\n-                    cur_node = last_kv.merge().descend();\n+                    cur_node = last_kv.merge(None).into_node();\n                 } else {\n-                    let right_len = last_kv.reborrow().right_edge().descend().len();\n+                    let right_len = last_kv.right_child_len();\n                     // `MIN_LEN + 1` to avoid readjust if merge happens on the next level.\n                     if right_len < MIN_LEN + 1 {\n                         last_kv.bulk_steal_left(MIN_LEN + 1 - right_len);\n                     }\n-                    cur_node = last_kv.right_edge().descend();\n+                    cur_node = last_kv.into_right_child();\n                 }\n             }\n         }\n@@ -86,17 +86,17 @@ impl<K, V> Root<K, V> {\n             let mut cur_node = self.node_as_mut();\n \n             while let Internal(node) = cur_node.force() {\n-                let mut first_kv = node.first_kv();\n+                let mut first_kv = node.first_kv().consider_for_balancing();\n \n                 if first_kv.can_merge() {\n-                    cur_node = first_kv.merge().descend();\n+                    cur_node = first_kv.merge(None).into_node();\n                 } else {\n-                    let left_len = first_kv.reborrow().left_edge().descend().len();\n+                    let left_len = first_kv.left_child_len();\n                     // `MIN_LEN + 1` to avoid readjust if merge happens on the next level.\n                     if left_len < MIN_LEN + 1 {\n                         first_kv.bulk_steal_right(MIN_LEN + 1 - left_len);\n                     }\n-                    cur_node = first_kv.left_edge().descend();\n+                    cur_node = first_kv.into_left_child();\n                 }\n             }\n         }"}]}