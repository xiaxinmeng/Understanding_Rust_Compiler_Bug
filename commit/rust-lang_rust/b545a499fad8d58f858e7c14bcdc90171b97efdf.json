{"sha": "b545a499fad8d58f858e7c14bcdc90171b97efdf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1NDVhNDk5ZmFkOGQ1OGY4NThlN2MxNGJjZGM5MDE3MWI5N2VmZGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-16T06:26:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-16T06:26:26Z"}, "message": "auto merge of #14115 : alexcrichton/rust/core-fmt, r=brson\n\nThis was a more difficult change than I thought it would be, and it is unfortunately a breaking change rather than a drop-in replacement. Most of the rationale can be found in the third commit.\r\n\r\ncc #13851", "tree": {"sha": "e4bebf36fa24fe0fe4dd6846291c59520ef1be28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4bebf36fa24fe0fe4dd6846291c59520ef1be28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b545a499fad8d58f858e7c14bcdc90171b97efdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b545a499fad8d58f858e7c14bcdc90171b97efdf", "html_url": "https://github.com/rust-lang/rust/commit/b545a499fad8d58f858e7c14bcdc90171b97efdf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b545a499fad8d58f858e7c14bcdc90171b97efdf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84406d438c6c49aa63875096e5f3cca1a3879f17", "url": "https://api.github.com/repos/rust-lang/rust/commits/84406d438c6c49aa63875096e5f3cca1a3879f17", "html_url": "https://github.com/rust-lang/rust/commit/84406d438c6c49aa63875096e5f3cca1a3879f17"}, {"sha": "2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f", "html_url": "https://github.com/rust-lang/rust/commit/2e2160b026d7a2b2d13c3a2b4d6aa073ab3ff43f"}], "stats": {"total": 6196, "additions": 3237, "deletions": 2959}, "files": [{"sha": "695c0420e2b109ad0e2e0c1cbd6110da7ac3e59f", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -41,15 +41,15 @@ impl FromStr for Mode {\n impl fmt::Show for Mode {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let msg = match *self {\n-          CompileFail => \"compile-fail\",\n-          RunFail => \"run-fail\",\n-          RunPass => \"run-pass\",\n-          Pretty => \"pretty\",\n-          DebugInfoGdb => \"debuginfo-gdb\",\n-          DebugInfoLldb => \"debuginfo-lldb\",\n-          Codegen => \"codegen\",\n+            CompileFail => \"compile-fail\",\n+            RunFail => \"run-fail\",\n+            RunPass => \"run-pass\",\n+            Pretty => \"pretty\",\n+            DebugInfoGdb => \"debuginfo-gdb\",\n+            DebugInfoLldb => \"debuginfo-lldb\",\n+            Codegen => \"codegen\",\n         };\n-        write!(f.buf, \"{}\", msg)\n+        msg.fmt(f)\n     }\n }\n "}, {"sha": "ba83ad8d37c9a77dfd901f4eae13afbc97b210c8", "filename": "src/libcollections/btree.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcollections%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcollections%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -425,8 +425,8 @@ impl<K: fmt::Show + TotalOrd, V: fmt::Show> fmt::Show for Leaf<K, V> {\n     ///Returns a string representation of a Leaf.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         for (i, s) in self.elts.iter().enumerate() {\n-            if i != 0 { try!(write!(f.buf, \" // \")) }\n-            try!(write!(f.buf, \"{}\", *s))\n+            if i != 0 { try!(write!(f, \" // \")) }\n+            try!(write!(f, \"{}\", *s))\n         }\n         Ok(())\n     }\n@@ -654,10 +654,10 @@ impl<K: fmt::Show + TotalOrd, V: fmt::Show> fmt::Show for Branch<K, V> {\n     ///Returns a string representation of a Branch.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         for (i, s) in self.elts.iter().enumerate() {\n-            if i != 0 { try!(write!(f.buf, \" // \")) }\n-            try!(write!(f.buf, \"{}\", *s))\n+            if i != 0 { try!(write!(f, \" // \")) }\n+            try!(write!(f, \"{}\", *s))\n         }\n-        write!(f.buf, \" // rightmost child: ({}) \", *self.rightmost_child)\n+        write!(f, \" // rightmost child: ({}) \", *self.rightmost_child)\n     }\n }\n \n@@ -715,7 +715,7 @@ impl<K: TotalOrd, V: TotalEq> TotalOrd for LeafElt<K, V> {\n impl<K: fmt::Show + TotalOrd, V: fmt::Show> fmt::Show for LeafElt<K, V> {\n     ///Returns a string representation of a LeafElt.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"Key: {}, value: {};\", self.key, self.value)\n+        write!(f, \"Key: {}, value: {};\", self.key, self.value)\n     }\n }\n \n@@ -765,7 +765,7 @@ impl<K: fmt::Show + TotalOrd, V: fmt::Show> fmt::Show for BranchElt<K, V> {\n     /// Returns string containing key, value, and child (which should recur to a\n     /// leaf) Consider changing in future to be more readable.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"Key: {}, value: {}, (child: {})\",\n+        write!(f, \"Key: {}, value: {}, (child: {})\",\n                self.key, self.value, *self.left)\n     }\n }"}, {"sha": "4259f458e00643baacdd6ac9fb2435d4390a025c", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -1418,14 +1418,14 @@ impl<K: TotalEq + Hash<S>, V: Eq, S, H: Hasher<S>> Eq for HashMap<K, V, H> {\n \n impl<K: TotalEq + Hash<S> + Show, V: Show, S, H: Hasher<S>> Show for HashMap<K, V, H> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f.buf, r\"\\{\"));\n+        try!(write!(f, r\"\\{\"));\n \n         for (i, (k, v)) in self.iter().enumerate() {\n-            if i != 0 { try!(write!(f.buf, \", \")); }\n-            try!(write!(f.buf, \"{}: {}\", *k, *v));\n+            if i != 0 { try!(write!(f, \", \")); }\n+            try!(write!(f, \"{}: {}\", *k, *v));\n         }\n \n-        write!(f.buf, r\"\\}\")\n+        write!(f, r\"\\}\")\n     }\n }\n \n@@ -1605,14 +1605,14 @@ impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n \n impl<T: TotalEq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f.buf, r\"\\{\"));\n+        try!(write!(f, r\"\\{\"));\n \n         for (i, x) in self.iter().enumerate() {\n-            if i != 0 { try!(write!(f.buf, \", \")); }\n-            try!(write!(f.buf, \"{}\", *x));\n+            if i != 0 { try!(write!(f, \", \")); }\n+            try!(write!(f, \"{}\", *x));\n         }\n \n-        write!(f.buf, r\"\\}\")\n+        write!(f, r\"\\}\")\n     }\n }\n "}, {"sha": "8fdc0e095bf411096cb4caa6bc162fb4182d2e65", "filename": "src/libcollections/lru_cache.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flru_cache.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -205,20 +205,20 @@ impl<A: fmt::Show + Hash + TotalEq, B: fmt::Show> fmt::Show for LruCache<A, B> {\n     /// Return a string that lists the key-value pairs from most-recently\n     /// used to least-recently used.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f.buf, r\"\\{\"));\n+        try!(write!(f, r\"\\{\"));\n         let mut cur = self.head;\n         for i in range(0, self.len()) {\n-            if i > 0 { try!(write!(f.buf, \", \")) }\n+            if i > 0 { try!(write!(f, \", \")) }\n             unsafe {\n                 cur = (*cur).next;\n-                try!(write!(f.buf, \"{}\", (*cur).key));\n+                try!(write!(f, \"{}\", (*cur).key));\n             }\n-            try!(write!(f.buf, \": \"));\n+            try!(write!(f, \": \"));\n             unsafe {\n-                try!(write!(f.buf, \"{}\", (*cur).value));\n+                try!(write!(f, \"{}\", (*cur).value));\n             }\n         }\n-        write!(f.buf, r\"\\}\")\n+        write!(f, r\"\\}\")\n     }\n }\n "}, {"sha": "61c1193e515973f939e9daf8ede42269079de50b", "filename": "src/libcore/any.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -166,12 +166,12 @@ mod tests {\n \n         match a.as_ref::<uint>() {\n             Some(&5) => {}\n-            x => fail!(\"Unexpected value {:?}\", x)\n+            x => fail!(\"Unexpected value {}\", x)\n         }\n \n         match a.as_ref::<Test>() {\n             None => {}\n-            x => fail!(\"Unexpected value {:?}\", x)\n+            x => fail!(\"Unexpected value {}\", x)\n         }\n     }\n \n@@ -189,35 +189,35 @@ mod tests {\n                 assert_eq!(*x, 5u);\n                 *x = 612;\n             }\n-            x => fail!(\"Unexpected value {:?}\", x)\n+            x => fail!(\"Unexpected value {}\", x)\n         }\n \n         match b_r.as_mut::<uint>() {\n             Some(x) => {\n                 assert_eq!(*x, 7u);\n                 *x = 413;\n             }\n-            x => fail!(\"Unexpected value {:?}\", x)\n+            x => fail!(\"Unexpected value {}\", x)\n         }\n \n         match a_r.as_mut::<Test>() {\n             None => (),\n-            x => fail!(\"Unexpected value {:?}\", x)\n+            x => fail!(\"Unexpected value {}\", x)\n         }\n \n         match b_r.as_mut::<Test>() {\n             None => (),\n-            x => fail!(\"Unexpected value {:?}\", x)\n+            x => fail!(\"Unexpected value {}\", x)\n         }\n \n         match a_r.as_mut::<uint>() {\n             Some(&612) => {}\n-            x => fail!(\"Unexpected value {:?}\", x)\n+            x => fail!(\"Unexpected value {}\", x)\n         }\n \n         match b_r.as_mut::<uint>() {\n             Some(&413) => {}\n-            x => fail!(\"Unexpected value {:?}\", x)\n+            x => fail!(\"Unexpected value {}\", x)\n         }\n     }\n \n@@ -229,11 +229,11 @@ mod tests {\n         let b = box Test as Box<Any>;\n \n         match a.move::<uint>() {\n-            Ok(a) => { assert_eq!(a, box 8u); }\n+            Ok(a) => { assert!(a == box 8u); }\n             Err(..) => fail!()\n         }\n         match b.move::<Test>() {\n-            Ok(a) => { assert_eq!(a, box Test); }\n+            Ok(a) => { assert!(a == box Test); }\n             Err(..) => fail!()\n         }\n \n@@ -246,13 +246,14 @@ mod tests {\n \n     #[test]\n     fn test_show() {\n-        let a = box 8u as Box<::realcore::any::Any>;\n-        let b = box Test as Box<::realcore::any::Any>;\n-        assert_eq!(format!(\"{}\", a), \"Box<Any>\".to_owned());\n-        assert_eq!(format!(\"{}\", b), \"Box<Any>\".to_owned());\n-\n-        let a = &8u as &::realcore::any::Any;\n-        let b = &Test as &::realcore::any::Any;\n+        use realstd::to_str::ToStr;\n+        let a = box 8u as Box<::realstd::any::Any>;\n+        let b = box Test as Box<::realstd::any::Any>;\n+        assert_eq!(a.to_str(), \"Box<Any>\".to_owned());\n+        assert_eq!(b.to_str(), \"Box<Any>\".to_owned());\n+\n+        let a = &8u as &Any;\n+        let b = &Test as &Any;\n         assert_eq!(format!(\"{}\", a), \"&Any\".to_owned());\n         assert_eq!(format!(\"{}\", b), \"&Any\".to_owned());\n     }"}, {"sha": "d42ad49485f6dae9927a33e8df4c68afc394fe68", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -255,7 +255,7 @@ mod test {\n     fn cell_has_sensible_show() {\n         use str::StrSlice;\n \n-        let x = ::realcore::cell::Cell::new(\"foo bar\");\n+        let x = Cell::new(\"foo bar\");\n         assert!(format!(\"{}\", x).contains(x.get()));\n \n         x.set(\"baz qux\");"}, {"sha": "6e9d4c9bafbf616be4ae623ac8c9fad8ea641f87", "filename": "src/libcore/char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -633,9 +633,9 @@ impl Default for char {\n mod test {\n     use super::{escape_unicode, escape_default};\n \n-    use realcore::char::Char;\n+    use char::Char;\n     use slice::ImmutableVector;\n-    use realstd::option::{Some, None};\n+    use option::{Some, None};\n     use realstd::strbuf::StrBuf;\n     use realstd::str::StrAllocating;\n "}, {"sha": "c7befe2f4b1e0a64d23bd7c162577b79f067ef7e", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -131,7 +131,7 @@ mod test {\n     fn test_owned_clone() {\n         let a = box 5i;\n         let b: Box<int> = realclone(&a);\n-        assert_eq!(a, b);\n+        assert!(a == b);\n     }\n \n     #[test]"}, {"sha": "a50108607ce71cf46d1af2a618714e83317ebac9", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -82,7 +82,7 @@ pub trait TotalEq: Eq {\n }\n \n /// An ordering is, e.g, a result of a comparison between two values.\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, Eq, Show)]\n pub enum Ordering {\n    /// An ordering where a compared value is less [than another].\n    Less = -1,"}, {"sha": "c4a2c9a609925fd15b9a565801c8399ad04d1bba", "filename": "src/libcore/failure.rs", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffailure.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -9,21 +9,28 @@\n // except according to those terms.\n \n //! Failure support for libcore\n+//!\n+//! The core library cannot define failure, but it does *declare* failure. This\n+//! means that the functions inside of libcore are allowed to fail, but to be\n+//! useful an upstream crate must define failure for libcore to use. The current\n+//! interface for failure is:\n+//!\n+//!     fn begin_unwind(fmt: &fmt::Arguments, file: &str, line: uint) -> !;\n+//!\n+//! This definition allows for failing with any general message, but it does not\n+//! allow for failing with a `~Any` value. The reason for this is that libcore\n+//! is not allowed to allocate.\n+//!\n+//! This module contains a few other failure functions, but these are just the\n+//! necessary lang items for the compiler. All failure is funneled through this\n+//! one function. Currently, the actual symbol is declared in the standard\n+//! library, but the location of this may change over time.\n \n #![allow(dead_code, missing_doc)]\n \n #[cfg(not(test))]\n use str::raw::c_str_to_static_slice;\n-\n-// FIXME: Once std::fmt is in libcore, all of these functions should delegate\n-//        to a common failure function with this signature:\n-//\n-//          extern {\n-//              fn rust_unwind(f: &fmt::Arguments, file: &str, line: uint) -> !;\n-//          }\n-//\n-//        Each of these functions can create a temporary fmt::Arguments\n-//        structure to pass to this function.\n+use fmt;\n \n #[cold] #[inline(never)] // this is the slow path, always\n #[lang=\"fail_\"]\n@@ -32,24 +39,31 @@ fn fail_(expr: *u8, file: *u8, line: uint) -> ! {\n     unsafe {\n         let expr = c_str_to_static_slice(expr as *i8);\n         let file = c_str_to_static_slice(file as *i8);\n-        begin_unwind(expr, file, line)\n+        format_args!(|args| -> () {\n+            begin_unwind(args, file, line);\n+        }, \"{}\", expr);\n+\n+        loop {}\n     }\n }\n \n #[cold]\n #[lang=\"fail_bounds_check\"]\n #[cfg(not(test))]\n fn fail_bounds_check(file: *u8, line: uint, index: uint, len: uint) -> ! {\n-    #[allow(ctypes)]\n-    extern { fn rust_fail_bounds_check(file: *u8, line: uint,\n-                                       index: uint, len: uint,) -> !; }\n-    unsafe { rust_fail_bounds_check(file, line, index, len) }\n+    let file = unsafe { c_str_to_static_slice(file as *i8) };\n+    format_args!(|args| -> () {\n+        begin_unwind(args, file, line);\n+    }, \"index out of bounds: the len is {} but the index is {}\", len, index);\n+    loop {}\n }\n \n #[cold]\n-pub fn begin_unwind(msg: &str, file: &'static str, line: uint) -> ! {\n+pub fn begin_unwind(fmt: &fmt::Arguments, file: &'static str, line: uint) -> ! {\n+    // FIXME: this should be a proper lang item, it should not just be some\n+    //        undefined symbol sitting in the middle of nowhere.\n     #[allow(ctypes)]\n-    extern { fn rust_begin_unwind(msg: &str, file: &'static str,\n+    extern { fn rust_begin_unwind(fmt: &fmt::Arguments, file: &'static str,\n                                   line: uint) -> !; }\n-    unsafe { rust_begin_unwind(msg, file, line) }\n+    unsafe { rust_begin_unwind(fmt, file, line) }\n }"}, {"sha": "e5fb148aded341b64fa5db72d5faa8ecfa1dd69e", "filename": "src/libcore/fmt/float.rs", "status": "added", "additions": 370, "deletions": 0, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -0,0 +1,370 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(missing_doc)]\n+\n+use char;\n+use container::Container;\n+use fmt;\n+use iter::{Iterator, range, DoubleEndedIterator};\n+use num::{Float, FPNaN, FPInfinite, ToPrimitive, Primitive};\n+use num::{Zero, One, cast};\n+use option::{None, Some};\n+use result::Ok;\n+use slice::{ImmutableVector, MutableVector};\n+use slice;\n+use str::StrSlice;\n+\n+/// A flag that specifies whether to use exponential (scientific) notation.\n+pub enum ExponentFormat {\n+    /// Do not use exponential notation.\n+    ExpNone,\n+    /// Use exponential notation with the exponent having a base of 10 and the\n+    /// exponent sign being `e` or `E`. For example, 1000 would be printed\n+    /// 1e3.\n+    ExpDec,\n+    /// Use exponential notation with the exponent having a base of 2 and the\n+    /// exponent sign being `p` or `P`. For example, 8 would be printed 1p3.\n+    ExpBin,\n+}\n+\n+/// The number of digits used for emitting the fractional part of a number, if\n+/// any.\n+pub enum SignificantDigits {\n+    /// All calculable digits will be printed.\n+    ///\n+    /// Note that bignums or fractions may cause a surprisingly large number\n+    /// of digits to be printed.\n+    DigAll,\n+\n+    /// At most the given number of digits will be printed, truncating any\n+    /// trailing zeroes.\n+    DigMax(uint),\n+\n+    /// Precisely the given number of digits will be printed.\n+    DigExact(uint)\n+}\n+\n+/// How to emit the sign of a number.\n+pub enum SignFormat {\n+    /// No sign will be printed. The exponent sign will also be emitted.\n+    SignNone,\n+    /// `-` will be printed for negative values, but no sign will be emitted\n+    /// for positive numbers.\n+    SignNeg,\n+    /// `+` will be printed for positive values, and `-` will be printed for\n+    /// negative values.\n+    SignAll,\n+}\n+\n+static DIGIT_P_RADIX: uint = ('p' as uint) - ('a' as uint) + 11u;\n+static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n+\n+/**\n+ * Converts a number to its string representation as a byte vector.\n+ * This is meant to be a common base implementation for all numeric string\n+ * conversion functions like `to_str()` or `to_str_radix()`.\n+ *\n+ * # Arguments\n+ * - `num`           - The number to convert. Accepts any number that\n+ *                     implements the numeric traits.\n+ * - `radix`         - Base to use. Accepts only the values 2-36. If the exponential notation\n+ *                     is used, then this base is only used for the significand. The exponent\n+ *                     itself always printed using a base of 10.\n+ * - `negative_zero` - Whether to treat the special value `-0` as\n+ *                     `-0` or as `+0`.\n+ * - `sign`          - How to emit the sign. See `SignFormat`.\n+ * - `digits`        - The amount of digits to use for emitting the fractional\n+ *                     part, if any. See `SignificantDigits`.\n+ * - `exp_format`   - Whether or not to use the exponential (scientific) notation.\n+ *                    See `ExponentFormat`.\n+ * - `exp_capital`   - Whether or not to use a capital letter for the exponent sign, if\n+ *                     exponential notation is desired.\n+ * - `f`             - A closure to invoke with the bytes representing the\n+ *                     float.\n+ *\n+ * # Failure\n+ * - Fails if `radix` < 2 or `radix` > 36.\n+ * - Fails if `radix` > 14 and `exp_format` is `ExpDec` due to conflict\n+ *   between digit and exponent sign `'e'`.\n+ * - Fails if `radix` > 25 and `exp_format` is `ExpBin` due to conflict\n+ *   between digit and exponent sign `'p'`.\n+ */\n+pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n+    num: T,\n+    radix: uint,\n+    negative_zero: bool,\n+    sign: SignFormat,\n+    digits: SignificantDigits,\n+    exp_format: ExponentFormat,\n+    exp_upper: bool,\n+    f: |&[u8]| -> U\n+) -> U {\n+    assert!(2 <= radix && radix <= 36);\n+    match exp_format {\n+        ExpDec if radix >= DIGIT_E_RADIX       // decimal exponent 'e'\n+          => fail!(\"float_to_str_bytes_common: radix {} incompatible with \\\n+                    use of 'e' as decimal exponent\", radix),\n+        ExpBin if radix >= DIGIT_P_RADIX       // binary exponent 'p'\n+          => fail!(\"float_to_str_bytes_common: radix {} incompatible with \\\n+                    use of 'p' as binary exponent\", radix),\n+        _ => ()\n+    }\n+\n+    let _0: T = Zero::zero();\n+    let _1: T = One::one();\n+\n+    match num.classify() {\n+        FPNaN => return f(\"NaN\".as_bytes()),\n+        FPInfinite if num > _0 => {\n+            return match sign {\n+                SignAll => return f(\"+inf\".as_bytes()),\n+                _       => return f(\"inf\".as_bytes()),\n+            };\n+        }\n+        FPInfinite if num < _0 => {\n+            return match sign {\n+                SignNone => return f(\"inf\".as_bytes()),\n+                _        => return f(\"-inf\".as_bytes()),\n+            };\n+        }\n+        _ => {}\n+    }\n+\n+    let neg = num < _0 || (negative_zero && _1 / num == Float::neg_infinity());\n+    // For an f64 the exponent is in the range of [-1022, 1023] for base 2, so\n+    // we may have up to that many digits. Give ourselves some extra wiggle room\n+    // otherwise as well.\n+    let mut buf = [0u8, ..1536];\n+    let mut end = 0;\n+    let radix_gen: T = cast(radix as int).unwrap();\n+\n+    let (num, exp) = match exp_format {\n+        ExpNone => (num, 0i32),\n+        ExpDec | ExpBin if num == _0 => (num, 0i32),\n+        ExpDec | ExpBin => {\n+            let (exp, exp_base) = match exp_format {\n+                ExpDec => (num.abs().log10().floor(), cast::<f64, T>(10.0f64).unwrap()),\n+                ExpBin => (num.abs().log2().floor(), cast::<f64, T>(2.0f64).unwrap()),\n+                ExpNone => fail!(\"unreachable\"),\n+            };\n+\n+            (num / exp_base.powf(exp), cast::<T, i32>(exp).unwrap())\n+        }\n+    };\n+\n+    // First emit the non-fractional part, looping at least once to make\n+    // sure at least a `0` gets emitted.\n+    let mut deccum = num.trunc();\n+    loop {\n+        // Calculate the absolute value of each digit instead of only\n+        // doing it once for the whole number because a\n+        // representable negative number doesn't necessary have an\n+        // representable additive inverse of the same type\n+        // (See twos complement). But we assume that for the\n+        // numbers [-35 .. 0] we always have [0 .. 35].\n+        let current_digit = (deccum % radix_gen).abs();\n+\n+        // Decrease the deccumulator one digit at a time\n+        deccum = deccum / radix_gen;\n+        deccum = deccum.trunc();\n+\n+        let c = char::from_digit(current_digit.to_int().unwrap() as uint, radix);\n+        buf[end] = c.unwrap() as u8;\n+        end += 1;\n+\n+        // No more digits to calculate for the non-fractional part -> break\n+        if deccum == _0 { break; }\n+    }\n+\n+    // If limited digits, calculate one digit more for rounding.\n+    let (limit_digits, digit_count, exact) = match digits {\n+        DigAll          => (false, 0u,      false),\n+        DigMax(count)   => (true,  count+1, false),\n+        DigExact(count) => (true,  count+1, true)\n+    };\n+\n+    // Decide what sign to put in front\n+    match sign {\n+        SignNeg | SignAll if neg => {\n+            buf[end] = '-' as u8;\n+            end += 1;\n+        }\n+        SignAll => {\n+            buf[end] = '+' as u8;\n+            end += 1;\n+        }\n+        _ => ()\n+    }\n+\n+    buf.mut_slice_to(end).reverse();\n+\n+    // Remember start of the fractional digits.\n+    // Points one beyond end of buf if none get generated,\n+    // or at the '.' otherwise.\n+    let start_fractional_digits = end;\n+\n+    // Now emit the fractional part, if any\n+    deccum = num.fract();\n+    if deccum != _0 || (limit_digits && exact && digit_count > 0) {\n+        buf[end] = '.' as u8;\n+        end += 1;\n+        let mut dig = 0u;\n+\n+        // calculate new digits while\n+        // - there is no limit and there are digits left\n+        // - or there is a limit, it's not reached yet and\n+        //   - it's exact\n+        //   - or it's a maximum, and there are still digits left\n+        while (!limit_digits && deccum != _0)\n+           || (limit_digits && dig < digit_count && (\n+                   exact\n+                || (!exact && deccum != _0)\n+              )\n+        ) {\n+            // Shift first fractional digit into the integer part\n+            deccum = deccum * radix_gen;\n+\n+            // Calculate the absolute value of each digit.\n+            // See note in first loop.\n+            let current_digit = deccum.trunc().abs();\n+\n+            let c = char::from_digit(current_digit.to_int().unwrap() as uint,\n+                                     radix);\n+            buf[end] = c.unwrap() as u8;\n+            end += 1;\n+\n+            // Decrease the deccumulator one fractional digit at a time\n+            deccum = deccum.fract();\n+            dig += 1u;\n+        }\n+\n+        // If digits are limited, and that limit has been reached,\n+        // cut off the one extra digit, and depending on its value\n+        // round the remaining ones.\n+        if limit_digits && dig == digit_count {\n+            let ascii2value = |chr: u8| {\n+                char::to_digit(chr as char, radix).unwrap()\n+            };\n+            let value2ascii = |val: uint| {\n+                char::from_digit(val, radix).unwrap() as u8\n+            };\n+\n+            let extra_digit = ascii2value(buf[end - 1]);\n+            end -= 1;\n+            if extra_digit >= radix / 2 { // -> need to round\n+                let mut i: int = end as int - 1;\n+                loop {\n+                    // If reached left end of number, have to\n+                    // insert additional digit:\n+                    if i < 0\n+                    || buf[i as uint] == '-' as u8\n+                    || buf[i as uint] == '+' as u8 {\n+                        for j in range(i as uint + 1, end).rev() {\n+                            buf[j + 1] = buf[j];\n+                        }\n+                        buf[(i + 1) as uint] = value2ascii(1);\n+                        end += 1;\n+                        break;\n+                    }\n+\n+                    // Skip the '.'\n+                    if buf[i as uint] == '.' as u8 { i -= 1; continue; }\n+\n+                    // Either increment the digit,\n+                    // or set to 0 if max and carry the 1.\n+                    let current_digit = ascii2value(buf[i as uint]);\n+                    if current_digit < (radix - 1) {\n+                        buf[i as uint] = value2ascii(current_digit+1);\n+                        break;\n+                    } else {\n+                        buf[i as uint] = value2ascii(0);\n+                        i -= 1;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // if number of digits is not exact, remove all trailing '0's up to\n+    // and including the '.'\n+    if !exact {\n+        let buf_max_i = end - 1;\n+\n+        // index to truncate from\n+        let mut i = buf_max_i;\n+\n+        // discover trailing zeros of fractional part\n+        while i > start_fractional_digits && buf[i] == '0' as u8 {\n+            i -= 1;\n+        }\n+\n+        // Only attempt to truncate digits if buf has fractional digits\n+        if i >= start_fractional_digits {\n+            // If buf ends with '.', cut that too.\n+            if buf[i] == '.' as u8 { i -= 1 }\n+\n+            // only resize buf if we actually remove digits\n+            if i < buf_max_i {\n+                end = i + 1;\n+            }\n+        }\n+    } // If exact and trailing '.', just cut that\n+    else {\n+        let max_i = end - 1;\n+        if buf[max_i] == '.' as u8 {\n+            end = max_i;\n+        }\n+    }\n+\n+    match exp_format {\n+        ExpNone => {},\n+        _ => {\n+            buf[end] = match exp_format {\n+                ExpDec if exp_upper => 'E',\n+                ExpDec if !exp_upper => 'e',\n+                ExpBin if exp_upper => 'P',\n+                ExpBin if !exp_upper => 'p',\n+                _ => fail!(\"unreachable\"),\n+            } as u8;\n+            end += 1;\n+\n+            struct Filler<'a> {\n+                buf: &'a mut [u8],\n+                end: &'a mut uint,\n+            }\n+\n+            impl<'a> fmt::FormatWriter for Filler<'a> {\n+                fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n+                    slice::bytes::copy_memory(self.buf.mut_slice_from(*self.end),\n+                                              bytes);\n+                    *self.end += bytes.len();\n+                    Ok(())\n+                }\n+            }\n+\n+            let mut filler = Filler { buf: buf, end: &mut end };\n+            match sign {\n+                SignNeg => {\n+                    let _ = format_args!(|args| {\n+                        fmt::write(&mut filler, args)\n+                    }, \"{:-}\", exp);\n+                }\n+                SignNone | SignAll => {\n+                    let _ = format_args!(|args| {\n+                        fmt::write(&mut filler, args)\n+                    }, \"{}\", exp);\n+                }\n+            }\n+        }\n+    }\n+\n+    f(buf.slice_to(end))\n+}"}, {"sha": "979928c10ad2ff04ec16b500e95126cefd9a7778", "filename": "src/libcore/fmt/mod.rs", "status": "added", "additions": 834, "deletions": 0, "changes": 834, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -0,0 +1,834 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Utilities for formatting and printing strings\n+\n+#![allow(unused_variable)]\n+\n+use any;\n+use cell::Cell;\n+use char::Char;\n+use container::Container;\n+use iter::{Iterator, range};\n+use kinds::Copy;\n+use mem;\n+use option::{Option, Some, None};\n+use result::{Ok, Err};\n+use result;\n+use slice::{Vector, ImmutableVector};\n+use slice;\n+use str::StrSlice;\n+use str;\n+\n+pub use self::num::radix;\n+pub use self::num::Radix;\n+pub use self::num::RadixFmt;\n+\n+macro_rules! write(\n+    ($dst:expr, $($arg:tt)*) => ({\n+        format_args!(|args| { $dst.write_fmt(args) }, $($arg)*)\n+    })\n+)\n+\n+mod num;\n+mod float;\n+pub mod rt;\n+\n+pub type Result = result::Result<(), FormatError>;\n+\n+/// dox\n+pub enum FormatError {\n+    /// dox\n+    WriteError,\n+}\n+\n+/// dox\n+pub trait FormatWriter {\n+    /// dox\n+    fn write(&mut self, bytes: &[u8]) -> Result;\n+}\n+\n+/// A struct to represent both where to emit formatting strings to and how they\n+/// should be formatted. A mutable version of this is passed to all formatting\n+/// traits.\n+pub struct Formatter<'a> {\n+    /// Flags for formatting (packed version of rt::Flag)\n+    pub flags: uint,\n+    /// Character used as 'fill' whenever there is alignment\n+    pub fill: char,\n+    /// Boolean indication of whether the output should be left-aligned\n+    pub align: rt::Alignment,\n+    /// Optionally specified integer width that the output should be\n+    pub width: Option<uint>,\n+    /// Optionally specified precision for numeric types\n+    pub precision: Option<uint>,\n+\n+    #[allow(missing_doc)]\n+    #[cfg(stage0)]\n+    pub buf: &'a mut FormatWriter,\n+    #[cfg(not(stage0))]\n+    buf: &'a mut FormatWriter,\n+    curarg: slice::Items<'a, Argument<'a>>,\n+    args: &'a [Argument<'a>],\n+}\n+\n+enum CurrentlyFormatting<'a> {\n+    Nothing,\n+    RawString(&'a str),\n+    Number(uint),\n+}\n+\n+/// This struct represents the generic \"argument\" which is taken by the Xprintf\n+/// family of functions. It contains a function to format the given value. At\n+/// compile time it is ensured that the function and the value have the correct\n+/// types, and then this struct is used to canonicalize arguments to one type.\n+pub struct Argument<'a> {\n+    formatter: extern \"Rust\" fn(&any::Void, &mut Formatter) -> Result,\n+    value: &'a any::Void,\n+}\n+\n+impl<'a> Arguments<'a> {\n+    /// When using the format_args!() macro, this function is used to generate the\n+    /// Arguments structure. The compiler inserts an `unsafe` block to call this,\n+    /// which is valid because the compiler performs all necessary validation to\n+    /// ensure that the resulting call to format/write would be safe.\n+    #[doc(hidden)] #[inline]\n+    pub unsafe fn new<'a>(fmt: &'static [rt::Piece<'static>],\n+                          args: &'a [Argument<'a>]) -> Arguments<'a> {\n+        Arguments{ fmt: mem::transmute(fmt), args: args }\n+    }\n+}\n+\n+/// This structure represents a safely precompiled version of a format string\n+/// and its arguments. This cannot be generated at runtime because it cannot\n+/// safely be done so, so no constructors are given and the fields are private\n+/// to prevent modification.\n+///\n+/// The `format_args!` macro will safely create an instance of this structure\n+/// and pass it to a user-supplied function. The macro validates the format\n+/// string at compile-time so usage of the `write` and `format` functions can\n+/// be safely performed.\n+pub struct Arguments<'a> {\n+    fmt: &'a [rt::Piece<'a>],\n+    args: &'a [Argument<'a>],\n+}\n+\n+impl<'a> Show for Arguments<'a> {\n+    fn fmt(&self, fmt: &mut Formatter) -> Result {\n+        write(fmt.buf, self)\n+    }\n+}\n+\n+/// When a format is not otherwise specified, types are formatted by ascribing\n+/// to this trait. There is not an explicit way of selecting this trait to be\n+/// used for formatting, it is only if no other format is specified.\n+pub trait Show {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+/// Format trait for the `b` character\n+pub trait Bool {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+/// Format trait for the `c` character\n+pub trait Char {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+/// Format trait for the `i` and `d` characters\n+pub trait Signed {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+/// Format trait for the `u` character\n+pub trait Unsigned {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+/// Format trait for the `o` character\n+pub trait Octal {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+/// Format trait for the `t` character\n+pub trait Binary {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+/// Format trait for the `x` character\n+pub trait LowerHex {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+/// Format trait for the `X` character\n+pub trait UpperHex {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+/// Format trait for the `s` character\n+pub trait String {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+/// Format trait for the `p` character\n+pub trait Pointer {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+/// Format trait for the `f` character\n+pub trait Float {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+/// Format trait for the `e` character\n+pub trait LowerExp {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+/// Format trait for the `E` character\n+pub trait UpperExp {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+// FIXME #11938 - UFCS would make us able call the above methods\n+// directly Show::show(x, fmt).\n+macro_rules! uniform_fn_call_workaround {\n+    ($( $name: ident, $trait_: ident; )*) => {\n+        $(\n+            #[doc(hidden)]\n+            pub fn $name<T: $trait_>(x: &T, fmt: &mut Formatter) -> Result {\n+                x.fmt(fmt)\n+            }\n+            )*\n+    }\n+}\n+uniform_fn_call_workaround! {\n+    secret_show, Show;\n+    secret_bool, Bool;\n+    secret_char, Char;\n+    secret_signed, Signed;\n+    secret_unsigned, Unsigned;\n+    secret_octal, Octal;\n+    secret_binary, Binary;\n+    secret_lower_hex, LowerHex;\n+    secret_upper_hex, UpperHex;\n+    secret_string, String;\n+    secret_pointer, Pointer;\n+    secret_float, Float;\n+    secret_lower_exp, LowerExp;\n+    secret_upper_exp, UpperExp;\n+}\n+\n+/// The `write` function takes an output stream, a precompiled format string,\n+/// and a list of arguments. The arguments will be formatted according to the\n+/// specified format string into the output stream provided.\n+///\n+/// # Arguments\n+///\n+///   * output - the buffer to write output to\n+///   * args - the precompiled arguments generated by `format_args!`\n+pub fn write(output: &mut FormatWriter, args: &Arguments) -> Result {\n+    let mut formatter = Formatter {\n+        flags: 0,\n+        width: None,\n+        precision: None,\n+        buf: output,\n+        align: rt::AlignUnknown,\n+        fill: ' ',\n+        args: args.args,\n+        curarg: args.args.iter(),\n+    };\n+    for piece in args.fmt.iter() {\n+        try!(formatter.run(piece, Nothing));\n+    }\n+    Ok(())\n+}\n+\n+impl<'a> Formatter<'a> {\n+\n+    // First up is the collection of functions used to execute a format string\n+    // at runtime. This consumes all of the compile-time statics generated by\n+    // the format! syntax extension.\n+\n+    fn run(&mut self, piece: &rt::Piece, cur: CurrentlyFormatting) -> Result {\n+        match *piece {\n+            rt::String(s) => self.buf.write(s.as_bytes()),\n+            rt::CurrentArgument(()) => {\n+                match cur {\n+                    Nothing => Ok(()),\n+                    Number(n) => secret_show(&radix(n, 10), self),\n+                    RawString(s) => self.buf.write(s.as_bytes()),\n+                }\n+            }\n+            rt::Argument(ref arg) => {\n+                // Fill in the format parameters into the formatter\n+                self.fill = arg.format.fill;\n+                self.align = arg.format.align;\n+                self.flags = arg.format.flags;\n+                self.width = self.getcount(&arg.format.width);\n+                self.precision = self.getcount(&arg.format.precision);\n+\n+                // Extract the correct argument\n+                let value = match arg.position {\n+                    rt::ArgumentNext => { *self.curarg.next().unwrap() }\n+                    rt::ArgumentIs(i) => self.args[i],\n+                };\n+\n+                // Then actually do some printing\n+                match arg.method {\n+                    None => (value.formatter)(value.value, self),\n+                    Some(ref method) => self.execute(*method, value)\n+                }\n+            }\n+        }\n+    }\n+\n+    fn getcount(&mut self, cnt: &rt::Count) -> Option<uint> {\n+        match *cnt {\n+            rt::CountIs(n) => { Some(n) }\n+            rt::CountImplied => { None }\n+            rt::CountIsParam(i) => {\n+                let v = self.args[i].value;\n+                unsafe { Some(*(v as *any::Void as *uint)) }\n+            }\n+            rt::CountIsNextParam => {\n+                let v = self.curarg.next().unwrap().value;\n+                unsafe { Some(*(v as *any::Void as *uint)) }\n+            }\n+        }\n+    }\n+\n+    fn execute(&mut self, method: &rt::Method, arg: Argument) -> Result {\n+        match *method {\n+            // Pluralization is selection upon a numeric value specified as the\n+            // parameter.\n+            rt::Plural(offset, ref selectors, ref default) => {\n+                // This is validated at compile-time to be a pointer to a\n+                // '&uint' value.\n+                let value: &uint = unsafe { mem::transmute(arg.value) };\n+                let value = *value;\n+\n+                // First, attempt to match against explicit values without the\n+                // offsetted value\n+                for s in selectors.iter() {\n+                    match s.selector {\n+                        rt::Literal(val) if value == val => {\n+                            return self.runplural(value, s.result);\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+\n+                // Next, offset the value and attempt to match against the\n+                // keyword selectors.\n+                let value = value - match offset { Some(i) => i, None => 0 };\n+                for s in selectors.iter() {\n+                    let run = match s.selector {\n+                        rt::Keyword(rt::Zero) => value == 0,\n+                        rt::Keyword(rt::One) => value == 1,\n+                        rt::Keyword(rt::Two) => value == 2,\n+\n+                        // FIXME: Few/Many should have a user-specified boundary\n+                        //      One possible option would be in the function\n+                        //      pointer of the 'arg: Argument' struct.\n+                        rt::Keyword(rt::Few) => value < 8,\n+                        rt::Keyword(rt::Many) => value >= 8,\n+\n+                        rt::Literal(..) => false\n+                    };\n+                    if run {\n+                        return self.runplural(value, s.result);\n+                    }\n+                }\n+\n+                self.runplural(value, *default)\n+            }\n+\n+            // Select is just a matching against the string specified.\n+            rt::Select(ref selectors, ref default) => {\n+                // This is validated at compile-time to be a pointer to a\n+                // string slice,\n+                let value: & &str = unsafe { mem::transmute(arg.value) };\n+                let value = *value;\n+\n+                for s in selectors.iter() {\n+                    if s.selector == value {\n+                        for piece in s.result.iter() {\n+                            try!(self.run(piece, RawString(value)));\n+                        }\n+                        return Ok(());\n+                    }\n+                }\n+                for piece in default.iter() {\n+                    try!(self.run(piece, RawString(value)));\n+                }\n+                Ok(())\n+            }\n+        }\n+    }\n+\n+    fn runplural(&mut self, value: uint, pieces: &[rt::Piece]) -> Result {\n+        for piece in pieces.iter() {\n+            try!(self.run(piece, Number(value)));\n+        }\n+        Ok(())\n+    }\n+\n+    // Helper methods used for padding and processing formatting arguments that\n+    // all formatting traits can use.\n+\n+    /// Performs the correct padding for an integer which has already been\n+    /// emitted into a byte-array. The byte-array should *not* contain the sign\n+    /// for the integer, that will be added by this method.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * is_positive - whether the original integer was positive or not.\n+    /// * prefix - if the '#' character (FlagAlternate) is provided, this\n+    ///   is the prefix to put in front of the number.\n+    /// * buf - the byte array that the number has been formatted into\n+    ///\n+    /// This function will correctly account for the flags provided as well as\n+    /// the minimum width. It will not take precision into account.\n+    pub fn pad_integral(&mut self, is_positive: bool, prefix: &str,\n+                        buf: &[u8]) -> Result {\n+        use fmt::rt::{FlagAlternate, FlagSignPlus, FlagSignAwareZeroPad};\n+\n+        let mut width = buf.len();\n+\n+        let mut sign = None;\n+        if !is_positive {\n+            sign = Some('-'); width += 1;\n+        } else if self.flags & (1 << (FlagSignPlus as uint)) != 0 {\n+            sign = Some('+'); width += 1;\n+        }\n+\n+        let mut prefixed = false;\n+        if self.flags & (1 << (FlagAlternate as uint)) != 0 {\n+            prefixed = true; width += prefix.len();\n+        }\n+\n+        // Writes the sign if it exists, and then the prefix if it was requested\n+        let write_prefix = |f: &mut Formatter| {\n+            for c in sign.move_iter() {\n+                let mut b = [0, ..4];\n+                let n = c.encode_utf8(b);\n+                try!(f.buf.write(b.slice_to(n)));\n+            }\n+            if prefixed { f.buf.write(prefix.as_bytes()) }\n+            else { Ok(()) }\n+        };\n+\n+        // The `width` field is more of a `min-width` parameter at this point.\n+        match self.width {\n+            // If there's no minimum length requirements then we can just\n+            // write the bytes.\n+            None => {\n+                try!(write_prefix(self)); self.buf.write(buf)\n+            }\n+            // Check if we're over the minimum width, if so then we can also\n+            // just write the bytes.\n+            Some(min) if width >= min => {\n+                try!(write_prefix(self)); self.buf.write(buf)\n+            }\n+            // The sign and prefix goes before the padding if the fill character\n+            // is zero\n+            Some(min) if self.flags & (1 << (FlagSignAwareZeroPad as uint)) != 0 => {\n+                self.fill = '0';\n+                try!(write_prefix(self));\n+                self.with_padding(min - width, rt::AlignRight, |f| f.buf.write(buf))\n+            }\n+            // Otherwise, the sign and prefix goes after the padding\n+            Some(min) => {\n+                self.with_padding(min - width, rt::AlignRight, |f| {\n+                    try!(write_prefix(f)); f.buf.write(buf)\n+                })\n+            }\n+        }\n+    }\n+\n+    /// This function takes a string slice and emits it to the internal buffer\n+    /// after applying the relevant formatting flags specified. The flags\n+    /// recognized for generic strings are:\n+    ///\n+    /// * width - the minimum width of what to emit\n+    /// * fill/align - what to emit and where to emit it if the string\n+    ///                provided needs to be padded\n+    /// * precision - the maximum length to emit, the string is truncated if it\n+    ///               is longer than this length\n+    ///\n+    /// Notably this function ignored the `flag` parameters\n+    pub fn pad(&mut self, s: &str) -> Result {\n+        // Make sure there's a fast path up front\n+        if self.width.is_none() && self.precision.is_none() {\n+            return self.buf.write(s.as_bytes());\n+        }\n+        // The `precision` field can be interpreted as a `max-width` for the\n+        // string being formatted\n+        match self.precision {\n+            Some(max) => {\n+                // If there's a maximum width and our string is longer than\n+                // that, then we must always have truncation. This is the only\n+                // case where the maximum length will matter.\n+                let char_len = s.char_len();\n+                if char_len >= max {\n+                    let nchars = ::cmp::min(max, char_len);\n+                    return self.buf.write(s.slice_chars(0, nchars).as_bytes());\n+                }\n+            }\n+            None => {}\n+        }\n+        // The `width` field is more of a `min-width` parameter at this point.\n+        match self.width {\n+            // If we're under the maximum length, and there's no minimum length\n+            // requirements, then we can just emit the string\n+            None => self.buf.write(s.as_bytes()),\n+            // If we're under the maximum width, check if we're over the minimum\n+            // width, if so it's as easy as just emitting the string.\n+            Some(width) if s.char_len() >= width => {\n+                self.buf.write(s.as_bytes())\n+            }\n+            // If we're under both the maximum and the minimum width, then fill\n+            // up the minimum width with the specified string + some alignment.\n+            Some(width) => {\n+                self.with_padding(width - s.len(), rt::AlignLeft, |me| {\n+                    me.buf.write(s.as_bytes())\n+                })\n+            }\n+        }\n+    }\n+\n+    /// Runs a callback, emitting the correct padding either before or\n+    /// afterwards depending on whether right or left alingment is requested.\n+    fn with_padding(&mut self,\n+                    padding: uint,\n+                    default: rt::Alignment,\n+                    f: |&mut Formatter| -> Result) -> Result {\n+        let align = match self.align {\n+            rt::AlignUnknown => default,\n+            rt::AlignLeft | rt::AlignRight => self.align\n+        };\n+        if align == rt::AlignLeft {\n+            try!(f(self));\n+        }\n+        let mut fill = [0u8, ..4];\n+        let len = self.fill.encode_utf8(fill);\n+        for _ in range(0, padding) {\n+            try!(self.buf.write(fill.slice_to(len)));\n+        }\n+        if align == rt::AlignRight {\n+            try!(f(self));\n+        }\n+        Ok(())\n+    }\n+\n+    /// Writes some data to the underlying buffer contained within this\n+    /// formatter.\n+    pub fn write(&mut self, data: &[u8]) -> Result {\n+        self.buf.write(data)\n+    }\n+\n+    /// Writes some formatted information into this instance\n+    pub fn write_fmt(&mut self, fmt: &Arguments) -> Result {\n+        write(self.buf, fmt)\n+    }\n+}\n+\n+/// This is a function which calls are emitted to by the compiler itself to\n+/// create the Argument structures that are passed into the `format` function.\n+#[doc(hidden)] #[inline]\n+pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter) -> Result,\n+                       t: &'a T) -> Argument<'a> {\n+    unsafe {\n+        Argument {\n+            formatter: mem::transmute(f),\n+            value: mem::transmute(t)\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+pub fn format(args: &Arguments) -> ~str {\n+    use str;\n+    use realstd::str::StrAllocating;\n+    use realstd::io::MemWriter;\n+\n+    fn mywrite<T: ::realstd::io::Writer>(t: &mut T, b: &[u8]) {\n+        use realstd::io::Writer;\n+        let _ = t.write(b);\n+    }\n+\n+    impl FormatWriter for MemWriter {\n+        fn write(&mut self, bytes: &[u8]) -> Result {\n+            mywrite(self, bytes);\n+            Ok(())\n+        }\n+    }\n+\n+    let mut i = MemWriter::new();\n+    let _ = write(&mut i, args);\n+    str::from_utf8(i.get_ref()).unwrap().to_owned()\n+}\n+\n+/// When the compiler determines that the type of an argument *must* be a string\n+/// (such as for select), then it invokes this method.\n+#[doc(hidden)] #[inline]\n+pub fn argumentstr<'a>(s: &'a &str) -> Argument<'a> {\n+    argument(secret_string, s)\n+}\n+\n+/// When the compiler determines that the type of an argument *must* be a uint\n+/// (such as for plural), then it invokes this method.\n+#[doc(hidden)] #[inline]\n+pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n+    argument(secret_unsigned, s)\n+}\n+\n+// Implementations of the core formatting traits\n+\n+impl<T: Show> Show for @T {\n+    fn fmt(&self, f: &mut Formatter) -> Result { secret_show(&**self, f) }\n+}\n+impl<'a, T: Show> Show for &'a T {\n+    fn fmt(&self, f: &mut Formatter) -> Result { secret_show(*self, f) }\n+}\n+impl<'a, T: Show> Show for &'a mut T {\n+    fn fmt(&self, f: &mut Formatter) -> Result { secret_show(&**self, f) }\n+}\n+\n+impl Bool for bool {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        secret_string(&(if *self {\"true\"} else {\"false\"}), f)\n+    }\n+}\n+\n+impl<'a, T: str::Str> String for T {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        f.pad(self.as_slice())\n+    }\n+}\n+\n+impl Char for char {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        let mut utf8 = [0u8, ..4];\n+        let amt = self.encode_utf8(utf8);\n+        let s: &str = unsafe { mem::transmute(utf8.slice_to(amt)) };\n+        secret_string(&s, f)\n+    }\n+}\n+\n+impl<T> Pointer for *T {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        f.flags |= 1 << (rt::FlagAlternate as uint);\n+        secret_lower_hex::<uint>(&(*self as uint), f)\n+    }\n+}\n+impl<T> Pointer for *mut T {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        secret_pointer::<*T>(&(*self as *T), f)\n+    }\n+}\n+impl<'a, T> Pointer for &'a T {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        secret_pointer::<*T>(&(&**self as *T), f)\n+    }\n+}\n+impl<'a, T> Pointer for &'a mut T {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        secret_pointer::<*T>(&(&**self as *T), f)\n+    }\n+}\n+\n+macro_rules! floating(($ty:ident) => {\n+    impl Float for $ty {\n+        fn fmt(&self, fmt: &mut Formatter) -> Result {\n+            use num::Signed;\n+\n+            let digits = match fmt.precision {\n+                Some(i) => float::DigExact(i),\n+                None => float::DigMax(6),\n+            };\n+            float::float_to_str_bytes_common(self.abs(),\n+                                             10,\n+                                             true,\n+                                             float::SignNeg,\n+                                             digits,\n+                                             float::ExpNone,\n+                                             false,\n+                                             |bytes| {\n+                fmt.pad_integral(*self >= 0.0, \"\", bytes)\n+            })\n+        }\n+    }\n+\n+    impl LowerExp for $ty {\n+        fn fmt(&self, fmt: &mut Formatter) -> Result {\n+            use num::Signed;\n+\n+            let digits = match fmt.precision {\n+                Some(i) => float::DigExact(i),\n+                None => float::DigMax(6),\n+            };\n+            float::float_to_str_bytes_common(self.abs(),\n+                                             10,\n+                                             true,\n+                                             float::SignNeg,\n+                                             digits,\n+                                             float::ExpDec,\n+                                             false,\n+                                             |bytes| {\n+                fmt.pad_integral(*self >= 0.0, \"\", bytes)\n+            })\n+        }\n+    }\n+\n+    impl UpperExp for $ty {\n+        fn fmt(&self, fmt: &mut Formatter) -> Result {\n+            use num::Signed;\n+\n+            let digits = match fmt.precision {\n+                Some(i) => float::DigExact(i),\n+                None => float::DigMax(6),\n+            };\n+            float::float_to_str_bytes_common(self.abs(),\n+                                             10,\n+                                             true,\n+                                             float::SignNeg,\n+                                             digits,\n+                                             float::ExpDec,\n+                                             true,\n+                                             |bytes| {\n+                fmt.pad_integral(*self >= 0.0, \"\", bytes)\n+            })\n+        }\n+    }\n+})\n+floating!(f32)\n+floating!(f64)\n+\n+// Implementation of Show for various core types\n+\n+macro_rules! delegate(($ty:ty to $other:ident) => {\n+    impl<'a> Show for $ty {\n+        fn fmt(&self, f: &mut Formatter) -> Result {\n+            (concat_idents!(secret_, $other)(self, f))\n+        }\n+    }\n+})\n+delegate!(~str to string)\n+delegate!(&'a str to string)\n+delegate!(bool to bool)\n+delegate!(char to char)\n+delegate!(f32 to float)\n+delegate!(f64 to float)\n+\n+impl<T> Show for *T {\n+    fn fmt(&self, f: &mut Formatter) -> Result { secret_pointer(self, f) }\n+}\n+impl<T> Show for *mut T {\n+    fn fmt(&self, f: &mut Formatter) -> Result { secret_pointer(self, f) }\n+}\n+\n+macro_rules! peel(($name:ident, $($other:ident,)*) => (tuple!($($other,)*)))\n+\n+macro_rules! tuple (\n+    () => ();\n+    ( $($name:ident,)+ ) => (\n+        impl<$($name:Show),*> Show for ($($name,)*) {\n+            #[allow(uppercase_variables, dead_assignment)]\n+            fn fmt(&self, f: &mut Formatter) -> Result {\n+                try!(write!(f, \"(\"));\n+                let ($(ref $name,)*) = *self;\n+                let mut n = 0;\n+                $(\n+                    if n > 0 {\n+                        try!(write!(f, \", \"));\n+                    }\n+                    try!(write!(f, \"{}\", *$name));\n+                    n += 1;\n+                )*\n+                if n == 1 {\n+                    try!(write!(f, \",\"));\n+                }\n+                write!(f, \")\")\n+            }\n+        }\n+        peel!($($name,)*)\n+    )\n+)\n+\n+tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n+\n+impl<'a> Show for &'a any::Any {\n+    fn fmt(&self, f: &mut Formatter) -> Result { f.pad(\"&Any\") }\n+}\n+\n+impl<'a, T: Show> Show for &'a [T] {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n+            try!(write!(f, \"[\"));\n+        }\n+        let mut is_first = true;\n+        for x in self.iter() {\n+            if is_first {\n+                is_first = false;\n+            } else {\n+                try!(write!(f, \", \"));\n+            }\n+            try!(write!(f, \"{}\", *x))\n+        }\n+        if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n+            try!(write!(f, \"]\"));\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl<'a, T: Show> Show for &'a mut [T] {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        secret_show(&self.as_slice(), f)\n+    }\n+}\n+\n+impl<T: Show> Show for ~[T] {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        secret_show(&self.as_slice(), f)\n+    }\n+}\n+\n+impl Show for () {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        f.pad(\"()\")\n+    }\n+}\n+\n+impl<T: Copy + Show> Show for Cell<T> {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        write!(f, r\"Cell \\{ value: {} \\}\", self.get())\n+    }\n+}\n+\n+// If you expected tests to be here, look instead at the run-pass/ifmt.rs test,\n+// it's a lot easier than creating all of the rt::Piece structures here."}, {"sha": "d9a327137812586759525a274962cb33347fde04", "filename": "src/libcore/fmt/num.rs", "status": "renamed", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -172,7 +172,7 @@ macro_rules! integer {\n         int_base!(Octal    for $Int as $Uint  -> Octal)\n         int_base!(LowerHex for $Int as $Uint  -> LowerHex)\n         int_base!(UpperHex for $Int as $Uint  -> UpperHex)\n-        radix_fmt!($Int as $Uint, fmt_int)\n+        radix_fmt!($Int as $Int, fmt_int)\n \n         int_base!(Show     for $Uint as $Uint -> Decimal)\n         int_base!(Unsigned for $Uint as $Uint -> Decimal)\n@@ -194,7 +194,7 @@ mod tests {\n     use fmt::radix;\n     use super::{Binary, Octal, Decimal, LowerHex, UpperHex};\n     use super::{GenericRadix, Radix};\n-    use str::StrAllocating;\n+    use realstd::str::StrAllocating;\n \n     #[test]\n     fn test_radix_base() {\n@@ -400,7 +400,6 @@ mod bench {\n         use super::test::Bencher;\n         use fmt::radix;\n         use rand::{XorShiftRng, Rng};\n-        use realstd::result::ResultUnwrap;\n \n         #[bench]\n         fn format_bin(b: &mut Bencher) {\n@@ -437,7 +436,6 @@ mod bench {\n         use super::test::Bencher;\n         use fmt::radix;\n         use rand::{XorShiftRng, Rng};\n-        use realstd::result::ResultUnwrap;\n \n         #[bench]\n         fn format_bin(b: &mut Bencher) {", "previous_filename": "src/libstd/fmt/num.rs"}, {"sha": "00c8661c8e3839c0a9c3386d6b37c264162364c4", "filename": "src/libcore/fmt/rt.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "previous_filename": "src/libstd/fmt/rt.rs"}, {"sha": "a5003a1458e119a7bf14776bcd52f13e1a16dc2f", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -471,7 +471,7 @@ extern \"rust-intrinsic\" {\n /// `TypeId` represents a globally unique identifier for a type\n #[lang=\"type_id\"] // This needs to be kept in lockstep with the code in trans/intrinsic.rs and\n                   // middle/lang_items.rs\n-#[deriving(Eq, TotalEq)]\n+#[deriving(Eq, TotalEq, Show)]\n #[cfg(not(test))]\n pub struct TypeId {\n     t: u64,"}, {"sha": "d40701860f46eb09ed85117e205ef3fe0fec0623", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 77, "deletions": 35, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -969,7 +969,7 @@ impl<A: TotalOrd, T: Iterator<A>> OrdIterator<A> for T {\n }\n \n /// `MinMaxResult` is an enum returned by `min_max`. See `OrdIterator::min_max` for more detail.\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, Eq, Show)]\n pub enum MinMaxResult<T> {\n     /// Empty iterator\n     NoElements,\n@@ -2329,19 +2329,48 @@ pub mod order {\n \n #[cfg(test)]\n mod tests {\n-    use realstd::prelude::*;\n-    use realstd::iter::*;\n-    use realstd::num;\n+    use prelude::*;\n+    use iter::*;\n+    use num;\n+    use realstd::vec::Vec;\n+    use realstd::slice::Vector;\n \n     use cmp;\n     use realstd::owned::Box;\n     use uint;\n \n+    impl<T> FromIterator<T> for Vec<T> {\n+        fn from_iter<I: Iterator<T>>(mut iterator: I) -> Vec<T> {\n+            let mut v = Vec::new();\n+            for e in iterator {\n+                v.push(e);\n+            }\n+            return v;\n+        }\n+    }\n+\n+    impl<'a, T> Iterator<&'a T> for ::realcore::slice::Items<'a, T> {\n+        fn next(&mut self) -> Option<&'a T> {\n+            use RealSome = realcore::option::Some;\n+            use RealNone = realcore::option::None;\n+            fn mynext<T, I: ::realcore::iter::Iterator<T>>(i: &mut I)\n+                -> ::realcore::option::Option<T>\n+            {\n+                use realcore::iter::Iterator;\n+                i.next()\n+            }\n+            match mynext(self) {\n+                RealSome(t) => Some(t),\n+                RealNone => None,\n+            }\n+        }\n+    }\n+\n     #[test]\n     fn test_counter_from_iter() {\n         let it = count(0, 5).take(10);\n         let xs: Vec<int> = FromIterator::from_iter(it);\n-        assert_eq!(xs, vec![0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n+        assert!(xs == vec![0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n     }\n \n     #[test]\n@@ -2371,7 +2400,7 @@ mod tests {\n     fn test_filter_map() {\n         let mut it = count(0u, 1u).take(10)\n             .filter_map(|x| if x % 2 == 0 { Some(x*x) } else { None });\n-        assert_eq!(it.collect::<Vec<uint>>(), vec![0*0, 2*2, 4*4, 6*6, 8*8]);\n+        assert!(it.collect::<Vec<uint>>() == vec![0*0, 2*2, 4*4, 6*6, 8*8]);\n     }\n \n     #[test]\n@@ -2630,7 +2659,7 @@ mod tests {\n     fn test_collect() {\n         let a = vec![1, 2, 3, 4, 5];\n         let b: Vec<int> = a.iter().map(|&x| x).collect();\n-        assert_eq!(a, b);\n+        assert!(a == b);\n     }\n \n     #[test]\n@@ -2702,7 +2731,8 @@ mod tests {\n         let mut it = xs.iter();\n         it.next();\n         it.next();\n-        assert_eq!(it.rev().map(|&x| x).collect::<Vec<int>>(), vec![16, 14, 12, 10, 8, 6]);\n+        assert!(it.rev().map(|&x| x).collect::<Vec<int>>() ==\n+                vec![16, 14, 12, 10, 8, 6]);\n     }\n \n     #[test]\n@@ -2940,12 +2970,12 @@ mod tests {\n \n     #[test]\n     fn test_double_ended_range() {\n-        assert_eq!(range(11i, 14).rev().collect::<Vec<int>>(), vec![13i, 12, 11]);\n+        assert!(range(11i, 14).rev().collect::<Vec<int>>() == vec![13i, 12, 11]);\n         for _ in range(10i, 0).rev() {\n             fail!(\"unreachable\");\n         }\n \n-        assert_eq!(range(11u, 14).rev().collect::<Vec<uint>>(), vec![13u, 12, 11]);\n+        assert!(range(11u, 14).rev().collect::<Vec<uint>>() == vec![13u, 12, 11]);\n         for _ in range(10u, 0).rev() {\n             fail!(\"unreachable\");\n         }\n@@ -2997,14 +3027,14 @@ mod tests {\n             }\n         }\n \n-        assert_eq!(range(0i, 5).collect::<Vec<int>>(), vec![0i, 1, 2, 3, 4]);\n-        assert_eq!(range(-10i, -1).collect::<Vec<int>>(),\n+        assert!(range(0i, 5).collect::<Vec<int>>() == vec![0i, 1, 2, 3, 4]);\n+        assert!(range(-10i, -1).collect::<Vec<int>>() ==\n                    vec![-10, -9, -8, -7, -6, -5, -4, -3, -2]);\n-        assert_eq!(range(0i, 5).rev().collect::<Vec<int>>(), vec![4, 3, 2, 1, 0]);\n-        assert_eq!(range(200, -5).collect::<Vec<int>>(), vec![]);\n-        assert_eq!(range(200, -5).rev().collect::<Vec<int>>(), vec![]);\n-        assert_eq!(range(200, 200).collect::<Vec<int>>(), vec![]);\n-        assert_eq!(range(200, 200).rev().collect::<Vec<int>>(), vec![]);\n+        assert!(range(0i, 5).rev().collect::<Vec<int>>() == vec![4, 3, 2, 1, 0]);\n+        assert_eq!(range(200, -5).len(), 0);\n+        assert_eq!(range(200, -5).rev().len(), 0);\n+        assert_eq!(range(200, 200).len(), 0);\n+        assert_eq!(range(200, 200).rev().len(), 0);\n \n         assert_eq!(range(0i, 100).size_hint(), (100, Some(100)));\n         // this test is only meaningful when sizeof uint < sizeof u64\n@@ -3015,32 +3045,44 @@ mod tests {\n \n     #[test]\n     fn test_range_inclusive() {\n-        assert_eq!(range_inclusive(0i, 5).collect::<Vec<int>>(), vec![0i, 1, 2, 3, 4, 5]);\n-        assert_eq!(range_inclusive(0i, 5).rev().collect::<Vec<int>>(), vec![5i, 4, 3, 2, 1, 0]);\n-        assert_eq!(range_inclusive(200, -5).collect::<Vec<int>>(), vec![]);\n-        assert_eq!(range_inclusive(200, -5).rev().collect::<Vec<int>>(), vec![]);\n-        assert_eq!(range_inclusive(200, 200).collect::<Vec<int>>(), vec![200]);\n-        assert_eq!(range_inclusive(200, 200).rev().collect::<Vec<int>>(), vec![200]);\n+        assert!(range_inclusive(0i, 5).collect::<Vec<int>>() ==\n+                vec![0i, 1, 2, 3, 4, 5]);\n+        assert!(range_inclusive(0i, 5).rev().collect::<Vec<int>>() ==\n+                vec![5i, 4, 3, 2, 1, 0]);\n+        assert_eq!(range_inclusive(200, -5).len(), 0);\n+        assert_eq!(range_inclusive(200, -5).rev().len(), 0);\n+        assert!(range_inclusive(200, 200).collect::<Vec<int>>() == vec![200]);\n+        assert!(range_inclusive(200, 200).rev().collect::<Vec<int>>() == vec![200]);\n     }\n \n     #[test]\n     fn test_range_step() {\n-        assert_eq!(range_step(0i, 20, 5).collect::<Vec<int>>(), vec![0, 5, 10, 15]);\n-        assert_eq!(range_step(20i, 0, -5).collect::<Vec<int>>(), vec![20, 15, 10, 5]);\n-        assert_eq!(range_step(20i, 0, -6).collect::<Vec<int>>(), vec![20, 14, 8, 2]);\n-        assert_eq!(range_step(200u8, 255, 50).collect::<Vec<u8>>(), vec![200u8, 250]);\n-        assert_eq!(range_step(200, -5, 1).collect::<Vec<int>>(), vec![]);\n-        assert_eq!(range_step(200, 200, 1).collect::<Vec<int>>(), vec![]);\n+        assert!(range_step(0i, 20, 5).collect::<Vec<int>>() ==\n+                vec![0, 5, 10, 15]);\n+        assert!(range_step(20i, 0, -5).collect::<Vec<int>>() ==\n+                vec![20, 15, 10, 5]);\n+        assert!(range_step(20i, 0, -6).collect::<Vec<int>>() ==\n+                vec![20, 14, 8, 2]);\n+        assert!(range_step(200u8, 255, 50).collect::<Vec<u8>>() ==\n+                vec![200u8, 250]);\n+        assert!(range_step(200, -5, 1).collect::<Vec<int>>() == vec![]);\n+        assert!(range_step(200, 200, 1).collect::<Vec<int>>() == vec![]);\n     }\n \n     #[test]\n     fn test_range_step_inclusive() {\n-        assert_eq!(range_step_inclusive(0i, 20, 5).collect::<Vec<int>>(), vec![0, 5, 10, 15, 20]);\n-        assert_eq!(range_step_inclusive(20i, 0, -5).collect::<Vec<int>>(), vec![20, 15, 10, 5, 0]);\n-        assert_eq!(range_step_inclusive(20i, 0, -6).collect::<Vec<int>>(), vec![20, 14, 8, 2]);\n-        assert_eq!(range_step_inclusive(200u8, 255, 50).collect::<Vec<u8>>(), vec![200u8, 250]);\n-        assert_eq!(range_step_inclusive(200, -5, 1).collect::<Vec<int>>(), vec![]);\n-        assert_eq!(range_step_inclusive(200, 200, 1).collect::<Vec<int>>(), vec![200]);\n+        assert!(range_step_inclusive(0i, 20, 5).collect::<Vec<int>>() ==\n+                vec![0, 5, 10, 15, 20]);\n+        assert!(range_step_inclusive(20i, 0, -5).collect::<Vec<int>>() ==\n+                vec![20, 15, 10, 5, 0]);\n+        assert!(range_step_inclusive(20i, 0, -6).collect::<Vec<int>>() ==\n+                vec![20, 14, 8, 2]);\n+        assert!(range_step_inclusive(200u8, 255, 50).collect::<Vec<u8>>() ==\n+                vec![200u8, 250]);\n+        assert!(range_step_inclusive(200, -5, 1).collect::<Vec<int>>() ==\n+                vec![]);\n+        assert!(range_step_inclusive(200, 200, 1).collect::<Vec<int>>() ==\n+                vec![200]);\n     }\n \n     #[test]"}, {"sha": "05b314b6998478a998fad6e2fc6b947cb5474ec0", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -11,7 +11,7 @@\n //! The Rust core library\n //!\n //! This library is meant to represent the core functionality of rust that is\n-//! maximally portable to other platforms. To that exent, this library has no\n+//! maximally portable to other platforms. To that extent, this library has no\n //! knowledge of things like allocation, threads, I/O, etc. This library is\n //! built on the assumption of a few existing symbols:\n //!\n@@ -48,15 +48,14 @@\n #[cfg(test)] extern crate realcore = \"core\";\n #[cfg(test)] extern crate libc;\n #[cfg(test)] extern crate native;\n-#[phase(syntax, link)] #[cfg(test)] extern crate realstd = \"std\";\n-#[phase(syntax, link)] #[cfg(test)] extern crate log;\n+#[cfg(test)] extern crate rand;\n+#[cfg(test)] extern crate realstd = \"std\";\n \n #[cfg(test)] pub use cmp = realcore::cmp;\n #[cfg(test)] pub use kinds = realcore::kinds;\n #[cfg(test)] pub use ops = realcore::ops;\n #[cfg(test)] pub use ty = realcore::ty;\n \n-#[cfg(not(test))]\n mod macros;\n \n #[path = \"num/float_macros.rs\"] mod float_macros;\n@@ -117,6 +116,7 @@ pub mod result;\n pub mod slice;\n pub mod str;\n pub mod tuple;\n+pub mod fmt;\n \n // FIXME: this module should not exist. Once owned allocations are no longer a\n //        language type, this module can move outside to the owned allocation\n@@ -131,10 +131,12 @@ mod std {\n     pub use clone;\n     pub use cmp;\n     pub use kinds;\n+    pub use option;\n+    pub use fmt;\n \n-    #[cfg(test)] pub use realstd::fmt;    // needed for fail!()\n     #[cfg(test)] pub use realstd::rt;     // needed for fail!()\n-    #[cfg(test)] pub use realstd::option; // needed for assert!()\n+    // #[cfg(test)] pub use realstd::option; // needed for fail!()\n+    // #[cfg(test)] pub use realstd::fmt;    // needed for fail!()\n     #[cfg(test)] pub use realstd::os;     // needed for tests\n     #[cfg(test)] pub use realstd::slice;  // needed for tests\n     #[cfg(test)] pub use realstd::vec;    // needed for vec![]"}, {"sha": "6474c5e37a44b46cb6930a35fef275ee3f085526", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 52, "deletions": 2, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -14,11 +14,29 @@\n #[macro_export]\n macro_rules! fail(\n     () => (\n-        fail!(\"explicit failure\")\n+        fail!(\"{}\", \"explicit failure\")\n     );\n     ($msg:expr) => (\n-        ::core::failure::begin_unwind($msg, file!(), line!())\n+        fail!(\"{}\", $msg)\n     );\n+    ($fmt:expr, $($arg:tt)*) => ({\n+        // a closure can't have return type !, so we need a full\n+        // function to pass to format_args!, *and* we need the\n+        // file and line numbers right here; so an inner bare fn\n+        // is our only choice.\n+        //\n+        // LLVM doesn't tend to inline this, presumably because begin_unwind_fmt\n+        // is #[cold] and #[inline(never)] and because this is flagged as cold\n+        // as returning !. We really do want this to be inlined, however,\n+        // because it's just a tiny wrapper. Small wins (156K to 149K in size)\n+        // were seen when forcing this to be inlined, and that number just goes\n+        // up with the number of calls to fail!()\n+        #[inline(always)]\n+        fn run_fmt(fmt: &::std::fmt::Arguments) -> ! {\n+            ::core::failure::begin_unwind(fmt, file!(), line!())\n+        }\n+        format_args!(run_fmt, $fmt, $($arg)*)\n+    });\n )\n \n /// Runtime assertion, for details see std::macros\n@@ -29,10 +47,42 @@ macro_rules! assert(\n             fail!(concat!(\"assertion failed: \", stringify!($cond)))\n         }\n     );\n+    ($cond:expr, $($arg:tt)*) => (\n+        if !$cond {\n+            fail!($($arg)*)\n+        }\n+    );\n+)\n+\n+/// Runtime assertion for equality, for details see std::macros\n+macro_rules! assert_eq(\n+    ($cond1:expr, $cond2:expr) => ({\n+        let c1 = $cond1;\n+        let c2 = $cond2;\n+        if c1 != c2 || c2 != c1 {\n+            fail!(\"expressions not equal, left: {}, right: {}\", c1, c2);\n+        }\n+    })\n )\n \n /// Runtime assertion, disableable at compile time\n #[macro_export]\n macro_rules! debug_assert(\n     ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert!($($arg)*); })\n )\n+\n+/// Short circuiting evaluation on Err\n+#[macro_export]\n+macro_rules! try(\n+    ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n+)\n+\n+#[cfg(test)]\n+macro_rules! vec( ($($e:expr),*) => ({\n+    let mut _v = ::std::vec::Vec::new();\n+    $(_v.push($e);)*\n+    _v\n+}) )\n+\n+#[cfg(test)]\n+macro_rules! format( ($($arg:tt)*) => (format_args!(::fmt::format, $($arg)*)) )"}, {"sha": "694f3e9fbd1f90ee2292975927d140421c4009a3", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 271, "deletions": 1, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -12,7 +12,10 @@\n \n use default::Default;\n use intrinsics;\n-use num::{Zero, One, Bounded, Signed, Num, Primitive};\n+use mem;\n+use num::{FPNormal, FPCategory, FPZero, FPSubnormal, FPInfinite, FPNaN};\n+use num::{Zero, One, Bounded, Signed, Num, Primitive, Float};\n+use option::Option;\n \n #[cfg(not(test))] use cmp::{Eq, Ord};\n #[cfg(not(test))] use ops::{Add, Sub, Mul, Div, Rem, Neg};\n@@ -225,3 +228,270 @@ impl Bounded for f32 {\n     #[inline]\n     fn max_value() -> f32 { MAX_VALUE }\n }\n+\n+impl Float for f32 {\n+    #[inline]\n+    fn nan() -> f32 { NAN }\n+\n+    #[inline]\n+    fn infinity() -> f32 { INFINITY }\n+\n+    #[inline]\n+    fn neg_infinity() -> f32 { NEG_INFINITY }\n+\n+    #[inline]\n+    fn neg_zero() -> f32 { -0.0 }\n+\n+    /// Returns `true` if the number is NaN\n+    #[inline]\n+    fn is_nan(self) -> bool { self != self }\n+\n+    /// Returns `true` if the number is infinite\n+    #[inline]\n+    fn is_infinite(self) -> bool {\n+        self == Float::infinity() || self == Float::neg_infinity()\n+    }\n+\n+    /// Returns `true` if the number is neither infinite or NaN\n+    #[inline]\n+    fn is_finite(self) -> bool {\n+        !(self.is_nan() || self.is_infinite())\n+    }\n+\n+    /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n+    #[inline]\n+    fn is_normal(self) -> bool {\n+        self.classify() == FPNormal\n+    }\n+\n+    /// Returns the floating point category of the number. If only one property\n+    /// is going to be tested, it is generally faster to use the specific\n+    /// predicate instead.\n+    fn classify(self) -> FPCategory {\n+        static EXP_MASK: u32 = 0x7f800000;\n+        static MAN_MASK: u32 = 0x007fffff;\n+\n+        let bits: u32 = unsafe { mem::transmute(self) };\n+        match (bits & MAN_MASK, bits & EXP_MASK) {\n+            (0, 0)        => FPZero,\n+            (_, 0)        => FPSubnormal,\n+            (0, EXP_MASK) => FPInfinite,\n+            (_, EXP_MASK) => FPNaN,\n+            _             => FPNormal,\n+        }\n+    }\n+\n+    #[inline]\n+    fn mantissa_digits(_: Option<f32>) -> uint { MANTISSA_DIGITS }\n+\n+    #[inline]\n+    fn digits(_: Option<f32>) -> uint { DIGITS }\n+\n+    #[inline]\n+    fn epsilon() -> f32 { EPSILON }\n+\n+    #[inline]\n+    fn min_exp(_: Option<f32>) -> int { MIN_EXP }\n+\n+    #[inline]\n+    fn max_exp(_: Option<f32>) -> int { MAX_EXP }\n+\n+    #[inline]\n+    fn min_10_exp(_: Option<f32>) -> int { MIN_10_EXP }\n+\n+    #[inline]\n+    fn max_10_exp(_: Option<f32>) -> int { MAX_10_EXP }\n+\n+    #[inline]\n+    fn min_pos_value(_: Option<f32>) -> f32 { MIN_POS_VALUE }\n+\n+    /// Returns the mantissa, exponent and sign as integers.\n+    fn integer_decode(self) -> (u64, i16, i8) {\n+        let bits: u32 = unsafe { mem::transmute(self) };\n+        let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };\n+        let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;\n+        let mantissa = if exponent == 0 {\n+            (bits & 0x7fffff) << 1\n+        } else {\n+            (bits & 0x7fffff) | 0x800000\n+        };\n+        // Exponent bias + mantissa shift\n+        exponent -= 127 + 23;\n+        (mantissa as u64, exponent, sign)\n+    }\n+\n+    /// Round half-way cases toward `NEG_INFINITY`\n+    #[inline]\n+    fn floor(self) -> f32 {\n+        unsafe { intrinsics::floorf32(self) }\n+    }\n+\n+    /// Round half-way cases toward `INFINITY`\n+    #[inline]\n+    fn ceil(self) -> f32 {\n+        unsafe { intrinsics::ceilf32(self) }\n+    }\n+\n+    /// Round half-way cases away from `0.0`\n+    #[inline]\n+    fn round(self) -> f32 {\n+        unsafe { intrinsics::roundf32(self) }\n+    }\n+\n+    /// The integer part of the number (rounds towards `0.0`)\n+    #[inline]\n+    fn trunc(self) -> f32 {\n+        unsafe { intrinsics::truncf32(self) }\n+    }\n+\n+    /// The fractional part of the number, satisfying:\n+    ///\n+    /// ```rust\n+    /// let x = 1.65f32;\n+    /// assert!(x == x.trunc() + x.fract())\n+    /// ```\n+    #[inline]\n+    fn fract(self) -> f32 { self - self.trunc() }\n+\n+    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n+    /// error. This produces a more accurate result with better performance than\n+    /// a separate multiplication operation followed by an add.\n+    #[inline]\n+    fn mul_add(self, a: f32, b: f32) -> f32 {\n+        unsafe { intrinsics::fmaf32(self, a, b) }\n+    }\n+\n+    /// The reciprocal (multiplicative inverse) of the number\n+    #[inline]\n+    fn recip(self) -> f32 { 1.0 / self }\n+\n+    fn powi(self, n: i32) -> f32 {\n+        unsafe { intrinsics::powif32(self, n) }\n+    }\n+\n+    #[inline]\n+    fn powf(self, n: f32) -> f32 {\n+        unsafe { intrinsics::powf32(self, n) }\n+    }\n+\n+    /// sqrt(2.0)\n+    #[inline]\n+    fn sqrt2() -> f32 { consts::SQRT2 }\n+\n+    /// 1.0 / sqrt(2.0)\n+    #[inline]\n+    fn frac_1_sqrt2() -> f32 { consts::FRAC_1_SQRT2 }\n+\n+    #[inline]\n+    fn sqrt(self) -> f32 {\n+        unsafe { intrinsics::sqrtf32(self) }\n+    }\n+\n+    #[inline]\n+    fn rsqrt(self) -> f32 { self.sqrt().recip() }\n+\n+    /// Archimedes' constant\n+    #[inline]\n+    fn pi() -> f32 { consts::PI }\n+\n+    /// 2.0 * pi\n+    #[inline]\n+    fn two_pi() -> f32 { consts::PI_2 }\n+\n+    /// pi / 2.0\n+    #[inline]\n+    fn frac_pi_2() -> f32 { consts::FRAC_PI_2 }\n+\n+    /// pi / 3.0\n+    #[inline]\n+    fn frac_pi_3() -> f32 { consts::FRAC_PI_3 }\n+\n+    /// pi / 4.0\n+    #[inline]\n+    fn frac_pi_4() -> f32 { consts::FRAC_PI_4 }\n+\n+    /// pi / 6.0\n+    #[inline]\n+    fn frac_pi_6() -> f32 { consts::FRAC_PI_6 }\n+\n+    /// pi / 8.0\n+    #[inline]\n+    fn frac_pi_8() -> f32 { consts::FRAC_PI_8 }\n+\n+    /// 1 .0/ pi\n+    #[inline]\n+    fn frac_1_pi() -> f32 { consts::FRAC_1_PI }\n+\n+    /// 2.0 / pi\n+    #[inline]\n+    fn frac_2_pi() -> f32 { consts::FRAC_2_PI }\n+\n+    /// 2.0 / sqrt(pi)\n+    #[inline]\n+    fn frac_2_sqrtpi() -> f32 { consts::FRAC_2_SQRTPI }\n+\n+    /// Euler's number\n+    #[inline]\n+    fn e() -> f32 { consts::E }\n+\n+    /// log2(e)\n+    #[inline]\n+    fn log2_e() -> f32 { consts::LOG2_E }\n+\n+    /// log10(e)\n+    #[inline]\n+    fn log10_e() -> f32 { consts::LOG10_E }\n+\n+    /// ln(2.0)\n+    #[inline]\n+    fn ln_2() -> f32 { consts::LN_2 }\n+\n+    /// ln(10.0)\n+    #[inline]\n+    fn ln_10() -> f32 { consts::LN_10 }\n+\n+    /// Returns the exponential of the number\n+    #[inline]\n+    fn exp(self) -> f32 {\n+        unsafe { intrinsics::expf32(self) }\n+    }\n+\n+    /// Returns 2 raised to the power of the number\n+    #[inline]\n+    fn exp2(self) -> f32 {\n+        unsafe { intrinsics::exp2f32(self) }\n+    }\n+\n+    /// Returns the natural logarithm of the number\n+    #[inline]\n+    fn ln(self) -> f32 {\n+        unsafe { intrinsics::logf32(self) }\n+    }\n+\n+    /// Returns the logarithm of the number with respect to an arbitrary base\n+    #[inline]\n+    fn log(self, base: f32) -> f32 { self.ln() / base.ln() }\n+\n+    /// Returns the base 2 logarithm of the number\n+    #[inline]\n+    fn log2(self) -> f32 {\n+        unsafe { intrinsics::log2f32(self) }\n+    }\n+\n+    /// Returns the base 10 logarithm of the number\n+    #[inline]\n+    fn log10(self) -> f32 {\n+        unsafe { intrinsics::log10f32(self) }\n+    }\n+\n+    /// Converts to degrees, assuming the number is in radians\n+    #[inline]\n+    fn to_degrees(self) -> f32 { self * (180.0f32 / Float::pi()) }\n+\n+    /// Converts to radians, assuming the number is in degrees\n+    #[inline]\n+    fn to_radians(self) -> f32 {\n+        let value: f32 = Float::pi();\n+        self * (value / 180.0f32)\n+    }\n+}"}, {"sha": "2c802f5d059f1f3dcb7226321f0142a887b16396", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 274, "deletions": 1, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -12,7 +12,10 @@\n \n use default::Default;\n use intrinsics;\n-use num::{Zero, One, Bounded, Signed, Num, Primitive};\n+use mem;\n+use num::{FPNormal, FPCategory, FPZero, FPSubnormal, FPInfinite, FPNaN};\n+use num::{Zero, One, Bounded, Signed, Num, Primitive, Float};\n+use option::Option;\n \n #[cfg(not(test))] use cmp::{Eq, Ord};\n #[cfg(not(test))] use ops::{Add, Sub, Mul, Div, Rem, Neg};\n@@ -225,3 +228,273 @@ impl Bounded for f64 {\n     #[inline]\n     fn max_value() -> f64 { MAX_VALUE }\n }\n+\n+impl Float for f64 {\n+    #[inline]\n+    fn nan() -> f64 { NAN }\n+\n+    #[inline]\n+    fn infinity() -> f64 { INFINITY }\n+\n+    #[inline]\n+    fn neg_infinity() -> f64 { NEG_INFINITY }\n+\n+    #[inline]\n+    fn neg_zero() -> f64 { -0.0 }\n+\n+    /// Returns `true` if the number is NaN\n+    #[inline]\n+    fn is_nan(self) -> bool { self != self }\n+\n+    /// Returns `true` if the number is infinite\n+    #[inline]\n+    fn is_infinite(self) -> bool {\n+        self == Float::infinity() || self == Float::neg_infinity()\n+    }\n+\n+    /// Returns `true` if the number is neither infinite or NaN\n+    #[inline]\n+    fn is_finite(self) -> bool {\n+        !(self.is_nan() || self.is_infinite())\n+    }\n+\n+    /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n+    #[inline]\n+    fn is_normal(self) -> bool {\n+        self.classify() == FPNormal\n+    }\n+\n+    /// Returns the floating point category of the number. If only one property\n+    /// is going to be tested, it is generally faster to use the specific\n+    /// predicate instead.\n+    fn classify(self) -> FPCategory {\n+        static EXP_MASK: u64 = 0x7ff0000000000000;\n+        static MAN_MASK: u64 = 0x000fffffffffffff;\n+\n+        let bits: u64 = unsafe { mem::transmute(self) };\n+        match (bits & MAN_MASK, bits & EXP_MASK) {\n+            (0, 0)        => FPZero,\n+            (_, 0)        => FPSubnormal,\n+            (0, EXP_MASK) => FPInfinite,\n+            (_, EXP_MASK) => FPNaN,\n+            _             => FPNormal,\n+        }\n+    }\n+\n+    #[inline]\n+    fn mantissa_digits(_: Option<f64>) -> uint { MANTISSA_DIGITS }\n+\n+    #[inline]\n+    fn digits(_: Option<f64>) -> uint { DIGITS }\n+\n+    #[inline]\n+    fn epsilon() -> f64 { EPSILON }\n+\n+    #[inline]\n+    fn min_exp(_: Option<f64>) -> int { MIN_EXP }\n+\n+    #[inline]\n+    fn max_exp(_: Option<f64>) -> int { MAX_EXP }\n+\n+    #[inline]\n+    fn min_10_exp(_: Option<f64>) -> int { MIN_10_EXP }\n+\n+    #[inline]\n+    fn max_10_exp(_: Option<f64>) -> int { MAX_10_EXP }\n+\n+    #[inline]\n+    fn min_pos_value(_: Option<f64>) -> f64 { MIN_POS_VALUE }\n+\n+    /// Returns the mantissa, exponent and sign as integers.\n+    fn integer_decode(self) -> (u64, i16, i8) {\n+        let bits: u64 = unsafe { mem::transmute(self) };\n+        let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };\n+        let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;\n+        let mantissa = if exponent == 0 {\n+            (bits & 0xfffffffffffff) << 1\n+        } else {\n+            (bits & 0xfffffffffffff) | 0x10000000000000\n+        };\n+        // Exponent bias + mantissa shift\n+        exponent -= 1023 + 52;\n+        (mantissa, exponent, sign)\n+    }\n+\n+    /// Round half-way cases toward `NEG_INFINITY`\n+    #[inline]\n+    fn floor(self) -> f64 {\n+        unsafe { intrinsics::floorf64(self) }\n+    }\n+\n+    /// Round half-way cases toward `INFINITY`\n+    #[inline]\n+    fn ceil(self) -> f64 {\n+        unsafe { intrinsics::ceilf64(self) }\n+    }\n+\n+    /// Round half-way cases away from `0.0`\n+    #[inline]\n+    fn round(self) -> f64 {\n+        unsafe { intrinsics::roundf64(self) }\n+    }\n+\n+    /// The integer part of the number (rounds towards `0.0`)\n+    #[inline]\n+    fn trunc(self) -> f64 {\n+        unsafe { intrinsics::truncf64(self) }\n+    }\n+\n+    /// The fractional part of the number, satisfying:\n+    ///\n+    /// ```rust\n+    /// let x = 1.65f64;\n+    /// assert!(x == x.trunc() + x.fract())\n+    /// ```\n+    #[inline]\n+    fn fract(self) -> f64 { self - self.trunc() }\n+\n+    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n+    /// error. This produces a more accurate result with better performance than\n+    /// a separate multiplication operation followed by an add.\n+    #[inline]\n+    fn mul_add(self, a: f64, b: f64) -> f64 {\n+        unsafe { intrinsics::fmaf64(self, a, b) }\n+    }\n+\n+    /// The reciprocal (multiplicative inverse) of the number\n+    #[inline]\n+    fn recip(self) -> f64 { 1.0 / self }\n+\n+    #[inline]\n+    fn powf(self, n: f64) -> f64 {\n+        unsafe { intrinsics::powf64(self, n) }\n+    }\n+\n+    #[inline]\n+    fn powi(self, n: i32) -> f64 {\n+        unsafe { intrinsics::powif64(self, n) }\n+    }\n+\n+    /// sqrt(2.0)\n+    #[inline]\n+    fn sqrt2() -> f64 { consts::SQRT2 }\n+\n+    /// 1.0 / sqrt(2.0)\n+    #[inline]\n+    fn frac_1_sqrt2() -> f64 { consts::FRAC_1_SQRT2 }\n+\n+    #[inline]\n+    fn sqrt(self) -> f64 {\n+        unsafe { intrinsics::sqrtf64(self) }\n+    }\n+\n+    #[inline]\n+    fn rsqrt(self) -> f64 { self.sqrt().recip() }\n+\n+    /// Archimedes' constant\n+    #[inline]\n+    fn pi() -> f64 { consts::PI }\n+\n+    /// 2.0 * pi\n+    #[inline]\n+    fn two_pi() -> f64 { consts::PI_2 }\n+\n+    /// pi / 2.0\n+    #[inline]\n+    fn frac_pi_2() -> f64 { consts::FRAC_PI_2 }\n+\n+    /// pi / 3.0\n+    #[inline]\n+    fn frac_pi_3() -> f64 { consts::FRAC_PI_3 }\n+\n+    /// pi / 4.0\n+    #[inline]\n+    fn frac_pi_4() -> f64 { consts::FRAC_PI_4 }\n+\n+    /// pi / 6.0\n+    #[inline]\n+    fn frac_pi_6() -> f64 { consts::FRAC_PI_6 }\n+\n+    /// pi / 8.0\n+    #[inline]\n+    fn frac_pi_8() -> f64 { consts::FRAC_PI_8 }\n+\n+    /// 1.0 / pi\n+    #[inline]\n+    fn frac_1_pi() -> f64 { consts::FRAC_1_PI }\n+\n+    /// 2.0 / pi\n+    #[inline]\n+    fn frac_2_pi() -> f64 { consts::FRAC_2_PI }\n+\n+    /// 2.0 / sqrt(pi)\n+    #[inline]\n+    fn frac_2_sqrtpi() -> f64 { consts::FRAC_2_SQRTPI }\n+\n+    /// Euler's number\n+    #[inline]\n+    fn e() -> f64 { consts::E }\n+\n+    /// log2(e)\n+    #[inline]\n+    fn log2_e() -> f64 { consts::LOG2_E }\n+\n+    /// log10(e)\n+    #[inline]\n+    fn log10_e() -> f64 { consts::LOG10_E }\n+\n+    /// ln(2.0)\n+    #[inline]\n+    fn ln_2() -> f64 { consts::LN_2 }\n+\n+    /// ln(10.0)\n+    #[inline]\n+    fn ln_10() -> f64 { consts::LN_10 }\n+\n+    /// Returns the exponential of the number\n+    #[inline]\n+    fn exp(self) -> f64 {\n+        unsafe { intrinsics::expf64(self) }\n+    }\n+\n+    /// Returns 2 raised to the power of the number\n+    #[inline]\n+    fn exp2(self) -> f64 {\n+        unsafe { intrinsics::exp2f64(self) }\n+    }\n+\n+    /// Returns the natural logarithm of the number\n+    #[inline]\n+    fn ln(self) -> f64 {\n+        unsafe { intrinsics::logf64(self) }\n+    }\n+\n+    /// Returns the logarithm of the number with respect to an arbitrary base\n+    #[inline]\n+    fn log(self, base: f64) -> f64 { self.ln() / base.ln() }\n+\n+    /// Returns the base 2 logarithm of the number\n+    #[inline]\n+    fn log2(self) -> f64 {\n+        unsafe { intrinsics::log2f64(self) }\n+    }\n+\n+    /// Returns the base 10 logarithm of the number\n+    #[inline]\n+    fn log10(self) -> f64 {\n+        unsafe { intrinsics::log10f64(self) }\n+    }\n+\n+\n+    /// Converts to degrees, assuming the number is in radians\n+    #[inline]\n+    fn to_degrees(self) -> f64 { self * (180.0f64 / Float::pi()) }\n+\n+    /// Converts to radians, assuming the number is in degrees\n+    #[inline]\n+    fn to_radians(self) -> f64 {\n+        let value: f64 = Float::pi();\n+        self * (value / 180.0)\n+    }\n+}\n+"}, {"sha": "47be5df67eabdb345c963e9cc58ccd9dfcaf8c39", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -874,3 +874,157 @@ pub fn test_num<T:Num + NumCast + ::std::fmt::Show>(ten: T, two: T) {\n     assert_eq!(ten.div(&two),  ten / two);\n     assert_eq!(ten.rem(&two),  ten % two);\n }\n+\n+/// Used for representing the classification of floating point numbers\n+#[deriving(Eq, Show)]\n+pub enum FPCategory {\n+    /// \"Not a Number\", often obtained by dividing by zero\n+    FPNaN,\n+    /// Positive or negative infinity\n+    FPInfinite ,\n+    /// Positive or negative zero\n+    FPZero,\n+    /// De-normalized floating point representation (less precise than `FPNormal`)\n+    FPSubnormal,\n+    /// A regular floating point number\n+    FPNormal,\n+}\n+\n+/// Operations on primitive floating point numbers.\n+// FIXME(#5527): In a future version of Rust, many of these functions will\n+//               become constants.\n+//\n+// FIXME(#8888): Several of these functions have a parameter named\n+//               `unused_self`. Removing it requires #8888 to be fixed.\n+pub trait Float: Signed + Primitive {\n+    /// Returns the NaN value.\n+    fn nan() -> Self;\n+    /// Returns the infinite value.\n+    fn infinity() -> Self;\n+    /// Returns the negative infinite value.\n+    fn neg_infinity() -> Self;\n+    /// Returns -0.0.\n+    fn neg_zero() -> Self;\n+\n+    /// Returns true if this value is NaN and false otherwise.\n+    fn is_nan(self) -> bool;\n+    /// Returns true if this value is positive infinity or negative infinity and\n+    /// false otherwise.\n+    fn is_infinite(self) -> bool;\n+    /// Returns true if this number is neither infinite nor NaN.\n+    fn is_finite(self) -> bool;\n+    /// Returns true if this number is neither zero, infinite, denormal, or NaN.\n+    fn is_normal(self) -> bool;\n+    /// Returns the category that this number falls into.\n+    fn classify(self) -> FPCategory;\n+\n+    // FIXME (#5527): These should be associated constants\n+\n+    /// Returns the number of binary digits of mantissa that this type supports.\n+    fn mantissa_digits(unused_self: Option<Self>) -> uint;\n+    /// Returns the number of base-10 digits of precision that this type supports.\n+    fn digits(unused_self: Option<Self>) -> uint;\n+    /// Returns the difference between 1.0 and the smallest representable number larger than 1.0.\n+    fn epsilon() -> Self;\n+    /// Returns the minimum binary exponent that this type can represent.\n+    fn min_exp(unused_self: Option<Self>) -> int;\n+    /// Returns the maximum binary exponent that this type can represent.\n+    fn max_exp(unused_self: Option<Self>) -> int;\n+    /// Returns the minimum base-10 exponent that this type can represent.\n+    fn min_10_exp(unused_self: Option<Self>) -> int;\n+    /// Returns the maximum base-10 exponent that this type can represent.\n+    fn max_10_exp(unused_self: Option<Self>) -> int;\n+    /// Returns the smallest normalized positive number that this type can represent.\n+    fn min_pos_value(unused_self: Option<Self>) -> Self;\n+\n+    /// Returns the mantissa, exponent and sign as integers, respectively.\n+    fn integer_decode(self) -> (u64, i16, i8);\n+\n+    /// Return the largest integer less than or equal to a number.\n+    fn floor(self) -> Self;\n+    /// Return the smallest integer greater than or equal to a number.\n+    fn ceil(self) -> Self;\n+    /// Return the nearest integer to a number. Round half-way cases away from\n+    /// `0.0`.\n+    fn round(self) -> Self;\n+    /// Return the integer part of a number.\n+    fn trunc(self) -> Self;\n+    /// Return the fractional part of a number.\n+    fn fract(self) -> Self;\n+\n+    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n+    /// error. This produces a more accurate result with better performance than\n+    /// a separate multiplication operation followed by an add.\n+    fn mul_add(self, a: Self, b: Self) -> Self;\n+    /// Take the reciprocal (inverse) of a number, `1/x`.\n+    fn recip(self) -> Self;\n+\n+    /// Raise a number to an integer power.\n+    ///\n+    /// Using this function is generally faster than using `powf`\n+    fn powi(self, n: i32) -> Self;\n+    /// Raise a number to a floating point power.\n+    fn powf(self, n: Self) -> Self;\n+\n+    /// sqrt(2.0).\n+    fn sqrt2() -> Self;\n+    /// 1.0 / sqrt(2.0).\n+    fn frac_1_sqrt2() -> Self;\n+\n+    /// Take the square root of a number.\n+    fn sqrt(self) -> Self;\n+    /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n+    fn rsqrt(self) -> Self;\n+\n+    // FIXME (#5527): These should be associated constants\n+\n+    /// Archimedes' constant.\n+    fn pi() -> Self;\n+    /// 2.0 * pi.\n+    fn two_pi() -> Self;\n+    /// pi / 2.0.\n+    fn frac_pi_2() -> Self;\n+    /// pi / 3.0.\n+    fn frac_pi_3() -> Self;\n+    /// pi / 4.0.\n+    fn frac_pi_4() -> Self;\n+    /// pi / 6.0.\n+    fn frac_pi_6() -> Self;\n+    /// pi / 8.0.\n+    fn frac_pi_8() -> Self;\n+    /// 1.0 / pi.\n+    fn frac_1_pi() -> Self;\n+    /// 2.0 / pi.\n+    fn frac_2_pi() -> Self;\n+    /// 2.0 / sqrt(pi).\n+    fn frac_2_sqrtpi() -> Self;\n+\n+    /// Euler's number.\n+    fn e() -> Self;\n+    /// log2(e).\n+    fn log2_e() -> Self;\n+    /// log10(e).\n+    fn log10_e() -> Self;\n+    /// ln(2.0).\n+    fn ln_2() -> Self;\n+    /// ln(10.0).\n+    fn ln_10() -> Self;\n+\n+    /// Returns `e^(self)`, (the exponential function).\n+    fn exp(self) -> Self;\n+    /// Returns 2 raised to the power of the number, `2^(self)`.\n+    fn exp2(self) -> Self;\n+    /// Returns the natural logarithm of the number.\n+    fn ln(self) -> Self;\n+    /// Returns the logarithm of the number with respect to an arbitrary base.\n+    fn log(self, base: Self) -> Self;\n+    /// Returns the base 2 logarithm of the number.\n+    fn log2(self) -> Self;\n+    /// Returns the base 10 logarithm of the number.\n+    fn log10(self) -> Self;\n+\n+    /// Convert radians to degrees.\n+    fn to_degrees(self) -> Self;\n+    /// Convert degrees to radians.\n+    fn to_radians(self) -> Self;\n+}"}, {"sha": "00f21ee4c9cedee495cd2d9dfd8e400cdc95d223", "filename": "src/libcore/option.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -148,7 +148,7 @@ use mem;\n use slice;\n \n /// The `Option`\n-#[deriving(Clone, Eq, Ord, TotalEq, TotalOrd)]\n+#[deriving(Clone, Eq, Ord, TotalEq, TotalOrd, Show)]\n pub enum Option<T> {\n     /// No value\n     None,\n@@ -595,9 +595,11 @@ pub fn collect<T, Iter: Iterator<Option<T>>, V: FromIterator<T>>(iter: Iter) ->\n \n #[cfg(test)]\n mod tests {\n-    use realstd::option::collect;\n-    use realstd::prelude::*;\n-    use realstd::iter::range;\n+    use realstd::vec::Vec;\n+    use realstd::str::StrAllocating;\n+    use option::collect;\n+    use prelude::*;\n+    use iter::range;\n \n     use str::StrSlice;\n     use kinds::marker;\n@@ -638,7 +640,7 @@ mod tests {\n         impl ::ops::Drop for R {\n            fn drop(&mut self) {\n                 let ii = &*self.i;\n-                let i = ii.borrow().clone();\n+                let i = *ii.borrow();\n                 *ii.borrow_mut() = i + 1;\n             }\n         }\n@@ -649,9 +651,14 @@ mod tests {\n             }\n         }\n \n+        fn realclone<T: ::realstd::clone::Clone>(t: &T) -> T {\n+            use realstd::clone::Clone;\n+            t.clone()\n+        }\n+\n         let i = Rc::new(RefCell::new(0));\n         {\n-            let x = R(i.clone());\n+            let x = R(realclone(&i));\n             let opt = Some(x);\n             let _y = opt.unwrap();\n         }\n@@ -849,21 +856,21 @@ mod tests {\n     fn test_collect() {\n         let v: Option<Vec<int>> = collect(range(0, 0)\n                                           .map(|_| Some(0)));\n-        assert_eq!(v, Some(vec![]));\n+        assert!(v == Some(vec![]));\n \n         let v: Option<Vec<int>> = collect(range(0, 3)\n                                           .map(|x| Some(x)));\n-        assert_eq!(v, Some(vec![0, 1, 2]));\n+        assert!(v == Some(vec![0, 1, 2]));\n \n         let v: Option<Vec<int>> = collect(range(0, 3)\n                                           .map(|x| if x > 1 { None } else { Some(x) }));\n-        assert_eq!(v, None);\n+        assert!(v == None);\n \n         // test that it does not take more elements than it needs\n         let mut functions = [|| Some(()), || None, || fail!()];\n \n         let v: Option<Vec<()>> = collect(functions.mut_iter().map(|f| (*f)()));\n \n-        assert_eq!(v, None);\n+        assert!(v == None);\n     }\n }"}, {"sha": "2c6b0af8d94e6b34d2bc62d809c519c4ae90b11d", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -35,7 +35,7 @@ pub use iter::{FromIterator, Extendable};\n pub use iter::{Iterator, DoubleEndedIterator, RandomAccessIterator, CloneableIterator};\n pub use iter::{OrdIterator, MutableDoubleEndedIterator, ExactSize};\n pub use num::{Num, NumCast, CheckedAdd, CheckedSub, CheckedMul};\n-pub use num::{Signed, Unsigned};\n+pub use num::{Signed, Unsigned, Float};\n pub use num::{Primitive, Int, ToPrimitive, FromPrimitive};\n pub use ptr::RawPtr;\n pub use str::{Str, StrSlice};"}, {"sha": "acdf0bf06589f6a7dcaa1874f1ad9b0316b1650b", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -480,7 +480,7 @@ impl<T> Ord for *mut T {\n #[cfg(test)]\n pub mod ptr_tests {\n     use super::*;\n-    use realstd::prelude::*;\n+    use prelude::*;\n \n     use realstd::c_str::ToCStr;\n     use mem;\n@@ -660,9 +660,6 @@ pub mod ptr_tests {\n                     let expected = expected_arr[ctr].with_ref(|buf| {\n                             str::raw::from_c_str(buf)\n                         });\n-                    debug!(\n-                        \"test_ptr_array_each_with_len e: {}, a: {}\",\n-                        expected, actual);\n                     assert_eq!(actual, expected);\n                     ctr += 1;\n                     iteration_count += 1;\n@@ -696,9 +693,6 @@ pub mod ptr_tests {\n                     let expected = expected_arr[ctr].with_ref(|buf| {\n                         str::raw::from_c_str(buf)\n                     });\n-                    debug!(\n-                        \"test_ptr_array_each e: {}, a: {}\",\n-                        expected, actual);\n                     assert_eq!(actual, expected);\n                     ctr += 1;\n                     iteration_count += 1;"}, {"sha": "3237269e4a64fb0dbe8a22e9822055c327e4ae29", "filename": "src/libcore/result.rs", "status": "modified", "additions": 48, "deletions": 21, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -268,13 +268,14 @@\n \n use clone::Clone;\n use cmp::Eq;\n+use std::fmt::Show;\n use iter::{Iterator, FromIterator};\n use option::{None, Option, Some};\n \n /// `Result` is a type that represents either success (`Ok`) or failure (`Err`).\n ///\n /// See the [`std::result`](index.html) module documentation for details.\n-#[deriving(Clone, Eq, Ord, TotalEq, TotalOrd)]\n+#[deriving(Clone, Eq, Ord, TotalEq, TotalOrd, Show)]\n #[must_use]\n pub enum Result<T, E> {\n     /// Contains the success value\n@@ -515,6 +516,34 @@ impl<T, E> Result<T, E> {\n     }\n }\n \n+impl<T, E: Show> Result<T, E> {\n+    /// Unwraps a result, yielding the content of an `Ok`.\n+    ///\n+    /// Fails if the value is an `Err`.\n+    #[inline]\n+    pub fn unwrap(self) -> T {\n+        match self {\n+            Ok(t) => t,\n+            Err(e) =>\n+                fail!(\"called `Result::unwrap()` on an `Err` value: {}\", e)\n+        }\n+    }\n+}\n+\n+impl<T: Show, E> Result<T, E> {\n+    /// Unwraps a result, yielding the content of an `Err`.\n+    ///\n+    /// Fails if the value is an `Ok`.\n+    #[inline]\n+    pub fn unwrap_err(self) -> E {\n+        match self {\n+            Ok(t) =>\n+                fail!(\"called `Result::unwrap_err()` on an `Ok` value: {}\", t),\n+            Err(e) => e\n+        }\n+    }\n+}\n+\n /////////////////////////////////////////////////////////////////////////////\n // Free functions\n /////////////////////////////////////////////////////////////////////////////\n@@ -592,9 +621,12 @@ pub fn fold_<T,E,Iter:Iterator<Result<T,E>>>(iterator: Iter) -> Result<(),E> {\n \n #[cfg(test)]\n mod tests {\n-    use realstd::result::{collect, fold, fold_};\n-    use realstd::prelude::*;\n-    use realstd::iter::range;\n+    use realstd::vec::Vec;\n+    use realstd::str::StrAllocating;\n+\n+    use result::{collect, fold, fold_};\n+    use prelude::*;\n+    use iter::range;\n \n     pub fn op1() -> Result<int, ~str> { Ok(666) }\n     pub fn op2() -> Result<int, ~str> { Err(\"sadface\".to_owned()) }\n@@ -641,33 +673,37 @@ mod tests {\n \n     #[test]\n     pub fn test_impl_map() {\n-        assert_eq!(Ok::<~str, ~str>(\"a\".to_owned()).map(|x| x + \"b\"), Ok(\"ab\".to_owned()));\n-        assert_eq!(Err::<~str, ~str>(\"a\".to_owned()).map(|x| x + \"b\"), Err(\"a\".to_owned()));\n+        assert_eq!(Ok::<~str, ~str>(\"a\".to_owned()).map(|x| x + \"b\"),\n+                   Ok(\"ab\".to_owned()));\n+        assert_eq!(Err::<~str, ~str>(\"a\".to_owned()).map(|x| x + \"b\"),\n+                   Err(\"a\".to_owned()));\n     }\n \n     #[test]\n     pub fn test_impl_map_err() {\n-        assert_eq!(Ok::<~str, ~str>(\"a\".to_owned()).map_err(|x| x + \"b\"), Ok(\"a\".to_owned()));\n-        assert_eq!(Err::<~str, ~str>(\"a\".to_owned()).map_err(|x| x + \"b\"), Err(\"ab\".to_owned()));\n+        assert_eq!(Ok::<~str, ~str>(\"a\".to_owned()).map_err(|x| x + \"b\"),\n+                   Ok(\"a\".to_owned()));\n+        assert_eq!(Err::<~str, ~str>(\"a\".to_owned()).map_err(|x| x + \"b\"),\n+                   Err(\"ab\".to_owned()));\n     }\n \n     #[test]\n     fn test_collect() {\n         let v: Result<Vec<int>, ()> = collect(range(0, 0).map(|_| Ok::<int, ()>(0)));\n-        assert_eq!(v, Ok(vec![]));\n+        assert!(v == Ok(vec![]));\n \n         let v: Result<Vec<int>, ()> = collect(range(0, 3).map(|x| Ok::<int, ()>(x)));\n-        assert_eq!(v, Ok(vec![0, 1, 2]));\n+        assert!(v == Ok(vec![0, 1, 2]));\n \n         let v: Result<Vec<int>, int> = collect(range(0, 3)\n                                                .map(|x| if x > 1 { Err(x) } else { Ok(x) }));\n-        assert_eq!(v, Err(2));\n+        assert!(v == Err(2));\n \n         // test that it does not take more elements than it needs\n         let mut functions = [|| Ok(()), || Err(1), || fail!()];\n \n         let v: Result<Vec<()>, int> = collect(functions.mut_iter().map(|f| (*f)()));\n-        assert_eq!(v, Err(1));\n+        assert!(v == Err(1));\n     }\n \n     #[test]\n@@ -691,15 +727,6 @@ mod tests {\n                    Err(1));\n     }\n \n-    #[test]\n-    pub fn test_to_str() {\n-        let ok: Result<int, ~str> = Ok(100);\n-        let err: Result<int, ~str> = Err(\"Err\".to_owned());\n-\n-        assert_eq!(ok.to_str(), \"Ok(100)\".to_owned());\n-        assert_eq!(err.to_str(), \"Err(Err)\".to_owned());\n-    }\n-\n     #[test]\n     pub fn test_fmt_default() {\n         let ok: Result<int, ~str> = Ok(100);"}, {"sha": "b55952e70598a85a069f8ab6c7015802bb4630a7", "filename": "src/libcore/should_not_exist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fshould_not_exist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fshould_not_exist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fshould_not_exist.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -20,7 +20,7 @@\n //      1. Implement DST\n //      2. Make `Box<T>` not a language feature\n //      3. Move `Box<T>` to a separate crate, liballoc.\n-//      4. Implement relevant trais in liballoc, not libcore\n+//      4. Implement relevant traits in liballoc, not libcore\n //\n // Currently, no progress has been made on this list.\n "}, {"sha": "bd4534b19ac62989622f807092df7053b2fda490", "filename": "src/libcore/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -542,7 +542,7 @@ pub struct UTF16Items<'a> {\n     iter: slice::Items<'a, u16>\n }\n /// The possibilities for values decoded from a `u16` stream.\n-#[deriving(Eq, TotalEq, Clone)]\n+#[deriving(Eq, TotalEq, Clone, Show)]\n pub enum UTF16Item {\n     /// A valid codepoint.\n     ScalarValue(char),"}, {"sha": "1921eef9f60d46d4d6fa28dc2f22485265ac0e7a", "filename": "src/libgreen/macros.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibgreen%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibgreen%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fmacros.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -51,11 +51,9 @@ macro_rules! rtabort (\n )\n \n pub fn dumb_println(args: &fmt::Arguments) {\n-    use std::io;\n     use std::rt;\n-\n     let mut w = rt::Stderr;\n-    let _ = fmt::writeln(&mut w as &mut io::Writer, args);\n+    let _ = writeln!(&mut w, \"{}\", args);\n }\n \n pub fn abort(msg: &str) -> ! {"}, {"sha": "5981f87b4f2b6fbe988a7ea5fbc762d75ac5fae8", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -188,7 +188,7 @@ impl fmt::Show for LogLevel {\n impl fmt::Signed for LogLevel {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let LogLevel(level) = *self;\n-        write!(fmt.buf, \"{}\", level)\n+        write!(fmt, \"{}\", level)\n     }\n }\n "}, {"sha": "ecc48d5569c0e20a3a91f6be9a7c811893d9f67b", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -120,7 +120,7 @@ impl Default for BigUint {\n \n impl fmt::Show for BigUint {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}\", self.to_str_radix(10))\n+        write!(f, \"{}\", self.to_str_radix(10))\n     }\n }\n \n@@ -843,7 +843,7 @@ impl Default for BigInt {\n \n impl fmt::Show for BigInt {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}\", self.to_str_radix(10))\n+        write!(f, \"{}\", self.to_str_radix(10))\n     }\n }\n "}, {"sha": "3bc2408188da00b66dab362f53261a076960c6ea", "filename": "src/libnum/complex.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fcomplex.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -78,15 +78,15 @@ impl<T: Clone + Num> Complex<T> {\n     }\n }\n \n-impl<T: Clone + Float> Complex<T> {\n+impl<T: Clone + FloatMath> Complex<T> {\n     /// Calculate |self|\n     #[inline]\n     pub fn norm(&self) -> T {\n         self.re.hypot(self.im)\n     }\n }\n \n-impl<T: Clone + Float> Complex<T> {\n+impl<T: Clone + FloatMath> Complex<T> {\n     /// Calculate the principal Arg of self.\n     #[inline]\n     pub fn arg(&self) -> T {\n@@ -171,9 +171,9 @@ impl<T: Clone + Num> One for Complex<T> {\n impl<T: fmt::Show + Num + Ord> fmt::Show for Complex<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.im < Zero::zero() {\n-            write!(f.buf, \"{}-{}i\", self.re, -self.im)\n+            write!(f, \"{}-{}i\", self.re, -self.im)\n         } else {\n-            write!(f.buf, \"{}+{}i\", self.re, self.im)\n+            write!(f, \"{}+{}i\", self.re, self.im)\n         }\n     }\n }"}, {"sha": "cd5c82acf6e9a17fb11f9395371123231a0b05a9", "filename": "src/libnum/rational.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Frational.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -276,7 +276,7 @@ impl<T: Clone + Integer + Ord>\n impl<T: fmt::Show> fmt::Show for Ratio<T> {\n     /// Renders as `numer/denom`.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}/{}\", self.numer, self.denom)\n+        write!(f, \"{}/{}\", self.numer, self.denom)\n     }\n }\n impl<T: ToStrRadix> ToStrRadix for Ratio<T> {"}, {"sha": "a695da9fa163e6cc592c585672eaf0f605beffde", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -37,7 +37,7 @@ pub struct Error {\n \n impl fmt::Show for Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"Regex syntax error near position {}: {}\",\n+        write!(f, \"Regex syntax error near position {}: {}\",\n                self.pos, self.msg)\n     }\n }"}, {"sha": "899c54d601bdb1a9625e23e10db35fda4595e74f", "filename": "src/libregex/re.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -117,7 +117,7 @@ pub struct Regex {\n impl fmt::Show for Regex {\n     /// Shows the original regular expression.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}\", self.original)\n+        write!(f, \"{}\", self.original)\n     }\n }\n "}, {"sha": "c885fc49de25f7009e8321d5828f92d4a8659f52", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -15,9 +15,7 @@\n \n use std::cell::RefCell;\n use collections::HashMap;\n-use std::io;\n use std::io::MemWriter;\n-use std::fmt;\n \n use middle::ty::param_ty;\n use middle::ty;\n@@ -28,9 +26,7 @@ use syntax::ast::*;\n use syntax::diagnostic::SpanHandler;\n use syntax::parse::token;\n \n-macro_rules! mywrite( ($wr:expr, $($arg:tt)*) => (\n-    format_args!(|a| { mywrite($wr, a) }, $($arg)*)\n-) )\n+macro_rules! mywrite( ($($arg:tt)*) => ({ write!($($arg)*); }) )\n \n pub struct ctxt<'a> {\n     pub diag: &'a SpanHandler,\n@@ -52,10 +48,6 @@ pub struct ty_abbrev {\n \n pub type abbrev_map = RefCell<HashMap<ty::t, ty_abbrev>>;\n \n-fn mywrite(w: &mut MemWriter, fmt: &fmt::Arguments) {\n-    fmt::write(&mut *w as &mut io::Writer, fmt);\n-}\n-\n pub fn enc_ty(w: &mut MemWriter, cx: &ctxt, t: ty::t) {\n     match cx.abbrevs.borrow_mut().find(&t) {\n         Some(a) => { w.write(a.s.as_bytes()); return; }"}, {"sha": "1954c6d4123eebb92f7fa440ea72142f5a19ada5", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -183,13 +183,13 @@ pub fn check_crate(tcx: &ty::ctxt,\n \n impl fmt::Show for LiveNode {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"ln({})\", self.get())\n+        write!(f, \"ln({})\", self.get())\n     }\n }\n \n impl fmt::Show for Variable {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"v({})\", self.get())\n+        write!(f, \"v({})\", self.get())\n     }\n }\n "}, {"sha": "517be1bde2f3a980ecb45115a643cc3d789bbb40", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -388,7 +388,7 @@ pub struct t { inner: *t_opaque }\n \n impl fmt::Show for t {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.buf.write_str(\"*t_opaque\")\n+        \"*t_opaque\".fmt(f)\n     }\n }\n \n@@ -912,7 +912,7 @@ impl Vid for TyVid {\n \n impl fmt::Show for TyVid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n-        write!(f.buf, \"<generic \\\\#{}>\", self.to_uint())\n+        write!(f, \"<generic \\\\#{}>\", self.to_uint())\n     }\n }\n \n@@ -922,7 +922,7 @@ impl Vid for IntVid {\n \n impl fmt::Show for IntVid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"<generic integer \\\\#{}>\", self.to_uint())\n+        write!(f, \"<generic integer \\\\#{}>\", self.to_uint())\n     }\n }\n \n@@ -932,7 +932,7 @@ impl Vid for FloatVid {\n \n impl fmt::Show for FloatVid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"<generic float \\\\#{}>\", self.to_uint())\n+        write!(f, \"<generic float \\\\#{}>\", self.to_uint())\n     }\n }\n \n@@ -949,7 +949,7 @@ impl fmt::Show for RegionVid {\n impl fmt::Show for FnSig {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // grr, without tcx not much we can do.\n-        write!(f.buf, \"(...)\")\n+        write!(f, \"(...)\")\n     }\n }\n \n@@ -1987,7 +1987,7 @@ impl ops::Sub<TypeContents,TypeContents> for TypeContents {\n \n impl fmt::Show for TypeContents {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"TypeContents({:t})\", self.bits)\n+        write!(f, \"TypeContents({:t})\", self.bits)\n     }\n }\n "}, {"sha": "d80e9f0888865b2e16415461f84c98524f44cd2e", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -103,12 +103,24 @@ fn type_is_defined_in_local_crate(tcx: &ty::ctxt, original_type: t) -> bool {\n     ty::walk_ty(original_type, |t| {\n         match get(t).sty {\n             ty_enum(def_id, _) |\n-            ty_trait(box ty::TyTrait { def_id, .. }) |\n             ty_struct(def_id, _) => {\n                 if def_id.krate == ast::LOCAL_CRATE {\n                     found_nominal = true;\n                 }\n             }\n+            ty_trait(box ty::TyTrait { def_id, ref store, .. }) => {\n+                if def_id.krate == ast::LOCAL_CRATE {\n+                    found_nominal = true;\n+                }\n+                if *store == ty::UniqTraitStore {\n+                    match tcx.lang_items.owned_box() {\n+                        Some(did) if did.krate == ast::LOCAL_CRATE => {\n+                            found_nominal = true;\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n             ty_uniq(..) => {\n                 match tcx.lang_items.owned_box() {\n                     Some(did) if did.krate == ast::LOCAL_CRATE => {"}, {"sha": "42850f8876338d002114ee3b88ef054e40022258", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -240,9 +240,9 @@ enum VarianceTerm<'a> {\n impl<'a> fmt::Show for VarianceTerm<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            ConstantTerm(c1) => write!(f.buf, \"{}\", c1),\n-            TransformTerm(v1, v2) => write!(f.buf, \"({} \\u00D7 {})\", v1, v2),\n-            InferredTerm(id) => write!(f.buf, \"[{}]\", { let InferredIndex(i) = id; i })\n+            ConstantTerm(c1) => write!(f, \"{}\", c1),\n+            TransformTerm(v1, v2) => write!(f, \"({} \\u00D7 {})\", v1, v2),\n+            InferredTerm(id) => write!(f, \"[{}]\", { let InferredIndex(i) = id; i })\n         }\n     }\n }"}, {"sha": "fe93dbbc081f8b688963eb8e9461073c62057ded", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -29,7 +29,7 @@ impl<'a> fmt::Show for Escape<'a> {\n         for (i, ch) in s.bytes().enumerate() {\n             match ch as char {\n                 '<' | '>' | '&' | '\\'' | '\"' => {\n-                    try!(fmt.buf.write(pile_o_bits.slice(last, i).as_bytes()));\n+                    try!(fmt.write(pile_o_bits.slice(last, i).as_bytes()));\n                     let s = match ch as char {\n                         '>' => \"&gt;\",\n                         '<' => \"&lt;\",\n@@ -38,15 +38,15 @@ impl<'a> fmt::Show for Escape<'a> {\n                         '\"' => \"&quot;\",\n                         _ => unreachable!()\n                     };\n-                    try!(fmt.buf.write(s.as_bytes()));\n+                    try!(fmt.write(s.as_bytes()));\n                     last = i + 1;\n                 }\n                 _ => {}\n             }\n         }\n \n         if last < s.len() {\n-            try!(fmt.buf.write(pile_o_bits.slice_from(last).as_bytes()));\n+            try!(fmt.write(pile_o_bits.slice_from(last).as_bytes()));\n         }\n         Ok(())\n     }"}, {"sha": "563da5318f7c13f1e67d2cccd3340e6aa3a404b5", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 71, "deletions": 71, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -16,7 +16,6 @@\n //! them in the future to instead emit any format desired.\n \n use std::fmt;\n-use std::io;\n use std::strbuf::StrBuf;\n \n use syntax::ast;\n@@ -52,46 +51,46 @@ impl FnStyleSpace {\n impl fmt::Show for clean::Generics {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.lifetimes.len() == 0 && self.type_params.len() == 0 { return Ok(()) }\n-        try!(f.buf.write(\"&lt;\".as_bytes()));\n+        try!(f.write(\"&lt;\".as_bytes()));\n \n         for (i, life) in self.lifetimes.iter().enumerate() {\n             if i > 0 {\n-                try!(f.buf.write(\", \".as_bytes()));\n+                try!(f.write(\", \".as_bytes()));\n             }\n-            try!(write!(f.buf, \"{}\", *life));\n+            try!(write!(f, \"{}\", *life));\n         }\n \n         if self.type_params.len() > 0 {\n             if self.lifetimes.len() > 0 {\n-                try!(f.buf.write(\", \".as_bytes()));\n+                try!(f.write(\", \".as_bytes()));\n             }\n \n             for (i, tp) in self.type_params.iter().enumerate() {\n                 if i > 0 {\n-                    try!(f.buf.write(\", \".as_bytes()))\n+                    try!(f.write(\", \".as_bytes()))\n                 }\n-                try!(f.buf.write(tp.name.as_bytes()));\n+                try!(f.write(tp.name.as_bytes()));\n \n                 if tp.bounds.len() > 0 {\n-                    try!(f.buf.write(\": \".as_bytes()));\n+                    try!(f.write(\": \".as_bytes()));\n                     for (i, bound) in tp.bounds.iter().enumerate() {\n                         if i > 0 {\n-                            try!(f.buf.write(\" + \".as_bytes()));\n+                            try!(f.write(\" + \".as_bytes()));\n                         }\n-                        try!(write!(f.buf, \"{}\", *bound));\n+                        try!(write!(f, \"{}\", *bound));\n                     }\n                 }\n             }\n         }\n-        try!(f.buf.write(\"&gt;\".as_bytes()));\n+        try!(f.write(\"&gt;\".as_bytes()));\n         Ok(())\n     }\n }\n \n impl fmt::Show for clean::Lifetime {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(f.buf.write(\"'\".as_bytes()));\n-        try!(f.buf.write(self.get_ref().as_bytes()));\n+        try!(f.write(\"'\".as_bytes()));\n+        try!(f.write(self.get_ref().as_bytes()));\n         Ok(())\n     }\n }\n@@ -100,10 +99,10 @@ impl fmt::Show for clean::TyParamBound {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             clean::RegionBound => {\n-                f.buf.write(\"'static\".as_bytes())\n+                f.write(\"::\".as_bytes())\n             }\n             clean::TraitBound(ref ty) => {\n-                write!(f.buf, \"{}\", *ty)\n+                write!(f, \"{}\", *ty)\n             }\n         }\n     }\n@@ -112,32 +111,33 @@ impl fmt::Show for clean::TyParamBound {\n impl fmt::Show for clean::Path {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.global {\n-            try!(f.buf.write(\"::\".as_bytes()))\n+            try!(f.write(\"::\".as_bytes()))\n         }\n+\n         for (i, seg) in self.segments.iter().enumerate() {\n             if i > 0 {\n-                try!(f.buf.write(\"::\".as_bytes()))\n+                try!(f.write(\"::\".as_bytes()))\n             }\n-            try!(f.buf.write(seg.name.as_bytes()));\n+            try!(f.write(seg.name.as_bytes()));\n \n             if seg.lifetimes.len() > 0 || seg.types.len() > 0 {\n-                try!(f.buf.write(\"&lt;\".as_bytes()));\n+                try!(f.write(\"&lt;\".as_bytes()));\n                 let mut comma = false;\n                 for lifetime in seg.lifetimes.iter() {\n                     if comma {\n-                        try!(f.buf.write(\", \".as_bytes()));\n+                        try!(f.write(\", \".as_bytes()));\n                     }\n                     comma = true;\n-                    try!(write!(f.buf, \"{}\", *lifetime));\n+                    try!(write!(f, \"{}\", *lifetime));\n                 }\n                 for ty in seg.types.iter() {\n                     if comma {\n-                        try!(f.buf.write(\", \".as_bytes()));\n+                        try!(f.write(\", \".as_bytes()));\n                     }\n                     comma = true;\n-                    try!(write!(f.buf, \"{}\", *ty));\n+                    try!(write!(f, \"{}\", *ty));\n                 }\n-                try!(f.buf.write(\"&gt;\".as_bytes()));\n+                try!(f.write(\"&gt;\".as_bytes()));\n             }\n         }\n         Ok(())\n@@ -146,7 +146,7 @@ impl fmt::Show for clean::Path {\n \n /// Used when rendering a `ResolvedPath` structure. This invokes the `path`\n /// rendering function with the necessary arguments for linking to a local path.\n-fn resolved_path(w: &mut io::Writer, did: ast::DefId, p: &clean::Path,\n+fn resolved_path(w: &mut fmt::Formatter, did: ast::DefId, p: &clean::Path,\n                  print_all: bool) -> fmt::Result {\n     path(w, p, print_all,\n         |cache, loc| {\n@@ -170,7 +170,7 @@ fn resolved_path(w: &mut io::Writer, did: ast::DefId, p: &clean::Path,\n         })\n }\n \n-fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n+fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n         root: |&render::Cache, &[StrBuf]| -> Option<StrBuf>,\n         info: |&render::Cache| -> Option<(Vec<StrBuf> , ItemType)>)\n     -> fmt::Result\n@@ -264,7 +264,7 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n }\n \n /// Helper to render type parameters\n-fn tybounds(w: &mut io::Writer,\n+fn tybounds(w: &mut fmt::Formatter,\n             typarams: &Option<Vec<clean::TyParamBound> >) -> fmt::Result {\n     match *typarams {\n         Some(ref params) => {\n@@ -286,13 +286,13 @@ impl fmt::Show for clean::Type {\n         match *self {\n             clean::TyParamBinder(id) | clean::Generic(id) => {\n                 let m = cache_key.get().unwrap();\n-                f.buf.write(m.typarams.get(&id).as_bytes())\n+                f.write(m.typarams.get(&id).as_bytes())\n             }\n             clean::ResolvedPath{ did, ref typarams, ref path} => {\n-                try!(resolved_path(f.buf, did, path, false));\n-                tybounds(f.buf, typarams)\n+                try!(resolved_path(f, did, path, false));\n+                tybounds(f, typarams)\n             }\n-            clean::Self(..) => f.buf.write(\"Self\".as_bytes()),\n+            clean::Self(..) => f.write(\"Self\".as_bytes()),\n             clean::Primitive(prim) => {\n                 let s = match prim {\n                     ast::TyInt(ast::TyI) => \"int\",\n@@ -312,11 +312,11 @@ impl fmt::Show for clean::Type {\n                     ast::TyBool => \"bool\",\n                     ast::TyChar => \"char\",\n                 };\n-                f.buf.write(s.as_bytes())\n+                f.write(s.as_bytes())\n             }\n             clean::Closure(ref decl, ref region) => {\n-                write!(f.buf, \"{style}{lifetimes}|{args}|{bounds}\\\n-                               {arrow, select, yes{ -&gt; {ret}} other{}}\",\n+                write!(f, \"{style}{lifetimes}|{args}|{bounds}\\\n+                           {arrow, select, yes{ -&gt; {ret}} other{}}\",\n                        style = FnStyleSpace(decl.fn_style),\n                        lifetimes = if decl.lifetimes.len() == 0 {\n                            \"\".to_owned()\n@@ -351,8 +351,8 @@ impl fmt::Show for clean::Type {\n                        })\n             }\n             clean::Proc(ref decl) => {\n-                write!(f.buf, \"{style}{lifetimes}proc({args}){bounds}\\\n-                               {arrow, select, yes{ -&gt; {ret}} other{}}\",\n+                write!(f, \"{style}{lifetimes}proc({args}){bounds}\\\n+                           {arrow, select, yes{ -&gt; {ret}} other{}}\",\n                        style = FnStyleSpace(decl.fn_style),\n                        lifetimes = if decl.lifetimes.len() == 0 {\n                            \"\".to_strbuf()\n@@ -374,7 +374,7 @@ impl fmt::Show for clean::Type {\n                        ret = decl.decl.output)\n             }\n             clean::BareFunction(ref decl) => {\n-                write!(f.buf, \"{}{}fn{}{}\",\n+                write!(f, \"{}{}fn{}{}\",\n                        FnStyleSpace(decl.fn_style),\n                        match decl.abi.as_slice() {\n                            \"\" => \" extern \".to_strbuf(),\n@@ -385,35 +385,35 @@ impl fmt::Show for clean::Type {\n                        decl.decl)\n             }\n             clean::Tuple(ref typs) => {\n-                try!(f.buf.write(\"(\".as_bytes()));\n+                try!(f.write(\"(\".as_bytes()));\n                 for (i, typ) in typs.iter().enumerate() {\n                     if i > 0 {\n-                        try!(f.buf.write(\", \".as_bytes()))\n+                        try!(f.write(\", \".as_bytes()))\n                     }\n-                    try!(write!(f.buf, \"{}\", *typ));\n+                    try!(write!(f, \"{}\", *typ));\n                 }\n-                f.buf.write(\")\".as_bytes())\n+                f.write(\")\".as_bytes())\n             }\n-            clean::Vector(ref t) => write!(f.buf, \"[{}]\", **t),\n+            clean::Vector(ref t) => write!(f, \"[{}]\", **t),\n             clean::FixedVector(ref t, ref s) => {\n-                write!(f.buf, \"[{}, ..{}]\", **t, *s)\n-            }\n-            clean::String => f.buf.write(\"str\".as_bytes()),\n-            clean::Bool => f.buf.write(\"bool\".as_bytes()),\n-            clean::Unit => f.buf.write(\"()\".as_bytes()),\n-            clean::Bottom => f.buf.write(\"!\".as_bytes()),\n-            clean::Unique(ref t) => write!(f.buf, \"~{}\", **t),\n-            clean::Managed(ref t) => write!(f.buf, \"@{}\", **t),\n+                write!(f, \"[{}, ..{}]\", **t, *s)\n+            }\n+            clean::String => f.write(\"str\".as_bytes()),\n+            clean::Bool => f.write(\"bool\".as_bytes()),\n+            clean::Unit => f.write(\"()\".as_bytes()),\n+            clean::Bottom => f.write(\"!\".as_bytes()),\n+            clean::Unique(ref t) => write!(f, \"~{}\", **t),\n+            clean::Managed(ref t) => write!(f, \"@{}\", **t),\n             clean::RawPointer(m, ref t) => {\n-                write!(f.buf, \"*{}{}\",\n+                write!(f, \"*{}{}\",\n                        match m {\n                            clean::Mutable => \"mut \",\n                            clean::Immutable => \"\",\n                        }, **t)\n             }\n             clean::BorrowedRef{ lifetime: ref l, mutability, type_: ref ty} => {\n                 let lt = match *l { Some(ref l) => format!(\"{} \", *l), _ => \"\".to_owned() };\n-                write!(f.buf, \"&amp;{}{}{}\",\n+                write!(f, \"&amp;{}{}{}\",\n                        lt,\n                        match mutability {\n                            clean::Mutable => \"mut \",\n@@ -428,19 +428,19 @@ impl fmt::Show for clean::Type {\n impl fmt::Show for clean::Arguments {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         for (i, input) in self.values.iter().enumerate() {\n-            if i > 0 { try!(write!(f.buf, \", \")); }\n+            if i > 0 { try!(write!(f, \", \")); }\n             if input.name.len() > 0 {\n-                try!(write!(f.buf, \"{}: \", input.name));\n+                try!(write!(f, \"{}: \", input.name));\n             }\n-            try!(write!(f.buf, \"{}\", input.type_));\n+            try!(write!(f, \"{}\", input.type_));\n         }\n         Ok(())\n     }\n }\n \n impl fmt::Show for clean::FnDecl {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"({args}){arrow, select, yes{ -&gt; {ret}} other{}}\",\n+        write!(f, \"({args}){arrow, select, yes{ -&gt; {ret}} other{}}\",\n                args = self.inputs,\n                arrow = match self.output { clean::Unit => \"no\", _ => \"yes\" },\n                ret = self.output)\n@@ -475,7 +475,7 @@ impl<'a> fmt::Show for Method<'a> {\n             }\n             args.push_str(format!(\"{}\", input.type_));\n         }\n-        write!(f.buf,\n+        write!(f,\n                \"({args}){arrow, select, yes{ -&gt; {ret}} other{}}\",\n                args = args,\n                arrow = match d.output { clean::Unit => \"no\", _ => \"yes\" },\n@@ -486,7 +486,7 @@ impl<'a> fmt::Show for Method<'a> {\n impl fmt::Show for VisSpace {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.get() {\n-            Some(ast::Public) => write!(f.buf, \"pub \"),\n+            Some(ast::Public) => write!(f, \"pub \"),\n             Some(ast::Inherited) | None => Ok(())\n         }\n     }\n@@ -495,7 +495,7 @@ impl fmt::Show for VisSpace {\n impl fmt::Show for FnStyleSpace {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.get() {\n-            ast::UnsafeFn => write!(f.buf, \"unsafe \"),\n+            ast::UnsafeFn => write!(f, \"unsafe \"),\n             ast::NormalFn => Ok(())\n         }\n     }\n@@ -506,23 +506,23 @@ impl fmt::Show for clean::ViewPath {\n         match *self {\n             clean::SimpleImport(ref name, ref src) => {\n                 if *name == src.path.segments.last().unwrap().name {\n-                    write!(f.buf, \"use {};\", *src)\n+                    write!(f, \"use {};\", *src)\n                 } else {\n-                    write!(f.buf, \"use {} = {};\", *name, *src)\n+                    write!(f, \"use {} = {};\", *name, *src)\n                 }\n             }\n             clean::GlobImport(ref src) => {\n-                write!(f.buf, \"use {}::*;\", *src)\n+                write!(f, \"use {}::*;\", *src)\n             }\n             clean::ImportList(ref src, ref names) => {\n-                try!(write!(f.buf, \"use {}::\\\\{\", *src));\n+                try!(write!(f, \"use {}::\\\\{\", *src));\n                 for (i, n) in names.iter().enumerate() {\n                     if i > 0 {\n-                        try!(write!(f.buf, \", \"));\n+                        try!(write!(f, \", \"));\n                     }\n-                    try!(write!(f.buf, \"{}\", *n));\n+                    try!(write!(f, \"{}\", *n));\n                 }\n-                write!(f.buf, \"\\\\};\")\n+                write!(f, \"\\\\};\")\n             }\n         }\n     }\n@@ -531,13 +531,13 @@ impl fmt::Show for clean::ViewPath {\n impl fmt::Show for clean::ImportSource {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.did {\n-            Some(did) => resolved_path(f.buf, did, &self.path, true),\n+            Some(did) => resolved_path(f, did, &self.path, true),\n             _ => {\n                 for (i, seg) in self.path.segments.iter().enumerate() {\n                     if i > 0 {\n-                        try!(write!(f.buf, \"::\"))\n+                        try!(write!(f, \"::\"))\n                     }\n-                    try!(write!(f.buf, \"{}\", seg.name));\n+                    try!(write!(f, \"{}\", seg.name));\n                 }\n                 Ok(())\n             }\n@@ -557,9 +557,9 @@ impl fmt::Show for clean::ViewListIdent {\n                         types: Vec::new(),\n                     })\n                 };\n-                resolved_path(f.buf, did, &path, false)\n+                resolved_path(f, did, &path, false)\n             }\n-            _ => write!(f.buf, \"{}\", self.name),\n+            _ => write!(f, \"{}\", self.name),\n         }\n     }\n }"}, {"sha": "dd465df1db7e4a3f5c1d217dff7d02d88b5308dc", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -26,7 +26,7 @@ pub struct Page<'a> {\n \n pub fn render<T: fmt::Show, S: fmt::Show>(\n     dst: &mut io::Writer, layout: &Layout, page: &Page, sidebar: &S, t: &T)\n-    -> fmt::Result\n+    -> io::IoResult<()>\n {\n     write!(dst,\n r##\"<!DOCTYPE html>"}, {"sha": "b64e77615e1f5905f1632d5971b3bd1de453f064", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -29,7 +29,6 @@\n use libc;\n use std::cell::RefCell;\n use std::fmt;\n-use std::io;\n use std::slice;\n use std::str;\n use collections::HashMap;\n@@ -141,7 +140,7 @@ fn stripped_filtered_line<'a>(s: &'a str) -> Option<&'a str> {\n \n local_data_key!(used_header_map: RefCell<HashMap<StrBuf, uint>>)\n \n-pub fn render(w: &mut io::Writer, s: &str, print_toc: bool) -> fmt::Result {\n+pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n     extern fn block(ob: *mut hoedown_buffer, text: *hoedown_buffer,\n                     lang: *hoedown_buffer, opaque: *mut libc::c_void) {\n         unsafe {\n@@ -355,13 +354,13 @@ impl<'a> fmt::Show for Markdown<'a> {\n         let Markdown(md) = *self;\n         // This is actually common enough to special-case\n         if md.len() == 0 { return Ok(()) }\n-        render(fmt.buf, md.as_slice(), false)\n+        render(fmt, md.as_slice(), false)\n     }\n }\n \n impl<'a> fmt::Show for MarkdownWithToc<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let MarkdownWithToc(md) = *self;\n-        render(fmt.buf, md.as_slice(), true)\n+        render(fmt, md.as_slice(), true)\n     }\n }"}, {"sha": "8ae29d7d273c2d89ca03303d7e403507e534f17a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 60, "deletions": 61, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -587,7 +587,7 @@ impl<'a> SourceCollector<'a> {\n             root_path: root_path.as_slice(),\n         };\n         try!(layout::render(&mut w as &mut Writer, &self.cx.layout,\n-                              &page, &(\"\"), &Source(contents)));\n+                            &page, &(\"\"), &Source(contents)));\n         try!(w.flush());\n         return Ok(());\n     }\n@@ -925,8 +925,8 @@ impl Context {\n             // write sycall all the time.\n             let mut writer = BufferedWriter::new(w);\n             try!(layout::render(&mut writer as &mut Writer, &cx.layout, &page,\n-                                  &Sidebar{ cx: cx, item: it },\n-                                  &Item{ cx: cx, item: it }));\n+                                &Sidebar{ cx: cx, item: it },\n+                                &Item{ cx: cx, item: it }));\n             writer.flush()\n         }\n \n@@ -997,17 +997,17 @@ impl<'a> Item<'a> {\n impl<'a> fmt::Show for Item<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         // Write the breadcrumb trail header for the top\n-        try!(write!(fmt.buf, \"\\n<h1 class='fqn'>\"));\n+        try!(write!(fmt, \"\\n<h1 class='fqn'>\"));\n         match self.item.inner {\n             clean::ModuleItem(ref m) => if m.is_crate {\n-                    try!(write!(fmt.buf, \"Crate \"));\n+                    try!(write!(fmt, \"Crate \"));\n                 } else {\n-                    try!(write!(fmt.buf, \"Module \"));\n+                    try!(write!(fmt, \"Module \"));\n                 },\n-            clean::FunctionItem(..) => try!(write!(fmt.buf, \"Function \")),\n-            clean::TraitItem(..) => try!(write!(fmt.buf, \"Trait \")),\n-            clean::StructItem(..) => try!(write!(fmt.buf, \"Struct \")),\n-            clean::EnumItem(..) => try!(write!(fmt.buf, \"Enum \")),\n+            clean::FunctionItem(..) => try!(write!(fmt, \"Function \")),\n+            clean::TraitItem(..) => try!(write!(fmt, \"Trait \")),\n+            clean::StructItem(..) => try!(write!(fmt, \"Struct \")),\n+            clean::EnumItem(..) => try!(write!(fmt, \"Enum \")),\n             _ => {}\n         }\n         let cur = self.cx.current.as_slice();\n@@ -1017,16 +1017,16 @@ impl<'a> fmt::Show for Item<'a> {\n             for _ in range(0, cur.len() - i - 1) {\n                 trail.push_str(\"../\");\n             }\n-            try!(write!(fmt.buf, \"<a href='{}index.html'>{}</a>::\",\n-                          trail, component.as_slice()));\n+            try!(write!(fmt, \"<a href='{}index.html'>{}</a>::\",\n+                        trail, component.as_slice()));\n         }\n-        try!(write!(fmt.buf, \"<a class='{}' href=''>{}</a>\",\n-                      shortty(self.item), self.item.name.get_ref().as_slice()));\n+        try!(write!(fmt, \"<a class='{}' href=''>{}</a>\",\n+                    shortty(self.item), self.item.name.get_ref().as_slice()));\n \n         // Write stability attributes\n         match attr::find_stability(self.item.attrs.iter()) {\n             Some(ref stability) => {\n-                try!(write!(fmt.buf,\n+                try!(write!(fmt,\n                        \"<a class='stability {lvl}' title='{reason}'>{lvl}</a>\",\n                        lvl = stability.level.to_str(),\n                        reason = match stability.text {\n@@ -1039,22 +1039,22 @@ impl<'a> fmt::Show for Item<'a> {\n \n         // Write `src` tag\n         if self.cx.include_sources {\n-            try!(write!(fmt.buf, \"<a class='source' href='{}'>[src]</a>\",\n+            try!(write!(fmt, \"<a class='source' href='{}'>[src]</a>\",\n                         self.link()));\n         }\n-        try!(write!(fmt.buf, \"</h1>\\n\"));\n+        try!(write!(fmt, \"</h1>\\n\"));\n \n         match self.item.inner {\n             clean::ModuleItem(ref m) => {\n-                item_module(fmt.buf, self.cx, self.item, m.items.as_slice())\n+                item_module(fmt, self.cx, self.item, m.items.as_slice())\n             }\n             clean::FunctionItem(ref f) | clean::ForeignFunctionItem(ref f) =>\n-                item_function(fmt.buf, self.item, f),\n-            clean::TraitItem(ref t) => item_trait(fmt.buf, self.item, t),\n-            clean::StructItem(ref s) => item_struct(fmt.buf, self.item, s),\n-            clean::EnumItem(ref e) => item_enum(fmt.buf, self.item, e),\n-            clean::TypedefItem(ref t) => item_typedef(fmt.buf, self.item, t),\n-            clean::MacroItem(ref m) => item_macro(fmt.buf, self.item, m),\n+                item_function(fmt, self.item, f),\n+            clean::TraitItem(ref t) => item_trait(fmt, self.item, t),\n+            clean::StructItem(ref s) => item_struct(fmt, self.item, s),\n+            clean::EnumItem(ref e) => item_enum(fmt, self.item, e),\n+            clean::TypedefItem(ref t) => item_typedef(fmt, self.item, t),\n+            clean::MacroItem(ref m) => item_macro(fmt, self.item, m),\n             _ => Ok(())\n         }\n     }\n@@ -1097,7 +1097,7 @@ fn shorter<'a>(s: Option<&'a str>) -> &'a str {\n     }\n }\n \n-fn document(w: &mut Writer, item: &clean::Item) -> fmt::Result {\n+fn document(w: &mut fmt::Formatter, item: &clean::Item) -> fmt::Result {\n     match item.doc_value() {\n         Some(s) => {\n             try!(write!(w, \"<div class='docblock'>{}</div>\", Markdown(s)));\n@@ -1107,7 +1107,7 @@ fn document(w: &mut Writer, item: &clean::Item) -> fmt::Result {\n     Ok(())\n }\n \n-fn item_module(w: &mut Writer, cx: &Context,\n+fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                item: &clean::Item, items: &[clean::Item]) -> fmt::Result {\n     try!(document(w, item));\n     debug!(\"{:?}\", items);\n@@ -1196,13 +1196,12 @@ fn item_module(w: &mut Writer, cx: &Context,\n                     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                         let Initializer(s, item) = *self;\n                         if s.len() == 0 { return Ok(()); }\n-                        try!(write!(f.buf, \"<code> = </code>\"));\n+                        try!(write!(f, \"<code> = </code>\"));\n                         if s.contains(\"\\n\") {\n-                            write!(f.buf,\n-                                   \"<a href='{}'>[definition]</a>\",\n+                            write!(f, \"<a href='{}'>[definition]</a>\",\n                                    item.link())\n                         } else {\n-                            write!(f.buf, \"<code>{}</code>\", s.as_slice())\n+                            write!(f, \"<code>{}</code>\", s.as_slice())\n                         }\n                     }\n                 }\n@@ -1262,7 +1261,7 @@ fn item_module(w: &mut Writer, cx: &Context,\n     write!(w, \"</table>\")\n }\n \n-fn item_function(w: &mut Writer, it: &clean::Item,\n+fn item_function(w: &mut fmt::Formatter, it: &clean::Item,\n                  f: &clean::Function) -> fmt::Result {\n     try!(write!(w, \"<pre class='rust fn'>{vis}{fn_style}fn \\\n                     {name}{generics}{decl}</pre>\",\n@@ -1274,7 +1273,7 @@ fn item_function(w: &mut Writer, it: &clean::Item,\n     document(w, it)\n }\n \n-fn item_trait(w: &mut Writer, it: &clean::Item,\n+fn item_trait(w: &mut fmt::Formatter, it: &clean::Item,\n               t: &clean::Trait) -> fmt::Result {\n     let mut parents = StrBuf::new();\n     if t.parents.len() > 0 {\n@@ -1318,7 +1317,7 @@ fn item_trait(w: &mut Writer, it: &clean::Item,\n     // Trait documentation\n     try!(document(w, it));\n \n-    fn meth(w: &mut Writer, m: &clean::TraitMethod) -> fmt::Result {\n+    fn meth(w: &mut fmt::Formatter, m: &clean::TraitMethod) -> fmt::Result {\n         try!(write!(w, \"<h3 id='{}.{}' class='method'><code>\",\n                       shortty(m.item()),\n                       *m.item().name.get_ref()));\n@@ -1374,8 +1373,8 @@ fn item_trait(w: &mut Writer, it: &clean::Item,\n     Ok(())\n }\n \n-fn render_method(w: &mut Writer, meth: &clean::Item) -> fmt::Result {\n-    fn fun(w: &mut Writer, it: &clean::Item, fn_style: ast::FnStyle,\n+fn render_method(w: &mut fmt::Formatter, meth: &clean::Item) -> fmt::Result {\n+    fn fun(w: &mut fmt::Formatter, it: &clean::Item, fn_style: ast::FnStyle,\n            g: &clean::Generics, selfty: &clean::SelfTy,\n            d: &clean::FnDecl) -> fmt::Result {\n         write!(w, \"{}fn <a href='\\\\#{ty}.{name}' class='fnname'>{name}</a>\\\n@@ -1400,7 +1399,7 @@ fn render_method(w: &mut Writer, meth: &clean::Item) -> fmt::Result {\n     }\n }\n \n-fn item_struct(w: &mut Writer, it: &clean::Item,\n+fn item_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                s: &clean::Struct) -> fmt::Result {\n     try!(write!(w, \"<pre class='rust struct'>\"));\n     try!(render_struct(w,\n@@ -1437,7 +1436,8 @@ fn item_struct(w: &mut Writer, it: &clean::Item,\n     render_methods(w, it)\n }\n \n-fn item_enum(w: &mut Writer, it: &clean::Item, e: &clean::Enum) -> fmt::Result {\n+fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n+             e: &clean::Enum) -> fmt::Result {\n     try!(write!(w, \"<pre class='rust enum'>{}enum {}{}\",\n                   VisSpace(it.visibility),\n                   it.name.get_ref().as_slice(),\n@@ -1533,7 +1533,7 @@ fn item_enum(w: &mut Writer, it: &clean::Item, e: &clean::Enum) -> fmt::Result {\n     Ok(())\n }\n \n-fn render_struct(w: &mut Writer, it: &clean::Item,\n+fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                  g: Option<&clean::Generics>,\n                  ty: doctree::StructType,\n                  fields: &[clean::Item],\n@@ -1597,7 +1597,7 @@ fn render_struct(w: &mut Writer, it: &clean::Item,\n     Ok(())\n }\n \n-fn render_methods(w: &mut Writer, it: &clean::Item) -> fmt::Result {\n+fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n     match cache_key.get().unwrap().impls.find(&it.id) {\n         Some(v) => {\n             let mut non_trait = v.iter().filter(|p| {\n@@ -1642,7 +1642,7 @@ fn render_methods(w: &mut Writer, it: &clean::Item) -> fmt::Result {\n     Ok(())\n }\n \n-fn render_impl(w: &mut Writer, i: &clean::Impl,\n+fn render_impl(w: &mut fmt::Formatter, i: &clean::Impl,\n                dox: &Option<StrBuf>) -> fmt::Result {\n     try!(write!(w, \"<h3 class='impl'><code>impl{} \", i.generics));\n     let trait_id = match i.trait_ {\n@@ -1664,8 +1664,8 @@ fn render_impl(w: &mut Writer, i: &clean::Impl,\n         None => {}\n     }\n \n-    fn docmeth(w: &mut Writer, item: &clean::Item,\n-               dox: bool) -> io::IoResult<()> {\n+    fn docmeth(w: &mut fmt::Formatter, item: &clean::Item,\n+               dox: bool) -> fmt::Result {\n         try!(write!(w, \"<h4 id='method.{}' class='method'><code>\",\n                       *item.name.get_ref()));\n         try!(render_method(w, item));\n@@ -1714,7 +1714,7 @@ fn render_impl(w: &mut Writer, i: &clean::Impl,\n     Ok(())\n }\n \n-fn item_typedef(w: &mut Writer, it: &clean::Item,\n+fn item_typedef(w: &mut fmt::Formatter, it: &clean::Item,\n                 t: &clean::Typedef) -> fmt::Result {\n     try!(write!(w, \"<pre class='rust typedef'>type {}{} = {};</pre>\",\n                   it.name.get_ref().as_slice(),\n@@ -1728,21 +1728,21 @@ impl<'a> fmt::Show for Sidebar<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let cx = self.cx;\n         let it = self.item;\n-        try!(write!(fmt.buf, \"<p class='location'>\"));\n+        try!(write!(fmt, \"<p class='location'>\"));\n         let len = cx.current.len() - if it.is_mod() {1} else {0};\n         for (i, name) in cx.current.iter().take(len).enumerate() {\n             if i > 0 {\n-                try!(write!(fmt.buf, \"&\\\\#8203;::\"));\n+                try!(write!(fmt, \"&\\\\#8203;::\"));\n             }\n-            try!(write!(fmt.buf, \"<a href='{}index.html'>{}</a>\",\n+            try!(write!(fmt, \"<a href='{}index.html'>{}</a>\",\n                           cx.root_path\n                             .as_slice()\n                             .slice_to((cx.current.len() - i - 1) * 3),\n                           *name));\n         }\n-        try!(write!(fmt.buf, \"</p>\"));\n+        try!(write!(fmt, \"</p>\"));\n \n-        fn block(w: &mut Writer, short: &str, longty: &str,\n+        fn block(w: &mut fmt::Formatter, short: &str, longty: &str,\n                  cur: &clean::Item, cx: &Context) -> fmt::Result {\n             let items = match cx.sidebar.find_equiv(&short) {\n                 Some(items) => items.as_slice(),\n@@ -1770,12 +1770,12 @@ impl<'a> fmt::Show for Sidebar<'a> {\n             Ok(())\n         }\n \n-        try!(block(fmt.buf, \"mod\", \"Modules\", it, cx));\n-        try!(block(fmt.buf, \"struct\", \"Structs\", it, cx));\n-        try!(block(fmt.buf, \"enum\", \"Enums\", it, cx));\n-        try!(block(fmt.buf, \"trait\", \"Traits\", it, cx));\n-        try!(block(fmt.buf, \"fn\", \"Functions\", it, cx));\n-        try!(block(fmt.buf, \"macro\", \"Macros\", it, cx));\n+        try!(block(fmt, \"mod\", \"Modules\", it, cx));\n+        try!(block(fmt, \"struct\", \"Structs\", it, cx));\n+        try!(block(fmt, \"enum\", \"Enums\", it, cx));\n+        try!(block(fmt, \"trait\", \"Traits\", it, cx));\n+        try!(block(fmt, \"fn\", \"Functions\", it, cx));\n+        try!(block(fmt, \"macro\", \"Macros\", it, cx));\n         Ok(())\n     }\n }\n@@ -1808,19 +1808,18 @@ impl<'a> fmt::Show for Source<'a> {\n             cols += 1;\n             tmp /= 10;\n         }\n-        try!(write!(fmt.buf, \"<pre class='line-numbers'>\"));\n+        try!(write!(fmt, \"<pre class='line-numbers'>\"));\n         for i in range(1, lines + 1) {\n-            try!(write!(fmt.buf, \"<span id='{0:u}'>{0:1$u}</span>\\n\", i, cols));\n+            try!(write!(fmt, \"<span id='{0:u}'>{0:1$u}</span>\\n\", i, cols));\n         }\n-        try!(write!(fmt.buf, \"</pre>\"));\n-        try!(write!(fmt.buf, \"{}\", highlight::highlight(s.as_slice(), None)));\n+        try!(write!(fmt, \"</pre>\"));\n+        try!(write!(fmt, \"{}\", highlight::highlight(s.as_slice(), None)));\n         Ok(())\n     }\n }\n \n-fn item_macro(w: &mut Writer, it: &clean::Item,\n+fn item_macro(w: &mut fmt::Formatter, it: &clean::Item,\n               t: &clean::Macro) -> fmt::Result {\n-    try!(w.write_str(highlight::highlight(t.source.as_slice(),\n-                                          Some(\"macro\")).as_slice()));\n+    try!(w.write(highlight::highlight(t.source.as_slice(), Some(\"macro\")).as_bytes()));\n     document(w, it)\n }"}, {"sha": "4dabdf64f8102da691d785e5ead46326bacb6165", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -174,17 +174,17 @@ impl TocBuilder {\n \n impl fmt::Show for Toc {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(fmt.buf, \"<ul>\"));\n+        try!(write!(fmt, \"<ul>\"));\n         for entry in self.entries.iter() {\n             // recursively format this table of contents (the\n             // `{children}` is the key).\n-            try!(write!(fmt.buf,\n+            try!(write!(fmt,\n                         \"\\n<li><a href=\\\"\\\\#{id}\\\">{num} {name}</a>{children}</li>\",\n                         id = entry.id,\n                         num = entry.sec_number, name = entry.name,\n                         children = entry.children))\n         }\n-        write!(fmt.buf, \"</ul>\")\n+        write!(fmt, \"</ul>\")\n     }\n }\n "}, {"sha": "141e3e515ac96ab9f759f8ffd5597205a6c8c366", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -379,7 +379,7 @@ impl UvError {\n \n impl fmt::Show for UvError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}: {}\", self.name(), self.desc())\n+        write!(f, \"{}: {}\", self.name(), self.desc())\n     }\n }\n "}, {"sha": "deb7036848f96413bd1c26c7038f8eebda416f9e", "filename": "src/librustuv/macros.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibrustuv%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibrustuv%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fmacros.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -28,9 +28,7 @@ macro_rules! uvdebug (\n )\n \n pub fn dumb_println(args: &fmt::Arguments) {\n-    use std::io;\n     use std::rt;\n-\n     let mut w = rt::Stderr;\n-    let _ = fmt::writeln(&mut w as &mut io::Writer, args);\n+    let _ = writeln!(&mut w, \"{}\", args);\n }"}, {"sha": "2f1d59b23a280b8326a68eee0ecb245d8668ed00", "filename": "src/libsemver/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibsemver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibsemver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsemver%2Flib.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -96,18 +96,18 @@ pub struct Version {\n impl fmt::Show for Version {\n     #[inline]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f.buf, \"{}.{}.{}\", self.major, self.minor, self.patch))\n+        try!(write!(f, \"{}.{}.{}\", self.major, self.minor, self.patch))\n         if !self.pre.is_empty() {\n-            try!(write!(f.buf, \"-\"));\n+            try!(write!(f, \"-\"));\n             for (i, x) in self.pre.iter().enumerate() {\n-                if i != 0 { try!(write!(f.buf, \".\")) };\n+                if i != 0 { try!(write!(f, \".\")) };\n                 try!(x.fmt(f));\n             }\n         }\n         if !self.build.is_empty() {\n-            try!(write!(f.buf, \"+\"));\n+            try!(write!(f, \"+\"));\n             for (i, x) in self.build.iter().enumerate() {\n-                if i != 0 { try!(write!(f.buf, \".\")) };\n+                if i != 0 { try!(write!(f, \".\")) };\n                 try!(x.fmt(f));\n             }\n         }"}, {"sha": "5ed778b49ebdd99367defc3a32f1b54b99d271db", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -170,8 +170,8 @@ impl fmt::Show for FromBase64Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             InvalidBase64Character(ch, idx) =>\n-                write!(f.buf, \"Invalid character '{}' at position {}\", ch, idx),\n-            InvalidBase64Length => write!(f.buf, \"Invalid length\"),\n+                write!(f, \"Invalid character '{}' at position {}\", ch, idx),\n+            InvalidBase64Length => write!(f, \"Invalid length\"),\n         }\n     }\n }"}, {"sha": "623bf85424a289faec8ac88fa3c1b943f114bfcb", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -69,8 +69,8 @@ impl fmt::Show for FromHexError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             InvalidHexCharacter(ch, idx) =>\n-                write!(f.buf, \"Invalid character '{}' at position {}\", ch, idx),\n-            InvalidHexLength => write!(f.buf, \"Invalid input length\"),\n+                write!(f, \"Invalid character '{}' at position {}\", ch, idx),\n+            InvalidHexLength => write!(f, \"Invalid input length\"),\n         }\n     }\n }"}, {"sha": "17a864d286232b12ee1b7281babfea4bb57d757c", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -2267,7 +2267,7 @@ impl<A:ToJson> ToJson for Option<A> {\n impl fmt::Show for Json {\n     /// Encodes a json value into a string\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.to_writer(f.buf)\n+        self.to_writer(f).map_err(|_| fmt::WriteError)\n     }\n }\n "}, {"sha": "6b3939872811d4874af371baa2b120aeaf221201", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -59,7 +59,7 @@\n //!\n //! impl fmt::Show for Flags {\n //!     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-//!         write!(f.buf, \"hi!\")\n+//!         write!(f, \"hi!\")\n //!     }\n //! }\n //!"}, {"sha": "86b77a46a39809a165a96d7acda41d06201ffeac", "filename": "src/libstd/fmt.rs", "status": "added", "additions": 588, "deletions": 0, "changes": 588, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -0,0 +1,588 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Utilities for formatting and printing strings\n+\n+This module contains the runtime support for the `format!` syntax extension.\n+This macro is implemented in the compiler to emit calls to this module in order\n+to format arguments at runtime into strings and streams.\n+\n+The functions contained in this module should not normally be used in everyday\n+use cases of `format!`. The assumptions made by these functions are unsafe for\n+all inputs, and the compiler performs a large amount of validation on the\n+arguments to `format!` in order to ensure safety at runtime. While it is\n+possible to call these functions directly, it is not recommended to do so in the\n+general case.\n+\n+## Usage\n+\n+The `format!` macro is intended to be familiar to those coming from C's\n+printf/fprintf functions or Python's `str.format` function. In its current\n+revision, the `format!` macro returns a `~str` type which is the result of the\n+formatting. In the future it will also be able to pass in a stream to format\n+arguments directly while performing minimal allocations.\n+\n+Some examples of the `format!` extension are:\n+\n+```rust\n+format!(\"Hello\");                 // => \"Hello\".to_owned()\n+format!(\"Hello, {:s}!\", \"world\"); // => \"Hello, world!\".to_owned()\n+format!(\"The number is {:d}\", 1); // => \"The number is 1\".to_owned()\n+format!(\"{:?}\", ~[3, 4]);         // => \"~[3, 4]\".to_owned()\n+format!(\"{value}\", value=4);      // => \"4\".to_owned()\n+format!(\"{} {}\", 1, 2);           // => \"1 2\".to_owned()\n+```\n+\n+From these, you can see that the first argument is a format string. It is\n+required by the compiler for this to be a string literal; it cannot be a\n+variable passed in (in order to perform validity checking). The compiler will\n+then parse the format string and determine if the list of arguments provided is\n+suitable to pass to this format string.\n+\n+### Positional parameters\n+\n+Each formatting argument is allowed to specify which value argument it's\n+referencing, and if omitted it is assumed to be \"the next argument\". For\n+example, the format string `{} {} {}` would take three parameters, and they\n+would be formatted in the same order as they're given. The format string\n+`{2} {1} {0}`, however, would format arguments in reverse order.\n+\n+Things can get a little tricky once you start intermingling the two types of\n+positional specifiers. The \"next argument\" specifier can be thought of as an\n+iterator over the argument. Each time a \"next argument\" specifier is seen, the\n+iterator advances. This leads to behavior like this:\n+\n+```rust\n+format!(\"{1} {} {0} {}\", 1, 2); // => \"2 1 1 2\".to_owned()\n+```\n+\n+The internal iterator over the argument has not been advanced by the time the\n+first `{}` is seen, so it prints the first argument. Then upon reaching the\n+second `{}`, the iterator has advanced forward to the second argument.\n+Essentially, parameters which explicitly name their argument do not affect\n+parameters which do not name an argument in terms of positional specifiers.\n+\n+A format string is required to use all of its arguments, otherwise it is a\n+compile-time error. You may refer to the same argument more than once in the\n+format string, although it must always be referred to with the same type.\n+\n+### Named parameters\n+\n+Rust itself does not have a Python-like equivalent of named parameters to a\n+function, but the `format!` macro is a syntax extension which allows it to\n+leverage named parameters. Named parameters are listed at the end of the\n+argument list and have the syntax:\n+\n+```notrust\n+identifier '=' expression\n+```\n+\n+For example, the following `format!` expressions all use named argument:\n+\n+```rust\n+format!(\"{argument}\", argument = \"test\");       // => \"test\".to_owned()\n+format!(\"{name} {}\", 1, name = 2);              // => \"2 1\".to_owned()\n+format!(\"{a:s} {c:d} {b:?}\", a=\"a\", b=(), c=3); // => \"a 3 ()\".to_owned()\n+```\n+\n+It is illegal to put positional parameters (those without names) after arguments\n+which have names. Like positional parameters, it is illegal to provided named\n+parameters that are unused by the format string.\n+\n+### Argument types\n+\n+Each argument's type is dictated by the format string. It is a requirement that\n+every argument is only ever referred to by one type. When specifying the format\n+of an argument, however, a string like `{}` indicates no type. This is allowed,\n+and if all references to one argument do not provide a type, then the format `?`\n+is used (the type's rust-representation is printed). For example, this is an\n+invalid format string:\n+\n+```notrust\n+{0:d} {0:s}\n+```\n+\n+Because the first argument is both referred to as an integer as well as a\n+string.\n+\n+Because formatting is done via traits, there is no requirement that the\n+`d` format actually takes an `int`, but rather it simply requires a type which\n+ascribes to the `Signed` formatting trait. There are various parameters which do\n+require a particular type, however. Namely if the syntax `{:.*s}` is used, then\n+the number of characters to print from the string precedes the actual string and\n+must have the type `uint`. Although a `uint` can be printed with `{:u}`, it is\n+illegal to reference an argument as such. For example, this is another invalid\n+format string:\n+\n+```notrust\n+{:.*s} {0:u}\n+```\n+\n+### Formatting traits\n+\n+When requesting that an argument be formatted with a particular type, you are\n+actually requesting that an argument ascribes to a particular trait. This allows\n+multiple actual types to be formatted via `{:d}` (like `i8` as well as `int`).\n+The current mapping of types to traits is:\n+\n+* `?` \u21d2 `Poly`\n+* `d` \u21d2 `Signed`\n+* `i` \u21d2 `Signed`\n+* `u` \u21d2 `Unsigned`\n+* `b` \u21d2 `Bool`\n+* `c` \u21d2 `Char`\n+* `o` \u21d2 `Octal`\n+* `x` \u21d2 `LowerHex`\n+* `X` \u21d2 `UpperHex`\n+* `s` \u21d2 `String`\n+* `p` \u21d2 `Pointer`\n+* `t` \u21d2 `Binary`\n+* `f` \u21d2 `Float`\n+* `e` \u21d2 `LowerExp`\n+* `E` \u21d2 `UpperExp`\n+* *nothing* \u21d2 `Show`\n+\n+What this means is that any type of argument which implements the\n+`std::fmt::Binary` trait can then be formatted with `{:t}`. Implementations are\n+provided for these traits for a number of primitive types by the standard\n+library as well. If no format is specified (as in `{}` or `{:6}`), then the\n+format trait used is the `Show` trait. This is one of the more commonly\n+implemented traits when formatting a custom type.\n+\n+When implementing a format trait for your own type, you will have to implement a\n+method of the signature:\n+\n+```rust\n+# use std;\n+# mod fmt { pub type Result = (); }\n+# struct T;\n+# trait SomeName<T> {\n+fn fmt(&self, f: &mut std::fmt::Formatter) -> fmt::Result;\n+# }\n+```\n+\n+Your type will be passed as `self` by-reference, and then the function should\n+emit output into the `f.buf` stream. It is up to each format trait\n+implementation to correctly adhere to the requested formatting parameters. The\n+values of these parameters will be listed in the fields of the `Formatter`\n+struct. In order to help with this, the `Formatter` struct also provides some\n+helper methods.\n+\n+Additionally, the return value of this function is `fmt::Result` which is a\n+typedef to `Result<(), IoError>` (also known as `IoError<()>`). Formatting\n+implementations should ensure that they return errors from `write!` correctly\n+(propagating errors upward).\n+\n+An example of implementing the formatting traits would look\n+like:\n+\n+```rust\n+use std::fmt;\n+use std::f64;\n+\n+struct Vector2D {\n+    x: int,\n+    y: int,\n+}\n+\n+impl fmt::Show for Vector2D {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        // The `f` value implements the `Writer` trait, which is what the\n+        // write! macro is expecting. Note that this formatting ignores the\n+        // various flags provided to format strings.\n+        write!(f, \"({}, {})\", self.x, self.y)\n+    }\n+}\n+\n+// Different traits allow different forms of output of a type. The meaning of\n+// this format is to print the magnitude of a vector.\n+impl fmt::Binary for Vector2D {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let magnitude = (self.x * self.x + self.y * self.y) as f64;\n+        let magnitude = magnitude.sqrt();\n+\n+        // Respect the formatting flags by using the helper method\n+        // `pad_integral` on the Formatter object. See the method documentation\n+        // for details, and the function `pad` can be used to pad strings.\n+        let decimals = f.precision.unwrap_or(3);\n+        let string = f64::to_str_exact(magnitude, decimals);\n+        f.pad_integral(true, \"\", string.as_bytes())\n+    }\n+}\n+\n+fn main() {\n+    let myvector = Vector2D { x: 3, y: 4 };\n+\n+    println!(\"{}\", myvector);       // => \"(3, 4)\"\n+    println!(\"{:10.3t}\", myvector); // => \"     5.000\"\n+}\n+```\n+\n+### Related macros\n+\n+There are a number of related macros in the `format!` family. The ones that are\n+currently implemented are:\n+\n+```ignore\n+format!      // described above\n+write!       // first argument is a &mut io::Writer, the destination\n+writeln!     // same as write but appends a newline\n+print!       // the format string is printed to the standard output\n+println!     // same as print but appends a newline\n+format_args! // described below.\n+```\n+\n+\n+#### `write!`\n+\n+This and `writeln` are two macros which are used to emit the format string to a\n+specified stream. This is used to prevent intermediate allocations of format\n+strings and instead directly write the output. Under the hood, this function is\n+actually invoking the `write` function defined in this module. Example usage is:\n+\n+```rust\n+# #![allow(unused_must_use)]\n+use std::io;\n+\n+let mut w = io::MemWriter::new();\n+write!(&mut w as &mut io::Writer, \"Hello {}!\", \"world\");\n+```\n+\n+#### `print!`\n+\n+This and `println` emit their output to stdout. Similarly to the `write!` macro,\n+the goal of these macros is to avoid intermediate allocations when printing\n+output. Example usage is:\n+\n+```rust\n+print!(\"Hello {}!\", \"world\");\n+println!(\"I have a newline {}\", \"character at the end\");\n+```\n+\n+#### `format_args!`\n+This is a curious macro which is used to safely pass around\n+an opaque object describing the format string. This object\n+does not require any heap allocations to create, and it only\n+references information on the stack. Under the hood, all of\n+the related macros are implemented in terms of this. First\n+off, some example usage is:\n+\n+```\n+use std::fmt;\n+use std::io;\n+\n+# #[allow(unused_must_use)]\n+# fn main() {\n+format_args!(fmt::format, \"this returns {}\", \"~str\");\n+\n+let some_writer: &mut io::Writer = &mut io::stdout();\n+format_args!(|args| { write!(some_writer, \"{}\", args) }, \"print with a {}\", \"closure\");\n+\n+fn my_fmt_fn(args: &fmt::Arguments) {\n+    write!(&mut io::stdout(), \"{}\", args);\n+}\n+format_args!(my_fmt_fn, \"or a {} too\", \"function\");\n+# }\n+```\n+\n+The first argument of the `format_args!` macro is a function (or closure) which\n+takes one argument of type `&fmt::Arguments`. This structure can then be\n+passed to the `write` and `format` functions inside this module in order to\n+process the format string. The goal of this macro is to even further prevent\n+intermediate allocations when dealing formatting strings.\n+\n+For example, a logging library could use the standard formatting syntax, but it\n+would internally pass around this structure until it has been determined where\n+output should go to.\n+\n+It is unsafe to programmatically create an instance of `fmt::Arguments` because\n+the operations performed when executing a format string require the compile-time\n+checks provided by the compiler. The `format_args!` macro is the only method of\n+safely creating these structures, but they can be unsafely created with the\n+constructor provided.\n+\n+## Internationalization\n+\n+The formatting syntax supported by the `format!` extension supports\n+internationalization by providing \"methods\" which execute various different\n+outputs depending on the input. The syntax and methods provided are similar to\n+other internationalization systems, so again nothing should seem alien.\n+Currently two methods are supported by this extension: \"select\" and \"plural\".\n+\n+Each method will execute one of a number of clauses, and then the value of the\n+clause will become what's the result of the argument's format. Inside of the\n+cases, nested argument strings may be provided, but all formatting arguments\n+must not be done through implicit positional means. All arguments inside of each\n+case of a method must be explicitly selected by their name or their integer\n+position.\n+\n+Furthermore, whenever a case is running, the special character `#` can be used\n+to reference the string value of the argument which was selected upon. As an\n+example:\n+\n+```rust\n+format!(\"{0, select, other{#}}\", \"hello\"); // => \"hello\".to_owned()\n+```\n+\n+This example is the equivalent of `{0:s}` essentially.\n+\n+### Select\n+\n+The select method is a switch over a `&str` parameter, and the parameter *must*\n+be of the type `&str`. An example of the syntax is:\n+\n+```notrust\n+{0, select, male{...} female{...} other{...}}\n+```\n+\n+Breaking this down, the `0`-th argument is selected upon with the `select`\n+method, and then a number of cases follow. Each case is preceded by an\n+identifier which is the match-clause to execute the given arm. In this case,\n+there are two explicit cases, `male` and `female`. The case will be executed if\n+the string argument provided is an exact match to the case selected.\n+\n+The `other` case is also a required case for all `select` methods. This arm will\n+be executed if none of the other arms matched the word being selected over.\n+\n+### Plural\n+\n+The plural method is a switch statement over a `uint` parameter, and the\n+parameter *must* be a `uint`. A plural method in its full glory can be specified\n+as:\n+\n+```notrust\n+{0, plural, offset=1 =1{...} two{...} many{...} other{...}}\n+```\n+\n+To break this down, the first `0` indicates that this method is selecting over\n+the value of the first positional parameter to the format string. Next, the\n+`plural` method is being executed. An optionally-supplied `offset` is then given\n+which indicates a number to subtract from argument `0` when matching. This is\n+then followed by a list of cases.\n+\n+Each case is allowed to supply a specific value to match upon with the syntax\n+`=N`. This case is executed if the value at argument `0` matches N exactly,\n+without taking the offset into account. A case may also be specified by one of\n+five keywords: `zero`, `one`, `two`, `few`, and `many`. These cases are matched\n+on after argument `0` has the offset taken into account. Currently the\n+definitions of `many` and `few` are hardcoded, but they are in theory defined by\n+the current locale.\n+\n+Finally, all `plural` methods must have an `other` case supplied which will be\n+executed if none of the other cases match.\n+\n+## Syntax\n+\n+The syntax for the formatting language used is drawn from other languages, so it\n+should not be too alien. Arguments are formatted with python-like syntax,\n+meaning that arguments are surrounded by `{}` instead of the C-like `%`. The\n+actual grammar for the formatting syntax is:\n+\n+```notrust\n+format_string := <text> [ format <text> ] *\n+format := '{' [ argument ] [ ':' format_spec ] [ ',' function_spec ] '}'\n+argument := integer | identifier\n+\n+format_spec := [[fill]align][sign]['#'][0][width]['.' precision][type]\n+fill := character\n+align := '<' | '>'\n+sign := '+' | '-'\n+width := count\n+precision := count | '*'\n+type := identifier | ''\n+count := parameter | integer\n+parameter := integer '$'\n+\n+function_spec := plural | select\n+select := 'select' ',' ( identifier arm ) *\n+plural := 'plural' ',' [ 'offset:' integer ] ( selector arm ) *\n+selector := '=' integer | keyword\n+keyword := 'zero' | 'one' | 'two' | 'few' | 'many' | 'other'\n+arm := '{' format_string '}'\n+```\n+\n+## Formatting Parameters\n+\n+Each argument being formatted can be transformed by a number of formatting\n+parameters (corresponding to `format_spec` in the syntax above). These\n+parameters affect the string representation of what's being formatted. This\n+syntax draws heavily from Python's, so it may seem a bit familiar.\n+\n+### Fill/Alignment\n+\n+The fill character is provided normally in conjunction with the `width`\n+parameter. This indicates that if the value being formatted is smaller than\n+`width` some extra characters will be printed around it. The extra characters\n+are specified by `fill`, and the alignment can be one of two options:\n+\n+* `<` - the argument is left-aligned in `width` columns\n+* `>` - the argument is right-aligned in `width` columns\n+\n+### Sign/#/0\n+\n+These can all be interpreted as flags for a particular formatter.\n+\n+* '+' - This is intended for numeric types and indicates that the sign should\n+        always be printed. Positive signs are never printed by default, and the\n+        negative sign is only printed by default for the `Signed` trait. This\n+        flag indicates that the correct sign (+ or -) should always be printed.\n+* '-' - Currently not used\n+* '#' - This flag is indicates that the \"alternate\" form of printing should be\n+        used. By default, this only applies to the integer formatting traits and\n+        performs like:\n+    * `x` - precedes the argument with a \"0x\"\n+    * `X` - precedes the argument with a \"0x\"\n+    * `t` - precedes the argument with a \"0b\"\n+    * `o` - precedes the argument with a \"0o\"\n+* '0' - This is used to indicate for integer formats that the padding should\n+        both be done with a `0` character as well as be sign-aware. A format\n+        like `{:08d}` would yield `00000001` for the integer `1`, while the same\n+        format would yield `-0000001` for the integer `-1`. Notice that the\n+        negative version has one fewer zero than the positive version.\n+\n+### Width\n+\n+This is a parameter for the \"minimum width\" that the format should take up. If\n+the value's string does not fill up this many characters, then the padding\n+specified by fill/alignment will be used to take up the required space.\n+\n+The default fill/alignment for non-numerics is a space and left-aligned. The\n+defaults for numeric formatters is also a space but with right-alignment. If the\n+'0' flag is specified for numerics, then the implicit fill character is '0'.\n+\n+The value for the width can also be provided as a `uint` in the list of\n+parameters by using the `2$` syntax indicating that the second argument is a\n+`uint` specifying the width.\n+\n+### Precision\n+\n+For non-numeric types, this can be considered a \"maximum width\". If the\n+resulting string is longer than this width, then it is truncated down to this\n+many characters and only those are emitted.\n+\n+For integral types, this has no meaning currently.\n+\n+For floating-point types, this indicates how many digits after the decimal point\n+should be printed.\n+\n+## Escaping\n+\n+The literal characters `{`, `}`, or `#` may be included in a string by\n+preceding them with the `\\` character. Since `\\` is already an\n+escape character in Rust strings, a string literal using this escape\n+will look like `\"\\\\{\"`.\n+\n+*/\n+\n+use io::Writer;\n+use io;\n+use option::None;\n+use repr;\n+use result::{Ok, Err};\n+use str::{StrAllocating};\n+use str;\n+use strbuf::StrBuf;\n+use slice::Vector;\n+\n+pub use core::fmt::{Formatter, Result, FormatWriter, Show, rt};\n+pub use core::fmt::{Show, Bool, Char, Signed, Unsigned, Octal, Binary};\n+pub use core::fmt::{LowerHex, UpperHex, String, Pointer};\n+pub use core::fmt::{Float, LowerExp, UpperExp};\n+pub use core::fmt::{FormatError, WriteError};\n+pub use core::fmt::{Argument, Arguments, write, radix, Radix, RadixFmt};\n+\n+#[doc(hidden)]\n+pub use core::fmt::{argument, argumentstr, argumentuint};\n+#[doc(hidden)]\n+pub use core::fmt::{secret_show, secret_string, secret_unsigned};\n+#[doc(hidden)]\n+pub use core::fmt::{secret_signed, secret_lower_hex, secret_upper_hex};\n+#[doc(hidden)]\n+pub use core::fmt::{secret_bool, secret_char, secret_octal, secret_binary};\n+#[doc(hidden)]\n+pub use core::fmt::{secret_bool, secret_char, secret_octal, secret_binary};\n+#[doc(hidden)]\n+pub use core::fmt::{secret_float, secret_upper_exp, secret_lower_exp};\n+#[doc(hidden)]\n+pub use core::fmt::{secret_pointer};\n+\n+#[doc(hidden)]\n+pub fn secret_poly<T: Poly>(x: &T, fmt: &mut Formatter) -> Result {\n+    // FIXME #11938 - UFCS would make us able call the this method\n+    //                directly Poly::fmt(x, fmt).\n+    x.fmt(fmt)\n+}\n+\n+/// Format trait for the `?` character\n+pub trait Poly {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+/// The format function takes a precompiled format string and a list of\n+/// arguments, to return the resulting formatted string.\n+///\n+/// # Arguments\n+///\n+///   * args - a structure of arguments generated via the `format_args!` macro.\n+///            Because this structure can only be safely generated at\n+///            compile-time, this function is safe.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::fmt;\n+///\n+/// let s = format_args!(fmt::format, \"Hello, {}!\", \"world\");\n+/// assert_eq!(s, \"Hello, world!\".to_owned());\n+/// ```\n+pub fn format(args: &Arguments) -> ~str {\n+    let mut output = io::MemWriter::new();\n+    let _ = write!(&mut output, \"{}\", args);\n+    str::from_utf8(output.unwrap().as_slice()).unwrap().to_owned()\n+}\n+\n+/// Temporary transition utility\n+pub fn format_strbuf(args: &Arguments) -> StrBuf {\n+    let mut output = io::MemWriter::new();\n+    let _ = write!(&mut output, \"{}\", args);\n+    str::from_utf8(output.unwrap().as_slice()).unwrap().into_strbuf()\n+}\n+\n+impl<T> Poly for T {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        match (f.width, f.precision) {\n+            (None, None) => {\n+                match repr::write_repr(f, self) {\n+                    Ok(()) => Ok(()),\n+                    Err(..) => Err(WriteError),\n+                }\n+            }\n+\n+            // If we have a specified width for formatting, then we have to make\n+            // this allocation of a new string\n+            _ => {\n+                let s = repr::repr_to_str(self);\n+                f.pad(s)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a> Writer for Formatter<'a> {\n+    fn write(&mut self, b: &[u8]) -> io::IoResult<()> {\n+        match (*self).write(b) {\n+            Ok(()) => Ok(()),\n+            Err(WriteError) => Err(io::standard_error(io::OtherIoError))\n+        }\n+    }\n+}"}, {"sha": "d4f12f590ae7516c0e064c2c7395f471d44facd1", "filename": "src/libstd/fmt/mod.rs", "status": "removed", "additions": 0, "deletions": 1405, "changes": 1405, "blob_url": "https://github.com/rust-lang/rust/blob/84406d438c6c49aa63875096e5f3cca1a3879f17/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84406d438c6c49aa63875096e5f3cca1a3879f17/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=84406d438c6c49aa63875096e5f3cca1a3879f17", "patch": "@@ -1,1405 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-Utilities for formatting and printing strings\n-\n-This module contains the runtime support for the `format!` syntax extension.\n-This macro is implemented in the compiler to emit calls to this module in order\n-to format arguments at runtime into strings and streams.\n-\n-The functions contained in this module should not normally be used in everyday\n-use cases of `format!`. The assumptions made by these functions are unsafe for\n-all inputs, and the compiler performs a large amount of validation on the\n-arguments to `format!` in order to ensure safety at runtime. While it is\n-possible to call these functions directly, it is not recommended to do so in the\n-general case.\n-\n-## Usage\n-\n-The `format!` macro is intended to be familiar to those coming from C's\n-printf/fprintf functions or Python's `str.format` function. In its current\n-revision, the `format!` macro returns a `~str` type which is the result of the\n-formatting. In the future it will also be able to pass in a stream to format\n-arguments directly while performing minimal allocations.\n-\n-Some examples of the `format!` extension are:\n-\n-```rust\n-format!(\"Hello\");                 // => \"Hello\".to_owned()\n-format!(\"Hello, {:s}!\", \"world\"); // => \"Hello, world!\".to_owned()\n-format!(\"The number is {:d}\", 1); // => \"The number is 1\".to_owned()\n-format!(\"{:?}\", ~[3, 4]);         // => \"~[3, 4]\".to_owned()\n-format!(\"{value}\", value=4);      // => \"4\".to_owned()\n-format!(\"{} {}\", 1, 2);           // => \"1 2\".to_owned()\n-```\n-\n-From these, you can see that the first argument is a format string. It is\n-required by the compiler for this to be a string literal; it cannot be a\n-variable passed in (in order to perform validity checking). The compiler will\n-then parse the format string and determine if the list of arguments provided is\n-suitable to pass to this format string.\n-\n-### Positional parameters\n-\n-Each formatting argument is allowed to specify which value argument it's\n-referencing, and if omitted it is assumed to be \"the next argument\". For\n-example, the format string `{} {} {}` would take three parameters, and they\n-would be formatted in the same order as they're given. The format string\n-`{2} {1} {0}`, however, would format arguments in reverse order.\n-\n-Things can get a little tricky once you start intermingling the two types of\n-positional specifiers. The \"next argument\" specifier can be thought of as an\n-iterator over the argument. Each time a \"next argument\" specifier is seen, the\n-iterator advances. This leads to behavior like this:\n-\n-```rust\n-format!(\"{1} {} {0} {}\", 1, 2); // => \"2 1 1 2\".to_owned()\n-```\n-\n-The internal iterator over the argument has not been advanced by the time the\n-first `{}` is seen, so it prints the first argument. Then upon reaching the\n-second `{}`, the iterator has advanced forward to the second argument.\n-Essentially, parameters which explicitly name their argument do not affect\n-parameters which do not name an argument in terms of positional specifiers.\n-\n-A format string is required to use all of its arguments, otherwise it is a\n-compile-time error. You may refer to the same argument more than once in the\n-format string, although it must always be referred to with the same type.\n-\n-### Named parameters\n-\n-Rust itself does not have a Python-like equivalent of named parameters to a\n-function, but the `format!` macro is a syntax extension which allows it to\n-leverage named parameters. Named parameters are listed at the end of the\n-argument list and have the syntax:\n-\n-```notrust\n-identifier '=' expression\n-```\n-\n-For example, the following `format!` expressions all use named argument:\n-\n-```rust\n-format!(\"{argument}\", argument = \"test\");       // => \"test\".to_owned()\n-format!(\"{name} {}\", 1, name = 2);              // => \"2 1\".to_owned()\n-format!(\"{a:s} {c:d} {b:?}\", a=\"a\", b=(), c=3); // => \"a 3 ()\".to_owned()\n-```\n-\n-It is illegal to put positional parameters (those without names) after arguments\n-which have names. Like positional parameters, it is illegal to provided named\n-parameters that are unused by the format string.\n-\n-### Argument types\n-\n-Each argument's type is dictated by the format string. It is a requirement that\n-every argument is only ever referred to by one type. When specifying the format\n-of an argument, however, a string like `{}` indicates no type. This is allowed,\n-and if all references to one argument do not provide a type, then the format `?`\n-is used (the type's rust-representation is printed). For example, this is an\n-invalid format string:\n-\n-```notrust\n-{0:d} {0:s}\n-```\n-\n-Because the first argument is both referred to as an integer as well as a\n-string.\n-\n-Because formatting is done via traits, there is no requirement that the\n-`d` format actually takes an `int`, but rather it simply requires a type which\n-ascribes to the `Signed` formatting trait. There are various parameters which do\n-require a particular type, however. Namely if the syntax `{:.*s}` is used, then\n-the number of characters to print from the string precedes the actual string and\n-must have the type `uint`. Although a `uint` can be printed with `{:u}`, it is\n-illegal to reference an argument as such. For example, this is another invalid\n-format string:\n-\n-```notrust\n-{:.*s} {0:u}\n-```\n-\n-### Formatting traits\n-\n-When requesting that an argument be formatted with a particular type, you are\n-actually requesting that an argument ascribes to a particular trait. This allows\n-multiple actual types to be formatted via `{:d}` (like `i8` as well as `int`).\n-The current mapping of types to traits is:\n-\n-* `?` \u21d2 `Poly`\n-* `d` \u21d2 `Signed`\n-* `i` \u21d2 `Signed`\n-* `u` \u21d2 `Unsigned`\n-* `b` \u21d2 `Bool`\n-* `c` \u21d2 `Char`\n-* `o` \u21d2 `Octal`\n-* `x` \u21d2 `LowerHex`\n-* `X` \u21d2 `UpperHex`\n-* `s` \u21d2 `String`\n-* `p` \u21d2 `Pointer`\n-* `t` \u21d2 `Binary`\n-* `f` \u21d2 `Float`\n-* `e` \u21d2 `LowerExp`\n-* `E` \u21d2 `UpperExp`\n-* *nothing* \u21d2 `Show`\n-\n-What this means is that any type of argument which implements the\n-`std::fmt::Binary` trait can then be formatted with `{:t}`. Implementations are\n-provided for these traits for a number of primitive types by the standard\n-library as well. If no format is specified (as in `{}` or `{:6}`), then the\n-format trait used is the `Show` trait. This is one of the more commonly\n-implemented traits when formatting a custom type.\n-\n-When implementing a format trait for your own type, you will have to implement a\n-method of the signature:\n-\n-```rust\n-# use std;\n-# mod fmt { pub type Result = (); }\n-# struct T;\n-# trait SomeName<T> {\n-fn fmt(&self, f: &mut std::fmt::Formatter) -> fmt::Result;\n-# }\n-```\n-\n-Your type will be passed as `self` by-reference, and then the function should\n-emit output into the `f.buf` stream. It is up to each format trait\n-implementation to correctly adhere to the requested formatting parameters. The\n-values of these parameters will be listed in the fields of the `Formatter`\n-struct. In order to help with this, the `Formatter` struct also provides some\n-helper methods.\n-\n-Additionally, the return value of this function is `fmt::Result` which is a\n-typedef to `Result<(), IoError>` (also known as `IoError<()>`). Formatting\n-implementations should ensure that they return errors from `write!` correctly\n-(propagating errors upward).\n-\n-An example of implementing the formatting traits would look\n-like:\n-\n-```rust\n-use std::fmt;\n-use std::f64;\n-\n-struct Vector2D {\n-    x: int,\n-    y: int,\n-}\n-\n-impl fmt::Show for Vector2D {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        // The `f.buf` value is of the type `&mut io::Writer`, which is what the\n-        // write! macro is expecting. Note that this formatting ignores the\n-        // various flags provided to format strings.\n-        write!(f.buf, \"({}, {})\", self.x, self.y)\n-    }\n-}\n-\n-// Different traits allow different forms of output of a type. The meaning of\n-// this format is to print the magnitude of a vector.\n-impl fmt::Binary for Vector2D {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let magnitude = (self.x * self.x + self.y * self.y) as f64;\n-        let magnitude = magnitude.sqrt();\n-\n-        // Respect the formatting flags by using the helper method\n-        // `pad_integral` on the Formatter object. See the method documentation\n-        // for details, and the function `pad` can be used to pad strings.\n-        let decimals = f.precision.unwrap_or(3);\n-        let string = f64::to_str_exact(magnitude, decimals);\n-        f.pad_integral(true, \"\", string.as_bytes())\n-    }\n-}\n-\n-fn main() {\n-    let myvector = Vector2D { x: 3, y: 4 };\n-\n-    println!(\"{}\", myvector);       // => \"(3, 4)\"\n-    println!(\"{:10.3t}\", myvector); // => \"     5.000\"\n-}\n-```\n-\n-### Related macros\n-\n-There are a number of related macros in the `format!` family. The ones that are\n-currently implemented are:\n-\n-```ignore\n-format!      // described above\n-write!       // first argument is a &mut io::Writer, the destination\n-writeln!     // same as write but appends a newline\n-print!       // the format string is printed to the standard output\n-println!     // same as print but appends a newline\n-format_args! // described below.\n-```\n-\n-\n-#### `write!`\n-\n-This and `writeln` are two macros which are used to emit the format string to a\n-specified stream. This is used to prevent intermediate allocations of format\n-strings and instead directly write the output. Under the hood, this function is\n-actually invoking the `write` function defined in this module. Example usage is:\n-\n-```rust\n-# #![allow(unused_must_use)]\n-use std::io;\n-\n-let mut w = io::MemWriter::new();\n-write!(&mut w as &mut io::Writer, \"Hello {}!\", \"world\");\n-```\n-\n-#### `print!`\n-\n-This and `println` emit their output to stdout. Similarly to the `write!` macro,\n-the goal of these macros is to avoid intermediate allocations when printing\n-output. Example usage is:\n-\n-```rust\n-print!(\"Hello {}!\", \"world\");\n-println!(\"I have a newline {}\", \"character at the end\");\n-```\n-\n-#### `format_args!`\n-This is a curious macro which is used to safely pass around\n-an opaque object describing the format string. This object\n-does not require any heap allocations to create, and it only\n-references information on the stack. Under the hood, all of\n-the related macros are implemented in terms of this. First\n-off, some example usage is:\n-\n-```\n-use std::fmt;\n-use std::io;\n-\n-# #[allow(unused_must_use)]\n-# fn main() {\n-format_args!(fmt::format, \"this returns {}\", \"~str\");\n-\n-let some_writer: &mut io::Writer = &mut io::stdout();\n-format_args!(|args| { fmt::write(some_writer, args) }, \"print with a {}\", \"closure\");\n-\n-fn my_fmt_fn(args: &fmt::Arguments) {\n-    fmt::write(&mut io::stdout(), args);\n-}\n-format_args!(my_fmt_fn, \"or a {} too\", \"function\");\n-# }\n-```\n-\n-The first argument of the `format_args!` macro is a function (or closure) which\n-takes one argument of type `&fmt::Arguments`. This structure can then be\n-passed to the `write` and `format` functions inside this module in order to\n-process the format string. The goal of this macro is to even further prevent\n-intermediate allocations when dealing formatting strings.\n-\n-For example, a logging library could use the standard formatting syntax, but it\n-would internally pass around this structure until it has been determined where\n-output should go to.\n-\n-It is unsafe to programmatically create an instance of `fmt::Arguments` because\n-the operations performed when executing a format string require the compile-time\n-checks provided by the compiler. The `format_args!` macro is the only method of\n-safely creating these structures, but they can be unsafely created with the\n-constructor provided.\n-\n-## Internationalization\n-\n-The formatting syntax supported by the `format!` extension supports\n-internationalization by providing \"methods\" which execute various different\n-outputs depending on the input. The syntax and methods provided are similar to\n-other internationalization systems, so again nothing should seem alien.\n-Currently two methods are supported by this extension: \"select\" and \"plural\".\n-\n-Each method will execute one of a number of clauses, and then the value of the\n-clause will become what's the result of the argument's format. Inside of the\n-cases, nested argument strings may be provided, but all formatting arguments\n-must not be done through implicit positional means. All arguments inside of each\n-case of a method must be explicitly selected by their name or their integer\n-position.\n-\n-Furthermore, whenever a case is running, the special character `#` can be used\n-to reference the string value of the argument which was selected upon. As an\n-example:\n-\n-```rust\n-format!(\"{0, select, other{#}}\", \"hello\"); // => \"hello\".to_owned()\n-```\n-\n-This example is the equivalent of `{0:s}` essentially.\n-\n-### Select\n-\n-The select method is a switch over a `&str` parameter, and the parameter *must*\n-be of the type `&str`. An example of the syntax is:\n-\n-```notrust\n-{0, select, male{...} female{...} other{...}}\n-```\n-\n-Breaking this down, the `0`-th argument is selected upon with the `select`\n-method, and then a number of cases follow. Each case is preceded by an\n-identifier which is the match-clause to execute the given arm. In this case,\n-there are two explicit cases, `male` and `female`. The case will be executed if\n-the string argument provided is an exact match to the case selected.\n-\n-The `other` case is also a required case for all `select` methods. This arm will\n-be executed if none of the other arms matched the word being selected over.\n-\n-### Plural\n-\n-The plural method is a switch statement over a `uint` parameter, and the\n-parameter *must* be a `uint`. A plural method in its full glory can be specified\n-as:\n-\n-```notrust\n-{0, plural, offset=1 =1{...} two{...} many{...} other{...}}\n-```\n-\n-To break this down, the first `0` indicates that this method is selecting over\n-the value of the first positional parameter to the format string. Next, the\n-`plural` method is being executed. An optionally-supplied `offset` is then given\n-which indicates a number to subtract from argument `0` when matching. This is\n-then followed by a list of cases.\n-\n-Each case is allowed to supply a specific value to match upon with the syntax\n-`=N`. This case is executed if the value at argument `0` matches N exactly,\n-without taking the offset into account. A case may also be specified by one of\n-five keywords: `zero`, `one`, `two`, `few`, and `many`. These cases are matched\n-on after argument `0` has the offset taken into account. Currently the\n-definitions of `many` and `few` are hardcoded, but they are in theory defined by\n-the current locale.\n-\n-Finally, all `plural` methods must have an `other` case supplied which will be\n-executed if none of the other cases match.\n-\n-## Syntax\n-\n-The syntax for the formatting language used is drawn from other languages, so it\n-should not be too alien. Arguments are formatted with python-like syntax,\n-meaning that arguments are surrounded by `{}` instead of the C-like `%`. The\n-actual grammar for the formatting syntax is:\n-\n-```notrust\n-format_string := <text> [ format <text> ] *\n-format := '{' [ argument ] [ ':' format_spec ] [ ',' function_spec ] '}'\n-argument := integer | identifier\n-\n-format_spec := [[fill]align][sign]['#'][0][width]['.' precision][type]\n-fill := character\n-align := '<' | '>'\n-sign := '+' | '-'\n-width := count\n-precision := count | '*'\n-type := identifier | ''\n-count := parameter | integer\n-parameter := integer '$'\n-\n-function_spec := plural | select\n-select := 'select' ',' ( identifier arm ) *\n-plural := 'plural' ',' [ 'offset:' integer ] ( selector arm ) *\n-selector := '=' integer | keyword\n-keyword := 'zero' | 'one' | 'two' | 'few' | 'many' | 'other'\n-arm := '{' format_string '}'\n-```\n-\n-## Formatting Parameters\n-\n-Each argument being formatted can be transformed by a number of formatting\n-parameters (corresponding to `format_spec` in the syntax above). These\n-parameters affect the string representation of what's being formatted. This\n-syntax draws heavily from Python's, so it may seem a bit familiar.\n-\n-### Fill/Alignment\n-\n-The fill character is provided normally in conjunction with the `width`\n-parameter. This indicates that if the value being formatted is smaller than\n-`width` some extra characters will be printed around it. The extra characters\n-are specified by `fill`, and the alignment can be one of two options:\n-\n-* `<` - the argument is left-aligned in `width` columns\n-* `>` - the argument is right-aligned in `width` columns\n-\n-### Sign/#/0\n-\n-These can all be interpreted as flags for a particular formatter.\n-\n-* '+' - This is intended for numeric types and indicates that the sign should\n-        always be printed. Positive signs are never printed by default, and the\n-        negative sign is only printed by default for the `Signed` trait. This\n-        flag indicates that the correct sign (+ or -) should always be printed.\n-* '-' - Currently not used\n-* '#' - This flag is indicates that the \"alternate\" form of printing should be\n-        used. By default, this only applies to the integer formatting traits and\n-        performs like:\n-    * `x` - precedes the argument with a \"0x\"\n-    * `X` - precedes the argument with a \"0x\"\n-    * `t` - precedes the argument with a \"0b\"\n-    * `o` - precedes the argument with a \"0o\"\n-* '0' - This is used to indicate for integer formats that the padding should\n-        both be done with a `0` character as well as be sign-aware. A format\n-        like `{:08d}` would yield `00000001` for the integer `1`, while the same\n-        format would yield `-0000001` for the integer `-1`. Notice that the\n-        negative version has one fewer zero than the positive version.\n-\n-### Width\n-\n-This is a parameter for the \"minimum width\" that the format should take up. If\n-the value's string does not fill up this many characters, then the padding\n-specified by fill/alignment will be used to take up the required space.\n-\n-The default fill/alignment for non-numerics is a space and left-aligned. The\n-defaults for numeric formatters is also a space but with right-alignment. If the\n-'0' flag is specified for numerics, then the implicit fill character is '0'.\n-\n-The value for the width can also be provided as a `uint` in the list of\n-parameters by using the `2$` syntax indicating that the second argument is a\n-`uint` specifying the width.\n-\n-### Precision\n-\n-For non-numeric types, this can be considered a \"maximum width\". If the\n-resulting string is longer than this width, then it is truncated down to this\n-many characters and only those are emitted.\n-\n-For integral types, this has no meaning currently.\n-\n-For floating-point types, this indicates how many digits after the decimal point\n-should be printed.\n-\n-## Escaping\n-\n-The literal characters `{`, `}`, or `#` may be included in a string by\n-preceding them with the `\\` character. Since `\\` is already an\n-escape character in Rust strings, a string literal using this escape\n-will look like `\"\\\\{\"`.\n-\n-*/\n-\n-use any;\n-use cell::Cell;\n-use char::Char;\n-use cmp;\n-use container::Container;\n-use intrinsics::TypeId;\n-use io::MemWriter;\n-use io;\n-use iter::{Iterator, range};\n-use iter;\n-use kinds::Copy;\n-use mem;\n-use num::Signed;\n-use option::{Option, Some, None};\n-use owned::Box;\n-use repr;\n-use result::{Ok, Err, ResultUnwrap};\n-use slice::{Vector, ImmutableVector};\n-use slice;\n-use str::{StrSlice, StrAllocating, UTF16Item, ScalarValue, LoneSurrogate};\n-use str;\n-use strbuf::StrBuf;\n-\n-pub use self::num::radix;\n-pub use self::num::Radix;\n-pub use self::num::RadixFmt;\n-\n-mod num;\n-pub mod rt;\n-\n-pub type Result = io::IoResult<()>;\n-\n-/// A struct to represent both where to emit formatting strings to and how they\n-/// should be formatted. A mutable version of this is passed to all formatting\n-/// traits.\n-pub struct Formatter<'a> {\n-    /// Flags for formatting (packed version of rt::Flag)\n-    pub flags: uint,\n-    /// Character used as 'fill' whenever there is alignment\n-    pub fill: char,\n-    /// Boolean indication of whether the output should be left-aligned\n-    pub align: rt::Alignment,\n-    /// Optionally specified integer width that the output should be\n-    pub width: Option<uint>,\n-    /// Optionally specified precision for numeric types\n-    pub precision: Option<uint>,\n-\n-    /// Output buffer.\n-    pub buf: &'a mut io::Writer,\n-    curarg: slice::Items<'a, Argument<'a>>,\n-    args: &'a [Argument<'a>],\n-}\n-\n-/// This struct represents the generic \"argument\" which is taken by the Xprintf\n-/// family of functions. It contains a function to format the given value. At\n-/// compile time it is ensured that the function and the value have the correct\n-/// types, and then this struct is used to canonicalize arguments to one type.\n-pub struct Argument<'a> {\n-    formatter: extern \"Rust\" fn(&any::Void, &mut Formatter) -> Result,\n-    value: &'a any::Void,\n-}\n-\n-impl<'a> Arguments<'a> {\n-    /// When using the format_args!() macro, this function is used to generate the\n-    /// Arguments structure. The compiler inserts an `unsafe` block to call this,\n-    /// which is valid because the compiler performs all necessary validation to\n-    /// ensure that the resulting call to format/write would be safe.\n-    #[doc(hidden)] #[inline]\n-    pub unsafe fn new<'a>(fmt: &'static [rt::Piece<'static>],\n-                          args: &'a [Argument<'a>]) -> Arguments<'a> {\n-        Arguments{ fmt: mem::transmute(fmt), args: args }\n-    }\n-}\n-\n-/// This structure represents a safely precompiled version of a format string\n-/// and its arguments. This cannot be generated at runtime because it cannot\n-/// safely be done so, so no constructors are given and the fields are private\n-/// to prevent modification.\n-///\n-/// The `format_args!` macro will safely create an instance of this structure\n-/// and pass it to a user-supplied function. The macro validates the format\n-/// string at compile-time so usage of the `write` and `format` functions can\n-/// be safely performed.\n-pub struct Arguments<'a> {\n-    fmt: &'a [rt::Piece<'a>],\n-    args: &'a [Argument<'a>],\n-}\n-\n-impl<'a> Show for Arguments<'a> {\n-    fn fmt(&self, fmt: &mut Formatter) -> Result {\n-        write(fmt.buf, self)\n-    }\n-}\n-\n-/// When a format is not otherwise specified, types are formatted by ascribing\n-/// to this trait. There is not an explicit way of selecting this trait to be\n-/// used for formatting, it is only if no other format is specified.\n-pub trait Show {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `b` character\n-pub trait Bool {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `c` character\n-pub trait Char {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `i` and `d` characters\n-pub trait Signed {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `u` character\n-pub trait Unsigned {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `o` character\n-pub trait Octal {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `t` character\n-pub trait Binary {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `x` character\n-pub trait LowerHex {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `X` character\n-pub trait UpperHex {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `s` character\n-pub trait String {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `?` character\n-pub trait Poly {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `p` character\n-pub trait Pointer {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `f` character\n-pub trait Float {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `e` character\n-pub trait LowerExp {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `E` character\n-pub trait UpperExp {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-// FIXME #11938 - UFCS would make us able call the above methods\n-// directly Show::show(x, fmt).\n-macro_rules! uniform_fn_call_workaround {\n-    ($( $name: ident, $trait_: ident; )*) => {\n-        $(\n-            #[doc(hidden)]\n-            pub fn $name<T: $trait_>(x: &T, fmt: &mut Formatter) -> Result {\n-                x.fmt(fmt)\n-            }\n-            )*\n-    }\n-}\n-uniform_fn_call_workaround! {\n-    secret_show, Show;\n-    secret_bool, Bool;\n-    secret_char, Char;\n-    secret_signed, Signed;\n-    secret_unsigned, Unsigned;\n-    secret_octal, Octal;\n-    secret_binary, Binary;\n-    secret_lower_hex, LowerHex;\n-    secret_upper_hex, UpperHex;\n-    secret_string, String;\n-    secret_poly, Poly;\n-    secret_pointer, Pointer;\n-    secret_float, Float;\n-    secret_lower_exp, LowerExp;\n-    secret_upper_exp, UpperExp;\n-}\n-\n-/// The `write` function takes an output stream, a precompiled format string,\n-/// and a list of arguments. The arguments will be formatted according to the\n-/// specified format string into the output stream provided.\n-///\n-/// # Arguments\n-///\n-///   * output - the buffer to write output to\n-///   * args - the precompiled arguments generated by `format_args!`\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// # #![allow(unused_must_use)]\n-/// use std::fmt;\n-/// use std::io;\n-///\n-/// let mut w = io::stdout();\n-/// format_args!(|args| { fmt::write(&mut w, args); }, \"Hello, {}!\", \"world\");\n-/// ```\n-pub fn write(output: &mut io::Writer, args: &Arguments) -> Result {\n-    unsafe { write_unsafe(output, args.fmt, args.args) }\n-}\n-\n-/// The `writeln` function takes the same arguments as `write`, except that it\n-/// will also write a newline (`\\n`) character at the end of the format string.\n-pub fn writeln(output: &mut io::Writer, args: &Arguments) -> Result {\n-    let first = unsafe { write_unsafe(output, args.fmt, args.args) };\n-    first.and_then(|()| output.write(['\\n' as u8]))\n-}\n-\n-/// The `write_unsafe` function takes an output stream, a precompiled format\n-/// string, and a list of arguments. The arguments will be formatted according\n-/// to the specified format string into the output stream provided.\n-///\n-/// See the documentation for `format` for why this function is unsafe and care\n-/// should be taken if calling it manually.\n-///\n-/// Thankfully the rust compiler provides macros like `write!` and\n-/// `format_args!` which perform all of this validation at compile-time\n-/// and provide a safe interface for invoking this function.\n-///\n-/// # Arguments\n-///\n-///   * output - the buffer to write output to\n-///   * fmts - the precompiled format string to emit\n-///   * args - the list of arguments to the format string. These are only the\n-///            positional arguments (not named)\n-///\n-/// Note that this function assumes that there are enough arguments for the\n-/// format string.\n-pub unsafe fn write_unsafe(output: &mut io::Writer,\n-                           fmt: &[rt::Piece],\n-                           args: &[Argument]) -> Result {\n-    let mut formatter = Formatter {\n-        flags: 0,\n-        width: None,\n-        precision: None,\n-        buf: output,\n-        align: rt::AlignUnknown,\n-        fill: ' ',\n-        args: args,\n-        curarg: args.iter(),\n-    };\n-    for piece in fmt.iter() {\n-        try!(formatter.run(piece, None));\n-    }\n-    Ok(())\n-}\n-\n-/// The format function takes a precompiled format string and a list of\n-/// arguments, to return the resulting formatted string.\n-///\n-/// # Arguments\n-///\n-///   * args - a structure of arguments generated via the `format_args!` macro.\n-///            Because this structure can only be safely generated at\n-///            compile-time, this function is safe.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::fmt;\n-///\n-/// let s = format_args!(fmt::format, \"Hello, {}!\", \"world\");\n-/// assert_eq!(s, \"Hello, world!\".to_owned());\n-/// ```\n-pub fn format(args: &Arguments) -> ~str {\n-    unsafe { format_unsafe(args.fmt, args.args) }\n-}\n-\n-/// Temporary transitionary thing.\n-pub fn format_strbuf(args: &Arguments) -> StrBuf {\n-    unsafe { format_unsafe_strbuf(args.fmt, args.args) }\n-}\n-\n-/// The unsafe version of the formatting function.\n-///\n-/// This is currently an unsafe function because the types of all arguments\n-/// aren't verified by immediate callers of this function. This currently does\n-/// not validate that the correct types of arguments are specified for each\n-/// format specifier, nor that each argument itself contains the right function\n-/// for formatting the right type value. Because of this, the function is marked\n-/// as `unsafe` if this is being called manually.\n-///\n-/// Thankfully the rust compiler provides the macro `format!` which will perform\n-/// all of this validation at compile-time and provides a safe interface for\n-/// invoking this function.\n-///\n-/// # Arguments\n-///\n-///   * fmts - the precompiled format string to emit.\n-///   * args - the list of arguments to the format string. These are only the\n-///            positional arguments (not named)\n-///\n-/// Note that this function assumes that there are enough arguments for the\n-/// format string.\n-pub unsafe fn format_unsafe(fmt: &[rt::Piece], args: &[Argument]) -> ~str {\n-    let mut output = MemWriter::new();\n-    write_unsafe(&mut output as &mut io::Writer, fmt, args).unwrap();\n-    return str::from_utf8(output.unwrap().as_slice()).unwrap().to_owned();\n-}\n-\n-/// Temporary transitionary thing.\n-pub unsafe fn format_unsafe_strbuf(fmt: &[rt::Piece], args: &[Argument])\n-                                   -> StrBuf {\n-    let mut output = MemWriter::new();\n-    write_unsafe(&mut output as &mut io::Writer, fmt, args).unwrap();\n-    return str::from_utf8(output.unwrap().as_slice()).unwrap().into_strbuf();\n-}\n-\n-impl<'a> Formatter<'a> {\n-\n-    // First up is the collection of functions used to execute a format string\n-    // at runtime. This consumes all of the compile-time statics generated by\n-    // the format! syntax extension.\n-\n-    fn run(&mut self, piece: &rt::Piece, cur: Option<&str>) -> Result {\n-        match *piece {\n-            rt::String(s) => self.buf.write(s.as_bytes()),\n-            rt::CurrentArgument(()) => self.buf.write(cur.unwrap().as_bytes()),\n-            rt::Argument(ref arg) => {\n-                // Fill in the format parameters into the formatter\n-                self.fill = arg.format.fill;\n-                self.align = arg.format.align;\n-                self.flags = arg.format.flags;\n-                self.width = self.getcount(&arg.format.width);\n-                self.precision = self.getcount(&arg.format.precision);\n-\n-                // Extract the correct argument\n-                let value = match arg.position {\n-                    rt::ArgumentNext => { *self.curarg.next().unwrap() }\n-                    rt::ArgumentIs(i) => self.args[i],\n-                };\n-\n-                // Then actually do some printing\n-                match arg.method {\n-                    None => (value.formatter)(value.value, self),\n-                    Some(ref method) => self.execute(*method, value)\n-                }\n-            }\n-        }\n-    }\n-\n-    fn getcount(&mut self, cnt: &rt::Count) -> Option<uint> {\n-        match *cnt {\n-            rt::CountIs(n) => { Some(n) }\n-            rt::CountImplied => { None }\n-            rt::CountIsParam(i) => {\n-                let v = self.args[i].value;\n-                unsafe { Some(*(v as *any::Void as *uint)) }\n-            }\n-            rt::CountIsNextParam => {\n-                let v = self.curarg.next().unwrap().value;\n-                unsafe { Some(*(v as *any::Void as *uint)) }\n-            }\n-        }\n-    }\n-\n-    fn execute(&mut self, method: &rt::Method, arg: Argument) -> Result {\n-        match *method {\n-            // Pluralization is selection upon a numeric value specified as the\n-            // parameter.\n-            rt::Plural(offset, ref selectors, ref default) => {\n-                // This is validated at compile-time to be a pointer to a\n-                // '&uint' value.\n-                let value: &uint = unsafe { mem::transmute(arg.value) };\n-                let value = *value;\n-\n-                // First, attempt to match against explicit values without the\n-                // offsetted value\n-                for s in selectors.iter() {\n-                    match s.selector {\n-                        rt::Literal(val) if value == val => {\n-                            return self.runplural(value, s.result);\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-\n-                // Next, offset the value and attempt to match against the\n-                // keyword selectors.\n-                let value = value - match offset { Some(i) => i, None => 0 };\n-                for s in selectors.iter() {\n-                    let run = match s.selector {\n-                        rt::Keyword(rt::Zero) => value == 0,\n-                        rt::Keyword(rt::One) => value == 1,\n-                        rt::Keyword(rt::Two) => value == 2,\n-\n-                        // FIXME: Few/Many should have a user-specified boundary\n-                        //      One possible option would be in the function\n-                        //      pointer of the 'arg: Argument' struct.\n-                        rt::Keyword(rt::Few) => value < 8,\n-                        rt::Keyword(rt::Many) => value >= 8,\n-\n-                        rt::Literal(..) => false\n-                    };\n-                    if run {\n-                        return self.runplural(value, s.result);\n-                    }\n-                }\n-\n-                self.runplural(value, *default)\n-            }\n-\n-            // Select is just a matching against the string specified.\n-            rt::Select(ref selectors, ref default) => {\n-                // This is validated at compile-time to be a pointer to a\n-                // string slice,\n-                let value: & &str = unsafe { mem::transmute(arg.value) };\n-                let value = *value;\n-\n-                for s in selectors.iter() {\n-                    if s.selector == value {\n-                        for piece in s.result.iter() {\n-                            try!(self.run(piece, Some(value)));\n-                        }\n-                        return Ok(());\n-                    }\n-                }\n-                for piece in default.iter() {\n-                    try!(self.run(piece, Some(value)));\n-                }\n-                Ok(())\n-            }\n-        }\n-    }\n-\n-    fn runplural(&mut self, value: uint, pieces: &[rt::Piece]) -> Result {\n-        ::uint::to_str_bytes(value, 10, |buf| {\n-            let valuestr = str::from_utf8(buf).unwrap();\n-            for piece in pieces.iter() {\n-                try!(self.run(piece, Some(valuestr)));\n-            }\n-            Ok(())\n-        })\n-    }\n-\n-    // Helper methods used for padding and processing formatting arguments that\n-    // all formatting traits can use.\n-\n-    /// Performs the correct padding for an integer which has already been\n-    /// emitted into a byte-array. The byte-array should *not* contain the sign\n-    /// for the integer, that will be added by this method.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * is_positive - whether the original integer was positive or not.\n-    /// * prefix - if the '#' character (FlagAlternate) is provided, this\n-    ///   is the prefix to put in front of the number.\n-    /// * buf - the byte array that the number has been formatted into\n-    ///\n-    /// This function will correctly account for the flags provided as well as\n-    /// the minimum width. It will not take precision into account.\n-    pub fn pad_integral(&mut self, is_positive: bool, prefix: &str, buf: &[u8]) -> Result {\n-        use fmt::rt::{FlagAlternate, FlagSignPlus, FlagSignAwareZeroPad};\n-\n-        let mut width = buf.len();\n-\n-        let mut sign = None;\n-        if !is_positive {\n-            sign = Some('-'); width += 1;\n-        } else if self.flags & (1 << (FlagSignPlus as uint)) != 0 {\n-            sign = Some('+'); width += 1;\n-        }\n-\n-        let mut prefixed = false;\n-        if self.flags & (1 << (FlagAlternate as uint)) != 0 {\n-            prefixed = true; width += prefix.len();\n-        }\n-\n-        // Writes the sign if it exists, and then the prefix if it was requested\n-        let write_prefix = |f: &mut Formatter| {\n-            for c in sign.move_iter() { try!(f.buf.write_char(c)); }\n-            if prefixed { f.buf.write_str(prefix) }\n-            else { Ok(()) }\n-        };\n-\n-        // The `width` field is more of a `min-width` parameter at this point.\n-        match self.width {\n-            // If there's no minimum length requirements then we can just\n-            // write the bytes.\n-            None => {\n-                try!(write_prefix(self)); self.buf.write(buf)\n-            }\n-            // Check if we're over the minimum width, if so then we can also\n-            // just write the bytes.\n-            Some(min) if width >= min => {\n-                try!(write_prefix(self)); self.buf.write(buf)\n-            }\n-            // The sign and prefix goes before the padding if the fill character\n-            // is zero\n-            Some(min) if self.flags & (1 << (FlagSignAwareZeroPad as uint)) != 0 => {\n-                self.fill = '0';\n-                try!(write_prefix(self));\n-                self.with_padding(min - width, rt::AlignRight, |f| f.buf.write(buf))\n-            }\n-            // Otherwise, the sign and prefix goes after the padding\n-            Some(min) => {\n-                self.with_padding(min - width, rt::AlignRight, |f| {\n-                    try!(write_prefix(f)); f.buf.write(buf)\n-                })\n-            }\n-        }\n-    }\n-\n-    /// This function takes a string slice and emits it to the internal buffer\n-    /// after applying the relevant formatting flags specified. The flags\n-    /// recognized for generic strings are:\n-    ///\n-    /// * width - the minimum width of what to emit\n-    /// * fill/align - what to emit and where to emit it if the string\n-    ///                provided needs to be padded\n-    /// * precision - the maximum length to emit, the string is truncated if it\n-    ///               is longer than this length\n-    ///\n-    /// Notably this function ignored the `flag` parameters\n-    pub fn pad(&mut self, s: &str) -> Result {\n-        // Make sure there's a fast path up front\n-        if self.width.is_none() && self.precision.is_none() {\n-            return self.buf.write(s.as_bytes());\n-        }\n-        // The `precision` field can be interpreted as a `max-width` for the\n-        // string being formatted\n-        match self.precision {\n-            Some(max) => {\n-                // If there's a maximum width and our string is longer than\n-                // that, then we must always have truncation. This is the only\n-                // case where the maximum length will matter.\n-                let char_len = s.char_len();\n-                if char_len >= max {\n-                    let nchars = ::cmp::min(max, char_len);\n-                    return self.buf.write(s.slice_chars(0, nchars).as_bytes());\n-                }\n-            }\n-            None => {}\n-        }\n-        // The `width` field is more of a `min-width` parameter at this point.\n-        match self.width {\n-            // If we're under the maximum length, and there's no minimum length\n-            // requirements, then we can just emit the string\n-            None => self.buf.write(s.as_bytes()),\n-            // If we're under the maximum width, check if we're over the minimum\n-            // width, if so it's as easy as just emitting the string.\n-            Some(width) if s.char_len() >= width => {\n-                self.buf.write(s.as_bytes())\n-            }\n-            // If we're under both the maximum and the minimum width, then fill\n-            // up the minimum width with the specified string + some alignment.\n-            Some(width) => {\n-                self.with_padding(width - s.len(), rt::AlignLeft, |me| {\n-                    me.buf.write(s.as_bytes())\n-                })\n-            }\n-        }\n-    }\n-\n-    /// Runs a callback, emitting the correct padding either before or\n-    /// afterwards depending on whether right or left alingment is requested.\n-    fn with_padding(&mut self,\n-                    padding: uint,\n-                    default: rt::Alignment,\n-                    f: |&mut Formatter| -> Result) -> Result {\n-        let align = match self.align {\n-            rt::AlignUnknown => default,\n-            rt::AlignLeft | rt::AlignRight => self.align\n-        };\n-        if align == rt::AlignLeft {\n-            try!(f(self));\n-        }\n-        let mut fill = [0u8, ..4];\n-        let len = self.fill.encode_utf8(fill);\n-        for _ in range(0, padding) {\n-            try!(self.buf.write(fill.slice_to(len)));\n-        }\n-        if align == rt::AlignRight {\n-            try!(f(self));\n-        }\n-        Ok(())\n-    }\n-}\n-\n-/// This is a function which calls are emitted to by the compiler itself to\n-/// create the Argument structures that are passed into the `format` function.\n-#[doc(hidden)] #[inline]\n-pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter) -> Result,\n-                       t: &'a T) -> Argument<'a> {\n-    unsafe {\n-        Argument {\n-            formatter: mem::transmute(f),\n-            value: mem::transmute(t)\n-        }\n-    }\n-}\n-\n-/// When the compiler determines that the type of an argument *must* be a string\n-/// (such as for select), then it invokes this method.\n-#[doc(hidden)] #[inline]\n-pub fn argumentstr<'a>(s: &'a &str) -> Argument<'a> {\n-    argument(secret_string, s)\n-}\n-\n-/// When the compiler determines that the type of an argument *must* be a uint\n-/// (such as for plural), then it invokes this method.\n-#[doc(hidden)] #[inline]\n-pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n-    argument(secret_unsigned, s)\n-}\n-\n-// Implementations of the core formatting traits\n-\n-impl<T: Show> Show for @T {\n-    fn fmt(&self, f: &mut Formatter) -> Result { secret_show(&**self, f) }\n-}\n-impl<T: Show> Show for Box<T> {\n-    fn fmt(&self, f: &mut Formatter) -> Result { secret_show(&**self, f) }\n-}\n-impl<'a, T: Show> Show for &'a T {\n-    fn fmt(&self, f: &mut Formatter) -> Result { secret_show(*self, f) }\n-}\n-impl<'a, T: Show> Show for &'a mut T {\n-    fn fmt(&self, f: &mut Formatter) -> Result { secret_show(*self, f) }\n-}\n-\n-impl Bool for bool {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        secret_string(&(if *self {\"true\"} else {\"false\"}), f)\n-    }\n-}\n-\n-impl<'a, T: str::Str> String for T {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        f.pad(self.as_slice())\n-    }\n-}\n-\n-impl Char for char {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        let mut utf8 = [0u8, ..4];\n-        let amt = self.encode_utf8(utf8);\n-        let s: &str = unsafe { mem::transmute(utf8.slice_to(amt)) };\n-        secret_string(&s, f)\n-    }\n-}\n-\n-macro_rules! floating(($ty:ident) => {\n-    impl Float for $ty {\n-        fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            // FIXME: this shouldn't perform an allocation\n-            let s = match fmt.precision {\n-                Some(i) => ::$ty::to_str_exact(self.abs(), i),\n-                None => ::$ty::to_str_digits(self.abs(), 6)\n-            };\n-            fmt.pad_integral(*self >= 0.0, \"\", s.as_bytes())\n-        }\n-    }\n-\n-    impl LowerExp for $ty {\n-        fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            // FIXME: this shouldn't perform an allocation\n-            let s = match fmt.precision {\n-                Some(i) => ::$ty::to_str_exp_exact(self.abs(), i, false),\n-                None => ::$ty::to_str_exp_digits(self.abs(), 6, false)\n-            };\n-            fmt.pad_integral(*self >= 0.0, \"\", s.as_bytes())\n-        }\n-    }\n-\n-    impl UpperExp for $ty {\n-        fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            // FIXME: this shouldn't perform an allocation\n-            let s = match fmt.precision {\n-                Some(i) => ::$ty::to_str_exp_exact(self.abs(), i, true),\n-                None => ::$ty::to_str_exp_digits(self.abs(), 6, true)\n-            };\n-            fmt.pad_integral(*self >= 0.0, \"\", s.as_bytes())\n-        }\n-    }\n-})\n-floating!(f32)\n-floating!(f64)\n-\n-impl<T> Poly for T {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        match (f.width, f.precision) {\n-            (None, None) => {\n-                repr::write_repr(f.buf, self)\n-            }\n-\n-            // If we have a specified width for formatting, then we have to make\n-            // this allocation of a new string\n-            _ => {\n-                let s = repr::repr_to_str(self);\n-                f.pad(s)\n-            }\n-        }\n-    }\n-}\n-\n-impl<T> Pointer for *T {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        f.flags |= 1 << (rt::FlagAlternate as uint);\n-        secret_lower_hex::<uint>(&(*self as uint), f)\n-    }\n-}\n-impl<T> Pointer for *mut T {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        secret_pointer::<*T>(&(*self as *T), f)\n-    }\n-}\n-impl<'a, T> Pointer for &'a T {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        secret_pointer::<*T>(&(&**self as *T), f)\n-    }\n-}\n-impl<'a, T> Pointer for &'a mut T {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        secret_pointer::<*T>(&(&**self as *T), f)\n-    }\n-}\n-\n-// Implementation of Show for various core types\n-\n-macro_rules! delegate(($ty:ty to $other:ident) => {\n-    impl<'a> Show for $ty {\n-        fn fmt(&self, f: &mut Formatter) -> Result {\n-            (concat_idents!(secret_, $other)(self, f))\n-        }\n-    }\n-})\n-delegate!(~str to string)\n-delegate!(&'a str to string)\n-delegate!(bool to bool)\n-delegate!(char to char)\n-delegate!(f32 to float)\n-delegate!(f64 to float)\n-\n-impl<T> Show for *T {\n-    fn fmt(&self, f: &mut Formatter) -> Result { secret_pointer(self, f) }\n-}\n-impl<T> Show for *mut T {\n-    fn fmt(&self, f: &mut Formatter) -> Result { secret_pointer(self, f) }\n-}\n-\n-macro_rules! peel(($name:ident, $($other:ident,)*) => (tuple!($($other,)*)))\n-\n-macro_rules! tuple (\n-    () => ();\n-    ( $($name:ident,)+ ) => (\n-        impl<$($name:Show),*> Show for ($($name,)*) {\n-            #[allow(uppercase_variables, dead_assignment)]\n-            fn fmt(&self, f: &mut Formatter) -> Result {\n-                try!(write!(f.buf, \"(\"));\n-                let ($(ref $name,)*) = *self;\n-                let mut n = 0;\n-                $(\n-                    if n > 0 {\n-                        try!(write!(f.buf, \", \"));\n-                    }\n-                    try!(write!(f.buf, \"{}\", *$name));\n-                    n += 1;\n-                )*\n-                if n == 1 {\n-                    try!(write!(f.buf, \",\"));\n-                }\n-                write!(f.buf, \")\")\n-            }\n-        }\n-        peel!($($name,)*)\n-    )\n-)\n-\n-tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n-\n-impl Show for Box<any::Any> {\n-    fn fmt(&self, f: &mut Formatter) -> Result { f.pad(\"Box<Any>\") }\n-}\n-\n-impl<'a> Show for &'a any::Any {\n-    fn fmt(&self, f: &mut Formatter) -> Result { f.pad(\"&Any\") }\n-}\n-\n-impl<T: Show> Show for Option<T> {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        match *self {\n-            Some(ref t) => write!(f.buf, \"Some({})\", *t),\n-            None => write!(f.buf, \"None\"),\n-        }\n-    }\n-}\n-\n-impl<T: Show, U: Show> Show for ::result::Result<T, U> {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        match *self {\n-            Ok(ref t) => write!(f.buf, \"Ok({})\", *t),\n-            Err(ref t) => write!(f.buf, \"Err({})\", *t),\n-        }\n-    }\n-}\n-\n-impl<'a, T: Show> Show for &'a [T] {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n-            try!(write!(f.buf, \"[\"));\n-        }\n-        let mut is_first = true;\n-        for x in self.iter() {\n-            if is_first {\n-                is_first = false;\n-            } else {\n-                try!(write!(f.buf, \", \"));\n-            }\n-            try!(write!(f.buf, \"{}\", *x))\n-        }\n-        if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n-            try!(write!(f.buf, \"]\"));\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl<'a, T: Show> Show for &'a mut [T] {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        secret_show(&self.as_slice(), f)\n-    }\n-}\n-\n-impl<T: Show> Show for ~[T] {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        secret_show(&self.as_slice(), f)\n-    }\n-}\n-\n-impl Show for () {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        f.pad(\"()\")\n-    }\n-}\n-\n-impl Show for TypeId {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        write!(f.buf, \"TypeId \\\\{ {} \\\\}\", self.hash())\n-    }\n-}\n-\n-impl<T: Show> Show for iter::MinMaxResult<T> {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        match *self {\n-            iter::NoElements =>\n-                write!(f.buf, \"NoElements\"),\n-            iter::OneElement(ref t) =>\n-                write!(f.buf, \"OneElement({})\", *t),\n-            iter::MinMax(ref t1, ref t2) =>\n-                write!(f.buf, \"MinMax({}, {})\", *t1, *t2),\n-        }\n-    }\n-}\n-\n-impl Show for cmp::Ordering {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        match *self {\n-            cmp::Less => write!(f.buf, \"Less\"),\n-            cmp::Greater => write!(f.buf, \"Greater\"),\n-            cmp::Equal => write!(f.buf, \"Equal\"),\n-        }\n-    }\n-}\n-\n-impl<T: Copy + Show> Show for Cell<T> {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        write!(f.buf, r\"Cell \\{ value: {} \\}\", self.get())\n-    }\n-}\n-\n-impl Show for UTF16Item {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        match *self {\n-            ScalarValue(c) => write!(f.buf, \"ScalarValue({})\", c),\n-            LoneSurrogate(u) => write!(f.buf, \"LoneSurrogate({})\", u),\n-        }\n-    }\n-}\n-\n-// If you expected tests to be here, look instead at the run-pass/ifmt.rs test,\n-// it's a lot easier than creating all of the rt::Piece structures here."}, {"sha": "2880365cf348f5c6a15f63988af56ded515bb8b9", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -16,7 +16,7 @@ use io::{Reader, Writer, Stream, Buffer, DEFAULT_BUF_SIZE, IoResult};\n use iter::ExactSize;\n use ops::Drop;\n use option::{Some, None, Option};\n-use result::{Ok, Err, ResultUnwrap};\n+use result::{Ok, Err};\n use slice::{ImmutableVector, MutableVector};\n use slice;\n use vec::Vec;"}, {"sha": "a043722581ba26d337d839bfed215c293b41a312", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -381,9 +381,9 @@ impl IoError {\n \n impl fmt::Show for IoError {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        try!(fmt.buf.write_str(self.desc));\n+        try!(write!(fmt, \"{}\", self.desc));\n         match self.detail {\n-            Some(ref s) => write!(fmt.buf, \" ({})\", *s),\n+            Some(ref s) => write!(fmt, \" ({})\", *s),\n             None => Ok(())\n         }\n     }\n@@ -964,6 +964,42 @@ pub trait Writer {\n     /// decide whether their stream needs to be buffered or not.\n     fn flush(&mut self) -> IoResult<()> { Ok(()) }\n \n+    /// Writes a formatted string into this writer, returning any error\n+    /// encountered.\n+    ///\n+    /// This method is primarily used to interface with the `format_args!`\n+    /// macro, but it is rare that this should explicitly be called. The\n+    /// `write!` macro should be favored to invoke this method instead.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will return any I/O error reported while formatting.\n+    fn write_fmt(&mut self, fmt: &fmt::Arguments) -> IoResult<()> {\n+        // Create a shim which translates a Writer to a FormatWriter and saves\n+        // off I/O errors. instead of discarding them\n+        struct Adaptor<'a, T> {\n+            inner: &'a mut T,\n+            error: IoResult<()>,\n+        }\n+        impl<'a, T: Writer> fmt::FormatWriter for Adaptor<'a, T> {\n+            fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n+                match self.inner.write(bytes) {\n+                    Ok(()) => Ok(()),\n+                    Err(e) => {\n+                        self.error = Err(e);\n+                        Err(fmt::WriteError)\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut output = Adaptor { inner: self, error: Ok(()) };\n+        match fmt::write(&mut output, fmt) {\n+            Ok(()) => Ok(()),\n+            Err(..) => output.error\n+        }\n+    }\n+\n     /// Write a rust string into this sink.\n     ///\n     /// The bytes written will be the UTF-8 encoded version of the input string."}, {"sha": "f469c419e8ef7962b0994a7a8f1c8082aed5fd1b", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -35,22 +35,22 @@ impl fmt::Show for IpAddr {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             Ipv4Addr(a, b, c, d) =>\n-                write!(fmt.buf, \"{}.{}.{}.{}\", a, b, c, d),\n+                write!(fmt, \"{}.{}.{}.{}\", a, b, c, d),\n \n             // Ipv4 Compatible address\n             Ipv6Addr(0, 0, 0, 0, 0, 0, g, h) => {\n-                write!(fmt.buf, \"::{}.{}.{}.{}\", (g >> 8) as u8, g as u8,\n+                write!(fmt, \"::{}.{}.{}.{}\", (g >> 8) as u8, g as u8,\n                        (h >> 8) as u8, h as u8)\n             }\n \n             // Ipv4-Mapped address\n             Ipv6Addr(0, 0, 0, 0, 0, 0xFFFF, g, h) => {\n-                write!(fmt.buf, \"::FFFF:{}.{}.{}.{}\", (g >> 8) as u8, g as u8,\n+                write!(fmt, \"::FFFF:{}.{}.{}.{}\", (g >> 8) as u8, g as u8,\n                        (h >> 8) as u8, h as u8)\n             }\n \n             Ipv6Addr(a, b, c, d, e, f, g, h) =>\n-                write!(fmt.buf, \"{:x}:{:x}:{:x}:{:x}:{:x}:{:x}:{:x}:{:x}\",\n+                write!(fmt, \"{:x}:{:x}:{:x}:{:x}:{:x}:{:x}:{:x}:{:x}\",\n                        a, b, c, d, e, f, g, h)\n         }\n     }\n@@ -65,8 +65,8 @@ pub struct SocketAddr {\n impl fmt::Show for SocketAddr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.ip {\n-            Ipv4Addr(..) => write!(f.buf, \"{}:{}\", self.ip, self.port),\n-            Ipv6Addr(..) => write!(f.buf, \"[{}]:{}\", self.ip, self.port),\n+            Ipv4Addr(..) => write!(f, \"{}:{}\", self.ip, self.port),\n+            Ipv6Addr(..) => write!(f, \"[{}]:{}\", self.ip, self.port),\n         }\n     }\n }"}, {"sha": "875dd01be823bfcf6f99bb6235824a98e2f65b61", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -384,8 +384,6 @@ mod test {\n     })\n \n     pub fn socket_name(addr: SocketAddr) {\n-        use result::ResultUnwrap;\n-\n         let server = UdpSocket::bind(addr);\n \n         assert!(server.is_ok());"}, {"sha": "fc760e6fe4ca312cd874369a7ac17df517b2dc1a", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -308,9 +308,9 @@ impl fmt::Show for Command {\n     /// non-utf8 data is lossily converted using the utf8 replacement\n     /// character.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f.buf, \"{}\", str::from_utf8_lossy(self.program.as_bytes_no_nul())));\n+        try!(write!(f, \"{}\", str::from_utf8_lossy(self.program.as_bytes_no_nul())));\n         for arg in self.args.iter() {\n-            try!(write!(f.buf, \" '{}'\", str::from_utf8_lossy(arg.as_bytes_no_nul())));\n+            try!(write!(f, \" '{}'\", str::from_utf8_lossy(arg.as_bytes_no_nul())));\n         }\n         Ok(())\n     }\n@@ -361,8 +361,8 @@ impl fmt::Show for ProcessExit {\n     /// Format a ProcessExit enum, to nicely present the information.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            ExitStatus(code) =>  write!(f.buf, \"exit code: {}\", code),\n-            ExitSignal(code) =>  write!(f.buf, \"signal: {}\", code),\n+            ExitStatus(code) =>  write!(f, \"exit code: {}\", code),\n+            ExitSignal(code) =>  write!(f, \"signal: {}\", code),\n         }\n     }\n }"}, {"sha": "e6d416164d008831ad2af668ba3154916f7298d5", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -36,7 +36,7 @@ use mem::replace;\n use option::{Option, Some, None};\n use owned::Box;\n use prelude::drop;\n-use result::{Ok, Err, ResultUnwrap};\n+use result::{Ok, Err};\n use rt;\n use rt::local::Local;\n use rt::rtio::{DontClose, IoFactory, LocalIo, RtioFileStream, RtioTTY};\n@@ -276,13 +276,13 @@ pub fn println(s: &str) {\n /// Similar to `print`, but takes a `fmt::Arguments` structure to be compatible\n /// with the `format_args!` macro.\n pub fn print_args(fmt: &fmt::Arguments) {\n-    with_task_stdout(|io| fmt::write(io, fmt))\n+    with_task_stdout(|io| write!(io, \"{}\", fmt))\n }\n \n /// Similar to `println`, but takes a `fmt::Arguments` structure to be\n /// compatible with the `format_args!` macro.\n pub fn println_args(fmt: &fmt::Arguments) {\n-    with_task_stdout(|io| fmt::writeln(io, fmt))\n+    with_task_stdout(|io| writeln!(io, \"{}\", fmt))\n }\n \n /// Representation of a reader of a standard input stream"}, {"sha": "119cd9aa2ca8848159a7dade3b5c94187a9ed6fd", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -153,6 +153,7 @@ pub use core::mem;\n pub use core::ptr;\n pub use core::raw;\n pub use core::tuple;\n+pub use core::result;\n \n // Run tests with libgreen instead of libnative.\n //\n@@ -218,7 +219,6 @@ pub mod hash;\n \n /* Common data structures */\n \n-pub mod result;\n pub mod option;\n \n /* Tasks and communication */"}, {"sha": "b260f685a34777fbe488d49044d18bff81f64a51", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -251,21 +251,27 @@ macro_rules! format_strbuf(\n /// write!(&mut w, \"formatted {}\", \"arguments\");\n /// ```\n #[macro_export]\n+#[cfg(not(stage0))]\n macro_rules! write(\n     ($dst:expr, $($arg:tt)*) => ({\n-        let dst: &mut ::std::io::Writer = $dst;\n-        format_args!(|args| { ::std::fmt::write(dst, args) }, $($arg)*)\n+        format_args_method!($dst, write_fmt, $($arg)*)\n+    })\n+)\n+#[cfg(stage0)]\n+#[macro_export]\n+macro_rules! write(\n+    ($dst:expr, $($arg:tt)*) => ({\n+        format_args!(|args| { $dst.write_fmt(args) }, $($arg)*)\n     })\n )\n \n /// Equivalent to the `write!` macro, except that a newline is appended after\n /// the message is written.\n #[macro_export]\n macro_rules! writeln(\n-    ($dst:expr, $($arg:tt)*) => ({\n-        let dst: &mut ::std::io::Writer = $dst;\n-        format_args!(|args| { ::std::fmt::writeln(dst, args) }, $($arg)*)\n-    })\n+    ($dst:expr, $fmt:expr $($arg:tt)*) => (\n+        write!($dst, concat!($fmt, \"\\n\") $($arg)*)\n+    )\n )\n \n /// Equivalent to the `println!` macro except that a newline is not printed at"}, {"sha": "e9ea0df2a7b9e4f02b3706a9f6b849827bc75f51", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 10, "deletions": 277, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -18,9 +18,7 @@ use prelude::*;\n use from_str::FromStr;\n use intrinsics;\n use libc::c_int;\n-use mem;\n use num::strconv;\n-use num::{FPCategory, FPNaN, FPInfinite , FPZero, FPSubnormal, FPNormal};\n use num;\n \n pub use core::f32::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n@@ -69,82 +67,7 @@ mod cmath {\n     }\n }\n \n-impl Float for f32 {\n-    #[inline]\n-    fn nan() -> f32 { NAN }\n-\n-    #[inline]\n-    fn infinity() -> f32 { INFINITY }\n-\n-    #[inline]\n-    fn neg_infinity() -> f32 { NEG_INFINITY }\n-\n-    #[inline]\n-    fn neg_zero() -> f32 { -0.0 }\n-\n-    /// Returns `true` if the number is NaN\n-    #[inline]\n-    fn is_nan(self) -> bool { self != self }\n-\n-    /// Returns `true` if the number is infinite\n-    #[inline]\n-    fn is_infinite(self) -> bool {\n-        self == Float::infinity() || self == Float::neg_infinity()\n-    }\n-\n-    /// Returns `true` if the number is neither infinite or NaN\n-    #[inline]\n-    fn is_finite(self) -> bool {\n-        !(self.is_nan() || self.is_infinite())\n-    }\n-\n-    /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n-    #[inline]\n-    fn is_normal(self) -> bool {\n-        self.classify() == FPNormal\n-    }\n-\n-    /// Returns the floating point category of the number. If only one property\n-    /// is going to be tested, it is generally faster to use the specific\n-    /// predicate instead.\n-    fn classify(self) -> FPCategory {\n-        static EXP_MASK: u32 = 0x7f800000;\n-        static MAN_MASK: u32 = 0x007fffff;\n-\n-        let bits: u32 = unsafe { mem::transmute(self) };\n-        match (bits & MAN_MASK, bits & EXP_MASK) {\n-            (0, 0)        => FPZero,\n-            (_, 0)        => FPSubnormal,\n-            (0, EXP_MASK) => FPInfinite,\n-            (_, EXP_MASK) => FPNaN,\n-            _             => FPNormal,\n-        }\n-    }\n-\n-    #[inline]\n-    fn mantissa_digits(_: Option<f32>) -> uint { MANTISSA_DIGITS }\n-\n-    #[inline]\n-    fn digits(_: Option<f32>) -> uint { DIGITS }\n-\n-    #[inline]\n-    fn epsilon() -> f32 { EPSILON }\n-\n-    #[inline]\n-    fn min_exp(_: Option<f32>) -> int { MIN_EXP }\n-\n-    #[inline]\n-    fn max_exp(_: Option<f32>) -> int { MAX_EXP }\n-\n-    #[inline]\n-    fn min_10_exp(_: Option<f32>) -> int { MIN_10_EXP }\n-\n-    #[inline]\n-    fn max_10_exp(_: Option<f32>) -> int { MAX_10_EXP }\n-\n-    #[inline]\n-    fn min_pos_value(_: Option<f32>) -> f32 { MIN_POS_VALUE }\n-\n+impl FloatMath for f32 {\n     /// Constructs a floating point number by multiplying `x` by 2 raised to the\n     /// power of `exp`\n     #[inline]\n@@ -166,61 +89,13 @@ impl Float for f32 {\n         }\n     }\n \n-    /// Returns the mantissa, exponent and sign as integers.\n-    fn integer_decode(self) -> (u64, i16, i8) {\n-        let bits: u32 = unsafe { mem::transmute(self) };\n-        let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };\n-        let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;\n-        let mantissa = if exponent == 0 {\n-            (bits & 0x7fffff) << 1\n-        } else {\n-            (bits & 0x7fffff) | 0x800000\n-        };\n-        // Exponent bias + mantissa shift\n-        exponent -= 127 + 23;\n-        (mantissa as u64, exponent, sign)\n-    }\n-\n     /// Returns the next representable floating-point value in the direction of\n     /// `other`.\n     #[inline]\n     fn next_after(self, other: f32) -> f32 {\n         unsafe { cmath::nextafterf(self, other) }\n     }\n \n-    /// Round half-way cases toward `NEG_INFINITY`\n-    #[inline]\n-    fn floor(self) -> f32 {\n-        unsafe { intrinsics::floorf32(self) }\n-    }\n-\n-    /// Round half-way cases toward `INFINITY`\n-    #[inline]\n-    fn ceil(self) -> f32 {\n-        unsafe { intrinsics::ceilf32(self) }\n-    }\n-\n-    /// Round half-way cases away from `0.0`\n-    #[inline]\n-    fn round(self) -> f32 {\n-        unsafe { intrinsics::roundf32(self) }\n-    }\n-\n-    /// The integer part of the number (rounds towards `0.0`)\n-    #[inline]\n-    fn trunc(self) -> f32 {\n-        unsafe { intrinsics::truncf32(self) }\n-    }\n-\n-    /// The fractional part of the number, satisfying:\n-    ///\n-    /// ```rust\n-    /// let x = 1.65f32;\n-    /// assert!(x == x.trunc() + x.fract())\n-    /// ```\n-    #[inline]\n-    fn fract(self) -> f32 { self - self.trunc() }\n-\n     #[inline]\n     fn max(self, other: f32) -> f32 {\n         unsafe { cmath::fmaxf(self, other) }\n@@ -231,43 +106,6 @@ impl Float for f32 {\n         unsafe { cmath::fminf(self, other) }\n     }\n \n-    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n-    /// error. This produces a more accurate result with better performance than\n-    /// a separate multiplication operation followed by an add.\n-    #[inline]\n-    fn mul_add(self, a: f32, b: f32) -> f32 {\n-        unsafe { intrinsics::fmaf32(self, a, b) }\n-    }\n-\n-    /// The reciprocal (multiplicative inverse) of the number\n-    #[inline]\n-    fn recip(self) -> f32 { 1.0 / self }\n-\n-    fn powi(self, n: i32) -> f32 {\n-        unsafe { intrinsics::powif32(self, n) }\n-    }\n-\n-    #[inline]\n-    fn powf(self, n: f32) -> f32 {\n-        unsafe { intrinsics::powf32(self, n) }\n-    }\n-\n-    /// sqrt(2.0)\n-    #[inline]\n-    fn sqrt2() -> f32 { consts::SQRT2 }\n-\n-    /// 1.0 / sqrt(2.0)\n-    #[inline]\n-    fn frac_1_sqrt2() -> f32 { consts::FRAC_1_SQRT2 }\n-\n-    #[inline]\n-    fn sqrt(self) -> f32 {\n-        unsafe { intrinsics::sqrtf32(self) }\n-    }\n-\n-    #[inline]\n-    fn rsqrt(self) -> f32 { self.sqrt().recip() }\n-\n     #[inline]\n     fn cbrt(self) -> f32 {\n         unsafe { cmath::cbrtf(self) }\n@@ -278,46 +116,6 @@ impl Float for f32 {\n         unsafe { cmath::hypotf(self, other) }\n     }\n \n-    /// Archimedes' constant\n-    #[inline]\n-    fn pi() -> f32 { consts::PI }\n-\n-    /// 2.0 * pi\n-    #[inline]\n-    fn two_pi() -> f32 { consts::PI_2 }\n-\n-    /// pi / 2.0\n-    #[inline]\n-    fn frac_pi_2() -> f32 { consts::FRAC_PI_2 }\n-\n-    /// pi / 3.0\n-    #[inline]\n-    fn frac_pi_3() -> f32 { consts::FRAC_PI_3 }\n-\n-    /// pi / 4.0\n-    #[inline]\n-    fn frac_pi_4() -> f32 { consts::FRAC_PI_4 }\n-\n-    /// pi / 6.0\n-    #[inline]\n-    fn frac_pi_6() -> f32 { consts::FRAC_PI_6 }\n-\n-    /// pi / 8.0\n-    #[inline]\n-    fn frac_pi_8() -> f32 { consts::FRAC_PI_8 }\n-\n-    /// 1 .0/ pi\n-    #[inline]\n-    fn frac_1_pi() -> f32 { consts::FRAC_1_PI }\n-\n-    /// 2.0 / pi\n-    #[inline]\n-    fn frac_2_pi() -> f32 { consts::FRAC_2_PI }\n-\n-    /// 2.0 / sqrt(pi)\n-    #[inline]\n-    fn frac_2_sqrtpi() -> f32 { consts::FRAC_2_SQRTPI }\n-\n     #[inline]\n     fn sin(self) -> f32 {\n         unsafe { intrinsics::sinf32(self) }\n@@ -359,67 +157,13 @@ impl Float for f32 {\n         (self.sin(), self.cos())\n     }\n \n-    /// Euler's number\n-    #[inline]\n-    fn e() -> f32 { consts::E }\n-\n-    /// log2(e)\n-    #[inline]\n-    fn log2_e() -> f32 { consts::LOG2_E }\n-\n-    /// log10(e)\n-    #[inline]\n-    fn log10_e() -> f32 { consts::LOG10_E }\n-\n-    /// ln(2.0)\n-    #[inline]\n-    fn ln_2() -> f32 { consts::LN_2 }\n-\n-    /// ln(10.0)\n-    #[inline]\n-    fn ln_10() -> f32 { consts::LN_10 }\n-\n-    /// Returns the exponential of the number\n-    #[inline]\n-    fn exp(self) -> f32 {\n-        unsafe { intrinsics::expf32(self) }\n-    }\n-\n-    /// Returns 2 raised to the power of the number\n-    #[inline]\n-    fn exp2(self) -> f32 {\n-        unsafe { intrinsics::exp2f32(self) }\n-    }\n-\n     /// Returns the exponential of the number, minus `1`, in a way that is\n     /// accurate even if the number is close to zero\n     #[inline]\n     fn exp_m1(self) -> f32 {\n         unsafe { cmath::expm1f(self) }\n     }\n \n-    /// Returns the natural logarithm of the number\n-    #[inline]\n-    fn ln(self) -> f32 {\n-        unsafe { intrinsics::logf32(self) }\n-    }\n-\n-    /// Returns the logarithm of the number with respect to an arbitrary base\n-    #[inline]\n-    fn log(self, base: f32) -> f32 { self.ln() / base.ln() }\n-\n-    /// Returns the base 2 logarithm of the number\n-    #[inline]\n-    fn log2(self) -> f32 {\n-        unsafe { intrinsics::log2f32(self) }\n-    }\n-\n-    /// Returns the base 10 logarithm of the number\n-    #[inline]\n-    fn log10(self) -> f32 {\n-        unsafe { intrinsics::log10f32(self) }\n-    }\n-\n     /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more\n     /// accurately than if the operations were performed separately\n     #[inline]\n@@ -486,17 +230,6 @@ impl Float for f32 {\n     fn atanh(self) -> f32 {\n         0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n     }\n-\n-    /// Converts to degrees, assuming the number is in radians\n-    #[inline]\n-    fn to_degrees(self) -> f32 { self * (180.0f32 / Float::pi()) }\n-\n-    /// Converts to radians, assuming the number is in degrees\n-    #[inline]\n-    fn to_radians(self) -> f32 {\n-        let value: f32 = Float::pi();\n-        self * (value / 180.0f32)\n-    }\n }\n \n //\n@@ -1000,18 +733,18 @@ mod tests {\n         // are supported in floating-point literals\n         let f1: f32 = from_str_hex(\"1p-123\").unwrap();\n         let f2: f32 = from_str_hex(\"1p-111\").unwrap();\n-        assert_eq!(Float::ldexp(1f32, -123), f1);\n-        assert_eq!(Float::ldexp(1f32, -111), f2);\n+        assert_eq!(FloatMath::ldexp(1f32, -123), f1);\n+        assert_eq!(FloatMath::ldexp(1f32, -111), f2);\n \n-        assert_eq!(Float::ldexp(0f32, -123), 0f32);\n-        assert_eq!(Float::ldexp(-0f32, -123), -0f32);\n+        assert_eq!(FloatMath::ldexp(0f32, -123), 0f32);\n+        assert_eq!(FloatMath::ldexp(-0f32, -123), -0f32);\n \n         let inf: f32 = Float::infinity();\n         let neg_inf: f32 = Float::neg_infinity();\n         let nan: f32 = Float::nan();\n-        assert_eq!(Float::ldexp(inf, -123), inf);\n-        assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n-        assert!(Float::ldexp(nan, -123).is_nan());\n+        assert_eq!(FloatMath::ldexp(inf, -123), inf);\n+        assert_eq!(FloatMath::ldexp(neg_inf, -123), neg_inf);\n+        assert!(FloatMath::ldexp(nan, -123).is_nan());\n     }\n \n     #[test]\n@@ -1024,8 +757,8 @@ mod tests {\n         let (x2, exp2) = f2.frexp();\n         assert_eq!((x1, exp1), (0.5f32, -122));\n         assert_eq!((x2, exp2), (0.5f32, -110));\n-        assert_eq!(Float::ldexp(x1, exp1), f1);\n-        assert_eq!(Float::ldexp(x2, exp2), f2);\n+        assert_eq!(FloatMath::ldexp(x1, exp1), f1);\n+        assert_eq!(FloatMath::ldexp(x2, exp2), f2);\n \n         assert_eq!(0f32.frexp(), (0f32, 0));\n         assert_eq!((-0f32).frexp(), (-0f32, 0));"}, {"sha": "869a275b1d4089b57eb983bc99b599b54dd3f17a", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 12, "deletions": 280, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -16,10 +16,8 @@ use prelude::*;\n \n use from_str::FromStr;\n use intrinsics;\n-use libc::{c_int};\n-use mem;\n-use num::{FPCategory, FPNaN, FPInfinite , FPZero, FPSubnormal, FPNormal};\n-use num::{strconv};\n+use libc::c_int;\n+use num::strconv;\n use num;\n \n pub use core::f64::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n@@ -77,82 +75,7 @@ mod cmath {\n     }\n }\n \n-impl Float for f64 {\n-    #[inline]\n-    fn nan() -> f64 { NAN }\n-\n-    #[inline]\n-    fn infinity() -> f64 { INFINITY }\n-\n-    #[inline]\n-    fn neg_infinity() -> f64 { NEG_INFINITY }\n-\n-    #[inline]\n-    fn neg_zero() -> f64 { -0.0 }\n-\n-    /// Returns `true` if the number is NaN\n-    #[inline]\n-    fn is_nan(self) -> bool { self != self }\n-\n-    /// Returns `true` if the number is infinite\n-    #[inline]\n-    fn is_infinite(self) -> bool {\n-        self == Float::infinity() || self == Float::neg_infinity()\n-    }\n-\n-    /// Returns `true` if the number is neither infinite or NaN\n-    #[inline]\n-    fn is_finite(self) -> bool {\n-        !(self.is_nan() || self.is_infinite())\n-    }\n-\n-    /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n-    #[inline]\n-    fn is_normal(self) -> bool {\n-        self.classify() == FPNormal\n-    }\n-\n-    /// Returns the floating point category of the number. If only one property\n-    /// is going to be tested, it is generally faster to use the specific\n-    /// predicate instead.\n-    fn classify(self) -> FPCategory {\n-        static EXP_MASK: u64 = 0x7ff0000000000000;\n-        static MAN_MASK: u64 = 0x000fffffffffffff;\n-\n-        let bits: u64 = unsafe { mem::transmute(self) };\n-        match (bits & MAN_MASK, bits & EXP_MASK) {\n-            (0, 0)        => FPZero,\n-            (_, 0)        => FPSubnormal,\n-            (0, EXP_MASK) => FPInfinite,\n-            (_, EXP_MASK) => FPNaN,\n-            _             => FPNormal,\n-        }\n-    }\n-\n-    #[inline]\n-    fn mantissa_digits(_: Option<f64>) -> uint { MANTISSA_DIGITS }\n-\n-    #[inline]\n-    fn digits(_: Option<f64>) -> uint { DIGITS }\n-\n-    #[inline]\n-    fn epsilon() -> f64 { EPSILON }\n-\n-    #[inline]\n-    fn min_exp(_: Option<f64>) -> int { MIN_EXP }\n-\n-    #[inline]\n-    fn max_exp(_: Option<f64>) -> int { MAX_EXP }\n-\n-    #[inline]\n-    fn min_10_exp(_: Option<f64>) -> int { MIN_10_EXP }\n-\n-    #[inline]\n-    fn max_10_exp(_: Option<f64>) -> int { MAX_10_EXP }\n-\n-    #[inline]\n-    fn min_pos_value(_: Option<f64>) -> f64 { MIN_POS_VALUE }\n-\n+impl FloatMath for f64 {\n     /// Constructs a floating point number by multiplying `x` by 2 raised to the\n     /// power of `exp`\n     #[inline]\n@@ -174,61 +97,13 @@ impl Float for f64 {\n         }\n     }\n \n-    /// Returns the mantissa, exponent and sign as integers.\n-    fn integer_decode(self) -> (u64, i16, i8) {\n-        let bits: u64 = unsafe { mem::transmute(self) };\n-        let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };\n-        let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;\n-        let mantissa = if exponent == 0 {\n-            (bits & 0xfffffffffffff) << 1\n-        } else {\n-            (bits & 0xfffffffffffff) | 0x10000000000000\n-        };\n-        // Exponent bias + mantissa shift\n-        exponent -= 1023 + 52;\n-        (mantissa, exponent, sign)\n-    }\n-\n     /// Returns the next representable floating-point value in the direction of\n     /// `other`.\n     #[inline]\n     fn next_after(self, other: f64) -> f64 {\n         unsafe { cmath::nextafter(self, other) }\n     }\n \n-    /// Round half-way cases toward `NEG_INFINITY`\n-    #[inline]\n-    fn floor(self) -> f64 {\n-        unsafe { intrinsics::floorf64(self) }\n-    }\n-\n-    /// Round half-way cases toward `INFINITY`\n-    #[inline]\n-    fn ceil(self) -> f64 {\n-        unsafe { intrinsics::ceilf64(self) }\n-    }\n-\n-    /// Round half-way cases away from `0.0`\n-    #[inline]\n-    fn round(self) -> f64 {\n-        unsafe { intrinsics::roundf64(self) }\n-    }\n-\n-    /// The integer part of the number (rounds towards `0.0`)\n-    #[inline]\n-    fn trunc(self) -> f64 {\n-        unsafe { intrinsics::truncf64(self) }\n-    }\n-\n-    /// The fractional part of the number, satisfying:\n-    ///\n-    /// ```rust\n-    /// let x = 1.65f64;\n-    /// assert!(x == x.trunc() + x.fract())\n-    /// ```\n-    #[inline]\n-    fn fract(self) -> f64 { self - self.trunc() }\n-\n     #[inline]\n     fn max(self, other: f64) -> f64 {\n         unsafe { cmath::fmax(self, other) }\n@@ -239,44 +114,6 @@ impl Float for f64 {\n         unsafe { cmath::fmin(self, other) }\n     }\n \n-    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n-    /// error. This produces a more accurate result with better performance than\n-    /// a separate multiplication operation followed by an add.\n-    #[inline]\n-    fn mul_add(self, a: f64, b: f64) -> f64 {\n-        unsafe { intrinsics::fmaf64(self, a, b) }\n-    }\n-\n-    /// The reciprocal (multiplicative inverse) of the number\n-    #[inline]\n-    fn recip(self) -> f64 { 1.0 / self }\n-\n-    #[inline]\n-    fn powf(self, n: f64) -> f64 {\n-        unsafe { intrinsics::powf64(self, n) }\n-    }\n-\n-    #[inline]\n-    fn powi(self, n: i32) -> f64 {\n-        unsafe { intrinsics::powif64(self, n) }\n-    }\n-\n-    /// sqrt(2.0)\n-    #[inline]\n-    fn sqrt2() -> f64 { consts::SQRT2 }\n-\n-    /// 1.0 / sqrt(2.0)\n-    #[inline]\n-    fn frac_1_sqrt2() -> f64 { consts::FRAC_1_SQRT2 }\n-\n-    #[inline]\n-    fn sqrt(self) -> f64 {\n-        unsafe { intrinsics::sqrtf64(self) }\n-    }\n-\n-    #[inline]\n-    fn rsqrt(self) -> f64 { self.sqrt().recip() }\n-\n     #[inline]\n     fn cbrt(self) -> f64 {\n         unsafe { cmath::cbrt(self) }\n@@ -287,46 +124,6 @@ impl Float for f64 {\n         unsafe { cmath::hypot(self, other) }\n     }\n \n-    /// Archimedes' constant\n-    #[inline]\n-    fn pi() -> f64 { consts::PI }\n-\n-    /// 2.0 * pi\n-    #[inline]\n-    fn two_pi() -> f64 { consts::PI_2 }\n-\n-    /// pi / 2.0\n-    #[inline]\n-    fn frac_pi_2() -> f64 { consts::FRAC_PI_2 }\n-\n-    /// pi / 3.0\n-    #[inline]\n-    fn frac_pi_3() -> f64 { consts::FRAC_PI_3 }\n-\n-    /// pi / 4.0\n-    #[inline]\n-    fn frac_pi_4() -> f64 { consts::FRAC_PI_4 }\n-\n-    /// pi / 6.0\n-    #[inline]\n-    fn frac_pi_6() -> f64 { consts::FRAC_PI_6 }\n-\n-    /// pi / 8.0\n-    #[inline]\n-    fn frac_pi_8() -> f64 { consts::FRAC_PI_8 }\n-\n-    /// 1.0 / pi\n-    #[inline]\n-    fn frac_1_pi() -> f64 { consts::FRAC_1_PI }\n-\n-    /// 2.0 / pi\n-    #[inline]\n-    fn frac_2_pi() -> f64 { consts::FRAC_2_PI }\n-\n-    /// 2.0 / sqrt(pi)\n-    #[inline]\n-    fn frac_2_sqrtpi() -> f64 { consts::FRAC_2_SQRTPI }\n-\n     #[inline]\n     fn sin(self) -> f64 {\n         unsafe { intrinsics::sinf64(self) }\n@@ -368,67 +165,13 @@ impl Float for f64 {\n         (self.sin(), self.cos())\n     }\n \n-    /// Euler's number\n-    #[inline]\n-    fn e() -> f64 { consts::E }\n-\n-    /// log2(e)\n-    #[inline]\n-    fn log2_e() -> f64 { consts::LOG2_E }\n-\n-    /// log10(e)\n-    #[inline]\n-    fn log10_e() -> f64 { consts::LOG10_E }\n-\n-    /// ln(2.0)\n-    #[inline]\n-    fn ln_2() -> f64 { consts::LN_2 }\n-\n-    /// ln(10.0)\n-    #[inline]\n-    fn ln_10() -> f64 { consts::LN_10 }\n-\n-    /// Returns the exponential of the number\n-    #[inline]\n-    fn exp(self) -> f64 {\n-        unsafe { intrinsics::expf64(self) }\n-    }\n-\n-    /// Returns 2 raised to the power of the number\n-    #[inline]\n-    fn exp2(self) -> f64 {\n-        unsafe { intrinsics::exp2f64(self) }\n-    }\n-\n     /// Returns the exponential of the number, minus `1`, in a way that is\n     /// accurate even if the number is close to zero\n     #[inline]\n     fn exp_m1(self) -> f64 {\n         unsafe { cmath::expm1(self) }\n     }\n \n-    /// Returns the natural logarithm of the number\n-    #[inline]\n-    fn ln(self) -> f64 {\n-        unsafe { intrinsics::logf64(self) }\n-    }\n-\n-    /// Returns the logarithm of the number with respect to an arbitrary base\n-    #[inline]\n-    fn log(self, base: f64) -> f64 { self.ln() / base.ln() }\n-\n-    /// Returns the base 2 logarithm of the number\n-    #[inline]\n-    fn log2(self) -> f64 {\n-        unsafe { intrinsics::log2f64(self) }\n-    }\n-\n-    /// Returns the base 10 logarithm of the number\n-    #[inline]\n-    fn log10(self) -> f64 {\n-        unsafe { intrinsics::log10f64(self) }\n-    }\n-\n     /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more\n     /// accurately than if the operations were performed separately\n     #[inline]\n@@ -495,17 +238,6 @@ impl Float for f64 {\n     fn atanh(self) -> f64 {\n         0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n     }\n-\n-    /// Converts to degrees, assuming the number is in radians\n-    #[inline]\n-    fn to_degrees(self) -> f64 { self * (180.0f64 / Float::pi()) }\n-\n-    /// Converts to radians, assuming the number is in degrees\n-    #[inline]\n-    fn to_radians(self) -> f64 {\n-        let value: f64 = Float::pi();\n-        self * (value / 180.0)\n-    }\n }\n \n //\n@@ -1003,18 +735,18 @@ mod tests {\n         // are supported in floating-point literals\n         let f1: f64 = from_str_hex(\"1p-123\").unwrap();\n         let f2: f64 = from_str_hex(\"1p-111\").unwrap();\n-        assert_eq!(Float::ldexp(1f64, -123), f1);\n-        assert_eq!(Float::ldexp(1f64, -111), f2);\n+        assert_eq!(FloatMath::ldexp(1f64, -123), f1);\n+        assert_eq!(FloatMath::ldexp(1f64, -111), f2);\n \n-        assert_eq!(Float::ldexp(0f64, -123), 0f64);\n-        assert_eq!(Float::ldexp(-0f64, -123), -0f64);\n+        assert_eq!(FloatMath::ldexp(0f64, -123), 0f64);\n+        assert_eq!(FloatMath::ldexp(-0f64, -123), -0f64);\n \n         let inf: f64 = Float::infinity();\n         let neg_inf: f64 = Float::neg_infinity();\n         let nan: f64 = Float::nan();\n-        assert_eq!(Float::ldexp(inf, -123), inf);\n-        assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n-        assert!(Float::ldexp(nan, -123).is_nan());\n+        assert_eq!(FloatMath::ldexp(inf, -123), inf);\n+        assert_eq!(FloatMath::ldexp(neg_inf, -123), neg_inf);\n+        assert!(FloatMath::ldexp(nan, -123).is_nan());\n     }\n \n     #[test]\n@@ -1027,8 +759,8 @@ mod tests {\n         let (x2, exp2) = f2.frexp();\n         assert_eq!((x1, exp1), (0.5f64, -122));\n         assert_eq!((x2, exp2), (0.5f64, -110));\n-        assert_eq!(Float::ldexp(x1, exp1), f1);\n-        assert_eq!(Float::ldexp(x2, exp2), f2);\n+        assert_eq!(FloatMath::ldexp(x1, exp1), f1);\n+        assert_eq!(FloatMath::ldexp(x2, exp2), f2);\n \n         assert_eq!(0f64.frexp(), (0f64, 0));\n         assert_eq!((-0f64).frexp(), (-0f64, 0));"}, {"sha": "396037d0dbace10cb6d897ee0e80252462441f22", "filename": "src/libstd/num/i16.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi16.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -15,7 +15,6 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n-use str;\n \n pub use core::i16::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "5640e82d077dc3a95eb465d39aebb5d15300bb61", "filename": "src/libstd/num/i32.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi32.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -15,7 +15,6 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n-use str;\n \n pub use core::i32::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "40245691e3456fc118f094e261433dc058572905", "filename": "src/libstd/num/i64.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi64.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -15,7 +15,6 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n-use str;\n \n pub use core::i64::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "7ddddd893e211989cc76ccdb76cba11f28f13402", "filename": "src/libstd/num/i8.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi8.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -15,7 +15,6 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n-use str;\n \n pub use core::i8::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "dc4d80601b7db6a0116eab77f409f584347e4946", "filename": "src/libstd/num/int.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -15,7 +15,6 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n-use str;\n \n pub use core::int::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "ddff42f68dba9fe870fb49fbfb9c89586d692eab", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -62,31 +62,23 @@ impl FromStrRadix for $T {\n /// ```\n #[inline]\n pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n+    use io::{Writer, Seek};\n     // The radix can be as low as 2, so we need at least 64 characters for a\n     // base 2 number, and then we need another for a possible '-' character.\n     let mut buf = [0u8, ..65];\n-    let mut cur = 0;\n-    strconv::int_to_str_bytes_common(n, radix, strconv::SignNeg, |i| {\n-        buf[cur] = i;\n-        cur += 1;\n-    });\n-    f(buf.slice(0, cur))\n+    let amt = {\n+        let mut wr = ::io::BufWriter::new(buf);\n+        (write!(&mut wr, \"{}\", ::fmt::radix(n, radix as u8))).unwrap();\n+        wr.tell().unwrap() as uint\n+    };\n+    f(buf.slice(0, amt))\n }\n \n impl ToStrRadix for $T {\n     /// Convert to a string in a given base.\n     #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n-        use slice::Vector;\n-        use str::StrAllocating;\n-\n-        let mut buf = ::vec::Vec::new();\n-        strconv::int_to_str_bytes_common(*self, radix, strconv::SignNeg, |i| {\n-            buf.push(i);\n-        });\n-        // We know we generated valid utf-8, so we don't need to go through that\n-        // check.\n-        unsafe { str::raw::from_utf8(buf.as_slice()).to_owned() }\n+        format!(\"{}\", ::fmt::radix(*self, radix as u8))\n     }\n }\n "}, {"sha": "3178fcbd66fdb8958e423a352f41942b134f2e33", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 4, "deletions": 150, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -30,71 +30,13 @@ pub use core::num::{checked_next_power_of_two};\n pub use core::num::{from_int, from_i8, from_i16, from_i32, from_i64};\n pub use core::num::{from_uint, from_u8, from_u16, from_u32, from_u64};\n pub use core::num::{from_f32, from_f64};\n+pub use core::num::{FPCategory, FPNaN, FPInfinite, FPZero, FPSubnormal};\n+pub use core::num::{FPNormal, Float};\n \n pub mod strconv;\n \n-/// Used for representing the classification of floating point numbers\n-#[deriving(Eq, Show)]\n-pub enum FPCategory {\n-    /// \"Not a Number\", often obtained by dividing by zero\n-    FPNaN,\n-    /// Positive or negative infinity\n-    FPInfinite ,\n-    /// Positive or negative zero\n-    FPZero,\n-    /// De-normalized floating point representation (less precise than `FPNormal`)\n-    FPSubnormal,\n-    /// A regular floating point number\n-    FPNormal,\n-}\n-\n-/// Operations on primitive floating point numbers.\n-// FIXME(#5527): In a future version of Rust, many of these functions will\n-//               become constants.\n-//\n-// FIXME(#8888): Several of these functions have a parameter named\n-//               `unused_self`. Removing it requires #8888 to be fixed.\n-pub trait Float: Signed + Primitive {\n-    /// Returns the NaN value.\n-    fn nan() -> Self;\n-    /// Returns the infinite value.\n-    fn infinity() -> Self;\n-    /// Returns the negative infinite value.\n-    fn neg_infinity() -> Self;\n-    /// Returns -0.0.\n-    fn neg_zero() -> Self;\n-\n-    /// Returns true if this value is NaN and false otherwise.\n-    fn is_nan(self) -> bool;\n-    /// Returns true if this value is positive infinity or negative infinity and\n-    /// false otherwise.\n-    fn is_infinite(self) -> bool;\n-    /// Returns true if this number is neither infinite nor NaN.\n-    fn is_finite(self) -> bool;\n-    /// Returns true if this number is neither zero, infinite, denormal, or NaN.\n-    fn is_normal(self) -> bool;\n-    /// Returns the category that this number falls into.\n-    fn classify(self) -> FPCategory;\n-\n-    // FIXME (#5527): These should be associated constants\n-\n-    /// Returns the number of binary digits of mantissa that this type supports.\n-    fn mantissa_digits(unused_self: Option<Self>) -> uint;\n-    /// Returns the number of base-10 digits of precision that this type supports.\n-    fn digits(unused_self: Option<Self>) -> uint;\n-    /// Returns the difference between 1.0 and the smallest representable number larger than 1.0.\n-    fn epsilon() -> Self;\n-    /// Returns the minimum binary exponent that this type can represent.\n-    fn min_exp(unused_self: Option<Self>) -> int;\n-    /// Returns the maximum binary exponent that this type can represent.\n-    fn max_exp(unused_self: Option<Self>) -> int;\n-    /// Returns the minimum base-10 exponent that this type can represent.\n-    fn min_10_exp(unused_self: Option<Self>) -> int;\n-    /// Returns the maximum base-10 exponent that this type can represent.\n-    fn max_10_exp(unused_self: Option<Self>) -> int;\n-    /// Returns the smallest normalized positive number that this type can represent.\n-    fn min_pos_value(unused_self: Option<Self>) -> Self;\n-\n+/// Mathematical operations on primitive floating point numbers.\n+pub trait FloatMath: Float {\n     /// Constructs a floating point number created by multiplying `x` by 2\n     /// raised to the power of `exp`.\n     fn ldexp(x: Self, exp: int) -> Self;\n@@ -105,82 +47,22 @@ pub trait Float: Signed + Primitive {\n     ///\n     ///  * `0.5 <= abs(x) < 1.0`\n     fn frexp(self) -> (Self, int);\n-    /// Returns the mantissa, exponent and sign as integers, respectively.\n-    fn integer_decode(self) -> (u64, i16, i8);\n \n     /// Returns the next representable floating-point value in the direction of\n     /// `other`.\n     fn next_after(self, other: Self) -> Self;\n \n-    /// Return the largest integer less than or equal to a number.\n-    fn floor(self) -> Self;\n-    /// Return the smallest integer greater than or equal to a number.\n-    fn ceil(self) -> Self;\n-    /// Return the nearest integer to a number. Round half-way cases away from\n-    /// `0.0`.\n-    fn round(self) -> Self;\n-    /// Return the integer part of a number.\n-    fn trunc(self) -> Self;\n-    /// Return the fractional part of a number.\n-    fn fract(self) -> Self;\n-\n     /// Returns the maximum of the two numbers.\n     fn max(self, other: Self) -> Self;\n     /// Returns the minimum of the two numbers.\n     fn min(self, other: Self) -> Self;\n \n-    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n-    /// error. This produces a more accurate result with better performance than\n-    /// a separate multiplication operation followed by an add.\n-    fn mul_add(self, a: Self, b: Self) -> Self;\n-    /// Take the reciprocal (inverse) of a number, `1/x`.\n-    fn recip(self) -> Self;\n-\n-    /// Raise a number to an integer power.\n-    ///\n-    /// Using this function is generally faster than using `powf`\n-    fn powi(self, n: i32) -> Self;\n-    /// Raise a number to a floating point power.\n-    fn powf(self, n: Self) -> Self;\n-\n-    /// sqrt(2.0).\n-    fn sqrt2() -> Self;\n-    /// 1.0 / sqrt(2.0).\n-    fn frac_1_sqrt2() -> Self;\n-\n-    /// Take the square root of a number.\n-    fn sqrt(self) -> Self;\n-    /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n-    fn rsqrt(self) -> Self;\n     /// Take the cubic root of a number.\n     fn cbrt(self) -> Self;\n     /// Calculate the length of the hypotenuse of a right-angle triangle given\n     /// legs of length `x` and `y`.\n     fn hypot(self, other: Self) -> Self;\n \n-    // FIXME (#5527): These should be associated constants\n-\n-    /// Archimedes' constant.\n-    fn pi() -> Self;\n-    /// 2.0 * pi.\n-    fn two_pi() -> Self;\n-    /// pi / 2.0.\n-    fn frac_pi_2() -> Self;\n-    /// pi / 3.0.\n-    fn frac_pi_3() -> Self;\n-    /// pi / 4.0.\n-    fn frac_pi_4() -> Self;\n-    /// pi / 6.0.\n-    fn frac_pi_6() -> Self;\n-    /// pi / 8.0.\n-    fn frac_pi_8() -> Self;\n-    /// 1.0 / pi.\n-    fn frac_1_pi() -> Self;\n-    /// 2.0 / pi.\n-    fn frac_2_pi() -> Self;\n-    /// 2.0 / sqrt(pi).\n-    fn frac_2_sqrtpi() -> Self;\n-\n     /// Computes the sine of a number (in radians).\n     fn sin(self) -> Self;\n     /// Computes the cosine of a number (in radians).\n@@ -206,32 +88,9 @@ pub trait Float: Signed + Primitive {\n     /// `(sin(x), cos(x))`.\n     fn sin_cos(self) -> (Self, Self);\n \n-    /// Euler's number.\n-    fn e() -> Self;\n-    /// log2(e).\n-    fn log2_e() -> Self;\n-    /// log10(e).\n-    fn log10_e() -> Self;\n-    /// ln(2.0).\n-    fn ln_2() -> Self;\n-    /// ln(10.0).\n-    fn ln_10() -> Self;\n-\n-    /// Returns `e^(self)`, (the exponential function).\n-    fn exp(self) -> Self;\n-    /// Returns 2 raised to the power of the number, `2^(self)`.\n-    fn exp2(self) -> Self;\n     /// Returns the exponential of the number, minus 1, in a way that is\n     /// accurate even if the number is close to zero.\n     fn exp_m1(self) -> Self;\n-    /// Returns the natural logarithm of the number.\n-    fn ln(self) -> Self;\n-    /// Returns the logarithm of the number with respect to an arbitrary base.\n-    fn log(self, base: Self) -> Self;\n-    /// Returns the base 2 logarithm of the number.\n-    fn log2(self) -> Self;\n-    /// Returns the base 10 logarithm of the number.\n-    fn log10(self) -> Self;\n     /// Returns the natural logarithm of the number plus 1 (`ln(1+n)`) more\n     /// accurately than if the operations were performed separately.\n     fn ln_1p(self) -> Self;\n@@ -248,11 +107,6 @@ pub trait Float: Signed + Primitive {\n     fn acosh(self) -> Self;\n     /// Inverse hyperbolic tangent function.\n     fn atanh(self) -> Self;\n-\n-    /// Convert radians to degrees.\n-    fn to_degrees(self) -> Self;\n-    /// Convert degrees to radians.\n-    fn to_radians(self) -> Self;\n }\n \n /// A generic trait for converting a value to a string with a radix (base)"}, {"sha": "e58872b8395a6c388cc974eb83aa007c2bd3de6e", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -19,7 +19,6 @@ use num::{Float, FPNaN, FPInfinite, ToPrimitive};\n use num;\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use option::{None, Option, Some};\n-use result::ResultUnwrap;\n use slice::{CloneableVector, ImmutableVector, MutableVector};\n use std::cmp::{Ord, Eq};\n use str::{StrAllocating, StrSlice};\n@@ -170,6 +169,7 @@ static NAN_BUF:          [u8, ..3] = ['N' as u8, 'a' as u8, 'N' as u8];\n  * # Failure\n  * - Fails if `radix` < 2 or `radix` > 36.\n  */\n+#[deprecated = \"format!() and friends should be favored instead\"]\n pub fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f: |u8|) {\n     assert!(2 <= radix && radix <= 36);\n \n@@ -258,6 +258,7 @@ pub fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f:\n  * - Fails if `radix` > 25 and `exp_format` is `ExpBin` due to conflict\n  *   between digit and exponent sign `'p'`.\n  */\n+#[allow(deprecated)]\n pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+\n                                   Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n         num: T, radix: uint, negative_zero: bool,\n@@ -820,7 +821,6 @@ mod bench {\n         use super::test::Bencher;\n         use rand::{XorShiftRng, Rng};\n         use num::ToStrRadix;\n-        use realstd::result::ResultUnwrap;\n \n         #[bench]\n         fn to_str_bin(b: &mut Bencher) {\n@@ -857,7 +857,6 @@ mod bench {\n         use super::test::Bencher;\n         use rand::{XorShiftRng, Rng};\n         use num::ToStrRadix;\n-        use realstd::result::ResultUnwrap;\n \n         #[bench]\n         fn to_str_bin(b: &mut Bencher) {\n@@ -894,7 +893,6 @@ mod bench {\n         use super::test::Bencher;\n         use rand::{XorShiftRng, Rng};\n         use f64;\n-        use realstd::result::ResultUnwrap;\n \n         #[bench]\n         fn float_to_str(b: &mut Bencher) {"}, {"sha": "65ac46af5aa0c80bdbc780119f221a34f1ef142b", "filename": "src/libstd/num/u16.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu16.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -15,7 +15,6 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n-use str;\n \n pub use core::u16::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "d549e4d0d636253aee6d7398f4f940344d6b32be", "filename": "src/libstd/num/u32.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu32.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -15,7 +15,6 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n-use str;\n \n pub use core::u32::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "3773e56f4d16df1f00d51025911947936fb8b9cf", "filename": "src/libstd/num/u64.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu64.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -15,7 +15,6 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n-use str;\n \n pub use core::u64::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "372e38d66521f1173e33e3e8e9e3ebb87db25839", "filename": "src/libstd/num/u8.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu8.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -15,7 +15,6 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n-use str;\n \n pub use core::u8::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "c419276fa24518024d4494e495f70e34ead2c155", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -15,7 +15,6 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n-use str;\n \n pub use core::uint::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "7977c647606775f695f4a84480a8dce5dfe9df46", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -63,31 +63,23 @@ impl FromStrRadix for $T {\n /// ```\n #[inline]\n pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n+    use io::{Writer, Seek};\n     // The radix can be as low as 2, so we need at least 64 characters for a\n-    // base 2 number.\n-    let mut buf = [0u8, ..64];\n-    let mut cur = 0;\n-    strconv::int_to_str_bytes_common(n, radix, strconv::SignNone, |i| {\n-        buf[cur] = i;\n-        cur += 1;\n-    });\n-    f(buf.slice(0, cur))\n+    // base 2 number, and then we need another for a possible '-' character.\n+    let mut buf = [0u8, ..65];\n+    let amt = {\n+        let mut wr = ::io::BufWriter::new(buf);\n+        (write!(&mut wr, \"{}\", ::fmt::radix(n, radix as u8))).unwrap();\n+        wr.tell().unwrap() as uint\n+    };\n+    f(buf.slice(0, amt))\n }\n \n impl ToStrRadix for $T {\n     /// Convert to a string in a given base.\n     #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n-        use slice::Vector;\n-        use str::StrAllocating;\n-\n-        let mut buf = ::vec::Vec::new();\n-        strconv::int_to_str_bytes_common(*self, radix, strconv::SignNone, |i| {\n-            buf.push(i);\n-        });\n-        // We know we generated valid utf-8, so we don't need to go through that\n-        // check.\n-        unsafe { str::raw::from_utf8(buf.as_slice()).to_owned() }\n+        format!(\"{}\", ::fmt::radix(*self, radix as u8))\n     }\n }\n "}, {"sha": "a4705b78caab7419c9a53e3727c095a9dcfc2340", "filename": "src/libstd/os.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -1073,19 +1073,19 @@ impl fmt::Show for MapError {\n             ErrAlreadyExists => \"File mapping for specified file already exists\",\n             ErrZeroLength => \"Zero-length mapping not allowed\",\n             ErrUnknown(code) => {\n-                return write!(out.buf, \"Unknown error = {}\", code)\n+                return write!(out, \"Unknown error = {}\", code)\n             },\n             ErrVirtualAlloc(code) => {\n-                return write!(out.buf, \"VirtualAlloc failure = {}\", code)\n+                return write!(out, \"VirtualAlloc failure = {}\", code)\n             },\n             ErrCreateFileMappingW(code) => {\n-                return write!(out.buf, \"CreateFileMappingW failure = {}\", code)\n+                return write!(out, \"CreateFileMappingW failure = {}\", code)\n             },\n             ErrMapViewOfFile(code) => {\n-                return write!(out.buf, \"MapViewOfFile failure = {}\", code)\n+                return write!(out, \"MapViewOfFile failure = {}\", code)\n             }\n         };\n-        write!(out.buf, \"{}\", str)\n+        write!(out, \"{}\", str)\n     }\n }\n "}, {"sha": "bd6684b390572b217e717aff2305146e30288239", "filename": "src/libstd/owned.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fowned.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -14,6 +14,7 @@ use any::{Any, AnyRefExt};\n use clone::Clone;\n use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering};\n use default::Default;\n+use fmt;\n use intrinsics;\n use mem;\n use raw::TraitObject;\n@@ -99,3 +100,16 @@ impl AnyOwnExt for Box<Any> {\n         }\n     }\n }\n+\n+impl<T: fmt::Show> fmt::Show for Box<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        (**self).fmt(f)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl fmt::Show for Box<Any> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"Box<Any>\")\n+    }\n+}"}, {"sha": "e39d8d34447a465e4eb54e8aaa91e762fb50e026", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -64,13 +64,12 @@ pub use iter::{Iterator, DoubleEndedIterator, RandomAccessIterator, CloneableIte\n pub use iter::{OrdIterator, MutableDoubleEndedIterator, ExactSize};\n pub use num::{Num, NumCast, CheckedAdd, CheckedSub, CheckedMul};\n pub use num::{Signed, Unsigned};\n-pub use num::{Primitive, Int, Float, ToPrimitive, FromPrimitive};\n+pub use num::{Primitive, Int, Float, FloatMath, ToPrimitive, FromPrimitive};\n pub use option::Expect;\n pub use owned::Box;\n pub use path::{GenericPath, Path, PosixPath, WindowsPath};\n pub use ptr::RawPtr;\n pub use io::{Buffer, Writer, Reader, Seek};\n-pub use result::{ResultUnwrap, ResultUnwrapErr};\n pub use str::{Str, StrVector, StrSlice, OwnedStr, IntoMaybeOwned};\n pub use str::{StrAllocating};\n pub use to_str::{ToStr, IntoStr};"}, {"sha": "35f32d0872802d3e3b8ad11b869d08022c5ba4d2", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -25,7 +25,7 @@ use option::{Some, None, Option};\n use ptr::RawPtr;\n use reflect;\n use reflect::{MovePtr, align};\n-use result::{Ok, Err, ResultUnwrap};\n+use result::{Ok, Err};\n use str::StrSlice;\n use to_str::ToStr;\n use slice::Vector;"}, {"sha": "ecbc164590b5e85b81a21c1925676bd28c8cbf70", "filename": "src/libstd/result.rs", "status": "removed", "additions": 0, "deletions": 312, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/84406d438c6c49aa63875096e5f3cca1a3879f17/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84406d438c6c49aa63875096e5f3cca1a3879f17/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=84406d438c6c49aa63875096e5f3cca1a3879f17", "patch": "@@ -1,312 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Error handling with the `Result` type\n-//!\n-//! `Result<T>` is the type used for returning and propagating\n-//! errors. It is an enum with the variants, `Ok(T)`, representing\n-//! success and containing a value, and `Err(E)`, representing error\n-//! and containing an error value.\n-//!\n-//! ~~~\n-//! enum Result<T, E> {\n-//!    Ok(T),\n-//!    Err(E)\n-//! }\n-//! ~~~\n-//!\n-//! Functions return `Result` whenever errors are expected and\n-//! recoverable. In the `std` crate `Result` is most prominently used\n-//! for [I/O](../io/index.html).\n-//!\n-//! A simple function returning `Result` might be\n-//! defined and used like so:\n-//!\n-//! ~~~\n-//! #[deriving(Show)]\n-//! enum Version { Version1, Version2 }\n-//!\n-//! fn parse_version(header: &[u8]) -> Result<Version, &'static str> {\n-//!     if header.len() < 1 {\n-//!         return Err(\"invalid header length\");\n-//!     }\n-//!     match header[0] {\n-//!         1 => Ok(Version1),\n-//!         2 => Ok(Version2),\n-//!         _ => Err(\"invalid version\")\n-//!     }\n-//! }\n-//!\n-//! let version = parse_version(&[1, 2, 3, 4]);\n-//! match version {\n-//!     Ok(v) => {\n-//!         println!(\"working with version: {}\", v);\n-//!     }\n-//!     Err(e) => {\n-//!         println!(\"error parsing header: {}\", e);\n-//!     }\n-//! }\n-//! ~~~\n-//!\n-//! Pattern matching on `Result`s is clear and straightforward for\n-//! simple cases, but `Result` comes with some convenience methods\n-//! that make working it more succinct.\n-//!\n-//! ~~~\n-//! let good_result: Result<int, int> = Ok(10);\n-//! let bad_result: Result<int, int> = Err(10);\n-//!\n-//! // The `is_ok` and `is_err` methods do what they say.\n-//! assert!(good_result.is_ok() && !good_result.is_err());\n-//! assert!(bad_result.is_err() && !bad_result.is_ok());\n-//!\n-//! // `map` consumes the `Result` and produces another.\n-//! let good_result: Result<int, int> = good_result.map(|i| i + 1);\n-//! let bad_result: Result<int, int> = bad_result.map(|i| i - 1);\n-//!\n-//! // Use `and_then` to continue the computation.\n-//! let good_result: Result<bool, int> = good_result.and_then(|i| Ok(i == 11));\n-//!\n-//! // Use `or_else` to handle the error.\n-//! let bad_result: Result<int, int> = bad_result.or_else(|i| Ok(11));\n-//!\n-//! // Consume the result and return the contents with `unwrap`.\n-//! let final_awesome_result = good_result.ok().unwrap();\n-//! ~~~\n-//!\n-//! # Results must be used\n-//!\n-//! A common problem with using return values to indicate errors is\n-//! that it is easy to ignore the return value, thus failing to handle\n-//! the error. Result is annotated with the #[must_use] attribute,\n-//! which will cause the compiler to issue a warning when a Result\n-//! value is ignored. This makes `Result` especially useful with\n-//! functions that may encounter errors but don't otherwise return a\n-//! useful value.\n-//!\n-//! Consider the `write_line` method defined for I/O types\n-//! by the [`Writer`](../io/trait.Writer.html) trait:\n-//!\n-//! ~~~\n-//! use std::io::IoError;\n-//!\n-//! trait Writer {\n-//!     fn write_line(&mut self, s: &str) -> Result<(), IoError>;\n-//! }\n-//! ~~~\n-//!\n-//! *Note: The actual definition of `Writer` uses `IoResult`, which\n-//! is just a synonym for `Result<T, IoError>`.*\n-//!\n-//! This method doesn`t produce a value, but the write may\n-//! fail. It's crucial to handle the error case, and *not* write\n-//! something like this:\n-//!\n-//! ~~~ignore\n-//! use std::io::{File, Open, Write};\n-//!\n-//! let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n-//! // If `write_line` errors, then we'll never know, because the return\n-//! // value is ignored.\n-//! file.write_line(\"important message\");\n-//! drop(file);\n-//! ~~~\n-//!\n-//! If you *do* write that in Rust, the compiler will by give you a\n-//! warning (by default, controlled by the `unused_must_use` lint).\n-//!\n-//! You might instead, if you don't want to handle the error, simply\n-//! fail, by converting to an `Option` with `ok`, then asserting\n-//! success with `expect`. This will fail if the write fails, proving\n-//! a marginally useful message indicating why:\n-//!\n-//! ~~~no_run\n-//! use std::io::{File, Open, Write};\n-//!\n-//! let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n-//! file.write_line(\"important message\").ok().expect(\"failed to write message\");\n-//! drop(file);\n-//! ~~~\n-//!\n-//! You might also simply assert success:\n-//!\n-//! ~~~no_run\n-//! # use std::io::{File, Open, Write};\n-//!\n-//! # let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n-//! assert!(file.write_line(\"important message\").is_ok());\n-//! # drop(file);\n-//! ~~~\n-//!\n-//! Or propagate the error up the call stack with `try!`:\n-//!\n-//! ~~~\n-//! # use std::io::{File, Open, Write, IoError};\n-//! fn write_message() -> Result<(), IoError> {\n-//!     let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n-//!     try!(file.write_line(\"important message\"));\n-//!     drop(file);\n-//!     return Ok(());\n-//! }\n-//! ~~~\n-//!\n-//! # The `try!` macro\n-//!\n-//! When writing code that calls many functions that return the\n-//! `Result` type, the error handling can be tedious.  The `try!`\n-//! macro hides some of the boilerplate of propagating errors up the\n-//! call stack.\n-//!\n-//! It replaces this:\n-//!\n-//! ~~~\n-//! use std::io::{File, Open, Write, IoError};\n-//!\n-//! struct Info { name: ~str, age: int, rating: int }\n-//!\n-//! fn write_info(info: &Info) -> Result<(), IoError> {\n-//!     let mut file = File::open_mode(&Path::new(\"my_best_friends.txt\"), Open, Write);\n-//!     // Early return on error\n-//!     match file.write_line(format!(\"name: {}\", info.name)) {\n-//!         Ok(_) => (),\n-//!         Err(e) => return Err(e)\n-//!     }\n-//!     match file.write_line(format!(\"age: {}\", info.age)) {\n-//!         Ok(_) => (),\n-//!         Err(e) => return Err(e)\n-//!     }\n-//!     return file.write_line(format!(\"rating: {}\", info.rating));\n-//! }\n-//! ~~~\n-//!\n-//! With this:\n-//!\n-//! ~~~\n-//! use std::io::{File, Open, Write, IoError};\n-//!\n-//! struct Info { name: ~str, age: int, rating: int }\n-//!\n-//! fn write_info(info: &Info) -> Result<(), IoError> {\n-//!     let mut file = File::open_mode(&Path::new(\"my_best_friends.txt\"), Open, Write);\n-//!     // Early return on error\n-//!     try!(file.write_line(format!(\"name: {}\", info.name)));\n-//!     try!(file.write_line(format!(\"age: {}\", info.age)));\n-//!     try!(file.write_line(format!(\"rating: {}\", info.rating)));\n-//!     return Ok(());\n-//! }\n-//! ~~~\n-//!\n-//! *It's much nicer!*\n-//!\n-//! Wrapping an expression in `try!` will result in the unwrapped\n-//! success (`Ok`) value, unless the result is `Err`, in which case\n-//! `Err` is returned early from the enclosing function. Its simple definition\n-//! makes it clear:\n-//!\n-//! ~~~\n-//! # #![feature(macro_rules)]\n-//! macro_rules! try(\n-//!     ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n-//! )\n-//! # fn main() { }\n-//! ~~~\n-//!\n-//! `try!` is imported by the prelude, and is available everywhere.\n-//!\n-//! # `Result` and `Option`\n-//!\n-//! The `Result` and [`Option`](../option/index.html) types are\n-//! similar and complementary: they are often employed to indicate a\n-//! lack of a return value; and they are trivially converted between\n-//! each other, so `Result`s are often handled by first converting to\n-//! `Option` with the [`ok`](../../core/result/enum.Result.html#method.ok) and\n-//! [`err`](../../core/result/enum.Result.html#method.ok) methods.\n-//!\n-//! Whereas `Option` only indicates the lack of a value, `Result` is\n-//! specifically for error reporting, and carries with it an error\n-//! value.  Sometimes `Option` is used for indicating errors, but this\n-//! is only for simple cases and is generally discouraged. Even when\n-//! there is no useful error value to return, prefer `Result<T, ()>`.\n-//!\n-//! Converting to an `Option` with `ok()` to handle an error:\n-//!\n-//! ~~~\n-//! use std::io::Timer;\n-//! let mut t = Timer::new().ok().expect(\"failed to create timer!\");\n-//! ~~~\n-//!\n-//! # `Result` vs. `fail!`\n-//!\n-//! `Result` is for recoverable errors; `fail!` is for unrecoverable\n-//! errors. Callers should always be able to avoid failure if they\n-//! take the proper precautions, for example, calling `is_some()`\n-//! on an `Option` type before calling `unwrap`.\n-//!\n-//! The suitability of `fail!` as an error handling mechanism is\n-//! limited by Rust's lack of any way to \"catch\" and resume execution\n-//! from a thrown exception. Therefore using failure for error\n-//! handling requires encapsulating fallable code in a task. Calling\n-//! the `fail!` macro, or invoking `fail!` indirectly should be\n-//! avoided as an error reporting strategy. Failure is only for\n-//! unrecoverable errors and a failing task is typically the sign of\n-//! a bug.\n-//!\n-//! A module that instead returns `Results` is alerting the caller\n-//! that failure is possible, and providing precise control over how\n-//! it is handled.\n-//!\n-//! Furthermore, failure may not be recoverable at all, depending on\n-//! the context. The caller of `fail!` should assume that execution\n-//! will not resume after failure, that failure is catastrophic.\n-\n-use fmt::Show;\n-\n-pub use core::result::{Result, Ok, Err, collect, fold, fold_};\n-\n-// FIXME: These traits should not exist. Once std::fmt is moved to libcore,\n-//        these can once again become inherent methods on Result.\n-\n-/// Temporary trait for unwrapping a result\n-pub trait ResultUnwrap<T, E> {\n-    /// Unwraps a result, yielding the content of an `Ok`.\n-    ///\n-    /// Fails if the value is an `Err`.\n-    fn unwrap(self) -> T;\n-}\n-\n-/// Temporary trait for unwrapping the error of a result\n-pub trait ResultUnwrapErr<T, E> {\n-    /// Unwraps a result, yielding the content of an `Err`.\n-    ///\n-    /// Fails if the value is an `Ok`.\n-    fn unwrap_err(self) -> E;\n-}\n-\n-impl<T, E: Show> ResultUnwrap<T, E> for Result<T, E> {\n-    #[inline]\n-    fn unwrap(self) -> T {\n-        match self {\n-            Ok(t) => t,\n-            Err(e) =>\n-                fail!(\"called `Result::unwrap()` on an `Err` value: {}\", e)\n-        }\n-    }\n-}\n-\n-impl<T: Show, E> ResultUnwrapErr<T, E> for Result<T, E> {\n-    #[inline]\n-    fn unwrap_err(self) -> E {\n-        match self {\n-            Ok(t) =>\n-                fail!(\"called `Result::unwrap_err()` on an `Ok` value: {}\", t),\n-            Err(e) => e\n-        }\n-    }\n-}"}, {"sha": "1cc513825a707e50831692cd7af452d8b70cb442", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -295,24 +295,12 @@ pub mod eabi {\n     }\n }\n \n-#[cold]\n-#[no_mangle]\n-#[cfg(not(test))]\n-pub extern fn rust_fail_bounds_check(file: *u8, line: uint,\n-                                     index: uint, len: uint) -> ! {\n-    use str::raw::c_str_to_static_slice;\n-\n-    let msg = format!(\"index out of bounds: the len is {} but the index is {}\",\n-                      len as uint, index as uint);\n-    begin_unwind(msg, unsafe { c_str_to_static_slice(file as *i8) }, line)\n-}\n-\n // Entry point of failure from the libcore crate\n #[no_mangle]\n #[cfg(not(test))]\n-pub extern fn rust_begin_unwind(msg: &str, file: &'static str, line: uint) -> ! {\n-    use str::StrAllocating;\n-    begin_unwind(msg.to_owned(), file, line)\n+pub extern fn rust_begin_unwind(msg: &fmt::Arguments,\n+                                file: &'static str, line: uint) -> ! {\n+    begin_unwind_fmt(msg, file, line)\n }\n \n /// The entry point for unwinding with a formatted message.\n@@ -402,9 +390,9 @@ fn begin_unwind_inner(msg: Box<Any:Send>,\n                 Some(mut stderr) => {\n                     Local::put(task);\n                     // FIXME: what to do when the task printing fails?\n-                    let _err = format_args!(|args| ::fmt::writeln(stderr, args),\n-                                            \"task '{}' failed at '{}', {}:{}\",\n-                                            n, msg_s, file, line);\n+                    let _err = write!(stderr,\n+                                      \"task '{}' failed at '{}', {}:{}\\n\",\n+                                      n, msg_s, file, line);\n                     if backtrace::log_enabled() {\n                         let _err = backtrace::write(stderr);\n                     }"}, {"sha": "5f9ea14a64711467c432ea1474a4d09b7c5e493a", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -110,8 +110,9 @@ impl io::Writer for Stdio {\n }\n \n pub fn dumb_println(args: &fmt::Arguments) {\n+    use io::Writer;\n     let mut w = Stderr;\n-    let _ = fmt::writeln(&mut w as &mut io::Writer, args);\n+    let _ = writeln!(&mut w, \"{}\", args);\n }\n \n pub fn abort(msg: &str) -> ! {"}, {"sha": "5c875b4a2ad088acd92035d2c85f498c12e982cd", "filename": "src/libstd/task.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -49,7 +49,6 @@ use str::{Str, SendStr, IntoMaybeOwned};\n \n #[cfg(test)] use any::AnyRefExt;\n #[cfg(test)] use owned::AnyOwnExt;\n-#[cfg(test)] use realstd::result::ResultUnwrap;\n #[cfg(test)] use result;\n #[cfg(test)] use str::StrAllocating;\n "}, {"sha": "bc53d2bec8d6e3ca2b7004af7c940b2fd9f735cf", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -155,7 +155,7 @@ impl Architecture {\n \n impl fmt::Show for Abi {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"\\\"{}\\\"\", self.name())\n+        write!(f, \"\\\"{}\\\"\", self.name())\n     }\n }\n "}, {"sha": "edcb8c32ecc40dc2b3dec63d81fa495efb9d8779", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -711,7 +711,7 @@ pub enum IntTy {\n \n impl fmt::Show for IntTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}\",\n+        write!(f, \"{}\",\n                ast_util::int_ty_to_str(*self, None, ast_util::AutoSuffix))\n     }\n }\n@@ -727,7 +727,7 @@ pub enum UintTy {\n \n impl fmt::Show for UintTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}\",\n+        write!(f, \"{}\",\n                ast_util::uint_ty_to_str(*self, None, ast_util::AutoSuffix))\n     }\n }\n@@ -741,7 +741,7 @@ pub enum FloatTy {\n \n impl fmt::Show for FloatTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}\", ast_util::float_ty_to_str(*self))\n+        write!(f, \"{}\", ast_util::float_ty_to_str(*self))\n     }\n }\n "}, {"sha": "f1561ea31f91bcae60fe5f511e09c5c58a332f91", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -41,7 +41,7 @@ impl PathElem {\n impl fmt::Show for PathElem {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let slot = token::get_name(self.name());\n-        write!(f.buf, \"{}\", slot)\n+        write!(f, \"{}\", slot)\n     }\n }\n "}, {"sha": "b7700cf396d48dba6d2e3266ea70bcac685d5e53", "filename": "src/libsyntax/crateid.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibsyntax%2Fcrateid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibsyntax%2Fcrateid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcrateid.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -33,16 +33,16 @@ pub struct CrateId {\n \n impl fmt::Show for CrateId {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f.buf, \"{}\", self.path));\n+        try!(write!(f, \"{}\", self.path));\n         let version = match self.version {\n             None => \"0.0\",\n             Some(ref version) => version.as_slice(),\n         };\n         if self.path == self.name ||\n                 self.path.as_slice().ends_with(format!(\"/{}\", self.name)) {\n-            write!(f.buf, \"\\\\#{}\", version)\n+            write!(f, \"\\\\#{}\", version)\n         } else {\n-            write!(f.buf, \"\\\\#{}:{}\", self.name, version)\n+            write!(f, \"\\\\#{}:{}\", self.name, version)\n         }\n     }\n }"}, {"sha": "06b56bbe472a250e804a429ff29596d4371884d9", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -281,7 +281,10 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n                                 ext::fmt::expand_syntax_ext));\n     syntax_expanders.insert(intern(\"format_args\"),\n                             builtin_normal_expander(\n-                                ext::format::expand_args));\n+                                ext::format::expand_format_args));\n+    syntax_expanders.insert(intern(\"format_args_method\"),\n+                            builtin_normal_expander(\n+                                ext::format::expand_format_args_method));\n     syntax_expanders.insert(intern(\"env\"),\n                             builtin_normal_expander(\n                                     ext::env::expand_env));"}, {"sha": "343100d3a8ef6194b0100edca159c0fdb2628dd6", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -120,23 +120,18 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n     // AST construction!\n     // we're basically calling\n     //\n-    // format_arg!(|__args| ::std::fmt::write(fmt.buf, __args), \"<format_string>\", exprs...)\n+    // format_arg_method!(fmt, write_fmt, \"<format_string>\", exprs...)\n     //\n     // but doing it directly via ext::format.\n     let formatter = substr.nonself_args[0];\n-    let buf = cx.expr_field_access(span, formatter, cx.ident_of(\"buf\"));\n-\n-    let std_write = vec!(cx.ident_of(\"std\"), cx.ident_of(\"fmt\"), cx.ident_of(\"write\"));\n-    let args = cx.ident_of(\"__args\");\n-    let write_call = cx.expr_call_global(span, std_write, vec!(buf, cx.expr_ident(span, args)));\n-    let format_closure = cx.lambda_expr(span, vec!(args), write_call);\n \n+    let meth = cx.ident_of(\"write_fmt\");\n     let s = token::intern_and_get_ident(format_string.as_slice());\n     let format_string = cx.expr_str(span, s);\n \n     // phew, not our responsibility any more!\n     format::expand_preparsed_format_args(cx, span,\n-                                         format_closure,\n+                                         format::MethodCall(formatter, meth),\n                                          format_string, exprs, Vec::new(),\n                                          HashMap::new())\n }"}, {"sha": "e92ce139d007036fa8d533c6727b6976709ee256", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 55, "deletions": 20, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -59,6 +59,11 @@ struct Context<'a, 'b> {\n     next_arg: uint,\n }\n \n+pub enum Invocation {\n+    Call(@ast::Expr),\n+    MethodCall(@ast::Expr, ast::Ident),\n+}\n+\n /// Parses the arguments from the given list of tokens, returning None\n /// if there's a parse error so we can continue parsing other format!\n /// expressions.\n@@ -67,8 +72,9 @@ struct Context<'a, 'b> {\n ///\n ///     Some((fmtstr, unnamed arguments, ordering of named arguments,\n ///           named arguments))\n-fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> (@ast::Expr, Option<(@ast::Expr, Vec<@ast::Expr>, Vec<StrBuf>,\n+fn parse_args(ecx: &mut ExtCtxt, sp: Span, allow_method: bool,\n+              tts: &[ast::TokenTree])\n+    -> (Invocation, Option<(@ast::Expr, Vec<@ast::Expr>, Vec<StrBuf>,\n                             HashMap<StrBuf, @ast::Expr>)>) {\n     let mut args = Vec::new();\n     let mut names = HashMap::<StrBuf, @ast::Expr>::new();\n@@ -80,22 +86,31 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                                                 .map(|x| (*x).clone())\n                                                 .collect());\n     // Parse the leading function expression (maybe a block, maybe a path)\n-    let extra = p.parse_expr();\n+    let invocation = if allow_method {\n+        let e = p.parse_expr();\n+        if !p.eat(&token::COMMA) {\n+            ecx.span_err(sp, \"expected token: `,`\");\n+            return (Call(e), None);\n+        }\n+        MethodCall(e, p.parse_ident())\n+    } else {\n+        Call(p.parse_expr())\n+    };\n     if !p.eat(&token::COMMA) {\n         ecx.span_err(sp, \"expected token: `,`\");\n-        return (extra, None);\n+        return (invocation, None);\n     }\n \n     if p.token == token::EOF {\n         ecx.span_err(sp, \"requires at least a format string argument\");\n-        return (extra, None);\n+        return (invocation, None);\n     }\n     let fmtstr = p.parse_expr();\n     let mut named = false;\n     while p.token != token::EOF {\n         if !p.eat(&token::COMMA) {\n             ecx.span_err(sp, \"expected token: `,`\");\n-            return (extra, None);\n+            return (invocation, None);\n         }\n         if p.token == token::EOF { break } // accept trailing commas\n         if named || (token::is_ident(&p.token) &&\n@@ -110,13 +125,13 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                     ecx.span_err(p.span,\n                                  \"expected ident, positional arguments \\\n                                  cannot follow named arguments\");\n-                    return (extra, None);\n+                    return (invocation, None);\n                 }\n                 _ => {\n                     ecx.span_err(p.span,\n                                  format!(\"expected ident for named argument, but found `{}`\",\n                                          p.this_token_to_str()));\n-                    return (extra, None);\n+                    return (invocation, None);\n                 }\n             };\n             let interned_name = token::get_ident(ident);\n@@ -137,7 +152,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             args.push(p.parse_expr());\n         }\n     }\n-    return (extra, Some((fmtstr, args, order, names)));\n+    return (invocation, Some((fmtstr, args, order, names)));\n }\n \n impl<'a, 'b> Context<'a, 'b> {\n@@ -595,7 +610,7 @@ impl<'a, 'b> Context<'a, 'b> {\n \n     /// Actually builds the expression which the iformat! block will be expanded\n     /// to\n-    fn to_expr(&self, extra: @ast::Expr) -> @ast::Expr {\n+    fn to_expr(&self, invocation: Invocation) -> @ast::Expr {\n         let mut lets = Vec::new();\n         let mut locals = Vec::new();\n         let mut names = Vec::from_fn(self.name_positions.len(), |_| None);\n@@ -699,8 +714,16 @@ impl<'a, 'b> Context<'a, 'b> {\n         let resname = self.ecx.ident_of(\"__args\");\n         lets.push(self.ecx.stmt_let(self.fmtsp, false, resname, result));\n         let res = self.ecx.expr_ident(self.fmtsp, resname);\n-        let result = self.ecx.expr_call(extra.span, extra, vec!(\n-                            self.ecx.expr_addr_of(extra.span, res)));\n+        let result = match invocation {\n+            Call(e) => {\n+                self.ecx.expr_call(e.span, e,\n+                                   vec!(self.ecx.expr_addr_of(e.span, res)))\n+            }\n+            MethodCall(e, m) => {\n+                self.ecx.expr_method_call(e.span, e, m,\n+                                          vec!(self.ecx.expr_addr_of(e.span, res)))\n+            }\n+        };\n         let body = self.ecx.expr_block(self.ecx.block(self.fmtsp, lets,\n                                                       Some(result)));\n \n@@ -794,13 +817,25 @@ impl<'a, 'b> Context<'a, 'b> {\n     }\n }\n \n-pub fn expand_args(ecx: &mut ExtCtxt, sp: Span,\n-                   tts: &[ast::TokenTree]) -> Box<base::MacResult> {\n+pub fn expand_format_args(ecx: &mut ExtCtxt, sp: Span,\n+                          tts: &[ast::TokenTree]) -> Box<base::MacResult> {\n+\n+    match parse_args(ecx, sp, false, tts) {\n+        (invocation, Some((efmt, args, order, names))) => {\n+            MacExpr::new(expand_preparsed_format_args(ecx, sp, invocation, efmt,\n+                                                      args, order, names))\n+        }\n+        (_, None) => MacExpr::new(ecx.expr_uint(sp, 2))\n+    }\n+}\n+\n+pub fn expand_format_args_method(ecx: &mut ExtCtxt, sp: Span,\n+                                 tts: &[ast::TokenTree]) -> Box<base::MacResult> {\n \n-    match parse_args(ecx, sp, tts) {\n-        (extra, Some((efmt, args, order, names))) => {\n-            MacExpr::new(expand_preparsed_format_args(ecx, sp, extra, efmt, args,\n-                                                order, names))\n+    match parse_args(ecx, sp, true, tts) {\n+        (invocation, Some((efmt, args, order, names))) => {\n+            MacExpr::new(expand_preparsed_format_args(ecx, sp, invocation, efmt,\n+                                                      args, order, names))\n         }\n         (_, None) => MacExpr::new(ecx.expr_uint(sp, 2))\n     }\n@@ -810,7 +845,7 @@ pub fn expand_args(ecx: &mut ExtCtxt, sp: Span,\n /// name=names...)` and construct the appropriate formatting\n /// expression.\n pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n-                                    extra: @ast::Expr,\n+                                    invocation: Invocation,\n                                     efmt: @ast::Expr, args: Vec<@ast::Expr>,\n                                     name_ordering: Vec<StrBuf>,\n                                     names: HashMap<StrBuf, @ast::Expr>) -> @ast::Expr {\n@@ -869,5 +904,5 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         }\n     }\n \n-    cx.to_expr(extra)\n+    cx.to_expr(invocation)\n }"}, {"sha": "5dfd18392a9c0da2a8c1b53eeaeb76c2e221af9f", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -594,7 +594,7 @@ impl BytesContainer for InternedString {\n \n impl fmt::Show for InternedString {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}\", self.string.as_slice())\n+        write!(f, \"{}\", self.string.as_slice())\n     }\n }\n "}, {"sha": "b3c768a519924c05f1cc63a10785374d8c8335c7", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -38,7 +38,7 @@ fn local_sort<T: Float>(v: &mut [T]) {\n }\n \n /// Trait that provides simple descriptive statistics on a univariate set of numeric samples.\n-pub trait Stats <T: Float + FromPrimitive>{\n+pub trait Stats <T: FloatMath + FromPrimitive>{\n \n     /// Sum of the samples.\n     ///\n@@ -143,7 +143,7 @@ pub struct Summary<T> {\n     pub iqr: T,\n }\n \n-impl<T: Float + FromPrimitive> Summary<T> {\n+impl<T: FloatMath + FromPrimitive> Summary<T> {\n \n     /// Construct a new summary of a sample set.\n     pub fn new(samples: &[T]) -> Summary<T> {\n@@ -164,7 +164,7 @@ impl<T: Float + FromPrimitive> Summary<T> {\n     }\n }\n \n-impl<'a,T: Float + FromPrimitive> Stats<T> for &'a [T] {\n+impl<'a,T: FloatMath + FromPrimitive> Stats<T> for &'a [T] {\n \n     // FIXME #11059 handle NaN, inf and overflow\n     #[allow(deprecated_owned_vector)]"}, {"sha": "5fc567f06d38d8fbed9fee6d5b4b7275bf6e9d2f", "filename": "src/liburl/lib.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -427,8 +427,8 @@ fn split_char_first(s: &str, c: char) -> (StrBuf, StrBuf) {\n impl fmt::Show for UserInfo {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.pass {\n-            Some(ref pass) => write!(f.buf, \"{}:{}@\", self.user, *pass),\n-            None => write!(f.buf, \"{}@\", self.user),\n+            Some(ref pass) => write!(f, \"{}:{}@\", self.user, *pass),\n+            None => write!(f, \"{}@\", self.user),\n         }\n     }\n }\n@@ -824,30 +824,30 @@ impl fmt::Show for Url {\n      * result in just \"http://somehost.com\".\n      */\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f.buf, \"{}:\", self.scheme));\n+        try!(write!(f, \"{}:\", self.scheme));\n \n         if !self.host.is_empty() {\n-            try!(write!(f.buf, \"//\"));\n+            try!(write!(f, \"//\"));\n             match self.user {\n-                Some(ref user) => try!(write!(f.buf, \"{}\", *user)),\n+                Some(ref user) => try!(write!(f, \"{}\", *user)),\n                 None => {}\n             }\n             match self.port {\n-                Some(ref port) => try!(write!(f.buf, \"{}:{}\", self.host,\n+                Some(ref port) => try!(write!(f, \"{}:{}\", self.host,\n                                                 *port)),\n-                None => try!(write!(f.buf, \"{}\", self.host)),\n+                None => try!(write!(f, \"{}\", self.host)),\n             }\n         }\n \n-        try!(write!(f.buf, \"{}\", self.path));\n+        try!(write!(f, \"{}\", self.path));\n \n         if !self.query.is_empty() {\n-            try!(write!(f.buf, \"?{}\", query_to_str(&self.query)));\n+            try!(write!(f, \"?{}\", query_to_str(&self.query)));\n         }\n \n         match self.fragment {\n             Some(ref fragment) => {\n-                write!(f.buf, \"\\\\#{}\", encode_component(fragment.as_slice()))\n+                write!(f, \"\\\\#{}\", encode_component(fragment.as_slice()))\n             }\n             None => Ok(()),\n         }\n@@ -856,14 +856,14 @@ impl fmt::Show for Url {\n \n impl fmt::Show for Path {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f.buf, \"{}\", self.path));\n+        try!(write!(f, \"{}\", self.path));\n         if !self.query.is_empty() {\n-            try!(write!(f.buf, \"?{}\", self.query))\n+            try!(write!(f, \"?{}\", self.query))\n         }\n \n         match self.fragment {\n             Some(ref fragment) => {\n-                write!(f.buf, \"\\\\#{}\", encode_component(fragment.as_slice()))\n+                write!(f, \"\\\\#{}\", encode_component(fragment.as_slice()))\n             }\n             None => Ok(())\n         }"}, {"sha": "94f1239cc08465cfebe60f7fd3ecb98957a98d39", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -154,17 +154,17 @@ impl fmt::Show for ParseError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             ErrorInvalidLength(found) =>\n-                write!(f.buf, \"Invalid length; expecting 32, 36 or 45 chars, \\\n-                               found {}\", found),\n+                write!(f, \"Invalid length; expecting 32, 36 or 45 chars, \\\n+                           found {}\", found),\n             ErrorInvalidCharacter(found, pos) =>\n-                write!(f.buf, \"Invalid character; found `{}` (0x{:02x}) at \\\n-                               offset {}\", found, found as uint, pos),\n+                write!(f, \"Invalid character; found `{}` (0x{:02x}) at \\\n+                           offset {}\", found, found as uint, pos),\n             ErrorInvalidGroups(found) =>\n-                write!(f.buf, \"Malformed; wrong number of groups: expected 1 \\\n-                               or 5, found {}\", found),\n+                write!(f, \"Malformed; wrong number of groups: expected 1 \\\n+                           or 5, found {}\", found),\n             ErrorInvalidGroupLength(group, found, expecting) =>\n-                write!(f.buf, \"Malformed; length of group {} was {}, \\\n-                               expecting {}\", group, found, expecting),\n+                write!(f, \"Malformed; length of group {} was {}, \\\n+                           expecting {}\", group, found, expecting),\n         }\n     }\n }\n@@ -474,7 +474,7 @@ impl FromStr for Uuid {\n /// Convert the UUID to a hexadecimal-based string representation\n impl fmt::Show for Uuid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}\", self.to_simple_str())\n+        write!(f, \"{}\", self.to_simple_str())\n     }\n }\n "}, {"sha": "c4c2f407423f5031c04f0bc529e804d8ae9e2e16", "filename": "src/test/auxiliary/cci_class_cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -19,7 +19,7 @@ pub mod kitty {\n \n     impl fmt::Show for cat {\n         fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-            write!(f.buf, \"{}\", self.name)\n+            write!(f, \"{}\", self.name)\n         }\n     }\n "}, {"sha": "f0bc0204fd26d17a53262f6581ba2619246396ea", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// no-pretty-expanded\n+\n #![feature(phase)]\n #[phase(syntax)] extern crate green;\n \n@@ -33,7 +35,7 @@ impl fmt::Show for Color {\n             Yellow => \"yellow\",\n             Blue => \"blue\",\n         };\n-        f.buf.write(str.as_bytes())\n+        write!(f, \"{}\", str)\n     }\n }\n \n@@ -82,7 +84,7 @@ impl fmt::Show for Number {\n         }\n \n         for s in out.iter().rev() {\n-            try!(f.buf.write(s.as_bytes()));\n+            try!(write!(f, \"{}\", s))\n         }\n         Ok(())\n     }"}, {"sha": "c8763899269ccefbcbbe98e62e9969cd5a5d1a03", "filename": "src/test/compile-fail-fulldeps/gated-phase.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-phase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-phase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-phase.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "previous_filename": "src/test/compile-fail/gated-phase.rs"}, {"sha": "f8eb9868a5b69413047261f344dfd11aeb957be9", "filename": "src/test/compile-fail-fulldeps/macro-crate-unexported-macro.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-unexported-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-unexported-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-unexported-macro.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "previous_filename": "src/test/compile-fail/macro-crate-unexported-macro.rs"}, {"sha": "84c915f267ec26fd78c3ccc59f2f804c37a501fe", "filename": "src/test/compile-fail-fulldeps/macro-crate-unknown-crate.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-unknown-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-unknown-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-unknown-crate.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "previous_filename": "src/test/compile-fail/macro-crate-unknown-crate.rs"}, {"sha": "2053f81683d7a3d50582dc9276c74da5cbd5766d", "filename": "src/test/compile-fail-fulldeps/phase-syntax-doesnt-resolve.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Fcompile-fail-fulldeps%2Fphase-syntax-doesnt-resolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Fcompile-fail-fulldeps%2Fphase-syntax-doesnt-resolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fphase-syntax-doesnt-resolve.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "previous_filename": "src/test/compile-fail/phase-syntax-doesnt-resolve.rs"}, {"sha": "897717971bc1735e1e863d854b6e5ae0fa5c9438", "filename": "src/test/compile-fail/ifmt-unimpl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Fcompile-fail%2Fifmt-unimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Fcompile-fail%2Fifmt-unimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-unimpl.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -10,5 +10,5 @@\n \n fn main() {\n     format!(\"{:d}\", \"3\");\n-    //~^ ERROR: failed to find an implementation of trait std::fmt::Signed\n+    //~^ ERROR: failed to find an implementation of trait core::fmt::Signed\n }"}, {"sha": "753c91d1dc9580ffde569ad6e219f1294ca0ea94", "filename": "src/test/compile-fail/use-after-move-implicity-coerced-object.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Fcompile-fail%2Fuse-after-move-implicity-coerced-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Fcompile-fail%2Fuse-after-move-implicity-coerced-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move-implicity-coerced-object.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -18,7 +18,7 @@ struct Number {\n \n impl fmt::Show for Number {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}\", self.n)\n+        write!(f, \"{}\", self.n)\n     }\n }\n "}, {"sha": "bb101140ec39351650e880b8e5b59794499e34d4", "filename": "src/test/run-pass/capturing-logging.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -26,7 +26,7 @@ struct MyWriter(ChanWriter);\n impl Logger for MyWriter {\n     fn log(&mut self, record: &LogRecord) {\n         let MyWriter(ref mut inner) = *self;\n-        fmt::writeln(inner as &mut Writer, record.args);\n+        write!(inner, \"{}\", record.args);\n     }\n }\n \n@@ -45,5 +45,7 @@ fn main() {\n         debug!(\"debug\");\n         info!(\"info\");\n     });\n-    assert_eq!(r.read_to_str().unwrap(), \"info\\n\".to_owned());\n+    let s = r.read_to_str().unwrap();\n+    assert!(s.contains(\"info\"));\n+    assert!(!s.contains(\"debug\"));\n }"}, {"sha": "fdd44740d0531021b8ec20403ae95130f850064f", "filename": "src/test/run-pass/class-separate-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -53,7 +53,7 @@ fn cat(in_x : uint, in_y : int, in_name: StrBuf) -> cat {\n \n impl fmt::Show for cat {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}\", self.name)\n+        write!(f, \"{}\", self.name)\n     }\n }\n "}, {"sha": "14c2a5ae6c8b6a153700957d50945f37dbedcca3", "filename": "src/test/run-pass/colorful-write-macros.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -8,7 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// no-pretty-expanded\n+\n #![allow(unused_must_use, dead_code)]\n+#![feature(macro_rules)]\n \n use std::io::MemWriter;\n \n@@ -21,8 +24,9 @@ fn borrowing_writer_from_struct_and_formatting_struct_field(foo: Foo) {\n     write!(foo.writer, \"{}\", foo.other);\n }\n \n-pub fn main() {\n+fn main() {\n     let mut w = MemWriter::new();\n     write!(&mut w as &mut Writer, \"\");\n     write!(&mut w, \"\"); // should coerce\n+    println!(\"ok\");\n }"}, {"sha": "41650b680512977c99f7c45dfaf1608558e67628", "filename": "src/test/run-pass/deriving-show-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Frun-pass%2Fderiving-show-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Frun-pass%2Fderiving-show-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-show-2.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -36,7 +36,7 @@ struct J(Custom);\n struct Custom;\n impl fmt::Show for Custom {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"yay\")\n+        write!(f, \"yay\")\n     }\n }\n "}, {"sha": "ee142aa8e6dbcdd0240dd60c5ae71c970b1af0d5", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -25,12 +25,12 @@ struct B;\n \n impl fmt::Signed for A {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.buf.write(\"aloha\".as_bytes())\n+        f.write(\"aloha\".as_bytes())\n     }\n }\n impl fmt::Signed for B {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.buf.write(\"adios\".as_bytes())\n+        f.write(\"adios\".as_bytes())\n     }\n }\n \n@@ -195,9 +195,9 @@ fn test_format_args() {\n     let mut buf = MemWriter::new();\n     {\n         let w = &mut buf as &mut io::Writer;\n-        format_args!(|args| { fmt::write(w, args); }, \"{}\", 1);\n-        format_args!(|args| { fmt::write(w, args); }, \"test\");\n-        format_args!(|args| { fmt::write(w, args); }, \"{test}\", test=3);\n+        format_args!(|args| { write!(w, \"{}\", args); }, \"{}\", 1);\n+        format_args!(|args| { write!(w, \"{}\", args); }, \"test\");\n+        format_args!(|args| { write!(w, \"{}\", args); }, \"{test}\", test=3);\n     }\n     let s = str::from_utf8(buf.unwrap().as_slice()).unwrap().to_owned();\n     t!(s, \"1test3\");"}, {"sha": "2ce3cb931e5d9772b12ab7f6ed13dedc36465bee", "filename": "src/test/run-pass/issue-2904.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2904.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -29,7 +29,7 @@ enum square {\n \n impl fmt::Show for square {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}\", match *self {\n+        write!(f, \"{}\", match *self {\n           bot => { \"R\".to_owned() }\n           wall => { \"#\".to_owned() }\n           rock => { \"*\".to_owned() }"}, {"sha": "cdc07c026772e3bcff717ea5b00572717010c227", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -106,7 +106,7 @@ impl fmt::Show for AsciiArt {\n                               .collect::<Vec<StrBuf>>();\n \n         // Concatenate the lines together using a new-line.\n-        write!(f.buf, \"{}\", lines.connect(\"\\n\"))\n+        write!(f, \"{}\", lines.connect(\"\\n\"))\n     }\n }\n "}, {"sha": "7431340e413a9f78f8fd1bd5d263df722ca18ba0", "filename": "src/test/run-pass/new-impl-syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Frun-pass%2Fnew-impl-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545a499fad8d58f858e7c14bcdc90171b97efdf/src%2Ftest%2Frun-pass%2Fnew-impl-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnew-impl-syntax.rs?ref=b545a499fad8d58f858e7c14bcdc90171b97efdf", "patch": "@@ -17,7 +17,7 @@ struct Thingy {\n \n impl fmt::Show for Thingy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"\\\\{ x: {}, y: {} \\\\}\", self.x, self.y)\n+        write!(f, \"\\\\{ x: {}, y: {} \\\\}\", self.x, self.y)\n     }\n }\n \n@@ -27,7 +27,7 @@ struct PolymorphicThingy<T> {\n \n impl<T:fmt::Show> fmt::Show for PolymorphicThingy<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}\", self.x)\n+        write!(f, \"{}\", self.x)\n     }\n }\n "}]}