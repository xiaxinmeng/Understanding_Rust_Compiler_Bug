{"sha": "e84efc4a4656e54a4f08b99592d5d98ac5726449", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4NGVmYzRhNDY1NmU1NGE0ZjA4Yjk5NTkyZDVkOThhYzU3MjY0NDk=", "commit": {"author": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-05-11T12:18:16Z"}, "committer": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-05-31T19:23:09Z"}, "message": "Replace the old match checking algorithm", "tree": {"sha": "7f21f05a7eb6cbef32ca9c081e19f9f0c2392567", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f21f05a7eb6cbef32ca9c081e19f9f0c2392567"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e84efc4a4656e54a4f08b99592d5d98ac5726449", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e84efc4a4656e54a4f08b99592d5d98ac5726449", "html_url": "https://github.com/rust-lang/rust/commit/e84efc4a4656e54a4f08b99592d5d98ac5726449", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e84efc4a4656e54a4f08b99592d5d98ac5726449/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "894b4c64ffdb280a38c1ea2e9be145ca308965fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/894b4c64ffdb280a38c1ea2e9be145ca308965fd", "html_url": "https://github.com/rust-lang/rust/commit/894b4c64ffdb280a38c1ea2e9be145ca308965fd"}], "stats": {"total": 2238, "additions": 311, "deletions": 1927}, "files": [{"sha": "283894704473bfa9093f08e7ac0b400064a8633f", "filename": "crates/hir_ty/src/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e84efc4a4656e54a4f08b99592d5d98ac5726449/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84efc4a4656e54a4f08b99592d5d98ac5726449/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs?ref=e84efc4a4656e54a4f08b99592d5d98ac5726449", "patch": "@@ -1,8 +1,6 @@\n //! Type inference-based diagnostics.\n mod expr;\n-#[allow(unused)] //todo\n mod match_check;\n-mod pattern;\n mod unsafe_check;\n mod decl_check;\n "}, {"sha": "c6015d236515a2966f0b49b231435f1f67fd8fc8", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 17, "deletions": 102, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/e84efc4a4656e54a4f08b99592d5d98ac5726449/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84efc4a4656e54a4f08b99592d5d98ac5726449/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=e84efc4a4656e54a4f08b99592d5d98ac5726449", "patch": "@@ -4,15 +4,20 @@\n \n use std::{cell::RefCell, sync::Arc};\n \n-use hir_def::{expr::Statement, path::path, resolver::HasResolver, AssocItemId, DefWithBodyId};\n+use hir_def::{\n+    expr::Statement, path::path, resolver::HasResolver, AssocItemId, DefWithBodyId, HasModule,\n+};\n use hir_expand::name;\n use rustc_hash::FxHashSet;\n use syntax::{ast, AstPtr};\n \n use crate::{\n     db::HirDatabase,\n     diagnostics::{\n-        match_check::{is_useful, MatchCheckCtx, Matrix, PatStack, Usefulness},\n+        match_check::{\n+            self,\n+            usefulness::{compute_match_usefulness, expand_pattern, MatchCheckCtx, PatternArena},\n+        },\n         MismatchedArgCount, MissingFields, MissingMatchArms, MissingOkOrSomeInTailExpr,\n         MissingPatFields, RemoveThisSemicolon,\n     },\n@@ -26,13 +31,7 @@ pub(crate) use hir_def::{\n     LocalFieldId, VariantId,\n };\n \n-use super::{\n-    pattern::{\n-        self,\n-        usefulness::{expand_pattern, PatternArena},\n-    },\n-    ReplaceFilterMapNextWithFindMap,\n-};\n+use super::ReplaceFilterMapNextWithFindMap;\n \n pub(super) struct ExprValidator<'a, 'b: 'a> {\n     owner: DefWithBodyId,\n@@ -68,7 +67,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n \n             match expr {\n                 Expr::Match { expr, arms } => {\n-                    self.validate_match2(id, *expr, arms, db, self.infer.clone());\n+                    self.validate_match(id, *expr, arms, db, self.infer.clone());\n                 }\n                 Expr::Call { .. } | Expr::MethodCall { .. } => {\n                     self.validate_call(db, id, expr);\n@@ -283,7 +282,6 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         }\n     }\n \n-    #[allow(dead_code)]\n     fn validate_match(\n         &mut self,\n         id: ExprId,\n@@ -301,90 +299,6 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             &infer.type_of_expr[match_expr]\n         };\n \n-        let cx = MatchCheckCtx { match_expr, body, infer: infer.clone(), db };\n-        let pats = arms.iter().map(|arm| arm.pat);\n-\n-        let mut seen = Matrix::empty();\n-        for pat in pats {\n-            if let Some(pat_ty) = infer.type_of_pat.get(pat) {\n-                // We only include patterns whose type matches the type\n-                // of the match expression. If we had a InvalidMatchArmPattern\n-                // diagnostic or similar we could raise that in an else\n-                // block here.\n-                //\n-                // When comparing the types, we also have to consider that rustc\n-                // will automatically de-reference the match expression type if\n-                // necessary.\n-                //\n-                // FIXME we should use the type checker for this.\n-                if (pat_ty == match_expr_ty\n-                    || match_expr_ty\n-                        .as_reference()\n-                        .map(|(match_expr_ty, ..)| match_expr_ty == pat_ty)\n-                        .unwrap_or(false))\n-                    && types_of_subpatterns_do_match(pat, &cx.body, &infer)\n-                {\n-                    // If we had a NotUsefulMatchArm diagnostic, we could\n-                    // check the usefulness of each pattern as we added it\n-                    // to the matrix here.\n-                    let v = PatStack::from_pattern(pat);\n-                    seen.push(&cx, v);\n-                    continue;\n-                }\n-            }\n-\n-            // If we can't resolve the type of a pattern, or the pattern type doesn't\n-            // fit the match expression, we skip this diagnostic. Skipping the entire\n-            // diagnostic rather than just not including this match arm is preferred\n-            // to avoid the chance of false positives.\n-            return;\n-        }\n-\n-        match is_useful(&cx, &seen, &PatStack::from_wild()) {\n-            Ok(Usefulness::Useful) => (),\n-            // if a wildcard pattern is not useful, then all patterns are covered\n-            Ok(Usefulness::NotUseful) => return,\n-            // this path is for unimplemented checks, so we err on the side of not\n-            // reporting any errors\n-            _ => return,\n-        }\n-\n-        if let Ok(source_ptr) = source_map.expr_syntax(id) {\n-            let root = source_ptr.file_syntax(db.upcast());\n-            if let ast::Expr::MatchExpr(match_expr) = &source_ptr.value.to_node(&root) {\n-                if let (Some(match_expr), Some(arms)) =\n-                    (match_expr.expr(), match_expr.match_arm_list())\n-                {\n-                    self.sink.push(MissingMatchArms {\n-                        file: source_ptr.file_id,\n-                        match_expr: AstPtr::new(&match_expr),\n-                        arms: AstPtr::new(&arms),\n-                    })\n-                }\n-            }\n-        }\n-    }\n-\n-    fn validate_match2(\n-        &mut self,\n-        id: ExprId,\n-        match_expr: ExprId,\n-        arms: &[MatchArm],\n-        db: &dyn HirDatabase,\n-        infer: Arc<InferenceResult>,\n-    ) {\n-        use crate::diagnostics::pattern::usefulness;\n-        use hir_def::HasModule;\n-\n-        let (body, source_map): (Arc<Body>, Arc<BodySourceMap>) =\n-            db.body_with_source_map(self.owner);\n-\n-        let match_expr_ty = if infer.type_of_expr[match_expr].is_unknown() {\n-            return;\n-        } else {\n-            &infer.type_of_expr[match_expr]\n-        };\n-\n         let pattern_arena = RefCell::new(PatternArena::new());\n \n         let mut m_arms = Vec::new();\n@@ -401,16 +315,17 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n                 // necessary.\n                 //\n                 // FIXME we should use the type checker for this.\n-                if pat_ty == match_expr_ty\n+                if (pat_ty == match_expr_ty\n                     || match_expr_ty\n                         .as_reference()\n                         .map(|(match_expr_ty, ..)| match_expr_ty == pat_ty)\n-                        .unwrap_or(false)\n+                        .unwrap_or(false))\n+                    && types_of_subpatterns_do_match(arm.pat, &body, &infer)\n                 {\n                     // If we had a NotUsefulMatchArm diagnostic, we could\n                     // check the usefulness of each pattern as we added it\n                     // to the matrix here.\n-                    let m_arm = usefulness::MatchArm {\n+                    let m_arm = match_check::MatchArm {\n                         pat: self.lower_pattern(\n                             arm.pat,\n                             &mut pattern_arena.borrow_mut(),\n@@ -434,14 +349,14 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             return;\n         }\n \n-        let cx = usefulness::MatchCheckCtx {\n+        let cx = MatchCheckCtx {\n             module: self.owner.module(db.upcast()),\n             match_expr,\n             infer: &infer,\n             db,\n             pattern_arena: &pattern_arena,\n         };\n-        let report = usefulness::compute_match_usefulness(&cx, &m_arms);\n+        let report = compute_match_usefulness(&cx, &m_arms);\n \n         // FIXME Report unreacheble arms\n         // https://github.com/rust-lang/rust/blob/25c15cdbe/compiler/rustc_mir_build/src/thir/pattern/check_match.rs#L200-L201\n@@ -473,8 +388,8 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         db: &dyn HirDatabase,\n         body: &Body,\n         have_errors: &mut bool,\n-    ) -> pattern::PatId {\n-        let mut patcx = pattern::PatCtxt::new(db, &self.infer, body);\n+    ) -> match_check::PatId {\n+        let mut patcx = match_check::PatCtxt::new(db, &self.infer, body);\n         let pattern = patcx.lower_pattern(pat);\n         let pattern = pattern_arena.alloc(expand_pattern(pattern));\n         if !patcx.errors.is_empty() {"}, {"sha": "aebadd3917012b05130a46dac9131ad469e7c84d", "filename": "crates/hir_ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 294, "deletions": 783, "changes": 1077, "blob_url": "https://github.com/rust-lang/rust/blob/e84efc4a4656e54a4f08b99592d5d98ac5726449/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84efc4a4656e54a4f08b99592d5d98ac5726449/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=e84efc4a4656e54a4f08b99592d5d98ac5726449", "patch": "@@ -1,864 +1,340 @@\n-//! This module implements match statement exhaustiveness checking and usefulness checking\n-//! for match arms.\n+//! Validation of matches.\n //!\n-//! It is modeled on the rustc module `librustc_mir_build::hair::pattern::_match`, which\n-//! contains very detailed documentation about the algorithms used here. I've duplicated\n-//! most of that documentation below.\n+//! This module provides lowering from [hir_def::expr::Pat] to [self::Pat] and match\n+//! checking algorithm.\n //!\n-//! This file includes the logic for exhaustiveness and usefulness checking for\n-//! pattern-matching. Specifically, given a list of patterns for a type, we can\n-//! tell whether:\n-//! - (a) the patterns cover every possible constructor for the type (exhaustiveness).\n-//! - (b) each pattern is necessary (usefulness).\n-//!\n-//! The algorithm implemented here is a modified version of the one described in\n-//! <http://moscova.inria.fr/~maranget/papers/warn/index.html>.\n-//! However, to save future implementors from reading the original paper, we\n-//! summarize the algorithm here to hopefully save time and be a little clearer\n-//! (without being so rigorous).\n-//!\n-//! The core of the algorithm revolves about a \"usefulness\" check. In particular, we\n-//! are trying to compute a predicate `U(P, p)` where `P` is a list of patterns (we refer to this as\n-//! a matrix). `U(P, p)` represents whether, given an existing list of patterns\n-//! `P_1 ..= P_m`, adding a new pattern `p` will be \"useful\" (that is, cover previously-\n-//! uncovered values of the type).\n-//!\n-//! If we have this predicate, then we can easily compute both exhaustiveness of an\n-//! entire set of patterns and the individual usefulness of each one.\n-//! (a) the set of patterns is exhaustive iff `U(P, _)` is false (i.e., adding a wildcard\n-//! match doesn't increase the number of values we're matching)\n-//! (b) a pattern `P_i` is not useful if `U(P[0..=(i-1), P_i)` is false (i.e., adding a\n-//! pattern to those that have come before it doesn't increase the number of values\n-//! we're matching).\n-//!\n-//! During the course of the algorithm, the rows of the matrix won't just be individual patterns,\n-//! but rather partially-deconstructed patterns in the form of a list of patterns. The paper\n-//! calls those pattern-vectors, and we will call them pattern-stacks. The same holds for the\n-//! new pattern `p`.\n-//!\n-//! For example, say we have the following:\n-//!\n-//! ```ignore\n-//! // x: (Option<bool>, Result<()>)\n-//! match x {\n-//!     (Some(true), _) => (),\n-//!     (None, Err(())) => (),\n-//!     (None, Err(_)) => (),\n-//! }\n-//! ```\n-//!\n-//! Here, the matrix `P` starts as:\n-//!\n-//! ```text\n-//! [\n-//!     [(Some(true), _)],\n-//!     [(None, Err(()))],\n-//!     [(None, Err(_))],\n-//! ]\n-//! ```\n-//!\n-//! We can tell it's not exhaustive, because `U(P, _)` is true (we're not covering\n-//! `[(Some(false), _)]`, for instance). In addition, row 3 is not useful, because\n-//! all the values it covers are already covered by row 2.\n-//!\n-//! A list of patterns can be thought of as a stack, because we are mainly interested in the top of\n-//! the stack at any given point, and we can pop or apply constructors to get new pattern-stacks.\n-//! To match the paper, the top of the stack is at the beginning / on the left.\n-//!\n-//! There are two important operations on pattern-stacks necessary to understand the algorithm:\n-//!\n-//! 1. We can pop a given constructor off the top of a stack. This operation is called\n-//!    `specialize`, and is denoted `S(c, p)` where `c` is a constructor (like `Some` or\n-//!    `None`) and `p` a pattern-stack.\n-//!    If the pattern on top of the stack can cover `c`, this removes the constructor and\n-//!    pushes its arguments onto the stack. It also expands OR-patterns into distinct patterns.\n-//!    Otherwise the pattern-stack is discarded.\n-//!    This essentially filters those pattern-stacks whose top covers the constructor `c` and\n-//!    discards the others.\n-//!\n-//!    For example, the first pattern above initially gives a stack `[(Some(true), _)]`. If we\n-//!    pop the tuple constructor, we are left with `[Some(true), _]`, and if we then pop the\n-//!    `Some` constructor we get `[true, _]`. If we had popped `None` instead, we would get\n-//!    nothing back.\n-//!\n-//!    This returns zero or more new pattern-stacks, as follows. We look at the pattern `p_1`\n-//!    on top of the stack, and we have four cases:\n-//!\n-//!    * 1.1. `p_1 = c(r_1, .., r_a)`, i.e. the top of the stack has constructor `c`. We push onto\n-//!           the stack the arguments of this constructor, and return the result:\n-//!\n-//!          r_1, .., r_a, p_2, .., p_n\n-//!\n-//!    * 1.2. `p_1 = c'(r_1, .., r_a')` where `c \u2260 c'`. We discard the current stack and return\n-//!           nothing.\n-//!    * 1.3. `p_1 = _`. We push onto the stack as many wildcards as the constructor `c` has\n-//!           arguments (its arity), and return the resulting stack:\n-//!\n-//!          _, .., _, p_2, .., p_n\n-//!\n-//!    * 1.4. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting stack:\n-//!\n-//!          S(c, (r_1, p_2, .., p_n))\n-//!          S(c, (r_2, p_2, .., p_n))\n-//!\n-//! 2. We can pop a wildcard off the top of the stack. This is called `D(p)`, where `p` is\n-//!    a pattern-stack.\n-//!    This is used when we know there are missing constructor cases, but there might be\n-//!    existing wildcard patterns, so to check the usefulness of the matrix, we have to check\n-//!    all its *other* components.\n-//!\n-//!    It is computed as follows. We look at the pattern `p_1` on top of the stack,\n-//!    and we have three cases:\n-//!    * 1.1. `p_1 = c(r_1, .., r_a)`. We discard the current stack and return nothing.\n-//!    * 1.2. `p_1 = _`. We return the rest of the stack:\n-//!\n-//!          p_2, .., p_n\n-//!\n-//!    * 1.3. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting stack:\n-//!\n-//!          D((r_1, p_2, .., p_n))\n-//!          D((r_2, p_2, .., p_n))\n-//!\n-//!    Note that the OR-patterns are not always used directly in Rust, but are used to derive the\n-//!    exhaustive integer matching rules, so they're written here for posterity.\n-//!\n-//! Both those operations extend straightforwardly to a list or pattern-stacks, i.e. a matrix, by\n-//! working row-by-row. Popping a constructor ends up keeping only the matrix rows that start with\n-//! the given constructor, and popping a wildcard keeps those rows that start with a wildcard.\n-//!\n-//!\n-//! The algorithm for computing `U`\n-//! -------------------------------\n-//! The algorithm is inductive (on the number of columns: i.e., components of tuple patterns).\n-//! That means we're going to check the components from left-to-right, so the algorithm\n-//! operates principally on the first component of the matrix and new pattern-stack `p`.\n-//! This algorithm is realized in the `is_useful` function.\n-//!\n-//! Base case (`n = 0`, i.e., an empty tuple pattern):\n-//! - If `P` already contains an empty pattern (i.e., if the number of patterns `m > 0`), then\n-//!   `U(P, p)` is false.\n-//! - Otherwise, `P` must be empty, so `U(P, p)` is true.\n-//!\n-//! Inductive step (`n > 0`, i.e., whether there's at least one column [which may then be expanded\n-//! into further columns later]). We're going to match on the top of the new pattern-stack, `p_1`:\n-//!\n-//! - If `p_1 == c(r_1, .., r_a)`, i.e. we have a constructor pattern.\n-//!   Then, the usefulness of `p_1` can be reduced to whether it is useful when\n-//!   we ignore all the patterns in the first column of `P` that involve other constructors.\n-//!   This is where `S(c, P)` comes in:\n-//!\n-//!   ```text\n-//!   U(P, p) := U(S(c, P), S(c, p))\n-//!   ```\n-//!\n-//!   This special case is handled in `is_useful_specialized`.\n-//!\n-//!   For example, if `P` is:\n-//!\n-//!   ```text\n-//!   [\n-//!       [Some(true), _],\n-//!       [None, 0],\n-//!   ]\n-//!   ```\n-//!\n-//!   and `p` is `[Some(false), 0]`, then we don't care about row 2 since we know `p` only\n-//!   matches values that row 2 doesn't. For row 1 however, we need to dig into the\n-//!   arguments of `Some` to know whether some new value is covered. So we compute\n-//!   `U([[true, _]], [false, 0])`.\n-//!\n-//! - If `p_1 == _`, then we look at the list of constructors that appear in the first component of\n-//!   the rows of `P`:\n-//!     - If there are some constructors that aren't present, then we might think that the\n-//!       wildcard `_` is useful, since it covers those constructors that weren't covered\n-//!       before.\n-//!       That's almost correct, but only works if there were no wildcards in those first\n-//!       components. So we need to check that `p` is useful with respect to the rows that\n-//!       start with a wildcard, if there are any. This is where `D` comes in:\n-//!       `U(P, p) := U(D(P), D(p))`\n-//!\n-//!       For example, if `P` is:\n-//!       ```text\n-//!       [\n-//!           [_, true, _],\n-//!           [None, false, 1],\n-//!       ]\n-//!       ```\n-//!       and `p` is `[_, false, _]`, the `Some` constructor doesn't appear in `P`. So if we\n-//!       only had row 2, we'd know that `p` is useful. However row 1 starts with a\n-//!       wildcard, so we need to check whether `U([[true, _]], [false, 1])`.\n-//!\n-//!     - Otherwise, all possible constructors (for the relevant type) are present. In this\n-//!       case we must check whether the wildcard pattern covers any unmatched value. For\n-//!       that, we can think of the `_` pattern as a big OR-pattern that covers all\n-//!       possible constructors. For `Option`, that would mean `_ = None | Some(_)` for\n-//!       example. The wildcard pattern is useful in this case if it is useful when\n-//!       specialized to one of the possible constructors. So we compute:\n-//!       `U(P, p) := \u2203(k \u03f5 constructors) U(S(k, P), S(k, p))`\n-//!\n-//!       For example, if `P` is:\n-//!       ```text\n-//!       [\n-//!           [Some(true), _],\n-//!           [None, false],\n-//!       ]\n-//!       ```\n-//!       and `p` is `[_, false]`, both `None` and `Some` constructors appear in the first\n-//!       components of `P`. We will therefore try popping both constructors in turn: we\n-//!       compute `U([[true, _]], [_, false])` for the `Some` constructor, and `U([[false]],\n-//!       [false])` for the `None` constructor. The first case returns true, so we know that\n-//!       `p` is useful for `P`. Indeed, it matches `[Some(false), _]` that wasn't matched\n-//!       before.\n-//!\n-//! - If `p_1 == r_1 | r_2`, then the usefulness depends on each `r_i` separately:\n-//!\n-//!   ```text\n-//!   U(P, p) := U(P, (r_1, p_2, .., p_n))\n-//!            || U(P, (r_2, p_2, .., p_n))\n-//!   ```\n-use std::{iter, sync::Arc};\n-\n-use hir_def::{\n-    adt::VariantData,\n-    body::Body,\n-    expr::{Expr, Literal, Pat, PatId},\n-    EnumVariantId, StructId, VariantId,\n-};\n+//! It is modeled on the rustc module `rustc_mir_build::thir::pattern`.\n+\n+mod deconstruct_pat;\n+mod pat_util;\n+pub(crate) mod usefulness;\n+\n+use hir_def::{body::Body, EnumVariantId, LocalFieldId, VariantId};\n use la_arena::Idx;\n-use smallvec::{smallvec, SmallVec};\n-\n-use crate::{db::HirDatabase, AdtId, InferenceResult, Interner, TyExt, TyKind};\n-\n-#[derive(Debug, Clone, Copy)]\n-/// Either a pattern from the source code being analyzed, represented as\n-/// as `PatId`, or a `Wild` pattern which is created as an intermediate\n-/// step in the match checking algorithm and thus is not backed by a\n-/// real `PatId`.\n-///\n-/// Note that it is totally valid for the `PatId` variant to contain\n-/// a `PatId` which resolves to a `Wild` pattern, if that wild pattern\n-/// exists in the source code being analyzed.\n-enum PatIdOrWild {\n-    PatId(PatId),\n-    Wild,\n-}\n \n-impl PatIdOrWild {\n-    fn as_pat(self, cx: &MatchCheckCtx) -> Pat {\n-        match self {\n-            PatIdOrWild::PatId(id) => cx.body.pats[id].clone(),\n-            PatIdOrWild::Wild => Pat::Wild,\n-        }\n-    }\n+use crate::{db::HirDatabase, InferenceResult, Interner, Substitution, Ty, TyKind};\n \n-    fn as_id(self) -> Option<PatId> {\n-        match self {\n-            PatIdOrWild::PatId(id) => Some(id),\n-            PatIdOrWild::Wild => None,\n-        }\n-    }\n-}\n+use self::pat_util::EnumerateAndAdjustIterator;\n \n-impl From<PatId> for PatIdOrWild {\n-    fn from(pat_id: PatId) -> Self {\n-        Self::PatId(pat_id)\n-    }\n-}\n+pub(crate) use self::usefulness::MatchArm;\n \n-impl From<&PatId> for PatIdOrWild {\n-    fn from(pat_id: &PatId) -> Self {\n-        Self::PatId(*pat_id)\n-    }\n-}\n+pub(crate) type PatId = Idx<Pat>;\n \n-#[derive(Debug, Clone, Copy, PartialEq)]\n-pub(super) enum MatchCheckErr {\n-    NotImplemented,\n-    MalformedMatchArm,\n-    /// Used when type inference cannot resolve the type of\n-    /// a pattern or expression.\n-    Unknown,\n+#[derive(Clone, Debug)]\n+pub(crate) enum PatternError {\n+    Unimplemented,\n+    UnresolvedVariant,\n }\n \n-/// The return type of `is_useful` is either an indication of usefulness\n-/// of the match arm, or an error in the case the match statement\n-/// is made up of types for which exhaustiveness checking is currently\n-/// not completely implemented.\n-///\n-/// The `std::result::Result` type is used here rather than a custom enum\n-/// to allow the use of `?`.\n-pub(super) type MatchCheckResult<T> = Result<T, MatchCheckErr>;\n-\n-#[derive(Debug)]\n-/// A row in a Matrix.\n-///\n-/// This type is modeled from the struct of the same name in `rustc`.\n-pub(super) struct PatStack(PatStackInner);\n-type PatStackInner = SmallVec<[PatIdOrWild; 2]>;\n+#[derive(Clone, Debug, PartialEq)]\n+pub(crate) struct FieldPat {\n+    pub(crate) field: LocalFieldId,\n+    pub(crate) pattern: Pat,\n+}\n \n-impl PatStack {\n-    pub(super) fn from_pattern(pat_id: PatId) -> PatStack {\n-        Self(smallvec!(pat_id.into()))\n-    }\n+#[derive(Clone, Debug, PartialEq)]\n+pub(crate) struct Pat {\n+    pub(crate) ty: Ty,\n+    pub(crate) kind: Box<PatKind>,\n+}\n \n-    pub(super) fn from_wild() -> PatStack {\n-        Self(smallvec!(PatIdOrWild::Wild))\n+impl Pat {\n+    pub(crate) fn wildcard_from_ty(ty: &Ty) -> Self {\n+        Pat { ty: ty.clone(), kind: Box::new(PatKind::Wild) }\n     }\n+}\n \n-    fn from_slice(slice: &[PatIdOrWild]) -> PatStack {\n-        Self(SmallVec::from_slice(slice))\n-    }\n+/// Close relative to `rustc_mir_build::thir::pattern::PatKind`\n+#[derive(Clone, Debug, PartialEq)]\n+pub(crate) enum PatKind {\n+    Wild,\n \n-    fn from_vec(v: PatStackInner) -> PatStack {\n-        Self(v)\n-    }\n+    /// `x`, `ref x`, `x @ P`, etc.\n+    Binding {\n+        subpattern: Option<Pat>,\n+    },\n+\n+    /// `Foo(...)` or `Foo{...}` or `Foo`, where `Foo` is a variant name from an ADT with\n+    /// multiple variants.\n+    Variant {\n+        substs: Substitution,\n+        enum_variant: EnumVariantId,\n+        subpatterns: Vec<FieldPat>,\n+    },\n+\n+    /// `(...)`, `Foo(...)`, `Foo{...}`, or `Foo`, where `Foo` is a variant name from an ADT with\n+    /// a single variant.\n+    Leaf {\n+        subpatterns: Vec<FieldPat>,\n+    },\n+\n+    /// `box P`, `&P`, `&mut P`, etc.\n+    Deref {\n+        subpattern: Pat,\n+    },\n+\n+    // FIXME: for now, only bool literals are implemented\n+    LiteralBool {\n+        value: bool,\n+    },\n+\n+    /// An or-pattern, e.g. `p | q`.\n+    /// Invariant: `pats.len() >= 2`.\n+    Or {\n+        pats: Vec<Pat>,\n+    },\n+}\n \n-    fn get_head(&self) -> Option<PatIdOrWild> {\n-        self.0.first().copied()\n-    }\n+pub(crate) struct PatCtxt<'a> {\n+    db: &'a dyn HirDatabase,\n+    infer: &'a InferenceResult,\n+    body: &'a Body,\n+    pub(crate) errors: Vec<PatternError>,\n+}\n \n-    fn tail(&self) -> &[PatIdOrWild] {\n-        self.0.get(1..).unwrap_or(&[])\n+impl<'a> PatCtxt<'a> {\n+    pub(crate) fn new(db: &'a dyn HirDatabase, infer: &'a InferenceResult, body: &'a Body) -> Self {\n+        Self { db, infer, body, errors: Vec::new() }\n     }\n \n-    fn to_tail(&self) -> PatStack {\n-        Self::from_slice(self.tail())\n+    pub(crate) fn lower_pattern(&mut self, pat: hir_def::expr::PatId) -> Pat {\n+        // FIXME: implement pattern adjustments (implicit pattern dereference; \"RFC 2005-match-ergonomics\")\n+        // More info https://github.com/rust-lang/rust/issues/42640#issuecomment-313535089\n+        let unadjusted_pat = self.lower_pattern_unadjusted(pat);\n+        unadjusted_pat\n     }\n \n-    fn replace_head_with<I, T>(&self, pats: I) -> PatStack\n-    where\n-        I: Iterator<Item = T>,\n-        T: Into<PatIdOrWild>,\n-    {\n-        let mut patterns: PatStackInner = smallvec![];\n-        for pat in pats {\n-            patterns.push(pat.into());\n-        }\n-        for pat in &self.0[1..] {\n-            patterns.push(*pat);\n-        }\n-        PatStack::from_vec(patterns)\n-    }\n+    fn lower_pattern_unadjusted(&mut self, pat: hir_def::expr::PatId) -> Pat {\n+        let ty = &self.infer[pat];\n+        let variant = self.infer.variant_resolution_for_pat(pat);\n \n-    /// Computes `D(self)`.\n-    ///\n-    /// See the module docs and the associated documentation in rustc for details.\n-    fn specialize_wildcard(&self, cx: &MatchCheckCtx) -> Option<PatStack> {\n-        if matches!(self.get_head()?.as_pat(cx), Pat::Wild) {\n-            Some(self.to_tail())\n-        } else {\n-            None\n-        }\n-    }\n+        let kind = match self.body[pat] {\n+            hir_def::expr::Pat::Wild => PatKind::Wild,\n \n-    /// Computes `S(constructor, self)`.\n-    ///\n-    /// See the module docs and the associated documentation in rustc for details.\n-    fn specialize_constructor(\n-        &self,\n-        cx: &MatchCheckCtx,\n-        constructor: &Constructor,\n-    ) -> MatchCheckResult<Option<PatStack>> {\n-        let head = match self.get_head() {\n-            Some(head) => head,\n-            None => return Ok(None),\n-        };\n+            hir_def::expr::Pat::Lit(expr) => self.lower_lit(expr),\n \n-        let head_pat = head.as_pat(cx);\n-        let result = match (head_pat, constructor) {\n-            (Pat::Tuple { args: pat_ids, ellipsis }, &Constructor::Tuple { arity }) => {\n-                if let Some(ellipsis) = ellipsis {\n-                    let (pre, post) = pat_ids.split_at(ellipsis);\n-                    let n_wild_pats = arity.saturating_sub(pat_ids.len());\n-                    let pre_iter = pre.iter().map(Into::into);\n-                    let wildcards = iter::repeat(PatIdOrWild::Wild).take(n_wild_pats);\n-                    let post_iter = post.iter().map(Into::into);\n-                    Some(self.replace_head_with(pre_iter.chain(wildcards).chain(post_iter)))\n-                } else {\n-                    Some(self.replace_head_with(pat_ids.iter()))\n-                }\n-            }\n-            (Pat::Lit(lit_expr), Constructor::Bool(constructor_val)) => {\n-                match cx.body.exprs[lit_expr] {\n-                    Expr::Literal(Literal::Bool(pat_val)) if *constructor_val == pat_val => {\n-                        Some(self.to_tail())\n-                    }\n-                    // it was a bool but the value doesn't match\n-                    Expr::Literal(Literal::Bool(_)) => None,\n-                    // perhaps this is actually unreachable given we have\n-                    // already checked that these match arms have the appropriate type?\n-                    _ => return Err(MatchCheckErr::NotImplemented),\n-                }\n+            hir_def::expr::Pat::Path(ref path) => {\n+                return self.lower_path(pat, path);\n             }\n-            (Pat::Wild, constructor) => Some(self.expand_wildcard(cx, constructor)?),\n-            (Pat::Path(_), constructor) => {\n-                // unit enum variants become `Pat::Path`\n-                let pat_id = head.as_id().expect(\"we know this isn't a wild\");\n-                let variant_id: VariantId = match constructor {\n-                    &Constructor::Enum(e) => e.into(),\n-                    &Constructor::Struct(s) => s.into(),\n-                    _ => return Err(MatchCheckErr::NotImplemented),\n+\n+            hir_def::expr::Pat::Tuple { ref args, ellipsis } => {\n+                let arity = match *ty.kind(&Interner) {\n+                    TyKind::Tuple(arity, _) => arity,\n+                    _ => panic!(\"unexpected type for tuple pattern: {:?}\", ty),\n                 };\n-                if Some(variant_id) != cx.infer.variant_resolution_for_pat(pat_id) {\n-                    None\n-                } else {\n-                    Some(self.to_tail())\n-                }\n+                let subpatterns = self.lower_tuple_subpats(args, arity, ellipsis);\n+                PatKind::Leaf { subpatterns }\n             }\n-            (Pat::TupleStruct { args: ref pat_ids, ellipsis, .. }, constructor) => {\n-                let pat_id = head.as_id().expect(\"we know this isn't a wild\");\n-                let variant_id: VariantId = match constructor {\n-                    &Constructor::Enum(e) => e.into(),\n-                    &Constructor::Struct(s) => s.into(),\n-                    _ => return Err(MatchCheckErr::MalformedMatchArm),\n-                };\n-                if Some(variant_id) != cx.infer.variant_resolution_for_pat(pat_id) {\n-                    None\n-                } else {\n-                    let constructor_arity = constructor.arity(cx)?;\n-                    if let Some(ellipsis_position) = ellipsis {\n-                        // If there are ellipsis in the pattern, the ellipsis must take the place\n-                        // of at least one sub-pattern, so `pat_ids` should be smaller than the\n-                        // constructor arity.\n-                        if pat_ids.len() < constructor_arity {\n-                            let mut new_patterns: Vec<PatIdOrWild> = vec![];\n-\n-                            for pat_id in &pat_ids[0..ellipsis_position] {\n-                                new_patterns.push((*pat_id).into());\n-                            }\n-\n-                            for _ in 0..(constructor_arity - pat_ids.len()) {\n-                                new_patterns.push(PatIdOrWild::Wild);\n-                            }\n-\n-                            for pat_id in &pat_ids[ellipsis_position..pat_ids.len()] {\n-                                new_patterns.push((*pat_id).into());\n-                            }\n-\n-                            Some(self.replace_head_with(new_patterns.into_iter()))\n-                        } else {\n-                            return Err(MatchCheckErr::MalformedMatchArm);\n-                        }\n-                    } else {\n-                        // If there is no ellipsis in the tuple pattern, the number\n-                        // of patterns must equal the constructor arity.\n-                        if pat_ids.len() == constructor_arity {\n-                            Some(self.replace_head_with(pat_ids.into_iter()))\n-                        } else {\n-                            return Err(MatchCheckErr::MalformedMatchArm);\n-                        }\n-                    }\n-                }\n-            }\n-            (Pat::Record { args: ref arg_patterns, .. }, constructor) => {\n-                let pat_id = head.as_id().expect(\"we know this isn't a wild\");\n-                let (variant_id, variant_data) = match constructor {\n-                    &Constructor::Enum(e) => (\n-                        e.into(),\n-                        cx.db.enum_data(e.parent).variants[e.local_id].variant_data.clone(),\n-                    ),\n-                    &Constructor::Struct(s) => {\n-                        (s.into(), cx.db.struct_data(s).variant_data.clone())\n-                    }\n-                    _ => return Err(MatchCheckErr::MalformedMatchArm),\n-                };\n-                if Some(variant_id) != cx.infer.variant_resolution_for_pat(pat_id) {\n-                    None\n-                } else {\n-                    match variant_data.as_ref() {\n-                        VariantData::Record(struct_field_arena) => {\n-                            // Here we treat any missing fields in the record as the wild pattern, as\n-                            // if the record has ellipsis. We want to do this here even if the\n-                            // record does not contain ellipsis, because it allows us to continue\n-                            // enforcing exhaustiveness for the rest of the match statement.\n-                            //\n-                            // Creating the diagnostic for the missing field in the pattern\n-                            // should be done in a different diagnostic.\n-                            let patterns = struct_field_arena.iter().map(|(_, struct_field)| {\n-                                arg_patterns\n-                                    .iter()\n-                                    .find(|pat| pat.name == struct_field.name)\n-                                    .map(|pat| PatIdOrWild::from(pat.pat))\n-                                    .unwrap_or(PatIdOrWild::Wild)\n-                            });\n-\n-                            Some(self.replace_head_with(patterns))\n-                        }\n-                        _ => return Err(MatchCheckErr::Unknown),\n-                    }\n-                }\n+\n+            hir_def::expr::Pat::Bind { subpat, .. } => {\n+                PatKind::Binding { subpattern: self.lower_opt_pattern(subpat) }\n             }\n-            (Pat::Or(_), _) => return Err(MatchCheckErr::NotImplemented),\n-            (_, _) => return Err(MatchCheckErr::NotImplemented),\n-        };\n \n-        Ok(result)\n-    }\n-\n-    /// A special case of `specialize_constructor` where the head of the pattern stack\n-    /// is a Wild pattern.\n-    ///\n-    /// Replaces the Wild pattern at the head of the pattern stack with N Wild patterns\n-    /// (N >= 0), where N is the arity of the given constructor.\n-    fn expand_wildcard(\n-        &self,\n-        cx: &MatchCheckCtx,\n-        constructor: &Constructor,\n-    ) -> MatchCheckResult<PatStack> {\n-        assert_eq!(\n-            Pat::Wild,\n-            self.get_head().expect(\"expand_wildcard called on empty PatStack\").as_pat(cx),\n-            \"expand_wildcard must only be called on PatStack with wild at head\",\n-        );\n+            hir_def::expr::Pat::TupleStruct { ref args, ellipsis, .. } if variant.is_some() => {\n+                let expected_len = variant.unwrap().variant_data(self.db.upcast()).fields().len();\n+                let subpatterns = self.lower_tuple_subpats(args, expected_len, ellipsis);\n+                self.lower_variant_or_leaf(pat, ty, subpatterns)\n+            }\n \n-        let mut patterns: PatStackInner = smallvec![];\n+            hir_def::expr::Pat::Record { ref args, .. } if variant.is_some() => {\n+                let variant_data = variant.unwrap().variant_data(self.db.upcast());\n+                let subpatterns = args\n+                    .iter()\n+                    .map(|field| FieldPat {\n+                        // XXX(iDawer): field lookup is inefficient\n+                        field: variant_data.field(&field.name).unwrap(),\n+                        pattern: self.lower_pattern(field.pat),\n+                    })\n+                    .collect();\n+                self.lower_variant_or_leaf(pat, ty, subpatterns)\n+            }\n+            hir_def::expr::Pat::TupleStruct { .. } | hir_def::expr::Pat::Record { .. } => {\n+                self.errors.push(PatternError::UnresolvedVariant);\n+                PatKind::Wild\n+            }\n \n-        for _ in 0..constructor.arity(cx)? {\n-            patterns.push(PatIdOrWild::Wild);\n-        }\n+            hir_def::expr::Pat::Or(ref pats) => PatKind::Or { pats: self.lower_patterns(pats) },\n \n-        for pat in &self.0[1..] {\n-            patterns.push(*pat);\n-        }\n+            _ => {\n+                self.errors.push(PatternError::Unimplemented);\n+                PatKind::Wild\n+            }\n+        };\n \n-        Ok(PatStack::from_vec(patterns))\n+        Pat { ty: ty.clone(), kind: Box::new(kind) }\n     }\n-}\n \n-/// A collection of PatStack.\n-///\n-/// This type is modeled from the struct of the same name in `rustc`.\n-pub(super) struct Matrix(Vec<PatStack>);\n-\n-impl Matrix {\n-    pub(super) fn empty() -> Self {\n-        Self(vec![])\n+    fn lower_tuple_subpats(\n+        &mut self,\n+        pats: &[hir_def::expr::PatId],\n+        expected_len: usize,\n+        ellipsis: Option<usize>,\n+    ) -> Vec<FieldPat> {\n+        pats.iter()\n+            .enumerate_and_adjust(expected_len, ellipsis)\n+            .map(|(i, &subpattern)| FieldPat {\n+                field: LocalFieldId::from_raw((i as u32).into()),\n+                pattern: self.lower_pattern(subpattern),\n+            })\n+            .collect()\n     }\n \n-    pub(super) fn push(&mut self, cx: &MatchCheckCtx, row: PatStack) {\n-        if let Some(Pat::Or(pat_ids)) = row.get_head().map(|pat_id| pat_id.as_pat(cx)) {\n-            // Or patterns are expanded here\n-            for pat_id in pat_ids {\n-                self.0.push(row.replace_head_with([pat_id].iter()));\n-            }\n-        } else {\n-            self.0.push(row);\n-        }\n+    fn lower_patterns(&mut self, pats: &[hir_def::expr::PatId]) -> Vec<Pat> {\n+        pats.iter().map(|&p| self.lower_pattern(p)).collect()\n     }\n \n-    fn is_empty(&self) -> bool {\n-        self.0.is_empty()\n+    fn lower_opt_pattern(&mut self, pat: Option<hir_def::expr::PatId>) -> Option<Pat> {\n+        pat.map(|p| self.lower_pattern(p))\n     }\n \n-    fn heads(&self) -> Vec<PatIdOrWild> {\n-        self.0.iter().flat_map(|p| p.get_head()).collect()\n+    fn lower_variant_or_leaf(\n+        &mut self,\n+        pat: hir_def::expr::PatId,\n+        ty: &Ty,\n+        subpatterns: Vec<FieldPat>,\n+    ) -> PatKind {\n+        let kind = match self.infer.variant_resolution_for_pat(pat) {\n+            Some(variant_id) => {\n+                if let VariantId::EnumVariantId(enum_variant) = variant_id {\n+                    let substs = match ty.kind(&Interner) {\n+                        TyKind::Adt(_, substs) | TyKind::FnDef(_, substs) => substs.clone(),\n+                        TyKind::Error => {\n+                            return PatKind::Wild;\n+                        }\n+                        _ => panic!(\"inappropriate type for def: {:?}\", ty),\n+                    };\n+                    PatKind::Variant { substs, enum_variant, subpatterns }\n+                } else {\n+                    PatKind::Leaf { subpatterns }\n+                }\n+            }\n+            None => {\n+                self.errors.push(PatternError::UnresolvedVariant);\n+                PatKind::Wild\n+            }\n+        };\n+        kind\n     }\n \n-    /// Computes `D(self)` for each contained PatStack.\n-    ///\n-    /// See the module docs and the associated documentation in rustc for details.\n-    fn specialize_wildcard(&self, cx: &MatchCheckCtx) -> Self {\n-        Self::collect(cx, self.0.iter().filter_map(|r| r.specialize_wildcard(cx)))\n-    }\n+    fn lower_path(&mut self, pat: hir_def::expr::PatId, _path: &hir_def::path::Path) -> Pat {\n+        let ty = &self.infer[pat];\n \n-    /// Computes `S(constructor, self)` for each contained PatStack.\n-    ///\n-    /// See the module docs and the associated documentation in rustc for details.\n-    fn specialize_constructor(\n-        &self,\n-        cx: &MatchCheckCtx,\n-        constructor: &Constructor,\n-    ) -> MatchCheckResult<Self> {\n-        let mut new_matrix = Matrix::empty();\n-        for pat in &self.0 {\n-            if let Some(pat) = pat.specialize_constructor(cx, constructor)? {\n-                new_matrix.push(cx, pat);\n+        let pat_from_kind = |kind| Pat { ty: ty.clone(), kind: Box::new(kind) };\n+\n+        match self.infer.variant_resolution_for_pat(pat) {\n+            Some(_) => pat_from_kind(self.lower_variant_or_leaf(pat, ty, Vec::new())),\n+            None => {\n+                self.errors.push(PatternError::UnresolvedVariant);\n+                pat_from_kind(PatKind::Wild)\n             }\n         }\n-\n-        Ok(new_matrix)\n     }\n \n-    fn collect<T: IntoIterator<Item = PatStack>>(cx: &MatchCheckCtx, iter: T) -> Self {\n-        let mut matrix = Matrix::empty();\n+    fn lower_lit(&mut self, expr: hir_def::expr::ExprId) -> PatKind {\n+        use hir_def::expr::{Expr, Literal::Bool};\n \n-        for pat in iter {\n-            // using push ensures we expand or-patterns\n-            matrix.push(cx, pat);\n+        match self.body[expr] {\n+            Expr::Literal(Bool(value)) => PatKind::LiteralBool { value },\n+            _ => {\n+                self.errors.push(PatternError::Unimplemented);\n+                PatKind::Wild\n+            }\n         }\n-\n-        matrix\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq)]\n-/// An indication of the usefulness of a given match arm, where\n-/// usefulness is defined as matching some patterns which were\n-/// not matched by an prior match arms.\n-///\n-/// We may eventually need an `Unknown` variant here.\n-pub(super) enum Usefulness {\n-    Useful,\n-    NotUseful,\n-}\n+pub(crate) trait PatternFoldable: Sized {\n+    fn fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n+        self.super_fold_with(folder)\n+    }\n \n-pub(super) struct MatchCheckCtx<'a> {\n-    pub(super) match_expr: Idx<Expr>,\n-    pub(super) body: Arc<Body>,\n-    pub(super) infer: Arc<InferenceResult>,\n-    pub(super) db: &'a dyn HirDatabase,\n+    fn super_fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self;\n }\n \n-/// Given a set of patterns `matrix`, and pattern to consider `v`, determines\n-/// whether `v` is useful. A pattern is useful if it covers cases which were\n-/// not previously covered.\n-///\n-/// When calling this function externally (that is, not the recursive calls) it\n-/// expected that you have already type checked the match arms. All patterns in\n-/// matrix should be the same type as v, as well as they should all be the same\n-/// type as the match expression.\n-pub(super) fn is_useful(\n-    cx: &MatchCheckCtx,\n-    matrix: &Matrix,\n-    v: &PatStack,\n-) -> MatchCheckResult<Usefulness> {\n-    // Handle two special cases:\n-    // - enum with no variants\n-    // - `!` type\n-    // In those cases, no match arm is useful.\n-    match cx.infer[cx.match_expr].strip_references().kind(&Interner) {\n-        TyKind::Adt(AdtId(hir_def::AdtId::EnumId(enum_id)), ..) => {\n-            if cx.db.enum_data(*enum_id).variants.is_empty() {\n-                return Ok(Usefulness::NotUseful);\n-            }\n-        }\n-        TyKind::Never => return Ok(Usefulness::NotUseful),\n-        _ => (),\n+pub(crate) trait PatternFolder: Sized {\n+    fn fold_pattern(&mut self, pattern: &Pat) -> Pat {\n+        pattern.super_fold_with(self)\n     }\n \n-    let head = match v.get_head() {\n-        Some(head) => head,\n-        None => {\n-            let result = if matrix.is_empty() { Usefulness::Useful } else { Usefulness::NotUseful };\n-\n-            return Ok(result);\n-        }\n-    };\n-\n-    if let Pat::Or(pat_ids) = head.as_pat(cx) {\n-        let mut found_unimplemented = false;\n-        let any_useful = pat_ids.iter().any(|&pat_id| {\n-            let v = PatStack::from_pattern(pat_id);\n-\n-            match is_useful(cx, matrix, &v) {\n-                Ok(Usefulness::Useful) => true,\n-                Ok(Usefulness::NotUseful) => false,\n-                _ => {\n-                    found_unimplemented = true;\n-                    false\n-                }\n-            }\n-        });\n-\n-        return if any_useful {\n-            Ok(Usefulness::Useful)\n-        } else if found_unimplemented {\n-            Err(MatchCheckErr::NotImplemented)\n-        } else {\n-            Ok(Usefulness::NotUseful)\n-        };\n+    fn fold_pattern_kind(&mut self, kind: &PatKind) -> PatKind {\n+        kind.super_fold_with(self)\n     }\n+}\n \n-    if let Some(constructor) = pat_constructor(cx, head)? {\n-        let matrix = matrix.specialize_constructor(&cx, &constructor)?;\n-        let v = v\n-            .specialize_constructor(&cx, &constructor)?\n-            .expect(\"we know this can't fail because we get the constructor from `v.head()` above\");\n-\n-        is_useful(&cx, &matrix, &v)\n-    } else {\n-        // expanding wildcard\n-        let mut used_constructors: Vec<Constructor> = vec![];\n-        for pat in matrix.heads() {\n-            if let Some(constructor) = pat_constructor(cx, pat)? {\n-                used_constructors.push(constructor);\n-            }\n-        }\n-\n-        // We assume here that the first constructor is the \"correct\" type. Since we\n-        // only care about the \"type\" of the constructor (i.e. if it is a bool we\n-        // don't care about the value), this assumption should be valid as long as\n-        // the match statement is well formed. We currently uphold this invariant by\n-        // filtering match arms before calling `is_useful`, only passing in match arms\n-        // whose type matches the type of the match expression.\n-        match &used_constructors.first() {\n-            Some(constructor) if all_constructors_covered(&cx, constructor, &used_constructors) => {\n-                // If all constructors are covered, then we need to consider whether\n-                // any values are covered by this wildcard.\n-                //\n-                // For example, with matrix '[[Some(true)], [None]]', all\n-                // constructors are covered (`Some`/`None`), so we need\n-                // to perform specialization to see that our wildcard will cover\n-                // the `Some(false)` case.\n-                //\n-                // Here we create a constructor for each variant and then check\n-                // usefulness after specializing for that constructor.\n-                let mut found_unimplemented = false;\n-                for constructor in constructor.all_constructors(cx) {\n-                    let matrix = matrix.specialize_constructor(&cx, &constructor)?;\n-                    let v = v.expand_wildcard(&cx, &constructor)?;\n-\n-                    match is_useful(&cx, &matrix, &v) {\n-                        Ok(Usefulness::Useful) => return Ok(Usefulness::Useful),\n-                        Ok(Usefulness::NotUseful) => continue,\n-                        _ => found_unimplemented = true,\n-                    };\n-                }\n-\n-                if found_unimplemented {\n-                    Err(MatchCheckErr::NotImplemented)\n-                } else {\n-                    Ok(Usefulness::NotUseful)\n-                }\n-            }\n-            _ => {\n-                // Either not all constructors are covered, or the only other arms\n-                // are wildcards. Either way, this pattern is useful if it is useful\n-                // when compared to those arms with wildcards.\n-                let matrix = matrix.specialize_wildcard(&cx);\n-                let v = v.to_tail();\n+impl<T: PatternFoldable> PatternFoldable for Box<T> {\n+    fn super_fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n+        let content: T = (**self).fold_with(folder);\n+        Box::new(content)\n+    }\n+}\n \n-                is_useful(&cx, &matrix, &v)\n-            }\n-        }\n+impl<T: PatternFoldable> PatternFoldable for Vec<T> {\n+    fn super_fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n+        self.iter().map(|t| t.fold_with(folder)).collect()\n     }\n }\n \n-#[derive(Debug, Clone, Copy)]\n-/// Similar to TypeCtor, but includes additional information about the specific\n-/// value being instantiated. For example, TypeCtor::Bool doesn't contain the\n-/// boolean value.\n-enum Constructor {\n-    Bool(bool),\n-    Tuple { arity: usize },\n-    Enum(EnumVariantId),\n-    Struct(StructId),\n+impl<T: PatternFoldable> PatternFoldable for Option<T> {\n+    fn super_fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n+        self.as_ref().map(|t| t.fold_with(folder))\n+    }\n }\n \n-impl Constructor {\n-    fn arity(&self, cx: &MatchCheckCtx) -> MatchCheckResult<usize> {\n-        let arity = match self {\n-            Constructor::Bool(_) => 0,\n-            Constructor::Tuple { arity } => *arity,\n-            Constructor::Enum(e) => {\n-                match cx.db.enum_data(e.parent).variants[e.local_id].variant_data.as_ref() {\n-                    VariantData::Tuple(struct_field_data) => struct_field_data.len(),\n-                    VariantData::Record(struct_field_data) => struct_field_data.len(),\n-                    VariantData::Unit => 0,\n+macro_rules! clone_impls {\n+    ($($ty:ty),+) => {\n+        $(\n+            impl PatternFoldable for $ty {\n+                fn super_fold_with<F: PatternFolder>(&self, _: &mut F) -> Self {\n+                    Clone::clone(self)\n                 }\n             }\n-            &Constructor::Struct(s) => match cx.db.struct_data(s).variant_data.as_ref() {\n-                VariantData::Tuple(struct_field_data) => struct_field_data.len(),\n-                VariantData::Record(struct_field_data) => struct_field_data.len(),\n-                VariantData::Unit => 0,\n-            },\n-        };\n-\n-        Ok(arity)\n+        )+\n     }\n+}\n \n-    fn all_constructors(&self, cx: &MatchCheckCtx) -> Vec<Constructor> {\n-        match self {\n-            Constructor::Bool(_) => vec![Constructor::Bool(true), Constructor::Bool(false)],\n-            Constructor::Tuple { .. } | Constructor::Struct(_) => vec![*self],\n-            Constructor::Enum(e) => cx\n-                .db\n-                .enum_data(e.parent)\n-                .variants\n-                .iter()\n-                .map(|(local_id, _)| {\n-                    Constructor::Enum(EnumVariantId { parent: e.parent, local_id })\n-                })\n-                .collect(),\n-        }\n+clone_impls! { LocalFieldId, Ty, Substitution, EnumVariantId }\n+\n+impl PatternFoldable for FieldPat {\n+    fn super_fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n+        FieldPat { field: self.field.fold_with(folder), pattern: self.pattern.fold_with(folder) }\n     }\n }\n \n-/// Returns the constructor for the given pattern. Should only return None\n-/// in the case of a Wild pattern.\n-fn pat_constructor(cx: &MatchCheckCtx, pat: PatIdOrWild) -> MatchCheckResult<Option<Constructor>> {\n-    let res = match pat.as_pat(cx) {\n-        Pat::Wild => None,\n-        Pat::Tuple { .. } => {\n-            let pat_id = pat.as_id().expect(\"we already know this pattern is not a wild\");\n-            Some(Constructor::Tuple {\n-                arity: cx.infer.type_of_pat[pat_id]\n-                    .as_tuple()\n-                    .ok_or(MatchCheckErr::Unknown)?\n-                    .len(&Interner),\n-            })\n-        }\n-        Pat::Lit(lit_expr) => match cx.body.exprs[lit_expr] {\n-            Expr::Literal(Literal::Bool(val)) => Some(Constructor::Bool(val)),\n-            _ => return Err(MatchCheckErr::NotImplemented),\n-        },\n-        Pat::TupleStruct { .. } | Pat::Path(_) | Pat::Record { .. } => {\n-            let pat_id = pat.as_id().expect(\"we already know this pattern is not a wild\");\n-            let variant_id =\n-                cx.infer.variant_resolution_for_pat(pat_id).ok_or(MatchCheckErr::Unknown)?;\n-            match variant_id {\n-                VariantId::EnumVariantId(enum_variant_id) => {\n-                    Some(Constructor::Enum(enum_variant_id))\n-                }\n-                VariantId::StructId(struct_id) => Some(Constructor::Struct(struct_id)),\n-                _ => return Err(MatchCheckErr::NotImplemented),\n-            }\n-        }\n-        _ => return Err(MatchCheckErr::NotImplemented),\n-    };\n+impl PatternFoldable for Pat {\n+    fn fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n+        folder.fold_pattern(self)\n+    }\n \n-    Ok(res)\n+    fn super_fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n+        Pat { ty: self.ty.fold_with(folder), kind: self.kind.fold_with(folder) }\n+    }\n }\n \n-fn all_constructors_covered(\n-    cx: &MatchCheckCtx,\n-    constructor: &Constructor,\n-    used_constructors: &[Constructor],\n-) -> bool {\n-    match constructor {\n-        Constructor::Tuple { arity } => {\n-            used_constructors.iter().any(|constructor| match constructor {\n-                Constructor::Tuple { arity: used_arity } => arity == used_arity,\n-                _ => false,\n-            })\n-        }\n-        Constructor::Bool(_) => {\n-            if used_constructors.is_empty() {\n-                return false;\n-            }\n-\n-            let covers_true =\n-                used_constructors.iter().any(|c| matches!(c, Constructor::Bool(true)));\n-            let covers_false =\n-                used_constructors.iter().any(|c| matches!(c, Constructor::Bool(false)));\n+impl PatternFoldable for PatKind {\n+    fn fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n+        folder.fold_pattern_kind(self)\n+    }\n \n-            covers_true && covers_false\n-        }\n-        Constructor::Enum(e) => cx.db.enum_data(e.parent).variants.iter().all(|(id, _)| {\n-            for constructor in used_constructors {\n-                if let Constructor::Enum(e) = constructor {\n-                    if id == e.local_id {\n-                        return true;\n-                    }\n-                }\n+    fn super_fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n+        match self {\n+            PatKind::Wild => PatKind::Wild,\n+            PatKind::Binding { subpattern } => {\n+                PatKind::Binding { subpattern: subpattern.fold_with(folder) }\n             }\n-\n-            false\n-        }),\n-        &Constructor::Struct(s) => used_constructors.iter().any(|constructor| match constructor {\n-            &Constructor::Struct(sid) => sid == s,\n-            _ => false,\n-        }),\n+            PatKind::Variant { substs, enum_variant, subpatterns } => PatKind::Variant {\n+                substs: substs.fold_with(folder),\n+                enum_variant: enum_variant.fold_with(folder),\n+                subpatterns: subpatterns.fold_with(folder),\n+            },\n+            PatKind::Leaf { subpatterns } => {\n+                PatKind::Leaf { subpatterns: subpatterns.fold_with(folder) }\n+            }\n+            PatKind::Deref { subpattern } => {\n+                PatKind::Deref { subpattern: subpattern.fold_with(folder) }\n+            }\n+            &PatKind::LiteralBool { value } => PatKind::LiteralBool { value },\n+            PatKind::Or { pats } => PatKind::Or { pats: pats.fold_with(folder) },\n+        }\n     }\n }\n \n@@ -1514,6 +990,41 @@ fn main() {\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn no_panic_at_unimplemented_subpattern_type() {\n+        check_diagnostics(\n+            r#\"\n+struct S { a: char}\n+fn main(v: S) {\n+    match v { S{ a }      => {} }\n+    match v { S{ a: _x }  => {} }\n+    match v { S{ a: 'a' } => {} }\n+    match v { S{..}       => {} }\n+    match v { _           => {} }\n+    match v { }\n+        //^ Missing match arm\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn binding() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match true {\n+        _x @ true => {}\n+        false     => {}\n+    }\n+    match true { _x @ true => {} }\n+        //^^^^ Missing match arm\n+}\n+\"#,\n+        );\n+    }\n+\n     mod false_negatives {\n         //! The implementation of match checking here is a work in progress. As we roll this out, we\n         //! prefer false negatives to false positives (ideally there would be no false positives). This"}, {"sha": "9fa82a952ac078152d44a3216284026ac41a4de1", "filename": "crates/hir_ty/src/diagnostics/match_check/deconstruct_pat.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e84efc4a4656e54a4f08b99592d5d98ac5726449/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84efc4a4656e54a4f08b99592d5d98ac5726449/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs?ref=e84efc4a4656e54a4f08b99592d5d98ac5726449", "previous_filename": "crates/hir_ty/src/diagnostics/pattern/deconstruct_pat.rs"}, {"sha": "eb0b07a522951ff6cecdda06d82c6525029a1030", "filename": "crates/hir_ty/src/diagnostics/match_check/pat_util.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e84efc4a4656e54a4f08b99592d5d98ac5726449/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84efc4a4656e54a4f08b99592d5d98ac5726449/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fpat_util.rs?ref=e84efc4a4656e54a4f08b99592d5d98ac5726449", "previous_filename": "crates/hir_ty/src/diagnostics/pattern/pat_util.rs"}, {"sha": "b01e3557cac066eb47b1f026f2003bad2b16bfd7", "filename": "crates/hir_ty/src/diagnostics/match_check/usefulness.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e84efc4a4656e54a4f08b99592d5d98ac5726449/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84efc4a4656e54a4f08b99592d5d98ac5726449/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs?ref=e84efc4a4656e54a4f08b99592d5d98ac5726449", "previous_filename": "crates/hir_ty/src/diagnostics/pattern/usefulness.rs"}, {"sha": "f8d2e9baa99fa57c4d6cc09e77c7fd2312755a93", "filename": "crates/hir_ty/src/diagnostics/pattern.rs", "status": "removed", "additions": 0, "deletions": 1040, "changes": 1040, "blob_url": "https://github.com/rust-lang/rust/blob/894b4c64ffdb280a38c1ea2e9be145ca308965fd/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/894b4c64ffdb280a38c1ea2e9be145ca308965fd/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern.rs?ref=894b4c64ffdb280a38c1ea2e9be145ca308965fd", "patch": "@@ -1,1040 +0,0 @@\n-//! Validation of matches.\n-//!\n-//! This module provides lowering from [hir_def::expr::Pat] to [self::Pat] and match\n-//! checking algorithm.\n-//!\n-//! It is modeled on the rustc module `rustc_mir_build::thir::pattern`.\n-\n-mod deconstruct_pat;\n-mod pat_util;\n-pub(crate) mod usefulness;\n-\n-use hir_def::{body::Body, EnumVariantId, LocalFieldId, VariantId};\n-use la_arena::Idx;\n-\n-use crate::{db::HirDatabase, InferenceResult, Interner, Substitution, Ty, TyKind};\n-\n-use self::pat_util::EnumerateAndAdjustIterator;\n-\n-pub(crate) type PatId = Idx<Pat>;\n-\n-#[derive(Clone, Debug)]\n-pub(crate) enum PatternError {\n-    Unimplemented,\n-    UnresolvedVariant,\n-}\n-\n-#[derive(Clone, Debug, PartialEq)]\n-pub(crate) struct FieldPat {\n-    pub(crate) field: LocalFieldId,\n-    pub(crate) pattern: Pat,\n-}\n-\n-#[derive(Clone, Debug, PartialEq)]\n-pub(crate) struct Pat {\n-    pub(crate) ty: Ty,\n-    pub(crate) kind: Box<PatKind>,\n-}\n-\n-impl Pat {\n-    pub(crate) fn wildcard_from_ty(ty: &Ty) -> Self {\n-        Pat { ty: ty.clone(), kind: Box::new(PatKind::Wild) }\n-    }\n-}\n-\n-/// Close relative to `rustc_mir_build::thir::pattern::PatKind`\n-#[derive(Clone, Debug, PartialEq)]\n-pub(crate) enum PatKind {\n-    Wild,\n-\n-    /// `x`, `ref x`, `x @ P`, etc.\n-    Binding {\n-        subpattern: Option<Pat>,\n-    },\n-\n-    /// `Foo(...)` or `Foo{...}` or `Foo`, where `Foo` is a variant name from an ADT with\n-    /// multiple variants.\n-    Variant {\n-        substs: Substitution,\n-        enum_variant: EnumVariantId,\n-        subpatterns: Vec<FieldPat>,\n-    },\n-\n-    /// `(...)`, `Foo(...)`, `Foo{...}`, or `Foo`, where `Foo` is a variant name from an ADT with\n-    /// a single variant.\n-    Leaf {\n-        subpatterns: Vec<FieldPat>,\n-    },\n-\n-    /// `box P`, `&P`, `&mut P`, etc.\n-    Deref {\n-        subpattern: Pat,\n-    },\n-\n-    // FIXME: for now, only bool literals are implemented\n-    LiteralBool {\n-        value: bool,\n-    },\n-\n-    /// An or-pattern, e.g. `p | q`.\n-    /// Invariant: `pats.len() >= 2`.\n-    Or {\n-        pats: Vec<Pat>,\n-    },\n-}\n-\n-pub(crate) struct PatCtxt<'a> {\n-    db: &'a dyn HirDatabase,\n-    infer: &'a InferenceResult,\n-    body: &'a Body,\n-    pub(crate) errors: Vec<PatternError>,\n-}\n-\n-impl<'a> PatCtxt<'a> {\n-    pub(crate) fn new(db: &'a dyn HirDatabase, infer: &'a InferenceResult, body: &'a Body) -> Self {\n-        Self { db, infer, body, errors: Vec::new() }\n-    }\n-\n-    pub(crate) fn lower_pattern(&mut self, pat: hir_def::expr::PatId) -> Pat {\n-        // FIXME: implement pattern adjustments (implicit pattern dereference; \"RFC 2005-match-ergonomics\")\n-        // More info https://github.com/rust-lang/rust/issues/42640#issuecomment-313535089\n-        let unadjusted_pat = self.lower_pattern_unadjusted(pat);\n-        unadjusted_pat\n-    }\n-\n-    fn lower_pattern_unadjusted(&mut self, pat: hir_def::expr::PatId) -> Pat {\n-        let ty = &self.infer[pat];\n-        let variant = self.infer.variant_resolution_for_pat(pat);\n-\n-        let kind = match self.body[pat] {\n-            hir_def::expr::Pat::Wild => PatKind::Wild,\n-\n-            hir_def::expr::Pat::Lit(expr) => self.lower_lit(expr),\n-\n-            hir_def::expr::Pat::Path(ref path) => {\n-                return self.lower_path(pat, path);\n-            }\n-\n-            hir_def::expr::Pat::Tuple { ref args, ellipsis } => {\n-                let arity = match *ty.kind(&Interner) {\n-                    TyKind::Tuple(arity, _) => arity,\n-                    _ => panic!(\"unexpected type for tuple pattern: {:?}\", ty),\n-                };\n-                let subpatterns = self.lower_tuple_subpats(args, arity, ellipsis);\n-                PatKind::Leaf { subpatterns }\n-            }\n-\n-            hir_def::expr::Pat::Bind { subpat, .. } => {\n-                PatKind::Binding { subpattern: self.lower_opt_pattern(subpat) }\n-            }\n-\n-            hir_def::expr::Pat::TupleStruct { ref args, ellipsis, .. } if variant.is_some() => {\n-                let expected_len = variant.unwrap().variant_data(self.db.upcast()).fields().len();\n-                let subpatterns = self.lower_tuple_subpats(args, expected_len, ellipsis);\n-                self.lower_variant_or_leaf(pat, ty, subpatterns)\n-            }\n-\n-            hir_def::expr::Pat::Record { ref args, .. } if variant.is_some() => {\n-                let variant_data = variant.unwrap().variant_data(self.db.upcast());\n-                let subpatterns = args\n-                    .iter()\n-                    .map(|field| FieldPat {\n-                        // XXX(iDawer): field lookup is inefficient\n-                        field: variant_data.field(&field.name).unwrap(),\n-                        pattern: self.lower_pattern(field.pat),\n-                    })\n-                    .collect();\n-                self.lower_variant_or_leaf(pat, ty, subpatterns)\n-            }\n-            hir_def::expr::Pat::TupleStruct { .. } | hir_def::expr::Pat::Record { .. } => {\n-                self.errors.push(PatternError::UnresolvedVariant);\n-                PatKind::Wild\n-            }\n-\n-            hir_def::expr::Pat::Or(ref pats) => PatKind::Or { pats: self.lower_patterns(pats) },\n-\n-            _ => {\n-                self.errors.push(PatternError::Unimplemented);\n-                PatKind::Wild\n-            }\n-        };\n-\n-        Pat { ty: ty.clone(), kind: Box::new(kind) }\n-    }\n-\n-    fn lower_tuple_subpats(\n-        &mut self,\n-        pats: &[hir_def::expr::PatId],\n-        expected_len: usize,\n-        ellipsis: Option<usize>,\n-    ) -> Vec<FieldPat> {\n-        pats.iter()\n-            .enumerate_and_adjust(expected_len, ellipsis)\n-            .map(|(i, &subpattern)| FieldPat {\n-                field: LocalFieldId::from_raw((i as u32).into()),\n-                pattern: self.lower_pattern(subpattern),\n-            })\n-            .collect()\n-    }\n-\n-    fn lower_patterns(&mut self, pats: &[hir_def::expr::PatId]) -> Vec<Pat> {\n-        pats.iter().map(|&p| self.lower_pattern(p)).collect()\n-    }\n-\n-    fn lower_opt_pattern(&mut self, pat: Option<hir_def::expr::PatId>) -> Option<Pat> {\n-        pat.map(|p| self.lower_pattern(p))\n-    }\n-\n-    fn lower_variant_or_leaf(\n-        &mut self,\n-        pat: hir_def::expr::PatId,\n-        ty: &Ty,\n-        subpatterns: Vec<FieldPat>,\n-    ) -> PatKind {\n-        let kind = match self.infer.variant_resolution_for_pat(pat) {\n-            Some(variant_id) => {\n-                if let VariantId::EnumVariantId(enum_variant) = variant_id {\n-                    let substs = match ty.kind(&Interner) {\n-                        TyKind::Adt(_, substs) | TyKind::FnDef(_, substs) => substs.clone(),\n-                        TyKind::Error => {\n-                            return PatKind::Wild;\n-                        }\n-                        _ => panic!(\"inappropriate type for def: {:?}\", ty),\n-                    };\n-                    PatKind::Variant { substs, enum_variant, subpatterns }\n-                } else {\n-                    PatKind::Leaf { subpatterns }\n-                }\n-            }\n-            None => {\n-                self.errors.push(PatternError::UnresolvedVariant);\n-                PatKind::Wild\n-            }\n-        };\n-        kind\n-    }\n-\n-    fn lower_path(&mut self, pat: hir_def::expr::PatId, _path: &hir_def::path::Path) -> Pat {\n-        let ty = &self.infer[pat];\n-\n-        let pat_from_kind = |kind| Pat { ty: ty.clone(), kind: Box::new(kind) };\n-\n-        match self.infer.variant_resolution_for_pat(pat) {\n-            Some(_) => pat_from_kind(self.lower_variant_or_leaf(pat, ty, Vec::new())),\n-            None => {\n-                self.errors.push(PatternError::UnresolvedVariant);\n-                pat_from_kind(PatKind::Wild)\n-            }\n-        }\n-    }\n-\n-    fn lower_lit(&mut self, expr: hir_def::expr::ExprId) -> PatKind {\n-        use hir_def::expr::{Expr, Literal::Bool};\n-\n-        match self.body[expr] {\n-            Expr::Literal(Bool(value)) => PatKind::LiteralBool { value },\n-            _ => {\n-                self.errors.push(PatternError::Unimplemented);\n-                PatKind::Wild\n-            }\n-        }\n-    }\n-}\n-\n-pub(crate) trait PatternFoldable: Sized {\n-    fn fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n-        self.super_fold_with(folder)\n-    }\n-\n-    fn super_fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self;\n-}\n-\n-pub(crate) trait PatternFolder: Sized {\n-    fn fold_pattern(&mut self, pattern: &Pat) -> Pat {\n-        pattern.super_fold_with(self)\n-    }\n-\n-    fn fold_pattern_kind(&mut self, kind: &PatKind) -> PatKind {\n-        kind.super_fold_with(self)\n-    }\n-}\n-\n-impl<T: PatternFoldable> PatternFoldable for Box<T> {\n-    fn super_fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n-        let content: T = (**self).fold_with(folder);\n-        Box::new(content)\n-    }\n-}\n-\n-impl<T: PatternFoldable> PatternFoldable for Vec<T> {\n-    fn super_fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n-        self.iter().map(|t| t.fold_with(folder)).collect()\n-    }\n-}\n-\n-impl<T: PatternFoldable> PatternFoldable for Option<T> {\n-    fn super_fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n-        self.as_ref().map(|t| t.fold_with(folder))\n-    }\n-}\n-\n-macro_rules! clone_impls {\n-    ($($ty:ty),+) => {\n-        $(\n-            impl PatternFoldable for $ty {\n-                fn super_fold_with<F: PatternFolder>(&self, _: &mut F) -> Self {\n-                    Clone::clone(self)\n-                }\n-            }\n-        )+\n-    }\n-}\n-\n-clone_impls! { LocalFieldId, Ty, Substitution, EnumVariantId }\n-\n-impl PatternFoldable for FieldPat {\n-    fn super_fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n-        FieldPat { field: self.field.fold_with(folder), pattern: self.pattern.fold_with(folder) }\n-    }\n-}\n-\n-impl PatternFoldable for Pat {\n-    fn fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n-        folder.fold_pattern(self)\n-    }\n-\n-    fn super_fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n-        Pat { ty: self.ty.fold_with(folder), kind: self.kind.fold_with(folder) }\n-    }\n-}\n-\n-impl PatternFoldable for PatKind {\n-    fn fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n-        folder.fold_pattern_kind(self)\n-    }\n-\n-    fn super_fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n-        match self {\n-            PatKind::Wild => PatKind::Wild,\n-            PatKind::Binding { subpattern } => {\n-                PatKind::Binding { subpattern: subpattern.fold_with(folder) }\n-            }\n-            PatKind::Variant { substs, enum_variant, subpatterns } => PatKind::Variant {\n-                substs: substs.fold_with(folder),\n-                enum_variant: enum_variant.fold_with(folder),\n-                subpatterns: subpatterns.fold_with(folder),\n-            },\n-            PatKind::Leaf { subpatterns } => {\n-                PatKind::Leaf { subpatterns: subpatterns.fold_with(folder) }\n-            }\n-            PatKind::Deref { subpattern } => {\n-                PatKind::Deref { subpattern: subpattern.fold_with(folder) }\n-            }\n-            &PatKind::LiteralBool { value } => PatKind::LiteralBool { value },\n-            PatKind::Or { pats } => PatKind::Or { pats: pats.fold_with(folder) },\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::diagnostics::tests::check_diagnostics;\n-\n-    #[test]\n-    fn empty_tuple() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match () { }\n-        //^^ Missing match arm\n-    match (()) { }\n-        //^^^^ Missing match arm\n-\n-    match () { _ => (), }\n-    match () { () => (), }\n-    match (()) { (()) => (), }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_two_empty_tuple() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match ((), ()) { }\n-        //^^^^^^^^ Missing match arm\n-\n-    match ((), ()) { ((), ()) => (), }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn boolean() {\n-        check_diagnostics(\n-            r#\"\n-fn test_main() {\n-    match false { }\n-        //^^^^^ Missing match arm\n-    match false { true => (), }\n-        //^^^^^ Missing match arm\n-    match (false, true) {}\n-        //^^^^^^^^^^^^^ Missing match arm\n-    match (false, true) { (true, true) => (), }\n-        //^^^^^^^^^^^^^ Missing match arm\n-    match (false, true) {\n-        //^^^^^^^^^^^^^ Missing match arm\n-        (false, true) => (),\n-        (false, false) => (),\n-        (true, false) => (),\n-    }\n-    match (false, true) { (true, _x) => (), }\n-        //^^^^^^^^^^^^^ Missing match arm\n-\n-    match false { true => (), false => (), }\n-    match (false, true) {\n-        (false, _) => (),\n-        (true, false) => (),\n-        (_, true) => (),\n-    }\n-    match (false, true) {\n-        (true, true) => (),\n-        (true, false) => (),\n-        (false, true) => (),\n-        (false, false) => (),\n-    }\n-    match (false, true) {\n-        (true, _x) => (),\n-        (false, true) => (),\n-        (false, false) => (),\n-    }\n-    match (false, true, false) {\n-        (false, ..) => (),\n-        (true, ..) => (),\n-    }\n-    match (false, true, false) {\n-        (.., false) => (),\n-        (.., true) => (),\n-    }\n-    match (false, true, false) { (..) => (), }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_tuple_and_bools() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match (false, ((), false)) {}\n-        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-    match (false, ((), false)) { (true, ((), true)) => (), }\n-        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-    match (false, ((), false)) { (true, _) => (), }\n-        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-\n-    match (false, ((), false)) {\n-        (true, ((), true)) => (),\n-        (true, ((), false)) => (),\n-        (false, ((), true)) => (),\n-        (false, ((), false)) => (),\n-    }\n-    match (false, ((), false)) {\n-        (true, ((), true)) => (),\n-        (true, ((), false)) => (),\n-        (false, _) => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enums() {\n-        check_diagnostics(\n-            r#\"\n-enum Either { A, B, }\n-\n-fn main() {\n-    match Either::A { }\n-        //^^^^^^^^^ Missing match arm\n-    match Either::B { Either::A => (), }\n-        //^^^^^^^^^ Missing match arm\n-\n-    match &Either::B {\n-        //^^^^^^^^^^ Missing match arm\n-        Either::A => (),\n-    }\n-\n-    match Either::B {\n-        Either::A => (), Either::B => (),\n-    }\n-    match &Either::B {\n-        Either::A => (), Either::B => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_containing_bool() {\n-        check_diagnostics(\n-            r#\"\n-enum Either { A(bool), B }\n-\n-fn main() {\n-    match Either::B { }\n-        //^^^^^^^^^ Missing match arm\n-    match Either::B {\n-        //^^^^^^^^^ Missing match arm\n-        Either::A(true) => (), Either::B => ()\n-    }\n-\n-    match Either::B {\n-        Either::A(true) => (),\n-        Either::A(false) => (),\n-        Either::B => (),\n-    }\n-    match Either::B {\n-        Either::B => (),\n-        _ => (),\n-    }\n-    match Either::B {\n-        Either::A(_) => (),\n-        Either::B => (),\n-    }\n-\n-}\n-        \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_different_sizes() {\n-        check_diagnostics(\n-            r#\"\n-enum Either { A(bool), B(bool, bool) }\n-\n-fn main() {\n-    match Either::A(false) {\n-        //^^^^^^^^^^^^^^^^ Missing match arm\n-        Either::A(_) => (),\n-        Either::B(false, _) => (),\n-    }\n-\n-    match Either::A(false) {\n-        Either::A(_) => (),\n-        Either::B(true, _) => (),\n-        Either::B(false, _) => (),\n-    }\n-    match Either::A(false) {\n-        Either::A(true) | Either::A(false) => (),\n-        Either::B(true, _) => (),\n-        Either::B(false, _) => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_enum_no_diagnostic() {\n-        check_diagnostics(\n-            r#\"\n-enum Either { A(bool), B(bool, bool) }\n-enum Either2 { C, D }\n-\n-fn main() {\n-    match (Either::A(false), Either2::C) {\n-        (Either::A(true), _) | (Either::A(false), _) => (),\n-        (Either::B(true, _), Either2::C) => (),\n-        (Either::B(false, _), Either2::C) => (),\n-        (Either::B(_, _), Either2::D) => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn or_pattern_no_diagnostic() {\n-        check_diagnostics(\n-            r#\"\n-enum Either {A, B}\n-\n-fn main() {\n-    match (Either::A, Either::B) {\n-        (Either::A | Either::B, _) => (),\n-    }\n-}\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn mismatched_types() {\n-        // Match statements with arms that don't match the\n-        // expression pattern do not fire this diagnostic.\n-        check_diagnostics(\n-            r#\"\n-enum Either { A, B }\n-enum Either2 { C, D }\n-\n-fn main() {\n-    match Either::A {\n-        Either2::C => (),\n-        Either2::D => (),\n-    }\n-    match (true, false) {\n-        (true, false, true) => (),\n-        (true) => (),\n-    }\n-    match (0) { () => () }\n-    match Unresolved::Bar { Unresolved::Baz => () }\n-}\n-        \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn malformed_match_arm_tuple_enum_missing_pattern() {\n-        // We are testing to be sure we don't panic here when the match\n-        // arm `Either::B` is missing its pattern.\n-        check_diagnostics(\n-            r#\"\n-enum Either { A, B(u32) }\n-\n-fn main() {\n-    match Either::A {\n-        Either::A => (),\n-        Either::B() => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn expr_diverges() {\n-        check_diagnostics(\n-            r#\"\n-enum Either { A, B }\n-\n-fn main() {\n-    match loop {} {\n-        Either::A => (),\n-        Either::B => (),\n-    }\n-    match loop {} {\n-        Either::A => (),\n-    }\n-    match loop { break Foo::A } {\n-        //^^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-        Either::A => (),\n-    }\n-    match loop { break Foo::A } {\n-        Either::A => (),\n-        Either::B => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn expr_partially_diverges() {\n-        check_diagnostics(\n-            r#\"\n-enum Either<T> { A(T), B }\n-\n-fn foo() -> Either<!> { Either::B }\n-fn main() -> u32 {\n-    match foo() {\n-        Either::A(val) => val,\n-        Either::B => 0,\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_record() {\n-        check_diagnostics(\n-            r#\"\n-enum Either { A { foo: bool }, B }\n-\n-fn main() {\n-    let a = Either::A { foo: true };\n-    match a { }\n-        //^ Missing match arm\n-    match a { Either::A { foo: true } => () }\n-        //^ Missing match arm\n-    match a {\n-        Either::A { } => (),\n-      //^^^^^^^^^ Missing structure fields:\n-      //        | - foo\n-        Either::B => (),\n-    }\n-    match a {\n-        //^ Missing match arm\n-        Either::A { } => (),\n-    } //^^^^^^^^^ Missing structure fields:\n-      //        | - foo\n-\n-    match a {\n-        Either::A { foo: true } => (),\n-        Either::A { foo: false } => (),\n-        Either::B => (),\n-    }\n-    match a {\n-        Either::A { foo: _ } => (),\n-        Either::B => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_record_fields_out_of_order() {\n-        check_diagnostics(\n-            r#\"\n-enum Either {\n-    A { foo: bool, bar: () },\n-    B,\n-}\n-\n-fn main() {\n-    let a = Either::A { foo: true, bar: () };\n-    match a {\n-        //^ Missing match arm\n-        Either::A { bar: (), foo: false } => (),\n-        Either::A { foo: true, bar: () } => (),\n-    }\n-\n-    match a {\n-        Either::A { bar: (), foo: false } => (),\n-        Either::A { foo: true, bar: () } => (),\n-        Either::B => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_record_ellipsis() {\n-        check_diagnostics(\n-            r#\"\n-enum Either {\n-    A { foo: bool, bar: bool },\n-    B,\n-}\n-\n-fn main() {\n-    let a = Either::B;\n-    match a {\n-        //^ Missing match arm\n-        Either::A { foo: true, .. } => (),\n-        Either::B => (),\n-    }\n-    match a {\n-        //^ Missing match arm\n-        Either::A { .. } => (),\n-    }\n-\n-    match a {\n-        Either::A { foo: true, .. } => (),\n-        Either::A { foo: false, .. } => (),\n-        Either::B => (),\n-    }\n-\n-    match a {\n-        Either::A { .. } => (),\n-        Either::B => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_tuple_partial_ellipsis() {\n-        check_diagnostics(\n-            r#\"\n-enum Either {\n-    A(bool, bool, bool, bool),\n-    B,\n-}\n-\n-fn main() {\n-    match Either::B {\n-        //^^^^^^^^^ Missing match arm\n-        Either::A(true, .., true) => (),\n-        Either::A(true, .., false) => (),\n-        Either::A(false, .., false) => (),\n-        Either::B => (),\n-    }\n-    match Either::B {\n-        //^^^^^^^^^ Missing match arm\n-        Either::A(true, .., true) => (),\n-        Either::A(true, .., false) => (),\n-        Either::A(.., true) => (),\n-        Either::B => (),\n-    }\n-\n-    match Either::B {\n-        Either::A(true, .., true) => (),\n-        Either::A(true, .., false) => (),\n-        Either::A(false, .., true) => (),\n-        Either::A(false, .., false) => (),\n-        Either::B => (),\n-    }\n-    match Either::B {\n-        Either::A(true, .., true) => (),\n-        Either::A(true, .., false) => (),\n-        Either::A(.., true) => (),\n-        Either::A(.., false) => (),\n-        Either::B => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn never() {\n-        check_diagnostics(\n-            r#\"\n-enum Never {}\n-\n-fn enum_(never: Never) {\n-    match never {}\n-}\n-fn enum_ref(never: &Never) {\n-    match never {}\n-        //^^^^^ Missing match arm\n-}\n-fn bang(never: !) {\n-    match never {}\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn unknown_type() {\n-        check_diagnostics(\n-            r#\"\n-enum Option<T> { Some(T), None }\n-\n-fn main() {\n-    // `Never` is deliberately not defined so that it's an uninferred type.\n-    match Option::<Never>::None {\n-        None => (),\n-        Some(never) => match never {},\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_bools_with_ellipsis_at_end_missing_arm() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match (false, true, false) {\n-        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-        (false, ..) => (),\n-    }\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_bools_with_ellipsis_at_beginning_missing_arm() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match (false, true, false) {\n-        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-        (.., false) => (),\n-    }\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_bools_with_ellipsis_in_middle_missing_arm() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match (false, true, false) {\n-        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-        (true, .., false) => (),\n-    }\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn record_struct() {\n-        check_diagnostics(\n-            r#\"struct Foo { a: bool }\n-fn main(f: Foo) {\n-    match f {}\n-        //^ Missing match arm\n-    match f { Foo { a: true } => () }\n-        //^ Missing match arm\n-    match &f { Foo { a: true } => () }\n-        //^^ Missing match arm\n-    match f { Foo { a: _ } => () }\n-    match f {\n-        Foo { a: true } => (),\n-        Foo { a: false } => (),\n-    }\n-    match &f {\n-        Foo { a: true } => (),\n-        Foo { a: false } => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_struct() {\n-        check_diagnostics(\n-            r#\"struct Foo(bool);\n-fn main(f: Foo) {\n-    match f {}\n-        //^ Missing match arm\n-    match f { Foo(true) => () }\n-        //^ Missing match arm\n-    match f {\n-        Foo(true) => (),\n-        Foo(false) => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn unit_struct() {\n-        check_diagnostics(\n-            r#\"struct Foo;\n-fn main(f: Foo) {\n-    match f {}\n-        //^ Missing match arm\n-    match f { Foo => () }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn record_struct_ellipsis() {\n-        check_diagnostics(\n-            r#\"struct Foo { foo: bool, bar: bool }\n-fn main(f: Foo) {\n-    match f { Foo { foo: true, .. } => () }\n-        //^ Missing match arm\n-    match f {\n-        //^ Missing match arm\n-        Foo { foo: true, .. } => (),\n-        Foo { bar: false, .. } => ()\n-    }\n-    match f { Foo { .. } => () }\n-    match f {\n-        Foo { foo: true, .. } => (),\n-        Foo { foo: false, .. } => ()\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn internal_or() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    enum Either { A(bool), B }\n-    match Either::B {\n-        //^^^^^^^^^ Missing match arm\n-        Either::A(true | false) => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_panic_at_unimplemented_subpattern_type() {\n-        check_diagnostics(\n-            r#\"\n-struct S { a: char}\n-fn main(v: S) {\n-    match v { S{ a }      => {} }\n-    match v { S{ a: _x }  => {} }\n-    match v { S{ a: 'a' } => {} }\n-    match v { S{..}       => {} }\n-    match v { _           => {} }\n-    match v { }\n-        //^ Missing match arm\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn binding() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match true {\n-        _x @ true => {}\n-        false     => {}\n-    }\n-    match true { _x @ true => {} }\n-        //^^^^ Missing match arm\n-}\n-\"#,\n-        );\n-    }\n-\n-    mod false_negatives {\n-        //! The implementation of match checking here is a work in progress. As we roll this out, we\n-        //! prefer false negatives to false positives (ideally there would be no false positives). This\n-        //! test module should document known false negatives. Eventually we will have a complete\n-        //! implementation of match checking and this module will be empty.\n-        //!\n-        //! The reasons for documenting known false negatives:\n-        //!\n-        //!   1. It acts as a backlog of work that can be done to improve the behavior of the system.\n-        //!   2. It ensures the code doesn't panic when handling these cases.\n-        use super::*;\n-\n-        #[test]\n-        fn integers() {\n-            // We don't currently check integer exhaustiveness.\n-            check_diagnostics(\n-                r#\"\n-fn main() {\n-    match 5 {\n-        10 => (),\n-        11..20 => (),\n-    }\n-}\n-\"#,\n-            );\n-        }\n-    }\n-}"}]}