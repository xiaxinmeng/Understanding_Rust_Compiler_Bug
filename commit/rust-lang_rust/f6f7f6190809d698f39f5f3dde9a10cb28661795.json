{"sha": "f6f7f6190809d698f39f5f3dde9a10cb28661795", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2ZjdmNjE5MDgwOWQ2OThmMzlmNWYzZGRlOWExMGNiMjg2NjE3OTU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-16T00:59:50Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-16T01:00:59Z"}, "message": "rustc: Implement logging in DPS", "tree": {"sha": "3eb67c52135302e8132153d19a028f2e6663134b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3eb67c52135302e8132153d19a028f2e6663134b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6f7f6190809d698f39f5f3dde9a10cb28661795", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6f7f6190809d698f39f5f3dde9a10cb28661795", "html_url": "https://github.com/rust-lang/rust/commit/f6f7f6190809d698f39f5f3dde9a10cb28661795", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6f7f6190809d698f39f5f3dde9a10cb28661795/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69abf0a5ffc20854f18a1fd720906c4f94cae7f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/69abf0a5ffc20854f18a1fd720906c4f94cae7f7", "html_url": "https://github.com/rust-lang/rust/commit/69abf0a5ffc20854f18a1fd720906c4f94cae7f7"}], "stats": {"total": 118, "additions": 109, "deletions": 9}, "files": [{"sha": "e4497ac8d8e8784218edd9dae6e50d7338283afb", "filename": "src/comp/middle/trans_dps.rs", "status": "modified", "additions": 109, "deletions": 9, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/f6f7f6190809d698f39f5f3dde9a10cb28661795/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f7f6190809d698f39f5f3dde9a10cb28661795/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs?ref=f6f7f6190809d698f39f5f3dde9a10cb28661795", "patch": "@@ -2,16 +2,19 @@\n // destination-passing style.\n \n import back::abi;\n+import back::link;\n import lib::llvm::llvm;\n import llvm::TypeRef;\n import llvm::ValueRef;\n import middle::trans;\n import middle::ty;\n import syntax::ast;\n+import syntax::codemap::span;\n import trans::block_ctxt;\n import trans::crate_ctxt;\n import trans::fn_ctxt;\n import trans::local_ctxt;\n+import util::ppaux;\n \n import std::ivec;\n import std::option::none;\n@@ -20,6 +23,7 @@ import std::str;\n \n import LLFalse = lib::llvm::False;\n import LLTrue = lib::llvm::True;\n+import ll = lib::llvm;\n import lltype_of = trans::val_ty;\n import option = std::option::t;\n import tc = trans_common;\n@@ -40,26 +44,35 @@ tag dest_slot {\n     dst_val(ValueRef);\n }\n \n-type dest = rec(dest_slot slot, bool move);\n+tag dest_mode { dm_copy; dm_move; dm_alias; }\n+\n+type dest = rec(dest_slot slot, dest_mode mode);\n \n fn dest_slot_for_ptr(&ty::ctxt tcx, ValueRef llptr, ty::t t) -> dest_slot {\n     if ty::type_is_nil(tcx, t) { dst_nil } else { dst_val(llptr) }\n }\n \n fn dest_copy(&ty::ctxt tcx, ValueRef llptr, ty::t t) -> dest {\n-    ret rec(slot=dest_slot_for_ptr(tcx, llptr, t), move=false);\n+    ret rec(slot=dest_slot_for_ptr(tcx, llptr, t), mode=dm_copy);\n }\n \n fn dest_move(&ty::ctxt tcx, ValueRef llptr, ty::t t) -> dest {\n-    ret rec(slot=dest_slot_for_ptr(tcx, llptr, t), move=true);\n+    ret rec(slot=dest_slot_for_ptr(tcx, llptr, t), mode=dm_move);\n+}\n+\n+fn dest_alias(&ty::ctxt tcx, ValueRef llptr, ty::t t) -> dest {\n+    ret rec(slot=dest_slot_for_ptr(tcx, llptr, t), mode=dm_alias);\n }\n \n-fn dest_tmp(&@block_ctxt bcx, ty::t t) -> tup(@block_ctxt, dest) {\n+fn dest_tmp(&@block_ctxt bcx, ty::t t, bool alias) -> tup(@block_ctxt, dest) {\n+    auto mode = if alias { dm_alias } else { dm_move };\n     if ty::type_is_nil(bcx_tcx(bcx), t) {\n-        ret tup(bcx, rec(slot=dst_nil, move=true));\n+        ret tup(bcx, rec(slot=dst_nil, mode=mode));\n     }\n     auto r = trans::alloc_ty(bcx, t);\n-    ret tup(r.bcx, dest_move(bcx_tcx(bcx), r.val, t));\n+    trans::add_clean(bcx, r.val, t);\n+    ret tup(r.bcx, rec(slot=dest_slot_for_ptr(bcx_tcx(bcx), r.val, t),\n+                       mode=mode));\n }\n \n fn dest_ptr(&dest dest) -> ValueRef {\n@@ -77,6 +90,7 @@ fn bcx_tcx(&@block_ctxt bcx) -> ty::ctxt { ret bcx.fcx.lcx.ccx.tcx; }\n fn bcx_ccx(&@block_ctxt bcx) -> @crate_ctxt { ret bcx.fcx.lcx.ccx; }\n fn bcx_lcx(&@block_ctxt bcx) -> @local_ctxt { ret bcx.fcx.lcx; }\n fn bcx_fcx(&@block_ctxt bcx) -> @fn_ctxt { ret bcx.fcx; }\n+fn lcx_ccx(&@local_ctxt lcx) -> @crate_ctxt { ret lcx.ccx; }\n \n \n // Common operations\n@@ -164,9 +178,92 @@ fn trans_lit(&@block_ctxt cx, &dest dest, &ast::lit lit) -> @block_ctxt {\n     ret bcx;\n }\n \n+fn trans_log(&@block_ctxt cx, &span sp, int level, &@ast::expr expr)\n+        -> @block_ctxt {\n+    fn trans_log_level(&@local_ctxt lcx) -> ValueRef {\n+        auto modname = str::connect_ivec(lcx.module_path, \"::\");\n+\n+        if (lcx_ccx(lcx).module_data.contains_key(modname)) {\n+            ret lcx_ccx(lcx).module_data.get(modname);\n+        }\n+\n+        auto s =\n+            link::mangle_internal_name_by_path_and_seq(lcx_ccx(lcx),\n+                                                       lcx.module_path,\n+                                                       \"loglevel\");\n+        auto lllevelptr = llvm::LLVMAddGlobal(lcx.ccx.llmod, tc::T_int(),\n+                                              str::buf(s));\n+        llvm::LLVMSetGlobalConstant(lllevelptr, LLFalse);\n+        llvm::LLVMSetInitializer(lllevelptr, tc::C_int(0));\n+        llvm::LLVMSetLinkage(lllevelptr, lib::llvm::LLVMInternalLinkage as\n+                             llvm::Linkage);\n+        lcx_ccx(lcx).module_data.insert(modname, lllevelptr);\n+        ret lllevelptr;\n+    }\n+\n+    fn trans_log_upcall(&@block_ctxt bcx, &span sp, ValueRef in_llval,\n+                        int level, ty::t t) {\n+        auto llval = in_llval;\n+        auto by_val; auto llupcall;\n+        alt (ty::struct(bcx_tcx(bcx), t)) {\n+          ty::ty_machine(ast::ty_f32) {\n+            by_val = true; llupcall = bcx_ccx(bcx).upcalls.log_float;\n+          }\n+          ty::ty_machine(ast::ty_f64) | ty::ty_float {\n+            by_val = false; llupcall = bcx_ccx(bcx).upcalls.log_double;\n+          }\n+          ty::ty_bool | ty::ty_machine(ast::ty_i8) |\n+                ty::ty_machine(ast::ty_i16) | ty::ty_machine(ast::ty_u8) |\n+                ty::ty_machine(ast::ty_u16) {\n+            by_val = true; llupcall = bcx_ccx(bcx).upcalls.log_int;\n+            llval = bcx.build.ZExt(llval, tc::T_i32());\n+          }\n+          ty::ty_int | ty::ty_machine(ast::ty_i32) |\n+                ty::ty_machine(ast::ty_u32) {\n+            by_val = true; llupcall = bcx_ccx(bcx).upcalls.log_int;\n+          }\n+          _ {\n+            bcx_ccx(bcx).sess.span_unimpl(sp, \"logging for values of type \" +\n+                ppaux::ty_to_str(bcx_tcx(bcx), t));\n+          }\n+        }\n+\n+        if by_val { llval = bcx.build.Load(llval); }\n+        bcx.build.Call(llupcall,\n+                       ~[bcx_fcx(bcx).lltaskptr, tc::C_int(level), llval]);\n+    }\n+\n+    auto bcx = cx;\n+\n+    auto lllevelptr = trans_log_level(bcx_lcx(bcx));\n+\n+    auto log_bcx = trans::new_scope_block_ctxt(bcx, \"log\");\n+    auto next_bcx = trans::new_scope_block_ctxt(bcx, \"next_log\");\n+\n+    auto should_log = bcx.build.ICmp(ll::LLVMIntSGE,\n+                                     bcx.build.Load(lllevelptr),\n+                                     tc::C_int(level));\n+    bcx.build.CondBr(should_log, log_bcx.llbb, next_bcx.llbb);\n+\n+    auto expr_t = ty::expr_ty(bcx_tcx(log_bcx), expr);\n+    auto r = dest_tmp(log_bcx, expr_t, true);\n+    log_bcx = r._0; auto tmp = r._1;\n+    log_bcx = trans_expr(log_bcx, tmp, expr);\n+\n+    trans_log_upcall(log_bcx, sp, dest_ptr(tmp), level, expr_t);\n+\n+    log_bcx = trans::trans_block_cleanups(log_bcx,\n+                                          trans::find_scope_cx(log_bcx));\n+    log_bcx.build.Br(next_bcx.llbb);\n+    ret next_bcx;\n+}\n+\n fn trans_expr(&@block_ctxt bcx, &dest dest, &@ast::expr expr) -> @block_ctxt {\n     alt (expr.node) {\n       ast::expr_lit(?lit) { trans_lit(bcx, dest, *lit); ret bcx; }\n+      ast::expr_log(?level, ?operand) {\n+        ret trans_log(bcx, expr.span, level, operand);\n+      }\n       _ { fail \"unhandled expr type in trans_expr\"; }\n     }\n }\n@@ -191,9 +288,12 @@ fn trans_block(&@block_ctxt cx, &dest dest, &ast::block block)\n     }\n \n     alt (block.node.expr) {\n-      some(?e) { ret trans_expr(bcx, dest, e); }\n-      none { ret bcx; }\n+      some(?e) { bcx = trans_expr(bcx, dest, e); }\n+      none { /* no-op */ }\n     }\n+\n+    bcx = trans::trans_block_cleanups(bcx, trans::find_scope_cx(bcx));\n+    ret bcx;\n }\n \n \n@@ -305,7 +405,7 @@ fn trans_stmt(&@block_ctxt cx, &@ast::stmt stmt) -> @block_ctxt {\n     auto bcx = cx;\n     alt (stmt.node) {\n       ast::stmt_expr(?e, _) {\n-        auto tmp_r = dest_tmp(bcx, ty::expr_ty(bcx_tcx(bcx), e));\n+        auto tmp_r = dest_tmp(bcx, ty::expr_ty(bcx_tcx(bcx), e), true);\n         bcx = tmp_r._0; auto tmp = tmp_r._1;\n         ret trans_expr(bcx, tmp, e);\n       }"}]}