{"sha": "a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1ZmUxNzZlOTcxNWY2ZTY3YTNlZGUzZDIwNGJhODRiMmY5MmNlN2Q=", "commit": {"author": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-07-11T16:54:01Z"}, "committer": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-07-12T19:53:34Z"}, "message": "Convert a first batch of diagnostics to have error codes", "tree": {"sha": "d8df65f649f4df474a02e6baf9d4b371b802e5f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8df65f649f4df474a02e6baf9d4b371b802e5f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d", "comment_count": 10, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d", "html_url": "https://github.com/rust-lang/rust/commit/a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d/comments", "author": null, "committer": null, "parents": [{"sha": "350f3aa856682fed816a0a2018b3bcf50178eeff", "url": "https://api.github.com/repos/rust-lang/rust/commits/350f3aa856682fed816a0a2018b3bcf50178eeff", "html_url": "https://github.com/rust-lang/rust/commit/350f3aa856682fed816a0a2018b3bcf50178eeff"}], "stats": {"total": 800, "additions": 410, "deletions": 390}, "files": [{"sha": "5f3bbf481056a4dc5662e616f39e7a4c58b55171", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d", "patch": "@@ -16,3 +16,99 @@ register_diagnostic!(E0001, r##\"\n     This means that perhaps some of the preceeding patterns are too general, this\n     one is too specific or the ordering is incorrect.\n \"##)\n+\n+register_diagnostics!(\n+    E0002,\n+    E0003,\n+    E0004,\n+    E0005,\n+    E0006,\n+    E0007,\n+    E0008,\n+    E0009,\n+    E0010,\n+    E0011,\n+    E0012,\n+    E0013,\n+    E0014,\n+    E0015,\n+    E0016,\n+    E0017,\n+    E0018,\n+    E0019,\n+    E0020,\n+    E0021,\n+    E0022,\n+    E0023,\n+    E0024,\n+    E0025,\n+    E0026,\n+    E0027,\n+    E0028,\n+    E0029,\n+    E0030,\n+    E0031,\n+    E0032,\n+    E0033,\n+    E0034,\n+    E0035,\n+    E0036,\n+    E0037,\n+    E0038,\n+    E0039,\n+    E0040,\n+    E0041,\n+    E0042,\n+    E0043,\n+    E0044,\n+    E0045,\n+    E0046,\n+    E0047,\n+    E0048,\n+    E0049,\n+    E0050,\n+    E0051,\n+    E0052,\n+    E0053,\n+    E0054,\n+    E0055,\n+    E0056,\n+    E0057,\n+    E0058,\n+    E0059,\n+    E0060,\n+    E0061,\n+    E0062,\n+    E0063,\n+    E0064,\n+    E0065,\n+    E0066,\n+    E0067,\n+    E0068,\n+    E0069,\n+    E0070,\n+    E0071,\n+    E0072,\n+    E0073,\n+    E0074,\n+    E0075,\n+    E0076,\n+    E0077,\n+    E0078,\n+    E0079,\n+    E0080,\n+    E0081,\n+    E0082,\n+    E0083,\n+    E0084,\n+    E0085,\n+    E0086,\n+    E0087,\n+    E0088,\n+    E0089,\n+    E0090,\n+    E0091,\n+    E0092,\n+    E0093,\n+    E0094\n+)"}, {"sha": "135e21e4e018463bb812176a1db0fc8da812b251", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d", "patch": "@@ -85,6 +85,9 @@ impl Session {\n     pub fn span_warn(&self, sp: Span, msg: &str) {\n         self.diagnostic().span_warn(sp, msg)\n     }\n+    pub fn span_warn_with_code(&self, sp: Span, msg: &str, code: &str) {\n+        self.diagnostic().span_warn_with_code(sp, msg, code)\n+    }\n     pub fn warn(&self, msg: &str) {\n         self.diagnostic().handler().warn(msg)\n     }"}, {"sha": "283d667f3a8032973ca4037ca30009d915cc5c35", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 22, "deletions": 29, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d", "patch": "@@ -87,28 +87,25 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr, is_const: bool) {\n         match e.node {\n           ExprUnary(UnDeref, _) => { }\n           ExprUnary(UnBox, _) | ExprUnary(UnUniq, _) => {\n-            v.tcx.sess.span_err(e.span,\n-                                \"cannot do allocations in constant expressions\");\n+            span_err!(v.tcx.sess, e.span, E0010, \"cannot do allocations in constant expressions\");\n             return;\n           }\n           ExprLit(lit) if ast_util::lit_is_str(lit) => {}\n           ExprBinary(..) | ExprUnary(..) => {\n             let method_call = typeck::MethodCall::expr(e.id);\n             if v.tcx.method_map.borrow().contains_key(&method_call) {\n-                v.tcx.sess.span_err(e.span, \"user-defined operators are not \\\n-                                             allowed in constant expressions\");\n+                span_err!(v.tcx.sess, e.span, E0011,\n+                    \"user-defined operators are not allowed in constant expressions\");\n             }\n           }\n           ExprLit(_) => (),\n           ExprCast(_, _) => {\n             let ety = ty::expr_ty(v.tcx, e);\n             if !ty::type_is_numeric(ety) && !ty::type_is_unsafe_ptr(ety) {\n-                v.tcx\n-                 .sess\n-                 .span_err(e.span,\n-                           format!(\"can not cast to `{}` in a constant \\\n-                                    expression\",\n-                                   ppaux::ty_to_string(v.tcx, ety)).as_slice())\n+                span_err!(v.tcx.sess, e.span, E0012,\n+                    \"can not cast to `{}` in a constant expression\",\n+                    ppaux::ty_to_string(v.tcx, ety)\n+                );\n             }\n           }\n           ExprPath(ref pth) => {\n@@ -117,9 +114,8 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr, is_const: bool) {\n             // foo::<bar> in a const. Currently that is only done on\n             // a path in trans::callee that only works in block contexts.\n             if !pth.segments.iter().all(|segment| segment.types.is_empty()) {\n-                v.tcx.sess.span_err(e.span,\n-                                    \"paths in constants may only refer to \\\n-                                     items without type parameters\");\n+                span_err!(v.tcx.sess, e.span, E0013,\n+                    \"paths in constants may only refer to items without type parameters\");\n             }\n             match v.tcx.def_map.borrow().find(&e.id) {\n               Some(&DefStatic(..)) |\n@@ -129,9 +125,8 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr, is_const: bool) {\n \n               Some(&def) => {\n                 debug!(\"(checking const) found bad def: {:?}\", def);\n-                v.tcx.sess.span_err(e.span,\n-                    \"paths in constants may only refer to \\\n-                     constants or functions\");\n+                span_err!(v.tcx.sess, e.span, E0014,\n+                    \"paths in constants may only refer to constants or functions\");\n               }\n               None => {\n                 v.tcx.sess.span_bug(e.span, \"unbound path in const?!\");\n@@ -143,19 +138,17 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr, is_const: bool) {\n                 Some(&DefStruct(..)) => {}    // OK.\n                 Some(&DefVariant(..)) => {}    // OK.\n                 _ => {\n-                    v.tcx.sess.span_err(e.span,\n-                        \"function calls in constants are limited to \\\n-                         struct and enum constructors\");\n+                    span_err!(v.tcx.sess, e.span, E0015,\n+                      \"function calls in constants are limited to struct and enum constructors\");\n                 }\n             }\n           }\n           ExprBlock(ref block) => {\n             // Check all statements in the block\n             for stmt in block.stmts.iter() {\n                 let block_span_err = |span|\n-                    v.tcx.sess.span_err(span,\n-                        \"blocks in constants are limited to \\\n-                        items and tail expressions\");\n+                    span_err!(v.tcx.sess, span, E0016,\n+                        \"blocks in constants are limited to items and tail expressions\");\n                 match stmt.node {\n                     StmtDecl(ref span, _) => {\n                         match span.node {\n@@ -187,18 +180,18 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr, is_const: bool) {\n           ExprRepeat(..) |\n           ExprStruct(..) => { }\n           ExprAddrOf(..) => {\n-                v.tcx.sess.span_err(e.span,\n-                    \"references in constants may only refer to \\\n-                     immutable values\");\n+              span_err!(v.tcx.sess, e.span, E0017,\n+                  \"references in constants may only refer to immutable values\");\n           },\n           ExprVstore(_, ExprVstoreUniq) => {\n-              v.tcx.sess.span_err(e.span, \"cannot allocate vectors in constant expressions\")\n+              span_err!(v.tcx.sess, e.span, E0018,\n+                  \"cannot allocate vectors in constant expressions\");\n           },\n \n           _ => {\n-            v.tcx.sess.span_err(e.span,\n-                                \"constant contains unimplemented expression type\");\n-            return;\n+              span_err!(v.tcx.sess, e.span, E0019,\n+                  \"constant contains unimplemented expression type\");\n+              return;\n           }\n         }\n     }"}, {"sha": "832b222ef1641200c1e38618a25bf1156ddb415c", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 24, "deletions": 31, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d", "patch": "@@ -142,15 +142,16 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n             // Finally, check if the whole match expression is exhaustive.\n             // Check for empty enum, because is_useful only works on inhabited types.\n             let pat_ty = node_id_to_type(cx.tcx, scrut.id);\n-            if (*arms).is_empty() {\n-               if !type_is_empty(cx.tcx, pat_ty) {\n-                   // We know the type is inhabited, so this must be wrong\n-                   cx.tcx.sess.span_err(ex.span, format!(\"non-exhaustive patterns: \\\n-                                type {} is non-empty\",\n-                                ty_to_string(cx.tcx, pat_ty)).as_slice());\n-               }\n-               // If the type *is* empty, it's vacuously exhaustive\n-               return;\n+            if arms.is_empty() {\n+                if !type_is_empty(cx.tcx, pat_ty) {\n+                    // We know the type is inhabited, so this must be wrong\n+                    span_err!(cx.tcx.sess, ex.span, E0002,\n+                        \"non-exhaustive patterns: type {} is non-empty\",\n+                        ty_to_string(cx.tcx, pat_ty)\n+                    );\n+                }\n+                // If the type *is* empty, it's vacuously exhaustive\n+                return;\n             }\n             let m: Matrix = Matrix(arms\n                 .iter()\n@@ -186,8 +187,9 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n \n             walk_pat(&**pat, |p| {\n                 if pat_matches_nan(p) {\n-                    cx.tcx.sess.span_warn(p.span, \"unmatchable NaN in pattern, \\\n-                                                   use the is_nan method in a guard instead\");\n+                    span_warn!(cx.tcx.sess, p.span, E0003,\n+                        \"unmatchable NaN in pattern, use the is_nan method in a guard instead\"\n+                    );\n                 }\n                 true\n             });\n@@ -222,9 +224,10 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, m: &Matrix) {\n                 [] => wild(),\n                 _ => unreachable!()\n             };\n-            let msg = format!(\"non-exhaustive patterns: `{0}` not covered\",\n-                              pat_to_string(&*witness));\n-            cx.tcx.sess.span_err(sp, msg.as_slice());\n+            span_err!(cx.tcx.sess, sp, E0004,\n+                \"non-exhaustive patterns: `{}` not covered\",\n+                pat_to_string(&*witness)\n+            );\n         }\n         NotUseful => {\n             // This is good, wildcard pattern isn't reachable\n@@ -779,11 +782,10 @@ fn check_local(cx: &mut MatchCheckCtxt, loc: &Local) {\n \n     match is_refutable(cx, loc.pat) {\n         Some(pat) => {\n-            let msg = format!(\n+            span_err!(cx.tcx.sess, loc.pat.span, E0005,\n                 \"refutable pattern in {} binding: `{}` not covered\",\n                 name, pat_to_string(&*pat)\n             );\n-            cx.tcx.sess.span_err(loc.pat.span, msg.as_slice());\n         },\n         None => ()\n     }\n@@ -801,11 +803,10 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n     for input in decl.inputs.iter() {\n         match is_refutable(cx, input.pat) {\n             Some(pat) => {\n-                let msg = format!(\n+                span_err!(cx.tcx.sess, input.pat.span, E0006,\n                     \"refutable pattern in function argument: `{}` not covered\",\n                     pat_to_string(&*pat)\n                 );\n-                cx.tcx.sess.span_err(input.pat.span, msg.as_slice());\n             },\n             None => ()\n         }\n@@ -850,21 +851,13 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n \n         // x @ Foo(..) is legal, but x @ Foo(y) isn't.\n         if sub.map_or(false, |p| pat_contains_bindings(def_map, &*p)) {\n-            tcx.sess.span_err(\n-                p.span,\n-                \"cannot bind by-move with sub-bindings\");\n+            span_err!(cx.tcx.sess, p.span, E0007, \"cannot bind by-move with sub-bindings\");\n         } else if has_guard {\n-            tcx.sess.span_err(\n-                p.span,\n-                \"cannot bind by-move into a pattern guard\");\n+            span_err!(cx.tcx.sess, p.span, E0008, \"cannot bind by-move into a pattern guard\");\n         } else if by_ref_span.is_some() {\n-            tcx.sess.span_err(\n-                p.span,\n-                \"cannot bind by-move and by-ref \\\n-                 in the same pattern\");\n-            tcx.sess.span_note(\n-                by_ref_span.unwrap(),\n-                \"by-ref binding occurs here\");\n+            span_err!(cx.tcx.sess, p.span, E0009,\n+                \"cannot bind by-move and by-ref in the same pattern\");\n+            span_note!(cx.tcx.sess, by_ref_span.unwrap(), \"by-ref binding occurs here\");\n         }\n     };\n "}, {"sha": "8985e633ad464b6f057db2f06c1e46dee83ccea2", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d", "patch": "@@ -112,18 +112,18 @@ impl<'a> Visitor<bool> for CheckStaticVisitor<'a> {\n                 visit::walk_expr(self, e, is_const);\n             }\n             ast::ExprVstore(_, ast::ExprVstoreMutSlice) => {\n-                self.tcx.sess.span_err(e.span,\n-                                       \"static items are not allowed to have mutable slices\");\n+                span_err!(self.tcx.sess, e.span, E0020,\n+                    \"static items are not allowed to have mutable slices\");\n            },\n             ast::ExprUnary(ast::UnBox, _) => {\n-                self.tcx.sess.span_err(e.span,\n-                                   \"static items are not allowed to have managed pointers\");\n+                span_err!(self.tcx.sess, e.span, E0021,\n+                    \"static items are not allowed to have managed pointers\");\n             }\n             ast::ExprBox(..) |\n             ast::ExprUnary(ast::UnUniq, _) |\n             ast::ExprVstore(_, ast::ExprVstoreUniq) => {\n-                self.tcx.sess.span_err(e.span,\n-                                   \"static items are not allowed to have custom pointers\");\n+                span_err!(self.tcx.sess, e.span, E0022,\n+                    \"static items are not allowed to have custom pointers\");\n             }\n             _ => {\n                 let node_ty = ty::node_id_to_type(self.tcx, e.id);"}, {"sha": "170f850328eb0af81c9f99ace31072750d47c500", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 31, "deletions": 45, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d", "patch": "@@ -253,14 +253,10 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n     if arg_len > 0 {\n         // N-ary variant.\n         if arg_len != subpats_len {\n-            let s = format!(\"this pattern has {} field{}, \\\n-                             but the corresponding {} has {} field{}\",\n-                         subpats_len,\n-                         if subpats_len == 1 {\"\"} else {\"s\"},\n-                         kind_name,\n-                         arg_len,\n-                         if arg_len == 1 {\"\"} else {\"s\"});\n-            tcx.sess.span_err(pat.span, s.as_slice());\n+            span_err!(tcx.sess, pat.span, E0023,\n+                      \"this pattern has {} field{}, but the corresponding {} has {} field{}\",\n+                      subpats_len, if subpats_len == 1 {\"\"} else {\"s\"},\n+                      kind_name, arg_len, if arg_len == 1 {\"\"} else {\"s\"});\n             error_happened = true;\n         }\n \n@@ -272,12 +268,10 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n             }\n         }\n     } else if subpats_len > 0 {\n-        tcx.sess.span_err(pat.span,\n-                          format!(\"this pattern has {} field{}, \\\n-                                   but the corresponding {} has no fields\",\n-                               subpats_len,\n-                               if subpats_len == 1 {\"\"} else {\"s\"},\n-                               kind_name).as_slice());\n+        span_err!(tcx.sess, pat.span, E0024,\n+                  \"this pattern has {} field{}, but the corresponding {} has no fields\",\n+                  subpats_len, if subpats_len == 1 {\"\"} else {\"s\"},\n+                  kind_name);\n         error_happened = true;\n     }\n \n@@ -321,9 +315,9 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n                 // Check the pattern anyway, so that attempts to look\n                 // up its type won't fail\n                 check_pat(pcx, &*field.pat, ty::mk_err());\n-                tcx.sess.span_err(span,\n-                    format!(\"field `{}` bound twice in pattern\",\n-                            token::get_ident(field.ident)).as_slice());\n+                span_err!(tcx.sess, span, E0025,\n+                    \"field `{}` bound twice in pattern\",\n+                    token::get_ident(field.ident));\n             }\n             Some(&(index, ref mut used)) => {\n                 *used = true;\n@@ -339,10 +333,10 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n                 // Check the pattern anyway, so that attempts to look\n                 // up its type won't fail\n                 check_pat(pcx, &*field.pat, ty::mk_err());\n-                tcx.sess.span_err(span,\n-                    format!(\"struct `{}` does not have a field named `{}`\",\n-                            ty::item_path_str(tcx, class_id),\n-                            token::get_ident(field.ident)).as_slice());\n+                span_err!(tcx.sess, span, E0026,\n+                    \"struct `{}` does not have a field named `{}`\",\n+                    ty::item_path_str(tcx, class_id),\n+                    token::get_ident(field.ident));\n             }\n         }\n     }\n@@ -353,11 +347,9 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n             if found_fields.contains(&i) {\n                 continue;\n             }\n-\n-            tcx.sess\n-               .span_err(span,\n-                         format!(\"pattern does not mention field `{}`\",\n-                                 token::get_name(field.name)).as_slice());\n+            span_err!(tcx.sess, span, E0027,\n+                \"pattern does not mention field `{}`\",\n+                token::get_name(field.name));\n         }\n     }\n }\n@@ -400,11 +392,9 @@ pub fn check_struct_like_enum_variant_pat(pcx: &pat_ctxt,\n         }\n         Some(&def::DefStruct(..)) | Some(&def::DefVariant(..)) => {\n             let name = pprust::path_to_string(path);\n-            tcx.sess.span_err(span,\n-                              format!(\"mismatched types: expected `{}` but \\\n-                                       found `{}`\",\n-                                      fcx.infcx().ty_to_string(expected),\n-                                      name).as_slice());\n+            span_err!(tcx.sess, span, E0028,\n+                \"mismatched types: expected `{}` but found `{}`\",\n+                fcx.infcx().ty_to_string(expected), name);\n         }\n         _ => {\n             tcx.sess.span_bug(span, \"resolve didn't write in variant\");\n@@ -441,16 +431,16 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         {\n             // no-op\n         } else if !ty::type_is_numeric(b_ty) && !ty::type_is_char(b_ty) {\n-            tcx.sess.span_err(pat.span,\n+            span_err!(tcx.sess, begin.span, E0029,\n                 \"only char and numeric types are allowed in range\");\n         } else {\n             match valid_range_bounds(fcx.ccx, &**begin, &**end) {\n                 Some(false) => {\n-                    tcx.sess.span_err(begin.span,\n+                    span_err!(tcx.sess, begin.span, E0030,\n                         \"lower range bound must be less than upper\");\n                 },\n                 None => {\n-                    tcx.sess.span_err(begin.span,\n+                    span_err!(tcx.sess, begin.span, E0031,\n                         \"mismatched types in range\");\n                 },\n                 _ => { },\n@@ -521,13 +511,10 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                     ty::ty_to_def_id(\n                         ty::lookup_item_type(tcx, item_did).ty).unwrap();\n                 if struct_did != cid {\n-                    tcx.sess\n-                       .span_err(path.span,\n-                                 format!(\"`{}` does not name the \\\n-                                          structure `{}`\",\n-                                         pprust::path_to_string(path),\n-                                         fcx.infcx()\n-                                            .ty_to_string(expected)).as_slice())\n+                    span_err!(tcx.sess, pat.span, E0032,\n+                        \"`{}` does not name the structure `{}`\",\n+                        pprust::path_to_string(path),\n+                        fcx.infcx().ty_to_string(expected));\n                 }\n \n                 check_struct_pat(pcx, pat.id, pat.span, expected, path,\n@@ -744,10 +731,9 @@ fn check_pointer_pat(pcx: &pat_ctxt,\n                 // This is \"x = SomeTrait\" being reduced from\n                 // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n                 check_pat(pcx, inner, ty::mk_err());\n-                tcx.sess.span_err(\n-                    span,\n-                    format!(\"type `{}` cannot be dereferenced\",\n-                            fcx.infcx().ty_to_string(expected)).as_slice());\n+                span_err!(tcx.sess, span, E0033,\n+                    \"type `{}` cannot be dereferenced\",\n+                    fcx.infcx().ty_to_string(expected));\n                 fcx.write_error(pat_id);\n             }\n             _ => {"}, {"sha": "4787837093844233fd86e2b65361cd293be94862", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 20, "deletions": 33, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d", "patch": "@@ -1041,8 +1041,7 @@ impl<'a> LookupContext<'a> {\n         }\n \n         if relevant_candidates.len() > 1 {\n-            self.tcx().sess.span_err(\n-                self.span,\n+            span_err!(self.tcx().sess, self.span, E0034,\n                 \"multiple applicable methods in scope\");\n             for (idx, candidate) in relevant_candidates.iter().enumerate() {\n                 self.report_candidate(idx, &candidate.origin);\n@@ -1112,13 +1111,11 @@ impl<'a> LookupContext<'a> {\n             if num_supplied_tps == 0u {\n                 self.fcx.infcx().next_ty_vars(num_method_tps)\n             } else if num_method_tps == 0u {\n-                tcx.sess.span_err(\n-                    self.span,\n-                    \"this method does not take type parameters\");\n+                span_err!(tcx.sess, self.span, E0035,\n+                    \"does not take type parameters\");\n                 self.fcx.infcx().next_ty_vars(num_method_tps)\n             } else if num_supplied_tps != num_method_tps {\n-                tcx.sess.span_err(\n-                    self.span,\n+                span_err!(tcx.sess, self.span, E0036,\n                     \"incorrect number of type parameters given for this method\");\n                 self.fcx.infcx().next_ty_vars(num_method_tps)\n             } else {\n@@ -1221,10 +1218,8 @@ impl<'a> LookupContext<'a> {\n \n         match candidate.method_ty.explicit_self {\n             ast::SelfStatic => { // reason (a) above\n-                self.tcx().sess.span_err(\n-                    self.span,\n-                    \"cannot call a method without a receiver \\\n-                     through an object\");\n+                span_err!(self.tcx().sess, self.span, E0037,\n+                    \"cannot call a method without a receiver through an object\");\n             }\n \n             ast::SelfValue(_) | ast::SelfRegion(..) | ast::SelfUniq(_) => {}\n@@ -1233,8 +1228,7 @@ impl<'a> LookupContext<'a> {\n         // reason (a) above\n         let check_for_self_ty = |ty| {\n             if ty::type_has_self(ty) {\n-                self.tcx().sess.span_err(\n-                    self.span,\n+                span_err!(self.tcx().sess, self.span, E0038,\n                     \"cannot call a method whose type contains a \\\n                      self-type through an object\");\n                 true\n@@ -1256,8 +1250,7 @@ impl<'a> LookupContext<'a> {\n \n         if candidate.method_ty.generics.has_type_params(subst::FnSpace) {\n             // reason (b) above\n-            self.tcx().sess.span_err(\n-                self.span,\n+            span_err!(self.tcx().sess, self.span, E0039,\n                 \"cannot call a generic method through an object\");\n         }\n     }\n@@ -1279,8 +1272,8 @@ impl<'a> LookupContext<'a> {\n         }\n \n         if bad {\n-            self.tcx().sess.span_err(self.span,\n-                                     \"explicit call to destructor\");\n+            span_err!(self.tcx().sess, self.span, E0040,\n+                \"explicit call to destructor\");\n         }\n     }\n \n@@ -1425,28 +1418,22 @@ impl<'a> LookupContext<'a> {\n         } else {\n             self.span\n         };\n-        self.tcx().sess.span_note(\n-            span,\n-            format!(\"candidate #{} is `{}`\",\n-                    idx + 1u,\n-                    ty::item_path_str(self.tcx(), did)).as_slice());\n+        span_note!(self.tcx().sess, span,\n+            \"candidate #{} is `{}`\",\n+            idx + 1u, ty::item_path_str(self.tcx(), did));\n     }\n \n     fn report_param_candidate(&self, idx: uint, did: DefId) {\n-        self.tcx().sess.span_note(\n-            self.span,\n-            format!(\"candidate #{} derives from the bound `{}`\",\n-                    idx + 1u,\n-                    ty::item_path_str(self.tcx(), did)).as_slice());\n+        span_note!(self.tcx().sess, self.span,\n+            \"candidate #{} derives from the bound `{}`\",\n+            idx + 1u, ty::item_path_str(self.tcx(), did));\n     }\n \n     fn report_trait_candidate(&self, idx: uint, did: DefId) {\n-        self.tcx().sess.span_note(\n-            self.span,\n-            format!(\"candidate #{} derives from the type of the receiver, \\\n-                     which is the trait `{}`\",\n-                    idx + 1u,\n-                    ty::item_path_str(self.tcx(), did)).as_slice());\n+        span_note!(self.tcx().sess, self.span,\n+            \"candidate #{} derives from the type of the receiver, \\\n+            which is the trait `{}`\",\n+            idx + 1u, ty::item_path_str(self.tcx(), did));\n     }\n \n     fn infcx(&'a self) -> &'a infer::InferCtxt<'a> {"}, {"sha": "7a4451c38f484f9cab8cb805ce8dd82e6de3fdbf", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 181, "deletions": 245, "changes": 426, "blob_url": "https://github.com/rust-lang/rust/blob/a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d", "patch": "@@ -569,11 +569,10 @@ fn check_for_field_shadowing(tcx: &ty::ctxt,\n             for f in fields.iter() {\n                 match super_fields.iter().find(|sf| f.name == sf.name) {\n                     Some(prev_field) => {\n-                        tcx.sess.span_err(span_for_field(tcx, f, id),\n-                            format!(\"field `{}` hides field declared in \\\n-                                     super-struct\",\n-                                    token::get_name(f.name)).as_slice());\n-                        tcx.sess.span_note(span_for_field(tcx, prev_field, parent_id),\n+                        span_err!(tcx.sess, span_for_field(tcx, f, id), E0041,\n+                            \"field `{}` hides field declared in super-struct\",\n+                            token::get_name(f.name));\n+                        span_note!(tcx.sess, span_for_field(tcx, prev_field, parent_id),\n                             \"previously declared here\");\n                     },\n                     None => {}\n@@ -595,16 +594,16 @@ fn check_fields_sized(tcx: &ty::ctxt,\n         if !ty::type_is_sized(tcx, t) {\n             match f.node.kind {\n                 ast::NamedField(ident, _) => {\n-                    tcx.sess.span_err(\n-                        f.span,\n-                        format!(\"type `{}` is dynamically sized. \\\n-                                 dynamically sized types may only \\\n-                                 appear as the type of the final \\\n-                                 field in a struct\",\n-                                 token::get_ident(ident)).as_slice());\n+                    span_err!(tcx.sess, f.span, E0042,\n+                        \"type `{}` is dynamically sized. \\\n+                         dynamically sized types may only \\\n+                         appear as the type of the final \\\n+                         field in a struct\",\n+                        token::get_ident(ident));\n                 }\n                 ast::UnnamedField(_) => {\n-                    tcx.sess.span_err(f.span, \"dynamically sized type in field\");\n+                    span_err!(tcx.sess, f.span, E0043,\n+                        \"dynamically sized type in field\");\n                 }\n             }\n         }\n@@ -719,14 +718,15 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n             for item in m.items.iter() {\n                 let pty = ty::lookup_item_type(ccx.tcx, local_def(item.id));\n                 if !pty.generics.types.is_empty() {\n-                    ccx.tcx.sess.span_err(item.span, \"foreign items may not have type parameters\");\n+                    span_err!(ccx.tcx.sess, item.span, E0044,\n+                        \"foreign items may not have type parameters\");\n                 }\n \n                 match item.node {\n                     ast::ForeignItemFn(ref fn_decl, _) => {\n                         if fn_decl.variadic && m.abi != abi::C {\n-                            ccx.tcx.sess.span_err(\n-                                item.span, \"variadic function must have C calling convention\");\n+                            span_err!(ccx.tcx.sess, item.span, E0045,\n+                                \"variadic function must have C calling convention\");\n                         }\n                     }\n                     _ => {}\n@@ -826,10 +826,9 @@ fn check_impl_methods_against_trait(ccx: &CrateCtxt,\n     }\n \n     if !missing_methods.is_empty() {\n-        tcx.sess.span_err(\n-            impl_span,\n-            format!(\"not all trait methods implemented, missing: {}\",\n-                    missing_methods.connect(\", \")).as_slice());\n+        span_err!(tcx.sess, impl_span, E0046,\n+            \"not all trait methods implemented, missing: {}\",\n+            missing_methods.connect(\", \"));\n     }\n }\n \n@@ -865,23 +864,17 @@ fn compare_impl_method(tcx: &ty::ctxt,\n     match (&trait_m.explicit_self, &impl_m.explicit_self) {\n         (&ast::SelfStatic, &ast::SelfStatic) => {}\n         (&ast::SelfStatic, _) => {\n-            tcx.sess.span_err(\n-                impl_m_span,\n-                format!(\"method `{}` has a `{}` declaration in the impl, \\\n-                        but not in the trait\",\n-                        token::get_ident(trait_m.ident),\n-                        pprust::explicit_self_to_string(\n-                            impl_m.explicit_self)).as_slice());\n+            span_err!(tcx.sess, impl_m_span, E0047,\n+                \"method `{}` has a `{}` declaration in the impl, but not in the trait\",\n+                token::get_ident(trait_m.ident),\n+                pprust::explicit_self_to_string(impl_m.explicit_self));\n             return;\n         }\n         (_, &ast::SelfStatic) => {\n-            tcx.sess.span_err(\n-                impl_m_span,\n-                format!(\"method `{}` has a `{}` declaration in the trait, \\\n-                        but not in the impl\",\n-                        token::get_ident(trait_m.ident),\n-                        pprust::explicit_self_to_string(\n-                            trait_m.explicit_self)).as_slice());\n+            span_err!(tcx.sess, impl_m_span, E0048,\n+                \"method `{}` has a `{}` declaration in the trait, but not in the impl\",\n+                token::get_ident(trait_m.ident),\n+                pprust::explicit_self_to_string(trait_m.explicit_self));\n             return;\n         }\n         _ => {\n@@ -892,28 +885,26 @@ fn compare_impl_method(tcx: &ty::ctxt,\n     let num_impl_m_type_params = impl_m.generics.types.len(subst::FnSpace);\n     let num_trait_m_type_params = trait_m.generics.types.len(subst::FnSpace);\n     if num_impl_m_type_params != num_trait_m_type_params {\n-        tcx.sess.span_err(\n-            impl_m_span,\n-            format!(\"method `{}` has {} type parameter{} \\\n-                     but its trait declaration has {} type parameter{}\",\n-                    token::get_ident(trait_m.ident),\n-                    num_impl_m_type_params,\n-                    if num_impl_m_type_params == 1 {\"\"} else {\"s\"},\n-                    num_trait_m_type_params,\n-                    if num_trait_m_type_params == 1 {\"\"} else {\"s\"}).as_slice());\n+        span_err!(tcx.sess, impl_m_span, E0049,\n+            \"method `{}` has {} type parameter{} \\\n+             but its trait declaration has {} type parameter{}\",\n+            token::get_ident(trait_m.ident),\n+            num_impl_m_type_params,\n+            if num_impl_m_type_params == 1 {\"\"} else {\"s\"},\n+            num_trait_m_type_params,\n+            if num_trait_m_type_params == 1 {\"\"} else {\"s\"});\n         return;\n     }\n \n     if impl_m.fty.sig.inputs.len() != trait_m.fty.sig.inputs.len() {\n-        tcx.sess.span_err(\n-            impl_m_span,\n-            format!(\"method `{}` has {} parameter{} \\\n-                     but the declaration in trait `{}` has {}\",\n-                 token::get_ident(trait_m.ident),\n-                 impl_m.fty.sig.inputs.len(),\n-                 if impl_m.fty.sig.inputs.len() == 1 {\"\"} else {\"s\"},\n-                 ty::item_path_str(tcx, trait_m.def_id),\n-                 trait_m.fty.sig.inputs.len()).as_slice());\n+        span_err!(tcx.sess, impl_m_span, E0050,\n+            \"method `{}` has {} parameter{} \\\n+             but the declaration in trait `{}` has {}\",\n+            token::get_ident(trait_m.ident),\n+            impl_m.fty.sig.inputs.len(),\n+            if impl_m.fty.sig.inputs.len() == 1 {\"\"} else {\"s\"},\n+            ty::item_path_str(tcx, trait_m.def_id),\n+            trait_m.fty.sig.inputs.len());\n         return;\n     }\n \n@@ -1002,16 +993,13 @@ fn compare_impl_method(tcx: &ty::ctxt,\n             impl_param_def.bounds.builtin_bounds -\n             trait_param_def.bounds.builtin_bounds;\n         if !extra_bounds.is_empty() {\n-           tcx.sess.span_err(\n-               impl_m_span,\n-               format!(\"in method `{}`, \\\n-                       type parameter {} requires `{}`, \\\n-                       which is not required by \\\n-                       the corresponding type parameter \\\n-                       in the trait declaration\",\n-                       token::get_ident(trait_m.ident),\n-                       i,\n-                       extra_bounds.user_string(tcx)).as_slice());\n+            span_err!(tcx.sess, impl_m_span, E0051,\n+                \"in method `{}`, type parameter {} requires `{}`, \\\n+                 which is not required by the corresponding type parameter \\\n+                 in the trait declaration\",\n+                token::get_ident(trait_m.ident),\n+                i,\n+                extra_bounds.user_string(tcx));\n            return;\n         }\n \n@@ -1043,17 +1031,12 @@ fn compare_impl_method(tcx: &ty::ctxt,\n             }\n \n             if !ok {\n-                tcx.sess.span_err(impl_m_span,\n-                                  format!(\"in method `{}`, type parameter {} \\\n-                                           requires bound `{}`, which is not \\\n-                                           required by the corresponding \\\n-                                           type parameter in the trait \\\n-                                           declaration\",\n-                                          token::get_ident(trait_m.ident),\n-                                          i,\n-                                          ppaux::trait_ref_to_string(\n-                                              tcx,\n-                                              &*impl_trait_bound)).as_slice())\n+                span_err!(tcx.sess, impl_m_span, E0052,\n+                    \"in method `{}`, type parameter {} requires bound `{}`, which is not \\\n+                     required by the corresponding type parameter in the trait declaration\",\n+                    token::get_ident(trait_m.ident),\n+                    i,\n+                    ppaux::trait_ref_to_string(tcx, &*impl_trait_bound));\n             }\n         }\n     }\n@@ -1071,11 +1054,10 @@ fn compare_impl_method(tcx: &ty::ctxt,\n                           impl_fty, trait_fty) {\n         Ok(()) => {}\n         Err(ref terr) => {\n-            tcx.sess.span_err(\n-                impl_m_span,\n-                format!(\"method `{}` has an incompatible type for trait: {}\",\n-                        token::get_ident(trait_m.ident),\n-                        ty::type_err_to_str(tcx, terr)).as_slice());\n+            span_err!(tcx.sess, impl_m_span, E0053,\n+                \"method `{}` has an incompatible type for trait: {}\",\n+                token::get_ident(trait_m.ident),\n+                ty::type_err_to_str(tcx, terr));\n             ty::note_and_explain_type_err(tcx, terr);\n         }\n     }\n@@ -1162,10 +1144,8 @@ fn check_cast(fcx: &FnCtxt,\n             }, t_e, None);\n         }\n     } else if ty::get(t_1).sty == ty::ty_bool {\n-        fcx.tcx()\n-           .sess\n-           .span_err(span,\n-                     \"cannot cast as `bool`, compare with zero instead\");\n+        span_err!(fcx.tcx().sess, span, E0054,\n+            \"cannot cast as `bool`, compare with zero instead\");\n     } else if ty::type_is_region_ptr(t_e) && ty::type_is_unsafe_ptr(t_1) {\n         fn types_compatible(fcx: &FnCtxt, sp: Span,\n                             t1: ty::t, t2: ty::t) -> bool {\n@@ -1533,9 +1513,9 @@ pub fn autoderef<T>(fcx: &FnCtxt, sp: Span, base_ty: ty::t,\n     }\n \n     // We've reached the recursion limit, error gracefully.\n-    fcx.tcx().sess.span_err(sp,\n-        format!(\"reached the recursion limit while auto-dereferencing {}\",\n-                base_ty.repr(fcx.tcx())).as_slice());\n+    span_err!(fcx.tcx().sess, sp, E0055,\n+        \"reached the recursion limit while auto-dereferencing {}\",\n+        base_ty.repr(fcx.tcx()));\n     (ty::mk_err(), 0, None)\n }\n \n@@ -1581,11 +1561,11 @@ fn try_overloaded_call(fcx: &FnCtxt,\n         write_call(fcx, call_expression, output_type);\n \n         if !fcx.tcx().sess.features.overloaded_calls.get() {\n-            fcx.tcx().sess.span_err(call_expression.span,\n-                                    \"overloaded calls are experimental\");\n-            fcx.tcx().sess.span_note(call_expression.span,\n-                                     \"add `#[feature(overloaded_calls)]` to \\\n-                                      the crate attributes to enable\");\n+            span_err!(fcx.tcx().sess, call_expression.span, E0056,\n+                \"overloaded calls are experimental\");\n+            span_note!(fcx.tcx().sess, call_expression.span,\n+                \"add `#[feature(overloaded_calls)]` to \\\n+                the crate attributes to enable\");\n         }\n \n         return true\n@@ -1783,36 +1763,30 @@ fn check_argument_types(fcx: &FnCtxt,\n         match ty::get(tuple_type).sty {\n             ty::ty_tup(ref arg_types) => {\n                 if arg_types.len() != args.len() {\n-                    let msg = format!(\n-                        \"this function takes {} parameter{} \\\n-                         but {} parameter{} supplied\",\n-                         arg_types.len(),\n-                         if arg_types.len() == 1 {\"\"} else {\"s\"},\n-                         args.len(),\n-                         if args.len() == 1 {\" was\"} else {\"s were\"});\n-                    tcx.sess.span_err(sp, msg.as_slice());\n+                    span_err!(tcx.sess, sp, E0057,\n+                        \"this function takes {} parameter{} but {} parameter{} supplied\",\n+                        arg_types.len(),\n+                        if arg_types.len() == 1 {\"\"} else {\"s\"},\n+                        args.len(),\n+                        if args.len() == 1 {\" was\"} else {\"s were\"});\n                     err_args(args.len())\n                 } else {\n                     (*arg_types).clone()\n                 }\n             }\n             ty::ty_nil => {\n                 if args.len() != 0 {\n-                    let msg = format!(\n-                        \"this function takes 0 parameters \\\n-                         but {} parameter{} supplied\",\n-                         args.len(),\n-                         if args.len() == 1 {\" was\"} else {\"s were\"});\n-                    tcx.sess.span_err(sp, msg.as_slice());\n+                    span_err!(tcx.sess, sp, E0058,\n+                        \"this function takes 0 parameters but {} parameter{} supplied\",\n+                        args.len(),\n+                        if args.len() == 1 {\" was\"} else {\"s were\"});\n                 }\n                 Vec::new()\n             }\n             _ => {\n-                tcx.sess\n-                   .span_err(sp,\n-                             \"cannot use call notation; the first type \\\n-                              parameter for the function trait is neither a \\\n-                              tuple nor unit\");\n+                span_err!(tcx.sess, sp, E0059,\n+                    \"cannot use call notation; the first type parameter \\\n+                     for the function trait is neither a tuple nor unit\");\n                 err_args(supplied_arg_count)\n             }\n         }\n@@ -1822,29 +1796,22 @@ fn check_argument_types(fcx: &FnCtxt,\n         if supplied_arg_count >= expected_arg_count {\n             fn_inputs.iter().map(|a| *a).collect()\n         } else {\n-            let msg = format!(\n+            span_err!(tcx.sess, sp, E0060,\n                 \"this function takes at least {} parameter{} \\\n                  but {} parameter{} supplied\",\n-                 expected_arg_count,\n-                 if expected_arg_count == 1 {\"\"} else {\"s\"},\n-                 supplied_arg_count,\n-                 if supplied_arg_count == 1 {\" was\"} else {\"s were\"});\n-\n-            tcx.sess.span_err(sp, msg.as_slice());\n-\n+                expected_arg_count,\n+                if expected_arg_count == 1 {\"\"} else {\"s\"},\n+                supplied_arg_count,\n+                if supplied_arg_count == 1 {\" was\"} else {\"s were\"});\n             err_args(supplied_arg_count)\n         }\n     } else {\n-        let msg = format!(\n-            \"this function takes {} parameter{} \\\n-             but {} parameter{} supplied\",\n-             expected_arg_count,\n-             if expected_arg_count == 1 {\"\"} else {\"s\"},\n-             supplied_arg_count,\n-             if supplied_arg_count == 1 {\" was\"} else {\"s were\"});\n-\n-        tcx.sess.span_err(sp, msg.as_slice());\n-\n+        span_err!(tcx.sess, sp, E0061,\n+            \"this function takes {} parameter{} but {} parameter{} supplied\",\n+            expected_arg_count,\n+            if expected_arg_count == 1 {\"\"} else {\"s\"},\n+            supplied_arg_count,\n+            if supplied_arg_count == 1 {\" was\"} else {\"s were\"});\n         err_args(supplied_arg_count)\n     };\n \n@@ -2730,11 +2697,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                     error_happened = true;\n                 }\n                 Some((_, true)) => {\n-                    tcx.sess.span_err(\n-                        field.ident.span,\n-                        format!(\"field `{}` specified more than once\",\n-                                token::get_ident(field.ident\n-                                                      .node)).as_slice());\n+                    span_err!(fcx.tcx().sess, field.ident.span, E0062,\n+                        \"field `{}` specified more than once\",\n+                        token::get_ident(field.ident.node));\n                     error_happened = true;\n                 }\n                 Some((field_id, false)) => {\n@@ -2772,11 +2737,10 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                     }\n                 }\n \n-                tcx.sess.span_err(span,\n-                    format!(\n-                        \"missing field{}: {fields}\",\n-                        if missing_fields.len() == 1 {\"\"} else {\"s\"},\n-                        fields = missing_fields.connect(\", \")).as_slice());\n+                span_err!(tcx.sess, span, E0063,\n+                    \"missing field{}: {}\",\n+                    if missing_fields.len() == 1 {\"\"} else {\"s\"},\n+                    missing_fields.connect(\", \"));\n              }\n         }\n \n@@ -2938,12 +2902,14 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                     }\n                 }\n                 ast::ExprLit(_) => {\n-                    let error = if vst == ast::ExprVstoreSlice {\n-                        \"`&\\\"string\\\"` has been removed; use `\\\"string\\\"` instead\"\n+                    if vst == ast::ExprVstoreSlice {\n+                        span_err!(tcx.sess, expr.span, E0064,\n+                            \"`&\\\"string\\\"` has been removed; use `\\\"string\\\"` instead\");\n                     } else {\n-                        \"`box \\\"string\\\"` has been removed; use `\\\"string\\\".to_string()` instead\"\n-                    };\n-                    tcx.sess.span_err(expr.span, error);\n+                        span_err!(tcx.sess, expr.span, E0065,\n+                            \"`box \\\"string\\\"` has been removed; use \\\n+                             `\\\"string\\\".to_string()` instead\");\n+                    }\n                     ty::mk_err()\n                 }\n                 _ => tcx.sess.span_bug(expr.span, \"vstore modifier on non-sequence\"),\n@@ -2977,9 +2943,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n           }\n \n           if !checked {\n-              tcx.sess.span_err(expr.span,\n-                                \"only the managed heap and exchange heap are \\\n-                                 currently supported\");\n+              span_err!(tcx.sess, expr.span, E0066,\n+                  \"only the managed heap and exchange heap are currently supported\");\n               fcx.write_ty(id, ty::mk_err());\n           }\n       }\n@@ -3011,7 +2976,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n         let tcx = fcx.tcx();\n         if !ty::expr_is_lval(tcx, &**lhs) {\n-            tcx.sess.span_err(lhs.span, \"illegal left-hand side expression\");\n+            span_err!(tcx.sess, lhs.span, E0067, \"illegal left-hand side expression\");\n         }\n \n         // Overwrite result of check_binop...this preserves existing behavior\n@@ -3077,7 +3042,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                 };\n                                 if is_newtype {\n                                     // This is an obsolete struct deref\n-                                    tcx.sess.span_err(expr.span,\n+                                    span_err!(tcx.sess, expr.span, E0068,\n                                         \"single-field tuple-structs can \\\n                                          no longer be dereferenced\");\n                                 } else {\n@@ -3181,8 +3146,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                     ret_ty, ty::mk_nil()) {\n             Ok(_) => { /* fall through */ }\n             Err(_) => {\n-                tcx.sess.span_err(\n-                    expr.span,\n+                span_err!(tcx.sess, expr.span, E0069,\n                     \"`return;` in function returning non-nil\");\n             }\n           },\n@@ -3201,7 +3165,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n         let tcx = fcx.tcx();\n         if !ty::expr_is_lval(tcx, &**lhs) {\n-            tcx.sess.span_err(lhs.span, \"illegal left-hand side expression\");\n+            span_err!(tcx.sess, expr.span, E0070,\n+                \"illegal left-hand side expression\");\n         }\n \n         let lhs_ty = fcx.expr_ty(&**lhs);\n@@ -3390,11 +3355,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                                  base_expr);\n                     }\n                     _ => {\n-                        tcx.sess\n-                           .span_err(path.span,\n-                                     format!(\"`{}` does not name a structure\",\n-                                             pprust::path_to_string(\n-                                                 path)).as_slice())\n+                        span_err!(tcx.sess, path.span, E0071,\n+                            \"`{}` does not name a structure\",\n+                            pprust::path_to_string(path));\n                     }\n                 }\n             }\n@@ -3766,10 +3729,10 @@ pub fn check_representable(tcx: &ty::ctxt,\n     // caught by case 1.\n     match ty::is_type_representable(tcx, sp, rty) {\n       ty::SelfRecursive => {\n-        tcx.sess.span_err(\n-          sp, format!(\"illegal recursive {} type; \\\n-                       wrap the inner value in a box to make it representable\",\n-                      designation).as_slice());\n+        span_err!(tcx.sess, sp, E0072,\n+            \"illegal recursive {} type; \\\n+             wrap the inner value in a box to make it representable\",\n+            designation);\n         return false\n       }\n       ty::Representable | ty::ContainsRecursive => (),\n@@ -3794,12 +3757,10 @@ pub fn check_instantiable(tcx: &ty::ctxt,\n                           -> bool {\n     let item_ty = ty::node_id_to_type(tcx, item_id);\n     if !ty::is_instantiable(tcx, item_ty) {\n-        tcx.sess\n-           .span_err(sp,\n-                     format!(\"this type cannot be instantiated without an \\\n-                              instance of itself; consider using \\\n-                              `Option<{}>`\",\n-                             ppaux::ty_to_string(tcx, item_ty)).as_slice());\n+        span_err!(tcx.sess, sp, E0073,\n+            \"this type cannot be instantiated without an \\\n+             instance of itself; consider using `Option<{}>`\",\n+            ppaux::ty_to_string(tcx, item_ty));\n         false\n     } else {\n         true\n@@ -3809,25 +3770,25 @@ pub fn check_instantiable(tcx: &ty::ctxt,\n pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n     let t = ty::node_id_to_type(tcx, id);\n     if ty::type_needs_subst(t) {\n-        tcx.sess.span_err(sp, \"SIMD vector cannot be generic\");\n+        span_err!(tcx.sess, sp, E0074, \"SIMD vector cannot be generic\");\n         return;\n     }\n     match ty::get(t).sty {\n         ty::ty_struct(did, ref substs) => {\n             let fields = ty::lookup_struct_fields(tcx, did);\n             if fields.is_empty() {\n-                tcx.sess.span_err(sp, \"SIMD vector cannot be empty\");\n+                span_err!(tcx.sess, sp, E0075, \"SIMD vector cannot be empty\");\n                 return;\n             }\n             let e = ty::lookup_field_type(tcx, did, fields.get(0).id, substs);\n             if !fields.iter().all(\n                          |f| ty::lookup_field_type(tcx, did, f.id, substs) == e) {\n-                tcx.sess.span_err(sp, \"SIMD vector should be homogeneous\");\n+                span_err!(tcx.sess, sp, E0076, \"SIMD vector should be homogeneous\");\n                 return;\n             }\n             if !ty::type_is_machine(e) {\n-                tcx.sess.span_err(sp, \"SIMD vector element type should be \\\n-                                       machine type\");\n+                span_err!(tcx.sess, sp, E0077,\n+                    \"SIMD vector element type should be machine type\");\n                 return;\n             }\n         }\n@@ -3852,16 +3813,10 @@ pub fn check_enum_variants_sized(ccx: &CrateCtxt,\n                     // A struct value with an unsized final field is itself\n                     // unsized and we must track this in the type system.\n                     if !ty::type_is_sized(ccx.tcx, *t) {\n-                        ccx.tcx\n-                           .sess\n-                           .span_err(\n-                               args.get(i).ty.span,\n-                               format!(\"type `{}` is dynamically sized. \\\n-                                        dynamically sized types may only \\\n-                                        appear as the final type in a \\\n-                                        variant\",\n-                                       ppaux::ty_to_string(ccx.tcx,\n-                                                        *t)).as_slice());\n+                        span_err!(ccx.tcx.sess, args.get(i).ty.span, E0078,\n+                            \"type `{}` is dynamically sized. dynamically sized types may only \\\n+                             appear as the final type in a variant\",\n+                             ppaux::ty_to_string(ccx.tcx, *t));\n                     }\n                 }\n             },\n@@ -3947,14 +3902,12 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n                         Ok(const_eval::const_int(val)) => current_disr_val = val as Disr,\n                         Ok(const_eval::const_uint(val)) => current_disr_val = val as Disr,\n                         Ok(_) => {\n-                            ccx.tcx.sess.span_err(e.span, \"expected signed integer constant\");\n+                            span_err!(ccx.tcx.sess, e.span, E0079,\n+                                \"expected signed integer constant\");\n                         }\n                         Err(ref err) => {\n-                            ccx.tcx\n-                               .sess\n-                               .span_err(e.span,\n-                                         format!(\"expected constant: {}\",\n-                                                 *err).as_slice());\n+                            span_err!(ccx.tcx.sess, e.span, E0080,\n+                                \"expected constant: {}\", *err);\n                         }\n                     }\n                 },\n@@ -3963,16 +3916,18 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n \n             // Check for duplicate discriminant values\n             if disr_vals.contains(&current_disr_val) {\n-                ccx.tcx.sess.span_err(v.span, \"discriminant value already exists\");\n+                span_err!(ccx.tcx.sess, v.span, E0081,\n+                    \"discriminant value already exists\");\n             }\n             // Check for unrepresentable discriminant values\n             match hint {\n                 attr::ReprAny | attr::ReprExtern => (),\n                 attr::ReprInt(sp, ity) => {\n                     if !disr_in_range(ccx, ity, current_disr_val) {\n-                        ccx.tcx.sess.span_err(v.span,\n-                                              \"discriminant value outside specified type\");\n-                        ccx.tcx.sess.span_note(sp, \"discriminant type specified here\");\n+                        span_err!(ccx.tcx.sess, v.span, E0082,\n+                            \"discriminant value outside specified type\");\n+                        span_note!(ccx.tcx.sess, sp,\n+                            \"discriminant type specified here\");\n                     }\n                 }\n             }\n@@ -3990,12 +3945,13 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n \n     let hint = ty::lookup_repr_hint(ccx.tcx, ast::DefId { krate: ast::LOCAL_CRATE, node: id });\n     if hint != attr::ReprAny && vs.len() <= 1 {\n-        let msg = if vs.len() == 1 {\n-            \"unsupported representation for univariant enum\"\n+        if vs.len() == 1 {\n+            span_err!(ccx.tcx.sess, sp, E0083,\n+                \"unsupported representation for univariant enum\");\n         } else {\n-            \"unsupported representation for zero-variant enum\"\n+            span_err!(ccx.tcx.sess, sp, E0084,\n+                \"unsupported representation for zero-variant enum\");\n         };\n-        ccx.tcx.sess.span_err(sp, msg)\n     }\n \n     let variants = do_check(ccx, vs, id, hint);\n@@ -4241,15 +4197,13 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         segment: &ast::PathSegment)\n     {\n         for typ in segment.types.iter() {\n-            fcx.tcx().sess.span_err(\n-                typ.span,\n+            span_err!(fcx.tcx().sess, typ.span, E0085,\n                 \"type parameters may not appear here\");\n             break;\n         }\n \n         for lifetime in segment.lifetimes.iter() {\n-            fcx.tcx().sess.span_err(\n-                lifetime.span,\n+            span_err!(fcx.tcx().sess, lifetime.span, E0086,\n                 \"lifetime parameters may not appear here\");\n             break;\n         }\n@@ -4288,14 +4242,11 @@ pub fn instantiate_path(fcx: &FnCtxt,\n                 if i < type_count {\n                     substs.types.push(space, t);\n                 } else if i == type_count {\n-                    fcx.tcx().sess.span_err(\n-                        typ.span,\n-                        format!(\n-                            \"too many type parameters provided: \\\n-                             expected at most {} parameter(s) \\\n-                             but found {} parameter(s)\",\n-                            type_count,\n-                            segment.types.len()).as_slice());\n+                    span_err!(fcx.tcx().sess, typ.span, E0087,\n+                        \"too many type parameters provided: \\\n+                         expected at most {} parameter(s) \\\n+                         but found {} parameter(s)\",\n+                         type_count, segment.types.len());\n                     substs.types.truncate(space, 0);\n                 }\n             }\n@@ -4309,13 +4260,11 @@ pub fn instantiate_path(fcx: &FnCtxt,\n                 if i < region_count {\n                     substs.mut_regions().push(space, r);\n                 } else if i == region_count {\n-                    fcx.tcx().sess.span_err(\n-                        lifetime.span,\n-                        format!(\n-                            \"too many lifetime parameters provided: \\\n-                             expected {} parameter(s) but found {} parameter(s)\",\n-                            region_count,\n-                            segment.lifetimes.len()).as_slice());\n+                    span_err!(fcx.tcx().sess, lifetime.span, E0088,\n+                        \"too many lifetime parameters provided: \\\n+                         expected {} parameter(s) but found {} parameter(s)\",\n+                        region_count,\n+                        segment.lifetimes.len());\n                     substs.mut_regions().truncate(space, 0);\n                 }\n             }\n@@ -4360,14 +4309,10 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         if provided_len < required_len {\n             let qualifier =\n                 if desired.len() != required_len { \"at least \" } else { \"\" };\n-            fcx.tcx().sess.span_err(\n-                span,\n-                format!(\"too few type parameters provided: \\\n-                             expected {}{} parameter(s) \\\n-                             but found {} parameter(s)\",\n-                            qualifier,\n-                            required_len,\n-                            provided_len).as_slice());\n+            span_err!(fcx.tcx().sess, span, E0089,\n+                \"too few type parameters provided: expected {}{} parameter(s) \\\n+                 but found {} parameter(s)\",\n+                qualifier, required_len, provided_len);\n             substs.types.replace(space,\n                                  Vec::from_elem(desired.len(), ty::mk_err()));\n             return;\n@@ -4418,14 +4363,10 @@ pub fn instantiate_path(fcx: &FnCtxt,\n \n         // Otherwise, too few were provided. Report an error and then\n         // use inference variables.\n-        fcx.tcx().sess.span_err(\n-            span,\n-            format!(\n-                \"too few lifetime parameters provided: \\\n-                         expected {} parameter(s) \\\n-                         but found {} parameter(s)\",\n-                desired.len(),\n-                provided_len).as_slice());\n+        span_err!(fcx.tcx().sess, span, E0090,\n+            \"too few lifetime parameters provided: expected {} parameter(s) \\\n+             but found {} parameter(s)\",\n+            desired.len(), provided_len);\n \n         substs.mut_regions().replace(\n             space,\n@@ -4547,10 +4488,9 @@ pub fn check_bounds_are_used(ccx: &CrateCtxt,\n \n     for (i, b) in tps_used.iter().enumerate() {\n         if !*b {\n-            ccx.tcx.sess.span_err(\n-                span,\n-                format!(\"type parameter `{}` is unused\",\n-                        token::get_ident(tps.get(i).ident)).as_slice());\n+            span_err!(ccx.tcx.sess, span, E0091,\n+                \"type parameter `{}` is unused\",\n+                token::get_ident(tps.get(i).ident));\n         }\n     }\n }\n@@ -4586,10 +4526,8 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                 (0, Vec::new(), ty::mk_nil())\n             }\n             op => {\n-                tcx.sess.span_err(it.span,\n-                                  format!(\"unrecognized atomic operation \\\n-                                           function: `{}`\",\n-                                          op).as_slice());\n+                span_err!(tcx.sess, it.span, E0092,\n+                    \"unrecognized atomic operation function: `{}`\", op);\n                 return;\n             }\n         }\n@@ -4813,9 +4751,8 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                 ty::mk_tup(tcx, vec!(ty::mk_u64(), ty::mk_bool()))),\n \n             ref other => {\n-                tcx.sess.span_err(it.span,\n-                                  format!(\"unrecognized intrinsic function: `{}`\",\n-                                          *other).as_slice());\n+                span_err!(tcx.sess, it.span, E0093,\n+                    \"unrecognized intrinsic function: `{}`\", *other);\n                 return;\n             }\n         }\n@@ -4833,11 +4770,10 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n     let i_ty = ty::lookup_item_type(ccx.tcx, local_def(it.id));\n     let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n     if i_n_tps != n_tps {\n-        tcx.sess.span_err(it.span,\n-                          format!(\"intrinsic has wrong number of type \\\n-                                   parameters: found {}, expected {}\",\n-                                  i_n_tps,\n-                                  n_tps).as_slice());\n+        span_err!(tcx.sess, it.span, E0094,\n+            \"intrinsic has wrong number of type \\\n+             parameters: found {}, expected {}\",\n+             i_n_tps, n_tps);\n     } else {\n         require_same_types(tcx,\n                            None,"}, {"sha": "0b26a641f8d508ccc78edd2c1b3a62ade133c9d3", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d", "patch": "@@ -98,6 +98,9 @@ impl SpanHandler {\n     pub fn span_warn(&self, sp: Span, msg: &str) {\n         self.handler.emit(Some((&self.cm, sp)), msg, Warning);\n     }\n+    pub fn span_warn_with_code(&self, sp: Span, msg: &str, code: &str) {\n+        self.handler.emit_with_code(Some((&self.cm, sp)), msg, code, Warning);\n+    }\n     pub fn span_note(&self, sp: Span, msg: &str) {\n         self.handler.emit(Some((&self.cm, sp)), msg, Note);\n     }"}, {"sha": "b4af7205c42068fae0ea49c8ec5f5427887bf85b", "filename": "src/libsyntax/diagnostics/macros.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs?ref=a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d", "patch": "@@ -49,3 +49,25 @@ macro_rules! span_err(\n         ($session).span_err_with_code($span, format!($($arg),*).as_slice(), stringify!($code))\n     })\n )\n+\n+#[macro_export]\n+macro_rules! span_warn(\n+    ($session:expr, $span:expr, $code:ident, $($arg:expr),*) => ({\n+        __diagnostic_used!($code);\n+        ($session).span_warn_with_code($span, format!($($arg),*).as_slice(), stringify!($code))\n+    })\n+)\n+\n+#[macro_export]\n+macro_rules! span_note(\n+    ($session:expr, $span:expr, $($arg:expr),*) => ({\n+        ($session).span_note($span, format!($($arg),*).as_slice())\n+    })\n+)\n+\n+#[macro_export]\n+macro_rules! register_diagnostics(\n+    ($($code:tt),*) => (\n+        $(register_diagnostic!($code))*\n+    )\n+)"}, {"sha": "209296989fa0de1e12d0fdecb3f257f8f7fe0f03", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=a5fe176e9715f6e67a3ede3d204ba84b2f92ce7d", "patch": "@@ -54,7 +54,8 @@ pub fn expand_diagnostic_used(ecx: &mut ExtCtxt, span: Span,\n     with_registered_diagnostics(|diagnostics| {\n         if !diagnostics.contains_key(&code.name) {\n             ecx.span_err(span, format!(\n-                \"unknown diagnostic code {}\", token::get_ident(code).get()\n+                \"unknown diagnostic code {}; add to librustc/diagnostics.rs\",\n+                token::get_ident(code).get()\n             ).as_slice());\n         }\n         ()"}]}