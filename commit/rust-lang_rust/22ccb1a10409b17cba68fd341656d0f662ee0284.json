{"sha": "22ccb1a10409b17cba68fd341656d0f662ee0284", "node_id": "C_kwDOAAsO6NoAKDIyY2NiMWExMDQwOWIxN2NiYTY4ZmQzNDE2NTZkMGY2NjJlZTAyODQ", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-12-30T10:30:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-30T10:30:28Z"}, "message": "Merge #11141\n\n11141: internal: add tests for extra parser entry points r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "39ecaa9533d3fbbe3d748f81db7d06fab6bda612", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39ecaa9533d3fbbe3d748f81db7d06fab6bda612"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22ccb1a10409b17cba68fd341656d0f662ee0284", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhzYpECRBK7hj4Ov3rIwAAzlcIAEfNAMamfizeO/+OigWCx4Co\nMUyqVW/2su2xo3HqqKnKfu1V5RwehL2MyDM5E5EtPVZpL0UuxzdXd6Z85VCigI4p\nRfujieCJZCvVJiZlK/U3wmj2S4xrWpjnzlI0AiSopB7TK5Hrhk7a7JbZqAatPgSG\nhIbpsYiLHR1nGnANa4HgCsl2RzEnGBMLnSj0LurAEH/jSYlAMKd/yttrFfTh8Nff\nTZzdlRbARebYDe/aLFregywRosmgf7z50+GdE4ddthdCeLiUwz5C2zw/I/gYdwdh\nQznvxQpH3NDGi4gTqMfRi2IPtr9hl+6AtY9SCXZ7Lu5agh+3arcE+OW0haHuTfg=\n=ZEVd\n-----END PGP SIGNATURE-----\n", "payload": "tree 39ecaa9533d3fbbe3d748f81db7d06fab6bda612\nparent e279d52f73503bfa8429eb71aef4905ce5f5df88\nparent 2f3237912dd557493560f76a9fbbd7926b7933a5\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1640860228 +0000\ncommitter GitHub <noreply@github.com> 1640860228 +0000\n\nMerge #11141\n\n11141: internal: add tests for extra parser entry points r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22ccb1a10409b17cba68fd341656d0f662ee0284", "html_url": "https://github.com/rust-lang/rust/commit/22ccb1a10409b17cba68fd341656d0f662ee0284", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22ccb1a10409b17cba68fd341656d0f662ee0284/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e279d52f73503bfa8429eb71aef4905ce5f5df88", "url": "https://api.github.com/repos/rust-lang/rust/commits/e279d52f73503bfa8429eb71aef4905ce5f5df88", "html_url": "https://github.com/rust-lang/rust/commit/e279d52f73503bfa8429eb71aef4905ce5f5df88"}, {"sha": "2f3237912dd557493560f76a9fbbd7926b7933a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f3237912dd557493560f76a9fbbd7926b7933a5", "html_url": "https://github.com/rust-lang/rust/commit/2f3237912dd557493560f76a9fbbd7926b7933a5"}], "stats": {"total": 166, "additions": 135, "deletions": 31}, "files": [{"sha": "b93072d4466e420072a5cca8a0610a1981a458ac", "filename": "crates/hir_def/src/macro_expansion_tests/mbe/matching.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/22ccb1a10409b17cba68fd341656d0f662ee0284/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ccb1a10409b17cba68fd341656d0f662ee0284/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmatching.rs?ref=22ccb1a10409b17cba68fd341656d0f662ee0284", "patch": "@@ -50,3 +50,56 @@ macro_rules! m{ ($fmt:expr) => (); }\n \"#]],\n     );\n }\n+\n+#[test]\n+fn asi() {\n+    // Thanks, Christopher!\n+    //\n+    // https://internals.rust-lang.org/t/understanding-decisions-behind-semicolons/15181/29\n+    check(\n+        r#\"\n+macro_rules! asi { ($($stmt:stmt)*) => ($($stmt)*); }\n+\n+fn main() {\n+    asi! {\n+        let a = 2\n+        let b = 5\n+        drop(b-a)\n+        println!(\"{}\", a+b)\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+macro_rules! asi { ($($stmt:stmt)*) => ($($stmt)*); }\n+\n+fn main() {\n+    let a = 2let b = 5drop(b-a)println!(\"{}\", a+b)\n+}\n+\"#]],\n+    )\n+}\n+\n+#[test]\n+fn stmt_boundaries() {\n+    // FIXME: this actually works OK under rustc.\n+    check(\n+        r#\"\n+macro_rules! m {\n+    ($($s:stmt)*) => (stringify!($($s |)*);)\n+}\n+m!(;;92;let x = 92; loop {};);\n+\"#,\n+        expect![[r#\"\n+macro_rules! m {\n+    ($($s:stmt)*) => (stringify!($($s |)*);)\n+}\n+stringify!(;\n+|;\n+|92|;\n+|let x = 92|;\n+|loop {}\n+|;\n+|);\n+\"#]],\n+    );\n+}"}, {"sha": "e1a265d817ca982514ac33350908e27dde2450ee", "filename": "crates/parser/src/grammar.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/22ccb1a10409b17cba68fd341656d0f662ee0284/crates%2Fparser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ccb1a10409b17cba68fd341656d0f662ee0284/crates%2Fparser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar.rs?ref=22ccb1a10409b17cba68fd341656d0f662ee0284", "patch": "@@ -59,7 +59,7 @@ pub(crate) mod entry {\n         }\n \n         pub(crate) fn stmt(p: &mut Parser) {\n-            expressions::stmt(p, expressions::StmtWithSemi::No, true);\n+            expressions::stmt(p, expressions::Semicolon::Forbidden);\n         }\n \n         pub(crate) fn pat(p: &mut Parser) {\n@@ -98,12 +98,7 @@ pub(crate) mod entry {\n             let m = p.start();\n \n             while !p.at(EOF) {\n-                if p.at(T![;]) {\n-                    p.bump(T![;]);\n-                    continue;\n-                }\n-\n-                expressions::stmt(p, expressions::StmtWithSemi::Optional, true);\n+                expressions::stmt(p, expressions::Semicolon::Optional);\n             }\n \n             m.complete(p, MACRO_STMTS);"}, {"sha": "9dbba89c568efe0019e72d05743a5335944c64b4", "filename": "crates/parser/src/grammar/expressions.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/22ccb1a10409b17cba68fd341656d0f662ee0284/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ccb1a10409b17cba68fd341656d0f662ee0284/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=22ccb1a10409b17cba68fd341656d0f662ee0284", "patch": "@@ -5,10 +5,11 @@ use super::*;\n pub(crate) use self::atom::{block_expr, match_arm_list};\n pub(super) use self::atom::{literal, LITERAL_FIRST};\n \n-pub(super) enum StmtWithSemi {\n-    Yes,\n-    No,\n+#[derive(PartialEq, Eq)]\n+pub(super) enum Semicolon {\n+    Required,\n     Optional,\n+    Forbidden,\n }\n \n const EXPR_FIRST: TokenSet = LHS_FIRST;\n@@ -28,7 +29,11 @@ fn expr_no_struct(p: &mut Parser) {\n     expr_bp(p, None, r, 1);\n }\n \n-pub(super) fn stmt(p: &mut Parser, with_semi: StmtWithSemi, prefer_expr: bool) {\n+pub(super) fn stmt(p: &mut Parser, semicolon: Semicolon) {\n+    if p.eat(T![;]) {\n+        return;\n+    }\n+\n     let m = p.start();\n     // test attr_on_expr_stmt\n     // fn foo() {\n@@ -40,7 +45,7 @@ pub(super) fn stmt(p: &mut Parser, with_semi: StmtWithSemi, prefer_expr: bool) {\n     attributes::outer_attrs(p);\n \n     if p.at(T![let]) {\n-        let_stmt(p, m, with_semi);\n+        let_stmt(p, m, semicolon);\n         return;\n     }\n \n@@ -52,7 +57,7 @@ pub(super) fn stmt(p: &mut Parser, with_semi: StmtWithSemi, prefer_expr: bool) {\n     };\n \n     if let Some((cm, blocklike)) = expr_stmt(p, Some(m)) {\n-        if !(p.at(T!['}']) || (prefer_expr && p.at(EOF))) {\n+        if !(p.at(T!['}']) || (semicolon != Semicolon::Required && p.at(EOF))) {\n             // test no_semi_after_block\n             // fn foo() {\n             //     if true {}\n@@ -68,27 +73,26 @@ pub(super) fn stmt(p: &mut Parser, with_semi: StmtWithSemi, prefer_expr: bool) {\n             //     test!{}\n             // }\n             let m = cm.precede(p);\n-            match with_semi {\n-                StmtWithSemi::No => (),\n-                StmtWithSemi::Optional => {\n-                    p.eat(T![;]);\n-                }\n-                StmtWithSemi::Yes => {\n+            match semicolon {\n+                Semicolon::Required => {\n                     if blocklike.is_block() {\n                         p.eat(T![;]);\n                     } else {\n                         p.expect(T![;]);\n                     }\n                 }\n+                Semicolon::Optional => {\n+                    p.eat(T![;]);\n+                }\n+                Semicolon::Forbidden => (),\n             }\n-\n             m.complete(p, EXPR_STMT);\n         }\n     }\n \n     // test let_stmt\n     // fn f() { let x: i32 = 92; }\n-    fn let_stmt(p: &mut Parser, m: Marker, with_semi: StmtWithSemi) {\n+    fn let_stmt(p: &mut Parser, m: Marker, with_semi: Semicolon) {\n         p.bump(T![let]);\n         patterns::pattern(p);\n         if p.at(T![:]) {\n@@ -113,11 +117,11 @@ pub(super) fn stmt(p: &mut Parser, with_semi: StmtWithSemi, prefer_expr: bool) {\n         }\n \n         match with_semi {\n-            StmtWithSemi::No => (),\n-            StmtWithSemi::Optional => {\n+            Semicolon::Forbidden => (),\n+            Semicolon::Optional => {\n                 p.eat(T![;]);\n             }\n-            StmtWithSemi::Yes => {\n+            Semicolon::Required => {\n                 p.expect(T![;]);\n             }\n         }\n@@ -143,13 +147,7 @@ pub(super) fn expr_block_contents(p: &mut Parser) {\n         //     fn f() {};\n         //     struct S {};\n         // }\n-\n-        if p.at(T![;]) {\n-            p.bump(T![;]);\n-            continue;\n-        }\n-\n-        stmt(p, StmtWithSemi::Yes, false);\n+        stmt(p, Semicolon::Required);\n     }\n }\n "}, {"sha": "e9ec9822d68c304b9444e20c098c648b3324be38", "filename": "crates/parser/src/output.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22ccb1a10409b17cba68fd341656d0f662ee0284/crates%2Fparser%2Fsrc%2Foutput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ccb1a10409b17cba68fd341656d0f662ee0284/crates%2Fparser%2Fsrc%2Foutput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Foutput.rs?ref=22ccb1a10409b17cba68fd341656d0f662ee0284", "patch": "@@ -22,6 +22,7 @@ pub struct Output {\n     error: Vec<String>,\n }\n \n+#[derive(Debug)]\n pub enum Step<'a> {\n     Token { kind: SyntaxKind, n_input_tokens: u8 },\n     Enter { kind: SyntaxKind },"}, {"sha": "b038d44fe08b2550864f2bbd6454ad2a73372a07", "filename": "crates/parser/src/shortcuts.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22ccb1a10409b17cba68fd341656d0f662ee0284/crates%2Fparser%2Fsrc%2Fshortcuts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ccb1a10409b17cba68fd341656d0f662ee0284/crates%2Fparser%2Fsrc%2Fshortcuts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fshortcuts.rs?ref=22ccb1a10409b17cba68fd341656d0f662ee0284", "patch": "@@ -16,6 +16,7 @@ use crate::{\n     SyntaxKind::{self, *},\n };\n \n+#[derive(Debug)]\n pub enum StrStep<'a> {\n     Token { kind: SyntaxKind, text: &'a str },\n     Enter { kind: SyntaxKind },\n@@ -49,6 +50,7 @@ impl<'a> LexedStr<'a> {\n         res\n     }\n \n+    /// NB: only valid to call with Output from Reparser/TopLevelEntry.\n     pub fn intersperse_trivia(\n         &self,\n         output: &crate::Output,"}, {"sha": "fb4885e98d506bb4cd5d95e83fed55640ab67da1", "filename": "crates/parser/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22ccb1a10409b17cba68fd341656d0f662ee0284/crates%2Fparser%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ccb1a10409b17cba68fd341656d0f662ee0284/crates%2Fparser%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Ftests.rs?ref=22ccb1a10409b17cba68fd341656d0f662ee0284", "patch": "@@ -1,4 +1,5 @@\n mod sourcegen_inline_tests;\n+mod entries;\n \n use std::{\n     fmt::Write,"}, {"sha": "947922d8b320dec56d1a8376fb9914756f02d821", "filename": "crates/parser/src/tests/entries.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/22ccb1a10409b17cba68fd341656d0f662ee0284/crates%2Fparser%2Fsrc%2Ftests%2Fentries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ccb1a10409b17cba68fd341656d0f662ee0284/crates%2Fparser%2Fsrc%2Ftests%2Fentries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Ftests%2Fentries.rs?ref=22ccb1a10409b17cba68fd341656d0f662ee0284", "patch": "@@ -0,0 +1,54 @@\n+use crate::{LexedStr, PrefixEntryPoint, Step};\n+\n+#[test]\n+fn vis() {\n+    check_prefix(PrefixEntryPoint::Vis, \"pub(crate) fn foo() {}\", \"pub(crate)\");\n+    check_prefix(PrefixEntryPoint::Vis, \"fn foo() {}\", \"\");\n+    check_prefix(PrefixEntryPoint::Vis, \"pub(fn foo() {}\", \"pub\");\n+    check_prefix(PrefixEntryPoint::Vis, \"pub(crate fn foo() {}\", \"pub(crate\");\n+    check_prefix(PrefixEntryPoint::Vis, \"crate fn foo() {}\", \"crate\");\n+}\n+\n+#[test]\n+fn block() {\n+    check_prefix(PrefixEntryPoint::Block, \"{}, 92\", \"{}\");\n+    check_prefix(PrefixEntryPoint::Block, \"{, 92)\", \"{, 92)\");\n+    check_prefix(PrefixEntryPoint::Block, \"()\", \"\");\n+}\n+\n+#[test]\n+fn stmt() {\n+    check_prefix(PrefixEntryPoint::Stmt, \"92; fn\", \"92\");\n+    check_prefix(PrefixEntryPoint::Stmt, \"let _ = 92; 1\", \"let _ = 92\");\n+    check_prefix(PrefixEntryPoint::Stmt, \"pub fn f() {} = 92\", \"pub fn f() {}\");\n+    check_prefix(PrefixEntryPoint::Stmt, \";;;\", \";\");\n+    check_prefix(PrefixEntryPoint::Stmt, \"+\", \"+\");\n+    check_prefix(PrefixEntryPoint::Stmt, \"@\", \"@\");\n+    check_prefix(PrefixEntryPoint::Stmt, \"loop {} - 1\", \"loop {}\");\n+}\n+\n+fn check_prefix(entry: PrefixEntryPoint, input: &str, prefix: &str) {\n+    let lexed = LexedStr::new(input);\n+    let input = lexed.to_input();\n+\n+    let mut n_tokens = 0;\n+    for step in entry.parse(&input).iter() {\n+        match step {\n+            Step::Token { n_input_tokens, .. } => n_tokens += n_input_tokens as usize,\n+            Step::Enter { .. } | Step::Exit | Step::Error { .. } => (),\n+        }\n+    }\n+\n+    let mut i = 0;\n+    loop {\n+        if n_tokens == 0 {\n+            break;\n+        }\n+        if !lexed.kind(i).is_trivia() {\n+            n_tokens -= 1;\n+        }\n+        i += 1;\n+    }\n+    let buf = &lexed.as_str()[..lexed.text_start(i)];\n+    assert_eq!(buf, prefix);\n+}"}]}