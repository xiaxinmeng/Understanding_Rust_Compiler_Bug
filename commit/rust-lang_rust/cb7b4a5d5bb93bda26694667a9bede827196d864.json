{"sha": "cb7b4a5d5bb93bda26694667a9bede827196d864", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiN2I0YTVkNWJiOTNiZGEyNjY5NDY2N2E5YmVkZTgyNzE5NmQ4NjQ=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-20T15:03:39Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-20T15:03:39Z"}, "message": "Some more fragment fixes", "tree": {"sha": "063bb4e015d41c1d5151039de33992b1f42c3688", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/063bb4e015d41c1d5151039de33992b1f42c3688"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb7b4a5d5bb93bda26694667a9bede827196d864", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb7b4a5d5bb93bda26694667a9bede827196d864", "html_url": "https://github.com/rust-lang/rust/commit/cb7b4a5d5bb93bda26694667a9bede827196d864", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb7b4a5d5bb93bda26694667a9bede827196d864/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8f1abf5f760524f75b4d4bcfe8b110eba5ea8fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8f1abf5f760524f75b4d4bcfe8b110eba5ea8fe", "html_url": "https://github.com/rust-lang/rust/commit/e8f1abf5f760524f75b4d4bcfe8b110eba5ea8fe"}], "stats": {"total": 263, "additions": 115, "deletions": 148}, "files": [{"sha": "0799f98b13253cab57f2896adea709ff79d6c989", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb7b4a5d5bb93bda26694667a9bede827196d864/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb7b4a5d5bb93bda26694667a9bede827196d864/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=cb7b4a5d5bb93bda26694667a9bede827196d864", "patch": "@@ -303,6 +303,13 @@ impl ModuleDef {\n         Some(segments.into_iter().join(\"::\"))\n     }\n \n+    pub fn canonical_module_path(\n+        &self,\n+        db: &dyn HirDatabase,\n+    ) -> Option<impl Iterator<Item = Module>> {\n+        self.module(db).map(|it| it.path_to_root(db).into_iter().rev())\n+    }\n+\n     pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n         match self {\n             ModuleDef::Adt(it) => Some(it.name(db)),"}, {"sha": "f8887e8fcd69ee1deeaf30185bda73e45fbc5533", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 104, "deletions": 143, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/cb7b4a5d5bb93bda26694667a9bede827196d864/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb7b4a5d5bb93bda26694667a9bede827196d864/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=cb7b4a5d5bb93bda26694667a9bede827196d864", "patch": "@@ -1,21 +1,16 @@\n //! Extracts, resolves and rewrites links and intra-doc links in markdown documentation.\n \n-use std::{\n-    convert::{TryFrom, TryInto},\n-    iter::once,\n-};\n-\n mod intra_doc_links;\n \n-use itertools::Itertools;\n+use std::convert::{TryFrom, TryInto};\n+\n use pulldown_cmark::{BrokenLink, CowStr, Event, InlineStr, LinkType, Options, Parser, Tag};\n use pulldown_cmark_to_cmark::{cmark_with_options, Options as CmarkOptions};\n use stdx::format_to;\n use url::Url;\n \n use hir::{\n-    db::{DefDatabase, HirDatabase},\n-    Adt, AsAssocItem, AssocItem, AssocItemContainer, Crate, Field, HasAttrs, ItemInNs, ModuleDef,\n+    db::HirDatabase, Adt, AsAssocItem, AssocItem, AssocItemContainer, Crate, HasAttrs, ModuleDef,\n };\n use ide_db::{\n     defs::{Definition, NameClass, NameRefClass},\n@@ -60,9 +55,13 @@ pub(crate) fn rewrite_links(db: &RootDatabase, markdown: &str, definition: Defin\n         }\n     });\n     let mut out = String::new();\n-    let mut options = CmarkOptions::default();\n-    options.code_block_backticks = 3;\n-    cmark_with_options(doc, &mut out, None, options).ok();\n+    cmark_with_options(\n+        doc,\n+        &mut out,\n+        None,\n+        CmarkOptions { code_block_backticks: 3, ..Default::default() },\n+    )\n+    .ok();\n     out\n }\n \n@@ -94,9 +93,13 @@ pub(crate) fn remove_links(markdown: &str) -> String {\n     });\n \n     let mut out = String::new();\n-    let mut options = CmarkOptions::default();\n-    options.code_block_backticks = 3;\n-    cmark_with_options(doc, &mut out, None, options).ok();\n+    cmark_with_options(\n+        doc,\n+        &mut out,\n+        None,\n+        CmarkOptions { code_block_backticks: 3, ..Default::default() },\n+    )\n+    .ok();\n     out\n }\n \n@@ -105,10 +108,10 @@ pub(crate) fn external_docs(\n     db: &RootDatabase,\n     position: &FilePosition,\n ) -> Option<DocumentationLink> {\n-    let sema = Semantics::new(db);\n+    let sema = &Semantics::new(db);\n     let file = sema.parse(position.file_id).syntax().clone();\n     let token = pick_best_token(file.token_at_offset(position.offset), |kind| match kind {\n-        IDENT | INT_NUMBER => 3,\n+        IDENT | INT_NUMBER | T![self] => 3,\n         T!['('] | T![')'] => 2,\n         kind if kind.is_trivia() => 0,\n         _ => 1,\n@@ -118,13 +121,13 @@ pub(crate) fn external_docs(\n     let node = token.parent()?;\n     let definition = match_ast! {\n         match node {\n-            ast::NameRef(name_ref) => match NameRefClass::classify(&sema, &name_ref)? {\n+            ast::NameRef(name_ref) => match NameRefClass::classify(sema, &name_ref)? {\n                 NameRefClass::Definition(def) => def,\n                 NameRefClass::FieldShorthand { local_ref: _, field_ref } => {\n                     Definition::Field(field_ref)\n                 }\n             },\n-            ast::Name(name) => match NameClass::classify(&sema, &name)? {\n+            ast::Name(name) => match NameClass::classify(sema, &name)? {\n                 NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n                 NameClass::PatFieldShorthand { local_def: _, field_ref } => Definition::Field(field_ref),\n             },\n@@ -135,7 +138,8 @@ pub(crate) fn external_docs(\n     get_doc_link(db, definition)\n }\n \n-/// Extracts all links from a given markdown text.\n+/// Extracts all links from a given markdown text returning the definition text range, link-text\n+/// and the namespace if known.\n pub(crate) fn extract_definitions_from_docs(\n     docs: &hir::Documentation,\n ) -> Vec<(TextRange, String, Option<hir::Namespace>)> {\n@@ -145,18 +149,16 @@ pub(crate) fn extract_definitions_from_docs(\n         Some(&mut broken_link_clone_cb),\n     )\n     .into_offset_iter()\n-    .filter_map(|(event, range)| {\n-        if let Event::Start(Tag::Link(_, target, title)) = event {\n-            let link = if target.is_empty() { title } else { target };\n-            let (link, ns) = parse_intra_doc_link(&link);\n+    .filter_map(|(event, range)| match event {\n+        Event::Start(Tag::Link(_, target, _)) => {\n+            let (link, ns) = parse_intra_doc_link(&target);\n             Some((\n                 TextRange::new(range.start.try_into().ok()?, range.end.try_into().ok()?),\n                 link.to_string(),\n                 ns,\n             ))\n-        } else {\n-            None\n         }\n+        _ => None,\n     })\n     .collect()\n }\n@@ -232,83 +234,59 @@ fn broken_link_clone_cb<'a, 'b>(link: BrokenLink<'a>) -> Option<(CowStr<'b>, Cow\n // This should cease to be a problem if RFC2988 (Stable Rustdoc URLs) is implemented\n // https://github.com/rust-lang/rfcs/pull/2988\n fn get_doc_link(db: &RootDatabase, definition: Definition) -> Option<String> {\n-    // Get the outermost definition for the module def. This is used to resolve the public path to the type,\n-    // then we can join the method, field, etc onto it if required.\n-    let target_def: ModuleDef = match definition {\n-        Definition::ModuleDef(def) => match def {\n-            ModuleDef::Function(f) => f\n-                .as_assoc_item(db)\n-                .and_then(|assoc| match assoc.container(db) {\n-                    AssocItemContainer::Trait(t) => Some(t.into()),\n-                    AssocItemContainer::Impl(impl_) => {\n-                        impl_.self_ty(db).as_adt().map(|adt| adt.into())\n-                    }\n-                })\n-                .unwrap_or_else(|| def),\n-            def => def,\n-        },\n-        Definition::Field(f) => f.parent_def(db).into(),\n-        // FIXME: Handle macros\n-        _ => return None,\n+    let (target, frag) = match definition {\n+        Definition::ModuleDef(def) => {\n+            if let Some(assoc_item) = def.as_assoc_item(db) {\n+                let def = match assoc_item.container(db) {\n+                    AssocItemContainer::Trait(t) => t.into(),\n+                    AssocItemContainer::Impl(i) => i.self_ty(db).as_adt()?.into(),\n+                };\n+                let frag = get_assoc_item_fragment(db, assoc_item)?;\n+                (def, Some(frag))\n+            } else {\n+                (def, None)\n+            }\n+        }\n+        Definition::Field(field) => {\n+            let def = match field.parent_def(db) {\n+                hir::VariantDef::Struct(it) => it.into(),\n+                hir::VariantDef::Union(it) => it.into(),\n+                hir::VariantDef::Variant(it) => it.into(),\n+            };\n+            (def, Some(format!(\"structfield.{}\", field.name(db))))\n+        }\n+        Definition::Macro(_) => todo!(),\n+        Definition::SelfType(_) => todo!(),\n+        Definition::Local(_) | Definition::GenericParam(_) | Definition::Label(_) => return None,\n     };\n \n-    let ns = ItemInNs::from(target_def);\n-\n     let krate = match definition {\n         // Definition::module gives back the parent module, we don't want that as it fails for root modules\n         Definition::ModuleDef(ModuleDef::Module(module)) => module.krate(),\n         _ => definition.module(db)?.krate(),\n     };\n-    // FIXME: using import map doesn't make sense here. What we want here is\n-    // canonical path. What import map returns is the shortest path suitable for\n-    // import. See this test:\n-    cov_mark::hit!(test_reexport_order);\n-    let import_map = db.import_map(krate.into());\n \n     let mut base = krate.display_name(db)?.to_string();\n-    let is_root_module = matches!(\n+    let is_non_root_module = !matches!(\n         definition,\n         Definition::ModuleDef(ModuleDef::Module(module)) if krate.root_module(db) == module\n     );\n-    if !is_root_module {\n-        base = once(base)\n-            .chain(import_map.path_of(ns)?.segments.iter().map(|name| name.to_string()))\n-            .join(\"/\");\n+    if is_non_root_module {\n+        target\n+            .canonical_module_path(db)?\n+            .flat_map(|it| it.name(db))\n+            .for_each(|name| format_to!(base, \"/{}\", name));\n     }\n     base += \"/\";\n \n-    let filename = get_symbol_filename(db, &target_def);\n-    let fragment = match definition {\n-        Definition::ModuleDef(def) => match def {\n-            ModuleDef::Function(f) => {\n-                get_symbol_fragment(db, &FieldOrAssocItem::AssocItem(AssocItem::Function(f)))\n-            }\n-            ModuleDef::Const(c) => {\n-                get_symbol_fragment(db, &FieldOrAssocItem::AssocItem(AssocItem::Const(c)))\n-            }\n-            ModuleDef::TypeAlias(ty) => {\n-                get_symbol_fragment(db, &FieldOrAssocItem::AssocItem(AssocItem::TypeAlias(ty)))\n-            }\n-            _ => None,\n-        },\n-        Definition::Field(field) => get_symbol_fragment(db, &FieldOrAssocItem::Field(field)),\n-        _ => None,\n-    };\n-\n-    get_doc_base_url(db, &krate)?\n+    let mut url = get_doc_base_url(db, &krate)?\n         .join(&base)\n-        .ok()\n-        .and_then(|mut url| {\n-            if !matches!(definition, Definition::ModuleDef(ModuleDef::Module(..))) {\n-                url.path_segments_mut().ok()?.pop();\n-            };\n-            Some(url)\n-        })\n-        .and_then(|url| url.join(filename.as_deref()?).ok())\n-        .and_then(\n-            |url| if let Some(fragment) = fragment { url.join(&fragment).ok() } else { Some(url) },\n-        )\n-        .map(|url| url.into())\n+        .ok()?\n+        .join(&get_symbol_filename(db, &target)?)\n+        .ok()?;\n+    url.set_fragment(frag.as_deref());\n+\n+    Some(url.into())\n }\n \n fn rewrite_intra_doc_link(\n@@ -322,10 +300,7 @@ fn rewrite_intra_doc_link(\n     let krate = resolved.module(db)?.krate();\n     let mut mod_path = String::new();\n     resolved\n-        .module(db)?\n-        .path_to_root(db)\n-        .into_iter()\n-        .rev()\n+        .canonical_module_path(db)?\n         .flat_map(|it| it.name(db))\n         .for_each(|name| format_to!(mod_path, \"{}/\", name));\n     let mut new_url = get_doc_base_url(db, &krate)?\n@@ -339,11 +314,7 @@ fn rewrite_intra_doc_link(\n             AssocItemContainer::Impl(i) => i.self_ty(db).as_adt()?.into(),\n         };\n         new_url = new_url.join(&get_symbol_filename(db, &resolved)?).ok()?;\n-        let frag = match assoc_item {\n-            AssocItem::Function(f) => format!(\"method.{}\", f.name(db)),\n-            AssocItem::Const(c) => format!(\"associatedconstant.{}\", c.name(db)?),\n-            AssocItem::TypeAlias(ta) => format!(\"associatedtype.{}\", ta.name(db)),\n-        };\n+        let frag = get_assoc_item_fragment(db, assoc_item)?;\n         new_url.set_fragment(Some(&frag));\n     } else {\n         new_url = new_url.join(&get_symbol_filename(db, &resolved)?).ok()?;\n@@ -360,16 +331,19 @@ fn rewrite_url_link(db: &RootDatabase, def: ModuleDef, target: &str) -> Option<S\n \n     let module = def.module(db)?;\n     let krate = module.krate();\n-    let canonical_path = def.canonical_path(db)?;\n-    let base = format!(\"{}/{}\", krate.display_name(db)?, canonical_path.replace(\"::\", \"/\"));\n+    let mut base = krate.display_name(db)?.to_string();\n+    let is_non_root_module = !matches!(\n+        def,\n+        ModuleDef::Module(module) if krate.root_module(db) == module\n+    );\n+    if is_non_root_module {\n+        def.canonical_module_path(db)?\n+            .flat_map(|it| it.name(db))\n+            .for_each(|name| format_to!(base, \"/{}\", name));\n+    }\n+    base += \"/\";\n \n-    get_doc_base_url(db, &krate)\n-        .and_then(|url| url.join(&base).ok())\n-        .and_then(|url| {\n-            get_symbol_filename(db, &def).as_deref().map(|f| url.join(f).ok()).flatten()\n-        })\n-        .and_then(|url| url.join(target).ok())\n-        .map(|url| url.into())\n+    get_doc_base_url(db, &krate)?.join(&base).ok()?.join(target).ok().map(Into::into)\n }\n \n /// Rewrites a markdown document, applying 'callback' to each link.\n@@ -410,7 +384,7 @@ fn map_links<'e>(\n \n /// Get the root URL for the documentation of a crate.\n ///\n-/// ```\n+/// ```ignore\n /// https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next\n /// ^^^^^^^^^^^^^^^^^^^^^^^^^^\n /// ```\n@@ -430,7 +404,7 @@ fn get_doc_base_url(db: &RootDatabase, krate: &Crate) -> Option<Url> {\n \n /// Get the filename and extension generated for a symbol by rustdoc.\n ///\n-/// ```\n+/// ```ignore\n /// https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next\n ///                                    ^^^^^^^^^^^^^^^^^^^\n /// ```\n@@ -441,7 +415,10 @@ fn get_symbol_filename(db: &dyn HirDatabase, definition: &ModuleDef) -> Option<S\n             Adt::Enum(e) => format!(\"enum.{}.html\", e.name(db)),\n             Adt::Union(u) => format!(\"union.{}.html\", u.name(db)),\n         },\n-        ModuleDef::Module(_) => \"index.html\".to_string(),\n+        ModuleDef::Module(m) => match m.name(db) {\n+            Some(name) => format!(\"{}/index.html\", name),\n+            None => String::from(\"index.html\"),\n+        },\n         ModuleDef::Trait(t) => format!(\"trait.{}.html\", t.name(db)),\n         ModuleDef::TypeAlias(t) => format!(\"type.{}.html\", t.name(db)),\n         ModuleDef::BuiltinType(t) => format!(\"primitive.{}.html\", t.name()),\n@@ -454,45 +431,36 @@ fn get_symbol_filename(db: &dyn HirDatabase, definition: &ModuleDef) -> Option<S\n     })\n }\n \n-enum FieldOrAssocItem {\n-    Field(Field),\n-    AssocItem(AssocItem),\n-}\n-\n /// Get the fragment required to link to a specific field, method, associated type, or associated constant.\n ///\n-/// ```\n+/// ```ignore\n /// https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next\n ///                                                       ^^^^^^^^^^^^^^\n /// ```\n-fn get_symbol_fragment(db: &dyn HirDatabase, field_or_assoc: &FieldOrAssocItem) -> Option<String> {\n-    Some(match field_or_assoc {\n-        FieldOrAssocItem::Field(field) => format!(\"#structfield.{}\", field.name(db)),\n-        FieldOrAssocItem::AssocItem(assoc) => match assoc {\n-            AssocItem::Function(function) => {\n-                let is_trait_method = function\n-                    .as_assoc_item(db)\n-                    .and_then(|assoc| assoc.containing_trait(db))\n-                    .is_some();\n-                // This distinction may get more complicated when specialization is available.\n-                // Rustdoc makes this decision based on whether a method 'has defaultness'.\n-                // Currently this is only the case for provided trait methods.\n-                if is_trait_method && !function.has_body(db) {\n-                    format!(\"#tymethod.{}\", function.name(db))\n-                } else {\n-                    format!(\"#method.{}\", function.name(db))\n-                }\n+fn get_assoc_item_fragment(db: &dyn HirDatabase, assoc_item: hir::AssocItem) -> Option<String> {\n+    Some(match assoc_item {\n+        AssocItem::Function(function) => {\n+            let is_trait_method =\n+                function.as_assoc_item(db).and_then(|assoc| assoc.containing_trait(db)).is_some();\n+            // This distinction may get more complicated when specialization is available.\n+            // Rustdoc makes this decision based on whether a method 'has defaultness'.\n+            // Currently this is only the case for provided trait methods.\n+            if is_trait_method && !function.has_body(db) {\n+                format!(\"tymethod.{}\", function.name(db))\n+            } else {\n+                format!(\"method.{}\", function.name(db))\n             }\n-            AssocItem::Const(constant) => format!(\"#associatedconstant.{}\", constant.name(db)?),\n-            AssocItem::TypeAlias(ty) => format!(\"#associatedtype.{}\", ty.name(db)),\n-        },\n+        }\n+        AssocItem::Const(constant) => format!(\"associatedconstant.{}\", constant.name(db)?),\n+        AssocItem::TypeAlias(ty) => format!(\"associatedtype.{}\", ty.name(db)),\n     })\n }\n \n #[cfg(test)]\n mod tests {\n     use expect_test::{expect, Expect};\n     use ide_db::base_db::FileRange;\n+    use itertools::Itertools;\n \n     use crate::{display::TryToNav, fixture};\n \n@@ -527,7 +495,7 @@ pub struct Fo$0o;\n             r#\"\n pub fn fo$0o() {}\n \"#,\n-            expect![[r##\"https://docs.rs/test/*/test/fn.foo.html#method.foo\"##]],\n+            expect![[r##\"https://docs.rs/test/*/test/fn.foo.html\"##]],\n         );\n     }\n \n@@ -599,13 +567,6 @@ pub mod foo {\n \n     #[test]\n     fn test_reexport_order() {\n-        cov_mark::check!(test_reexport_order);\n-        // FIXME: This should return\n-        //\n-        //    https://docs.rs/test/*/test/wrapper/modulestruct.Item.html\n-        //\n-        // That is, we should point inside the module, rather than at the\n-        // re-export.\n         check_external_docs(\n             r#\"\n pub mod wrapper {\n@@ -620,7 +581,7 @@ fn foo() {\n     let bar: wrapper::It$0em;\n }\n         \"#,\n-            expect![[r#\"https://docs.rs/test/*/test/wrapper/struct.Item.html\"#]],\n+            expect![[r#\"https://docs.rs/test/*/test/wrapper/module/struct.Item.html\"#]],\n         )\n     }\n \n@@ -657,7 +618,7 @@ pub trait Foo {\n /// [buzz]: Foo::buzz\n pub struct Bar$0;\n \"#,\n-            expect![[r###\"[Foo](https://docs.rs/test/*/test/trait.Foo.html#method.buzz)\"###]],\n+            expect![[r###\"[Foo](https://docs.rs/test/*/test/trait.Foo.html#tymethod.buzz)\"###]],\n         )\n     }\n "}, {"sha": "d94999dddd3f3b09fccbd2f3af87d68518192d3b", "filename": "crates/ide/src/doc_links/intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb7b4a5d5bb93bda26694667a9bede827196d864/crates%2Fide%2Fsrc%2Fdoc_links%2Fintra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb7b4a5d5bb93bda26694667a9bede827196d864/crates%2Fide%2Fsrc%2Fdoc_links%2Fintra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links%2Fintra_doc_links.rs?ref=cb7b4a5d5bb93bda26694667a9bede827196d864", "patch": "@@ -1,3 +1,5 @@\n+//! Helper tools for intra doc links.\n+\n const TYPES: ([&str; 9], [&str; 0]) =\n     ([\"type\", \"struct\", \"enum\", \"mod\", \"trait\", \"union\", \"module\", \"prim\", \"primitive\"], []);\n const VALUES: ([&str; 8], [&str; 1]) ="}, {"sha": "e9ba825c0333cf32292075c85bc00ac92c32e193", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb7b4a5d5bb93bda26694667a9bede827196d864/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb7b4a5d5bb93bda26694667a9bede827196d864/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=cb7b4a5d5bb93bda26694667a9bede827196d864", "patch": "@@ -2103,7 +2103,7 @@ pub struct B$0ar\n \n                 ---\n \n-                [Foo](https://docs.rs/test/*/test/trait.Foo.html#method.buzz)\n+                [Foo](https://docs.rs/test/*/test/trait.Foo.html#tymethod.buzz)\n             \"##]],\n         );\n     }"}, {"sha": "2cf801751ca7a50f995d20850608c79e9a57ef85", "filename": "crates/ide/src/runnables.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb7b4a5d5bb93bda26694667a9bede827196d864/crates%2Fide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb7b4a5d5bb93bda26694667a9bede827196d864/crates%2Fide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frunnables.rs?ref=cb7b4a5d5bb93bda26694667a9bede827196d864", "patch": "@@ -400,10 +400,7 @@ fn module_def_doctest(db: &RootDatabase, def: hir::ModuleDef) -> Option<Runnable\n     let def_name = def.name(db)?;\n     let path = (|| {\n         let mut path = String::new();\n-        def.module(db)?\n-            .path_to_root(db)\n-            .into_iter()\n-            .rev()\n+        def.canonical_module_path(db)?\n             .flat_map(|it| it.name(db))\n             .for_each(|name| format_to!(path, \"{}::\", name));\n         // This probably belongs to canonical_path?"}]}