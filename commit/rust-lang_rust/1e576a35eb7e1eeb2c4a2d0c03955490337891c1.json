{"sha": "1e576a35eb7e1eeb2c4a2d0c03955490337891c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlNTc2YTM1ZWI3ZTFlZWIyYzRhMmQwYzAzOTU1NDkwMzM3ODkxYzE=", "commit": {"author": {"name": "Steven Stewart-Gallus", "email": "sstewartgallus00@mylangara.bc.ca", "date": "2013-08-09T02:33:34Z"}, "committer": {"name": "Steven Stewart-Gallus", "email": "sstewartgallus00@mylangara.bc.ca", "date": "2013-08-09T02:34:01Z"}, "message": "Isolate common wait_end logic", "tree": {"sha": "b952bc2890c4f2828e61d9e9da6b49542d276327", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b952bc2890c4f2828e61d9e9da6b49542d276327"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e576a35eb7e1eeb2c4a2d0c03955490337891c1", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e576a35eb7e1eeb2c4a2d0c03955490337891c1", "html_url": "https://github.com/rust-lang/rust/commit/1e576a35eb7e1eeb2c4a2d0c03955490337891c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e576a35eb7e1eeb2c4a2d0c03955490337891c1/comments", "author": {"login": "mstewartgallus", "id": 4070335, "node_id": "MDQ6VXNlcjQwNzAzMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4070335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mstewartgallus", "html_url": "https://github.com/mstewartgallus", "followers_url": "https://api.github.com/users/mstewartgallus/followers", "following_url": "https://api.github.com/users/mstewartgallus/following{/other_user}", "gists_url": "https://api.github.com/users/mstewartgallus/gists{/gist_id}", "starred_url": "https://api.github.com/users/mstewartgallus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mstewartgallus/subscriptions", "organizations_url": "https://api.github.com/users/mstewartgallus/orgs", "repos_url": "https://api.github.com/users/mstewartgallus/repos", "events_url": "https://api.github.com/users/mstewartgallus/events{/privacy}", "received_events_url": "https://api.github.com/users/mstewartgallus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mstewartgallus", "id": 4070335, "node_id": "MDQ6VXNlcjQwNzAzMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4070335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mstewartgallus", "html_url": "https://github.com/mstewartgallus", "followers_url": "https://api.github.com/users/mstewartgallus/followers", "following_url": "https://api.github.com/users/mstewartgallus/following{/other_user}", "gists_url": "https://api.github.com/users/mstewartgallus/gists{/gist_id}", "starred_url": "https://api.github.com/users/mstewartgallus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mstewartgallus/subscriptions", "organizations_url": "https://api.github.com/users/mstewartgallus/orgs", "repos_url": "https://api.github.com/users/mstewartgallus/repos", "events_url": "https://api.github.com/users/mstewartgallus/events{/privacy}", "received_events_url": "https://api.github.com/users/mstewartgallus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9db698a81b0d68b093030fe52f941146aba65dd3", "url": "https://api.github.com/repos/rust-lang/rust/commits/9db698a81b0d68b093030fe52f941146aba65dd3", "html_url": "https://github.com/rust-lang/rust/commit/9db698a81b0d68b093030fe52f941146aba65dd3"}], "stats": {"total": 26, "additions": 13, "deletions": 13}, "files": [{"sha": "3bdb16a13d21aa30314f48bfcefc51a5e622680c", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1e576a35eb7e1eeb2c4a2d0c03955490337891c1/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e576a35eb7e1eeb2c4a2d0c03955490337891c1/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=1e576a35eb7e1eeb2c4a2d0c03955490337891c1", "patch": "@@ -71,6 +71,12 @@ impl WaitQueue {\n         }\n         count\n     }\n+\n+    fn wait_end(&self) -> WaitEnd {\n+        let (wait_end, signal_end) = comm::oneshot();\n+        self.tail.send_deferred(signal_end);\n+        wait_end\n+    }\n }\n \n // The building-block used to make semaphores, mutexes, and rwlocks.\n@@ -99,12 +105,9 @@ impl<Q:Send> Sem<Q> {\n             do (**self).with |state| {\n                 state.count -= 1;\n                 if state.count < 0 {\n-                    // Create waiter nobe.\n-                    let (WaitEnd, SignalEnd) = comm::oneshot();\n-                    // Tell outer scope we need to block.\n-                    waiter_nobe = Some(WaitEnd);\n-                    // Enqueue ourself.\n-                    state.waiters.tail.send_deferred(SignalEnd);\n+                    // Create waiter nobe, enqueue ourself, and tell\n+                    // outer scope we need to block.\n+                    waiter_nobe = Some(state.waiters.wait_end());\n                 }\n             }\n             // Uncomment if you wish to test for sem races. Not valgrind-friendly.\n@@ -200,10 +203,7 @@ impl<'self> Condvar<'self> {\n      * wait() is equivalent to wait_on(0).\n      */\n     pub fn wait_on(&self, condvar_id: uint) {\n-        // Create waiter nobe.\n-        let (WaitEnd, SignalEnd) = comm::oneshot();\n-        let mut WaitEnd   = Some(WaitEnd);\n-        let mut SignalEnd = Some(SignalEnd);\n+        let mut WaitEnd = None;\n         let mut out_of_bounds = None;\n         do task::unkillable {\n             // Release lock, 'atomically' enqueuing ourselves in so doing.\n@@ -215,9 +215,9 @@ impl<'self> Condvar<'self> {\n                         if state.count <= 0 {\n                             state.waiters.signal();\n                         }\n-                        // Enqueue ourself to be woken up by a signaller.\n-                        let SignalEnd = SignalEnd.take_unwrap();\n-                        state.blocked[condvar_id].tail.send_deferred(SignalEnd);\n+                        // Create waiter nobe, and enqueue ourself to\n+                        // be woken up by a signaller.\n+                        WaitEnd = Some(state.blocked[condvar_id].wait_end());\n                     } else {\n                         out_of_bounds = Some(state.blocked.len());\n                     }"}]}