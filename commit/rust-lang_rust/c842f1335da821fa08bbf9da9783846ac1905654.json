{"sha": "c842f1335da821fa08bbf9da9783846ac1905654", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4NDJmMTMzNWRhODIxZmEwOGJiZjlkYTk3ODM4NDZhYzE5MDU2NTQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-07-02T01:39:27Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-07-02T15:20:12Z"}, "message": "Completely disable rusti on 32-bit hosts", "tree": {"sha": "c3c7cb77c925218e13296898ee43f444800b3e86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3c7cb77c925218e13296898ee43f444800b3e86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c842f1335da821fa08bbf9da9783846ac1905654", "comment_count": 12, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c842f1335da821fa08bbf9da9783846ac1905654", "html_url": "https://github.com/rust-lang/rust/commit/c842f1335da821fa08bbf9da9783846ac1905654", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c842f1335da821fa08bbf9da9783846ac1905654/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "451c94343f2c49cfcc790816fd8587bfdc7ecfb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/451c94343f2c49cfcc790816fd8587bfdc7ecfb8", "html_url": "https://github.com/rust-lang/rust/commit/451c94343f2c49cfcc790816fd8587bfdc7ecfb8"}], "stats": {"total": 674, "additions": 3, "deletions": 671}, "files": [{"sha": "bbc4b9ff719789478a873c570b3e99c6a4bf0a0d", "filename": "src/librusti/rusti.rc", "status": "removed", "additions": 0, "deletions": 667, "changes": 667, "blob_url": "https://github.com/rust-lang/rust/blob/451c94343f2c49cfcc790816fd8587bfdc7ecfb8/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/451c94343f2c49cfcc790816fd8587bfdc7ecfb8/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=451c94343f2c49cfcc790816fd8587bfdc7ecfb8", "patch": "@@ -1,667 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n- * rusti - A REPL using the JIT backend\n- *\n- * Rusti works by serializing state between lines of input. This means that each\n- * line can be run in a separate task, and the only limiting factor is that all\n- * local bound variables are encodable.\n- *\n- * This is accomplished by feeding in generated input to rustc for execution in\n- * the JIT compiler. Currently input actually gets fed in three times to get\n- * information about the program.\n- *\n- * - Pass #1\n- *   In this pass, the input is simply thrown at the parser and the input comes\n- *   back. This validates the structure of the program, and at this stage the\n- *   global items (fns, structs, impls, traits, etc.) are filtered from the\n- *   input into the \"global namespace\". These declarations shadow all previous\n- *   declarations of an item by the same name.\n- *\n- * - Pass #2\n- *   After items have been stripped, the remaining input is passed to rustc\n- *   along with all local variables declared (initialized to nothing). This pass\n- *   runs up to typechecking. From this, we can learn about the types of each\n- *   bound variable, what variables are bound, and also ensure that all the\n- *   types are encodable (the input can actually be run).\n- *\n- * - Pass #3\n- *   Finally, a program is generated to deserialize the local variable state,\n- *   run the code input, and then reserialize all bindings back into a local\n- *   hash map. Once this code runs, the input has fully been run and the REPL\n- *   waits for new input.\n- *\n- * Encoding/decoding is done with EBML, and there is simply a map of ~str ->\n- * ~[u8] maintaining the values of each local binding (by name).\n- */\n-\n-#[link(name = \"rusti\",\n-       vers = \"0.7\",\n-       uuid = \"7fb5bf52-7d45-4fee-8325-5ad3311149fc\",\n-       url = \"https://github.com/mozilla/rust/tree/master/src/rusti\")];\n-\n-#[license = \"MIT/ASL2\"];\n-#[crate_type = \"lib\"];\n-\n-extern mod extra;\n-extern mod rustc;\n-extern mod syntax;\n-\n-use std::{libc, io, os, task, vec};\n-use std::cell::Cell;\n-use extra::rl;\n-\n-use rustc::driver::{driver, session};\n-use syntax::{ast, diagnostic};\n-use syntax::ast_util::*;\n-use syntax::parse::token;\n-use syntax::print::pprust;\n-\n-use program::Program;\n-use utils::*;\n-\n-mod program;\n-pub mod utils;\n-\n-/**\n- * A structure shared across REPL instances for storing history\n- * such as statements and view items. I wish the AST was sendable.\n- */\n-pub struct Repl {\n-    prompt: ~str,\n-    binary: ~str,\n-    running: bool,\n-    lib_search_paths: ~[~str],\n-\n-    program: Program,\n-}\n-\n-// Action to do after reading a :command\n-enum CmdAction {\n-    action_none,\n-    action_run_line(~str),\n-}\n-\n-/// Run an input string in a Repl, returning the new Repl.\n-fn run(mut repl: Repl, input: ~str) -> Repl {\n-    // Build some necessary rustc boilerplate for compiling things\n-    let binary = repl.binary.to_managed();\n-    let options = @session::options {\n-        crate_type: session::unknown_crate,\n-        binary: binary,\n-        addl_lib_search_paths: @mut repl.lib_search_paths.map(|p| Path(*p)),\n-        jit: true,\n-        .. copy *session::basic_options()\n-    };\n-    // Because we assume that everything is encodable (and assert so), add some\n-    // extra helpful information if the error crops up. Otherwise people are\n-    // bound to be very confused when they find out code is running that they\n-    // never typed in...\n-    let sess = driver::build_session(options, |cm, msg, lvl| {\n-        diagnostic::emit(cm, msg, lvl);\n-        if msg.contains(\"failed to find an implementation of trait\") &&\n-           msg.contains(\"extra::serialize::Encodable\") {\n-            diagnostic::emit(cm,\n-                             \"Currrently rusti serializes bound locals between \\\n-                              different lines of input. This means that all \\\n-                              values of local variables need to be encodable, \\\n-                              and this type isn't encodable\",\n-                             diagnostic::note);\n-        }\n-    });\n-    let intr = token::get_ident_interner();\n-\n-    //\n-    // Stage 1: parse the input and filter it into the program (as necessary)\n-    //\n-    debug!(\"parsing: %s\", input);\n-    let crate = parse_input(sess, binary, input);\n-    let mut to_run = ~[];       // statements to run (emitted back into code)\n-    let new_locals = @mut ~[];  // new locals being defined\n-    let mut result = None;      // resultant expression (to print via pp)\n-    do find_main(crate, sess) |blk| {\n-        // Fish out all the view items, be sure to record 'extern mod' items\n-        // differently beause they must appear before all 'use' statements\n-        for blk.node.view_items.iter().advance |vi| {\n-            let s = do with_pp(intr) |pp, _| {\n-                pprust::print_view_item(pp, *vi);\n-            };\n-            match vi.node {\n-                ast::view_item_extern_mod(*) => {\n-                    repl.program.record_extern(s);\n-                }\n-                ast::view_item_use(*) => { repl.program.record_view_item(s); }\n-            }\n-        }\n-\n-        // Iterate through all of the block's statements, inserting them into\n-        // the correct portions of the program\n-        for blk.node.stmts.iter().advance |stmt| {\n-            let s = do with_pp(intr) |pp, _| { pprust::print_stmt(pp, *stmt); };\n-            match stmt.node {\n-                ast::stmt_decl(d, _) => {\n-                    match d.node {\n-                        ast::decl_item(it) => {\n-                            let name = sess.str_of(it.ident);\n-                            match it.node {\n-                                // Structs are treated specially because to make\n-                                // them at all usable they need to be decorated\n-                                // with #[deriving(Encoable, Decodable)]\n-                                ast::item_struct(*) => {\n-                                    repl.program.record_struct(name, s);\n-                                }\n-                                // Item declarations are hoisted out of main()\n-                                _ => { repl.program.record_item(name, s); }\n-                            }\n-                        }\n-\n-                        // Local declarations must be specially dealt with,\n-                        // record all local declarations for use later on\n-                        ast::decl_local(l) => {\n-                            let mutbl = l.node.is_mutbl;\n-                            do each_binding(l) |path, _| {\n-                                let s = do with_pp(intr) |pp, _| {\n-                                    pprust::print_path(pp, path, false);\n-                                };\n-                                new_locals.push((s, mutbl));\n-                            }\n-                            to_run.push(s);\n-                        }\n-                    }\n-                }\n-\n-                // run statements with expressions (they have effects)\n-                ast::stmt_mac(*) | ast::stmt_semi(*) | ast::stmt_expr(*) => {\n-                    to_run.push(s);\n-                }\n-            }\n-        }\n-        result = do blk.node.expr.map_consume |e| {\n-            do with_pp(intr) |pp, _| { pprust::print_expr(pp, e); }\n-        };\n-    }\n-    // return fast for empty inputs\n-    if to_run.len() == 0 && result.is_none() {\n-        return repl;\n-    }\n-\n-    //\n-    // Stage 2: run everything up to typeck to learn the types of the new\n-    //          variables introduced into the program\n-    //\n-    info!(\"Learning about the new types in the program\");\n-    repl.program.set_cache(); // before register_new_vars (which changes them)\n-    let input = to_run.connect(\"\\n\");\n-    let test = repl.program.test_code(input, &result, *new_locals);\n-    debug!(\"testing with ^^^^^^ %?\", (||{ println(test) })());\n-    let dinput = driver::str_input(test.to_managed());\n-    let cfg = driver::build_configuration(sess, binary, &dinput);\n-    let outputs = driver::build_output_filenames(&dinput, &None, &None, [], sess);\n-    let (crate, tcx) = driver::compile_upto(sess, copy cfg, &dinput,\n-                                            driver::cu_typeck, Some(outputs));\n-    // Once we're typechecked, record the types of all local variables defined\n-    // in this input\n-    do find_main(crate.expect(\"crate after cu_typeck\"), sess) |blk| {\n-        repl.program.register_new_vars(blk, tcx.expect(\"tcx after cu_typeck\"));\n-    }\n-\n-    //\n-    // Stage 3: Actually run the code in the JIT\n-    //\n-    info!(\"actually running code\");\n-    let code = repl.program.code(input, &result);\n-    debug!(\"actually running ^^^^^^ %?\", (||{ println(code) })());\n-    let input = driver::str_input(code.to_managed());\n-    let cfg = driver::build_configuration(sess, binary, &input);\n-    let outputs = driver::build_output_filenames(&input, &None, &None, [], sess);\n-    let sess = driver::build_session(options, diagnostic::emit);\n-    driver::compile_upto(sess, cfg, &input, driver::cu_everything,\n-                         Some(outputs));\n-\n-    //\n-    // Stage 4: Inform the program that computation is done so it can update all\n-    //          local variable bindings.\n-    //\n-    info!(\"cleaning up after code\");\n-    repl.program.consume_cache();\n-\n-    return repl;\n-\n-    fn parse_input(sess: session::Session, binary: @str,\n-                   input: &str) -> @ast::crate {\n-        let code = fmt!(\"fn main() {\\n %s \\n}\", input);\n-        let input = driver::str_input(code.to_managed());\n-        let cfg = driver::build_configuration(sess, binary, &input);\n-        let outputs = driver::build_output_filenames(&input, &None, &None, [], sess);\n-        let (crate, _) = driver::compile_upto(sess, cfg, &input,\n-                                              driver::cu_parse, Some(outputs));\n-        crate.expect(\"parsing should return a crate\")\n-    }\n-\n-    fn find_main(crate: @ast::crate, sess: session::Session,\n-                 f: &fn(&ast::blk)) {\n-        for crate.node.module.items.iter().advance |item| {\n-            match item.node {\n-                ast::item_fn(_, _, _, _, ref blk) => {\n-                    if item.ident == sess.ident_of(\"main\") {\n-                        return f(blk);\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n-        fail!(\"main function was expected somewhere...\");\n-    }\n-}\n-\n-// Compiles a crate given by the filename as a library if the compiled\n-// version doesn't exist or is older than the source file. Binary is\n-// the name of the compiling executable. Returns Some(true) if it\n-// successfully compiled, Some(false) if the crate wasn't compiled\n-// because it already exists and is newer than the source file, or\n-// None if there were compile errors.\n-fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n-    match do task::try {\n-        let src_path = Path(src_filename);\n-        let binary = binary.to_managed();\n-        let options = @session::options {\n-            binary: binary,\n-            addl_lib_search_paths: @mut ~[os::getcwd()],\n-            .. copy *session::basic_options()\n-        };\n-        let input = driver::file_input(copy src_path);\n-        let sess = driver::build_session(options, diagnostic::emit);\n-        *sess.building_library = true;\n-        let cfg = driver::build_configuration(sess, binary, &input);\n-        let outputs = driver::build_output_filenames(\n-            &input, &None, &None, [], sess);\n-        // If the library already exists and is newer than the source\n-        // file, skip compilation and return None.\n-        let mut should_compile = true;\n-        let dir = os::list_dir_path(&Path(outputs.out_filename.dirname()));\n-        let maybe_lib_path = do dir.iter().find_ |file| {\n-            // The actual file's name has a hash value and version\n-            // number in it which is unknown at this time, so looking\n-            // for a file that matches out_filename won't work,\n-            // instead we guess which file is the library by matching\n-            // the prefix and suffix of out_filename to files in the\n-            // directory.\n-            let file_str = file.filename().get();\n-            file_str.starts_with(outputs.out_filename.filestem().get())\n-                && file_str.ends_with(outputs.out_filename.filetype().get())\n-        };\n-        match maybe_lib_path {\n-            Some(lib_path) => {\n-                let (src_mtime, _) = src_path.get_mtime().get();\n-                let (lib_mtime, _) = lib_path.get_mtime().get();\n-                if lib_mtime >= src_mtime {\n-                    should_compile = false;\n-                }\n-            },\n-            None => { },\n-        }\n-        if (should_compile) {\n-            println(fmt!(\"compiling %s...\", src_filename));\n-            driver::compile_upto(sess, cfg, &input, driver::cu_everything,\n-                                 Some(outputs));\n-            true\n-        } else { false }\n-    } {\n-        Ok(true) => Some(true),\n-        Ok(false) => Some(false),\n-        Err(_) => None,\n-    }\n-}\n-\n-/// Tries to get a line from rl after outputting a prompt. Returns\n-/// None if no input was read (e.g. EOF was reached).\n-fn get_line(use_rl: bool, prompt: &str) -> Option<~str> {\n-    if use_rl {\n-        let result = unsafe { rl::read(prompt) };\n-\n-        match result {\n-            None => None,\n-            Some(line) => {\n-                unsafe { rl::add_history(line) };\n-                Some(line)\n-            }\n-        }\n-    } else {\n-        if io::stdin().eof() {\n-            None\n-        } else {\n-            Some(io::stdin().read_line())\n-        }\n-    }\n-}\n-\n-/// Run a command, e.g. :clear, :exit, etc.\n-fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n-           cmd: ~str, args: ~[~str], use_rl: bool) -> CmdAction {\n-    let mut action = action_none;\n-    match cmd {\n-        ~\"exit\" => repl.running = false,\n-        ~\"clear\" => {\n-            repl.program.clear();\n-\n-            // XXX: Win32 version of linenoise can't do this\n-            //rl::clear();\n-        }\n-        ~\"help\" => {\n-            println(\n-                \":{\\\\n ..lines.. \\\\n:}\\\\n - execute multiline command\\n\\\n-                 :load <crate> ... - loads given crates as dynamic libraries\\n\\\n-                 :clear - clear the bindings\\n\\\n-                 :exit - exit from the repl\\n\\\n-                 :help - show this message\");\n-        }\n-        ~\"load\" => {\n-            let mut loaded_crates: ~[~str] = ~[];\n-            for args.iter().advance |arg| {\n-                let (crate, filename) =\n-                    if arg.ends_with(\".rs\") || arg.ends_with(\".rc\") {\n-                    (arg.slice_to(arg.len() - 3).to_owned(), copy *arg)\n-                } else {\n-                    (copy *arg, *arg + \".rs\")\n-                };\n-                match compile_crate(filename, copy repl.binary) {\n-                    Some(_) => loaded_crates.push(crate),\n-                    None => { }\n-                }\n-            }\n-            for loaded_crates.iter().advance |crate| {\n-                let crate_path = Path(*crate);\n-                let crate_dir = crate_path.dirname();\n-                repl.program.record_extern(fmt!(\"extern mod %s;\", *crate));\n-                if !repl.lib_search_paths.iter().any_(|x| x == &crate_dir) {\n-                    repl.lib_search_paths.push(crate_dir);\n-                }\n-            }\n-            if loaded_crates.is_empty() {\n-                println(\"no crates loaded\");\n-            } else {\n-                println(fmt!(\"crates loaded: %s\",\n-                                 loaded_crates.connect(\", \")));\n-            }\n-        }\n-        ~\"{\" => {\n-            let mut multiline_cmd = ~\"\";\n-            let mut end_multiline = false;\n-            while (!end_multiline) {\n-                match get_line(use_rl, \"rusti| \") {\n-                    None => fail!(\"unterminated multiline command :{ .. :}\"),\n-                    Some(line) => {\n-                        if line.trim() == \":}\" {\n-                            end_multiline = true;\n-                        } else {\n-                            multiline_cmd.push_str(line);\n-                            multiline_cmd.push_char('\\n');\n-                        }\n-                    }\n-                }\n-            }\n-            action = action_run_line(multiline_cmd);\n-        }\n-        _ => println(~\"unknown cmd: \" + cmd)\n-    }\n-    return action;\n-}\n-\n-/// Executes a line of input, which may either be rust code or a\n-/// :command. Returns a new Repl if it has changed.\n-pub fn run_line(repl: &mut Repl, in: @io::Reader, out: @io::Writer, line: ~str,\n-                use_rl: bool)\n-    -> Option<Repl> {\n-    if line.starts_with(\":\") {\n-        // drop the : and the \\n (one byte each)\n-        let full = line.slice(1, line.len());\n-        let split: ~[~str] = full.word_iter().transform(|s| s.to_owned()).collect();\n-        let len = split.len();\n-\n-        if len > 0 {\n-            let cmd = copy split[0];\n-\n-            if !cmd.is_empty() {\n-                let args = if len > 1 {\n-                    vec::slice(split, 1, len).to_owned()\n-                } else { ~[] };\n-\n-                match run_cmd(repl, in, out, cmd, args, use_rl) {\n-                    action_none => { }\n-                    action_run_line(multiline_cmd) => {\n-                        if !multiline_cmd.is_empty() {\n-                            return run_line(repl, in, out, multiline_cmd, use_rl);\n-                        }\n-                    }\n-                }\n-                return None;\n-            }\n-        }\n-    }\n-\n-    let line = Cell::new(line);\n-    let r = Cell::new(copy *repl);\n-    let result = do task::try {\n-        run(r.take(), line.take())\n-    };\n-\n-    if result.is_ok() {\n-        return Some(result.get());\n-    }\n-    return None;\n-}\n-\n-pub fn main() {\n-    let args = os::args();\n-    let in = io::stdin();\n-    let out = io::stdout();\n-    let mut repl = Repl {\n-        prompt: ~\"rusti> \",\n-        binary: copy args[0],\n-        running: true,\n-        lib_search_paths: ~[],\n-\n-        program: Program::new(),\n-    };\n-\n-    let istty = unsafe { libc::isatty(libc::STDIN_FILENO as i32) } != 0;\n-\n-    // only print this stuff if the user is actually typing into rusti\n-    if istty {\n-        println(\"WARNING: The Rust REPL is experimental and may be\");\n-        println(\"unstable. If you encounter problems, please use the\");\n-        println(\"compiler instead. Type :help for help.\");\n-\n-        unsafe {\n-            do rl::complete |line, suggest| {\n-                if line.starts_with(\":\") {\n-                    suggest(~\":clear\");\n-                    suggest(~\":exit\");\n-                    suggest(~\":help\");\n-                    suggest(~\":load\");\n-                }\n-            }\n-        }\n-    }\n-\n-    while repl.running {\n-        match get_line(istty, repl.prompt) {\n-            None => break,\n-            Some(line) => {\n-                if line.is_empty() {\n-                    if istty {\n-                        println(\"()\");\n-                    }\n-                    loop;\n-                }\n-                match run_line(&mut repl, in, out, line, istty) {\n-                    Some(new_repl) => repl = new_repl,\n-                    None => { }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-//#[cfg(test)]\n-#[cfg(ignore)] // FIXME #7541 doesn't work under cross-compile\n-mod tests {\n-    use std::io;\n-    use std::iterator::IteratorUtil;\n-    use program::Program;\n-    use super::*;\n-\n-    fn repl() -> Repl {\n-        Repl {\n-            prompt: ~\"rusti> \",\n-            binary: ~\"rusti\",\n-            running: true,\n-            lib_search_paths: ~[],\n-            program: Program::new(),\n-        }\n-    }\n-\n-    fn run_program(prog: &str) {\n-        let mut r = repl();\n-        for prog.split_iter('\\n').advance |cmd| {\n-            let result = run_line(&mut r, io::stdin(), io::stdout(),\n-                                  cmd.to_owned(), false);\n-            r = result.expect(fmt!(\"the command '%s' failed\", cmd));\n-        }\n-    }\n-\n-    #[test]\n-    // FIXME: #7220 rusti on 32bit mac doesn't work.\n-    #[cfg(not(target_word_size=\"32\",\n-              target_os=\"macos\"))]\n-    fn run_all() {\n-        // FIXME(#7071):\n-        // By default, unit tests are run in parallel. Rusti, on the other hand,\n-        // does not enjoy doing this. I suspect that it is because the LLVM\n-        // bindings are not thread-safe (when running parallel tests, some tests\n-        // were triggering assertions in LLVM (or segfaults). Hence, this\n-        // function exists to run everything serially (sadface).\n-        //\n-        // To get some interesting output, run with RUST_LOG=rusti::tests\n-\n-        debug!(\"hopefully this runs\");\n-        run_program(\"\");\n-\n-        debug!(\"regression test for #5937\");\n-        run_program(\"use std::hashmap;\");\n-\n-        debug!(\"regression test for #5784\");\n-        run_program(\"let a = 3;\");\n-\n-        // XXX: can't spawn new tasks because the JIT code is cleaned up\n-        //      after the main function is done.\n-        // debug!(\"regression test for #5803\");\n-        // run_program(\"\n-        //     spawn( || println(\\\"Please don't segfault\\\") );\n-        //     do spawn { println(\\\"Please?\\\"); }\n-        // \");\n-\n-        debug!(\"inferred integers are usable\");\n-        run_program(\"let a = 2;\\n()\\n\");\n-        run_program(\"\n-            let a = 3;\n-            let b = 4u;\n-            assert!((a as uint) + b == 7)\n-        \");\n-\n-        debug!(\"local variables can be shadowed\");\n-        run_program(\"\n-            let a = 3;\n-            let a = 5;\n-            assert!(a == 5)\n-        \");\n-\n-        debug!(\"strings are usable\");\n-        run_program(\"\n-            let a = ~\\\"\\\";\n-            let b = \\\"\\\";\n-            let c = @\\\"\\\";\n-            let d = a + b + c;\n-            assert!(d.len() == 0);\n-        \");\n-\n-        debug!(\"vectors are usable\");\n-        run_program(\"\n-            let a = ~[1, 2, 3];\n-            let b = &[1, 2, 3];\n-            let c = @[1, 2, 3];\n-            let d = a + b + c;\n-            assert!(d.len() == 9);\n-            let e: &[int] = [];\n-        \");\n-\n-        debug!(\"structs are usable\");\n-        run_program(\"\n-            struct A{ a: int }\n-            let b = A{ a: 3 };\n-            assert!(b.a == 3)\n-        \");\n-\n-        debug!(\"mutable variables\");\n-        run_program(\"\n-            let mut a = 3;\n-            a = 5;\n-            let mut b = std::hashmap::HashSet::new::<int>();\n-            b.insert(a);\n-            assert!(b.contains(&5))\n-            assert!(b.len() == 1)\n-        \");\n-\n-        debug!(\"functions are cached\");\n-        run_program(\"\n-            fn fib(x: int) -> int { if x < 2 {x} else { fib(x - 1) + fib(x - 2) } }\n-            let a = fib(3);\n-            let a = a + fib(4);\n-            assert!(a == 5)\n-        \");\n-\n-        debug!(\"modules are cached\");\n-        run_program(\"\n-            mod b { pub fn foo() -> uint { 3 } }\n-            assert!(b::foo() == 3)\n-        \");\n-\n-        debug!(\"multiple function definitions are allowed\");\n-        run_program(\"\n-            fn f() {}\n-            fn f() {}\n-            f()\n-        \");\n-\n-        debug!(\"multiple item definitions are allowed\");\n-        run_program(\"\n-            fn f() {}\n-            mod f {}\n-            struct f;\n-            enum f {}\n-            fn f() {}\n-            f()\n-        \");\n-    }\n-\n-    #[test]\n-    // FIXME: #7220 rusti on 32bit mac doesn't work.\n-    #[cfg(not(target_word_size=\"32\",\n-              target_os=\"macos\"))]\n-    fn exit_quits() {\n-        let mut r = repl();\n-        assert!(r.running);\n-        let result = run_line(&mut r, io::stdin(), io::stdout(),\n-                              ~\":exit\", false);\n-        assert!(result.is_none());\n-        assert!(!r.running);\n-    }\n-}"}, {"sha": "bdbbcfc2b665ee9c891e7f92b45cec1cf25166ed", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c842f1335da821fa08bbf9da9783846ac1905654/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c842f1335da821fa08bbf9da9783846ac1905654/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=c842f1335da821fa08bbf9da9783846ac1905654", "patch": "@@ -511,8 +511,7 @@ pub fn main() {\n     }\n }\n \n-//#[cfg(test)]\n-#[cfg(ignore)] // FIXME #7541 doesn't work under cross-compile\n+#[cfg(test)]\n mod tests {\n     use std::io;\n     use std::iterator::IteratorUtil;\n@@ -530,8 +529,8 @@ mod tests {\n     }\n \n     // FIXME: #7220 rusti on 32bit mac doesn't work.\n+    // FIXME: #7641 rusti on 32bit linux cross compile doesn't work\n     #[cfg(not(target_word_size=\"32\"))]\n-    #[cfg(not(target_os=\"macos\"))]\n     fn run_program(prog: &str) {\n         let mut r = repl();\n         for prog.split_iter('\\n').advance |cmd| {\n@@ -540,7 +539,7 @@ mod tests {\n             r = result.expect(fmt!(\"the command '%s' failed\", cmd));\n         }\n     }\n-    #[cfg(target_word_size=\"32\", target_os=\"macos\")]\n+    #[cfg(target_word_size=\"32\")]\n     fn run_program(_: &str) {}\n \n     #[test]"}]}