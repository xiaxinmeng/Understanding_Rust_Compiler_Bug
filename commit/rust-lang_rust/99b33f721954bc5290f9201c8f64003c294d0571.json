{"sha": "99b33f721954bc5290f9201c8f64003c294d0571", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5YjMzZjcyMTk1NGJjNTI5MGY5MjAxYzhmNjQwMDNjMjk0ZDA1NzE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-07-02T19:47:32Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-07-17T21:57:51Z"}, "message": "librustc: Remove all uses of \"copy\".", "tree": {"sha": "786c9bf75d54512d0a80f6975ad40516ab432c3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/786c9bf75d54512d0a80f6975ad40516ab432c3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99b33f721954bc5290f9201c8f64003c294d0571", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99b33f721954bc5290f9201c8f64003c294d0571", "html_url": "https://github.com/rust-lang/rust/commit/99b33f721954bc5290f9201c8f64003c294d0571", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99b33f721954bc5290f9201c8f64003c294d0571/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "html_url": "https://github.com/rust-lang/rust/commit/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32"}], "stats": {"total": 5786, "additions": 3186, "deletions": 2600}, "files": [{"sha": "76e3f2f32ee77090bf8dff3f9e00f813c6d1361f", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -117,9 +117,11 @@ pub fn parse_config(args: ~[~str]) -> config {\n         mode: str_mode(getopts::opt_str(matches, \"mode\")),\n         run_ignored: getopts::opt_present(matches, \"ignored\"),\n         filter:\n-             if !matches.free.is_empty() {\n-                 Some(copy matches.free[0])\n-             } else { None },\n+            if !matches.free.is_empty() {\n+                 Some(matches.free[0].clone())\n+            } else {\n+                None\n+            },\n         logfile: getopts::opt_maybe_str(matches, \"logfile\").map(|s| Path(*s)),\n         save_metrics: getopts::opt_maybe_str(matches, \"save-metrics\").map(|s| Path(*s)),\n         ratchet_metrics:\n@@ -223,9 +225,9 @@ pub fn run_tests(config: &config) {\n \n pub fn test_opts(config: &config) -> test::TestOpts {\n     test::TestOpts {\n-        filter: copy config.filter,\n+        filter: config.filter.clone(),\n         run_ignored: config.run_ignored,\n-        logfile: copy config.logfile,\n+        logfile: config.logfile.clone(),\n         run_tests: true,\n         run_benchmarks: true,\n         ratchet_metrics: copy config.ratchet_metrics,\n@@ -240,7 +242,7 @@ pub fn make_tests(config: &config) -> ~[test::TestDescAndFn] {\n     let mut tests = ~[];\n     let dirs = os::list_dir_path(&config.src_base);\n     for dirs.iter().advance |file| {\n-        let file = copy *file;\n+        let file = (*file).clone();\n         debug!(\"inspecting file %s\", file.to_str());\n         if is_test(config, file) {\n             let t = do make_test(config, file) {\n@@ -306,7 +308,7 @@ pub fn make_test_name(config: &config, testfile: &Path) -> test::TestName {\n \n pub fn make_test_closure(config: &config, testfile: &Path) -> test::TestFn {\n     use std::cell::Cell;\n-    let config = Cell::new(copy *config);\n+    let config = Cell::new((*config).clone());\n     let testfile = Cell::new(testfile.to_str());\n     test::DynTestFn(|| { runtest::run(config.take(), testfile.take()) })\n }"}, {"sha": "ac87eabc0fddba056858d143d3fc6d2444eda4aa", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -22,7 +22,7 @@ fn target_env(lib_path: &str, prog: &str) -> ~[(~str,~str)] {\n     let aux_path = prog.slice(0u, prog.len() - 4u).to_owned() + \".libaux\";\n \n     env = do env.map() |pair| {\n-        let (k,v) = copy *pair;\n+        let (k,v) = (*pair).clone();\n         if k == ~\"PATH\" { (~\"PATH\", v + \";\" + lib_path + \";\" + aux_path) }\n         else { (k,v) }\n     };"}, {"sha": "f071c204810f0fdaee6d5783e83eea8271fd5031", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -150,7 +150,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     let mut round = 0;\n     while round < rounds {\n         logv(config, fmt!(\"pretty-printing round %d\", round));\n-        let ProcRes = print_source(config, testfile, copy srcs[round]);\n+        let ProcRes = print_source(config, testfile, srcs[round].clone());\n \n         if ProcRes.status != 0 {\n             fatal_ProcRes(fmt!(\"pretty-printing failed in round %d\", round),\n@@ -168,9 +168,9 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n             let filepath = testfile.dir_path().push_rel(file);\n             io::read_whole_file_str(&filepath).get()\n           }\n-          None => { copy srcs[srcs.len() - 2u] }\n+          None => { srcs[srcs.len() - 2u].clone() }\n         };\n-    let mut actual = copy srcs[srcs.len() - 1u];\n+    let mut actual = srcs[srcs.len() - 1u].clone();\n \n     if props.pp_exact.is_some() {\n         // Now we have to care about line endings\n@@ -243,13 +243,13 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n     let mut config = match config.rustcflags {\n         Some(ref flags) => config {\n             rustcflags: Some(flags.replace(\"-O\", \"\")),\n-            .. copy *config\n+            .. (*config).clone()\n         },\n-        None => copy *config\n+        None => (*config).clone()\n     };\n     let config = &mut config;\n     let cmds = props.debugger_cmds.connect(\"\\n\");\n-    let check_lines = copy props.check_lines;\n+    let check_lines = props.check_lines.clone();\n \n     // compile test file (it shoud have 'compile-flags:-g' in the header)\n     let mut ProcRes = compile_test(config, props, testfile);\n@@ -498,7 +498,7 @@ fn exec_compiled_test(config: &config, props: &TestProps,\n                       testfile: &Path) -> ProcRes {\n \n     // If testing the new runtime then set the RUST_NEWRT env var\n-    let env = copy props.exec_env;\n+    let env = props.exec_env.clone();\n     let env = if config.newrt { env + &[(~\"RUST_NEWRT\", ~\"1\")] } else { env };\n \n     match config.target {\n@@ -742,7 +742,7 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n \n     // copy to target\n     let copy_result = procsrv::run(\"\", config.adb_path,\n-        [~\"push\", copy args.prog, copy config.adb_test_dir],\n+        [~\"push\", args.prog.clone(), config.adb_test_dir.clone()],\n         ~[(~\"\",~\"\")], Some(~\"\"));\n \n     if config.verbose {\n@@ -832,7 +832,7 @@ fn _arm_push_aux_shared_library(config: &config, testfile: &Path) {\n         if (file.filetype() == Some(~\".so\")) {\n \n             let copy_result = procsrv::run(\"\", config.adb_path,\n-                [~\"push\", file.to_str(), copy config.adb_test_dir],\n+                [~\"push\", file.to_str(), config.adb_test_dir.clone()],\n                 ~[(~\"\",~\"\")], Some(~\"\"));\n \n             if config.verbose {"}, {"sha": "054b4ce5177d53f64244f32e89c684881fdd3c16", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -534,7 +534,7 @@ mod tests {\n \n             let arc_v : ARC<~[int]> = p.recv();\n \n-            let v = copy (*arc_v.get());\n+            let v = (*arc_v.get()).clone();\n             assert_eq!(v[3], 4);\n         };\n "}, {"sha": "449a9aba4a7af95b2e2d57bda49f417977b0f4ab", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -211,14 +211,14 @@ impl<'self> FromBase64 for &'self [u8] {\n             let val = byte as u32;\n \n             match ch {\n-                'A'..'Z'  => buf |= val - 0x41,\n-                'a'..'z'  => buf |= val - 0x47,\n-                '0'..'9'  => buf |= val + 0x04,\n-                '+'|'-'   => buf |= 0x3E,\n-                '/'|'_'   => buf |= 0x3F,\n+                'A'..'Z' => buf |= val - 0x41,\n+                'a'..'z' => buf |= val - 0x47,\n+                '0'..'9' => buf |= val + 0x04,\n+                '+'|'-' => buf |= 0x3E,\n+                '/'|'_' => buf |= 0x3F,\n                 '\\r'|'\\n' => loop,\n-                '='       => break,\n-                _         => return Err(~\"Invalid Base64 character\")\n+                '=' => break,\n+                _ => return Err(~\"Invalid Base64 character\")\n             }\n \n             buf <<= 6;"}, {"sha": "f3f0f42125d4513a82b191959a745cf9571f2897", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -266,7 +266,7 @@ impl Bitv {\n         else {\n             let nelems = nbits/uint::bits +\n                          if nbits % uint::bits == 0 {0} else {1};\n-            let elem = if init {!0} else {0};\n+            let elem = if init {!0u} else {0u};\n             let s = vec::from_elem(nelems, elem);\n             Big(~BigBitv::new(s))\n         };\n@@ -518,7 +518,7 @@ impl Clone for Bitv {\n             Bitv{nbits: self.nbits, rep: Small(~SmallBitv{bits: b.bits})}\n           }\n           Big(ref b) => {\n-            let mut st = vec::from_elem(self.nbits / uint::bits + 1, 0);\n+            let mut st = vec::from_elem(self.nbits / uint::bits + 1, 0u);\n             let len = st.len();\n             for uint::range(0, len) |i| { st[i] = b.storage[i]; };\n             Bitv{nbits: self.nbits, rep: Big(~BigBitv{storage: st})}"}, {"sha": "f72d3ee694fded47ae43f426408bbeba277a3c93", "filename": "src/libextra/c_vec.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fc_vec.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -119,17 +119,19 @@ pub unsafe fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: @fn())\n  *\n  * Fails if `ofs` is greater or equal to the length of the vector\n  */\n-pub fn get<T:Copy>(t: CVec<T>, ofs: uint) -> T {\n+pub fn get<T:Clone>(t: CVec<T>, ofs: uint) -> T {\n     assert!(ofs < len(t));\n-    return unsafe { copy *ptr::mut_offset(t.base, ofs) };\n+    return unsafe {\n+        (*ptr::mut_offset(t.base, ofs)).clone()\n+    };\n }\n \n /**\n  * Sets the value of an element at a given index\n  *\n  * Fails if `ofs` is greater or equal to the length of the vector\n  */\n-pub fn set<T:Copy>(t: CVec<T>, ofs: uint, v: T) {\n+pub fn set<T>(t: CVec<T>, ofs: uint, v: T) {\n     assert!(ofs < len(t));\n     unsafe { *ptr::mut_offset(t.base, ofs) = v };\n }"}, {"sha": "840b412757709ee1d1b0519da5437d8b6defa635", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -609,8 +609,8 @@ mod tests {\n     }\n \n     #[cfg(test)]\n-    fn list_from<T: Copy>(v: &[T]) -> DList<T> {\n-        v.iter().transform(|x| copy *x).collect()\n+    fn list_from<T: Clone>(v: &[T]) -> DList<T> {\n+        v.iter().transform(|x| (*x).clone()).collect()\n     }\n \n     #[test]"}, {"sha": "c9b0cbb27532c50aa61cc909a8e51f8d4ed67ec7", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -29,6 +29,7 @@ struct EbmlState {\n     data_pos: uint,\n }\n \n+#[deriving(Clone)]\n pub struct Doc {\n     data: @~[u8],\n     start: uint,\n@@ -615,6 +616,7 @@ pub mod writer {\n     use super::*;\n \n     use std::cast;\n+    use std::clone::Clone;\n     use std::io;\n \n     // ebml writing\n@@ -623,6 +625,15 @@ pub mod writer {\n         priv size_positions: ~[uint],\n     }\n \n+    impl Clone for Encoder {\n+        fn clone(&self) -> Encoder {\n+            Encoder {\n+                writer: self.writer,\n+                size_positions: self.size_positions.clone(),\n+            }\n+        }\n+    }\n+\n     fn write_sized_vuint(w: @io::Writer, n: uint, size: uint) {\n         match size {\n             1u => w.write(&[0x80u8 | (n as u8)]),"}, {"sha": "cc87809ad5b716d1faa21e0e1d3c3e2d162fbf70", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -107,6 +107,7 @@ and `line_num_file` represent the number of lines read in total and in\n the current file respectively. `current_path` is `None` if the current\n file is `stdin`.\n */\n+#[deriving(Clone)]\n pub struct FileInputState {\n     current_path: Option<Path>,\n     line_num: uint,\n@@ -223,7 +224,7 @@ impl FileInput {\n         let path_option = self.fi.files.shift();\n         let file = match path_option {\n             None => io::stdin(),\n-            Some(ref path) => io::file_reader(path).get()\n+            Some(ref path) => io::file_reader(path).unwrap()\n         };\n \n         self.fi.current_reader = Some(file);\n@@ -259,15 +260,15 @@ impl FileInput {\n     */\n     pub fn each_line_state(&self,\n                             f: &fn(&str, FileInputState) -> bool) -> bool {\n-         self.each_line(|line| f(line, copy self.fi.state))\n+         self.each_line(|line| f(line, self.fi.state.clone()))\n     }\n \n \n     /**\n     Retrieve the current `FileInputState` information.\n     */\n     pub fn state(&self) -> FileInputState {\n-        copy self.fi.state\n+        self.fi.state.clone()\n     }\n }\n \n@@ -431,7 +432,7 @@ mod test {\n         let paths = ~[Some(Path(\"some/path\")),\n                       Some(Path(\"some/other/path\"))];\n \n-        assert_eq!(pathify(strs, true), copy paths);\n+        assert_eq!(pathify(strs, true), paths.clone());\n         assert_eq!(pathify(strs, false), paths);\n \n         assert_eq!(pathify([~\"-\"], true), ~[None]);\n@@ -449,7 +450,7 @@ mod test {\n             make_file(filename.get_ref(), [fmt!(\"%u\", i)]);\n         }\n \n-        let fi = FileInput::from_vec(copy filenames);\n+        let fi = FileInput::from_vec(filenames.clone());\n \n         for \"012\".iter().enumerate().advance |(line, c)| {\n             assert_eq!(fi.read_byte(), c as int);\n@@ -459,7 +460,7 @@ mod test {\n             assert_eq!(fi.state().line_num, line + 1);\n             assert_eq!(fi.state().line_num_file, 1);\n \n-            assert_eq!(copy fi.state().current_path, copy filenames[line]);\n+            assert_eq!(fi.state().current_path.clone(), filenames[line].clone());\n         }\n \n         assert_eq!(fi.read_byte(), -1);\n@@ -542,13 +543,13 @@ mod test {\n         make_file(filenames[2].get_ref(), [~\"3\", ~\"4\"]);\n \n         let mut count = 0;\n-        for input_vec_state(copy filenames) |line, state| {\n+        for input_vec_state(filenames.clone()) |line, state| {\n             let expected_path = match line {\n-                \"1\" | \"2\" => copy filenames[0],\n-                \"3\" | \"4\" => copy filenames[2],\n+                \"1\" | \"2\" => filenames[0].clone(),\n+                \"3\" | \"4\" => filenames[2].clone(),\n                 _ => fail!(\"unexpected line\")\n             };\n-            assert_eq!(copy state.current_path, expected_path);\n+            assert_eq!(state.current_path.clone(), expected_path);\n             count += 1;\n         }\n         assert_eq!(count, 4);"}, {"sha": "5a5aacc8d540940ac57bd92282673f5baa1b217d", "filename": "src/libextra/flatpipes.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflatpipes.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -164,8 +164,8 @@ Constructors for flat pipes that send POD types using memcpy.\n \n # Safety Note\n \n-This module is currently unsafe because it uses `Copy Send` as a type\n-parameter bounds meaning POD (plain old data), but `Copy Send` and\n+This module is currently unsafe because it uses `Clone + Send` as a type\n+parameter bounds meaning POD (plain old data), but `Clone + Send` and\n POD are not equivelant.\n \n */\n@@ -188,7 +188,7 @@ pub mod pod {\n     pub type PipeChan<T> = FlatChan<T, PodFlattener<T>, PipeByteChan>;\n \n     /// Create a `FlatPort` from a `Reader`\n-    pub fn reader_port<T:Copy + Send,R:Reader>(\n+    pub fn reader_port<T:Clone + Send,R:Reader>(\n         reader: R\n     ) -> ReaderPort<T, R> {\n         let unflat: PodUnflattener<T> = PodUnflattener::new();\n@@ -197,7 +197,7 @@ pub mod pod {\n     }\n \n     /// Create a `FlatChan` from a `Writer`\n-    pub fn writer_chan<T:Copy + Send,W:Writer>(\n+    pub fn writer_chan<T:Clone + Send,W:Writer>(\n         writer: W\n     ) -> WriterChan<T, W> {\n         let flat: PodFlattener<T> = PodFlattener::new();\n@@ -206,21 +206,21 @@ pub mod pod {\n     }\n \n     /// Create a `FlatPort` from a `Port<~[u8]>`\n-    pub fn pipe_port<T:Copy + Send>(port: Port<~[u8]>) -> PipePort<T> {\n+    pub fn pipe_port<T:Clone + Send>(port: Port<~[u8]>) -> PipePort<T> {\n         let unflat: PodUnflattener<T> = PodUnflattener::new();\n         let byte_port = PipeBytePort::new(port);\n         FlatPort::new(unflat, byte_port)\n     }\n \n     /// Create a `FlatChan` from a `Chan<~[u8]>`\n-    pub fn pipe_chan<T:Copy + Send>(chan: Chan<~[u8]>) -> PipeChan<T> {\n+    pub fn pipe_chan<T:Clone + Send>(chan: Chan<~[u8]>) -> PipeChan<T> {\n         let flat: PodFlattener<T> = PodFlattener::new();\n         let byte_chan = PipeByteChan::new(chan);\n         FlatChan::new(flat, byte_chan)\n     }\n \n     /// Create a pair of `FlatChan` and `FlatPort`, backed by pipes\n-    pub fn pipe_stream<T:Copy + Send>() -> (PipePort<T>, PipeChan<T>) {\n+    pub fn pipe_stream<T:Clone + Send>() -> (PipePort<T>, PipeChan<T>) {\n         let (port, chan) = comm::stream();\n         return (pipe_port(port), pipe_chan(chan));\n     }\n@@ -348,7 +348,7 @@ pub mod flatteners {\n     use std::sys::size_of;\n     use std::vec;\n \n-    // FIXME #4074: Copy + Send != POD\n+    // FIXME #4074: Clone + Send != POD\n     pub struct PodUnflattener<T> {\n         bogus: ()\n     }\n@@ -357,17 +357,17 @@ pub mod flatteners {\n         bogus: ()\n     }\n \n-    impl<T:Copy + Send> Unflattener<T> for PodUnflattener<T> {\n+    impl<T:Clone + Send> Unflattener<T> for PodUnflattener<T> {\n         fn unflatten(&self, buf: ~[u8]) -> T {\n             assert!(size_of::<T>() != 0);\n             assert_eq!(size_of::<T>(), buf.len());\n             let addr_of_init: &u8 = unsafe { &*vec::raw::to_ptr(buf) };\n             let addr_of_value: &T = unsafe { cast::transmute(addr_of_init) };\n-            copy *addr_of_value\n+            (*addr_of_value).clone()\n         }\n     }\n \n-    impl<T:Copy + Send> Flattener<T> for PodFlattener<T> {\n+    impl<T:Clone + Send> Flattener<T> for PodFlattener<T> {\n         fn flatten(&self, val: T) -> ~[u8] {\n             assert!(size_of::<T>() != 0);\n             let val: *T = ptr::to_unsafe_ptr(&val);\n@@ -376,15 +376,15 @@ pub mod flatteners {\n         }\n     }\n \n-    impl<T:Copy + Send> PodUnflattener<T> {\n+    impl<T:Clone + Send> PodUnflattener<T> {\n         pub fn new() -> PodUnflattener<T> {\n             PodUnflattener {\n                 bogus: ()\n             }\n         }\n     }\n \n-    impl<T:Copy + Send> PodFlattener<T> {\n+    impl<T:Clone + Send> PodFlattener<T> {\n         pub fn new() -> PodFlattener<T> {\n             PodFlattener {\n                 bogus: ()\n@@ -655,7 +655,7 @@ mod test {\n \n         chan.send(10);\n \n-        let bytes = copy *chan.byte_chan.writer.bytes;\n+        let bytes = (*chan.byte_chan.writer.bytes).clone();\n \n         let reader = BufReader::new(bytes);\n         let port = serial::reader_port(reader);\n@@ -703,7 +703,7 @@ mod test {\n \n         chan.send(10);\n \n-        let bytes = copy *chan.byte_chan.writer.bytes;\n+        let bytes = (*chan.byte_chan.writer.bytes).clone();\n \n         let reader = BufReader::new(bytes);\n         let port = pod::reader_port(reader);\n@@ -785,13 +785,13 @@ mod test {\n         let accept_chan = Cell::new(accept_chan);\n \n         // The server task\n-        let addr = copy addr0;\n+        let addr = addr0.clone();\n         do task::spawn || {\n             let iotask = &uv::global_loop::get();\n             let begin_connect_chan = begin_connect_chan.take();\n             let accept_chan = accept_chan.take();\n             let listen_res = do tcp::listen(\n-                copy addr, port, 128, iotask, |_kill_ch| {\n+                addr.clone(), port, 128, iotask, |_kill_ch| {\n                     // Tell the sender to initiate the connection\n                     debug!(\"listening\");\n                     begin_connect_chan.send(())\n@@ -811,14 +811,14 @@ mod test {\n         }\n \n         // Client task\n-        let addr = copy addr0;\n+        let addr = addr0.clone();\n         do task::spawn || {\n             // Wait for the server to start listening\n             begin_connect_port.recv();\n \n             debug!(\"connecting\");\n             let iotask = &uv::global_loop::get();\n-            let connect_result = tcp::connect(copy addr, port, iotask);\n+            let connect_result = tcp::connect(addr.clone(), port, iotask);\n             assert!(connect_result.is_ok());\n             let sock = result::unwrap(connect_result);\n             let socket_buf: tcp::TcpSocketBuf = tcp::socket_buf(sock);"}, {"sha": "7074d76536a35829d5da352928a0bedf5ffa6ccc", "filename": "src/libextra/fun_treemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffun_treemap.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -46,19 +46,19 @@ pub fn insert<K:Eq + Ord,V>(m: Treemap<K, V>, k: K, v: V) -> Treemap<K, V> {\n }\n \n /// Find a value based on the key\n-pub fn find<K:Eq + Ord,V:Copy>(m: Treemap<K, V>, k: K) -> Option<V> {\n+pub fn find<K:Eq + Ord,V:Clone>(m: Treemap<K, V>, k: K) -> Option<V> {\n     match *m {\n         Empty => None,\n         Node(kk, v, left, right) => cond!(\n-            (k == *kk) { Some(copy *v)  }\n+            (k == *kk) { Some((*v).clone()) }\n             (k <  *kk) { find(left, k)  }\n             _          { find(right, k) }\n         )\n     }\n }\n \n /// Visit all pairs in the map in order.\n-pub fn traverse<K, V: Copy>(m: Treemap<K, V>, f: &fn(&K, &V)) {\n+pub fn traverse<K, V>(m: Treemap<K, V>, f: &fn(&K, &V)) {\n     match *m {\n         Empty => (),\n         // Previously, this had what looked like redundant"}, {"sha": "667f136276fb7a1eaef07e6a899e34773147cd68", "filename": "src/libextra/future.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -53,10 +53,10 @@ priv enum FutureState<A> {\n }\n \n /// Methods on the `future` type\n-impl<A:Copy> Future<A> {\n+impl<A:Clone> Future<A> {\n     pub fn get(&mut self) -> A {\n         //! Get the value of the future.\n-        copy *(self.get_ref())\n+        (*(self.get_ref())).clone()\n     }\n }\n "}, {"sha": "07a1c6744040e5dc6589d31d99217f5d3ee99f7f", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 42, "deletions": 31, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -52,7 +52,7 @@\n  *    fn main() {\n  *        let args = os::args();\n  *\n- *        let program = copy args[0];\n+ *        let program = args[0].clone();\n  *\n  *        let opts = ~[\n  *            optopt(\"o\"),\n@@ -69,7 +69,7 @@\n  *        }\n  *        let output = opt_maybe_str(&matches, \"o\");\n  *        let input: &str = if !matches.free.is_empty() {\n- *            copy matches.free[0]\n+ *            matches.free[0].clone()\n  *        } else {\n  *            print_usage(program, opts);\n  *            return;\n@@ -89,20 +89,28 @@ use std::option::{Some, None};\n use std::str;\n use std::vec;\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub enum Name {\n     Long(~str),\n     Short(char),\n }\n \n-#[deriving(Eq)]\n-pub enum HasArg { Yes, No, Maybe, }\n+#[deriving(Clone, Eq)]\n+pub enum HasArg {\n+    Yes,\n+    No,\n+    Maybe,\n+}\n \n-#[deriving(Eq)]\n-pub enum Occur { Req, Optional, Multi, }\n+#[deriving(Clone, Eq)]\n+pub enum Occur {\n+    Req,\n+    Optional,\n+    Multi,\n+}\n \n /// A description of a possible option\n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub struct Opt {\n     name: Name,\n     hasarg: HasArg,\n@@ -150,14 +158,17 @@ pub fn optmulti(name: &str) -> Opt {\n     return Opt {name: mkname(name), hasarg: Yes, occur: Multi};\n }\n \n-#[deriving(Eq)]\n-enum Optval { Val(~str), Given, }\n+#[deriving(Clone, Eq)]\n+enum Optval {\n+    Val(~str),\n+    Given,\n+}\n \n /**\n  * The result of checking command line arguments. Contains a vector\n  * of matches and a vector of free strings.\n  */\n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub struct Matches {\n     opts: ~[Opt],\n     vals: ~[~[Optval]],\n@@ -171,7 +182,7 @@ fn is_arg(arg: &str) -> bool {\n fn name_str(nm: &Name) -> ~str {\n     return match *nm {\n       Short(ch) => str::from_char(ch),\n-      Long(ref s) => copy *s\n+      Long(ref s) => (*s).clone()\n     };\n }\n \n@@ -183,7 +194,7 @@ fn find_opt(opts: &[Opt], nm: Name) -> Option<uint> {\n  * The type returned when the command line does not conform to the\n  * expected format. Pass this value to <fail_str> to get an error message.\n  */\n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub enum Fail_ {\n     ArgumentMissing(~str),\n     UnrecognizedOption(~str),\n@@ -234,13 +245,13 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n     let l = args.len();\n     let mut i = 0;\n     while i < l {\n-        let cur = copy args[i];\n+        let cur = args[i].clone();\n         let curlen = cur.len();\n         if !is_arg(cur) {\n             free.push(cur);\n         } else if cur == ~\"--\" {\n             let mut j = i + 1;\n-            while j < l { free.push(copy args[j]); j += 1; }\n+            while j < l { free.push(args[j].clone()); j += 1; }\n             break;\n         } else {\n             let mut names;\n@@ -270,7 +281,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n                        interpreted correctly\n                     */\n \n-                    match find_opt(opts, copy opt) {\n+                    match find_opt(opts, opt.clone()) {\n                       Some(id) => last_valid_opt_id = Some(id),\n                       None => {\n                         let arg_follows =\n@@ -296,7 +307,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n             let mut name_pos = 0;\n             for names.iter().advance() |nm| {\n                 name_pos += 1;\n-                let optid = match find_opt(opts, copy *nm) {\n+                let optid = match find_opt(opts, (*nm).clone()) {\n                   Some(id) => id,\n                   None => return Err(UnrecognizedOption(name_str(nm)))\n                 };\n@@ -309,18 +320,18 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n                   }\n                   Maybe => {\n                     if !i_arg.is_none() {\n-                        vals[optid].push(Val((copy i_arg).get()));\n+                        vals[optid].push(Val((i_arg.clone()).get()));\n                     } else if name_pos < names.len() ||\n                                   i + 1 == l || is_arg(args[i + 1]) {\n                         vals[optid].push(Given);\n-                    } else { i += 1; vals[optid].push(Val(copy args[i])); }\n+                    } else { i += 1; vals[optid].push(Val(args[i].clone())); }\n                   }\n                   Yes => {\n                     if !i_arg.is_none() {\n-                        vals[optid].push(Val((copy i_arg).get()));\n+                        vals[optid].push(Val(i_arg.clone().get()));\n                     } else if i + 1 == l {\n                         return Err(ArgumentMissing(name_str(nm)));\n-                    } else { i += 1; vals[optid].push(Val(copy args[i])); }\n+                    } else { i += 1; vals[optid].push(Val(args[i].clone())); }\n                   }\n                 }\n             }\n@@ -350,15 +361,15 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n \n fn opt_vals(mm: &Matches, nm: &str) -> ~[Optval] {\n     return match find_opt(mm.opts, mkname(nm)) {\n-      Some(id) => copy mm.vals[id],\n+      Some(id) => mm.vals[id].clone(),\n       None => {\n         error!(\"No option '%s' defined\", nm);\n         fail!()\n       }\n     };\n }\n \n-fn opt_val(mm: &Matches, nm: &str) -> Optval { copy opt_vals(mm, nm)[0] }\n+fn opt_val(mm: &Matches, nm: &str) -> Optval { opt_vals(mm, nm)[0].clone() }\n \n /// Returns true if an option was matched\n pub fn opt_present(mm: &Matches, nm: &str) -> bool {\n@@ -401,7 +412,7 @@ pub fn opt_str(mm: &Matches, nm: &str) -> ~str {\n pub fn opts_str(mm: &Matches, names: &[~str]) -> ~str {\n     for names.iter().advance |nm| {\n         match opt_val(mm, *nm) {\n-          Val(ref s) => return copy *s,\n+          Val(ref s) => return (*s).clone(),\n           _ => ()\n         }\n     }\n@@ -419,7 +430,7 @@ pub fn opt_strs(mm: &Matches, nm: &str) -> ~[~str] {\n     let mut acc: ~[~str] = ~[];\n     let r = opt_vals(mm, nm);\n     for r.iter().advance |v| {\n-        match *v { Val(ref s) => acc.push(copy *s), _ => () }\n+        match *v { Val(ref s) => acc.push((*s).clone()), _ => () }\n     }\n     acc\n }\n@@ -429,7 +440,7 @@ pub fn opt_maybe_str(mm: &Matches, nm: &str) -> Option<~str> {\n     let vals = opt_vals(mm, nm);\n     if vals.is_empty() { return None::<~str>; }\n     return match vals[0] {\n-        Val(ref s) => Some(copy *s),\n+        Val(ref s) => Some((*s).clone()),\n         _ => None\n     };\n }\n@@ -445,7 +456,7 @@ pub fn opt_maybe_str(mm: &Matches, nm: &str) -> Option<~str> {\n pub fn opt_default(mm: &Matches, nm: &str, def: &str) -> Option<~str> {\n     let vals = opt_vals(mm, nm);\n     if vals.is_empty() { return None::<~str>; }\n-    return match vals[0] { Val(ref s) => Some::<~str>(copy *s),\n+    return match vals[0] { Val(ref s) => Some::<~str>((*s).clone()),\n                            _      => Some::<~str>(str::to_owned(def)) }\n }\n \n@@ -471,7 +482,7 @@ pub mod groups {\n     /** one group of options, e.g., both -h and --help, along with\n      * their shared description and properties\n      */\n-    #[deriving(Eq)]\n+    #[deriving(Clone, Eq)]\n     pub struct OptGroup {\n         short_name: ~str,\n         long_name: ~str,\n@@ -556,7 +567,7 @@ pub mod groups {\n                      long_name: long_name,\n                      hasarg: hasarg,\n                      occur: occur,\n-                     _} = copy *lopt;\n+                     _} = (*lopt).clone();\n \n         match (short_name.len(), long_name.len()) {\n            (0,0) => fail!(\"this long-format option was given no name\"),\n@@ -600,7 +611,7 @@ pub mod groups {\n                          hint: hint,\n                          desc: desc,\n                          hasarg: hasarg,\n-                         _} = copy *optref;\n+                         _} = (*optref).clone();\n \n             let mut row = \" \".repeat(4);\n \n@@ -916,7 +927,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => {\n-            error!(fail_str(copy f));\n+            error!(fail_str(f.clone()));\n             check_fail_type(f, UnexpectedArgument_);\n           }\n           _ => fail!()"}, {"sha": "8c5af33cc38a99bdb7628089e5a80f55705465e0", "filename": "src/libextra/json.rs", "status": "modified", "additions": 11, "deletions": 47, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -30,6 +30,7 @@ use sort::Sort;\n use treemap::TreeMap;\n \n /// Represents a json value\n+#[deriving(Clone, Eq)]\n pub enum Json {\n     Number(float),\n     String(~str),\n@@ -1113,43 +1114,6 @@ impl serialize::Decoder for Decoder {\n     }\n }\n \n-impl Eq for Json {\n-    fn eq(&self, other: &Json) -> bool {\n-        match (self) {\n-            &Number(f0) =>\n-                match other { &Number(f1) => f0 == f1, _ => false },\n-            &String(ref s0) =>\n-                match other { &String(ref s1) => s0 == s1, _ => false },\n-            &Boolean(b0) =>\n-                match other { &Boolean(b1) => b0 == b1, _ => false },\n-            &Null =>\n-                match other { &Null => true, _ => false },\n-            &List(ref v0) =>\n-                match other { &List(ref v1) => v0 == v1, _ => false },\n-            &Object(ref d0) => {\n-                match other {\n-                    &Object(ref d1) => {\n-                        if d0.len() == d1.len() {\n-                            let mut equal = true;\n-                            for d0.iter().advance |(k, v0)| {\n-                                match d1.find(k) {\n-                                    Some(v1) if v0 == v1 => { },\n-                                    _ => { equal = false; break }\n-                                }\n-                            };\n-                            equal\n-                        } else {\n-                            false\n-                        }\n-                    }\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    fn ne(&self, other: &Json) -> bool { !self.eq(other) }\n-}\n-\n /// Test if two json values are less than one another\n impl Ord for Json {\n     fn lt(&self, other: &Json) -> bool {\n@@ -1195,12 +1159,12 @@ impl Ord for Json {\n \n                         // FIXME #4430: this is horribly inefficient...\n                         for d0.iter().advance |(k, v)| {\n-                             d0_flat.push((@copy *k, @copy *v));\n+                             d0_flat.push((@(*k).clone(), @(*v).clone()));\n                         }\n                         d0_flat.qsort();\n \n                         for d1.iter().advance |(k, v)| {\n-                            d1_flat.push((@copy *k, @copy *v));\n+                            d1_flat.push((@(*k).clone(), @(*v).clone()));\n                         }\n                         d1_flat.qsort();\n \n@@ -1232,7 +1196,7 @@ pub trait ToJson {\n }\n \n impl ToJson for Json {\n-    fn to_json(&self) -> Json { copy *self }\n+    fn to_json(&self) -> Json { (*self).clone() }\n }\n \n impl ToJson for @Json {\n@@ -1300,11 +1264,11 @@ impl ToJson for bool {\n }\n \n impl ToJson for ~str {\n-    fn to_json(&self) -> Json { String(copy *self) }\n+    fn to_json(&self) -> Json { String((*self).clone()) }\n }\n \n impl ToJson for @~str {\n-    fn to_json(&self) -> Json { String(copy **self) }\n+    fn to_json(&self) -> Json { String((**self).clone()) }\n }\n \n impl<A:ToJson,B:ToJson> ToJson for (A, B) {\n@@ -1335,7 +1299,7 @@ impl<A:ToJson> ToJson for HashMap<~str, A> {\n     fn to_json(&self) -> Json {\n         let mut d = HashMap::new();\n         for self.iter().advance |(key, value)| {\n-            d.insert(copy *key, value.to_json());\n+            d.insert((*key).clone(), value.to_json());\n         }\n         Object(~d)\n     }\n@@ -1345,7 +1309,7 @@ impl<A:ToJson> ToJson for TreeMap<~str, A> {\n     fn to_json(&self) -> Json {\n         let mut d = HashMap::new();\n         for self.iter().advance |(key, value)| {\n-            d.insert(copy *key, value.to_json());\n+            d.insert((*key).clone(), value.to_json());\n         }\n         Object(~d)\n     }\n@@ -1404,7 +1368,7 @@ mod tests {\n \n         for items.iter().advance |item| {\n             match *item {\n-                (ref key, ref value) => { d.insert(copy *key, copy *value); },\n+                (ref key, ref value) => { d.insert((*key).clone(), (*value).clone()); },\n             }\n         };\n \n@@ -1549,8 +1513,8 @@ mod tests {\n \n         // We can't compare the strings directly because the object fields be\n         // printed in a different order.\n-        assert_eq!(copy a, from_str(to_str(&a)).unwrap());\n-        assert_eq!(copy a, from_str(to_pretty_str(&a)).unwrap());\n+        assert_eq!(a.clone(), from_str(to_str(&a)).unwrap());\n+        assert_eq!(a.clone(), from_str(to_pretty_str(&a)).unwrap());\n     }\n \n     #[test]"}, {"sha": "87d0c05aec1e783fac19638a4e1922dac8f9f015", "filename": "src/libextra/list.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flist.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -25,8 +25,8 @@ pub enum MutList<T> {\n }\n \n /// Create a list from a vector\n-pub fn from_vec<T:Copy>(v: &[T]) -> @List<T> {\n-    v.rev_iter().fold(@Nil::<T>, |t, h| @Cons(copy *h, t))\n+pub fn from_vec<T:Clone>(v: &[T]) -> @List<T> {\n+    v.rev_iter().fold(@Nil::<T>, |t, h| @Cons((*h).clone(), t))\n }\n \n /**\n@@ -42,7 +42,7 @@ pub fn from_vec<T:Copy>(v: &[T]) -> @List<T> {\n  * * z - The initial value\n  * * f - The function to apply\n  */\n-pub fn foldl<T:Copy,U>(z: T, ls: @List<U>, f: &fn(&T, &U) -> T) -> T {\n+pub fn foldl<T:Clone,U>(z: T, ls: @List<U>, f: &fn(&T, &U) -> T) -> T {\n     let mut accum: T = z;\n     do iter(ls) |elt| { accum = f(&accum, elt);}\n     accum\n@@ -55,12 +55,12 @@ pub fn foldl<T:Copy,U>(z: T, ls: @List<U>, f: &fn(&T, &U) -> T) -> T {\n  * When function `f` returns true then an option containing the element\n  * is returned. If `f` matches no elements then none is returned.\n  */\n-pub fn find<T:Copy>(ls: @List<T>, f: &fn(&T) -> bool) -> Option<T> {\n+pub fn find<T:Clone>(ls: @List<T>, f: &fn(&T) -> bool) -> Option<T> {\n     let mut ls = ls;\n     loop {\n         ls = match *ls {\n           Cons(ref hd, tl) => {\n-            if f(hd) { return Some(copy *hd); }\n+            if f(hd) { return Some((*hd).clone()); }\n             tl\n           }\n           Nil => return None\n@@ -69,15 +69,15 @@ pub fn find<T:Copy>(ls: @List<T>, f: &fn(&T) -> bool) -> Option<T> {\n }\n \n /// Returns true if a list contains an element with the given value\n-pub fn has<T:Copy + Eq>(ls: @List<T>, elt: T) -> bool {\n+pub fn has<T:Eq>(ls: @List<T>, elt: T) -> bool {\n     for each(ls) |e| {\n         if *e == elt { return true; }\n     }\n     return false;\n }\n \n /// Returns true if the list is empty\n-pub fn is_empty<T:Copy>(ls: @List<T>) -> bool {\n+pub fn is_empty<T>(ls: @List<T>) -> bool {\n     match *ls {\n         Nil => true,\n         _ => false\n@@ -92,37 +92,37 @@ pub fn len<T>(ls: @List<T>) -> uint {\n }\n \n /// Returns all but the first element of a list\n-pub fn tail<T:Copy>(ls: @List<T>) -> @List<T> {\n+pub fn tail<T>(ls: @List<T>) -> @List<T> {\n     match *ls {\n         Cons(_, tl) => return tl,\n         Nil => fail!(\"list empty\")\n     }\n }\n \n /// Returns the first element of a list\n-pub fn head<T:Copy>(ls: @List<T>) -> T {\n+pub fn head<T:Clone>(ls: @List<T>) -> T {\n     match *ls {\n-      Cons(ref hd, _) => copy *hd,\n+      Cons(ref hd, _) => (*hd).clone(),\n       // makes me sad\n       _ => fail!(\"head invoked on empty list\")\n     }\n }\n \n /// Appends one list to another\n-pub fn append<T:Copy>(l: @List<T>, m: @List<T>) -> @List<T> {\n+pub fn append<T:Clone>(l: @List<T>, m: @List<T>) -> @List<T> {\n     match *l {\n       Nil => return m,\n       Cons(ref x, xs) => {\n         let rest = append(xs, m);\n-        return @Cons(copy *x, rest);\n+        return @Cons((*x).clone(), rest);\n       }\n     }\n }\n \n /*\n /// Push one element into the front of a list, returning a new list\n /// THIS VERSION DOESN'T ACTUALLY WORK\n-fn push<T:Copy>(ll: &mut @list<T>, vv: T) {\n+fn push<T:Clone>(ll: &mut @list<T>, vv: T) {\n     ll = &mut @cons(vv, *ll)\n }\n */"}, {"sha": "4c3fefc6eed92ebb392bab4b0260c18e572a9b6a", "filename": "src/libextra/net/ip.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet%2Fip.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -176,12 +176,19 @@ pub mod v4 {\n     pub fn parse_addr(ip: &str) -> IpAddr {\n         match try_parse_addr(ip) {\n           result::Ok(addr) => addr,\n-          result::Err(ref err_data) => fail!(copy err_data.err_msg)\n+          result::Err(ref err_data) => fail!(err_data.err_msg.clone())\n         }\n     }\n+\n     // the simple, old style numberic representation of\n     // ipv4\n-    pub struct Ipv4Rep { a: u8, b: u8, c: u8, d: u8 }\n+    #[deriving(Clone)]\n+    pub struct Ipv4Rep {\n+        a: u8,\n+        b: u8,\n+        c: u8,\n+        d: u8,\n+    }\n \n     pub trait AsUnsafeU32 {\n         unsafe fn as_u32(&self) -> u32;\n@@ -271,7 +278,7 @@ pub mod v6 {\n     pub fn parse_addr(ip: &str) -> IpAddr {\n         match try_parse_addr(ip) {\n           result::Ok(addr) => addr,\n-          result::Err(err_data) => fail!(copy err_data.err_msg)\n+          result::Err(err_data) => fail!(err_data.err_msg.clone())\n         }\n     }\n     pub fn try_parse_addr(ip: &str) -> result::Result<IpAddr,ParseAddrErr> {"}, {"sha": "eebb8490aa2876196883de0aabfdeded32645c38", "filename": "src/libextra/net/tcp.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet%2Ftcp.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -86,6 +86,7 @@ pub fn TcpSocketBuf(data: @mut TcpBufferedSocketData) -> TcpSocketBuf {\n }\n \n /// Contains raw, string-based, error information returned from libuv\n+#[deriving(Clone)]\n pub struct TcpErrData {\n     err_name: ~str,\n     err_msg: ~str,\n@@ -278,8 +279,8 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n                                                     as *libc::c_void);\n                 let tcp_conn_err = match err_data.err_name {\n                     ~\"ECONNREFUSED\" => ConnectionRefused,\n-                    _ => GenericConnectErr(copy err_data.err_name,\n-                                           copy err_data.err_msg)\n+                    _ => GenericConnectErr(err_data.err_name.clone(),\n+                                           err_data.err_msg.clone())\n                 };\n                 result::Err(tcp_conn_err)\n             }\n@@ -343,7 +344,7 @@ pub fn write_future(sock: &TcpSocket, raw_write_data: ~[u8])\n {\n     let socket_data_ptr: *TcpSocketData = &*sock.socket_data;\n     do future_spawn {\n-        let data_copy = copy(raw_write_data);\n+        let data_copy = raw_write_data.clone();\n         write_common_impl(socket_data_ptr, data_copy)\n     }\n }\n@@ -770,8 +771,8 @@ fn listen_common(host_ip: ip::IpAddr,\n                     debug!(\"Got '%s' '%s' libuv error\",\n                                     err_data.err_name, err_data.err_msg);\n                     result::Err(\n-                        GenericListenErr(copy err_data.err_name,\n-                                         copy err_data.err_msg))\n+                        GenericListenErr(err_data.err_name.clone(),\n+                                         err_data.err_msg.clone()))\n                 }\n             }\n         }\n@@ -791,8 +792,8 @@ fn listen_common(host_ip: ip::IpAddr,\n             match kill_result {\n                 // some failure post bind/listen\n                 Some(ref err_data) => result::Err(GenericListenErr(\n-                    copy err_data.err_name,\n-                    copy err_data.err_msg)),\n+                    err_data.err_name.clone(),\n+                    err_data.err_msg.clone())),\n                 // clean exit\n                 None => result::Ok(())\n             }\n@@ -1263,7 +1264,10 @@ trait ToTcpErr {\n \n impl ToTcpErr for uv::ll::uv_err_data {\n     fn to_tcp_err(&self) -> TcpErrData {\n-        TcpErrData { err_name: copy self.err_name, err_msg: copy self.err_msg }\n+        TcpErrData {\n+            err_name: self.err_name.clone(),\n+            err_msg: self.err_msg.clone(),\n+        }\n     }\n }\n "}, {"sha": "9404f3f4896ea6046c1359e96e0066428f34351b", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -282,7 +282,7 @@ impl Mul<BigUint, BigUint> for BigUint {\n \n         fn mul_digit(a: &BigUint, n: BigDigit) -> BigUint {\n             if n == 0 { return Zero::zero(); }\n-            if n == 1 { return copy *a; }\n+            if n == 1 { return (*a).clone(); }\n \n             let mut carry = 0;\n             let mut prod = do a.data.iter().transform |ai| {\n@@ -357,10 +357,10 @@ impl Integer for BigUint {\n     fn div_mod_floor(&self, other: &BigUint) -> (BigUint, BigUint) {\n         if other.is_zero() { fail!() }\n         if self.is_zero() { return (Zero::zero(), Zero::zero()); }\n-        if *other == One::one() { return (copy *self, Zero::zero()); }\n+        if *other == One::one() { return ((*self).clone(), Zero::zero()); }\n \n         match self.cmp(other) {\n-            Less    => return (Zero::zero(), copy *self),\n+            Less    => return (Zero::zero(), (*self).clone()),\n             Equal   => return (One::one(), Zero::zero()),\n             Greater => {} // Do nothing\n         }\n@@ -411,7 +411,7 @@ impl Integer for BigUint {\n         fn div_estimate(a: &BigUint, b: &BigUint, n: uint)\n             -> (BigUint, BigUint, BigUint) {\n             if a.data.len() < n {\n-                return (Zero::zero(), Zero::zero(), copy *a);\n+                return (Zero::zero(), Zero::zero(), (*a).clone());\n             }\n \n             let an = a.data.slice(a.data.len() - n, a.data.len());\n@@ -428,7 +428,7 @@ impl Integer for BigUint {\n \n             let shift = (a.data.len() - an.len()) - (b.data.len() - 1);\n             if shift == 0 {\n-                return (BigUint::new(d), One::one(), copy *b);\n+                return (BigUint::new(d), One::one(), (*b).clone());\n             }\n             return (BigUint::from_slice(d).shl_unit(shift),\n                     One::one::<BigUint>().shl_unit(shift),\n@@ -444,8 +444,8 @@ impl Integer for BigUint {\n \n     fn gcd(&self, other: &BigUint) -> BigUint {\n         // Use Euclid's algorithm\n-        let mut m = copy *self;\n-        let mut n = copy *other;\n+        let mut m = (*self).clone();\n+        let mut n = (*other).clone();\n         while !m.is_zero() {\n             let temp = m;\n             m = n % temp;\n@@ -500,7 +500,7 @@ impl ToStrRadix for BigUint {\n         if base == BigDigit::base {\n             return fill_concat(self.data, radix, max_len)\n         }\n-        return fill_concat(convert_base(copy *self, base), radix, max_len);\n+        return fill_concat(convert_base((*self).clone(), base), radix, max_len);\n \n \n         fn convert_base(n: BigUint, base: uint) -> ~[BigDigit] {\n@@ -612,14 +612,14 @@ impl BigUint {\n \n \n     priv fn shl_unit(&self, n_unit: uint) -> BigUint {\n-        if n_unit == 0 || self.is_zero() { return copy *self; }\n+        if n_unit == 0 || self.is_zero() { return (*self).clone(); }\n \n-        return BigUint::new(vec::from_elem(n_unit, 0) + self.data);\n+        return BigUint::new(vec::from_elem(n_unit, 0u32) + self.data);\n     }\n \n \n     priv fn shl_bits(&self, n_bits: uint) -> BigUint {\n-        if n_bits == 0 || self.is_zero() { return copy *self; }\n+        if n_bits == 0 || self.is_zero() { return (*self).clone(); }\n \n         let mut carry = 0;\n         let mut shifted = do self.data.iter().transform |elem| {\n@@ -635,7 +635,7 @@ impl BigUint {\n \n \n     priv fn shr_unit(&self, n_unit: uint) -> BigUint {\n-        if n_unit == 0 { return copy *self; }\n+        if n_unit == 0 { return (*self).clone(); }\n         if self.data.len() < n_unit { return Zero::zero(); }\n         return BigUint::from_slice(\n             self.data.slice(n_unit, self.data.len())\n@@ -644,7 +644,7 @@ impl BigUint {\n \n \n     priv fn shr_bits(&self, n_bits: uint) -> BigUint {\n-        if n_bits == 0 || self.data.is_empty() { return copy *self; }\n+        if n_bits == 0 || self.data.is_empty() { return (*self).clone(); }\n \n         let mut borrow = 0;\n         let mut shifted = ~[];"}, {"sha": "1c686843ab095ade770a492fca84993d0d96b752", "filename": "src/libextra/par.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpar.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Cloneright 2012 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -32,7 +32,7 @@ static MIN_GRANULARITY : uint = 1024u;\n  * This is used to build most of the other parallel vector functions,\n  * like map or alli.\n  */\n-fn map_slices<A:Copy + Send,B:Copy + Send>(\n+fn map_slices<A:Clone + Send,B:Clone + Send>(\n     xs: &[A],\n     f: &fn() -> ~fn(uint, v: &[A]) -> B)\n     -> ~[B] {\n@@ -42,8 +42,7 @@ fn map_slices<A:Copy + Send,B:Copy + Send>(\n         info!(\"small slice\");\n         // This is a small vector, fall back on the normal map.\n         ~[f()(0u, xs)]\n-    }\n-    else {\n+    } else {\n         let num_tasks = num::min(MAX_TASKS, len / MIN_GRANULARITY);\n \n         let items_per_task = len / num_tasks;\n@@ -86,7 +85,7 @@ fn map_slices<A:Copy + Send,B:Copy + Send>(\n }\n \n /// A parallel version of map.\n-pub fn map<A:Copy + Send,B:Copy + Send>(\n+pub fn map<A:Copy + Clone + Send,B:Copy + Clone + Send>(\n     xs: &[A], fn_factory: &fn() -> ~fn(&A) -> B) -> ~[B] {\n     vec::concat(map_slices(xs, || {\n         let f = fn_factory();\n@@ -97,7 +96,7 @@ pub fn map<A:Copy + Send,B:Copy + Send>(\n }\n \n /// A parallel version of mapi.\n-pub fn mapi<A:Copy + Send,B:Copy + Send>(\n+pub fn mapi<A:Copy + Clone + Send,B:Copy + Clone + Send>(\n         xs: &[A],\n         fn_factory: &fn() -> ~fn(uint, &A) -> B) -> ~[B] {\n     let slices = map_slices(xs, || {\n@@ -116,7 +115,7 @@ pub fn mapi<A:Copy + Send,B:Copy + Send>(\n }\n \n /// Returns true if the function holds for all elements in the vector.\n-pub fn alli<A:Copy + Send>(\n+pub fn alli<A:Clone + Send>(\n     xs: &[A],\n     fn_factory: &fn() -> ~fn(uint, &A) -> bool) -> bool\n {\n@@ -131,7 +130,7 @@ pub fn alli<A:Copy + Send>(\n }\n \n /// Returns true if the function holds for any elements in the vector.\n-pub fn any<A:Copy + Send>(\n+pub fn any<A:Clone + Send>(\n     xs: &[A],\n     fn_factory: &fn() -> ~fn(&A) -> bool) -> bool {\n     let mapped = map_slices(xs, || {"}, {"sha": "dc274dfb814139b733138ab79f6094d21ac83f7c", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -308,8 +308,8 @@ mod tests {\n     }\n \n     fn check_to_vec(data: ~[int]) {\n-        let heap = PriorityQueue::from_vec(copy data);\n-        assert_eq!(merge_sort((copy heap).to_vec(), |x, y| x.le(y)),\n+        let heap = PriorityQueue::from_vec(data.clone());\n+        assert_eq!(merge_sort(heap.clone().to_vec(), |x, y| x.le(y)),\n                    merge_sort(data, |x, y| x.le(y)));\n         assert_eq!(heap.to_sorted_vec(), merge_sort(data, |x, y| x.le(y)));\n     }"}, {"sha": "c331cdfd868d0fe659ac577046089109b1503708", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -329,8 +329,8 @@ impl<A, T: Iterator<A>> FromIterator<A, T> for RingBuf<A> {\n #[cfg(test)]\n mod tests {\n     use super::*;\n+    use std::clone::Clone;\n     use std::cmp::Eq;\n-    use std::kinds::Copy;\n     use std::{int, uint};\n     use extra::test;\n \n@@ -416,34 +416,34 @@ mod tests {\n     }\n \n     #[cfg(test)]\n-    fn test_parameterized<T:Copy + Eq>(a: T, b: T, c: T, d: T) {\n-        let mut deq = RingBuf::new();\n+    fn test_parameterized<T:Clone + Eq>(a: T, b: T, c: T, d: T) {\n+        let mut deq = Deque::new();\n         assert_eq!(deq.len(), 0);\n-        deq.push_front(copy a);\n-        deq.push_front(copy b);\n-        deq.push_back(copy c);\n+        deq.add_front(a.clone());\n+        deq.add_front(b.clone());\n+        deq.add_back(c.clone());\n         assert_eq!(deq.len(), 3);\n-        deq.push_back(copy d);\n+        deq.add_back(d.clone());\n         assert_eq!(deq.len(), 4);\n-        assert_eq!(deq.front(), Some(&b));\n-        assert_eq!(deq.back(), Some(&d));\n-        assert_eq!(deq.pop_front(), Some(copy b));\n-        assert_eq!(deq.pop_back(), Some(copy d));\n-        assert_eq!(deq.pop_back(), Some(copy c));\n-        assert_eq!(deq.pop_back(), Some(copy a));\n+        assert_eq!((*deq.peek_front()).clone(), b.clone());\n+        assert_eq!((*deq.peek_back()).clone(), d.clone());\n+        assert_eq!(deq.pop_front(), b.clone());\n+        assert_eq!(deq.pop_back(), d.clone());\n+        assert_eq!(deq.pop_back(), c.clone());\n+        assert_eq!(deq.pop_back(), a.clone());\n         assert_eq!(deq.len(), 0);\n-        deq.push_back(copy c);\n+        deq.add_back(c.clone());\n         assert_eq!(deq.len(), 1);\n-        deq.push_front(copy b);\n+        deq.add_front(b.clone());\n         assert_eq!(deq.len(), 2);\n-        deq.push_back(copy d);\n+        deq.add_back(d.clone());\n         assert_eq!(deq.len(), 3);\n-        deq.push_front(copy a);\n+        deq.add_front(a.clone());\n         assert_eq!(deq.len(), 4);\n-        assert_eq!(copy *deq.get(0), copy a);\n-        assert_eq!(copy *deq.get(1), copy b);\n-        assert_eq!(copy *deq.get(2), copy c);\n-        assert_eq!(copy *deq.get(3), copy d);\n+        assert_eq!((*deq.get(0)).clone(), a.clone());\n+        assert_eq!((*deq.get(1)).clone(), b.clone());\n+        assert_eq!((*deq.get(2)).clone(), c.clone());\n+        assert_eq!((*deq.get(3)).clone(), d.clone());\n     }\n \n     #[test]\n@@ -501,15 +501,21 @@ mod tests {\n         }\n     }\n \n-    #[deriving(Eq)]\n-    enum Taggy { One(int), Two(int, int), Three(int, int, int), }\n+    #[deriving(Clone, Eq)]\n+    enum Taggy {\n+        One(int),\n+        Two(int, int),\n+        Three(int, int, int),\n+    }\n \n-    #[deriving(Eq)]\n+    #[deriving(Clone, Eq)]\n     enum Taggypar<T> {\n-        Onepar(int), Twopar(int, int), Threepar(int, int, int),\n+        Onepar(int),\n+        Twopar(int, int),\n+        Threepar(int, int, int),\n     }\n \n-    #[deriving(Eq)]\n+    #[deriving(Clone, Eq)]\n     struct RecCy {\n         x: int,\n         y: int,"}, {"sha": "9f2bfd6592ae5c242b2e49998bf263565241ebc4", "filename": "src/libextra/semver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsemver.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -21,7 +21,7 @@ use std::option::{Option, Some, None};\n use std::to_str::ToStr;\n use std::uint;\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub enum Identifier {\n     Numeric(uint),\n     AlphaNumeric(~str)\n@@ -62,7 +62,7 @@ impl ToStr for Identifier {\n }\n \n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub struct Version {\n     major: uint,\n     minor: uint,"}, {"sha": "6ad4d2acd9056fc2f58e78d1c0ee30fd8f7bb25d", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -219,12 +219,12 @@ impl<V> SmallIntMap<V> {\n     }\n }\n \n-impl<V:Copy> SmallIntMap<V> {\n+impl<V:Clone> SmallIntMap<V> {\n     pub fn update_with_key(&mut self, key: uint, val: V,\n                            ff: &fn(uint, V, V) -> V) -> bool {\n         let new_val = match self.find(&key) {\n             None => val,\n-            Some(orig) => ff(key, copy *orig, val)\n+            Some(orig) => ff(key, (*orig).clone(), val)\n         };\n         self.insert(key, new_val)\n     }"}, {"sha": "8a21ea0bd3bca9e1b81437b8e080d330f91470f2", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -24,19 +24,18 @@ type Le<'self, T> = &'self fn(v1: &T, v2: &T) -> bool;\n  * Has worst case O(n log n) performance, best case O(n), but\n  * is not space efficient. This is a stable sort.\n  */\n-pub fn merge_sort<T:Copy>(v: &[T], le: Le<T>) -> ~[T] {\n+pub fn merge_sort<T:Copy + Clone>(v: &[T], le: Le<T>) -> ~[T] {\n     type Slice = (uint, uint);\n \n     return merge_sort_(v, (0u, v.len()), le);\n \n-    fn merge_sort_<T:Copy>(v: &[T], slice: Slice, le: Le<T>)\n-        -> ~[T] {\n+    fn merge_sort_<T:Copy + Clone>(v: &[T], slice: Slice, le: Le<T>) -> ~[T] {\n         let begin = slice.first();\n         let end = slice.second();\n \n         let v_len = end - begin;\n         if v_len == 0 { return ~[]; }\n-        if v_len == 1 { return ~[copy v[begin]]; }\n+        if v_len == 1 { return ~[v[begin].clone()]; }\n \n         let mid = v_len / 2 + begin;\n         let a = (begin, mid);\n@@ -45,17 +44,20 @@ pub fn merge_sort<T:Copy>(v: &[T], le: Le<T>) -> ~[T] {\n                                     merge_sort_(v, b, |x,y| le(x,y)));\n     }\n \n-    fn merge<T:Copy>(le: Le<T>, a: &[T], b: &[T]) -> ~[T] {\n+    fn merge<T:Copy + Clone>(le: Le<T>, a: &[T], b: &[T]) -> ~[T] {\n         let mut rs = vec::with_capacity(a.len() + b.len());\n         let a_len = a.len();\n         let mut a_ix = 0;\n         let b_len = b.len();\n         let mut b_ix = 0;\n         while a_ix < a_len && b_ix < b_len {\n             if le(&a[a_ix], &b[b_ix]) {\n-                rs.push(copy a[a_ix]);\n+                rs.push(a[a_ix].clone());\n                 a_ix += 1;\n-            } else { rs.push(copy b[b_ix]); b_ix += 1; }\n+            } else {\n+                rs.push(b[b_ix].clone());\n+                b_ix += 1;\n+            }\n         }\n         rs.push_all(a.slice(a_ix, a_len));\n         rs.push_all(b.slice(b_ix, b_len));\n@@ -104,9 +106,9 @@ pub fn quick_sort<T>(arr: &mut [T], compare_func: Le<T>) {\n     qsort::<T>(arr, 0u, len - 1u, compare_func);\n }\n \n-fn qsort3<T:Copy + Ord + Eq>(arr: &mut [T], left: int, right: int) {\n+fn qsort3<T:Clone + Ord + Eq>(arr: &mut [T], left: int, right: int) {\n     if right <= left { return; }\n-    let v: T = copy arr[right];\n+    let v: T = arr[right].clone();\n     let mut i: int = left - 1;\n     let mut j: int = right;\n     let mut p: int = i;\n@@ -161,7 +163,7 @@ fn qsort3<T:Copy + Ord + Eq>(arr: &mut [T], left: int, right: int) {\n  *\n  * This is an unstable sort.\n  */\n-pub fn quick_sort3<T:Copy + Ord + Eq>(arr: &mut [T]) {\n+pub fn quick_sort3<T:Clone + Ord + Eq>(arr: &mut [T]) {\n     if arr.len() <= 1 { return; }\n     let len = arr.len(); // FIXME(#5074) nested calls\n     qsort3(arr, 0, (len - 1) as int);\n@@ -172,7 +174,7 @@ pub trait Sort {\n     fn qsort(self);\n }\n \n-impl<'self, T:Copy + Ord + Eq> Sort for &'self mut [T] {\n+impl<'self, T:Clone + Ord + Eq> Sort for &'self mut [T] {\n     fn qsort(self) { quick_sort3(self); }\n }\n \n@@ -181,7 +183,7 @@ static MIN_GALLOP: uint = 7;\n static INITIAL_TMP_STORAGE: uint = 128;\n \n #[allow(missing_doc)]\n-pub fn tim_sort<T:Copy + Ord>(array: &mut [T]) {\n+pub fn tim_sort<T:Copy + Clone + Ord>(array: &mut [T]) {\n     let size = array.len();\n     if size < 2 {\n         return;\n@@ -225,15 +227,15 @@ pub fn tim_sort<T:Copy + Ord>(array: &mut [T]) {\n     ms.merge_force_collapse(array);\n }\n \n-fn binarysort<T:Copy + Ord>(array: &mut [T], start: uint) {\n+fn binarysort<T:Copy + Clone + Ord>(array: &mut [T], start: uint) {\n     let size = array.len();\n     let mut start = start;\n     assert!(start <= size);\n \n     if start == 0 { start += 1; }\n \n     while start < size {\n-        let pivot = copy array[start];\n+        let pivot = array[start].clone();\n         let mut left = 0;\n         let mut right = start;\n         assert!(left <= right);\n@@ -275,7 +277,7 @@ fn min_run_length(n: uint) -> uint {\n     return n + r;\n }\n \n-fn count_run_ascending<T:Copy + Ord>(array: &mut [T]) -> uint {\n+fn count_run_ascending<T:Clone + Ord>(array: &mut [T]) -> uint {\n     let size = array.len();\n     assert!(size > 0);\n     if size == 1 { return 1; }\n@@ -295,7 +297,7 @@ fn count_run_ascending<T:Copy + Ord>(array: &mut [T]) -> uint {\n     return run;\n }\n \n-fn gallop_left<T:Copy + Ord>(key: &T,\n+fn gallop_left<T:Clone + Ord>(key: &T,\n                              array: &[T],\n                              hint: uint)\n                           -> uint {\n@@ -346,7 +348,7 @@ fn gallop_left<T:Copy + Ord>(key: &T,\n     return ofs;\n }\n \n-fn gallop_right<T:Copy + Ord>(key: &T,\n+fn gallop_right<T:Clone + Ord>(key: &T,\n                               array: &[T],\n                               hint: uint)\n                            -> uint {\n@@ -417,7 +419,7 @@ fn MergeState<T>() -> MergeState<T> {\n     }\n }\n \n-impl<T:Copy + Ord> MergeState<T> {\n+impl<T:Copy + Clone + Ord> MergeState<T> {\n     fn push_run(&mut self, run_base: uint, run_len: uint) {\n         let tmp = RunState{base: run_base, len: run_len};\n         self.runs.push(tmp);\n@@ -470,7 +472,7 @@ impl<T:Copy + Ord> MergeState<T> {\n \n         let mut tmp = ~[];\n         for uint::range(base1, base1+len1) |i| {\n-            tmp.push(copy array[i]);\n+            tmp.push(array[i].clone());\n         }\n \n         let mut c1 = 0;\n@@ -580,7 +582,7 @@ impl<T:Copy + Ord> MergeState<T> {\n \n         let mut tmp = ~[];\n         for uint::range(base2, base2+len2) |i| {\n-            tmp.push(copy array[i]);\n+            tmp.push(array[i].clone());\n         }\n \n         let mut c1 = base1 + len1 - 1;\n@@ -726,21 +728,21 @@ impl<T:Copy + Ord> MergeState<T> {\n }\n \n #[inline]\n-fn copy_vec<T:Copy>(dest: &mut [T],\n+fn copy_vec<T:Clone>(dest: &mut [T],\n                     s1: uint,\n                     from: &[T]) {\n     assert!(s1+from.len() <= dest.len());\n \n     for from.iter().enumerate().advance |(i, v)| {\n-        dest[s1+i] = copy *v;\n+        dest[s1+i] = (*v).clone();\n     }\n }\n \n #[inline]\n-fn shift_vec<T:Copy>(dest: &mut [T],\n-                     s1: uint,\n-                     s2: uint,\n-                     len: uint) {\n+fn shift_vec<T:Copy + Clone>(dest: &mut [T],\n+                             s1: uint,\n+                             s2: uint,\n+                             len: uint) {\n     assert!(s1+len <= dest.len());\n \n     let tmp = dest.slice(s2, s2+len).to_owned();\n@@ -902,7 +904,7 @@ mod tests {\n         fn ile(x: &(&'static str), y: &(&'static str)) -> bool\n         {\n             // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n-            // to_ascii_consume and to_str_consume to not do a unnecessary copy.\n+            // to_ascii_consume and to_str_consume to not do a unnecessary clone.\n             // (Actually, could just remove the to_str_* call, but needs an deriving(Ord) on\n             // Ascii)\n             let x = x.to_ascii().to_lower().to_str_ascii();\n@@ -1038,17 +1040,17 @@ mod big_tests {\n         tabulate_managed(low, high);\n     }\n \n-    fn multiplyVec<T:Copy>(arr: &[T], num: uint) -> ~[T] {\n+    fn multiplyVec<T:Clone>(arr: &[T], num: uint) -> ~[T] {\n         let size = arr.len();\n         let res = do vec::from_fn(num) |i| {\n-            copy arr[i % size]\n+            arr[i % size].clone()\n         };\n         res\n     }\n \n     fn makeRange(n: uint) -> ~[uint] {\n         let one = do vec::from_fn(n) |i| { i };\n-        let mut two = copy one;\n+        let mut two = one.clone();\n         two.reverse();\n         vec::append(two, one)\n     }"}, {"sha": "b891d022292373c781addf3288d2dbc9d9a71cc8", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -99,7 +99,7 @@ pub trait Stats {\n }\n \n /// Extracted collection of all the summary statistics of a sample set.\n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n struct Summary {\n     sum: f64,\n     min: f64,"}, {"sha": "840669f27b5282795f7e030a32ae34f2e260d6d6", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -39,6 +39,7 @@ enum FormatState {\n }\n \n /// Types of parameters a capability can use\n+#[deriving(Clone)]\n pub enum Param {\n     String(~str),\n     Number(int)\n@@ -82,7 +83,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n     // Copy parameters into a local vector for mutability\n     let mut mparams = [Number(0), ..9];\n     for mparams.mut_iter().zip(params.iter()).advance |(dst, src)| {\n-        *dst = copy *src;\n+        *dst = (*src).clone();\n     }\n \n     for cap.iter().transform(|&x| x).advance |c| {\n@@ -214,7 +215,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                             _         => return Err(~\"non-number on stack with %~\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n-                    'i' => match (copy mparams[0], copy mparams[1]) {\n+                    'i' => match (mparams[0].clone(), mparams[1].clone()) {\n                         (Number(x), Number(y)) => {\n                             mparams[0] = Number(x+1);\n                             mparams[1] = Number(y+1);\n@@ -263,10 +264,10 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n             },\n             PushParam => {\n                 // params are 1-indexed\n-                stack.push(copy mparams[match char::to_digit(cur, 10) {\n+                stack.push(mparams[match char::to_digit(cur, 10) {\n                     Some(d) => d - 1,\n                     None => return Err(~\"bad param number\")\n-                }]);\n+                }].clone());\n             },\n             SetVar => {\n                 if cur >= 'A' && cur <= 'Z' {\n@@ -286,10 +287,10 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n             GetVar => {\n                 if cur >= 'A' && cur <= 'Z' {\n                     let idx = (cur as u8) - ('A' as u8);\n-                    stack.push(copy vars.sta[idx]);\n+                    stack.push(vars.sta[idx].clone());\n                 } else if cur >= 'a' && cur <= 'z' {\n                     let idx = (cur as u8) - ('a' as u8);\n-                    stack.push(copy vars.dyn[idx]);\n+                    stack.push(vars.dyn[idx].clone());\n                 } else {\n                     return Err(~\"bad variable name in %g\");\n                 }"}, {"sha": "b45e1d6323bdd32490de1a2e6bb685439eedbf0f", "filename": "src/libextra/test.rs", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -44,13 +44,14 @@ use std::os;\n // colons. This way if some test runner wants to arrange the tests\n // hierarchically it may.\n \n+#[deriving(Clone)]\n pub enum TestName {\n     StaticTestName(&'static str),\n     DynTestName(~str)\n }\n impl ToStr for TestName {\n     fn to_str(&self) -> ~str {\n-        match copy *self {\n+        match (*self).clone() {\n             StaticTestName(s) => s.to_str(),\n             DynTestName(s) => s.to_str()\n         }\n@@ -80,6 +81,7 @@ pub struct BenchHarness {\n \n // The definition of a single test. A test runner will run a list of\n // these.\n+#[deriving(Clone)]\n pub struct TestDesc {\n     name: TestName,\n     ignore: bool,\n@@ -134,10 +136,10 @@ pub fn test_main_static(args: &[~str], tests: &[TestDescAndFn]) {\n     let owned_tests = do tests.map |t| {\n         match t.testfn {\n             StaticTestFn(f) =>\n-            TestDescAndFn { testfn: StaticTestFn(f), desc: copy t.desc },\n+            TestDescAndFn { testfn: StaticTestFn(f), desc: t.desc.clone() },\n \n             StaticBenchFn(f) =>\n-            TestDescAndFn { testfn: StaticBenchFn(f), desc: copy t.desc },\n+            TestDescAndFn { testfn: StaticBenchFn(f), desc: t.desc.clone() },\n \n             _ => {\n                 fail!(\"non-static tests passed to test::test_main_static\");\n@@ -178,8 +180,10 @@ pub fn parse_opts(args: &[~str]) -> OptRes {\n \n     let filter =\n         if matches.free.len() > 0 {\n-            Some(copy (matches).free[0])\n-        } else { None };\n+            Some((matches).free[0].clone())\n+        } else {\n+            None\n+        };\n \n     let run_ignored = getopts::opt_present(&matches, \"ignored\");\n \n@@ -214,19 +218,19 @@ pub fn parse_opts(args: &[~str]) -> OptRes {\n     either::Left(test_opts)\n }\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub struct BenchSamples {\n     ns_iter_summ: stats::Summary,\n     mb_s: uint\n }\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub enum TestResult {\n     TrOk,\n     TrFailed,\n     TrIgnored,\n     TrMetrics(MetricMap),\n-    TrBench(BenchSamples)\n+    TrBench(BenchSamples),\n }\n \n struct ConsoleTestState {\n@@ -500,7 +504,7 @@ pub fn run_tests_console(opts: &TestOpts,\n                          tests: ~[TestDescAndFn]) -> bool {\n     fn callback(event: &TestEvent, st: &mut ConsoleTestState) {\n         debug!(\"callback(event=%?)\", event);\n-        match copy *event {\n+        match (*event).clone() {\n             TeFiltered(ref filtered_tests) => st.write_run_start(filtered_tests.len()),\n             TeWait(ref test) => st.write_test_start(test),\n             TeResult(test, result) => {\n@@ -584,6 +588,7 @@ fn should_sort_failures_before_printing_them() {\n \n fn use_color() -> bool { return get_concurrency() == 1; }\n \n+#[deriving(Clone)]\n enum TestEvent {\n     TeFiltered(~[TestDesc]),\n     TeWait(TestDesc),\n@@ -597,7 +602,7 @@ fn run_tests(opts: &TestOpts,\n              callback: &fn(e: TestEvent)) {\n \n     let filtered_tests = filter_tests(opts, tests);\n-    let filtered_descs = filtered_tests.map(|t| copy t.desc);\n+    let filtered_descs = filtered_tests.map(|t| t.desc.clone());\n \n     callback(TeFiltered(filtered_descs));\n \n@@ -628,15 +633,15 @@ fn run_tests(opts: &TestOpts,\n                 // We are doing one test at a time so we can print the name\n                 // of the test before we run it. Useful for debugging tests\n                 // that hang forever.\n-                callback(TeWait(copy test.desc));\n+                callback(TeWait(test.desc.clone()));\n             }\n             run_test(!opts.run_tests, test, ch.clone());\n             pending += 1;\n         }\n \n         let (desc, result) = p.recv();\n         if concurrency != 1 {\n-            callback(TeWait(copy desc));\n+            callback(TeWait(desc.clone()));\n         }\n         callback(TeResult(desc, result));\n         pending -= 1;\n@@ -645,7 +650,7 @@ fn run_tests(opts: &TestOpts,\n     // All benchmarks run at the end, in serial.\n     // (this includes metric fns)\n     for filtered_benchs_and_metrics.consume_iter().advance |b| {\n-        callback(TeWait(copy b.desc));\n+        callback(TeWait(b.desc.clone()));\n         run_test(!opts.run_benchmarks, b, ch.clone());\n         let (test, result) = p.recv();\n         callback(TeResult(test, result));\n@@ -678,7 +683,7 @@ pub fn filter_tests(\n         filtered\n     } else {\n         let filter_str = match opts.filter {\n-          Some(ref f) => copy *f,\n+          Some(ref f) => (*f).clone(),\n           None => ~\"\"\n         };\n \n@@ -752,7 +757,7 @@ pub fn run_test(force_ignore: bool,\n             let task_result = result_future.unwrap().recv();\n             let test_result = calc_result(&desc,\n                                           task_result == task::Success);\n-            monitor_ch.send((copy desc, test_result));\n+            monitor_ch.send((desc.clone(), test_result));\n         }\n     }\n \n@@ -813,14 +818,14 @@ impl MetricMap {\n     /// Load MetricDiff from a file.\n     pub fn load(p: &Path) -> MetricMap {\n         assert!(os::path_exists(p));\n-        let f = io::file_reader(p).get();\n+        let f = io::file_reader(p).unwrap();\n         let mut decoder = json::Decoder(json::from_reader(f).get());\n         MetricMap(Decodable::decode(&mut decoder))\n     }\n \n     /// Write MetricDiff to a file.\n     pub fn save(&self, p: &Path) {\n-        let f = io::file_writer(p, [io::Create, io::Truncate]).get();\n+        let f = io::file_writer(p, [io::Create, io::Truncate]).unwrap();\n         json::to_pretty_writer(f, &self.to_json());\n     }\n \n@@ -868,11 +873,11 @@ impl MetricMap {\n                     }\n                 }\n             };\n-            diff.insert(copy *k, r);\n+            diff.insert((*k).clone(), r);\n         }\n         for self.iter().advance |(k, _)| {\n             if !diff.contains_key(k) {\n-                diff.insert(copy *k, MetricAdded);\n+                diff.insert((*k).clone(), MetricAdded);\n             }\n         }\n         diff\n@@ -1153,7 +1158,7 @@ mod tests {\n           either::Left(o) => o,\n           _ => fail!(\"Malformed arg in first_free_arg_should_be_a_filter\")\n         };\n-        assert!(\"filter\" == (copy opts.filter).get());\n+        assert!(\"filter\" == opts.filter.clone().get());\n     }\n \n     #[test]\n@@ -1236,11 +1241,11 @@ mod tests {\n             for names.iter().advance |name| {\n                 let test = TestDescAndFn {\n                     desc: TestDesc {\n-                        name: DynTestName(copy *name),\n+                        name: DynTestName((*name).clone()),\n                         ignore: false,\n                         should_fail: false\n                     },\n-                    testfn: DynTestFn(copy testfn),\n+                    testfn: DynTestFn(testfn.clone()),\n                 };\n                 tests.push(test);\n             }"}, {"sha": "a3b85b05d5d492c9f8015d7b8ddf8e93cd3c0f18", "filename": "src/libextra/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -683,7 +683,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                 tm_yday: tm.tm_yday,\n                 tm_isdst: tm.tm_isdst,\n                 tm_gmtoff: tm.tm_gmtoff,\n-                tm_zone: copy tm.tm_zone,\n+                tm_zone: tm.tm_zone.clone(),\n                 tm_nsec: tm.tm_nsec,\n             })\n         } else { result }\n@@ -829,7 +829,7 @@ priv fn do_strftime(format: &str, tm: &Tm) -> ~str {\n           //'x' {}\n           'Y' => int::to_str(tm.tm_year as int + 1900),\n           'y' => fmt!(\"%02d\", (tm.tm_year as int + 1900) % 100),\n-          'Z' => copy tm.tm_zone,\n+          'Z' => tm.tm_zone.clone(),\n           'z' => {\n             let sign = if tm.tm_gmtoff > 0_i32 { '+' } else { '-' };\n             let mut m = num::abs(tm.tm_gmtoff) / 60_i32;"}, {"sha": "223e17d0952408a1eb46577519a294714af7fef9", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -791,8 +791,8 @@ mod test_treemap {\n         let v1 = \"baz\".as_bytes();\n         let v2 = \"foobar\".as_bytes();\n \n-        m.insert(copy k1, copy v1);\n-        m.insert(copy k2, copy v2);\n+        m.insert(k1.clone(), v1.clone());\n+        m.insert(k2.clone(), v2.clone());\n \n         assert_eq!(m.find(&k2), Some(&v2));\n         assert_eq!(m.find(&k1), Some(&v1));"}, {"sha": "74798d260c175451f8f5a3fe29317f9c689149cd", "filename": "src/libextra/uv_ll.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuv_ll.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -1476,7 +1476,7 @@ mod test {\n                 let client_data = get_data_for_uv_handle(\n                     client_stream_ptr as *libc::c_void) as *tcp_server_data;\n \n-                let server_kill_msg = copy (*client_data).server_kill_msg;\n+                let server_kill_msg = (*client_data).server_kill_msg.clone();\n                 let write_req = (*client_data).server_write_req;\n                 if request_str.contains(server_kill_msg) {\n                     debug!(~\"SERVER: client req contains kill_msg!\");\n@@ -1726,12 +1726,12 @@ mod test {\n         let (continue_port, continue_chan) = stream::<bool>();\n         let continue_chan = SharedChan::new(continue_chan);\n \n-        let kill_server_msg_copy = copy kill_server_msg;\n-        let server_resp_msg_copy = copy server_resp_msg;\n+        let kill_server_msg_copy = kill_server_msg.clone();\n+        let server_resp_msg_copy = server_resp_msg.clone();\n         do task::spawn_sched(task::ManualThreads(1)) {\n             impl_uv_tcp_server(bind_ip, port,\n-                               copy kill_server_msg_copy,\n-                               copy server_resp_msg_copy,\n+                               kill_server_msg_copy.clone(),\n+                               server_resp_msg_copy.clone(),\n                                server_chan.clone(),\n                                continue_chan.clone());\n         };\n@@ -1741,7 +1741,7 @@ mod test {\n         continue_port.recv();\n         debug!(~\"received on continue port, set up tcp client\");\n \n-        let kill_server_msg_copy = copy kill_server_msg;\n+        let kill_server_msg_copy = kill_server_msg.clone();\n         do task::spawn_sched(task::ManualThreads(1u)) {\n             impl_uv_tcp_request(request_ip, port,\n                                kill_server_msg_copy,"}, {"sha": "99cf8c6912c332927d581ef4ad899936a1c6aae3", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -97,7 +97,7 @@ use std::util::replace;\n *\n */\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Clone, Eq, Encodable, Decodable)]\n struct WorkKey {\n     kind: ~str,\n     name: ~str\n@@ -138,6 +138,12 @@ impl WorkKey {\n \n struct WorkMap(HashMap<WorkKey, ~str>);\n \n+impl Clone for WorkMap {\n+    fn clone(&self) -> WorkMap {\n+        WorkMap((**self).clone())\n+    }\n+}\n+\n impl WorkMap {\n     fn new() -> WorkMap { WorkMap(HashMap::new()) }\n }\n@@ -146,7 +152,7 @@ impl<S:Encoder> Encodable<S> for WorkMap {\n     fn encode(&self, s: &mut S) {\n         let mut d = ~[];\n         for self.iter().advance |(k, v)| {\n-            d.push((copy *k, copy *v))\n+            d.push(((*k).clone(), (*v).clone()))\n         }\n         sort::tim_sort(d);\n         d.encode(s)\n@@ -215,6 +221,7 @@ struct Context {\n     freshness: HashMap<~str,@fn(&str,&str)->bool>\n }\n \n+#[deriving(Clone)]\n struct Prep {\n     ctxt: @Context,\n     fn_name: ~str,\n@@ -341,7 +348,7 @@ impl TPrep for Prep {\n                               &self.declared_inputs) &&\n             self.all_fresh(\"discovered input\", disc_in) &&\n             self.all_fresh(\"discovered output\", disc_out) => {\n-                Work::new(@mut copy *self, Left(json_decode(*res)))\n+                Work::new(@mut (*self).clone(), Left(json_decode(*res)))\n             }\n \n             _ => {\n@@ -358,7 +365,7 @@ impl TPrep for Prep {\n                     let v = blk(&exe);\n                     send_one(chan, (exe, v));\n                 }\n-                Work::new(@mut copy *self, Right(port))\n+                Work::new(@mut (*self).clone(), Right(port))\n             }\n         }\n     }\n@@ -413,7 +420,7 @@ fn test() {\n     let w:Work<~str> = do cx.prep(\"test1\") |prep| {\n         let pth = Path(\"foo.c\");\n         {\n-            let file = io::file_writer(&pth, [io::Create]).get();\n+            let file = io::file_writer(&pth, [io::Create]).unwrap();\n             file.write_str(\"int main() { return 0; }\");\n         }\n "}, {"sha": "adf73a7e7f00ff6526a55d4a9673cababdedcf8d", "filename": "src/librust/rust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrust%2Frust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrust%2Frust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrust%2Frust.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -118,7 +118,7 @@ static COMMANDS: &'static [Command<'static>] = &[\n ];\n \n fn rustc_help() {\n-    rustc::usage(copy os::args()[0])\n+    rustc::usage(os::args()[0].clone())\n }\n \n fn find_cmd(command_string: &str) -> Option<Command> {\n@@ -148,7 +148,7 @@ fn cmd_help(args: &[~str]) -> ValidUsage {\n     }\n \n     match args {\n-        [ref command_string] => print_usage(copy *command_string),\n+        [ref command_string] => print_usage((*command_string).clone()),\n         _                    => Invalid\n     }\n }"}, {"sha": "98fd37d7633cfbaa0eecf7f0a2573905ce05efc2", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -39,7 +39,7 @@ use syntax::attr;\n use syntax::print::pprust;\n use syntax::parse::token;\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub enum output_type {\n     output_type_none,\n     output_type_bitcode,\n@@ -291,7 +291,7 @@ pub mod write {\n             }\n \n             let passes = if sess.opts.custom_passes.len() > 0 {\n-                copy sess.opts.custom_passes\n+                sess.opts.custom_passes.clone()\n             } else {\n                 if sess.lint_llvm() {\n                     mpm.add_pass_from_name(\"lint\");\n@@ -817,7 +817,7 @@ pub fn link_binary(sess: Session,\n     // For win32, there is no cc command,\n     // so we add a condition to make it use gcc.\n     let cc_prog: ~str = match sess.opts.linker {\n-        Some(ref linker) => copy *linker,\n+        Some(ref linker) => linker.to_str(),\n         None => match sess.targ_cfg.os {\n             session::os_android =>\n                 match &sess.opts.android_cross_path {\n@@ -845,7 +845,7 @@ pub fn link_binary(sess: Session,\n \n         out_filename.dir_path().push(long_libname)\n     } else {\n-        /*bad*/copy *out_filename\n+        out_filename.clone()\n     };\n \n     debug!(\"output: %s\", output.to_str());\n@@ -896,7 +896,7 @@ pub fn link_args(sess: Session,\n         let long_libname = output_dll_filename(sess.targ_cfg.os, lm);\n         out_filename.dir_path().push(long_libname)\n     } else {\n-        /*bad*/copy *out_filename\n+        out_filename.clone()\n     };\n \n     // The default library location, we need this to find the runtime."}, {"sha": "c56ed34309c76ea93800d80e61990e5df9aac915", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -185,7 +185,7 @@ pub fn minimize_rpaths(rpaths: &[Path]) -> ~[Path] {\n     let mut minimized = ~[];\n     for rpaths.iter().advance |rpath| {\n         if set.insert(rpath.to_str()) {\n-            minimized.push(copy *rpath);\n+            minimized.push(rpath.clone());\n         }\n     }\n     minimized"}, {"sha": "2c1f3dd1918d7bcff744ce1a83211d551dfa6f7d", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -109,10 +109,14 @@ pub fn build_configuration(sess: Session, argv0: @str, input: &input) ->\n     // Combine the configuration requested by the session (command line) with\n     // some default and generated configuration items\n     let default_cfg = default_configuration(sess, argv0, input);\n-    let user_cfg = /*bad*/copy sess.opts.cfg;\n+    let user_cfg = sess.opts.cfg.clone();\n     // If the user wants a test runner, then add the test cfg\n-    let user_cfg = if sess.opts.test { append_configuration(user_cfg, @\"test\") }\n-                   else { user_cfg };\n+    let user_cfg = if sess.opts.test {\n+        append_configuration(user_cfg, @\"test\")\n+    } else {\n+        user_cfg\n+    };\n+\n     // If the user requested GC, then add the GC cfg\n     let user_cfg = append_configuration(\n         user_cfg,\n@@ -202,7 +206,8 @@ pub fn compile_rest(sess: Session,\n                      front::config::strip_unconfigured_items(crate));\n \n         crate = time(time_passes, ~\"expansion\", ||\n-                     syntax::ext::expand::expand_crate(sess.parse_sess, copy cfg,\n+                     syntax::ext::expand::expand_crate(sess.parse_sess,\n+                                                       cfg.clone(),\n                                                        crate));\n \n         // strip again, in case expansion added anything with a #[cfg].\n@@ -213,7 +218,9 @@ pub fn compile_rest(sess: Session,\n                      front::test::modify_for_testing(sess, crate));\n     }\n \n-    if phases.to == cu_expand { return (Some(crate), None); }\n+    if phases.to == cu_expand {\n+        return (Some(crate), None);\n+    }\n \n     assert!(phases.from != cu_no_trans);\n \n@@ -371,17 +378,28 @@ pub fn compile_rest(sess: Session,\n     return (None, None);\n }\n \n-pub fn compile_upto(sess: Session, cfg: ast::crate_cfg,\n-                input: &input, upto: compile_phase,\n-                outputs: Option<@OutputFilenames>)\n-    -> (Option<@ast::crate>, Option<ty::ctxt>) {\n+pub fn compile_upto(sess: Session,\n+                    cfg: ast::crate_cfg,\n+                    input: &input,\n+                    upto: compile_phase,\n+                    outputs: Option<@OutputFilenames>)\n+                    -> (Option<@ast::crate>, Option<ty::ctxt>) {\n     let time_passes = sess.time_passes();\n-    let crate = time(time_passes, ~\"parsing\",\n-                         || parse_input(sess, copy cfg, input) );\n-    if upto == cu_parse { return (Some(crate), None); }\n+    let crate = time(time_passes,\n+                     ~\"parsing\",\n+                     || parse_input(sess, cfg.clone(), input) );\n+    if upto == cu_parse {\n+        return (Some(crate), None);\n+    }\n \n-    compile_rest(sess, cfg, compile_upto { from: cu_parse, to: upto },\n-                 outputs, Some(crate))\n+    compile_rest(sess,\n+                 cfg,\n+                 compile_upto {\n+                    from: cu_parse,\n+                    to: upto\n+                 },\n+                 outputs,\n+                 Some(crate))\n }\n \n pub fn compile_input(sess: Session, cfg: ast::crate_cfg, input: &input,\n@@ -877,7 +895,7 @@ pub fn build_output_filenames(input: &input,\n           // have to make up a name\n           // We want to toss everything after the final '.'\n           let dirpath = match *odir {\n-              Some(ref d) => (/*bad*/copy *d),\n+              Some(ref d) => (*d).clone(),\n               None => match *input {\n                   str_input(_) => os::getcwd(),\n                   file_input(ref ifile) => (*ifile).dir_path()\n@@ -914,9 +932,9 @@ pub fn build_output_filenames(input: &input,\n       }\n \n       Some(ref out_file) => {\n-        out_path = (/*bad*/copy *out_file);\n+        out_path = (*out_file).clone();\n         obj_path = if stop_after_codegen {\n-            (/*bad*/copy *out_file)\n+            (*out_file).clone()\n         } else {\n             (*out_file).with_filetype(obj_suffix)\n         };"}, {"sha": "7579616b4ce1da326b936e6befc1ff7a1f487c7d", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -33,7 +33,12 @@ use std::hashmap::HashMap;\n #[deriving(Eq)]\n pub enum os { os_win32, os_macos, os_linux, os_android, os_freebsd, }\n \n-pub enum crate_type { bin_crate, lib_crate, unknown_crate, }\n+#[deriving(Clone)]\n+pub enum crate_type {\n+    bin_crate,\n+    lib_crate,\n+    unknown_crate,\n+}\n \n pub struct config {\n     os: os,\n@@ -118,14 +123,15 @@ pub fn debugging_opts_map() -> ~[(~str, ~str, uint)] {\n     ]\n }\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub enum OptLevel {\n     No, // -O0\n     Less, // -O1\n     Default, // -O2\n     Aggressive // -O3\n }\n \n+#[deriving(Clone)]\n pub struct options {\n     // The crate config requested for the session, which may be combined\n     // with additional crate configurations during the compile process\n@@ -345,10 +351,8 @@ pub fn basic_options() -> @options {\n }\n \n // Seems out of place, but it uses session, so I'm putting it here\n-pub fn expect<T:Copy>(sess: Session,\n-                       opt: Option<T>,\n-                       msg: &fn() -> ~str)\n-                    -> T {\n+pub fn expect<T:Clone>(sess: Session, opt: Option<T>, msg: &fn() -> ~str)\n+                       -> T {\n     diagnostic::expect(sess.diagnostic(), opt, msg)\n }\n "}, {"sha": "88524781191787bef261ccb744939a73cdb4f9cc", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -99,14 +99,14 @@ fn fold_item_underscore(cx: @Context, item: &ast::item_,\n         ast::item_impl(ref a, ref b, ref c, ref methods) => {\n             let methods = methods.iter().filter(|m| method_in_cfg(cx, **m))\n                 .transform(|x| *x).collect();\n-            ast::item_impl(/*bad*/ copy *a, /*bad*/ copy *b, /*bad*/ copy *c, methods)\n+            ast::item_impl((*a).clone(), (*b).clone(), (*c).clone(), methods)\n         }\n         ast::item_trait(ref a, ref b, ref methods) => {\n             let methods = methods.iter().filter(|m| trait_method_in_cfg(cx, *m) )\n-                .transform(|x| /* bad */copy *x).collect();\n-            ast::item_trait(/*bad*/copy *a, /*bad*/copy *b, methods)\n+                .transform(|x| (*x).clone()).collect();\n+            ast::item_trait((*a).clone(), (*b).clone(), methods)\n         }\n-        ref item => /*bad*/ copy *item\n+        ref item => (*item).clone(),\n     };\n \n     fold::noop_fold_item_underscore(&item, fld)\n@@ -151,25 +151,25 @@ fn fold_block(\n }\n \n fn item_in_cfg(cx: @Context, item: @ast::item) -> bool {\n-    return (cx.in_cfg)(/*bad*/copy item.attrs);\n+    return (cx.in_cfg)(item.attrs);\n }\n \n fn foreign_item_in_cfg(cx: @Context, item: @ast::foreign_item) -> bool {\n-    return (cx.in_cfg)(/*bad*/copy item.attrs);\n+    return (cx.in_cfg)(item.attrs);\n }\n \n fn view_item_in_cfg(cx: @Context, item: &ast::view_item) -> bool {\n     return (cx.in_cfg)(item.attrs);\n }\n \n fn method_in_cfg(cx: @Context, meth: @ast::method) -> bool {\n-    return (cx.in_cfg)(/*bad*/copy meth.attrs);\n+    return (cx.in_cfg)(meth.attrs);\n }\n \n fn trait_method_in_cfg(cx: @Context, meth: &ast::trait_method) -> bool {\n     match *meth {\n-        ast::required(ref meth) => (cx.in_cfg)(/*bad*/copy meth.attrs),\n-        ast::provided(@ref meth) => (cx.in_cfg)(/*bad*/copy meth.attrs)\n+        ast::required(ref meth) => (cx.in_cfg)(meth.attrs),\n+        ast::provided(@ref meth) => (cx.in_cfg)(meth.attrs)\n     }\n }\n "}, {"sha": "3d4b22ecd8c78eb8c3b30daa27d732823ffc7b38", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -64,7 +64,7 @@ fn inject_libstd_ref(sess: Session, crate: &ast::crate) -> @ast::crate {\n             let vis = vec::append(~[vi1], crate.module.view_items);\n             let mut new_module = ast::_mod {\n                 view_items: vis,\n-                ../*bad*/copy crate.module\n+                ..crate.module.clone()\n             };\n \n             if !no_prelude(crate.attrs) {\n@@ -76,7 +76,7 @@ fn inject_libstd_ref(sess: Session, crate: &ast::crate) -> @ast::crate {\n             // FIXME #2543: Bad copy.\n             let new_crate = ast::crate_ {\n                 module: new_module,\n-                ..copy *crate\n+                ..(*crate).clone()\n             };\n             (new_crate, span)\n         },\n@@ -115,7 +115,7 @@ fn inject_libstd_ref(sess: Session, crate: &ast::crate) -> @ast::crate {\n             // FIXME #2543: Bad copy.\n             let new_module = ast::_mod {\n                 view_items: vis,\n-                ..copy *module\n+                ..(*module).clone()\n             };\n             fold::noop_fold_mod(&new_module, fld)\n         },"}, {"sha": "61a530b307c457a815eeddf7213a1874d1270ade", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -66,7 +66,7 @@ fn generate_test_harness(sess: session::Session,\n     let cx: @mut TestCtxt = @mut TestCtxt {\n         sess: sess,\n         crate: crate,\n-        ext_cx: ExtCtxt::new(sess.parse_sess, copy sess.opts.cfg),\n+        ext_cx: ExtCtxt::new(sess.parse_sess, sess.opts.cfg.clone()),\n         path: ~[],\n         testfns: ~[]\n     };\n@@ -109,26 +109,31 @@ fn fold_mod(cx: @mut TestCtxt,\n \n     fn nomain(cx: @mut TestCtxt, item: @ast::item) -> @ast::item {\n         if !*cx.sess.building_library {\n-            @ast::item{\n+            @ast::item {\n                 attrs: do item.attrs.iter().filter_map |attr| {\n-                    if \"main\" != attr::get_attr_name(attr) {Some(*attr)} else {None}\n+                    if \"main\" != attr::get_attr_name(attr) {\n+                        Some(*attr)\n+                    } else {\n+                        None\n+                    }\n                 }.collect(),\n-                .. copy *item}\n-        } else { item }\n+                .. (*item).clone()\n+            }\n+        } else {\n+            item\n+        }\n     }\n \n     let mod_nomain = ast::_mod {\n-        view_items: /*bad*/copy m.view_items,\n+        view_items: m.view_items.clone(),\n         items: m.items.iter().transform(|i| nomain(cx, *i)).collect(),\n     };\n \n     fold::noop_fold_mod(&mod_nomain, fld)\n }\n \n-fn fold_crate(cx: @mut TestCtxt,\n-              c: &ast::crate_,\n-              fld: @fold::ast_fold)\n-           -> ast::crate_ {\n+fn fold_crate(cx: @mut TestCtxt, c: &ast::crate_, fld: @fold::ast_fold)\n+              -> ast::crate_ {\n     let folded = fold::noop_fold_crate(c, fld);\n \n     // Add a special __test module to the crate that will contain code\n@@ -144,7 +149,7 @@ fn fold_item(cx: @mut TestCtxt, i: @ast::item, fld: @fold::ast_fold)\n           -> Option<@ast::item> {\n     cx.path.push(i.ident);\n     debug!(\"current path: %s\",\n-           ast_util::path_name_i(copy cx.path));\n+           ast_util::path_name_i(cx.path.clone()));\n \n     if is_test_fn(cx, i) || is_bench_fn(i) {\n         match i.node {\n@@ -158,7 +163,7 @@ fn fold_item(cx: @mut TestCtxt, i: @ast::item, fld: @fold::ast_fold)\n             debug!(\"this is a test function\");\n             let test = Test {\n                 span: i.span,\n-                path: /*bad*/copy cx.path,\n+                path: cx.path.clone(),\n                 bench: is_bench_fn(i),\n                 ignore: is_ignored(cx, i),\n                 should_fail: should_fail(i)\n@@ -235,7 +240,7 @@ fn is_ignored(cx: @mut TestCtxt, i: @ast::item) -> bool {\n             .filter_map(|i| attr::get_meta_item_list(i))\n             .collect::<~[~[@ast::meta_item]]>()\n             .concat_vec();\n-        config::metas_in_cfg(/*bad*/copy cx.crate.node.config, cfg_metas)\n+        config::metas_in_cfg(cx.crate.node.config.clone(), cfg_metas)\n     } else {\n         false\n     }\n@@ -248,8 +253,8 @@ fn should_fail(i: @ast::item) -> bool {\n fn add_test_module(cx: &TestCtxt, m: &ast::_mod) -> ast::_mod {\n     let testmod = mk_test_module(cx);\n     ast::_mod {\n-        items: vec::append_one(/*bad*/copy m.items, testmod),\n-        .. /*bad*/ copy *m\n+        items: vec::append_one(m.items.clone(), testmod),\n+        ..(*m).clone()\n     }\n }\n \n@@ -333,7 +338,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n      };\n \n     debug!(\"Synthetic test module:\\n%s\\n\",\n-           pprust::item_to_str(@copy item, cx.sess.intr()));\n+           pprust::item_to_str(@item.clone(), cx.sess.intr()));\n \n     return @item;\n }\n@@ -406,7 +411,7 @@ fn mk_test_descs(cx: &TestCtxt) -> @ast::expr {\n \n fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::expr {\n     let span = test.span;\n-    let path = /*bad*/copy test.path;\n+    let path = test.path.clone();\n \n     let ext_cx = cx.ext_cx;\n "}, {"sha": "aeb2017c9d647ebd03ed55945ec0d1414b773519", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -58,6 +58,7 @@ pub enum Linkage {\n     LinkerPrivateWeakLinkage = 16,\n }\n \n+#[deriving(Clone)]\n pub enum Attribute {\n     ZExtAttribute = 1,\n     SExtAttribute = 2,"}, {"sha": "dea263532b2861019121ad08a7ea042af4560adc", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -82,8 +82,7 @@ fn warn_if_multiple_versions(e: @mut Env,\n         );\n \n         let vec: ~[Either<cache_entry, cache_entry>] = crate_cache.iter().transform(|&entry| {\n-            let othername = loader::crate_name_from_metas(\n-                copy *entry.metas);\n+            let othername = loader::crate_name_from_metas(*entry.metas);\n             if name == othername {\n                 Left(entry)\n             } else {\n@@ -100,8 +99,8 @@ fn warn_if_multiple_versions(e: @mut Env,\n             for matches.iter().advance |match_| {\n                 diag.span_note(match_.span, \"used here\");\n                 let attrs = ~[\n-                    attr::mk_attr(attr::mk_list_item(\n-                        @\"link\", /*bad*/copy *match_.metas))\n+                    attr::mk_attr(attr::mk_list_item(@\"link\",\n+                                                     (*match_.metas).clone()))\n                 ];\n                 loader::note_linkage_attrs(e.intr, diag, attrs);\n             }\n@@ -141,7 +140,11 @@ fn visit_view_item(e: @mut Env, i: &ast::view_item) {\n       ast::view_item_extern_mod(ident, ref meta_items, id) => {\n         debug!(\"resolving extern mod stmt. ident: %?, meta: %?\",\n                ident, *meta_items);\n-        let cnum = resolve_crate(e, ident, copy *meta_items, @\"\", i.span);\n+        let cnum = resolve_crate(e,\n+                                 ident,\n+                                 (*meta_items).clone(),\n+                                 @\"\",\n+                                 i.span);\n         cstore::add_extern_mod_stmt_cnum(e.cstore, id, cnum);\n       }\n       _ => ()\n@@ -306,8 +309,8 @@ fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n         let cmetas = metas_with(dep.vers, @\"vers\", ~[]);\n         debug!(\"resolving dep crate %s ver: %s hash: %s\",\n                cname_str, dep.vers, dep.hash);\n-        match existing_match(e, metas_with_ident(cname_str,\n-                                                 copy cmetas),\n+        match existing_match(e,\n+                             metas_with_ident(cname_str, cmetas.clone()),\n                              dep.hash) {\n           Some(local_cnum) => {\n             debug!(\"already have it\");"}, {"sha": "7f4bfea568fbc0fad102385101a1d3e3478276da", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -91,12 +91,13 @@ pub fn iter_crate_data(cstore: &CStore,\n \n pub fn add_used_crate_file(cstore: &mut CStore, lib: &Path) {\n     if !cstore.used_crate_files.contains(lib) {\n-        cstore.used_crate_files.push(copy *lib);\n+        cstore.used_crate_files.push((*lib).clone());\n     }\n }\n \n pub fn get_used_crate_files(cstore: &CStore) -> ~[Path] {\n-    return /*bad*/copy cstore.used_crate_files;\n+    // XXX(pcwalton): Bad copy.\n+    return cstore.used_crate_files.clone();\n }\n \n pub fn add_used_library(cstore: &mut CStore, lib: @str) -> bool {\n@@ -135,10 +136,16 @@ pub fn find_extern_mod_stmt_cnum(cstore: &CStore,\n     cstore.extern_mod_crate_map.find(&emod_id).map_consume(|x| *x)\n }\n \n+#[deriving(Clone)]\n+struct crate_hash {\n+    name: @str,\n+    vers: @str,\n+    hash: @str,\n+}\n+\n // returns hashes of crates directly used by this crate. Hashes are sorted by\n // (crate name, crate version, crate hash) in lexicographic order (not semver)\n pub fn get_dep_hashes(cstore: &CStore) -> ~[@str] {\n-    struct crate_hash { name: @str, vers: @str, hash: @str }\n     let mut result = ~[];\n \n     for cstore.extern_mod_crate_map.each_value |&cnum| {"}, {"sha": "caa170605dec30776ec2324e33ec5e46d6dc4ba9", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -714,7 +714,7 @@ pub fn maybe_get_item_ast(cdata: cmd, tcx: ty::ctxt,\n         let item_path = item_path(item_doc);\n         item_path.init().to_owned()\n     };\n-    match decode_inlined_item(cdata, tcx, copy path, item_doc) {\n+    match decode_inlined_item(cdata, tcx, /*bad*/path.clone(), item_doc) {\n       Some(ref ii) => csearch::found(*ii),\n       None => {\n         match item_parent_item(item_doc) {\n@@ -746,7 +746,7 @@ pub fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n                                 item, tcx, cdata);\n         let name = item_name(intr, item);\n         let arg_tys = match ty::get(ctor_ty).sty {\n-          ty::ty_bare_fn(ref f) => copy f.sig.inputs,\n+          ty::ty_bare_fn(ref f) => f.sig.inputs.clone(),\n           _ => ~[], // Nullary enum variant.\n         };\n         match variant_disr_val(item) {\n@@ -1149,6 +1149,7 @@ pub fn get_crate_attributes(data: @~[u8]) -> ~[ast::attribute] {\n     return get_attributes(reader::Doc(data));\n }\n \n+#[deriving(Clone)]\n pub struct crate_dep {\n     cnum: ast::crate_num,\n     name: ast::ident,"}, {"sha": "ab42e84e2acfed4504728a798633317d5a74bf02", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -128,6 +128,7 @@ fn encode_region_param(ecx: &EncodeContext,\n     }\n }\n \n+#[deriving(Clone)]\n struct entry<T> {\n     val: T,\n     pos: uint\n@@ -662,7 +663,7 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n                           -> ~[entry<int>] {\n     /* Each class has its own index, since different classes\n        may have fields with the same name */\n-    let index = @mut ~[];\n+    let mut index = ~[];\n     let tcx = ecx.tcx;\n      /* We encode both private and public fields -- need to include\n         private fields to get the offsets right */\n@@ -685,7 +686,7 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n         encode_def_id(ebml_w, local_def(id));\n         ebml_w.end_tag();\n     }\n-    /*bad*/copy *index\n+    index\n }\n \n // This is for encoding info for ctors and dtors\n@@ -781,10 +782,10 @@ fn encode_info_for_method(ecx: &EncodeContext,\n \n     let mut combined_ty_params = opt_vec::Empty;\n     for owner_generics.ty_params.iter().advance |x| {\n-        combined_ty_params.push(copy *x)\n+        combined_ty_params.push((*x).clone())\n     }\n     for method_generics.ty_params.iter().advance |x| {\n-        combined_ty_params.push(copy *x)\n+        combined_ty_params.push((*x).clone())\n     }\n     let len = combined_ty_params.len();\n     encode_type_param_bounds(ebml_w, ecx, &combined_ty_params);\n@@ -1151,7 +1152,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                 ebml_w: &mut writer::Encoder,\n                                 nitem: @foreign_item,\n                                 index: @mut ~[entry<int>],\n-                                path: ast_map::path,\n+                                path: &ast_map::path,\n                                 abi: AbiSet) {\n     index.push(entry { val: nitem.id, pos: ebml_w.writer.tell() });\n \n@@ -1164,11 +1165,11 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n         encode_name(ecx, ebml_w, nitem.ident);\n         if abi.is_intrinsic() {\n-            (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_foreign(nitem));\n+            (ecx.encode_inlined_item)(ecx, ebml_w, *path, ii_foreign(nitem));\n         } else {\n             encode_symbol(ecx, ebml_w, nitem.id);\n         }\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(nitem.ident));\n+        encode_path(ecx, ebml_w, *path, ast_map::path_name(nitem.ident));\n       }\n       foreign_item_static(_, mutbl) => {\n         encode_def_id(ebml_w, local_def(nitem.id));\n@@ -1180,7 +1181,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n         encode_symbol(ecx, ebml_w, nitem.id);\n         encode_name(ecx, ebml_w, nitem.ident);\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(nitem.ident));\n+        encode_path(ecx, ebml_w, *path, ast_map::path_name(nitem.ident));\n       }\n     }\n     ebml_w.end_tag();\n@@ -1208,12 +1209,12 @@ fn encode_info_for_items(ecx: &EncodeContext,\n     visit::visit_crate(crate, ((), visit::mk_vt(@visit::Visitor {\n         visit_expr: |_e, (_cx, _v)| { },\n         visit_item: {\n-            let ebml_w = copy *ebml_w;\n+            let ebml_w = (*ebml_w).clone();\n             |i, (cx, v)| {\n                 visit::visit_item(i, (cx, v));\n                 match items.get_copy(&i.id) {\n                     ast_map::node_item(_, pt) => {\n-                        let mut ebml_w = copy ebml_w;\n+                        let mut ebml_w = ebml_w.clone();\n                         // See above\n                         let ecx : &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n                         encode_info_for_item(ecx, &mut ebml_w, i, index, *pt);\n@@ -1223,7 +1224,7 @@ fn encode_info_for_items(ecx: &EncodeContext,\n             }\n         },\n         visit_foreign_item: {\n-            let ebml_w = copy *ebml_w;\n+            let ebml_w = (*ebml_w).clone();\n             |ni, (cx, v)| {\n                 visit::visit_foreign_item(ni, (cx, v));\n                 match items.get_copy(&ni.id) {\n@@ -1234,14 +1235,14 @@ fn encode_info_for_items(ecx: &EncodeContext,\n                                 token::get_ident_interner()),\n                                 token::ident_to_str(&ni.ident));\n \n-                        let mut ebml_w = copy ebml_w;\n+                        let mut ebml_w = ebml_w.clone();\n                         // See above\n                         let ecx : &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n                         encode_info_for_foreign_item(ecx,\n                                                      &mut ebml_w,\n                                                      ni,\n                                                      index,\n-                                                     /*bad*/copy *pt,\n+                                                     pt,\n                                                      abi);\n                     }\n                     // case for separate item and foreign-item tables\n@@ -1252,24 +1253,24 @@ fn encode_info_for_items(ecx: &EncodeContext,\n         ..*visit::default_visitor()\n     })));\n     ebml_w.end_tag();\n-    return /*bad*/copy *index;\n+    return /*bad*/(*index).clone();\n }\n \n \n // Path and definition ID indexing\n \n-fn create_index<T:Copy + Hash + IterBytes>(index: ~[entry<T>]) ->\n-   ~[@~[entry<T>]] {\n+fn create_index<T:Clone + Hash + IterBytes>(index: ~[entry<T>])\n+                                            -> ~[@~[entry<T>]] {\n     let mut buckets: ~[@mut ~[entry<T>]] = ~[];\n     for uint::range(0u, 256u) |_i| { buckets.push(@mut ~[]); };\n     for index.iter().advance |elt| {\n         let h = elt.val.hash() as uint;\n-        buckets[h % 256].push(copy *elt);\n+        buckets[h % 256].push((*elt).clone());\n     }\n \n     let mut buckets_frozen = ~[];\n     for buckets.iter().advance |bucket| {\n-        buckets_frozen.push(@/*bad*/copy **bucket);\n+        buckets_frozen.push(@/*bad*/(**bucket).clone());\n     }\n     return buckets_frozen;\n }\n@@ -1401,7 +1402,7 @@ fn synthesize_crate_attrs(ecx: &EncodeContext,\n                 match attr.node.value.node {\n                   meta_list(_, ref l) => {\n                     found_link_attr = true;;\n-                    synthesize_link_attr(ecx, /*bad*/copy *l)\n+                    synthesize_link_attr(ecx, (*l).clone())\n                   }\n                   _ => *attr\n                 }"}, {"sha": "62bbe22a0432427558952323c19b336a7616a28d", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -21,8 +21,11 @@ use std::str;\n pub type pick<'self, T> = &'self fn(path: &Path) -> Option<T>;\n \n pub fn pick_file(file: Path, path: &Path) -> Option<Path> {\n-    if path.file_path() == file { option::Some(copy *path) }\n-    else { option::None }\n+    if path.file_path() == file {\n+        option::Some((*path).clone())\n+    } else {\n+        option::None\n+    }\n }\n \n pub trait FileSearch {"}, {"sha": "5cf69e26a5019be0f839a249c4c69b76b0a8345b", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -55,11 +55,11 @@ pub struct Context {\n \n pub fn load_library_crate(cx: &Context) -> (~str, @~[u8]) {\n     match find_library_crate(cx) {\n-      Some(ref t) => return (/*bad*/copy *t),\n+      Some(ref t) => return (/*bad*/(*t).clone()),\n       None => {\n-        cx.diag.span_fatal(\n-            cx.span, fmt!(\"can't find crate for `%s`\",\n-                          token::ident_to_str(&cx.ident)));\n+        cx.diag.span_fatal(cx.span,\n+                           fmt!(\"can't find crate for `%s`\",\n+                                token::ident_to_str(&cx.ident)));\n       }\n     }\n }"}, {"sha": "987902d67a878527dbdb4ff32988c61d9c56b6b3", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -61,7 +61,7 @@ pub fn enc_ty(w: @io::Writer, cx: @ctxt, t: ty::t) {\n             Some(&s) => s,\n             None => {\n                 let s = do io::with_str_writer |wr| {\n-                    enc_sty(wr, cx, /*bad*/copy ty::get(t).sty);\n+                    enc_sty(wr, cx, &ty::get(t).sty);\n                 }.to_managed();\n                 cx.tcx.short_names_cache.insert(t, s);\n                 s\n@@ -75,7 +75,7 @@ pub fn enc_ty(w: @io::Writer, cx: @ctxt, t: ty::t) {\n               None => {}\n           }\n           let pos = w.tell();\n-          enc_sty(w, cx, /*bad*/copy ty::get(t).sty);\n+          enc_sty(w, cx, &ty::get(t).sty);\n           let end = w.tell();\n           let len = end - pos;\n           fn estimate_sz(u: uint) -> uint {\n@@ -221,8 +221,8 @@ pub fn enc_trait_store(w: @io::Writer, cx: @ctxt, s: ty::TraitStore) {\n     }\n }\n \n-fn enc_sty(w: @io::Writer, cx: @ctxt, st: ty::sty) {\n-    match st {\n+fn enc_sty(w: @io::Writer, cx: @ctxt, st: &ty::sty) {\n+    match *st {\n       ty::ty_nil => w.write_char('n'),\n       ty::ty_bot => w.write_char('z'),\n       ty::ty_bool => w.write_char('b'),\n@@ -271,7 +271,7 @@ fn enc_sty(w: @io::Writer, cx: @ctxt, st: ty::sty) {\n         enc_bounds(w, cx, &bounds);\n         w.write_char(']');\n       }\n-      ty::ty_tup(ts) => {\n+      ty::ty_tup(ref ts) => {\n         w.write_str(&\"T[\");\n         for ts.iter().advance |t| { enc_ty(w, cx, *t); }\n         w.write_char(']');"}, {"sha": "d4d20e75c9de603e5d8058b013c40b9c57d88a9e", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -106,7 +106,7 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n                            tcx: ty::ctxt,\n                            maps: Maps,\n-                           path: ast_map::path,\n+                           path: &[ast_map::path_elt],\n                            par_doc: ebml::Doc)\n                         -> Option<ast::inlined_item> {\n     let dcx = @DecodeContext {\n@@ -134,7 +134,9 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n                ast_map::path_to_str(path, token::get_ident_interner()),\n                tcx.sess.str_of(ii.ident()));\n         ast_map::map_decoded_item(tcx.sess.diagnostic(),\n-                                  dcx.tcx.items, path, &ii);\n+                                  dcx.tcx.items,\n+                                  path.to_owned(),\n+                                  &ii);\n         decode_side_tables(xcx, ast_doc);\n         match ii {\n           ast::ii_item(i) => {\n@@ -618,7 +620,7 @@ fn encode_vtable_origin(ecx: &e::EncodeContext,\n                     ebml_w.emit_def_id(def_id)\n                 }\n                 do ebml_w.emit_enum_variant_arg(1u) |ebml_w| {\n-                    ebml_w.emit_tys(ecx, /*bad*/copy *tys);\n+                    ebml_w.emit_tys(ecx, *tys);\n                 }\n                 do ebml_w.emit_enum_variant_arg(2u) |ebml_w| {\n                     encode_vtable_res(ecx, ebml_w, vtable_res);\n@@ -814,7 +816,7 @@ fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n                              ebml_w: &mut writer::Encoder,\n                              ii: &ast::inlined_item) {\n     ebml_w.start_tag(c::tag_table as uint);\n-    let new_ebml_w = copy *ebml_w;\n+    let new_ebml_w = (*ebml_w).clone();\n \n     // Because the ast visitor uses @fn, I can't pass in\n     // ecx directly, but /I/ know that it'll be fine since\n@@ -827,7 +829,7 @@ fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n             // Note: this will cause a copy of ebml_w, which is bad as\n             // it is mutable. But I believe it's harmless since we generate\n             // balanced EBML.\n-            let mut new_ebml_w = copy new_ebml_w;\n+            let mut new_ebml_w = new_ebml_w.clone();\n             // See above\n             let ecx : &e::EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n             encode_side_tables_for_id(ecx, maps, &mut new_ebml_w, id)"}, {"sha": "d6a373445b76df19c5ebeccfd8728505e3a06251", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -49,6 +49,15 @@ pub mod gather_loans;\n pub mod move_data;\n \n pub struct LoanDataFlowOperator;\n+\n+/// XXX(pcwalton): Should just be #[deriving(Clone)], but that doesn't work\n+/// yet on unit structs.\n+impl Clone for LoanDataFlowOperator {\n+    fn clone(&self) -> LoanDataFlowOperator {\n+        LoanDataFlowOperator\n+    }\n+}\n+\n pub type LoanDataFlow = DataFlowContext<LoanDataFlowOperator>;\n \n pub fn check_crate("}, {"sha": "b96a91f568223445d0772a073e34038dcf3ca3d1", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -71,6 +71,12 @@ pub struct FlowedMoveData {\n #[deriving(Eq)]\n pub struct MovePathIndex(uint);\n \n+impl Clone for MovePathIndex {\n+    fn clone(&self) -> MovePathIndex {\n+        MovePathIndex(**self)\n+    }\n+}\n+\n static InvalidMovePathIndex: MovePathIndex =\n     MovePathIndex(uint::max_value);\n \n@@ -133,9 +139,27 @@ pub struct Assignment {\n }\n \n pub struct MoveDataFlowOperator;\n+\n+/// XXX(pcwalton): Should just be #[deriving(Clone)], but that doesn't work\n+/// yet on unit structs.\n+impl Clone for MoveDataFlowOperator {\n+    fn clone(&self) -> MoveDataFlowOperator {\n+        MoveDataFlowOperator\n+    }\n+}\n+\n pub type MoveDataFlow = DataFlowContext<MoveDataFlowOperator>;\n \n pub struct AssignDataFlowOperator;\n+\n+/// XXX(pcwalton): Should just be #[deriving(Clone)], but that doesn't work\n+/// yet on unit structs.\n+impl Clone for AssignDataFlowOperator {\n+    fn clone(&self) -> AssignDataFlowOperator {\n+        AssignDataFlowOperator\n+    }\n+}\n+\n pub type AssignDataFlow = DataFlowContext<AssignDataFlowOperator>;\n \n impl MoveData {"}, {"sha": "f6d23dde14338c4b77f8b1e8dfafe26fa9c0a093", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -194,20 +194,21 @@ pub fn check_expr(sess: Session,\n     visit::visit_expr(e, (is_const, v));\n }\n \n+#[deriving(Clone)]\n+struct env {\n+    root_it: @item,\n+    sess: Session,\n+    ast_map: ast_map::map,\n+    def_map: resolve::DefMap,\n+    idstack: @mut ~[node_id]\n+}\n+\n // Make sure a const item doesn't recursively refer to itself\n // FIXME: Should use the dependency graph when it's available (#1356)\n pub fn check_item_recursion(sess: Session,\n                             ast_map: ast_map::map,\n                             def_map: resolve::DefMap,\n                             it: @item) {\n-    struct env {\n-        root_it: @item,\n-        sess: Session,\n-        ast_map: ast_map::map,\n-        def_map: resolve::DefMap,\n-        idstack: @mut ~[node_id]\n-    }\n-\n     let env = env {\n         root_it: it,\n         sess: sess,"}, {"sha": "a8cef8eb27653b479934e2fd74995348a33b1373", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -14,6 +14,7 @@ use middle::ty;\n use syntax::ast::*;\n use syntax::visit;\n \n+#[deriving(Clone)]\n pub struct Context {\n     in_loop: bool,\n     can_ret: bool"}, {"sha": "928e02b9165353c346d875df4f85d17f3eabd5c4", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -473,7 +473,7 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                   left_ty: ty::t)\n                -> Option<~[@pat]> {\n     // Sad, but I can't get rid of this easily\n-    let r0 = copy *raw_pat(r[0]);\n+    let r0 = (*raw_pat(r[0])).clone();\n     match r0 {\n         pat{id: pat_id, node: n, span: pat_span} =>\n             match n {"}, {"sha": "15e61145262fb472f8038691504d5ef035cf9add", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -238,7 +238,7 @@ pub fn lookup_const_by_id(tcx: ty::ctxt,\n             capture_map: @mut HashMap::new()\n         };\n         match csearch::maybe_get_item_ast(tcx, def_id,\n-            |a, b, c, d| astencode::decode_inlined_item(a, b, maps, /*bar*/ copy c, d)) {\n+            |a, b, c, d| astencode::decode_inlined_item(a, b, maps, c, d)) {\n             csearch::found(ast::ii_item(item)) => match item.node {\n                 item_static(_, ast::m_imm, const_expr) => Some(const_expr),\n                 _ => None\n@@ -275,7 +275,7 @@ pub fn process_crate(crate: &ast::crate,\n \n // FIXME (#33): this doesn't handle big integer/float literals correctly\n // (nor does the rest of our literal handling).\n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub enum const_val {\n     const_float(f64),\n     const_int(i64),\n@@ -303,7 +303,7 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &expr)\n           Ok(const_uint(i)) => Ok(const_uint(-i)),\n           Ok(const_str(_)) => Err(~\"Negate on string\"),\n           Ok(const_bool(_)) => Err(~\"Negate on boolean\"),\n-          ref err => (/*bad*/copy *err)\n+          ref err => ((*err).clone())\n         }\n       }\n       expr_unary(_, not, inner) => {\n@@ -410,28 +410,34 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &expr)\n       expr_cast(base, _) => {\n         let ety = tcx.expr_ty(e);\n         let base = eval_const_expr_partial(tcx, base);\n-        match /*bad*/copy base {\n+        match base {\n             Err(_) => base,\n             Ok(val) => {\n                 match ty::get(ety).sty {\n-                    ty::ty_float(_) => match val {\n-                        const_uint(u) => Ok(const_float(u as f64)),\n-                        const_int(i) => Ok(const_float(i as f64)),\n-                        const_float(_) => base,\n-                        _ => Err(~\"Can't cast float to str\"),\n-                    },\n-                    ty::ty_uint(_) => match val {\n-                        const_uint(_) => base,\n-                        const_int(i) => Ok(const_uint(i as u64)),\n-                        const_float(f) => Ok(const_uint(f as u64)),\n-                        _ => Err(~\"Can't cast str to uint\"),\n-                    },\n-                    ty::ty_int(_) | ty::ty_bool => match val {\n-                        const_uint(u) => Ok(const_int(u as i64)),\n-                        const_int(_) => base,\n-                        const_float(f) => Ok(const_int(f as i64)),\n-                        _ => Err(~\"Can't cast str to int\"),\n-                    },\n+                    ty::ty_float(_) => {\n+                        match val {\n+                            const_uint(u) => Ok(const_float(u as f64)),\n+                            const_int(i) => Ok(const_float(i as f64)),\n+                            const_float(f) => Ok(const_float(f)),\n+                            _ => Err(~\"Can't cast float to str\"),\n+                        }\n+                    }\n+                    ty::ty_uint(_) => {\n+                        match val {\n+                            const_uint(u) => Ok(const_uint(u)),\n+                            const_int(i) => Ok(const_uint(i as u64)),\n+                            const_float(f) => Ok(const_uint(f as u64)),\n+                            _ => Err(~\"Can't cast str to uint\"),\n+                        }\n+                    }\n+                    ty::ty_int(_) | ty::ty_bool => {\n+                        match val {\n+                            const_uint(u) => Ok(const_int(u as i64)),\n+                            const_int(i) => Ok(const_int(i)),\n+                            const_float(f) => Ok(const_int(f as i64)),\n+                            _ => Err(~\"Can't cast str to int\"),\n+                        }\n+                    }\n                     _ => Err(~\"Can't cast this type\")\n                 }\n             }"}, {"sha": "62d1b552691d85949d34cea5879eefcf1cc72f5d", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -30,6 +30,7 @@ use middle::ty;\n use middle::typeck;\n use util::ppaux::Repr;\n \n+#[deriving(Clone)]\n pub struct DataFlowContext<O> {\n     priv tcx: ty::ctxt,\n     priv method_map: typeck::method_map,\n@@ -294,8 +295,8 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n     }\n }\n \n-impl<O:DataFlowOperator+Copy+'static> DataFlowContext<O> {\n-//                      ^^^^^^^^^^^^ only needed for pretty printing\n+impl<O:DataFlowOperator+Clone+'static> DataFlowContext<O> {\n+//                      ^^^^^^^^^^^^^ only needed for pretty printing\n     pub fn propagate(&mut self, blk: &ast::blk) {\n         //! Performs the data flow analysis.\n \n@@ -304,23 +305,25 @@ impl<O:DataFlowOperator+Copy+'static> DataFlowContext<O> {\n             return;\n         }\n \n-        let mut propcx = PropagationContext {\n-            dfcx: self,\n-            changed: true\n-        };\n+        {\n+            let mut propcx = PropagationContext {\n+                dfcx: self,\n+                changed: true\n+            };\n \n-        let mut temp = vec::from_elem(self.words_per_id, 0);\n-        let mut loop_scopes = ~[];\n+            let mut temp = vec::from_elem(self.words_per_id, 0u);\n+            let mut loop_scopes = ~[];\n \n-        while propcx.changed {\n-            propcx.changed = false;\n-            propcx.reset(temp);\n-            propcx.walk_block(blk, temp, &mut loop_scopes);\n+            while propcx.changed {\n+                propcx.changed = false;\n+                propcx.reset(temp);\n+                propcx.walk_block(blk, temp, &mut loop_scopes);\n+            }\n         }\n \n         debug!(\"Dataflow result:\");\n         debug!(\"%s\", {\n-            let this = @copy *self;\n+            let this = @(*self).clone();\n             this.pretty_print_to(io::stderr(), blk);\n             \"\"\n         });\n@@ -897,7 +900,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n         // statement.\n         let initial_state = reslice(in_out).to_owned();\n         for pats.iter().advance |&pat| {\n-            let mut temp = copy initial_state;\n+            let mut temp = initial_state.clone();\n             self.walk_pat(pat, temp, loop_scopes);\n             join_bits(&self.dfcx.oper, temp, in_out);\n         }"}, {"sha": "0bbe674d8212f5383ac4a64adb81ac481e221b1e", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -79,7 +79,7 @@ fn collect_freevars(def_map: resolve::DefMap, blk: &ast::blk)\n                                           visit_expr: walk_expr,\n                                           .. *visit::default_visitor()});\n     (v.visit_block)(blk, (1, v));\n-    return @/*bad*/copy *refs;\n+    return @(*refs).clone();\n }\n \n // Build a map from every function and for-each body to a set of the"}, {"sha": "6d9a15a3c34175d943e77c0f5c3d5a82a5c8d1a3", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -53,6 +53,7 @@ use syntax::{visit, ast_util};\n \n pub static try_adding: &'static str = \"Try adding a move\";\n \n+#[deriving(Clone)]\n pub struct Context {\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,"}, {"sha": "0e4b2805cce4de124fc486fd05fdf1354bd6ae55", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -67,7 +67,7 @@ use syntax::{ast, visit, ast_util};\n  * item that's being warned about.\n  */\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub enum lint {\n     ctypes,\n     unused_imports,\n@@ -109,7 +109,7 @@ pub fn level_to_str(lv: level) -> &'static str {\n     }\n }\n \n-#[deriving(Eq, Ord)]\n+#[deriving(Clone, Eq, Ord)]\n pub enum level {\n     allow, warn, deny, forbid\n }\n@@ -652,8 +652,11 @@ fn lint_type_limits() -> visit::vt<@mut Context> {\n         }\n     }\n \n-    fn check_limits(cx: &Context, binop: ast::binop, l: &ast::expr,\n-                    r: &ast::expr) -> bool {\n+    fn check_limits(cx: &Context,\n+                    binop: ast::binop,\n+                    l: @ast::expr,\n+                    r: @ast::expr)\n+                    -> bool {\n         let (lit, expr, swap) = match (&l.node, &r.node) {\n             (&ast::expr_lit(_), _) => (l, r, true),\n             (_, &ast::expr_lit(_)) => (r, l, false),\n@@ -666,7 +669,7 @@ fn lint_type_limits() -> visit::vt<@mut Context> {\n         } else {\n             binop\n         };\n-        match ty::get(ty::expr_ty(cx.tcx, @/*bad*/copy *expr)).sty {\n+        match ty::get(ty::expr_ty(cx.tcx, expr)).sty {\n             ty::ty_int(int_ty) => {\n                 let (min, max) = int_ty_range(int_ty);\n                 let lit_val: i64 = match lit.node {\n@@ -708,7 +711,7 @@ fn lint_type_limits() -> visit::vt<@mut Context> {\n     visit::mk_vt(@visit::Visitor {\n         visit_expr: |e, (cx, vt): (@mut Context, visit::vt<@mut Context>)| {\n             match e.node {\n-                ast::expr_binary(_, ref binop, @ref l, @ref r) => {\n+                ast::expr_binary(_, ref binop, l, r) => {\n                     if is_comparison(*binop)\n                         && !check_limits(cx, *binop, l, r) {\n                         cx.span_lint(type_limits, e.span,"}, {"sha": "689a4931b37df1a416d94253daa13544e59b2354", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -128,6 +128,12 @@ struct Variable(uint);\n #[deriving(Eq)]\n struct LiveNode(uint);\n \n+impl Clone for LiveNode {\n+    fn clone(&self) -> LiveNode {\n+        LiveNode(**self)\n+    }\n+}\n+\n #[deriving(Eq)]\n enum LiveNodeKind {\n     FreeVarNode(span),\n@@ -522,6 +528,7 @@ fn visit_expr(expr: @expr, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n // Actually we compute just a bit more than just liveness, but we use\n // the same basic propagation framework in all cases.\n \n+#[deriving(Clone)]\n struct Users {\n     reader: LiveNode,\n     writer: LiveNode,"}, {"sha": "79d7f397bb25b611c35366b8e4d7c242d4020ccd", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -170,12 +170,14 @@ pub type MovesMap = @mut HashSet<node_id>;\n pub type MovedVariablesSet = @mut HashSet<node_id>;\n \n /** See the section Output on the module comment for explanation. */\n+#[deriving(Clone)]\n pub struct MoveMaps {\n     moves_map: MovesMap,\n     moved_variables_set: MovedVariablesSet,\n     capture_map: CaptureMap\n }\n \n+#[deriving(Clone)]\n struct VisitContext {\n     tcx: ty::ctxt,\n     method_map: method_map,"}, {"sha": "036c0751483435c2c3f91067490647eac64a01ca", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -376,7 +376,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n         visit_item: |item, (method_map, visitor)| {\n             // Do not check privacy inside items with the resolve_unexported\n             // attribute. This is used for the test runner.\n-            if !attr::contains_name(attr::attr_metas(/*bad*/copy item.attrs),\n+            if !attr::contains_name(attr::attr_metas(item.attrs),\n                                     \"!resolve_unexported\") {\n                 visit::visit_item(item, (method_map, visitor));\n             }"}, {"sha": "a0ba9ac5a8841c161ea53c9cb6bc99632fcc7374", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -76,7 +76,7 @@ fn trait_method_might_be_inlined(trait_method: &trait_method) -> bool {\n // The context we're in. If we're in a public context, then public symbols are\n // marked reachable. If we're in a private context, then only trait\n // implementations are marked reachable.\n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n enum PrivacyContext {\n     PublicContext,\n     PrivateContext,"}, {"sha": "69c22ee5220643e0d2f6aae21d53cf8446faccbc", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -60,6 +60,7 @@ pub struct RegionMaps {\n     priv cleanup_scopes: HashSet<ast::node_id>\n }\n \n+#[deriving(Clone)]\n pub struct Context {\n     sess: Session,\n     def_map: resolve::DefMap,"}, {"sha": "80078eba239368723c79725d8f5e2933e2438803", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -158,6 +158,7 @@ pub enum ImportDirectiveSubclass {\n }\n \n /// The context that we thread through while building the reduced graph.\n+#[deriving(Clone)]\n pub enum ReducedGraphParent {\n     ModuleReducedGraphParent(@mut Module)\n }\n@@ -1483,12 +1484,13 @@ impl Resolver {\n                             for source_idents.iter().advance |source_ident| {\n                                 let name = source_ident.node.name;\n                                 let subclass = @SingleImport(name, name);\n-                                self.build_import_directive(privacy,\n-                                                            module_,\n-                                                            copy module_path,\n-                                                            subclass,\n-                                                            source_ident.span,\n-                                                            source_ident.node.id);\n+                                self.build_import_directive(\n+                                    privacy,\n+                                    module_,\n+                                    module_path.clone(),\n+                                    subclass,\n+                                    source_ident.span,\n+                                    source_ident.node.id);\n                             }\n                         }\n                         view_path_glob(_, id) => {\n@@ -5165,13 +5167,13 @@ impl Resolver {\n         match self.method_map.find(&name) {\n             Some(candidate_traits) => loop {\n                 // Look for the current trait.\n-                match /*bad*/copy self.current_trait_refs {\n-                    Some(trait_def_ids) => {\n+                match self.current_trait_refs {\n+                    Some(ref trait_def_ids) => {\n                         for trait_def_ids.iter().advance |trait_def_id| {\n                             if candidate_traits.contains(trait_def_id) {\n-                                self.add_trait_info(\n-                                    &mut found_traits,\n-                                    *trait_def_id, name);\n+                                self.add_trait_info(&mut found_traits,\n+                                                    *trait_def_id,\n+                                                    name);\n                             }\n                         }\n                     }\n@@ -5428,10 +5430,9 @@ pub fn resolve_crate(session: Session,\n                   -> CrateMap {\n     let resolver = @mut Resolver(session, lang_items, crate);\n     resolver.resolve();\n-    let Resolver { def_map, export_map2, trait_map, _ } = copy *resolver;\n     CrateMap {\n-        def_map: def_map,\n-        exp_map2: export_map2,\n-        trait_map: trait_map\n+        def_map: resolver.def_map,\n+        exp_map2: resolver.export_map2,\n+        trait_map: resolver.trait_map.clone(),\n     }\n }"}, {"sha": "718bb4c9e20c4237831ee06f51341f876e82a2ed", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -76,7 +76,7 @@\n  *\n  *    let a: A = ...;\n  *    let b: B = ...;\n- *    match (a, b) { (ref c, copy d) => { ... } }\n+ *    match (a, b) { (ref c, d) => { ... } }\n  *\n  * For `c` and `d`, we would generate allocas of type `C*` and `D*`\n  * respectively.  These are called the `llmatch`.  As we match, when we come\n@@ -540,9 +540,10 @@ pub fn enter_opt<'r>(bcx: block,\n             }\n             ast::pat_enum(_, ref subpats) => {\n                 if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n+                    // XXX: Must we clone?\n                     match *subpats {\n                         None => Some(vec::from_elem(variant_size, dummy)),\n-                        _ => copy *subpats\n+                        _ => (*subpats).clone(),\n                     }\n                 } else {\n                     None\n@@ -597,7 +598,7 @@ pub fn enter_opt<'r>(bcx: block,\n                         let n = before.len() + after.len();\n                         let i = before.len();\n                         if opt_eq(tcx, &vec_len_ge(n, i), opt) {\n-                            Some(vec::append_one(copy *before, slice) +\n+                            Some(vec::append_one((*before).clone(), slice) +\n                                     *after)\n                         } else {\n                             None\n@@ -606,7 +607,7 @@ pub fn enter_opt<'r>(bcx: block,\n                     None => {\n                         let n = before.len();\n                         if opt_eq(tcx, &vec_len_eq(n), opt) {\n-                            Some(copy *before)\n+                            Some((*before).clone())\n                         } else {\n                             None\n                         }\n@@ -673,9 +674,7 @@ pub fn enter_tup<'r>(bcx: block,\n     let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n-            ast::pat_tup(ref elts) => {\n-                Some(copy *elts)\n-            }\n+            ast::pat_tup(ref elts) => Some((*elts).clone()),\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n                 Some(vec::from_elem(n_elts, dummy))\n@@ -701,7 +700,7 @@ pub fn enter_tuple_struct<'r>(bcx: block,\n     let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n-            ast::pat_enum(_, Some(ref elts)) => Some(copy *elts),\n+            ast::pat_enum(_, Some(ref elts)) => Some((*elts).clone()),\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n                 Some(vec::from_elem(n_elts, dummy))\n@@ -1582,7 +1581,7 @@ pub fn compile_submatch(bcx: block,\n                 let args = extract_vec_elems(opt_cx, pat_span, pat_id, n, slice,\n                                              val, test_val);\n                 size = args.vals.len();\n-                unpacked = /*bad*/copy args.vals;\n+                unpacked = args.vals.clone();\n                 opt_cx = args.bcx;\n             }\n             lit(_) | range(_, _) => ()\n@@ -1606,7 +1605,7 @@ pub fn compile_submatch(bcx: block,\n pub fn trans_match(bcx: block,\n                    match_expr: &ast::expr,\n                    discr_expr: @ast::expr,\n-                   arms: ~[ast::arm],\n+                   arms: &[ast::arm],\n                    dest: Dest) -> block {\n     let _icx = push_ctxt(\"match::trans_match\");\n     do with_scope(bcx, match_expr.info(), \"match\") |bcx| {"}, {"sha": "821242d64c96cfb8e0822a7bc2fb78cd52f9ce2a", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -191,9 +191,11 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n                             Some(ptrfield) => {\n                                 return NullablePointer {\n                                     nndiscr: discr,\n-                                    nonnull: mk_struct(cx, cases[discr].tys, false),\n+                                    nonnull: mk_struct(cx,\n+                                                       cases[discr].tys,\n+                                                       false),\n                                     ptrfield: ptrfield,\n-                                    nullfields: copy cases[1 - discr].tys\n+                                    nullfields: cases[1 - discr].tys.clone()\n                                 }\n                             }\n                             None => { }"}, {"sha": "9d8bac6467e9151461ca116afaa219bde1dc5b15", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 36, "deletions": 22, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -112,7 +112,7 @@ impl Drop for _InsnCtxt {\n     fn drop(&self) {\n         do local_data::modify(task_local_insn_key) |c| {\n             do c.map_consume |ctx| {\n-                let mut ctx = copy *ctx;\n+                let mut ctx = (*ctx).clone();\n                 ctx.pop();\n                 @ctx\n             }\n@@ -124,7 +124,7 @@ pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n     debug!(\"new InsnCtxt: %s\", s);\n     do local_data::modify(task_local_insn_key) |c| {\n         do c.map_consume |ctx| {\n-            let mut ctx = copy *ctx;\n+            let mut ctx = (*ctx).clone();\n             ctx.push(s);\n             @ctx\n         }\n@@ -1413,7 +1413,7 @@ pub fn with_scope(bcx: block,\n     let scope = simple_block_scope(bcx.scope, opt_node_info);\n     bcx.scope = Some(scope);\n     let ret = f(bcx);\n-    let ret = trans_block_cleanups_(ret, /*bad*/copy scope.cleanups, false);\n+    let ret = trans_block_cleanups_(ret, (scope.cleanups).clone(), false);\n     bcx.scope = scope.parent;\n     ret\n }\n@@ -1427,7 +1427,9 @@ pub fn with_scope_result(bcx: block,\n     let scope = simple_block_scope(bcx.scope, opt_node_info);\n     bcx.scope = Some(scope);\n     let Result { bcx: out_bcx, val } = f(bcx);\n-    let out_bcx = trans_block_cleanups_(out_bcx, /*bad*/copy scope.cleanups, false);\n+    let out_bcx = trans_block_cleanups_(out_bcx,\n+                                        (scope.cleanups).clone(),\n+                                        false);\n     bcx.scope = scope.parent;\n \n     rslt(out_bcx, val)\n@@ -1932,7 +1934,7 @@ pub fn trans_fn(ccx: @mut CrateContext,\n     let _icx = push_ctxt(\"trans_fn\");\n     let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, id));\n     trans_closure(ccx,\n-                  copy path,\n+                  path.clone(),\n                   decl,\n                   body,\n                   llfndecl,\n@@ -2038,7 +2040,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n     let fn_args = do args.map |varg| {\n         ast::arg {\n             is_mutbl: false,\n-            ty: copy *varg.ty(),\n+            ty: (*varg.ty()).clone(),\n             pat: ast_util::ident_to_pat(\n                 ccx.tcx.sess.next_node_id(),\n                 codemap::dummy_sp(),\n@@ -2047,12 +2049,21 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n         }\n     };\n \n+    let no_substs: &[ty::t] = [];\n     let ty_param_substs = match param_substs {\n-        Some(ref substs) => { copy substs.tys }\n-        None => ~[]\n+        Some(ref substs) => {\n+            let v: &[ty::t] = substs.tys;\n+            v\n+        }\n+        None => {\n+            let v: &[ty::t] = no_substs;\n+            v\n+        }\n     };\n \n-    let ctor_ty = ty::subst_tps(ccx.tcx, ty_param_substs, None,\n+    let ctor_ty = ty::subst_tps(ccx.tcx,\n+                                ty_param_substs,\n+                                None,\n                                 ty::node_id_to_type(ccx.tcx, ctor_id));\n \n     let result_ty = match ty::get(ctor_ty).sty {\n@@ -2130,7 +2141,7 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n         if purity == ast::extern_fn  {\n             let llfndecl = get_item_val(ccx, item.id);\n             foreign::trans_foreign_fn(ccx,\n-                                      vec::append(/*bad*/copy *path,\n+                                      vec::append((*path).clone(),\n                                                   [path_name(item.ident)]),\n                                       decl,\n                                       body,\n@@ -2139,7 +2150,7 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n         } else if !generics.is_type_parameterized() {\n             let llfndecl = get_item_val(ccx, item.id);\n             trans_fn(ccx,\n-                     vec::append(/*bad*/copy *path, [path_name(item.ident)]),\n+                     vec::append((*path).clone(), [path_name(item.ident)]),\n                      decl,\n                      body,\n                      llfndecl,\n@@ -2160,8 +2171,12 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n         }\n       }\n       ast::item_impl(ref generics, _, _, ref ms) => {\n-        meth::trans_impl(ccx, /*bad*/copy *path, item.ident, *ms,\n-                         generics, item.id);\n+        meth::trans_impl(ccx,\n+                         (*path).clone(),\n+                         item.ident,\n+                         *ms,\n+                         generics,\n+                         item.id);\n       }\n       ast::item_mod(ref m) => {\n         trans_mod(ccx, m);\n@@ -2274,7 +2289,7 @@ pub fn register_fn_fuller(ccx: @mut CrateContext,\n     let ps = if attr::attrs_contains_name(attrs, \"no_mangle\") {\n         path_elt_to_str(*path.last(), token::get_ident_interner())\n     } else {\n-        mangle_exported_name(ccx, /*bad*/copy path, node_type)\n+        mangle_exported_name(ccx, path, node_type)\n     };\n \n     let llfn = decl_fn(ccx.llmod, ps, cc, fn_ty);\n@@ -2432,7 +2447,7 @@ pub fn item_path(ccx: &CrateContext, i: &ast::item) -> path {\n             // separate map for paths?\n         _ => fail!(\"item_path\")\n     };\n-    vec::append(/*bad*/copy *base, [path_name(i.ident)])\n+    vec::append((*base).clone(), [path_name(i.ident)])\n }\n \n pub fn get_item_val(ccx: @mut CrateContext, id: ast::node_id) -> ValueRef {\n@@ -2445,8 +2460,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::node_id) -> ValueRef {\n         let item = ccx.tcx.items.get_copy(&id);\n         let val = match item {\n           ast_map::node_item(i, pth) => {\n-            let my_path = vec::append(/*bad*/copy *pth,\n-                                      [path_name(i.ident)]);\n+            let my_path = vec::append((*pth).clone(), [path_name(i.ident)]);\n             match i.node {\n               ast::item_static(_, m, expr) => {\n                 let typ = ty::node_id_to_type(ccx.tcx, i.id);\n@@ -2502,7 +2516,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::node_id) -> ValueRef {\n             match ni.node {\n                 ast::foreign_item_fn(*) => {\n                     register_fn(ccx, ni.span,\n-                                vec::append(/*bad*/copy *pth,\n+                                vec::append((*pth).clone(),\n                                             [path_name(ni.ident)]),\n                                 ni.id,\n                                 ni.attrs)\n@@ -2526,7 +2540,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::node_id) -> ValueRef {\n             match v.node.kind {\n                 ast::tuple_variant_kind(ref args) => {\n                     assert!(args.len() != 0u);\n-                    let pth = vec::append(/*bad*/copy *pth,\n+                    let pth = vec::append((*pth).clone(),\n                                           [path_name(enm.ident),\n                                            path_name((*v).node.name)]);\n                     llfn = match enm.node {\n@@ -2554,7 +2568,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::node_id) -> ValueRef {\n                 Some(ctor_id) => {\n                     let llfn = register_fn(ccx,\n                                            struct_item.span,\n-                                           /*bad*/copy *struct_path,\n+                                           (*struct_path).clone(),\n                                            ctor_id,\n                                            struct_item.attrs);\n                     set_inline_hint(llfn);\n@@ -2583,7 +2597,7 @@ pub fn register_method(ccx: @mut CrateContext,\n                        m: @ast::method) -> ValueRef {\n     let mty = ty::node_id_to_type(ccx.tcx, id);\n \n-    let mut path = /*bad*/ copy *path;\n+    let mut path = (*path).clone();\n     path.push(path_name(gensym_name(\"meth\")));\n     path.push(path_name(m.ident));\n \n@@ -2603,7 +2617,7 @@ pub fn trans_constant(ccx: &mut CrateContext, it: @ast::item) {\n         let mut i = 0;\n         let path = item_path(ccx, it);\n         for (*enum_definition).variants.iter().advance |variant| {\n-            let p = vec::append(/*bad*/copy path, [\n+            let p = vec::append(path.clone(), [\n                 path_name(variant.node.name),\n                 path_name(special_idents::descrim)\n             ]);"}, {"sha": "26fce42f8e35e20cd787caaa02d0eb9dfd27c1fc", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -897,7 +897,7 @@ pub fn add_span_comment(bcx: block, sp: span, text: &str) {\n     let ccx = bcx.ccx();\n     if ccx.sess.asm_comments() {\n         let s = fmt!(\"%s (%s)\", text, ccx.sess.codemap.span_to_str(sp));\n-        debug!(\"%s\", copy s);\n+        debug!(\"%s\", s);\n         add_comment(bcx, s);\n     }\n }"}, {"sha": "b7e157bc7e25423fdc442a6c4ecaff064002cbe3", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -22,6 +22,7 @@ pub trait ABIInfo {\n     fn compute_info(&self, atys: &[Type], rty: Type, ret_def: bool) -> FnType;\n }\n \n+#[deriving(Clone)]\n pub struct LLVMType {\n     cast: bool,\n     ty: Type"}, {"sha": "fb09c8994ce7708e57e3a123553760b91a0831a4", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -24,7 +24,7 @@ use std::option::Option;\n use std::uint;\n use std::vec;\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n enum RegClass {\n     NoClass,\n     Int,"}, {"sha": "0885c5086e857fa98c37d53e0af0d8648bff01d5", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -221,7 +221,7 @@ fn resolve_default_method_vtables(bcx: block,\n     // Build up a param_substs that we are going to resolve the\n     // trait_vtables under.\n     let param_substs = Some(@param_substs {\n-        tys: copy substs.tps,\n+        tys: substs.tps.clone(),\n         self_ty: substs.self_ty,\n         vtables: impl_vtables,\n         self_vtable: None"}, {"sha": "6b10d53dd410594588a29b91f723ca7310e331e8", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -423,11 +423,11 @@ pub fn trans_expr_fn(bcx: block,\n \n     let llfnty = type_of_fn_from_ty(ccx, fty);\n \n-    let sub_path = vec::append_one(/*bad*/copy bcx.fcx.path,\n+    let sub_path = vec::append_one(bcx.fcx.path.clone(),\n                                    path_name(special_idents::anon));\n     // XXX: Bad copy.\n     let s = mangle_internal_name_by_path_and_seq(ccx,\n-                                                 copy sub_path,\n+                                                 sub_path.clone(),\n                                                  \"expr_fn\");\n     let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n "}, {"sha": "29cc8d8197317b8aef4e90bded5ea7a7266a0116", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -287,7 +287,7 @@ pub enum heap {\n     heap_exchange_closure\n }\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub enum cleantype {\n     normal_exit_only,\n     normal_exit_and_unwind\n@@ -298,8 +298,19 @@ pub enum cleanup {\n     clean_temp(ValueRef, @fn(block) -> block, cleantype),\n }\n \n+// Can't use deriving(Clone) because of the managed closure.\n+impl Clone for cleanup {\n+    fn clone(&self) -> cleanup {\n+        match *self {\n+            clean(f, ct) => clean(f, ct),\n+            clean_temp(v, f, ct) => clean_temp(v, f, ct),\n+        }\n+    }\n+}\n+\n // Used to remember and reuse existing cleanup paths\n // target: none means the path ends in an resume instruction\n+#[deriving(Clone)]\n pub struct cleanup_path {\n     target: Option<BasicBlockRef>,\n     size: uint,\n@@ -441,7 +452,7 @@ pub fn revoke_clean(cx: block, val: ValueRef) {\n pub fn block_cleanups(bcx: block) -> ~[cleanup] {\n     match bcx.scope {\n        None  => ~[],\n-       Some(inf) => /*bad*/copy inf.cleanups\n+       Some(inf) => inf.cleanups.clone(),\n     }\n }\n \n@@ -1036,15 +1047,17 @@ pub fn resolve_vtables_under_param_substs(tcx: ty::ctxt,\n     -> typeck::vtable_res {\n     @vts.iter().transform(|ds|\n       @ds.iter().transform(\n-          |d| resolve_vtable_under_param_substs(tcx, param_substs, copy *d))\n+          |d| resolve_vtable_under_param_substs(tcx,\n+                                                param_substs,\n+                                                d))\n                           .collect::<~[typeck::vtable_origin]>())\n         .collect::<~[typeck::vtable_param_res]>()\n }\n \n \n // Apply the typaram substitutions in the fn_ctxt to a vtable. This should\n // eliminate any vtable_params.\n-pub fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: typeck::vtable_origin)\n+pub fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: &typeck::vtable_origin)\n     -> typeck::vtable_origin {\n     resolve_vtable_under_param_substs(fcx.ccx.tcx,\n                                       fcx.param_substs,\n@@ -1053,17 +1066,17 @@ pub fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: typeck::vtable_origin)\n \n pub fn resolve_vtable_under_param_substs(tcx: ty::ctxt,\n                                          param_substs: Option<@param_substs>,\n-                                         vt: typeck::vtable_origin)\n-    -> typeck::vtable_origin {\n-    match vt {\n-        typeck::vtable_static(trait_id, tys, sub) => {\n+                                         vt: &typeck::vtable_origin)\n+                                         -> typeck::vtable_origin {\n+    match *vt {\n+        typeck::vtable_static(trait_id, ref tys, sub) => {\n             let tys = match param_substs {\n                 Some(substs) => {\n                     do tys.iter().transform |t| {\n                         ty::subst_tps(tcx, substs.tys, substs.self_ty, *t)\n                     }.collect()\n                 }\n-                _ => tys\n+                _ => tys.to_owned()\n             };\n             typeck::vtable_static(\n                 trait_id, tys,\n@@ -1085,7 +1098,7 @@ pub fn resolve_vtable_under_param_substs(tcx: ty::ctxt,\n             match param_substs {\n                 Some(@param_substs\n                      {self_vtable: Some(ref self_vtable), _}) => {\n-                    copy *self_vtable\n+                    (*self_vtable).clone()\n                 }\n                 _ => {\n                     tcx.sess.bug(fmt!(\n@@ -1097,13 +1110,15 @@ pub fn resolve_vtable_under_param_substs(tcx: ty::ctxt,\n     }\n }\n \n-pub fn find_vtable(tcx: ty::ctxt, ps: &param_substs,\n-                   n_param: uint, n_bound: uint)\n-    -> typeck::vtable_origin {\n+pub fn find_vtable(tcx: ty::ctxt,\n+                   ps: &param_substs,\n+                   n_param: uint,\n+                   n_bound: uint)\n+                   -> typeck::vtable_origin {\n     debug!(\"find_vtable(n_param=%u, n_bound=%u, ps=%s)\",\n            n_param, n_bound, ps.repr(tcx));\n \n-    /*bad*/ copy ps.vtables.get()[n_param][n_bound]\n+    ps.vtables.get()[n_param][n_bound].clone()\n }\n \n pub fn dummy_substs(tps: ~[ty::t]) -> ty::substs {"}, {"sha": "00b59d187bfd629a05f2ee0f4cda608073eb4200", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -816,8 +816,8 @@ fn create_ty(cx: &mut CrateContext, t: ty::t, span: span) -> DIType {\n \n     debug!(\"create_ty: %?\", ty::get(t));\n \n-    let sty = copy ty::get(t).sty;\n-    let ty_md = match sty {\n+    let sty = &ty::get(t).sty;\n+    let ty_md = match *sty {\n         ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_int(_) | ty::ty_uint(_)\n         | ty::ty_float(_) => create_basic_type(cx, t, span),\n         ty::ty_estr(ref vstore) => {"}, {"sha": "b92f43b1c8d41adbec710ba8c6a331ba528bbe83", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -570,8 +570,7 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n             return controlflow::trans_if(bcx, cond, thn, els, dest);\n         }\n         ast::expr_match(discr, ref arms) => {\n-            return _match::trans_match(bcx, expr, discr, /*bad*/copy *arms,\n-                                       dest);\n+            return _match::trans_match(bcx, expr, discr, *arms, dest);\n         }\n         ast::expr_block(ref blk) => {\n             return do base::with_scope(bcx, blk.info(),"}, {"sha": "bebed1c3d0da2808981b9f2badfff6f9791874ef", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -109,7 +109,7 @@ fn foreign_signature(ccx: &mut CrateContext, fn_sig: &ty::FnSig)\n \n fn shim_types(ccx: @mut CrateContext, id: ast::node_id) -> ShimTypes {\n     let fn_sig = match ty::get(ty::node_id_to_type(ccx.tcx, id)).sty {\n-        ty::ty_bare_fn(ref fn_ty) => copy fn_ty.sig,\n+        ty::ty_bare_fn(ref fn_ty) => fn_ty.sig.clone(),\n         _ => ccx.sess.bug(\"c_arg_and_ret_lltys called on non-function type\")\n     };\n     let llsig = foreign_signature(ccx, &fn_sig);\n@@ -1163,7 +1163,7 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n     let _icx = push_ctxt(\"foreign::build_foreign_fn\");\n \n     fn build_rust_fn(ccx: @mut CrateContext,\n-                     path: ast_map::path,\n+                     path: &ast_map::path,\n                      decl: &ast::fn_decl,\n                      body: &ast::blk,\n                      id: ast::node_id)\n@@ -1172,13 +1172,14 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n         let t = ty::node_id_to_type(ccx.tcx, id);\n         // XXX: Bad copy.\n         let ps = link::mangle_internal_name_by_path(\n-            ccx, vec::append_one(copy path, ast_map::path_name(\n-                special_idents::clownshoe_abi\n-            )));\n+                            ccx,\n+                            vec::append_one((*path).clone(),\n+                                            ast_map::path_name(\n+                                            special_idents::clownshoe_abi)));\n         let llty = type_of_fn_from_ty(ccx, t);\n         let llfndecl = decl_internal_cdecl_fn(ccx.llmod, ps, llty);\n         trans_fn(ccx,\n-                 path,\n+                 (*path).clone(),\n                  decl,\n                  body,\n                  llfndecl,\n@@ -1318,7 +1319,7 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n     let tys = shim_types(ccx, id);\n     // The internal Rust ABI function - runs on the Rust stack\n     // XXX: Bad copy.\n-    let llrustfn = build_rust_fn(ccx, copy path, decl, body, id);\n+    let llrustfn = build_rust_fn(ccx, &path, decl, body, id);\n     // The internal shim function - runs on the Rust stack\n     let llshimfn = build_shim_fn(ccx, path, llrustfn, &tys);\n     // The foreign C function - runs on the C stack\n@@ -1337,9 +1338,10 @@ pub fn register_foreign_fn(ccx: @mut CrateContext,\n \n     let tys = shim_types(ccx, node_id);\n     do tys.fn_ty.decl_fn |fnty| {\n+        // XXX(pcwalton): We should not copy the path.\n         register_fn_fuller(ccx,\n                            sp,\n-                           /*bad*/copy path,\n+                           path.clone(),\n                            node_id,\n                            attrs,\n                            t,"}, {"sha": "b717445a22f4e295f2edd649a20068c1c90adb28", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -426,7 +426,7 @@ pub fn trans_struct_drop_flag(bcx: block, t: ty::t, v0: ValueRef, dtor_did: ast:\n \n         // Find and call the actual destructor\n         let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did,\n-                                     class_did, /*bad*/copy substs.tps);\n+                                     class_did, substs.tps.clone());\n \n         // The second argument is the \"self\" argument for drop\n         let params = unsafe {\n@@ -461,7 +461,7 @@ pub fn trans_struct_drop(mut bcx: block, t: ty::t, v0: ValueRef, dtor_did: ast::\n \n     // Find and call the actual destructor\n     let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did,\n-                                 class_did, /*bad*/copy substs.tps);\n+                                 class_did, substs.tps.clone());\n \n     // The second argument is the \"self\" argument for drop\n     let params = unsafe {"}, {"sha": "c91be89b30ba2fd97a8b0ba06d0bb1d0ccd70f26", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -44,8 +44,7 @@ pub fn maybe_instantiate_inline(ccx: @mut CrateContext, fn_id: ast::def_id)\n         csearch::maybe_get_item_ast(\n             ccx.tcx, fn_id,\n             |a,b,c,d| {\n-                astencode::decode_inlined_item(a, b, ccx.maps,\n-                                               /*bad*/ copy c, d)\n+                astencode::decode_inlined_item(a, b, ccx.maps, c.clone(), d)\n             });\n     return match csearch_result {\n         csearch::not_found => {"}, {"sha": "4ca8057f3889d433bc3517f9d235a6001da7467c", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -60,7 +60,7 @@ pub fn trans_impl(ccx: @mut CrateContext,\n     for methods.iter().advance |method| {\n         if method.generics.ty_params.len() == 0u {\n             let llfn = get_item_val(ccx, method.id);\n-            let path = vec::append_one(/*bad*/copy sub_path,\n+            let path = vec::append_one(sub_path.clone(),\n                                        path_name(method.ident));\n \n             trans_method(ccx,\n@@ -72,18 +72,17 @@ pub fn trans_impl(ccx: @mut CrateContext,\n     }\n }\n \n-/**\n-Translates a (possibly monomorphized) method body.\n-\n-# Parameters\n-\n-- `path`: the path to the method\n-- `method`: the AST node for the method\n-- `param_substs`: if this is a generic method, the current values for\n-  type parameters and so forth, else none\n-- `llfn`: the LLVM ValueRef for the method\n-- `impl_id`: the node ID of the impl this method is inside\n-*/\n+/// Translates a (possibly monomorphized) method body.\n+///\n+/// Parameters:\n+/// * `path`: the path to the method\n+/// * `method`: the AST node for the method\n+/// * `param_substs`: if this is a generic method, the current values for\n+///   type parameters and so forth, else none\n+/// * `llfn`: the LLVM ValueRef for the method\n+/// * `impl_id`: the node ID of the impl this method is inside\n+///\n+/// XXX(pcwalton) Can we take `path` by reference?\n pub fn trans_method(ccx: @mut CrateContext,\n                     path: path,\n                     method: &ast::method,\n@@ -226,9 +225,13 @@ pub fn trans_method_callee(bcx: block,\n             match bcx.fcx.param_substs {\n                 Some(@param_substs\n                      {self_vtable: Some(ref vtbl), _}) => {\n-                    trans_monomorphized_callee(bcx, callee_id, this, mentry,\n-                                               trait_id, method_index,\n-                                               copy *vtbl)\n+                    trans_monomorphized_callee(bcx,\n+                                               callee_id,\n+                                               this,\n+                                               mentry,\n+                                               trait_id,\n+                                               method_index,\n+                                               (*vtbl).clone())\n                 }\n                 _ => {\n                     fail!(\"trans_method_callee: missing self_vtable\")\n@@ -503,7 +506,7 @@ pub fn trans_trait_callee(bcx: block,\n                           self_expr: @ast::expr,\n                           store: ty::TraitStore,\n                           explicit_self: ast::explicit_self_)\n-                       -> Callee {\n+                          -> Callee {\n     //!\n     //\n     // Create a method callee where the method is coming from a trait\n@@ -646,7 +649,7 @@ pub fn vtable_id(ccx: @mut CrateContext,\n     match origin {\n         &typeck::vtable_static(impl_id, ref substs, sub_vtables) => {\n             let psubsts = param_substs {\n-                tys: copy *substs,\n+                tys: (*substs).clone(),\n                 vtables: Some(sub_vtables),\n                 self_ty: None,\n                 self_vtable: None\n@@ -733,7 +736,7 @@ pub fn make_impl_vtable(bcx: block,\n         let fty = ty::subst_tps(tcx,\n                                 substs,\n                                 None,\n-                                ty::mk_bare_fn(tcx, copy im.fty));\n+                                ty::mk_bare_fn(tcx, im.fty.clone()));\n         if im.generics.has_type_params() || ty::type_has_self(fty) {\n             debug!(\"(making impl vtable) method has self or type params: %s\",\n                    tcx.sess.str_of(im.ident));\n@@ -784,8 +787,8 @@ pub fn trans_trait_cast(bcx: block,\n     bcx = expr::trans_into(bcx, val, SaveIn(llboxdest));\n \n     // Store the vtable into the pair or triple.\n-    let orig = /*bad*/copy ccx.maps.vtable_map.get(&id)[0][0];\n-    let orig = resolve_vtable_in_fn_ctxt(bcx.fcx, orig);\n+    let orig = ccx.maps.vtable_map.get(&id)[0][0].clone();\n+    let orig = resolve_vtable_in_fn_ctxt(bcx.fcx, &orig);\n     let vtable = get_vtable(bcx, v_ty, orig);\n     Store(bcx, vtable, PointerCast(bcx,\n                                    GEPi(bcx, lldest, [0u, abi::trt_field_vtable]),"}, {"sha": "3e5f72679724b78f94cb961af3cd8f522c2d5f8a", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -210,13 +210,13 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n     ccx.monomorphizing.insert(fn_id, depth + 1);\n \n     let elt = path_name(gensym_name(ccx.sess.str_of(name)));\n-    let mut pt = /* bad */copy (*pt);\n+    let mut pt = (*pt).clone();\n     pt.push(elt);\n-    let s = mangle_exported_name(ccx, /*bad*/copy pt, mono_ty);\n+    let s = mangle_exported_name(ccx, pt.clone(), mono_ty);\n     debug!(\"monomorphize_fn mangled to %s\", s);\n \n     let mk_lldecl = || {\n-        let lldecl = decl_internal_cdecl_fn(ccx.llmod, /*bad*/copy s, llfty);\n+        let lldecl = decl_internal_cdecl_fn(ccx.llmod, s, llfty);\n         ccx.monomorphized.insert(hash_id, lldecl);\n         lldecl\n     };\n@@ -227,7 +227,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n                 _\n             }, _) => {\n         let d = mk_lldecl();\n-        set_inline_hint_if_appr(/*bad*/copy i.attrs, d);\n+        set_inline_hint_if_appr(i.attrs, d);\n         trans_fn(ccx,\n                  pt,\n                  decl,\n@@ -255,8 +255,13 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n         set_inline_hint(d);\n         match v.node.kind {\n             ast::tuple_variant_kind(ref args) => {\n-                trans_enum_variant(ccx, enum_item.id, v, /*bad*/copy *args,\n-                                   this_tv.disr_val, Some(psubsts), d);\n+                trans_enum_variant(ccx,\n+                                   enum_item.id,\n+                                   v,\n+                                   (*args).clone(),\n+                                   this_tv.disr_val,\n+                                   Some(psubsts),\n+                                   d);\n             }\n             ast::struct_variant_kind(_) =>\n                 ccx.tcx.sess.bug(\"can't monomorphize struct variants\"),\n@@ -266,21 +271,21 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n       ast_map::node_method(mth, _, _) => {\n         // XXX: What should the self type be here?\n         let d = mk_lldecl();\n-        set_inline_hint_if_appr(/*bad*/copy mth.attrs, d);\n+        set_inline_hint_if_appr(mth.attrs.clone(), d);\n         meth::trans_method(ccx, pt, mth, Some(psubsts), d);\n         d\n       }\n       ast_map::node_trait_method(@ast::provided(mth), _, pt) => {\n         let d = mk_lldecl();\n-        set_inline_hint_if_appr(/*bad*/copy mth.attrs, d);\n-        meth::trans_method(ccx, /*bad*/copy *pt, mth, Some(psubsts), d);\n+        set_inline_hint_if_appr(mth.attrs.clone(), d);\n+        meth::trans_method(ccx, (*pt).clone(), mth, Some(psubsts), d);\n         d\n       }\n       ast_map::node_struct_ctor(struct_def, _, _) => {\n         let d = mk_lldecl();\n         set_inline_hint(d);\n         base::trans_tuple_struct(ccx,\n-                                 /*bad*/copy struct_def.fields,\n+                                 struct_def.fields,\n                                  struct_def.ctor_id.expect(\"ast-mapped tuple struct \\\n                                                             didn't have a ctor id\"),\n                                  Some(psubsts),\n@@ -372,7 +377,7 @@ pub fn make_mono_id(ccx: @mut CrateContext,\n       Some(vts) => {\n         debug!(\"make_mono_id vtables=%s substs=%s\",\n                vts.repr(ccx.tcx), substs.tys.repr(ccx.tcx));\n-        let self_vtables = substs.self_vtable.map(|vtbl| @~[copy *vtbl]);\n+        let self_vtables = substs.self_vtable.map(|vtbl| @~[(*vtbl).clone()]);\n         let vts_iter = self_vtables.iter().chain_(vts.iter());\n         vts_iter.zip(substs_iter).transform(|(vtable, subst)| {\n             let v = vtable.map(|vt| meth::vtable_id(ccx, vt));"}, {"sha": "49f9f4481b98cd9b9525a313446b8734ea00dfe7", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -92,7 +92,7 @@ impl Reflector {\n             *self.visitor_methods).expect(fmt!(\"Couldn't find visit method \\\n                                                 for %s\", ty_name));\n         let mth_ty =\n-            ty::mk_bare_fn(tcx, copy self.visitor_methods[mth_idx].fty);\n+            ty::mk_bare_fn(tcx, self.visitor_methods[mth_idx].fty.clone());\n         let v = self.visitor_val;\n         debug!(\"passing %u args:\", args.len());\n         let mut bcx = self.bcx;"}, {"sha": "9bb7f9571f39f1775b5e3c9a32ba324a866edd83", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -25,7 +25,7 @@ use std::cast;\n \n use std::libc::{c_uint};\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub struct Type {\n     priv rf: TypeRef\n }"}, {"sha": "814ba16fd74efbfebf73e2869d354b032c3af484", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -83,7 +83,7 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n \n     let cx = Context {\n         ccx: ccx,\n-        uses: @mut vec::from_elem(n_tps, 0)\n+        uses: @mut vec::from_elem(n_tps, 0u)\n     };\n \n     // If the method is a default method, we mark all of the types as\n@@ -99,10 +99,15 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n     }\n \n     let map_node = match ccx.tcx.items.find(&fn_id_loc.node) {\n-        Some(x) => (/*bad*/copy *x),\n-        None    => ccx.sess.bug(fmt!(\"type_uses_for: unbound item ID %?\",\n-                                     fn_id_loc))\n+        Some(x) => {\n+            (*x).clone()\n+        }\n+        None => {\n+            ccx.sess.bug(fmt!(\"type_uses_for: unbound item ID %?\",\n+                              fn_id_loc))\n+        }\n     };\n+\n     match map_node {\n       ast_map::node_item(@ast::item { node: item_fn(_, _, _, _, ref body),\n                                       _ }, _) |\n@@ -121,11 +126,13 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n       ast_map::node_variant(_, _, _) => {\n         for uint::range(0u, n_tps) |n| { cx.uses[n] |= use_repr;}\n       }\n-      ast_map::node_foreign_item(i@@foreign_item { node: foreign_item_fn(*),\n-                                                   _ },\n-                                 abi,\n-                                 _,\n-                                 _) => {\n+      ast_map::node_foreign_item(i@@foreign_item {\n+            node: foreign_item_fn(*),\n+            _\n+        },\n+        abi,\n+        _,\n+        _) => {\n         if abi.is_intrinsic() {\n             let nm = cx.ccx.sess.str_of(i.ident);\n             let name = nm.as_slice();\n@@ -161,16 +168,17 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n \n                     \"bswap16\" | \"bswap32\" | \"bswap64\" => 0,\n \n-                    // would be cool to make these an enum instead of strings!\n+                    // would be cool to make these an enum instead of\n+                    // strings!\n                     _ => fail!(\"unknown intrinsic in type_use\")\n                 }\n             };\n             for uint::range(0u, n_tps) |n| { cx.uses[n] |= flags;}\n         }\n       }\n       ast_map::node_struct_ctor(*) => {\n-        // Similarly to node_variant, this monomorphized function just uses\n-        // the representations of all of its type parameters.\n+        // Similarly to node_variant, this monomorphized function just\n+        // uses the representations of all of its type parameters.\n         for uint::range(0, n_tps) |n| { cx.uses[n] |= use_repr; }\n       }\n       _ => {"}, {"sha": "c02eb271e29c06ba7f4ae5695c5ced110e462912", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 102, "deletions": 65, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -96,21 +96,21 @@ impl Method {\n     }\n }\n \n-#[deriving(Eq, IterBytes)]\n+#[deriving(Clone, Eq, IterBytes)]\n pub struct mt {\n     ty: t,\n     mutbl: ast::mutability,\n }\n \n-#[deriving(Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum vstore {\n     vstore_fixed(uint),\n     vstore_uniq,\n     vstore_box,\n     vstore_slice(Region)\n }\n \n-#[deriving(Eq, IterBytes, Encodable, Decodable)]\n+#[deriving(Clone, Eq, IterBytes, Encodable, Decodable)]\n pub enum TraitStore {\n     BoxTraitStore,              // @Trait\n     UniqTraitStore,             // ~Trait\n@@ -119,7 +119,7 @@ pub enum TraitStore {\n \n // XXX: This should probably go away at some point. Maybe after destructors\n // do?\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Clone, Eq, Encodable, Decodable)]\n pub enum SelfMode {\n     ByCopy,\n     ByRef,\n@@ -177,8 +177,12 @@ pub enum ast_ty_to_ty_cache_entry {\n \n pub type opt_region_variance = Option<region_variance>;\n \n-#[deriving(Eq, Decodable, Encodable)]\n-pub enum region_variance { rv_covariant, rv_invariant, rv_contravariant }\n+#[deriving(Clone, Eq, Decodable, Encodable)]\n+pub enum region_variance {\n+    rv_covariant,\n+    rv_invariant,\n+    rv_contravariant,\n+}\n \n #[deriving(Decodable, Encodable)]\n pub enum AutoAdjustment {\n@@ -366,14 +370,14 @@ pub fn type_has_regions(t: t) -> bool {\n }\n pub fn type_id(t: t) -> uint { get(t).id }\n \n-#[deriving(Eq,IterBytes)]\n+#[deriving(Clone, Eq, IterBytes)]\n pub struct BareFnTy {\n     purity: ast::purity,\n     abis: AbiSet,\n     sig: FnSig\n }\n \n-#[deriving(Eq,IterBytes)]\n+#[deriving(Clone, Eq, IterBytes)]\n pub struct ClosureTy {\n     purity: ast::purity,\n     sigil: ast::Sigil,\n@@ -390,21 +394,21 @@ pub struct ClosureTy {\n  * - `lifetimes` is the list of region names bound in this fn.\n  * - `inputs` is the list of arguments and their modes.\n  * - `output` is the return type. */\n-#[deriving(Eq, IterBytes)]\n+#[deriving(Clone, Eq, IterBytes)]\n pub struct FnSig {\n     bound_lifetime_names: OptVec<ast::ident>,\n     inputs: ~[t],\n     output: t\n }\n \n-#[deriving(Eq, IterBytes)]\n+#[deriving(Clone, Eq, IterBytes)]\n pub struct param_ty {\n     idx: uint,\n     def_id: def_id\n }\n \n /// Representation of regions:\n-#[deriving(Eq, IterBytes, Encodable, Decodable)]\n+#[deriving(Clone, Eq, IterBytes, Encodable, Decodable)]\n pub enum Region {\n     /// Bound regions are found (primarily) in function types.  They indicate\n     /// region parameters that have yet to be replaced with actual regions\n@@ -450,13 +454,13 @@ impl Region {\n     }\n }\n \n-#[deriving(Eq, IterBytes, Encodable, Decodable)]\n+#[deriving(Clone, Eq, IterBytes, Encodable, Decodable)]\n pub struct FreeRegion {\n     scope_id: node_id,\n     bound_region: bound_region\n }\n \n-#[deriving(Eq, IterBytes, Encodable, Decodable)]\n+#[deriving(Clone, Eq, IterBytes, Encodable, Decodable)]\n pub enum bound_region {\n     /// The self region for structs, impls (&T in a type defn or &'self T)\n     br_self,\n@@ -501,7 +505,7 @@ type opt_region = Option<Region>;\n  * - `self_ty` is the type to which `self` should be remapped, if any.  The\n  *   `self` type is rather funny in that it can only appear on traits and is\n  *   always substituted away to the implementing type for a trait. */\n-#[deriving(Eq, IterBytes)]\n+#[deriving(Clone, Eq, IterBytes)]\n pub struct substs {\n     self_r: opt_region,\n     self_ty: Option<ty::t>,\n@@ -557,7 +561,7 @@ mod primitives {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in libsyntax/ast.rs as well.\n-#[deriving(Eq, IterBytes)]\n+#[deriving(Clone, Eq, IterBytes)]\n pub enum sty {\n     ty_nil,\n     ty_bot,\n@@ -600,22 +604,25 @@ pub struct TraitRef {\n     substs: substs\n }\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub enum IntVarValue {\n     IntType(ast::int_ty),\n     UintType(ast::uint_ty),\n }\n \n+#[deriving(Clone)]\n pub enum terr_vstore_kind {\n     terr_vec, terr_str, terr_fn, terr_trait\n }\n \n+#[deriving(Clone)]\n pub struct expected_found<T> {\n     expected: T,\n     found: T\n }\n \n // Data structures used in type unification\n+#[deriving(Clone)]\n pub enum type_err {\n     terr_mismatch,\n     terr_purity_mismatch(expected_found<purity>),\n@@ -657,7 +664,7 @@ pub struct ParamBounds {\n \n pub type BuiltinBounds = EnumSet<BuiltinBound>;\n \n-#[deriving(Eq, IterBytes)]\n+#[deriving(Clone, Eq, IterBytes)]\n pub enum BuiltinBound {\n     BoundCopy,\n     BoundStatic,\n@@ -689,28 +696,28 @@ impl CLike for BuiltinBound {\n     }\n }\n \n-#[deriving(Eq, IterBytes)]\n+#[deriving(Clone, Eq, IterBytes)]\n pub struct TyVid(uint);\n \n-#[deriving(Eq, IterBytes)]\n+#[deriving(Clone, Eq, IterBytes)]\n pub struct IntVid(uint);\n \n-#[deriving(Eq, IterBytes)]\n+#[deriving(Clone, Eq, IterBytes)]\n pub struct FloatVid(uint);\n \n-#[deriving(Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct RegionVid {\n     id: uint\n }\n \n-#[deriving(Eq, IterBytes)]\n+#[deriving(Clone, Eq, IterBytes)]\n pub enum InferTy {\n     TyVar(TyVid),\n     IntVar(IntVid),\n     FloatVar(FloatVid)\n }\n \n-#[deriving(Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Encodable, Decodable, IterBytes)]\n pub enum InferRegion {\n     ReVar(RegionVid),\n     ReSkolemized(uint, bound_region)\n@@ -795,6 +802,7 @@ impl ToStr for IntVarValue {\n     }\n }\n \n+#[deriving(Clone)]\n pub struct TypeParameterDef {\n     ident: ast::ident,\n     def_id: ast::def_id,\n@@ -803,6 +811,7 @@ pub struct TypeParameterDef {\n \n /// Information about the type/lifetime parametesr associated with an item.\n /// Analogous to ast::Generics.\n+#[deriving(Clone)]\n pub struct Generics {\n     type_param_defs: @~[TypeParameterDef],\n     region_param: Option<region_variance>,\n@@ -824,6 +833,7 @@ impl Generics {\n ///\n /// - `ty`: the base type.  May have reference to the (unsubstituted) bound\n ///   region `&self` or to (unsubstituted) ty_param types\n+#[deriving(Clone)]\n pub struct ty_param_bounds_and_ty {\n     generics: Generics,\n     ty: t\n@@ -1264,7 +1274,7 @@ pub fn fold_sig(sig: &FnSig, fldop: &fn(t) -> t) -> FnSig {\n     let args = sig.inputs.map(|arg| fldop(*arg));\n \n     FnSig {\n-        bound_lifetime_names: copy sig.bound_lifetime_names,\n+        bound_lifetime_names: sig.bound_lifetime_names.clone(),\n         inputs: args,\n         output: fldop(sig.output)\n     }\n@@ -1314,7 +1324,14 @@ fn fold_sty(sty: &sty, fldop: &fn(t) -> t) -> sty {\n         }\n         ty_closure(ref f) => {\n             let sig = fold_sig(&f.sig, fldop);\n-            ty_closure(ClosureTy {sig: sig, ..copy *f})\n+            ty_closure(ClosureTy {\n+                sig: sig,\n+                purity: f.purity,\n+                sigil: f.sigil,\n+                onceness: f.onceness,\n+                region: f.region,\n+                bounds: f.bounds,\n+            })\n         }\n         ty_rptr(r, ref tm) => {\n             ty_rptr(r, mt {ty: fldop(tm.ty), mutbl: tm.mutbl})\n@@ -1325,7 +1342,7 @@ fn fold_sty(sty: &sty, fldop: &fn(t) -> t) -> sty {\n         ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n         ty_estr(_) | ty_type | ty_opaque_closure_ptr(_) | ty_err |\n         ty_opaque_box | ty_infer(_) | ty_param(*) | ty_self(_) => {\n-            /*bad*/copy *sty\n+            (*sty).clone()\n         }\n     }\n }\n@@ -1400,13 +1417,21 @@ pub fn fold_regions_and_ty(\n         ty::mk_trait(cx, def_id, fold_substs(substs, fldr, fldt), st, mutbl, bounds)\n       }\n       ty_bare_fn(ref f) => {\n-          ty::mk_bare_fn(cx, BareFnTy {sig: fold_sig(&f.sig, fldfnt),\n-                                       ..copy *f})\n+          ty::mk_bare_fn(cx, BareFnTy {\n+            sig: fold_sig(&f.sig, fldfnt),\n+            purity: f.purity,\n+            abis: f.abis.clone(),\n+          })\n       }\n       ty_closure(ref f) => {\n-          ty::mk_closure(cx, ClosureTy {region: fldr(f.region),\n-                                        sig: fold_sig(&f.sig, fldfnt),\n-                                        ..copy *f})\n+          ty::mk_closure(cx, ClosureTy {\n+            region: fldr(f.region),\n+            sig: fold_sig(&f.sig, fldfnt),\n+            purity: f.purity,\n+            sigil: f.sigil,\n+            onceness: f.onceness,\n+            bounds: f.bounds,\n+          })\n       }\n       ref sty => {\n         fold_sty_to_ty(cx, sty, |t| fldt(t))\n@@ -2493,9 +2518,11 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_enum(did, ref substs) => {\n         let variants = enum_variants(cx, did);\n         for (*variants).iter().advance |variant| {\n-            let tup_ty = mk_tup(cx, /*bad*/copy variant.args);\n-\n+            // XXX(pcwalton): This is an inefficient way to do this. Don't\n+            // synthesize a tuple!\n+            //\n             // Perform any type parameter substitutions.\n+            let tup_ty = mk_tup(cx, variant.args.clone());\n             let tup_ty = subst(cx, substs, tup_ty);\n             if !type_is_pod(cx, tup_ty) { result = false; }\n         }\n@@ -2711,10 +2738,11 @@ pub fn node_id_to_type(cx: ctxt, id: ast::node_id) -> t {\n     }\n }\n \n+// XXX(pcwalton): Makes a copy, bleh. Probably better to not do that.\n pub fn node_id_to_type_params(cx: ctxt, id: ast::node_id) -> ~[t] {\n     match cx.node_type_substs.find(&id) {\n       None => return ~[],\n-      Some(ts) => return /*bad*/ copy *ts\n+      Some(ts) => return (*ts).clone(),\n     }\n }\n \n@@ -2724,8 +2752,8 @@ fn node_id_has_type_params(cx: ctxt, id: ast::node_id) -> bool {\n \n pub fn ty_fn_sig(fty: t) -> FnSig {\n     match get(fty).sty {\n-        ty_bare_fn(ref f) => copy f.sig,\n-        ty_closure(ref f) => copy f.sig,\n+        ty_bare_fn(ref f) => f.sig.clone(),\n+        ty_closure(ref f) => f.sig.clone(),\n         ref s => {\n             fail!(\"ty_fn_sig() called on non-fn type: %?\", s)\n         }\n@@ -2735,8 +2763,8 @@ pub fn ty_fn_sig(fty: t) -> FnSig {\n // Type accessors for substructures of types\n pub fn ty_fn_args(fty: t) -> ~[t] {\n     match get(fty).sty {\n-        ty_bare_fn(ref f) => copy f.sig.inputs,\n-        ty_closure(ref f) => copy f.sig.inputs,\n+        ty_bare_fn(ref f) => f.sig.inputs.clone(),\n+        ty_closure(ref f) => f.sig.inputs.clone(),\n         ref s => {\n             fail!(\"ty_fn_args() called on non-fn type: %?\", s)\n         }\n@@ -2823,8 +2851,8 @@ pub fn replace_closure_return_type(tcx: ctxt, fn_type: t, ret_type: t) -> t {\n     match ty::get(fn_type).sty {\n         ty::ty_closure(ref fty) => {\n             ty::mk_closure(tcx, ClosureTy {\n-                sig: FnSig {output: ret_type, ..copy fty.sig},\n-                ..copy *fty\n+                sig: FnSig {output: ret_type, ..fty.sig.clone()},\n+                ..(*fty).clone()\n             })\n         }\n         _ => {\n@@ -2906,7 +2934,7 @@ pub fn adjust_ty(cx: ctxt,\n                                        onceness: ast::Many,\n                                        region: r,\n                                        bounds: ty::AllBuiltinBounds(),\n-                                       sig: copy b.sig})\n+                                       sig: b.sig.clone()})\n                 }\n                 ref b => {\n                     cx.sess.bug(\n@@ -2990,7 +3018,7 @@ pub fn adjust_ty(cx: ctxt,\n                 ty::mk_closure(cx, ClosureTy {\n                     sigil: BorrowedSigil,\n                     region: r,\n-                    ..copy *fty\n+                    ..(*fty).clone()\n                 })\n             }\n \n@@ -3034,11 +3062,10 @@ pub fn expr_has_ty_params(cx: ctxt, expr: &ast::expr) -> bool {\n     return node_id_has_type_params(cx, expr.id);\n }\n \n-pub fn method_call_type_param_defs(\n-    tcx: ctxt,\n-    method_map: typeck::method_map,\n-    id: ast::node_id) -> Option<@~[TypeParameterDef]>\n-{\n+pub fn method_call_type_param_defs(tcx: ctxt,\n+                                   method_map: typeck::method_map,\n+                                   id: ast::node_id)\n+                                   -> Option<@~[TypeParameterDef]> {\n     do method_map.find(&id).map |method| {\n         match method.origin {\n           typeck::method_static(did) => {\n@@ -3059,8 +3086,10 @@ pub fn method_call_type_param_defs(\n             let trait_type_param_defs =\n                 ty::lookup_trait_def(tcx, trt_id).generics.type_param_defs;\n             @vec::append(\n-                copy *trait_type_param_defs,\n-                *ty::trait_method(tcx, trt_id, n_mth).generics.type_param_defs)\n+                (*trait_type_param_defs).clone(),\n+                *ty::trait_method(tcx,\n+                                  trt_id,\n+                                  n_mth).generics.type_param_defs)\n           }\n         }\n     }\n@@ -3548,7 +3577,7 @@ pub fn trait_ref_supertraits(cx: ctxt, trait_ref: &ty::TraitRef) -> ~[@TraitRef]\n         |supertrait_ref| supertrait_ref.subst(cx, &trait_ref.substs))\n }\n \n-fn lookup_locally_or_in_crate_store<V:Copy>(\n+fn lookup_locally_or_in_crate_store<V:Clone>(\n     descr: &str,\n     def_id: ast::def_id,\n     map: &mut HashMap<ast::def_id, V>,\n@@ -3566,16 +3595,16 @@ fn lookup_locally_or_in_crate_store<V:Copy>(\n      */\n \n     match map.find(&def_id) {\n-        Some(&ref v) => { return copy *v; }\n+        Some(&ref v) => { return (*v).clone(); }\n         None => { }\n     }\n \n     if def_id.crate == ast::local_crate {\n         fail!(\"No def'n found for %? in tcx.%s\", def_id, descr);\n     }\n     let v = load_external();\n-    map.insert(def_id, copy v);\n-    return copy v;\n+    map.insert(def_id, v.clone());\n+    v\n }\n \n pub fn trait_method(cx: ctxt, trait_did: ast::def_id, idx: uint) -> @Method {\n@@ -3679,6 +3708,7 @@ fn struct_ctor_id(cx: ctxt, struct_did: ast::def_id) -> Option<ast::def_id> {\n }\n \n // Enum information\n+#[deriving(Clone)]\n pub struct VariantInfo_ {\n     args: ~[t],\n     ctor_ty: t,\n@@ -3700,8 +3730,11 @@ pub fn substd_enum_variants(cx: ctxt,\n \n         let substd_ctor_ty = subst(cx, substs, variant_info.ctor_ty);\n \n-        @VariantInfo_{args: substd_args, ctor_ty: substd_ctor_ty,\n-                      ../*bad*/copy **variant_info}\n+        @VariantInfo_ {\n+            args: substd_args,\n+            ctor_ty: substd_ctor_ty,\n+            ..(**variant_info).clone()\n+        }\n     }.collect()\n }\n \n@@ -3770,21 +3803,21 @@ pub fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n                 ast_map::path_name(item.ident)\n               }\n             };\n-            vec::append_one(/*bad*/copy *path, item_elt)\n+            vec::append_one((*path).clone(), item_elt)\n           }\n \n           ast_map::node_foreign_item(nitem, _, _, path) => {\n-            vec::append_one(/*bad*/copy *path,\n+            vec::append_one((*path).clone(),\n                             ast_map::path_name(nitem.ident))\n           }\n \n           ast_map::node_method(method, _, path) => {\n-            vec::append_one(/*bad*/copy *path,\n+            vec::append_one((*path).clone(),\n                             ast_map::path_name(method.ident))\n           }\n           ast_map::node_trait_method(trait_method, _, path) => {\n             let method = ast_util::trait_method_to_ty_method(&*trait_method);\n-            vec::append_one(/*bad*/copy *path,\n+            vec::append_one((*path).clone(),\n                             ast_map::path_name(method.ident))\n           }\n \n@@ -3794,7 +3827,7 @@ pub fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n           }\n \n           ast_map::node_struct_ctor(_, item, path) => {\n-            vec::append_one(/*bad*/copy *path, ast_map::path_name(item.ident))\n+            vec::append_one((*path).clone(), ast_map::path_name(item.ident))\n           }\n \n           ref node => {\n@@ -4193,7 +4226,7 @@ pub fn normalize_ty(cx: ctxt, t: t) -> t {\n         ty_closure(ref closure_ty) => {\n             mk_closure(cx, ClosureTy {\n                 region: ty::re_static,\n-                ..copy *closure_ty\n+                ..(*closure_ty).clone()\n             })\n         }\n \n@@ -4205,7 +4238,7 @@ pub fn normalize_ty(cx: ctxt, t: t) -> t {\n                      substs {\n                         self_r: Some(ty::re_static),\n                         self_ty: None,\n-                        tps: /*bad*/copy (*r).tps\n+                        tps: (*r).tps.clone()\n                      }),\n                 None =>\n                     t\n@@ -4217,7 +4250,7 @@ pub fn normalize_ty(cx: ctxt, t: t) -> t {\n                 // Ditto.\n                 mk_struct(cx, did, substs {self_r: Some(ty::re_static),\n                                            self_ty: None,\n-                                           tps: /*bad*/copy (*r).tps}),\n+                                           tps: (*r).tps.clone()}),\n               None =>\n                 t\n             },\n@@ -4403,6 +4436,10 @@ pub fn visitor_object_ty(tcx: ctxt) -> Result<(@TraitRef, t), ~str> {\n     let mut static_trait_bound = EmptyBuiltinBounds();\n     static_trait_bound.add(BoundStatic);\n     Ok((trait_ref,\n-        mk_trait(tcx, trait_ref.def_id, copy trait_ref.substs,\n-                 BoxTraitStore, ast::m_imm, static_trait_bound)))\n+        mk_trait(tcx,\n+                 trait_ref.def_id,\n+                 trait_ref.substs.clone(),\n+                 BoxTraitStore,\n+                 ast::m_imm,\n+                 static_trait_bound)))\n }"}, {"sha": "343cbc2bea7897fb72c1cab83b397ac0e716fdf2", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -105,7 +105,7 @@ pub fn get_region_reporting_err(\n     }\n }\n \n-pub fn ast_region_to_region<AC:AstConv,RS:region_scope + Copy + 'static>(\n+pub fn ast_region_to_region<AC:AstConv,RS:region_scope + Clone + 'static>(\n     this: &AC,\n     rscope: &RS,\n     default_span: span,\n@@ -130,7 +130,7 @@ pub fn ast_region_to_region<AC:AstConv,RS:region_scope + Copy + 'static>(\n     get_region_reporting_err(this.tcx(), span, opt_lifetime, res)\n }\n \n-fn ast_path_substs<AC:AstConv,RS:region_scope + Copy + 'static>(\n+fn ast_path_substs<AC:AstConv,RS:region_scope + Clone + 'static>(\n     this: &AC,\n     rscope: &RS,\n     def_id: ast::def_id,\n@@ -184,12 +184,13 @@ fn ast_path_substs<AC:AstConv,RS:region_scope + Copy + 'static>(\n     substs {self_r:self_r, self_ty:self_ty, tps:tps}\n }\n \n-pub fn ast_path_to_substs_and_ty<AC:AstConv,RS:region_scope + Copy + 'static>(\n-    this: &AC,\n-    rscope: &RS,\n-    did: ast::def_id,\n-    path: &ast::Path) -> ty_param_substs_and_ty\n-{\n+pub fn ast_path_to_substs_and_ty<AC:AstConv,\n+                                 RS:region_scope + Clone + 'static>(\n+                                 this: &AC,\n+                                 rscope: &RS,\n+                                 did: ast::def_id,\n+                                 path: &ast::Path)\n+                                 -> ty_param_substs_and_ty {\n     let tcx = this.tcx();\n     let ty::ty_param_bounds_and_ty {\n         generics: generics,\n@@ -201,7 +202,7 @@ pub fn ast_path_to_substs_and_ty<AC:AstConv,RS:region_scope + Copy + 'static>(\n     ty_param_substs_and_ty { substs: substs, ty: ty }\n }\n \n-pub fn ast_path_to_trait_ref<AC:AstConv,RS:region_scope + Copy + 'static>(\n+pub fn ast_path_to_trait_ref<AC:AstConv,RS:region_scope + Clone + 'static>(\n     this: &AC,\n     rscope: &RS,\n     trait_def_id: ast::def_id,\n@@ -224,7 +225,7 @@ pub fn ast_path_to_trait_ref<AC:AstConv,RS:region_scope + Copy + 'static>(\n     return trait_ref;\n }\n \n-pub fn ast_path_to_ty<AC:AstConv,RS:region_scope + Copy + 'static>(\n+pub fn ast_path_to_ty<AC:AstConv,RS:region_scope + Clone + 'static>(\n         this: &AC,\n         rscope: &RS,\n         did: ast::def_id,\n@@ -246,10 +247,10 @@ pub static NO_TPS: uint = 2;\n // Parses the programmer's textual representation of a type into our\n // internal notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID:\n-pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n+pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Clone + 'static>(\n     this: &AC, rscope: &RS, ast_ty: &ast::Ty) -> ty::t {\n \n-    fn ast_mt_to_mt<AC:AstConv, RS:region_scope + Copy + 'static>(\n+    fn ast_mt_to_mt<AC:AstConv, RS:region_scope + Clone + 'static>(\n         this: &AC, rscope: &RS, mt: &ast::mt) -> ty::mt {\n \n         ty::mt {ty: ast_ty_to_ty(this, rscope, mt.ty), mutbl: mt.mutbl}\n@@ -258,7 +259,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n     // Handle @, ~, and & being able to mean estrs and evecs.\n     // If a_seq_ty is a str or a vec, make it an estr/evec.\n     // Also handle first-class trait types.\n-    fn mk_pointer<AC:AstConv,RS:region_scope + Copy + 'static>(\n+    fn mk_pointer<AC:AstConv,RS:region_scope + Clone + 'static>(\n         this: &AC,\n         rscope: &RS,\n         a_seq_ty: &ast::mt,\n@@ -305,7 +306,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n                         let bounds = conv_builtin_bounds(this.tcx(), bounds, trait_store);\n                         return ty::mk_trait(tcx,\n                                             result.def_id,\n-                                            copy result.substs,\n+                                            result.substs.clone(),\n                                             trait_store,\n                                             a_seq_ty.mutbl,\n                                             bounds);\n@@ -522,7 +523,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n }\n \n pub fn ty_of_arg<AC:AstConv,\n-                 RS:region_scope + Copy + 'static>(\n+                 RS:region_scope + Clone + 'static>(\n                  this: &AC,\n                  rscope: &RS,\n                  a: &ast::arg,\n@@ -570,7 +571,7 @@ struct SelfInfo {\n     explicit_self: ast::explicit_self\n }\n \n-pub fn ty_of_method<AC:AstConv,RS:region_scope + Copy + 'static>(\n+pub fn ty_of_method<AC:AstConv,RS:region_scope + Clone + 'static>(\n     this: &AC,\n     rscope: &RS,\n     purity: ast::purity,\n@@ -588,7 +589,7 @@ pub fn ty_of_method<AC:AstConv,RS:region_scope + Copy + 'static>(\n     (a.get(), b)\n }\n \n-pub fn ty_of_bare_fn<AC:AstConv,RS:region_scope + Copy + 'static>(\n+pub fn ty_of_bare_fn<AC:AstConv,RS:region_scope + Clone + 'static>(\n     this: &AC,\n     rscope: &RS,\n     purity: ast::purity,\n@@ -601,7 +602,7 @@ pub fn ty_of_bare_fn<AC:AstConv,RS:region_scope + Copy + 'static>(\n     b\n }\n \n-fn ty_of_method_or_bare_fn<AC:AstConv,RS:region_scope + Copy + 'static>(\n+fn ty_of_method_or_bare_fn<AC:AstConv,RS:region_scope + Clone + 'static>(\n     this: &AC,\n     rscope: &RS,\n     purity: ast::purity,\n@@ -615,7 +616,9 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:region_scope + Copy + 'static>(\n     // new region names that appear inside of the fn decl are bound to\n     // that function type\n     let bound_lifetime_names = bound_lifetimes(this, lifetimes);\n-    let rb = in_binding_rscope(rscope, RegionParamNames(copy bound_lifetime_names));\n+    let rb =\n+        in_binding_rscope(rscope,\n+                          RegionParamNames(bound_lifetime_names.clone()));\n \n     let opt_transformed_self_ty = opt_self_info.map(|&self_info| {\n         transform_self_ty(this, &rb, self_info)\n@@ -637,7 +640,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:region_scope + Copy + 'static>(\n                                 output: output_ty}\n             });\n \n-    fn transform_self_ty<AC:AstConv,RS:region_scope + Copy + 'static>(\n+    fn transform_self_ty<AC:AstConv,RS:region_scope + Clone + 'static>(\n         this: &AC,\n         rscope: &RS,\n         self_info: &SelfInfo) -> Option<ty::t>\n@@ -670,7 +673,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:region_scope + Copy + 'static>(\n     }\n }\n \n-pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + 'static>(\n+pub fn ty_of_closure<AC:AstConv,RS:region_scope + Clone + 'static>(\n     this: &AC,\n     rscope: &RS,\n     sigil: ast::Sigil,\n@@ -716,7 +719,9 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + 'static>(\n     // new region names that appear inside of the fn decl are bound to\n     // that function type\n     let bound_lifetime_names = bound_lifetimes(this, lifetimes);\n-    let rb = in_binding_rscope(rscope, RegionParamNames(copy bound_lifetime_names));\n+    let rb =\n+        in_binding_rscope(rscope,\n+                          RegionParamNames(bound_lifetime_names.clone()));\n \n     let input_tys = do decl.inputs.iter().enumerate().transform |(i, a)| {\n         let expected_arg_ty = do expected_sig.chain_ref |e| {"}, {"sha": "c16e9a0a92856ee913ebc59a596879a3671f9a92", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -120,7 +120,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n     // contains type variables.\n \n     // Check to see whether this is an enum or a struct.\n-    match structure_of(pcx.fcx, pat.span, expected) {\n+    match *structure_of(pcx.fcx, pat.span, expected) {\n         ty::ty_enum(_, ref expected_substs) => {\n             // Lookup the enum and variant def ids:\n             let v_def = lookup_def(pcx.fcx, pat.span, pat.id);\n@@ -165,8 +165,9 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n                              None);\n                     fcx.write_error(pat.id);\n                     kind_name = \"[error]\";\n-                    arg_types = (copy *subpats).get_or_default(~[]).map(|_|\n-                                                                        ty::mk_err());\n+                    arg_types = (*subpats).clone()\n+                                          .get_or_default(~[])\n+                                          .map(|_| ty::mk_err());\n                 }\n             }\n         }\n@@ -207,8 +208,9 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n                     None);\n             fcx.write_error(pat.id);\n             kind_name = \"[error]\";\n-            arg_types = (copy *subpats).get_or_default(~[]).map(|_|\n-                                                                ty::mk_err());\n+            arg_types = (*subpats).clone()\n+                                  .get_or_default(~[])\n+                                  .map(|_| ty::mk_err());\n         }\n     }\n \n@@ -486,7 +488,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         // Grab the class data that we care about.\n         let structure = structure_of(fcx, pat.span, expected);\n         let mut error_happened = false;\n-        match structure {\n+        match *structure {\n             ty::ty_struct(cid, ref substs) => {\n                 check_struct_pat(pcx, pat.id, pat.span, expected, path,\n                                  *fields, etc, cid, substs);\n@@ -507,15 +509,14 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         // Finally, write in the type.\n         if error_happened {\n             fcx.write_error(pat.id);\n-        }\n-        else {\n+        } else {\n             fcx.write_ty(pat.id, expected);\n         }\n       }\n       ast::pat_tup(ref elts) => {\n         let s = structure_of(fcx, pat.span, expected);\n         let e_count = elts.len();\n-        match s {\n+        match *s {\n             ty::ty_tup(ref ex_elts) if e_count == ex_elts.len() => {\n                 for elts.iter().enumerate().advance |(i, elt)| {\n                     check_pat(pcx, *elt, ex_elts[i]);\n@@ -527,7 +528,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n                     check_pat(pcx, *elt, ty::mk_err());\n                 }\n                 // use terr_tuple_size if both types are tuples\n-                let type_error = match s {\n+                let type_error = match *s {\n                     ty::ty_tup(ref ex_elts) =>\n                         ty::terr_tuple_size(ty::expected_found{expected: ex_elts.len(),\n                                                            found: e_count}),\n@@ -555,9 +556,9 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             fcx.infcx().next_region_var(\n                 infer::PatternRegion(pat.span));\n \n-        let (elt_type, region_var) = match structure_of(\n-          fcx, pat.span, expected\n-        ) {\n+        let (elt_type, region_var) = match *structure_of(fcx,\n+                                                         pat.span,\n+                                                         expected) {\n           ty::ty_evec(mt, vstore) => {\n             let region_var = match vstore {\n                 ty::vstore_slice(r) => r,\n@@ -626,7 +627,7 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n         check_pat(pcx, inner, e_inner.ty);\n         fcx.write_ty(pat_id, expected);\n     };\n-    match structure_of(fcx, span, expected) {\n+    match *structure_of(fcx, span, expected) {\n         ty::ty_box(e_inner) if pointer_kind == Managed => {\n             check_inner(e_inner);\n         }"}, {"sha": "d2a11953af056d1c85e0de11fa64da8ad9d5a643", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -171,6 +171,7 @@ pub struct LookupContext<'self> {\n  * A potential method that might be called, assuming the receiver\n  * is of a suitable type.\n  */\n+#[deriving(Clone)]\n pub struct Candidate {\n     rcvr_ty: ty::t,\n     rcvr_substs: ty::substs,\n@@ -384,7 +385,7 @@ impl<'self> LookupContext<'self> {\n \n             let cand = Candidate {\n                 rcvr_ty: rcvr_ty,\n-                rcvr_substs: copy bound_trait_ref.substs,\n+                rcvr_substs: bound_trait_ref.substs.clone(),\n                 method_ty: method,\n                 origin: method_param(\n                     method_param {\n@@ -441,7 +442,7 @@ impl<'self> LookupContext<'self> {\n         // for Self.\n         let rcvr_substs = substs {\n             self_ty: Some(self_ty),\n-            ../*bad*/copy *substs\n+            ..(*substs).clone()\n         };\n \n         self.inherent_candidates.push(Candidate {\n@@ -506,7 +507,7 @@ impl<'self> LookupContext<'self> {\n                 };\n                 self.inherent_candidates.push(Candidate {\n                     rcvr_ty: self_ty,\n-                    rcvr_substs: copy info.trait_ref.substs,\n+                    rcvr_substs: info.trait_ref.substs.clone(),\n                     method_ty: info.method_ty,\n                     origin: origin\n                 });\n@@ -814,8 +815,9 @@ impl<'self> LookupContext<'self> {\n                                rcvr_ty: ty::t,\n                                candidates: &mut ~[Candidate])\n                                -> Option<method_map_entry> {\n+        // XXX(pcwalton): Do we need to clone here?\n         let relevant_candidates: ~[Candidate] =\n-            candidates.iter().transform(|c| copy *c).\n+            candidates.iter().transform(|c| (*c).clone()).\n                 filter(|c| self.is_relevant(rcvr_ty, c)).collect();\n \n         let relevant_candidates = self.merge_candidates(relevant_candidates);\n@@ -840,7 +842,7 @@ impl<'self> LookupContext<'self> {\n         let mut merged = ~[];\n         let mut i = 0;\n         while i < candidates.len() {\n-            let candidate_a = /*bad*/copy candidates[i];\n+            let candidate_a = &candidates[i];\n \n             let mut skip = false;\n \n@@ -875,7 +877,7 @@ impl<'self> LookupContext<'self> {\n                 // There are more than one of these and we need only one\n                 loop;\n             } else {\n-                merged.push(candidate_a);\n+                merged.push(candidate_a.clone());\n             }\n         }\n \n@@ -951,9 +953,9 @@ impl<'self> LookupContext<'self> {\n         // Construct the full set of type parameters for the method,\n         // which is equal to the class tps + the method tps.\n         let all_substs = substs {\n-            tps: vec::append(/*bad*/copy candidate.rcvr_substs.tps,\n-                             m_substs),\n-            ../*bad*/copy candidate.rcvr_substs\n+            tps: vec::append(candidate.rcvr_substs.tps.clone(), m_substs),\n+            self_r: candidate.rcvr_substs.self_r,\n+            self_ty: candidate.rcvr_substs.self_ty,\n         };\n \n         // Compute the method type with type parameters substituted\n@@ -966,7 +968,7 @@ impl<'self> LookupContext<'self> {\n         // Replace any bound regions that appear in the function\n         // signature with region variables\n         let bare_fn_ty = match ty::get(fty).sty {\n-            ty::ty_bare_fn(ref f) => copy *f,\n+            ty::ty_bare_fn(ref f) => f,\n             ref s => {\n                 tcx.sess.span_bug(\n                     self.expr.span,\n@@ -979,7 +981,11 @@ impl<'self> LookupContext<'self> {\n                 |br| self.fcx.infcx().next_region_var(\n                     infer::BoundRegionInFnCall(self.expr.span, br)));\n         let transformed_self_ty = opt_transformed_self_ty.get();\n-        let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {sig: fn_sig, ..bare_fn_ty});\n+        let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n+            sig: fn_sig,\n+            purity: bare_fn_ty.purity,\n+            abis: bare_fn_ty.abis.clone(),\n+        });\n         debug!(\"after replacing bound regions, fty=%s\", self.ty_to_str(fty));\n \n         let self_mode = get_mode_from_explicit_self(candidate.method_ty.explicit_self);\n@@ -1178,7 +1184,7 @@ impl<'self> LookupContext<'self> {\n                                 trait_did: def_id,\n                                 method_num: uint) -> ty::t {\n             let trait_methods = ty::trait_methods(tcx, trait_did);\n-            ty::mk_bare_fn(tcx, copy trait_methods[method_num].fty)\n+            ty::mk_bare_fn(tcx, trait_methods[method_num].fty.clone())\n         }\n     }\n "}, {"sha": "deec93140b4fa304273725f76c5dfd51df2f8524", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 53, "deletions": 32, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -168,6 +168,7 @@ pub struct inherited {\n     vtable_map: vtable_map,\n }\n \n+#[deriving(Clone)]\n pub enum FnKind {\n     // This is a for-closure.  The ty::t is the return type of the\n     // enclosing function.\n@@ -180,6 +181,7 @@ pub enum FnKind {\n     Vanilla\n }\n \n+#[deriving(Clone)]\n pub struct PurityState {\n     def: ast::node_id,\n     purity: ast::purity,\n@@ -219,6 +221,7 @@ enum AllowOverloadedOperatorsFlag {\n     DontAllowOverloadedOperators,\n }\n \n+#[deriving(Clone)]\n pub struct FnCtxt {\n     // Number of errors that had been reported when we started\n     // checking this function. On exit, if we find that *more* errors\n@@ -833,7 +836,7 @@ impl FnCtxt {\n \n     pub fn node_ty_substs(&self, id: ast::node_id) -> ty::substs {\n         match self.inh.node_type_substs.find(&id) {\n-            Some(ts) => (/*bad*/copy *ts),\n+            Some(ts) => (*ts).clone(),\n             None => {\n                 self.tcx().sess.bug(\n                     fmt!(\"no type substs for node %d: %s in fcx %s\",\n@@ -986,7 +989,7 @@ pub fn do_autoderef(fcx: @mut FnCtxt, sp: span, t: ty::t) -> (ty::t, uint) {\n         let sty = structure_of(fcx, sp, t1);\n \n         // Some extra checks to detect weird cycles and so forth:\n-        match sty {\n+        match *sty {\n             ty::ty_box(inner) | ty::ty_uniq(inner) |\n             ty::ty_rptr(_, inner) => {\n                 match ty::get(t1).sty {\n@@ -1014,7 +1017,7 @@ pub fn do_autoderef(fcx: @mut FnCtxt, sp: span, t: ty::t) -> (ty::t, uint) {\n         }\n \n         // Otherwise, deref if type is derefable:\n-        match ty::deref_sty(fcx.ccx.tcx, &sty, false) {\n+        match ty::deref_sty(fcx.ccx.tcx, sty, false) {\n             None => {\n                 return (t1, autoderefs);\n             }\n@@ -1352,28 +1355,35 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         // Extract the function signature from `in_fty`.\n         let fn_sty = structure_of(fcx, f.span, fn_ty);\n \n-        let fn_sig = match fn_sty {\n-            ty::ty_bare_fn(ty::BareFnTy {sig: sig, _}) |\n-            ty::ty_closure(ty::ClosureTy {sig: sig, _}) => sig,\n+        // This is the \"default\" function signature, used in case of error.\n+        // In that case, we check each argument against \"error\" in order to\n+        // set up all the node type bindings.\n+        let error_fn_sig = FnSig {\n+            bound_lifetime_names: opt_vec::Empty,\n+            inputs: err_args(args.len()),\n+            output: ty::mk_err()\n+        };\n+\n+        let fn_sig = match *fn_sty {\n+            ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, _}) |\n+            ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) => sig,\n             _ => {\n                 fcx.type_error_message(call_expr.span, |actual| {\n                     fmt!(\"expected function but \\\n                           found `%s`\", actual) }, fn_ty, None);\n-\n-                // check each arg against \"error\", in order to set up\n-                // all the node type bindings\n-                FnSig {bound_lifetime_names: opt_vec::Empty,\n-                       inputs: err_args(args.len()),\n-                       output: ty::mk_err()}\n+                &error_fn_sig\n             }\n         };\n \n         // Replace any bound regions that appear in the function\n         // signature with region variables\n         let (_, _, fn_sig) =\n-            replace_bound_regions_in_fn_sig(\n-                fcx.tcx(), @Nil, None, &fn_sig,\n-                |br| fcx.infcx().next_region_var(\n+            replace_bound_regions_in_fn_sig(fcx.tcx(),\n+                                            @Nil,\n+                                            None,\n+                                            fn_sig,\n+                                            |br| fcx.infcx()\n+                                                    .next_region_var(\n                     infer::BoundRegionInFnCall(call_expr.span, br)));\n \n         // Call the generic checker.\n@@ -1708,7 +1718,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         // to impure and block. Note that we only will use those for\n         // block syntax lambdas; that is, lambdas without explicit\n         // sigils.\n-        let expected_sty = unpack_expected(fcx, expected, |x| Some(copy *x));\n+        let expected_sty = unpack_expected(fcx,\n+                                           expected,\n+                                           |x| Some((*x).clone()));\n         let error_happened = false;\n         let (expected_sig,\n              expected_purity,\n@@ -1761,10 +1773,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 output: ty::mk_err()\n             };\n             ty::mk_err()\n-        }\n-        else {\n-            let fn_ty_copy = copy fn_ty;\n-            fty_sig = copy fn_ty.sig;\n+        } else {\n+            let fn_ty_copy = fn_ty.clone();\n+            fty_sig = fn_ty.sig.clone();\n             ty::mk_closure(tcx, fn_ty_copy)\n         };\n \n@@ -1795,7 +1806,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                                 fcx.expr_ty(base));\n         let (base_t, derefs) = do_autoderef(fcx, expr.span, expr_t);\n \n-        match structure_of(fcx, expr.span, base_t) {\n+        match *structure_of(fcx, expr.span, base_t) {\n             ty::ty_struct(base_id, ref substs) => {\n                 // This is just for fields -- the same code handles\n                 // methods in both classes and traits\n@@ -2119,16 +2130,20 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         // 2. the closure that was given returns unit\n         let tcx = fcx.tcx();\n         let mut err_happened = false;\n-        let expected_sty = unpack_expected(fcx, expected, |x| Some(copy *x));\n+        let expected_sty = unpack_expected(fcx,\n+                                           expected,\n+                                           |x| Some((*x).clone()));\n         let inner_ty = match expected_sty {\n             Some(ty::ty_closure(ref fty)) => {\n                 match fcx.mk_subty(false, infer::Misc(expr.span),\n                                    fty.sig.output, ty::mk_bool()) {\n                     result::Ok(_) => {\n                         ty::mk_closure(tcx, ty::ClosureTy {\n-                            sig: FnSig {output: ty::mk_nil(),\n-                                        ..copy fty.sig},\n-                            ..copy *fty\n+                            sig: FnSig {\n+                                output: ty::mk_nil(),\n+                                ..fty.sig.clone()\n+                            },\n+                            ..(*fty).clone()\n                         })\n                     }\n                     result::Err(_) => {\n@@ -2361,13 +2376,13 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 }\n                 ast::deref => {\n                     let sty = structure_of(fcx, expr.span, oprnd_t);\n-                    let operand_ty = ty::deref_sty(tcx, &sty, true);\n+                    let operand_ty = ty::deref_sty(tcx, sty, true);\n                     match operand_ty {\n                         Some(mt) => {\n                             oprnd_t = mt.ty\n                         }\n                         None => {\n-                            match sty {\n+                            match *sty {\n                                 ty::ty_enum(*) => {\n                                     tcx.sess.span_err(\n                                         expr.span,\n@@ -2564,7 +2579,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n           check_loop_body(fcx, expr, expected, loop_body);\n       }\n       ast::expr_do_body(b) => {\n-        let expected_sty = unpack_expected(fcx, expected, |x| Some(copy *x));\n+        let expected_sty = unpack_expected(fcx,\n+                                           expected,\n+                                           |x| Some((*x).clone()));\n         let inner_ty = match expected_sty {\n             Some(ty::ty_closure(_)) => expected.get(),\n             _ => match expected {\n@@ -2759,7 +2776,10 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n       }\n       ast::expr_tup(ref elts) => {\n         let flds = unpack_expected(fcx, expected, |sty| {\n-            match *sty { ty::ty_tup(ref flds) => Some(copy *flds), _ => None }\n+            match *sty {\n+                ty::ty_tup(ref flds) => Some((*flds).clone()),\n+                _ => None\n+            }\n         });\n         let mut bot_field = false;\n         let mut err_field = false;\n@@ -2816,7 +2836,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n           } else {\n               let (base_t, derefs) = do_autoderef(fcx, expr.span, raw_base_t);\n               let base_sty = structure_of(fcx, expr.span, base_t);\n-              match ty::index_sty(&base_sty) {\n+              match ty::index_sty(base_sty) {\n                   Some(mt) => {\n                       require_integral(fcx, idx.span, idx_t);\n                       fcx.write_ty(id, mt.ty);\n@@ -3374,8 +3394,9 @@ pub fn structurally_resolved_type(fcx: @mut FnCtxt, sp: span, tp: ty::t)\n }\n \n // Returns the one-level-deep structure of the given type.\n-pub fn structure_of(fcx: @mut FnCtxt, sp: span, typ: ty::t) -> ty::sty {\n-    /*bad*/copy ty::get(structurally_resolved_type(fcx, sp, typ)).sty\n+pub fn structure_of<'a>(fcx: @mut FnCtxt, sp: span, typ: ty::t)\n+                        -> &'a ty::sty {\n+    &ty::get(structurally_resolved_type(fcx, sp, typ)).sty\n }\n \n pub fn type_is_integral(fcx: @mut FnCtxt, sp: span, typ: ty::t) -> bool {"}, {"sha": "d9036c72db6594bf0a0fba01df990b604d828d6f", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -132,9 +132,12 @@ fn lookup_vtables(vcx: &VtableContext,\n     @result\n }\n \n-fn fixup_substs(vcx: &VtableContext, location_info: &LocationInfo,\n-                id: ast::def_id, substs: ty::substs,\n-                is_early: bool) -> Option<ty::substs> {\n+fn fixup_substs(vcx: &VtableContext,\n+                location_info: &LocationInfo,\n+                id: ast::def_id,\n+                substs: ty::substs,\n+                is_early: bool)\n+                -> Option<ty::substs> {\n     let tcx = vcx.tcx();\n     // use a dummy type just to package up the substs that need fixing up\n     let t = ty::mk_trait(tcx,\n@@ -144,7 +147,7 @@ fn fixup_substs(vcx: &VtableContext, location_info: &LocationInfo,\n                          ty::EmptyBuiltinBounds());\n     do fixup_ty(vcx, location_info, t, is_early).map |t_f| {\n         match ty::get(*t_f).sty {\n-          ty::ty_trait(_, ref substs_f, _, _, _) => (/*bad*/copy *substs_f),\n+          ty::ty_trait(_, ref substs_f, _, _, _) => (*substs_f).clone(),\n           _ => fail!(\"t_f should be a trait\")\n         }\n     }\n@@ -365,7 +368,7 @@ fn lookup_vtable(vcx: &VtableContext,\n                                                               trait_ref.def_id,\n                                                               substs,\n                                                               is_early) {\n-                                Some(ref substs) => (/*bad*/copy *substs),\n+                                Some(ref substs) => (*substs).clone(),\n                                 None => {\n                                     assert!(is_early);\n                                     // Bail out with a bogus answer\n@@ -403,25 +406,24 @@ fn lookup_vtable(vcx: &VtableContext,\n                             // the impl as well as the resolved list\n                             // of type substitutions for the target\n                             // trait.\n-                            found.push(\n-                                vtable_static(im.did,\n-                                              /*bad*/copy substs_f.tps,\n-                                              subres));\n+                            found.push(vtable_static(im.did,\n+                                                     substs_f.tps.clone(),\n+                                                     subres));\n                         }\n                     }\n                 }\n             }\n \n             match found.len() {\n                 0 => { /* fallthrough */ }\n-                1 => { return Some(/*bad*/copy found[0]); }\n+                1 => return Some(found[0].clone()),\n                 _ => {\n                     if !is_early {\n                         vcx.tcx().sess.span_err(\n                             location_info.span,\n                             \"multiple applicable methods in scope\");\n                     }\n-                    return Some(/*bad*/copy found[0]);\n+                    return Some(found[0].clone());\n                 }\n             }\n         }\n@@ -587,7 +589,7 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                           let target_trait_ref = @ty::TraitRef {\n                               def_id: target_def_id,\n                               substs: ty::substs {\n-                                  tps: copy target_substs.tps,\n+                                  tps: target_substs.tps.clone(),\n                                   self_r: target_substs.self_r,\n                                   self_ty: Some(mt.ty)\n                               }"}, {"sha": "187a5eccdb166d6d92ff8134e015069ee1236324", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -208,9 +208,10 @@ impl CoherenceChecker {\n \n                 match item.node {\n                     item_impl(_, ref opt_trait, _, _) => {\n-                        let opt_trait : ~[trait_ref] = opt_trait.iter()\n-                                                                .transform(|x| copy *x)\n-                                                                .collect();\n+                        let opt_trait : ~[trait_ref] =\n+                            opt_trait.iter()\n+                                     .transform(|x| (*x).clone())\n+                                     .collect();\n                         self.check_implementation(item, opt_trait);\n                     }\n                     _ => {\n@@ -358,14 +359,14 @@ impl CoherenceChecker {\n             let new_generics = ty::Generics {\n                 type_param_defs:\n                     @vec::append(\n-                        copy *impl_poly_type.generics.type_param_defs,\n+                        (*impl_poly_type.generics.type_param_defs).clone(),\n                         *new_method_ty.generics.type_param_defs),\n                 region_param:\n                     impl_poly_type.generics.region_param\n             };\n             let new_polytype = ty::ty_param_bounds_and_ty {\n                 generics: new_generics,\n-                ty: ty::mk_bare_fn(tcx, copy new_method_ty.fty)\n+                ty: ty::mk_bare_fn(tcx, new_method_ty.fty.clone())\n             };\n             debug!(\"new_polytype=%s\", new_polytype.repr(tcx));\n \n@@ -901,7 +902,7 @@ impl CoherenceChecker {\n \n             // XXX(sully): We could probably avoid this copy if there are no\n             // default methods.\n-            let mut methods = copy implementation.methods;\n+            let mut methods = implementation.methods.clone();\n             self.add_provided_methods_to_impl(&mut methods,\n                                               &trait_ref.def_id,\n                                               &implementation.did);"}, {"sha": "5d39f1ae374c17ab86a922aa5937c706eeb84fd2", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 33, "deletions": 26, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -86,15 +86,15 @@ pub fn collect_item_types(ccx: @mut CrateCtxt, crate: &ast::crate) {\n }\n \n pub trait ToTy {\n-    fn to_ty<RS:region_scope + Copy + 'static>(\n+    fn to_ty<RS:region_scope + Clone + 'static>(\n              &self,\n              rs: &RS,\n              ast_ty: &ast::Ty)\n              -> ty::t;\n }\n \n impl ToTy for CrateCtxt {\n-    fn to_ty<RS:region_scope + Copy + 'static>(\n+    fn to_ty<RS:region_scope + Clone + 'static>(\n              &self,\n              rs: &RS,\n              ast_ty: &ast::Ty)\n@@ -309,7 +309,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n         // create the type of `foo`, applying the substitution above\n         let ty = ty::subst(tcx,\n                            &substs,\n-                           ty::mk_bare_fn(tcx, copy m.fty));\n+                           ty::mk_bare_fn(tcx, m.fty.clone()));\n \n         // create the type parameter definitions for `foo`, applying\n         // the substitution to any traits that appear in their bounds.\n@@ -569,27 +569,35 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n \n     // Create a bare fn type for trait/impl that includes self argument\n     let trait_fty =\n-        ty::mk_bare_fn(\n-            tcx,\n-            ty::BareFnTy {purity: trait_m.fty.purity,\n-                          abis: trait_m.fty.abis,\n-                          sig: ty::FnSig {\n-                              bound_lifetime_names:\n-                                  copy trait_m.fty.sig.bound_lifetime_names,\n-                              inputs: trait_fn_args,\n-                              output: trait_m.fty.sig.output\n-                          }});\n+        ty::mk_bare_fn(tcx,\n+                       ty::BareFnTy {\n+                            purity: trait_m.fty.purity,\n+                            abis: trait_m.fty.abis,\n+                            sig: ty::FnSig {\n+                                bound_lifetime_names:\n+                                    trait_m.fty\n+                                           .sig\n+                                           .bound_lifetime_names\n+                                           .clone(),\n+                                inputs: trait_fn_args,\n+                                output: trait_m.fty.sig.output\n+                            }\n+                        });\n     let impl_fty =\n-        ty::mk_bare_fn(\n-            tcx,\n-            ty::BareFnTy {purity: impl_m.fty.purity,\n-                          abis: impl_m.fty.abis,\n-                          sig: ty::FnSig {\n-                              bound_lifetime_names:\n-                                  copy impl_m.fty.sig.bound_lifetime_names,\n-                              inputs: impl_fn_args,\n-                              output: impl_m.fty.sig.output\n-                          }});\n+        ty::mk_bare_fn(tcx,\n+                       ty::BareFnTy {\n+                            purity: impl_m.fty.purity,\n+                            abis: impl_m.fty.abis,\n+                            sig: ty::FnSig {\n+                                bound_lifetime_names:\n+                                    impl_m.fty\n+                                          .sig\n+                                          .bound_lifetime_names\n+                                          .clone(),\n+                                    inputs: impl_fn_args,\n+                                    output: impl_m.fty.sig.output\n+                            }\n+                        });\n \n     // Perform substitutions so that the trait/impl methods are expressed\n     // in terms of the same set of type/region parameters:\n@@ -730,8 +738,7 @@ pub fn convert_methods(ccx: &CrateCtxt,\n                           untransformed_rcvr_ty,\n                           rcvr_ast_generics, rcvr_visibility,\n                           &m.generics);\n-        let fty =\n-            ty::mk_bare_fn(tcx, copy mty.fty);\n+        let fty = ty::mk_bare_fn(tcx, mty.fty.clone());\n         tcx.tcache.insert(\n             local_def(m.id),\n \n@@ -740,7 +747,7 @@ pub fn convert_methods(ccx: &CrateCtxt,\n             ty_param_bounds_and_ty {\n                 generics: ty::Generics {\n                     type_param_defs: @vec::append(\n-                        copy *rcvr_ty_generics.type_param_defs,\n+                        (*rcvr_ty_generics.type_param_defs).clone(),\n                         *m_ty_generics.type_param_defs),\n                     region_param: rcvr_ty_generics.region_param\n                 },"}, {"sha": "a6899d7150e08d16b7d9e19c389f64616cc6a319", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -275,8 +275,10 @@ impl Coerce {\n                b.inf_str(self.infcx));\n \n         let fn_ty = match *sty_a {\n-            ty::ty_closure(ref f) if f.sigil == ast::ManagedSigil => copy *f,\n-            ty::ty_closure(ref f) if f.sigil == ast::OwnedSigil => copy *f,\n+            ty::ty_closure(ref f) if f.sigil == ast::ManagedSigil ||\n+                                     f.sigil == ast::OwnedSigil => {\n+                (*f).clone()\n+            }\n             ty::ty_bare_fn(ref f) => {\n                 return self.coerce_from_bare_fn(a, f, b);\n             }\n@@ -331,16 +333,16 @@ impl Coerce {\n         }\n \n         let fn_ty_b = match *sty_b {\n-            ty::ty_closure(ref f) => {copy *f}\n-            _ => {\n-                return self.subtype(a, b);\n-            }\n+            ty::ty_closure(ref f) => (*f).clone(),\n+            _ => return self.subtype(a, b),\n         };\n \n         let adj = @ty::AutoAddEnv(fn_ty_b.region, fn_ty_b.sigil);\n-        let a_closure = ty::mk_closure(\n-            self.infcx.tcx,\n-            ty::ClosureTy {sig: copy fn_ty_a.sig, ..fn_ty_b});\n+        let a_closure = ty::mk_closure(self.infcx.tcx,\n+                                       ty::ClosureTy {\n+                                            sig: fn_ty_a.sig.clone(),\n+                                            ..fn_ty_b\n+                                       });\n         if_ok!(self.subtype(a_closure, b));\n         Ok(Some(adj))\n     }"}, {"sha": "65fbd08056125c48737eccd9e85640367b52e4b1", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -241,13 +241,14 @@ pub fn super_substs<C:Combine>(\n \n     do this.tps(a.tps, b.tps).chain |tps| {\n         do this.self_tys(a.self_ty, b.self_ty).chain |self_ty| {\n-            do relate_region_param(this, generics,\n-                                   a.self_r, b.self_r).chain |self_r|\n-            {\n+            do relate_region_param(this,\n+                                   generics,\n+                                   a.self_r,\n+                                   b.self_r).chain |self_r| {\n                 Ok(substs {\n                     self_r: self_r,\n                     self_ty: self_ty,\n-                    tps: /*bad*/copy tps\n+                    tps: tps.clone()\n                 })\n             }\n         }\n@@ -425,7 +426,7 @@ pub fn super_fn_sigs<C:Combine>(\n             .chain |inputs| {\n         do this.tys(a_f.output, b_f.output).chain |output| {\n             Ok(FnSig {bound_lifetime_names: opt_vec::Empty, // FIXME(#4846)\n-                      inputs: /*bad*/copy inputs,\n+                      inputs: inputs.clone(),\n                       output: output})\n         }\n     }\n@@ -515,7 +516,12 @@ pub fn super_tys<C:Combine>(\n           do this.substs(&trait_def.generics, a_substs, b_substs).chain |substs| {\n               do this.trait_stores(ty::terr_trait, a_store, b_store).chain |s| {\n                   do this.bounds(a_bounds, b_bounds).chain |bounds| {\n-                    Ok(ty::mk_trait(tcx, a_id, /*bad*/copy substs, s, a_mutbl, bounds))\n+                    Ok(ty::mk_trait(tcx,\n+                                    a_id,\n+                                    substs.clone(),\n+                                    s,\n+                                    a_mutbl,\n+                                    bounds))\n                   }\n               }\n           }"}, {"sha": "b95d977bd436600eef8cb9952a0d9f7d709bbf41", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 58, "deletions": 56, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -71,48 +71,48 @@ impl LatticeValue for ty::t {\n }\n \n pub trait CombineFieldsLatticeMethods {\n-    fn var_sub_var<T:Copy + InferStr + LatticeValue,\n-                   V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(&self,\n-                                                                    a_id: V,\n-                                                                    b_id: V)\n-                                                                    -> ures;\n+    fn var_sub_var<T:Clone + InferStr + LatticeValue,\n+                   V:Clone + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(&self,\n+                                                                     a_id: V,\n+                                                                     b_id: V)\n+                                                                     -> ures;\n     /// make variable a subtype of T\n-    fn var_sub_t<T:Copy + InferStr + LatticeValue,\n-                 V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n+    fn var_sub_t<T:Clone + InferStr + LatticeValue,\n+                 V:Clone + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n                  &self,\n                  a_id: V,\n                  b: T)\n                  -> ures;\n-    fn t_sub_var<T:Copy + InferStr + LatticeValue,\n-                 V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n+    fn t_sub_var<T:Clone + InferStr + LatticeValue,\n+                 V:Clone + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n                  &self,\n                  a: T,\n                  b_id: V)\n                  -> ures;\n-    fn merge_bnd<T:Copy + InferStr + LatticeValue>(\n+    fn merge_bnd<T:Clone + InferStr + LatticeValue>(\n                  &self,\n                  a: &Bound<T>,\n                  b: &Bound<T>,\n                  lattice_op: LatticeOp<T>)\n                  -> cres<Bound<T>>;\n-    fn set_var_to_merged_bounds<T:Copy + InferStr + LatticeValue,\n-                                V:Copy+Eq+ToStr+Vid+UnifyVid<Bounds<T>>>(\n+    fn set_var_to_merged_bounds<T:Clone + InferStr + LatticeValue,\n+                                V:Clone+Eq+ToStr+Vid+UnifyVid<Bounds<T>>>(\n                                 &self,\n                                 v_id: V,\n                                 a: &Bounds<T>,\n                                 b: &Bounds<T>,\n                                 rank: uint)\n                                 -> ures;\n-    fn bnds<T:Copy + InferStr + LatticeValue>(\n+    fn bnds<T:Clone + InferStr + LatticeValue>(\n             &self,\n             a: &Bound<T>,\n             b: &Bound<T>)\n             -> ures;\n }\n \n impl CombineFieldsLatticeMethods for CombineFields {\n-    fn var_sub_var<T:Copy + InferStr + LatticeValue,\n-                   V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n+    fn var_sub_var<T:Clone + InferStr + LatticeValue,\n+                   V:Clone + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n                    &self,\n                    a_id: V,\n                    b_id: V)\n@@ -126,10 +126,10 @@ impl CombineFieldsLatticeMethods for CombineFields {\n         // Need to make sub_id a subtype of sup_id.\n         let node_a = self.infcx.get(a_id);\n         let node_b = self.infcx.get(b_id);\n-        let a_id = copy node_a.root;\n-        let b_id = copy node_b.root;\n-        let a_bounds = copy node_a.possible_types;\n-        let b_bounds = copy node_b.possible_types;\n+        let a_id = node_a.root.clone();\n+        let b_id = node_b.root.clone();\n+        let a_bounds = node_a.possible_types.clone();\n+        let b_bounds = node_b.possible_types.clone();\n \n         debug!(\"vars(%s=%s <: %s=%s)\",\n                a_id.to_str(), a_bounds.inf_str(self.infcx),\n@@ -164,8 +164,8 @@ impl CombineFieldsLatticeMethods for CombineFields {\n     }\n \n     /// make variable a subtype of T\n-    fn var_sub_t<T:Copy + InferStr + LatticeValue,\n-                 V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n+    fn var_sub_t<T:Clone + InferStr + LatticeValue,\n+                 V:Clone + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n                  &self,\n                  a_id: V,\n                  b: T)\n@@ -175,9 +175,9 @@ impl CombineFieldsLatticeMethods for CombineFields {\n          * Make a variable (`a_id`) a subtype of the concrete type `b` */\n \n         let node_a = self.infcx.get(a_id);\n-        let a_id = copy node_a.root;\n+        let a_id = node_a.root.clone();\n         let a_bounds = &node_a.possible_types;\n-        let b_bounds = &Bounds { lb: None, ub: Some(copy b) };\n+        let b_bounds = &Bounds { lb: None, ub: Some(b.clone()) };\n \n         debug!(\"var_sub_t(%s=%s <: %s)\",\n                a_id.to_str(),\n@@ -188,8 +188,8 @@ impl CombineFieldsLatticeMethods for CombineFields {\n             a_id, a_bounds, b_bounds, node_a.rank)\n     }\n \n-    fn t_sub_var<T:Copy + InferStr + LatticeValue,\n-                 V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n+    fn t_sub_var<T:Clone + InferStr + LatticeValue,\n+                 V:Clone + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n                  &self,\n                  a: T,\n                  b_id: V)\n@@ -198,9 +198,9 @@ impl CombineFieldsLatticeMethods for CombineFields {\n          *\n          * Make a concrete type (`a`) a subtype of the variable `b_id` */\n \n-        let a_bounds = &Bounds { lb: Some(copy a), ub: None };\n+        let a_bounds = &Bounds { lb: Some(a.clone()), ub: None };\n         let node_b = self.infcx.get(b_id);\n-        let b_id = copy node_b.root;\n+        let b_id = node_b.root.clone();\n         let b_bounds = &node_b.possible_types;\n \n         debug!(\"t_sub_var(%s <: %s=%s)\",\n@@ -212,7 +212,7 @@ impl CombineFieldsLatticeMethods for CombineFields {\n             b_id, a_bounds, b_bounds, node_b.rank)\n     }\n \n-    fn merge_bnd<T:Copy + InferStr + LatticeValue>(\n+    fn merge_bnd<T:Clone + InferStr + LatticeValue>(\n                  &self,\n                  a: &Bound<T>,\n                  b: &Bound<T>,\n@@ -229,8 +229,8 @@ impl CombineFieldsLatticeMethods for CombineFields {\n \n         match (a, b) {\n             (&None,          &None) => Ok(None),\n-            (&Some(_),       &None) => Ok(copy *a),\n-            (&None,          &Some(_)) => Ok(copy *b),\n+            (&Some(_),       &None) => Ok((*a).clone()),\n+            (&None,          &Some(_)) => Ok((*b).clone()),\n             (&Some(ref v_a), &Some(ref v_b)) => {\n                 do lattice_op(self, v_a, v_b).chain |v| {\n                     Ok(Some(v))\n@@ -239,8 +239,8 @@ impl CombineFieldsLatticeMethods for CombineFields {\n         }\n     }\n \n-    fn set_var_to_merged_bounds<T:Copy + InferStr + LatticeValue,\n-                                V:Copy+Eq+ToStr+Vid+UnifyVid<Bounds<T>>>(\n+    fn set_var_to_merged_bounds<T:Clone + InferStr + LatticeValue,\n+                                V:Clone+Eq+ToStr+Vid+UnifyVid<Bounds<T>>>(\n                                 &self,\n                                 v_id: V,\n                                 a: &Bounds<T>,\n@@ -301,10 +301,10 @@ impl CombineFieldsLatticeMethods for CombineFields {\n         uok()\n     }\n \n-    fn bnds<T:Copy + InferStr + LatticeValue>(&self,\n-                                              a: &Bound<T>,\n-                                              b: &Bound<T>)\n-                                              -> ures {\n+    fn bnds<T:Clone + InferStr + LatticeValue>(&self,\n+                                               a: &Bound<T>,\n+                                               b: &Bound<T>)\n+                                               -> ures {\n         debug!(\"bnds(%s <: %s)\", a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n         let _r = indenter();\n@@ -330,8 +330,8 @@ impl CombineFieldsLatticeMethods for CombineFields {\n \n pub trait LatticeDir {\n     fn combine_fields(&self) -> CombineFields;\n-    fn bnd<T:Copy>(&self, b: &Bounds<T>) -> Option<T>;\n-    fn with_bnd<T:Copy>(&self, b: &Bounds<T>, t: T) -> Bounds<T>;\n+    fn bnd<T:Clone>(&self, b: &Bounds<T>) -> Option<T>;\n+    fn with_bnd<T:Clone>(&self, b: &Bounds<T>, t: T) -> Bounds<T>;\n }\n \n pub trait TyLatticeDir {\n@@ -340,9 +340,9 @@ pub trait TyLatticeDir {\n \n impl LatticeDir for Lub {\n     fn combine_fields(&self) -> CombineFields { **self }\n-    fn bnd<T:Copy>(&self, b: &Bounds<T>) -> Option<T> { copy b.ub }\n-    fn with_bnd<T:Copy>(&self, b: &Bounds<T>, t: T) -> Bounds<T> {\n-        Bounds { ub: Some(t), ..copy *b }\n+    fn bnd<T:Clone>(&self, b: &Bounds<T>) -> Option<T> { b.ub.clone() }\n+    fn with_bnd<T:Clone>(&self, b: &Bounds<T>, t: T) -> Bounds<T> {\n+        Bounds { ub: Some(t), ..(*b).clone() }\n     }\n }\n \n@@ -354,9 +354,9 @@ impl TyLatticeDir for Lub {\n \n impl LatticeDir for Glb {\n     fn combine_fields(&self) -> CombineFields { **self }\n-    fn bnd<T:Copy>(&self, b: &Bounds<T>) -> Option<T> { copy b.lb }\n-    fn with_bnd<T:Copy>(&self, b: &Bounds<T>, t: T) -> Bounds<T> {\n-        Bounds { lb: Some(t), ..copy *b }\n+    fn bnd<T:Clone>(&self, b: &Bounds<T>) -> Option<T> { b.lb.clone() }\n+    fn with_bnd<T:Clone>(&self, b: &Bounds<T>, t: T) -> Bounds<T> {\n+        Bounds { lb: Some(t), ..(*b).clone() }\n     }\n }\n \n@@ -412,6 +412,7 @@ pub fn super_lattice_tys<L:LatticeDir + TyLatticeDir + Combine>(\n \n pub type LatticeDirOp<'self, T> = &'self fn(a: &T, b: &T) -> cres<T>;\n \n+#[deriving(Clone)]\n pub enum LatticeVarResult<V,T> {\n     VarResult(V),\n     ValueResult(T)\n@@ -433,17 +434,17 @@ pub enum LatticeVarResult<V,T> {\n  *   result is a variable.  This is indicated with a `VarResult`\n  *   return. */\n pub fn lattice_vars<L:LatticeDir + Combine,\n-                    T:Copy + InferStr + LatticeValue,\n-                    V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n+                    T:Clone + InferStr + LatticeValue,\n+                    V:Clone + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n     this: &L,                           // defines whether we want LUB or GLB\n     a_vid: V,                          // first variable\n     b_vid: V,                          // second variable\n     lattice_dir_op: LatticeDirOp<T>)    // LUB or GLB operation on types\n     -> cres<LatticeVarResult<V,T>> {\n     let nde_a = this.infcx().get(a_vid);\n     let nde_b = this.infcx().get(b_vid);\n-    let a_vid = copy nde_a.root;\n-    let b_vid = copy nde_b.root;\n+    let a_vid = nde_a.root.clone();\n+    let b_vid = nde_b.root.clone();\n     let a_bounds = &nde_a.possible_types;\n     let b_bounds = &nde_b.possible_types;\n \n@@ -473,21 +474,21 @@ pub fn lattice_vars<L:LatticeDir + Combine,\n     // Otherwise, we need to merge A and B into one variable.  We can\n     // then use either variable as an upper bound:\n     let cf = this.combine_fields();\n-    do cf.var_sub_var(copy a_vid, copy b_vid).then {\n-        Ok(VarResult(copy a_vid))\n+    do cf.var_sub_var(a_vid.clone(), b_vid.clone()).then {\n+        Ok(VarResult(a_vid.clone()))\n     }\n }\n \n pub fn lattice_var_and_t<L:LatticeDir + Combine,\n-                         T:Copy + InferStr + LatticeValue,\n-                         V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n+                         T:Clone + InferStr + LatticeValue,\n+                         V:Clone + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n     this: &L,\n     a_id: V,\n     b: &T,\n     lattice_dir_op: LatticeDirOp<T>)\n     -> cres<T> {\n     let nde_a = this.infcx().get(a_id);\n-    let a_id = copy nde_a.root;\n+    let a_id = nde_a.root.clone();\n     let a_bounds = &nde_a.possible_types;\n \n     // The comments in this function are written for LUB, but they\n@@ -509,10 +510,11 @@ pub fn lattice_var_and_t<L:LatticeDir + Combine,\n             // If a does not have an upper bound, make b the upper bound of a\n             // and then return b.\n             debug!(\"bnd=None\");\n-            let a_bounds = this.with_bnd(a_bounds, copy *b);\n+            let a_bounds = this.with_bnd(a_bounds, (*b).clone());\n             do this.combine_fields().bnds(&a_bounds.lb, &a_bounds.ub).then {\n-                this.infcx().set(copy a_id, Root(copy a_bounds, nde_a.rank));\n-                Ok(copy *b)\n+                this.infcx().set(a_id.clone(),\n+                                 Root(a_bounds.clone(), nde_a.rank));\n+                Ok((*b).clone())\n             }\n         }\n     }"}, {"sha": "1f0fb1357628d0d9d2734e185e2ef46d34ad38e7", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -62,6 +62,8 @@ pub mod coercion;\n pub mod error_reporting;\n \n pub type Bound<T> = Option<T>;\n+\n+#[deriving(Clone)]\n pub struct Bounds<T> {\n     lb: Bound<T>,\n     ub: Bound<T>\n@@ -96,6 +98,7 @@ pub struct InferCtxt {\n /// Why did we require that the two types be related?\n ///\n /// See `error_reporting.rs` for more details\n+#[deriving(Clone)]\n pub enum TypeOrigin {\n     // Not yet categorized in a better way\n     Misc(span),\n@@ -120,6 +123,7 @@ pub enum TypeOrigin {\n }\n \n /// See `error_reporting.rs` for more details\n+#[deriving(Clone)]\n pub enum ValuePairs {\n     Types(ty::expected_found<ty::t>),\n     TraitRefs(ty::expected_found<@ty::TraitRef>),\n@@ -129,6 +133,7 @@ pub enum ValuePairs {\n /// encounter an error or subtyping constraint.\n ///\n /// See `error_reporting.rs` for more details.\n+#[deriving(Clone)]\n pub struct TypeTrace {\n     origin: TypeOrigin,\n     values: ValuePairs,\n@@ -137,6 +142,7 @@ pub struct TypeTrace {\n /// The origin of a `r1 <= r2` constraint.\n ///\n /// See `error_reporting.rs` for more details\n+#[deriving(Clone)]\n pub enum SubregionOrigin {\n     // Arose from a subtyping relation\n     Subtype(TypeTrace),\n@@ -245,7 +251,7 @@ pub fn fixup_err_to_str(f: fixup_err) -> ~str {\n     }\n }\n \n-fn new_ValsAndBindings<V:Copy,T:Copy>() -> ValsAndBindings<V, T> {\n+fn new_ValsAndBindings<V:Clone,T:Clone>() -> ValsAndBindings<V, T> {\n     ValsAndBindings {\n         vals: SmallIntMap::new(),\n         bindings: ~[]\n@@ -439,12 +445,12 @@ pub fn resolve_region(cx: @mut InferCtxt, r: ty::Region, modes: uint)\n }\n \n trait then {\n-    fn then<T:Copy>(&self, f: &fn() -> Result<T,ty::type_err>)\n+    fn then<T:Clone>(&self, f: &fn() -> Result<T,ty::type_err>)\n         -> Result<T,ty::type_err>;\n }\n \n impl then for ures {\n-    fn then<T:Copy>(&self, f: &fn() -> Result<T,ty::type_err>)\n+    fn then<T:Clone>(&self, f: &fn() -> Result<T,ty::type_err>)\n         -> Result<T,ty::type_err> {\n         self.chain(|_i| f())\n     }\n@@ -467,11 +473,11 @@ trait CresCompare<T> {\n     fn compare(&self, t: T, f: &fn() -> ty::type_err) -> cres<T>;\n }\n \n-impl<T:Copy + Eq> CresCompare<T> for cres<T> {\n+impl<T:Clone + Eq> CresCompare<T> for cres<T> {\n     fn compare(&self, t: T, f: &fn() -> ty::type_err) -> cres<T> {\n-        do (copy *self).chain |s| {\n+        do (*self).clone().chain |s| {\n             if s == t {\n-                copy *self\n+                (*self).clone()\n             } else {\n                 Err(f())\n             }\n@@ -483,10 +489,8 @@ pub fn uok() -> ures {\n     Ok(())\n }\n \n-fn rollback_to<V:Copy + Vid,T:Copy>(\n-    vb: &mut ValsAndBindings<V, T>,\n-    len: uint)\n-{\n+fn rollback_to<V:Clone + Vid,T:Clone>(vb: &mut ValsAndBindings<V, T>,\n+                                      len: uint) {\n     while vb.bindings.len() != len {\n         let (vid, old_v) = vb.bindings.pop();\n         vb.vals.insert(vid.to_uint(), old_v);\n@@ -588,10 +592,10 @@ impl InferCtxt {\n     }\n }\n \n-fn next_simple_var<V:Copy,T:Copy>(\n-        counter: &mut uint,\n-        bindings: &mut ValsAndBindings<V,Option<T>>)\n-     -> uint {\n+fn next_simple_var<V:Clone,T:Clone>(counter: &mut uint,\n+                                    bindings: &mut ValsAndBindings<V,\n+                                                                   Option<T>>)\n+                                    -> uint {\n     let id = *counter;\n     *counter += 1;\n     bindings.vals.insert(id, Root(None, 0));\n@@ -668,15 +672,17 @@ impl InferCtxt {\n         // make up a dummy type just to reuse/abuse the resolve machinery\n         let dummy0 = ty::mk_trait(self.tcx,\n                                   trait_ref.def_id,\n-                                  copy trait_ref.substs,\n+                                  trait_ref.substs.clone(),\n                                   ty::UniqTraitStore,\n                                   ast::m_imm,\n                                   ty::EmptyBuiltinBounds());\n         let dummy1 = self.resolve_type_vars_if_possible(dummy0);\n         match ty::get(dummy1).sty {\n             ty::ty_trait(ref def_id, ref substs, _, _, _) => {\n-                ty::TraitRef {def_id: *def_id,\n-                              substs: copy *substs}\n+                ty::TraitRef {\n+                    def_id: *def_id,\n+                    substs: (*substs).clone(),\n+                }\n             }\n             _ => {\n                 self.tcx.sess.bug("}, {"sha": "5ebbee8986b0bd4d58602ebb211bee9dfe9a90bd", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 42, "deletions": 39, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -18,6 +18,7 @@ use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::to_str::InferStr;\n use syntax::ast;\n \n+#[deriving(Clone)]\n pub enum VarValue<V, T> {\n     Redirect(V),\n     Root(T, uint),\n@@ -40,27 +41,27 @@ pub trait UnifyVid<T> {\n }\n \n pub trait UnifyInferCtxtMethods {\n-    fn get<T:Copy,\n-           V:Copy + Eq + Vid + UnifyVid<T>>(\n+    fn get<T:Clone,\n+           V:Clone + Eq + Vid + UnifyVid<T>>(\n            &mut self,\n            vid: V)\n            -> Node<V, T>;\n-    fn set<T:Copy + InferStr,\n-           V:Copy + Vid + ToStr + UnifyVid<T>>(\n+    fn set<T:Clone + InferStr,\n+           V:Clone + Vid + ToStr + UnifyVid<T>>(\n            &mut self,\n            vid: V,\n            new_v: VarValue<V, T>);\n-    fn unify<T:Copy + InferStr,\n-             V:Copy + Vid + ToStr + UnifyVid<T>>(\n+    fn unify<T:Clone + InferStr,\n+             V:Clone + Vid + ToStr + UnifyVid<T>>(\n              &mut self,\n              node_a: &Node<V, T>,\n              node_b: &Node<V, T>)\n              -> (V, uint);\n }\n \n impl UnifyInferCtxtMethods for InferCtxt {\n-    fn get<T:Copy,\n-           V:Copy + Eq + Vid + UnifyVid<T>>(\n+    fn get<T:Clone,\n+           V:Clone + Eq + Vid + UnifyVid<T>>(\n            &mut self,\n            vid: V)\n            -> Node<V, T> {\n@@ -75,26 +76,26 @@ impl UnifyInferCtxtMethods for InferCtxt {\n         let vb = UnifyVid::appropriate_vals_and_bindings(self);\n         return helper(tcx, vb, vid);\n \n-        fn helper<T:Copy, V:Copy+Eq+Vid>(\n+        fn helper<T:Clone, V:Clone+Eq+Vid>(\n             tcx: ty::ctxt,\n             vb: &mut ValsAndBindings<V,T>,\n             vid: V) -> Node<V, T>\n         {\n             let vid_u = vid.to_uint();\n             let var_val = match vb.vals.find(&vid_u) {\n-                Some(&ref var_val) => copy *var_val,\n+                Some(&ref var_val) => (*var_val).clone(),\n                 None => {\n                     tcx.sess.bug(fmt!(\n                         \"failed lookup of vid `%u`\", vid_u));\n                 }\n             };\n             match var_val {\n                 Redirect(vid) => {\n-                    let node: Node<V,T> = helper(tcx, vb, copy vid);\n+                    let node: Node<V,T> = helper(tcx, vb, vid.clone());\n                     if node.root != vid {\n                         // Path compression\n                         vb.vals.insert(vid.to_uint(),\n-                                       Redirect(copy node.root));\n+                                       Redirect(node.root.clone()));\n                     }\n                     node\n                 }\n@@ -105,8 +106,8 @@ impl UnifyInferCtxtMethods for InferCtxt {\n         }\n     }\n \n-    fn set<T:Copy + InferStr,\n-           V:Copy + Vid + ToStr + UnifyVid<T>>(\n+    fn set<T:Clone + InferStr,\n+           V:Clone + Vid + ToStr + UnifyVid<T>>(\n            &mut self,\n            vid: V,\n            new_v: VarValue<V, T>) {\n@@ -119,13 +120,13 @@ impl UnifyInferCtxtMethods for InferCtxt {\n                vid.to_str(), new_v.inf_str(self));\n \n         let vb = UnifyVid::appropriate_vals_and_bindings(self);\n-        let old_v = copy *vb.vals.get(&vid.to_uint());\n-        vb.bindings.push((copy vid, old_v));\n+        let old_v = (*vb.vals.get(&vid.to_uint())).clone();\n+        vb.bindings.push((vid.clone(), old_v));\n         vb.vals.insert(vid.to_uint(), new_v);\n     }\n \n-    fn unify<T:Copy + InferStr,\n-             V:Copy + Vid + ToStr + UnifyVid<T>>(\n+    fn unify<T:Clone + InferStr,\n+             V:Clone + Vid + ToStr + UnifyVid<T>>(\n              &mut self,\n              node_a: &Node<V, T>,\n              node_b: &Node<V, T>)\n@@ -141,18 +142,18 @@ impl UnifyInferCtxtMethods for InferCtxt {\n         if node_a.rank > node_b.rank {\n             // a has greater rank, so a should become b's parent,\n             // i.e., b should redirect to a.\n-            self.set(copy node_b.root, Redirect(copy node_a.root));\n-            (copy node_a.root, node_a.rank)\n+            self.set(node_b.root.clone(), Redirect(node_a.root.clone()));\n+            (node_a.root.clone(), node_a.rank)\n         } else if node_a.rank < node_b.rank {\n             // b has greater rank, so a should redirect to b.\n-            self.set(copy node_a.root, Redirect(copy node_b.root));\n-            (copy node_b.root, node_b.rank)\n+            self.set(node_a.root.clone(), Redirect(node_b.root.clone()));\n+            (node_b.root.clone(), node_b.rank)\n         } else {\n             // If equal, redirect one to the other and increment the\n             // other's rank.\n             assert_eq!(node_a.rank, node_b.rank);\n-            self.set(copy node_b.root, Redirect(copy node_a.root));\n-            (copy node_a.root, node_a.rank + 1)\n+            self.set(node_b.root.clone(), Redirect(node_a.root.clone()));\n+            (node_a.root.clone(), node_a.rank + 1)\n         }\n     }\n \n@@ -179,15 +180,15 @@ pub fn mk_err<T:SimplyUnifiable>(a_is_expected: bool,\n }\n \n pub trait InferCtxtMethods {\n-    fn simple_vars<T:Copy + Eq + InferStr + SimplyUnifiable,\n-                   V:Copy + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n+    fn simple_vars<T:Clone + Eq + InferStr + SimplyUnifiable,\n+                   V:Clone + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n                    &mut self,\n                    a_is_expected: bool,\n                    a_id: V,\n                    b_id: V)\n                    -> ures;\n-    fn simple_var_t<T:Copy + Eq + InferStr + SimplyUnifiable,\n-                    V:Copy + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n+    fn simple_var_t<T:Clone + Eq + InferStr + SimplyUnifiable,\n+                    V:Clone + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n                     &mut self,\n                     a_is_expected: bool,\n                     a_id: V,\n@@ -196,8 +197,8 @@ pub trait InferCtxtMethods {\n }\n \n impl InferCtxtMethods for InferCtxt {\n-    fn simple_vars<T:Copy + Eq + InferStr + SimplyUnifiable,\n-                   V:Copy + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n+    fn simple_vars<T:Clone + Eq + InferStr + SimplyUnifiable,\n+                   V:Clone + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n                    &mut self,\n                    a_is_expected: bool,\n                    a_id: V,\n@@ -212,20 +213,22 @@ impl InferCtxtMethods for InferCtxt {\n \n         let node_a = self.get(a_id);\n         let node_b = self.get(b_id);\n-        let a_id = copy node_a.root;\n-        let b_id = copy node_b.root;\n+        let a_id = node_a.root.clone();\n+        let b_id = node_b.root.clone();\n \n         if a_id == b_id { return uok(); }\n \n         let combined = match (&node_a.possible_types, &node_b.possible_types)\n         {\n             (&None, &None) => None,\n-            (&Some(ref v), &None) | (&None, &Some(ref v)) => Some(copy *v),\n+            (&Some(ref v), &None) | (&None, &Some(ref v)) => {\n+                Some((*v).clone())\n+            }\n             (&Some(ref v1), &Some(ref v2)) => {\n                 if *v1 != *v2 {\n-                    return mk_err(a_is_expected, copy *v1, copy *v2);\n+                    return mk_err(a_is_expected, (*v1).clone(), (*v2).clone())\n                 }\n-                Some(copy *v1)\n+                Some((*v1).clone())\n             }\n         };\n \n@@ -234,8 +237,8 @@ impl InferCtxtMethods for InferCtxt {\n         return uok();\n     }\n \n-    fn simple_var_t<T:Copy + Eq + InferStr + SimplyUnifiable,\n-                    V:Copy + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n+    fn simple_var_t<T:Clone + Eq + InferStr + SimplyUnifiable,\n+                    V:Clone + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n                     &mut self,\n                     a_is_expected: bool,\n                     a_id: V,\n@@ -249,7 +252,7 @@ impl InferCtxtMethods for InferCtxt {\n          * `b`. */\n \n         let node_a = self.get(a_id);\n-        let a_id = copy node_a.root;\n+        let a_id = node_a.root.clone();\n \n         match node_a.possible_types {\n             None => {\n@@ -261,7 +264,7 @@ impl InferCtxtMethods for InferCtxt {\n                 if *a_t == b {\n                     return uok();\n                 } else {\n-                    return mk_err(a_is_expected, copy *a_t, b);\n+                    return mk_err(a_is_expected, (*a_t).clone(), b);\n                 }\n             }\n         }"}, {"sha": "5f68f439eba49eac024cc4f55ddd9669758a16f1", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -75,7 +75,7 @@ pub mod infer;\n pub mod collect;\n pub mod coherence;\n \n-#[deriving(Encodable, Decodable)]\n+#[deriving(Clone, Encodable, Decodable)]\n pub enum method_origin {\n     // supertrait method invoked on \"self\" inside a default method\n     // first field is supertrait ID;\n@@ -99,7 +99,7 @@ pub enum method_origin {\n \n // details for a method invoked with a receiver whose type is a type parameter\n // with a bounded trait.\n-#[deriving(Encodable, Decodable)]\n+#[deriving(Clone, Encodable, Decodable)]\n pub struct method_param {\n     // the trait containing the method to be invoked\n     trait_id: ast::def_id,\n@@ -115,6 +115,7 @@ pub struct method_param {\n     bound_num: uint,\n }\n \n+#[deriving(Clone)]\n pub struct method_map_entry {\n     // the type of the self parameter, which is not reflected in the fn type\n     // (FIXME #3446)\n@@ -138,6 +139,7 @@ pub type vtable_param_res = @~[vtable_origin];\n // Resolutions for bounds of all parameters, left to right, for a given path.\n pub type vtable_res = @~[vtable_param_res];\n \n+#[deriving(Clone)]\n pub enum vtable_origin {\n     /*\n       Statically known vtable. def_id gives the class or impl item\n@@ -215,7 +217,7 @@ pub fn write_tpt_to_tcx(tcx: ty::ctxt,\n                         tpt: &ty::ty_param_substs_and_ty) {\n     write_ty_to_tcx(tcx, node_id, tpt.ty);\n     if !tpt.substs.tps.is_empty() {\n-        write_substs_to_tcx(tcx, node_id, copy tpt.substs.tps);\n+        write_substs_to_tcx(tcx, node_id, tpt.substs.tps.clone());\n     }\n }\n "}, {"sha": "2f319687f6ce3700dbfdf6c598c14b3f687ca6e0", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -30,6 +30,7 @@ pub trait region_scope {\n                       -> Result<ty::Region, RegionError>;\n }\n \n+#[deriving(Clone)]\n pub enum empty_rscope { empty_rscope }\n impl region_scope for empty_rscope {\n     fn anon_region(&self, _span: span) -> Result<ty::Region, RegionError> {\n@@ -48,6 +49,7 @@ impl region_scope for empty_rscope {\n     }\n }\n \n+#[deriving(Clone)]\n pub struct RegionParamNames(OptVec<ast::ident>);\n \n impl RegionParamNames {\n@@ -121,6 +123,7 @@ impl RegionParamNames {\n     }\n }\n \n+#[deriving(Clone)]\n struct RegionParameterization {\n     variance: ty::region_variance,\n     region_param_names: RegionParamNames,\n@@ -143,6 +146,7 @@ impl RegionParameterization {\n     }\n }\n \n+#[deriving(Clone)]\n pub struct MethodRscope {\n     explicit_self: ast::explicit_self_,\n     variance: Option<ty::region_variance>,\n@@ -166,7 +170,7 @@ impl MethodRscope {\n     }\n \n     pub fn region_param_names(&self) -> RegionParamNames {\n-        copy self.region_param_names\n+        self.region_param_names.clone()\n     }\n }\n \n@@ -206,6 +210,7 @@ impl region_scope for MethodRscope {\n     }\n }\n \n+#[deriving(Clone)]\n pub struct type_rscope(Option<RegionParameterization>);\n \n impl type_rscope {\n@@ -268,11 +273,21 @@ pub struct binding_rscope {\n     region_param_names: RegionParamNames,\n }\n \n-pub fn in_binding_rscope<RS:region_scope + Copy + 'static>(\n+impl Clone for binding_rscope {\n+    fn clone(&self) -> binding_rscope {\n+        binding_rscope {\n+            base: self.base,\n+            anon_bindings: self.anon_bindings,\n+            region_param_names: self.region_param_names.clone(),\n+        }\n+    }\n+}\n+\n+pub fn in_binding_rscope<RS:region_scope + Clone + 'static>(\n         this: &RS,\n         region_param_names: RegionParamNames)\n      -> binding_rscope {\n-    let base = @copy *this;\n+    let base = @(*this).clone();\n     let base = base as @region_scope;\n     binding_rscope {\n         base: base,"}, {"sha": "a2e6527489c916a38e688500969245fc4f5818dd", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -116,6 +116,7 @@ pub mod lib {\n // macros.\n /*\n mod std {\n+    pub use std::clone;\n     pub use std::cmp;\n     pub use std::os;\n     pub use std::str;\n@@ -184,17 +185,20 @@ Available lint options:\n pub fn describe_debug_flags() {\n     io::println(fmt!(\"\\nAvailable debug options:\\n\"));\n     let r = session::debugging_opts_map();\n-    for r.iter().advance |pair| {\n-        let (name, desc, _) = /*bad*/copy *pair;\n-        io::println(fmt!(\"    -Z %-20s -- %s\", name, desc));\n+    for r.iter().advance |tuple| {\n+        match *tuple {\n+            (ref name, ref desc, _) => {\n+                io::println(fmt!(\"    -Z %-20s -- %s\", *name, *desc));\n+            }\n+        }\n     }\n }\n \n pub fn run_compiler(args: &~[~str], demitter: diagnostic::Emitter) {\n     // Don't display log spew by default. Can override with RUST_LOG.\n     ::std::logging::console_off();\n \n-    let mut args = /*bad*/copy *args;\n+    let mut args = (*args).clone();\n     let binary = args.shift().to_managed();\n \n     if args.is_empty() { usage(binary); return; }"}, {"sha": "2466c373f23b4cb61904c43d8a622ccd7320bcac", "filename": "src/librustc/util/enum_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Futil%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Futil%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fenum_set.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -10,7 +10,7 @@\n \n use std::iterator::Iterator;\n \n-#[deriving(Eq, IterBytes)]\n+#[deriving(Clone, Eq, IterBytes)]\n pub struct EnumSet<E> {\n     // We must maintain the invariant that no bits are set\n     // for which no variant exists"}, {"sha": "09725a03a14e0db21d7982105db96aa2b44105a7", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -832,7 +832,7 @@ impl UserString for ty::TraitRef {\n         let path = ty::item_path(tcx, self.def_id);\n         let base = ast_map::path_to_str(path, tcx.sess.intr());\n         if tcx.sess.verbose() && self.substs.self_ty.is_some() {\n-            let mut all_tps = copy self.substs.tps;\n+            let mut all_tps = self.substs.tps.clone();\n             for self.substs.self_ty.iter().advance |&t| { all_tps.push(t); }\n             parameterized(tcx, base, self.substs.self_r, all_tps)\n         } else {"}, {"sha": "b20d8cab2a4c3e8d9fd6fc3fbf754c9eadfb33e9", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -51,11 +51,11 @@ pub struct Srv {\n }\n \n pub fn from_str<T>(source: ~str, owner: SrvOwner<T>) -> T {\n-    run(owner, copy source, parse::from_str_sess)\n+    run(owner, source.clone(), parse::from_str_sess)\n }\n \n pub fn from_file<T>(file: ~str, owner: SrvOwner<T>) -> T {\n-    run(owner, copy file, |sess, f| parse::from_file_sess(sess, &Path(f)))\n+    run(owner, file.clone(), |sess, f| parse::from_file_sess(sess, &Path(f)))\n }\n \n fn run<T>(owner: SrvOwner<T>, source: ~str, parse: Parser) -> T {\n@@ -117,7 +117,8 @@ fn build_ctxt(sess: Session,\n                                                      copy sess.opts.cfg, ast);\n     let ast = config::strip_unconfigured_items(ast);\n     let ast = syntax::ext::expand::expand_crate(sess.parse_sess,\n-                                                copy sess.opts.cfg, ast);\n+                                                sess.opts.cfg.clone(),\n+                                                ast);\n     let ast = front::test::modify_for_testing(sess, ast);\n     let ast_map = ast_map::map_crate(sess.diagnostic(), ast);\n "}, {"sha": "cc274e26f5b2da51d6eeaf341bde33af3227923f", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -61,17 +61,17 @@ fn fold_crate(\n     let doc = fold::default_seq_fold_crate(fold, doc);\n \n     let attrs = do astsrv::exec(srv) |ctxt| {\n-        let attrs = copy ctxt.ast.node.attrs;\n+        let attrs = ctxt.ast.node.attrs.clone();\n         attr_parser::parse_crate(attrs)\n     };\n \n     doc::CrateDoc {\n         topmod: doc::ModDoc {\n             item: doc::ItemDoc {\n-                name: (copy attrs.name).get_or_default(doc.topmod.name()),\n-                .. copy doc.topmod.item\n+                name: attrs.name.clone().get_or_default(doc.topmod.name()),\n+                .. doc.topmod.item.clone()\n             },\n-            .. copy doc.topmod\n+            .. doc.topmod.clone()\n         }\n     }\n }\n@@ -87,7 +87,7 @@ fn fold_item(\n     let desc = if doc.id == ast::crate_node_id {\n         // This is the top-level mod, use the crate attributes\n         do astsrv::exec(srv) |ctxt| {\n-            attr_parser::parse_desc(copy ctxt.ast.node.attrs)\n+            attr_parser::parse_desc(ctxt.ast.node.attrs.clone())\n         }\n     } else {\n         parse_item_attrs(srv, doc.id, attr_parser::parse_desc)\n@@ -105,8 +105,8 @@ fn parse_item_attrs<T:Send>(\n     parse_attrs: ~fn(a: ~[ast::attribute]) -> T) -> T {\n     do astsrv::exec(srv) |ctxt| {\n         let attrs = match ctxt.ast_map.get_copy(&id) {\n-            ast_map::node_item(item, _) => copy item.attrs,\n-            ast_map::node_foreign_item(item, _, _, _) => copy item.attrs,\n+            ast_map::node_item(item, _) => item.attrs.clone(),\n+            ast_map::node_foreign_item(item, _, _, _) => item.attrs.clone(),\n             _ => fail!(\"parse_item_attrs: not an item\")\n         };\n         parse_attrs(attrs)\n@@ -124,21 +124,21 @@ fn fold_enum(\n \n     doc::EnumDoc {\n         variants: do doc.variants.iter().transform |variant| {\n-            let variant = copy *variant;\n+            let variant = (*variant).clone();\n             let desc = {\n-                let variant = copy variant;\n+                let variant = variant.clone();\n                 do astsrv::exec(srv.clone()) |ctxt| {\n                     match ctxt.ast_map.get_copy(&doc_id) {\n                         ast_map::node_item(@ast::item {\n                             node: ast::item_enum(ref enum_definition, _), _\n                         }, _) => {\n                             let ast_variant =\n-                                copy *enum_definition.variants.iter().find_(|v| {\n+                                (*enum_definition.variants.iter().find_(|v| {\n                                     to_str(v.node.name) == variant.name\n-                                }).get();\n+                                }).get()).clone();\n \n                             attr_parser::parse_desc(\n-                                copy ast_variant.node.attrs)\n+                                ast_variant.node.attrs.clone())\n                         }\n                         _ => {\n                             fail!(\"Enum variant %s has id that's not bound to an enum item\",\n@@ -165,7 +165,7 @@ fn fold_trait(\n     let doc = fold::default_seq_fold_trait(fold, doc);\n \n     doc::TraitDoc {\n-        methods: merge_method_attrs(srv, doc.id(), copy doc.methods),\n+        methods: merge_method_attrs(srv, doc.id(), doc.methods.clone()),\n         .. doc\n     }\n }\n@@ -183,13 +183,13 @@ fn merge_method_attrs(\n                 node: ast::item_trait(_, _, ref methods), _\n             }, _) => {\n                 methods.iter().transform(|method| {\n-                    match copy *method {\n+                    match (*method).clone() {\n                         ast::required(ty_m) => {\n                             (to_str(ty_m.ident),\n-                             attr_parser::parse_desc(copy ty_m.attrs))\n+                             attr_parser::parse_desc(ty_m.attrs.clone()))\n                         }\n                         ast::provided(m) => {\n-                            (to_str(m.ident), attr_parser::parse_desc(copy m.attrs))\n+                            (to_str(m.ident), attr_parser::parse_desc(m.attrs.clone()))\n                         }\n                     }\n                 }).collect()\n@@ -199,7 +199,7 @@ fn merge_method_attrs(\n             }, _) => {\n                 methods.iter().transform(|method| {\n                     (to_str(method.ident),\n-                     attr_parser::parse_desc(copy method.attrs))\n+                     attr_parser::parse_desc(method.attrs.clone()))\n                 }).collect()\n             }\n             _ => fail!(\"unexpected item\")\n@@ -212,7 +212,7 @@ fn merge_method_attrs(\n \n         doc::MethodDoc {\n             desc: desc,\n-            .. copy *doc\n+            .. (*doc).clone()\n         }\n     }.collect()\n }\n@@ -226,7 +226,7 @@ fn fold_impl(\n     let doc = fold::default_seq_fold_impl(fold, doc);\n \n     doc::ImplDoc {\n-        methods: merge_method_attrs(srv, doc.id(), copy doc.methods),\n+        methods: merge_method_attrs(srv, doc.id(), doc.methods.clone()),\n         .. doc\n     }\n }\n@@ -240,7 +240,7 @@ mod test {\n     use extract;\n \n     fn mk_doc(source: ~str) -> doc::Doc {\n-        do astsrv::from_str(copy source) |srv| {\n+        do astsrv::from_str(source.clone()) |srv| {\n             let doc = extract::from_srv(srv.clone(), ~\"\");\n             run(srv.clone(), doc)\n         }"}, {"sha": "675ff7a8b951284759e03757d9961e5c8f374502", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -19,7 +19,7 @@ use std::vec;\n use extra::getopts;\n \n /// The type of document to output\n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub enum OutputFormat {\n     /// Markdown\n     pub Markdown,\n@@ -28,7 +28,7 @@ pub enum OutputFormat {\n }\n \n /// How to organize the output\n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub enum OutputStyle {\n     /// All in a single document\n     pub DocPerCrate,\n@@ -37,6 +37,7 @@ pub enum OutputStyle {\n }\n \n /// The configuration for a rustdoc session\n+#[deriving(Clone)]\n pub struct Config {\n     input_crate: Path,\n     output_dir: Path,\n@@ -45,10 +46,6 @@ pub struct Config {\n     pandoc_cmd: Option<~str>\n }\n \n-impl Clone for Config {\n-    fn clone(&self) -> Config { copy *self }\n-}\n-\n fn opt_output_dir() -> ~str { ~\"output-dir\" }\n fn opt_output_format() -> ~str { ~\"output-format\" }\n fn opt_output_style() -> ~str { ~\"output-style\" }\n@@ -84,7 +81,7 @@ pub fn usage() {\n \n pub fn default_config(input_crate: &Path) -> Config {\n     Config {\n-        input_crate: copy *input_crate,\n+        input_crate: (*input_crate).clone(),\n         output_dir: Path(\".\"),\n         output_format: PandocHtml,\n         output_style: DocPerMod,\n@@ -145,35 +142,35 @@ fn config_from_opts(\n         let output_dir = getopts::opt_maybe_str(matches, opt_output_dir());\n         let output_dir = output_dir.map(|s| Path(*s));\n         result::Ok(Config {\n-            output_dir: output_dir.get_or_default(copy config.output_dir),\n+            output_dir: output_dir.get_or_default(config.output_dir.clone()),\n             .. config\n         })\n     };\n     let result = do result::chain(result) |config| {\n         let output_format = getopts::opt_maybe_str(\n             matches, opt_output_format());\n-        do output_format.map_default(result::Ok(copy config))\n+        do output_format.map_default(result::Ok(config.clone()))\n             |output_format| {\n             do result::chain(parse_output_format(*output_format))\n                 |output_format| {\n \n                 result::Ok(Config {\n                     output_format: output_format,\n-                    .. copy config\n+                    .. config.clone()\n                 })\n             }\n         }\n     };\n     let result = do result::chain(result) |config| {\n         let output_style =\n             getopts::opt_maybe_str(matches, opt_output_style());\n-        do output_style.map_default(result::Ok(copy config))\n+        do output_style.map_default(result::Ok(config.clone()))\n             |output_style| {\n             do result::chain(parse_output_style(*output_style))\n                 |output_style| {\n                 result::Ok(Config {\n                     output_style: output_style,\n-                    .. copy config\n+                    .. config.clone()\n                 })\n             }\n         }\n@@ -186,7 +183,7 @@ fn config_from_opts(\n         do result::chain(pandoc_cmd) |pandoc_cmd| {\n             result::Ok(Config {\n                 pandoc_cmd: pandoc_cmd,\n-                .. copy config\n+                .. config.clone()\n             })\n         }\n     };\n@@ -237,7 +234,7 @@ pub fn maybe_find_pandoc(\n     };\n \n     match pandoc {\n-        Some(x) => Ok(Some(copy *x)), // ugly, shouldn't be doubly wrapped\n+        Some(x) => Ok(Some((*x).clone())), // ugly, shouldn't be doubly wrapped\n         None => Err(~\"couldn't find pandoc\")\n     }\n }"}, {"sha": "9e1dffb989b0017e7d6e2111c7d2389cea9f76b0", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -49,7 +49,7 @@ fn fold_item(fold: &fold::Fold<()>, doc: doc::ItemDoc) -> doc::ItemDoc {\n     let doc = fold::default_seq_fold_item(fold, doc);\n \n     doc::ItemDoc {\n-        brief: extract(copy doc.desc),\n+        brief: extract(doc.desc.clone()),\n         .. doc\n     }\n }\n@@ -59,8 +59,8 @@ fn fold_trait(fold: &fold::Fold<()>, doc: doc::TraitDoc) -> doc::TraitDoc {\n \n     doc::TraitDoc {\n         methods: doc.methods.map(|doc| doc::MethodDoc {\n-            brief: extract(copy doc.desc),\n-            .. copy *doc\n+            brief: extract(doc.desc.clone()),\n+            .. (*doc).clone()\n         }),\n         .. doc\n     }\n@@ -71,8 +71,8 @@ fn fold_impl(fold: &fold::Fold<()>, doc: doc::ImplDoc) -> doc::ImplDoc {\n \n     doc::ImplDoc {\n         methods: doc.methods.map(|doc| doc::MethodDoc {\n-            brief: extract(copy doc.desc),\n-            .. copy *doc\n+            brief: extract(doc.desc.clone()),\n+            .. (*doc).clone()\n         }),\n         .. doc\n     }\n@@ -83,13 +83,13 @@ pub fn extract(desc: Option<~str>) -> Option<~str> {\n         return None\n     }\n \n-    parse_desc((copy desc).get())\n+    parse_desc(desc.clone().get())\n }\n \n fn parse_desc(desc: ~str) -> Option<~str> {\n     static MAX_BRIEF_LEN: uint = 120u;\n \n-    match first_sentence(copy desc) {\n+    match first_sentence(desc.clone()) {\n       Some(first_sentence) => {\n         if first_sentence.len() <= MAX_BRIEF_LEN {\n             Some(first_sentence)\n@@ -180,7 +180,7 @@ mod test {\n     use extract;\n \n     fn mk_doc(source: ~str) -> doc::Doc {\n-        do astsrv::from_str(copy source) |srv| {\n+        do astsrv::from_str(source.clone()) |srv| {\n             let doc = extract::from_srv(srv.clone(), ~\"\");\n             let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n             run(srv.clone(), doc)\n@@ -223,7 +223,7 @@ mod test {\n     #[test]\n     fn should_promote_short_descs() {\n         let desc = Some(~\"desc\");\n-        let brief = extract(copy desc);\n+        let brief = extract(desc.clone());\n         assert_eq!(brief, desc);\n     }\n "}, {"sha": "9d173e271eba67bb227cdb4124ee45ead8e2ba0b", "filename": "src/librustdoc/doc.rs", "status": "modified", "additions": 56, "deletions": 42, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoc.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -15,18 +15,18 @@ use doc;\n \n pub type AstId = int;\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub struct Doc {\n     pages: ~[Page]\n }\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub enum Page {\n     CratePage(CrateDoc),\n     ItemPage(ItemTag)\n }\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub enum Implementation {\n     Required,\n     Provided,\n@@ -36,7 +36,7 @@ pub enum Implementation {\n  * Most rustdocs can be parsed into 'sections' according to their markdown\n  * headers\n  */\n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub struct Section {\n     header: ~str,\n     body: ~str\n@@ -45,12 +45,12 @@ pub struct Section {\n // FIXME (#2596): We currently give topmod the name of the crate.  There\n // would probably be fewer special cases if the crate had its own name\n // and topmod's name was the empty string.\n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub struct CrateDoc {\n     topmod: ModDoc\n }\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub enum ItemTag {\n     ModTag(ModDoc),\n     NmodTag(NmodDoc),\n@@ -63,7 +63,7 @@ pub enum ItemTag {\n     StructTag(StructDoc)\n }\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub struct ItemDoc {\n     id: AstId,\n     name: ~str,\n@@ -75,20 +75,20 @@ pub struct ItemDoc {\n     reexport: bool\n }\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub struct SimpleItemDoc {\n     item: ItemDoc,\n     sig: Option<~str>\n }\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub struct ModDoc {\n     item: ItemDoc,\n     items: ~[ItemTag],\n     index: Option<Index>\n }\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub struct NmodDoc {\n     item: ItemDoc,\n     fns: ~[FnDoc],\n@@ -99,26 +99,26 @@ pub type ConstDoc = SimpleItemDoc;\n \n pub type FnDoc = SimpleItemDoc;\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub struct EnumDoc {\n     item: ItemDoc,\n     variants: ~[VariantDoc]\n }\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub struct VariantDoc {\n     name: ~str,\n     desc: Option<~str>,\n     sig: Option<~str>\n }\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub struct TraitDoc {\n     item: ItemDoc,\n     methods: ~[MethodDoc]\n }\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub struct MethodDoc {\n     name: ~str,\n     brief: Option<~str>,\n@@ -128,7 +128,7 @@ pub struct MethodDoc {\n     implementation: Implementation,\n }\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub struct ImplDoc {\n     item: ItemDoc,\n     bounds_str: Option<~str>,\n@@ -139,14 +139,14 @@ pub struct ImplDoc {\n \n pub type TyDoc = SimpleItemDoc;\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub struct StructDoc {\n     item: ItemDoc,\n     fields: ~[~str],\n     sig: Option<~str>\n }\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub struct Index {\n     entries: ~[IndexEntry]\n }\n@@ -161,7 +161,7 @@ pub struct Index {\n  * * brief - The brief description\n  * * link - A format-specific string representing the link target\n  */\n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub struct IndexEntry {\n     kind: ~str,\n     name: ~str,\n@@ -172,23 +172,23 @@ pub struct IndexEntry {\n impl Doc {\n     pub fn CrateDoc(&self) -> CrateDoc {\n         self.pages.iter().fold(None, |_m, page| {\n-            match copy *page {\n+            match (*page).clone() {\n               doc::CratePage(doc) => Some(doc),\n               _ => None\n             }\n         }).get()\n     }\n \n     pub fn cratemod(&self) -> ModDoc {\n-        copy self.CrateDoc().topmod\n+        self.CrateDoc().topmod.clone()\n     }\n }\n \n macro_rules! filt_mapper {\n     ($vec:expr, $pat:pat) => {\n         do ($vec).iter().filter_map |thing| {\n             match thing {\n-                &$pat => Some(copy *x),\n+                &$pat => Some((*x).clone()),\n                 _ => None\n             }\n         }.collect()\n@@ -298,45 +298,59 @@ pub trait Item {\n impl Item for ItemTag {\n     fn item(&self) -> ItemDoc {\n         match self {\n-          &doc::ModTag(ref doc) => copy doc.item,\n-          &doc::NmodTag(ref doc) => copy doc.item,\n-          &doc::FnTag(ref doc) => copy doc.item,\n-          &doc::ConstTag(ref doc) => copy doc.item,\n-          &doc::EnumTag(ref doc) => copy doc.item,\n-          &doc::TraitTag(ref doc) => copy doc.item,\n-          &doc::ImplTag(ref doc) => copy doc.item,\n-          &doc::TyTag(ref doc) => copy doc.item,\n-          &doc::StructTag(ref doc) => copy doc.item\n+          &doc::ModTag(ref doc) => doc.item.clone(),\n+          &doc::NmodTag(ref doc) => doc.item.clone(),\n+          &doc::FnTag(ref doc) => doc.item.clone(),\n+          &doc::ConstTag(ref doc) => doc.item.clone(),\n+          &doc::EnumTag(ref doc) => doc.item.clone(),\n+          &doc::TraitTag(ref doc) => doc.item.clone(),\n+          &doc::ImplTag(ref doc) => doc.item.clone(),\n+          &doc::TyTag(ref doc) => doc.item.clone(),\n+          &doc::StructTag(ref doc) => doc.item.clone(),\n         }\n     }\n }\n \n impl Item for SimpleItemDoc {\n-    fn item(&self) -> ItemDoc { copy self.item }\n+    fn item(&self) -> ItemDoc {\n+        self.item.clone()\n+    }\n }\n \n impl Item for ModDoc {\n-    fn item(&self) -> ItemDoc { copy self.item }\n+    fn item(&self) -> ItemDoc {\n+        self.item.clone()\n+    }\n }\n \n impl Item for NmodDoc {\n-    fn item(&self) -> ItemDoc { copy self.item }\n+    fn item(&self) -> ItemDoc {\n+        self.item.clone()\n+    }\n }\n \n impl Item for EnumDoc {\n-    fn item(&self) -> ItemDoc { copy self.item }\n+    fn item(&self) -> ItemDoc {\n+        self.item.clone()\n+    }\n }\n \n impl Item for TraitDoc {\n-    fn item(&self) -> ItemDoc { copy self.item }\n+    fn item(&self) -> ItemDoc {\n+        self.item.clone()\n+    }\n }\n \n impl Item for ImplDoc {\n-    fn item(&self) -> ItemDoc { copy self.item }\n+    fn item(&self) -> ItemDoc {\n+        self.item.clone()\n+    }\n }\n \n impl Item for StructDoc {\n-    fn item(&self) -> ItemDoc { copy self.item }\n+    fn item(&self) -> ItemDoc {\n+        self.item.clone()\n+    }\n }\n \n pub trait ItemUtils {\n@@ -354,22 +368,22 @@ impl<A:Item> ItemUtils for A {\n     }\n \n     fn name(&self) -> ~str {\n-        copy self.item().name\n+        self.item().name.clone()\n     }\n \n     fn path(&self) -> ~[~str] {\n-        copy self.item().path\n+        self.item().path.clone()\n     }\n \n     fn brief(&self) -> Option<~str> {\n-        copy self.item().brief\n+        self.item().brief.clone()\n     }\n \n     fn desc(&self) -> Option<~str> {\n-        copy self.item().desc\n+        self.item().desc.clone()\n     }\n \n     fn sections(&self) -> ~[Section] {\n-        copy self.item().sections\n+        self.item().sections.clone()\n     }\n }"}, {"sha": "095066b164755f8d20f4152faba67fbd14b700a6", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -39,7 +39,7 @@ pub fn from_srv(\n     //! Use the AST service to create a document tree\n \n     do astsrv::exec(srv) |ctxt| {\n-        extract(ctxt.ast, copy default_name)\n+        extract(ctxt.ast, default_name.clone())\n     }\n }\n \n@@ -61,7 +61,7 @@ fn top_moddoc_from_crate(\n     default_name: ~str\n ) -> doc::ModDoc {\n     moddoc_from_mod(mk_itemdoc(ast::crate_node_id, default_name),\n-                    copy crate.node.module)\n+                    crate.node.module.clone())\n }\n \n fn mk_itemdoc(id: ast::node_id, name: ~str) -> doc::ItemDoc {\n@@ -84,7 +84,7 @@ fn moddoc_from_mod(\n         item: itemdoc,\n         items: do module_.items.iter().filter_map |item| {\n             let ItemDoc = mk_itemdoc(item.id, to_str(item.ident));\n-            match copy item.node {\n+            match item.node.clone() {\n               ast::item_mod(m) => {\n                 Some(doc::ModTag(\n                     moddoc_from_mod(ItemDoc, m)\n@@ -107,7 +107,7 @@ fn moddoc_from_mod(\n               }\n               ast::item_enum(enum_definition, _) => {\n                 Some(doc::EnumTag(\n-                    enumdoc_from_enum(ItemDoc, copy enum_definition.variants)\n+                    enumdoc_from_enum(ItemDoc, enum_definition.variants.clone())\n                 ))\n               }\n               ast::item_trait(_, _, methods) => {\n@@ -203,7 +203,7 @@ fn traitdoc_from_trait(\n     doc::TraitDoc {\n         item: itemdoc,\n         methods: do methods.iter().transform |method| {\n-            match copy *method {\n+            match (*method).clone() {\n               ast::required(ty_m) => {\n                 doc::MethodDoc {\n                     name: to_str(ty_m.ident),"}, {"sha": "ad0dabdc3a4b5437ddab8519bc620a1107a91150", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -154,7 +154,7 @@ pub fn default_par_fold<T:Clone>(ctxt: T) -> Fold<T> {\n pub fn default_seq_fold_doc<T>(fold: &Fold<T>, doc: doc::Doc) -> doc::Doc {\n     doc::Doc {\n         pages: do doc.pages.iter().transform |page| {\n-            match copy *page {\n+            match (*page).clone() {\n               doc::CratePage(doc) => {\n                 doc::CratePage((fold.fold_crate)(fold, doc))\n               }\n@@ -172,7 +172,7 @@ pub fn default_seq_fold_crate<T>(\n     doc: doc::CrateDoc\n ) -> doc::CrateDoc {\n     doc::CrateDoc {\n-        topmod: (fold.fold_mod)(fold, copy doc.topmod)\n+        topmod: (fold.fold_mod)(fold, doc.topmod.clone())\n     }\n }\n \n@@ -188,9 +188,9 @@ pub fn default_any_fold_mod<T:Clone>(\n     doc: doc::ModDoc\n ) -> doc::ModDoc {\n     doc::ModDoc {\n-        item: (fold.fold_item)(fold, copy doc.item),\n+        item: (fold.fold_item)(fold, doc.item.clone()),\n         items: doc.items.iter().transform(|ItemTag| {\n-            fold_ItemTag(fold, copy *ItemTag)\n+            fold_ItemTag(fold, (*ItemTag).clone())\n         }).collect(),\n         .. doc\n     }\n@@ -201,9 +201,9 @@ pub fn default_seq_fold_mod<T>(\n     doc: doc::ModDoc\n ) -> doc::ModDoc {\n     doc::ModDoc {\n-        item: (fold.fold_item)(fold, copy doc.item),\n+        item: (fold.fold_item)(fold, doc.item.clone()),\n         items: doc.items.iter().transform(|ItemTag| {\n-            fold_ItemTag(fold, copy *ItemTag)\n+            fold_ItemTag(fold, (*ItemTag).clone())\n         }).collect(),\n         .. doc\n     }\n@@ -214,9 +214,9 @@ pub fn default_par_fold_mod<T:Clone>(\n     doc: doc::ModDoc\n ) -> doc::ModDoc {\n     doc::ModDoc {\n-        item: (fold.fold_item)(fold, copy doc.item),\n+        item: (fold.fold_item)(fold, doc.item.clone()),\n         items: doc.items.iter().transform(|ItemTag| {\n-            fold_ItemTag(fold, copy *ItemTag)\n+            fold_ItemTag(fold, (*ItemTag).clone())\n         }).collect(),\n         .. doc\n     }\n@@ -227,9 +227,9 @@ pub fn default_any_fold_nmod<T:Clone>(\n     doc: doc::NmodDoc\n ) -> doc::NmodDoc {\n     doc::NmodDoc {\n-        item: (fold.fold_item)(fold, copy doc.item),\n+        item: (fold.fold_item)(fold, doc.item.clone()),\n         fns: doc.fns.iter().transform(|FnDoc| {\n-            (fold.fold_fn)(fold, copy *FnDoc)\n+            (fold.fold_fn)(fold, (*FnDoc).clone())\n         }).collect(),\n         .. doc\n     }\n@@ -240,9 +240,9 @@ pub fn default_seq_fold_nmod<T>(\n     doc: doc::NmodDoc\n ) -> doc::NmodDoc {\n     doc::NmodDoc {\n-        item: (fold.fold_item)(fold, copy doc.item),\n+        item: (fold.fold_item)(fold, doc.item.clone()),\n         fns: doc.fns.iter().transform(|FnDoc| {\n-            (fold.fold_fn)(fold, copy *FnDoc)\n+            (fold.fold_fn)(fold, (*FnDoc).clone())\n         }).collect(),\n         .. doc\n     }\n@@ -253,9 +253,9 @@ pub fn default_par_fold_nmod<T:Clone>(\n     doc: doc::NmodDoc\n ) -> doc::NmodDoc {\n     doc::NmodDoc {\n-        item: (fold.fold_item)(fold, copy doc.item),\n+        item: (fold.fold_item)(fold, doc.item.clone()),\n         fns: doc.fns.iter().transform(|FnDoc| {\n-            (fold.fold_fn)(fold, copy *FnDoc)\n+            (fold.fold_fn)(fold, (*FnDoc).clone())\n         }).collect(),\n         .. doc\n     }\n@@ -298,7 +298,7 @@ pub fn default_seq_fold_fn<T>(\n     doc: doc::FnDoc\n ) -> doc::FnDoc {\n     doc::SimpleItemDoc {\n-        item: (fold.fold_item)(fold, copy doc.item),\n+        item: (fold.fold_item)(fold, doc.item.clone()),\n         .. doc\n     }\n }\n@@ -308,7 +308,7 @@ pub fn default_seq_fold_const<T>(\n     doc: doc::ConstDoc\n ) -> doc::ConstDoc {\n     doc::SimpleItemDoc {\n-        item: (fold.fold_item)(fold, copy doc.item),\n+        item: (fold.fold_item)(fold, doc.item.clone()),\n         .. doc\n     }\n }\n@@ -318,7 +318,7 @@ pub fn default_seq_fold_enum<T>(\n     doc: doc::EnumDoc\n ) -> doc::EnumDoc {\n     doc::EnumDoc {\n-        item: (fold.fold_item)(fold, copy doc.item),\n+        item: (fold.fold_item)(fold, doc.item.clone()),\n         .. doc\n     }\n }\n@@ -328,7 +328,7 @@ pub fn default_seq_fold_trait<T>(\n     doc: doc::TraitDoc\n ) -> doc::TraitDoc {\n     doc::TraitDoc {\n-        item: (fold.fold_item)(fold, copy doc.item),\n+        item: (fold.fold_item)(fold, doc.item.clone()),\n         .. doc\n     }\n }\n@@ -338,7 +338,7 @@ pub fn default_seq_fold_impl<T>(\n     doc: doc::ImplDoc\n ) -> doc::ImplDoc {\n     doc::ImplDoc {\n-        item: (fold.fold_item)(fold, copy doc.item),\n+        item: (fold.fold_item)(fold, doc.item.clone()),\n         .. doc\n     }\n }\n@@ -348,7 +348,7 @@ pub fn default_seq_fold_type<T>(\n     doc: doc::TyDoc\n ) -> doc::TyDoc {\n     doc::SimpleItemDoc {\n-        item: (fold.fold_item)(fold, copy doc.item),\n+        item: (fold.fold_item)(fold, doc.item.clone()),\n         .. doc\n     }\n }\n@@ -358,7 +358,7 @@ pub fn default_seq_fold_struct<T>(\n     doc: doc::StructDoc\n ) -> doc::StructDoc {\n     doc::StructDoc {\n-        item: (fold.fold_item)(fold, copy doc.item),\n+        item: (fold.fold_item)(fold, doc.item.clone()),\n         .. doc\n     }\n }\n@@ -369,7 +369,7 @@ fn default_fold_should_produce_same_doc() {\n     let ast = parse::from_str(source);\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_seq_fold(());\n-    let folded = (fld.fold_doc)(&fld, copy doc);\n+    let folded = (fld.fold_doc)(&fld, doc.clone());\n     assert_eq!(doc, folded);\n }\n \n@@ -379,7 +379,7 @@ fn default_fold_should_produce_same_consts() {\n     let ast = parse::from_str(source);\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_seq_fold(());\n-    let folded = (fld.fold_doc)(&fld, copy doc);\n+    let folded = (fld.fold_doc)(&fld, doc.clone());\n     assert_eq!(doc, folded);\n }\n \n@@ -389,7 +389,7 @@ fn default_fold_should_produce_same_enums() {\n     let ast = parse::from_str(source);\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_seq_fold(());\n-    let folded = (fld.fold_doc)(&fld, copy doc);\n+    let folded = (fld.fold_doc)(&fld, doc.clone());\n     assert_eq!(doc, folded);\n }\n \n@@ -399,6 +399,6 @@ fn default_parallel_fold_should_produce_same_doc() {\n     let ast = parse::from_str(source);\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_par_fold(());\n-    let folded = (fld.fold_doc)(&fld, copy doc);\n+    let folded = (fld.fold_doc)(&fld, doc.clone());\n     assert_eq!(doc, folded);\n }"}, {"sha": "e766909b8abd2109c3a0a2814b9626e3c57e1777", "filename": "src/librustdoc/markdown_index_pass.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_index_pass.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -24,7 +24,7 @@ use pass::Pass;\n pub fn mk_pass(config: config::Config) -> Pass {\n     Pass {\n         name: ~\"markdown_index\",\n-        f: |srv, doc| run(srv, doc, copy config)\n+        f: |srv, doc| run(srv, doc, config.clone())\n     }\n }\n \n@@ -49,7 +49,7 @@ fn fold_mod(\n     let doc = fold::default_any_fold_mod(fold, doc);\n \n     doc::ModDoc {\n-        index: Some(build_mod_index(copy doc, copy fold.ctxt)),\n+        index: Some(build_mod_index(doc.clone(), fold.ctxt.clone())),\n         .. doc\n     }\n }\n@@ -62,7 +62,7 @@ fn fold_nmod(\n     let doc = fold::default_any_fold_nmod(fold, doc);\n \n     doc::NmodDoc {\n-        index: Some(build_nmod_index(copy doc, copy fold.ctxt)),\n+        index: Some(build_nmod_index(doc.clone(), fold.ctxt.clone())),\n         .. doc\n     }\n }\n@@ -73,7 +73,7 @@ fn build_mod_index(\n ) -> doc::Index {\n     doc::Index {\n         entries: doc.items.map(|doc| {\n-            item_to_entry(copy *doc, &config)\n+            item_to_entry((*doc).clone(), &config)\n         })\n     }\n }\n@@ -84,7 +84,7 @@ fn build_nmod_index(\n ) -> doc::Index {\n     doc::Index {\n         entries: doc.fns.map(|doc| {\n-            item_to_entry(doc::FnTag(copy *doc), &config)\n+            item_to_entry(doc::FnTag((*doc).clone()), &config)\n         })\n     }\n }\n@@ -97,16 +97,16 @@ fn item_to_entry(\n       doc::ModTag(_) | doc::NmodTag(_)\n       if config.output_style == config::DocPerMod => {\n         markdown_writer::make_filename(config,\n-                                       doc::ItemPage(copy doc)).to_str()\n+                                       doc::ItemPage(doc.clone())).to_str()\n       }\n       _ => {\n-        ~\"#\" + pandoc_header_id(markdown_pass::header_text(copy doc))\n+        ~\"#\" + pandoc_header_id(markdown_pass::header_text(doc.clone()))\n       }\n     };\n \n     doc::IndexEntry {\n-        kind: markdown_pass::header_kind(copy doc),\n-        name: markdown_pass::header_name(copy doc),\n+        kind: markdown_pass::header_kind(doc.clone()),\n+        name: markdown_pass::header_name(doc.clone()),\n         brief: doc.brief(),\n         link: link\n     }"}, {"sha": "a1f4ddf986b0ec247c47d3f0870217b661ec0195", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 25, "deletions": 35, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -57,7 +57,7 @@ fn run(\n     // makes the headers come out nested correctly.\n     let sorted_doc = (sort_pass::mk_pass(\n         ~\"mods last\", mods_last\n-    ).f)(srv, copy doc);\n+    ).f)(srv, doc.clone());\n \n     write_markdown(sorted_doc, writer_factory);\n \n@@ -77,15 +77,15 @@ pub fn write_markdown(\n     // (See #2484, which is closed.)\n     do doc.pages.map |page| {\n         let ctxt = Ctxt {\n-            w: writer_factory(copy *page)\n+            w: writer_factory((*page).clone())\n         };\n         write_page(&ctxt, page)\n     };\n }\n \n fn write_page(ctxt: &Ctxt, page: &doc::Page) {\n-    write_title(ctxt, copy *page);\n-    match copy *page {\n+    write_title(ctxt, (*page).clone());\n+    match (*page).clone() {\n         doc::CratePage(doc) => {\n             write_crate(ctxt, doc);\n         }\n@@ -106,7 +106,7 @@ fn write_title(ctxt: &Ctxt, page: doc::Page) {\n fn make_title(page: doc::Page) -> ~str {\n     let item = match page {\n         doc::CratePage(CrateDoc) => {\n-            doc::ModTag(copy CrateDoc.topmod)\n+            doc::ModTag(CrateDoc.topmod.clone())\n         }\n         doc::ItemPage(ItemTag) => {\n             ItemTag\n@@ -208,7 +208,7 @@ pub fn header_name(doc: doc::ItemTag) -> ~str {\n pub fn header_text(doc: doc::ItemTag) -> ~str {\n     match &doc {\n         &doc::ImplTag(ref ImplDoc) => {\n-            let header_kind = header_kind(copy doc);\n+            let header_kind = header_kind(doc.clone());\n             let bounds = if ImplDoc.bounds_str.is_some() {\n                 fmt!(\" where `%s`\", *ImplDoc.bounds_str.get_ref())\n             } else {\n@@ -227,7 +227,7 @@ pub fn header_text(doc: doc::ItemTag) -> ~str {\n         _ => {}\n     }\n \n-    header_text_(header_kind(copy doc),\n+    header_text_(header_kind(doc.clone()),\n                  header_name(doc))\n }\n \n@@ -239,7 +239,7 @@ fn write_crate(\n     ctxt: &Ctxt,\n     doc: doc::CrateDoc\n ) {\n-    write_top_module(ctxt, copy doc.topmod);\n+    write_top_module(ctxt, doc.topmod.clone());\n }\n \n fn write_top_module(\n@@ -280,13 +280,13 @@ fn write_desc(\n \n fn write_sections(ctxt: &Ctxt, sections: &[doc::Section]) {\n     for sections.iter().advance |section| {\n-        write_section(ctxt, copy *section);\n+        write_section(ctxt, (*section).clone());\n     }\n }\n \n fn write_section(ctxt: &Ctxt, section: doc::Section) {\n-    write_header_(ctxt, H4, copy section.header);\n-    ctxt.w.put_line(copy section.body);\n+    write_header_(ctxt, H4, section.header.clone());\n+    ctxt.w.put_line(section.body.clone());\n     ctxt.w.put_line(~\"\");\n }\n \n@@ -300,7 +300,7 @@ fn write_mod_contents(\n     }\n \n     for doc.items.iter().advance |itemTag| {\n-        write_item(ctxt, copy *itemTag);\n+        write_item(ctxt, (*itemTag).clone());\n     }\n }\n \n@@ -314,7 +314,7 @@ fn write_item_no_header(ctxt: &Ctxt, doc: doc::ItemTag) {\n \n fn write_item_(ctxt: &Ctxt, doc: doc::ItemTag, write_header: bool) {\n     if write_header {\n-        write_item_header(ctxt, copy doc);\n+        write_item_header(ctxt, doc.clone());\n     }\n \n     match doc {\n@@ -351,7 +351,7 @@ fn write_index(ctxt: &Ctxt, index: &doc::Index) {\n \n     for index.entries.iter().advance |entry| {\n         let header = header_text_(entry.kind, entry.name);\n-        let id = copy entry.link;\n+        let id = entry.link.clone();\n         if entry.brief.is_some() {\n             ctxt.w.put_line(fmt!(\"* [%s](%s) - %s\",\n                                  header, id, *entry.brief.get_ref()));\n@@ -371,21 +371,16 @@ fn write_nmod(ctxt: &Ctxt, doc: doc::NmodDoc) {\n     }\n \n     for doc.fns.iter().advance |FnDoc| {\n-        write_item_header(ctxt, doc::FnTag(copy *FnDoc));\n-        write_fn(ctxt, copy *FnDoc);\n+        write_item_header(ctxt, doc::FnTag((*FnDoc).clone()));\n+        write_fn(ctxt, (*FnDoc).clone());\n     }\n }\n \n fn write_fn(\n     ctxt: &Ctxt,\n     doc: doc::FnDoc\n ) {\n-    write_fnlike(\n-        ctxt,\n-        copy doc.sig,\n-        doc.desc(),\n-        doc.sections()\n-    );\n+    write_fnlike(ctxt, doc.sig.clone(), doc.desc(), doc.sections());\n }\n \n fn write_fnlike(\n@@ -418,7 +413,7 @@ fn write_const(\n     ctxt: &Ctxt,\n     doc: doc::ConstDoc\n ) {\n-    write_sig(ctxt, copy doc.sig);\n+    write_sig(ctxt, doc.sig.clone());\n     write_common(ctxt, doc.desc(), doc.sections());\n }\n \n@@ -441,7 +436,7 @@ fn write_variants(\n     write_header_(ctxt, H4, ~\"Variants\");\n \n     for docs.iter().advance |variant| {\n-        write_variant(ctxt, copy *variant);\n+        write_variant(ctxt, (*variant).clone());\n     }\n \n     ctxt.w.put_line(~\"\");\n@@ -454,7 +449,7 @@ fn write_variant(ctxt: &Ctxt, doc: doc::VariantDoc) {\n     // space out list items so they all end up within paragraph elements\n     ctxt.w.put_line(~\"\");\n \n-    match copy doc.desc {\n+    match doc.desc.clone() {\n         Some(desc) => {\n             ctxt.w.put_line(list_item_indent(fmt!(\"* `%s` - %s\", *sig, desc)));\n         }\n@@ -480,18 +475,13 @@ fn write_trait(ctxt: &Ctxt, doc: doc::TraitDoc) {\n \n fn write_methods(ctxt: &Ctxt, docs: &[doc::MethodDoc]) {\n     for docs.iter().advance |doc| {\n-        write_method(ctxt, copy *doc);\n+        write_method(ctxt, (*doc).clone());\n     }\n }\n \n fn write_method(ctxt: &Ctxt, doc: doc::MethodDoc) {\n     write_header_(ctxt, H3, header_text_(\"Method\", doc.name));\n-    write_fnlike(\n-        ctxt,\n-        copy doc.sig,\n-        copy doc.desc,\n-        doc.sections\n-    );\n+    write_fnlike(ctxt, doc.sig.clone(), doc.desc.clone(), doc.sections);\n }\n \n fn write_impl(ctxt: &Ctxt, doc: doc::ImplDoc) {\n@@ -503,15 +493,15 @@ fn write_type(\n     ctxt: &Ctxt,\n     doc: doc::TyDoc\n ) {\n-    write_sig(ctxt, copy doc.sig);\n+    write_sig(ctxt, doc.sig.clone());\n     write_common(ctxt, doc.desc(), doc.sections());\n }\n \n fn put_struct(\n     ctxt: &Ctxt,\n     doc: doc::StructDoc\n ) {\n-    write_sig(ctxt, copy doc.sig);\n+    write_sig(ctxt, doc.sig.clone());\n     write_common(ctxt, doc.desc(), doc.sections());\n }\n \n@@ -766,7 +756,7 @@ mod test {\n                     topmod: doc::ModDoc{\n                         items: ~[doc::FnTag(doc::SimpleItemDoc{\n                             sig: Some(~\"line 1\\nline 2\"),\n-                            .. copy doc.cratemod().fns()[0]\n+                            .. (doc.cratemod().fns()[0]).clone()\n                         })],\n                         .. doc.cratemod()\n                     },"}, {"sha": "74ce1b650bce86acaf271b5d249a23503df93f9d", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -22,6 +22,7 @@ use std::str;\n use std::task;\n use extra::future;\n \n+#[deriving(Clone)]\n pub enum WriteInstr {\n     Write(~str),\n     Done\n@@ -90,7 +91,7 @@ fn pandoc_writer(\n     page: doc::Page\n ) -> Writer {\n     assert!(config.pandoc_cmd.is_some());\n-    let pandoc_cmd = copy *config.pandoc_cmd.get_ref();\n+    let pandoc_cmd = (*config.pandoc_cmd.get_ref()).clone();\n     let filename = make_local_filename(config, page);\n \n     let pandoc_args = ~[\n@@ -198,7 +199,7 @@ pub fn future_writer_factory(\n             let mut future = future;\n             writer_ch.send(writer);\n             let s = future.get();\n-            markdown_ch.send((copy page, s));\n+            markdown_ch.send((page.clone(), s));\n         }\n         writer_po.recv()\n     };\n@@ -208,7 +209,7 @@ pub fn future_writer_factory(\n \n fn future_writer() -> (Writer, future::Future<~str>) {\n     let (port, chan) = comm::stream();\n-    let writer: ~fn(instr: WriteInstr) = |instr| chan.send(copy instr);\n+    let writer: ~fn(instr: WriteInstr) = |instr| chan.send(instr.clone());\n     let future = do future::from_fn || {\n         let mut res = ~\"\";\n         loop {\n@@ -234,7 +235,7 @@ mod test {\n \n     fn mk_doc(name: ~str, source: ~str) -> doc::Doc {\n         do astsrv::from_str(source) |srv| {\n-            let doc = extract::from_srv(srv.clone(), copy name);\n+            let doc = extract::from_srv(srv.clone(), name.clone());\n             let doc = (path_pass::mk_pass().f)(srv.clone(), doc);\n             doc\n         }\n@@ -278,7 +279,7 @@ mod test {\n         };\n         let doc = mk_doc(~\"\", ~\"mod a { mod b { } }\");\n         // hidden __std_macros module at the start.\n-        let modb = copy doc.cratemod().mods()[1].mods()[0];\n+        let modb = doc.cratemod().mods()[1].mods()[0].clone();\n         let page = doc::ItemPage(doc::ModTag(modb));\n         let filename = make_local_filename(&config, page);\n         assert_eq!(filename, Path(\"output/dir/a_b.html\"));"}, {"sha": "4f1ce45cb60c07f407eaffbcd9f41212881da92b", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 18, "deletions": 31, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -23,7 +23,6 @@ use doc;\n use fold::Fold;\n use fold;\n use pass::Pass;\n-use util::NominalOp;\n \n use std::comm::*;\n use std::task;\n@@ -62,8 +61,6 @@ pub fn run(\n type PagePort = Port<Option<doc::Page>>;\n type PageChan = SharedChan<Option<doc::Page>>;\n \n-type NominalPageChan = NominalOp<PageChan>;\n-\n fn make_doc_from_pages(page_port: &PagePort) -> doc::Doc {\n     let mut pages = ~[];\n     loop {\n@@ -81,46 +78,39 @@ fn make_doc_from_pages(page_port: &PagePort) -> doc::Doc {\n \n fn find_pages(doc: doc::Doc, page_chan: PageChan) {\n     let fold = Fold {\n-        ctxt: NominalOp { op: page_chan.clone() },\n+        ctxt: page_chan.clone(),\n         fold_crate: fold_crate,\n         fold_mod: fold_mod,\n         fold_nmod: fold_nmod,\n-        .. fold::default_any_fold(NominalOp { op: page_chan.clone() })\n+        .. fold::default_any_fold(page_chan.clone())\n     };\n-    (fold.fold_doc)(&fold, copy doc);\n+    (fold.fold_doc)(&fold, doc.clone());\n \n     page_chan.send(None);\n }\n \n-fn fold_crate(\n-    fold: &fold::Fold<NominalPageChan>,\n-    doc: doc::CrateDoc\n-) -> doc::CrateDoc {\n-\n+fn fold_crate(fold: &fold::Fold<PageChan>, doc: doc::CrateDoc)\n+              -> doc::CrateDoc {\n     let doc = fold::default_seq_fold_crate(fold, doc);\n \n     let page = doc::CratePage(doc::CrateDoc {\n-        topmod: strip_mod(copy doc.topmod),\n-        .. copy doc\n+        topmod: strip_mod(doc.topmod.clone()),\n+        .. doc.clone()\n     });\n \n-    fold.ctxt.op.send(Some(page));\n+    fold.ctxt.send(Some(page));\n \n     doc\n }\n \n-fn fold_mod(\n-    fold: &fold::Fold<NominalPageChan>,\n-    doc: doc::ModDoc\n-) -> doc::ModDoc {\n-\n+fn fold_mod(fold: &fold::Fold<PageChan>, doc: doc::ModDoc) -> doc::ModDoc {\n     let doc = fold::default_any_fold_mod(fold, doc);\n \n     if doc.id() != ast::crate_node_id {\n \n-        let doc = strip_mod(copy doc);\n+        let doc = strip_mod(doc.clone());\n         let page = doc::ItemPage(doc::ModTag(doc));\n-        fold.ctxt.op.send(Some(page));\n+        fold.ctxt.send(Some(page));\n     }\n \n     doc\n@@ -133,18 +123,15 @@ fn strip_mod(doc: doc::ModDoc) -> doc::ModDoc {\n               doc::ModTag(_) | doc::NmodTag(_) => false,\n               _ => true\n             }\n-        }.transform(|x| copy *x).collect::<~[doc::ItemTag]>(),\n-        .. copy doc\n+        }.transform(|x| (*x).clone()).collect::<~[doc::ItemTag]>(),\n+        .. doc.clone()\n     }\n }\n \n-fn fold_nmod(\n-    fold: &fold::Fold<NominalPageChan>,\n-    doc: doc::NmodDoc\n-) -> doc::NmodDoc {\n+fn fold_nmod(fold: &fold::Fold<PageChan>, doc: doc::NmodDoc) -> doc::NmodDoc {\n     let doc = fold::default_seq_fold_nmod(fold, doc);\n-    let page = doc::ItemPage(doc::NmodTag(copy doc));\n-    fold.ctxt.op.send(Some(page));\n+    let page = doc::ItemPage(doc::NmodTag(doc.clone()));\n+    fold.ctxt.send(Some(page));\n     return doc;\n }\n \n@@ -162,7 +149,7 @@ mod test {\n         output_style: config::OutputStyle,\n         source: ~str\n     ) -> doc::Doc {\n-        do astsrv::from_str(copy source) |srv| {\n+        do astsrv::from_str(source.clone()) |srv| {\n             let doc = extract::from_srv(srv.clone(), ~\"\");\n             let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n             let doc = (prune_hidden_pass::mk_pass().f)(srv.clone(), doc);\n@@ -171,7 +158,7 @@ mod test {\n     }\n \n     fn mk_doc(source: ~str) -> doc::Doc {\n-        mk_doc_(config::DocPerMod, copy source)\n+        mk_doc_(config::DocPerMod, source.clone())\n     }\n \n     #[test]"}, {"sha": "83aa6e46c76285c03328ea2cf1b4006b3798ab3f", "filename": "src/librustdoc/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fparse.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -29,7 +29,7 @@ pub fn from_str(source: @str) -> @ast::crate {\n \n pub fn from_file_sess(sess: session::Session, file: &Path) -> @ast::crate {\n     parse::parse_crate_from_file(\n-        file, cfg(sess, file_input(copy *file)), sess.parse_sess)\n+        file, cfg(sess, file_input((*file).clone())), sess.parse_sess)\n }\n \n pub fn from_str_sess(sess: session::Session, source: @str) -> @ast::crate {"}, {"sha": "0654e1bbd1af1ae9c79aa5fb28b0a0d80cc5835e", "filename": "src/librustdoc/pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpass.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -31,8 +31,8 @@ pub fn run_passes(\n     do passes.iter().fold(doc) |doc, pass| {\n         debug!(\"pass #%d\", passno);\n         passno += 1;\n-        do time(copy pass.name) {\n-            (pass.f)(srv.clone(), copy doc)\n+        do time(pass.name.clone()) {\n+            (pass.f)(srv.clone(), doc.clone())\n         }\n     }\n }\n@@ -49,7 +49,7 @@ fn test_run_passes() {\n                     topmod: doc::ModDoc{\n                         item: doc::ItemDoc {\n                             name: doc.cratemod().name() + \"two\",\n-                            .. copy doc.cratemod().item\n+                            .. doc.cratemod().item.clone()\n                         },\n                         items: ~[],\n                         index: None\n@@ -68,7 +68,7 @@ fn test_run_passes() {\n                     topmod: doc::ModDoc{\n                         item: doc::ItemDoc {\n                             name: doc.cratemod().name() + \"three\",\n-                            .. copy doc.cratemod().item\n+                            .. doc.cratemod().item.clone()\n                         },\n                         items: ~[],\n                         index: None"}, {"sha": "b333417f2f824459d0bf2718ee9dff4ee5a86b8d", "filename": "src/librustdoc/path_pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fpath_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fpath_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpath_pass.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -38,7 +38,7 @@ impl Clone for Ctxt {\n     fn clone(&self) -> Ctxt {\n         Ctxt {\n             srv: self.srv.clone(),\n-            path: @mut copy *self.path\n+            path: @mut (*self.path).clone()\n         }\n     }\n }\n@@ -61,7 +61,7 @@ fn run(srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n \n fn fold_item(fold: &fold::Fold<Ctxt>, doc: doc::ItemDoc) -> doc::ItemDoc {\n     doc::ItemDoc {\n-        path: copy *fold.ctxt.path,\n+        path: (*fold.ctxt.path).clone(),\n         .. doc\n     }\n }\n@@ -75,7 +75,7 @@ fn fold_mod(fold: &fold::Fold<Ctxt>, doc: doc::ModDoc) -> doc::ModDoc {\n     if !is_topmod { fold.ctxt.path.pop(); }\n \n     doc::ModDoc {\n-        item: (fold.fold_item)(fold, copy doc.item),\n+        item: (fold.fold_item)(fold, doc.item.clone()),\n         .. doc\n     }\n }\n@@ -86,7 +86,7 @@ fn fold_nmod(fold: &fold::Fold<Ctxt>, doc: doc::NmodDoc) -> doc::NmodDoc {\n     fold.ctxt.path.pop();\n \n     doc::NmodDoc {\n-        item: (fold.fold_item)(fold, copy doc.item),\n+        item: (fold.fold_item)(fold, doc.item.clone()),\n         .. doc\n     }\n }"}, {"sha": "04cb0e3f71076f55efb87225dd697eea1dbcbdf1", "filename": "src/librustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_hidden_pass.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -43,7 +43,7 @@ fn fold_mod(\n     doc::ModDoc {\n         items: do doc.items.iter().filter |item_tag| {\n             !is_hidden(fold.ctxt.clone(), item_tag.item())\n-        }.transform(|x| copy *x).collect(),\n+        }.transform(|x| (*x).clone()).collect(),\n         .. doc\n     }\n }\n@@ -54,7 +54,7 @@ fn is_hidden(srv: astsrv::Srv, doc: doc::ItemDoc) -> bool {\n     let id = doc.id;\n     do astsrv::exec(srv) |ctxt| {\n         let attrs = match ctxt.ast_map.get_copy(&id) {\n-          ast_map::node_item(item, _) => copy item.attrs,\n+          ast_map::node_item(item, _) => item.attrs.clone(),\n           _ => ~[]\n         };\n         attr_parser::parse_hidden(attrs)\n@@ -69,7 +69,7 @@ mod test {\n     use prune_hidden_pass::run;\n \n     fn mk_doc(source: ~str) -> doc::Doc {\n-        do astsrv::from_str(copy source) |srv| {\n+        do astsrv::from_str(source.clone()) |srv| {\n             let doc = extract::from_srv(srv.clone(), ~\"\");\n             run(srv.clone(), doc)\n         }"}, {"sha": "6f3f91f3c65de66cb9de4f1bcd82146115ee371b", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -61,11 +61,11 @@ fn fold_impl(\n                 match item.node {\n                     ast::item_impl(_, None, _, ref methods) => {\n                         // Associated impls have complex rules for method visibility\n-                        strip_priv_methods(copy doc, *methods, item.vis)\n+                        strip_priv_methods(doc.clone(), *methods, item.vis)\n                     }\n                     ast::item_impl(_, Some(_), _ ,_) => {\n                         // Trait impls don't\n-                        copy doc\n+                        doc.clone()\n                     }\n                     _ => fail!()\n                 }\n@@ -91,7 +91,7 @@ fn strip_priv_methods(\n             ast::private => false,\n             ast::inherited => item_vis == ast::public\n         }\n-    }.transform(|x| copy *x).collect();\n+    }.transform(|x| (*x).clone()).collect();\n \n     doc::ImplDoc {\n         methods: methods,\n@@ -126,7 +126,7 @@ fn fold_mod(\n                     is_visible(fold.ctxt.clone(), item_tag.item())\n                 }\n             }\n-        }).transform(|x| copy *x).collect(),\n+        }).transform(|x| (*x).clone()).collect(),\n         .. doc\n     }\n }\n@@ -163,7 +163,7 @@ mod test {\n     use prune_private_pass::run;\n \n     fn mk_doc(source: ~str) -> doc::Doc {\n-        do astsrv::from_str(copy source) |srv| {\n+        do astsrv::from_str(source.clone()) |srv| {\n             let doc = extract::from_srv(srv.clone(), ~\"\");\n             let doc = tystr_pass::run(srv.clone(), doc);\n             run(srv.clone(), doc)"}, {"sha": "644f3d78cf49c6969f58e5d0a706146b75203262", "filename": "src/librustdoc/rustdoc.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -59,7 +59,6 @@ pub mod page_pass;\n pub mod sectionalize_pass;\n pub mod escape_pass;\n pub mod prune_private_pass;\n-pub mod util;\n \n pub fn main() {\n     let args = os::args();\n@@ -83,7 +82,7 @@ pub fn main() {\n /// Runs rustdoc over the given file\n fn run(config: Config) {\n \n-    let source_file = copy config.input_crate;\n+    let source_file = config.input_crate.clone();\n \n     // Create an AST service from the source code\n     do astsrv::from_file(source_file.to_str()) |srv| {\n@@ -96,7 +95,7 @@ fn run(config: Config) {\n         // Extract the initial doc tree from the AST. This contains\n         // just names and node ids.\n         let doc = time(~\"extract\", || {\n-            let default_name = copy source_file;\n+            let default_name = source_file.clone();\n             extract::from_srv(srv.clone(), default_name.to_str())\n         });\n \n@@ -127,13 +126,13 @@ fn run(config: Config) {\n             // Sort items again by kind\n             sort_item_type_pass::mk_pass(),\n             // Create indexes appropriate for markdown\n-            markdown_index_pass::mk_pass(copy config),\n+            markdown_index_pass::mk_pass(config.clone()),\n             // Break the document into pages if required by the\n             // output format\n             page_pass::mk_pass(config.output_style),\n             // Render\n             markdown_pass::mk_pass(\n-                markdown_writer::make_writer_factory(copy config)\n+                markdown_writer::make_writer_factory(config.clone())\n             )\n         ]);\n     }"}, {"sha": "9f39f8545395e48c9e7d01d886f75df9a8fa04ae", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -39,7 +39,7 @@ pub fn run(_srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n \n fn fold_item(fold: &fold::Fold<()>, doc: doc::ItemDoc) -> doc::ItemDoc {\n     let doc = fold::default_seq_fold_item(fold, doc);\n-    let (desc, sections) = sectionalize(copy doc.desc);\n+    let (desc, sections) = sectionalize(doc.desc.clone());\n \n     doc::ItemDoc {\n         desc: desc,\n@@ -53,12 +53,12 @@ fn fold_trait(fold: &fold::Fold<()>, doc: doc::TraitDoc) -> doc::TraitDoc {\n \n     doc::TraitDoc {\n         methods: do doc.methods.map |method| {\n-            let (desc, sections) = sectionalize(copy method.desc);\n+            let (desc, sections) = sectionalize(method.desc.clone());\n \n             doc::MethodDoc {\n                 desc: desc,\n                 sections: sections,\n-                .. copy *method\n+                .. (*method).clone()\n             }\n         },\n         .. doc\n@@ -70,12 +70,12 @@ fn fold_impl(fold: &fold::Fold<()>, doc: doc::ImplDoc) -> doc::ImplDoc {\n \n     doc::ImplDoc {\n         methods: do doc.methods.map |method| {\n-            let (desc, sections) = sectionalize(copy method.desc);\n+            let (desc, sections) = sectionalize(method.desc.clone());\n \n             doc::MethodDoc {\n                 desc: desc,\n                 sections: sections,\n-                .. copy *method\n+                .. (*method).clone()\n             }\n         },\n         .. doc\n@@ -105,30 +105,30 @@ fn sectionalize(desc: Option<~str>) -> (Option<~str>, ~[doc::Section]) {\n     }\n \n     let mut new_desc = None::<~str>;\n-    let mut current_section = None;\n+    let mut current_section: Option<doc::Section> = None;\n     let mut sections = ~[];\n \n     for desc.get_ref().any_line_iter().advance |line| {\n         match parse_header(line) {\n           Some(header) => {\n             if current_section.is_some() {\n-                sections.push(copy *current_section.get_ref());\n+                sections.push((*current_section.get_ref()).clone());\n             }\n             current_section = Some(doc::Section {\n                 header: header.to_owned(),\n                 body: ~\"\"\n             });\n           }\n           None => {\n-            match copy current_section {\n+            match current_section.clone() {\n               Some(section) => {\n                 current_section = Some(doc::Section {\n                     body: fmt!(\"%s\\n%s\", section.body, line),\n                     .. section\n                 });\n               }\n               None => {\n-                new_desc = match copy new_desc {\n+                new_desc = match new_desc.clone() {\n                   Some(desc) => {\n                     Some(fmt!(\"%s\\n%s\", desc, line))\n                   }\n@@ -170,7 +170,7 @@ mod test {\n     use sectionalize_pass::run;\n \n     fn mk_doc(source: ~str) -> doc::Doc {\n-        do astsrv::from_str(copy source) |srv| {\n+        do astsrv::from_str(source.clone()) |srv| {\n             let doc = extract::from_srv(srv.clone(), ~\"\");\n             let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n             let doc = (prune_hidden_pass::mk_pass().f)(srv.clone(), doc);"}, {"sha": "8b973c78d73bb8a3aa763f2e0406569ff255a550", "filename": "src/librustdoc/sort_pass.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fsort_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Fsort_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_pass.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -15,20 +15,30 @@ use doc;\n use fold::Fold;\n use fold;\n use pass::Pass;\n-use util::NominalOp;\n \n #[cfg(test)] use extract;\n \n use extra::sort;\n+use std::clone::Clone;\n \n pub type ItemLtEqOp = @fn(v1: &doc::ItemTag, v2:  &doc::ItemTag) -> bool;\n \n-type ItemLtEq = NominalOp<ItemLtEqOp>;\n+struct ItemLtEq {\n+    op: ItemLtEqOp,\n+}\n+\n+impl Clone for ItemLtEq {\n+    fn clone(&self) -> ItemLtEq {\n+        ItemLtEq {\n+            op: self.op,\n+        }\n+    }\n+}\n \n pub fn mk_pass(name: ~str, lteq: ItemLtEqOp) -> Pass {\n     Pass {\n-        name: copy name,\n-        f: |srv, doc| run(srv, doc, NominalOp { op: lteq })\n+        name: name.clone(),\n+        f: |srv, doc| run(srv, doc, ItemLtEq { op: lteq })\n     }\n }\n "}, {"sha": "5121a312d934ebe60532ea81f2cc8a765b93579a", "filename": "src/librustdoc/text_pass.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftext_pass.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -17,14 +17,13 @@ use doc;\n use fold::Fold;\n use fold;\n use pass::Pass;\n-use util::NominalOp;\n \n use std::cell::Cell;\n \n pub fn mk_pass(name: ~str, op: @fn(&str) -> ~str) -> Pass {\n     let op = Cell::new(op);\n     Pass {\n-        name: copy name,\n+        name: name.clone(),\n         f: |srv: astsrv::Srv, doc: doc::Doc| -> doc::Doc {\n             run(srv, doc, op.take())\n         }\n@@ -33,13 +32,25 @@ pub fn mk_pass(name: ~str, op: @fn(&str) -> ~str) -> Pass {\n \n type Op = @fn(&str) -> ~str;\n \n+struct WrappedOp {\n+    op: Op,\n+}\n+\n+impl Clone for WrappedOp {\n+    fn clone(&self) -> WrappedOp {\n+        WrappedOp {\n+            op: self.op,\n+        }\n+    }\n+}\n+\n #[allow(non_implicitly_copyable_typarams)]\n fn run(\n     _srv: astsrv::Srv,\n     doc: doc::Doc,\n     op: Op\n ) -> doc::Doc {\n-    let op = NominalOp {\n+    let op = WrappedOp {\n         op: op\n     };\n     let fold = Fold {\n@@ -52,85 +63,74 @@ fn run(\n     (fold.fold_doc)(&fold, doc)\n }\n \n-fn maybe_apply_op(op: NominalOp<Op>, s: &Option<~str>) -> Option<~str> {\n+fn maybe_apply_op(op: WrappedOp, s: &Option<~str>) -> Option<~str> {\n     s.map(|s| (op.op)(*s) )\n }\n \n-fn fold_item(\n-    fold: &fold::Fold<NominalOp<Op>>,\n-    doc: doc::ItemDoc\n-) -> doc::ItemDoc {\n+fn fold_item(fold: &fold::Fold<WrappedOp>, doc: doc::ItemDoc)\n+             -> doc::ItemDoc {\n     let doc = fold::default_seq_fold_item(fold, doc);\n \n     doc::ItemDoc {\n         brief: maybe_apply_op(fold.ctxt, &doc.brief),\n         desc: maybe_apply_op(fold.ctxt, &doc.desc),\n-        sections: apply_to_sections(fold.ctxt, copy doc.sections),\n+        sections: apply_to_sections(fold.ctxt, doc.sections.clone()),\n         .. doc\n     }\n }\n \n-fn apply_to_sections(\n-    op: NominalOp<Op>,\n-    sections: ~[doc::Section]\n-) -> ~[doc::Section] {\n+fn apply_to_sections(op: WrappedOp, sections: ~[doc::Section])\n+                     -> ~[doc::Section] {\n     sections.map(|section| doc::Section {\n-        header: (op.op)(copy section.header),\n-        body: (op.op)(copy section.body)\n+        header: (op.op)(section.header.clone()),\n+        body: (op.op)(section.body.clone())\n     })\n }\n \n-fn fold_enum(\n-    fold: &fold::Fold<NominalOp<Op>>,\n-    doc: doc::EnumDoc) -> doc::EnumDoc {\n+fn fold_enum(fold: &fold::Fold<WrappedOp>, doc: doc::EnumDoc)\n+             -> doc::EnumDoc {\n     let doc = fold::default_seq_fold_enum(fold, doc);\n     let fold_copy = *fold;\n \n     doc::EnumDoc {\n         variants: do doc.variants.map |variant| {\n             doc::VariantDoc {\n                 desc: maybe_apply_op(fold_copy.ctxt, &variant.desc),\n-                .. copy *variant\n+                .. (*variant).clone()\n             }\n         },\n         .. doc\n     }\n }\n \n-fn fold_trait(\n-    fold: &fold::Fold<NominalOp<Op>>,\n-    doc: doc::TraitDoc\n-) -> doc::TraitDoc {\n+fn fold_trait(fold: &fold::Fold<WrappedOp>, doc: doc::TraitDoc)\n+              -> doc::TraitDoc {\n     let doc = fold::default_seq_fold_trait(fold, doc);\n \n     doc::TraitDoc {\n-        methods: apply_to_methods(fold.ctxt, copy doc.methods),\n+        methods: apply_to_methods(fold.ctxt, doc.methods.clone()),\n         .. doc\n     }\n }\n \n-fn apply_to_methods(\n-    op: NominalOp<Op>,\n-    docs: ~[doc::MethodDoc]\n-) -> ~[doc::MethodDoc] {\n+fn apply_to_methods(op: WrappedOp, docs: ~[doc::MethodDoc])\n+                    -> ~[doc::MethodDoc] {\n     do docs.map |doc| {\n         doc::MethodDoc {\n             brief: maybe_apply_op(op, &doc.brief),\n             desc: maybe_apply_op(op, &doc.desc),\n-            sections: apply_to_sections(op, copy doc.sections),\n-            .. copy *doc\n+            sections: apply_to_sections(op, doc.sections.clone()),\n+            .. (*doc).clone()\n         }\n     }\n }\n \n-fn fold_impl(\n-    fold: &fold::Fold<NominalOp<Op>>,\n-    doc: doc::ImplDoc\n-) -> doc::ImplDoc {\n+fn fold_impl(fold: &fold::Fold<WrappedOp>, doc: doc::ImplDoc)\n+             -> doc::ImplDoc {\n     let doc = fold::default_seq_fold_impl(fold, doc);\n \n     doc::ImplDoc {\n-        methods: apply_to_methods(fold.ctxt, copy doc.methods),\n+        methods: apply_to_methods(fold.ctxt, doc.methods.clone()),\n         .. doc\n     }\n }\n@@ -147,7 +147,7 @@ mod test {\n     use text_pass::mk_pass;\n \n     fn mk_doc(source: ~str) -> doc::Doc {\n-        do astsrv::from_str(copy source) |srv| {\n+        do astsrv::from_str(source.clone()) |srv| {\n             let doc = extract::from_srv(srv.clone(), ~\"\");\n             let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n             let doc = (desc_to_brief_pass::mk_pass().f)(srv.clone(), doc);"}, {"sha": "aaba0427b6245684efe097362fa31a96d4758a54", "filename": "src/librustdoc/trim_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Ftrim_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Ftrim_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftrim_pass.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -32,7 +32,7 @@ mod test {\n     use trim_pass::mk_pass;\n \n     fn mk_doc(source: ~str) -> doc::Doc {\n-        do astsrv::from_str(copy source) |srv| {\n+        do astsrv::from_str(source.clone()) |srv| {\n             let doc = extract::from_srv(srv.clone(), ~\"\");\n             let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n             let doc = (prune_hidden_pass::mk_pass().f)(srv.clone(), doc);"}, {"sha": "f66aeca06ffc821c767024d0e0278a99834e18dd", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -90,7 +90,7 @@ fn fold_const(\n \n     doc::SimpleItemDoc {\n         sig: Some({\n-            let doc = copy doc;\n+            let doc = doc.clone();\n             do astsrv::exec(srv) |ctxt| {\n                 match ctxt.ast_map.get_copy(&doc.id()) {\n                     ast_map::node_item(@ast::item {\n@@ -115,16 +115,16 @@ fn fold_enum(\n     doc::EnumDoc {\n         variants: do doc.variants.iter().transform |variant| {\n             let sig = {\n-                let variant = copy *variant;\n+                let variant = (*variant).clone();\n                 do astsrv::exec(srv.clone()) |ctxt| {\n                     match ctxt.ast_map.get_copy(&doc_id) {\n                         ast_map::node_item(@ast::item {\n                             node: ast::item_enum(ref enum_definition, _), _\n                         }, _) => {\n                             let ast_variant =\n-                                copy *do enum_definition.variants.iter().find_ |v| {\n+                                (*do enum_definition.variants.iter().find_ |v| {\n                                 to_str(v.node.name) == variant.name\n-                            }.get();\n+                            }.get()).clone();\n \n                             pprust::variant_to_str(\n                                 &ast_variant, extract::interner())\n@@ -136,7 +136,7 @@ fn fold_enum(\n \n             doc::VariantDoc {\n                 sig: Some(sig),\n-                .. copy *variant\n+                .. (*variant).clone()\n             }\n         }.collect(),\n         .. doc\n@@ -148,7 +148,7 @@ fn fold_trait(\n     doc: doc::TraitDoc\n ) -> doc::TraitDoc {\n     doc::TraitDoc {\n-        methods: merge_methods(fold.ctxt.clone(), doc.id(), copy doc.methods),\n+        methods: merge_methods(fold.ctxt.clone(), doc.id(), doc.methods.clone()),\n         .. doc\n     }\n }\n@@ -160,8 +160,8 @@ fn merge_methods(\n ) -> ~[doc::MethodDoc] {\n     do docs.iter().transform |doc| {\n         doc::MethodDoc {\n-            sig: get_method_sig(srv.clone(), item_id, copy doc.name),\n-            .. copy *doc\n+            sig: get_method_sig(srv.clone(), item_id, doc.name.clone()),\n+            .. (*doc).clone()\n         }\n     }.collect()\n }\n@@ -177,13 +177,13 @@ fn get_method_sig(\n                 node: ast::item_trait(_, _, ref methods), _\n             }, _) => {\n                 match methods.iter().find_(|&method| {\n-                    match copy *method {\n+                    match (*method).clone() {\n                         ast::required(ty_m) => to_str(ty_m.ident) == method_name,\n                         ast::provided(m) => to_str(m.ident) == method_name,\n                     }\n                 }) {\n                     Some(method) => {\n-                        match copy *method {\n+                        match (*method).clone() {\n                             ast::required(ty_m) => {\n                                 Some(pprust::fun_to_str(\n                                     &ty_m.decl,\n@@ -241,7 +241,7 @@ fn fold_impl(\n     let srv = fold.ctxt.clone();\n \n     let (bounds, trait_types, self_ty) = {\n-        let doc = copy doc;\n+        let doc = doc.clone();\n         do astsrv::exec(srv) |ctxt| {\n             match ctxt.ast_map.get_copy(&doc.id()) {\n                 ast_map::node_item(@ast::item {\n@@ -266,7 +266,7 @@ fn fold_impl(\n         bounds_str: bounds,\n         trait_types: trait_types,\n         self_ty: self_ty,\n-        methods: merge_methods(fold.ctxt.clone(), doc.id(), copy doc.methods),\n+        methods: merge_methods(fold.ctxt.clone(), doc.id(), doc.methods.clone()),\n         .. doc\n     }\n }\n@@ -280,7 +280,7 @@ fn fold_type(\n \n     doc::SimpleItemDoc {\n         sig: {\n-            let doc = copy doc;\n+            let doc = doc.clone();\n             do astsrv::exec(srv) |ctxt| {\n                 match ctxt.ast_map.get_copy(&doc.id()) {\n                     ast_map::node_item(@ast::item {\n@@ -311,7 +311,7 @@ fn fold_struct(\n \n     doc::StructDoc {\n         sig: {\n-            let doc = copy doc;\n+            let doc = doc.clone();\n             do astsrv::exec(srv) |ctxt| {\n                 match ctxt.ast_map.get_copy(&doc.id()) {\n                     ast_map::node_item(item, _) => {\n@@ -332,15 +332,15 @@ fn fold_struct(\n /// should be a simple pprust::struct_to_str function that does\n /// what I actually want\n fn strip_struct_extra_stuff(item: @ast::item) -> @ast::item {\n-    let node = match copy item.node {\n+    let node = match item.node.clone() {\n         ast::item_struct(def, tys) => ast::item_struct(def, tys),\n         _ => fail!(\"not a struct\")\n     };\n \n     @ast::item {\n         attrs: ~[], // Remove the attributes\n         node: node,\n-        .. copy *item\n+        .. (*item).clone()\n     }\n }\n \n@@ -353,7 +353,7 @@ mod test {\n     use tystr_pass::run;\n \n     fn mk_doc(source: ~str) -> doc::Doc {\n-        do astsrv::from_str(copy source) |srv| {\n+        do astsrv::from_str(source.clone()) |srv| {\n             let doc = extract::from_srv(srv.clone(), ~\"\");\n             run(srv.clone(), doc)\n         }"}, {"sha": "20e64087442219c463dddc86b946168fafb5a1a0", "filename": "src/librustdoc/util.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustdoc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustdoc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Futil.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-// Just a named container for our op, so it can have impls\n-pub struct NominalOp<T> {\n-    op: T\n-}\n-\n-impl<T:Copy> Clone for NominalOp<T> {\n-    fn clone(&self) -> NominalOp<T> { copy *self }\n-}"}, {"sha": "e3a32801ca90696312f4294192bc1a8790466539", "filename": "src/librusti/program.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrusti%2Fprogram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrusti%2Fprogram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Fprogram.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -22,6 +22,7 @@ use utils::*;\n \n /// This structure keeps track of the state of the world for the code being\n /// executed in rusti.\n+#[deriving(Clone)]\n struct Program {\n     /// All known local variables\n     local_vars: HashMap<~str, LocalVariable>,\n@@ -41,6 +42,7 @@ struct Program {\n }\n \n /// Represents a local variable that the program is currently using.\n+#[deriving(Clone)]\n struct LocalVariable {\n     /// Should this variable be locally declared as mutable?\n     mutable: bool,\n@@ -218,7 +220,7 @@ impl Program {\n     pub fn set_cache(&self) {\n         let map = @mut HashMap::new();\n         for self.local_vars.iter().advance |(name, value)| {\n-            map.insert(copy *name, @copy value.data);\n+            map.insert((*name).clone(), @(value.data).clone());\n         }\n         local_data::set(tls_key, map);\n     }\n@@ -230,7 +232,7 @@ impl Program {\n         let map = local_data::pop(tls_key).expect(\"tls is empty\");\n         do map.consume |name, value| {\n             match self.local_vars.find_mut(&name) {\n-                Some(v) => { v.data = copy *value; }\n+                Some(v) => { v.data = (*value).clone(); }\n                 None => { fail!(\"unknown variable %s\", name) }\n             }\n         }\n@@ -303,7 +305,7 @@ impl Program {\n                         ty::ty_evec(mt, ty::vstore_slice(*)) |\n                         ty::ty_evec(mt, ty::vstore_fixed(*)) => {\n                             let vty = ppaux::ty_to_str(tcx, mt.ty);\n-                            let derefs = copy tystr;\n+                            let derefs = tystr.clone();\n                             lvar.ty = tystr + \"~[\" + vty + \"]\";\n                             lvar.alterations = Some((tystr + \"&[\" + vty + \"]\",\n                                                      derefs));\n@@ -312,7 +314,7 @@ impl Program {\n                         // Similar to vectors, &str serializes to ~str, so a\n                         // borrow must be taken\n                         ty::ty_estr(ty::vstore_slice(*)) => {\n-                            let derefs = copy tystr;\n+                            let derefs = tystr.clone();\n                             lvar.ty = tystr + \"~str\";\n                             lvar.alterations = Some((tystr + \"&str\", derefs));\n                             break;\n@@ -326,7 +328,7 @@ impl Program {\n                         // If we're just borrowing (no vectors or strings), then\n                         // we just need to record how many borrows there were.\n                         _ => {\n-                            let derefs = copy tystr;\n+                            let derefs = tystr.clone();\n                             let tmptystr = ppaux::ty_to_str(tcx, t);\n                             lvar.alterations = Some((tystr + tmptystr, derefs));\n                             lvar.ty = tmptystr;"}, {"sha": "1bee2146089fae3671344606b90fe86ce9c320f9", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -118,7 +118,7 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n         binary: binary,\n         addl_lib_search_paths: @mut lib_search_paths.map(|p| Path(*p)),\n         jit: true,\n-        .. copy *session::basic_options()\n+        .. (*session::basic_options()).clone()\n     };\n     // Because we assume that everything is encodable (and assert so), add some\n     // extra helpful information if the error crops up. Otherwise people are\n@@ -224,7 +224,7 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n     let dinput = driver::str_input(test.to_managed());\n     let cfg = driver::build_configuration(sess, binary, &dinput);\n     let outputs = driver::build_output_filenames(&dinput, &None, &None, [], sess);\n-    let (crate, tcx) = driver::compile_upto(sess, copy cfg, &dinput,\n+    let (crate, tcx) = driver::compile_upto(sess, cfg.clone(), &dinput,\n                                             driver::cu_typeck, Some(outputs));\n     // Once we're typechecked, record the types of all local variables defined\n     // in this input\n@@ -300,9 +300,9 @@ fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n         let options = @session::options {\n             binary: binary,\n             addl_lib_search_paths: @mut ~[os::getcwd()],\n-            .. copy *session::basic_options()\n+            .. (*session::basic_options()).clone()\n         };\n-        let input = driver::file_input(copy src_path);\n+        let input = driver::file_input(src_path.clone());\n         let sess = driver::build_session(options, diagnostic::emit);\n         *sess.building_library = true;\n         let cfg = driver::build_configuration(sess, binary, &input);\n@@ -393,11 +393,11 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n             for args.iter().advance |arg| {\n                 let (crate, filename) =\n                     if arg.ends_with(\".rs\") || arg.ends_with(\".rc\") {\n-                    (arg.slice_to(arg.len() - 3).to_owned(), copy *arg)\n+                    (arg.slice_to(arg.len() - 3).to_owned(), (*arg).clone())\n                 } else {\n-                    (copy *arg, *arg + \".rs\")\n+                    ((*arg).clone(), *arg + \".rs\")\n                 };\n-                match compile_crate(filename, copy repl.binary) {\n+                match compile_crate(filename, repl.binary.clone()) {\n                     Some(_) => loaded_crates.push(crate),\n                     None => { }\n                 }\n@@ -452,7 +452,7 @@ pub fn run_line(repl: &mut Repl, in: @io::Reader, out: @io::Writer, line: ~str,\n         let len = split.len();\n \n         if len > 0 {\n-            let cmd = copy split[0];\n+            let cmd = split[0].clone();\n \n             if !cmd.is_empty() {\n                 let args = if len > 1 {\n@@ -473,9 +473,9 @@ pub fn run_line(repl: &mut Repl, in: @io::Reader, out: @io::Writer, line: ~str,\n     }\n \n     let line = Cell::new(line);\n-    let program = Cell::new(copy repl.program);\n-    let lib_search_paths = Cell::new(copy repl.lib_search_paths);\n-    let binary = Cell::new(copy repl.binary);\n+    let program = Cell::new(repl.program.clone());\n+    let lib_search_paths = Cell::new(repl.lib_search_paths.clone());\n+    let binary = Cell::new(repl.binary.clone());\n     let result = do task::try {\n         run(program.take(), binary.take(), lib_search_paths.take(), line.take())\n     };\n@@ -499,7 +499,7 @@ pub fn main() {\n     let out = io::stdout();\n     let mut repl = Repl {\n         prompt: ~\"rusti> \",\n-        binary: copy args[0],\n+        binary: args[0].clone(),\n         running: true,\n         lib_search_paths: ~[],\n         engines: ~[],"}, {"sha": "bcda135cbb666442746066a1c1bf10190fcd918d", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -66,9 +66,9 @@ pub fn install_lib(sysroot: @Path,\n     let build_dir = workspace.push(\"build\");\n     let dst_dir = build_dir.push_rel(&*pkg_id.local_path);\n     let pkg_src = PkgSrc {\n-        root: copy workspace,\n-        dst_dir: copy dst_dir,\n-        id: copy pkg_id,\n+        root: workspace.clone(),\n+        dst_dir: dst_dir.clone(),\n+        id: pkg_id.clone(),\n         libs: ~[mk_crate(lib_path)],\n         mains: ~[],\n         tests: ~[],"}, {"sha": "f75c5347d71e9e6fc1bc03294df1e14d0f6bed80", "filename": "src/librustpkg/crate.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustpkg%2Fcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustpkg%2Fcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcrate.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -12,6 +12,7 @@ use std::path::Path;\n use std::vec;\n \n /// A crate is a unit of Rust code to be compiled into a binary or library\n+#[deriving(Clone)]\n pub struct Crate {\n     file: Path,\n     flags: ~[~str],\n@@ -22,37 +23,37 @@ impl Crate {\n \n     pub fn new(p: &Path) -> Crate {\n         Crate {\n-            file: copy *p,\n+            file: (*p).clone(),\n             flags: ~[],\n             cfgs: ~[]\n         }\n     }\n \n     fn flag(&self, flag: ~str) -> Crate {\n         Crate {\n-            flags: vec::append(copy self.flags, [flag]),\n-            .. copy *self\n+            flags: vec::append(self.flags.clone(), [flag]),\n+            .. (*self).clone()\n         }\n     }\n \n     fn flags(&self, flags: ~[~str]) -> Crate {\n         Crate {\n-            flags: vec::append(copy self.flags, flags),\n-            .. copy *self\n+            flags: vec::append(self.flags.clone(), flags),\n+            .. (*self).clone()\n         }\n     }\n \n     fn cfg(&self, cfg: ~str) -> Crate {\n         Crate {\n-            cfgs: vec::append(copy self.cfgs, [cfg]),\n-            .. copy *self\n+            cfgs: vec::append(self.cfgs.clone(), [cfg]),\n+            .. (*self).clone()\n         }\n     }\n \n     fn cfgs(&self, cfgs: ~[~str]) -> Crate {\n         Crate {\n-            cfgs: vec::append(copy self.cfgs, cfgs),\n-            .. copy *self\n+            cfgs: vec::append(self.cfgs.clone(), cfgs),\n+            .. (*self).clone()\n         }\n     }\n }"}, {"sha": "e1cf5b1fd35c57139c4426c416a877ecfbf28d9e", "filename": "src/librustpkg/package_id.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustpkg%2Fpackage_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustpkg%2Fpackage_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_id.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -15,6 +15,7 @@ use version::{try_getting_version, try_getting_local_version,\n /// Path-fragment identifier of a package such as\n /// 'github.com/graydon/test'; path must be a relative\n /// path with >=1 component.\n+#[deriving(Clone)]\n pub struct PkgId {\n     /// Remote path: for example, github.com/mozilla/quux-whatever\n     remote_path: RemotePath,\n@@ -70,8 +71,8 @@ impl PkgId {\n             return cond.raise((p, ~\"0-length pkgid\"));\n         }\n         let remote_path = RemotePath(p);\n-        let local_path = normalize(copy remote_path);\n-        let short_name = (copy local_path).filestem().expect(fmt!(\"Strange path! %s\", s));\n+        let local_path = normalize(remote_path.clone());\n+        let short_name = local_path.clone().filestem().expect(fmt!(\"Strange path! %s\", s));\n \n         let version = match given_version {\n             Some(v) => v,"}, {"sha": "4ba9c8066e4f3ac9e88e2e57faae8f1648c8fa20", "filename": "src/librustpkg/package_path.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustpkg%2Fpackage_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustpkg%2Fpackage_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_path.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -10,17 +10,31 @@\n \n // rustpkg utilities having to do with local and remote paths\n \n-use std::path::Path;\n-use std::option::Some;\n+use std::clone::Clone;\n+use std::hash::Streaming;\n use std::hash;\n+use std::option::Some;\n+use std::path::Path;\n use std::rt::io::Writer;\n-use std::hash::Streaming;\n \n /// Wrappers to prevent local and remote paths from getting confused\n /// (These will go away after #6407)\n pub struct RemotePath (Path);\n+\n+impl Clone for RemotePath {\n+    fn clone(&self) -> RemotePath {\n+        RemotePath((**self).clone())\n+    }\n+}\n+\n pub struct LocalPath (Path);\n \n+impl Clone for LocalPath {\n+    fn clone(&self) -> LocalPath {\n+        LocalPath((**self).clone())\n+    }\n+}\n+\n \n // normalize should be the only way to construct a LocalPath\n // (though this isn't enforced)"}, {"sha": "f7eed969a69b8ee9bea64a9edfbdab42f69301e0", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -41,9 +41,9 @@ impl PkgSrc {\n     pub fn new(src_dir: &Path, dst_dir: &Path,\n                   id: &PkgId) -> PkgSrc {\n         PkgSrc {\n-            root: copy *src_dir,\n-            dst_dir: copy *dst_dir,\n-            id: copy *id,\n+            root: (*src_dir).clone(),\n+            dst_dir: (*dst_dir).clone(),\n+            id: (*id).clone(),\n             libs: ~[],\n             mains: ~[],\n             tests: ~[],\n@@ -62,15 +62,15 @@ impl PkgSrc {\n         debug!(\"Checking dirs: %?\", dirs);\n         let path = dirs.iter().find_(|&d| os::path_exists(d));\n         match path {\n-            Some(d) => dir = copy *d,\n+            Some(d) => dir = (*d).clone(),\n             None => dir = match self.fetch_git() {\n-                None => cond.raise((copy self.id, ~\"supplied path for package dir does not \\\n+                None => cond.raise((self.id.clone(), ~\"supplied path for package dir does not \\\n                                       exist, and couldn't interpret it as a URL fragment\")),\n                 Some(d) => d\n             }\n         }\n         if !os::path_is_dir(&dir) {\n-            cond.raise((copy self.id, ~\"supplied path for package dir is a \\\n+            cond.raise((self.id.clone(), ~\"supplied path for package dir is a \\\n                                         non-directory\"));\n         }\n \n@@ -104,15 +104,15 @@ impl PkgSrc {\n         let url = fmt!(\"https://%s\", self.id.remote_path.to_str());\n         let branch_args = match self.id.version {\n                       NoVersion => ~[],\n-                      ExactRevision(ref s) => ~[~\"--branch\", copy *s],\n+                      ExactRevision(ref s) => ~[~\"--branch\", (*s).clone()],\n                       SemanticVersion(ref s) => ~[~\"--branch\", s.to_str()]\n         };\n \n \n         note(fmt!(\"Fetching package: git clone %s %s %?\", url, local.to_str(), branch_args));\n \n         if run::process_output(\"git\",\n-                               ~[~\"clone\", copy url, local.to_str()] + branch_args).status != 0 {\n+                               ~[~\"clone\", url.clone(), local.to_str()] + branch_args).status != 0 {\n             note(fmt!(\"fetching %s failed: can't clone repository\", url));\n             None\n         }\n@@ -199,7 +199,7 @@ impl PkgSrc {\n             note(\"Couldn't infer any crates to build.\\n\\\n                          Try naming a crate `main.rs`, `lib.rs`, \\\n                          `test.rs`, or `bench.rs`.\");\n-            cond.raise(copy self.id);\n+            cond.raise(self.id.clone());\n         }\n \n         debug!(\"found %u libs, %u mains, %u tests, %u benchs\","}, {"sha": "a2cae3ab20eafca3af073ce8ebd239b26bc62ba2", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -55,7 +55,7 @@ pub fn rust_path() -> ~[Path] {\n     let cwd = os::getcwd();\n     // now add in default entries\n     env_rust_path.push(cwd.push(\".rust\"));\n-    env_rust_path.push(copy cwd);\n+    env_rust_path.push(cwd.clone());\n     do cwd.each_parent() |p| { push_if_exists(&mut env_rust_path, p) };\n     let h = os::homedir();\n     for h.iter().advance |h| { push_if_exists(&mut env_rust_path, h); }\n@@ -94,7 +94,7 @@ pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n     let src_dir = workspace.push(\"src\");\n     let dirs = os::list_dir(&src_dir);\n     for dirs.iter().advance |p| {\n-        let p = Path(copy *p);\n+        let p = Path((*p).clone());\n         debug!(\"=> p = %s\", p.to_str());\n         if !os::path_is_dir(&src_dir.push_rel(&p)) {\n             loop;\n@@ -107,7 +107,7 @@ pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n         else {\n             let pf = p.filename();\n             for pf.iter().advance |pf| {\n-                let f_ = copy *pf;\n+                let f_ = (*pf).clone();\n                 let g = f_.to_str();\n                 match split_version_general(g, '-') {\n                     Some((ref might_match, ref vers)) => {\n@@ -145,7 +145,7 @@ pub fn first_pkgid_src_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<P\n     let rs = pkgid_src_in_workspace(pkgid, workspace);\n     for rs.iter().advance |p| {\n         if os::path_exists(p) {\n-            return Some(copy *p);\n+            return Some((*p).clone());\n         }\n     }\n     None\n@@ -242,7 +242,7 @@ pub fn library_in_workspace(path: &LocalPath, short_name: &str, where: Target,\n     for dir_contents.iter().advance |p| {\n         let mut which = 0;\n         let mut hash = None;\n-        let p_path = Path(copy *p);\n+        let p_path = Path((*p).clone());\n         let extension = p_path.filetype();\n         debug!(\"p = %s, p's extension is %?\", p.to_str(), extension);\n         match extension {\n@@ -308,7 +308,7 @@ pub fn target_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n pub fn target_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     use conditions::bad_path::cond;\n     if !os::path_is_dir(workspace) {\n-        cond.raise((copy *workspace,\n+        cond.raise(((*workspace).clone(),\n                     fmt!(\"Workspace supplied to target_library_in_workspace \\\n                           is not a directory! %s\", workspace.to_str())));\n     }\n@@ -341,7 +341,7 @@ fn target_file_in_workspace(pkgid: &PkgId, workspace: &Path,\n     };\n     let result = workspace.push(subdir);\n     if !os::path_exists(&result) && !mkdir_recursive(&result, U_RWX) {\n-        cond.raise((copy result, fmt!(\"target_file_in_workspace couldn't \\\n+        cond.raise((result.clone(), fmt!(\"target_file_in_workspace couldn't \\\n             create the %s dir (pkgid=%s, workspace=%s, what=%?, where=%?\",\n             subdir, pkgid.to_str(), workspace.to_str(), what, where)));\n     }\n@@ -375,12 +375,15 @@ pub fn mk_output_path(what: OutputType, where: Target,\n     // the executable blat-0.5 to live under blat/\n     let dir = match where {\n         // If we're installing, it just goes under <workspace>...\n-        Install => copy *workspace, // bad copy, but I just couldn't make the borrow checker happy\n+        Install => {\n+            // bad copy, but I just couldn't make the borrow checker happy\n+            (*workspace).clone()\n+        }\n         // and if we're just building, it goes in a package-specific subdir\n         Build => workspace.push_rel(&*pkg_id.local_path)\n     };\n     debug!(\"[%?:%?] mk_output_path: short_name = %s, path = %s\", what, where,\n-           if what == Lib { copy short_name_with_version } else { copy pkg_id.short_name },\n+           if what == Lib { short_name_with_version.clone() } else { pkg_id.short_name.clone() },\n            dir.to_str());\n     let mut output_path = match what {\n         // this code is duplicated from elsewhere; fix this"}, {"sha": "f2845c00ea6f6b21ce4a17d18daa6f6e1debde45", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -104,12 +104,12 @@ impl<'self> PkgScript<'self> {\n             binary: binary,\n             maybe_sysroot: Some(@os::self_exe_path().get().pop()),\n             crate_type: session::bin_crate,\n-            .. copy *session::basic_options()\n+            .. (*session::basic_options()).clone()\n         };\n         let input = driver::file_input(script);\n         let sess = driver::build_session(options, diagnostic::emit);\n         let cfg = driver::build_configuration(sess, binary, &input);\n-        let (crate, _) = driver::compile_upto(sess, copy cfg, &input, driver::cu_parse, None);\n+        let (crate, _) = driver::compile_upto(sess, cfg.clone(), &input, driver::cu_parse, None);\n         let work_dir = build_pkg_id_in_workspace(id, workspace);\n \n         debug!(\"Returning package script with id %?\", id);\n@@ -203,7 +203,7 @@ impl CtxMethods for Ctx {\n                 }\n                 // The package id is presumed to be the first command-line\n                 // argument\n-                let pkgid = PkgId::new(copy args[0], &os::getcwd());\n+                let pkgid = PkgId::new(args[0].clone(), &os::getcwd());\n                 for each_pkg_parent_workspace(&pkgid) |workspace| {\n                     debug!(\"found pkg %s in workspace %s, trying to build\",\n                            pkgid.to_str(), workspace.to_str());\n@@ -216,7 +216,7 @@ impl CtxMethods for Ctx {\n                 }\n                 // The package id is presumed to be the first command-line\n                 // argument\n-                let pkgid = PkgId::new(copy args[0], &os::getcwd());\n+                let pkgid = PkgId::new(args[0].clone(), &os::getcwd());\n                 let cwd = os::getcwd();\n                 self.clean(&cwd, &pkgid); // tjc: should use workspace, not cwd\n             }\n@@ -225,7 +225,7 @@ impl CtxMethods for Ctx {\n                     return usage::do_cmd();\n                 }\n \n-                self.do_cmd(copy args[0], copy args[1]);\n+                self.do_cmd(args[0].clone(), args[1].clone());\n             }\n             \"info\" => {\n                 self.info();\n@@ -423,16 +423,16 @@ impl CtxMethods for Ctx {\n             debug!(\"Copying: %s -> %s\", exec.to_str(), target_exec.to_str());\n             if !(os::mkdir_recursive(&target_exec.dir_path(), U_RWX) &&\n                  os::copy_file(exec, &target_exec)) {\n-                cond.raise((copy *exec, copy target_exec));\n+                cond.raise(((*exec).clone(), target_exec.clone()));\n             }\n         }\n         for maybe_library.iter().advance |lib| {\n-            let target_lib = (copy target_lib).expect(fmt!(\"I built %s but apparently \\\n+            let target_lib = target_lib.clone().expect(fmt!(\"I built %s but apparently \\\n                                                 didn't install it!\", lib.to_str()));\n             debug!(\"Copying: %s -> %s\", lib.to_str(), target_lib.to_str());\n             if !(os::mkdir_recursive(&target_lib.dir_path(), U_RWX) &&\n                  os::copy_file(lib, &target_lib)) {\n-                cond.raise((copy *lib, copy target_lib));\n+                cond.raise(((*lib).clone(), target_lib.clone()));\n             }\n         }\n     }\n@@ -475,7 +475,7 @@ pub fn main() {\n                getopts::opt_present(matches, \"help\");\n     let json = getopts::opt_present(matches, \"j\") ||\n                getopts::opt_present(matches, \"json\");\n-    let mut args = copy matches.free;\n+    let mut args = matches.free.clone();\n \n     args.shift();\n "}, {"sha": "9d4c2f87a614dc565700c2ee9524b90649ec9028", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -44,7 +44,7 @@ fn fake_pkg() -> PkgId {\n     let sn = ~\"bogus\";\n     let remote = RemotePath(Path(sn));\n     PkgId {\n-        local_path: normalize(copy remote),\n+        local_path: normalize(remote.clone()),\n         remote_path: remote,\n         short_name: sn,\n         version: NoVersion\n@@ -54,7 +54,7 @@ fn fake_pkg() -> PkgId {\n fn git_repo_pkg() -> PkgId {\n     let remote = RemotePath(Path(\"mockgithub.com/catamorphism/test-pkg\"));\n     PkgId {\n-        local_path: normalize(copy remote),\n+        local_path: normalize(remote.clone()),\n         remote_path: remote,\n         short_name: ~\"test_pkg\",\n         version: NoVersion\n@@ -218,7 +218,7 @@ fn command_line_test(args: &[~str], cwd: &Path) -> ProcessOutput {\n fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~str)]>)\n     -> ProcessOutput {\n     let cmd = test_sysroot().push(\"bin\").push(\"rustpkg\").to_str();\n-    let cwd = normalize(RemotePath(copy *cwd));\n+    let cwd = normalize(RemotePath((*cwd).clone()));\n     debug!(\"About to run command: %? %? in %s\", cmd, args, cwd.to_str());\n     assert!(os::path_is_dir(&*cwd));\n     let cwd = cwd.clone();\n@@ -365,7 +365,7 @@ fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n         if p.filetype() == Some(~\".rs\") {\n             // should be able to do this w/o a process\n             if run::process_output(\"touch\", [p.to_str()]).status != 0 {\n-                let _ = cond.raise((copy pkg_src_dir, ~\"Bad path\"));\n+                let _ = cond.raise((pkg_src_dir.clone(), ~\"Bad path\"));\n             }\n             break;\n         }\n@@ -388,7 +388,7 @@ fn frob_source_file(workspace: &Path, pkgid: &PkgId) {\n         Some(p) => {\n             let w = io::file_writer(*p, &[io::Append]);\n             match w {\n-                Err(s) => { let _ = cond.raise((copy **p, fmt!(\"Bad path: %s\", s))); }\n+                Err(s) => { let _ = cond.raise(((**p).clone(), fmt!(\"Bad path: %s\", s))); }\n                 Ok(w)  => w.write_line(\"\")\n             }\n         }\n@@ -458,7 +458,7 @@ fn test_install_invalid() {\n     }).in {\n         do cond.trap(|_| {\n             error_occurred = true;\n-            copy temp_workspace\n+            temp_workspace.clone()\n         }).in {\n             ctxt.install(&temp_workspace, &pkgid);\n         }\n@@ -542,7 +542,7 @@ fn test_package_ids_must_be_relative_path_like() {\n     do cond.trap(|(p, e)| {\n         assert!(\"\" == p.to_str());\n         assert!(\"0-length pkgid\" == e);\n-        copy whatever\n+        whatever.clone()\n     }).in {\n         let x = PkgId::new(\"\", &os::getcwd());\n         assert_eq!(~\"foo-0.1\", x.to_str());\n@@ -551,7 +551,7 @@ fn test_package_ids_must_be_relative_path_like() {\n     do cond.trap(|(p, e)| {\n         assert_eq!(p.to_str(), os::make_absolute(&Path(\"foo/bar/quux\")).to_str());\n         assert!(\"absolute pkgid\" == e);\n-        copy whatever\n+        whatever.clone()\n     }).in {\n         let z = PkgId::new(os::make_absolute(&Path(\"foo/bar/quux\")).to_str(),\n                            &os::getcwd());"}, {"sha": "ef3546efac18fe4f5833333a1baf9c3e6571d8e6", "filename": "src/librustpkg/testsuite/pass/src/fancy-lib/pkg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -27,7 +27,7 @@ pub fn main() {\n                argument\");\n     }\n \n-    let sysroot_arg = copy args[1];\n+    let sysroot_arg = args[1].clone();\n     let sysroot = Path(sysroot_arg);\n     if !os::path_exists(&sysroot) {\n         fail!(\"Package script requires a sysroot that exists; %s doesn't\", sysroot.to_str());\n@@ -53,4 +53,4 @@ pub fn main() {\n \n     api::install_lib(@sysroot, os::getcwd(), ~\"fancy-lib\", Path(\"lib.rs\"),\n                      NoVersion);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "d2f5e00513c4cc4a5687c01726685434e8e33084", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -81,17 +81,21 @@ fn fold_mod(_ctx: @mut ReadyCtx,\n     fn strip_main(item: @ast::item) -> @ast::item {\n         @ast::item {\n             attrs: do item.attrs.iter().filter_map |attr| {\n-                if \"main\" != attr::get_attr_name(attr) {Some(*attr)} else {None}\n+                if \"main\" != attr::get_attr_name(attr) {\n+                    Some(*attr)\n+                } else {\n+                    None\n+                }\n             }.collect(),\n-            .. copy *item\n+            .. (*item).clone()\n         }\n     }\n \n     fold::noop_fold_mod(&ast::_mod {\n         items: do m.items.map |item| {\n             strip_main(*item)\n         },\n-        .. copy *m\n+        .. (*m).clone()\n     }, fold)\n }\n \n@@ -122,7 +126,7 @@ fn fold_item(ctx: @mut ReadyCtx,\n         ctx.fns.push(ListenerFn {\n             cmds: cmds,\n             span: item.span,\n-            path: /*bad*/copy ctx.path\n+            path: /*bad*/ctx.path.clone()\n         });\n     }\n \n@@ -139,7 +143,7 @@ pub fn ready_crate(sess: session::Session,\n     let ctx = @mut ReadyCtx {\n         sess: sess,\n         crate: crate,\n-        ext_cx: ExtCtxt::new(sess.parse_sess, copy sess.opts.cfg),\n+        ext_cx: ExtCtxt::new(sess.parse_sess, sess.opts.cfg.clone()),\n         path: ~[],\n         fns: ~[]\n     };\n@@ -168,7 +172,7 @@ pub fn compile_input(ctxt: &Ctx,\n     let workspace = out_dir.pop().pop();\n \n     assert!(in_file.components.len() > 1);\n-    let input = driver::file_input(copy *in_file);\n+    let input = driver::file_input((*in_file).clone());\n     debug!(\"compile_input: %s / %?\", in_file.to_str(), what);\n     // tjc: by default, use the package ID name as the link name\n     // not sure if we should support anything else\n@@ -191,17 +195,17 @@ pub fn compile_input(ctxt: &Ctx,\n                               Main => ~[]\n                           }\n                           + flags\n-                          + cfgs.flat_map(|c| { ~[~\"--cfg\", copy *c] }),\n+                          + cfgs.flat_map(|c| { ~[~\"--cfg\", (*c).clone()] }),\n                           driver::optgroups()).get();\n     let options = @session::options {\n         crate_type: crate_type,\n         optimize: if opt { session::Aggressive } else { session::No },\n         test: what == Test || what == Bench,\n         maybe_sysroot: ctxt.sysroot_opt,\n-        addl_lib_search_paths: @mut (~[copy *out_dir]),\n+        addl_lib_search_paths: @mut (~[(*out_dir).clone()]),\n         // output_type should be conditional\n         output_type: output_type_exe, // Use this to get a library? That's weird\n-        .. copy *driver::build_session_options(binary, &matches, diagnostic::emit)\n+        .. (*driver::build_session_options(binary, &matches, diagnostic::emit)).clone()\n     };\n \n     let addl_lib_search_paths = @mut options.addl_lib_search_paths;\n@@ -216,7 +220,7 @@ pub fn compile_input(ctxt: &Ctx,\n     // Infer dependencies that rustpkg needs to build, by scanning for\n     // `extern mod` directives.\n     let cfg = driver::build_configuration(sess, binary, &input);\n-    let (crate_opt, _) = driver::compile_upto(sess, copy cfg, &input, driver::cu_expand, None);\n+    let (crate_opt, _) = driver::compile_upto(sess, cfg.clone(), &input, driver::cu_expand, None);\n \n     let mut crate = match crate_opt {\n         Some(c) => c,\n@@ -238,7 +242,7 @@ pub fn compile_input(ctxt: &Ctx,\n         let short_name_to_use = match what {\n             Test  => fmt!(\"%stest\", pkg_id.short_name),\n             Bench => fmt!(\"%sbench\", pkg_id.short_name),\n-            _     => copy pkg_id.short_name\n+            _     => pkg_id.short_name.clone()\n         };\n         debug!(\"Injecting link name: %s\", short_name_to_use);\n         crate = @codemap::respan(crate.span, ast::crate_ {\n@@ -248,12 +252,12 @@ pub fn compile_input(ctxt: &Ctx,\n                                       mk_string_lit(short_name_to_use.to_managed()))),\n                    @dummy_spanned(meta_name_value(@\"vers\",\n                          mk_string_lit(pkg_id.version.to_str().to_managed())))])))],\n-            ..copy crate.node});\n+            ..crate.node.clone()});\n     }\n \n     debug!(\"calling compile_crate_from_input, out_dir = %s,\n            building_library = %?\", out_dir.to_str(), sess.building_library);\n-    compile_crate_from_input(&input, out_dir, sess, crate, copy cfg, driver::cu_expand);\n+    compile_crate_from_input(&input, out_dir, sess, crate, cfg.clone(), driver::cu_expand);\n     true\n }\n \n@@ -272,7 +276,7 @@ pub fn compile_crate_from_input(input: &driver::input,\n            build_dir.to_str(), sess.building_library);\n \n     // bad copy\n-    let outputs = driver::build_output_filenames(input, &Some(copy *build_dir), &None,\n+    let outputs = driver::build_output_filenames(input, &Some((*build_dir).clone()), &None,\n                                                  crate.node.attrs, sess);\n \n     debug!(\"Outputs are %? and output type = %?\", outputs, sess.opts.output_type);\n@@ -326,7 +330,7 @@ pub fn find_and_install_dependencies(ctxt: &Ctx,\n                                 ) {\n     // :-(\n     debug!(\"In find_and_install_dependencies...\");\n-    let my_workspace = copy *workspace;\n+    let my_workspace = (*workspace).clone();\n     let my_ctxt      = *ctxt;\n     for c.each_view_item() |vi: &ast::view_item| {\n         debug!(\"A view item!\");"}, {"sha": "9e68ba54b6dfb12e828a7b5f7ee3f91ca96c54a3", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -18,6 +18,7 @@ use std::{char, os, result, run, str};\n use package_path::RemotePath;\n use extra::tempfile::mkdtemp;\n \n+#[deriving(Clone)]\n pub enum Version {\n     ExactRevision(~str), // Should look like a m.n.(...).x\n     SemanticVersion(semver::Version),"}, {"sha": "13354e6128474bcba23783022e7bba313a4e9915", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -11,9 +11,9 @@\n //! Managed vectors\n \n use cast::transmute;\n+use clone::Clone;\n use container::Container;\n use iterator::IteratorUtil;\n-use kinds::Copy;\n use option::Option;\n use sys;\n use uint;\n@@ -90,10 +90,14 @@ pub fn build_sized_opt<A>(size: Option<uint>,\n /// Iterates over the `rhs` vector, copying each element and appending it to the\n /// `lhs`. Afterwards, the `lhs` is then returned for use again.\n #[inline]\n-pub fn append<T:Copy>(lhs: @[T], rhs: &[T]) -> @[T] {\n+pub fn append<T:Clone>(lhs: @[T], rhs: &[T]) -> @[T] {\n     do build_sized(lhs.len() + rhs.len()) |push| {\n-        for lhs.iter().advance |x| { push(copy *x); }\n-        for uint::range(0, rhs.len()) |i| { push(copy rhs[i]); }\n+        for lhs.iter().advance |x| {\n+            push((*x).clone());\n+        }\n+        for uint::range(0, rhs.len()) |i| {\n+            push(rhs[i].clone());\n+        }\n     }\n }\n \n@@ -126,10 +130,13 @@ pub fn from_fn<T>(n_elts: uint, op: &fn(uint) -> T) -> @[T] {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value `t`.\n  */\n-pub fn from_elem<T:Copy>(n_elts: uint, t: T) -> @[T] {\n+pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> @[T] {\n     do build_sized(n_elts) |push| {\n         let mut i: uint = 0u;\n-        while i < n_elts { push(copy t); i += 1u; }\n+        while i < n_elts {\n+            push(t.clone());\n+            i += 1u;\n+        }\n     }\n }\n \n@@ -152,18 +159,24 @@ pub fn to_managed_consume<T>(v: ~[T]) -> @[T] {\n  * Creates and initializes an immutable managed vector by copying all the\n  * elements of a slice.\n  */\n-pub fn to_managed<T:Copy>(v: &[T]) -> @[T] {\n-    from_fn(v.len(), |i| copy v[i])\n+pub fn to_managed<T:Clone>(v: &[T]) -> @[T] {\n+    from_fn(v.len(), |i| v[i].clone())\n+}\n+\n+impl<T> Clone for @[T] {\n+    fn clone(&self) -> @[T] {\n+        *self\n+    }\n }\n \n #[cfg(not(test))]\n pub mod traits {\n     use at_vec::append;\n-    use vec::Vector;\n-    use kinds::Copy;\n+    use clone::Clone;\n     use ops::Add;\n+    use vec::Vector;\n \n-    impl<'self,T:Copy, V: Vector<T>> Add<V,@[T]> for @[T] {\n+    impl<'self,T:Clone, V: Vector<T>> Add<V,@[T]> for @[T] {\n         #[inline]\n         fn add(&self, rhs: &V) -> @[T] {\n             append(*self, rhs.as_slice())"}, {"sha": "86eec80ae6f8b092d5e9e83b0b3405cfb7b83604", "filename": "src/libstd/cast.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcast.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -35,6 +35,14 @@ pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n     dest\n }\n \n+/**\n+ * Forces a copy of a value, even if that value is considered noncopyable.\n+ */\n+#[inline]\n+pub unsafe fn unsafe_copy<T>(thing: &T) -> T {\n+    transmute_copy(thing)\n+}\n+\n /**\n  * Move a thing into the void\n  *"}, {"sha": "80caa34ce065800b8bc864ae956febecaeb7ff5d", "filename": "src/libstd/condition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcondition.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -86,7 +86,7 @@ impl<'self, T, U> Condition<'self, T, U> {\n \n     pub fn raise(&self, t: T) -> U {\n         let msg = fmt!(\"Unhandled condition: %s: %?\", self.name, t);\n-        self.raise_default(t, || fail!(copy msg))\n+        self.raise_default(t, || fail!(msg.clone()))\n     }\n \n     pub fn raise_default(&self, t: T, default: &fn() -> U) -> U {"}, {"sha": "fcbd98a79e7967f184a70a3bec83dd15c4e46f90", "filename": "src/libstd/either.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -12,9 +12,9 @@\n \n #[allow(missing_doc)];\n \n+use clone::Clone;\n use container::Container;\n use cmp::Eq;\n-use kinds::Copy;\n use iterator::IteratorUtil;\n use result::Result;\n use result;\n@@ -43,23 +43,23 @@ pub fn either<T, U, V>(f_left: &fn(&T) -> V,\n }\n \n /// Extracts from a vector of either all the left values\n-pub fn lefts<T:Copy,U>(eithers: &[Either<T, U>]) -> ~[T] {\n+pub fn lefts<T:Clone,U>(eithers: &[Either<T, U>]) -> ~[T] {\n     do vec::build_sized(eithers.len()) |push| {\n         for eithers.iter().advance |elt| {\n             match *elt {\n-                Left(ref l) => { push(copy *l); }\n+                Left(ref l) => { push((*l).clone()); }\n                 _ => { /* fallthrough */ }\n             }\n         }\n     }\n }\n \n /// Extracts from a vector of either all the right values\n-pub fn rights<T, U: Copy>(eithers: &[Either<T, U>]) -> ~[U] {\n+pub fn rights<T, U: Clone>(eithers: &[Either<T, U>]) -> ~[U] {\n     do vec::build_sized(eithers.len()) |push| {\n         for eithers.iter().advance |elt| {\n             match *elt {\n-                Right(ref r) => { push(copy *r); }\n+                Right(ref r) => { push((*r).clone()); }\n                 _ => { /* fallthrough */ }\n             }\n         }"}, {"sha": "7cf2c594202eb1c51fbb46544b4e0d52cddfe2b5", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -25,10 +25,9 @@ use option::{None, Option, Some};\n use rand::RngUtil;\n use rand;\n use uint;\n-use vec;\n-use vec::{ImmutableVector, MutableVector, OwnedVector};\n-use kinds::Copy;\n use util::{replace, unreachable};\n+use vec::{ImmutableVector, MutableVector, OwnedVector};\n+use vec;\n \n static INITIAL_CAPACITY: uint = 32u; // 2^5\n \n@@ -525,15 +524,15 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n     }\n }\n \n-impl<K: Hash + Eq, V: Copy> HashMap<K, V> {\n+impl<K: Hash + Eq, V: Clone> HashMap<K, V> {\n     /// Like `find`, but returns a copy of the value.\n     pub fn find_copy(&self, k: &K) -> Option<V> {\n-        self.find(k).map_consume(|v| copy *v)\n+        self.find(k).map_consume(|v| (*v).clone())\n     }\n \n     /// Like `get`, but returns a copy of the value.\n     pub fn get_copy(&self, k: &K) -> V {\n-        copy *self.get(k)\n+        (*self.get(k)).clone()\n     }\n }\n \n@@ -554,6 +553,16 @@ impl<K:Hash + Eq,V:Eq> Eq for HashMap<K, V> {\n     fn ne(&self, other: &HashMap<K, V>) -> bool { !self.eq(other) }\n }\n \n+impl<K:Hash + Eq + Clone,V:Clone> Clone for HashMap<K,V> {\n+    fn clone(&self) -> HashMap<K,V> {\n+        let mut new_map = HashMap::with_capacity(self.len());\n+        for self.iter().advance |(key, value)| {\n+            new_map.insert((*key).clone(), (*value).clone());\n+        }\n+        new_map\n+    }\n+}\n+\n /// HashMap iterator\n pub struct HashMapIterator<'self, K, V> {\n     priv iter: vec::VecIterator<'self, Option<Bucket<K, V>>>,"}, {"sha": "e074eba68aef9bf07c802ad182c0510b503242c5", "filename": "src/libstd/io.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -48,6 +48,7 @@ implement `Reader` and `Writer`, where appropriate.\n \n use result::Result;\n \n+use clone::Clone;\n use container::Container;\n use int;\n use libc;\n@@ -1697,7 +1698,7 @@ pub fn with_bytes_writer(f: &fn(@Writer)) -> ~[u8] {\n     let wr = @BytesWriter::new();\n     f(wr as @Writer);\n     let @BytesWriter { bytes, _ } = wr;\n-    copy *bytes\n+    (*bytes).clone()\n }\n \n pub fn with_str_writer(f: &fn(@Writer)) -> ~str {\n@@ -1750,7 +1751,6 @@ pub fn read_whole_file(file: &Path) -> Result<~[u8], ~str> {\n \n pub mod fsync {\n     use io::{FILERes, FdRes, fd_t};\n-    use kinds::Copy;\n     use libc;\n     use ops::Drop;\n     use option::{None, Option, Some};\n@@ -1775,21 +1775,20 @@ pub mod fsync {\n         arg: Arg<t>,\n     }\n \n-    impl <t: Copy> Res<t> {\n+    impl <t> Res<t> {\n         pub fn new(arg: Arg<t>) -> Res<t> {\n             Res { arg: arg }\n         }\n     }\n \n     #[unsafe_destructor]\n-    impl<T:Copy> Drop for Res<T> {\n+    impl<T> Drop for Res<T> {\n         fn drop(&self) {\n             match self.arg.opt_level {\n                 None => (),\n                 Some(level) => {\n                   // fail hard if not succesful\n-                  assert!(((self.arg.fsync_fn)(copy self.arg.val, level)\n-                    != -1));\n+                  assert!(((self.arg.fsync_fn)(&self.arg.val, level) != -1));\n                 }\n             }\n         }\n@@ -1798,7 +1797,7 @@ pub mod fsync {\n     pub struct Arg<t> {\n         val: t,\n         opt_level: Option<Level>,\n-        fsync_fn: @fn(f: t, Level) -> int,\n+        fsync_fn: @fn(f: &t, Level) -> int,\n     }\n \n     // fsync file after executing blk\n@@ -1810,7 +1809,7 @@ pub mod fsync {\n             val: file.f, opt_level: opt_level,\n             fsync_fn: |file, l| {\n                 unsafe {\n-                    os::fsync_fd(libc::fileno(file), l) as int\n+                    os::fsync_fd(libc::fileno(*file), l) as int\n                 }\n             }\n         }));\n@@ -1821,7 +1820,7 @@ pub mod fsync {\n                        blk: &fn(v: Res<fd_t>)) {\n         blk(Res::new(Arg {\n             val: fd.fd, opt_level: opt_level,\n-            fsync_fn: |fd, l| os::fsync_fd(fd, l) as int\n+            fsync_fn: |fd, l| os::fsync_fd(*fd, l) as int\n         }));\n     }\n \n@@ -1833,7 +1832,7 @@ pub mod fsync {\n                     blk: &fn(v: Res<@FSyncable>)) {\n         blk(Res::new(Arg {\n             val: o, opt_level: opt_level,\n-            fsync_fn: |o, l| o.fsync(l)\n+            fsync_fn: |o, l| (*o).fsync(l)\n         }));\n     }\n }\n@@ -1854,7 +1853,7 @@ mod tests {\n         debug!(tmpfile);\n         let frood: ~str =\n             ~\"A hoopy frood who really knows where his towel is.\";\n-        debug!(copy frood);\n+        debug!(frood.clone());\n         {\n             let out: @io::Writer =\n                 result::get(\n@@ -1863,7 +1862,7 @@ mod tests {\n         }\n         let inp: @io::Reader = result::get(&io::file_reader(tmpfile));\n         let frood2: ~str = inp.read_c_str();\n-        debug!(copy frood2);\n+        debug!(frood2.clone());\n         assert_eq!(frood, frood2);\n     }\n "}, {"sha": "168bb7c14f0a6ed5b4802c6e645fa2064a764d40", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -135,9 +135,11 @@ pub fn modify<T: 'static>(key: Key<@T>, f: &fn(Option<@T>) -> Option<@T>) {\n  */\n #[cfg(not(stage0))]\n pub fn modify<T: 'static>(key: Key<T>, f: &fn(Option<T>) -> Option<T>) {\n-    match f(pop(key)) {\n-        Some(next) => { set(key, next); }\n-        None => {}\n+    unsafe {\n+        match f(pop(::cast::unsafe_copy(&key))) {\n+            Some(next) => { set(key, next); }\n+            None => {}\n+        }\n     }\n }\n "}, {"sha": "4661bc20403a90ec9daf19cf5840440337455ddf", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -10,6 +10,7 @@\n \n #[allow(missing_doc)];\n \n+use clone::Clone;\n use container::Container;\n use core::cmp::{Ord, Eq};\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n@@ -467,7 +468,7 @@ priv static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n  */\n pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+\n                                     Mul<T,T>+Sub<T,T>+Neg<T>+Add<T,T>+\n-                                    NumStrConv>(\n+                                    NumStrConv+Clone>(\n         buf: &[u8], radix: uint, negative: bool, fractional: bool,\n         special: bool, exponent: ExponentFormat, empty_zero: bool,\n         ignore_underscores: bool\n@@ -528,8 +529,8 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+\n \n     // Initialize accumulator with signed zero for floating point parsing to\n     // work\n-    let mut accum      = if accum_positive { copy _0 } else { -_1 * _0};\n-    let mut last_accum = copy accum; // Necessary to detect overflow\n+    let mut accum      = if accum_positive { _0.clone() } else { -_1 * _0};\n+    let mut last_accum = accum.clone(); // Necessary to detect overflow\n     let mut i          = start;\n     let mut exp_found  = false;\n \n@@ -540,7 +541,7 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+\n         match char::to_digit(c, radix) {\n             Some(digit) => {\n                 // shift accum one digit left\n-                accum = accum * copy radix_gen;\n+                accum = accum * radix_gen.clone();\n \n                 // add/subtract current digit depending on sign\n                 if accum_positive {\n@@ -555,7 +556,7 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+\n                     if accum_positive && accum <= last_accum { return None; }\n                     if !accum_positive && accum >= last_accum { return None; }\n                 }\n-                last_accum = copy accum;\n+                last_accum = accum.clone();\n             }\n             None => match c {\n                 '_' if ignore_underscores => {}\n@@ -577,7 +578,7 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+\n     // Parse fractional part of number\n     // Skip if already reached start of exponent\n     if !exp_found {\n-        let mut power = copy _1;\n+        let mut power = _1.clone();\n \n         while i < len {\n             let c = buf[i] as char;\n@@ -599,7 +600,7 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+\n                     // Detect overflow by comparing to last value\n                     if accum_positive && accum < last_accum { return None; }\n                     if !accum_positive && accum > last_accum { return None; }\n-                    last_accum = copy accum;\n+                    last_accum = accum.clone();\n                 }\n                 None => match c {\n                     '_' if ignore_underscores => {}\n@@ -625,7 +626,7 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+\n         }\n     }\n \n-    let mut multiplier = copy _1;\n+    let mut multiplier = _1.clone();\n \n     if exp_found {\n         let c = buf[i] as char;\n@@ -663,7 +664,7 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+\n  */\n #[inline]\n pub fn from_str_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+Mul<T,T>+\n-                              Sub<T,T>+Neg<T>+Add<T,T>+NumStrConv>(\n+                              Sub<T,T>+Neg<T>+Add<T,T>+NumStrConv+Clone>(\n         buf: &str, radix: uint, negative: bool, fractional: bool,\n         special: bool, exponent: ExponentFormat, empty_zero: bool,\n         ignore_underscores: bool"}, {"sha": "42d892fee9b503a7bab6d2065e3cce5a7f1eea0f", "filename": "src/libstd/option.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -41,9 +41,9 @@ let unwrapped_msg = match msg {\n \n */\n \n+use clone::Clone;\n use cmp::{Eq,Ord};\n use ops::Add;\n-use kinds::Copy;\n use util;\n use num::Zero;\n use iterator::Iterator;\n@@ -88,13 +88,13 @@ impl<T:Ord> Ord for Option<T> {\n     }\n }\n \n-impl<T: Copy+Add<T,T>> Add<Option<T>, Option<T>> for Option<T> {\n+impl<T:Clone+Add<T,T>> Add<Option<T>, Option<T>> for Option<T> {\n     #[inline]\n     fn add(&self, other: &Option<T>) -> Option<T> {\n         match (&*self, &*other) {\n             (&None, &None) => None,\n-            (_, &None) => copy *self,\n-            (&None, _) => copy *other,\n+            (_, &None) => (*self).clone(),\n+            (&None, _) => (*other).clone(),\n             (&Some(ref lhs), &Some(ref rhs)) => Some(*lhs + *rhs)\n         }\n     }\n@@ -313,9 +313,7 @@ impl<T> Option<T> {\n           None => fail!(reason.to_owned()),\n         }\n     }\n-}\n \n-impl<T:Copy> Option<T> {\n     /**\n     Gets the value out of an option\n \n@@ -354,7 +352,7 @@ impl<T:Copy> Option<T> {\n     }\n }\n \n-impl<T:Copy + Zero> Option<T> {\n+impl<T:Zero> Option<T> {\n     /// Returns the contained value or zero (for this type)\n     #[inline]\n     pub fn get_or_zero(self) -> T {"}, {"sha": "c54cf3910bd0053dbdf503093e9ae578654aa543", "filename": "src/libstd/os.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -29,6 +29,7 @@\n #[allow(missing_doc)];\n \n use cast;\n+use clone::Clone;\n use container::Container;\n use io;\n use iterator::IteratorUtil;\n@@ -630,7 +631,7 @@ pub fn path_exists(p: &Path) -> bool {\n // the input paths.\n pub fn make_absolute(p: &Path) -> Path {\n     if p.is_absolute {\n-        copy *p\n+        (*p).clone()\n     } else {\n         getcwd().push_many(p.components)\n     }\n@@ -1252,15 +1253,17 @@ static overridden_arg_key: local_data::Key<@OverriddenArgs> = &local_data::Key;\n pub fn args() -> ~[~str] {\n     match local_data::get(overridden_arg_key, |k| k.map(|&k| *k)) {\n         None => real_args(),\n-        Some(args) => copy args.val\n+        Some(args) => args.val.clone()\n     }\n }\n \n /// For the current task, overrides the task-local cache of the arguments this\n /// program had when it started. These new arguments are only available to the\n /// current task via the `os::args` method.\n pub fn set_args(new_args: ~[~str]) {\n-    let overridden_args = @OverriddenArgs { val: copy new_args };\n+    let overridden_args = @OverriddenArgs {\n+        val: new_args.clone()\n+    };\n     local_data::set(overridden_arg_key, overridden_args);\n }\n \n@@ -1807,7 +1810,7 @@ mod tests {\n         }\n         let n = make_rand_name();\n         setenv(n, s);\n-        debug!(copy s);\n+        debug!(s.clone());\n         assert_eq!(getenv(n), option::Some(s));\n     }\n \n@@ -1816,7 +1819,7 @@ mod tests {\n         let path = os::self_exe_path();\n         assert!(path.is_some());\n         let path = path.get();\n-        debug!(copy path);\n+        debug!(path.clone());\n \n         // Hard to test this function\n         assert!(path.is_absolute);\n@@ -1828,8 +1831,8 @@ mod tests {\n         let e = env();\n         assert!(e.len() > 0u);\n         for e.iter().advance |p| {\n-            let (n, v) = copy *p;\n-            debug!(copy n);\n+            let (n, v) = (*p).clone();\n+            debug!(n.clone());\n             let v2 = getenv(n);\n             // MingW seems to set some funky environment variables like\n             // \"=C:=C:\\MinGW\\msys\\1.0\\bin\" and \"!::=::\\\" that are returned\n@@ -1844,7 +1847,7 @@ mod tests {\n \n         let mut e = env();\n         setenv(n, \"VALUE\");\n-        assert!(!e.contains(&(copy n, ~\"VALUE\")));\n+        assert!(!e.contains(&(n.clone(), ~\"VALUE\")));\n \n         e = env();\n         assert!(e.contains(&(n, ~\"VALUE\")));\n@@ -1920,7 +1923,7 @@ mod tests {\n         assert!(dirs.len() > 0u);\n \n         for dirs.iter().advance |dir| {\n-            debug!(copy *dir);\n+            debug!((*dir).clone());\n         }\n     }\n "}, {"sha": "fe298931d423627af5e970db074c85d5ad3cb8dd", "filename": "src/libstd/path.rs", "status": "modified", "additions": 41, "deletions": 37, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -16,6 +16,7 @@ Cross-platform file path handling\n \n #[allow(missing_doc)];\n \n+use clone::Clone;\n use container::Container;\n use cmp::Eq;\n use iterator::IteratorUtil;\n@@ -553,7 +554,7 @@ impl GenericPath for PosixPath {\n     fn filename(&self) -> Option<~str> {\n         match self.components.len() {\n             0 => None,\n-            n => Some(copy self.components[n - 1]),\n+            n => Some(self.components[n - 1].clone()),\n         }\n     }\n \n@@ -563,7 +564,7 @@ impl GenericPath for PosixPath {\n             Some(ref f) => {\n                 match f.rfind('.') {\n                     Some(p) => Some(f.slice_to(p).to_owned()),\n-                    None => Some(copy *f),\n+                    None => Some((*f).clone()),\n                 }\n             }\n         }\n@@ -603,7 +604,7 @@ impl GenericPath for PosixPath {\n \n     fn with_filetype(&self, t: &str) -> PosixPath {\n         match (t.len(), self.filestem()) {\n-            (0, None)        => copy *self,\n+            (0, None)        => (*self).clone(),\n             (0, Some(ref s)) => self.with_filename(*s),\n             (_, None)        => self.with_filename(fmt!(\".%s\", t)),\n             (_, Some(ref s)) => self.with_filename(fmt!(\"%s.%s\", *s, t)),\n@@ -612,15 +613,15 @@ impl GenericPath for PosixPath {\n \n     fn dir_path(&self) -> PosixPath {\n         match self.components.len() {\n-            0 => copy *self,\n+            0 => (*self).clone(),\n             _ => self.pop(),\n         }\n     }\n \n     fn file_path(&self) -> PosixPath {\n         let cs = match self.filename() {\n           None => ~[],\n-          Some(ref f) => ~[copy *f]\n+          Some(ref f) => ~[(*f).clone()]\n         };\n         PosixPath {\n             is_absolute: false,\n@@ -637,7 +638,7 @@ impl GenericPath for PosixPath {\n         if other.is_absolute {\n             PosixPath {\n                 is_absolute: true,\n-                components: copy other.components,\n+                components: other.components.clone(),\n             }\n         } else {\n             self.push_rel(other)\n@@ -649,7 +650,7 @@ impl GenericPath for PosixPath {\n     }\n \n     fn push_many<S: Str>(&self, cs: &[S]) -> PosixPath {\n-        let mut v = copy self.components;\n+        let mut v = self.components.clone();\n         for cs.iter().advance |e| {\n             for e.as_slice().split_iter(windows::is_sep).advance |s| {\n                 if !s.is_empty() {\n@@ -664,17 +665,20 @@ impl GenericPath for PosixPath {\n     }\n \n     fn push(&self, s: &str) -> PosixPath {\n-        let mut v = copy self.components;\n+        let mut v = self.components.clone();\n         for s.split_iter(windows::is_sep).advance |s| {\n             if !s.is_empty() {\n                 v.push(s.to_owned())\n             }\n         }\n-        PosixPath { components: v, ..copy *self }\n+        PosixPath {\n+            components: v,\n+            ..(*self).clone()\n+        }\n     }\n \n     fn pop(&self) -> PosixPath {\n-        let mut cs = copy self.components;\n+        let mut cs = self.components.clone();\n         if cs.len() != 0 {\n             cs.pop();\n         }\n@@ -734,13 +738,13 @@ impl GenericPath for WindowsPath {\n         ) {\n             (Some((ref d, ref r)), _) => {\n                 host = None;\n-                device = Some(copy *d);\n-                rest = copy *r;\n+                device = Some((*d).clone());\n+                rest = (*r).clone();\n             }\n             (None, Some((ref h, ref r))) => {\n-                host = Some(copy *h);\n+                host = Some((*h).clone());\n                 device = None;\n-                rest = copy *r;\n+                rest = (*r).clone();\n             }\n             (None, None) => {\n                 host = None;\n@@ -773,7 +777,7 @@ impl GenericPath for WindowsPath {\n     fn filename(&self) -> Option<~str> {\n         match self.components.len() {\n             0 => None,\n-            n => Some(copy self.components[n - 1]),\n+            n => Some(self.components[n - 1].clone()),\n         }\n     }\n \n@@ -783,7 +787,7 @@ impl GenericPath for WindowsPath {\n             Some(ref f) => {\n                 match f.rfind('.') {\n                     Some(p) => Some(f.slice_to(p).to_owned()),\n-                    None => Some(copy *f),\n+                    None => Some((*f).clone()),\n                 }\n             }\n         }\n@@ -823,7 +827,7 @@ impl GenericPath for WindowsPath {\n \n     fn with_filetype(&self, t: &str) -> WindowsPath {\n         match (t.len(), self.filestem()) {\n-            (0, None)        => copy *self,\n+            (0, None)        => (*self).clone(),\n             (0, Some(ref s)) => self.with_filename(*s),\n             (_, None)        => self.with_filename(fmt!(\".%s\", t)),\n             (_, Some(ref s)) => self.with_filename(fmt!(\"%s.%s\", *s, t)),\n@@ -832,7 +836,7 @@ impl GenericPath for WindowsPath {\n \n     fn dir_path(&self) -> WindowsPath {\n         match self.components.len() {\n-            0 => copy *self,\n+            0 => (*self).clone(),\n             _ => self.pop(),\n         }\n     }\n@@ -844,7 +848,7 @@ impl GenericPath for WindowsPath {\n             is_absolute: false,\n             components: match self.filename() {\n                 None => ~[],\n-                Some(ref f) => ~[copy *f],\n+                Some(ref f) => ~[(*f).clone()],\n             }\n         }\n     }\n@@ -864,10 +868,10 @@ impl GenericPath for WindowsPath {\n         match other.host {\n             Some(ref host) => {\n                 return WindowsPath {\n-                    host: Some(copy *host),\n-                    device: copy other.device,\n+                    host: Some((*host).clone()),\n+                    device: other.device.clone(),\n                     is_absolute: true,\n-                    components: copy other.components,\n+                    components: other.components.clone(),\n                 };\n             }\n             _ => {}\n@@ -878,9 +882,9 @@ impl GenericPath for WindowsPath {\n             Some(ref device) => {\n                 return WindowsPath {\n                     host: None,\n-                    device: Some(copy *device),\n+                    device: Some((*device).clone()),\n                     is_absolute: true,\n-                    components: copy other.components,\n+                    components: other.components.clone(),\n                 };\n             }\n             _ => {}\n@@ -889,10 +893,10 @@ impl GenericPath for WindowsPath {\n         /* fallback: host and device of lhs win, but the\n            whole path of the right */\n         WindowsPath {\n-            host: copy self.host,\n-            device: copy self.device,\n+            host: self.host.clone(),\n+            device: self.device.clone(),\n             is_absolute: self.is_absolute || other.is_absolute,\n-            components: copy other.components,\n+            components: other.components.clone(),\n         }\n     }\n \n@@ -912,7 +916,7 @@ impl GenericPath for WindowsPath {\n     }\n \n     fn push_many<S: Str>(&self, cs: &[S]) -> WindowsPath {\n-        let mut v = copy self.components;\n+        let mut v = self.components.clone();\n         for cs.iter().advance |e| {\n             for e.as_slice().split_iter(windows::is_sep).advance |s| {\n                 if !s.is_empty() {\n@@ -922,39 +926,39 @@ impl GenericPath for WindowsPath {\n         }\n         // tedious, but as-is, we can't use ..self\n         WindowsPath {\n-            host: copy self.host,\n-            device: copy self.device,\n+            host: self.host.clone(),\n+            device: self.device.clone(),\n             is_absolute: self.is_absolute,\n             components: v\n         }\n     }\n \n     fn push(&self, s: &str) -> WindowsPath {\n-        let mut v = copy self.components;\n+        let mut v = self.components.clone();\n         for s.split_iter(windows::is_sep).advance |s| {\n             if !s.is_empty() {\n                 v.push(s.to_owned())\n             }\n         }\n-        WindowsPath { components: v, ..copy *self }\n+        WindowsPath { components: v, ..(*self).clone() }\n     }\n \n     fn pop(&self) -> WindowsPath {\n-        let mut cs = copy self.components;\n+        let mut cs = self.components.clone();\n         if cs.len() != 0 {\n             cs.pop();\n         }\n         WindowsPath {\n-            host: copy self.host,\n-            device: copy self.device,\n+            host: self.host.clone(),\n+            device: self.device.clone(),\n             is_absolute: self.is_absolute,\n             components: cs,\n         }\n     }\n \n     fn normalize(&self) -> WindowsPath {\n         WindowsPath {\n-            host: copy self.host,\n+            host: self.host.clone(),\n             device: match self.device {\n                 None => None,\n \n@@ -982,7 +986,7 @@ pub fn normalize(components: &[~str]) -> ~[~str] {\n             cs.pop();\n             loop;\n         }\n-        cs.push(copy *c);\n+        cs.push((*c).clone());\n     }\n     cs\n }"}, {"sha": "caf15120bd710c4c8601dcfde04c9e0813b158a6", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -11,6 +11,7 @@\n //! Unsafe pointer utility functions\n \n use cast;\n+use clone::Clone;\n use option::{Option, Some, None};\n use sys;\n use unstable::intrinsics;\n@@ -45,6 +46,12 @@ pub unsafe fn buf_len<T>(buf: **T) -> uint {\n     position(buf, |i| *i == null())\n }\n \n+impl<T> Clone for *T {\n+    fn clone(&self) -> *T {\n+        *self\n+    }\n+}\n+\n /// Return the first offset `i` such that `f(buf[i]) == true`.\n #[inline]\n pub unsafe fn position<T>(buf: *T, f: &fn(&T) -> bool) -> uint {\n@@ -617,7 +624,7 @@ pub mod ptr_tests {\n             array_each_with_len(arr_ptr, arr.len(),\n                                 |e| {\n                                          let actual = str::raw::from_c_str(e);\n-                                         let expected = copy expected_arr[ctr];\n+                                         let expected = expected_arr[ctr].clone();\n                                          debug!(\n                                              \"test_ptr_array_each e: %s, a: %s\",\n                                              expected, actual);\n@@ -649,7 +656,7 @@ pub mod ptr_tests {\n             let mut iteration_count = 0;\n             array_each(arr_ptr, |e| {\n                 let actual = str::raw::from_c_str(e);\n-                let expected = copy expected_arr[ctr];\n+                let expected = expected_arr[ctr].clone();\n                 debug!(\n                     \"test_ptr_array_each e: %s, a: %s\",\n                     expected, actual);"}, {"sha": "7d65ba63ff0cefdd03371d08bc83769121545b36", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -44,6 +44,7 @@ fn main () {\n */\n \n use cast;\n+use clone::Clone;\n use cmp;\n use container::Container;\n use int;\n@@ -355,9 +356,9 @@ pub trait RngUtil {\n      * }\n      * ~~~\n      */\n-    fn choose<T:Copy>(&mut self, values: &[T]) -> T;\n+    fn choose<T:Copy + Clone>(&mut self, values: &[T]) -> T;\n     /// Choose Some(item) randomly, returning None if values is empty\n-    fn choose_option<T:Copy>(&mut self, values: &[T]) -> Option<T>;\n+    fn choose_option<T:Clone>(&mut self, values: &[T]) -> Option<T>;\n     /**\n      * Choose an item respecting the relative weights, failing if the sum of\n      * the weights is 0\n@@ -378,7 +379,7 @@ pub trait RngUtil {\n      * }\n      * ~~~\n      */\n-    fn choose_weighted<T:Copy>(&mut self, v : &[Weighted<T>]) -> T;\n+    fn choose_weighted<T:Copy + Clone>(&mut self, v : &[Weighted<T>]) -> T;\n     /**\n      * Choose Some(item) respecting the relative weights, returning none if\n      * the sum of the weights is 0\n@@ -399,7 +400,7 @@ pub trait RngUtil {\n      * }\n      * ~~~\n      */\n-    fn choose_weighted_option<T:Copy>(&mut self, v: &[Weighted<T>])\n+    fn choose_weighted_option<T:Clone>(&mut self, v: &[Weighted<T>])\n                                      -> Option<T>;\n     /**\n      * Return a vec containing copies of the items, in order, where\n@@ -421,7 +422,7 @@ pub trait RngUtil {\n      * }\n      * ~~~\n      */\n-    fn weighted_vec<T:Copy>(&mut self, v: &[Weighted<T>]) -> ~[T];\n+    fn weighted_vec<T:Clone>(&mut self, v: &[Weighted<T>]) -> ~[T];\n     /**\n      * Shuffle a vec\n      *\n@@ -438,7 +439,7 @@ pub trait RngUtil {\n      * }\n      * ~~~\n      */\n-    fn shuffle<T:Copy>(&mut self, values: &[T]) -> ~[T];\n+    fn shuffle<T:Copy + Clone>(&mut self, values: &[T]) -> ~[T];\n     /**\n      * Shuffle a mutable vec in place\n      *\n@@ -531,32 +532,32 @@ impl<R: Rng> RngUtil for R {\n     }\n \n     /// Choose an item randomly, failing if values is empty\n-    fn choose<T:Copy>(&mut self, values: &[T]) -> T {\n+    fn choose<T:Copy + Clone>(&mut self, values: &[T]) -> T {\n         self.choose_option(values).get()\n     }\n \n     /// Choose Some(item) randomly, returning None if values is empty\n-    fn choose_option<T:Copy>(&mut self, values: &[T]) -> Option<T> {\n+    fn choose_option<T:Clone>(&mut self, values: &[T]) -> Option<T> {\n         if values.is_empty() {\n             None\n         } else {\n-            Some(copy values[self.gen_uint_range(0u, values.len())])\n+            Some(values[self.gen_uint_range(0u, values.len())].clone())\n         }\n     }\n     /**\n      * Choose an item respecting the relative weights, failing if the sum of\n      * the weights is 0\n      */\n-    fn choose_weighted<T:Copy>(&mut self, v: &[Weighted<T>]) -> T {\n+    fn choose_weighted<T:Copy + Clone>(&mut self, v: &[Weighted<T>]) -> T {\n         self.choose_weighted_option(v).get()\n     }\n \n     /**\n      * Choose Some(item) respecting the relative weights, returning none if\n      * the sum of the weights is 0\n      */\n-    fn choose_weighted_option<T:Copy>(&mut self, v: &[Weighted<T>])\n-                                     -> Option<T> {\n+    fn choose_weighted_option<T:Clone>(&mut self, v: &[Weighted<T>])\n+                                       -> Option<T> {\n         let mut total = 0u;\n         for v.iter().advance |item| {\n             total += item.weight;\n@@ -569,7 +570,7 @@ impl<R: Rng> RngUtil for R {\n         for v.iter().advance |item| {\n             so_far += item.weight;\n             if so_far > chosen {\n-                return Some(copy item.item);\n+                return Some(item.item.clone());\n             }\n         }\n         util::unreachable();\n@@ -579,18 +580,18 @@ impl<R: Rng> RngUtil for R {\n      * Return a vec containing copies of the items, in order, where\n      * the weight of the item determines how many copies there are\n      */\n-    fn weighted_vec<T:Copy>(&mut self, v: &[Weighted<T>]) -> ~[T] {\n+    fn weighted_vec<T:Clone>(&mut self, v: &[Weighted<T>]) -> ~[T] {\n         let mut r = ~[];\n         for v.iter().advance |item| {\n             for uint::range(0u, item.weight) |_i| {\n-                r.push(copy item.item);\n+                r.push(item.item.clone());\n             }\n         }\n         r\n     }\n \n     /// Shuffle a vec\n-    fn shuffle<T:Copy>(&mut self, values: &[T]) -> ~[T] {\n+    fn shuffle<T:Copy + Clone>(&mut self, values: &[T]) -> ~[T] {\n         let mut m = values.to_owned();\n         self.shuffle_mut(m);\n         m"}, {"sha": "4fdcf9bb0b3fea1c4484782c0c94b0cabc025a8b", "filename": "src/libstd/result.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -12,10 +12,10 @@\n \n #[allow(missing_doc)];\n \n+use clone::Clone;\n use cmp::Eq;\n use either;\n use either::Either;\n-use kinds::Copy;\n use iterator::IteratorUtil;\n use option::{None, Option, Some};\n use vec;\n@@ -39,9 +39,9 @@ pub enum Result<T, U> {\n  * If the result is an error\n  */\n #[inline]\n-pub fn get<T:Copy,U>(res: &Result<T, U>) -> T {\n+pub fn get<T:Clone,U>(res: &Result<T, U>) -> T {\n     match *res {\n-      Ok(ref t) => copy *t,\n+      Ok(ref t) => (*t).clone(),\n       Err(ref the_err) =>\n         fail!(\"get called on error result: %?\", *the_err)\n     }\n@@ -71,9 +71,9 @@ pub fn get_ref<'a, T, U>(res: &'a Result<T, U>) -> &'a T {\n  * If the result is not an error\n  */\n #[inline]\n-pub fn get_err<T, U: Copy>(res: &Result<T, U>) -> U {\n+pub fn get_err<T, U: Clone>(res: &Result<T, U>) -> U {\n     match *res {\n-      Err(ref u) => copy *u,\n+      Err(ref u) => (*u).clone(),\n       Ok(_) => fail!(\"get_err called on ok result\")\n     }\n }\n@@ -100,11 +100,11 @@ pub fn is_err<T, U>(res: &Result<T, U>) -> bool {\n  * result variants are converted to `either::left`.\n  */\n #[inline]\n-pub fn to_either<T:Copy,U:Copy>(res: &Result<U, T>)\n+pub fn to_either<T:Clone,U:Clone>(res: &Result<U, T>)\n     -> Either<T, U> {\n     match *res {\n-      Ok(ref res) => either::Right(copy *res),\n-      Err(ref fail_) => either::Left(copy *fail_)\n+      Ok(ref res) => either::Right((*res).clone()),\n+      Err(ref fail_) => either::Left((*fail_).clone())\n     }\n }\n \n@@ -203,11 +203,11 @@ pub fn iter_err<T, E>(res: &Result<T, E>, f: &fn(&E)) {\n  *     }\n  */\n #[inline]\n-pub fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: &fn(&T) -> U)\n+pub fn map<T, E: Clone, U: Clone>(res: &Result<T, E>, op: &fn(&T) -> U)\n   -> Result<U, E> {\n     match *res {\n       Ok(ref t) => Ok(op(t)),\n-      Err(ref e) => Err(copy *e)\n+      Err(ref e) => Err((*e).clone())\n     }\n }\n \n@@ -220,10 +220,10 @@ pub fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: &fn(&T) -> U)\n  * successful result while handling an error.\n  */\n #[inline]\n-pub fn map_err<T:Copy,E,F:Copy>(res: &Result<T, E>, op: &fn(&E) -> F)\n+pub fn map_err<T:Clone,E,F:Clone>(res: &Result<T, E>, op: &fn(&E) -> F)\n   -> Result<T, F> {\n     match *res {\n-      Ok(ref t) => Ok(copy *t),\n+      Ok(ref t) => Ok((*t).clone()),\n       Err(ref e) => Err(op(e))\n     }\n }\n@@ -261,22 +261,22 @@ impl<T, E> Result<T, E> {\n     }\n }\n \n-impl<T:Copy,E> Result<T, E> {\n+impl<T:Clone,E> Result<T, E> {\n     #[inline]\n     pub fn get(&self) -> T { get(self) }\n \n     #[inline]\n-    pub fn map_err<F:Copy>(&self, op: &fn(&E) -> F) -> Result<T,F> {\n+    pub fn map_err<F:Clone>(&self, op: &fn(&E) -> F) -> Result<T,F> {\n         map_err(self, op)\n     }\n }\n \n-impl<T, E: Copy> Result<T, E> {\n+impl<T, E:Clone> Result<T, E> {\n     #[inline]\n     pub fn get_err(&self) -> E { get_err(self) }\n \n     #[inline]\n-    pub fn map<U:Copy>(&self, op: &fn(&T) -> U) -> Result<U,E> {\n+    pub fn map<U:Clone>(&self, op: &fn(&T) -> U) -> Result<U,E> {\n         map(self, op)\n     }\n }\n@@ -299,9 +299,8 @@ impl<T, E: Copy> Result<T, E> {\n  *     }\n  */\n #[inline]\n-pub fn map_vec<T,U:Copy,V:Copy>(\n-    ts: &[T], op: &fn(&T) -> Result<V,U>) -> Result<~[V],U> {\n-\n+pub fn map_vec<T,U,V>(ts: &[T], op: &fn(&T) -> Result<V,U>)\n+                      -> Result<~[V],U> {\n     let mut vs: ~[V] = vec::with_capacity(ts.len());\n     for ts.iter().advance |t| {\n         match op(t) {\n@@ -314,15 +313,18 @@ pub fn map_vec<T,U:Copy,V:Copy>(\n \n #[inline]\n #[allow(missing_doc)]\n-pub fn map_opt<T,U:Copy,V:Copy>(\n-    o_t: &Option<T>, op: &fn(&T) -> Result<V,U>) -> Result<Option<V>,U> {\n-\n+pub fn map_opt<T,\n+               U,\n+               V>(\n+               o_t: &Option<T>,\n+               op: &fn(&T) -> Result<V,U>)\n+               -> Result<Option<V>,U> {\n     match *o_t {\n-      None => Ok(None),\n-      Some(ref t) => match op(t) {\n-        Ok(v) => Ok(Some(v)),\n-        Err(e) => Err(e)\n-      }\n+        None => Ok(None),\n+        Some(ref t) => match op(t) {\n+            Ok(v) => Ok(Some(v)),\n+            Err(e) => Err(e)\n+        }\n     }\n }\n \n@@ -336,7 +338,7 @@ pub fn map_opt<T,U:Copy,V:Copy>(\n  * to accommodate an error like the vectors being of different lengths.\n  */\n #[inline]\n-pub fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n+pub fn map_vec2<S,T,U,V>(ss: &[S], ts: &[T],\n                 op: &fn(&S,&T) -> Result<V,U>) -> Result<~[V],U> {\n \n     assert!(vec::same_length(ss, ts));\n@@ -359,7 +361,7 @@ pub fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n  * on its own as no result vector is built.\n  */\n #[inline]\n-pub fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n+pub fn iter_vec2<S,T,U>(ss: &[S], ts: &[T],\n                          op: &fn(&S,&T) -> Result<(),U>) -> Result<(),U> {\n \n     assert!(vec::same_length(ss, ts));"}, {"sha": "924db1a21b729774ad1d9ba06db52be254555961", "filename": "src/libstd/rt/join_latch.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Frt%2Fjoin_latch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Frt%2Fjoin_latch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fjoin_latch.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -583,29 +583,31 @@ mod test {\n         }\n     }\n \n+    #[deriving(Clone)]\n+    struct Order {\n+        immediate: bool,\n+        succeed: bool,\n+        orders: ~[Order]\n+    }\n+\n     #[test]\n     fn whateverman() {\n-        struct Order {\n-            immediate: bool,\n-            succeed: bool,\n-            orders: ~[Order]\n-        }\n         fn next(latch: &mut JoinLatch, orders: ~[Order]) {\n             for orders.iter().advance |order| {\n-                let suborders = copy order.orders;\n+                let suborders = order.orders.clone();\n                 let child_latch = Cell::new(latch.new_child());\n                 let succeed = order.succeed;\n                 if order.immediate {\n                     do spawntask_immediately {\n                         let mut child_latch = child_latch.take();\n-                        next(&mut *child_latch, copy suborders);\n+                        next(&mut *child_latch, suborders.clone());\n                         rtdebug!(\"immediate releasing\");\n                         child_latch.release(succeed);\n                     }\n                 } else {\n                     do spawntask_later {\n                         let mut child_latch = child_latch.take();\n-                        next(&mut *child_latch, copy suborders);\n+                        next(&mut *child_latch, suborders.clone());\n                         rtdebug!(\"later releasing\");\n                         child_latch.release(succeed);\n                     }"}, {"sha": "d2c308c07eaf80e1ebc41582dec594957366ae2a", "filename": "src/libstd/run.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -13,6 +13,7 @@\n #[allow(missing_doc)];\n \n use cast;\n+use clone::Clone;\n use comm::{stream, SharedChan, GenericChan, GenericPort};\n use io;\n use iterator::IteratorUtil;\n@@ -698,7 +699,7 @@ fn with_argv<T>(prog: &str, args: &[~str],\n     let mut argptrs = ~[str::as_c_str(prog, |b| b)];\n     let mut tmps = ~[];\n     for args.iter().advance |arg| {\n-        let t = @copy *arg;\n+        let t = @(*arg).clone();\n         tmps.push(t);\n         argptrs.push(str::as_c_str(*t, |b| b));\n     }"}, {"sha": "0811dab407ef5d2a2b47452cb60430e657464033", "filename": "src/libstd/str.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -2260,6 +2260,13 @@ impl Clone for ~str {\n     }\n }\n \n+impl Clone for @str {\n+    #[inline]\n+    fn clone(&self) -> @str {\n+        *self\n+    }\n+}\n+\n /// External iterator for a string's characters. Use with the `std::iterator`\n /// module.\n pub struct StrCharIterator<'self> {\n@@ -3210,7 +3217,7 @@ mod tests {\n                 0x000a_u16 ]) ];\n \n         for pairs.iter().advance |p| {\n-            let (s, u) = copy *p;\n+            let (s, u) = (*p).clone();\n             assert!(s.to_utf16() == u);\n             assert!(from_utf16(u) == s);\n             assert!(from_utf16(s.to_utf16()) == s);"}, {"sha": "841be4df6e296ae4de3cb90c07e7417d21278ae8", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -12,14 +12,15 @@\n \n #[allow(missing_doc)];\n \n+use clone::Clone;\n use kinds::Copy;\n use vec;\n use vec::ImmutableVector;\n use iterator::IteratorUtil;\n \n pub use self::inner::*;\n \n-/// Method extensions to pairs where both types satisfy the `Copy` bound\n+/// Method extensions to pairs where both types satisfy the `Clone` bound\n pub trait CopyableTuple<T, U> {\n     /// Return the first element of self\n     fn first(&self) -> T;\n@@ -29,34 +30,34 @@ pub trait CopyableTuple<T, U> {\n     fn swap(&self) -> (U, T);\n }\n \n-impl<T:Copy,U:Copy> CopyableTuple<T, U> for (T, U) {\n+impl<T:Clone,U:Clone> CopyableTuple<T, U> for (T, U) {\n     /// Return the first element of self\n     #[inline]\n     fn first(&self) -> T {\n         match *self {\n-            (ref t, _) => copy *t,\n+            (ref t, _) => (*t).clone(),\n         }\n     }\n \n     /// Return the second element of self\n     #[inline]\n     fn second(&self) -> U {\n         match *self {\n-            (_, ref u) => copy *u,\n+            (_, ref u) => (*u).clone(),\n         }\n     }\n \n     /// Return the results of swapping the two elements of self\n     #[inline]\n     fn swap(&self) -> (U, T) {\n-        match copy *self {\n+        match (*self).clone() {\n             (t, u) => (u, t),\n         }\n     }\n }\n \n /// Method extensions for pairs where the types don't necessarily satisfy the\n-/// `Copy` bound\n+/// `Clone` bound\n pub trait ImmutableTuple<T, U> {\n     /// Return a reference to the first element of self\n     fn first_ref<'a>(&'a self) -> &'a T;\n@@ -84,7 +85,11 @@ pub trait ExtendedTupleOps<A,B> {\n     fn map<C>(&self, f: &fn(a: &A, b: &B) -> C) -> ~[C];\n }\n \n-impl<'self,A:Copy,B:Copy> ExtendedTupleOps<A,B> for (&'self [A], &'self [B]) {\n+impl<'self,\n+     A:Copy + Clone,\n+     B:Copy + Clone>\n+     ExtendedTupleOps<A,B> for\n+     (&'self [A], &'self [B]) {\n     #[inline]\n     fn zip(&self) -> ~[(A, B)] {\n         match *self {\n@@ -104,7 +109,10 @@ impl<'self,A:Copy,B:Copy> ExtendedTupleOps<A,B> for (&'self [A], &'self [B]) {\n     }\n }\n \n-impl<A:Copy,B:Copy> ExtendedTupleOps<A,B> for (~[A], ~[B]) {\n+impl<A:Copy + Clone,\n+     B:Copy + Clone>\n+     ExtendedTupleOps<A,B> for\n+     (~[A], ~[B]) {\n     #[inline]\n     fn zip(&self) -> ~[(A, B)] {\n         match *self {"}, {"sha": "8e7efeb532a74e96c280c053f3bc93060ce0e5e1", "filename": "src/libstd/util.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Futil.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -127,6 +127,8 @@ pub fn unreachable() -> ! {\n #[cfg(test)]\n mod tests {\n     use super::*;\n+\n+    use clone::Clone;\n     use option::{None, Some};\n     use either::{Either, Left, Right};\n     use sys::size_of;\n@@ -136,8 +138,8 @@ mod tests {\n     fn identity_crisis() {\n         // Writing a test for the identity function. How did it come to this?\n         let x = ~[(5, false)];\n-        //FIXME #3387 assert!(x.eq(id(copy x)));\n-        let y = copy x;\n+        //FIXME #3387 assert!(x.eq(id(x.clone())));\n+        let y = x.clone();\n         assert!(x.eq(&id(y)));\n     }\n "}, {"sha": "c9c5217ca6132022536c5fc7b924bd3c9de70bc8", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -14,12 +14,11 @@\n \n use cast::transmute;\n use cast;\n+use clone::Clone;\n use container::{Container, Mutable};\n-use cmp;\n use cmp::{Eq, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n-use clone::Clone;\n+use cmp;\n use iterator::*;\n-use kinds::Copy;\n use libc::c_void;\n use num::Zero;\n use option::{None, Option, Some};\n@@ -72,7 +71,7 @@ pub fn from_fn<T>(n_elts: uint, op: &fn(uint) -> T) -> ~[T] {\n  * Creates an owned vector of size `n_elts` and initializes the elements\n  * to the value `t`.\n  */\n-pub fn from_elem<T:Copy>(n_elts: uint, t: T) -> ~[T] {\n+pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> ~[T] {\n     // FIXME (#7136): manually inline from_fn for 2x plus speedup (sadly very\n     // important, from_elem is a bottleneck in borrowck!). Unfortunately it\n     // still is substantially slower than using the unsafe\n@@ -82,7 +81,7 @@ pub fn from_elem<T:Copy>(n_elts: uint, t: T) -> ~[T] {\n         do v.as_mut_buf |p, _len| {\n             let mut i = 0u;\n             while i < n_elts {\n-                intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i)), copy t);\n+                intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i)), t.clone());\n                 i += 1u;\n             }\n         }\n@@ -241,7 +240,7 @@ impl<'self, T> Iterator<&'self [T]> for VecRSplitIterator<'self, T> {\n /// Iterates over the `rhs` vector, copying each element and appending it to the\n /// `lhs`. Afterwards, the `lhs` is then returned for use again.\n #[inline]\n-pub fn append<T:Copy>(lhs: ~[T], rhs: &[T]) -> ~[T] {\n+pub fn append<T:Clone>(lhs: ~[T], rhs: &[T]) -> ~[T] {\n     let mut v = lhs;\n     v.push_all(rhs);\n     v\n@@ -269,16 +268,16 @@ pub fn flat_map<T, U>(v: &[T], f: &fn(t: &T) -> ~[U]) -> ~[U] {\n }\n \n /// Flattens a vector of vectors of T into a single vector of T.\n-pub fn concat<T:Copy>(v: &[~[T]]) -> ~[T] { v.concat_vec() }\n+pub fn concat<T:Clone>(v: &[~[T]]) -> ~[T] { v.concat_vec() }\n \n /// Concatenate a vector of vectors, placing a given separator between each\n-pub fn connect<T:Copy>(v: &[~[T]], sep: &T) -> ~[T] { v.connect_vec(sep) }\n+pub fn connect<T:Clone>(v: &[~[T]], sep: &T) -> ~[T] { v.connect_vec(sep) }\n \n /// Flattens a vector of vectors of T into a single vector of T.\n-pub fn concat_slices<T:Copy>(v: &[&[T]]) -> ~[T] { v.concat_vec() }\n+pub fn concat_slices<T:Clone>(v: &[&[T]]) -> ~[T] { v.concat_vec() }\n \n /// Concatenate a vector of vectors, placing a given separator between each\n-pub fn connect_slices<T:Copy>(v: &[&[T]], sep: &T) -> ~[T] { v.connect_vec(sep) }\n+pub fn connect_slices<T:Clone>(v: &[&[T]], sep: &T) -> ~[T] { v.connect_vec(sep) }\n \n #[allow(missing_doc)]\n pub trait VectorVector<T> {\n@@ -288,25 +287,25 @@ pub trait VectorVector<T> {\n     pub fn connect_vec(&self, sep: &T) -> ~[T];\n }\n \n-impl<'self, T:Copy> VectorVector<T> for &'self [~[T]] {\n+impl<'self, T:Clone> VectorVector<T> for &'self [~[T]] {\n     /// Flattens a vector of slices of T into a single vector of T.\n     pub fn concat_vec(&self) -> ~[T] {\n-        self.flat_map(|inner| copy *inner)\n+        self.flat_map(|inner| (*inner).clone())\n     }\n \n     /// Concatenate a vector of vectors, placing a given separator between each.\n     pub fn connect_vec(&self, sep: &T) -> ~[T] {\n         let mut r = ~[];\n         let mut first = true;\n         for self.iter().advance |inner| {\n-            if first { first = false; } else { r.push(copy *sep); }\n-            r.push_all(copy *inner);\n+            if first { first = false; } else { r.push((*sep).clone()); }\n+            r.push_all((*inner).clone());\n         }\n         r\n     }\n }\n \n-impl<'self, T:Copy> VectorVector<T> for &'self [&'self [T]] {\n+impl<'self,T:Clone> VectorVector<T> for &'self [&'self [T]] {\n     /// Flattens a vector of slices of T into a single vector of T.\n     pub fn concat_vec(&self) -> ~[T] {\n         self.flat_map(|&inner| inner.to_owned())\n@@ -317,7 +316,7 @@ impl<'self, T:Copy> VectorVector<T> for &'self [&'self [T]] {\n         let mut r = ~[];\n         let mut first = true;\n         for self.iter().advance |&inner| {\n-            if first { first = false; } else { r.push(copy *sep); }\n+            if first { first = false; } else { r.push((*sep).clone()); }\n             r.push_all(inner);\n         }\n         r\n@@ -331,11 +330,11 @@ impl<'self, T:Copy> VectorVector<T> for &'self [&'self [T]] {\n /**\n  * Convert a vector of pairs into a pair of vectors, by reference. As unzip().\n  */\n-pub fn unzip_slice<T:Copy,U:Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n+pub fn unzip_slice<T:Clone,U:Clone>(v: &[(T, U)]) -> (~[T], ~[U]) {\n     let mut ts = ~[];\n     let mut us = ~[];\n     for v.iter().advance |p| {\n-        let (t, u) = copy *p;\n+        let (t, u) = (*p).clone();\n         ts.push(t);\n         us.push(u);\n     }\n@@ -364,14 +363,13 @@ pub fn unzip<T,U>(v: ~[(T, U)]) -> (~[T], ~[U]) {\n /**\n  * Convert two vectors to a vector of pairs, by reference. As zip().\n  */\n-pub fn zip_slice<T:Copy,U:Copy>(v: &[T], u: &[U])\n-        -> ~[(T, U)] {\n+pub fn zip_slice<T:Clone,U:Clone>(v: &[T], u: &[U]) -> ~[(T, U)] {\n     let mut zipped = ~[];\n     let sz = v.len();\n     let mut i = 0u;\n     assert_eq!(sz, u.len());\n     while i < sz {\n-        zipped.push((copy v[i], copy u[i]));\n+        zipped.push((v[i].clone(), u[i].clone()));\n         i += 1u;\n     }\n     zipped\n@@ -415,9 +413,9 @@ pub fn zip<T, U>(mut v: ~[T], mut u: ~[U]) -> ~[(T, U)] {\n  *\n  *  * `fun` - The function to iterate over the combinations\n  */\n-pub fn each_permutation<T:Copy>(values: &[T], fun: &fn(perm : &[T]) -> bool) -> bool {\n+pub fn each_permutation<T:Clone>(values: &[T], fun: &fn(perm : &[T]) -> bool) -> bool {\n     let length = values.len();\n-    let mut permutation = vec::from_fn(length, |i| copy values[i]);\n+    let mut permutation = vec::from_fn(length, |i| values[i].clone());\n     if length <= 1 {\n         fun(permutation);\n         return true;\n@@ -444,7 +442,7 @@ pub fn each_permutation<T:Copy>(values: &[T], fun: &fn(perm : &[T]) -> bool) ->\n         indices.mut_slice(k+1, length).reverse();\n         // fixup permutation based on indices\n         for uint::range(k, length) |i| {\n-            permutation[i] = copy values[indices[i]];\n+            permutation[i] = values[indices[i]].clone();\n         }\n     }\n }\n@@ -496,7 +494,8 @@ impl<'self, T> Iterator<&'self [T]> for VecChunkIter<'self, T> {\n #[cfg(not(test))]\n pub mod traits {\n     use super::Vector;\n-    use kinds::Copy;\n+\n+    use clone::Clone;\n     use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Equal, Equiv};\n     use ops::Add;\n \n@@ -615,15 +614,15 @@ pub mod traits {\n         fn gt(&self, other: &@[T]) -> bool { self.as_slice() > other.as_slice() }\n     }\n \n-    impl<'self,T:Copy, V: Vector<T>> Add<V, ~[T]> for &'self [T] {\n+    impl<'self,T:Clone, V: Vector<T>> Add<V, ~[T]> for &'self [T] {\n         #[inline]\n         fn add(&self, rhs: &V) -> ~[T] {\n             let mut res = self.to_owned();\n             res.push_all(rhs.as_slice());\n             res\n         }\n     }\n-    impl<T:Copy, V: Vector<T>> Add<V, ~[T]> for ~[T] {\n+    impl<T:Clone, V: Vector<T>> Add<V, ~[T]> for ~[T] {\n         #[inline]\n         fn add(&self, rhs: &V) -> ~[T] {\n             let mut res = self.to_owned();\n@@ -688,13 +687,13 @@ pub trait CopyableVector<T> {\n }\n \n /// Extension methods for vectors\n-impl<'self,T:Copy> CopyableVector<T> for &'self [T] {\n+impl<'self,T:Clone> CopyableVector<T> for &'self [T] {\n     /// Returns a copy of `v`.\n     #[inline]\n     fn to_owned(&self) -> ~[T] {\n         let mut result = with_capacity(self.len());\n         for self.iter().advance |e| {\n-            result.push(copy *e);\n+            result.push((*e).clone());\n         }\n         result\n     }\n@@ -927,6 +926,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U] {\n         flat_map(*self, f)\n     }\n+\n     /// Returns a pointer to the element at the given index, without doing\n     /// bounds checking.\n     #[inline]\n@@ -1044,7 +1044,7 @@ pub trait ImmutableCopyableVector<T> {\n }\n \n /// Extension methods for vectors\n-impl<'self,T:Copy> ImmutableCopyableVector<T> for &'self [T] {\n+impl<'self,T:Clone> ImmutableCopyableVector<T> for &'self [T] {\n     /**\n      * Partitions the vector into those that satisfies the predicate, and\n      * those that do not.\n@@ -1056,9 +1056,9 @@ impl<'self,T:Copy> ImmutableCopyableVector<T> for &'self [T] {\n \n         for self.iter().advance |elt| {\n             if f(elt) {\n-                lefts.push(copy *elt);\n+                lefts.push((*elt).clone());\n             } else {\n-                rights.push(copy *elt);\n+                rights.push((*elt).clone());\n             }\n         }\n \n@@ -1068,7 +1068,7 @@ impl<'self,T:Copy> ImmutableCopyableVector<T> for &'self [T] {\n     /// Returns the element at the given index, without doing bounds checking.\n     #[inline]\n     unsafe fn unsafe_get(&self, index: uint) -> T {\n-        copy *self.unsafe_ref(index)\n+        (*self.unsafe_ref(index)).clone()\n     }\n }\n \n@@ -1555,13 +1555,13 @@ impl<T> Mutable for ~[T] {\n }\n \n #[allow(missing_doc)]\n-pub trait OwnedCopyableVector<T:Copy> {\n+pub trait OwnedCopyableVector<T:Clone> {\n     fn push_all(&mut self, rhs: &[T]);\n     fn grow(&mut self, n: uint, initval: &T);\n     fn grow_set(&mut self, index: uint, initval: &T, val: T);\n }\n \n-impl<T:Copy> OwnedCopyableVector<T> for ~[T] {\n+impl<T:Clone> OwnedCopyableVector<T> for ~[T] {\n     /// Iterates over the slice `rhs`, copies each element, and then appends it to\n     /// the vector provided `v`. The `rhs` vector is traversed in-order.\n     ///\n@@ -1596,7 +1596,7 @@ impl<T:Copy> OwnedCopyableVector<T> for ~[T] {\n         let mut i: uint = 0u;\n \n         while i < n {\n-            self.push(copy *initval);\n+            self.push((*initval).clone());\n             i += 1u;\n         }\n     }\n@@ -1894,7 +1894,7 @@ pub struct UnboxedVecRepr {\n /// Unsafe operations\n pub mod raw {\n     use cast::transmute;\n-    use kinds::Copy;\n+    use clone::Clone;\n     use managed;\n     use option::{None, Some};\n     use ptr;\n@@ -2009,8 +2009,8 @@ pub mod raw {\n      * Unchecked vector indexing.\n      */\n     #[inline]\n-    pub unsafe fn get<T:Copy>(v: &[T], i: uint) -> T {\n-        v.as_imm_buf(|p, _len| copy *ptr::offset(p, i))\n+    pub unsafe fn get<T:Clone>(v: &[T], i: uint) -> T {\n+        v.as_imm_buf(|p, _len| (*ptr::offset(p, i)).clone())\n     }\n \n     /**"}, {"sha": "bf0dee0822fd12f56b4d7a0e2d5e2a1740be4fbd", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -58,7 +58,7 @@ enum AbiArchitecture {\n     Archs(u32)  // Multiple architectures (bitset)\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Clone, Eq, Encodable, Decodable)]\n pub struct AbiSet {\n     priv bits: u32   // each bit represents one of the abis below\n }"}, {"sha": "38f0b2496cbfeb61c330a17c146046aebfa08e3f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 102, "deletions": 72, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -24,7 +24,7 @@ use extra::serialize::{Encodable, Decodable, Encoder, Decoder};\n // table) and a SyntaxContext to track renaming and\n // macro expansion per Flatt et al., \"Macros\n // That Work Together\"\n-#[deriving(Eq,IterBytes)]\n+#[deriving(Clone, Eq, IterBytes)]\n pub struct ident { name: Name, ctxt: SyntaxContext }\n \n /// Construct an identifier with the given name and an empty context:\n@@ -93,7 +93,7 @@ impl<D:Decoder> Decodable<D> for ident {\n // Functions may or may not have names.\n pub type fn_ident = Option<ident>;\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct Lifetime {\n     id: node_id,\n     span: span,\n@@ -104,7 +104,7 @@ pub struct Lifetime {\n // for instance: core::cmp::Eq  .  It's represented\n // as a sequence of identifiers, along with a bunch\n // of supporting information.\n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct Path {\n     span: span,\n     global: bool,\n@@ -117,7 +117,7 @@ pub type crate_num = int;\n \n pub type node_id = int;\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct def_id {\n     crate: crate_num,\n     node: node_id,\n@@ -126,27 +126,27 @@ pub struct def_id {\n pub static local_crate: crate_num = 0;\n pub static crate_node_id: node_id = 0;\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n // The AST represents all type param bounds as types.\n // typeck::collect::compute_bounds matches these against\n // the \"special\" built-in traits (see middle::lang_items) and\n // detects Copy, Send, Send, and Freeze.\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum TyParamBound {\n     TraitTyParamBound(trait_ref),\n     RegionTyParamBound\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct TyParam {\n     ident: ident,\n     id: node_id,\n     bounds: OptVec<TyParamBound>\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct Generics {\n     lifetimes: OptVec<Lifetime>,\n-    ty_params: OptVec<TyParam>\n+    ty_params: OptVec<TyParam>,\n }\n \n impl Generics {\n@@ -161,7 +161,7 @@ impl Generics {\n     }\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum def {\n     def_fn(def_id, purity),\n     def_static_method(/* method */ def_id,\n@@ -199,7 +199,7 @@ pub type crate_cfg = ~[@meta_item];\n \n pub type crate = spanned<crate_>;\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct crate_ {\n     module: _mod,\n     attrs: ~[attribute],\n@@ -208,7 +208,7 @@ pub struct crate_ {\n \n pub type meta_item = spanned<meta_item_>;\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum meta_item_ {\n     meta_word(@str),\n     meta_list(@str, ~[@meta_item]),\n@@ -217,7 +217,7 @@ pub enum meta_item_ {\n \n //pub type blk = spanned<blk_>;\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n pub struct blk {\n     view_items: ~[view_item],\n     stmts: ~[@stmt],\n@@ -227,26 +227,26 @@ pub struct blk {\n     span: span,\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct pat {\n     id: node_id,\n     node: pat_,\n     span: span,\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct field_pat {\n     ident: ident,\n     pat: @pat,\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum binding_mode {\n     bind_by_ref(mutability),\n     bind_infer\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum pat_ {\n     pat_wild,\n     // A pat_ident may either be a new bound variable,\n@@ -271,10 +271,10 @@ pub enum pat_ {\n     pat_vec(~[@pat], Option<@pat>, ~[@pat])\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum mutability { m_mutbl, m_imm, m_const, }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum Sigil {\n     BorrowedSigil,\n     OwnedSigil,\n@@ -300,7 +300,7 @@ pub enum vstore {\n     vstore_slice(Option<Lifetime>) // &'foo? [1,2,3,4]\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum expr_vstore {\n     expr_vstore_uniq,                  // ~[1,2,3,4]\n     expr_vstore_box,                   // @[1,2,3,4]\n@@ -309,7 +309,7 @@ pub enum expr_vstore {\n     expr_vstore_mut_slice,             // &mut [1,2,3,4]\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum binop {\n     add,\n     subtract,\n@@ -331,7 +331,7 @@ pub enum binop {\n     gt,\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum unop {\n     box(mutability),\n     uniq,\n@@ -342,7 +342,7 @@ pub enum unop {\n \n pub type stmt = spanned<stmt_>;\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum stmt_ {\n     // could be an item or a local (let) binding:\n     stmt_decl(@decl, node_id),\n@@ -380,23 +380,26 @@ pub enum decl_ {\n     decl_item(@item),\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct arm {\n     pats: ~[@pat],\n     guard: Option<@expr>,\n     body: blk,\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct field_ {\n     ident: ident,\n     expr: @expr,\n }\n \n pub type field = spanned<field_>;\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n-pub enum blk_check_mode { default_blk, unsafe_blk, }\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+pub enum blk_check_mode {\n+    default_blk,\n+    unsafe_blk,\n+}\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct expr {\n@@ -418,14 +421,14 @@ impl expr {\n     }\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum CallSugar {\n     NoSugar,\n     DoSugar,\n     ForSugar\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum expr_ {\n     expr_vstore(@expr, expr_vstore),\n     expr_vec(~[@expr], mutability),\n@@ -496,7 +499,7 @@ pub enum expr_ {\n // else knows what to do with them, so you'll probably get a syntax\n // error.\n //\n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n #[doc=\"For macro invocations; parsing is delegated to the macro\"]\n pub enum token_tree {\n     // a single token\n@@ -569,7 +572,7 @@ pub enum token_tree {\n //\n pub type matcher = spanned<matcher_>;\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum matcher_ {\n     // match one token\n     match_tok(::parse::token::Token),\n@@ -582,14 +585,14 @@ pub enum matcher_ {\n \n pub type mac = spanned<mac_>;\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum mac_ {\n     mac_invoc_tt(Path,~[token_tree]),   // new macro-invocation\n }\n \n pub type lit = spanned<lit_>;\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum lit_ {\n     lit_str(@str),\n     lit_int(i64, int_ty),\n@@ -603,7 +606,7 @@ pub enum lit_ {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct mt {\n     ty: ~Ty,\n     mutbl: mutability,\n@@ -617,7 +620,7 @@ pub struct ty_field_ {\n \n pub type ty_field = spanned<ty_field_>;\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct ty_method {\n     ident: ident,\n     attrs: ~[attribute],\n@@ -629,35 +632,52 @@ pub struct ty_method {\n     span: span,\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n // A trait method is either required (meaning it doesn't have an\n // implementation, just a signature) or provided (meaning it has a default\n // implementation).\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum trait_method {\n     required(ty_method),\n     provided(@method),\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n-pub enum int_ty { ty_i, ty_char, ty_i8, ty_i16, ty_i32, ty_i64, }\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+pub enum int_ty {\n+    ty_i,\n+    ty_char,\n+    ty_i8,\n+    ty_i16,\n+    ty_i32,\n+    ty_i64,\n+}\n \n impl ToStr for int_ty {\n     fn to_str(&self) -> ~str {\n         ::ast_util::int_ty_to_str(*self)\n     }\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n-pub enum uint_ty { ty_u, ty_u8, ty_u16, ty_u32, ty_u64, }\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+pub enum uint_ty {\n+    ty_u,\n+    ty_u8,\n+    ty_u16,\n+    ty_u32,\n+    ty_u64,\n+}\n \n impl ToStr for uint_ty {\n     fn to_str(&self) -> ~str {\n         ::ast_util::uint_ty_to_str(*self)\n     }\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n-pub enum float_ty { ty_f, ty_f32, ty_f64, }\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+pub enum float_ty {\n+    ty_f,\n+    ty_f32,\n+    ty_f64,\n+}\n \n impl ToStr for float_ty {\n     fn to_str(&self) -> ~str {\n@@ -666,15 +686,15 @@ impl ToStr for float_ty {\n }\n \n // NB Eq method appears below.\n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n pub struct Ty {\n     id: node_id,\n     node: ty_,\n     span: span,\n }\n \n // Not represented directly in the AST, referred to by name through a ty_path.\n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum prim_ty {\n     ty_int(int_ty),\n     ty_uint(uint_ty),\n@@ -683,7 +703,7 @@ pub enum prim_ty {\n     ty_bool,\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum Onceness {\n     Once,\n     Many\n@@ -722,7 +742,7 @@ pub struct TyBareFn {\n     decl: fn_decl\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum ty_ {\n     ty_nil,\n     ty_bot, /* bottom type */\n@@ -743,13 +763,13 @@ pub enum ty_ {\n     ty_infer,\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum asm_dialect {\n     asm_att,\n     asm_intel\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct inline_asm {\n     asm: @str,\n     clobbers: @str,\n@@ -760,22 +780,22 @@ pub struct inline_asm {\n     dialect: asm_dialect\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct arg {\n     is_mutbl: bool,\n     ty: Ty,\n     pat: @pat,\n     id: node_id,\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct fn_decl {\n     inputs: ~[arg],\n     output: Ty,\n     cf: ret_style,\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum purity {\n     unsafe_fn, // declared with \"unsafe fn\"\n     impure_fn, // declared with \"fn\"\n@@ -793,14 +813,14 @@ impl ToStr for purity {\n     }\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum ret_style {\n     noreturn, // functions with return type _|_ that always\n               // raise an error or exit (i.e. never return to the caller)\n     return_val, // everything else\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum explicit_self_ {\n     sty_static,                                // no self\n     sty_value,                                 // `self`\n@@ -826,42 +846,45 @@ pub struct method {\n     vis: visibility,\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct _mod {\n     view_items: ~[view_item],\n     items: ~[@item],\n }\n \n // Foreign mods can be named or anonymous\n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n-pub enum foreign_mod_sort { named, anonymous }\n+#[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n+pub enum foreign_mod_sort {\n+    named,\n+    anonymous,\n+}\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n pub struct foreign_mod {\n     sort: foreign_mod_sort,\n     abis: AbiSet,\n     view_items: ~[view_item],\n     items: ~[@foreign_item],\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct variant_arg {\n     ty: Ty,\n     id: node_id,\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum variant_kind {\n     tuple_variant_kind(~[variant_arg]),\n     struct_variant_kind(@struct_def),\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct enum_def {\n     variants: ~[variant],\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct variant_ {\n     name: ident,\n     attrs: ~[attribute],\n@@ -873,7 +896,7 @@ pub struct variant_ {\n \n pub type variant = spanned<variant_>;\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct path_list_ident_ {\n     name: ident,\n     id: node_id,\n@@ -883,7 +906,7 @@ pub type path_list_ident = spanned<path_list_ident_>;\n \n pub type view_path = spanned<view_path_>;\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Eq, Encodable, Decodable, IterBytes)]\n pub enum view_path_ {\n \n     // quux = foo::bar::baz\n@@ -900,15 +923,15 @@ pub enum view_path_ {\n     view_path_list(Path, ~[path_list_ident], node_id)\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct view_item {\n     node: view_item_,\n     attrs: ~[attribute],\n     vis: visibility,\n     span: span,\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum view_item_ {\n     view_item_extern_mod(ident, ~[@meta_item], node_id),\n     view_item_use(~[@view_path]),\n@@ -920,11 +943,14 @@ pub type attribute = spanned<attribute_>;\n // Distinguishes between attributes that decorate items and attributes that\n // are contained as statements within items. These two cases need to be\n // distinguished for pretty-printing.\n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n-pub enum attr_style { attr_outer, attr_inner, }\n+#[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n+pub enum attr_style {\n+    attr_outer,\n+    attr_inner,\n+}\n \n // doc-comments are promoted to attributes that have is_sugared_doc = true\n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n pub struct attribute_ {\n     style: attr_style,\n     value: @meta_item,\n@@ -938,14 +964,18 @@ pub struct attribute_ {\n   If this impl is an item_impl, the impl_id is redundant (it could be the\n   same as the impl's node id).\n  */\n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n pub struct trait_ref {\n     path: Path,\n     ref_id: node_id,\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n-pub enum visibility { public, private, inherited }\n+#[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n+pub enum visibility {\n+    public,\n+    private,\n+    inherited,\n+}\n \n impl visibility {\n     pub fn inherit_from(&self, parent_visibility: visibility) -> visibility {\n@@ -984,7 +1014,7 @@ pub struct struct_def {\n   FIXME (#3300): Should allow items to be anonymous. Right now\n   we just use dummy names for anon items.\n  */\n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct item {\n     ident: ident,\n     attrs: ~[attribute],\n@@ -994,7 +1024,7 @@ pub struct item {\n     span: span,\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum item_ {\n     item_static(Ty, mutability, @expr),\n     item_fn(fn_decl, purity, AbiSet, Generics, blk),"}, {"sha": "721f5108cc02b0f7f2d039c024c1ac99a12b7ed1", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 10, "deletions": 28, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -24,31 +24,12 @@ use std::cmp;\n use std::hashmap::HashMap;\n use std::vec;\n \n+#[deriving(Clone, Eq)]\n pub enum path_elt {\n     path_mod(ident),\n     path_name(ident)\n }\n \n-impl cmp::Eq for path_elt {\n-    fn eq(&self, other: &path_elt) -> bool {\n-        match (*self) {\n-            path_mod(e0a) => {\n-                match (*other) {\n-                    path_mod(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            path_name(e0a) => {\n-                match (*other) {\n-                    path_name(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    fn ne(&self, other: &path_elt) -> bool { !(*self).eq(other) }\n-}\n-\n pub type path = ~[path_elt];\n \n pub fn path_to_str_with_sep(p: &[path_elt], sep: &str, itr: @ident_interner)\n@@ -64,7 +45,6 @@ pub fn path_to_str_with_sep(p: &[path_elt], sep: &str, itr: @ident_interner)\n \n pub fn path_ident_to_str(p: &path, i: ident, itr: @ident_interner) -> ~str {\n     if p.is_empty() {\n-        //FIXME /* FIXME (#2543) */ copy *i\n         itr.get(i.name).to_owned()\n     } else {\n         fmt!(\"%s::%s\", path_to_str(*p, itr), itr.get(i.name))\n@@ -82,6 +62,7 @@ pub fn path_elt_to_str(pe: path_elt, itr: @ident_interner) -> ~str {\n     }\n }\n \n+#[deriving(Clone)]\n pub enum ast_node {\n     node_item(@item, @path),\n     node_foreign_item(@foreign_item, AbiSet, visibility, @path),\n@@ -109,7 +90,7 @@ pub struct Ctx {\n pub type vt = visit::vt<@mut Ctx>;\n \n pub fn extend(cx: @mut Ctx, elt: ident) -> @path {\n-    @(vec::append(copy cx.path, [path_name(elt)]))\n+    @(vec::append(cx.path.clone(), [path_name(elt)]))\n }\n \n pub fn mk_ast_map_visitor() -> vt {\n@@ -149,7 +130,7 @@ pub fn map_decoded_item(diag: @span_handler,\n     // variables that are simultaneously in scope).\n     let cx = @mut Ctx {\n         map: map,\n-        path: copy path,\n+        path: path.clone(),\n         diag: diag,\n     };\n     let v = mk_ast_map_visitor();\n@@ -190,7 +171,7 @@ pub fn map_fn(\n }\n \n pub fn map_block(b: &blk, (cx,v): (@mut Ctx, visit::vt<@mut Ctx>)) {\n-    cx.map.insert(b.id, node_block(/* FIXME (#2543) */ copy *b));\n+    cx.map.insert(b.id, node_block(/* FIXME (#2543) */ (*b).clone()));\n     visit::visit_block(b, (cx, v));\n }\n \n@@ -216,7 +197,7 @@ pub fn map_method(impl_did: def_id, impl_path: @path,\n }\n \n pub fn map_item(i: @item, (cx, v): (@mut Ctx, visit::vt<@mut Ctx>)) {\n-    let item_path = @/* FIXME (#2543) */ copy cx.path;\n+    let item_path = @/* FIXME (#2543) */ cx.path.clone();\n     cx.map.insert(i.id, node_item(i, item_path));\n     match i.node {\n         item_impl(_, _, _, ref ms) => {\n@@ -228,7 +209,8 @@ pub fn map_item(i: @item, (cx, v): (@mut Ctx, visit::vt<@mut Ctx>)) {\n         item_enum(ref enum_definition, _) => {\n             for (*enum_definition).variants.iter().advance |v| {\n                 cx.map.insert(v.node.id, node_variant(\n-                    /* FIXME (#2543) */ copy *v, i,\n+                    /* FIXME (#2543) */ (*v).clone(),\n+                    i,\n                     extend(cx, i.ident)));\n             }\n         }\n@@ -251,7 +233,7 @@ pub fn map_item(i: @item, (cx, v): (@mut Ctx, visit::vt<@mut Ctx>)) {\n                             extend(cx, i.ident)\n                         } else {\n                             // Anonymous extern mods go in the parent scope\n-                            @copy cx.path\n+                            @cx.path.clone()\n                         }\n                     )\n                 );\n@@ -275,7 +257,7 @@ pub fn map_item(i: @item, (cx, v): (@mut Ctx, visit::vt<@mut Ctx>)) {\n                 let d_id = ast_util::local_def(i.id);\n                 cx.map.insert(\n                     id,\n-                    node_trait_method(@copy *tm, d_id, item_path)\n+                    node_trait_method(@(*tm).clone(), d_id, item_path)\n                 );\n             }\n         }"}, {"sha": "843fd4bdba2c0816f3f2005a4bc6470f83c3ed0e", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 51, "deletions": 45, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -238,7 +238,11 @@ pub fn is_unguarded(a: &arm) -> bool {\n }\n \n pub fn unguarded_pat(a: &arm) -> Option<~[@pat]> {\n-    if is_unguarded(a) { Some(/* FIXME (#2543) */ copy a.pats) } else { None }\n+    if is_unguarded(a) {\n+        Some(/* FIXME (#2543) */ a.pats.clone())\n+    } else {\n+        None\n+    }\n }\n \n pub fn public_methods(ms: ~[@method]) -> ~[@method] {\n@@ -254,14 +258,14 @@ pub fn public_methods(ms: ~[@method]) -> ~[@method] {\n // a default, pull out the useful fields to make a ty_method\n pub fn trait_method_to_ty_method(method: &trait_method) -> ty_method {\n     match *method {\n-        required(ref m) => copy *m,\n+        required(ref m) => (*m).clone(),\n         provided(ref m) => {\n             ty_method {\n                 ident: m.ident,\n-                attrs: copy m.attrs,\n+                attrs: m.attrs.clone(),\n                 purity: m.purity,\n-                decl: copy m.decl,\n-                generics: copy m.generics,\n+                decl: m.decl.clone(),\n+                generics: m.generics.clone(),\n                 explicit_self: m.explicit_self,\n                 id: m.id,\n                 span: m.span,\n@@ -276,7 +280,7 @@ pub fn split_trait_methods(trait_methods: &[trait_method])\n     let mut provd = ~[];\n     for trait_methods.iter().advance |trt_method| {\n         match *trt_method {\n-          required(ref tm) => reqd.push(copy *tm),\n+          required(ref tm) => reqd.push((*tm).clone()),\n           provided(m) => provd.push(m)\n         }\n     };\n@@ -293,7 +297,7 @@ pub fn struct_field_visibility(field: ast::struct_field) -> visibility {\n pub trait inlined_item_utils {\n     fn ident(&self) -> ident;\n     fn id(&self) -> ast::node_id;\n-    fn accept<E: Copy>(&self, e: E, v: visit::vt<E>);\n+    fn accept<E: Clone>(&self, e: E, v: visit::vt<E>);\n }\n \n impl inlined_item_utils for inlined_item {\n@@ -313,7 +317,7 @@ impl inlined_item_utils for inlined_item {\n         }\n     }\n \n-    fn accept<E: Copy>(&self, e: E, v: visit::vt<E>) {\n+    fn accept<E: Clone>(&self, e: E, v: visit::vt<E>) {\n         match *self {\n             ii_item(i) => (v.visit_item)(i, (e, v)),\n             ii_foreign(i) => (v.visit_foreign_item)(i, (e, v)),\n@@ -385,33 +389,33 @@ impl id_range {\n     }\n }\n \n-pub fn id_visitor<T: Copy>(vfn: @fn(node_id, T)) -> visit::vt<T> {\n+pub fn id_visitor<T: Clone>(vfn: @fn(node_id, T)) -> visit::vt<T> {\n     let visit_generics: @fn(&Generics, T) = |generics, t| {\n         for generics.ty_params.iter().advance |p| {\n-            vfn(p.id, copy t);\n+            vfn(p.id, t.clone());\n         }\n         for generics.lifetimes.iter().advance |p| {\n-            vfn(p.id, copy t);\n+            vfn(p.id, t.clone());\n         }\n     };\n     visit::mk_vt(@visit::Visitor {\n-        visit_mod: |m, sp, id, (t, vt)| {\n-            vfn(id, copy t);\n+        visit_mod: |m, sp, id, (t, vt): (T, visit::vt<T>)| {\n+            vfn(id, t.clone());\n             visit::visit_mod(m, sp, id, (t, vt));\n         },\n \n         visit_view_item: |vi, (t, vt)| {\n             match vi.node {\n-              view_item_extern_mod(_, _, id) => vfn(id, copy t),\n+              view_item_extern_mod(_, _, id) => vfn(id, t.clone()),\n               view_item_use(ref vps) => {\n                   for vps.iter().advance |vp| {\n                       match vp.node {\n-                          view_path_simple(_, _, id) => vfn(id, copy t),\n-                          view_path_glob(_, id) => vfn(id, copy t),\n+                          view_path_simple(_, _, id) => vfn(id, t.clone()),\n+                          view_path_glob(_, id) => vfn(id, t.clone()),\n                           view_path_list(_, ref paths, id) => {\n-                              vfn(id, copy t);\n+                              vfn(id, t.clone());\n                               for paths.iter().advance |p| {\n-                                  vfn(p.node.id, copy t);\n+                                  vfn(p.node.id, t.clone());\n                               }\n                           }\n                       }\n@@ -422,86 +426,88 @@ pub fn id_visitor<T: Copy>(vfn: @fn(node_id, T)) -> visit::vt<T> {\n         },\n \n         visit_foreign_item: |ni, (t, vt)| {\n-            vfn(ni.id, copy t);\n+            vfn(ni.id, t.clone());\n             visit::visit_foreign_item(ni, (t, vt));\n         },\n \n         visit_item: |i, (t, vt)| {\n-            vfn(i.id, copy t);\n+            vfn(i.id, t.clone());\n             match i.node {\n               item_enum(ref enum_definition, _) =>\n-                for (*enum_definition).variants.iter().advance |v| { vfn(v.node.id, copy t); },\n+                for (*enum_definition).variants.iter().advance |v| {\n+                    vfn(v.node.id, t.clone());\n+                },\n               _ => ()\n             }\n             visit::visit_item(i, (t, vt));\n         },\n \n         visit_local: |l, (t, vt)| {\n-            vfn(l.node.id, copy t);\n+            vfn(l.node.id, t.clone());\n             visit::visit_local(l, (t, vt));\n         },\n         visit_block: |b, (t, vt)| {\n-            vfn(b.id, copy t);\n+            vfn(b.id, t.clone());\n             visit::visit_block(b, (t, vt));\n         },\n         visit_stmt: |s, (t, vt)| {\n-            vfn(ast_util::stmt_id(s), copy t);\n+            vfn(ast_util::stmt_id(s), t.clone());\n             visit::visit_stmt(s, (t, vt));\n         },\n         visit_pat: |p, (t, vt)| {\n-            vfn(p.id, copy t);\n+            vfn(p.id, t.clone());\n             visit::visit_pat(p, (t, vt));\n         },\n \n         visit_expr: |e, (t, vt)| {\n             {\n                 let r = e.get_callee_id();\n                 for r.iter().advance |callee_id| {\n-                    vfn(*callee_id, copy t);\n+                    vfn(*callee_id, t.clone());\n                 }\n             }\n-            vfn(e.id, copy t);\n+            vfn(e.id, t.clone());\n             visit::visit_expr(e, (t, vt));\n         },\n \n         visit_ty: |ty, (t, vt)| {\n-            vfn(ty.id, copy t);\n+            vfn(ty.id, t.clone());\n             match ty.node {\n-              ty_path(_, _, id) => vfn(id, copy t),\n+              ty_path(_, _, id) => vfn(id, t.clone()),\n               _ => { /* fall through */ }\n             }\n             visit::visit_ty(ty, (t, vt));\n         },\n \n         visit_generics: |generics, (t, vt)| {\n-            visit_generics(generics, copy t);\n+            visit_generics(generics, t.clone());\n             visit::visit_generics(generics, (t, vt));\n         },\n \n         visit_fn: |fk, d, a, b, id, (t, vt)| {\n-            vfn(id, copy t);\n+            vfn(id, t.clone());\n \n             match *fk {\n                 visit::fk_item_fn(_, generics, _, _) => {\n-                    visit_generics(generics, copy t);\n+                    visit_generics(generics, t.clone());\n                 }\n                 visit::fk_method(_, generics, m) => {\n-                    vfn(m.self_id, copy t);\n-                    visit_generics(generics, copy t);\n+                    vfn(m.self_id, t.clone());\n+                    visit_generics(generics, t.clone());\n                 }\n                 visit::fk_anon(_) |\n                 visit::fk_fn_block => {\n                 }\n             }\n \n             for d.inputs.iter().advance |arg| {\n-                vfn(arg.id, copy t)\n+                vfn(arg.id, t.clone())\n             }\n-            visit::visit_fn(fk, d, a, b, id, (copy t, vt));\n+            visit::visit_fn(fk, d, a, b, id, (t.clone(), vt));\n         },\n \n         visit_struct_field: |f, (t, vt)| {\n-            vfn(f.node.id, copy t);\n+            vfn(f.node.id, t.clone());\n             visit::visit_struct_field(f, (t, vt));\n         },\n \n@@ -800,19 +806,19 @@ mod test {\n     #[test] fn xorpush_test () {\n         let mut s = ~[];\n         xorPush(&mut s,14);\n-        assert_eq!(copy s,~[14]);\n+        assert_eq!(s.clone(),~[14]);\n         xorPush(&mut s,14);\n-        assert_eq!(copy s,~[]);\n+        assert_eq!(s.clone(),~[]);\n         xorPush(&mut s,14);\n-        assert_eq!(copy s,~[14]);\n+        assert_eq!(s.clone(),~[14]);\n         xorPush(&mut s,15);\n-        assert_eq!(copy s,~[14,15]);\n+        assert_eq!(s.clone(),~[14,15]);\n         xorPush (&mut s,16);\n-        assert_eq!(copy s,~[14,15,16]);\n+        assert_eq!(s.clone(),~[14,15,16]);\n         xorPush (&mut s,16);\n-        assert_eq!(copy s,~[14,15]);\n+        assert_eq!(s.clone(),~[14,15]);\n         xorPush (&mut s,15);\n-        assert_eq!(copy s,~[14]);\n+        assert_eq!(s.clone(),~[14]);\n     }\n \n     // convert a list of uints to an @[ident]\n@@ -868,7 +874,7 @@ mod test {\n         let mut t = new_sctable_internal();\n \n         let test_sc = ~[M(3),R(id(101,0),14),M(9)];\n-        assert_eq!(unfold_test_sc(copy test_sc,empty_ctxt,&mut t),4);\n+        assert_eq!(unfold_test_sc(test_sc.clone(),empty_ctxt,&mut t),4);\n         assert_eq!(t.table[2],Mark(9,0));\n         assert_eq!(t.table[3],Rename(id(101,0),14,2));\n         assert_eq!(t.table[4],Mark(3,3));"}, {"sha": "7dd01a54f7a95a09b935b81a210ff8d5386bf493", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -116,7 +116,7 @@ pub fn get_meta_item_value_str(meta: @ast::meta_item) -> Option<@str> {\n pub fn get_meta_item_list(meta: @ast::meta_item)\n                        -> Option<~[@ast::meta_item]> {\n     match meta.node {\n-        ast::meta_list(_, ref l) => Some(/* FIXME (#2543) */ copy *l),\n+        ast::meta_list(_, ref l) => Some(/* FIXME (#2543) */ (*l).clone()),\n         _ => None\n     }\n }\n@@ -266,7 +266,7 @@ pub fn sort_meta_items(items: &[@ast::meta_item]) -> ~[@ast::meta_item] {\n             ast::meta_list(n, ref mis) => {\n                 @spanned {\n                     node: ast::meta_list(n, sort_meta_items(*mis)),\n-                    .. /*bad*/ copy **m\n+                    .. /*bad*/ (**m).clone()\n                 }\n             }\n             _ => *m\n@@ -286,7 +286,9 @@ pub fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: &str) ->\n pub fn find_linkage_metas(attrs: &[ast::attribute]) -> ~[@ast::meta_item] {\n     do find_attrs_by_name(attrs, \"link\").flat_map |attr| {\n         match attr.node.value.node {\n-            ast::meta_list(_, ref items) => /* FIXME (#2543) */ copy *items,\n+            ast::meta_list(_, ref items) => {\n+                /* FIXME (#2543) */ (*items).clone()\n+            }\n             _ => ~[]\n         }\n     }"}, {"sha": "a9499881cff6a95b741392a1fed16c993cf6284d", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -31,7 +31,7 @@ pub trait Pos {\n }\n \n /// A byte offset\n-#[deriving(Eq,IterBytes)]\n+#[deriving(Clone, Eq, IterBytes)]\n pub struct BytePos(uint);\n /// A character offset. Because of multibyte utf8 characters, a byte offset\n /// is not equivalent to a character offset. The CodeMap will convert BytePos\n@@ -96,15 +96,18 @@ are *absolute* positions from the beginning of the codemap, not positions\n relative to FileMaps. Methods on the CodeMap can be used to relate spans back\n to the original source.\n */\n-#[deriving(IterBytes)]\n+#[deriving(Clone, IterBytes)]\n pub struct span {\n     lo: BytePos,\n     hi: BytePos,\n     expn_info: Option<@ExpnInfo>\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n-pub struct spanned<T> { node: T, span: span }\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+pub struct spanned<T> {\n+    node: T,\n+    span: span,\n+}\n \n impl cmp::Eq for span {\n     fn eq(&self, other: &span) -> bool {"}, {"sha": "717c5571994fffc711f2a0cc069c4f2ac7e9cdc9", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -265,7 +265,7 @@ fn highlight_lines(cm: @codemap::CodeMap,\n     // arbitrarily only print up to six lines of the error\n     let max_lines = 6u;\n     let mut elided = false;\n-    let mut display_lines = /* FIXME (#2543) */ copy lines.lines;\n+    let mut display_lines = /* FIXME (#2543) */ lines.lines.clone();\n     if display_lines.len() > max_lines {\n         display_lines = display_lines.slice(0u, max_lines).to_owned();\n         elided = true;\n@@ -345,11 +345,11 @@ fn print_macro_backtrace(cm: @codemap::CodeMap, sp: span) {\n     }\n }\n \n-pub fn expect<T:Copy>(diag: @span_handler,\n+pub fn expect<T:Clone>(diag: @span_handler,\n                        opt: Option<T>,\n                        msg: &fn() -> ~str) -> T {\n     match opt {\n-       Some(ref t) => copy *t,\n-       None => diag.handler().bug(msg())\n+       Some(ref t) => (*t).clone(),\n+       None => diag.handler().bug(msg()),\n     }\n }"}, {"sha": "e2f37bd54bd21c8cf13112bb9ea246d6e7f76e57", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -238,7 +238,7 @@ impl ExtCtxt {\n \n     pub fn codemap(&self) -> @CodeMap { self.parse_sess.cm }\n     pub fn parse_sess(&self) -> @mut parse::ParseSess { self.parse_sess }\n-    pub fn cfg(&self) -> ast::crate_cfg { copy self.cfg }\n+    pub fn cfg(&self) -> ast::crate_cfg { self.cfg.clone() }\n     pub fn call_site(&self) -> span {\n         match *self.backtrace {\n             Some(@ExpnInfo {call_site: cs, _}) => cs,\n@@ -249,7 +249,7 @@ impl ExtCtxt {\n     pub fn backtrace(&self) -> Option<@ExpnInfo> { *self.backtrace }\n     pub fn mod_push(&self, i: ast::ident) { self.mod_path.push(i); }\n     pub fn mod_pop(&self) { self.mod_path.pop(); }\n-    pub fn mod_path(&self) -> ~[ast::ident] { copy *self.mod_path }\n+    pub fn mod_path(&self) -> ~[ast::ident] { (*self.mod_path).clone() }\n     pub fn bt_push(&self, ei: codemap::ExpnInfo) {\n         match ei {\n             ExpnInfo {call_site: cs, callee: ref callee} => {"}, {"sha": "334721a38ed97c3079a6098b3e8125a1f69d76aa", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -351,7 +351,7 @@ impl AstBuilder for @ExtCtxt {\n         };\n         Generics {\n             ty_params: new_params,\n-            .. copy *generics\n+            .. (*generics).clone()\n         }\n     }\n \n@@ -611,13 +611,13 @@ impl AstBuilder for @ExtCtxt {\n     }\n     fn lambda0(&self, _span: span, blk: ast::blk) -> @ast::expr {\n         let ext_cx = *self;\n-        let blk_e = self.expr(blk.span, ast::expr_block(copy blk));\n+        let blk_e = self.expr(blk.span, ast::expr_block(blk.clone()));\n         quote_expr!(|| $blk_e )\n     }\n \n     fn lambda1(&self, _span: span, blk: ast::blk, ident: ast::ident) -> @ast::expr {\n         let ext_cx = *self;\n-        let blk_e = self.expr(blk.span, ast::expr_block(copy blk));\n+        let blk_e = self.expr(blk.span, ast::expr_block(blk.clone()));\n         quote_expr!(|$ident| $blk_e )\n     }\n "}, {"sha": "a50f4d70f0e9eae0c81e2dce65757b089c4eef7c", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -335,7 +335,7 @@ impl<'self> TraitDef<'self> {\n                     cx.typarambound(p.to_path(cx, span, type_ident, generics))\n                 });\n             // require the current trait\n-            bounds.push(cx.typarambound(copy trait_path));\n+            bounds.push(cx.typarambound(trait_path.clone()));\n \n             trait_generics.ty_params.push(cx.typaram(ty_param.ident, bounds));\n         }\n@@ -751,7 +751,7 @@ impl<'self> MethodDef<'self> {\n                         do self_vec.iter()\n                            .zip(enum_matching_fields.iter())\n                            .transform |(&(id, self_f), other)| {\n-                        (id, self_f, copy *other)\n+                        (id, self_f, (*other).clone())\n                     }.collect();\n                     substructure = EnumMatching(variant_index, variant, field_tuples);\n                 }\n@@ -789,7 +789,9 @@ impl<'self> MethodDef<'self> {\n                                                                     current_match_str,\n                                                                     ast::m_imm);\n \n-                matches_so_far.push((index, /*bad*/ copy *variant, idents));\n+                matches_so_far.push((index,\n+                                     /*bad*/ (*variant).clone(),\n+                                     idents));\n                 let arm_expr = self.build_enum_match(cx, span,\n                                                      enum_def,\n                                                      type_ident,\n@@ -818,7 +820,9 @@ impl<'self> MethodDef<'self> {\n                                                                        current_match_str,\n                                                                        ast::m_imm);\n \n-                    matches_so_far.push((index, /*bad*/ copy *variant, idents));\n+                    matches_so_far.push((index,\n+                                         /*bad*/ (*variant).clone(),\n+                                         idents));\n                     let new_matching =\n                         match matching {\n                             _ if match_count == 0 => Some(index),\n@@ -897,7 +901,8 @@ pub fn create_subpatterns(cx: @ExtCtxt,\n                           mutbl: ast::mutability)\n                    -> ~[@ast::pat] {\n     do field_paths.map |path| {\n-        cx.pat(span, ast::pat_ident(ast::bind_by_ref(mutbl), copy *path, None))\n+        cx.pat(span,\n+               ast::pat_ident(ast::bind_by_ref(mutbl), (*path).clone(), None))\n     }\n }\n \n@@ -944,7 +949,7 @@ fn create_struct_pattern(cx: @ExtCtxt,\n         };\n         let path = cx.path_ident(span,\n                                  cx.ident_of(fmt!(\"%s_%u\", prefix, i)));\n-        paths.push(copy path);\n+        paths.push(path.clone());\n         ident_expr.push((opt_id, cx.expr_path(path)));\n     }\n \n@@ -990,7 +995,7 @@ fn create_enum_variant_pattern(cx: @ExtCtxt,\n                 let path = cx.path_ident(span,\n                                          cx.ident_of(fmt!(\"%s_%u\", prefix, i)));\n \n-                paths.push(copy path);\n+                paths.push(path.clone());\n                 ident_expr.push((None, cx.expr_path(path)));\n             }\n \n@@ -1029,12 +1034,12 @@ pub fn cs_fold(use_foldl: bool,\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             if use_foldl {\n                 do all_fields.iter().fold(base) |old, triple| {\n-                    let (_, self_f, other_fs) = copy *triple;\n+                    let (_, self_f, other_fs) = (*triple).clone();\n                     f(cx, span, old, self_f, other_fs)\n                 }\n             } else {\n                 do all_fields.rev_iter().fold(base) |old, triple| {\n-                    let (_, self_f, other_fs) = copy *triple;\n+                    let (_, self_f, other_fs) = (*triple).clone();\n                     f(cx, span, old, self_f, other_fs)\n                 }\n             }\n@@ -1067,7 +1072,7 @@ pub fn cs_same_method(f: &fn(@ExtCtxt, span, ~[@expr]) -> @expr,\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             // call self_n.method(other_1_n, other_2_n, ...)\n             let called = do all_fields.map |triple| {\n-                let (_, self_field, other_fields) = copy *triple;\n+                let (_, self_field, other_fields) = (*triple).clone();\n                 cx.expr_method_call(span,\n                                     self_field,\n                                     substructure.method_ident,"}, {"sha": "be13e103a721b474848a09206b58206efc942689", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -56,8 +56,9 @@ fn iter_bytes_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @\n     let iter_bytes_ident = substr.method_ident;\n     let call_iterbytes = |thing_expr| {\n         cx.expr_method_call(span,\n-                              thing_expr, iter_bytes_ident,\n-                              ~[lsb0, borrowed_f])\n+                            thing_expr,\n+                            iter_bytes_ident,\n+                            ~[lsb0, borrowed_f])\n     };\n     let mut exprs = ~[];\n     let fields;"}, {"sha": "823f21401ca2d73e6364dcc1f923a7c837a02e5a", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -61,7 +61,7 @@ fn rand_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n     ];\n     let rand_call = || {\n         cx.expr_call_global(span,\n-                            copy rand_ident,\n+                            rand_ident.clone(),\n                             ~[ rng[0].duplicate(cx) ])\n     };\n \n@@ -79,7 +79,11 @@ fn rand_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n             // need to specify the uint-ness of the random number\n             let uint_ty = cx.ty_ident(span, cx.ident_of(\"uint\"));\n             let r_ty = cx.ty_ident(span, cx.ident_of(\"R\"));\n-            let rand_name = cx.path_all(span, true, copy rand_ident, None, ~[ uint_ty, r_ty ]);\n+            let rand_name = cx.path_all(span,\n+                                        true,\n+                                        rand_ident.clone(),\n+                                        None,\n+                                        ~[ uint_ty, r_ty ]);\n             let rand_name = cx.expr_path(rand_name);\n \n             // ::std::rand::Rand::rand::<uint>(rng)"}, {"sha": "5bee804d58250901e311408b96602321fa1809a9", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -63,7 +63,7 @@ fn zero_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n         cx.ident_of(\"zero\")\n     ];\n     let zero_call = || {\n-        cx.expr_call_global(span, copy zero_ident, ~[])\n+        cx.expr_call_global(span, zero_ident.clone(), ~[])\n     };\n \n     return match *substr.fields {"}, {"sha": "ba8e3e729338fe79921a7cc742bc0566f311f631", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -83,7 +83,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n \n                             //keep going, outside-in\n                             let fully_expanded =\n-                                copy fld.fold_expr(expanded).node;\n+                                fld.fold_expr(expanded).node.clone();\n                             cx.bt_pop();\n \n                             (fully_expanded, s)\n@@ -208,7 +208,7 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n                     -> Option<@ast::item> {\n     let (pth, tts) = match it.node {\n         item_mac(codemap::spanned { node: mac_invoc_tt(ref pth, ref tts), _}) => {\n-            (pth, copy *tts)\n+            (pth, (*tts).clone())\n         }\n         _ => cx.span_bug(it.span, \"invalid item macro invocation\")\n     };\n@@ -298,7 +298,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n         stmt_mac(ref mac, semi) => {\n             match mac.node {\n                 mac_invoc_tt(ref pth, ref tts) => {\n-                    (copy *mac, pth, copy *tts, semi)\n+                    ((*mac).clone(), pth, (*tts).clone(), semi)\n                 }\n             }\n         }\n@@ -337,7 +337,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n                 Some(stmt) => {\n                     let fully_expanded = &stmt.node;\n                     cx.bt_pop();\n-                    copy *fully_expanded\n+                    (*fully_expanded).clone()\n                 }\n                 None => {\n                     cx.span_fatal(pth.span,\n@@ -725,7 +725,7 @@ pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n     // every method/element of AstFoldFns in fold.rs.\n     let extsbox = @mut syntax_expander_table();\n     let afp = default_ast_fold();\n-    let cx = ExtCtxt::new(parse_sess, copy cfg);\n+    let cx = ExtCtxt::new(parse_sess, cfg.clone());\n     let f_pre = @AstFoldFns {\n         fold_expr: |expr,span,recur|\n             expand_expr(extsbox, cx, expr, span, recur, afp.fold_expr),"}, {"sha": "eb8b01c427dcb80f8cb8d3ecb128842ae2dd5de6", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -49,15 +49,15 @@ pub trait append_types {\n impl append_types for ast::Path {\n     fn add_ty(&self, ty: ast::Ty) -> ast::Path {\n         ast::Path {\n-            types: vec::append_one(copy self.types, ty),\n-            .. copy *self\n+            types: vec::append_one(self.types.clone(), ty),\n+            .. (*self).clone()\n         }\n     }\n \n     fn add_tys(&self, tys: ~[ast::Ty]) -> ast::Path {\n         ast::Path {\n-            types: vec::append(copy self.types, tys),\n-            .. copy *self\n+            types: vec::append(self.types.clone(), tys),\n+            .. (*self).clone()\n         }\n     }\n }"}, {"sha": "b8a0da8fe8fb7cab20afa8b4daf9b0afbb9caf3e", "filename": "src/libsyntax/ext/pipes/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -67,7 +67,7 @@ pub fn expand_proto(cx: @ExtCtxt, _sp: span, id: ast::ident,\n     let cfg = cx.cfg();\n     let tt_rdr = new_tt_reader(cx.parse_sess().span_diagnostic,\n                                None,\n-                               copy tt);\n+                               tt.clone());\n     let rdr = tt_rdr as @reader;\n     let rust_parser = Parser(sess, cfg, rdr.dup());\n "}, {"sha": "e5219721594c9ce8e86039d6ef98983bc29514c5", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -44,7 +44,7 @@ impl proto_parser for parser::Parser {\n         let name = interner_get(id.name);\n \n         self.expect(&token::COLON);\n-        let dir = match copy *self.token {\n+        let dir = match (*self.token).clone() {\n             token::IDENT(n, _) => interner_get(n.name),\n             _ => fail!()\n         };"}, {"sha": "b046c99d144e6f38a9e2924384035518eb932444", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -56,7 +56,8 @@ impl gen_send for message {\n                 next.generics.ty_params.len());\n             let arg_names = vec::from_fn(tys.len(), |i| cx.ident_of(\"x_\"+i.to_str()));\n             let args_ast: ~[ast::arg] = arg_names.iter().zip(tys.iter())\n-                .transform(|(n, t)| cx.arg(span, copy *n, copy *t)).collect();\n+                .transform(|(n, t)|\n+                    cx.arg(span, (*n).clone(), (*t).clone())).collect();\n \n             let pipe_ty = cx.ty_path(\n                 path(~[this.data_name()], span)\n@@ -117,7 +118,7 @@ impl gen_send for message {\n \n             let mut rty = cx.ty_path(path(~[next.data_name()],\n                                           span)\n-                                     .add_tys(copy next_state.tys), None);\n+                                     .add_tys(next_state.tys.clone()), None);\n             if try {\n                 rty = cx.ty_option(rty);\n             }\n@@ -137,7 +138,8 @@ impl gen_send for message {\n                 let arg_names = vec::from_fn(tys.len(), |i| \"x_\" + i.to_str());\n \n                 let args_ast: ~[ast::arg] = arg_names.iter().zip(tys.iter())\n-                    .transform(|(n, t)| cx.arg(span, cx.ident_of(*n), copy *t)).collect();\n+                    .transform(|(n, t)|\n+                        cx.arg(span, cx.ident_of(*n), (*t).clone())).collect();\n \n                 let args_ast = vec::append(\n                     ~[cx.arg(span,\n@@ -152,7 +154,7 @@ impl gen_send for message {\n                     ~\"\"\n                 }\n                 else {\n-                    ~\"(\" + arg_names.map(|x| copy *x).connect(\", \") + \")\"\n+                    ~\"(\" + arg_names.map(|x| (*x).clone()).connect(\", \") + \")\"\n                 };\n \n                 let mut body = ~\"{ \";\n@@ -209,7 +211,7 @@ impl to_type_decls for state {\n         let mut items_msg = ~[];\n \n         for self.messages.iter().advance |m| {\n-            let message(name, span, tys, this, next) = copy *m;\n+            let message(name, span, tys, this, next) = (*m).clone();\n \n             let tys = match next {\n               Some(ref next_state) => {\n@@ -225,7 +227,7 @@ impl to_type_decls for state {\n                                 cx.ty_path(\n                                     path(~[cx.ident_of(dir),\n                                            cx.ident_of(next_name)], span)\n-                                    .add_tys(copy next_state.tys), None))\n+                                    .add_tys(next_state.tys.clone()), None))\n               }\n               None => tys\n             };\n@@ -374,7 +376,7 @@ impl gen_init for protocol {\n         for self.states.iter().advance |s| {\n             for s.generics.ty_params.iter().advance |tp| {\n                 match params.iter().find_(|tpp| tp.ident == tpp.ident) {\n-                  None => params.push(copy *tp),\n+                  None => params.push((*tp).clone()),\n                   _ => ()\n                 }\n             }\n@@ -392,7 +394,7 @@ impl gen_init for protocol {\n         let fields = do self.states.iter().transform |s| {\n             for s.generics.ty_params.iter().advance |tp| {\n                 match params.iter().find_(|tpp| tp.ident == tpp.ident) {\n-                  None => params.push(copy *tp),\n+                  None => params.push((*tp).clone()),\n                   _ => ()\n                 }\n             }"}, {"sha": "c93b89daa40217774a6793ff4425eb3abb764a37", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -35,12 +35,14 @@ impl direction {\n     }\n }\n \n+#[deriving(Clone)]\n pub struct next_state {\n     state: @str,\n     tys: ~[ast::Ty],\n }\n \n // name, span, data, current state, next state\n+#[deriving(Clone)]\n pub struct message(@str, span, ~[ast::Ty], state, Option<next_state>);\n \n impl message {\n@@ -59,7 +61,7 @@ impl message {\n     /// Return the type parameters actually used by this message\n     pub fn get_generics(&self) -> ast::Generics {\n         match *self {\n-          message(_, _, _, this, _) => copy this.generics\n+          message(_, _, _, this, _) => this.generics.clone()\n         }\n     }\n }\n@@ -216,7 +218,7 @@ pub fn visit<Tproto, Tstate, Tmessage, V: visitor<Tproto, Tstate, Tmessage>>(\n \n     let states: ~[Tstate] = do proto.states.iter().transform |&s| {\n         let messages: ~[Tmessage] = do s.messages.iter().transform |m| {\n-            let message(name, span, tys, this, next) = copy *m;\n+            let message(name, span, tys, this, next) = (*m).clone();\n             visitor.visit_message(name, span, tys, this, next)\n         }.collect();\n         visitor.visit_state(s, messages)"}, {"sha": "80e3953da86c141fe78a981cbf2448cec6002937", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -45,7 +45,7 @@ pub mod rt {\n \n     impl ToTokens for ~[token_tree] {\n         pub fn to_tokens(&self, _cx: @ExtCtxt) -> ~[token_tree] {\n-            copy *self\n+            (*self).clone()\n         }\n     }\n "}, {"sha": "626a562b92c0397e9aa78222c185b132d9fafd9a", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -148,6 +148,6 @@ fn res_rel_file(cx: @ExtCtxt, sp: codemap::span, arg: &Path) -> Path {\n         let cu = Path(cx.codemap().span_to_filename(sp));\n         cu.dir_path().push_many(arg.components)\n     } else {\n-        copy *arg\n+        (*arg).clone()\n     }\n }"}, {"sha": "f7f17d3ba64ac33ed235f87f3104e305caec3f00", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -26,11 +26,7 @@ pub fn expand_trace_macros(cx: @ExtCtxt,\n                                None,\n                                tt.to_owned());\n     let rdr = tt_rdr as @reader;\n-    let rust_parser = Parser(\n-        sess,\n-        copy cfg,\n-        rdr.dup()\n-    );\n+    let rust_parser = Parser(sess, cfg.clone(), rdr.dup());\n \n     if rust_parser.is_keyword(keywords::True) {\n         cx.set_trace_macros(true);"}, {"sha": "54ccd489171608cf0422ea6f990c699f2b1ed6f0", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -96,6 +96,7 @@ eof: [a $( a )* a b \u00b7]\n /* to avoid costly uniqueness checks, we require that `match_seq` always has a\n nonempty body. */\n \n+#[deriving(Clone)]\n pub enum matcher_pos_up { /* to break a circularity */\n     matcher_pos_up(Option<~MatcherPos>)\n }\n@@ -107,6 +108,7 @@ pub fn is_some(mpu: &matcher_pos_up) -> bool {\n     }\n }\n \n+#[deriving(Clone)]\n pub struct MatcherPos {\n     elts: ~[ast::matcher], // maybe should be <'>? Need to understand regions.\n     sep: Option<Token>,\n@@ -119,7 +121,7 @@ pub struct MatcherPos {\n \n pub fn copy_up(mpu: &matcher_pos_up) -> ~MatcherPos {\n     match *mpu {\n-      matcher_pos_up(Some(ref mp)) => copy (*mp),\n+      matcher_pos_up(Some(ref mp)) => (*mp).clone(),\n       _ => fail!()\n     }\n }\n@@ -279,7 +281,7 @@ pub fn parse(\n \n                         // Only touch the binders we have actually bound\n                         for uint::range(ei.match_lo, ei.match_hi) |idx| {\n-                            let sub = copy ei.matches[idx];\n+                            let sub = ei.matches[idx].clone();\n                             new_pos.matches[idx]\n                                 .push(@matched_seq(sub,\n                                                    mk_sp(ei.sp_lo,\n@@ -293,10 +295,10 @@ pub fn parse(\n                     // can we go around again?\n \n                     // the *_t vars are workarounds for the lack of unary move\n-                    match copy ei.sep {\n+                    match ei.sep {\n                       Some(ref t) if idx == len => { // we need a separator\n                         if tok == (*t) { //pass the separator\n-                            let mut ei_t = ei;\n+                            let mut ei_t = ei.clone();\n                             ei_t.idx += 1;\n                             next_eis.push(ei_t);\n                         }\n@@ -311,12 +313,12 @@ pub fn parse(\n                     eof_eis.push(ei);\n                 }\n             } else {\n-                match copy ei.elts[idx].node {\n+                match ei.elts[idx].node.clone() {\n                   /* need to descend into sequence */\n                   match_seq(ref matchers, ref sep, zero_ok,\n                             match_idx_lo, match_idx_hi) => {\n                     if zero_ok {\n-                        let mut new_ei = copy ei;\n+                        let mut new_ei = ei.clone();\n                         new_ei.idx += 1u;\n                         //we specifically matched zero repeats.\n                         for uint::range(match_idx_lo, match_idx_hi) |idx| {\n@@ -329,8 +331,8 @@ pub fn parse(\n                     let matches = vec::from_elem(ei.matches.len(), ~[]);\n                     let ei_t = ei;\n                     cur_eis.push(~MatcherPos {\n-                        elts: copy *matchers,\n-                        sep: copy *sep,\n+                        elts: (*matchers).clone(),\n+                        sep: (*sep).clone(),\n                         idx: 0u,\n                         up: matcher_pos_up(Some(ei_t)),\n                         matches: matches,\n@@ -340,7 +342,7 @@ pub fn parse(\n                   }\n                   match_nonterminal(_,_,_) => { bb_eis.push(ei) }\n                   match_tok(ref t) => {\n-                    let mut ei_t = ei;\n+                    let mut ei_t = ei.clone();\n                     if (*t) == tok {\n                         ei_t.idx += 1;\n                         next_eis.push(ei_t);\n@@ -388,7 +390,7 @@ pub fn parse(\n                 }\n                 rdr.next_token();\n             } else /* bb_eis.len() == 1 */ {\n-                let rust_parser = Parser(sess, copy cfg, rdr.dup());\n+                let rust_parser = Parser(sess, cfg.clone(), rdr.dup());\n \n                 let mut ei = bb_eis.pop();\n                 match ei.elts[ei.idx].node {\n@@ -426,7 +428,7 @@ pub fn parse_nt(p: &Parser, name: &str) -> nonterminal {\n       \"ident\" => match *p.token {\n         token::IDENT(sn,b) => { p.bump(); token::nt_ident(sn,b) }\n         _ => p.fatal(~\"expected ident, found \"\n-                     + token::to_str(get_ident_interner(), &copy *p.token))\n+                     + token::to_str(get_ident_interner(), p.token))\n       },\n       \"path\" => token::nt_path(p.parse_path_with_tps(false)),\n       \"tt\" => {"}, {"sha": "399a1827c681f8025e636fe9b25aed449475c6c3", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -32,7 +32,10 @@ pub fn add_new_extension(cx: @ExtCtxt,\n                       -> base::MacResult {\n     // these spans won't matter, anyways\n     fn ms(m: matcher_) -> matcher {\n-        spanned { node: copy m, span: dummy_sp() }\n+        spanned {\n+            node: m.clone(),\n+            span: dummy_sp()\n+        }\n     }\n \n     let lhs_nm =  gensym_ident(\"lhs\");\n@@ -55,20 +58,20 @@ pub fn add_new_extension(cx: @ExtCtxt,\n     // Parse the macro_rules! invocation (`none` is for no interpolations):\n     let arg_reader = new_tt_reader(cx.parse_sess().span_diagnostic,\n                                    None,\n-                                   copy arg);\n+                                   arg.clone());\n     let argument_map = parse_or_else(cx.parse_sess(),\n                                      cx.cfg(),\n                                      arg_reader as @reader,\n                                      argument_gram);\n \n     // Extract the arguments:\n     let lhses = match *argument_map.get(&lhs_nm) {\n-        @matched_seq(ref s, _) => /* FIXME (#2543) */ @copy *s,\n+        @matched_seq(ref s, _) => /* FIXME (#2543) */ @(*s).clone(),\n         _ => cx.span_bug(sp, \"wrong-structured lhs\")\n     };\n \n     let rhses = match *argument_map.get(&rhs_nm) {\n-      @matched_seq(ref s, _) => /* FIXME (#2543) */ @copy *s,\n+      @matched_seq(ref s, _) => /* FIXME (#2543) */ @(*s).clone(),\n       _ => cx.span_bug(sp, \"wrong-structured rhs\")\n     };\n \n@@ -132,7 +135,7 @@ pub fn add_new_extension(cx: @ExtCtxt,\n                   }\n                   failure(sp, ref msg) => if sp.lo >= best_fail_spot.lo {\n                     best_fail_spot = sp;\n-                    best_fail_msg = copy *msg;\n+                    best_fail_msg = (*msg).clone();\n                   },\n                   error(sp, ref msg) => cx.span_fatal(sp, (*msg))\n                 }"}, {"sha": "67318c60db9a51d961a9277b58238bd7625d213a", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -74,10 +74,10 @@ pub fn new_tt_reader(sp_diag: @span_handler,\n \n fn dup_tt_frame(f: @mut TtFrame) -> @mut TtFrame {\n     @mut TtFrame {\n-        forest: @mut (copy *f.forest),\n+        forest: @mut (*f.forest).clone(),\n         idx: f.idx,\n         dotdotdoted: f.dotdotdoted,\n-        sep: copy f.sep,\n+        sep: f.sep.clone(),\n         up: match f.up {\n             Some(up_frame) => Some(dup_tt_frame(up_frame)),\n             None => None\n@@ -89,11 +89,11 @@ pub fn dup_tt_reader(r: @mut TtReader) -> @mut TtReader {\n     @mut TtReader {\n         sp_diag: r.sp_diag,\n         stack: dup_tt_frame(r.stack),\n-        repeat_idx: copy r.repeat_idx,\n-        repeat_len: copy r.repeat_len,\n-        cur_tok: copy r.cur_tok,\n+        repeat_idx: r.repeat_idx.clone(),\n+        repeat_len: r.repeat_len.clone(),\n+        cur_tok: r.cur_tok.clone(),\n         cur_span: r.cur_span,\n-        interpolations: copy r.interpolations,\n+        interpolations: r.interpolations.clone(),\n     }\n }\n \n@@ -122,19 +122,23 @@ fn lookup_cur_matched(r: &mut TtReader, name: ident) -> @named_match {\n         }\n     }\n }\n+\n+#[deriving(Clone)]\n enum lis {\n-    lis_unconstrained, lis_constraint(uint, ident), lis_contradiction(~str)\n+    lis_unconstrained,\n+    lis_constraint(uint, ident),\n+    lis_contradiction(~str),\n }\n \n fn lockstep_iter_size(t: &token_tree, r: &mut TtReader) -> lis {\n     fn lis_merge(lhs: lis, rhs: lis) -> lis {\n         match lhs {\n-          lis_unconstrained => copy rhs,\n-          lis_contradiction(_) => copy lhs,\n+          lis_unconstrained => rhs.clone(),\n+          lis_contradiction(_) => lhs.clone(),\n           lis_constraint(l_len, ref l_id) => match rhs {\n-            lis_unconstrained => copy lhs,\n-            lis_contradiction(_) => copy rhs,\n-            lis_constraint(r_len, _) if l_len == r_len => copy lhs,\n+            lis_unconstrained => lhs.clone(),\n+            lis_contradiction(_) => rhs.clone(),\n+            lis_constraint(r_len, _) if l_len == r_len => lhs.clone(),\n             lis_constraint(r_len, ref r_id) => {\n                 let l_n = ident_to_str(l_id);\n                 let r_n = ident_to_str(r_id);\n@@ -163,8 +167,9 @@ fn lockstep_iter_size(t: &token_tree, r: &mut TtReader) -> lis {\n // return the next token from the TtReader.\n // EFFECT: advances the reader's token field\n pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n+    // XXX(pcwalton): Bad copy?\n     let ret_val = TokenAndSpan {\n-        tok: copy r.cur_tok,\n+        tok: r.cur_tok.clone(),\n         sp: r.cur_span,\n     };\n     loop {\n@@ -199,7 +204,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n         } else { /* repeat */\n             r.stack.idx = 0u;\n             r.repeat_idx[r.repeat_idx.len() - 1u] += 1u;\n-            match copy r.stack.sep {\n+            match r.stack.sep.clone() {\n               Some(tk) => {\n                 r.cur_tok = tk; /* repeat same span, I guess */\n                 return ret_val;\n@@ -210,7 +215,8 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n     }\n     loop { /* because it's easiest, this handles `tt_delim` not starting\n     with a `tt_tok`, even though it won't happen */\n-        match copy r.stack.forest[r.stack.idx] {\n+        // XXX(pcwalton): Bad copy.\n+        match r.stack.forest[r.stack.idx].clone() {\n           tt_delim(tts) => {\n             r.stack = @mut TtFrame {\n                 forest: @mut tts,\n@@ -228,7 +234,8 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n             return ret_val;\n           }\n           tt_seq(sp, tts, sep, zerok) => {\n-            let t = tt_seq(sp, copy tts, copy sep, zerok);\n+            // XXX(pcwalton): Bad copy.\n+            let t = tt_seq(sp, tts.clone(), sep.clone(), zerok);\n             match lockstep_iter_size(&t, r) {\n               lis_unconstrained => {\n                 r.sp_diag.span_fatal(\n@@ -278,8 +285,9 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                 return ret_val;\n               }\n               matched_nonterminal(ref other_whole_nt) => {\n+                // XXX(pcwalton): Bad copy.\n                 r.cur_span = sp;\n-                r.cur_tok = INTERPOLATED(copy *other_whole_nt);\n+                r.cur_tok = INTERPOLATED((*other_whole_nt).clone());\n                 r.stack.idx += 1u;\n                 return ret_val;\n               }"}, {"sha": "b831bb1864310f7d78e821ba1e4d2c73f0956e34", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -144,17 +144,17 @@ fn fold_tts(tts : &[token_tree], fld: @ast_fold) -> ~[token_tree] {\n }\n \n // apply ident folder if it's an ident, otherwise leave it alone\n-fn maybe_fold_ident(t : &token::Token, fld: @ast_fold) -> token::Token {\n+fn maybe_fold_ident(t: &token::Token, fld: @ast_fold) -> token::Token {\n     match *t {\n         token::IDENT(id,followed_by_colons) =>\n         token::IDENT(fld.fold_ident(id),followed_by_colons),\n-        _ => copy *t\n+        _ => (*t).clone()\n     }\n }\n \n pub fn fold_fn_decl(decl: &ast::fn_decl, fld: @ast_fold) -> ast::fn_decl {\n     ast::fn_decl {\n-        inputs: decl.inputs.map(|x| fold_arg_(/*bad*/ copy *x, fld)),\n+        inputs: decl.inputs.map(|x| fold_arg_(/*bad*/ (*x).clone(), fld)),\n         output: fld.fold_ty(&decl.output),\n         cf: decl.cf,\n     }\n@@ -176,7 +176,7 @@ pub fn fold_ty_param(tp: TyParam,\n \n pub fn fold_ty_params(tps: &OptVec<TyParam>,\n                       fld: @ast_fold) -> OptVec<TyParam> {\n-    let tps = /*bad*/ copy *tps;\n+    let tps = /*bad*/ (*tps).clone();\n     tps.map_consume(|tp| fold_ty_param(tp, fld))\n }\n \n@@ -209,7 +209,7 @@ pub fn noop_fold_crate(c: &crate_, fld: @ast_fold) -> crate_ {\n }\n \n fn noop_fold_view_item(vi: &view_item_, _fld: @ast_fold) -> view_item_ {\n-    return /* FIXME (#2543) */ copy *vi;\n+    return /* FIXME (#2543) */ (*vi).clone();\n }\n \n \n@@ -226,7 +226,8 @@ fn noop_fold_foreign_item(ni: @foreign_item, fld: @ast_fold)\n                 foreign_item_fn(ref fdec, purity, ref generics) => {\n                     foreign_item_fn(\n                         ast::fn_decl {\n-                            inputs: fdec.inputs.map(|a| fold_arg(/*bad*/copy *a)),\n+                            inputs: fdec.inputs.map(|a|\n+                                fold_arg(/*bad*/(*a).clone())),\n                             output: fld.fold_ty(&fdec.output),\n                             cf: fdec.cf,\n                         },\n@@ -299,7 +300,7 @@ pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n         }\n         item_struct(ref struct_def, ref generics) => {\n             let struct_def = fold_struct_def(*struct_def, fld);\n-            item_struct(struct_def, /* FIXME (#2543) */ copy *generics)\n+            item_struct(struct_def, /* FIXME (#2543) */ (*generics).clone())\n         }\n         item_impl(ref generics, ref ifce, ref ty, ref methods) => {\n             item_impl(\n@@ -312,7 +313,7 @@ pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n         item_trait(ref generics, ref traits, ref methods) => {\n             let methods = do methods.map |method| {\n                 match *method {\n-                    required(*) => copy *method,\n+                    required(*) => (*method).clone(),\n                     provided(method) => provided(fld.fold_method(method))\n                 }\n             };\n@@ -353,7 +354,7 @@ fn fold_struct_field(f: @struct_field, fld: @ast_fold) -> @struct_field {\n             kind: f.node.kind,\n             id: fld.new_id(f.node.id),\n             ty: fld.fold_ty(&f.node.ty),\n-            attrs: /* FIXME (#2543) */ copy f.node.attrs,\n+            attrs: /* FIXME (#2543) */ f.node.attrs.clone(),\n         },\n         span: fld.new_span(f.span),\n     }\n@@ -362,7 +363,7 @@ fn fold_struct_field(f: @struct_field, fld: @ast_fold) -> @struct_field {\n fn noop_fold_method(m: @method, fld: @ast_fold) -> @method {\n     @ast::method {\n         ident: fld.fold_ident(m.ident),\n-        attrs: /* FIXME (#2543) */ copy m.attrs,\n+        attrs: /* FIXME (#2543) */ m.attrs.clone(),\n         generics: fold_generics(&m.generics, fld),\n         explicit_self: m.explicit_self,\n         purity: m.purity,\n@@ -545,8 +546,10 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n         }\n         expr_loop_body(f) => expr_loop_body(fld.fold_expr(f)),\n         expr_do_body(f) => expr_do_body(fld.fold_expr(f)),\n-        expr_lit(_) => copy *e,\n-        expr_cast(expr, ref ty) => expr_cast(fld.fold_expr(expr), copy *ty),\n+        expr_lit(_) => (*e).clone(),\n+        expr_cast(expr, ref ty) => {\n+            expr_cast(fld.fold_expr(expr), (*ty).clone())\n+        }\n         expr_addr_of(m, ohs) => expr_addr_of(m, fld.fold_expr(ohs)),\n         expr_if(cond, ref tr, fl) => {\n             expr_if(\n@@ -623,7 +626,7 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n             expr_inline_asm(inline_asm {\n                 inputs: a.inputs.map(|&(c, in)| (c, fld.fold_expr(in))),\n                 outputs: a.outputs.map(|&(c, out)| (c, fld.fold_expr(out))),\n-                .. copy *a\n+                .. (*a).clone()\n             })\n         }\n         expr_mac(ref mac) => expr_mac(fold_mac(mac)),\n@@ -662,7 +665,7 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n         }\n     }\n     match *t {\n-        ty_nil | ty_bot | ty_infer => copy *t,\n+        ty_nil | ty_bot | ty_infer => (*t).clone(),\n         ty_box(ref mt) => ty_box(fold_mt(mt, fld)),\n         ty_uniq(ref mt) => ty_uniq(fold_mt(mt, fld)),\n         ty_vec(ref mt) => ty_vec(fold_mt(mt, fld)),\n@@ -676,12 +679,12 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n                 onceness: f.onceness,\n                 bounds: fold_opt_bounds(&f.bounds, fld),\n                 decl: fold_fn_decl(&f.decl, fld),\n-                lifetimes: copy f.lifetimes,\n+                lifetimes: f.lifetimes.clone(),\n             })\n         }\n         ty_bare_fn(ref f) => {\n             ty_bare_fn(@TyBareFn {\n-                lifetimes: copy f.lifetimes,\n+                lifetimes: f.lifetimes.clone(),\n                 purity: f.purity,\n                 abis: f.abis,\n                 decl: fold_fn_decl(&f.decl, fld)\n@@ -727,7 +730,7 @@ fn noop_fold_variant(v: &variant_, fld: @ast_fold) -> variant_ {\n     match v.kind {\n         tuple_variant_kind(ref variant_args) => {\n             kind = tuple_variant_kind(do variant_args.map |x| {\n-                fold_variant_arg(/*bad*/ copy *x)\n+                fold_variant_arg(/*bad*/ (*x).clone())\n             })\n         }\n         struct_variant_kind(struct_def) => {\n@@ -844,7 +847,7 @@ impl ast_fold for AstFoldFns {\n                 kind: sf.node.kind,\n                 id: sf.node.id,\n                 ty: self.fold_ty(&sf.node.ty),\n-                attrs: copy sf.node.attrs,\n+                attrs: sf.node.attrs.clone(),\n             },\n             span: (self.new_span)(sf.span),\n         }"}, {"sha": "6ec80140c7658ee334bf86defb559c38abce0654", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -18,7 +18,7 @@\n \n use std::vec::{VecIterator};\n \n-#[deriving(Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Encodable, Decodable, IterBytes)]\n pub enum OptVec<T> {\n     Empty,\n     Vec(~[T])\n@@ -113,7 +113,7 @@ pub fn take_vec<T>(v: OptVec<T>) -> ~[T] {\n     }\n }\n \n-impl<T:Copy> OptVec<T> {\n+impl<T:Clone> OptVec<T> {\n     fn prepend(&self, t: T) -> OptVec<T> {\n         let mut v0 = ~[t];\n         match *self {"}, {"sha": "85c7d5de0641247b8a551827c1523bf4adf23b6c", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -39,7 +39,7 @@ impl parser_attr for Parser {\n         loop {\n             match *self.token {\n               token::POUND => {\n-                if self.look_ahead(1u) != token::LBRACKET {\n+                if self.look_ahead(1, |t| *t != token::LBRACKET) {\n                     break;\n                 }\n                 attrs.push(self.parse_attribute(ast::attr_outer));\n@@ -96,7 +96,7 @@ impl parser_attr for Parser {\n         loop {\n             match *self.token {\n               token::POUND => {\n-                if self.look_ahead(1u) != token::LBRACKET {\n+                if self.look_ahead(1, |t| *t != token::LBRACKET) {\n                     // This is an extension\n                     break;\n                 }\n@@ -162,12 +162,10 @@ impl parser_attr for Parser {\n \n     // matches meta_seq = ( COMMASEP(meta_item) )\n     fn parse_meta_seq(&self) -> ~[@ast::meta_item] {\n-        copy self.parse_seq(\n-            &token::LPAREN,\n-            &token::RPAREN,\n-            seq_sep_trailing_disallowed(token::COMMA),\n-            |p| p.parse_meta_item()\n-        ).node\n+        self.parse_seq(&token::LPAREN,\n+                       &token::RPAREN,\n+                       seq_sep_trailing_disallowed(token::COMMA),\n+                       |p| p.parse_meta_item()).node\n     }\n \n     fn parse_optional_meta(&self) -> ~[@ast::meta_item] {"}, {"sha": "83af5bade3a835a73e0d02f84f62fa17437bfeaf", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -22,14 +22,15 @@ use std::io;\n use std::str;\n use std::uint;\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub enum cmnt_style {\n     isolated, // No code on either side of each line of the comment\n     trailing, // Code exists to the left of the comment\n     mixed, // Code before /* foo */ and after the comment\n     blank_line, // Just a manual blank line \"\\n\\n\", for layout\n }\n \n+#[deriving(Clone)]\n pub struct cmnt {\n     style: cmnt_style,\n     lines: ~[~str],\n@@ -324,6 +325,7 @@ fn consume_comment(rdr: @mut StringReader,\n     debug!(\"<<< consume comment\");\n }\n \n+#[deriving(Clone)]\n pub struct lit {\n     lit: ~str,\n     pos: BytePos"}, {"sha": "8db80cdddedbf4ed8864310d9fb64b1a0880d47d", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -20,6 +20,7 @@ use parse::token::{str_to_ident};\n use std::char;\n use std::either;\n use std::u64;\n+use std::util;\n \n pub use ext::tt::transcribe::{TtReader, new_tt_reader};\n \n@@ -93,7 +94,7 @@ fn dup_string_reader(r: @mut StringReader) -> @mut StringReader {\n         col: r.col,\n         curr: r.curr,\n         filemap: r.filemap,\n-        peek_tok: copy r.peek_tok,\n+        peek_tok: r.peek_tok.clone(),\n         peek_span: r.peek_span\n     }\n }\n@@ -103,7 +104,7 @@ impl reader for StringReader {\n     // return the next token. EFFECT: advances the string_reader.\n     fn next_token(@mut self) -> TokenAndSpan {\n         let ret_val = TokenAndSpan {\n-            tok: /*bad*/copy self.peek_tok,\n+            tok: util::replace(&mut self.peek_tok, token::UNDERSCORE),\n             sp: self.peek_span,\n         };\n         string_advance_token(self);\n@@ -114,8 +115,9 @@ impl reader for StringReader {\n     }\n     fn span_diag(@mut self) -> @span_handler { self.span_diagnostic }\n     fn peek(@mut self) -> TokenAndSpan {\n+        // XXX(pcwalton): Bad copy!\n         TokenAndSpan {\n-            tok: /*bad*/copy self.peek_tok,\n+            tok: self.peek_tok.clone(),\n             sp: self.peek_span,\n         }\n     }\n@@ -131,7 +133,7 @@ impl reader for TtReader {\n     fn span_diag(@mut self) -> @span_handler { self.sp_diag }\n     fn peek(@mut self) -> TokenAndSpan {\n         TokenAndSpan {\n-            tok: copy self.cur_tok,\n+            tok: self.cur_tok.clone(),\n             sp: self.cur_span,\n         }\n     }\n@@ -143,8 +145,8 @@ impl reader for TtReader {\n fn string_advance_token(r: @mut StringReader) {\n     match (consume_whitespace_and_comments(r)) {\n         Some(comment) => {\n-            r.peek_tok = copy comment.tok;\n             r.peek_span = comment.sp;\n+            r.peek_tok = comment.tok;\n         },\n         None => {\n             if is_eof(r) {\n@@ -818,15 +820,15 @@ mod test {\n             sp:span {lo:BytePos(21),hi:BytePos(23),expn_info: None}};\n         assert_eq!(tok1,tok2);\n         // the 'main' id is already read:\n-        assert_eq!(copy string_reader.last_pos,BytePos(28));\n+        assert_eq!(string_reader.last_pos.clone(), BytePos(28));\n         // read another token:\n         let tok3 = string_reader.next_token();\n         let tok4 = TokenAndSpan{\n             tok:token::IDENT(str_to_ident(\"main\"), false),\n             sp:span {lo:BytePos(24),hi:BytePos(28),expn_info: None}};\n         assert_eq!(tok3,tok4);\n         // the lparen is already read:\n-        assert_eq!(copy string_reader.last_pos,BytePos(29))\n+        assert_eq!(string_reader.last_pos.clone(), BytePos(29))\n     }\n \n     // check that the given reader produces the desired stream"}, {"sha": "410849b4482734e2cc5348d97ff9dce839a4b8d4", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -79,7 +79,7 @@ pub fn parse_crate_from_file(\n     cfg: ast::crate_cfg,\n     sess: @mut ParseSess\n ) -> @ast::crate {\n-    new_parser_from_file(sess, /*bad*/ copy cfg, input).parse_crate_mod()\n+    new_parser_from_file(sess, /*bad*/ cfg.clone(), input).parse_crate_mod()\n     // why is there no p.abort_if_errors here?\n }\n \n@@ -89,12 +89,10 @@ pub fn parse_crate_from_source_str(\n     cfg: ast::crate_cfg,\n     sess: @mut ParseSess\n ) -> @ast::crate {\n-    let p = new_parser_from_source_str(\n-        sess,\n-        /*bad*/ copy cfg,\n-        name,\n-        source\n-    );\n+    let p = new_parser_from_source_str(sess,\n+                                       /*bad*/ cfg.clone(),\n+                                       name,\n+                                       source);\n     maybe_aborted(p.parse_crate_mod(),p)\n }\n \n@@ -457,7 +455,7 @@ mod test {\n     }\n \n     fn parser_done(p: Parser){\n-        assert_eq!(copy *p.token,token::EOF);\n+        assert_eq!((*p.token).clone(), token::EOF);\n     }\n \n     #[test] fn parse_ident_pat () {"}, {"sha": "148fca36ed29d16ec497682d7e121c79fc821e96", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -314,8 +314,8 @@ impl ParserObsoleteMethods for Parser {\n \n     pub fn try_parse_obsolete_with(&self) -> bool {\n         if *self.token == token::COMMA\n-            && self.token_is_obsolete_ident(\"with\",\n-                                            &self.look_ahead(1u)) {\n+            && self.look_ahead(1,\n+                               |t| self.token_is_obsolete_ident(\"with\", t)) {\n             self.bump();\n         }\n         if self.eat_obsolete_ident(\"with\") {\n@@ -329,8 +329,8 @@ impl ParserObsoleteMethods for Parser {\n \n     pub fn try_parse_obsolete_priv_section(&self, attrs: &[attribute])\n                                            -> bool {\n-        if self.is_keyword(keywords::Priv) && self.look_ahead(1) ==\n-                token::LBRACE {\n+        if self.is_keyword(keywords::Priv) &&\n+                self.look_ahead(1, |t| *t == token::LBRACE) {\n             self.obsolete(*self.span, ObsoletePrivSection);\n             self.eat_keyword(keywords::Priv);\n             self.bump();"}, {"sha": "c67b2aefb6326698b89d2c017e107f993ce37730", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 490, "deletions": 356, "changes": 846, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -97,6 +97,7 @@ use opt_vec::OptVec;\n use std::either::Either;\n use std::either;\n use std::hashmap::HashSet;\n+use std::util;\n use std::vec;\n \n #[deriving(Eq)]\n@@ -111,8 +112,9 @@ type arg_or_capture_item = Either<arg, ()>;\n type item_info = (ident, item_, Option<~[attribute]>);\n \n pub enum item_or_view_item {\n-    // indicates a failure to parse any kind of item:\n-    iovi_none,\n+    // Indicates a failure to parse any kind of item. The attributes are\n+    // returned.\n+    iovi_none(~[attribute]),\n     iovi_item(@item),\n     iovi_foreign_item(@foreign_item),\n     iovi_view_item(view_item)\n@@ -141,7 +143,7 @@ macro_rules! maybe_whole_expr (\n                     Some($p.mk_expr(\n                         ($p).span.lo,\n                         ($p).span.hi,\n-                        expr_path(/* bad */ copy *pt)))\n+                        expr_path(/* bad */ (*pt).clone())))\n                 }\n                 _ => None\n             };\n@@ -158,48 +160,83 @@ macro_rules! maybe_whole_expr (\n \n macro_rules! maybe_whole (\n     ($p:expr, $constructor:ident) => (\n-        match copy *($p).token {\n-            INTERPOLATED(token::$constructor(x)) => {\n-                $p.bump();\n-                return x;\n+        {\n+            let __found__ = match *($p).token {\n+                INTERPOLATED(token::$constructor(_)) => {\n+                    Some(($p).bump_and_get())\n+                }\n+                _ => None\n+            };\n+            match __found__ {\n+                Some(INTERPOLATED(token::$constructor(x))) => {\n+                    return x.clone()\n+                }\n+                _ => {}\n             }\n-            _ => ()\n-       }\n+        }\n     );\n     (deref $p:expr, $constructor:ident) => (\n-        match copy *($p).token {\n-            INTERPOLATED(token::$constructor(x)) => {\n-                $p.bump();\n-                return copy *x;\n+        {\n+            let __found__ = match *($p).token {\n+                INTERPOLATED(token::$constructor(_)) => {\n+                    Some(($p).bump_and_get())\n+                }\n+                _ => None\n+            };\n+            match __found__ {\n+                Some(INTERPOLATED(token::$constructor(x))) => {\n+                    return (*x).clone()\n+                }\n+                _ => {}\n             }\n-            _ => ()\n         }\n     );\n     (Some $p:expr, $constructor:ident) => (\n-        match copy *($p).token {\n-            INTERPOLATED(token::$constructor(x)) => {\n-                $p.bump();\n-                return Some(x);\n+        {\n+            let __found__ = match *($p).token {\n+                INTERPOLATED(token::$constructor(_)) => {\n+                    Some(($p).bump_and_get())\n+                }\n+                _ => None\n+            };\n+            match __found__ {\n+                Some(INTERPOLATED(token::$constructor(x))) => {\n+                    return Some(x.clone()),\n+                }\n+                _ => {}\n             }\n-            _ => ()\n         }\n     );\n     (iovi $p:expr, $constructor:ident) => (\n-        match copy *($p).token {\n-            INTERPOLATED(token::$constructor(x)) => {\n-                $p.bump();\n-                return iovi_item(x);\n+        {\n+            let __found__ = match *($p).token {\n+                INTERPOLATED(token::$constructor(_)) => {\n+                    Some(($p).bump_and_get())\n+                }\n+                _ => None\n+            };\n+            match __found__ {\n+                Some(INTERPOLATED(token::$constructor(x))) => {\n+                    return iovi_item(x.clone())\n+                }\n+                _ => {}\n             }\n-            _ => ()\n         }\n     );\n     (pair_empty $p:expr, $constructor:ident) => (\n-        match copy *($p).token {\n-            INTERPOLATED(token::$constructor(x)) => {\n-                $p.bump();\n-                return (~[], x);\n+        {\n+            let __found__ = match *($p).token {\n+                INTERPOLATED(token::$constructor(_)) => {\n+                    Some(($p).bump_and_get())\n+                }\n+                _ => None\n+            };\n+            match __found__ {\n+                Some(INTERPOLATED(token::$constructor(x))) => {\n+                    return (~[], x.clone())\n+                }\n+                _ => {}\n             }\n-            _ => ()\n         }\n     )\n )\n@@ -227,18 +264,23 @@ pub fn Parser(sess: @mut ParseSess,\n               cfg: ast::crate_cfg,\n               rdr: @reader)\n            -> Parser {\n-    let tok0 = copy rdr.next_token();\n+    let tok0 = rdr.next_token();\n     let interner = get_ident_interner();\n+    let span = tok0.sp;\n+    let placeholder = TokenAndSpan {\n+        tok: token::UNDERSCORE,\n+        sp: span,\n+    };\n \n     Parser {\n         reader: rdr,\n         interner: interner,\n         sess: sess,\n         cfg: cfg,\n-        token: @mut copy tok0.tok,\n-        span: @mut tok0.sp,\n-        last_span: @mut tok0.sp,\n-        buffer: @mut ([copy tok0, .. 4]),\n+        token: @mut tok0.tok,\n+        span: @mut span,\n+        last_span: @mut span,\n+        buffer: @mut ([placeholder, .. 4]),\n         buffer_start: @mut 0,\n         buffer_end: @mut 0,\n         tokens_consumed: @mut 0,\n@@ -534,14 +576,29 @@ impl Parser {\n         let next = if *self.buffer_start == *self.buffer_end {\n             self.reader.next_token()\n         } else {\n-            let next = copy self.buffer[*self.buffer_start];\n-            *self.buffer_start = (*self.buffer_start + 1) & 3;\n-            next\n+            // Avoid token copies with `util::replace`.\n+            let buffer_start = *self.buffer_start as uint;\n+            let next_index = (buffer_start + 1) & 3 as uint;\n+            *self.buffer_start = next_index as int;\n+\n+            let placeholder = TokenAndSpan {\n+                tok: token::UNDERSCORE,\n+                sp: *self.span,\n+            };\n+            util::replace(&mut self.buffer[buffer_start], placeholder)\n         };\n-        *self.token = /*bad*/copy next.tok;\n         *self.span = next.sp;\n+        *self.token = next.tok;\n         *self.tokens_consumed += 1u;\n     }\n+\n+    // Advance the parser by one token and return the bumped token.\n+    pub fn bump_and_get(&self) -> token::Token {\n+        let old_token = util::replace(self.token, token::UNDERSCORE);\n+        self.bump();\n+        old_token\n+    }\n+\n     // EFFECT: replace the current token and span with the given one\n     pub fn replace_token(&self,\n                          next: token::Token,\n@@ -556,13 +613,14 @@ impl Parser {\n         }\n         return (4 - *self.buffer_start) + *self.buffer_end;\n     }\n-    pub fn look_ahead(&self, distance: uint) -> token::Token {\n+    pub fn look_ahead<R>(&self, distance: uint, f: &fn(&token::Token) -> R)\n+                         -> R {\n         let dist = distance as int;\n         while self.buffer_length() < dist {\n             self.buffer[*self.buffer_end] = self.reader.next_token();\n             *self.buffer_end = (*self.buffer_end + 1) & 3;\n         }\n-        return copy self.buffer[(*self.buffer_start + dist - 1) & 3].tok;\n+        f(&self.buffer[(*self.buffer_start + dist - 1) & 3].tok)\n     }\n     pub fn fatal(&self, m: &str) -> ! {\n         self.sess.span_diagnostic.span_fatal(*self.span, m)\n@@ -902,11 +960,13 @@ impl Parser {\n                         one_tuple = true;\n                     }\n                 }\n-                let t = if ts.len() == 1 && !one_tuple {\n-                    copy ts[0].node\n-                } else {\n-                    ty_tup(ts)\n-                };\n+\n+                if ts.len() == 1 && !one_tuple {\n+                    self.expect(&token::RPAREN);\n+                    return ts[0]\n+                }\n+\n+                let t = ty_tup(ts);\n                 self.expect(&token::RPAREN);\n                 t\n             }\n@@ -958,7 +1018,7 @@ impl Parser {\n         } else if self.eat_keyword(keywords::Extern) {\n             // EXTERN FUNCTION\n             self.parse_ty_bare_fn()\n-        } else if self.token_is_closure_keyword(&copy *self.token) {\n+        } else if self.token_is_closure_keyword(self.token) {\n             // CLOSURE\n             let result = self.parse_ty_closure(ast::BorrowedSigil, None);\n             self.obsolete(*self.last_span, ObsoleteBareFnType);\n@@ -990,13 +1050,13 @@ impl Parser {\n             }\n \n             token::IDENT(*) => {\n-                if self.look_ahead(1u) == token::BINOP(token::SLASH) &&\n-                    self.token_is_closure_keyword(&self.look_ahead(2u))\n-                {\n+                if self.look_ahead(1, |t| *t == token::BINOP(token::SLASH)) &&\n+                        self.look_ahead(2, |t|\n+                                        self.token_is_closure_keyword(t)) {\n                     let lifetime = self.parse_lifetime();\n                     self.obsolete(*self.last_span, ObsoleteLifetimeNotation);\n                     return self.parse_ty_closure(sigil, Some(lifetime));\n-                } else if self.token_is_closure_keyword(&copy *self.token) {\n+                } else if self.token_is_closure_keyword(self.token) {\n                     return self.parse_ty_closure(sigil, None);\n                 }\n             }\n@@ -1023,7 +1083,7 @@ impl Parser {\n         // look for `&'lt` or `&'foo ` and interpret `foo` as the region name:\n         let opt_lifetime = self.parse_opt_lifetime();\n \n-        if self.token_is_closure_keyword(&copy *self.token) {\n+        if self.token_is_closure_keyword(self.token) {\n             return self.parse_ty_closure(BorrowedSigil, opt_lifetime);\n         }\n \n@@ -1056,18 +1116,18 @@ impl Parser {\n         } else if *self.token == token::ANDAND {\n             1\n         } else if *self.token == token::BINOP(token::PLUS) {\n-            if self.look_ahead(1) == token::BINOP(token::PLUS) {\n+            if self.look_ahead(1, |t| *t == token::BINOP(token::PLUS)) {\n                 2\n             } else {\n                 1\n             }\n         } else { 0 };\n         if offset == 0 {\n             is_plain_ident(&*self.token)\n-                && self.look_ahead(1) == token::COLON\n+                && self.look_ahead(1, |t| *t == token::COLON)\n         } else {\n-            is_plain_ident(&self.look_ahead(offset))\n-                && self.look_ahead(offset + 1) == token::COLON\n+            self.look_ahead(offset, |t| is_plain_ident(t))\n+                && self.look_ahead(offset + 1, |t| *t == token::COLON)\n         }\n     }\n \n@@ -1133,7 +1193,7 @@ impl Parser {\n             self.obsolete(*self.last_span, ObsoleteFixedLengthVectorType);\n             Some(self.parse_expr())\n         } else if *self.token == token::COMMA &&\n-                self.look_ahead(1) == token::DOTDOT {\n+                self.look_ahead(1, |t| *t == token::DOTDOT) {\n             self.bump();\n             self.bump();\n             Some(self.parse_expr())\n@@ -1165,10 +1225,9 @@ impl Parser {\n         } else if self.eat_keyword(keywords::False) {\n             lit_bool(false)\n         } else {\n-            // XXX: This is a really bad copy!\n-            let tok = copy *self.token;\n-            self.bump();\n-            self.lit_from_token(&tok)\n+            let token = self.bump_and_get();\n+            let lit = self.lit_from_token(&token);\n+            lit\n         };\n         codemap::spanned { node: lit, span: mk_sp(lo, self.last_span.hi) }\n     }\n@@ -1209,12 +1268,17 @@ impl Parser {\n         loop {\n             match *self.token {\n                 token::MOD_SEP => {\n-                    match self.look_ahead(1) {\n-                        token::IDENT(*) => {\n-                            self.bump();\n-                            ids.push(self.parse_ident());\n+                    let is_ident = do self.look_ahead(1) |t| {\n+                        match *t {\n+                            token::IDENT(*) => true,\n+                            _ => false,\n                         }\n-                        _ => break\n+                    };\n+                    if is_ident {\n+                        self.bump();\n+                        ids.push(self.parse_ident());\n+                    } else {\n+                        break\n                     }\n                 }\n                 _ => break\n@@ -1253,7 +1317,7 @@ impl Parser {\n         // be written \"foo/&x\"\n         let rp_slash = {\n             if *self.token == token::BINOP(token::SLASH)\n-                && self.look_ahead(1u) == token::BINOP(token::AND)\n+                && self.look_ahead(1, |t| *t == token::BINOP(token::AND))\n             {\n                 self.bump(); self.bump();\n                 self.obsolete(*self.last_span, ObsoleteLifetimeNotation);\n@@ -1294,10 +1358,12 @@ impl Parser {\n             }\n         };\n \n-        ast::Path { span: mk_sp(lo, hi),\n-                     rp: rp,\n-                     types: tps,\n-                     .. path }\n+        ast::Path {\n+            span: mk_sp(lo, hi),\n+            rp: rp,\n+            types: tps,\n+            .. path.clone()\n+        }\n     }\n \n     // parse a path optionally with type parameters. If 'colons'\n@@ -1328,7 +1394,7 @@ impl Parser {\n \n             // Also accept the (obsolete) syntax `foo/`\n             token::IDENT(*) => {\n-                if self.look_ahead(1u) == token::BINOP(token::SLASH) {\n+                if self.look_ahead(1, |t| *t == token::BINOP(token::SLASH)) {\n                     self.obsolete(*self.last_span, ObsoleteLifetimeNotation);\n                     Some(self.parse_lifetime())\n                 } else {\n@@ -1589,7 +1655,7 @@ impl Parser {\n                 // Nonempty vector.\n                 let first_expr = self.parse_expr();\n                 if *self.token == token::COMMA &&\n-                        self.look_ahead(1) == token::DOTDOT {\n+                        self.look_ahead(1, |t| *t == token::DOTDOT) {\n                     // Repeating vector syntax: [ 0, ..512 ]\n                     self.bump();\n                     self.bump();\n@@ -1658,12 +1724,11 @@ impl Parser {\n                 };\n \n                 let ket = token::flip_delimiter(&*self.token);\n-                let tts = self.parse_unspanned_seq(\n-                    &copy *self.token,\n-                    &ket,\n-                    seq_sep_none(),\n-                    |p| p.parse_token_tree()\n-                );\n+                self.bump();\n+\n+                let tts = self.parse_seq_to_end(&ket,\n+                                                seq_sep_none(),\n+                                                |p| p.parse_token_tree());\n                 let hi = self.span.hi;\n \n                 return self.mk_mac_expr(lo, hi, mac_invoc_tt(pth, tts));\n@@ -1809,8 +1874,7 @@ impl Parser {\n             self.bump();\n             (None, zerok)\n         } else {\n-            let sep = copy *self.token;\n-            self.bump();\n+            let sep = self.bump_and_get();\n             if *self.token == token::BINOP(token::STAR)\n                 || *self.token == token::BINOP(token::PLUS) {\n                 let zerok = *self.token == token::BINOP(token::STAR);\n@@ -1877,9 +1941,7 @@ impl Parser {\n \n         // turn the next token into a tt_tok:\n         fn parse_any_tt_tok(p: &Parser) -> token_tree{\n-            let res = tt_tok(*p.span, copy *p.token);\n-            p.bump();\n-            res\n+            tt_tok(*p.span, p.bump_and_get())\n         }\n \n         match *self.token {\n@@ -1925,32 +1987,25 @@ impl Parser {\n         let name_idx = @mut 0u;\n         match *self.token {\n             token::LBRACE | token::LPAREN | token::LBRACKET => {\n-                self.parse_matcher_subseq(\n-                    name_idx,\n-                    copy *self.token,\n-                    // tjc: not sure why we need a copy\n-                    token::flip_delimiter(self.token)\n-                )\n+                let other_delimiter = token::flip_delimiter(self.token);\n+                self.bump();\n+                self.parse_matcher_subseq_upto(name_idx, &other_delimiter)\n             }\n             _ => self.fatal(\"expected open delimiter\")\n         }\n     }\n \n-\n     // This goofy function is necessary to correctly match parens in matchers.\n     // Otherwise, `$( ( )` would be a valid matcher, and `$( () )` would be\n     // invalid. It's similar to common::parse_seq.\n-    pub fn parse_matcher_subseq(&self,\n-                                name_idx: @mut uint,\n-                                bra: token::Token,\n-                                ket: token::Token)\n-                                -> ~[matcher] {\n+    pub fn parse_matcher_subseq_upto(&self,\n+                                     name_idx: @mut uint,\n+                                     ket: &token::Token)\n+                                     -> ~[matcher] {\n         let mut ret_val = ~[];\n         let mut lparens = 0u;\n \n-        self.expect(&bra);\n-\n-        while *self.token != ket || lparens > 0u {\n+        while *self.token != *ket || lparens > 0u {\n             if *self.token == token::LPAREN { lparens += 1u; }\n             if *self.token == token::RPAREN { lparens -= 1u; }\n             ret_val.push(self.parse_matcher(name_idx));\n@@ -1968,11 +2023,9 @@ impl Parser {\n             self.bump();\n             if *self.token == token::LPAREN {\n                 let name_idx_lo = *name_idx;\n-                let ms = self.parse_matcher_subseq(\n-                    name_idx,\n-                    token::LPAREN,\n-                    token::RPAREN\n-                );\n+                self.bump();\n+                let ms = self.parse_matcher_subseq_upto(name_idx,\n+                                                        &token::RPAREN);\n                 if ms.len() == 0u {\n                     self.fatal(\"repetition body must be nonempty\");\n                 }\n@@ -1987,9 +2040,7 @@ impl Parser {\n                 m\n             }\n         } else {\n-            let m = match_tok(copy *self.token);\n-            self.bump();\n-            m\n+            match_tok(self.bump_and_get())\n         };\n \n         return spanned(lo, self.span.hi, m);\n@@ -2094,16 +2145,15 @@ impl Parser {\n     // parse an expression of binops of at least min_prec precedence\n     pub fn parse_more_binops(&self, lhs: @expr, min_prec: uint) -> @expr {\n         if self.expr_is_complete(lhs) { return lhs; }\n-        let peeked = copy *self.token;\n-        if peeked == token::BINOP(token::OR) &&\n+        if token::BINOP(token::OR) == *self.token &&\n             (*self.restriction == RESTRICT_NO_BAR_OP ||\n              *self.restriction == RESTRICT_NO_BAR_OR_DOUBLEBAR_OP) {\n             lhs\n-        } else if peeked == token::OROR &&\n+        } else if token::OROR == *self.token &&\n             *self.restriction == RESTRICT_NO_BAR_OR_DOUBLEBAR_OP {\n             lhs\n         } else {\n-            let cur_opt = token_to_binop(peeked);\n+            let cur_opt = token_to_binop(self.token);\n             match cur_opt {\n                 Some(cur_op) => {\n                     let cur_prec = operator_prec(cur_op);\n@@ -2290,23 +2340,31 @@ impl Parser {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n-                let args = vec::append(copy *args, [last_arg]);\n+                let args = vec::append((*args).clone(), [last_arg]);\n                 self.mk_expr(lo, block.span.hi, expr_call(f, args, sugar))\n             }\n             expr_method_call(_, f, i, ref tps, ref args, NoSugar) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n-                let args = vec::append(copy *args, [last_arg]);\n+                let args = vec::append((*args).clone(), [last_arg]);\n                 self.mk_expr(lo, block.span.hi,\n-                             self.mk_method_call(f, i, copy *tps, args, sugar))\n+                             self.mk_method_call(f,\n+                                                 i,\n+                                                 (*tps).clone(),\n+                                                 args,\n+                                                 sugar))\n             }\n             expr_field(f, i, ref tps) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n                 self.mk_expr(lo, block.span.hi,\n-                             self.mk_method_call(f, i, copy *tps, ~[last_arg], sugar))\n+                             self.mk_method_call(f,\n+                                                 i,\n+                                                 (*tps).clone(),\n+                                                 ~[last_arg],\n+                                                 sugar))\n             }\n             expr_path(*) | expr_call(*) | expr_method_call(*) |\n                 expr_paren(*) => {\n@@ -2343,7 +2401,7 @@ impl Parser {\n         let is_loop_header =\n             *self.token == token::LBRACE\n             || (is_ident(&*self.token)\n-                && self.look_ahead(1) == token::LBRACE);\n+                && self.look_ahead(1, |t| *t == token::LBRACE));\n \n         if is_loop_header {\n             // This is a loop body\n@@ -2373,11 +2431,10 @@ impl Parser {\n \n     // For distingishing between record literals and blocks\n     fn looking_at_record_literal(&self) -> bool {\n-        let lookahead = self.look_ahead(1);\n         *self.token == token::LBRACE &&\n-            (token::is_keyword(keywords::Mut, &lookahead) ||\n-             (is_plain_ident(&lookahead) &&\n-              self.look_ahead(2) == token::COLON))\n+            (self.look_ahead(1, |t| token::is_keyword(keywords::Mut, t)) ||\n+             (self.look_ahead(1, |t| token::is_plain_ident(t)) &&\n+              self.look_ahead(2, |t| *t == token::COLON)))\n     }\n \n     fn parse_match_expr(&self) -> @expr {\n@@ -2388,7 +2445,9 @@ impl Parser {\n         while *self.token != token::RBRACE {\n             let pats = self.parse_pats();\n             let mut guard = None;\n-            if self.eat_keyword(keywords::If) { guard = Some(self.parse_expr()); }\n+            if self.eat_keyword(keywords::If) {\n+                guard = Some(self.parse_expr());\n+            }\n             self.expect(&token::FAT_ARROW);\n             let expr = self.parse_expr_res(RESTRICT_STMT_EXPR);\n \n@@ -2554,12 +2613,21 @@ impl Parser {\n         maybe_whole!(self, nt_pat);\n \n         let lo = self.span.lo;\n-        let mut hi = self.span.hi;\n+        let mut hi;\n         let pat;\n-        match /*bad*/ copy *self.token {\n+        match *self.token {\n             // parse _\n-          token::UNDERSCORE => { self.bump(); pat = pat_wild; }\n-            // parse @pat\n+          token::UNDERSCORE => {\n+            self.bump();\n+            pat = pat_wild;\n+            hi = self.last_span.hi;\n+            return @ast::pat {\n+                id: self.get_id(),\n+                node: pat,\n+                span: mk_sp(lo, hi)\n+            }\n+          }\n+          // parse @pat\n           token::AT => {\n             self.bump();\n             let sub = self.parse_pat();\n@@ -2580,6 +2648,12 @@ impl Parser {\n               }\n               _ => pat_box(sub)\n             };\n+            hi = self.last_span.hi;\n+            return @ast::pat {\n+                id: self.get_id(),\n+                node: pat,\n+                span: mk_sp(lo, hi)\n+            }\n           }\n           token::TILDE => {\n             // parse ~pat\n@@ -2602,6 +2676,12 @@ impl Parser {\n               }\n               _ => pat_uniq(sub)\n             };\n+            hi = self.last_span.hi;\n+            return @ast::pat {\n+                id: self.get_id(),\n+                node: pat,\n+                span: mk_sp(lo, hi)\n+            }\n           }\n           token::BINOP(token::AND) => {\n               // parse &pat\n@@ -2623,7 +2703,13 @@ impl Parser {\n                       pat_lit(vst)\n                   }\n               _ => pat_region(sub)\n-              };\n+            };\n+            hi = self.last_span.hi;\n+            return @ast::pat {\n+                id: self.get_id(),\n+                node: pat,\n+                span: mk_sp(lo, hi)\n+            }\n           }\n           token::LBRACE => {\n             self.bump();\n@@ -2632,6 +2718,12 @@ impl Parser {\n             self.bump();\n             self.obsolete(*self.span, ObsoleteRecordPattern);\n             pat = pat_wild;\n+            hi = self.last_span.hi;\n+            return @ast::pat {\n+                id: self.get_id(),\n+                node: pat,\n+                span: mk_sp(lo, hi)\n+            }\n           }\n           token::LPAREN => {\n             // parse (pat,pat,pat,...) as tuple\n@@ -2646,7 +2738,7 @@ impl Parser {\n                 pat = pat_lit(expr);\n             } else {\n                 let mut fields = ~[self.parse_pat()];\n-                if self.look_ahead(1) != token::RPAREN {\n+                if self.look_ahead(1, |t| *t != token::RPAREN) {\n                     while *self.token == token::COMMA {\n                         self.bump();\n                         fields.push(self.parse_pat());\n@@ -2657,6 +2749,12 @@ impl Parser {\n                 self.expect(&token::RPAREN);\n                 pat = pat_tup(fields);\n             }\n+            hi = self.last_span.hi;\n+            return @ast::pat {\n+                id: self.get_id(),\n+                node: pat,\n+                span: mk_sp(lo, hi)\n+            }\n           }\n           token::LBRACKET => {\n             // parse [pat,pat,...] as vector pattern\n@@ -2666,118 +2764,130 @@ impl Parser {\n             hi = self.span.hi;\n             self.expect(&token::RBRACKET);\n             pat = ast::pat_vec(before, slice, after);\n+            hi = self.last_span.hi;\n+            return @ast::pat {\n+                id: self.get_id(),\n+                node: pat,\n+                span: mk_sp(lo, hi)\n+            }\n           }\n-          ref tok => {\n-            if !is_ident_or_path(tok)\n+          _ => {}\n+        }\n+\n+        let tok = self.token;\n+        if !is_ident_or_path(tok)\n                 || self.is_keyword(keywords::True)\n-                || self.is_keyword(keywords::False)\n-            {\n-                // Parse an expression pattern or exp .. exp.\n-                //\n-                // These expressions are limited to literals (possibly\n-                // preceded by unary-minus) or identifiers.\n-                let val = self.parse_literal_maybe_minus();\n-                if self.eat(&token::DOTDOT) {\n-                    let end = if is_ident_or_path(tok) {\n-                        let path = self.parse_path_with_tps(true);\n-                        let hi = self.span.hi;\n-                        self.mk_expr(lo, hi, expr_path(path))\n-                    } else {\n-                        self.parse_literal_maybe_minus()\n-                    };\n-                    pat = pat_range(val, end);\n+                || self.is_keyword(keywords::False) {\n+            // Parse an expression pattern or exp .. exp.\n+            //\n+            // These expressions are limited to literals (possibly\n+            // preceded by unary-minus) or identifiers.\n+            let val = self.parse_literal_maybe_minus();\n+            if self.eat(&token::DOTDOT) {\n+                let end = if is_ident_or_path(tok) {\n+                    let path = self.parse_path_with_tps(true);\n+                    let hi = self.span.hi;\n+                    self.mk_expr(lo, hi, expr_path(path))\n                 } else {\n-                    pat = pat_lit(val);\n-                }\n-            } else if self.eat_keyword(keywords::Ref) {\n-                // parse ref pat\n-                let mutbl = self.parse_mutability();\n-                pat = self.parse_pat_ident(bind_by_ref(mutbl));\n-            } else if self.eat_keyword(keywords::Copy) {\n-                // parse copy pat\n-                self.obsolete(*self.span, ObsoletePatternCopyKeyword);\n-                pat = self.parse_pat_ident(bind_infer);\n+                    self.parse_literal_maybe_minus()\n+                };\n+                pat = pat_range(val, end);\n             } else {\n-                let can_be_enum_or_struct;\n-                match self.look_ahead(1) {\n+                pat = pat_lit(val);\n+            }\n+        } else if self.eat_keyword(keywords::Ref) {\n+            // parse ref pat\n+            let mutbl = self.parse_mutability();\n+            pat = self.parse_pat_ident(bind_by_ref(mutbl));\n+        } else if self.eat_keyword(keywords::Copy) {\n+            // parse copy pat\n+            self.obsolete(*self.span, ObsoletePatternCopyKeyword);\n+            pat = self.parse_pat_ident(bind_infer);\n+        } else {\n+            let can_be_enum_or_struct = do self.look_ahead(1) |t| {\n+                match *t {\n                     token::LPAREN | token::LBRACKET | token::LT |\n-                    token::LBRACE | token::MOD_SEP =>\n-                        can_be_enum_or_struct = true,\n-                    _ =>\n-                        can_be_enum_or_struct = false\n+                    token::LBRACE | token::MOD_SEP => true,\n+                    _ => false,\n                 }\n+            };\n \n-                if self.look_ahead(1) == token::DOTDOT {\n-                    let start = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n-                    self.eat(&token::DOTDOT);\n-                    let end = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n-                    pat = pat_range(start, end);\n+            if self.look_ahead(1, |t| *t == token::DOTDOT) {\n+                let start = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n+                self.eat(&token::DOTDOT);\n+                let end = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n+                pat = pat_range(start, end);\n+            } else if is_plain_ident(&*self.token) && !can_be_enum_or_struct {\n+                let name = self.parse_path_without_tps();\n+                let sub;\n+                if self.eat(&token::AT) {\n+                    // parse foo @ pat\n+                    sub = Some(self.parse_pat());\n+                } else {\n+                    // or just foo\n+                    sub = None;\n                 }\n-                else if is_plain_ident(&*self.token) && !can_be_enum_or_struct {\n-                    let name = self.parse_path_without_tps();\n-                    let sub;\n-                    if self.eat(&token::AT) {\n-                        // parse foo @ pat\n-                        sub = Some(self.parse_pat());\n-                    } else {\n-                        // or just foo\n-                        sub = None;\n+                pat = pat_ident(bind_infer, name, sub);\n+            } else {\n+                // parse an enum pat\n+                let enum_path = self.parse_path_with_tps(true);\n+                match *self.token {\n+                    token::LBRACE => {\n+                        self.bump();\n+                        let (fields, etc) =\n+                            self.parse_pat_fields();\n+                        self.bump();\n+                        pat = pat_struct(enum_path, fields, etc);\n                     }\n-                    pat = pat_ident(bind_infer, name, sub);\n-                } else {\n-                    // parse an enum pat\n-                    let enum_path = self.parse_path_with_tps(true);\n-                    match *self.token {\n-                        token::LBRACE => {\n-                            self.bump();\n-                            let (fields, etc) =\n-                                self.parse_pat_fields();\n-                            self.bump();\n-                            pat = pat_struct(enum_path, fields, etc);\n-                        }\n-                        _ => {\n-                            let mut args: ~[@pat] = ~[];\n-                            match *self.token {\n-                              token::LPAREN => match self.look_ahead(1u) {\n-                                token::BINOP(token::STAR) => {\n-                                    // This is a \"top constructor only\" pat\n-                                      self.bump(); self.bump();\n-                                      self.expect(&token::RPAREN);\n-                                      pat = pat_enum(enum_path, None);\n-                                  }\n-                                _ => {\n-                                    args = self.parse_unspanned_seq(\n-                                        &token::LPAREN,\n-                                        &token::RPAREN,\n-                                        seq_sep_trailing_disallowed(\n-                                            token::COMMA\n-                                        ),\n-                                        |p| p.parse_pat()\n-                                    );\n-                                    pat = pat_enum(enum_path, Some(args));\n-                                  }\n-                              },\n-                              _ => {\n-                                  if enum_path.idents.len()==1u {\n-                                      // it could still be either an enum\n-                                      // or an identifier pattern, resolve\n-                                      // will sort it out:\n-                                      pat = pat_ident(bind_infer,\n-                                                      enum_path,\n-                                                      None);\n-                                  } else {\n-                                      pat = pat_enum(enum_path, Some(args));\n-                                  }\n-                              }\n+                    _ => {\n+                        let mut args: ~[@pat] = ~[];\n+                        match *self.token {\n+                          token::LPAREN => {\n+                            let is_star = do self.look_ahead(1) |t| {\n+                                match *t {\n+                                    token::BINOP(token::STAR) => true,\n+                                    _ => false,\n+                                }\n+                            };\n+                            if is_star {\n+                                // This is a \"top constructor only\" pat\n+                                self.bump();\n+                                self.bump();\n+                                self.expect(&token::RPAREN);\n+                                pat = pat_enum(enum_path, None);\n+                            } else {\n+                                args = self.parse_unspanned_seq(\n+                                    &token::LPAREN,\n+                                    &token::RPAREN,\n+                                    seq_sep_trailing_disallowed(token::COMMA),\n+                                    |p| p.parse_pat()\n+                                );\n+                                pat = pat_enum(enum_path, Some(args));\n                             }\n+                          },\n+                          _ => {\n+                              if enum_path.idents.len()==1u {\n+                                  // it could still be either an enum\n+                                  // or an identifier pattern, resolve\n+                                  // will sort it out:\n+                                  pat = pat_ident(bind_infer,\n+                                                  enum_path,\n+                                                  None);\n+                              } else {\n+                                  pat = pat_enum(enum_path, Some(args));\n+                              }\n+                          }\n                         }\n                     }\n                 }\n             }\n-            hi = self.last_span.hi;\n-          }\n         }\n-        @ast::pat { id: self.get_id(), node: pat, span: mk_sp(lo, hi) }\n+        hi = self.last_span.hi;\n+        @ast::pat {\n+            id: self.get_id(),\n+            node: pat,\n+            span: mk_sp(lo, hi),\n+        }\n     }\n \n     // parse ident or ident @ pat\n@@ -2878,23 +2988,22 @@ impl Parser {\n     pub fn parse_stmt(&self, item_attrs: ~[attribute]) -> @stmt {\n         maybe_whole!(self, nt_stmt);\n \n-        fn check_expected_item(p: &Parser, current_attrs: &[attribute]) {\n+        fn check_expected_item(p: &Parser, found_attrs: bool) {\n             // If we have attributes then we should have an item\n-            if !current_attrs.is_empty() {\n-                p.span_err(*p.last_span,\n-                           \"expected item after attributes\");\n+            if found_attrs {\n+                p.span_err(*p.last_span, \"expected item after attributes\");\n             }\n         }\n \n         let lo = self.span.lo;\n         if self.is_keyword(keywords::Let) {\n-            check_expected_item(self, item_attrs);\n+            check_expected_item(self, !item_attrs.is_empty());\n             self.expect_keyword(keywords::Let);\n             let decl = self.parse_let();\n             return @spanned(lo, decl.span.hi, stmt_decl(decl, self.get_id()));\n         } else if is_ident(&*self.token)\n             && !token::is_any_keyword(self.token)\n-            && self.look_ahead(1) == token::NOT {\n+            && self.look_ahead(1, |t| *t == token::NOT) {\n             // parse a macro invocation. Looks like there's serious\n             // overlap here; if this clause doesn't catch it (and it\n             // won't, for brace-delimited macros) it will fall through\n@@ -2908,7 +3017,7 @@ impl Parser {\n             // somewhat awkward... and probably undocumented. Of course,\n             // I could just be wrong.\n \n-            check_expected_item(self, item_attrs);\n+            check_expected_item(self, !item_attrs.is_empty());\n \n             // Potential trouble: if we allow macros with paths instead of\n             // idents, we'd need to look ahead past the whole path here...\n@@ -2944,8 +3053,8 @@ impl Parser {\n             }\n \n         } else {\n-            match self.parse_item_or_view_item(/*bad*/ copy item_attrs,\n-                                                           false) {\n+            let found_attrs = !item_attrs.is_empty();\n+            match self.parse_item_or_view_item(item_attrs, false) {\n                 iovi_item(i) => {\n                     let hi = i.span.hi;\n                     let decl = @spanned(lo, hi, decl_item(i));\n@@ -2958,10 +3067,10 @@ impl Parser {\n                 iovi_foreign_item(_) => {\n                     self.fatal(\"foreign items are not allowed here\");\n                 }\n-                iovi_none() => { /* fallthrough */ }\n+                iovi_none(_) => { /* fallthrough */ }\n             }\n \n-            check_expected_item(self, item_attrs);\n+            check_expected_item(self, found_attrs);\n \n             // Remainder are line-expr stmts.\n             let e = self.parse_expr_res(RESTRICT_STMT_EXPR);\n@@ -3056,48 +3165,66 @@ impl Parser {\n                     match stmt.node {\n                         stmt_expr(e, stmt_id) => {\n                             // expression without semicolon\n-                            match copy *self.token {\n+                            let has_semi;\n+                            match *self.token {\n                                 token::SEMI => {\n-                                    self.bump();\n-                                    stmts.push(@codemap::spanned {\n-                                        node: stmt_semi(e, stmt_id),\n-                                        .. copy *stmt});\n+                                    has_semi = true;\n                                 }\n                                 token::RBRACE => {\n+                                    has_semi = false;\n                                     expr = Some(e);\n                                 }\n-                                t => {\n+                                ref t => {\n+                                    has_semi = false;\n                                     if classify::stmt_ends_with_semi(stmt) {\n                                         self.fatal(\n                                             fmt!(\n                                                 \"expected `;` or `}` after \\\n                                                  expression but found `%s`\",\n-                                                self.token_to_str(&t)\n+                                                self.token_to_str(t)\n                                             )\n                                         );\n                                     }\n                                     stmts.push(stmt);\n                                 }\n                             }\n+\n+                            if has_semi {\n+                                self.bump();\n+                                stmts.push(@codemap::spanned {\n+                                    node: stmt_semi(e, stmt_id),\n+                                    span: stmt.span,\n+                                });\n+                            }\n                         }\n                         stmt_mac(ref m, _) => {\n                             // statement macro; might be an expr\n+                            let has_semi;\n                             match *self.token {\n                                 token::SEMI => {\n-                                    self.bump();\n-                                    stmts.push(@codemap::spanned {\n-                                        node: stmt_mac(copy *m, true),\n-                                        .. copy *stmt});\n+                                    has_semi = true;\n                                 }\n                                 token::RBRACE => {\n                                     // if a block ends in `m!(arg)` without\n                                     // a `;`, it must be an expr\n+                                    has_semi = false;\n                                     expr = Some(\n                                         self.mk_mac_expr(stmt.span.lo,\n                                                          stmt.span.hi,\n-                                                         copy m.node));\n+                                                         m.node.clone()));\n+                                }\n+                                _ => {\n+                                    has_semi = false;\n+                                    stmts.push(stmt);\n                                 }\n-                                _ => { stmts.push(stmt); }\n+                            }\n+\n+                            if has_semi {\n+                                self.bump();\n+                                stmts.push(@codemap::spanned {\n+                                    node: stmt_mac((*m).clone(), true),\n+                                    span: stmt.span,\n+                                });\n                             }\n                         }\n                         _ => { // all other kinds of statements:\n@@ -3302,10 +3429,10 @@ impl Parser {\n             p: &Parser\n         ) -> ast::explicit_self_ {\n             // We need to make sure it isn't a mode or a type\n-            if token::is_keyword(keywords::Self, &p.look_ahead(1)) ||\n-                ((token::is_keyword(keywords::Const, &p.look_ahead(1)) ||\n-                  token::is_keyword(keywords::Mut, &p.look_ahead(1))) &&\n-                 token::is_keyword(keywords::Self, &p.look_ahead(2))) {\n+            if p.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) ||\n+                ((p.look_ahead(1, |t| token::is_keyword(keywords::Const, t)) ||\n+                  p.look_ahead(1, |t| token::is_keyword(keywords::Mut, t))) &&\n+                 p.look_ahead(2, |t| token::is_keyword(keywords::Self, t))) {\n \n                 p.bump();\n                 let mutability = p.parse_mutability();\n@@ -3326,25 +3453,30 @@ impl Parser {\n             //\n             // We already know that the current token is `&`.\n \n-            if (token::is_keyword(keywords::Self, &this.look_ahead(1))) {\n+            if this.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) {\n                 this.bump();\n                 this.expect_self_ident();\n                 sty_region(None, m_imm)\n-            } else if (this.token_is_mutability(&this.look_ahead(1)) &&\n-                       token::is_keyword(keywords::Self, &this.look_ahead(2))) {\n+            } else if this.look_ahead(1, |t| this.token_is_mutability(t)) &&\n+                    this.look_ahead(2,\n+                                    |t| token::is_keyword(keywords::Self,\n+                                                          t)) {\n                 this.bump();\n                 let mutability = this.parse_mutability();\n                 this.expect_self_ident();\n                 sty_region(None, mutability)\n-            } else if (this.token_is_lifetime(&this.look_ahead(1)) &&\n-                       token::is_keyword(keywords::Self, &this.look_ahead(2))) {\n+            } else if this.look_ahead(1, |t| this.token_is_lifetime(t)) &&\n+                       this.look_ahead(2,\n+                                       |t| token::is_keyword(keywords::Self,\n+                                                             t)) {\n                 this.bump();\n                 let lifetime = this.parse_lifetime();\n                 this.expect_self_ident();\n                 sty_region(Some(lifetime), m_imm)\n-            } else if (this.token_is_lifetime(&this.look_ahead(1)) &&\n-                       this.token_is_mutability(&this.look_ahead(2)) &&\n-                       token::is_keyword(keywords::Self, &this.look_ahead(3))) {\n+            } else if this.look_ahead(1, |t| this.token_is_lifetime(t)) &&\n+                      this.look_ahead(2, |t| this.token_is_mutability(t)) &&\n+                      this.look_ahead(3, |t| token::is_keyword(keywords::Self,\n+                                                               t)) {\n                 this.bump();\n                 let lifetime = this.parse_lifetime();\n                 let mutability = this.parse_mutability();\n@@ -3563,7 +3695,7 @@ impl Parser {\n             let opt_trait_ref = match ty.node {\n                 ty_path(ref path, None, node_id) => {\n                     Some(trait_ref {\n-                        path: /* bad */ copy *path,\n+                        path: /* bad */ (*path).clone(),\n                         ref_id: node_id\n                     })\n                 }\n@@ -3768,17 +3900,18 @@ impl Parser {\n \n     // given a termination token and a vector of already-parsed\n     // attributes (of length 0 or 1), parse all of the items in a module\n-    fn parse_mod_items(&self, term: token::Token,\n-                       first_item_attrs: ~[attribute]) -> _mod {\n+    fn parse_mod_items(&self,\n+                       term: token::Token,\n+                       first_item_attrs: ~[attribute])\n+                       -> _mod {\n         // parse all of the items up to closing or an attribute.\n         // view items are legal here.\n         let ParsedItemsAndViewItems {\n             attrs_remaining: attrs_remaining,\n             view_items: view_items,\n             items: starting_items,\n             _\n-        } = self.parse_items_and_view_items(first_item_attrs,\n-                                            true, true);\n+        } = self.parse_items_and_view_items(first_item_attrs, true, true);\n         let mut items: ~[@item] = starting_items;\n         let attrs_remaining_len = attrs_remaining.len();\n \n@@ -3793,25 +3926,19 @@ impl Parser {\n             }\n             debug!(\"parse_mod_items: parse_item_or_view_item(attrs=%?)\",\n                    attrs);\n-            match self.parse_item_or_view_item(\n-                /*bad*/ copy attrs,\n-                true // macros allowed\n-            ) {\n+            match self.parse_item_or_view_item(attrs,\n+                                               true /* macros allowed */) {\n               iovi_item(item) => items.push(item),\n               iovi_view_item(view_item) => {\n-                self.span_fatal(view_item.span, \"view items must be  declared at the top of the \\\n-                                                 module\");\n+                self.span_fatal(view_item.span,\n+                                \"view items must be declared at the top of \\\n+                                 the module\");\n               }\n               _ => {\n-                self.fatal(\n-                    fmt!(\n-                        \"expected item but found `%s`\",\n-                        self.this_token_to_str()\n-                    )\n-                );\n+                self.fatal(fmt!(\"expected item but found `%s`\",\n+                                self.this_token_to_str()));\n               }\n             }\n-            debug!(\"parse_mod_items: attrs=%?\", attrs);\n         }\n \n         if first && attrs_remaining_len > 0u {\n@@ -3834,7 +3961,7 @@ impl Parser {\n     }\n \n     // parse a `mod <foo> { ... }` or `mod <foo>;` item\n-    fn parse_item_mod(&self, outer_attrs: ~[ast::attribute]) -> item_info {\n+    fn parse_item_mod(&self, outer_attrs: &[ast::attribute]) -> item_info {\n         let id_span = *self.span;\n         let id = self.parse_ident();\n         if *self.token == token::SEMI {\n@@ -3853,7 +3980,7 @@ impl Parser {\n         }\n     }\n \n-    fn push_mod_path(&self, id: ident, attrs: ~[ast::attribute]) {\n+    fn push_mod_path(&self, id: ident, attrs: &[ast::attribute]) {\n         let default_path = token::interner_get(id.name);\n         let file_path = match ::attr::first_attr_value_str_by_name(\n             attrs, \"path\") {\n@@ -3869,17 +3996,18 @@ impl Parser {\n     }\n \n     // read a module from a source file.\n-    fn eval_src_mod(&self, id: ast::ident,\n-                    outer_attrs: ~[ast::attribute],\n-                    id_sp: span) -> (ast::item_, ~[ast::attribute]) {\n-\n+    fn eval_src_mod(&self,\n+                    id: ast::ident,\n+                    outer_attrs: &[ast::attribute],\n+                    id_sp: span)\n+                    -> (ast::item_, ~[ast::attribute]) {\n         let prefix = Path(self.sess.cm.span_to_filename(*self.span));\n         let prefix = prefix.dir_path();\n         let mod_path_stack = &*self.mod_path_stack;\n         let mod_path = Path(\".\").push_many(*mod_path_stack);\n         let default_path = token::interner_get(id.name).to_owned() + \".rs\";\n         let file_path = match ::attr::first_attr_value_str_by_name(\n-            outer_attrs, \"path\") {\n+                outer_attrs, \"path\") {\n             Some(d) => {\n                 let path = Path(d);\n                 if !path.is_absolute {\n@@ -3891,14 +4019,17 @@ impl Parser {\n             None => mod_path.push(default_path)\n         };\n \n-        self.eval_src_mod_from_path(prefix, file_path,\n-                                    outer_attrs, id_sp)\n+        self.eval_src_mod_from_path(prefix,\n+                                    file_path,\n+                                    outer_attrs.to_owned(),\n+                                    id_sp)\n     }\n \n-    fn eval_src_mod_from_path(&self, prefix: Path, path: Path,\n+    fn eval_src_mod_from_path(&self,\n+                              prefix: Path,\n+                              path: Path,\n                               outer_attrs: ~[ast::attribute],\n-                              id_sp: span\n-                             ) -> (ast::item_, ~[ast::attribute]) {\n+                              id_sp: span) -> (ast::item_, ~[ast::attribute]) {\n \n         let full_path = if path.is_absolute {\n             path\n@@ -3924,8 +4055,10 @@ impl Parser {\n         self.sess.included_mod_stack.push(full_path.clone());\n \n         let p0 =\n-            new_sub_parser_from_file(self.sess, copy self.cfg,\n-                                     &full_path, id_sp);\n+            new_sub_parser_from_file(self.sess,\n+                                     self.cfg.clone(),\n+                                     &full_path,\n+                                     id_sp);\n         let (inner, next) = p0.parse_inner_attrs_and_next();\n         let mod_attrs = vec::append(outer_attrs, inner);\n         let first_item_outer_attrs = next;\n@@ -4074,7 +4207,7 @@ impl Parser {\n \n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident,\n                                           item_foreign_mod(m), visibility,\n-                                          maybe_append(/*bad*/ copy attrs,\n+                                          maybe_append(attrs,\n                                                        Some(inner))));\n         }\n \n@@ -4087,7 +4220,7 @@ impl Parser {\n         self.expect(&token::SEMI);\n         iovi_view_item(ast::view_item {\n             node: view_item_extern_mod(ident, metadata, self.get_id()),\n-            attrs: copy attrs,\n+            attrs: attrs,\n             vis: visibility,\n             span: mk_sp(lo, self.last_span.hi)\n         })\n@@ -4253,8 +4386,8 @@ impl Parser {\n         }\n     }\n \n-    fn fn_expr_lookahead(&self, tok: token::Token) -> bool {\n-        match tok {\n+    fn fn_expr_lookahead(&self, tok: &token::Token) -> bool {\n+        match *tok {\n           token::LPAREN | token::AT | token::TILDE | token::BINOP(_) => true,\n           _ => false\n         }\n@@ -4304,11 +4437,10 @@ impl Parser {\n     // flags; on failure, return iovi_none.\n     // NB: this function no longer parses the items inside an\n     // extern mod.\n-    fn parse_item_or_view_item(\n-        &self,\n-        attrs: ~[attribute],\n-        macros_allowed: bool\n-    ) -> item_or_view_item {\n+    fn parse_item_or_view_item(&self,\n+                               attrs: ~[attribute],\n+                               macros_allowed: bool)\n+                               -> item_or_view_item {\n         maybe_whole!(iovi self, nt_item);\n         let lo = self.span.lo;\n \n@@ -4348,7 +4480,7 @@ impl Parser {\n         // the rest are all guaranteed to be items:\n         if (self.is_keyword(keywords::Const) ||\n             (self.is_keyword(keywords::Static) &&\n-             !token::is_keyword(keywords::Fn, &self.look_ahead(1)))) {\n+             self.look_ahead(1, |t| !token::is_keyword(keywords::Fn, t)))) {\n             // CONST / STATIC ITEM\n             if self.is_keyword(keywords::Const) {\n                 self.obsolete(*self.span, ObsoleteConstItem);\n@@ -4360,7 +4492,7 @@ impl Parser {\n                                           maybe_append(attrs, extra_attrs)));\n         }\n         if self.is_keyword(keywords::Fn) &&\n-            !self.fn_expr_lookahead(self.look_ahead(1u)) {\n+                self.look_ahead(1, |f| !self.fn_expr_lookahead(f)) {\n             // FUNCTION ITEM\n             self.bump();\n             let (ident, item_, extra_attrs) =\n@@ -4380,7 +4512,7 @@ impl Parser {\n                                           maybe_append(attrs, extra_attrs)));\n         }\n         if self.is_keyword(keywords::Unsafe)\n-            && self.look_ahead(1u) != token::LBRACE {\n+            && self.look_ahead(1u, |t| *t != token::LBRACE) {\n             // UNSAFE FUNCTION ITEM\n             self.bump();\n             self.expect_keyword(keywords::Fn);\n@@ -4392,8 +4524,7 @@ impl Parser {\n         }\n         if self.eat_keyword(keywords::Mod) {\n             // MODULE ITEM\n-            let (ident, item_, extra_attrs) =\n-                self.parse_item_mod(/*bad*/ copy attrs);\n+            let (ident, item_, extra_attrs) = self.parse_item_mod(attrs);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n@@ -4438,11 +4569,10 @@ impl Parser {\n     }\n \n     // parse a foreign item; on failure, return iovi_none.\n-    fn parse_foreign_item(\n-        &self,\n-        attrs: ~[attribute],\n-        macros_allowed: bool\n-    ) -> item_or_view_item {\n+    fn parse_foreign_item(&self,\n+                          attrs: ~[attribute],\n+                          macros_allowed: bool)\n+                          -> item_or_view_item {\n         maybe_whole!(iovi self, nt_item);\n         let lo = self.span.lo;\n \n@@ -4471,10 +4601,10 @@ impl Parser {\n         visibility : visibility\n     ) -> item_or_view_item {\n         if macros_allowed && !token::is_any_keyword(self.token)\n-                && self.look_ahead(1) == token::NOT\n-                && (is_plain_ident(&self.look_ahead(2))\n-                    || self.look_ahead(2) == token::LPAREN\n-                    || self.look_ahead(2) == token::LBRACE) {\n+                && self.look_ahead(1, |t| *t == token::NOT)\n+                && (self.look_ahead(2, |t| is_plain_ident(t))\n+                    || self.look_ahead(2, |t| *t == token::LPAREN)\n+                    || self.look_ahead(2, |t| *t == token::LBRACE)) {\n             // MACRO INVOCATION ITEM\n             if attrs.len() > 0 {\n                 self.fatal(\"attrs on macros are not yet supported\");\n@@ -4496,12 +4626,10 @@ impl Parser {\n             let tts = match *self.token {\n                 token::LPAREN | token::LBRACE => {\n                     let ket = token::flip_delimiter(&*self.token);\n-                    self.parse_unspanned_seq(\n-                        &copy *self.token,\n-                        &ket,\n-                        seq_sep_none(),\n-                        |p| p.parse_token_tree()\n-                    )\n+                    self.bump();\n+                    self.parse_seq_to_end(&ket,\n+                                          seq_sep_none(),\n+                                          |p| p.parse_token_tree())\n                 }\n                 _ => self.fatal(\"expected open delimiter\")\n             };\n@@ -4526,12 +4654,12 @@ impl Parser {\n             s.push_char('`');\n             self.span_fatal(*self.last_span, s);\n         }\n-        return iovi_none;\n+        return iovi_none(attrs);\n     }\n \n     pub fn parse_item(&self, attrs: ~[attribute]) -> Option<@ast::item> {\n         match self.parse_item_or_view_item(attrs, true) {\n-            iovi_none =>\n+            iovi_none(attrs) =>\n                 None,\n             iovi_view_item(_) =>\n                 self.fatal(\"view items are not allowed here\"),\n@@ -4648,18 +4776,19 @@ impl Parser {\n     }\n \n     fn is_view_item(&self) -> bool {\n-        let tok;\n-        let next_tok;\n         if !self.is_keyword(keywords::Pub) && !self.is_keyword(keywords::Priv) {\n-            tok = copy *self.token;\n-            next_tok = self.look_ahead(1);\n+            token::is_keyword(keywords::Use, self.token)\n+                || (token::is_keyword(keywords::Extern, self.token) &&\n+                    self.look_ahead(1,\n+                                    |t| token::is_keyword(keywords::Mod, t)))\n         } else {\n-            tok = self.look_ahead(1);\n-            next_tok = self.look_ahead(2);\n-        };\n-        token::is_keyword(keywords::Use, &tok)\n-            || (token::is_keyword(keywords::Extern, &tok) &&\n-                token::is_keyword(keywords::Mod, &next_tok))\n+            self.look_ahead(1, |t| token::is_keyword(keywords::Use, t))\n+                || (self.look_ahead(1,\n+                                    |t| token::is_keyword(keywords::Extern,\n+                                                          t)) &&\n+                    self.look_ahead(2,\n+                                    |t| token::is_keyword(keywords::Mod, t)))\n+        }\n     }\n \n     // parse a view item.\n@@ -4706,11 +4835,14 @@ impl Parser {\n         // view items, and regular items) ... except that because\n         // of macros, I'd like to delay that entire check until later.\n         loop {\n-            match self.parse_item_or_view_item(/*bad*/ copy attrs,\n-                                                           macros_allowed) {\n-                iovi_none => {\n-                    done = true;\n-                    break;\n+            match self.parse_item_or_view_item(attrs, macros_allowed) {\n+                iovi_none(attrs) => {\n+                    return ParsedItemsAndViewItems {\n+                        attrs_remaining: attrs,\n+                        view_items: view_items,\n+                        items: items,\n+                        foreign_items: ~[]\n+                    }\n                 }\n                 iovi_view_item(view_item) => {\n                     match view_item.node {\n@@ -4740,23 +4872,24 @@ impl Parser {\n         }\n \n         // Next, parse items.\n-        if !done {\n-            loop {\n-                match self.parse_item_or_view_item(/*bad*/ copy attrs,\n-                                                   macros_allowed) {\n-                    iovi_none => break,\n-                    iovi_view_item(view_item) => {\n-                        self.span_err(view_item.span,\n-                                      \"`use` and `extern mod` declarations must precede items\");\n-                    }\n-                    iovi_item(item) => {\n-                        items.push(item)\n-                    }\n-                    iovi_foreign_item(_) => {\n-                        fail!();\n-                    }\n+        loop {\n+            match self.parse_item_or_view_item(attrs, macros_allowed) {\n+                iovi_none(returned_attrs) => {\n+                    attrs = returned_attrs;\n+                    break\n+                }\n+                iovi_view_item(view_item) => {\n+                    attrs = self.parse_outer_attributes();\n+                    self.span_err(view_item.span,\n+                                  \"`use` and `extern mod` declarations must precede items\");\n+                }\n+                iovi_item(item) => {\n+                    attrs = self.parse_outer_attributes();\n+                    items.push(item)\n+                }\n+                iovi_foreign_item(_) => {\n+                    fail!();\n                 }\n-                attrs = self.parse_outer_attributes();\n             }\n         }\n \n@@ -4777,9 +4910,10 @@ impl Parser {\n                                     self.parse_outer_attributes());\n         let mut foreign_items = ~[];\n         loop {\n-            match self.parse_foreign_item(/*bad*/ copy attrs, macros_allowed) {\n-                iovi_none => {\n+            match self.parse_foreign_item(attrs, macros_allowed) {\n+                iovi_none(returned_attrs) => {\n                     if *self.token == token::RBRACE {\n+                        attrs = returned_attrs;\n                         break\n                     }\n                     self.unexpected();\n@@ -4821,7 +4955,7 @@ impl Parser {\n         @spanned(lo, self.span.lo,\n                  ast::crate_ { module: m,\n                                attrs: inner,\n-                               config: copy self.cfg })\n+                               config: self.cfg.clone() })\n     }\n \n     pub fn parse_str(&self) -> @str {"}, {"sha": "8e14e56439e5f2945a2fff9d9d06d2abe8341022", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -20,7 +20,7 @@ use std::local_data;\n use std::rand;\n use std::rand::RngUtil;\n \n-#[deriving(Encodable, Decodable, Eq, IterBytes)]\n+#[deriving(Clone, Encodable, Decodable, Eq, IterBytes)]\n pub enum binop {\n     PLUS,\n     MINUS,\n@@ -34,7 +34,7 @@ pub enum binop {\n     SHR,\n }\n \n-#[deriving(Encodable, Decodable, Eq, IterBytes)]\n+#[deriving(Clone, Encodable, Decodable, Eq, IterBytes)]\n pub enum Token {\n     /* Expression-operator symbols. */\n     EQ,\n@@ -95,7 +95,7 @@ pub enum Token {\n     EOF,\n }\n \n-#[deriving(Encodable, Decodable, Eq, IterBytes)]\n+#[deriving(Clone, Encodable, Decodable, Eq, IterBytes)]\n /// For interpolation during macro expansion.\n pub enum nonterminal {\n     nt_item(@ast::item),\n@@ -350,8 +350,8 @@ pub mod special_idents {\n  * Maps a token to a record specifying the corresponding binary\n  * operator\n  */\n-pub fn token_to_binop(tok: Token) -> Option<ast::binop> {\n-  match tok {\n+pub fn token_to_binop(tok: &Token) -> Option<ast::binop> {\n+  match *tok {\n       BINOP(STAR)    => Some(ast::mul),\n       BINOP(SLASH)   => Some(ast::div),\n       BINOP(PERCENT) => Some(ast::rem),"}, {"sha": "af2a49770828b5c219049f64e2ec28fad41ed83b", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -64,19 +64,25 @@\n use std::io;\n use std::vec;\n \n-#[deriving(Eq)]\n-pub enum breaks { consistent, inconsistent, }\n+#[deriving(Clone, Eq)]\n+pub enum breaks {\n+    consistent,\n+    inconsistent,\n+}\n \n+#[deriving(Clone)]\n pub struct break_t {\n     offset: int,\n     blank_space: int\n }\n \n+#[deriving(Clone)]\n pub struct begin_t {\n     offset: int,\n     breaks: breaks\n }\n \n+#[deriving(Clone)]\n pub enum token {\n     STRING(@str, int),\n     BREAK(break_t),\n@@ -476,11 +482,11 @@ impl Printer {\n     pub fn print(&mut self, x: token, L: int) {\n         debug!(\"print %s %d (remaining line space=%d)\", tok_str(x), L,\n                self.space);\n-        debug!(\"%s\", buf_str(copy self.token,\n-                           copy self.size,\n-                           self.left,\n-                           self.right,\n-                           6u));\n+        debug!(\"%s\", buf_str(self.token.clone(),\n+                             self.size.clone(),\n+                             self.left,\n+                             self.right,\n+                             6));\n         match x {\n           BEGIN(b) => {\n             if L > self.space {"}, {"sha": "2f0241967d95d24f2ba68e9be9b757a0b573c398", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -121,11 +121,15 @@ pub fn print_crate(cm: @CodeMap,\n         s: pp::mk_printer(out, default_columns),\n         cm: Some(cm),\n         intr: intr,\n-        comments: Some(copy cmnts),\n+        comments: Some(cmnts),\n         // If the code is post expansion, don't use the table of\n         // literals, since it doesn't correspond with the literals\n         // in the AST anymore.\n-        literals: if is_expanded { None } else { Some(copy lits) },\n+        literals: if is_expanded {\n+            None\n+        } else {\n+            Some(lits)\n+        },\n         cur_cmnt_and_lit: @mut CurrentCommentAndLiteral {\n             cur_cmnt: 0,\n             cur_lit: 0\n@@ -405,15 +409,19 @@ pub fn print_type(s: @ps, ty: &ast::Ty) {\n         pclose(s);\n       }\n       ast::ty_bare_fn(f) => {\n-          let generics = ast::Generics {lifetimes: copy f.lifetimes,\n-                                        ty_params: opt_vec::Empty};\n+          let generics = ast::Generics {\n+            lifetimes: f.lifetimes.clone(),\n+            ty_params: opt_vec::Empty\n+          };\n           print_ty_fn(s, Some(f.abis), None, &None,\n                       f.purity, ast::Many, &f.decl, None, &None,\n                       Some(&generics), None);\n       }\n       ast::ty_closure(f) => {\n-          let generics = ast::Generics {lifetimes: copy f.lifetimes,\n-                                        ty_params: opt_vec::Empty};\n+          let generics = ast::Generics {\n+            lifetimes: f.lifetimes.clone(),\n+            ty_params: opt_vec::Empty\n+          };\n           print_ty_fn(s, None, Some(f.sigil), &f.region,\n                       f.purity, f.onceness, &f.decl, None, &f.bounds,\n                       Some(&generics), None);\n@@ -1167,13 +1175,13 @@ pub fn print_expr(s: @ps, expr: &ast::expr) {\n         pclose(s);\n       }\n       ast::expr_call(func, ref args, sugar) => {\n-        let mut base_args = copy *args;\n+        let mut base_args = (*args).clone();\n         let blk = print_call_pre(s, sugar, &mut base_args);\n         print_expr(s, func);\n         print_call_post(s, sugar, &blk, &mut base_args);\n       }\n       ast::expr_method_call(_, func, ident, ref tys, ref args, sugar) => {\n-        let mut base_args = copy *args;\n+        let mut base_args = (*args).clone();\n         let blk = print_call_pre(s, sugar, &mut base_args);\n         print_expr(s, func);\n         word(s.s, \".\");\n@@ -1798,12 +1806,10 @@ pub fn print_meta_item(s: @ps, item: &ast::meta_item) {\n       ast::meta_list(name, ref items) => {\n         word(s.s, name);\n         popen(s);\n-        commasep(\n-            s,\n-            consistent,\n-            items.as_slice(),\n-            |p, &i| print_meta_item(p, i)\n-        );\n+        commasep(s,\n+                 consistent,\n+                 items.as_slice(),\n+                 |p, &i| print_meta_item(p, i));\n         pclose(s);\n       }\n     }\n@@ -2061,7 +2067,7 @@ pub fn next_lit(s: @ps, pos: BytePos) -> Option<comments::lit> {\n     match s.literals {\n       Some(ref lits) => {\n         while s.cur_cmnt_and_lit.cur_lit < lits.len() {\n-            let ltrl = /*bad*/ copy (*lits)[s.cur_cmnt_and_lit.cur_lit];\n+            let ltrl = (*lits)[s.cur_cmnt_and_lit.cur_lit].clone();\n             if ltrl.pos > pos { return None; }\n             s.cur_cmnt_and_lit.cur_lit += 1u;\n             if ltrl.pos == pos { return Some(ltrl); }\n@@ -2148,8 +2154,10 @@ pub fn next_comment(s: @ps) -> Option<comments::cmnt> {\n     match s.comments {\n       Some(ref cmnts) => {\n         if s.cur_cmnt_and_lit.cur_cmnt < cmnts.len() {\n-            return Some(copy cmnts[s.cur_cmnt_and_lit.cur_cmnt]);\n-        } else { return None::<comments::cmnt>; }\n+            return Some(cmnts[s.cur_cmnt_and_lit.cur_cmnt].clone());\n+        } else {\n+            return None::<comments::cmnt>;\n+        }\n       }\n       _ => return None::<comments::cmnt>\n     }"}, {"sha": "3d2e0632a33775d2cd50b86ebac5c98b77263b51", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -21,7 +21,7 @@ pub struct Interner<T> {\n }\n \n // when traits can extend traits, we should extend index<uint,T> to get []\n-impl<T:Eq + IterBytes + Hash + Freeze + Copy> Interner<T> {\n+impl<T:Eq + IterBytes + Hash + Freeze + Clone> Interner<T> {\n     pub fn new() -> Interner<T> {\n         Interner {\n             map: @mut HashMap::new(),\n@@ -31,7 +31,9 @@ impl<T:Eq + IterBytes + Hash + Freeze + Copy> Interner<T> {\n \n     pub fn prefill(init: &[T]) -> Interner<T> {\n         let rv = Interner::new();\n-        for init.iter().advance |v| { rv.intern(copy *v); }\n+        for init.iter().advance |v| {\n+            rv.intern((*v).clone());\n+        }\n         rv\n     }\n \n@@ -43,7 +45,7 @@ impl<T:Eq + IterBytes + Hash + Freeze + Copy> Interner<T> {\n \n         let vect = &mut *self.vect;\n         let new_idx = vect.len();\n-        self.map.insert(copy val, new_idx);\n+        self.map.insert(val.clone(), new_idx);\n         vect.push(val);\n         new_idx\n     }\n@@ -58,7 +60,9 @@ impl<T:Eq + IterBytes + Hash + Freeze + Copy> Interner<T> {\n         new_idx\n     }\n \n-    pub fn get(&self, idx: uint) -> T { copy self.vect[idx] }\n+    pub fn get(&self, idx: uint) -> T {\n+        self.vect[idx].clone()\n+    }\n \n     pub fn len(&self) -> uint { let vect = &*self.vect; vect.len() }\n "}, {"sha": "d68958ffa775074d57f85ed550e653b3311e5ed5", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 148, "deletions": 129, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -59,7 +59,7 @@ pub fn generics_of_fn(fk: &fn_kind) -> Generics {\n     match *fk {\n         fk_item_fn(_, generics, _, _) |\n         fk_method(_, generics, _) => {\n-            copy *generics\n+            (*generics).clone()\n         }\n         fk_anon(*) | fk_fn_block(*) => {\n             Generics {\n@@ -94,7 +94,7 @@ pub struct Visitor<E> {\n \n pub type visitor<E> = @Visitor<E>;\n \n-pub fn default_visitor<E: Copy>() -> visitor<E> {\n+pub fn default_visitor<E:Clone>() -> visitor<E> {\n     return @Visitor {\n         visit_mod: |a,b,c,d|visit_mod::<E>(a, b, c, d),\n         visit_view_item: |a,b|visit_view_item::<E>(a, b),\n@@ -118,35 +118,42 @@ pub fn default_visitor<E: Copy>() -> visitor<E> {\n     };\n }\n \n-pub fn visit_crate<E: Copy>(c: &crate, (e, v): (E, vt<E>)) {\n+pub fn visit_crate<E:Clone>(c: &crate, (e, v): (E, vt<E>)) {\n     (v.visit_mod)(&c.node.module, c.span, crate_node_id, (e, v));\n }\n \n-pub fn visit_mod<E: Copy>(m: &_mod, _sp: span, _id: node_id, (e, v): (E, vt<E>)) {\n-    for m.view_items.iter().advance |vi| { (v.visit_view_item)(vi, (copy e, v)); }\n-    for m.items.iter().advance |i| { (v.visit_item)(*i, (copy e, v)); }\n+pub fn visit_mod<E:Clone>(m: &_mod,\n+                          _sp: span,\n+                          _id: node_id,\n+                          (e, v): (E, vt<E>)) {\n+    for m.view_items.iter().advance |vi| {\n+        (v.visit_view_item)(vi, (e.clone(), v));\n+    }\n+    for m.items.iter().advance |i| {\n+        (v.visit_item)(*i, (e.clone(), v));\n+    }\n }\n \n pub fn visit_view_item<E>(_vi: &view_item, (_e, _v): (E, vt<E>)) { }\n \n-pub fn visit_local<E: Copy>(loc: &local, (e, v): (E, vt<E>)) {\n-    (v.visit_pat)(loc.node.pat, (copy e, v));\n-    (v.visit_ty)(&loc.node.ty, (copy e, v));\n+pub fn visit_local<E:Clone>(loc: &local, (e, v): (E, vt<E>)) {\n+    (v.visit_pat)(loc.node.pat, (e.clone(), v));\n+    (v.visit_ty)(&loc.node.ty, (e.clone(), v));\n     match loc.node.init {\n       None => (),\n       Some(ex) => (v.visit_expr)(ex, (e, v))\n     }\n }\n \n-fn visit_trait_ref<E: Copy>(tref: &ast::trait_ref, (e, v): (E, vt<E>)) {\n+fn visit_trait_ref<E:Clone>(tref: &ast::trait_ref, (e, v): (E, vt<E>)) {\n     visit_path(&tref.path, (e, v));\n }\n \n-pub fn visit_item<E: Copy>(i: &item, (e, v): (E, vt<E>)) {\n+pub fn visit_item<E:Clone>(i: &item, (e, v): (E, vt<E>)) {\n     match i.node {\n         item_static(ref t, _, ex) => {\n-            (v.visit_ty)(t, (copy e, v));\n-            (v.visit_expr)(ex, (copy e, v));\n+            (v.visit_ty)(t, (e.clone(), v));\n+            (v.visit_expr)(ex, (e.clone(), v));\n         }\n         item_fn(ref decl, purity, abi, ref generics, ref body) => {\n             (v.visit_fn)(\n@@ -166,164 +173,174 @@ pub fn visit_item<E: Copy>(i: &item, (e, v): (E, vt<E>)) {\n         }\n         item_mod(ref m) => (v.visit_mod)(m, i.span, i.id, (e, v)),\n         item_foreign_mod(ref nm) => {\n-            for nm.view_items.iter().advance |vi| { (v.visit_view_item)(vi, (copy e, v)); }\n-            for nm.items.iter().advance |ni| { (v.visit_foreign_item)(*ni, (copy e, v)); }\n+            for nm.view_items.iter().advance |vi| {\n+                (v.visit_view_item)(vi, (e.clone(), v));\n+            }\n+            for nm.items.iter().advance |ni| {\n+                (v.visit_foreign_item)(*ni, (e.clone(), v));\n+            }\n         }\n         item_ty(ref t, ref tps) => {\n-            (v.visit_ty)(t, (copy e, v));\n+            (v.visit_ty)(t, (e.clone(), v));\n             (v.visit_generics)(tps, (e, v));\n         }\n         item_enum(ref enum_definition, ref tps) => {\n-            (v.visit_generics)(tps, (copy e, v));\n+            (v.visit_generics)(tps, (e.clone(), v));\n             visit_enum_def(\n                 enum_definition,\n                 tps,\n                 (e, v)\n             );\n         }\n         item_impl(ref tps, ref traits, ref ty, ref methods) => {\n-            (v.visit_generics)(tps, (copy e, v));\n+            (v.visit_generics)(tps, (e.clone(), v));\n             for traits.iter().advance |p| {\n-                visit_trait_ref(p, (copy e, v));\n+                visit_trait_ref(p, (e.clone(), v));\n             }\n-            (v.visit_ty)(ty, (copy e, v));\n+            (v.visit_ty)(ty, (e.clone(), v));\n             for methods.iter().advance |m| {\n-                visit_method_helper(*m, (copy e, v))\n+                visit_method_helper(*m, (e.clone(), v))\n             }\n         }\n         item_struct(struct_def, ref generics) => {\n-            (v.visit_generics)(generics, (copy e, v));\n+            (v.visit_generics)(generics, (e.clone(), v));\n             (v.visit_struct_def)(struct_def, i.ident, generics, i.id, (e, v));\n         }\n         item_trait(ref generics, ref traits, ref methods) => {\n-            (v.visit_generics)(generics, (copy e, v));\n-            for traits.iter().advance |p| { visit_path(&p.path, (copy e, v)); }\n+            (v.visit_generics)(generics, (e.clone(), v));\n+            for traits.iter().advance |p| {\n+                visit_path(&p.path, (e.clone(), v));\n+            }\n             for methods.iter().advance |m| {\n-                (v.visit_trait_method)(m, (copy e, v));\n+                (v.visit_trait_method)(m, (e.clone(), v));\n             }\n         }\n         item_mac(ref m) => visit_mac(m, (e, v))\n     }\n }\n \n-pub fn visit_enum_def<E: Copy>(enum_definition: &ast::enum_def,\n+pub fn visit_enum_def<E:Clone>(enum_definition: &ast::enum_def,\n                                tps: &Generics,\n                                (e, v): (E, vt<E>)) {\n     for enum_definition.variants.iter().advance |vr| {\n         match vr.node.kind {\n             tuple_variant_kind(ref variant_args) => {\n                 for variant_args.iter().advance |va| {\n-                    (v.visit_ty)(&va.ty, (copy e, v));\n+                    (v.visit_ty)(&va.ty, (e.clone(), v));\n                 }\n             }\n             struct_variant_kind(struct_def) => {\n                 (v.visit_struct_def)(struct_def, vr.node.name, tps,\n-                                     vr.node.id, (copy e, v));\n+                                     vr.node.id, (e.clone(), v));\n             }\n         }\n         // Visit the disr expr if it exists\n         for vr.node.disr_expr.iter().advance |ex| {\n-            (v.visit_expr)(*ex, (copy e, v))\n+            (v.visit_expr)(*ex, (e.clone(), v))\n         }\n     }\n }\n \n pub fn skip_ty<E>(_t: &Ty, (_e,_v): (E, vt<E>)) {}\n \n-pub fn visit_ty<E: Copy>(t: &Ty, (e, v): (E, vt<E>)) {\n+pub fn visit_ty<E:Clone>(t: &Ty, (e, v): (E, vt<E>)) {\n     match t.node {\n         ty_box(ref mt) | ty_uniq(ref mt) |\n         ty_vec(ref mt) | ty_ptr(ref mt) | ty_rptr(_, ref mt) => {\n             (v.visit_ty)(mt.ty, (e, v));\n         },\n         ty_tup(ref ts) => {\n             for ts.iter().advance |tt| {\n-                (v.visit_ty)(tt, (copy e, v));\n+                (v.visit_ty)(tt, (e.clone(), v));\n             }\n         },\n         ty_closure(ref f) => {\n-            for f.decl.inputs.iter().advance |a| { (v.visit_ty)(&a.ty, (copy e, v)); }\n-            (v.visit_ty)(&f.decl.output, (copy e, v));\n+            for f.decl.inputs.iter().advance |a| {\n+                (v.visit_ty)(&a.ty, (e.clone(), v));\n+            }\n+            (v.visit_ty)(&f.decl.output, (e.clone(), v));\n             do f.bounds.map |bounds| {\n-                visit_ty_param_bounds(bounds, (copy e, v));\n+                visit_ty_param_bounds(bounds, (e.clone(), v));\n             };\n         },\n         ty_bare_fn(ref f) => {\n-            for f.decl.inputs.iter().advance |a| { (v.visit_ty)(&a.ty, (copy e, v)); }\n+            for f.decl.inputs.iter().advance |a| {\n+                (v.visit_ty)(&a.ty, (e.clone(), v));\n+            }\n             (v.visit_ty)(&f.decl.output, (e, v));\n         },\n         ty_path(ref p, ref bounds, _) => {\n-            visit_path(p, (copy e, v));\n+            visit_path(p, (e.clone(), v));\n             do bounds.map |bounds| {\n-                visit_ty_param_bounds(bounds, (copy e, v));\n+                visit_ty_param_bounds(bounds, (e.clone(), v));\n             };\n         },\n         ty_fixed_length_vec(ref mt, ex) => {\n-            (v.visit_ty)(mt.ty, (copy e, v));\n-            (v.visit_expr)(ex, (copy e, v));\n+            (v.visit_ty)(mt.ty, (e.clone(), v));\n+            (v.visit_expr)(ex, (e.clone(), v));\n         },\n         ty_nil | ty_bot | ty_mac(_) | ty_infer => ()\n     }\n }\n \n-pub fn visit_path<E: Copy>(p: &Path, (e, v): (E, vt<E>)) {\n-    for p.types.iter().advance |tp| { (v.visit_ty)(tp, (copy e, v)); }\n+pub fn visit_path<E:Clone>(p: &Path, (e, v): (E, vt<E>)) {\n+    for p.types.iter().advance |tp| { (v.visit_ty)(tp, (e.clone(), v)); }\n }\n \n-pub fn visit_pat<E: Copy>(p: &pat, (e, v): (E, vt<E>)) {\n+pub fn visit_pat<E:Clone>(p: &pat, (e, v): (E, vt<E>)) {\n     match p.node {\n         pat_enum(ref path, ref children) => {\n-            visit_path(path, (copy e, v));\n+            visit_path(path, (e.clone(), v));\n             for children.iter().advance |children| {\n                 for children.iter().advance |child| {\n-                    (v.visit_pat)(*child, (copy e, v));\n+                    (v.visit_pat)(*child, (e.clone(), v));\n                 }\n             }\n         }\n         pat_struct(ref path, ref fields, _) => {\n-            visit_path(path, (copy e, v));\n+            visit_path(path, (e.clone(), v));\n             for fields.iter().advance |f| {\n-                (v.visit_pat)(f.pat, (copy e, v));\n+                (v.visit_pat)(f.pat, (e.clone(), v));\n             }\n         }\n         pat_tup(ref elts) => {\n             for elts.iter().advance |elt| {\n-                (v.visit_pat)(*elt, (copy e, v))\n+                (v.visit_pat)(*elt, (e.clone(), v))\n             }\n         },\n         pat_box(inner) | pat_uniq(inner) | pat_region(inner) => {\n             (v.visit_pat)(inner, (e, v))\n         },\n         pat_ident(_, ref path, ref inner) => {\n-            visit_path(path, (copy e, v));\n+            visit_path(path, (e.clone(), v));\n             for inner.iter().advance |subpat| {\n-                (v.visit_pat)(*subpat, (copy e, v))\n+                (v.visit_pat)(*subpat, (e.clone(), v))\n             }\n         }\n         pat_lit(ex) => (v.visit_expr)(ex, (e, v)),\n         pat_range(e1, e2) => {\n-            (v.visit_expr)(e1, (copy e, v));\n+            (v.visit_expr)(e1, (e.clone(), v));\n             (v.visit_expr)(e2, (e, v));\n         }\n         pat_wild => (),\n         pat_vec(ref before, ref slice, ref after) => {\n             for before.iter().advance |elt| {\n-                (v.visit_pat)(*elt, (copy e, v));\n+                (v.visit_pat)(*elt, (e.clone(), v));\n             }\n             for slice.iter().advance |elt| {\n-                (v.visit_pat)(*elt, (copy e, v));\n+                (v.visit_pat)(*elt, (e.clone(), v));\n             }\n             for after.iter().advance |tail| {\n-                (v.visit_pat)(*tail, (copy e, v));\n+                (v.visit_pat)(*tail, (e.clone(), v));\n             }\n         }\n     }\n }\n \n-pub fn visit_foreign_item<E: Copy>(ni: &foreign_item, (e, v): (E, vt<E>)) {\n+pub fn visit_foreign_item<E:Clone>(ni: &foreign_item, (e, v): (E, vt<E>)) {\n     match ni.node {\n         foreign_item_fn(ref fd, _, ref generics) => {\n-            visit_fn_decl(fd, (copy e, v));\n+            visit_fn_decl(fd, (e.clone(), v));\n             (v.visit_generics)(generics, (e, v));\n         }\n         foreign_item_static(ref t, _) => {\n@@ -332,26 +349,26 @@ pub fn visit_foreign_item<E: Copy>(ni: &foreign_item, (e, v): (E, vt<E>)) {\n     }\n }\n \n-pub fn visit_ty_param_bounds<E: Copy>(bounds: &OptVec<TyParamBound>,\n+pub fn visit_ty_param_bounds<E:Clone>(bounds: &OptVec<TyParamBound>,\n                                       (e, v): (E, vt<E>)) {\n     for bounds.iter().advance |bound| {\n         match *bound {\n-            TraitTyParamBound(ref ty) => visit_trait_ref(ty, (copy e, v)),\n+            TraitTyParamBound(ref ty) => visit_trait_ref(ty, (e.clone(), v)),\n             RegionTyParamBound => {}\n         }\n     }\n }\n \n-pub fn visit_generics<E: Copy>(generics: &Generics, (e, v): (E, vt<E>)) {\n+pub fn visit_generics<E:Clone>(generics: &Generics, (e, v): (E, vt<E>)) {\n     for generics.ty_params.iter().advance |tp| {\n-        visit_ty_param_bounds(&tp.bounds, (copy e, v));\n+        visit_ty_param_bounds(&tp.bounds, (e.clone(), v));\n     }\n }\n \n-pub fn visit_fn_decl<E: Copy>(fd: &fn_decl, (e, v): (E, vt<E>)) {\n+pub fn visit_fn_decl<E:Clone>(fd: &fn_decl, (e, v): (E, vt<E>)) {\n     for fd.inputs.iter().advance |a| {\n-        (v.visit_pat)(a.pat, (copy e, v));\n-        (v.visit_ty)(&a.ty, (copy e, v));\n+        (v.visit_pat)(a.pat, (e.clone(), v));\n+        (v.visit_ty)(&a.ty, (e.clone(), v));\n     }\n     (v.visit_ty)(&fd.output, (e, v));\n }\n@@ -360,7 +377,7 @@ pub fn visit_fn_decl<E: Copy>(fd: &fn_decl, (e, v): (E, vt<E>)) {\n // visit_fn() and check for fk_method().  I named this visit_method_helper()\n // because it is not a default impl of any method, though I doubt that really\n // clarifies anything. - Niko\n-pub fn visit_method_helper<E: Copy>(m: &method, (e, v): (E, vt<E>)) {\n+pub fn visit_method_helper<E:Clone>(m: &method, (e, v): (E, vt<E>)) {\n     (v.visit_fn)(&fk_method(m.ident, &m.generics, m),\n                  &m.decl,\n                  &m.body,\n@@ -369,49 +386,51 @@ pub fn visit_method_helper<E: Copy>(m: &method, (e, v): (E, vt<E>)) {\n                  (e, v));\n }\n \n-pub fn visit_fn<E: Copy>(fk: &fn_kind, decl: &fn_decl, body: &blk, _sp: span,\n+pub fn visit_fn<E:Clone>(fk: &fn_kind, decl: &fn_decl, body: &blk, _sp: span,\n                          _id: node_id, (e, v): (E, vt<E>)) {\n-    visit_fn_decl(decl, (copy e, v));\n+    visit_fn_decl(decl, (e.clone(), v));\n     let generics = generics_of_fn(fk);\n-    (v.visit_generics)(&generics, (copy e, v));\n+    (v.visit_generics)(&generics, (e.clone(), v));\n     (v.visit_block)(body, (e, v));\n }\n \n-pub fn visit_ty_method<E: Copy>(m: &ty_method, (e, v): (E, vt<E>)) {\n-    for m.decl.inputs.iter().advance |a| { (v.visit_ty)(&a.ty, (copy e, v)); }\n-    (v.visit_generics)(&m.generics, (copy e, v));\n+pub fn visit_ty_method<E:Clone>(m: &ty_method, (e, v): (E, vt<E>)) {\n+    for m.decl.inputs.iter().advance |a| {\n+        (v.visit_ty)(&a.ty, (e.clone(), v));\n+    }\n+    (v.visit_generics)(&m.generics, (e.clone(), v));\n     (v.visit_ty)(&m.decl.output, (e, v));\n }\n \n-pub fn visit_trait_method<E: Copy>(m: &trait_method, (e, v): (E, vt<E>)) {\n+pub fn visit_trait_method<E:Clone>(m: &trait_method, (e, v): (E, vt<E>)) {\n     match *m {\n       required(ref ty_m) => (v.visit_ty_method)(ty_m, (e, v)),\n       provided(m) => visit_method_helper(m, (e, v))\n     }\n }\n \n-pub fn visit_struct_def<E: Copy>(\n+pub fn visit_struct_def<E:Clone>(\n     sd: @struct_def,\n     _nm: ast::ident,\n     _generics: &Generics,\n     _id: node_id,\n     (e, v): (E, vt<E>)\n ) {\n     for sd.fields.iter().advance |f| {\n-        (v.visit_struct_field)(*f, (copy e, v));\n+        (v.visit_struct_field)(*f, (e.clone(), v));\n     }\n }\n \n-pub fn visit_struct_field<E: Copy>(sf: &struct_field, (e, v): (E, vt<E>)) {\n+pub fn visit_struct_field<E:Clone>(sf: &struct_field, (e, v): (E, vt<E>)) {\n     (v.visit_ty)(&sf.node.ty, (e, v));\n }\n \n-pub fn visit_block<E: Copy>(b: &blk, (e, v): (E, vt<E>)) {\n+pub fn visit_block<E:Clone>(b: &blk, (e, v): (E, vt<E>)) {\n     for b.view_items.iter().advance |vi| {\n-        (v.visit_view_item)(vi, (copy e, v));\n+        (v.visit_view_item)(vi, (e.clone(), v));\n     }\n     for b.stmts.iter().advance |s| {\n-        (v.visit_stmt)(*s, (copy e, v));\n+        (v.visit_stmt)(*s, (e.clone(), v));\n     }\n     visit_expr_opt(b.expr, (e, v));\n }\n@@ -425,7 +444,7 @@ pub fn visit_stmt<E>(s: &stmt, (e, v): (E, vt<E>)) {\n     }\n }\n \n-pub fn visit_decl<E: Copy>(d: &decl, (e, v): (E, vt<E>)) {\n+pub fn visit_decl<E:Clone>(d: &decl, (e, v): (E, vt<E>)) {\n     match d.node {\n         decl_local(ref loc) => (v.visit_local)(*loc, (e, v)),\n         decl_item(it) => (v.visit_item)(it, (e, v))\n@@ -436,67 +455,67 @@ pub fn visit_expr_opt<E>(eo: Option<@expr>, (e, v): (E, vt<E>)) {\n     match eo { None => (), Some(ex) => (v.visit_expr)(ex, (e, v)) }\n }\n \n-pub fn visit_exprs<E: Copy>(exprs: &[@expr], (e, v): (E, vt<E>)) {\n-    for exprs.iter().advance |ex| { (v.visit_expr)(*ex, (copy e, v)); }\n+pub fn visit_exprs<E:Clone>(exprs: &[@expr], (e, v): (E, vt<E>)) {\n+    for exprs.iter().advance |ex| { (v.visit_expr)(*ex, (e.clone(), v)); }\n }\n \n pub fn visit_mac<E>(_m: &mac, (_e, _v): (E, vt<E>)) {\n     /* no user-serviceable parts inside */\n }\n \n-pub fn visit_expr<E: Copy>(ex: @expr, (e, v): (E, vt<E>)) {\n+pub fn visit_expr<E:Clone>(ex: @expr, (e, v): (E, vt<E>)) {\n     match ex.node {\n-        expr_vstore(x, _) => (v.visit_expr)(x, (copy e, v)),\n-        expr_vec(ref es, _) => visit_exprs(*es, (copy e, v)),\n+        expr_vstore(x, _) => (v.visit_expr)(x, (e.clone(), v)),\n+        expr_vec(ref es, _) => visit_exprs(*es, (e.clone(), v)),\n         expr_repeat(element, count, _) => {\n-            (v.visit_expr)(element, (copy e, v));\n-            (v.visit_expr)(count, (copy e, v));\n+            (v.visit_expr)(element, (e.clone(), v));\n+            (v.visit_expr)(count, (e.clone(), v));\n         }\n         expr_struct(ref p, ref flds, base) => {\n-            visit_path(p, (copy e, v));\n+            visit_path(p, (e.clone(), v));\n             for flds.iter().advance |f| {\n-                (v.visit_expr)(f.node.expr, (copy e, v));\n+                (v.visit_expr)(f.node.expr, (e.clone(), v));\n             }\n-            visit_expr_opt(base, (copy e, v));\n+            visit_expr_opt(base, (e.clone(), v));\n         }\n         expr_tup(ref elts) => {\n-            for elts.iter().advance |el| { (v.visit_expr)(*el, (copy e, v)) }\n+            for elts.iter().advance |el| { (v.visit_expr)(*el, (e.clone(), v)) }\n         }\n         expr_call(callee, ref args, _) => {\n-            visit_exprs(*args, (copy e, v));\n-            (v.visit_expr)(callee, (copy e, v));\n+            visit_exprs(*args, (e.clone(), v));\n+            (v.visit_expr)(callee, (e.clone(), v));\n         }\n         expr_method_call(_, callee, _, ref tys, ref args, _) => {\n-            visit_exprs(*args, (copy e, v));\n+            visit_exprs(*args, (e.clone(), v));\n             for tys.iter().advance |tp| {\n-                (v.visit_ty)(tp, (copy e, v));\n+                (v.visit_ty)(tp, (e.clone(), v));\n             }\n-            (v.visit_expr)(callee, (copy e, v));\n+            (v.visit_expr)(callee, (e.clone(), v));\n         }\n         expr_binary(_, _, a, b) => {\n-            (v.visit_expr)(a, (copy e, v));\n-            (v.visit_expr)(b, (copy e, v));\n+            (v.visit_expr)(a, (e.clone(), v));\n+            (v.visit_expr)(b, (e.clone(), v));\n         }\n         expr_addr_of(_, x) | expr_unary(_, _, x) |\n-        expr_loop_body(x) | expr_do_body(x) => (v.visit_expr)(x, (copy e, v)),\n+        expr_loop_body(x) | expr_do_body(x) => (v.visit_expr)(x, (e.clone(), v)),\n         expr_lit(_) => (),\n         expr_cast(x, ref t) => {\n-            (v.visit_expr)(x, (copy e, v));\n-            (v.visit_ty)(t, (copy e, v));\n+            (v.visit_expr)(x, (e.clone(), v));\n+            (v.visit_ty)(t, (e.clone(), v));\n         }\n         expr_if(x, ref b, eo) => {\n-            (v.visit_expr)(x, (copy e, v));\n-            (v.visit_block)(b, (copy e, v));\n-            visit_expr_opt(eo, (copy e, v));\n+            (v.visit_expr)(x, (e.clone(), v));\n+            (v.visit_block)(b, (e.clone(), v));\n+            visit_expr_opt(eo, (e.clone(), v));\n         }\n         expr_while(x, ref b) => {\n-            (v.visit_expr)(x, (copy e, v));\n-            (v.visit_block)(b, (copy e, v));\n+            (v.visit_expr)(x, (e.clone(), v));\n+            (v.visit_block)(b, (e.clone(), v));\n         }\n-        expr_loop(ref b, _) => (v.visit_block)(b, (copy e, v)),\n+        expr_loop(ref b, _) => (v.visit_block)(b, (e.clone(), v)),\n         expr_match(x, ref arms) => {\n-            (v.visit_expr)(x, (copy e, v));\n-            for arms.iter().advance |a| { (v.visit_arm)(a, (copy e, v)); }\n+            (v.visit_expr)(x, (e.clone(), v));\n+            for arms.iter().advance |a| { (v.visit_arm)(a, (e.clone(), v)); }\n         }\n         expr_fn_block(ref decl, ref body) => {\n             (v.visit_fn)(\n@@ -505,56 +524,56 @@ pub fn visit_expr<E: Copy>(ex: @expr, (e, v): (E, vt<E>)) {\n                 body,\n                 ex.span,\n                 ex.id,\n-                (copy e, v)\n+                (e.clone(), v)\n             );\n         }\n-        expr_block(ref b) => (v.visit_block)(b, (copy e, v)),\n+        expr_block(ref b) => (v.visit_block)(b, (e.clone(), v)),\n         expr_assign(a, b) => {\n-            (v.visit_expr)(b, (copy e, v));\n-            (v.visit_expr)(a, (copy e, v));\n+            (v.visit_expr)(b, (e.clone(), v));\n+            (v.visit_expr)(a, (e.clone(), v));\n         }\n-        expr_copy(a) => (v.visit_expr)(a, (copy e, v)),\n+        expr_copy(a) => (v.visit_expr)(a, (e.clone(), v)),\n         expr_assign_op(_, _, a, b) => {\n-            (v.visit_expr)(b, (copy e, v));\n-            (v.visit_expr)(a, (copy e, v));\n+            (v.visit_expr)(b, (e.clone(), v));\n+            (v.visit_expr)(a, (e.clone(), v));\n         }\n         expr_field(x, _, ref tys) => {\n-            (v.visit_expr)(x, (copy e, v));\n+            (v.visit_expr)(x, (e.clone(), v));\n             for tys.iter().advance |tp| {\n-                (v.visit_ty)(tp, (copy e, v));\n+                (v.visit_ty)(tp, (e.clone(), v));\n             }\n         }\n         expr_index(_, a, b) => {\n-            (v.visit_expr)(a, (copy e, v));\n-            (v.visit_expr)(b, (copy e, v));\n+            (v.visit_expr)(a, (e.clone(), v));\n+            (v.visit_expr)(b, (e.clone(), v));\n         }\n-        expr_path(ref p) => visit_path(p, (copy e, v)),\n+        expr_path(ref p) => visit_path(p, (e.clone(), v)),\n         expr_self => (),\n         expr_break(_) => (),\n         expr_again(_) => (),\n-        expr_ret(eo) => visit_expr_opt(eo, (copy e, v)),\n+        expr_ret(eo) => visit_expr_opt(eo, (e.clone(), v)),\n         expr_log(lv, x) => {\n-            (v.visit_expr)(lv, (copy e, v));\n-            (v.visit_expr)(x, (copy e, v));\n+            (v.visit_expr)(lv, (e.clone(), v));\n+            (v.visit_expr)(x, (e.clone(), v));\n         }\n-        expr_mac(ref mac) => visit_mac(mac, (copy e, v)),\n-        expr_paren(x) => (v.visit_expr)(x, (copy e, v)),\n+        expr_mac(ref mac) => visit_mac(mac, (e.clone(), v)),\n+        expr_paren(x) => (v.visit_expr)(x, (e.clone(), v)),\n         expr_inline_asm(ref a) => {\n             for a.inputs.iter().advance |&(_, in)| {\n-                (v.visit_expr)(in, (copy e, v));\n+                (v.visit_expr)(in, (e.clone(), v));\n             }\n             for a.outputs.iter().advance |&(_, out)| {\n-                (v.visit_expr)(out, (copy e, v));\n+                (v.visit_expr)(out, (e.clone(), v));\n             }\n         }\n     }\n     (v.visit_expr_post)(ex, (e, v));\n }\n \n-pub fn visit_arm<E: Copy>(a: &arm, (e, v): (E, vt<E>)) {\n-    for a.pats.iter().advance |p| { (v.visit_pat)(*p, (copy e, v)); }\n-    visit_expr_opt(a.guard, (copy e, v));\n-    (v.visit_block)(&a.body, (copy e, v));\n+pub fn visit_arm<E:Clone>(a: &arm, (e, v): (E, vt<E>)) {\n+    for a.pats.iter().advance |p| { (v.visit_pat)(*p, (e.clone(), v)); }\n+    visit_expr_opt(a.guard, (e.clone(), v));\n+    (v.visit_block)(&a.body, (e.clone(), v));\n }\n \n // Simpler, non-context passing interface. Always walks the whole tree, simply"}, {"sha": "61a3ca1559c277827db1d366b1113b07a1efcb8e", "filename": "src/test/auxiliary/cci_capture_clause.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -11,10 +11,10 @@\n use std::comm::*;\n use std::task;\n \n-pub fn foo<T:Send + Copy>(x: T) -> Port<T> {\n+pub fn foo<T:Send + Clone>(x: T) -> Port<T> {\n     let (p, c) = stream();\n     do task::spawn() {\n-        c.send(copy x);\n+        c.send(x.clone());\n     }\n     p\n }"}, {"sha": "c1e23f1f5c848ddd67d4f98a57a22d4bbb151330", "filename": "src/test/auxiliary/cci_class_cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -18,7 +18,7 @@ pub mod kitty {\n     }\n \n     impl ToStr for cat {\n-       fn to_str(&self) -> ~str { copy self.name }\n+       fn to_str(&self) -> ~str { self.name.clone() }\n     }\n \n     impl cat {"}, {"sha": "d53b7d825cb37f115fcf662b67376f9c0c7f660d", "filename": "src/test/auxiliary/cci_nested_lib.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -18,26 +18,28 @@ pub struct alist<A,B> {\n     data: @mut ~[Entry<A,B>]\n }\n \n-pub fn alist_add<A:Copy,B:Copy>(lst: &alist<A,B>, k: A, v: B) {\n+pub fn alist_add<A,B>(lst: &alist<A,B>, k: A, v: B) {\n     lst.data.push(Entry{key:k, value:v});\n }\n \n-pub fn alist_get<A:Copy,B:Copy>(lst: &alist<A,B>, k: A) -> B {\n+pub fn alist_get<A:Clone,B:Clone>(lst: &alist<A,B>, k: A) -> B {\n     let eq_fn = lst.eq_fn;\n     for lst.data.iter().advance |entry| {\n-        if eq_fn(copy entry.key, copy k) { return copy entry.value; }\n+        if eq_fn(entry.key.clone(), k.clone()) {\n+            return entry.value.clone();\n+        }\n     }\n     fail!();\n }\n \n #[inline]\n-pub fn new_int_alist<B:Copy>() -> alist<int, B> {\n+pub fn new_int_alist<B>() -> alist<int, B> {\n     fn eq_int(a: int, b: int) -> bool { a == b }\n     return alist {eq_fn: eq_int, data: @mut ~[]};\n }\n \n #[inline]\n-pub fn new_int_alist_2<B:Copy>() -> alist<int, B> {\n+pub fn new_int_alist_2<B>() -> alist<int, B> {\n     #[inline]\n     fn eq_int(a: int, b: int) -> bool { a == b }\n     return alist {eq_fn: eq_int, data: @mut ~[]};"}, {"sha": "75a4b6e262109fb4d85b5e08a7dbf9728615cd28", "filename": "src/test/auxiliary/issue-2631-a.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -18,6 +18,6 @@ use std::hashmap::HashMap;\n pub type header_map = HashMap<~str, @mut ~[@~str]>;\n \n // the unused ty param is necessary so this gets monomorphized\n-pub fn request<T:Copy>(req: &header_map) {\n-  let _x = copy *(copy **req.get(&~\"METHOD\"))[0u];\n+pub fn request<T>(req: &header_map) {\n+  let _x = (*((**req.get(&~\"METHOD\")).clone())[0u]).clone();\n }"}, {"sha": "eed271c5499fe55ca98c90965fc40d8a6be35369", "filename": "src/test/auxiliary/issue2378a.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fauxiliary%2Fissue2378a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fauxiliary%2Fissue2378a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue2378a.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -13,10 +13,10 @@\n \n enum maybe<T> { just(T), nothing }\n \n-impl <T:Copy> Index<uint,T> for maybe<T> {\n+impl <T:Clone> Index<uint,T> for maybe<T> {\n     fn index(&self, idx: &uint) -> T {\n         match self {\n-            &just(ref t) => copy *t,\n+            &just(ref t) => (*t).clone(),\n             &nothing => { fail!(); }\n         }\n     }"}, {"sha": "d2c42bacc63a968470b25492eca00475319f33c5", "filename": "src/test/auxiliary/issue2378b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fauxiliary%2Fissue2378b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fauxiliary%2Fissue2378b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue2378b.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -17,7 +17,7 @@ use issue2378a::maybe;\n \n struct two_maybes<T> {a: maybe<T>, b: maybe<T>}\n \n-impl <T:Copy> Index<uint,(T,T)> for two_maybes<T> {\n+impl<T:Clone> Index<uint,(T,T)> for two_maybes<T> {\n     fn index(&self, idx: &uint) -> (T, T) {\n         (self.a[*idx], self.b[*idx])\n     }"}, {"sha": "cd90c9b06c4ce0ad5649fa1cb9f68812e96584dc", "filename": "src/test/auxiliary/issue4516_ty_param_lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fauxiliary%2Fissue4516_ty_param_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fauxiliary%2Fissue4516_ty_param_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue4516_ty_param_lib.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub fn to_closure<A:'static + Copy>(x: A) -> @fn() -> A {\n-    let result: @fn() -> A = || copy x;\n+pub fn to_closure<A:'static + Clone>(x: A) -> @fn() -> A {\n+    let result: @fn() -> A = || x.clone();\n     result\n }"}, {"sha": "9f504db8f2a4f9f114ea6897a87d5aa1690551ee", "filename": "src/test/auxiliary/issue_2242_a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fauxiliary%2Fissue_2242_a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fauxiliary%2Fissue_2242_a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2242_a.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -16,5 +16,5 @@ trait to_strz {\n }\n \n impl to_strz for ~str {\n-    fn to_strz() -> ~str { copy self }\n+    fn to_strz() -> ~str { self.clone() }\n }"}, {"sha": "bbdfd3ecf79445ad8ad4e5bccaf826dcb34c1121", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -198,7 +198,11 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n               white => {\n                 let i = i as node_id;\n \n+<<<<<<< HEAD\n                 let neighbors = &graph[i];\n+=======\n+                let neighbors = graph[i].clone();\n+>>>>>>> librustc: Remove all uses of \"copy\".\n \n                 let mut color = white;\n \n@@ -283,7 +287,7 @@ fn pbfs(graph: &arc::ARC<graph>, key: node_id) -> bfs_result {\n                   white => {\n                     let i = i as node_id;\n \n-                    let neighbors = copy graph[i];\n+                    let neighbors = graph[i].clone();\n \n                     let mut color = white;\n \n@@ -397,7 +401,7 @@ fn validate(edges: ~[(node_id, node_id)],\n     info!(~\"Verifying tree and graph edges...\");\n \n     let status = do par::alli(tree) {\n-        let edges = copy edges;\n+        let edges = edges.clone();\n         let result: ~fn(x: uint, v: &i64) -> bool = |u, v| {\n             let u = u as node_id;\n             if *v == -1i64 || u == root {\n@@ -438,7 +442,7 @@ fn main() {\n                                  edges.len(), stop - start));\n \n     let start = time::precise_time_s();\n-    let graph = make_graph(1 << scale, copy edges);\n+    let graph = make_graph(1 << scale, edges.clone());\n     let stop = time::precise_time_s();\n \n     let mut total_edges = 0;\n@@ -451,15 +455,15 @@ fn main() {\n     let mut total_seq = 0.0;\n     let mut total_par = 0.0;\n \n-    let graph_arc = arc::ARC(copy graph);\n+    let graph_arc = arc::ARC(graph.clone());\n \n     do gen_search_keys(graph, num_keys).map() |root| {\n         io::stdout().write_line(~\"\");\n         io::stdout().write_line(fmt!(\"Search key: %?\", root));\n \n         if do_sequential {\n             let start = time::precise_time_s();\n-            let bfs_tree = bfs(copy graph, *root);\n+            let bfs_tree = bfs(graph.clone(), *root);\n             let stop = time::precise_time_s();\n \n             //total_seq += stop - start;\n@@ -470,7 +474,7 @@ fn main() {\n \n             if do_validate {\n                 let start = time::precise_time_s();\n-                assert!((validate(copy edges, *root, bfs_tree)));\n+                assert!((validate(edges.clone(), *root, bfs_tree)));\n                 let stop = time::precise_time_s();\n \n                 io::stdout().write_line(\n@@ -479,7 +483,7 @@ fn main() {\n             }\n \n             let start = time::precise_time_s();\n-            let bfs_tree = bfs2(copy graph, *root);\n+            let bfs_tree = bfs2(graph.clone(), *root);\n             let stop = time::precise_time_s();\n \n             total_seq += stop - start;\n@@ -490,7 +494,7 @@ fn main() {\n \n             if do_validate {\n                 let start = time::precise_time_s();\n-                assert!((validate(copy edges, *root, bfs_tree)));\n+                assert!((validate(edges.clone(), *root, bfs_tree)));\n                 let stop = time::precise_time_s();\n \n                 io::stdout().write_line(\n@@ -510,7 +514,7 @@ fn main() {\n \n         if do_validate {\n             let start = time::precise_time_s();\n-            assert!((validate(copy edges, *root, bfs_tree)));\n+            assert!((validate(edges.clone(), *root, bfs_tree)));\n             let stop = time::precise_time_s();\n \n             io::stdout().write_line(fmt!(\"Validation completed in %? seconds.\","}, {"sha": "8aff30ec80a8b68de2751025495c0cc879fd67a2", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -43,7 +43,7 @@ fn server(requests: &Port<request>, responses: &comm::Chan<uint>) {\n     let mut done = false;\n     while !done {\n         match requests.try_recv() {\n-          Some(get_count) => { responses.send(copy count); }\n+          Some(get_count) => { responses.send(count.clone()); }\n           Some(bytes(b)) => {\n             //error!(\"server: received %? bytes\", b);\n             count += b;\n@@ -107,7 +107,7 @@ fn main() {\n     } else if args.len() <= 1u {\n         ~[~\"\", ~\"10000\", ~\"4\"]\n     } else {\n-        copy args\n+        args.clone()\n     };\n \n     info!(\"%?\", args);"}, {"sha": "0046fb9dd12350295a3f475010ff9f737ef9d0d2", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -34,11 +34,11 @@ enum request {\n }\n \n fn server(requests: &PortSet<request>, responses: &Chan<uint>) {\n-    let mut count = 0;\n+    let mut count: uint = 0;\n     let mut done = false;\n     while !done {\n         match requests.try_recv() {\n-          Some(get_count) => { responses.send(copy count); }\n+          Some(get_count) => { responses.send(count.clone()); }\n           Some(bytes(b)) => {\n             //error!(\"server: received %? bytes\", b);\n             count += b;\n@@ -103,7 +103,7 @@ fn main() {\n     } else if args.len() <= 1u {\n         ~[~\"\", ~\"10000\", ~\"4\"]\n     } else {\n-        copy args\n+        args.clone()\n     };\n \n     info!(\"%?\", args);"}, {"sha": "a60e0b9e340bd7bc5b62e6122121ad180eaedded", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -77,7 +77,7 @@ fn main() {\n     } else if args.len() <= 1u {\n         ~[~\"\", ~\"10\", ~\"100\"]\n     } else {\n-        copy args\n+        args.clone()\n     };\n \n     let num_tasks = uint::from_str(args[1]).get();"}, {"sha": "b4692c774aa2c7b45b4a744ae4803ba3a40ad09d", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -63,7 +63,7 @@ fn main() {\n     } else if args.len() <= 1u {\n         ~[~\"\", ~\"100\", ~\"1000\"]\n     } else {\n-        copy args\n+        args.clone()\n     };\n \n     let num_tasks = uint::from_str(args[1]).get();"}, {"sha": "0c6b97c6b7819f5046ba9ed04bf596ebd1516b5b", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -73,7 +73,7 @@ fn main() {\n     } else if args.len() <= 1u {\n         ~[~\"\", ~\"10\", ~\"100\"]\n     } else {\n-        copy args\n+        args.clone()\n     };\n \n     let num_tasks = uint::from_str(args[1]).get();"}, {"sha": "f6e90d1b7456bf50975b769aad3ea4bb0c2fe4c5", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -37,6 +37,7 @@ fn myrandom_next(r: @mut MyRandom, mx: u32) -> u32 {\n     mx * r.last / 139968u32\n }\n \n+#[deriving(Clone)]\n struct AminoAcids {\n     ch: char,\n     prob: u32\n@@ -59,10 +60,14 @@ fn select_random(r: u32, genelist: ~[AminoAcids]) -> char {\n             let mid: uint = lo + (hi - lo) / 2u;\n             if target < v[mid].prob {\n                 return bisect(v, lo, mid, target);\n-            } else { return bisect(v, mid, hi, target); }\n-        } else { return v[hi].ch; }\n+            } else {\n+                return bisect(v, mid, hi, target);\n+            }\n+        } else {\n+            return v[hi].ch;\n+        }\n     }\n-    bisect(copy genelist, 0, genelist.len() - 1, r)\n+    bisect(genelist.clone(), 0, genelist.len() - 1, r)\n }\n \n fn make_random_fasta(wr: @io::Writer,\n@@ -78,7 +83,7 @@ fn make_random_fasta(wr: @io::Writer,\n     let mut op: ~str = ~\"\";\n     for uint::range(0u, n as uint) |_i| {\n         op.push_char(select_random(myrandom_next(rng, 100u32),\n-                                              copy genelist));\n+                                   genelist.clone()));\n         if op.len() >= LINE_LENGTH {\n             wr.write_line(op);\n             op = ~\"\";"}, {"sha": "64cfa2561a4bdac0d3a690816bd652f416c34198", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -34,22 +34,31 @@ fn sort_and_fmt(mm: &HashMap<~[u8], uint>, total: uint) -> ~str {\n       return (xx as float) * 100f / (yy as float);\n    }\n \n-   fn le_by_val<TT:Copy,UU:Copy + Ord>(kv0: &(TT,UU),\n-                                         kv1: &(TT,UU)) -> bool {\n-      let (_, v0) = copy *kv0;\n-      let (_, v1) = copy *kv1;\n+   fn le_by_val<TT:Copy + Clone,\n+                UU:Copy + Clone + Ord>(\n+                kv0: &(TT,UU),\n+                kv1: &(TT,UU))\n+                -> bool {\n+      let (_, v0) = (*kv0).clone();\n+      let (_, v1) = (*kv1).clone();\n       return v0 >= v1;\n    }\n \n-   fn le_by_key<TT:Copy + Ord,UU:Copy>(kv0: &(TT,UU),\n-                                         kv1: &(TT,UU)) -> bool {\n-      let (k0, _) = copy *kv0;\n-      let (k1, _) = copy *kv1;\n+   fn le_by_key<TT:Copy + Clone + Ord,\n+                UU:Copy + Clone>(\n+                kv0: &(TT,UU),\n+                kv1: &(TT,UU))\n+                -> bool {\n+      let (k0, _) = (*kv0).clone();\n+      let (k1, _) = (*kv1).clone();\n       return k0 <= k1;\n    }\n \n    // sort by key, then by value\n-   fn sortKV<TT:Copy + Ord,UU:Copy + Ord>(orig: ~[(TT,UU)]) -> ~[(TT,UU)] {\n+   fn sortKV<TT:Copy + Clone + Ord,\n+             UU:Copy + Clone + Ord>(\n+             orig: ~[(TT,UU)])\n+             -> ~[(TT,UU)] {\n       return sort::merge_sort(sort::merge_sort(orig, le_by_key), le_by_val);\n    }\n \n@@ -65,7 +74,7 @@ fn sort_and_fmt(mm: &HashMap<~[u8], uint>, total: uint) -> ~str {\n    let mut buffer = ~\"\";\n \n    for pairs_sorted.iter().advance |kv| {\n-       let (k,v) = copy *kv;\n+       let (k,v) = (*kv).clone();\n        unsafe {\n            let b = str::raw::from_bytes(k);\n            // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use"}, {"sha": "cbc2d3f0ea8871f9e51fcbaff33cb3c79ea1c2c0", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -105,7 +105,7 @@ fn main() {\n         args\n     };\n \n-    let opts = parse_opts(copy args);\n+    let opts = parse_opts(args.clone());\n \n     if opts.stress {\n         stress(2);"}, {"sha": "d3fd20a029358500bbe7a51b6f8feef6ef2bb69e", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -48,7 +48,7 @@ fn main() {\n     } else if args.len() <= 1 {\n         ~[~\"\", ~\"100\"]\n     } else {\n-        copy args\n+        args.clone()\n     };\n \n     let (p,c) = comm::stream();"}, {"sha": "e07e53347120b56df48a02915e9589806331de16", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -68,7 +68,7 @@ fn main() {\n     } else if args.len() <= 1u {\n         ~[~\"\", ~\"100\"]\n     } else {\n-        copy args\n+        args.clone()\n     };\n \n     let num_tasks = uint::from_str(args[1]).get();"}, {"sha": "d5c5597e57fce15f3d0794bd44e92e6872b51b27", "filename": "src/test/compile-fail/borrowck-lend-flow-match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -30,7 +30,7 @@ fn separate_arms() {\n             x = Some(1); //~ ERROR cannot assign\n         }\n     }\n-    copy x; // just to prevent liveness warnings\n+    x.clone(); // just to prevent liveness warnings\n }\n \n fn guard() {"}, {"sha": "39a0e585ad2db4b954012097258cdc7fba3e363f", "filename": "src/test/compile-fail/borrowck-move-out-of-vec-tail.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -1,5 +1,6 @@\n // Test that we do not permit moves from &[] matched by a vec pattern.\n \n+#[deriving(Clone)]\n struct Foo {\n     string: ~str\n }\n@@ -21,7 +22,7 @@ pub fn main() {\n                     ::std::util::unreachable();\n                 }\n             }\n-            let z = copy tail[0];\n+            let z = tail[0].clone();\n             info!(fmt!(\"%?\", z));\n         }\n         _ => {"}, {"sha": "8d9718ca380fbf1955ed3622db28065640ab5a42", "filename": "src/test/compile-fail/borrowck-pat-reassign-binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -22,5 +22,5 @@ fn main() {\n           x = Some(*i+1); //~ ERROR cannot assign to `x`\n       }\n     }\n-    copy x; // just to prevent liveness warnings\n+    x.clone(); // just to prevent liveness warnings\n }"}, {"sha": "460e2ce23fc9f0a65f1a5fe6db055b913a0ca19e", "filename": "src/test/compile-fail/by-move-pattern-binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fby-move-pattern-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fby-move-pattern-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fby-move-pattern-binding.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -13,7 +13,7 @@ fn main() {\n     let s = S { x: Bar(~\"hello\") };\n     match &s.x {\n         &Foo => {}\n-        &Bar(identifier) => f(copy identifier)  //~ ERROR cannot move\n+        &Bar(identifier) => f(identifier.clone())  //~ ERROR cannot move\n     };\n     match &s.x {\n         &Foo => {}"}, {"sha": "a90b04b79adc19c10621b040f9bc9d16c36346c7", "filename": "src/test/compile-fail/copy-a-resource.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -24,7 +24,7 @@ fn foo(i:int) -> foo {\n \n fn main() {\n     let x = foo(10);\n-    let _y = copy x;\n-    //~^ ERROR copying a value of non-copyable type `foo`\n+    let _y = x.clone();\n+    //~^ ERROR does not implement any method in scope\n     error!(x);\n }"}, {"sha": "1a7cc5d3ad5eb7c86d5335bb7bc3536c5e8b1aaa", "filename": "src/test/compile-fail/infinite-instantiation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -21,13 +21,13 @@ impl to_opt for uint {\n     }\n }\n \n-impl<T:Copy> to_opt for Option<T> {\n+impl<T:Clone> to_opt for Option<T> {\n     fn to_option(&self) -> Option<Option<T>> {\n-        Some(copy *self)\n+        Some((*self).clone())\n     }\n }\n \n-fn function<T:to_opt>(counter: uint, t: T) {\n+fn function<T:to_opt + Clone>(counter: uint, t: T) {\n     if counter > 0u {\n         function(counter - 1u, t.to_option());\n     }"}, {"sha": "95cb5c6475c187bd75b30c4e1fb0d2044d36de25", "filename": "src/test/compile-fail/issue-2823.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fissue-2823.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fissue-2823.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2823.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -20,6 +20,6 @@ impl Drop for C {\n \n fn main() {\n     let c = C{ x: 2};\n-    let d = copy c; //~ ERROR copying a value of non-copyable type `C`\n+    let d = c.clone(); //~ ERROR does not implement any method in scope\n     error!(\"%?\", d.x);\n }"}, {"sha": "93f55d55e46c13abad0beb958636d48914d6d71c", "filename": "src/test/compile-fail/issue-4542.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fissue-4542.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fissue-4542.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4542.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -12,7 +12,7 @@\n \n fn main() {\n     for os::args().each |arg| {\n-        match copy *arg {\n+        match (*arg).clone() {\n             s => { }\n         }\n     }"}, {"sha": "ed21df4a691acefed423b08b5f06f0d62c230bc6", "filename": "src/test/compile-fail/kindck-owned.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn copy1<T:Copy>(t: T) -> @fn() -> T {\n-    let result: @fn() -> T = || copy t; //~ ERROR does not fulfill `'static`\n+fn copy1<T:Clone>(t: T) -> @fn() -> T {\n+    let result: @fn() -> T = || t.clone();  //~ ERROR does not fulfill `'static`\n     result\n }\n \n-fn copy2<T:Copy + 'static>(t: T) -> @fn() -> T {\n-    let result: @fn() -> T = || copy t;\n+fn copy2<T:Clone + 'static>(t: T) -> @fn() -> T {\n+    let result: @fn() -> T = || t.clone();\n     result\n }\n \n@@ -24,11 +24,14 @@ fn main() {\n \n     copy2(@3);\n     copy2(@&x); //~ ERROR does not fulfill `'static`\n+<<<<<<< HEAD\n \n     let boxed: @fn() = || {};\n     copy2(boxed);\n     let owned: ~fn() = || {};\n     copy2(owned);    //~ ERROR does not fulfill `Copy`\n     let borrowed: &fn:Copy() = || {};\n     copy2(borrowed); //~ ERROR does not fulfill `'static`\n+=======\n+>>>>>>> librustc: Remove all uses of \"copy\".\n }"}, {"sha": "f8afc10c49b9de089b2dceed8afd771ccf69648e", "filename": "src/test/compile-fail/liveness-assign-imm-local-in-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-loop.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -13,7 +13,7 @@ fn test() {\n     loop {\n         v = 1; //~ ERROR re-assignment of immutable variable\n         //~^ NOTE prior assignment occurs here\n-        copy v; // just to prevent liveness warnings\n+        v.clone(); // just to prevent liveness warnings\n     }\n }\n "}, {"sha": "43d7ca8375328371ec75a066340a98a1b8f1d620", "filename": "src/test/compile-fail/liveness-assign-imm-local-in-op-eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-op-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-op-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-op-eq.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -12,7 +12,7 @@ fn test() {\n     let v: int;\n     v = 2;  //~ NOTE prior assignment occurs here\n     v += 1; //~ ERROR re-assignment of immutable variable\n-    copy v;\n+    v.clone();\n }\n \n fn main() {"}, {"sha": "8eb84525b83967518ff29749f429605aaaa86b48", "filename": "src/test/compile-fail/liveness-assign-imm-local-with-init.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-with-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-with-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-with-init.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -10,9 +10,9 @@\n \n fn test() {\n     let v: int = 1; //~ NOTE prior assignment occurs here\n-    copy v;\n+    v.clone();\n     v = 2; //~ ERROR re-assignment of immutable variable\n-    copy v;\n+    v.clone();\n }\n \n fn main() {"}, {"sha": "df78b25187bf2304f257ee542a4bc650c8e9f35b", "filename": "src/test/compile-fail/liveness-dead.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fliveness-dead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fliveness-dead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-dead.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -15,14 +15,14 @@ fn f1(x: &mut int) {\n }\n \n fn f2() {\n-    let mut x = 3; //~ ERROR: value assigned to `x` is never read\n+    let mut x: int = 3; //~ ERROR: value assigned to `x` is never read\n     x = 4;\n-    copy x;\n+    x.clone();\n }\n \n fn f3() {\n-    let mut x = 3;\n-    copy x;\n+    let mut x: int = 3;\n+    x.clone();\n     x = 4; //~ ERROR: value assigned to `x` is never read\n }\n "}, {"sha": "96b3c2453c56f44dac511884d106a7377198303f", "filename": "src/test/compile-fail/liveness-init-in-fru.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fliveness-init-in-fru.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fliveness-init-in-fru.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-init-in-fru.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -9,11 +9,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-struct point {x: int, y: int}\n+#[deriving(Clone)]\n+struct point {\n+    x: int,\n+    y: int,\n+}\n \n fn main() {\n     let mut origin: point;\n     origin = point {x: 10,.. origin}; //~ ERROR use of possibly uninitialized variable: `origin`\n-    copy origin;\n+    origin.clone();\n }"}, {"sha": "cbe805551c2007011d5c4eff9d379b549562cb78", "filename": "src/test/compile-fail/liveness-init-op-equal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fliveness-init-op-equal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fliveness-init-op-equal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-init-op-equal.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -11,7 +11,7 @@\n fn test() {\n     let v: int;\n     v += 1; //~ ERROR use of possibly uninitialized variable: `v`\n-    copy v;\n+    v.clone();\n }\n \n fn main() {"}, {"sha": "6e813809f03dc2d41e66b89817079882307998de", "filename": "src/test/compile-fail/liveness-init-plus-equal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fliveness-init-plus-equal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fliveness-init-plus-equal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-init-plus-equal.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -11,7 +11,7 @@\n fn test() {\n     let mut v: int;\n     v = v + 1; //~ ERROR use of possibly uninitialized variable: `v`\n-    copy v;\n+    v.clone();\n }\n \n fn main() {"}, {"sha": "b6cecf0145ce91c95089c245d22c051b36f1d66a", "filename": "src/test/compile-fail/liveness-move-in-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-loop.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -17,7 +17,7 @@ fn main() {\n             loop {\n                 loop {\n                     x = y; //~ ERROR use of moved value\n-                    copy x;\n+                    x.clone();\n                 }\n             }\n         }"}, {"sha": "eed7ba16da4159e9607395834719c89cfc1027f7", "filename": "src/test/compile-fail/liveness-move-in-while.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-while.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -14,7 +14,7 @@ fn main() {\n     let mut x: ~int;\n     loop {\n         info!(y); //~ ERROR use of moved value: `y`\n-        while true { while true { while true { x = y; copy x; } } }\n+        while true { while true { while true { x = y; x.clone(); } } }\n         //~^ ERROR use of moved value: `y`\n     }\n }"}, {"sha": "3423c780c4aec1c26a4ed797d0318604c179270e", "filename": "src/test/compile-fail/liveness-use-after-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -12,5 +12,5 @@ fn main() {\n     let x = ~5;\n     let y = x;\n     info!(*x); //~ ERROR use of moved value: `x`\n-    copy y;\n+    y.clone();\n }"}, {"sha": "b70c9e11f34c4af267e993b4c0d102d2c0e0bf58", "filename": "src/test/compile-fail/moves-based-on-type-distribute-copy-over-paren.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-distribute-copy-over-paren.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-distribute-copy-over-paren.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-distribute-copy-over-paren.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -18,25 +18,25 @@ fn f05() {\n \n fn f10() {\n     let x = ~\"hi\";\n-    let _y = Foo { f:copy x };\n+    let _y = Foo { f:x.clone() };\n     touch(&x);\n }\n \n fn f20() {\n     let x = ~\"hi\";\n-    let _y = Foo { f:copy (x) };\n+    let _y = Foo { f:(x).clone() };\n     touch(&x);\n }\n \n fn f30() {\n     let x = ~\"hi\";\n-    let _y = Foo { f:copy ((x)) };\n+    let _y = Foo { f:((x)).clone() };\n     touch(&x);\n }\n \n fn f40() {\n     let x = ~\"hi\";\n-    let _y = Foo { f:(((((copy ((x))))))) };\n+    let _y = Foo { f:(((((((x)).clone()))))) };\n     touch(&x);\n }\n "}, {"sha": "64d29a5575635c530320a63d83ebbcba46a823c8", "filename": "src/test/compile-fail/non-copyable-void.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -14,7 +14,7 @@ fn main() {\n     let x : *~[int] = &~[1,2,3];\n     let y : *libc::c_void = x as *libc::c_void;\n     unsafe {\n-        let _z = copy *y;\n-        //~^ ERROR copying a value of non-copyable type\n+        let _z = (*y).clone();\n+        //~^ ERROR does not implement any method in scope\n     }\n }"}, {"sha": "e64d5b67ab76893678ff75fe959f09febc5f0649", "filename": "src/test/compile-fail/noncopyable-class.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -38,6 +38,6 @@ fn foo(i:int) -> foo {\n \n fn main() {\n     let x = foo(10);\n-    let _y = copy x; //~ ERROR copying a value of non-copyable type\n+    let _y = x.clone(); //~ ERROR does not implement any method in scope\n     error!(x);\n }"}, {"sha": "ccbe265000df28186ceaa6e64d3dbeddc816b04b", "filename": "src/test/compile-fail/pinned-deep-copy.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fpinned-deep-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Fpinned-deep-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpinned-deep-copy.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -27,13 +27,16 @@ fn r(i: @mut int) -> r {\n     }\n }\n \n+struct A {\n+    y: r,\n+}\n+\n fn main() {\n     let i = @mut 0;\n     {\n-        struct A { y: r }\n         // Can't do this copy\n         let x = ~~~A {y: r(i)};\n-        let _z = copy x; //~ ERROR copying a value of non-copyable type\n+        let _z = x.clone(); //~ ERROR failed to find an implementation\n         info!(x);\n     }\n     error!(*i);"}, {"sha": "ace0f516eef03b5cfbedfe8e9893c3522f885f77", "filename": "src/test/compile-fail/unique-object-noncopyable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Funique-object-noncopyable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Funique-object-noncopyable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-object-noncopyable.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -29,5 +29,5 @@ impl Foo for Bar {\n fn main() {\n     let x = ~Bar { x: 10 };\n     let y: ~Foo = x as ~Foo;\n-    let _z = copy y; //~ ERROR copying a value of non-copyable type\n+    let _z = y.clone(); //~ ERROR does not implement any method in scope\n }"}, {"sha": "0218899bf2ed5a99efde3d4dc43b5d7e13386c6a", "filename": "src/test/compile-fail/unique-pinned-nocopy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n struct r {\n-  b:bool,\n+  b: bool,\n }\n \n impl Drop for r {\n@@ -18,6 +18,6 @@ impl Drop for r {\n \n fn main() {\n     let i = ~r { b: true };\n-    let _j = copy i; //~ ERROR copying a value of non-copyable type\n+    let _j = i.clone(); //~ ERROR failed to find an implementation\n     info!(i);\n }"}, {"sha": "bee36ea8293457f956de275bee85c56d03997c39", "filename": "src/test/compile-fail/unique-vec-res.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -29,9 +29,8 @@ fn main() {\n     let i2 = @mut 1;\n     let r1 = ~[~r { i: i1 }];\n     let r2 = ~[~r { i: i2 }];\n-    f(copy r1, copy r2);\n-    //~^ ERROR copying a value of non-copyable type\n-    //~^^ ERROR copying a value of non-copyable type\n+    f(r1.clone(), r2.clone());\n+    //~^ ERROR failed to find an implementation of\n     info!((r2, *i1));\n     info!((r1, *i2));\n }"}, {"sha": "38a72353a1e39f76d0d9d48cab8f9e050be7a0d3", "filename": "src/test/run-fail/unwind-box-fn-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-fail%2Funwind-box-fn-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-fail%2Funwind-box-fn-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-box-fn-unique.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -17,7 +17,7 @@ fn failfn() {\n fn main() {\n     let y = ~0;\n     let x: @~fn() = @(|| {\n-        error!(copy y);\n+        error!(y.clone());\n     });\n     failfn();\n     error!(x);"}, {"sha": "a94f904c4921ab21c86818f5130207dc7da4956f", "filename": "src/test/run-fail/unwind-box-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-fail%2Funwind-box-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-fail%2Funwind-box-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-box-fn.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -17,7 +17,7 @@ fn failfn() {\n fn main() {\n     let y = ~0;\n     let x: @@fn() = @|| {\n-        error!(copy y);\n+        error!(y.clone());\n     };\n     failfn();\n     error!(x);"}, {"sha": "640be6635ee293181b462a26d675f24e3c21ea1d", "filename": "src/test/run-fail/unwind-lambda.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-fail%2Funwind-lambda.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-fail%2Funwind-lambda.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-lambda.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -15,11 +15,11 @@ fn main() {\n     let carrots = @~\"crunchy\";\n \n     let result: @fn(@~str, &fn(~str)) = (|tasties, macerate| {\n-        macerate(copy *tasties);\n+        macerate((*tasties).clone());\n     });\n     result(carrots, |food| {\n         let mush = food + cheese;\n-        let cheese = copy cheese;\n+        let cheese = cheese.clone();\n         let f: &fn() = || {\n             let chew = mush + cheese;\n             fail!(\"so yummy\")"}, {"sha": "75af701cedeae70620042153bd003c6c9a6b1660", "filename": "src/test/run-fail/unwind-misc-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -18,7 +18,7 @@ fn main() {\n     let mut arr = ~[];\n     for uint::range(0u, 10u) |i| {\n         arr += ~[@~\"key stuff\"];\n-        map.insert(copy arr, arr + ~[@~\"value stuff\"]);\n+        map.insert(arr.clone(), arr + ~[@~\"value stuff\"]);\n         if arr.len() == 5 {\n             fail!();\n         }"}, {"sha": "a821e4647c12831c2019a507ff151a1c38764065", "filename": "src/test/run-pass/alignment-gep-tup-like-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -12,8 +12,8 @@ struct pair<A,B> {\n     a: A, b: B\n }\n \n-fn f<A:Copy + 'static>(a: A, b: u16) -> @fn() -> (A, u16) {\n-    let result: @fn() -> (A, u16) = || (copy a, b);\n+fn f<A:Clone + 'static>(a: A, b: u16) -> @fn() -> (A, u16) {\n+    let result: @fn() -> (A, u16) = || (a.clone(), b);\n     result\n }\n "}, {"sha": "1d910023a636875262b41e71afebf931d817c56d", "filename": "src/test/run-pass/alignment-gep-tup-like-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -18,13 +18,13 @@ struct Rec<A> {\n     rec: Option<@mut RecEnum<A>>\n }\n \n-fn make_cycle<A:Copy>(a: A) {\n+fn make_cycle<A>(a: A) {\n     let g: @mut RecEnum<A> = @mut RecEnum(Rec {val: a, rec: None});\n     g.rec = Some(g);\n }\n \n-fn f<A:Send + Copy,B:Send + Copy>(a: A, b: B) -> @fn() -> (A, B) {\n-    let result: @fn() -> (A, B) = || (copy a, copy b);\n+fn f<A:Send + Clone,B:Send + Clone>(a: A, b: B) -> @fn() -> (A, B) {\n+    let result: @fn() -> (A, B) = || (a.clone(), b.clone());\n     result\n }\n "}, {"sha": "11751ed6ade3b271dde772d81dc0edf85d92262b", "filename": "src/test/run-pass/borrowed-ptr-pattern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo<T:Copy>(x: &T) -> T{\n+fn foo<T:Clone>(x: &T) -> T{\n     match x {\n-        &ref a => copy *a\n+        &ref a => (*a).clone()\n     }\n }\n "}, {"sha": "2e92395d5490795296cad5b2bc37d93507cedaff", "filename": "src/test/run-pass/box-unbox.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-unbox.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -12,7 +12,7 @@\n \n struct Box<T> {c: @T}\n \n-fn unbox<T:Copy>(b: Box<T>) -> T { return copy *b.c; }\n+fn unbox<T:Clone>(b: Box<T>) -> T { return (*b.c).clone(); }\n \n pub fn main() {\n     let foo: int = 17;"}, {"sha": "97bcd7c5308ab8517354fdf75fa395243f092fd8", "filename": "src/test/run-pass/class-cast-to-trait-multiple-types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -46,6 +46,7 @@ fn dog() -> dog {\n     }\n }\n \n+#[deriving(Clone)]\n struct cat {\n   priv meows : @mut uint,\n \n@@ -88,7 +89,7 @@ fn annoy_neighbors(critter: @noisy) {\n pub fn main() {\n   let nyan : cat  = cat(0u, 2, ~\"nyan\");\n   let whitefang : dog = dog();\n-  annoy_neighbors(@(copy nyan) as @noisy);\n+  annoy_neighbors(@nyan.clone() as @noisy);\n   annoy_neighbors(@whitefang as @noisy);\n   assert_eq!(nyan.meow_count(), 10u);\n   assert_eq!(*whitefang.volume, 1);"}, {"sha": "59de9e9e76e82e9fb358d1fce05abd0da566bbb7", "filename": "src/test/run-pass/class-implement-traits.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -16,6 +16,7 @@ trait noisy {\n   fn speak(&mut self);\n }\n \n+#[deriving(Clone)]\n struct cat {\n     priv meows : uint,\n \n@@ -68,6 +69,6 @@ pub fn main() {\n   nyan.eat();\n   assert!((!nyan.eat()));\n   for uint::range(1u, 10u) |_i| {\n-    make_speak(copy nyan);\n+    make_speak(nyan.clone());\n   }\n }"}, {"sha": "01c6442fa00b86263db84c875a1f38c538055c54", "filename": "src/test/run-pass/close-over-big-then-small-data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -16,8 +16,8 @@ struct Pair<A,B> {\n     a: A, b: B\n }\n \n-fn f<A:Copy + 'static>(a: A, b: u16) -> @fn() -> (A, u16) {\n-    let result: @fn() -> (A, u16) = || (copy a, b);\n+fn f<A:Clone + 'static>(a: A, b: u16) -> @fn() -> (A, u16) {\n+    let result: @fn() -> (A, u16) = || (a.clone(), b);\n     result\n }\n "}, {"sha": "8c2ae22e8edfcc343e5ac87dc21cd67cf962384e", "filename": "src/test/run-pass/closure-bounds-copyable-squiggle-closure.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Ftest%2Frun-pass%2Fclosure-bounds-copyable-squiggle-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Ftest%2Frun-pass%2Fclosure-bounds-copyable-squiggle-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-bounds-copyable-squiggle-closure.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Tests correct copying of heap closures' environments.\n-\n-fn foo(x: ~fn:Copy()) -> (~fn:(), ~fn:()) {\n-    (copy x, x)\n-}\n-fn main() {\n-    let v = ~[~[1,2,3],~[4,5,6]]; // shouldn't get double-freed\n-    let (f1,f2) = do foo {\n-        assert!(v.len() == 2);\n-    };\n-    f1();\n-    f2();\n-}"}, {"sha": "88d474a51e1da03904f64c1ce695d1c6d7f480c6", "filename": "src/test/run-pass/closure-bounds-squiggle-closure-as-copyable-typaram.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Ftest%2Frun-pass%2Fclosure-bounds-squiggle-closure-as-copyable-typaram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Ftest%2Frun-pass%2Fclosure-bounds-squiggle-closure-as-copyable-typaram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-bounds-squiggle-closure-as-copyable-typaram.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Tests correct copying of heap closures' environments.\n-\n-fn bar<T: Copy>(x: T) -> (T, T) {\n-    (copy x, x)\n-}\n-fn foo(x: ~fn:Copy()) -> (~fn:(), ~fn:()) {\n-    bar(x)\n-}\n-fn main() {\n-    let v = ~[~[1,2,3],~[4,5,6]]; // shouldn't get double-freed\n-    let (f1,f2) = do foo {\n-        assert!(v.len() == 2);\n-    };\n-    f1();\n-    f2();\n-}"}, {"sha": "295f175fca4f7937a9709d36ea1874c942623e22", "filename": "src/test/run-pass/explicit-self.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fexplicit-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fexplicit-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -41,12 +41,15 @@ fn select_based_on_unit_circle<'r, T>(\n     shape.select(threshold, a, b)\n }\n \n-\n+#[deriving(Clone)]\n struct thing {\n     x: A\n }\n \n-struct A { a: @int }\n+#[deriving(Clone)]\n+struct A {\n+    a: @int\n+}\n \n fn thing(x: A) -> thing {\n     thing {\n@@ -72,7 +75,7 @@ pub fn main() {\n     assert_eq!(x.quux(), 10);\n \n     let y = ~thing(A {a: @10});\n-    assert_eq!((copy y).bar(), 10);\n+    assert_eq!(y.clone().bar(), 10);\n     assert_eq!(y.quux(), 10);\n \n     let z = thing(A {a: @11});"}, {"sha": "7d849bbff01ce2a1a3f44e36bbec5a313b07179b", "filename": "src/test/run-pass/expr-block-generic-box2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -13,8 +13,8 @@\n \n type compare<T> = @fn(T, T) -> bool;\n \n-fn test_generic<T:Copy>(expected: T, eq: compare<T>) {\n-    let actual: T = { copy expected };\n+fn test_generic<T:Clone>(expected: T, eq: compare<T>) {\n+    let actual: T = { expected.clone() };\n     assert!((eq(expected, actual)));\n }\n "}, {"sha": "389a42ae7af71148b20ad9d619c5459be11aad0c", "filename": "src/test/run-pass/expr-block-generic-unique2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -13,8 +13,8 @@\n \n type compare<T> = @fn(T, T) -> bool;\n \n-fn test_generic<T:Copy>(expected: T, eq: compare<T>) {\n-    let actual: T = { copy expected };\n+fn test_generic<T:Clone>(expected: T, eq: compare<T>) {\n+    let actual: T = { expected.clone() };\n     assert!((eq(expected, actual)));\n }\n "}, {"sha": "7091fceb7715ea72973eebf65046b05697563b78", "filename": "src/test/run-pass/expr-block-generic.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -15,8 +15,8 @@\n // Tests for standalone blocks as expressions with dynamic type sizes\n type compare<T> = @fn(T, T) -> bool;\n \n-fn test_generic<T:Copy>(expected: T, eq: compare<T>) {\n-    let actual: T = { copy expected };\n+fn test_generic<T:Clone>(expected: T, eq: compare<T>) {\n+    let actual: T = { expected.clone() };\n     assert!((eq(expected, actual)));\n }\n \n@@ -25,7 +25,11 @@ fn test_bool() {\n     test_generic::<bool>(true, compare_bool);\n }\n \n-struct Pair {a: int, b: int}\n+#[deriving(Clone)]\n+struct Pair {\n+    a: int,\n+    b: int,\n+}\n \n fn test_rec() {\n     fn compare_rec(t1: Pair, t2: Pair) -> bool {"}, {"sha": "a2d28a2be041c31bc8f1f88f9fadddc231d3fb15", "filename": "src/test/run-pass/expr-if-generic-box2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -13,8 +13,8 @@\n \n type compare<T> = @fn(T, T) -> bool;\n \n-fn test_generic<T:Copy>(expected: T, not_expected: T, eq: compare<T>) {\n-    let actual: T = if true { copy expected } else { not_expected };\n+fn test_generic<T:Clone>(expected: T, not_expected: T, eq: compare<T>) {\n+    let actual: T = if true { expected.clone() } else { not_expected };\n     assert!((eq(expected, actual)));\n }\n "}, {"sha": "f5b2a1a79869b058d1812afd605a364949e8a9e7", "filename": "src/test/run-pass/expr-if-generic.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -14,8 +14,8 @@\n // Tests for if as expressions with dynamic type sizes\n type compare<T> = @fn(T, T) -> bool;\n \n-fn test_generic<T:Copy>(expected: T, not_expected: T, eq: compare<T>) {\n-    let actual: T = if true { copy expected } else { not_expected };\n+fn test_generic<T:Clone>(expected: T, not_expected: T, eq: compare<T>) {\n+    let actual: T = if true { expected.clone() } else { not_expected };\n     assert!((eq(expected, actual)));\n }\n \n@@ -24,7 +24,11 @@ fn test_bool() {\n     test_generic::<bool>(true, false, compare_bool);\n }\n \n-struct Pair {a: int, b: int}\n+#[deriving(Clone)]\n+struct Pair {\n+    a: int,\n+    b: int,\n+}\n \n fn test_rec() {\n     fn compare_rec(t1: Pair, t2: Pair) -> bool {"}, {"sha": "a2ccf5c0fb906452e33b0cd42fbd01a9c6718904", "filename": "src/test/run-pass/expr-match-generic-box2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fexpr-match-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fexpr-match-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-match-generic-box2.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -13,8 +13,8 @@\n \n type compare<T> = @fn(T, T) -> bool;\n \n-fn test_generic<T:Copy>(expected: T, eq: compare<T>) {\n-    let actual: T = match true { true => { copy expected }, _ => fail!(\"wat\") };\n+fn test_generic<T:Clone>(expected: T, eq: compare<T>) {\n+    let actual: T = match true { true => { expected.clone() }, _ => fail!(\"wat\") };\n     assert!((eq(expected, actual)));\n }\n "}, {"sha": "59f1ff14f5902047f8f4cd691460f0aceae9fa26", "filename": "src/test/run-pass/expr-match-generic.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fexpr-match-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fexpr-match-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-match-generic.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -13,8 +13,8 @@\n \n type compare<T> = @fn(T, T) -> bool;\n \n-fn test_generic<T:Copy>(expected: T, eq: compare<T>) {\n-  let actual: T = match true { true => { copy expected }, _ => fail!(\"wat\") };\n+fn test_generic<T:Clone>(expected: T, eq: compare<T>) {\n+  let actual: T = match true { true => { expected.clone() }, _ => fail!(\"wat\") };\n     assert!((eq(expected, actual)));\n }\n \n@@ -23,7 +23,11 @@ fn test_bool() {\n     test_generic::<bool>(true, compare_bool);\n }\n \n-struct Pair { a: int, b: int }\n+#[deriving(Clone)]\n+struct Pair {\n+    a: int,\n+    b: int,\n+}\n \n fn test_rec() {\n     fn compare_rec(t1: Pair, t2: Pair) -> bool {"}, {"sha": "3c30a6b53afa3443db3e89677c78729b8b431379", "filename": "src/test/run-pass/generic-derived-type.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -10,12 +10,16 @@\n \n \n \n-fn g<X:Copy>(x: X) -> X { return x; }\n+fn g<X>(x: X) -> X { return x; }\n \n-struct Pair<T> {a: T, b: T}\n+#[deriving(Clone)]\n+struct Pair<T> {\n+    a: T,\n+    b: T\n+}\n \n-fn f<T:Copy>(t: T) -> Pair<T> {\n-    let x: Pair<T> = Pair {a: copy t, b: t};\n+fn f<T:Clone>(t: T) -> Pair<T> {\n+    let x: Pair<T> = Pair {a: t.clone(), b: t};\n     return g::<Pair<T>>(x);\n }\n "}, {"sha": "161f37eb444e0a94664afcf1c24eb18c14f8cb79", "filename": "src/test/run-pass/getopts_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fgetopts_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fgetopts_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgetopts_ref.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -21,7 +21,7 @@ pub fn main() {\n     match getopts(args, opts) {\n         Ok(ref m)  =>\n             assert!(!opt_present(m, \"b\")),\n-        Err(ref f) => fail!(fail_str(copy *f))\n+        Err(ref f) => fail!(fail_str((*f).clone()))\n     };\n \n }"}, {"sha": "aa9be2203c6b2540b909ef9f118fbe0ae8f68323", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -23,37 +23,30 @@ enum object {\n \n fn lookup(table: ~json::Object, key: ~str, default: ~str) -> ~str\n {\n-    match table.find(&key)\n-    {\n-        option::Some(&extra::json::String(ref s)) =>\n-        {\n-            copy *s\n+    match table.find(&key) {\n+        option::Some(&extra::json::String(ref s)) => {\n+            (*s).clone()\n         }\n-        option::Some(value) =>\n-        {\n+        option::Some(value) => {\n             error!(\"%s was expected to be a string but is a %?\", key, value);\n             default\n         }\n-        option::None =>\n-        {\n+        option::None => {\n             default\n         }\n     }\n }\n \n fn add_interface(store: int, managed_ip: ~str, data: extra::json::Json) -> (~str, object)\n {\n-    match &data\n-    {\n-        &extra::json::Object(ref interface) =>\n-        {\n-            let name = lookup(copy *interface, ~\"ifDescr\", ~\"\");\n+    match &data {\n+        &extra::json::Object(ref interface) => {\n+            let name = lookup((*interface).clone(), ~\"ifDescr\", ~\"\");\n             let label = fmt!(\"%s-%s\", managed_ip, name);\n \n             (label, bool_value(false))\n         }\n-        _ =>\n-        {\n+        _ => {\n             error!(\"Expected dict for %s interfaces but found %?\", managed_ip, data);\n             (~\"gnos:missing-interface\", bool_value(true))\n         }\n@@ -67,7 +60,7 @@ fn add_interfaces(store: int, managed_ip: ~str, device: HashMap<~str, extra::jso\n         &extra::json::List(ref interfaces) =>\n         {\n           do interfaces.map |interface| {\n-                add_interface(store, copy managed_ip, copy *interface)\n+                add_interface(store, managed_ip.clone(), (*interface).clone())\n           }\n         }\n         _ =>"}, {"sha": "387b0a68d21785ed38b457cb9478fe413fb05b96", "filename": "src/test/run-pass/issue-4241.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4241.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -103,7 +103,7 @@ priv fn cmd_to_str(cmd: ~[~str]) -> ~str {\n   res.push_str(\"\\r\\n\");\n     for cmd.iter().advance |s| {\n     res.push_str([~\"$\", s.len().to_str(), ~\"\\r\\n\",\n-                  copy *s, ~\"\\r\\n\"].concat() );\n+                  (*s).clone(), ~\"\\r\\n\"].concat() );\n     }\n   res\n }"}, {"sha": "61c63245d7026d57a235233b56590d0d38a774ad", "filename": "src/test/run-pass/ivec-add.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fivec-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fivec-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-add.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn double<T:Copy>(a: T) -> ~[T] { return ~[copy a] + ~[a]; }\n+fn double<T:Copy + Clone>(a: T) -> ~[T] { return ~[a.clone()] + ~[a]; }\n \n fn double_int(a: int) -> ~[int] { return ~[a] + ~[a]; }\n "}, {"sha": "1370aea6df50db0415b61f1532d3333ae9228e2d", "filename": "src/test/run-pass/kindck-owned-trait-contains-1.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -10,11 +10,13 @@\n \n trait repeat<A> { fn get(&self) -> A; }\n \n-impl<A:Copy> repeat<A> for @A {\n-    fn get(&self) -> A { copy **self }\n+impl<A:Clone> repeat<A> for @A {\n+    fn get(&self) -> A {\n+        (**self).clone()\n+    }\n }\n \n-fn repeater<A:Copy>(v: @A) -> @repeat:<A> {\n+fn repeater<A:Clone>(v: @A) -> @repeat:<A> {\n     // Note: owned kind is not necessary as A appears in the trait type\n     @v as @repeat:<A> // No\n }"}, {"sha": "ac6dfa00f484174b3d0021d2ec48df140e54d577", "filename": "src/test/run-pass/move-1-unique.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fmove-1-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fmove-1-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-1-unique.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -8,7 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct Triple { x: int, y: int, z: int }\n+#[deriving(Clone)]\n+struct Triple {\n+    x: int,\n+    y: int,\n+    z: int,\n+}\n \n fn test(x: bool, foo: ~Triple) -> int {\n     let bar = foo;\n@@ -19,8 +24,8 @@ fn test(x: bool, foo: ~Triple) -> int {\n \n pub fn main() {\n     let x = ~Triple{x: 1, y: 2, z: 3};\n-    assert_eq!(test(true, copy x), 2);\n-    assert_eq!(test(true, copy x), 2);\n-    assert_eq!(test(true, copy x), 2);\n+    assert_eq!(test(true, x.clone()), 2);\n+    assert_eq!(test(true, x.clone()), 2);\n+    assert_eq!(test(true, x.clone()), 2);\n     assert_eq!(test(false, x), 5);\n }"}, {"sha": "377fae52f49014defb34c8b78099026ad68b38ef", "filename": "src/test/run-pass/move-3-unique.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fmove-3-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fmove-3-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-3-unique.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -12,7 +12,12 @@ extern mod extra;\n \n use std::uint;\n \n-struct Triple { x: int, y: int, z: int }\n+#[deriving(Clone)]\n+struct Triple {\n+    x: int,\n+    y: int,\n+    z: int,\n+}\n \n fn test(x: bool, foo: ~Triple) -> int {\n     let bar = foo;\n@@ -24,7 +29,7 @@ fn test(x: bool, foo: ~Triple) -> int {\n pub fn main() {\n     let x = ~Triple{x: 1, y: 2, z: 3};\n     for uint::range(0u, 10000u) |_i| {\n-        assert_eq!(test(true, copy x), 2);\n+        assert_eq!(test(true, x.clone()), 2);\n     }\n     assert_eq!(test(false, x), 5);\n }"}, {"sha": "694773f4c7c421a96aab1d33f9f1db1a0ba787f8", "filename": "src/test/run-pass/newtype-polymorphic.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -8,15 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[deriving(Clone)]\n struct myvec<X>(~[X]);\n \n-fn myvec_deref<X:Copy>(mv: myvec<X>) -> ~[X] { return copy *mv; }\n+fn myvec_deref<X:Clone>(mv: myvec<X>) -> ~[X] { return (*mv).clone(); }\n \n-fn myvec_elt<X:Copy>(mv: myvec<X>) -> X { return mv[0]; }\n+fn myvec_elt<X>(mv: myvec<X>) -> X { return mv[0]; }\n \n pub fn main() {\n     let mv = myvec(~[1, 2, 3]);\n-    assert_eq!(myvec_deref(copy mv)[1], 2);\n-    assert_eq!(myvec_elt(copy mv), 1);\n+    assert_eq!(myvec_deref(mv.clone())[1], 2);\n+    assert_eq!(myvec_elt(mv.clone()), 1);\n     assert_eq!(mv[2], 3);\n }"}, {"sha": "62bd54e439527e2919980ae30019d096aa8db8d6", "filename": "src/test/run-pass/nullable-pointer-iotareduction.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -1,3 +1,7 @@\n+// xfail-test\n+\n+// xfail'd due to a bug in move detection for macros.\n+\n // Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n@@ -36,23 +40,25 @@ impl<T> E<T> {\n \n macro_rules! check_option {\n     ($e:expr: $T:ty) => {{\n-        check_option!(copy $e: $T, |ptr| assert!(*ptr == $e));\n+        check_option!($e: $T, |ptr| assert!(*ptr == $e));\n     }};\n     ($e:expr: $T:ty, |$v:ident| $chk:expr) => {{\n         assert!(option::None::<$T>.is_none());\n-        let s_ = option::Some::<$T>($e);\n+        let e = $e;\n+        let s_ = option::Some::<$T>(e);\n         let $v = s_.get_ref();\n         $chk\n     }}\n }\n \n macro_rules! check_fancy {\n     ($e:expr: $T:ty) => {{\n-        check_fancy!(copy $e: $T, |ptr| assert!(*ptr == $e));\n+        check_fancy!($e: $T, |ptr| assert!(*ptr == $e));\n     }};\n     ($e:expr: $T:ty, |$v:ident| $chk:expr) => {{\n         assert!(Nothing::<$T>((), ((), ()), [23i8, ..0]).is_none());\n-        let t_ = Thing::<$T>(23, $e);\n+        let e = $e;\n+        let t_ = Thing::<$T>(23, e);\n         match t_.get_ref() {\n             (23, $v) => { $chk }\n             _ => fail!(\"Thing::<%s>(23, %s).get_ref() != (23, _)\",\n@@ -74,7 +80,6 @@ pub fn main() {\n     check_type!(@19: @int);\n     check_type!(~\"foo\": ~str);\n     check_type!(@\"bar\": @str);\n-    check_type!(~[]: ~[int]);\n     check_type!(~[20, 22]: ~[int]);\n     check_type!(@[]: @[int]);\n     check_type!(@[24, 26]: @[int]);"}, {"sha": "824cacc620db971670d122e4f5613049d991efeb", "filename": "src/test/run-pass/overload-index-operator.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Foverload-index-operator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Foverload-index-operator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverload-index-operator.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -17,6 +17,7 @@ struct AssociationList<K,V> {\n     pairs: ~[AssociationPair<K,V>]\n }\n \n+#[deriving(Clone)]\n struct AssociationPair<K,V> {\n     key: K,\n     value: V\n@@ -28,11 +29,11 @@ impl<K,V> AssociationList<K,V> {\n     }\n }\n \n-impl<K:Eq,V:Copy> Index<K,V> for AssociationList<K,V> {\n+impl<K:Eq,V:Clone> Index<K,V> for AssociationList<K,V> {\n     fn index(&self, index: &K) -> V {\n         for self.pairs.iter().advance |pair| {\n             if pair.key == *index {\n-                return copy pair.value;\n+                return pair.value.clone();\n             }\n         }\n         fail!(\"No value found for key: %?\", index);\n@@ -44,8 +45,8 @@ pub fn main() {\n     let bar = ~\"bar\";\n \n     let mut list = AssociationList {pairs: ~[]};\n-    list.push(copy foo, 22);\n-    list.push(copy bar, 44);\n+    list.push(foo.clone(), 22);\n+    list.push(bar.clone(), 44);\n \n     assert!(list[foo] == 22)\n     assert!(list[bar] == 44)"}, {"sha": "faae814821d7af011ce917715704f948bf014370", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -499,9 +499,9 @@ struct Stuff {\n }\n \n impl my_visitor {\n-    pub fn get<T:Copy>(&self, f: &fn(T)) {\n+    pub fn get<T:Clone>(&self, f: &fn(T)) {\n         unsafe {\n-            f(copy *(self.ptr1 as *T));\n+            f((*(self.ptr1 as *T)).clone());\n         }\n     }\n "}, {"sha": "75d978b0d05281dccddda4b281fa985fb291fd06", "filename": "src/test/run-pass/resource-generic.rs", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Ftest%2Frun-pass%2Fresource-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Ftest%2Frun-pass%2Fresource-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-generic.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -1,40 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-fast\n-\n-struct Arg<T> {val: T, fin: extern fn(T)}\n-\n-struct finish<T> {\n-  arg: Arg<T>\n-}\n-\n-#[unsafe_destructor]\n-impl<T:Copy> Drop for finish<T> {\n-    fn drop(&self) {\n-        unsafe {\n-            (self.arg.fin)(copy self.arg.val);\n-        }\n-    }\n-}\n-\n-fn finish<T:Copy>(arg: Arg<T>) -> finish<T> {\n-    finish {\n-        arg: arg\n-    }\n-}\n-\n-pub fn main() {\n-    let box = @mut 10;\n-    fn dec_box(i: @mut int) { *i -= 1; }\n-\n-    { let _i = finish(Arg{val: box, fin: dec_box}); }\n-    assert_eq!(*box, 9);\n-}"}, {"sha": "e192a38dfa317c069c67cc8c031f1bab5c88733a", "filename": "src/test/run-pass/sendfn-generic-fn.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fsendfn-generic-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fsendfn-generic-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendfn-generic-fn.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -14,25 +14,29 @@ use std::task;\n \n pub fn main() { test05(); }\n \n-struct Pair<A,B> { a: A, b: B }\n+#[deriving(Clone)]\n+struct Pair<A,B> {\n+    a: A,\n+    b: B,\n+}\n \n-fn make_generic_record<A:Copy,B:Copy>(a: A, b: B) -> Pair<A,B> {\n+fn make_generic_record<A,B>(a: A, b: B) -> Pair<A,B> {\n     return Pair {a: a, b: b};\n }\n \n fn test05_start(f: &~fn(v: float, v: ~str) -> Pair<float, ~str>) {\n     let p = (*f)(22.22f, ~\"Hi\");\n-    info!(copy p);\n+    info!(p.clone());\n     assert!(p.a == 22.22f);\n     assert!(p.b == ~\"Hi\");\n \n     let q = (*f)(44.44f, ~\"Ho\");\n-    info!(copy q);\n+    info!(q.clone());\n     assert!(q.a == 44.44f);\n     assert!(q.b == ~\"Ho\");\n }\n \n-fn spawn<A:Copy,B:Copy>(f: extern fn(&~fn(A,B)->Pair<A,B>)) {\n+fn spawn<A,B>(f: extern fn(&~fn(A,B)->Pair<A,B>)) {\n     let arg: ~fn(A, B) -> Pair<A,B> = |a, b| make_generic_record(a, b);\n     task::spawn(|| f(&arg));\n }"}, {"sha": "11489c33eeac5965c229c90653104c44a98072e0", "filename": "src/test/run-pass/shape_intrinsic_tag_then_rec.rs", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fshape_intrinsic_tag_then_rec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Fshape_intrinsic_tag_then_rec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fshape_intrinsic_tag_then_rec.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -13,27 +13,50 @@\n // interior record which is then itself interior to\n // something else, shape calculations were off.\n \n+#[deriving(Clone)]\n enum opt_span {\n-\n     //hack (as opposed to option), to make `span` compile\n     os_none,\n     os_some(@Span),\n }\n-struct Span {lo: uint, hi: uint, expanded_from: opt_span}\n-struct Spanned<T> { data: T, span: Span }\n+\n+#[deriving(Clone)]\n+struct Span {\n+    lo: uint,\n+    hi: uint,\n+    expanded_from: opt_span,\n+}\n+\n+#[deriving(Clone)]\n+struct Spanned<T> {\n+    data: T,\n+    span: Span,\n+}\n+\n type ty_ = uint;\n-struct Path_ { global: bool, idents: ~[~str], types: ~[@ty] }\n+\n+#[deriving(Clone)]\n+struct Path_ {\n+    global: bool,\n+    idents: ~[~str],\n+    types: ~[@ty],\n+}\n+\n type path = Spanned<Path_>;\n type ty = Spanned<ty_>;\n \n-struct X { sp: Span, path: path }\n+#[deriving(Clone)]\n+struct X {\n+    sp: Span,\n+    path: path,\n+}\n \n pub fn main() {\n     let sp: Span = Span {lo: 57451u, hi: 57542u, expanded_from: os_none};\n     let t: @ty = @Spanned { data: 3u, span: sp };\n     let p_: Path_ = Path_ { global: true, idents: ~[~\"hi\"], types: ~[t] };\n     let p: path = Spanned { data: p_, span: sp };\n     let x = X { sp: sp, path: p };\n-    error!(copy x.path);\n-    error!(copy x);\n+    error!(x.path.clone());\n+    error!(x.clone());\n }"}, {"sha": "3b3074b4a7d05e87433b1d5365a6e3c46537cc09", "filename": "src/test/run-pass/unique-copy-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Funique-copy-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b33f721954bc5290f9201c8f64003c294d0571/src%2Ftest%2Frun-pass%2Funique-copy-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-copy-box.rs?ref=99b33f721954bc5290f9201c8f64003c294d0571", "patch": "@@ -15,7 +15,7 @@ pub fn main() {\n         let i = ~@1;\n         let j = ~@2;\n         let rc1 = sys::refcount(*i);\n-        let j = copy i;\n+        let j = i.clone();\n         let rc2 = sys::refcount(*i);\n         error!(\"rc1: %u rc2: %u\", rc1, rc2);\n         assert_eq!(rc1 + 1u, rc2);"}]}