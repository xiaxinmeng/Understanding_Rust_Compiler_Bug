{"sha": "f2b9b2d13bb14dd80d5bacbbb63d9d5cc6003a35", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyYjliMmQxM2JiMTRkZDgwZDViYWNiYmI2M2Q5ZDVjYzYwMDNhMzU=", "commit": {"author": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2019-05-23T18:48:27Z"}, "committer": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2019-06-03T03:50:03Z"}, "message": "move DefPathBasedNames to ty::print::obsolete", "tree": {"sha": "bf53017844d68640f48188a4152427779de45a07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf53017844d68640f48188a4152427779de45a07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2b9b2d13bb14dd80d5bacbbb63d9d5cc6003a35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2b9b2d13bb14dd80d5bacbbb63d9d5cc6003a35", "html_url": "https://github.com/rust-lang/rust/commit/f2b9b2d13bb14dd80d5bacbbb63d9d5cc6003a35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2b9b2d13bb14dd80d5bacbbb63d9d5cc6003a35/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3287ddf937d873f8a4e5dbbd0fe2937904dfdd88", "url": "https://api.github.com/repos/rust-lang/rust/commits/3287ddf937d873f8a4e5dbbd0fe2937904dfdd88", "html_url": "https://github.com/rust-lang/rust/commit/3287ddf937d873f8a4e5dbbd0fe2937904dfdd88"}], "stats": {"total": 593, "additions": 296, "deletions": 297}, "files": [{"sha": "a3986f7c055e66c825385067c4f621f5e1be12e1", "filename": "src/librustc/ty/print/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2b9b2d13bb14dd80d5bacbbb63d9d5cc6003a35/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b9b2d13bb14dd80d5bacbbb63d9d5cc6003a35/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs?ref=f2b9b2d13bb14dd80d5bacbbb63d9d5cc6003a35", "patch": "@@ -7,6 +7,7 @@ use rustc_data_structures::fx::FxHashSet;\n \n // `pretty` is a separate module only for organization.\n mod pretty;\n+pub mod obsolete;\n pub use self::pretty::*;\n \n pub trait Print<'gcx, 'tcx, P> {"}, {"sha": "85d338699b0e02c526efa66cf40ee8e6f52547dd", "filename": "src/librustc/ty/print/obsolete.rs", "status": "added", "additions": 286, "deletions": 0, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/f2b9b2d13bb14dd80d5bacbbb63d9d5cc6003a35/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b9b2d13bb14dd80d5bacbbb63d9d5cc6003a35/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs?ref=f2b9b2d13bb14dd80d5bacbbb63d9d5cc6003a35", "patch": "@@ -0,0 +1,286 @@\n+//! Allows for producing a unique string key for a mono item.\n+//! These keys are used by the handwritten auto-tests, so they need to be\n+//! predictable and human-readable.\n+//!\n+//! Note: A lot of this could looks very similar to what's already in `ty::print`.\n+//! FIXME(eddyb) implement a custom `PrettyPrinter` for this.\n+\n+use rustc::hir::def_id::DefId;\n+use rustc::mir::interpret::ConstValue;\n+use rustc::ty::subst::SubstsRef;\n+use rustc::ty::{self, ClosureSubsts, Const, GeneratorSubsts, Instance, Ty, TyCtxt};\n+use rustc::{bug, hir};\n+use std::fmt::Write;\n+use std::iter;\n+use syntax::ast;\n+\n+/// Same as `unique_type_name()` but with the result pushed onto the given\n+/// `output` parameter.\n+pub struct DefPathBasedNames<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    omit_disambiguators: bool,\n+    omit_local_crate_name: bool,\n+}\n+\n+impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n+    pub fn new(\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        omit_disambiguators: bool,\n+        omit_local_crate_name: bool,\n+    ) -> Self {\n+        DefPathBasedNames { tcx, omit_disambiguators, omit_local_crate_name }\n+    }\n+\n+    // Pushes the type name of the specified type to the provided string.\n+    // If `debug` is true, printing normally unprintable types is allowed\n+    // (e.g. `ty::GeneratorWitness`). This parameter should only be set when\n+    // this method is being used for logging purposes (e.g. with `debug!` or `info!`)\n+    // When being used for codegen purposes, `debug` should be set to `false`\n+    // in order to catch unexpected types that should never end up in a type name.\n+    pub fn push_type_name(&self, t: Ty<'tcx>, output: &mut String, debug: bool) {\n+        match t.sty {\n+            ty::Bool => output.push_str(\"bool\"),\n+            ty::Char => output.push_str(\"char\"),\n+            ty::Str => output.push_str(\"str\"),\n+            ty::Never => output.push_str(\"!\"),\n+            ty::Int(ast::IntTy::Isize) => output.push_str(\"isize\"),\n+            ty::Int(ast::IntTy::I8) => output.push_str(\"i8\"),\n+            ty::Int(ast::IntTy::I16) => output.push_str(\"i16\"),\n+            ty::Int(ast::IntTy::I32) => output.push_str(\"i32\"),\n+            ty::Int(ast::IntTy::I64) => output.push_str(\"i64\"),\n+            ty::Int(ast::IntTy::I128) => output.push_str(\"i128\"),\n+            ty::Uint(ast::UintTy::Usize) => output.push_str(\"usize\"),\n+            ty::Uint(ast::UintTy::U8) => output.push_str(\"u8\"),\n+            ty::Uint(ast::UintTy::U16) => output.push_str(\"u16\"),\n+            ty::Uint(ast::UintTy::U32) => output.push_str(\"u32\"),\n+            ty::Uint(ast::UintTy::U64) => output.push_str(\"u64\"),\n+            ty::Uint(ast::UintTy::U128) => output.push_str(\"u128\"),\n+            ty::Float(ast::FloatTy::F32) => output.push_str(\"f32\"),\n+            ty::Float(ast::FloatTy::F64) => output.push_str(\"f64\"),\n+            ty::Adt(adt_def, substs) => {\n+                self.push_def_path(adt_def.did, output);\n+                self.push_generic_params(substs, iter::empty(), output, debug);\n+            }\n+            ty::Tuple(component_types) => {\n+                output.push('(');\n+                for &component_type in component_types {\n+                    self.push_type_name(component_type.expect_ty(), output, debug);\n+                    output.push_str(\", \");\n+                }\n+                if !component_types.is_empty() {\n+                    output.pop();\n+                    output.pop();\n+                }\n+                output.push(')');\n+            }\n+            ty::RawPtr(ty::TypeAndMut { ty: inner_type, mutbl }) => {\n+                output.push('*');\n+                match mutbl {\n+                    hir::MutImmutable => output.push_str(\"const \"),\n+                    hir::MutMutable => output.push_str(\"mut \"),\n+                }\n+\n+                self.push_type_name(inner_type, output, debug);\n+            }\n+            ty::Ref(_, inner_type, mutbl) => {\n+                output.push('&');\n+                if mutbl == hir::MutMutable {\n+                    output.push_str(\"mut \");\n+                }\n+\n+                self.push_type_name(inner_type, output, debug);\n+            }\n+            ty::Array(inner_type, len) => {\n+                output.push('[');\n+                self.push_type_name(inner_type, output, debug);\n+                write!(output, \"; {}\", len.unwrap_usize(self.tcx)).unwrap();\n+                output.push(']');\n+            }\n+            ty::Slice(inner_type) => {\n+                output.push('[');\n+                self.push_type_name(inner_type, output, debug);\n+                output.push(']');\n+            }\n+            ty::Dynamic(ref trait_data, ..) => {\n+                if let Some(principal) = trait_data.principal() {\n+                    self.push_def_path(principal.def_id(), output);\n+                    self.push_generic_params(\n+                        principal.skip_binder().substs,\n+                        trait_data.projection_bounds(),\n+                        output,\n+                        debug,\n+                    );\n+                } else {\n+                    output.push_str(\"dyn '_\");\n+                }\n+            }\n+            ty::Foreign(did) => self.push_def_path(did, output),\n+            ty::FnDef(..) | ty::FnPtr(_) => {\n+                let sig = t.fn_sig(self.tcx);\n+                if sig.unsafety() == hir::Unsafety::Unsafe {\n+                    output.push_str(\"unsafe \");\n+                }\n+\n+                let abi = sig.abi();\n+                if abi != ::rustc_target::spec::abi::Abi::Rust {\n+                    output.push_str(\"extern \\\"\");\n+                    output.push_str(abi.name());\n+                    output.push_str(\"\\\" \");\n+                }\n+\n+                output.push_str(\"fn(\");\n+\n+                let sig =\n+                    self.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n+\n+                if !sig.inputs().is_empty() {\n+                    for &parameter_type in sig.inputs() {\n+                        self.push_type_name(parameter_type, output, debug);\n+                        output.push_str(\", \");\n+                    }\n+                    output.pop();\n+                    output.pop();\n+                }\n+\n+                if sig.c_variadic {\n+                    if !sig.inputs().is_empty() {\n+                        output.push_str(\", ...\");\n+                    } else {\n+                        output.push_str(\"...\");\n+                    }\n+                }\n+\n+                output.push(')');\n+\n+                if !sig.output().is_unit() {\n+                    output.push_str(\" -> \");\n+                    self.push_type_name(sig.output(), output, debug);\n+                }\n+            }\n+            ty::Generator(def_id, GeneratorSubsts { ref substs }, _)\n+            | ty::Closure(def_id, ClosureSubsts { ref substs }) => {\n+                self.push_def_path(def_id, output);\n+                let generics = self.tcx.generics_of(self.tcx.closure_base_def_id(def_id));\n+                let substs = substs.truncate_to(self.tcx, generics);\n+                self.push_generic_params(substs, iter::empty(), output, debug);\n+            }\n+            ty::Error\n+            | ty::Bound(..)\n+            | ty::Infer(_)\n+            | ty::Placeholder(..)\n+            | ty::UnnormalizedProjection(..)\n+            | ty::Projection(..)\n+            | ty::Param(_)\n+            | ty::GeneratorWitness(_)\n+            | ty::Opaque(..) => {\n+                if debug {\n+                    output.push_str(&format!(\"`{:?}`\", t));\n+                } else {\n+                    bug!(\n+                        \"DefPathBasedNames: trying to create type name for unexpected type: {:?}\",\n+                        t,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n+    // Pushes the the name of the specified const to the provided string.\n+    // If `debug` is true, usually-unprintable consts (such as `Infer`) will be printed,\n+    // as well as the unprintable types of constants (see `push_type_name` for more details).\n+    pub fn push_const_name(&self, c: &Const<'tcx>, output: &mut String, debug: bool) {\n+        match c.val {\n+            ConstValue::Scalar(..) | ConstValue::Slice { .. } | ConstValue::ByRef(..) => {\n+                // FIXME(const_generics): we could probably do a better job here.\n+                write!(output, \"{:?}\", c).unwrap()\n+            }\n+            _ => {\n+                if debug {\n+                    write!(output, \"{:?}\", c).unwrap()\n+                } else {\n+                    bug!(\n+                        \"DefPathBasedNames: trying to create const name for unexpected const: {:?}\",\n+                        c,\n+                    );\n+                }\n+            }\n+        }\n+        output.push_str(\": \");\n+        self.push_type_name(c.ty, output, debug);\n+    }\n+\n+    pub fn push_def_path(&self, def_id: DefId, output: &mut String) {\n+        let def_path = self.tcx.def_path(def_id);\n+\n+        // some_crate::\n+        if !(self.omit_local_crate_name && def_id.is_local()) {\n+            output.push_str(&self.tcx.crate_name(def_path.krate).as_str());\n+            output.push_str(\"::\");\n+        }\n+\n+        // foo::bar::ItemName::\n+        for part in self.tcx.def_path(def_id).data {\n+            if self.omit_disambiguators {\n+                write!(output, \"{}::\", part.data.as_interned_str()).unwrap();\n+            } else {\n+                write!(output, \"{}[{}]::\", part.data.as_interned_str(), part.disambiguator)\n+                    .unwrap();\n+            }\n+        }\n+\n+        // remove final \"::\"\n+        output.pop();\n+        output.pop();\n+    }\n+\n+    fn push_generic_params<I>(\n+        &self,\n+        substs: SubstsRef<'tcx>,\n+        projections: I,\n+        output: &mut String,\n+        debug: bool,\n+    ) where\n+        I: Iterator<Item = ty::PolyExistentialProjection<'tcx>>,\n+    {\n+        let mut projections = projections.peekable();\n+        if substs.non_erasable_generics().next().is_none() && projections.peek().is_none() {\n+            return;\n+        }\n+\n+        output.push('<');\n+\n+        for type_parameter in substs.types() {\n+            self.push_type_name(type_parameter, output, debug);\n+            output.push_str(\", \");\n+        }\n+\n+        for projection in projections {\n+            let projection = projection.skip_binder();\n+            let name = &self.tcx.associated_item(projection.item_def_id).ident.as_str();\n+            output.push_str(name);\n+            output.push_str(\"=\");\n+            self.push_type_name(projection.ty, output, debug);\n+            output.push_str(\", \");\n+        }\n+\n+        for const_parameter in substs.consts() {\n+            self.push_const_name(const_parameter, output, debug);\n+            output.push_str(\", \");\n+        }\n+\n+        output.pop();\n+        output.pop();\n+\n+        output.push('>');\n+    }\n+\n+    pub fn push_instance_as_string(\n+        &self,\n+        instance: Instance<'tcx>,\n+        output: &mut String,\n+        debug: bool,\n+    ) {\n+        self.push_def_path(instance.def_id(), output);\n+        self.push_generic_params(instance.substs, iter::empty(), output, debug);\n+    }\n+}"}, {"sha": "7a82fd731f60483d1fdb5df533eea33faf0e675f", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2b9b2d13bb14dd80d5bacbbb63d9d5cc6003a35/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b9b2d13bb14dd80d5bacbbb63d9d5cc6003a35/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=f2b9b2d13bb14dd80d5bacbbb63d9d5cc6003a35", "patch": "@@ -4,7 +4,7 @@ use crate::type_::Type;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::layout::{self, Align, LayoutOf, FnTypeExt, PointeeInfo, Size, TyLayout};\n use rustc_target::abi::{FloatTy, TyLayoutMethods};\n-use rustc_mir::monomorphize::item::DefPathBasedNames;\n+use rustc::ty::print::obsolete::DefPathBasedNames;\n use rustc_codegen_ssa::traits::*;\n \n use std::fmt::Write;"}, {"sha": "fc3d0712fca5ac83f3e428e53278bf5d6659e523", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2b9b2d13bb14dd80d5bacbbb63d9d5cc6003a35/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b9b2d13bb14dd80d5bacbbb63d9d5cc6003a35/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=f2b9b2d13bb14dd80d5bacbbb63d9d5cc6003a35", "patch": "@@ -24,6 +24,7 @@ use rustc::mir::mono::{CodegenUnitNameBuilder, CodegenUnit};\n use rustc::ty::{self, Ty, TyCtxt, Instance};\n use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n use rustc::ty::query::Providers;\n+use rustc::ty::print::obsolete::DefPathBasedNames;\n use rustc::middle::cstore::{self, LinkagePreference};\n use rustc::util::common::{time, print_time_passes_entry};\n use rustc::session::config::{self, EntryFnType, Lto};"}, {"sha": "2fc42098669eade9634105f75a6a3b75351f9f3f", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2b9b2d13bb14dd80d5bacbbb63d9d5cc6003a35/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b9b2d13bb14dd80d5bacbbb63d9d5cc6003a35/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=f2b9b2d13bb14dd80d5bacbbb63d9d5cc6003a35", "patch": "@@ -182,6 +182,7 @@ use rustc::mir::interpret::{AllocId, ConstValue};\n use rustc::middle::lang_items::{ExchangeMallocFnLangItem, StartFnLangItem};\n use rustc::ty::subst::{InternalSubsts, SubstsRef};\n use rustc::ty::{self, TypeFoldable, Ty, TyCtxt, GenericParamDefKind, Instance};\n+use rustc::ty::print::obsolete::DefPathBasedNames;\n use rustc::ty::adjustment::{CustomCoerceUnsized, PointerCast};\n use rustc::session::config::EntryFnType;\n use rustc::mir::{self, Location, Place, PlaceBase, Promoted, Static, StaticKind};\n@@ -193,7 +194,7 @@ use crate::monomorphize;\n use rustc::util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n use rustc::util::common::time;\n \n-use crate::monomorphize::item::{MonoItemExt, DefPathBasedNames, InstantiationMode};\n+use crate::monomorphize::item::{MonoItemExt, InstantiationMode};\n \n use rustc_data_structures::bit_set::GrowableBitSet;\n use rustc_data_structures::sync::{MTRef, MTLock, ParallelIterator, par_iter};"}, {"sha": "d60d0fe9114d36de15bd88058d1f03956cb0b146", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 5, "deletions": 295, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/f2b9b2d13bb14dd80d5bacbbb63d9d5cc6003a35/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b9b2d13bb14dd80d5bacbbb63d9d5cc6003a35/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=f2b9b2d13bb14dd80d5bacbbb63d9d5cc6003a35", "patch": "@@ -1,14 +1,11 @@\n-use rustc::hir;\n-use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc::mir::interpret::ConstValue;\n+use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::mir::mono::MonoItem;\n use rustc::session::config::OptLevel;\n-use rustc::ty::{self, Ty, TyCtxt, Const, ClosureSubsts, GeneratorSubsts, Instance};\n-use rustc::ty::subst::{SubstsRef, InternalSubsts};\n-use syntax::ast;\n+use rustc::ty::{self, TyCtxt, Instance};\n+use rustc::ty::subst::InternalSubsts;\n+use rustc::ty::print::obsolete::DefPathBasedNames;\n use syntax::attr::InlineAttr;\n-use std::fmt::{self, Write};\n-use std::iter;\n+use std::fmt;\n use rustc::mir::mono::Linkage;\n use syntax_pos::symbol::InternedString;\n use syntax::source_map::Span;\n@@ -206,290 +203,3 @@ impl<'a, 'tcx> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {\n         self\n     }\n }\n-\n-//=-----------------------------------------------------------------------------\n-// MonoItem String Keys\n-//=-----------------------------------------------------------------------------\n-\n-// The code below allows for producing a unique string key for a mono item.\n-// These keys are used by the handwritten auto-tests, so they need to be\n-// predictable and human-readable.\n-//\n-// Note: A lot of this could looks very similar to what's already in `ty::print`.\n-// FIXME(eddyb) implement a custom `PrettyPrinter` for this.\n-\n-/// Same as `unique_type_name()` but with the result pushed onto the given\n-/// `output` parameter.\n-pub struct DefPathBasedNames<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    omit_disambiguators: bool,\n-    omit_local_crate_name: bool,\n-}\n-\n-impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-               omit_disambiguators: bool,\n-               omit_local_crate_name: bool)\n-               -> Self {\n-        DefPathBasedNames {\n-            tcx,\n-            omit_disambiguators,\n-            omit_local_crate_name,\n-        }\n-    }\n-\n-    // Pushes the type name of the specified type to the provided string.\n-    // If `debug` is true, printing normally unprintable types is allowed\n-    // (e.g. `ty::GeneratorWitness`). This parameter should only be set when\n-    // this method is being used for logging purposes (e.g. with `debug!` or `info!`)\n-    // When being used for codegen purposes, `debug` should be set to `false`\n-    // in order to catch unexpected types that should never end up in a type name.\n-    pub fn push_type_name(&self, t: Ty<'tcx>, output: &mut String, debug: bool) {\n-        match t.sty {\n-            ty::Bool              => output.push_str(\"bool\"),\n-            ty::Char              => output.push_str(\"char\"),\n-            ty::Str               => output.push_str(\"str\"),\n-            ty::Never             => output.push_str(\"!\"),\n-            ty::Int(ast::IntTy::Isize)    => output.push_str(\"isize\"),\n-            ty::Int(ast::IntTy::I8)    => output.push_str(\"i8\"),\n-            ty::Int(ast::IntTy::I16)   => output.push_str(\"i16\"),\n-            ty::Int(ast::IntTy::I32)   => output.push_str(\"i32\"),\n-            ty::Int(ast::IntTy::I64)   => output.push_str(\"i64\"),\n-            ty::Int(ast::IntTy::I128)   => output.push_str(\"i128\"),\n-            ty::Uint(ast::UintTy::Usize)   => output.push_str(\"usize\"),\n-            ty::Uint(ast::UintTy::U8)   => output.push_str(\"u8\"),\n-            ty::Uint(ast::UintTy::U16)  => output.push_str(\"u16\"),\n-            ty::Uint(ast::UintTy::U32)  => output.push_str(\"u32\"),\n-            ty::Uint(ast::UintTy::U64)  => output.push_str(\"u64\"),\n-            ty::Uint(ast::UintTy::U128)  => output.push_str(\"u128\"),\n-            ty::Float(ast::FloatTy::F32) => output.push_str(\"f32\"),\n-            ty::Float(ast::FloatTy::F64) => output.push_str(\"f64\"),\n-            ty::Adt(adt_def, substs) => {\n-                self.push_def_path(adt_def.did, output);\n-                self.push_generic_params(substs, iter::empty(), output, debug);\n-            },\n-            ty::Tuple(component_types) => {\n-                output.push('(');\n-                for &component_type in component_types {\n-                    self.push_type_name(component_type.expect_ty(), output, debug);\n-                    output.push_str(\", \");\n-                }\n-                if !component_types.is_empty() {\n-                    output.pop();\n-                    output.pop();\n-                }\n-                output.push(')');\n-            },\n-            ty::RawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n-                output.push('*');\n-                match mutbl {\n-                    hir::MutImmutable => output.push_str(\"const \"),\n-                    hir::MutMutable => output.push_str(\"mut \"),\n-                }\n-\n-                self.push_type_name(inner_type, output, debug);\n-            },\n-            ty::Ref(_, inner_type, mutbl) => {\n-                output.push('&');\n-                if mutbl == hir::MutMutable {\n-                    output.push_str(\"mut \");\n-                }\n-\n-                self.push_type_name(inner_type, output, debug);\n-            },\n-            ty::Array(inner_type, len) => {\n-                output.push('[');\n-                self.push_type_name(inner_type, output, debug);\n-                write!(output, \"; {}\", len.unwrap_usize(self.tcx)).unwrap();\n-                output.push(']');\n-            },\n-            ty::Slice(inner_type) => {\n-                output.push('[');\n-                self.push_type_name(inner_type, output, debug);\n-                output.push(']');\n-            },\n-            ty::Dynamic(ref trait_data, ..) => {\n-                if let Some(principal) = trait_data.principal() {\n-                    self.push_def_path(principal.def_id(), output);\n-                    self.push_generic_params(\n-                        principal.skip_binder().substs,\n-                        trait_data.projection_bounds(),\n-                        output,\n-                        debug\n-                    );\n-                } else {\n-                    output.push_str(\"dyn '_\");\n-                }\n-            },\n-            ty::Foreign(did) => self.push_def_path(did, output),\n-            ty::FnDef(..) |\n-            ty::FnPtr(_) => {\n-                let sig = t.fn_sig(self.tcx);\n-                if sig.unsafety() == hir::Unsafety::Unsafe {\n-                    output.push_str(\"unsafe \");\n-                }\n-\n-                let abi = sig.abi();\n-                if abi != ::rustc_target::spec::abi::Abi::Rust {\n-                    output.push_str(\"extern \\\"\");\n-                    output.push_str(abi.name());\n-                    output.push_str(\"\\\" \");\n-                }\n-\n-                output.push_str(\"fn(\");\n-\n-                let sig = self.tcx.normalize_erasing_late_bound_regions(\n-                    ty::ParamEnv::reveal_all(),\n-                    &sig,\n-                );\n-\n-                if !sig.inputs().is_empty() {\n-                    for &parameter_type in sig.inputs() {\n-                        self.push_type_name(parameter_type, output, debug);\n-                        output.push_str(\", \");\n-                    }\n-                    output.pop();\n-                    output.pop();\n-                }\n-\n-                if sig.c_variadic {\n-                    if !sig.inputs().is_empty() {\n-                        output.push_str(\", ...\");\n-                    } else {\n-                        output.push_str(\"...\");\n-                    }\n-                }\n-\n-                output.push(')');\n-\n-                if !sig.output().is_unit() {\n-                    output.push_str(\" -> \");\n-                    self.push_type_name(sig.output(), output, debug);\n-                }\n-            },\n-            ty::Generator(def_id, GeneratorSubsts { ref substs }, _) |\n-            ty::Closure(def_id, ClosureSubsts { ref substs }) => {\n-                self.push_def_path(def_id, output);\n-                let generics = self.tcx.generics_of(self.tcx.closure_base_def_id(def_id));\n-                let substs = substs.truncate_to(self.tcx, generics);\n-                self.push_generic_params(substs, iter::empty(), output, debug);\n-            }\n-            ty::Error |\n-            ty::Bound(..) |\n-            ty::Infer(_) |\n-            ty::Placeholder(..) |\n-            ty::UnnormalizedProjection(..) |\n-            ty::Projection(..) |\n-            ty::Param(_) |\n-            ty::GeneratorWitness(_) |\n-            ty::Opaque(..) => {\n-                if debug {\n-                    output.push_str(&format!(\"`{:?}`\", t));\n-                } else {\n-                    bug!(\n-                        \"DefPathBasedNames: trying to create type name for unexpected type: {:?}\",\n-                        t,\n-                    );\n-                }\n-            }\n-        }\n-    }\n-\n-    // Pushes the the name of the specified const to the provided string.\n-    // If `debug` is true, usually-unprintable consts (such as `Infer`) will be printed,\n-    // as well as the unprintable types of constants (see `push_type_name` for more details).\n-    pub fn push_const_name(&self, c: &Const<'tcx>, output: &mut String, debug: bool) {\n-        match c.val {\n-            ConstValue::Scalar(..) | ConstValue::Slice { .. } | ConstValue::ByRef(..) => {\n-                // FIXME(const_generics): we could probably do a better job here.\n-                write!(output, \"{:?}\", c).unwrap()\n-            }\n-            _ => {\n-                if debug {\n-                    write!(output, \"{:?}\", c).unwrap()\n-                } else {\n-                    bug!(\n-                        \"DefPathBasedNames: trying to create const name for unexpected const: {:?}\",\n-                        c,\n-                    );\n-                }\n-            }\n-        }\n-        output.push_str(\": \");\n-        self.push_type_name(c.ty, output, debug);\n-    }\n-\n-    pub fn push_def_path(&self,\n-                         def_id: DefId,\n-                         output: &mut String) {\n-        let def_path = self.tcx.def_path(def_id);\n-\n-        // some_crate::\n-        if !(self.omit_local_crate_name && def_id.is_local()) {\n-            output.push_str(&self.tcx.crate_name(def_path.krate).as_str());\n-            output.push_str(\"::\");\n-        }\n-\n-        // foo::bar::ItemName::\n-        for part in self.tcx.def_path(def_id).data {\n-            if self.omit_disambiguators {\n-                write!(output, \"{}::\", part.data.as_interned_str()).unwrap();\n-            } else {\n-                write!(output, \"{}[{}]::\",\n-                       part.data.as_interned_str(),\n-                       part.disambiguator).unwrap();\n-            }\n-        }\n-\n-        // remove final \"::\"\n-        output.pop();\n-        output.pop();\n-    }\n-\n-    fn push_generic_params<I>(\n-        &self,\n-        substs: SubstsRef<'tcx>,\n-        projections: I,\n-        output: &mut String,\n-        debug: bool,\n-    ) where I: Iterator<Item=ty::PolyExistentialProjection<'tcx>> {\n-        let mut projections = projections.peekable();\n-        if substs.non_erasable_generics().next().is_none() && projections.peek().is_none() {\n-            return;\n-        }\n-\n-        output.push('<');\n-\n-        for type_parameter in substs.types() {\n-            self.push_type_name(type_parameter, output, debug);\n-            output.push_str(\", \");\n-        }\n-\n-        for projection in projections {\n-            let projection = projection.skip_binder();\n-            let name = &self.tcx.associated_item(projection.item_def_id).ident.as_str();\n-            output.push_str(name);\n-            output.push_str(\"=\");\n-            self.push_type_name(projection.ty, output, debug);\n-            output.push_str(\", \");\n-        }\n-\n-        for const_parameter in substs.consts() {\n-            self.push_const_name(const_parameter, output, debug);\n-            output.push_str(\", \");\n-        }\n-\n-        output.pop();\n-        output.pop();\n-\n-        output.push('>');\n-    }\n-\n-    pub fn push_instance_as_string(&self,\n-                                   instance: Instance<'tcx>,\n-                                   output: &mut String,\n-                                   debug: bool) {\n-        self.push_def_path(instance.def_id(), output);\n-        self.push_generic_params(instance.substs, iter::empty(), output, debug);\n-    }\n-}"}]}