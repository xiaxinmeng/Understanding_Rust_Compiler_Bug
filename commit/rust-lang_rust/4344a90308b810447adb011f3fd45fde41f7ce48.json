{"sha": "4344a90308b810447adb011f3fd45fde41f7ce48", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzNDRhOTAzMDhiODEwNDQ3YWRiMDExZjNmZDQ1ZmRlNDFmN2NlNDg=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-03T23:37:34Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-09T19:17:44Z"}, "message": "Pretty-print `$crate` as `crate`/`::my_crate` in tokens\n\n...but only if those tokens are printed from inside of AST pretty-printing.", "tree": {"sha": "350ece7d231f13a2626ffc4d50340f0abeef4704", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/350ece7d231f13a2626ffc4d50340f0abeef4704"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4344a90308b810447adb011f3fd45fde41f7ce48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4344a90308b810447adb011f3fd45fde41f7ce48", "html_url": "https://github.com/rust-lang/rust/commit/4344a90308b810447adb011f3fd45fde41f7ce48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4344a90308b810447adb011f3fd45fde41f7ce48/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7aaf0de700d1bc242d270dcc7e2fee9e3533ea0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7aaf0de700d1bc242d270dcc7e2fee9e3533ea0a", "html_url": "https://github.com/rust-lang/rust/commit/7aaf0de700d1bc242d270dcc7e2fee9e3533ea0a"}], "stats": {"total": 125, "additions": 70, "deletions": 55}, "files": [{"sha": "7e099bc4d509510eb56a65e1c4a4d89e9bd67d73", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 62, "deletions": 47, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/4344a90308b810447adb011f3fd45fde41f7ce48/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4344a90308b810447adb011f3fd45fde41f7ce48/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=4344a90308b810447adb011f3fd45fde41f7ce48", "patch": "@@ -18,7 +18,7 @@ use crate::tokenstream::{self, TokenStream, TokenTree};\n \n use rustc_target::spec::abi::{self, Abi};\n use syntax_pos::{self, BytePos};\n-use syntax_pos::{DUMMY_SP, FileName};\n+use syntax_pos::{DUMMY_SP, FileName, Span};\n \n use std::borrow::Cow;\n use std::io::Read;\n@@ -181,7 +181,46 @@ pub fn literal_to_string(lit: token::Lit) -> String {\n     out\n }\n \n+fn ident_to_string(ident: ast::Ident, is_raw: bool) -> String {\n+    ident_to_string_ext(ident.name, is_raw, Some(ident.span))\n+}\n+\n+// AST pretty-printer is used as a fallback for turning AST structures into token streams for\n+// proc macros. Additionally, proc macros may stringify their input and expect it survive the\n+// stringification (especially true for proc macro derives written between Rust 1.15 and 1.30).\n+// So we need to somehow pretty-print `$crate` in a way preserving at least some of its\n+// hygiene data, most importantly name of the crate it refers to.\n+// As a result we print `$crate` as `crate` if it refers to the local crate\n+// and as `::other_crate_name` if it refers to some other crate.\n+// Note, that this is only done if the ident token is printed from inside of AST pretty-pringing,\n+// but not otherwise. Pretty-printing is the only way for proc macros to discover token contents,\n+// so we should not perform this lossy conversion if the top level call to the pretty-printer was\n+// done for a token stream or a single token.\n+fn ident_to_string_ext(\n+    name: ast::Name, is_raw: bool, convert_dollar_crate: Option<Span>\n+) -> String {\n+    if is_raw {\n+        format!(\"r#{}\", name)\n+    } else {\n+        if name == kw::DollarCrate {\n+            if let Some(span) = convert_dollar_crate {\n+                let converted = span.ctxt().dollar_crate_name();\n+                return if converted.is_path_segment_keyword() {\n+                    converted.to_string()\n+                } else {\n+                    format!(\"::{}\", converted)\n+                }\n+            }\n+        }\n+        name.to_string()\n+    }\n+}\n+\n pub fn token_kind_to_string(tok: &TokenKind) -> String {\n+    token_kind_to_string_ext(tok, None)\n+}\n+\n+fn token_kind_to_string_ext(tok: &TokenKind, convert_dollar_crate: Option<Span>) -> String {\n     match *tok {\n         token::Eq                   => \"=\".to_string(),\n         token::Lt                   => \"<\".to_string(),\n@@ -227,8 +266,7 @@ pub fn token_kind_to_string(tok: &TokenKind) -> String {\n         token::Literal(lit) => literal_to_string(lit),\n \n         /* Name components */\n-        token::Ident(s, false)      => s.to_string(),\n-        token::Ident(s, true)       => format!(\"r#{}\", s),\n+        token::Ident(s, is_raw)     => ident_to_string_ext(s, is_raw, convert_dollar_crate),\n         token::Lifetime(s)          => s.to_string(),\n \n         /* Other */\n@@ -243,7 +281,12 @@ pub fn token_kind_to_string(tok: &TokenKind) -> String {\n }\n \n pub fn token_to_string(token: &Token) -> String {\n-    token_kind_to_string(&token.kind)\n+    token_to_string_ext(token, false)\n+}\n+\n+fn token_to_string_ext(token: &Token, convert_dollar_crate: bool) -> String {\n+    let convert_dollar_crate = if convert_dollar_crate { Some(token.span) } else { None };\n+    token_kind_to_string_ext(&token.kind, convert_dollar_crate)\n }\n \n crate fn nonterminal_to_string(nt: &Nonterminal) -> String {\n@@ -256,9 +299,8 @@ crate fn nonterminal_to_string(nt: &Nonterminal) -> String {\n         token::NtBlock(ref e)       => block_to_string(e),\n         token::NtStmt(ref e)        => stmt_to_string(e),\n         token::NtPat(ref e)         => pat_to_string(e),\n-        token::NtIdent(e, false)    => ident_to_string(e),\n-        token::NtIdent(e, true)     => format!(\"r#{}\", ident_to_string(e)),\n-        token::NtLifetime(e)        => ident_to_string(e),\n+        token::NtIdent(e, is_raw)   => ident_to_string(e, is_raw),\n+        token::NtLifetime(e)        => e.to_string(),\n         token::NtLiteral(ref e)     => expr_to_string(e),\n         token::NtTT(ref tree)       => tt_to_string(tree.clone()),\n         token::NtImplItem(ref e)    => impl_item_to_string(e),\n@@ -293,15 +335,15 @@ pub fn lifetime_to_string(lt: &ast::Lifetime) -> String {\n }\n \n pub fn tt_to_string(tt: tokenstream::TokenTree) -> String {\n-    to_string(|s| s.print_tt(tt))\n+    to_string(|s| s.print_tt(tt, false))\n }\n \n pub fn tts_to_string(tts: &[tokenstream::TokenTree]) -> String {\n-    to_string(|s| s.print_tts(tts.iter().cloned().collect()))\n+    tokens_to_string(tts.iter().cloned().collect())\n }\n \n pub fn tokens_to_string(tokens: TokenStream) -> String {\n-    to_string(|s| s.print_tts(tokens))\n+    to_string(|s| s.print_tts_ext(tokens, false))\n }\n \n pub fn stmt_to_string(stmt: &ast::Stmt) -> String {\n@@ -344,10 +386,6 @@ pub fn path_segment_to_string(p: &ast::PathSegment) -> String {\n     to_string(|s| s.print_path_segment(p, false))\n }\n \n-pub fn ident_to_string(id: ast::Ident) -> String {\n-    to_string(|s| s.print_ident(id))\n-}\n-\n pub fn vis_to_string(v: &ast::Visibility) -> String {\n     to_string(|s| s.print_visibility(v))\n }\n@@ -629,11 +667,7 @@ pub trait PrintState<'a> {\n                 self.writer().word(\"::\");\n             }\n             if segment.ident.name != kw::PathRoot {\n-                if segment.ident.name == kw::DollarCrate {\n-                    self.print_dollar_crate(segment.ident);\n-                } else {\n-                    self.writer().word(segment.ident.as_str().to_string());\n-                }\n+                self.writer().word(ident_to_string(segment.ident, segment.ident.is_raw_guess()));\n             }\n         }\n     }\n@@ -707,10 +741,10 @@ pub trait PrintState<'a> {\n     /// appropriate macro, transcribe back into the grammar we just parsed from,\n     /// and then pretty-print the resulting AST nodes (so, e.g., we print\n     /// expression arguments as expressions). It can be done! I think.\n-    fn print_tt(&mut self, tt: tokenstream::TokenTree) {\n+    fn print_tt(&mut self, tt: tokenstream::TokenTree, convert_dollar_crate: bool) {\n         match tt {\n             TokenTree::Token(ref token) => {\n-                self.writer().word(token_to_string(&token));\n+                self.writer().word(token_to_string_ext(&token, convert_dollar_crate));\n                 match token.kind {\n                     token::DocComment(..) => {\n                         self.writer().hardbreak()\n@@ -729,12 +763,16 @@ pub trait PrintState<'a> {\n     }\n \n     fn print_tts(&mut self, tts: tokenstream::TokenStream) {\n+        self.print_tts_ext(tts, true)\n+    }\n+\n+    fn print_tts_ext(&mut self, tts: tokenstream::TokenStream, convert_dollar_crate: bool) {\n         self.ibox(0);\n         for (i, tt) in tts.into_trees().enumerate() {\n             if i != 0 {\n                 self.writer().space();\n             }\n-            self.print_tt(tt);\n+            self.print_tt(tt, convert_dollar_crate);\n         }\n         self.end();\n     }\n@@ -744,21 +782,6 @@ pub trait PrintState<'a> {\n     }\n \n     fn nbsp(&mut self) { self.writer().word(\" \") }\n-\n-    // AST pretty-printer is used as a fallback for turning AST structures into token streams for\n-    // proc macros. Additionally, proc macros may stringify their input and expect it survive the\n-    // stringification (especially true for proc macro derives written between Rust 1.15 and 1.30).\n-    // So we need to somehow pretty-print `$crate` in paths in a way preserving at least some of\n-    // its hygiene data, most importantly name of the crate it refers to.\n-    // As a result we print `$crate` as `crate` if it refers to the local crate\n-    // and as `::other_crate_name` if it refers to some other crate.\n-    fn print_dollar_crate(&mut self, ident: ast::Ident) {\n-        let name = ident.span.ctxt().dollar_crate_name();\n-        if !ast::Ident::with_empty_ctxt(name).is_path_segment_keyword() {\n-            self.writer().word(\"::\");\n-        }\n-        self.writer().word(name.as_str().to_string())\n-    }\n }\n \n impl<'a> PrintState<'a> for State<'a> {\n@@ -2287,11 +2310,7 @@ impl<'a> State<'a> {\n     }\n \n     crate fn print_ident(&mut self, ident: ast::Ident) {\n-        if ident.is_raw_guess() {\n-            self.s.word(format!(\"r#{}\", ident));\n-        } else {\n-            self.s.word(ident.as_str().to_string());\n-        }\n+        self.s.word(ident_to_string(ident, ident.is_raw_guess()));\n         self.ann.post(self, AnnNode::Ident(&ident))\n     }\n \n@@ -2322,11 +2341,7 @@ impl<'a> State<'a> {\n                           segment: &ast::PathSegment,\n                           colons_before_params: bool) {\n         if segment.ident.name != kw::PathRoot {\n-            if segment.ident.name == kw::DollarCrate {\n-                self.print_dollar_crate(segment.ident);\n-            } else {\n-                self.print_ident(segment.ident);\n-            }\n+            self.print_ident(segment.ident);\n             if let Some(ref args) = segment.args {\n                 self.print_generic_args(args, colons_before_params);\n             }"}, {"sha": "84821259d7b9b9bd05fa967dc5777b8d1dc93185", "filename": "src/test/ui/proc-macro/dollar-crate-issue-57089.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4344a90308b810447adb011f3fd45fde41f7ce48/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/4344a90308b810447adb011f3fd45fde41f7ce48/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout?ref=4344a90308b810447adb011f3fd45fde41f7ce48", "patch": "@@ -1,4 +1,4 @@\n-PRINT-BANG INPUT (DISPLAY): struct M ( $crate :: S ) ;\n+PRINT-BANG INPUT (DISPLAY): struct M ( crate :: S ) ;\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n@@ -39,7 +39,7 @@ PRINT-BANG INPUT (DEBUG): TokenStream [\n     },\n ]\n PRINT-ATTR INPUT (DISPLAY): struct A(crate::S);\n-PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ( $crate :: S ) ;\n+PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ( crate :: S ) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\","}, {"sha": "9d9677d49e31898e48450f5c10e04865542a0685", "filename": "src/test/ui/proc-macro/dollar-crate.stdout", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4344a90308b810447adb011f3fd45fde41f7ce48/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/4344a90308b810447adb011f3fd45fde41f7ce48/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout?ref=4344a90308b810447adb011f3fd45fde41f7ce48", "patch": "@@ -1,4 +1,4 @@\n-PRINT-BANG INPUT (DISPLAY): struct M ( $crate :: S ) ;\n+PRINT-BANG INPUT (DISPLAY): struct M ( crate :: S ) ;\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n@@ -39,7 +39,7 @@ PRINT-BANG INPUT (DEBUG): TokenStream [\n     },\n ]\n PRINT-ATTR INPUT (DISPLAY): struct A(crate::S);\n-PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ( $crate :: S ) ;\n+PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ( crate :: S ) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n@@ -80,7 +80,7 @@ PRINT-ATTR INPUT (DEBUG): TokenStream [\n     },\n ]\n PRINT-DERIVE INPUT (DISPLAY): struct D(crate::S);\n-PRINT-DERIVE RE-COLLECTED (DISPLAY): struct D ( $crate :: S ) ;\n+PRINT-DERIVE RE-COLLECTED (DISPLAY): struct D ( crate :: S ) ;\n PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n@@ -120,7 +120,7 @@ PRINT-DERIVE INPUT (DEBUG): TokenStream [\n         span: #2 bytes(LO..HI),\n     },\n ]\n-PRINT-BANG INPUT (DISPLAY): struct M ( $crate :: S ) ;\n+PRINT-BANG INPUT (DISPLAY): struct M ( ::dollar_crate_external :: S ) ;\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n@@ -161,7 +161,7 @@ PRINT-BANG INPUT (DEBUG): TokenStream [\n     },\n ]\n PRINT-ATTR INPUT (DISPLAY): struct A(::dollar_crate_external::S);\n-PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ( $crate :: S ) ;\n+PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ( ::dollar_crate_external :: S ) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n@@ -202,7 +202,7 @@ PRINT-ATTR INPUT (DEBUG): TokenStream [\n     },\n ]\n PRINT-DERIVE INPUT (DISPLAY): struct D(::dollar_crate_external::S);\n-PRINT-DERIVE RE-COLLECTED (DISPLAY): struct D ( $crate :: S ) ;\n+PRINT-DERIVE RE-COLLECTED (DISPLAY): struct D ( ::dollar_crate_external :: S ) ;\n PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\","}]}