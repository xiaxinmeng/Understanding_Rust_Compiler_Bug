{"sha": "ccba6c51511a86cd36af52dc4f51cd3a0df95909", "node_id": "C_kwDOAAsO6NoAKGNjYmE2YzUxNTExYTg2Y2QzNmFmNTJkYzRmNTFjZDNhMGRmOTU5MDk", "commit": {"author": {"name": "Markus Everling", "email": "markuseverling@gmail.com", "date": "2023-01-17T20:08:23Z"}, "committer": {"name": "Markus Everling", "email": "markuseverling@gmail.com", "date": "2023-01-17T23:33:05Z"}, "message": "Add `vec_deque::IntoIter` benchmarks", "tree": {"sha": "6b2f7b1d2e003e258af9e3beb58560330302250b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b2f7b1d2e003e258af9e3beb58560330302250b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ccba6c51511a86cd36af52dc4f51cd3a0df95909", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ccba6c51511a86cd36af52dc4f51cd3a0df95909", "html_url": "https://github.com/rust-lang/rust/commit/ccba6c51511a86cd36af52dc4f51cd3a0df95909", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ccba6c51511a86cd36af52dc4f51cd3a0df95909/comments", "author": {"login": "Sp00ph", "id": 61327188, "node_id": "MDQ6VXNlcjYxMzI3MTg4", "avatar_url": "https://avatars.githubusercontent.com/u/61327188?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Sp00ph", "html_url": "https://github.com/Sp00ph", "followers_url": "https://api.github.com/users/Sp00ph/followers", "following_url": "https://api.github.com/users/Sp00ph/following{/other_user}", "gists_url": "https://api.github.com/users/Sp00ph/gists{/gist_id}", "starred_url": "https://api.github.com/users/Sp00ph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Sp00ph/subscriptions", "organizations_url": "https://api.github.com/users/Sp00ph/orgs", "repos_url": "https://api.github.com/users/Sp00ph/repos", "events_url": "https://api.github.com/users/Sp00ph/events{/privacy}", "received_events_url": "https://api.github.com/users/Sp00ph/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Sp00ph", "id": 61327188, "node_id": "MDQ6VXNlcjYxMzI3MTg4", "avatar_url": "https://avatars.githubusercontent.com/u/61327188?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Sp00ph", "html_url": "https://github.com/Sp00ph", "followers_url": "https://api.github.com/users/Sp00ph/followers", "following_url": "https://api.github.com/users/Sp00ph/following{/other_user}", "gists_url": "https://api.github.com/users/Sp00ph/gists{/gist_id}", "starred_url": "https://api.github.com/users/Sp00ph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Sp00ph/subscriptions", "organizations_url": "https://api.github.com/users/Sp00ph/orgs", "repos_url": "https://api.github.com/users/Sp00ph/repos", "events_url": "https://api.github.com/users/Sp00ph/events{/privacy}", "received_events_url": "https://api.github.com/users/Sp00ph/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c13b145f47e36158c252e0359a8374f1aff3e5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c13b145f47e36158c252e0359a8374f1aff3e5e", "html_url": "https://github.com/rust-lang/rust/commit/7c13b145f47e36158c252e0359a8374f1aff3e5e"}], "stats": {"total": 146, "additions": 145, "deletions": 1}, "files": [{"sha": "313a97ed1ffcc34d5c78edd23e18bd21b032976e", "filename": "library/alloc/benches/vec_deque.rs", "status": "modified", "additions": 145, "deletions": 1, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/ccba6c51511a86cd36af52dc4f51cd3a0df95909/library%2Falloc%2Fbenches%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccba6c51511a86cd36af52dc4f51cd3a0df95909/library%2Falloc%2Fbenches%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fvec_deque.rs?ref=ccba6c51511a86cd36af52dc4f51cd3a0df95909", "patch": "@@ -1,4 +1,8 @@\n-use std::collections::VecDeque;\n+use core::iter::Iterator;\n+use std::{\n+    collections::{vec_deque, VecDeque},\n+    mem,\n+};\n use test::{black_box, Bencher};\n \n #[bench]\n@@ -53,6 +57,146 @@ fn bench_try_fold(b: &mut Bencher) {\n     b.iter(|| black_box(ring.iter().try_fold(0, |a, b| Some(a + b))))\n }\n \n+/// does the memory bookkeeping to reuse the buffer of the Vec between iterations.\n+/// `setup` must not modify its argument's length or capacity. `g` must not move out of its argument.\n+fn into_iter_helper<\n+    T: Copy,\n+    F: FnOnce(&mut VecDeque<T>),\n+    G: FnOnce(&mut vec_deque::IntoIter<T>),\n+>(\n+    v: &mut Vec<T>,\n+    setup: F,\n+    g: G,\n+) {\n+    let ptr = v.as_mut_ptr();\n+    let len = v.len();\n+    // ensure that the vec is full, to make sure that any wrapping from the deque doesn't\n+    // access uninitialized memory.\n+    assert_eq!(v.len(), v.capacity());\n+\n+    let mut deque = VecDeque::from(mem::take(v));\n+    setup(&mut deque);\n+\n+    let mut it = deque.into_iter();\n+    g(&mut it);\n+\n+    mem::forget(it);\n+\n+    // SAFETY: the provided functions are not allowed to modify the allocation, so the buffer is still alive.\n+    // len and capacity are accurate due to the above assertion.\n+    // All the elements in the buffer are still valid, because of `T: Copy` which implies `T: !Drop`.\n+    mem::forget(mem::replace(v, unsafe { Vec::from_raw_parts(ptr, len, len) }));\n+}\n+\n+#[bench]\n+fn bench_into_iter(b: &mut Bencher) {\n+    let len = 1024;\n+    // we reuse this allocation for every run\n+    let mut vec: Vec<usize> = (0..len).collect();\n+    vec.shrink_to_fit();\n+\n+    b.iter(|| {\n+        let mut sum = 0;\n+        into_iter_helper(\n+            &mut vec,\n+            |_| {},\n+            |it| {\n+                for i in it {\n+                    sum += i;\n+                }\n+            },\n+        );\n+        black_box(sum);\n+\n+        let mut sum = 0;\n+        // rotating a full deque doesn't move any memory.\n+        into_iter_helper(\n+            &mut vec,\n+            |d| d.rotate_left(len / 2),\n+            |it| {\n+                for i in it {\n+                    sum += i;\n+                }\n+            },\n+        );\n+        black_box(sum);\n+    });\n+}\n+\n+#[bench]\n+fn bench_into_iter_fold(b: &mut Bencher) {\n+    let len = 1024;\n+\n+    // because `fold` takes ownership of the iterator,\n+    // we can't prevent it from dropping the memory,\n+    // so we have to bite the bullet and reallocate\n+    // for every iteration.\n+    b.iter(|| {\n+        let deque: VecDeque<usize> = (0..len).collect();\n+        assert_eq!(deque.len(), deque.capacity());\n+        let sum = deque.into_iter().fold(0, |a, b| a + b);\n+        black_box(sum);\n+\n+        // rotating a full deque doesn't move any memory.\n+        let mut deque: VecDeque<usize> = (0..len).collect();\n+        assert_eq!(deque.len(), deque.capacity());\n+        deque.rotate_left(len / 2);\n+        let sum = deque.into_iter().fold(0, |a, b| a + b);\n+        black_box(sum);\n+    });\n+}\n+\n+#[bench]\n+fn bench_into_iter_try_fold(b: &mut Bencher) {\n+    let len = 1024;\n+    // we reuse this allocation for every run\n+    let mut vec: Vec<usize> = (0..len).collect();\n+    vec.shrink_to_fit();\n+\n+    // Iterator::any uses Iterator::try_fold under the hood\n+    b.iter(|| {\n+        let mut b = false;\n+        into_iter_helper(&mut vec, |_| {}, |it| b = it.any(|i| i == len - 1));\n+        black_box(b);\n+\n+        into_iter_helper(&mut vec, |d| d.rotate_left(len / 2), |it| b = it.any(|i| i == len - 1));\n+        black_box(b);\n+    });\n+}\n+\n+#[bench]\n+fn bench_into_iter_next_chunk(b: &mut Bencher) {\n+    let len = 1024;\n+    // we reuse this allocation for every run\n+    let mut vec: Vec<usize> = (0..len).collect();\n+    vec.shrink_to_fit();\n+\n+    b.iter(|| {\n+        let mut buf = [0; 64];\n+        into_iter_helper(\n+            &mut vec,\n+            |_| {},\n+            |it| {\n+                while let Ok(a) = it.next_chunk() {\n+                    buf = a;\n+                }\n+            },\n+        );\n+        black_box(buf);\n+\n+        into_iter_helper(\n+            &mut vec,\n+            |d| d.rotate_left(len / 2),\n+            |it| {\n+                while let Ok(a) = it.next_chunk() {\n+                    buf = a;\n+                }\n+            },\n+        );\n+        black_box(buf);\n+    });\n+}\n+\n #[bench]\n fn bench_from_array_1000(b: &mut Bencher) {\n     const N: usize = 1000;"}]}