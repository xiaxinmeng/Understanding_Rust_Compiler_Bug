{"sha": "42a386fcf89a40e6c3a8806ccf381514c2a77c10", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyYTM4NmZjZjg5YTQwZTZjM2E4ODA2Y2NmMzgxNTE0YzJhNzdjMTA=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2015-08-14T04:58:20Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2015-08-20T00:00:15Z"}, "message": "Make Condvar::wait_timeout return an enum instead of a bool\n\nReturning a primitive bool results in a somewhat confusing API - does\n`true` indicate success - i.e. no timeout, or that a timeout has\noccurred? An explicitly named enum makes it clearer.\n\n[breaking-change]", "tree": {"sha": "e77742b5cb6447176ebb66c91fdb4981c0cc6336", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e77742b5cb6447176ebb66c91fdb4981c0cc6336"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42a386fcf89a40e6c3a8806ccf381514c2a77c10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42a386fcf89a40e6c3a8806ccf381514c2a77c10", "html_url": "https://github.com/rust-lang/rust/commit/42a386fcf89a40e6c3a8806ccf381514c2a77c10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42a386fcf89a40e6c3a8806ccf381514c2a77c10/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aca2057ed5fb7af3f8905b2bc01f72fa001c35c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/aca2057ed5fb7af3f8905b2bc01f72fa001c35c8", "html_url": "https://github.com/rust-lang/rust/commit/aca2057ed5fb7af3f8905b2bc01f72fa001c35c8"}], "stats": {"total": 64, "additions": 45, "deletions": 19}, "files": [{"sha": "11ba4a8023dc30f8142f9f7a1d727d90efdf3d95", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 44, "deletions": 18, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/42a386fcf89a40e6c3a8806ccf381514c2a77c10/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a386fcf89a40e6c3a8806ccf381514c2a77c10/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=42a386fcf89a40e6c3a8806ccf381514c2a77c10", "patch": "@@ -18,6 +18,17 @@ use sys_common::poison::{self, LockResult};\n use sys::time::SteadyTime;\n use time::Duration;\n \n+/// A type indicating whether a timed wait on a condition variable returned\n+/// due to a time out or not.\n+#[derive(Debug, PartialEq, Eq)]\n+#[unstable(feature = \"wait_timeout\", reason = \"newly added\")]\n+pub enum TimedOut {\n+    /// The wait timed out.\n+    Yes,\n+    /// The wait did not time out.\n+    No\n+}\n+\n /// A Condition Variable\n ///\n /// Condition variables represent the ability to block a thread such that it\n@@ -170,16 +181,16 @@ impl Condvar {\n     /// preemption or platform differences that may not cause the maximum\n     /// amount of time waited to be precisely `dur`.\n     ///\n-    /// The returned boolean is `false` only if the timeout is known\n-    /// to have elapsed.\n+    /// The returned `TimedOut` value indicates if the timeout is known to have\n+    /// elapsed.\n     ///\n     /// Like `wait`, the lock specified will be re-acquired when this function\n     /// returns, regardless of whether the timeout elapsed or not.\n     #[unstable(feature = \"wait_timeout\", reason = \"waiting for Duration\",\n                issue = \"27772\")]\n     pub fn wait_timeout<'a, T>(&self, guard: MutexGuard<'a, T>,\n                                dur: Duration)\n-                               -> LockResult<(MutexGuard<'a, T>, bool)> {\n+                               -> LockResult<(MutexGuard<'a, T>, TimedOut)> {\n         unsafe {\n             let me: &'static Condvar = &*(self as *const _);\n             me.inner.wait_timeout(guard, dur)\n@@ -199,7 +210,7 @@ impl Condvar {\n                                        guard: MutexGuard<'a, T>,\n                                        dur: Duration,\n                                        f: F)\n-                                       -> LockResult<(MutexGuard<'a, T>, bool)>\n+                                       -> LockResult<(MutexGuard<'a, T>, TimedOut)>\n             where F: FnMut(LockResult<&mut T>) -> bool {\n         unsafe {\n             let me: &'static Condvar = &*(self as *const _);\n@@ -278,7 +289,13 @@ impl StaticCondvar {\n                issue = \"27717\")]\n     pub fn wait_timeout_ms<'a, T>(&'static self, guard: MutexGuard<'a, T>, ms: u32)\n                                   -> LockResult<(MutexGuard<'a, T>, bool)> {\n-        self.wait_timeout(guard, Duration::from_millis(ms as u64))\n+        match self.wait_timeout(guard, Duration::from_millis(ms as u64)) {\n+            Ok((guard, timed_out)) => Ok((guard, timed_out == TimedOut::No)),\n+            Err(poison) => {\n+                let (guard, timed_out) = poison.into_inner();\n+                Err(PoisonError::new((guard, timed_out == TimedOut::No)))\n+            }\n+        }\n     }\n \n     /// Waits on this condition variable for a notification, timing out after a\n@@ -291,11 +308,15 @@ impl StaticCondvar {\n     pub fn wait_timeout<'a, T>(&'static self,\n                                guard: MutexGuard<'a, T>,\n                                timeout: Duration)\n-                               -> LockResult<(MutexGuard<'a, T>, bool)> {\n+                               -> LockResult<(MutexGuard<'a, T>, TimedOut)> {\n         let (poisoned, success) = unsafe {\n             let lock = mutex::guard_lock(&guard);\n             self.verify(lock);\n-            let success = self.inner.wait_timeout(lock, timeout);\n+            let success = if self.inner.wait_timeout(lock, timeout) {\n+                TimedOut::No\n+            } else {\n+                TimedOut::Yes\n+            };\n             (mutex::guard_poison(&guard).get(), success)\n         };\n         if poisoned {\n@@ -319,7 +340,7 @@ impl StaticCondvar {\n                                        guard: MutexGuard<'a, T>,\n                                        dur: Duration,\n                                        mut f: F)\n-                                       -> LockResult<(MutexGuard<'a, T>, bool)>\n+                                       -> LockResult<(MutexGuard<'a, T>, TimedOut)>\n             where F: FnMut(LockResult<&mut T>) -> bool {\n         // This could be made more efficient by pushing the implementation into\n         // sys::condvar\n@@ -332,28 +353,33 @@ impl StaticCondvar {\n             let now = SteadyTime::now();\n             let consumed = &now - &start;\n             let guard = guard_result.unwrap_or_else(|e| e.into_inner());\n-            let (new_guard_result, no_timeout) = if consumed > dur {\n-                (Ok(guard), false)\n+            let (new_guard_result, timed_out) = if consumed > dur {\n+                (Ok(guard), TimedOut::Yes)\n             } else {\n                 match self.wait_timeout(guard, dur - consumed) {\n-                    Ok((new_guard, no_timeout)) => (Ok(new_guard), no_timeout),\n+                    Ok((new_guard, timed_out)) => (Ok(new_guard), timed_out),\n                     Err(err) => {\n                         let (new_guard, no_timeout) = err.into_inner();\n                         (Err(PoisonError::new(new_guard)), no_timeout)\n                     }\n                 }\n             };\n             guard_result = new_guard_result;\n-            if !no_timeout {\n+            if timed_out == TimedOut::Yes {\n                 let result = f(guard_result\n                                     .as_mut()\n                                     .map(|g| &mut **g)\n                                     .map_err(|e| PoisonError::new(&mut **e.get_mut())));\n+                let result = if result {\n+                    TimedOut::No\n+                } else {\n+                    TimedOut::Yes\n+                };\n                 return poison::map_result(guard_result, |g| (g, result));\n             }\n         }\n \n-        poison::map_result(guard_result, |g| (g, true))\n+        poison::map_result(guard_result, |g| (g, TimedOut::No))\n     }\n \n     /// Wakes up one blocked thread on this condvar.\n@@ -410,7 +436,7 @@ mod tests {\n \n     use super::StaticCondvar;\n     use sync::mpsc::channel;\n-    use sync::{StaticMutex, Condvar, Mutex, Arc};\n+    use sync::{StaticMutex, Condvar, Mutex, Arc, TimedOut};\n     use sync::atomic::{AtomicUsize, Ordering};\n     use thread;\n     use time::Duration;\n@@ -508,10 +534,10 @@ mod tests {\n         static S: AtomicUsize = AtomicUsize::new(0);\n \n         let g = M.lock().unwrap();\n-        let (g, success) = C.wait_timeout_with(g, Duration::new(0, 1000), |_| {\n+        let (g, timed_out) = C.wait_timeout_with(g, Duration::new(0, 1000), |_| {\n             false\n         }).unwrap();\n-        assert!(!success);\n+        assert_eq!(timed_out, TimedOut::Yes);\n \n         let (tx, rx) = channel();\n         let _t = thread::spawn(move || {\n@@ -535,7 +561,7 @@ mod tests {\n \n         let mut state = 0;\n         let day = 24 * 60 * 60;\n-        let (_g, success) = C.wait_timeout_with(g, Duration::new(day, 0), |_| {\n+        let (_g, timed_out) = C.wait_timeout_with(g, Duration::new(day, 0), |_| {\n             assert_eq!(state, S.load(Ordering::SeqCst));\n             tx.send(()).unwrap();\n             state += 1;\n@@ -544,7 +570,7 @@ mod tests {\n                 _ => true,\n             }\n         }).unwrap();\n-        assert!(success);\n+        assert_eq!(timed_out, TimedOut::No);\n     }\n \n     #[test]"}, {"sha": "8539311f823f9590365bea49d54c62c8b5bbc4ea", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42a386fcf89a40e6c3a8806ccf381514c2a77c10/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a386fcf89a40e6c3a8806ccf381514c2a77c10/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=42a386fcf89a40e6c3a8806ccf381514c2a77c10", "patch": "@@ -21,7 +21,7 @@ pub use alloc::arc::{Arc, Weak};\n pub use core::atomic;\n \n pub use self::barrier::{Barrier, BarrierWaitResult};\n-pub use self::condvar::{Condvar, StaticCondvar, CONDVAR_INIT};\n+pub use self::condvar::{Condvar, StaticCondvar, TimedOut, CONDVAR_INIT};\n pub use self::mutex::MUTEX_INIT;\n pub use self::mutex::{Mutex, MutexGuard, StaticMutex};\n pub use self::once::{Once, ONCE_INIT};"}]}