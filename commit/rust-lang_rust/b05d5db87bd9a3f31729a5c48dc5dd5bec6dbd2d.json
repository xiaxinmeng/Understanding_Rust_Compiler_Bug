{"sha": "b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwNWQ1ZGI4N2JkOWEzZjMxNzI5YTVjNDhkYzVkZDViZWM2ZGJkMmQ=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-05-01T12:35:34Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-05-01T13:40:59Z"}, "message": "Ensure that drop order of `async fn` matches `fn`.\n\nThis commit modifies the lowering of `async fn` arguments so that the\ndrop order matches the equivalent `fn`.\n\nPreviously, async function arguments were lowered as shown below:\n\n    async fn foo(<pattern>: <ty>) {\n      async move {\n      }\n    } // <-- dropped as you \"exit\" the fn\n\n    // ...becomes...\n    fn foo(__arg0: <ty>) {\n      async move {\n        let <pattern> = __arg0;\n      } // <-- dropped as you \"exit\" the async block\n    }\n\nAfter this PR, async function arguments will be lowered as:\n\n    async fn foo(<pattern>: <ty>, <pattern>: <ty>, <pattern>: <ty>) {\n      async move {\n      }\n    } // <-- dropped as you \"exit\" the fn\n\n    // ...becomes...\n    fn foo(__arg0: <ty>, __arg1: <ty>, __arg2: <ty>) {\n      async move {\n        let __arg2 = __arg2;\n        let <pattern> = __arg2;\n        let __arg1 = __arg1;\n        let <pattern> = __arg1;\n        let __arg0 = __arg0;\n        let <pattern> = __arg0;\n      } // <-- dropped as you \"exit\" the async block\n    }\n\nIf `<pattern>` is a simple ident, then it is lowered to a single\n`let <pattern> = <pattern>;` statement as an optimization.", "tree": {"sha": "89ebc62179b1a604b975caa5a9c38cd061db2077", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89ebc62179b1a604b975caa5a9c38cd061db2077"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAlzJoesACgkQAXYLT59T\n8VTKjw/9Fjm5YOVpSMI1e8asSTBYfQjpbeUTHxfJq5ecTRjstECCWFllAmL5y8Mx\n2qwp2oiVlXV66HiFzbU3gPYD0D5U5+aAaOEC13rVnTCy/sNMyLrel1yg/WADe6pF\nKxcgW6USVWP20PwuBZU4umof8vw1gfjI4W4fNVhdkWreEs/8Q2kvWTS79rpvdXfW\nC/Ejd3PZGLXXXp3I1pvwAxovN8ZHr5as4MMO3QR5hUTTw34Kd4o0Hyo8A/+QV6/J\nvjblZpV5mPiiyc+kiYpabyT4AIFh4wK0Clr/o1AsYfnea0ALRdd0wvyT8tlOop0y\nsqYmiU7U5la50rM1CIEhm+gPbDN/3en/2VcOSPFZq7MNEZ2F2W6/EegKE0AWJeDT\nNnw4M9+PfklclxI9xFzbVslVbdFykSo0WOrCoW0DkgSirl3iUWEv96QqI34S9YIR\nR9Ymw8mJUK3NSNAufVF4OVxzqC9YnvHvT82ouL9YI9xjOuiAf2oZ/fCjzOdNegFi\nZvR+UZPCjWuKZcvvi4BRmDKxQtL68Roa2WLDNGqh+mhW9bnjJ+P7uj/Xa7mmrIwV\n2mv44cvbgKnNxxxwScTXDj2FImfzLVk3eqn9NZRwMsRM9JUGaldaeK74TRXmUfsI\nOuu6gpUKdiLyt6c3CasFB1e+WeXkUCI6uzAREr63uoPBaDznvx8=\n=43d9\n-----END PGP SIGNATURE-----", "payload": "tree 89ebc62179b1a604b975caa5a9c38cd061db2077\nparent 47e0803d5c2ad5952220f2c260d7e12921c1d3fe\nauthor David Wood <david@davidtw.co> 1556714134 +0100\ncommitter David Wood <david@davidtw.co> 1556718059 +0100\n\nEnsure that drop order of `async fn` matches `fn`.\n\nThis commit modifies the lowering of `async fn` arguments so that the\ndrop order matches the equivalent `fn`.\n\nPreviously, async function arguments were lowered as shown below:\n\n    async fn foo(<pattern>: <ty>) {\n      async move {\n      }\n    } // <-- dropped as you \"exit\" the fn\n\n    // ...becomes...\n    fn foo(__arg0: <ty>) {\n      async move {\n        let <pattern> = __arg0;\n      } // <-- dropped as you \"exit\" the async block\n    }\n\nAfter this PR, async function arguments will be lowered as:\n\n    async fn foo(<pattern>: <ty>, <pattern>: <ty>, <pattern>: <ty>) {\n      async move {\n      }\n    } // <-- dropped as you \"exit\" the fn\n\n    // ...becomes...\n    fn foo(__arg0: <ty>, __arg1: <ty>, __arg2: <ty>) {\n      async move {\n        let __arg2 = __arg2;\n        let <pattern> = __arg2;\n        let __arg1 = __arg1;\n        let <pattern> = __arg1;\n        let __arg0 = __arg0;\n        let <pattern> = __arg0;\n      } // <-- dropped as you \"exit\" the async block\n    }\n\nIf `<pattern>` is a simple ident, then it is lowered to a single\n`let <pattern> = <pattern>;` statement as an optimization.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d", "html_url": "https://github.com/rust-lang/rust/commit/b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47e0803d5c2ad5952220f2c260d7e12921c1d3fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/47e0803d5c2ad5952220f2c260d7e12921c1d3fe", "html_url": "https://github.com/rust-lang/rust/commit/47e0803d5c2ad5952220f2c260d7e12921c1d3fe"}], "stats": {"total": 622, "additions": 401, "deletions": 221}, "files": [{"sha": "e7fe9bf40ba79043399155fdfbb89176682d5fdf", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d", "patch": "@@ -2996,8 +2996,33 @@ impl<'a> LoweringContext<'a> {\n             if let IsAsync::Async { closure_id, ref arguments, .. } = asyncness {\n                 let mut body = body.clone();\n \n+                // Async function arguments are lowered into the closure body so that they are\n+                // captured and so that the drop order matches the equivalent non-async functions.\n+                //\n+                //     async fn foo(<pattern>: <ty>, <pattern>: <ty>, <pattern>: <ty>) {\n+                //       async move {\n+                //       }\n+                //     }\n+                //\n+                //     // ...becomes...\n+                //     fn foo(__arg0: <ty>, __arg1: <ty>, __arg2: <ty>) {\n+                //       async move {\n+                //         let __arg2 = __arg2;\n+                //         let <pattern> = __arg2;\n+                //         let __arg1 = __arg1;\n+                //         let <pattern> = __arg1;\n+                //         let __arg0 = __arg0;\n+                //         let <pattern> = __arg0;\n+                //       }\n+                //     }\n+                //\n+                // If `<pattern>` is a simple ident, then it is lowered to a single\n+                // `let <pattern> = <pattern>;` statement as an optimization.\n                 for a in arguments.iter().rev() {\n-                    body.stmts.insert(0, a.stmt.clone());\n+                    if let Some(pat_stmt) = a.pat_stmt.clone() {\n+                        body.stmts.insert(0, pat_stmt);\n+                    }\n+                    body.stmts.insert(0, a.move_stmt.clone());\n                 }\n \n                 let async_expr = this.make_async_expr(\n@@ -3093,7 +3118,11 @@ impl<'a> LoweringContext<'a> {\n                         let mut decl = decl.clone();\n                         // Replace the arguments of this async function with the generated\n                         // arguments that will be moved into the closure.\n-                        decl.inputs = arguments.clone().drain(..).map(|a| a.arg).collect();\n+                        for (i, a) in arguments.clone().drain(..).enumerate() {\n+                            if let Some(arg) = a.arg {\n+                                decl.inputs[i] = arg;\n+                            }\n+                        }\n                         lower_fn(&decl)\n                     } else {\n                         lower_fn(decl)\n@@ -3590,7 +3619,11 @@ impl<'a> LoweringContext<'a> {\n                     let mut sig = sig.clone();\n                     // Replace the arguments of this async function with the generated\n                     // arguments that will be moved into the closure.\n-                    sig.decl.inputs = arguments.clone().drain(..).map(|a| a.arg).collect();\n+                    for (i, a) in arguments.clone().drain(..).enumerate() {\n+                        if let Some(arg) = a.arg {\n+                            sig.decl.inputs[i] = arg;\n+                        }\n+                    }\n                     lower_method(&sig)\n                 } else {\n                     lower_method(sig)"}, {"sha": "78de85398594efb747920b0816d3415aaae4a278", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d", "patch": "@@ -94,7 +94,9 @@ impl<'a> DefCollector<'a> {\n             // Walk the generated arguments for the `async fn`.\n             for a in arguments {\n                 use visit::Visitor;\n-                this.visit_ty(&a.arg.ty);\n+                if let Some(arg) = &a.arg {\n+                    this.visit_ty(&arg.ty);\n+                }\n             }\n \n             // We do not invoke `walk_fn_decl` as this will walk the arguments that are being\n@@ -105,10 +107,13 @@ impl<'a> DefCollector<'a> {\n                 *closure_id, DefPathData::ClosureExpr, REGULAR_SPACE, span,\n             );\n             this.with_parent(closure_def, |this| {\n+                use visit::Visitor;\n+                // Walk each of the generated statements before the regular block body.\n                 for a in arguments {\n-                    use visit::Visitor;\n-                    // Walk each of the generated statements before the regular block body.\n-                    this.visit_stmt(&a.stmt);\n+                    this.visit_stmt(&a.move_stmt);\n+                    if let Some(pat_stmt) = &a.pat_stmt {\n+                        this.visit_stmt(&pat_stmt);\n+                    }\n                 }\n \n                 visit::walk_block(this, &body);"}, {"sha": "8d5c1798e0fa4a5c0ef82d076419d45fb351795c", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d", "patch": "@@ -1334,14 +1334,19 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         if let ast::IsAsync::Async { ref arguments, .. } = header.asyncness.node {\n             for a in arguments {\n                 // Visit the argument..\n-                self.visit_pat(&a.arg.pat);\n-                if let ast::ArgSource::AsyncFn(pat) = &a.arg.source {\n-                    self.visit_pat(pat);\n+                if let Some(arg) = &a.arg {\n+                    self.visit_pat(&arg.pat);\n+                    if let ast::ArgSource::AsyncFn(pat) = &arg.source {\n+                        self.visit_pat(pat);\n+                    }\n+                    self.visit_ty(&arg.ty);\n                 }\n-                self.visit_ty(&a.arg.ty);\n \n                 // ..and the statement.\n-                self.visit_stmt(&a.stmt);\n+                self.visit_stmt(&a.move_stmt);\n+                if let Some(pat_stmt) = &a.pat_stmt {\n+                    self.visit_stmt(&pat_stmt);\n+                }\n             }\n         }\n     }"}, {"sha": "281be201a66cee56441e82d608ed68d62909740a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d", "patch": "@@ -862,7 +862,13 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n         // Walk the generated async arguments if this is an `async fn`, otherwise walk the\n         // normal arguments.\n         if let IsAsync::Async { ref arguments, .. } = asyncness {\n-            for a in arguments { add_argument(&a.arg); }\n+            for (i, a) in arguments.iter().enumerate() {\n+                if let Some(arg) = &a.arg {\n+                    add_argument(&arg);\n+                } else {\n+                    add_argument(&declaration.inputs[i]);\n+                }\n+            }\n         } else {\n             for a in &declaration.inputs { add_argument(a); }\n         }\n@@ -882,8 +888,11 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n                     let mut body = body.clone();\n                     // Insert the generated statements into the body before attempting to\n                     // resolve names.\n-                    for a in arguments {\n-                        body.stmts.insert(0, a.stmt.clone());\n+                    for a in arguments.iter().rev() {\n+                        if let Some(pat_stmt) = a.pat_stmt.clone() {\n+                            body.stmts.insert(0, pat_stmt);\n+                        }\n+                        body.stmts.insert(0, a.move_stmt.clone());\n                     }\n                     self.visit_block(&body);\n                 } else {"}, {"sha": "33b8c76bb531a2a6fc9219eb373bec20d0fad763", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d", "patch": "@@ -1865,10 +1865,14 @@ pub enum Unsafety {\n pub struct AsyncArgument {\n     /// `__arg0`\n     pub ident: Ident,\n-    /// `__arg0: <ty>` argument to replace existing function argument `<pat>: <ty>`.\n-    pub arg: Arg,\n-    /// `let <pat>: <ty> = __arg0;` statement to be inserted at the start of the block.\n-    pub stmt: Stmt,\n+    /// `__arg0: <ty>` argument to replace existing function argument `<pat>: <ty>`. Only if\n+    /// argument is not a simple binding.\n+    pub arg: Option<Arg>,\n+    /// `let __arg0 = __arg0;` statement to be inserted at the start of the block.\n+    pub move_stmt: Stmt,\n+    /// `let <pat> = __arg0;` statement to be inserted at the start of the block, after matching\n+    /// move statement. Only if argument is not a simple binding.\n+    pub pat_stmt: Option<Stmt>,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]"}, {"sha": "f5e18e98436e6e1b222ca0eabca59fb3e3074afb", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d", "patch": "@@ -199,7 +199,10 @@ impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n \n         if let ast::IsAsync::Async { ref mut arguments, .. } = a {\n             for argument in arguments.iter_mut() {\n-                self.next_id(&mut argument.stmt.id);\n+                self.next_id(&mut argument.move_stmt.id);\n+                if let Some(ref mut pat_stmt) = &mut argument.pat_stmt {\n+                    self.next_id(&mut pat_stmt.id);\n+                }\n             }\n         }\n     }"}, {"sha": "2e09235ca77b0a72bbcb1463778789e73e747164", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d", "patch": "@@ -694,13 +694,21 @@ pub fn noop_visit_asyncness<T: MutVisitor>(asyncness: &mut IsAsync, vis: &mut T)\n         IsAsync::Async { closure_id, return_impl_trait_id, ref mut arguments } => {\n             vis.visit_id(closure_id);\n             vis.visit_id(return_impl_trait_id);\n-            for AsyncArgument { ident, arg, stmt } in arguments.iter_mut() {\n+            for AsyncArgument { ident, arg, pat_stmt, move_stmt } in arguments.iter_mut() {\n                 vis.visit_ident(ident);\n-                vis.visit_arg(arg);\n-                visit_clobber(stmt, |stmt| {\n+                if let Some(arg) = arg {\n+                    vis.visit_arg(arg);\n+                }\n+                visit_clobber(move_stmt, |stmt| {\n                     vis.flat_map_stmt(stmt)\n                         .expect_one(\"expected visitor to produce exactly one item\")\n                 });\n+                visit_opt(pat_stmt, |stmt| {\n+                    visit_clobber(stmt, |stmt| {\n+                        vis.flat_map_stmt(stmt)\n+                            .expect_one(\"expected visitor to produce exactly one item\")\n+                    })\n+                });\n             }\n         }\n         IsAsync::NotAsync => {}"}, {"sha": "a10ee17b7e79ee576924aa57e6421e12d49c31ce", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 48, "deletions": 14, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d", "patch": "@@ -8880,25 +8880,44 @@ impl<'a> Parser<'a> {\n                 let name = format!(\"__arg{}\", index);\n                 let ident = Ident::from_str(&name);\n \n+                // Check if this is a ident pattern, if so, we can optimize and avoid adding a\n+                // `let <pat> = __argN;` statement, instead just adding a `let <pat> = <pat>;`\n+                // statement.\n+                let (ident, is_simple_pattern) = match input.pat.node {\n+                    PatKind::Ident(_, ident, _) => (ident, true),\n+                    _ => (ident, false),\n+                };\n+\n                 // Construct an argument representing `__argN: <ty>` to replace the argument of the\n-                // async function.\n-                let arg = Arg {\n-                    ty: input.ty.clone(),\n-                    id,\n+                // async function if it isn't a simple pattern.\n+                let arg = if is_simple_pattern {\n+                    None\n+                } else {\n+                    Some(Arg {\n+                        ty: input.ty.clone(),\n+                        id,\n+                        pat: P(Pat {\n+                            id,\n+                            node: PatKind::Ident(\n+                                BindingMode::ByValue(Mutability::Immutable), ident, None,\n+                            ),\n+                            span,\n+                        }),\n+                        source: ArgSource::AsyncFn(input.pat.clone()),\n+                    })\n+                };\n+\n+                // Construct a `let __argN = __argN;` statement to insert at the top of the\n+                // async closure. This makes sure that the argument is captured by the closure and\n+                // that the drop order is correct.\n+                let move_local = Local {\n                     pat: P(Pat {\n                         id,\n                         node: PatKind::Ident(\n                             BindingMode::ByValue(Mutability::Immutable), ident, None,\n                         ),\n                         span,\n                     }),\n-                    source: ArgSource::AsyncFn(input.pat.clone()),\n-                };\n-\n-                // Construct a `let <pat> = __argN;` statement to insert at the top of the\n-                // async closure.\n-                let local = P(Local {\n-                    pat: input.pat.clone(),\n                     // We explicitly do not specify the type for this statement. When the user's\n                     // argument type is `impl Trait` then this would require the\n                     // `impl_trait_in_bindings` feature to also be present for that same type to\n@@ -8918,10 +8937,25 @@ impl<'a> Parser<'a> {\n                     span,\n                     attrs: ThinVec::new(),\n                     source: LocalSource::AsyncFn,\n-                });\n-                let stmt = Stmt { id, node: StmtKind::Local(local), span, };\n+                };\n+\n+                // Construct a `let <pat> = __argN;` statement to insert at the top of the\n+                // async closure if this isn't a simple pattern.\n+                let pat_stmt = if is_simple_pattern {\n+                    None\n+                } else {\n+                    Some(Stmt {\n+                        id,\n+                        node: StmtKind::Local(P(Local {\n+                            pat: input.pat.clone(),\n+                            ..move_local.clone()\n+                        })),\n+                        span,\n+                    })\n+                };\n \n-                arguments.push(AsyncArgument { ident, arg, stmt });\n+                let move_stmt = Stmt { id, node: StmtKind::Local(P(move_local)), span };\n+                arguments.push(AsyncArgument { ident, arg, pat_stmt, move_stmt });\n             }\n         }\n     }"}, {"sha": "708c570498460147de3cac9a1f6a884452d7966b", "filename": "src/test/run-pass/async-await-drop-order-for-async-fn-parameters.rs", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d/src%2Ftest%2Frun-pass%2Fasync-await-drop-order-for-async-fn-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d/src%2Ftest%2Frun-pass%2Fasync-await-drop-order-for-async-fn-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fasync-await-drop-order-for-async-fn-parameters.rs?ref=b05d5db87bd9a3f31729a5c48dc5dd5bec6dbd2d", "patch": "@@ -0,0 +1,263 @@\n+// aux-build:arc_wake.rs\n+// edition:2018\n+// run-pass\n+\n+#![allow(unused_variables)]\n+#![feature(async_await, await_macro)]\n+\n+// Test that the drop order for parameters in a fn and async fn matches up. Also test that\n+// parameters (used or unused) are not dropped until the async fn completes execution.\n+// See also #54716.\n+\n+extern crate arc_wake;\n+\n+use arc_wake::ArcWake;\n+use std::cell::RefCell;\n+use std::future::Future;\n+use std::marker::PhantomData;\n+use std::sync::Arc;\n+use std::rc::Rc;\n+use std::task::Context;\n+\n+struct EmptyWaker;\n+\n+impl ArcWake for EmptyWaker {\n+    fn wake(self: Arc<Self>) {}\n+}\n+\n+#[derive(Debug, Eq, PartialEq)]\n+enum DropOrder {\n+    Function,\n+    Val(&'static str),\n+}\n+\n+type DropOrderListPtr = Rc<RefCell<Vec<DropOrder>>>;\n+\n+struct D(&'static str, DropOrderListPtr);\n+\n+impl Drop for D {\n+    fn drop(&mut self) {\n+        self.1.borrow_mut().push(DropOrder::Val(self.0));\n+    }\n+}\n+\n+/// Check that unused bindings are dropped after the function is polled.\n+async fn foo_async(x: D, _y: D) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+fn foo_sync(x: D, _y: D) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+/// Check that underscore patterns are dropped after the function is polled.\n+async fn bar_async(x: D, _: D) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+fn bar_sync(x: D, _: D) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+/// Check that underscore patterns within more complex patterns are dropped after the function\n+/// is polled.\n+async fn baz_async((x, _): (D, D)) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+fn baz_sync((x, _): (D, D)) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+/// Check that underscore and unused bindings within and outwith more complex patterns are dropped\n+/// after the function is polled.\n+async fn foobar_async(x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+fn foobar_sync(x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+struct Foo;\n+\n+impl Foo {\n+    /// Check that unused bindings are dropped after the method is polled.\n+    async fn foo_async(x: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    fn foo_sync(x: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore patterns are dropped after the method is polled.\n+    async fn bar_async(x: D, _: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    fn bar_sync(x: D, _: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore patterns within more complex patterns are dropped after the method\n+    /// is polled.\n+    async fn baz_async((x, _): (D, D)) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    fn baz_sync((x, _): (D, D)) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore and unused bindings within and outwith more complex patterns are\n+    /// dropped after the method is polled.\n+    async fn foobar_async(x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    fn foobar_sync(x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+}\n+\n+struct Bar<'a>(PhantomData<&'a ()>);\n+\n+impl<'a> Bar<'a> {\n+    /// Check that unused bindings are dropped after the method with self is polled.\n+    async fn foo_async(&'a self, x: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    fn foo_sync(&'a self, x: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore patterns are dropped after the method with self is polled.\n+    async fn bar_async(&'a self, x: D, _: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    fn bar_sync(&'a self, x: D, _: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore patterns within more complex patterns are dropped after the method\n+    /// with self is polled.\n+    async fn baz_async(&'a self, (x, _): (D, D)) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    fn baz_sync(&'a self, (x, _): (D, D)) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore and unused bindings within and outwith more complex patterns are\n+    /// dropped after the method with self is polled.\n+    async fn foobar_async(&'a self, x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    fn foobar_sync(&'a self, x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+}\n+\n+fn assert_drop_order_after_poll<Fut: Future<Output = ()>>(\n+    f: impl FnOnce(DropOrderListPtr) -> Fut,\n+    g: impl FnOnce(DropOrderListPtr),\n+) {\n+    let empty = Arc::new(EmptyWaker);\n+    let waker = ArcWake::into_waker(empty);\n+    let mut cx = Context::from_waker(&waker);\n+\n+    let actual_order = Rc::new(RefCell::new(Vec::new()));\n+    let mut fut = Box::pin(f(actual_order.clone()));\n+    let _ = fut.as_mut().poll(&mut cx);\n+\n+    let expected_order = Rc::new(RefCell::new(Vec::new()));\n+    g(expected_order.clone());\n+\n+    assert_eq!(*actual_order.borrow(), *expected_order.borrow());\n+}\n+\n+fn main() {\n+    // Free functions (see doc comment on function for what it tests).\n+    assert_drop_order_after_poll(|l| foo_async(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n+                                 |l| foo_sync(D(\"x\", l.clone()), D(\"_y\", l.clone())));\n+    assert_drop_order_after_poll(|l| bar_async(D(\"x\", l.clone()), D(\"_\", l.clone())),\n+                                 |l| bar_sync(D(\"x\", l.clone()), D(\"_\", l.clone())));\n+    assert_drop_order_after_poll(|l| baz_async((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n+                                 |l| baz_sync((D(\"x\", l.clone()), D(\"_\", l.clone()))));\n+    assert_drop_order_after_poll(\n+        |l| {\n+            foobar_async(\n+                D(\"x\", l.clone()),\n+                (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+                D(\"_\", l.clone()),\n+                D(\"_y\", l.clone()),\n+            )\n+        },\n+        |l| {\n+            foobar_sync(\n+                D(\"x\", l.clone()),\n+                (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+                D(\"_\", l.clone()),\n+                D(\"_y\", l.clone()),\n+            )\n+        },\n+    );\n+\n+    // Methods w/out self (see doc comment on function for what it tests).\n+    assert_drop_order_after_poll(|l| Foo::foo_async(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n+                                 |l| Foo::foo_sync(D(\"x\", l.clone()), D(\"_y\", l.clone())));\n+    assert_drop_order_after_poll(|l| Foo::bar_async(D(\"x\", l.clone()), D(\"_\", l.clone())),\n+                                 |l| Foo::bar_sync(D(\"x\", l.clone()), D(\"_\", l.clone())));\n+    assert_drop_order_after_poll(|l| Foo::baz_async((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n+                                 |l| Foo::baz_sync((D(\"x\", l.clone()), D(\"_\", l.clone()))));\n+    assert_drop_order_after_poll(\n+        |l| {\n+            Foo::foobar_async(\n+                D(\"x\", l.clone()),\n+                (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+                D(\"_\", l.clone()),\n+                D(\"_y\", l.clone()),\n+            )\n+        },\n+        |l| {\n+            Foo::foobar_sync(\n+                D(\"x\", l.clone()),\n+                (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+                D(\"_\", l.clone()),\n+                D(\"_y\", l.clone()),\n+            )\n+        },\n+    );\n+\n+    // Methods (see doc comment on function for what it tests).\n+    let b = Bar(Default::default());\n+    assert_drop_order_after_poll(|l| b.foo_async(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n+                                 |l| b.foo_sync(D(\"x\", l.clone()), D(\"_y\", l.clone())));\n+    assert_drop_order_after_poll(|l| b.bar_async(D(\"x\", l.clone()), D(\"_\", l.clone())),\n+                                 |l| b.bar_sync(D(\"x\", l.clone()), D(\"_\", l.clone())));\n+    assert_drop_order_after_poll(|l| b.baz_async((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n+                                 |l| b.baz_sync((D(\"x\", l.clone()), D(\"_\", l.clone()))));\n+    assert_drop_order_after_poll(\n+        |l| {\n+            b.foobar_async(\n+                D(\"x\", l.clone()),\n+                (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+                D(\"_\", l.clone()),\n+                D(\"_y\", l.clone()),\n+            )\n+        },\n+        |l| {\n+            b.foobar_sync(\n+                D(\"x\", l.clone()),\n+                (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+                D(\"_\", l.clone()),\n+                D(\"_y\", l.clone()),\n+            )\n+        },\n+    );\n+}"}, {"sha": "961c412f5ecb2751bf86551d087beb84becbf77a", "filename": "src/test/run-pass/issue-54716.rs", "status": "removed", "additions": 0, "deletions": 184, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/47e0803d5c2ad5952220f2c260d7e12921c1d3fe/src%2Ftest%2Frun-pass%2Fissue-54716.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47e0803d5c2ad5952220f2c260d7e12921c1d3fe/src%2Ftest%2Frun-pass%2Fissue-54716.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-54716.rs?ref=47e0803d5c2ad5952220f2c260d7e12921c1d3fe", "patch": "@@ -1,184 +0,0 @@\n-// aux-build:arc_wake.rs\n-// edition:2018\n-// run-pass\n-\n-#![allow(unused_variables)]\n-#![feature(async_await, await_macro)]\n-\n-extern crate arc_wake;\n-\n-use arc_wake::ArcWake;\n-use std::cell::RefCell;\n-use std::future::Future;\n-use std::marker::PhantomData;\n-use std::sync::Arc;\n-use std::rc::Rc;\n-use std::task::Context;\n-\n-struct EmptyWaker;\n-\n-impl ArcWake for EmptyWaker {\n-    fn wake(self: Arc<Self>) {}\n-}\n-\n-#[derive(Debug, Eq, PartialEq)]\n-enum DropOrder {\n-    Function,\n-    Val(&'static str),\n-}\n-\n-type DropOrderListPtr = Rc<RefCell<Vec<DropOrder>>>;\n-\n-struct D(&'static str, DropOrderListPtr);\n-\n-impl Drop for D {\n-    fn drop(&mut self) {\n-        self.1.borrow_mut().push(DropOrder::Val(self.0));\n-    }\n-}\n-\n-/// Check that unused bindings are dropped after the function is polled.\n-async fn foo(x: D, _y: D) {\n-    x.1.borrow_mut().push(DropOrder::Function);\n-}\n-\n-/// Check that underscore patterns are dropped after the function is polled.\n-async fn bar(x: D, _: D) {\n-    x.1.borrow_mut().push(DropOrder::Function);\n-}\n-\n-/// Check that underscore patterns within more complex patterns are dropped after the function\n-/// is polled.\n-async fn baz((x, _): (D, D)) {\n-    x.1.borrow_mut().push(DropOrder::Function);\n-}\n-\n-/// Check that underscore and unused bindings within and outwith more complex patterns are dropped\n-/// after the function is polled.\n-async fn foobar(x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n-    x.1.borrow_mut().push(DropOrder::Function);\n-}\n-\n-struct Foo;\n-\n-impl Foo {\n-    /// Check that unused bindings are dropped after the method is polled.\n-    async fn foo(x: D, _y: D) {\n-        x.1.borrow_mut().push(DropOrder::Function);\n-    }\n-\n-    /// Check that underscore patterns are dropped after the method is polled.\n-    async fn bar(x: D, _: D) {\n-        x.1.borrow_mut().push(DropOrder::Function);\n-    }\n-\n-    /// Check that underscore patterns within more complex patterns are dropped after the method\n-    /// is polled.\n-    async fn baz((x, _): (D, D)) {\n-        x.1.borrow_mut().push(DropOrder::Function);\n-    }\n-\n-    /// Check that underscore and unused bindings within and outwith more complex patterns are\n-    /// dropped after the method is polled.\n-    async fn foobar(x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n-        x.1.borrow_mut().push(DropOrder::Function);\n-    }\n-}\n-\n-struct Bar<'a>(PhantomData<&'a ()>);\n-\n-impl<'a> Bar<'a> {\n-    /// Check that unused bindings are dropped after the method with self is polled.\n-    async fn foo(&'a self, x: D, _y: D) {\n-        x.1.borrow_mut().push(DropOrder::Function);\n-    }\n-\n-    /// Check that underscore patterns are dropped after the method with self is polled.\n-    async fn bar(&'a self, x: D, _: D) {\n-        x.1.borrow_mut().push(DropOrder::Function);\n-    }\n-\n-    /// Check that underscore patterns within more complex patterns are dropped after the method\n-    /// with self is polled.\n-    async fn baz(&'a self, (x, _): (D, D)) {\n-        x.1.borrow_mut().push(DropOrder::Function);\n-    }\n-\n-    /// Check that underscore and unused bindings within and outwith more complex patterns are\n-    /// dropped after the method with self is polled.\n-    async fn foobar(&'a self, x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n-        x.1.borrow_mut().push(DropOrder::Function);\n-    }\n-}\n-\n-fn assert_drop_order_after_poll<Fut: Future<Output = ()>>(\n-    f: impl FnOnce(DropOrderListPtr) -> Fut,\n-    expected_order: &[DropOrder],\n-) {\n-    let empty = Arc::new(EmptyWaker);\n-    let waker = ArcWake::into_waker(empty);\n-    let mut cx = Context::from_waker(&waker);\n-\n-    let actual_order = Rc::new(RefCell::new(Vec::new()));\n-    let mut fut = Box::pin(f(actual_order.clone()));\n-    let _ = fut.as_mut().poll(&mut cx);\n-\n-    assert_eq!(*actual_order.borrow(), expected_order);\n-}\n-\n-fn main() {\n-    use DropOrder::*;\n-\n-    // At time of writing (23/04/19), the `bar` and `foobar` tests do not output the same order as\n-    // the equivalent non-async functions. This is because the drop order of captured variables\n-    // doesn't match the drop order of arguments in a function.\n-\n-    // Free functions (see doc comment on function for what it tests).\n-    assert_drop_order_after_poll(|l| foo(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n-                                 &[Function, Val(\"_y\"), Val(\"x\")]);\n-    assert_drop_order_after_poll(|l| bar(D(\"x\", l.clone()), D(\"_\", l.clone())),\n-                                 &[Function, Val(\"x\"), Val(\"_\")]);\n-    assert_drop_order_after_poll(|l| baz((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n-                                 &[Function, Val(\"x\"), Val(\"_\")]);\n-    assert_drop_order_after_poll(|l| {\n-        foobar(\n-            D(\"x\", l.clone()),\n-            (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n-            D(\"_\", l.clone()),\n-            D(\"_y\", l.clone()),\n-        )\n-    }, &[Function, Val(\"_y\"), Val(\"_c\"), Val(\"a\"), Val(\"x\"), Val(\"_\"), Val(\"_\")]);\n-\n-    // Methods w/out self (see doc comment on function for what it tests).\n-    assert_drop_order_after_poll(|l| Foo::foo(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n-                                 &[Function, Val(\"_y\"), Val(\"x\")]);\n-    assert_drop_order_after_poll(|l| Foo::bar(D(\"x\", l.clone()), D(\"_\", l.clone())),\n-                                 &[Function, Val(\"x\"), Val(\"_\")]);\n-    assert_drop_order_after_poll(|l| Foo::baz((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n-                                 &[Function, Val(\"x\"), Val(\"_\")]);\n-    assert_drop_order_after_poll(|l| {\n-        Foo::foobar(\n-            D(\"x\", l.clone()),\n-            (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n-            D(\"_\", l.clone()),\n-            D(\"_y\", l.clone()),\n-        )\n-    }, &[Function, Val(\"_y\"), Val(\"_c\"), Val(\"a\"), Val(\"x\"), Val(\"_\"), Val(\"_\")]);\n-\n-    // Methods (see doc comment on function for what it tests).\n-    let b = Bar(Default::default());\n-    assert_drop_order_after_poll(|l| b.foo(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n-                                 &[Function, Val(\"_y\"), Val(\"x\")]);\n-    assert_drop_order_after_poll(|l| b.bar(D(\"x\", l.clone()), D(\"_\", l.clone())),\n-                                 &[Function, Val(\"x\"), Val(\"_\")]);\n-    assert_drop_order_after_poll(|l| b.baz((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n-                                 &[Function, Val(\"x\"), Val(\"_\")]);\n-    assert_drop_order_after_poll(|l| {\n-        b.foobar(\n-            D(\"x\", l.clone()),\n-            (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n-            D(\"_\", l.clone()),\n-            D(\"_y\", l.clone()),\n-        )\n-    }, &[Function, Val(\"_y\"), Val(\"_c\"), Val(\"a\"), Val(\"x\"), Val(\"_\"), Val(\"_\")]);\n-}"}]}