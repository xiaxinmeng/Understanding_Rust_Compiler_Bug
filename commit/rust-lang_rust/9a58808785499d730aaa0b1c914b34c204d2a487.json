{"sha": "9a58808785499d730aaa0b1c914b34c204d2a487", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhNTg4MDg3ODU0OTlkNzMwYWFhMGIxYzkxNGIzNGMyMDRkMmE0ODc=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-12-28T23:31:17Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-12-29T05:20:38Z"}, "message": "Little bit of refactoring in resolve", "tree": {"sha": "c282799abe9c9da4a904934f2f61e772d691a1da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c282799abe9c9da4a904934f2f61e772d691a1da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a58808785499d730aaa0b1c914b34c204d2a487", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a58808785499d730aaa0b1c914b34c204d2a487", "html_url": "https://github.com/rust-lang/rust/commit/9a58808785499d730aaa0b1c914b34c204d2a487", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a58808785499d730aaa0b1c914b34c204d2a487/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c1567e62250fa681f73b997ca252f99e99728cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c1567e62250fa681f73b997ca252f99e99728cd", "html_url": "https://github.com/rust-lang/rust/commit/9c1567e62250fa681f73b997ca252f99e99728cd"}], "stats": {"total": 193, "additions": 94, "deletions": 99}, "files": [{"sha": "3f35f99a9956e29b0a20b93939310f0bd1c59b6b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 94, "deletions": 99, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/9a58808785499d730aaa0b1c914b34c204d2a487/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a58808785499d730aaa0b1c914b34c204d2a487/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=9a58808785499d730aaa0b1c914b34c204d2a487", "patch": "@@ -459,6 +459,22 @@ impl ImportResolution {\n \n         target.unwrap().shadowable\n     }\n+\n+    fn set_target_and_id(&mut self,\n+                         namespace: Namespace,\n+                         target: Option<Target>,\n+                         id: NodeId) {\n+        match namespace {\n+            TypeNS  => {\n+                self.type_target = target;\n+                self.type_id = id;\n+            }\n+            ValueNS => {\n+                self.value_target = target;\n+                self.value_id = id;\n+            }\n+        }\n+    }\n }\n \n /// The link from a module up to its nearest parent node.\n@@ -2705,64 +2721,45 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // We've successfully resolved the import. Write the results in.\n         let mut import_resolutions = module_.import_resolutions.borrow_mut();\n         let import_resolution = &mut (*import_resolutions)[target];\n+        {\n+            let check_and_write_import = |namespace, result: &_, used_public: &mut bool| {\n+                let namespace_name = match namespace {\n+                    TypeNS => \"type\",\n+                    ValueNS => \"value\",\n+                };\n \n-        match value_result {\n-            BoundResult(ref target_module, ref name_bindings) => {\n-                debug!(\"(resolving single import) found value target: {}\",\n-                       { name_bindings.value_def.borrow().clone().unwrap().def });\n-                self.check_for_conflicting_import(\n-                    &import_resolution.value_target,\n-                    directive.span,\n-                    target,\n-                    ValueNS);\n-\n-                self.check_that_import_is_importable(\n-                    &**name_bindings,\n-                    directive.span,\n-                    target,\n-                    ValueNS);\n-\n-                import_resolution.value_target =\n-                    Some(Target::new(target_module.clone(),\n-                                     name_bindings.clone(),\n-                                     directive.shadowable));\n-                import_resolution.value_id = directive.id;\n-                import_resolution.is_public = directive.is_public;\n-                value_used_public = name_bindings.defined_in_public_namespace(ValueNS);\n-            }\n-            UnboundResult => { /* Continue. */ }\n-            UnknownResult => {\n-                panic!(\"value result should be known at this point\");\n-            }\n-        }\n-        match type_result {\n-            BoundResult(ref target_module, ref name_bindings) => {\n-                debug!(\"(resolving single import) found type target: {}\",\n-                       { name_bindings.type_def.borrow().clone().unwrap().type_def });\n-                self.check_for_conflicting_import(\n-                    &import_resolution.type_target,\n-                    directive.span,\n-                    target,\n-                    TypeNS);\n-\n-                self.check_that_import_is_importable(\n-                    &**name_bindings,\n-                    directive.span,\n-                    target,\n-                    TypeNS);\n-\n-                import_resolution.type_target =\n-                    Some(Target::new(target_module.clone(),\n-                                     name_bindings.clone(),\n-                                     directive.shadowable));\n-                import_resolution.type_id = directive.id;\n-                import_resolution.is_public = directive.is_public;\n-                type_used_public = name_bindings.defined_in_public_namespace(TypeNS);\n-            }\n-            UnboundResult => { /* Continue. */ }\n-            UnknownResult => {\n-                panic!(\"type result should be known at this point\");\n-            }\n+                match *result {\n+                    BoundResult(ref target_module, ref name_bindings) => {\n+                        debug!(\"(resolving single import) found {} target: {}\",\n+                               namespace_name,\n+                               name_bindings.def_for_namespace(namespace));\n+                        self.check_for_conflicting_import(\n+                            &import_resolution.target_for_namespace(namespace),\n+                            directive.span,\n+                            target,\n+                            namespace);\n+\n+                        self.check_that_import_is_importable(\n+                            &**name_bindings,\n+                            directive.span,\n+                            target,\n+                            namespace);\n+\n+                        let target = Some(Target::new(target_module.clone(),\n+                                                      name_bindings.clone(),\n+                                                      directive.shadowable));\n+                        import_resolution.set_target_and_id(namespace, target, directive.id);\n+                        import_resolution.is_public = directive.is_public;\n+                        *used_public = name_bindings.defined_in_public_namespace(namespace);\n+                    }\n+                    UnboundResult => { /* Continue. */ }\n+                    UnknownResult => {\n+                        panic!(\"{} result should be known at this point\", namespace_name);\n+                    }\n+                }\n+            };\n+            check_and_write_import(ValueNS, &value_result, &mut value_used_public);\n+            check_and_write_import(TypeNS, &type_result, &mut type_used_public);\n         }\n \n         self.check_for_conflicts_between_imports_and_items(\n@@ -2818,7 +2815,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     // Resolves a glob import. Note that this function cannot fail; it either\n     // succeeds or bails out (as importing * from an empty module or a module\n-    // that exports nothing is valid).\n+    // that exports nothing is valid). containing_module is the module we are\n+    // actually importing, i.e., `foo` in `use foo::*`.\n     fn resolve_glob_import(&mut self,\n                            module_: &Module,\n                            containing_module: Rc<Module>,\n@@ -2844,12 +2842,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         assert_eq!(containing_module.glob_count.get(), 0);\n \n         // Add all resolved imports from the containing module.\n-        let import_resolutions = containing_module.import_resolutions\n-                                                  .borrow();\n+        let import_resolutions = containing_module.import_resolutions.borrow();\n         for (ident, target_import_resolution) in import_resolutions.iter() {\n             debug!(\"(resolving glob import) writing module resolution \\\n                     {} into `{}`\",\n-                   target_import_resolution.type_target.is_none(),\n+                   token::get_name(*ident),\n                    self.module_to_string(module_));\n \n             if !target_import_resolution.is_public {\n@@ -2869,17 +2866,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             // Continue.\n                         }\n                         Some(ref value_target) => {\n-                            dest_import_resolution.value_target =\n-                                Some(value_target.clone());\n+                            dest_import_resolution.value_target = Some(value_target.clone());\n                         }\n                     }\n                     match target_import_resolution.type_target {\n                         None => {\n                             // Continue.\n                         }\n                         Some(ref type_target) => {\n-                            dest_import_resolution.type_target =\n-                                Some(type_target.clone());\n+                            dest_import_resolution.type_target = Some(type_target.clone());\n                         }\n                     }\n                     dest_import_resolution.is_public = is_public;\n@@ -2901,8 +2896,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Add all children from the containing module.\n         self.populate_module_if_necessary(&containing_module);\n \n-        for (&name, name_bindings) in containing_module.children\n-                                                       .borrow().iter() {\n+        for (&name, name_bindings) in containing_module.children.borrow().iter() {\n             self.merge_import_resolution(module_,\n                                          containing_module.clone(),\n                                          import_directive,\n@@ -2912,8 +2906,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         // Add external module children from the containing module.\n-        for (&name, module) in containing_module.external_module_children\n-                                                .borrow().iter() {\n+        for (&name, module) in containing_module.external_module_children.borrow().iter() {\n             let name_bindings =\n                 Rc::new(Resolver::create_name_bindings_from_module(module.clone()));\n             self.merge_import_resolution(module_,\n@@ -2958,41 +2951,39 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         debug!(\"(resolving glob import) writing resolution `{}` in `{}` \\\n                to `{}`\",\n-               token::get_name(name).get().to_string(),\n+               token::get_name(name).get(),\n                self.module_to_string(&*containing_module),\n                self.module_to_string(module_));\n \n         // Merge the child item into the import resolution.\n-        if name_bindings.defined_in_namespace_with(ValueNS, IMPORTABLE | PUBLIC) {\n-            debug!(\"(resolving glob import) ... for value target\");\n-            if dest_import_resolution.shadowable(ValueNS) == Shadowable::Never {\n-                let msg = format!(\"a value named `{}` has already been imported \\\n-                                   in this module\",\n-                                  token::get_name(name).get());\n-                self.session.span_err(import_directive.span, msg.as_slice());\n-            } else {\n-                dest_import_resolution.value_target =\n-                    Some(Target::new(containing_module.clone(),\n-                                     name_bindings.clone(),\n-                                     import_directive.shadowable));\n-                dest_import_resolution.value_id = id;\n-            }\n-        }\n-        if name_bindings.defined_in_namespace_with(TypeNS, IMPORTABLE | PUBLIC) {\n-            debug!(\"(resolving glob import) ... for type target\");\n-            if dest_import_resolution.shadowable(TypeNS) == Shadowable::Never {\n-                let msg = format!(\"a type named `{}` has already been imported \\\n-                                   in this module\",\n-                                  token::get_name(name).get());\n-                self.session.span_err(import_directive.span, msg.as_slice());\n-            } else {\n-                dest_import_resolution.type_target =\n-                    Some(Target::new(containing_module,\n-                                     name_bindings.clone(),\n-                                     import_directive.shadowable));\n-                dest_import_resolution.type_id = id;\n-            }\n+        {\n+            let merge_child_item = |namespace| {\n+                if name_bindings.defined_in_namespace_with(namespace, IMPORTABLE | PUBLIC) {\n+                    let namespace_name = match namespace {\n+                        TypeNS => \"type\",\n+                        ValueNS => \"value\",\n+                    };\n+                    debug!(\"(resolving glob import) ... for {} target\", namespace_name);\n+                    if dest_import_resolution.shadowable(namespace) == Shadowable::Never {\n+                        let msg = format!(\"a {} named `{}` has already been imported \\\n+                                           in this module\",\n+                                          namespace_name,\n+                                          token::get_name(name).get());\n+                        self.session.span_err(import_directive.span, msg.as_slice());\n+                    } else {\n+                        let target = Target::new(containing_module.clone(),\n+                                                 name_bindings.clone(),\n+                                                 import_directive.shadowable);\n+                        dest_import_resolution.set_target_and_id(namespace,\n+                                                                 Some(target),\n+                                                                 id);\n+                    }\n+                }\n+            };\n+            merge_child_item(ValueNS);\n+            merge_child_item(TypeNS);\n         }\n+\n         dest_import_resolution.is_public = is_public;\n \n         self.check_for_conflicts_between_imports_and_items(\n@@ -3012,6 +3003,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             return\n         }\n \n+        debug!(\"check_for_conflicting_import: {}; target exists: {}\",\n+               token::get_name(name).get(),\n+               target.is_some());\n+\n         match *target {\n             Some(ref target) if target.shadowable != Shadowable::Always => {\n                 let msg = format!(\"a {} named `{}` has already been imported \\"}]}