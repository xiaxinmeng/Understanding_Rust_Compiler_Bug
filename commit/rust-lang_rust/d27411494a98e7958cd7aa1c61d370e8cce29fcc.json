{"sha": "d27411494a98e7958cd7aa1c61d370e8cce29fcc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyNzQxMTQ5NGE5OGU3OTU4Y2Q3YWExYzYxZDM3MGU4Y2NlMjlmY2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-12T03:40:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-12T03:40:10Z"}, "message": "Auto merge of #44985 - zilbuz:issue-44974, r=pnkfelix\n\nMIR borrowck: print lvalues in error messages in the same way that the AST borrowck\n\nFix #44974\n\n- Print fields with `.name` rather than `.<num>`\n- Autoderef values if followed by a field or an index\n- Output `[..]` when borrowing inside a slice", "tree": {"sha": "1cb1b292cffab910f15a42e1998b94245732df14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1cb1b292cffab910f15a42e1998b94245732df14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d27411494a98e7958cd7aa1c61d370e8cce29fcc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d27411494a98e7958cd7aa1c61d370e8cce29fcc", "html_url": "https://github.com/rust-lang/rust/commit/d27411494a98e7958cd7aa1c61d370e8cce29fcc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d27411494a98e7958cd7aa1c61d370e8cce29fcc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbb5054fa9fb9dac785553d6b2baa765f5c0e999", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbb5054fa9fb9dac785553d6b2baa765f5c0e999", "html_url": "https://github.com/rust-lang/rust/commit/fbb5054fa9fb9dac785553d6b2baa765f5c0e999"}, {"sha": "e32e81c9da5adcc77bd12192d45d2d4af54d0ee9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e32e81c9da5adcc77bd12192d45d2d4af54d0ee9", "html_url": "https://github.com/rust-lang/rust/commit/e32e81c9da5adcc77bd12192d45d2d4af54d0ee9"}], "stats": {"total": 474, "additions": 439, "deletions": 35}, "files": [{"sha": "62c7c7db13bd7fea7ba837005a26c9fd73bf9f1c", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 100, "deletions": 26, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/d27411494a98e7958cd7aa1c61d370e8cce29fcc/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d27411494a98e7958cd7aa1c61d370e8cce29fcc/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=d27411494a98e7958cd7aa1c61d370e8cce29fcc", "patch": "@@ -14,7 +14,7 @@ use rustc::hir::def_id::{DefId};\n use rustc::infer::{InferCtxt};\n use rustc::ty::{self, TyCtxt, ParamEnv};\n use rustc::ty::maps::Providers;\n-use rustc::mir::{AssertMessage, BasicBlock, BorrowKind, Location, Lvalue};\n+use rustc::mir::{AssertMessage, BasicBlock, BorrowKind, Location, Lvalue, Local};\n use rustc::mir::{Mir, Mutability, Operand, Projection, ProjectionElem, Rvalue};\n use rustc::mir::{Statement, StatementKind, Terminator, TerminatorKind};\n use rustc::mir::transform::{MirSource};\n@@ -1080,49 +1080,52 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     // End-user visible description of `lvalue`\n     fn describe_lvalue(&self, lvalue: &Lvalue) -> String {\n         let mut buf = String::new();\n-        self.append_lvalue_to_string(lvalue, &mut buf);\n+        self.append_lvalue_to_string(lvalue, &mut buf, None);\n         buf\n     }\n \n     // Appends end-user visible description of `lvalue` to `buf`.\n-    fn append_lvalue_to_string(&self, lvalue: &Lvalue, buf: &mut String) {\n+    fn append_lvalue_to_string(&self, lvalue: &Lvalue, buf: &mut String, autoderef: Option<bool>) {\n         match *lvalue {\n             Lvalue::Local(local) => {\n-                let local = &self.mir.local_decls[local];\n-                match local.name {\n-                    Some(name) => buf.push_str(&format!(\"{}\", name)),\n-                    None => buf.push_str(\"_\"),\n-                }\n+                self.append_local_to_string(local, buf, \"_\");\n             }\n             Lvalue::Static(ref static_) => {\n                 buf.push_str(&format!(\"{}\", &self.tcx.item_name(static_.def_id)));\n             }\n             Lvalue::Projection(ref proj) => {\n+                let mut autoderef = autoderef.unwrap_or(false);\n                 let (prefix, suffix, index_operand) = match proj.elem {\n-                    ProjectionElem::Deref =>\n-                        (\"(*\", format!(\")\"), None),\n+                    ProjectionElem::Deref => {\n+                        if autoderef {\n+                            (\"\", format!(\"\"), None)\n+                        } else {\n+                            (\"(*\", format!(\")\"), None)\n+                        }\n+                    },\n                     ProjectionElem::Downcast(..) =>\n                         (\"\",   format!(\"\"), None), // (dont emit downcast info)\n-                    ProjectionElem::Field(field, _ty) =>\n-                        (\"\",   format!(\".{}\", field.index()), None), // FIXME: report name of field\n-                    ProjectionElem::Index(index) =>\n-                        (\"\",   format!(\"\"), Some(index)),\n-                    ProjectionElem::ConstantIndex { offset, min_length, from_end: true } =>\n-                        (\"\",   format!(\"[{} of {}]\", offset, min_length), None),\n-                    ProjectionElem::ConstantIndex { offset, min_length, from_end: false } =>\n-                        (\"\",   format!(\"[-{} of {}]\", offset, min_length), None),\n-                    ProjectionElem::Subslice { from, to: 0 } =>\n-                        (\"\",   format!(\"[{}:]\", from), None),\n-                    ProjectionElem::Subslice { from: 0, to } =>\n-                        (\"\",   format!(\"[:-{}]\", to), None),\n-                    ProjectionElem::Subslice { from, to } =>\n-                        (\"\",   format!(\"[{}:-{}]\", from, to), None),\n+                    ProjectionElem::Field(field, _ty) => {\n+                        autoderef = true;\n+                        (\"\", format!(\".{}\", self.describe_field(&proj.base, field.index())), None)\n+                    },\n+                    ProjectionElem::Index(index) => {\n+                        autoderef = true;\n+                        (\"\",   format!(\"\"), Some(index))\n+                    },\n+                    ProjectionElem::ConstantIndex { .. } | ProjectionElem::Subslice { .. } => {\n+                        autoderef = true;\n+                        // Since it isn't possible to borrow an element on a particular index and\n+                        // then use another while the borrow is held, don't output indices details\n+                        // to avoid confusing the end-user\n+                        (\"\",   format!(\"[..]\"), None)\n+                    },\n                 };\n                 buf.push_str(prefix);\n-                self.append_lvalue_to_string(&proj.base, buf);\n+                self.append_lvalue_to_string(&proj.base, buf, Some(autoderef));\n                 if let Some(index) = index_operand {\n                     buf.push_str(\"[\");\n-                    self.append_lvalue_to_string(&Lvalue::Local(index), buf);\n+                    self.append_local_to_string(index, buf, \"..\");\n                     buf.push_str(\"]\");\n                 } else {\n                     buf.push_str(&suffix);\n@@ -1131,6 +1134,77 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n         }\n     }\n \n+    // Appends end-user visible description of the `local` lvalue to `buf`. If `local` doesn't have\n+    // a name, then `none_string` is appended instead\n+    fn append_local_to_string(&self, local_index: Local, buf: &mut String, none_string: &str) {\n+        let local = &self.mir.local_decls[local_index];\n+        match local.name {\n+            Some(name) => buf.push_str(&format!(\"{}\", name)),\n+            None => buf.push_str(none_string)\n+        }\n+    }\n+\n+    // End-user visible description of the `field_index`nth field of `base`\n+    fn describe_field(&self, base: &Lvalue, field_index: usize) -> String {\n+        match *base {\n+            Lvalue::Local(local) => {\n+                let local = &self.mir.local_decls[local];\n+                self.describe_field_from_ty(&local.ty, field_index)\n+            },\n+            Lvalue::Static(ref static_) => {\n+                self.describe_field_from_ty(&static_.ty, field_index)\n+            },\n+            Lvalue::Projection(ref proj) => {\n+                match proj.elem {\n+                    ProjectionElem::Deref =>\n+                        self.describe_field(&proj.base, field_index),\n+                    ProjectionElem::Downcast(def, variant_index) =>\n+                        format!(\"{}\", def.variants[variant_index].fields[field_index].name),\n+                    ProjectionElem::Field(_, field_type) =>\n+                        self.describe_field_from_ty(&field_type, field_index),\n+                    ProjectionElem::Index(..)\n+                    | ProjectionElem::ConstantIndex { .. }\n+                    | ProjectionElem::Subslice { .. } =>\n+                        format!(\"{}\", self.describe_field(&proj.base, field_index)),\n+                }\n+            }\n+        }\n+    }\n+\n+    // End-user visible description of the `field_index`nth field of `ty`\n+    fn describe_field_from_ty(&self, ty: &ty::Ty, field_index: usize) -> String {\n+        if ty.is_box() {\n+            // If the type is a box, the field is described from the boxed type\n+            self.describe_field_from_ty(&ty.boxed_ty(), field_index)\n+        }\n+        else {\n+            match ty.sty {\n+                ty::TyAdt(def, _) => {\n+                    if def.is_enum() {\n+                        format!(\"{}\", field_index)\n+                    }\n+                    else {\n+                        format!(\"{}\", def.struct_variant().fields[field_index].name)\n+                    }\n+                },\n+                ty::TyTuple(_, _) => {\n+                    format!(\"{}\", field_index)\n+                },\n+                ty::TyRef(_, tnm) | ty::TyRawPtr(tnm) => {\n+                    self.describe_field_from_ty(&tnm.ty, field_index)\n+                },\n+                ty::TyArray(ty, _) | ty::TySlice(ty) => {\n+                    self.describe_field_from_ty(&ty, field_index)\n+                }\n+                _ => {\n+                    // Might need a revision when the fields in trait RFC is implemented\n+                    // (https://github.com/rust-lang/rfcs/pull/1546)\n+                    bug!(\"End-user description not implemented for field access on `{:?}`\", ty.sty);\n+                }\n+            }\n+        }\n+    }\n+\n     // Retrieve span of given borrow from the current MIR representation\n     fn retrieve_borrow_span(&self, borrow: &BorrowData) -> Span {\n         self.mir.source_info(borrow.location).span"}, {"sha": "548436c3ed87021eedd2d0b2383ddb45bd158188", "filename": "src/test/compile-fail/borrowck/borrowck-assign-comp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d27411494a98e7958cd7aa1c61d370e8cce29fcc/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-assign-comp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d27411494a98e7958cd7aa1c61d370e8cce29fcc/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-assign-comp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-assign-comp.rs?ref=d27411494a98e7958cd7aa1c61d370e8cce29fcc", "patch": "@@ -22,7 +22,7 @@ fn a() {\n     // immutable.  Otherwise the type of &_q.x (&isize) would be wrong.\n     p.x = 5; //[ast]~ ERROR cannot assign to `p.x`\n              //[mir]~^ ERROR cannot assign to `p.x` because it is borrowed (Ast)\n-             //[mir]~| ERROR cannot assign to `p.0` because it is borrowed (Mir)\n+             //[mir]~| ERROR cannot assign to `p.x` because it is borrowed (Mir)\n     q.x;\n }\n \n@@ -47,7 +47,7 @@ fn d() {\n     let q = &p.y;\n     p.y = 5; //[ast]~ ERROR cannot assign to `p.y`\n              //[mir]~^ ERROR cannot assign to `p.y` because it is borrowed (Ast)\n-             //[mir]~| ERROR cannot assign to `p.1` because it is borrowed (Mir)\n+             //[mir]~| ERROR cannot assign to `p.y` because it is borrowed (Mir)\n     *q;\n }\n "}, {"sha": "0b6b9bf7d484d9fd3faf114c8a499b533d36a3c5", "filename": "src/test/compile-fail/borrowck/borrowck-closures-mut-and-imm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d27411494a98e7958cd7aa1c61d370e8cce29fcc/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-closures-mut-and-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d27411494a98e7958cd7aa1c61d370e8cce29fcc/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-closures-mut-and-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-closures-mut-and-imm.rs?ref=d27411494a98e7958cd7aa1c61d370e8cce29fcc", "patch": "@@ -82,7 +82,7 @@ fn g() {\n     let c1 = || get(&*x.f);\n     *x.f = 5; //[ast]~ ERROR cannot assign to `*x.f`\n               //[mir]~^ ERROR cannot assign to `*x.f` because it is borrowed (Ast)\n-              //[mir]~| ERROR cannot assign to `(*(*x).0)` because it is borrowed (Mir)\n+              //[mir]~| ERROR cannot assign to `(*x.f)` because it is borrowed (Mir)\n }\n \n fn h() {"}, {"sha": "cff913b17beddd49ce8323dd8254628a9031e520", "filename": "src/test/compile-fail/borrowck/borrowck-describe-lvalue.rs", "status": "added", "additions": 330, "deletions": 0, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/d27411494a98e7958cd7aa1c61d370e8cce29fcc/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-describe-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d27411494a98e7958cd7aa1c61d370e8cce29fcc/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-describe-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-describe-lvalue.rs?ref=d27411494a98e7958cd7aa1c61d370e8cce29fcc", "patch": "@@ -0,0 +1,330 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n+#![feature(slice_patterns)]\n+#![feature(advanced_slice_patterns)]\n+\n+pub struct Foo {\n+  x: u32\n+}\n+\n+pub struct Bar(u32);\n+\n+pub enum Baz {\n+    X(u32)\n+}\n+\n+union U {\n+    a: u8,\n+    b: u64,\n+}\n+\n+impl Foo {\n+  fn x(&mut self) -> &mut u32 { &mut self.x }\n+}\n+\n+impl Bar {\n+    fn x(&mut self) -> &mut u32 { &mut self.0 }\n+}\n+\n+impl Baz {\n+    fn x(&mut self) -> &mut u32 {\n+        match *self {\n+            Baz::X(ref mut value) => value\n+        }\n+    }\n+}\n+\n+static mut sfoo : Foo = Foo{x: 23 };\n+static mut sbar : Bar = Bar(23);\n+static mut stuple : (i32, i32) = (24, 25);\n+static mut senum : Baz = Baz::X(26);\n+static mut sunion : U = U { a: 0 };\n+\n+fn main() {\n+    // Local and field from struct\n+    {\n+        let mut f = Foo { x: 22 };\n+        let _x = f.x();\n+        f.x; //[ast]~ ERROR cannot use `f.x` because it was mutably borrowed\n+             //[mir]~^ ERROR cannot use `f.x` because it was mutably borrowed (Ast)\n+             //[mir]~| ERROR cannot use `f.x` because it was mutably borrowed (Mir)\n+    }\n+    // Local and field from tuple-struct\n+    {\n+        let mut g = Bar(22);\n+        let _0 = g.x();\n+        g.0; //[ast]~ ERROR cannot use `g.0` because it was mutably borrowed\n+             //[mir]~^ ERROR cannot use `g.0` because it was mutably borrowed (Ast)\n+             //[mir]~| ERROR cannot use `g.0` because it was mutably borrowed (Mir)\n+    }\n+    // Local and field from tuple\n+    {\n+        let mut h = (22, 23);\n+        let _0 = &mut h.0;\n+        h.0; //[ast]~ ERROR cannot use `h.0` because it was mutably borrowed\n+             //[mir]~^ ERROR cannot use `h.0` because it was mutably borrowed (Ast)\n+             //[mir]~| ERROR cannot use `h.0` because it was mutably borrowed (Mir)\n+    }\n+    // Local and field from enum\n+    {\n+        let mut e = Baz::X(2);\n+        let _e0 = e.x();\n+        match e {\n+            Baz::X(value) => value\n+            //[ast]~^ ERROR cannot use `e.0` because it was mutably borrowed\n+            //[mir]~^^ ERROR cannot use `e.0` because it was mutably borrowed (Ast)\n+            //[mir]~| ERROR cannot use `e.0` because it was mutably borrowed (Mir)\n+        };\n+    }\n+    // Local and field from union\n+    unsafe {\n+        let mut u = U { b: 0 };\n+        let _ra = &mut u.a;\n+        u.a; //[ast]~ ERROR cannot use `u.a` because it was mutably borrowed\n+             //[mir]~^ ERROR cannot use `u.a` because it was mutably borrowed (Ast)\n+             //[mir]~| ERROR cannot use `u.a` because it was mutably borrowed (Mir)\n+    }\n+    // Static and field from struct\n+    unsafe {\n+        let _x = sfoo.x();\n+        sfoo.x; //[mir]~ ERROR cannot use `sfoo.x` because it was mutably borrowed (Mir)\n+    }\n+    // Static and field from tuple-struct\n+    unsafe {\n+        let _0 = sbar.x();\n+        sbar.0; //[mir]~ ERROR cannot use `sbar.0` because it was mutably borrowed (Mir)\n+    }\n+    // Static and field from tuple\n+    unsafe {\n+        let _0 = &mut stuple.0;\n+        stuple.0; //[mir]~ ERROR cannot use `stuple.0` because it was mutably borrowed (Mir)\n+    }\n+    // Static and field from enum\n+    unsafe {\n+        let _e0 = senum.x();\n+        match senum {\n+            Baz::X(value) => value\n+            //[mir]~^ ERROR cannot use `senum.0` because it was mutably borrowed (Mir)\n+        };\n+    }\n+    // Static and field from union\n+    unsafe {\n+        let _ra = &mut sunion.a;\n+        sunion.a; //[mir]~ ERROR cannot use `sunion.a` because it was mutably borrowed (Mir)\n+    }\n+    // Deref and field from struct\n+    {\n+        let mut f = Box::new(Foo { x: 22 });\n+        let _x = f.x();\n+        f.x; //[ast]~ ERROR cannot use `f.x` because it was mutably borrowed\n+             //[mir]~^ ERROR cannot use `f.x` because it was mutably borrowed (Ast)\n+             //[mir]~| ERROR cannot use `f.x` because it was mutably borrowed (Mir)\n+    }\n+    // Deref and field from tuple-struct\n+    {\n+        let mut g = Box::new(Bar(22));\n+        let _0 = g.x();\n+        g.0; //[ast]~ ERROR cannot use `g.0` because it was mutably borrowed\n+             //[mir]~^ ERROR cannot use `g.0` because it was mutably borrowed (Ast)\n+             //[mir]~| ERROR cannot use `g.0` because it was mutably borrowed (Mir)\n+    }\n+    // Deref and field from tuple\n+    {\n+        let mut h = Box::new((22, 23));\n+        let _0 = &mut h.0;\n+        h.0; //[ast]~ ERROR cannot use `h.0` because it was mutably borrowed\n+             //[mir]~^ ERROR cannot use `h.0` because it was mutably borrowed (Ast)\n+             //[mir]~| ERROR cannot use `h.0` because it was mutably borrowed (Mir)\n+    }\n+    // Deref and field from enum\n+    {\n+        let mut e = Box::new(Baz::X(3));\n+        let _e0 = e.x();\n+        match *e {\n+            Baz::X(value) => value\n+            //[ast]~^ ERROR cannot use `e.0` because it was mutably borrowed\n+            //[mir]~^^ ERROR cannot use `e.0` because it was mutably borrowed (Ast)\n+            //[mir]~| ERROR cannot use `e.0` because it was mutably borrowed (Mir)\n+        };\n+    }\n+    // Deref and field from union\n+    unsafe {\n+        let mut u = Box::new(U { b: 0 });\n+        let _ra = &mut u.a;\n+        u.a; //[ast]~ ERROR cannot use `u.a` because it was mutably borrowed\n+             //[mir]~^ ERROR cannot use `u.a` because it was mutably borrowed (Ast)\n+             //[mir]~| ERROR cannot use `u.a` because it was mutably borrowed (Mir)\n+    }\n+    // Constant index\n+    {\n+        let mut v = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+        let _v = &mut v;\n+        match v {\n+            &[x, _, .., _, _] => println!(\"{}\", x),\n+                //[ast]~^ ERROR cannot use `v[..]` because it was mutably borrowed\n+                //[mir]~^^ ERROR cannot use `v[..]` because it was mutably borrowed (Ast)\n+                //[mir]~| ERROR cannot use `v[..]` because it was mutably borrowed (Mir)\n+                            _ => panic!(\"other case\"),\n+        }\n+        match v {\n+            &[_, x, .., _, _] => println!(\"{}\", x),\n+                //[ast]~^ ERROR cannot use `v[..]` because it was mutably borrowed\n+                //[mir]~^^ ERROR cannot use `v[..]` because it was mutably borrowed (Ast)\n+                //[mir]~| ERROR cannot use `v[..]` because it was mutably borrowed (Mir)\n+                            _ => panic!(\"other case\"),\n+        }\n+        match v {\n+            &[_, _, .., x, _] => println!(\"{}\", x),\n+                //[ast]~^ ERROR cannot use `v[..]` because it was mutably borrowed\n+                //[mir]~^^ ERROR cannot use `v[..]` because it was mutably borrowed (Ast)\n+                //[mir]~| ERROR cannot use `v[..]` because it was mutably borrowed (Mir)\n+                            _ => panic!(\"other case\"),\n+        }\n+        match v {\n+            &[_, _, .., _, x] => println!(\"{}\", x),\n+                //[ast]~^ ERROR cannot use `v[..]` because it was mutably borrowed\n+                //[mir]~^^ ERROR cannot use `v[..]` because it was mutably borrowed (Ast)\n+                //[mir]~| ERROR cannot use `v[..]` because it was mutably borrowed (Mir)\n+                            _ => panic!(\"other case\"),\n+        }\n+    }\n+    // Subslices\n+    {\n+        let mut v = &[1, 2, 3, 4, 5];\n+        let _v = &mut v;\n+        match v {\n+            &[x..] => println!(\"{:?}\", x),\n+                //[ast]~^ ERROR cannot use `v[..]` because it was mutably borrowed\n+                //[mir]~^^ ERROR cannot use `v[..]` because it was mutably borrowed (Ast)\n+                //[mir]~| ERROR cannot use `v[..]` because it was mutably borrowed (Mir)\n+            _ => panic!(\"other case\"),\n+        }\n+        match v {\n+            &[_, x..] => println!(\"{:?}\", x),\n+                //[ast]~^ ERROR cannot use `v[..]` because it was mutably borrowed\n+                //[mir]~^^ ERROR cannot use `v[..]` because it was mutably borrowed (Ast)\n+                //[mir]~| ERROR cannot use `v[..]` because it was mutably borrowed (Mir)\n+            _ => panic!(\"other case\"),\n+        }\n+        match v {\n+            &[x.., _] => println!(\"{:?}\", x),\n+                //[ast]~^ ERROR cannot use `v[..]` because it was mutably borrowed\n+                //[mir]~^^ ERROR cannot use `v[..]` because it was mutably borrowed (Ast)\n+                //[mir]~| ERROR cannot use `v[..]` because it was mutably borrowed (Mir)\n+            _ => panic!(\"other case\"),\n+        }\n+        match v {\n+            &[_, x.., _] => println!(\"{:?}\", x),\n+                //[ast]~^ ERROR cannot use `v[..]` because it was mutably borrowed\n+                //[mir]~^^ ERROR cannot use `v[..]` because it was mutably borrowed (Ast)\n+                //[mir]~| ERROR cannot use `v[..]` because it was mutably borrowed (Mir)\n+            _ => panic!(\"other case\"),\n+        }\n+    }\n+    // Downcasted field\n+    {\n+        enum E<X> { A(X), B { x: X } }\n+\n+        let mut e = E::A(3);\n+        let _e = &mut e;\n+        match e {\n+            E::A(ref ax) =>\n+                //[ast]~^ ERROR cannot borrow `e.0` as immutable because `e` is also borrowed as mutable\n+                //[mir]~^^ ERROR cannot borrow `e.0` as immutable because `e` is also borrowed as mutable (Ast)\n+                //[mir]~| ERROR cannot borrow `e.0` as immutable because it is also borrowed as mutable (Mir)\n+                //[mir]~| ERROR cannot use `e` because it was mutably borrowed (Mir)\n+                println!(\"e.ax: {:?}\", ax),\n+            E::B { x: ref bx } =>\n+                //[ast]~^ ERROR cannot borrow `e.x` as immutable because `e` is also borrowed as mutable\n+                //[mir]~^^ ERROR cannot borrow `e.x` as immutable because `e` is also borrowed as mutable (Ast)\n+                //[mir]~| ERROR cannot borrow `e.x` as immutable because it is also borrowed as mutable (Mir)\n+                println!(\"e.bx: {:?}\", bx),\n+        }\n+    }\n+    // Field in field\n+    {\n+        struct F { x: u32, y: u32 };\n+        struct S { x: F, y: (u32, u32), };\n+        let mut s = S { x: F { x: 1, y: 2}, y: (999, 998) };\n+        let _s = &mut s;\n+        match s {\n+            S  { y: (ref y0, _), .. } =>\n+                //[ast]~^ ERROR cannot borrow `s.y.0` as immutable because `s` is also borrowed as mutable\n+                //[mir]~^^ ERROR cannot borrow `s.y.0` as immutable because `s` is also borrowed as mutable (Ast)\n+                //[mir]~| ERROR cannot borrow `s.y.0` as immutable because it is also borrowed as mutable (Mir)\n+                println!(\"y0: {:?}\", y0),\n+            _ => panic!(\"other case\"),\n+        }\n+        match s {\n+            S  { x: F { y: ref x0, .. }, .. } =>\n+                //[ast]~^ ERROR cannot borrow `s.x.y` as immutable because `s` is also borrowed as mutable\n+                //[mir]~^^ ERROR cannot borrow `s.x.y` as immutable because `s` is also borrowed as mutable (Ast)\n+                //[mir]~| ERROR cannot borrow `s.x.y` as immutable because it is also borrowed as mutable (Mir)\n+                println!(\"x0: {:?}\", x0),\n+            _ => panic!(\"other case\"),\n+        }\n+    }\n+    // Field of ref\n+    {\n+        struct Block<'a> {\n+            current: &'a u8,\n+            unrelated: &'a u8,\n+        };\n+\n+        fn bump<'a>(mut block: &mut Block<'a>) {\n+            let x = &mut block;\n+            let p: &'a u8 = &*block.current;\n+            //[mir]~^ ERROR cannot borrow `(*block.current)` as immutable because it is also borrowed as mutable (Mir)\n+            // No errors in AST because of issue rust#38899\n+        }\n+    }\n+    // Field of ptr\n+    {\n+        struct Block2 {\n+            current: *const u8,\n+            unrelated: *const u8,\n+        }\n+\n+        unsafe fn bump2(mut block: *mut Block2) {\n+            let x = &mut block;\n+            let p : *const u8 = &*(*block).current;\n+            //[mir]~^ ERROR cannot borrow `(*block.current)` as immutable because it is also borrowed as mutable (Mir)\n+            // No errors in AST because of issue rust#38899\n+        }\n+    }\n+    // Field of index\n+    {\n+        struct F {x: u32, y: u32};\n+        let mut v = &[F{x: 1, y: 2}, F{x: 3, y: 4}];\n+        let _v = &mut v;\n+        v[0].y;\n+        //[ast]~^ ERROR cannot use `v[..].y` because it was mutably borrowed\n+        //[mir]~^^ ERROR cannot use `v[..].y` because it was mutably borrowed (Ast)\n+        //[mir]~| ERROR cannot use `v[..].y` because it was mutably borrowed (Mir)\n+        //[mir]~| ERROR cannot use `(*v)` because it was mutably borrowed (Mir)\n+    }\n+    // Field of constant index\n+    {\n+        struct F {x: u32, y: u32};\n+        let mut v = &[F{x: 1, y: 2}, F{x: 3, y: 4}];\n+        let _v = &mut v;\n+        match v {\n+            &[_, F {x: ref xf, ..}] => println!(\"{}\", xf),\n+            //[mir]~^ ERROR cannot borrow `v[..].x` as immutable because it is also borrowed as mutable (Mir)\n+            // No errors in AST\n+            _ => panic!(\"other case\")\n+        }\n+    }\n+}"}, {"sha": "0655d2914eefa9ece4d20997905ed0f69043d6a5", "filename": "src/test/compile-fail/borrowck/borrowck-union-borrow.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d27411494a98e7958cd7aa1c61d370e8cce29fcc/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d27411494a98e7958cd7aa1c61d370e8cce29fcc/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs?ref=d27411494a98e7958cd7aa1c61d370e8cce29fcc", "patch": "@@ -34,13 +34,13 @@ fn main() {\n             let ra = &u.a;\n             let rma = &mut u.a; //[ast]~ ERROR cannot borrow `u.a` as mutable because it is also borrowed as immutable\n                                 //[mir]~^ ERROR cannot borrow `u.a` as mutable because it is also borrowed as immutable (Ast)\n-                                //[mir]~| ERROR cannot borrow `u.0` as mutable because it is also borrowed as immutable (Mir)\n+                                //[mir]~| ERROR cannot borrow `u.a` as mutable because it is also borrowed as immutable (Mir)\n         }\n         {\n             let ra = &u.a;\n             u.a = 1; //[ast]~ ERROR cannot assign to `u.a` because it is borrowed\n                      //[mir]~^ ERROR cannot assign to `u.a` because it is borrowed (Ast)\n-                     //[mir]~| ERROR cannot assign to `u.0` because it is borrowed (Mir)\n+                     //[mir]~| ERROR cannot assign to `u.a` because it is borrowed (Mir)\n         }\n         // Imm borrow, other field\n         {\n@@ -68,25 +68,25 @@ fn main() {\n             let rma = &mut u.a;\n             let ra = &u.a; //[ast]~ ERROR cannot borrow `u.a` as immutable because it is also borrowed as mutable\n                          //[mir]~^ ERROR cannot borrow `u.a` as immutable because it is also borrowed as mutable (Ast)\n-                         //[mir]~| ERROR cannot borrow `u.0` as immutable because it is also borrowed as mutable (Mir)\n+                         //[mir]~| ERROR cannot borrow `u.a` as immutable because it is also borrowed as mutable (Mir)\n         }\n         {\n             let ra = &mut u.a;\n             let a = u.a; //[ast]~ ERROR cannot use `u.a` because it was mutably borrowed\n                          //[mir]~^ ERROR cannot use `u.a` because it was mutably borrowed (Ast)\n-                         //[mir]~| ERROR cannot use `u.0` because it was mutably borrowed (Mir)\n+                         //[mir]~| ERROR cannot use `u.a` because it was mutably borrowed (Mir)\n         }\n         {\n             let rma = &mut u.a;\n             let rma2 = &mut u.a; //[ast]~ ERROR cannot borrow `u.a` as mutable more than once at a time\n                                  //[mir]~^ ERROR cannot borrow `u.a` as mutable more than once at a time (Ast)\n-                                 //[mir]~| ERROR cannot borrow `u.0` as mutable more than once at a time (Mir)\n+                                 //[mir]~| ERROR cannot borrow `u.a` as mutable more than once at a time (Mir)\n         }\n         {\n             let rma = &mut u.a;\n             u.a = 1; //[ast]~ ERROR cannot assign to `u.a` because it is borrowed\n                      //[mir]~^ ERROR cannot assign to `u.a` because it is borrowed (Ast)\n-                     //[mir]~| ERROR cannot assign to `u.0` because it is borrowed (Mir)\n+                     //[mir]~| ERROR cannot assign to `u.a` because it is borrowed (Mir)\n         }\n         // Mut borrow, other field\n         {"}]}