{"sha": "840eac2c05c31744f58e4a581ba838ac00a10cbc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0MGVhYzJjMDVjMzE3NDRmNThlNGE1ODFiYTgzOGFjMDBhMTBjYmM=", "commit": {"author": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2019-04-07T17:44:10Z"}, "committer": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2019-04-17T10:53:29Z"}, "message": "Use {get,match}_def_path from LateContext", "tree": {"sha": "a5ef92c0d7281d62adf2ac2d2e261b39e444cdcb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5ef92c0d7281d62adf2ac2d2e261b39e444cdcb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/840eac2c05c31744f58e4a581ba838ac00a10cbc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZxoS6lESXlRGMHWcaTCGhp1QZjcFAly3BakACgkQaTCGhp1Q\nZjfs7xAAqAYqcMTU0GXyccJiS/gDLtd0igiD5EphreYqs9Guzk58ywnlgTl5PJ2F\na0x5REe1VSZJIHO9PIGBkHfN/rQduw1k36+r9jgxfxgMc67nkwEVmzK7Q2xetwRX\nw86wCIde7UN6qbjXGt2JnBexkb+9+EEGrp9SWYSn97N4cf0pzDFp3bK7vyH6si8L\nBYnoQGVHi2377+UGyRuDeQyVjvZ4FWq8btk6ptmmmwv2P/XZ+bh4MF+POcDsxcF/\nz4z3ZhYvY4xrENhNZ7JUOxw0ao0CIcGXLxdyakm6frwE+ZnV4iSGztW6jF4gCzGV\nL/OPfMdMwXJXil80BdjAfJJ0woCEuOWvAFMyl5ElmWOD9EaRQv3j8Akeoj/Q7VP9\njoShfuN2s9A8oOROvy7E/undYxBj4LBWFq1ahNgAWZdbKkgTLtfonu/QKuO35HnC\njC+y7GMfWD7Eh8Lj4QYQBZUXrQKxK7+GryRG8yB+P8cJz1IGcrTRRMrZ/dSO66Nj\n++kcMv+BEMLgnB+09ue+AGMZfAXG4dOhxKq11liJryFR9cS6URgzk5+XyauH3Er4\nrdQcqHJFozesmiVZ5ZP/k1NxX4Pyh1GHnUtWROsqGbPZQDBO3E86SoJWdW1+iJEG\n48lZahUZfmz/4wuyIdRL7DJ8zhU67eP+xtbdcqTX7pkXMeEV4Jk=\n=2R7T\n-----END PGP SIGNATURE-----", "payload": "tree a5ef92c0d7281d62adf2ac2d2e261b39e444cdcb\nparent 2f100e04af6085a286caf6c4416733723bedac49\nauthor flip1995 <hello@philkrones.com> 1554659050 +0200\ncommitter flip1995 <hello@philkrones.com> 1555498409 +0200\n\nUse {get,match}_def_path from LateContext\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/840eac2c05c31744f58e4a581ba838ac00a10cbc", "html_url": "https://github.com/rust-lang/rust/commit/840eac2c05c31744f58e4a581ba838ac00a10cbc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/840eac2c05c31744f58e4a581ba838ac00a10cbc/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f100e04af6085a286caf6c4416733723bedac49", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f100e04af6085a286caf6c4416733723bedac49", "html_url": "https://github.com/rust-lang/rust/commit/2f100e04af6085a286caf6c4416733723bedac49"}], "stats": {"total": 250, "additions": 122, "deletions": 128}, "files": [{"sha": "d56e1e88fcef32c2e8cb99224bc665814c06cf81", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=840eac2c05c31744f58e4a581ba838ac00a10cbc", "patch": "@@ -2,7 +2,7 @@\n \n use crate::reexport::*;\n use crate::utils::{\n-    in_macro, last_line_of_span, match_def_path, paths, snippet_opt, span_lint, span_lint_and_sugg, span_lint_and_then,\n+    in_macro, last_line_of_span, paths, snippet_opt, span_lint, span_lint_and_sugg, span_lint_and_then,\n     without_block_comments,\n };\n use if_chain::if_chain;\n@@ -11,7 +11,7 @@ use rustc::lint::{\n     in_external_macro, CheckLintNameResult, EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintArray,\n     LintContext, LintPass,\n };\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use semver::Version;\n@@ -234,7 +234,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if is_relevant_item(cx.tcx, item) {\n+        if is_relevant_item(cx, item) {\n             check_attrs(cx, item.span, item.ident.name, &item.attrs)\n         }\n         match item.node {\n@@ -302,13 +302,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n-        if is_relevant_impl(cx.tcx, item) {\n+        if is_relevant_impl(cx, item) {\n             check_attrs(cx, item.span, item.ident.name, &item.attrs)\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n-        if is_relevant_trait(cx.tcx, item) {\n+        if is_relevant_trait(cx, item) {\n             check_attrs(cx, item.span, item.ident.name, &item.attrs)\n         }\n     }\n@@ -361,52 +361,52 @@ fn check_clippy_lint_names(cx: &LateContext<'_, '_>, items: &[NestedMetaItem]) {\n     }\n }\n \n-fn is_relevant_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &Item) -> bool {\n+fn is_relevant_item(cx: &LateContext<'_, '_>, item: &Item) -> bool {\n     if let ItemKind::Fn(_, _, _, eid) = item.node {\n-        is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.hir().body(eid).value)\n+        is_relevant_expr(cx, cx.tcx.body_tables(eid), &cx.tcx.hir().body(eid).value)\n     } else {\n         true\n     }\n }\n \n-fn is_relevant_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &ImplItem) -> bool {\n+fn is_relevant_impl(cx: &LateContext<'_, '_>, item: &ImplItem) -> bool {\n     match item.node {\n-        ImplItemKind::Method(_, eid) => is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.hir().body(eid).value),\n+        ImplItemKind::Method(_, eid) => is_relevant_expr(cx, cx.tcx.body_tables(eid), &cx.tcx.hir().body(eid).value),\n         _ => false,\n     }\n }\n \n-fn is_relevant_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &TraitItem) -> bool {\n+fn is_relevant_trait(cx: &LateContext<'_, '_>, item: &TraitItem) -> bool {\n     match item.node {\n         TraitItemKind::Method(_, TraitMethod::Required(_)) => true,\n         TraitItemKind::Method(_, TraitMethod::Provided(eid)) => {\n-            is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.hir().body(eid).value)\n+            is_relevant_expr(cx, cx.tcx.body_tables(eid), &cx.tcx.hir().body(eid).value)\n         },\n         _ => false,\n     }\n }\n \n-fn is_relevant_block<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, tables: &ty::TypeckTables<'_>, block: &Block) -> bool {\n+fn is_relevant_block(cx: &LateContext<'_, '_>, tables: &ty::TypeckTables<'_>, block: &Block) -> bool {\n     if let Some(stmt) = block.stmts.first() {\n         match &stmt.node {\n             StmtKind::Local(_) => true,\n-            StmtKind::Expr(expr) | StmtKind::Semi(expr) => is_relevant_expr(tcx, tables, expr),\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => is_relevant_expr(cx, tables, expr),\n             _ => false,\n         }\n     } else {\n-        block.expr.as_ref().map_or(false, |e| is_relevant_expr(tcx, tables, e))\n+        block.expr.as_ref().map_or(false, |e| is_relevant_expr(cx, tables, e))\n     }\n }\n \n-fn is_relevant_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, tables: &ty::TypeckTables<'_>, expr: &Expr) -> bool {\n+fn is_relevant_expr(cx: &LateContext<'_, '_>, tables: &ty::TypeckTables<'_>, expr: &Expr) -> bool {\n     match &expr.node {\n-        ExprKind::Block(block, _) => is_relevant_block(tcx, tables, block),\n-        ExprKind::Ret(Some(e)) => is_relevant_expr(tcx, tables, e),\n+        ExprKind::Block(block, _) => is_relevant_block(cx, tables, block),\n+        ExprKind::Ret(Some(e)) => is_relevant_expr(cx, tables, e),\n         ExprKind::Ret(None) | ExprKind::Break(_, None) => false,\n         ExprKind::Call(path_expr, _) => {\n             if let ExprKind::Path(qpath) = &path_expr.node {\n                 if let Some(fun_id) = tables.qpath_def(qpath, path_expr.hir_id).opt_def_id() {\n-                    !match_def_path(tcx, fun_id, &paths::BEGIN_PANIC)\n+                    !cx.match_def_path(fun_id, &paths::BEGIN_PANIC)\n                 } else {\n                     true\n                 }"}, {"sha": "3aa826d8bed64aadd1d2f86ba8fd52409bfd7942", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=840eac2c05c31744f58e4a581ba838ac00a10cbc", "patch": "@@ -1,6 +1,6 @@\n #![allow(clippy::float_cmp)]\n \n-use crate::utils::{clip, get_def_path, sext, unsext};\n+use crate::utils::{clip, sext, unsext};\n use if_chain::if_chain;\n use rustc::hir::def::Def;\n use rustc::hir::*;\n@@ -180,7 +180,7 @@ pub fn constant<'c, 'cc>(\n     e: &Expr,\n ) -> Option<(Constant, bool)> {\n     let mut cx = ConstEvalLateContext {\n-        tcx: lcx.tcx,\n+        lcx,\n         tables,\n         param_env: lcx.param_env,\n         needed_resolution: false,\n@@ -199,11 +199,11 @@ pub fn constant_simple<'c, 'cc>(\n \n /// Creates a `ConstEvalLateContext` from the given `LateContext` and `TypeckTables`.\n pub fn constant_context<'c, 'cc>(\n-    lcx: &LateContext<'c, 'cc>,\n+    lcx: &'c LateContext<'c, 'cc>,\n     tables: &'c ty::TypeckTables<'cc>,\n ) -> ConstEvalLateContext<'c, 'cc> {\n     ConstEvalLateContext {\n-        tcx: lcx.tcx,\n+        lcx,\n         tables,\n         param_env: lcx.param_env,\n         needed_resolution: false,\n@@ -212,7 +212,7 @@ pub fn constant_context<'c, 'cc>(\n }\n \n pub struct ConstEvalLateContext<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    lcx: &'a LateContext<'a, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     needed_resolution: bool,\n@@ -231,7 +231,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             ExprKind::Tup(ref tup) => self.multi(tup).map(Constant::Tuple),\n             ExprKind::Repeat(ref value, _) => {\n                 let n = match self.tables.expr_ty(e).sty {\n-                    ty::Array(_, n) => n.assert_usize(self.tcx).expect(\"array length\"),\n+                    ty::Array(_, n) => n.assert_usize(self.lcx.tcx).expect(\"array length\"),\n                     _ => span_bug!(e.span, \"typeck error\"),\n                 };\n                 self.expr(value).map(|v| Constant::Repeat(Box::new(v), n))\n@@ -249,7 +249,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n                     if let ExprKind::Path(qpath) = &callee.node;\n                     let def = self.tables.qpath_def(qpath, callee.hir_id);\n                     if let Some(def_id) = def.opt_def_id();\n-                    let def_path = get_def_path(self.tcx, def_id)\n+                    let def_path = self.lcx.get_def_path(def_id)\n                         .iter()\n                         .map(LocalInternedString::get)\n                         .collect::<Vec<_>>();\n@@ -283,8 +283,8 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             Int(value) => {\n                 let value = !value;\n                 match ty.sty {\n-                    ty::Int(ity) => Some(Int(unsext(self.tcx, value as i128, ity))),\n-                    ty::Uint(ity) => Some(Int(clip(self.tcx, value, ity))),\n+                    ty::Int(ity) => Some(Int(unsext(self.lcx.tcx, value as i128, ity))),\n+                    ty::Uint(ity) => Some(Int(clip(self.lcx.tcx, value, ity))),\n                     _ => None,\n                 }\n             },\n@@ -301,10 +301,10 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n                     _ => return None,\n                 };\n                 // sign extend\n-                let value = sext(self.tcx, value, ity);\n+                let value = sext(self.lcx.tcx, value, ity);\n                 let value = value.checked_neg()?;\n                 // clear unused bits\n-                Some(Int(unsext(self.tcx, value, ity)))\n+                Some(Int(unsext(self.lcx.tcx, value, ity)))\n             },\n             F32(f) => Some(F32(-f)),\n             F64(f) => Some(F64(-f)),\n@@ -329,16 +329,16 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n                 let substs = if self.substs.is_empty() {\n                     substs\n                 } else {\n-                    substs.subst(self.tcx, self.substs)\n+                    substs.subst(self.lcx.tcx, self.substs)\n                 };\n-                let instance = Instance::resolve(self.tcx, self.param_env, def_id, substs)?;\n+                let instance = Instance::resolve(self.lcx.tcx, self.param_env, def_id, substs)?;\n                 let gid = GlobalId {\n                     instance,\n                     promoted: None,\n                 };\n \n-                let result = self.tcx.const_eval(self.param_env.and(gid)).ok()?;\n-                let ret = miri_to_const(self.tcx, &result);\n+                let result = self.lcx.tcx.const_eval(self.param_env.and(gid)).ok()?;\n+                let ret = miri_to_const(self.lcx.tcx, &result);\n                 if ret.is_some() {\n                     self.needed_resolution = true;\n                 }\n@@ -376,9 +376,9 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n         match (l, r) {\n             (Constant::Int(l), Some(Constant::Int(r))) => match self.tables.expr_ty(left).sty {\n                 ty::Int(ity) => {\n-                    let l = sext(self.tcx, l, ity);\n-                    let r = sext(self.tcx, r, ity);\n-                    let zext = |n: i128| Constant::Int(unsext(self.tcx, n, ity));\n+                    let l = sext(self.lcx.tcx, l, ity);\n+                    let r = sext(self.lcx.tcx, r, ity);\n+                    let zext = |n: i128| Constant::Int(unsext(self.lcx.tcx, n, ity));\n                     match op.node {\n                         BinOpKind::Add => l.checked_add(r).map(zext),\n                         BinOpKind::Sub => l.checked_sub(r).map(zext),"}, {"sha": "2f80e37ab29ff9f1f433b240465deb5f7cfc4c3d", "filename": "clippy_lints/src/default_trait_access.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=840eac2c05c31744f58e4a581ba838ac00a10cbc", "patch": "@@ -5,7 +5,7 @@ use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n \n-use crate::utils::{any_parent_is_automatically_derived, match_def_path, paths, span_lint_and_sugg};\n+use crate::utils::{any_parent_is_automatically_derived, paths, span_lint_and_sugg};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for literal calls to `Default::default()`.\n@@ -48,7 +48,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DefaultTraitAccess {\n             if !any_parent_is_automatically_derived(cx.tcx, expr.hir_id);\n             if let ExprKind::Path(ref qpath) = path.node;\n             if let Some(def_id) = cx.tables.qpath_def(qpath, path.hir_id).opt_def_id();\n-            if match_def_path(cx.tcx, def_id, &paths::DEFAULT_TRAIT_METHOD);\n+            if cx.match_def_path(def_id, &paths::DEFAULT_TRAIT_METHOD);\n             then {\n                 match qpath {\n                     QPath::Resolved(..) => {"}, {"sha": "37a4f5d7c5faa21652c3e656e47f5657692a0291", "filename": "clippy_lints/src/drop_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fdrop_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fdrop_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_bounds.rs?ref=840eac2c05c31744f58e4a581ba838ac00a10cbc", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{match_def_path, paths, span_lint};\n+use crate::utils::{paths, span_lint};\n use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::lint::{LateLintPass, LintArray, LintPass};\n@@ -66,7 +66,7 @@ fn lint_bound<'a, 'tcx>(cx: &rustc::lint::LateContext<'a, 'tcx>, bound: &'tcx Ge\n     if_chain! {\n         if let GenericBound::Trait(t, _) = bound;\n         if let Some(def_id) = t.trait_ref.path.def.opt_def_id();\n-        if match_def_path(cx.tcx, def_id, &paths::DROP_TRAIT);\n+        if cx.match_def_path(def_id, &paths::DROP_TRAIT);\n         then {\n             span_lint(\n                 cx,"}, {"sha": "240f4425a6b058fb959b9ea4154a4653af15808f", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=840eac2c05c31744f58e4a581ba838ac00a10cbc", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{is_copy, match_def_path, paths, span_note_and_lint};\n+use crate::utils::{is_copy, paths, span_note_and_lint};\n use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -132,10 +132,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 let arg_ty = cx.tables.expr_ty(arg);\n \n                 if let ty::Ref(..) = arg_ty.sty {\n-                    if match_def_path(cx.tcx, def_id, &paths::DROP) {\n+                    if cx.match_def_path(def_id, &paths::DROP) {\n                         lint = DROP_REF;\n                         msg = DROP_REF_SUMMARY.to_string();\n-                    } else if match_def_path(cx.tcx, def_id, &paths::MEM_FORGET) {\n+                    } else if cx.match_def_path(def_id, &paths::MEM_FORGET) {\n                         lint = FORGET_REF;\n                         msg = FORGET_REF_SUMMARY.to_string();\n                     } else {\n@@ -148,10 +148,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                                        arg.span,\n                                        &format!(\"argument has type {}\", arg_ty));\n                 } else if is_copy(cx, arg_ty) {\n-                    if match_def_path(cx.tcx, def_id, &paths::DROP) {\n+                    if cx.match_def_path(def_id, &paths::DROP) {\n                         lint = DROP_COPY;\n                         msg = DROP_COPY_SUMMARY.to_string();\n-                    } else if match_def_path(cx.tcx, def_id, &paths::MEM_FORGET) {\n+                    } else if cx.match_def_path(def_id, &paths::MEM_FORGET) {\n                         lint = FORGET_COPY;\n                         msg = FORGET_COPY_SUMMARY.to_string();\n                     } else {"}, {"sha": "223c0022a66961b2b79d24c4f40968aeacf94c8a", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=840eac2c05c31744f58e4a581ba838ac00a10cbc", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{is_expn_of, match_def_path, resolve_node, span_lint, span_lint_and_sugg};\n+use crate::utils::{is_expn_of, resolve_node, span_lint, span_lint_and_sugg};\n use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -54,9 +54,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             if let ExprKind::Path(ref qpath) = dest_fun.node;\n             if let Some(dest_fun_id) =\n                 resolve_node(cx, qpath, dest_fun.hir_id).opt_def_id();\n-            if let Some(dest_name) = if match_def_path(cx.tcx, dest_fun_id, &[\"std\", \"io\", \"stdio\", \"stdout\"]) {\n+            if let Some(dest_name) = if cx.match_def_path(dest_fun_id, &[\"std\", \"io\", \"stdio\", \"stdout\"]) {\n                 Some(\"stdout\")\n-            } else if match_def_path(cx.tcx, dest_fun_id, &[\"std\", \"io\", \"stdio\", \"stderr\"]) {\n+            } else if cx.match_def_path(dest_fun_id, &[\"std\", \"io\", \"stdio\", \"stderr\"]) {\n                 Some(\"stderr\")\n             } else {\n                 None"}, {"sha": "05ec59fabe41a74cc4a3fed21a76e6a5a5755ca3", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=840eac2c05c31744f58e4a581ba838ac00a10cbc", "patch": "@@ -1,5 +1,5 @@\n use crate::utils::paths::{BEGIN_PANIC, BEGIN_PANIC_FMT, FROM_TRAIT, OPTION, RESULT};\n-use crate::utils::{is_expn_of, match_def_path, method_chain_args, span_lint_and_then, walk_ptrs_ty};\n+use crate::utils::{is_expn_of, method_chain_args, span_lint_and_then, walk_ptrs_ty};\n use if_chain::if_chain;\n use rustc::hir;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -47,7 +47,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FallibleImplFrom {\n         if_chain! {\n             if let hir::ItemKind::Impl(.., ref impl_items) = item.node;\n             if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(impl_def_id);\n-            if match_def_path(cx.tcx, impl_trait_ref.def_id, &FROM_TRAIT);\n+            if cx.match_def_path(impl_trait_ref.def_id, &FROM_TRAIT);\n             then {\n                 lint_impl_body(cx, item.span, impl_items);\n             }\n@@ -60,7 +60,7 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n     use rustc::hir::*;\n \n     struct FindPanicUnwrap<'a, 'tcx: 'a> {\n-        tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+        lcx: &'a LateContext<'a, 'tcx>,\n         tables: &'tcx ty::TypeckTables<'tcx>,\n         result: Vec<Span>,\n     }\n@@ -72,8 +72,8 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n                 if let ExprKind::Call(ref func_expr, _) = expr.node;\n                 if let ExprKind::Path(QPath::Resolved(_, ref path)) = func_expr.node;\n                 if let Some(path_def_id) = path.def.opt_def_id();\n-                if match_def_path(self.tcx, path_def_id, &BEGIN_PANIC) ||\n-                    match_def_path(self.tcx, path_def_id, &BEGIN_PANIC_FMT);\n+                if self.lcx.match_def_path(path_def_id, &BEGIN_PANIC) ||\n+                    self.lcx.match_def_path(path_def_id, &BEGIN_PANIC_FMT);\n                 if is_expn_of(expr.span, \"unreachable\").is_none();\n                 then {\n                     self.result.push(expr.span);\n@@ -83,7 +83,7 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n             // check for `unwrap`\n             if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n                 let reciever_ty = walk_ptrs_ty(self.tables.expr_ty(&arglists[0][0]));\n-                if match_type(self.tcx, reciever_ty, &OPTION) || match_type(self.tcx, reciever_ty, &RESULT) {\n+                if match_type(self.lcx, reciever_ty, &OPTION) || match_type(self.lcx, reciever_ty, &RESULT) {\n                     self.result.push(expr.span);\n                 }\n             }\n@@ -107,7 +107,7 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n                 let body = cx.tcx.hir().body(body_id);\n                 let impl_item_def_id = cx.tcx.hir().local_def_id_from_hir_id(impl_item.id.hir_id);\n                 let mut fpu = FindPanicUnwrap {\n-                    tcx: cx.tcx,\n+                    lcx: cx,\n                     tables: cx.tcx.typeck_tables_of(impl_item_def_id),\n                     result: Vec::new(),\n                 };\n@@ -132,9 +132,9 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n     }\n }\n \n-fn match_type<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'_>, path: &[&str]) -> bool {\n+fn match_type(cx: &LateContext<'_, '_>, ty: Ty<'_>, path: &[&str]) -> bool {\n     match ty.sty {\n-        ty::Adt(adt, _) => match_def_path(tcx, adt.did, path),\n+        ty::Adt(adt, _) => cx.match_def_path(adt.did, path),\n         _ => false,\n     }\n }"}, {"sha": "2a88c28536fee21ee99d942590d4a4a6464184b1", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=840eac2c05c31744f58e4a581ba838ac00a10cbc", "patch": "@@ -1,7 +1,6 @@\n use crate::utils::paths;\n use crate::utils::{\n-    in_macro, is_expn_of, last_path_segment, match_def_path, match_type, resolve_node, snippet, span_lint_and_then,\n-    walk_ptrs_ty,\n+    in_macro, is_expn_of, last_path_segment, match_type, resolve_node, snippet, span_lint_and_then, walk_ptrs_ty,\n };\n use if_chain::if_chain;\n use rustc::hir::*;\n@@ -59,9 +58,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     if_chain! {\n                         if let ExprKind::Path(ref qpath) = fun.node;\n                         if let Some(fun_def_id) = resolve_node(cx, qpath, fun.hir_id).opt_def_id();\n-                        let new_v1 = match_def_path(cx.tcx, fun_def_id, &paths::FMT_ARGUMENTS_NEWV1);\n-                        let new_v1_fmt = match_def_path(\n-                            cx.tcx,\n+                        let new_v1 = cx.match_def_path(fun_def_id, &paths::FMT_ARGUMENTS_NEWV1);\n+                        let new_v1_fmt = cx.match_def_path(\n                             fun_def_id,\n                             &paths::FMT_ARGUMENTS_NEWV1FORMATTED\n                         );\n@@ -162,7 +160,7 @@ fn get_single_string_arg<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option\n         if args.len() == 2;\n         if let ExprKind::Path(ref qpath) = args[1].node;\n         if let Some(fun_def_id) = resolve_node(cx, qpath, args[1].hir_id).opt_def_id();\n-        if match_def_path(cx.tcx, fun_def_id, &paths::DISPLAY_FMT_METHOD);\n+        if cx.match_def_path(fun_def_id, &paths::DISPLAY_FMT_METHOD);\n         then {\n             let ty = walk_ptrs_ty(cx.tables.pat_ty(&pat[0]));\n             if ty.sty == ty::Str || match_type(cx, ty, &paths::STRING) {"}, {"sha": "5fa685682261c47466e90b536fc0a263c688b609", "filename": "clippy_lints/src/identity_conversion.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_conversion.rs?ref=840eac2c05c31744f58e4a581ba838ac00a10cbc", "patch": "@@ -1,6 +1,4 @@\n-use crate::utils::{\n-    in_macro, match_def_path, match_trait_method, same_tys, snippet, snippet_with_macro_callsite, span_lint_and_then,\n-};\n+use crate::utils::{in_macro, match_trait_method, same_tys, snippet, snippet_with_macro_callsite, span_lint_and_then};\n use crate::utils::{paths, resolve_node};\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -99,7 +97,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n             ExprKind::Call(ref path, ref args) => {\n                 if let ExprKind::Path(ref qpath) = path.node {\n                     if let Some(def_id) = resolve_node(cx, qpath, path.hir_id).opt_def_id() {\n-                        if match_def_path(cx.tcx, def_id, &paths::FROM_FROM[..]) {\n+                        if cx.match_def_path(def_id, &paths::FROM_FROM[..]) {\n                             let a = cx.tables.expr_ty(e);\n                             let b = cx.tables.expr_ty(&args[0]);\n                             if same_tys(cx, a, b) {"}, {"sha": "2e5ebeda24abed651933a53b5e33a85d52207450", "filename": "clippy_lints/src/invalid_ref.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Finvalid_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Finvalid_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finvalid_ref.rs?ref=840eac2c05c31744f58e4a581ba838ac00a10cbc", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{match_def_path, paths, span_help_and_lint};\n+use crate::utils::{paths, span_help_and_lint};\n use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -47,12 +47,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidRef {\n             if let ty::Ref(..) = cx.tables.expr_ty(expr).sty;\n             if let Some(def_id) = cx.tables.qpath_def(qpath, path.hir_id).opt_def_id();\n             then {\n-                let msg = if match_def_path(cx.tcx, def_id, &paths::MEM_ZEROED) |\n-                             match_def_path(cx.tcx, def_id, &paths::INIT)\n+                let msg = if cx.match_def_path(def_id, &paths::MEM_ZEROED) |\n+                             cx.match_def_path(def_id, &paths::INIT)\n                 {\n                     ZERO_REF_SUMMARY\n-                } else if match_def_path(cx.tcx, def_id, &paths::MEM_UNINIT) |\n-                          match_def_path(cx.tcx, def_id, &paths::UNINIT)\n+                } else if cx.match_def_path(def_id, &paths::MEM_UNINIT) |\n+                          cx.match_def_path(def_id, &paths::UNINIT)\n                 {\n                     UNINIT_REF_SUMMARY\n                 } else {"}, {"sha": "14266da1a1082c74107b27f4cc6ade2942fe14a7", "filename": "clippy_lints/src/mem_discriminant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fmem_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fmem_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_discriminant.rs?ref=840eac2c05c31744f58e4a581ba838ac00a10cbc", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{match_def_path, paths, snippet, span_lint_and_then, walk_ptrs_ty_depth};\n+use crate::utils::{paths, snippet, span_lint_and_then, walk_ptrs_ty_depth};\n use if_chain::if_chain;\n use rustc::hir::{Expr, ExprKind};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -46,7 +46,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemDiscriminant {\n             // is `mem::discriminant`\n             if let ExprKind::Path(ref func_qpath) = func.node;\n             if let Some(def_id) = cx.tables.qpath_def(func_qpath, func.hir_id).opt_def_id();\n-            if match_def_path(cx.tcx, def_id, &paths::MEM_DISCRIMINANT);\n+            if cx.match_def_path(def_id, &paths::MEM_DISCRIMINANT);\n             // type is non-enum\n             let ty_param = cx.tables.node_substs(func.hir_id).type_at(0);\n             if !ty_param.is_enum();"}, {"sha": "6f94580a0649cf9958e61ff59cdc46daf407a12e", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=840eac2c05c31744f58e4a581ba838ac00a10cbc", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{match_def_path, paths, span_lint};\n+use crate::utils::{paths, span_lint};\n use rustc::hir::{Expr, ExprKind};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n@@ -38,7 +38,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemForget {\n         if let ExprKind::Call(ref path_expr, ref args) = e.node {\n             if let ExprKind::Path(ref qpath) = path_expr.node {\n                 if let Some(def_id) = cx.tables.qpath_def(qpath, path_expr.hir_id).opt_def_id() {\n-                    if match_def_path(cx.tcx, def_id, &paths::MEM_FORGET) {\n+                    if cx.match_def_path(def_id, &paths::MEM_FORGET) {\n                         let forgot_ty = cx.tables.expr_ty(&args[0]);\n \n                         if forgot_ty.ty_adt_def().map_or(false, |def| def.has_dtor(cx.tcx)) {"}, {"sha": "855de165540c496e3475998059bff0e1d3855034", "filename": "clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_replace.rs?ref=840eac2c05c31744f58e4a581ba838ac00a10cbc", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{match_def_path, match_qpath, paths, snippet_with_applicability, span_lint_and_sugg};\n+use crate::utils::{match_qpath, paths, snippet_with_applicability, span_lint_and_sugg};\n use if_chain::if_chain;\n use rustc::hir::{Expr, ExprKind, MutMutable, QPath};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -52,7 +52,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemReplace {\n             if func_args.len() == 2;\n             if let ExprKind::Path(ref func_qpath) = func.node;\n             if let Some(def_id) = cx.tables.qpath_def(func_qpath, func.hir_id).opt_def_id();\n-            if match_def_path(cx.tcx, def_id, &paths::MEM_REPLACE);\n+            if cx.match_def_path(def_id, &paths::MEM_REPLACE);\n \n             // Check that second argument is `Option::None`\n             if let ExprKind::Path(ref replacement_qpath) = func_args[1].node;"}, {"sha": "28b779416864d83005b956301942fc7f85fd1ddc", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=840eac2c05c31744f58e4a581ba838ac00a10cbc", "patch": "@@ -21,10 +21,10 @@ use crate::utils::paths;\n use crate::utils::sugg;\n use crate::utils::{\n     get_arg_name, get_parent_expr, get_trait_def_id, has_iter_method, implements_trait, in_macro, is_copy, is_expn_of,\n-    is_self, is_self_ty, iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath,\n-    match_trait_method, match_type, match_var, method_calls, method_chain_args, remove_blocks, return_ty, same_tys,\n-    single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint,\n-    span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq,\n+    is_self, is_self_ty, iter_input_pats, last_path_segment, match_path, match_qpath, match_trait_method, match_type,\n+    match_var, method_calls, method_chain_args, remove_blocks, return_ty, same_tys, single_segment_path, snippet,\n+    snippet_with_applicability, snippet_with_macro_callsite, span_lint, span_lint_and_sugg, span_lint_and_then,\n+    span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq,\n };\n \n #[derive(Clone)]\n@@ -1464,7 +1464,7 @@ fn lint_cstring_as_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr, new: &hir::Ex\n         if args.len() == 1;\n         if let hir::ExprKind::Path(ref path) = fun.node;\n         if let Def::Method(did) = cx.tables.qpath_def(path, fun.hir_id);\n-        if match_def_path(cx.tcx, did, &paths::CSTRING_NEW);\n+        if cx.match_def_path(did, &paths::CSTRING_NEW);\n         then {\n             span_lint_and_then(\n                 cx,"}, {"sha": "92cc6f2a3028a16879b61bb618f4019733463cfb", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=840eac2c05c31744f58e4a581ba838ac00a10cbc", "patch": "@@ -1,5 +1,5 @@\n use crate::consts::{constant_simple, Constant};\n-use crate::utils::{match_def_path, paths, span_lint};\n+use crate::utils::{paths, span_lint};\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n@@ -73,9 +73,9 @@ fn min_max<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<(MinMax, Cons\n     if let ExprKind::Call(ref path, ref args) = expr.node {\n         if let ExprKind::Path(ref qpath) = path.node {\n             cx.tables.qpath_def(qpath, path.hir_id).opt_def_id().and_then(|def_id| {\n-                if match_def_path(cx.tcx, def_id, &paths::CMP_MIN) {\n+                if cx.match_def_path(def_id, &paths::CMP_MIN) {\n                     fetch_const(cx, args, MinMax::Min)\n-                } else if match_def_path(cx.tcx, def_id, &paths::CMP_MAX) {\n+                } else if cx.match_def_path(def_id, &paths::CMP_MAX) {\n                     fetch_const(cx, args, MinMax::Max)\n                 } else {\n                     None"}, {"sha": "af0a9214342e76adcced14ebd02da7c742a01725", "filename": "clippy_lints/src/panic_unimplemented.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs?ref=840eac2c05c31744f58e4a581ba838ac00a10cbc", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{is_direct_expn_of, is_expn_of, match_def_path, paths, resolve_node, span_lint};\n+use crate::utils::{is_direct_expn_of, is_expn_of, paths, resolve_node, span_lint};\n use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -62,7 +62,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             if let ExprKind::Call(ref fun, ref params) = ex.node;\n             if let ExprKind::Path(ref qpath) = fun.node;\n             if let Some(fun_def_id) = resolve_node(cx, qpath, fun.hir_id).opt_def_id();\n-            if match_def_path(cx.tcx, fun_def_id, &paths::BEGIN_PANIC);\n+            if cx.match_def_path(fun_def_id, &paths::BEGIN_PANIC);\n             if params.len() == 2;\n             then {\n                 if is_expn_of(expr.span, \"unimplemented\").is_some() {"}, {"sha": "b2e8315716abcd92a6dabb2cf0950d61b16a572f", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=840eac2c05c31744f58e4a581ba838ac00a10cbc", "patch": "@@ -8,7 +8,7 @@ use syntax::ptr::P;\n \n use crate::utils::paths::*;\n use crate::utils::sugg::Sugg;\n-use crate::utils::{match_def_path, match_type, span_lint_and_then, SpanlessEq};\n+use crate::utils::{match_type, span_lint_and_then, SpanlessEq};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for expressions that could be replaced by the question mark operator.\n@@ -129,7 +129,7 @@ impl Pass {\n             ExprKind::Ret(Some(ref expr)) => Self::expression_returns_none(cx, expr),\n             ExprKind::Path(ref qp) => {\n                 if let Def::Ctor(def_id, def::CtorOf::Variant, _) = cx.tables.qpath_def(qp, expression.hir_id) {\n-                    return match_def_path(cx.tcx, def_id, &OPTION_NONE);\n+                    return cx.match_def_path(def_id, &OPTION_NONE);\n                 }\n \n                 false"}, {"sha": "9df7009c0743ce8c8d9276c0550e8466ba0a7417", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=840eac2c05c31744f58e4a581ba838ac00a10cbc", "patch": "@@ -1,5 +1,5 @@\n use crate::utils::{\n-    has_drop, in_macro, is_copy, match_def_path, match_type, paths, snippet_opt, span_lint_hir, span_lint_hir_and_then,\n+    has_drop, in_macro, is_copy, match_type, paths, snippet_opt, span_lint_hir, span_lint_hir_and_then,\n     walk_ptrs_ty_depth,\n };\n use if_chain::if_chain;\n@@ -104,14 +104,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantClone {\n \n             let (fn_def_id, arg, arg_ty, _) = unwrap_or_continue!(is_call_with_ref_arg(cx, mir, &terminator.kind));\n \n-            let from_borrow = match_def_path(cx.tcx, fn_def_id, &paths::CLONE_TRAIT_METHOD)\n-                || match_def_path(cx.tcx, fn_def_id, &paths::TO_OWNED_METHOD)\n-                || (match_def_path(cx.tcx, fn_def_id, &paths::TO_STRING_METHOD)\n-                    && match_type(cx, arg_ty, &paths::STRING));\n+            let from_borrow = cx.match_def_path(fn_def_id, &paths::CLONE_TRAIT_METHOD)\n+                || cx.match_def_path(fn_def_id, &paths::TO_OWNED_METHOD)\n+                || (cx.match_def_path(fn_def_id, &paths::TO_STRING_METHOD) && match_type(cx, arg_ty, &paths::STRING));\n \n             let from_deref = !from_borrow\n-                && (match_def_path(cx.tcx, fn_def_id, &paths::PATH_TO_PATH_BUF)\n-                    || match_def_path(cx.tcx, fn_def_id, &paths::OS_STR_TO_OS_STRING));\n+                && (cx.match_def_path(fn_def_id, &paths::PATH_TO_PATH_BUF)\n+                    || cx.match_def_path(fn_def_id, &paths::OS_STR_TO_OS_STRING));\n \n             if !from_borrow && !from_deref {\n                 continue;\n@@ -144,7 +143,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantClone {\n                     if let Some((pred_fn_def_id, pred_arg, pred_arg_ty, Some(res))) =\n                         is_call_with_ref_arg(cx, mir, &pred_terminator.kind);\n                     if *res == mir::Place::Base(mir::PlaceBase::Local(cloned));\n-                    if match_def_path(cx.tcx, pred_fn_def_id, &paths::DEREF_TRAIT_METHOD);\n+                    if cx.match_def_path(pred_fn_def_id, &paths::DEREF_TRAIT_METHOD);\n                     if match_type(cx, pred_arg_ty, &paths::PATH_BUF)\n                         || match_type(cx, pred_arg_ty, &paths::OS_STRING);\n                     then {"}, {"sha": "4d1dbc75c94923d14f2d13cd5bb7846c740f3241", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=840eac2c05c31744f58e4a581ba838ac00a10cbc", "patch": "@@ -1,5 +1,5 @@\n use crate::consts::{constant, Constant};\n-use crate::utils::{is_expn_of, match_def_path, match_type, paths, span_help_and_lint, span_lint};\n+use crate::utils::{is_expn_of, match_type, paths, span_help_and_lint, span_lint};\n use if_chain::if_chain;\n use regex_syntax;\n use rustc::hir::*;\n@@ -120,15 +120,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             if args.len() == 1;\n             if let Some(def_id) = cx.tables.qpath_def(qpath, fun.hir_id).opt_def_id();\n             then {\n-                if match_def_path(cx.tcx, def_id, &paths::REGEX_NEW) ||\n-                   match_def_path(cx.tcx, def_id, &paths::REGEX_BUILDER_NEW) {\n+                if cx.match_def_path(def_id, &paths::REGEX_NEW) ||\n+                   cx.match_def_path(def_id, &paths::REGEX_BUILDER_NEW) {\n                     check_regex(cx, &args[0], true);\n-                } else if match_def_path(cx.tcx, def_id, &paths::REGEX_BYTES_NEW) ||\n-                   match_def_path(cx.tcx, def_id, &paths::REGEX_BYTES_BUILDER_NEW) {\n+                } else if cx.match_def_path(def_id, &paths::REGEX_BYTES_NEW) ||\n+                   cx.match_def_path(def_id, &paths::REGEX_BYTES_BUILDER_NEW) {\n                     check_regex(cx, &args[0], false);\n-                } else if match_def_path(cx.tcx, def_id, &paths::REGEX_SET_NEW) {\n+                } else if cx.match_def_path(def_id, &paths::REGEX_SET_NEW) {\n                     check_set(cx, &args[0], true);\n-                } else if match_def_path(cx.tcx, def_id, &paths::REGEX_BYTES_SET_NEW) {\n+                } else if cx.match_def_path(def_id, &paths::REGEX_BYTES_SET_NEW) {\n                     check_set(cx, &args[0], false);\n                 }\n             }"}, {"sha": "cd7dd8c49070f510c2dbb157374fba7125a42d82", "filename": "clippy_lints/src/replace_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Freplace_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Freplace_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freplace_consts.rs?ref=840eac2c05c31744f58e4a581ba838ac00a10cbc", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{match_def_path, span_lint_and_sugg};\n+use crate::utils::span_lint_and_sugg;\n use if_chain::if_chain;\n use rustc::hir;\n use rustc::hir::def::Def;\n@@ -48,7 +48,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ReplaceConsts {\n             if let Def::Const(def_id) = cx.tables.qpath_def(qp, expr.hir_id);\n             then {\n                 for &(const_path, repl_snip) in REPLACEMENTS {\n-                    if match_def_path(cx.tcx, def_id, const_path) {\n+                    if cx.match_def_path(def_id, const_path) {\n                         span_lint_and_sugg(\n                             cx,\n                             REPLACE_CONSTS,"}, {"sha": "f07fe97020bd747070c44e86fe0e6a5148418d3e", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=840eac2c05c31744f58e4a581ba838ac00a10cbc", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{last_path_segment, match_def_path, paths, snippet, span_lint, span_lint_and_then, sugg};\n+use crate::utils::{last_path_segment, paths, snippet, span_lint, span_lint_and_then, sugg};\n use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -231,7 +231,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n         if let ExprKind::Call(ref path_expr, ref args) = e.node {\n             if let ExprKind::Path(ref qpath) = path_expr.node {\n                 if let Some(def_id) = cx.tables.qpath_def(qpath, path_expr.hir_id).opt_def_id() {\n-                    if match_def_path(cx.tcx, def_id, &paths::TRANSMUTE) {\n+                    if cx.match_def_path(def_id, &paths::TRANSMUTE) {\n                         let from_ty = cx.tables.expr_ty(&args[0]);\n                         let to_ty = cx.tables.expr_ty(e);\n "}, {"sha": "744ee0f6c20251cf2b5435e4aa6bbce56dfe6a1a", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=840eac2c05c31744f58e4a581ba838ac00a10cbc", "patch": "@@ -10,7 +10,6 @@ use rustc::hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisito\n use rustc::hir::*;\n use rustc::lint::{in_external_macro, LateContext, LateLintPass, LintArray, LintContext, LintPass};\n use rustc::ty::layout::LayoutOf;\n-use rustc::ty::print::Printer;\n use rustc::ty::{self, InferTy, Ty, TyCtxt, TypeckTables};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n@@ -24,8 +23,8 @@ use crate::consts::{constant, Constant};\n use crate::utils::paths;\n use crate::utils::{\n     clip, comparisons, differing_macro_contexts, higher, in_constant, in_macro, int_bits, last_path_segment,\n-    match_def_path, match_path, multispan_sugg, same_tys, sext, snippet, snippet_opt, snippet_with_applicability,\n-    span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then, unsext, AbsolutePathPrinter,\n+    match_path, multispan_sugg, same_tys, sext, snippet, snippet_opt, snippet_with_applicability, span_help_and_lint,\n+    span_lint, span_lint_and_sugg, span_lint_and_then, unsext,\n };\n \n /// Handles all the linting of funky types\n@@ -229,7 +228,7 @@ fn match_type_parameter(cx: &LateContext<'_, '_>, qpath: &QPath, path: &[&str])\n         });\n         if let TyKind::Path(ref qpath) = ty.node;\n         if let Some(did) = cx.tables.qpath_def(qpath, ty.hir_id).opt_def_id();\n-        if match_def_path(cx.tcx, did, path);\n+        if cx.match_def_path(did, path);\n         then {\n             return true;\n         }\n@@ -263,7 +262,7 @@ fn check_ty(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty, is_local: bool) {\n                         );\n                         return; // don't recurse into the type\n                     }\n-                } else if match_def_path(cx.tcx, def_id, &paths::VEC) {\n+                } else if cx.match_def_path(def_id, &paths::VEC) {\n                     if_chain! {\n                         // Get the _ part of Vec<_>\n                         if let Some(ref last) = last_path_segment(qpath).args;\n@@ -298,7 +297,7 @@ fn check_ty(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty, is_local: bool) {\n                             }\n                         }\n                     }\n-                } else if match_def_path(cx.tcx, def_id, &paths::OPTION) {\n+                } else if cx.match_def_path(def_id, &paths::OPTION) {\n                     if match_type_parameter(cx, qpath, &paths::OPTION) {\n                         span_lint(\n                             cx,\n@@ -309,7 +308,7 @@ fn check_ty(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty, is_local: bool) {\n                         );\n                         return; // don't recurse into the type\n                     }\n-                } else if match_def_path(cx.tcx, def_id, &paths::LINKED_LIST) {\n+                } else if cx.match_def_path(def_id, &paths::LINKED_LIST) {\n                     span_help_and_lint(\n                         cx,\n                         LINKEDLIST,\n@@ -1136,9 +1135,9 @@ impl LintPass for CastPass {\n \n // Check if the given type is either `core::ffi::c_void` or\n // one of the platform specific `libc::<platform>::c_void` of libc.\n-fn is_c_void<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'_>) -> bool {\n+fn is_c_void(cx: &LateContext<'_, '_>, ty: Ty<'_>) -> bool {\n     if let ty::Adt(adt, _) = ty.sty {\n-        let names = AbsolutePathPrinter { tcx }.print_def_path(adt.did, &[]).unwrap();\n+        let names = cx.get_def_path(adt.did);\n \n         if names.is_empty() {\n             return false;\n@@ -1262,7 +1261,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n                 if let Some(to_align) = cx.layout_of(to_ptr_ty.ty).ok().map(|a| a.align.abi);\n                 if from_align < to_align;\n                 // with c_void, we inherently need to trust the user\n-                if !is_c_void(cx.tcx, from_ptr_ty.ty);\n+                if !is_c_void(cx, from_ptr_ty.ty);\n                 then {\n                     span_lint(\n                         cx,"}, {"sha": "6bb45b2c73f83c7980993b79460bd01032a5fee9", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=840eac2c05c31744f58e4a581ba838ac00a10cbc", "patch": "@@ -3,7 +3,7 @@\n \n #![deny(clippy::missing_docs_in_private_items)]\n \n-use crate::utils::{is_expn_of, match_def_path, match_qpath, paths, resolve_node};\n+use crate::utils::{is_expn_of, match_qpath, paths, resolve_node};\n use if_chain::if_chain;\n use rustc::lint::LateContext;\n use rustc::{hir, ty};\n@@ -216,11 +216,11 @@ pub fn vec_macro<'e>(cx: &LateContext<'_, '_>, expr: &'e hir::Expr) -> Option<Ve\n         if is_expn_of(fun.span, \"vec\").is_some();\n         if let Some(fun_def_id) = resolve_node(cx, path, fun.hir_id).opt_def_id();\n         then {\n-            return if match_def_path(cx.tcx, fun_def_id, &paths::VEC_FROM_ELEM) && args.len() == 2 {\n+            return if cx.match_def_path(fun_def_id, &paths::VEC_FROM_ELEM) && args.len() == 2 {\n                 // `vec![elem; size]` case\n                 Some(VecArgs::Repeat(&args[0], &args[1]))\n             }\n-            else if match_def_path(cx.tcx, fun_def_id, &paths::SLICE_INTO_VEC) && args.len() == 1 {\n+            else if cx.match_def_path(fun_def_id, &paths::SLICE_INTO_VEC) && args.len() == 1 {\n                 // `vec![a, b, c]` case\n                 if_chain! {\n                     if let hir::ExprKind::Box(ref boxed) = args[0].node;"}, {"sha": "69d026272824003a8b64f30fa6867dff48a33fbb", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=840eac2c05c31744f58e4a581ba838ac00a10cbc", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{match_def_path, match_type, paths, span_help_and_lint, span_lint, walk_ptrs_ty};\n+use crate::utils::{match_type, paths, span_help_and_lint, span_lint, walk_ptrs_ty};\n use if_chain::if_chain;\n use rustc::hir;\n use rustc::hir::def::Def;\n@@ -144,7 +144,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LintWithoutLintPass {\n             if_chain! {\n                 if let hir::TraitRef{path, ..} = trait_ref;\n                 if let Def::Trait(def_id) = path.def;\n-                if match_def_path(cx.tcx, def_id, &paths::LINT_PASS);\n+                if cx.match_def_path(def_id, &paths::LINT_PASS);\n                 then {\n                     let mut collector = LintCollector {\n                         output: &mut self.registered_lints,\n@@ -196,7 +196,7 @@ fn is_lint_ref_type<'tcx>(cx: &LateContext<'_, 'tcx>, ty: &Ty) -> bool {\n     {\n         if let TyKind::Path(ref path) = inner.node {\n             if let Def::Struct(def_id) = cx.tables.qpath_def(path, inner.hir_id) {\n-                return match_def_path(cx.tcx, def_id, &paths::LINT);\n+                return cx.match_def_path(def_id, &paths::LINT);\n             }\n         }\n     }"}, {"sha": "e9c078544db5f41f162c13153168588f4e995158", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840eac2c05c31744f58e4a581ba838ac00a10cbc/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=840eac2c05c31744f58e4a581ba838ac00a10cbc", "patch": "@@ -96,7 +96,7 @@ pub fn in_macro(span: Span) -> bool {\n /// Checks if type is struct, enum or union type with the given def path.\n pub fn match_type(cx: &LateContext<'_, '_>, ty: Ty<'_>, path: &[&str]) -> bool {\n     match ty.sty {\n-        ty::Adt(adt, _) => match_def_path(cx.tcx, adt.did, path),\n+        ty::Adt(adt, _) => cx.match_def_path(adt.did, path),\n         _ => false,\n     }\n }\n@@ -106,7 +106,7 @@ pub fn match_trait_method(cx: &LateContext<'_, '_>, expr: &Expr, path: &[&str])\n     let def_id = cx.tables.type_dependent_def_id(expr.hir_id).unwrap();\n     let trt_id = cx.tcx.trait_of_item(def_id);\n     if let Some(trt_id) = trt_id {\n-        match_def_path(cx.tcx, trt_id, path)\n+        cx.match_def_path(trt_id, path)\n     } else {\n         false\n     }\n@@ -989,7 +989,7 @@ pub fn has_iter_method(cx: &LateContext<'_, '_>, probably_ref_ty: Ty<'_>) -> Opt\n     };\n \n     for path in &INTO_ITER_COLLECTIONS {\n-        if match_def_path(cx.tcx, def_id, path) {\n+        if cx.match_def_path(def_id, path) {\n             return Some(path.last().unwrap());\n         }\n     }"}]}