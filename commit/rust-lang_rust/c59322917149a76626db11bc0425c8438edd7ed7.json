{"sha": "c59322917149a76626db11bc0425c8438edd7ed7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1OTMyMjkxNzE0OWE3NjYyNmRiMTFiYzA0MjVjODQzOGVkZDdlZDc=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2018-03-22T02:08:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-03-22T02:08:01Z"}, "message": "Merge pull request #2535 from nrc/import-ord\n\nImport ordering", "tree": {"sha": "55e9f211f91c3889f925331f587d0f76f0bc5de2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55e9f211f91c3889f925331f587d0f76f0bc5de2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c59322917149a76626db11bc0425c8438edd7ed7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJasxABCRBK7hj4Ov3rIwAAdHIIAFqC6bh4st196mr7+1KkJoFm\naO/AXLmLEzQAm4HGtB+EHPNab5OYi9isAUpClOncm2cw9eBUkzKiJ59++6TJDbXw\nR1fK49rH4CF8xR/cWjnKMUkQY2emKRkDzfvMlUsThJ6jBLK5jfoiAySHCJ71HxFZ\nVD6igN72l8dxsjdnyAUUDTUSmFktOP42/Pvd4hqz6300BnZHmgJOrvHwfebwr8oV\nwxDZm8Qiv2RIbLog8qCKheuslOOuTkXjB7WFpAEmIxTd+i+moWcTUZ0R/LEGhrT6\nuZEo3WPQIStPYq7Lx4PLcyMFHAyvwDWJP/x7mwPumCp6QkE3BdVoQd7sa1NyGSU=\n=aOPg\n-----END PGP SIGNATURE-----\n", "payload": "tree 55e9f211f91c3889f925331f587d0f76f0bc5de2\nparent 55162239007a1514dd9c5fe99c377c1929be1039\nparent 3a138a24a32d382670dfe55f744f902c9e1e2658\nauthor Nick Cameron <nrc@ncameron.org> 1521684481 +1300\ncommitter GitHub <noreply@github.com> 1521684481 +1300\n\nMerge pull request #2535 from nrc/import-ord\n\nImport ordering"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c59322917149a76626db11bc0425c8438edd7ed7", "html_url": "https://github.com/rust-lang/rust/commit/c59322917149a76626db11bc0425c8438edd7ed7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c59322917149a76626db11bc0425c8438edd7ed7/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55162239007a1514dd9c5fe99c377c1929be1039", "url": "https://api.github.com/repos/rust-lang/rust/commits/55162239007a1514dd9c5fe99c377c1929be1039", "html_url": "https://github.com/rust-lang/rust/commit/55162239007a1514dd9c5fe99c377c1929be1039"}, {"sha": "3a138a24a32d382670dfe55f744f902c9e1e2658", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a138a24a32d382670dfe55f744f902c9e1e2658", "html_url": "https://github.com/rust-lang/rust/commit/3a138a24a32d382670dfe55f744f902c9e1e2658"}], "stats": {"total": 711, "additions": 537, "deletions": 174}, "files": [{"sha": "f7fa88b61f2c9144cdac4fe80d7f7789df30f476", "filename": "Configurations.md", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/Configurations.md", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/Configurations.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Configurations.md?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -1297,28 +1297,28 @@ Reorder import statements in group\n \n **Note:** This option takes effect only when [`reorder_imports`](#reorder_imports) is set to `true`.\n \n-#### `false` (default):\n+#### `true` (default):\n \n ```rust\n-use std::mem;\n use std::io;\n+use std::mem;\n \n-use lorem;\n-use ipsum;\n use dolor;\n+use ipsum;\n+use lorem;\n use sit;\n ```\n \n-#### `true`:\n+#### `false`:\n \n-```rust\n-use std::io;\n-use std::mem;\n \n+```rust\n use dolor;\n use ipsum;\n use lorem;\n use sit;\n+use std::io;\n+use std::mem;\n ```\n \n See also [`reorder_imports`](#reorder_imports).\n@@ -1360,7 +1360,11 @@ Reorder `extern crate` statements in group\n - **Possible values**: `true`, `false`\n - **Stable**: No\n \n-#### `true` (default):\n+#### `false` (default):\n+\n+This value has no influence beyond the effect of the [`reorder_extern_crates`](#reorder_extern_crates) option. Set [`reorder_extern_crates`](#reorder_extern_crates) to `false` if you do not want `extern crate` groups to be collapsed and ordered.\n+\n+#### `true`:\n \n **Note:** This only takes effect when [`reorder_extern_crates`](#reorder_extern_crates) is set to `true`.\n \n@@ -1374,10 +1378,6 @@ extern crate lorem;\n extern crate sit;\n ```\n \n-#### `false`:\n-\n-This value has no influence beyond the effect of the [`reorder_extern_crates`](#reorder_extern_crates) option. Set [`reorder_extern_crates`](#reorder_extern_crates) to `false` if you do not want `extern crate` groups to be collapsed and ordered.\n-\n ## `reorder_modules`\n \n Reorder `mod` declarations alphabetically in group.\n@@ -1386,7 +1386,7 @@ Reorder `mod` declarations alphabetically in group.\n - **Possible values**: `true`, `false`\n - **Stable**: No\n \n-#### `true`\n+#### `true` (default)\n \n ```rust\n mod a;"}, {"sha": "ae37b043c05567b1fd250f8035bec80275d5613b", "filename": "bootstrap.sh", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/bootstrap.sh", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/bootstrap.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/bootstrap.sh?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -7,9 +7,8 @@\n cargo build --release\n \n target/release/rustfmt --write-mode=overwrite src/lib.rs\n-target/release/rustfmt --write-mode=overwrite src/bin/rustfmt.rs\n-target/release/rustfmt --write-mode=overwrite src/bin/cargo-fmt.rs\n-target/release/rustfmt --write-mode=overwrite tests/system.rs\n+target/release/rustfmt --write-mode=overwrite src/bin/main.rs\n+target/release/rustfmt --write-mode=overwrite src/cargo-fmt/main.rs\n \n for filename in tests/target/*.rs; do\n     if ! grep -q \"rustfmt-\" \"$filename\"; then"}, {"sha": "b59e47930e0c44ea965e6a43875e015ce1dce7bd", "filename": "src/bin/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/src%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/src%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmain.rs?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -14,16 +14,16 @@ extern crate env_logger;\n extern crate getopts;\n extern crate rustfmt_nightly as rustfmt;\n \n-use std::{env, error};\n use std::fs::File;\n use std::io::{self, Read, Write};\n use std::path::{Path, PathBuf};\n use std::str::FromStr;\n+use std::{env, error};\n \n use getopts::{Matches, Options};\n \n-use rustfmt::config::{get_toml_path, Color, Config, WriteMode};\n use rustfmt::config::file_lines::FileLines;\n+use rustfmt::config::{get_toml_path, Color, Config, WriteMode};\n use rustfmt::{run, FileName, Input, Summary};\n \n type FmtError = Box<error::Error + Send + Sync>;"}, {"sha": "d798981415e847d1bdeb0257da9656c46c068c38", "filename": "src/chains.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -77,8 +77,8 @@ use std::borrow::Cow;\n use std::cmp::min;\n use std::iter;\n \n-use syntax::{ast, ptr};\n use syntax::codemap::Span;\n+use syntax::{ast, ptr};\n \n pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -> Option<String> {\n     debug!(\"rewrite_chain {:?}\", shape);"}, {"sha": "2ec31afa391847c97195a14f194f622c0a590d2a", "filename": "src/closures.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/src%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/src%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fclosures.rs?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n use config::lists::*;\n-use syntax::{ast, ptr};\n use syntax::codemap::Span;\n use syntax::parse::classify;\n+use syntax::{ast, ptr};\n \n use codemap::SpanUtils;\n use expr::{block_contains_comment, is_simple_block, is_unsafe_block, rewrite_cond, ToExpr};"}, {"sha": "c5f24004fcf712241a316a3112665d38f2b4c964", "filename": "src/codemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/src%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/src%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodemap.rs?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -12,8 +12,8 @@\n //! This includes extension traits and methods for looking up spans and line ranges for AST nodes.\n \n use config::file_lines::LineRange;\n-use visitor::SnippetProvider;\n use syntax::codemap::{BytePos, CodeMap, Span};\n+use visitor::SnippetProvider;\n \n use comment::FindUncommented;\n "}, {"sha": "cf3f827c00daba13697024bf6604334ee9a6360b", "filename": "src/config/file_lines.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/src%2Fconfig%2Ffile_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/src%2Fconfig%2Ffile_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Ffile_lines.rs?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -10,9 +10,9 @@\n \n //! This module contains types and functions to support formatting specific line ranges.\n \n-use std::{cmp, iter, str};\n use std::collections::HashMap;\n use std::rc::Rc;\n+use std::{cmp, iter, str};\n \n use serde::de::{Deserialize, Deserializer};\n use serde_json as json;"}, {"sha": "d49fdbe7ebaeb30204acd19db77a679bf4b8bf87", "filename": "src/config/license.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/src%2Fconfig%2Flicense.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/src%2Fconfig%2Flicense.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Flicense.rs?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -1,6 +1,6 @@\n-use std::io;\n use std::fmt;\n use std::fs::File;\n+use std::io;\n use std::io::Read;\n \n use regex;"}, {"sha": "5d5e91ebaed3773ae9ef8ea424eafd1a349d8818", "filename": "src/config/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/src%2Fconfig%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/src%2Fconfig%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fmod.rs?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::{env, fs};\n use std::cell::Cell;\n use std::default::Default;\n use std::fs::File;\n use std::io::{Error, ErrorKind, Read};\n use std::path::{Path, PathBuf};\n+use std::{env, fs};\n \n use regex::Regex;\n \n@@ -23,9 +23,9 @@ mod config_type;\n mod options;\n \n pub mod file_lines;\n+pub mod license;\n pub mod lists;\n pub mod summary;\n-pub mod license;\n \n use config::config_type::ConfigType;\n use config::file_lines::FileLines;\n@@ -70,11 +70,11 @@ create_config! {\n     // Ordering\n     reorder_extern_crates: bool, true, false, \"Reorder extern crate statements alphabetically\";\n     reorder_extern_crates_in_group: bool, true, false, \"Reorder extern crate statements in group\";\n-    reorder_imports: bool, false, false, \"Reorder import statements alphabetically\";\n-    reorder_imports_in_group: bool, false, false, \"Reorder import statements in group\";\n+    reorder_imports: bool, true, false, \"Reorder import statements alphabetically\";\n+    reorder_imports_in_group: bool, true, false, \"Reorder import statements in group\";\n     reorder_imported_names: bool, true, false,\n         \"Reorder lists of names in import statements alphabetically\";\n-    reorder_modules: bool, false, false, \"Reorder module statemtents alphabetically in group\";\n+    reorder_modules: bool, true, false, \"Reorder module statemtents alphabetically in group\";\n \n     // Spaces around punctuation\n     binop_separator: SeparatorPlace, SeparatorPlace::Front, false,"}, {"sha": "99bf752f2b9aa532a1d93da7c19e67839d4fca1e", "filename": "src/config/summary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/src%2Fconfig%2Fsummary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/src%2Fconfig%2Fsummary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fsummary.rs?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::time::{Duration, Instant};\n use std::default::Default;\n+use std::time::{Duration, Instant};\n \n #[must_use]\n #[derive(Debug, Default, Clone, Copy)]"}, {"sha": "d364da20128af5faa3182e53b503cc3ea63bfc93", "filename": "src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -13,8 +13,8 @@ use std::cmp::min;\n use std::iter::repeat;\n \n use config::lists::*;\n-use syntax::{ast, ptr};\n use syntax::codemap::{BytePos, CodeMap, Span};\n+use syntax::{ast, ptr};\n \n use chains::rewrite_chain;\n use closures;"}, {"sha": "c871395f72ab9aed4b57b49a235fa250dd89b240", "filename": "src/format-diff/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/src%2Fformat-diff%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/src%2Fformat-diff%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformat-diff%2Fmain.rs?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -23,10 +23,10 @@ extern crate regex;\n extern crate serde_derive;\n extern crate serde_json as json;\n \n-use std::{env, fmt, process};\n use std::collections::HashSet;\n use std::error::Error;\n use std::io::{self, BufRead};\n+use std::{env, fmt, process};\n \n use regex::Regex;\n "}, {"sha": "2e0e869d12a50025baf167407ebcdbb2b1d3b82d", "filename": "src/items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -15,9 +15,9 @@ use std::cmp::min;\n \n use config::lists::*;\n use regex::Regex;\n-use syntax::{abi, ast, ptr, symbol};\n use syntax::codemap::{self, BytePos, Span};\n use syntax::visit;\n+use syntax::{abi, ast, ptr, symbol};\n \n use codemap::{LineRangeUtils, SpanUtils};\n use comment::{combine_strs_with_missing_comments, contains_comment, recover_comment_removed,\n@@ -26,8 +26,8 @@ use config::{BraceStyle, Config, Density, IndentStyle};\n use expr::{format_expr, is_empty_block, is_simple_block_stmt, rewrite_assign_rhs,\n            rewrite_assign_rhs_with, ExprType, RhsTactics};\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, ListItem, Separator};\n-use rewrite::{Rewrite, RewriteContext};\n use overflow;\n+use rewrite::{Rewrite, RewriteContext};\n use shape::{Indent, Shape};\n use spanned::Spanned;\n use types::TraitTyParamBounds;"}, {"sha": "4fdb7d0f47d75545a1e6067c79be8de865777f65", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -38,11 +38,11 @@ use std::path::PathBuf;\n use std::rc::Rc;\n use std::time::Duration;\n \n-use syntax::errors::{DiagnosticBuilder, Handler};\n-use syntax::errors::emitter::{ColorConfig, EmitterWriter};\n use syntax::ast;\n-use syntax::codemap::{CodeMap, FilePathMapping};\n pub use syntax::codemap::FileName;\n+use syntax::codemap::{CodeMap, FilePathMapping};\n+use syntax::errors::emitter::{ColorConfig, EmitterWriter};\n+use syntax::errors::{DiagnosticBuilder, Handler};\n use syntax::parse::{self, ParseSess};\n \n use checkstyle::{output_footer, output_header};"}, {"sha": "fdb022db077ff7c4610980f92dee2cc6106de16b", "filename": "src/lists.rs", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -56,7 +56,7 @@ impl AsRef<ListItem> for ListItem {\n     }\n }\n \n-#[derive(PartialEq, Eq)]\n+#[derive(PartialEq, Eq, Debug)]\n pub enum ListItemCommentStyle {\n     // Try to keep the comment on the same line with the item.\n     SameLine,\n@@ -66,6 +66,7 @@ pub enum ListItemCommentStyle {\n     None,\n }\n \n+#[derive(Debug)]\n pub struct ListItem {\n     // None for comments mean that they are not present.\n     pub pre_comment: Option<String>,\n@@ -118,6 +119,18 @@ impl ListItem {\n             new_lines: false,\n         }\n     }\n+\n+    // true if the item causes something to be written.\n+    fn is_substantial(&self) -> bool {\n+        fn empty(s: &Option<String>) -> bool {\n+            match *s {\n+                Some(ref s) if !s.is_empty() => false,\n+                _ => true,\n+            }\n+        }\n+\n+        !(empty(&self.pre_comment) && empty(&self.item) && empty(&self.post_comment))\n+    }\n }\n \n /// The type of separator for lists.\n@@ -220,6 +233,10 @@ where\n             item_last_line_width -= indent_str.len();\n         }\n \n+        if !item.is_substantial() {\n+            continue;\n+        }\n+\n         match tactic {\n             DefinitiveListTactic::Horizontal if !first => {\n                 result.push(' ');\n@@ -276,26 +293,28 @@ where\n                 rewrite_comment(comment, block_mode, formatting.shape, formatting.config)?;\n             result.push_str(&comment);\n \n-            if tactic == DefinitiveListTactic::Vertical {\n-                // We cannot keep pre-comments on the same line if the comment if normalized.\n-                let keep_comment = if formatting.config.normalize_comments()\n-                    || item.pre_comment_style == ListItemCommentStyle::DifferentLine\n-                {\n-                    false\n+            if !inner_item.is_empty() {\n+                if tactic == DefinitiveListTactic::Vertical {\n+                    // We cannot keep pre-comments on the same line if the comment if normalized.\n+                    let keep_comment = if formatting.config.normalize_comments()\n+                        || item.pre_comment_style == ListItemCommentStyle::DifferentLine\n+                    {\n+                        false\n+                    } else {\n+                        // We will try to keep the comment on the same line with the item here.\n+                        // 1 = ` `\n+                        let total_width = total_item_width(item) + item_sep_len + 1;\n+                        total_width <= formatting.shape.width\n+                    };\n+                    if keep_comment {\n+                        result.push(' ');\n+                    } else {\n+                        result.push('\\n');\n+                        result.push_str(indent_str);\n+                    }\n                 } else {\n-                    // We will try to keep the comment on the same line with the item here.\n-                    // 1 = ` `\n-                    let total_width = total_item_width(item) + item_sep_len + 1;\n-                    total_width <= formatting.shape.width\n-                };\n-                if keep_comment {\n                     result.push(' ');\n-                } else {\n-                    result.push('\\n');\n-                    result.push_str(indent_str);\n                 }\n-            } else {\n-                result.push(' ');\n             }\n             item_max_width = None;\n         }\n@@ -304,7 +323,7 @@ where\n             result.push_str(formatting.separator.trim());\n             result.push(' ');\n         }\n-        result.push_str(&inner_item[..]);\n+        result.push_str(inner_item);\n \n         // Post-comments\n         if tactic != DefinitiveListTactic::Vertical && item.post_comment.is_some() {"}, {"sha": "ec1ca29d1739b7840424690de65d6576aa545e4f", "filename": "src/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -22,7 +22,6 @@\n use std::collections::HashMap;\n \n use config::lists::*;\n-use syntax::{ast, ptr};\n use syntax::codemap::{BytePos, Span};\n use syntax::parse::new_parser_from_tts;\n use syntax::parse::parser::Parser;\n@@ -31,6 +30,7 @@ use syntax::print::pprust;\n use syntax::symbol;\n use syntax::tokenstream::{Cursor, ThinTokenStream, TokenStream, TokenTree};\n use syntax::util::ThinVec;\n+use syntax::{ast, ptr};\n \n use codemap::SpanUtils;\n use comment::{contains_comment, remove_trailing_white_spaces, CharClasses, FindUncommented,"}, {"sha": "f5794c65c4c4b7d48ffd0a506a8d49312cc11152", "filename": "src/missed_spans.rs", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -104,19 +104,38 @@ impl<'a> FmtVisitor<'a> {\n     }\n \n     fn push_vertical_spaces(&mut self, mut newline_count: usize) {\n-        // The buffer already has a trailing newline.\n-        let offset = if self.buffer.ends_with('\\n') { 0 } else { 1 };\n-        let newline_upper_bound = self.config.blank_lines_upper_bound() + offset;\n-        let newline_lower_bound = self.config.blank_lines_lower_bound() + offset;\n-        if newline_count > newline_upper_bound {\n-            newline_count = newline_upper_bound;\n-        } else if newline_count < newline_lower_bound {\n-            newline_count = newline_lower_bound;\n+        let offset = self.count_trailing_newlines();\n+        let newline_upper_bound = self.config.blank_lines_upper_bound() + 1;\n+        let newline_lower_bound = self.config.blank_lines_lower_bound() + 1;\n+\n+        if newline_count + offset > newline_upper_bound {\n+            if offset >= newline_upper_bound {\n+                newline_count = 0;\n+            } else {\n+                newline_count = newline_upper_bound - offset;\n+            }\n+        } else if newline_count + offset < newline_lower_bound {\n+            if offset >= newline_lower_bound {\n+                newline_count = 0;\n+            } else {\n+                newline_count = newline_lower_bound - offset;\n+            }\n         }\n+\n         let blank_lines: String = repeat('\\n').take(newline_count).collect();\n         self.push_str(&blank_lines);\n     }\n \n+    fn count_trailing_newlines(&self) -> usize {\n+        let mut buf = &*self.buffer;\n+        let mut result = 0;\n+        while buf.ends_with('\\n') {\n+            buf = &buf[..buf.len() - 1];\n+            result += 1;\n+        }\n+        result\n+    }\n+\n     fn write_snippet<F>(&mut self, span: Span, process_last_snippet: F)\n     where\n         F: Fn(&mut FmtVisitor, &str, &str),"}, {"sha": "c76b67c461ebc319000fe2598fd0cd8ef946ce1c", "filename": "src/overflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/src%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/src%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foverflow.rs?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -17,9 +17,9 @@ use syntax::codemap::Span;\n \n use closures;\n use codemap::SpanUtils;\n+use expr::{is_nested_call, maybe_get_args_offset, ToExpr};\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, ListItem, Separator};\n use rewrite::{Rewrite, RewriteContext};\n-use expr::{is_nested_call, maybe_get_args_offset, ToExpr};\n use shape::Shape;\n use spanned::Spanned;\n use utils::{count_newlines, extra_offset, first_line_width, last_line_width, mk_sp, paren_overhead};"}, {"sha": "5595fa5b237ba6373575dc9c577daa55502fc6e2", "filename": "src/reorder.rs", "status": "modified", "additions": 404, "deletions": 82, "changes": 486, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/src%2Freorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/src%2Freorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freorder.rs?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -17,6 +17,7 @@\n // TODO(#2455): Reorder trait items.\n \n use config::{Config, lists::*};\n+use syntax::ast::UseTreeKind;\n use syntax::{ast, attr, codemap::Span};\n \n use attr::filter_inline_attrs;\n@@ -31,86 +32,12 @@ use spanned::Spanned;\n use utils::mk_sp;\n use visitor::FmtVisitor;\n \n-use std::cmp::Ordering;\n+use std::cmp::{Ord, Ordering, PartialOrd};\n \n-fn compare_path_segments(a: &ast::PathSegment, b: &ast::PathSegment) -> Ordering {\n-    a.identifier.name.as_str().cmp(&b.identifier.name.as_str())\n-}\n-\n-fn compare_paths(a: &ast::Path, b: &ast::Path) -> Ordering {\n-    for segment in a.segments.iter().zip(b.segments.iter()) {\n-        let ord = compare_path_segments(segment.0, segment.1);\n-        if ord != Ordering::Equal {\n-            return ord;\n-        }\n-    }\n-    a.segments.len().cmp(&b.segments.len())\n-}\n-\n-fn compare_use_trees(a: &ast::UseTree, b: &ast::UseTree, nested: bool) -> Ordering {\n-    use ast::UseTreeKind::*;\n-\n-    // `use_nested_groups` is not yet supported, remove the `if !nested` when support will be\n-    // fully added\n-    if !nested {\n-        let paths_cmp = compare_paths(&a.prefix, &b.prefix);\n-        if paths_cmp != Ordering::Equal {\n-            return paths_cmp;\n-        }\n-    }\n-\n-    match (&a.kind, &b.kind) {\n-        (&Simple(ident_a), &Simple(ident_b)) => {\n-            let name_a = &*path_to_imported_ident(&a.prefix).name.as_str();\n-            let name_b = &*path_to_imported_ident(&b.prefix).name.as_str();\n-            let name_ordering = if name_a == \"self\" {\n-                if name_b == \"self\" {\n-                    Ordering::Equal\n-                } else {\n-                    Ordering::Less\n-                }\n-            } else if name_b == \"self\" {\n-                Ordering::Greater\n-            } else {\n-                name_a.cmp(name_b)\n-            };\n-            if name_ordering == Ordering::Equal {\n-                if ident_a.name.as_str() != name_a {\n-                    if ident_b.name.as_str() != name_b {\n-                        ident_a.name.as_str().cmp(&ident_b.name.as_str())\n-                    } else {\n-                        Ordering::Greater\n-                    }\n-                } else {\n-                    Ordering::Less\n-                }\n-            } else {\n-                name_ordering\n-            }\n-        }\n-        (&Glob, &Glob) => Ordering::Equal,\n-        (&Simple(_), _) | (&Glob, &Nested(_)) => Ordering::Less,\n-        (&Nested(ref a_items), &Nested(ref b_items)) => {\n-            let mut a = a_items\n-                .iter()\n-                .map(|&(ref tree, _)| tree.clone())\n-                .collect::<Vec<_>>();\n-            let mut b = b_items\n-                .iter()\n-                .map(|&(ref tree, _)| tree.clone())\n-                .collect::<Vec<_>>();\n-            a.sort_by(|a, b| compare_use_trees(a, b, true));\n-            b.sort_by(|a, b| compare_use_trees(a, b, true));\n-            for comparison_pair in a.iter().zip(b.iter()) {\n-                let ord = compare_use_trees(comparison_pair.0, comparison_pair.1, true);\n-                if ord != Ordering::Equal {\n-                    return ord;\n-                }\n-            }\n-            a.len().cmp(&b.len())\n-        }\n-        (&Glob, &Simple(_)) | (&Nested(_), _) => Ordering::Greater,\n-    }\n+fn compare_use_trees(a: &ast::UseTree, b: &ast::UseTree) -> Ordering {\n+    let aa = UseTree::from_ast(a).normalize();\n+    let bb = UseTree::from_ast(b).normalize();\n+    aa.cmp(&bb)\n }\n \n /// Choose the ordering between the given two items.\n@@ -120,7 +47,7 @@ fn compare_items(a: &ast::Item, b: &ast::Item) -> Ordering {\n             a.ident.name.as_str().cmp(&b.ident.name.as_str())\n         }\n         (&ast::ItemKind::Use(ref a_tree), &ast::ItemKind::Use(ref b_tree)) => {\n-            compare_use_trees(a_tree, b_tree, false)\n+            compare_use_trees(a_tree, b_tree)\n         }\n         (&ast::ItemKind::ExternCrate(ref a_name), &ast::ItemKind::ExternCrate(ref b_name)) => {\n             // `extern crate foo as bar;`\n@@ -149,8 +76,6 @@ fn compare_items(a: &ast::Item, b: &ast::Item) -> Ordering {\n \n /// Rewrite a list of items with reordering. Every item in `items` must have\n /// the same `ast::ItemKind`.\n-// TODO (some day) remove unused imports, expand globs, compress many single\n-// imports into a list import.\n fn rewrite_reorderable_items(\n     context: &RewriteContext,\n     reorderable_items: &[&ast::Item],\n@@ -196,6 +121,7 @@ fn rewrite_reorderable_items(\n         span.hi(),\n         false,\n     );\n+\n     let mut item_pair_vec: Vec<_> = items.zip(reorderable_items.iter()).collect();\n     item_pair_vec.sort_by(|a, b| compare_items(a.1, b.1));\n     let item_vec: Vec<_> = item_pair_vec.into_iter().map(|pair| pair.0).collect();\n@@ -329,3 +255,399 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         }\n     }\n }\n+\n+// Ordering of imports\n+\n+// We order imports by translating to our own representation and then sorting.\n+// The Rust AST data structures are really bad for this. Rustfmt applies a bunch\n+// of normalisations to imports and since we want to sort based on the result\n+// of these (and to maintain idempotence) we must apply the same normalisations\n+// to the data structures for sorting.\n+//\n+// We sort `self` and `super` before other imports, then identifier imports,\n+// then glob imports, then lists of imports. We do not take aliases into account\n+// when ordering unless the imports are identical except for the alias (rare in\n+// practice).\n+\n+// FIXME(#2531) - we should unify the comparison code here with the formatting\n+// code elsewhere since we are essentially string-ifying twice. Furthermore, by\n+// parsing to our own format on comparison, we repeat a lot of work when\n+// sorting.\n+\n+// FIXME we do a lot of allocation to make our own representation.\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+enum UseSegment {\n+    Ident(String, Option<String>),\n+    Slf(Option<String>),\n+    Super(Option<String>),\n+    Glob,\n+    List(Vec<UseTree>),\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+struct UseTree {\n+    path: Vec<UseSegment>,\n+}\n+\n+impl UseSegment {\n+    // Clone a version of self with any top-level alias removed.\n+    fn remove_alias(&self) -> UseSegment {\n+        match *self {\n+            UseSegment::Ident(ref s, _) => UseSegment::Ident(s.clone(), None),\n+            UseSegment::Slf(_) => UseSegment::Slf(None),\n+            UseSegment::Super(_) => UseSegment::Super(None),\n+            _ => self.clone(),\n+        }\n+    }\n+}\n+\n+impl UseTree {\n+    fn from_ast(a: &ast::UseTree) -> UseTree {\n+        let mut result = UseTree { path: vec![] };\n+        for p in &a.prefix.segments {\n+            result.path.push(UseSegment::Ident(\n+                (*p.identifier.name.as_str()).to_owned(),\n+                None,\n+            ));\n+        }\n+        match a.kind {\n+            UseTreeKind::Glob => {\n+                result.path.push(UseSegment::Glob);\n+            }\n+            UseTreeKind::Nested(ref list) => {\n+                result.path.push(UseSegment::List(\n+                    list.iter().map(|t| Self::from_ast(&t.0)).collect(),\n+                ));\n+            }\n+            UseTreeKind::Simple(ref rename) => {\n+                let mut name = (*path_to_imported_ident(&a.prefix).name.as_str()).to_owned();\n+                let alias = if &name == &*rename.name.as_str() {\n+                    None\n+                } else {\n+                    Some((&*rename.name.as_str()).to_owned())\n+                };\n+\n+                let segment = if &name == \"self\" {\n+                    UseSegment::Slf(alias)\n+                } else if &name == \"super\" {\n+                    UseSegment::Super(alias)\n+                } else {\n+                    UseSegment::Ident(name, alias)\n+                };\n+\n+                // `name` is already in result.\n+                result.path.pop();\n+                result.path.push(segment);\n+            }\n+        }\n+        result\n+    }\n+\n+    // Do the adjustments that rustfmt does elsewhere to use paths.\n+    fn normalize(mut self) -> UseTree {\n+        let mut last = self.path.pop().expect(\"Empty use tree?\");\n+        // Hack around borrow checker.\n+        let mut normalize_sole_list = false;\n+        let mut aliased_self = false;\n+\n+        // Normalise foo::self -> foo.\n+        if let UseSegment::Slf(None) = last {\n+            return self;\n+        }\n+\n+        // Normalise foo::self as bar -> foo as bar.\n+        if let UseSegment::Slf(_) = last {\n+            match self.path.last() {\n+                None => {}\n+                Some(UseSegment::Ident(_, None)) => {\n+                    aliased_self = true;\n+                }\n+                _ => unreachable!(),\n+            }\n+        }\n+\n+        if aliased_self {\n+            match self.path.last() {\n+                Some(UseSegment::Ident(_, ref mut old_rename)) => {\n+                    assert!(old_rename.is_none());\n+                    if let UseSegment::Slf(Some(rename)) = last {\n+                        *old_rename = Some(rename);\n+                        return self;\n+                    }\n+                }\n+                _ => unreachable!(),\n+            }\n+        }\n+\n+        // Normalise foo::{bar} -> foo::bar\n+        if let UseSegment::List(ref list) = last {\n+            if list.len() == 1 && list[0].path.len() == 1 {\n+                normalize_sole_list = true;\n+            }\n+        }\n+\n+        if normalize_sole_list {\n+            match last {\n+                UseSegment::List(list) => {\n+                    self.path.push(list[0].path[0].clone());\n+                    return self.normalize();\n+                }\n+                _ => unreachable!(),\n+            }\n+        }\n+\n+        // Recursively normalize elements of a list use (including sorting the list).\n+        if let UseSegment::List(list) = last {\n+            let mut list: Vec<_> = list.into_iter().map(|ut| ut.normalize()).collect();\n+            list.sort();\n+            last = UseSegment::List(list);\n+        }\n+\n+        self.path.push(last);\n+        self\n+    }\n+}\n+\n+impl PartialOrd for UseSegment {\n+    fn partial_cmp(&self, other: &UseSegment) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+impl PartialOrd for UseTree {\n+    fn partial_cmp(&self, other: &UseTree) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+impl Ord for UseSegment {\n+    fn cmp(&self, other: &UseSegment) -> Ordering {\n+        use self::UseSegment::*;\n+\n+        match (self, other) {\n+            (&Slf(ref a), &Slf(ref b)) | (&Super(ref a), &Super(ref b)) => a.cmp(b),\n+            (&Glob, &Glob) => Ordering::Equal,\n+            (&Ident(ref ia, ref aa), &Ident(ref ib, ref ab)) => {\n+                let ident_ord = ia.cmp(ib);\n+                if ident_ord != Ordering::Equal {\n+                    return ident_ord;\n+                }\n+                if aa.is_none() && ab.is_some() {\n+                    return Ordering::Less;\n+                }\n+                if aa.is_some() && ab.is_none() {\n+                    return Ordering::Greater;\n+                }\n+                aa.cmp(ab)\n+            }\n+            (&List(ref a), &List(ref b)) => {\n+                for (a, b) in a.iter().zip(b.iter()) {\n+                    let ord = a.cmp(b);\n+                    if ord != Ordering::Equal {\n+                        return ord;\n+                    }\n+                }\n+\n+                a.len().cmp(&b.len())\n+            }\n+            (&Slf(_), _) => Ordering::Less,\n+            (_, &Slf(_)) => Ordering::Greater,\n+            (&Super(_), _) => Ordering::Less,\n+            (_, &Super(_)) => Ordering::Greater,\n+            (&Ident(..), _) => Ordering::Less,\n+            (_, &Ident(..)) => Ordering::Greater,\n+            (&Glob, _) => Ordering::Less,\n+            (_, &Glob) => Ordering::Greater,\n+        }\n+    }\n+}\n+impl Ord for UseTree {\n+    fn cmp(&self, other: &UseTree) -> Ordering {\n+        for (a, b) in self.path.iter().zip(other.path.iter()) {\n+            let ord = a.cmp(b);\n+            // The comparison without aliases is a hack to avoid situations like\n+            // comparing `a::b` to `a as c` - where the latter should be ordered\n+            // first since it is shorter.\n+            if ord != Ordering::Equal && a.remove_alias().cmp(&b.remove_alias()) != Ordering::Equal\n+            {\n+                return ord;\n+            }\n+        }\n+\n+        self.path.len().cmp(&other.path.len())\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    // Parse the path part of an import. This parser is not robust and is only\n+    // suitable for use in a test harness.\n+    fn parse_use_tree(s: &str) -> UseTree {\n+        use std::iter::Peekable;\n+        use std::mem::swap;\n+        use std::str::Chars;\n+\n+        struct Parser<'a> {\n+            input: Peekable<Chars<'a>>,\n+        }\n+\n+        impl<'a> Parser<'a> {\n+            fn bump(&mut self) {\n+                self.input.next().unwrap();\n+            }\n+            fn eat(&mut self, c: char) {\n+                assert!(self.input.next().unwrap() == c);\n+            }\n+            fn push_segment(\n+                result: &mut Vec<UseSegment>,\n+                buf: &mut String,\n+                alias_buf: &mut Option<String>,\n+            ) {\n+                if !buf.is_empty() {\n+                    let mut alias = None;\n+                    swap(alias_buf, &mut alias);\n+                    if buf == \"self\" {\n+                        result.push(UseSegment::Slf(alias));\n+                        *buf = String::new();\n+                        *alias_buf = None;\n+                    } else if buf == \"super\" {\n+                        result.push(UseSegment::Super(alias));\n+                        *buf = String::new();\n+                        *alias_buf = None;\n+                    } else {\n+                        let mut name = String::new();\n+                        swap(buf, &mut name);\n+                        result.push(UseSegment::Ident(name, alias));\n+                    }\n+                }\n+            }\n+            fn parse_in_list(&mut self) -> UseTree {\n+                let mut result = vec![];\n+                let mut buf = String::new();\n+                let mut alias_buf = None;\n+                while let Some(&c) = self.input.peek() {\n+                    match c {\n+                        '{' => {\n+                            assert!(buf.is_empty());\n+                            self.bump();\n+                            result.push(UseSegment::List(self.parse_list()));\n+                            self.eat('}');\n+                        }\n+                        '*' => {\n+                            assert!(buf.is_empty());\n+                            self.bump();\n+                            result.push(UseSegment::Glob);\n+                        }\n+                        ':' => {\n+                            self.bump();\n+                            self.eat(':');\n+                            Self::push_segment(&mut result, &mut buf, &mut alias_buf);\n+                        }\n+                        '}' | ',' => {\n+                            Self::push_segment(&mut result, &mut buf, &mut alias_buf);\n+                            return UseTree { path: result };\n+                        }\n+                        ' ' => {\n+                            self.bump();\n+                            self.eat('a');\n+                            self.eat('s');\n+                            self.eat(' ');\n+                            alias_buf = Some(String::new());\n+                        }\n+                        c => {\n+                            self.bump();\n+                            if let Some(ref mut buf) = alias_buf {\n+                                buf.push(c);\n+                            } else {\n+                                buf.push(c);\n+                            }\n+                        }\n+                    }\n+                }\n+                Self::push_segment(&mut result, &mut buf, &mut alias_buf);\n+                UseTree { path: result }\n+            }\n+\n+            fn parse_list(&mut self) -> Vec<UseTree> {\n+                let mut result = vec![];\n+                loop {\n+                    match self.input.peek().unwrap() {\n+                        ',' | ' ' => self.bump(),\n+                        '}' => {\n+                            return result;\n+                        }\n+                        _ => result.push(self.parse_in_list()),\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut parser = Parser {\n+            input: s.chars().peekable(),\n+        };\n+        parser.parse_in_list()\n+    }\n+\n+    #[test]\n+    fn test_use_tree_normalize() {\n+        assert_eq!(parse_use_tree(\"a::self\").normalize(), parse_use_tree(\"a\"));\n+        assert_eq!(\n+            parse_use_tree(\"a::self as foo\").normalize(),\n+            parse_use_tree(\"a as foo\")\n+        );\n+        assert_eq!(parse_use_tree(\"a::{self}\").normalize(), parse_use_tree(\"a\"));\n+        assert_eq!(parse_use_tree(\"a::{b}\").normalize(), parse_use_tree(\"a::b\"));\n+        assert_eq!(\n+            parse_use_tree(\"a::{b, c::self}\").normalize(),\n+            parse_use_tree(\"a::{b, c}\")\n+        );\n+        assert_eq!(\n+            parse_use_tree(\"a::{b as bar, c::self}\").normalize(),\n+            parse_use_tree(\"a::{b as bar, c}\")\n+        );\n+    }\n+\n+    #[test]\n+    fn test_use_tree_ord() {\n+        assert!(parse_use_tree(\"a\").normalize() < parse_use_tree(\"aa\").normalize());\n+        assert!(parse_use_tree(\"a\").normalize() < parse_use_tree(\"a::a\").normalize());\n+        assert!(parse_use_tree(\"a\").normalize() < parse_use_tree(\"*\").normalize());\n+        assert!(parse_use_tree(\"a\").normalize() < parse_use_tree(\"{a, b}\").normalize());\n+        assert!(parse_use_tree(\"*\").normalize() < parse_use_tree(\"{a, b}\").normalize());\n+\n+        assert!(\n+            parse_use_tree(\"aaaaaaaaaaaaaaa::{bb, cc, dddddddd}\").normalize()\n+                < parse_use_tree(\"aaaaaaaaaaaaaaa::{bb, cc, ddddddddd}\").normalize()\n+        );\n+        assert!(\n+            parse_use_tree(\"serde::de::{Deserialize}\").normalize()\n+                < parse_use_tree(\"serde_json\").normalize()\n+        );\n+        assert!(parse_use_tree(\"a::b::c\").normalize() < parse_use_tree(\"a::b::*\").normalize());\n+        assert!(\n+            parse_use_tree(\"foo::{Bar, Baz}\").normalize()\n+                < parse_use_tree(\"{Bar, Baz}\").normalize()\n+        );\n+\n+        assert!(\n+            parse_use_tree(\"foo::{self as bar}\").normalize()\n+                < parse_use_tree(\"foo::{qux as bar}\").normalize()\n+        );\n+        assert!(\n+            parse_use_tree(\"foo::{qux as bar}\").normalize()\n+                < parse_use_tree(\"foo::{baz, qux as bar}\").normalize()\n+        );\n+        assert!(\n+            parse_use_tree(\"foo::{self as bar, baz}\").normalize()\n+                < parse_use_tree(\"foo::{baz, qux as bar}\").normalize()\n+        );\n+\n+        assert!(parse_use_tree(\"Foo\").normalize() < parse_use_tree(\"foo\").normalize());\n+        assert!(parse_use_tree(\"foo\").normalize() < parse_use_tree(\"foo::Bar\").normalize());\n+\n+        assert!(\n+            parse_use_tree(\"std::cmp::{d, c, b, a}\").normalize()\n+                < parse_use_tree(\"std::cmp::{b, e, g, f}\").normalize()\n+        );\n+    }\n+}"}, {"sha": "db72a775f414f498c585c0323691934d79b04edb", "filename": "src/rustfmt_diff.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/src%2Frustfmt_diff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/src%2Frustfmt_diff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustfmt_diff.rs?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -12,8 +12,8 @@ use config::Color;\n use diff;\n use std::collections::VecDeque;\n use std::io;\n-use term;\n use std::io::Write;\n+use term;\n use utils::use_colored_tty;\n \n #[derive(Debug, PartialEq)]\n@@ -211,8 +211,8 @@ where\n \n #[cfg(test)]\n mod test {\n-    use super::{make_diff, Mismatch};\n     use super::DiffLine::*;\n+    use super::{make_diff, Mismatch};\n \n     #[test]\n     fn diff_simple() {"}, {"sha": "d1d526efe3699548a2b4ec86d32911169e40ee61", "filename": "src/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -10,10 +10,10 @@\n \n use std::borrow::Cow;\n \n-use syntax::{abi, ptr};\n use syntax::ast::{self, Attribute, CrateSugar, MetaItem, MetaItemKind, NestedMetaItem,\n                   NestedMetaItemKind, Path, Visibility, VisibilityKind};\n use syntax::codemap::{BytePos, Span, NO_EXPANSION};\n+use syntax::{abi, ptr};\n \n use config::Color;\n use rewrite::RewriteContext;"}, {"sha": "54a85062d435f16146ac56eb519de45265267ec6", "filename": "src/visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use syntax::{ast, visit};\n use syntax::attr::HasAttrs;\n use syntax::codemap::{self, BytePos, CodeMap, Pos, Span};\n use syntax::parse::ParseSess;\n+use syntax::{ast, visit};\n \n use attr::*;\n use codemap::{LineRangeUtils, SpanUtils};"}, {"sha": "8c4d67575dcb25a4cc6dbc709ebd2227c9108968", "filename": "tests/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/tests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/tests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Flib.rs?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -23,11 +23,11 @@ use std::iter::{Enumerate, Peekable};\n use std::path::{Path, PathBuf};\n use std::str::Chars;\n \n-use rustfmt::*;\n-use rustfmt::config::{Color, Config, ReportTactic};\n use rustfmt::config::summary::Summary;\n+use rustfmt::config::{Color, Config, ReportTactic};\n use rustfmt::filemap::write_system_newlines;\n use rustfmt::rustfmt_diff::*;\n+use rustfmt::*;\n \n const DIFF_CONTEXT_SIZE: usize = 3;\n const CONFIGURATIONS_FILE_NAME: &str = \"Configurations.md\";"}, {"sha": "cbe5f4c7bb2f31f89a49b894ee95921a2abac846", "filename": "tests/source/imports.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/tests%2Fsource%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/tests%2Fsource%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fimports.rs?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -21,6 +21,7 @@ use {/* Pre-comment! */\n      Foo, Bar /* comment */};\n use Foo::{Bar, Baz};\n pub use syntax::ast::{Expr_, Expr, ExprAssign, ExprCall, ExprMethodCall, ExprPath};\n+\n use syntax::some::{};\n \n use self;"}, {"sha": "e31819be2c07a673fa3248cc6e3c2c66631761eb", "filename": "tests/target/imports-reorder-lines-and-items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/tests%2Ftarget%2Fimports-reorder-lines-and-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/tests%2Ftarget%2Fimports-reorder-lines-and-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fimports-reorder-lines-and-items.rs?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -2,9 +2,9 @@\n // rustfmt-reorder_imported_names: true\n \n use std::cmp::{a, b, c, d};\n-use std::ddd::{a, b, c as g, d as p};\n use std::ddd::aaa;\n-// This comment should stay with `use std::ddd:bbb;`\n-use std::ddd::bbb;\n+use std::ddd::{a, b, c as g, d as p};\n /// This comment should stay with `use std::str;`\n use std::str;\n+// This comment should stay with `use std::ddd:bbb;`\n+use std::ddd::bbb;"}, {"sha": "2aeb8fadd2cbe1ed882b6f88ad34230b2fb0a812", "filename": "tests/target/imports-reorder-lines.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/tests%2Ftarget%2Fimports-reorder-lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/tests%2Ftarget%2Fimports-reorder-lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fimports-reorder-lines.rs?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -2,29 +2,29 @@\n \n use std::cmp::{a, b, c, d};\n use std::cmp::{b, e, f, g};\n+use std::ddd::aaa;\n+use std::str;\n // This comment should stay with `use std::ddd;`\n use std::ddd;\n-use std::ddd::aaa;\n use std::ddd::bbb;\n-use std::str;\n \n mod test {}\n \n use aaa;\n-use aaa::*;\n use aaa::bbb;\n+use aaa::*;\n \n mod test {}\n // If item names are equal, order by rename\n \n-use test::{a as aa, c};\n use test::{a as bb, b};\n+use test::{a as aa, c};\n \n mod test {}\n // If item names are equal, order by rename - no rename comes before a rename\n \n-use test::{a, c};\n use test::{a as bb, b};\n+use test::{a, c};\n \n mod test {}\n // `self` always comes first"}, {"sha": "af5f1ee7bcf6f4a8eb43b52b7a4be239cb517a3d", "filename": "tests/target/imports.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/tests%2Ftarget%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/tests%2Ftarget%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fimports.rs?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -4,11 +4,11 @@\n // Imports.\n \n // Long import.\n-use syntax::ast::{ItemDefaultImpl, ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic};\n-use exceedingly::looooooooooooooooooooooooooooooooooooooooooooooooooooooooooong::import::path::{ItemA,\n-                                                                                                ItemB};\n use exceedingly::loooooooooooooooooooooooooooooooooooooooooooooooooooooooong::import::path::{ItemA,\n                                                                                              ItemB};\n+use exceedingly::looooooooooooooooooooooooooooooooooooooooooooooooooooooooooong::import::path::{ItemA,\n+                                                                                                ItemB};\n+use syntax::ast::{ItemDefaultImpl, ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic};\n \n use list::{// Another item\n            AnotherItem, // Another Comment\n@@ -19,10 +19,10 @@ use list::{// Another item\n \n use test::{/* A */ self /* B */, Other /* C */};\n \n-use syntax;\n-use {Bar /* comment */, /* Pre-comment! */ Foo};\n use Foo::{Bar, Baz};\n+use syntax;\n pub use syntax::ast::{Expr, ExprAssign, ExprCall, ExprMethodCall, ExprPath, Expr_};\n+use {Bar /* comment */, /* Pre-comment! */ Foo};\n \n use self;\n use std::io;\n@@ -43,21 +43,21 @@ fn test() {\n }\n \n // Simple imports\n-use foo::bar::baz;\n use bar::quux as kaas;\n use foo;\n+use foo::bar::baz;\n \n // With aliases.\n-use foo::{self as bar, baz};\n use foo as bar;\n use foo::qux as bar;\n+use foo::{self as bar, baz};\n use foo::{baz, qux as bar};\n \n // With absolute paths\n+use Foo;\n use foo;\n use foo::Bar;\n use foo::{Bar, Baz};\n-use Foo;\n use {Bar, Baz};\n \n // Root globs\n@@ -83,6 +83,6 @@ use fooo::{bar, x, y, z,\n            bar::*};\n \n // nested imports with a single sub-tree.\n-use a::b::c::*;\n use a::b::c::d;\n+use a::b::c::*;\n use a::b::c::{xxx, yyy, zzz};"}, {"sha": "ca77a761fb4ef690cd66649d7216cbe12b7ad827", "filename": "tests/target/issue-1124.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/tests%2Ftarget%2Fissue-1124.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/tests%2Ftarget%2Fissue-1124.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-1124.rs?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -14,7 +14,9 @@ mod a {\n     use d;\n }\n \n+use z;\n+\n+use y;\n+\n use a;\n use x;\n-use y;\n-use z;"}, {"sha": "d4e594515b3c239bd2784f8da5a5b501f4ee2db7", "filename": "tests/target/issue-2256.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/tests%2Ftarget%2Fissue-2256.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/tests%2Ftarget%2Fissue-2256.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-2256.rs?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -2,6 +2,7 @@\n use std::borrow::Cow;\n \n /* comment */\n+\n /* comment */\n \n /* comment */"}, {"sha": "11d1d69e91af891c40efd589df4e0c23f8591f43", "filename": "tests/target/skip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c59322917149a76626db11bc0425c8438edd7ed7/tests%2Ftarget%2Fskip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59322917149a76626db11bc0425c8438edd7ed7/tests%2Ftarget%2Fskip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fskip.rs?ref=c59322917149a76626db11bc0425c8438edd7ed7", "patch": "@@ -59,7 +59,7 @@ fn skip_on_statements() {\n \n     // Item\n     #[cfg_attr(rustfmt, rustfmt_skip)]\n-    use   foobar  ;\n+    use foobar;\n \n     // Mac\n     #[cfg_attr(rustfmt, rustfmt_skip)]"}]}