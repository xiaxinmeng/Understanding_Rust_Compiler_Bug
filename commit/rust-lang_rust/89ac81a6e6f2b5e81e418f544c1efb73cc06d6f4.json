{"sha": "89ac81a6e6f2b5e81e418f544c1efb73cc06d6f4", "node_id": "C_kwDOAAsO6NoAKDg5YWM4MWE2ZTZmMmI1ZTgxZTQxOGY1NDRjMWVmYjczY2MwNmQ2ZjQ", "commit": {"author": {"name": "Frank Steffahn", "email": "frank.steffahn@stu.uni-kiel.de", "date": "2022-02-10T10:42:02Z"}, "committer": {"name": "Frank Steffahn", "email": "frank.steffahn@stu.uni-kiel.de", "date": "2022-02-10T10:54:06Z"}, "message": "Make all hir::Map methods consistently by-value\n\n(hir::Map only consists of a single reference anyways)", "tree": {"sha": "7abc5d8a4eae1a69a280a0df6e677a850670cb7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7abc5d8a4eae1a69a280a0df6e677a850670cb7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89ac81a6e6f2b5e81e418f544c1efb73cc06d6f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89ac81a6e6f2b5e81e418f544c1efb73cc06d6f4", "html_url": "https://github.com/rust-lang/rust/commit/89ac81a6e6f2b5e81e418f544c1efb73cc06d6f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89ac81a6e6f2b5e81e418f544c1efb73cc06d6f4/comments", "author": {"login": "steffahn", "id": 3986214, "node_id": "MDQ6VXNlcjM5ODYyMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3986214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steffahn", "html_url": "https://github.com/steffahn", "followers_url": "https://api.github.com/users/steffahn/followers", "following_url": "https://api.github.com/users/steffahn/following{/other_user}", "gists_url": "https://api.github.com/users/steffahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/steffahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steffahn/subscriptions", "organizations_url": "https://api.github.com/users/steffahn/orgs", "repos_url": "https://api.github.com/users/steffahn/repos", "events_url": "https://api.github.com/users/steffahn/events{/privacy}", "received_events_url": "https://api.github.com/users/steffahn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steffahn", "id": 3986214, "node_id": "MDQ6VXNlcjM5ODYyMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3986214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steffahn", "html_url": "https://github.com/steffahn", "followers_url": "https://api.github.com/users/steffahn/followers", "following_url": "https://api.github.com/users/steffahn/following{/other_user}", "gists_url": "https://api.github.com/users/steffahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/steffahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steffahn/subscriptions", "organizations_url": "https://api.github.com/users/steffahn/orgs", "repos_url": "https://api.github.com/users/steffahn/repos", "events_url": "https://api.github.com/users/steffahn/events{/privacy}", "received_events_url": "https://api.github.com/users/steffahn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d6ee0db96aada145725838379f909bbb8aa2312", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d6ee0db96aada145725838379f909bbb8aa2312", "html_url": "https://github.com/rust-lang/rust/commit/5d6ee0db96aada145725838379f909bbb8aa2312"}], "stats": {"total": 168, "additions": 84, "deletions": 84}, "files": [{"sha": "c55f2a7b03941461ed0e9ca824d69da656f99532", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/89ac81a6e6f2b5e81e418f544c1efb73cc06d6f4/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89ac81a6e6f2b5e81e418f544c1efb73cc06d6f4/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=89ac81a6e6f2b5e81e418f544c1efb73cc06d6f4", "patch": "@@ -141,22 +141,22 @@ pub trait Map<'hir> {\n // Used when no map is actually available, forcing manual implementation of nested visitors.\n impl<'hir> Map<'hir> for ! {\n     fn find(&self, _: HirId) -> Option<Node<'hir>> {\n-        unreachable!()\n+        *self;\n     }\n     fn body(&self, _: BodyId) -> &'hir Body<'hir> {\n-        unreachable!()\n+        *self;\n     }\n     fn item(&self, _: ItemId) -> &'hir Item<'hir> {\n-        unreachable!()\n+        *self;\n     }\n     fn trait_item(&self, _: TraitItemId) -> &'hir TraitItem<'hir> {\n-        unreachable!()\n+        *self;\n     }\n     fn impl_item(&self, _: ImplItemId) -> &'hir ImplItem<'hir> {\n-        unreachable!()\n+        *self;\n     }\n     fn foreign_item(&self, _: ForeignItemId) -> &'hir ForeignItem<'hir> {\n-        unreachable!()\n+        *self;\n     }\n }\n "}, {"sha": "f36847c778109249544df0d16fc5b77532854aa4", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/89ac81a6e6f2b5e81e418f544c1efb73cc06d6f4/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89ac81a6e6f2b5e81e418f544c1efb73cc06d6f4/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=89ac81a6e6f2b5e81e418f544c1efb73cc06d6f4", "patch": "@@ -149,35 +149,35 @@ impl<'hir> Iterator for ParentOwnerIterator<'hir> {\n }\n \n impl<'hir> Map<'hir> {\n-    pub fn krate(&self) -> &'hir Crate<'hir> {\n+    pub fn krate(self) -> &'hir Crate<'hir> {\n         self.tcx.hir_crate(())\n     }\n \n-    pub fn root_module(&self) -> &'hir Mod<'hir> {\n+    pub fn root_module(self) -> &'hir Mod<'hir> {\n         match self.tcx.hir_owner(CRATE_DEF_ID).map(|o| o.node) {\n             Some(OwnerNode::Crate(item)) => item,\n             _ => bug!(),\n         }\n     }\n \n-    pub fn items(&self) -> impl Iterator<Item = &'hir Item<'hir>> + 'hir {\n+    pub fn items(self) -> impl Iterator<Item = &'hir Item<'hir>> + 'hir {\n         let krate = self.krate();\n         krate.owners.iter().filter_map(|owner| match owner.as_owner()?.node() {\n             OwnerNode::Item(item) => Some(item),\n             _ => None,\n         })\n     }\n \n-    pub fn def_key(&self, def_id: LocalDefId) -> DefKey {\n+    pub fn def_key(self, def_id: LocalDefId) -> DefKey {\n         // Accessing the DefKey is ok, since it is part of DefPathHash.\n         self.tcx.untracked_resolutions.definitions.def_key(def_id)\n     }\n \n-    pub fn def_path_from_hir_id(&self, id: HirId) -> Option<DefPath> {\n+    pub fn def_path_from_hir_id(self, id: HirId) -> Option<DefPath> {\n         self.opt_local_def_id(id).map(|def_id| self.def_path(def_id))\n     }\n \n-    pub fn def_path(&self, def_id: LocalDefId) -> DefPath {\n+    pub fn def_path(self, def_id: LocalDefId) -> DefPath {\n         // Accessing the DefPath is ok, since it is part of DefPathHash.\n         self.tcx.untracked_resolutions.definitions.def_path(def_id)\n     }\n@@ -189,7 +189,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     #[inline]\n-    pub fn local_def_id(&self, hir_id: HirId) -> LocalDefId {\n+    pub fn local_def_id(self, hir_id: HirId) -> LocalDefId {\n         self.opt_local_def_id(hir_id).unwrap_or_else(|| {\n             bug!(\n                 \"local_def_id: no entry for `{:?}`, which has a map of `{:?}`\",\n@@ -200,7 +200,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     #[inline]\n-    pub fn opt_local_def_id(&self, hir_id: HirId) -> Option<LocalDefId> {\n+    pub fn opt_local_def_id(self, hir_id: HirId) -> Option<LocalDefId> {\n         if hir_id.local_id == ItemLocalId::new(0) {\n             Some(hir_id.owner)\n         } else {\n@@ -214,18 +214,18 @@ impl<'hir> Map<'hir> {\n     }\n \n     #[inline]\n-    pub fn local_def_id_to_hir_id(&self, def_id: LocalDefId) -> HirId {\n+    pub fn local_def_id_to_hir_id(self, def_id: LocalDefId) -> HirId {\n         self.tcx.local_def_id_to_hir_id(def_id)\n     }\n \n-    pub fn iter_local_def_id(&self) -> impl Iterator<Item = LocalDefId> + '_ {\n+    pub fn iter_local_def_id(self) -> impl Iterator<Item = LocalDefId> + 'hir {\n         // Create a dependency to the crate to be sure we reexcute this when the amount of\n         // definitions change.\n         self.tcx.ensure().hir_crate(());\n         self.tcx.untracked_resolutions.definitions.iter_local_def_id()\n     }\n \n-    pub fn opt_def_kind(&self, local_def_id: LocalDefId) -> Option<DefKind> {\n+    pub fn opt_def_kind(self, local_def_id: LocalDefId) -> Option<DefKind> {\n         let hir_id = self.local_def_id_to_hir_id(local_def_id);\n         let def_kind = match self.find(hir_id)? {\n             Node::Item(item) => match item.kind {\n@@ -312,12 +312,12 @@ impl<'hir> Map<'hir> {\n         Some(def_kind)\n     }\n \n-    pub fn def_kind(&self, local_def_id: LocalDefId) -> DefKind {\n+    pub fn def_kind(self, local_def_id: LocalDefId) -> DefKind {\n         self.opt_def_kind(local_def_id)\n             .unwrap_or_else(|| bug!(\"def_kind: unsupported node: {:?}\", local_def_id))\n     }\n \n-    pub fn find_parent_node(&self, id: HirId) -> Option<HirId> {\n+    pub fn find_parent_node(self, id: HirId) -> Option<HirId> {\n         if id.local_id == ItemLocalId::from_u32(0) {\n             Some(self.tcx.hir_owner_parent(id.owner))\n         } else {\n@@ -328,12 +328,12 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn get_parent_node(&self, hir_id: HirId) -> HirId {\n+    pub fn get_parent_node(self, hir_id: HirId) -> HirId {\n         self.find_parent_node(hir_id).unwrap()\n     }\n \n     /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n-    pub fn find(&self, id: HirId) -> Option<Node<'hir>> {\n+    pub fn find(self, id: HirId) -> Option<Node<'hir>> {\n         if id.local_id == ItemLocalId::from_u32(0) {\n             let owner = self.tcx.hir_owner(id.owner)?;\n             Some(owner.node.into())\n@@ -346,26 +346,26 @@ impl<'hir> Map<'hir> {\n \n     /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n     #[inline]\n-    pub fn find_by_def_id(&self, id: LocalDefId) -> Option<Node<'hir>> {\n+    pub fn find_by_def_id(self, id: LocalDefId) -> Option<Node<'hir>> {\n         self.find(self.local_def_id_to_hir_id(id))\n     }\n \n     /// Retrieves the `Node` corresponding to `id`, panicking if it cannot be found.\n-    pub fn get(&self, id: HirId) -> Node<'hir> {\n+    pub fn get(self, id: HirId) -> Node<'hir> {\n         self.find(id).unwrap_or_else(|| bug!(\"couldn't find hir id {} in the HIR map\", id))\n     }\n \n     /// Retrieves the `Node` corresponding to `id`, panicking if it cannot be found.\n     #[inline]\n-    pub fn get_by_def_id(&self, id: LocalDefId) -> Node<'hir> {\n+    pub fn get_by_def_id(self, id: LocalDefId) -> Node<'hir> {\n         self.find_by_def_id(id).unwrap_or_else(|| bug!(\"couldn't find {:?} in the HIR map\", id))\n     }\n \n-    pub fn get_if_local(&self, id: DefId) -> Option<Node<'hir>> {\n+    pub fn get_if_local(self, id: DefId) -> Option<Node<'hir>> {\n         id.as_local().and_then(|id| self.find(self.local_def_id_to_hir_id(id)))\n     }\n \n-    pub fn get_generics(&self, id: LocalDefId) -> Option<&'hir Generics<'hir>> {\n+    pub fn get_generics(self, id: LocalDefId) -> Option<&'hir Generics<'hir>> {\n         let node = self.tcx.hir_owner(id)?;\n         match node.node {\n             OwnerNode::ImplItem(impl_item) => Some(&impl_item.generics),\n@@ -386,43 +386,43 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn item(&self, id: ItemId) -> &'hir Item<'hir> {\n+    pub fn item(self, id: ItemId) -> &'hir Item<'hir> {\n         self.tcx.hir_owner(id.def_id).unwrap().node.expect_item()\n     }\n \n-    pub fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem<'hir> {\n+    pub fn trait_item(self, id: TraitItemId) -> &'hir TraitItem<'hir> {\n         self.tcx.hir_owner(id.def_id).unwrap().node.expect_trait_item()\n     }\n \n-    pub fn impl_item(&self, id: ImplItemId) -> &'hir ImplItem<'hir> {\n+    pub fn impl_item(self, id: ImplItemId) -> &'hir ImplItem<'hir> {\n         self.tcx.hir_owner(id.def_id).unwrap().node.expect_impl_item()\n     }\n \n-    pub fn foreign_item(&self, id: ForeignItemId) -> &'hir ForeignItem<'hir> {\n+    pub fn foreign_item(self, id: ForeignItemId) -> &'hir ForeignItem<'hir> {\n         self.tcx.hir_owner(id.def_id).unwrap().node.expect_foreign_item()\n     }\n \n-    pub fn body(&self, id: BodyId) -> &'hir Body<'hir> {\n+    pub fn body(self, id: BodyId) -> &'hir Body<'hir> {\n         self.tcx.hir_owner_nodes(id.hir_id.owner).unwrap().bodies[&id.hir_id.local_id]\n     }\n \n-    pub fn fn_decl_by_hir_id(&self, hir_id: HirId) -> Option<&'hir FnDecl<'hir>> {\n+    pub fn fn_decl_by_hir_id(self, hir_id: HirId) -> Option<&'hir FnDecl<'hir>> {\n         if let Some(node) = self.find(hir_id) {\n             fn_decl(node)\n         } else {\n             bug!(\"no node for hir_id `{}`\", hir_id)\n         }\n     }\n \n-    pub fn fn_sig_by_hir_id(&self, hir_id: HirId) -> Option<&'hir FnSig<'hir>> {\n+    pub fn fn_sig_by_hir_id(self, hir_id: HirId) -> Option<&'hir FnSig<'hir>> {\n         if let Some(node) = self.find(hir_id) {\n             fn_sig(node)\n         } else {\n             bug!(\"no node for hir_id `{}`\", hir_id)\n         }\n     }\n \n-    pub fn enclosing_body_owner(&self, hir_id: HirId) -> HirId {\n+    pub fn enclosing_body_owner(self, hir_id: HirId) -> HirId {\n         for (parent, _) in self.parent_iter(hir_id) {\n             if let Some(body) = self.maybe_body_owned_by(parent) {\n                 return self.body_owner(body);\n@@ -435,24 +435,24 @@ impl<'hir> Map<'hir> {\n     /// Returns the `HirId` that corresponds to the definition of\n     /// which this is the body of, i.e., a `fn`, `const` or `static`\n     /// item (possibly associated), a closure, or a `hir::AnonConst`.\n-    pub fn body_owner(&self, BodyId { hir_id }: BodyId) -> HirId {\n+    pub fn body_owner(self, BodyId { hir_id }: BodyId) -> HirId {\n         let parent = self.get_parent_node(hir_id);\n         assert!(self.find(parent).map_or(false, |n| is_body_owner(n, hir_id)));\n         parent\n     }\n \n-    pub fn body_owner_def_id(&self, id: BodyId) -> LocalDefId {\n+    pub fn body_owner_def_id(self, id: BodyId) -> LocalDefId {\n         self.local_def_id(self.body_owner(id))\n     }\n \n     /// Given a `HirId`, returns the `BodyId` associated with it,\n     /// if the node is a body owner, otherwise returns `None`.\n-    pub fn maybe_body_owned_by(&self, hir_id: HirId) -> Option<BodyId> {\n+    pub fn maybe_body_owned_by(self, hir_id: HirId) -> Option<BodyId> {\n         self.find(hir_id).map(associated_body).flatten()\n     }\n \n     /// Given a body owner's id, returns the `BodyId` associated with it.\n-    pub fn body_owned_by(&self, id: HirId) -> BodyId {\n+    pub fn body_owned_by(self, id: HirId) -> BodyId {\n         self.maybe_body_owned_by(id).unwrap_or_else(|| {\n             span_bug!(\n                 self.span(id),\n@@ -462,7 +462,7 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n-    pub fn body_param_names(&self, id: BodyId) -> impl Iterator<Item = Ident> + 'hir {\n+    pub fn body_param_names(self, id: BodyId) -> impl Iterator<Item = Ident> + 'hir {\n         self.body(id).params.iter().map(|arg| match arg.pat.kind {\n             PatKind::Binding(_, _, ident, _) => ident,\n             _ => Ident::empty(),\n@@ -472,7 +472,7 @@ impl<'hir> Map<'hir> {\n     /// Returns the `BodyOwnerKind` of this `LocalDefId`.\n     ///\n     /// Panics if `LocalDefId` does not have an associated body.\n-    pub fn body_owner_kind(&self, id: HirId) -> BodyOwnerKind {\n+    pub fn body_owner_kind(self, id: HirId) -> BodyOwnerKind {\n         match self.get(id) {\n             Node::Item(&Item { kind: ItemKind::Const(..), .. })\n             | Node::TraitItem(&TraitItem { kind: TraitItemKind::Const(..), .. })\n@@ -495,7 +495,7 @@ impl<'hir> Map<'hir> {\n     /// This should only be used for determining the context of a body, a return\n     /// value of `Some` does not always suggest that the owner of the body is `const`,\n     /// just that it has to be checked as if it were.\n-    pub fn body_const_context(&self, did: LocalDefId) -> Option<ConstContext> {\n+    pub fn body_const_context(self, did: LocalDefId) -> Option<ConstContext> {\n         let hir_id = self.local_def_id_to_hir_id(did);\n         let ccx = match self.body_owner_kind(hir_id) {\n             BodyOwnerKind::Const => ConstContext::Const,\n@@ -549,7 +549,7 @@ impl<'hir> Map<'hir> {\n         });\n     }\n \n-    pub fn ty_param_owner(&self, id: HirId) -> LocalDefId {\n+    pub fn ty_param_owner(self, id: HirId) -> LocalDefId {\n         match self.get(id) {\n             Node::Item(&Item { kind: ItemKind::Trait(..) | ItemKind::TraitAlias(..), .. }) => {\n                 id.expect_owner()\n@@ -559,7 +559,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn ty_param_name(&self, id: HirId) -> Symbol {\n+    pub fn ty_param_name(self, id: HirId) -> Symbol {\n         match self.get(id) {\n             Node::Item(&Item { kind: ItemKind::Trait(..) | ItemKind::TraitAlias(..), .. }) => {\n                 kw::SelfUpper\n@@ -569,18 +569,18 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn trait_impls(&self, trait_did: DefId) -> &'hir [LocalDefId] {\n+    pub fn trait_impls(self, trait_did: DefId) -> &'hir [LocalDefId] {\n         self.tcx.all_local_trait_impls(()).get(&trait_did).map_or(&[], |xs| &xs[..])\n     }\n \n     /// Gets the attributes on the crate. This is preferable to\n     /// invoking `krate.attrs` because it registers a tighter\n     /// dep-graph access.\n-    pub fn krate_attrs(&self) -> &'hir [ast::Attribute] {\n+    pub fn krate_attrs(self) -> &'hir [ast::Attribute] {\n         self.attrs(CRATE_HIR_ID)\n     }\n \n-    pub fn get_module(&self, module: LocalDefId) -> (&'hir Mod<'hir>, Span, HirId) {\n+    pub fn get_module(self, module: LocalDefId) -> (&'hir Mod<'hir>, Span, HirId) {\n         let hir_id = HirId::make_owner(module);\n         match self.tcx.hir_owner(module).map(|o| o.node) {\n             Some(OwnerNode::Item(&Item { span, kind: ItemKind::Mod(ref m), .. })) => {\n@@ -620,7 +620,7 @@ impl<'hir> Map<'hir> {\n     /// follows lexical scoping rules -- then you want a different\n     /// approach. You should override `visit_nested_item` in your\n     /// visitor and then call `intravisit::walk_crate` instead.\n-    pub fn visit_all_item_likes<V>(&self, visitor: &mut V)\n+    pub fn visit_all_item_likes<V>(self, visitor: &mut V)\n     where\n         V: itemlikevisit::ItemLikeVisitor<'hir>,\n     {\n@@ -637,7 +637,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     /// A parallel version of `visit_all_item_likes`.\n-    pub fn par_visit_all_item_likes<V>(&self, visitor: &V)\n+    pub fn par_visit_all_item_likes<V>(self, visitor: &V)\n     where\n         V: itemlikevisit::ParItemLikeVisitor<'hir> + Sync + Send,\n     {\n@@ -653,7 +653,7 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n-    pub fn visit_item_likes_in_module<V>(&self, module: LocalDefId, visitor: &mut V)\n+    pub fn visit_item_likes_in_module<V>(self, module: LocalDefId, visitor: &mut V)\n     where\n         V: ItemLikeVisitor<'hir>,\n     {\n@@ -676,7 +676,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn for_each_module(&self, f: impl Fn(LocalDefId)) {\n+    pub fn for_each_module(self, f: impl Fn(LocalDefId)) {\n         let mut queue = VecDeque::new();\n         queue.push_back(CRATE_DEF_ID);\n \n@@ -689,12 +689,12 @@ impl<'hir> Map<'hir> {\n \n     #[cfg(not(parallel_compiler))]\n     #[inline]\n-    pub fn par_for_each_module(&self, f: impl Fn(LocalDefId)) {\n+    pub fn par_for_each_module(self, f: impl Fn(LocalDefId)) {\n         self.for_each_module(f)\n     }\n \n     #[cfg(parallel_compiler)]\n-    pub fn par_for_each_module(&self, f: impl Fn(LocalDefId) + Sync) {\n+    pub fn par_for_each_module(self, f: impl Fn(LocalDefId) + Sync) {\n         use rustc_data_structures::sync::{par_iter, ParallelIterator};\n         par_iter_submodules(self.tcx, CRATE_DEF_ID, &f);\n \n@@ -721,7 +721,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     /// Checks if the node is left-hand side of an assignment.\n-    pub fn is_lhs(&self, id: HirId) -> bool {\n+    pub fn is_lhs(self, id: HirId) -> bool {\n         match self.find(self.get_parent_node(id)) {\n             Some(Node::Expr(expr)) => match expr.kind {\n                 ExprKind::Assign(lhs, _rhs, _span) => lhs.hir_id == id,\n@@ -733,7 +733,7 @@ impl<'hir> Map<'hir> {\n \n     /// Whether the expression pointed at by `hir_id` belongs to a `const` evaluation context.\n     /// Used exclusively for diagnostics, to avoid suggestion function calls.\n-    pub fn is_inside_const_context(&self, hir_id: HirId) -> bool {\n+    pub fn is_inside_const_context(self, hir_id: HirId) -> bool {\n         self.body_const_context(self.local_def_id(self.enclosing_body_owner(hir_id))).is_some()\n     }\n \n@@ -759,7 +759,7 @@ impl<'hir> Map<'hir> {\n     ///     false\n     /// }\n     /// ```\n-    pub fn get_return_block(&self, id: HirId) -> Option<HirId> {\n+    pub fn get_return_block(self, id: HirId) -> Option<HirId> {\n         let mut iter = self.parent_iter(id).peekable();\n         let mut ignore_tail = false;\n         if let Some(node) = self.find(id) {\n@@ -799,7 +799,7 @@ impl<'hir> Map<'hir> {\n     /// parent item is in this map. The \"parent item\" is the closest parent node\n     /// in the HIR which is recorded by the map and is an item, either an item\n     /// in a module, trait, or impl.\n-    pub fn get_parent_item(&self, hir_id: HirId) -> LocalDefId {\n+    pub fn get_parent_item(self, hir_id: HirId) -> LocalDefId {\n         if let Some((def_id, _node)) = self.parent_owner_iter(hir_id).next() {\n             def_id\n         } else {\n@@ -809,7 +809,7 @@ impl<'hir> Map<'hir> {\n \n     /// Returns the `HirId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n-    pub(super) fn get_module_parent_node(&self, hir_id: HirId) -> LocalDefId {\n+    pub(super) fn get_module_parent_node(self, hir_id: HirId) -> LocalDefId {\n         for (def_id, node) in self.parent_owner_iter(hir_id) {\n             if let OwnerNode::Item(&Item { kind: ItemKind::Mod(_), .. }) = node {\n                 return def_id;\n@@ -823,7 +823,7 @@ impl<'hir> Map<'hir> {\n     ///\n     /// Used by error reporting when there's a type error in an if or match arm caused by the\n     /// expression needing to be unit.\n-    pub fn get_if_cause(&self, hir_id: HirId) -> Option<&'hir Expr<'hir>> {\n+    pub fn get_if_cause(self, hir_id: HirId) -> Option<&'hir Expr<'hir>> {\n         for (_, node) in self.parent_iter(hir_id) {\n             match node {\n                 Node::Item(_)\n@@ -841,7 +841,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     /// Returns the nearest enclosing scope. A scope is roughly an item or block.\n-    pub fn get_enclosing_scope(&self, hir_id: HirId) -> Option<HirId> {\n+    pub fn get_enclosing_scope(self, hir_id: HirId) -> Option<HirId> {\n         for (hir_id, node) in self.parent_iter(hir_id) {\n             if let Node::Item(Item {\n                 kind:\n@@ -868,7 +868,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     /// Returns the defining scope for an opaque type definition.\n-    pub fn get_defining_scope(&self, id: HirId) -> HirId {\n+    pub fn get_defining_scope(self, id: HirId) -> HirId {\n         let mut scope = id;\n         loop {\n             scope = self.get_enclosing_scope(scope).unwrap_or(CRATE_HIR_ID);\n@@ -878,7 +878,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn get_foreign_abi(&self, hir_id: HirId) -> Abi {\n+    pub fn get_foreign_abi(self, hir_id: HirId) -> Abi {\n         let parent = self.get_parent_item(hir_id);\n         if let Some(node) = self.tcx.hir_owner(parent) {\n             if let OwnerNode::Item(Item { kind: ItemKind::ForeignMod { abi, .. }, .. }) = node.node\n@@ -892,35 +892,35 @@ impl<'hir> Map<'hir> {\n         )\n     }\n \n-    pub fn expect_item(&self, id: LocalDefId) -> &'hir Item<'hir> {\n+    pub fn expect_item(self, id: LocalDefId) -> &'hir Item<'hir> {\n         match self.tcx.hir_owner(id) {\n             Some(Owner { node: OwnerNode::Item(item), .. }) => item,\n             _ => bug!(\"expected item, found {}\", self.node_to_string(HirId::make_owner(id))),\n         }\n     }\n \n-    pub fn expect_impl_item(&self, id: LocalDefId) -> &'hir ImplItem<'hir> {\n+    pub fn expect_impl_item(self, id: LocalDefId) -> &'hir ImplItem<'hir> {\n         match self.tcx.hir_owner(id) {\n             Some(Owner { node: OwnerNode::ImplItem(item), .. }) => item,\n             _ => bug!(\"expected impl item, found {}\", self.node_to_string(HirId::make_owner(id))),\n         }\n     }\n \n-    pub fn expect_trait_item(&self, id: LocalDefId) -> &'hir TraitItem<'hir> {\n+    pub fn expect_trait_item(self, id: LocalDefId) -> &'hir TraitItem<'hir> {\n         match self.tcx.hir_owner(id) {\n             Some(Owner { node: OwnerNode::TraitItem(item), .. }) => item,\n             _ => bug!(\"expected trait item, found {}\", self.node_to_string(HirId::make_owner(id))),\n         }\n     }\n \n-    pub fn expect_variant(&self, id: HirId) -> &'hir Variant<'hir> {\n+    pub fn expect_variant(self, id: HirId) -> &'hir Variant<'hir> {\n         match self.find(id) {\n             Some(Node::Variant(variant)) => variant,\n             _ => bug!(\"expected variant, found {}\", self.node_to_string(id)),\n         }\n     }\n \n-    pub fn expect_foreign_item(&self, id: LocalDefId) -> &'hir ForeignItem<'hir> {\n+    pub fn expect_foreign_item(self, id: LocalDefId) -> &'hir ForeignItem<'hir> {\n         match self.tcx.hir_owner(id) {\n             Some(Owner { node: OwnerNode::ForeignItem(item), .. }) => item,\n             _ => {\n@@ -929,14 +929,14 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn expect_expr(&self, id: HirId) -> &'hir Expr<'hir> {\n+    pub fn expect_expr(self, id: HirId) -> &'hir Expr<'hir> {\n         match self.find(id) {\n             Some(Node::Expr(expr)) => expr,\n             _ => bug!(\"expected expr, found {}\", self.node_to_string(id)),\n         }\n     }\n \n-    pub fn opt_name(&self, id: HirId) -> Option<Symbol> {\n+    pub fn opt_name(self, id: HirId) -> Option<Symbol> {\n         Some(match self.get(id) {\n             Node::Item(i) => i.ident.name,\n             Node::ForeignItem(fi) => fi.ident.name,\n@@ -952,7 +952,7 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n-    pub fn name(&self, id: HirId) -> Symbol {\n+    pub fn name(self, id: HirId) -> Symbol {\n         match self.opt_name(id) {\n             Some(name) => name,\n             None => bug!(\"no name for {}\", self.node_to_string(id)),\n@@ -961,18 +961,18 @@ impl<'hir> Map<'hir> {\n \n     /// Given a node ID, gets a list of attributes associated with the AST\n     /// corresponding to the node-ID.\n-    pub fn attrs(&self, id: HirId) -> &'hir [ast::Attribute] {\n+    pub fn attrs(self, id: HirId) -> &'hir [ast::Attribute] {\n         self.tcx.hir_attrs(id.owner).get(id.local_id)\n     }\n \n     /// Gets the span of the definition of the specified HIR node.\n     /// This is used by `tcx.get_span`\n-    pub fn span(&self, hir_id: HirId) -> Span {\n+    pub fn span(self, hir_id: HirId) -> Span {\n         self.opt_span(hir_id)\n             .unwrap_or_else(|| bug!(\"hir::map::Map::span: id not in map: {:?}\", hir_id))\n     }\n \n-    pub fn opt_span(&self, hir_id: HirId) -> Option<Span> {\n+    pub fn opt_span(self, hir_id: HirId) -> Option<Span> {\n         let span = match self.find(hir_id)? {\n             Node::Param(param) => param.span,\n             Node::Item(item) => match &item.kind {\n@@ -1021,7 +1021,7 @@ impl<'hir> Map<'hir> {\n \n     /// Like `hir.span()`, but includes the body of function items\n     /// (instead of just the function header)\n-    pub fn span_with_body(&self, hir_id: HirId) -> Span {\n+    pub fn span_with_body(self, hir_id: HirId) -> Span {\n         match self.find(hir_id) {\n             Some(Node::TraitItem(item)) => item.span,\n             Some(Node::ImplItem(impl_item)) => impl_item.span,\n@@ -1031,11 +1031,11 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn span_if_local(&self, id: DefId) -> Option<Span> {\n+    pub fn span_if_local(self, id: DefId) -> Option<Span> {\n         id.as_local().and_then(|id| self.opt_span(self.local_def_id_to_hir_id(id)))\n     }\n \n-    pub fn res_span(&self, res: Res) -> Option<Span> {\n+    pub fn res_span(self, res: Res) -> Option<Span> {\n         match res {\n             Res::Err => None,\n             Res::Local(id) => Some(self.span(id)),\n@@ -1045,13 +1045,13 @@ impl<'hir> Map<'hir> {\n \n     /// Get a representation of this `id` for debugging purposes.\n     /// NOTE: Do NOT use this in diagnostics!\n-    pub fn node_to_string(&self, id: HirId) -> String {\n+    pub fn node_to_string(self, id: HirId) -> String {\n         hir_id_to_string(self, id)\n     }\n \n     /// Returns the HirId of `N` in `struct Foo<const N: usize = { ... }>` when\n     /// called with the HirId for the `{ ... }` anon const\n-    pub fn opt_const_param_default_param_hir_id(&self, anon_const: HirId) -> Option<HirId> {\n+    pub fn opt_const_param_default_param_hir_id(self, anon_const: HirId) -> Option<HirId> {\n         match self.get(self.get_parent_node(anon_const)) {\n             Node::GenericParam(GenericParam {\n                 hir_id: param_id,\n@@ -1065,27 +1065,27 @@ impl<'hir> Map<'hir> {\n \n impl<'hir> intravisit::Map<'hir> for Map<'hir> {\n     fn find(&self, hir_id: HirId) -> Option<Node<'hir>> {\n-        self.find(hir_id)\n+        (*self).find(hir_id)\n     }\n \n     fn body(&self, id: BodyId) -> &'hir Body<'hir> {\n-        self.body(id)\n+        (*self).body(id)\n     }\n \n     fn item(&self, id: ItemId) -> &'hir Item<'hir> {\n-        self.item(id)\n+        (*self).item(id)\n     }\n \n     fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem<'hir> {\n-        self.trait_item(id)\n+        (*self).trait_item(id)\n     }\n \n     fn impl_item(&self, id: ImplItemId) -> &'hir ImplItem<'hir> {\n-        self.impl_item(id)\n+        (*self).impl_item(id)\n     }\n \n     fn foreign_item(&self, id: ForeignItemId) -> &'hir ForeignItem<'hir> {\n-        self.foreign_item(id)\n+        (*self).foreign_item(id)\n     }\n }\n \n@@ -1154,7 +1154,7 @@ fn upstream_crates(tcx: TyCtxt<'_>) -> Vec<(StableCrateId, Svh)> {\n     upstream_crates\n }\n \n-fn hir_id_to_string(map: &Map<'_>, id: HirId) -> String {\n+fn hir_id_to_string(map: Map<'_>, id: HirId) -> String {\n     let id_str = format!(\" (hir_id={})\", id);\n \n     let path_str = || {"}]}