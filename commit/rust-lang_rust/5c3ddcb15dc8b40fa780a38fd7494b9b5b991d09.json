{"sha": "5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjM2RkY2IxNWRjOGI0MGZhNzgwYTM4ZmQ3NDk0YjliNWI5OTFkMDk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T23:22:24Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T23:22:24Z"}, "message": "rollup merge of #20481: seanmonstar/fmt-show-string\n\nConflicts:\n\tsrc/compiletest/runtest.rs\n\tsrc/libcore/fmt/mod.rs\n\tsrc/libfmt_macros/lib.rs\n\tsrc/libregex/parse.rs\n\tsrc/librustc/middle/cfg/construct.rs\n\tsrc/librustc/middle/dataflow.rs\n\tsrc/librustc/middle/infer/higher_ranked/mod.rs\n\tsrc/librustc/middle/ty.rs\n\tsrc/librustc_back/archive.rs\n\tsrc/librustc_borrowck/borrowck/fragments.rs\n\tsrc/librustc_borrowck/borrowck/gather_loans/mod.rs\n\tsrc/librustc_resolve/lib.rs\n\tsrc/librustc_trans/back/link.rs\n\tsrc/librustc_trans/save/mod.rs\n\tsrc/librustc_trans/trans/base.rs\n\tsrc/librustc_trans/trans/callee.rs\n\tsrc/librustc_trans/trans/common.rs\n\tsrc/librustc_trans/trans/consts.rs\n\tsrc/librustc_trans/trans/controlflow.rs\n\tsrc/librustc_trans/trans/debuginfo.rs\n\tsrc/librustc_trans/trans/expr.rs\n\tsrc/librustc_trans/trans/monomorphize.rs\n\tsrc/librustc_typeck/astconv.rs\n\tsrc/librustc_typeck/check/method/mod.rs\n\tsrc/librustc_typeck/check/mod.rs\n\tsrc/librustc_typeck/check/regionck.rs\n\tsrc/librustc_typeck/collect.rs\n\tsrc/libsyntax/ext/format.rs\n\tsrc/libsyntax/ext/source_util.rs\n\tsrc/libsyntax/ext/tt/transcribe.rs\n\tsrc/libsyntax/parse/mod.rs\n\tsrc/libsyntax/parse/token.rs\n\tsrc/test/run-pass/issue-8898.rs", "tree": {"sha": "9ad6d0c242e45a785dae4b22f1e4ddd9d4f9c55a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ad6d0c242e45a785dae4b22f1e4ddd9d4f9c55a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "html_url": "https://github.com/rust-lang/rust/commit/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f27b500800fc2720c5caa4a0cd5dcc46c0b911f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f27b500800fc2720c5caa4a0cd5dcc46c0b911f", "html_url": "https://github.com/rust-lang/rust/commit/5f27b500800fc2720c5caa4a0cd5dcc46c0b911f"}, {"sha": "44440e5c18a1dbcc9685866ffffe00c508929079", "url": "https://api.github.com/repos/rust-lang/rust/commits/44440e5c18a1dbcc9685866ffffe00c508929079", "html_url": "https://github.com/rust-lang/rust/commit/44440e5c18a1dbcc9685866ffffe00c508929079"}], "stats": {"total": 4793, "additions": 2712, "deletions": 2081}, "files": [{"sha": "c29f74d74181087ab05ef8f6f6e79af20fdc6670", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -43,9 +43,9 @@ impl FromStr for Mode {\n     }\n }\n \n-impl fmt::Show for Mode {\n+impl fmt::String for Mode {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let msg = match *self {\n+        fmt::String::fmt(match *self {\n             CompileFail => \"compile-fail\",\n             RunFail => \"run-fail\",\n             RunPass => \"run-pass\",\n@@ -54,8 +54,13 @@ impl fmt::Show for Mode {\n             DebugInfoGdb => \"debuginfo-gdb\",\n             DebugInfoLldb => \"debuginfo-lldb\",\n             Codegen => \"codegen\",\n-        };\n-        msg.fmt(f)\n+        }, f)\n+    }\n+}\n+\n+impl fmt::Show for Mode {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n     }\n }\n "}, {"sha": "23674efe9683fcea978e1c4719f983b8e5e58032", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -108,7 +108,7 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n     let matches =\n         &match getopts::getopts(args_.as_slice(), groups.as_slice()) {\n           Ok(m) => m,\n-          Err(f) => panic!(\"{}\", f)\n+          Err(f) => panic!(\"{:?}\", f)\n         };\n \n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n@@ -127,7 +127,7 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n         match regex::Regex::new(s) {\n             Ok(re) => Some(re),\n             Err(e) => {\n-                println!(\"failed to parse filter /{}/: {}\", s, e);\n+                println!(\"failed to parse filter /{}/: {:?}\", s, e);\n                 panic!()\n             }\n         }\n@@ -186,11 +186,11 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n pub fn log_config(config: &Config) {\n     let c = config;\n     logv(c, format!(\"configuration:\"));\n-    logv(c, format!(\"compile_lib_path: {}\", config.compile_lib_path));\n-    logv(c, format!(\"run_lib_path: {}\", config.run_lib_path));\n-    logv(c, format!(\"rustc_path: {}\", config.rustc_path.display()));\n-    logv(c, format!(\"src_base: {}\", config.src_base.display()));\n-    logv(c, format!(\"build_base: {}\", config.build_base.display()));\n+    logv(c, format!(\"compile_lib_path: {:?}\", config.compile_lib_path));\n+    logv(c, format!(\"run_lib_path: {:?}\", config.run_lib_path));\n+    logv(c, format!(\"rustc_path: {:?}\", config.rustc_path.display()));\n+    logv(c, format!(\"src_base: {:?}\", config.src_base.display()));\n+    logv(c, format!(\"build_base: {:?}\", config.build_base.display()));\n     logv(c, format!(\"stage_id: {}\", config.stage_id));\n     logv(c, format!(\"mode: {}\", config.mode));\n     logv(c, format!(\"run_ignored: {}\", config.run_ignored));\n@@ -206,10 +206,10 @@ pub fn log_config(config: &Config) {\n     logv(c, format!(\"jit: {}\", config.jit));\n     logv(c, format!(\"target: {}\", config.target));\n     logv(c, format!(\"host: {}\", config.host));\n-    logv(c, format!(\"android-cross-path: {}\",\n+    logv(c, format!(\"android-cross-path: {:?}\",\n                     config.android_cross_path.display()));\n-    logv(c, format!(\"adb_path: {}\", config.adb_path));\n-    logv(c, format!(\"adb_test_dir: {}\", config.adb_test_dir));\n+    logv(c, format!(\"adb_path: {:?}\", config.adb_path));\n+    logv(c, format!(\"adb_test_dir: {:?}\", config.adb_test_dir));\n     logv(c, format!(\"adb_device_status: {}\",\n                     config.adb_device_status));\n     match config.test_shard {\n@@ -271,7 +271,7 @@ pub fn run_tests(config: &Config) {\n         Ok(true) => {}\n         Ok(false) => panic!(\"Some tests failed\"),\n         Err(e) => {\n-            println!(\"I/O failure during tests: {}\", e);\n+            println!(\"I/O failure during tests: {:?}\", e);\n         }\n     }\n }\n@@ -299,13 +299,13 @@ pub fn test_opts(config: &Config) -> test::TestOpts {\n }\n \n pub fn make_tests(config: &Config) -> Vec<test::TestDescAndFn> {\n-    debug!(\"making tests from {}\",\n+    debug!(\"making tests from {:?}\",\n            config.src_base.display());\n     let mut tests = Vec::new();\n     let dirs = fs::readdir(&config.src_base).unwrap();\n     for file in dirs.iter() {\n         let file = file.clone();\n-        debug!(\"inspecting file {}\", file.display());\n+        debug!(\"inspecting file {:?}\", file.display());\n         if is_test(config, &file) {\n             let t = make_test(config, &file, || {\n                 match config.mode {"}, {"sha": "dcfac688c7f62cd0083c919df1bf1c55209f9522", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -84,7 +84,7 @@ fn parse_expected(last_nonfollow_error: Option<uint>,\n             (which, line)\n         };\n \n-        debug!(\"line={} which={} kind={} msg={}\", line_num, which, kind, msg);\n+        debug!(\"line={} which={:?} kind={:?} msg={:?}\", line_num, which, kind, msg);\n         Some((which, ExpectedError { line: line,\n                                      kind: kind,\n                                      msg: msg, }))"}, {"sha": "8a27903259f92aceabbd5d6c4d1a75dee1abe933", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -61,7 +61,7 @@ pub fn run_metrics(config: Config, testfile: String, mm: &mut MetricMap) {\n         print!(\"\\n\\n\");\n     }\n     let testfile = Path::new(testfile);\n-    debug!(\"running {}\", testfile.display());\n+    debug!(\"running {:?}\", testfile.display());\n     let props = header::load_props(&testfile);\n     debug!(\"loaded props\");\n     match config.mode {\n@@ -141,7 +141,7 @@ fn check_correct_failure_status(proc_res: &ProcRes) {\n     static RUST_ERR: int = 101;\n     if !proc_res.status.matches_exit_status(RUST_ERR) {\n         fatal_proc_rec(\n-            format!(\"failure produced the wrong error: {}\",\n+            format!(\"failure produced the wrong error: {:?}\",\n                     proc_res.status).as_slice(),\n             proc_res);\n     }\n@@ -410,7 +410,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                          ],\n                          vec!((\"\".to_string(), \"\".to_string())),\n                          Some(\"\".to_string()))\n-                .expect(format!(\"failed to exec `{}`\", config.adb_path).as_slice());\n+                .expect(format!(\"failed to exec `{:?}`\", config.adb_path).as_slice());\n \n             procsrv::run(\"\",\n                          config.adb_path.as_slice(),\n@@ -422,7 +422,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                          ],\n                          vec!((\"\".to_string(), \"\".to_string())),\n                          Some(\"\".to_string()))\n-                .expect(format!(\"failed to exec `{}`\", config.adb_path).as_slice());\n+                .expect(format!(\"failed to exec `{:?}`\", config.adb_path).as_slice());\n \n             let adb_arg = format!(\"export LD_LIBRARY_PATH={}; \\\n                                    gdbserver :5039 {}/{}\",\n@@ -443,7 +443,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                                                       vec!((\"\".to_string(),\n                                                             \"\".to_string())),\n                                                       Some(\"\".to_string()))\n-                .expect(format!(\"failed to exec `{}`\", config.adb_path).as_slice());\n+                .expect(format!(\"failed to exec `{:?}`\", config.adb_path).as_slice());\n             loop {\n                 //waiting 1 second for gdbserver start\n                 timer::sleep(Duration::milliseconds(1000));\n@@ -481,7 +481,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                              debugger_opts.as_slice(),\n                              vec!((\"\".to_string(), \"\".to_string())),\n                              None)\n-                .expect(format!(\"failed to exec `{}`\", gdb_path).as_slice());\n+                .expect(format!(\"failed to exec `{:?}`\", gdb_path).as_slice());\n             let cmdline = {\n                 let cmdline = make_cmdline(\"\",\n                                            \"arm-linux-androideabi-gdb\",\n@@ -547,7 +547,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n \n             // Add line breakpoints\n             for line in breakpoint_lines.iter() {\n-                script_str.push_str(&format!(\"break '{}':{}\\n\",\n+                script_str.push_str(&format!(\"break '{:?}':{}\\n\",\n                                              testfile.filename_display(),\n                                              *line)[]);\n             }\n@@ -888,7 +888,7 @@ fn check_error_patterns(props: &TestProps,\n                         output_to_check: &str,\n                         proc_res: &ProcRes) {\n     if props.error_patterns.is_empty() {\n-        fatal(format!(\"no error pattern specified in {}\",\n+        fatal(format!(\"no error pattern specified in {:?}\",\n                       testfile.display()).as_slice());\n     }\n     let mut next_err_idx = 0u;\n@@ -954,7 +954,7 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n     }\n \n     let prefixes = expected_errors.iter().map(|ee| {\n-        format!(\"{}:{}:\", testfile.display(), ee.line)\n+        format!(\"{:?}:{}:\", testfile.display(), ee.line)\n     }).collect::<Vec<String> >();\n \n     #[cfg(windows)]\n@@ -1190,7 +1190,7 @@ fn compose_and_run_compiler(\n                                      None);\n         if !auxres.status.success() {\n             fatal_proc_rec(\n-                format!(\"auxiliary build of {} failed to compile: \",\n+                format!(\"auxiliary build of {:?} failed to compile: \",\n                         abs_ab.display()).as_slice(),\n                 &auxres);\n         }\n@@ -1600,7 +1600,7 @@ fn _arm_push_aux_shared_library(config: &Config, testfile: &Path) {\n                 .expect(format!(\"failed to exec `{}`\", config.adb_path).as_slice());\n \n             if config.verbose {\n-                println!(\"push ({}) {} {} {}\",\n+                println!(\"push ({}) {:?} {} {}\",\n                     config.target, file.display(),\n                     copy_result.out, copy_result.err);\n             }"}, {"sha": "7789620a64fe354964f23930d89fd3d11561ce46", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -581,7 +581,7 @@ impl<T: Eq> Eq for Arc<T> {}\n \n impl<T: fmt::Show> fmt::Show for Arc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        (**self).fmt(f)\n+        write!(f, \"Arc({:?})\", (**self))\n     }\n }\n \n@@ -794,7 +794,7 @@ mod tests {\n     #[test]\n     fn show_arc() {\n         let a = Arc::new(5u32);\n-        assert!(format!(\"{}\", a) == \"5\")\n+        assert!(format!(\"{:?}\", a) == \"Arc(5u32)\")\n     }\n \n     // Make sure deriving works with Arc<T>"}, {"sha": "37827e6311a79ef5b3e4a6c94a7feb4ce025f0dc", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -145,7 +145,13 @@ impl BoxAny for Box<Any> {\n \n impl<T: ?Sized + fmt::Show> fmt::Show for Box<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        (**self).fmt(f)\n+        write!(f, \"Box({:?})\", &**self)\n+    }\n+}\n+\n+impl<T: ?Sized + fmt::String> fmt::String for Box<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(&**self, f)\n     }\n }\n "}, {"sha": "91566e89a1642589a1084adebd93bc1812444f20", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -607,7 +607,7 @@ impl<S: hash::Writer, T: Hash<S>> Hash<S> for Rc<T> {\n #[experimental = \"Show is experimental.\"]\n impl<T: fmt::Show> fmt::Show for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        (**self).fmt(f)\n+        write!(f, \"Rc({:?})\", **self)\n     }\n }\n \n@@ -962,4 +962,10 @@ mod tests {\n         assert!(cow1_weak.upgrade().is_none());\n     }\n \n+    #[test]\n+    fn test_show() {\n+        let foo = Rc::new(75u);\n+        assert!(format!(\"{:?}\", foo) == \"Rc(75u)\")\n+    }\n+\n }"}, {"sha": "93215c3435e3ff7b3635f4511cd6fd00417a961d", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -1729,13 +1729,13 @@ impl BitvSet {\n \n impl fmt::Show for BitvSet {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(fmt, \"{{\"));\n+        try!(write!(fmt, \"BitvSet {{\"));\n         let mut first = true;\n         for n in self.iter() {\n             if !first {\n                 try!(write!(fmt, \", \"));\n             }\n-            try!(write!(fmt, \"{}\", n));\n+            try!(write!(fmt, \"{:?}\", n));\n             first = false;\n         }\n         write!(fmt, \"}}\")"}, {"sha": "0dd345110d73d61ddc5160493d30c010f9f890d3", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -866,11 +866,11 @@ impl<K: Ord, V: Ord> Ord for BTreeMap<K, V> {\n #[stable]\n impl<K: Show, V: Show> Show for BTreeMap<K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{{\"));\n+        try!(write!(f, \"BTreeMap {{\"));\n \n         for (i, (k, v)) in self.iter().enumerate() {\n             if i != 0 { try!(write!(f, \", \")); }\n-            try!(write!(f, \"{}: {}\", *k, *v));\n+            try!(write!(f, \"{:?}: {:?}\", *k, *v));\n         }\n \n         write!(f, \"}}\")"}, {"sha": "a764264fd1e68d575ead2c4356070a1abbb705f3", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -493,7 +493,7 @@ impl<K: Clone, V: Clone> Clone for Node<K, V> {\n ///     // Now the handle still points at index 75, but on the small node, which has no index 75.\n ///     flag.set(true);\n ///\n-///     println!(\"Uninitialized memory: {}\", handle.into_kv());\n+///     println!(\"Uninitialized memory: {:?}\", handle.into_kv());\n /// }\n /// ```\n #[derive(Copy)]"}, {"sha": "44140154ae48e17070fc302b5419a96637353405", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -556,11 +556,11 @@ impl<'a, 'b, T: Ord + Clone> BitOr<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n #[stable]\n impl<T: Show> Show for BTreeSet<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{{\"));\n+        try!(write!(f, \"BTreeSet {{\"));\n \n         for (i, x) in self.iter().enumerate() {\n             if i != 0 { try!(write!(f, \", \")); }\n-            try!(write!(f, \"{}\", *x));\n+            try!(write!(f, \"{:?}\", *x));\n         }\n \n         write!(f, \"}}\")"}, {"sha": "4ebd3dc63b698a861c7f79f861ef620683f78d88", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -663,11 +663,11 @@ impl<A: Clone> Clone for DList<A> {\n #[stable]\n impl<A: fmt::Show> fmt::Show for DList<A> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"[\"));\n+        try!(write!(f, \"DList [\"));\n \n         for (i, e) in self.iter().enumerate() {\n             if i != 0 { try!(write!(f, \", \")); }\n-            try!(write!(f, \"{}\", *e));\n+            try!(write!(f, \"{:?}\", *e));\n         }\n \n         write!(f, \"]\")"}, {"sha": "1b852d0ba680d20a07a8b29325957e2dea95287c", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -33,13 +33,13 @@ impl<E> Copy for EnumSet<E> {}\n \n impl<E:CLike+fmt::Show> fmt::Show for EnumSet<E> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(fmt, \"{{\"));\n+        try!(write!(fmt, \"EnumSet {{\"));\n         let mut first = true;\n         for e in self.iter() {\n             if !first {\n                 try!(write!(fmt, \", \"));\n             }\n-            try!(write!(fmt, \"{}\", e));\n+            try!(write!(fmt, \"{:?}\", e));\n             first = false;\n         }\n         write!(fmt, \"}}\")\n@@ -287,11 +287,11 @@ mod test {\n     #[test]\n     fn test_show() {\n         let mut e = EnumSet::new();\n-        assert_eq!(\"{}\", e.to_string());\n+        assert!(format!(\"{:?}\", e) == \"EnumSet {}\");\n         e.insert(A);\n-        assert_eq!(\"{A}\", e.to_string());\n+        assert!(format!(\"{:?}\", e) == \"EnumSet {A}\");\n         e.insert(C);\n-        assert_eq!(\"{A, C}\", e.to_string());\n+        assert!(format!(\"{:?}\", e) == \"EnumSet {A, C}\");\n     }\n \n     #[test]"}, {"sha": "9374d42b2c7631fcb7a6185ae5f2f8aaa216ce5b", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -1613,11 +1613,11 @@ impl<A> Extend<A> for RingBuf<A> {\n #[stable]\n impl<T: fmt::Show> fmt::Show for RingBuf<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"[\"));\n+        try!(write!(f, \"RingBuf [\"));\n \n         for (i, e) in self.iter().enumerate() {\n             if i != 0 { try!(write!(f, \", \")); }\n-            try!(write!(f, \"{}\", *e));\n+            try!(write!(f, \"{:?}\", *e));\n         }\n \n         write!(f, \"]\")"}, {"sha": "95b0a16d4c5e0b43280e0eca37772badef3cb311", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -2471,25 +2471,25 @@ mod tests {\n         macro_rules! test_show_vec {\n             ($x:expr, $x_str:expr) => ({\n                 let (x, x_str) = ($x, $x_str);\n-                assert_eq!(format!(\"{}\", x), x_str);\n-                assert_eq!(format!(\"{}\", x.as_slice()), x_str);\n+                assert_eq!(format!(\"{:?}\", x), x_str);\n+                assert_eq!(format!(\"{:?}\", x.as_slice()), x_str);\n             })\n         }\n         let empty: Vec<int> = vec![];\n         test_show_vec!(empty, \"[]\");\n-        test_show_vec!(vec![1i], \"[1]\");\n-        test_show_vec!(vec![1i, 2, 3], \"[1, 2, 3]\");\n+        test_show_vec!(vec![1i], \"[1i]\");\n+        test_show_vec!(vec![1i, 2, 3], \"[1i, 2i, 3i]\");\n         test_show_vec!(vec![vec![], vec![1u], vec![1u, 1u]],\n-                       \"[[], [1], [1, 1]]\");\n+                       \"[[], [1u], [1u, 1u]]\");\n \n         let empty_mut: &mut [int] = &mut[];\n         test_show_vec!(empty_mut, \"[]\");\n         let v: &mut[int] = &mut[1];\n-        test_show_vec!(v, \"[1]\");\n+        test_show_vec!(v, \"[1i]\");\n         let v: &mut[int] = &mut[1, 2, 3];\n-        test_show_vec!(v, \"[1, 2, 3]\");\n+        test_show_vec!(v, \"[1i, 2i, 3i]\");\n         let v: &mut [&mut[uint]] = &mut[&mut[], &mut[1u], &mut[1u, 1u]];\n-        test_show_vec!(v, \"[[], [1], [1, 1]]\");\n+        test_show_vec!(v, \"[[], [1u], [1u, 1u]]\");\n     }\n \n     #[test]"}, {"sha": "938ee73455f45877fa2c1543e314ae4180e2f771", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -677,13 +677,25 @@ impl FromUtf8Error {\n \n impl fmt::Show for FromUtf8Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.error.fmt(f)\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for FromUtf8Error {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(&self.error, f)\n     }\n }\n \n impl fmt::Show for FromUtf16Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        \"invalid utf-16: lone surrogate found\".fmt(f)\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for FromUtf16Error {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(\"invalid utf-16: lone surrogate found\", f)\n     }\n }\n \n@@ -793,10 +805,17 @@ impl Default for String {\n     }\n }\n \n-#[experimental = \"waiting on Show stabilization\"]\n+#[experimental = \"waiting on fmt stabilization\"]\n+impl fmt::String for String {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(&**self, f)\n+    }\n+}\n+\n+#[experimental = \"waiting on fmt stabilization\"]\n impl fmt::Show for String {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        (**self).fmt(f)\n+        fmt::Show::fmt(&**self, f)\n     }\n }\n \n@@ -902,6 +921,8 @@ pub trait ToString {\n     fn to_string(&self) -> String;\n }\n \n+#[cfg(stage0)]\n+//NOTE(stage0): remove after stage0 snapshot\n impl<T: fmt::Show> ToString for T {\n     fn to_string(&self) -> String {\n         use core::fmt::Writer;\n@@ -912,6 +933,17 @@ impl<T: fmt::Show> ToString for T {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<T: fmt::String> ToString for T {\n+    fn to_string(&self) -> String {\n+        use core::fmt::Writer;\n+        let mut buf = String::new();\n+        let _ = buf.write_fmt(format_args!(\"{}\", self));\n+        buf.shrink_to_fit();\n+        buf\n+    }\n+}\n+\n impl IntoCow<'static, String, str> for String {\n     fn into_cow(self) -> CowString<'static> {\n         Cow::Owned(self)"}, {"sha": "a3f7f6c91576b6f55a817fa2b2b93452f921d6d9", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -1450,7 +1450,14 @@ impl<T> Default for Vec<T> {\n #[experimental = \"waiting on Show stability\"]\n impl<T:fmt::Show> fmt::Show for Vec<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.as_slice().fmt(f)\n+        fmt::Show::fmt(self.as_slice(), f)\n+    }\n+}\n+\n+#[experimental = \"waiting on Show stability\"]\n+impl<T:fmt::String> fmt::String for Vec<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self.as_slice(), f)\n     }\n }\n "}, {"sha": "4399a6fec2274bd42b8e8a5553a6490a0fcfb3f4", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -489,11 +489,11 @@ impl<V: Ord> Ord for VecMap<V> {\n #[stable]\n impl<V: fmt::Show> fmt::Show for VecMap<V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{{\"));\n+        try!(write!(f, \"VecMap {{\"));\n \n         for (i, (k, v)) in self.iter().enumerate() {\n             if i != 0 { try!(write!(f, \", \")); }\n-            try!(write!(f, \"{}: {}\", k, *v));\n+            try!(write!(f, \"{}: {:?}\", k, *v));\n         }\n \n         write!(f, \"}}\")\n@@ -929,9 +929,9 @@ mod test_map {\n         map.insert(1, 2i);\n         map.insert(3, 4i);\n \n-        let map_str = map.to_string();\n-        assert!(map_str == \"{1: 2, 3: 4}\" || map_str == \"{3: 4, 1: 2}\");\n-        assert_eq!(format!(\"{}\", empty), \"{}\");\n+        let map_str = format!(\"{:?}\", map);\n+        assert!(map_str == \"VecMap {1: 2i, 3: 4i}\" || map_str == \"{3: 4i, 1: 2i}\");\n+        assert_eq!(format!(\"{:?}\", empty), \"VecMap {}\");\n     }\n \n     #[test]"}, {"sha": "2c74ad239257f21b543f520946d51eac5afdcbca", "filename": "src/libcore/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -46,7 +46,7 @@\n //!     // different type: just print it out unadorned.\n //!     match value_any.downcast_ref::<String>() {\n //!         Some(as_string) => {\n-//!             println!(\"String ({}): {}\", as_string.len(), as_string);\n+//!             println!(\"String ({}): {:?}\", as_string.len(), as_string);\n //!         }\n //!         None => {\n //!             println!(\"{}\", value);"}, {"sha": "8cde33c9408fe8d3784aa259e6d770d647306094", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -133,6 +133,7 @@ impl<T> ToOwned<T> for T where T: Clone {\n ///     }\n /// }\n /// ```\n+//#[deriving(Show)] NOTE(stage0): uncomment after snapshot\n pub enum Cow<'a, T, B: ?Sized + 'a> where B: ToOwned<T> {\n     /// Borrowed data.\n     Borrowed(&'a B),\n@@ -141,6 +142,16 @@ pub enum Cow<'a, T, B: ?Sized + 'a> where B: ToOwned<T> {\n     Owned(T)\n }\n \n+//NOTE(stage0): replace with deriving(Show) after snapshot\n+impl<'a, T, B: ?Sized> fmt::Show for Cow<'a, T, B> where\n+    B: fmt::String + ToOwned<T>,\n+    T: fmt::String\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n #[stable]\n impl<'a, T, B: ?Sized> Clone for Cow<'a, T, B> where B: ToOwned<T> {\n     fn clone(&self) -> Cow<'a, T, B> {\n@@ -237,11 +248,14 @@ impl<'a, T, B: ?Sized> PartialOrd for Cow<'a, T, B> where B: PartialOrd + ToOwne\n     }\n }\n \n-impl<'a, T, B: ?Sized> fmt::Show for Cow<'a, T, B> where B: fmt::Show + ToOwned<T>, T: fmt::Show {\n+impl<'a, T, B: ?Sized> fmt::String for Cow<'a, T, B> where\n+    B: fmt::String + ToOwned<T>,\n+    T: fmt::String,\n+{\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            Borrowed(ref b) => fmt::Show::fmt(b, f),\n-            Owned(ref o) => fmt::Show::fmt(o, f),\n+            Borrowed(ref b) => fmt::String::fmt(b, f),\n+            Owned(ref o) => fmt::String::fmt(o, f),\n         }\n     }\n }"}, {"sha": "3cc197c323c1d10e7e46d61e22b9ea68e746fdb7", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -160,7 +160,6 @@\n use clone::Clone;\n use cmp::PartialEq;\n use default::Default;\n-use fmt;\n use kinds::{Copy, Send};\n use ops::{Deref, DerefMut, Drop};\n use option::Option;\n@@ -364,16 +363,6 @@ impl<T: PartialEq> PartialEq for RefCell<T> {\n     }\n }\n \n-#[unstable]\n-impl<T:fmt::Show> fmt::Show for RefCell<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match self.try_borrow() {\n-            Some(val) => write!(f, \"{}\", val),\n-            None => write!(f, \"<borrowed RefCell>\")\n-        }\n-    }\n-}\n-\n struct BorrowRef<'b> {\n     _borrow: &'b Cell<BorrowFlag>,\n }"}, {"sha": "fe2511d1f7f96bd3c86c0b8c19b9d4106be41966", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 121, "deletions": 18, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -13,7 +13,8 @@\n #![allow(unused_variables)]\n \n use any;\n-use cell::{Cell, Ref, RefMut};\n+use cell::{Cell, RefCell, Ref, RefMut};\n+use char::CharExt;\n use iter::{Iterator, IteratorExt, range};\n use kinds::{Copy, Sized};\n use mem;\n@@ -215,21 +216,37 @@ pub struct Arguments<'a> {\n     args: &'a [Argument<'a>],\n }\n \n+#[cfg(stage0)]\n+//FIXME: remove after stage0 snapshot\n impl<'a> Show for Arguments<'a> {\n     fn fmt(&self, fmt: &mut Formatter) -> Result {\n         write(fmt.buf, *self)\n     }\n }\n \n-/// When a format is not otherwise specified, types are formatted by ascribing\n-/// to this trait. There is not an explicit way of selecting this trait to be\n-/// used for formatting, it is only if no other format is specified.\n+#[cfg(not(stage0))]\n+impl<'a> String for Arguments<'a> {\n+    fn fmt(&self, fmt: &mut Formatter) -> Result {\n+        write(fmt.buf, *self)\n+    }\n+}\n+\n+/// Format trait for the `:?` format. Useful for debugging, most all types\n+/// should implement this.\n #[unstable = \"I/O and core have yet to be reconciled\"]\n pub trait Show {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n+/// When a value can be semantically expressed as a String, this trait may be\n+/// used. It corresponds to the default format, `{}`.\n+#[unstable = \"I/O and core have yet to be reconciled\"]\n+pub trait String {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n \n /// Format trait for the `o` character\n #[unstable = \"I/O and core have yet to be reconciled\"]\n@@ -572,7 +589,7 @@ impl<'a> Formatter<'a> {\n \n impl Show for Error {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        \"an error occurred when formatting an argument\".fmt(f)\n+        String::fmt(\"an error occurred when formatting an argument\", f)\n     }\n }\n \n@@ -595,33 +612,86 @@ pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n \n // Implementations of the core formatting traits\n \n-impl<'a, T: ?Sized + Show> Show for &'a T {\n-    fn fmt(&self, f: &mut Formatter) -> Result { (**self).fmt(f) }\n-}\n-impl<'a, T: ?Sized + Show> Show for &'a mut T {\n-    fn fmt(&self, f: &mut Formatter) -> Result { (**self).fmt(f) }\n+macro_rules! fmt_refs {\n+    ($($tr:ident),*) => {\n+        $(\n+        impl<'a, T: ?Sized + $tr> $tr for &'a T {\n+            fn fmt(&self, f: &mut Formatter) -> Result { $tr::fmt(&**self, f) }\n+        }\n+        impl<'a, T: ?Sized + $tr> $tr for &'a mut T {\n+            fn fmt(&self, f: &mut Formatter) -> Result { $tr::fmt(&**self, f) }\n+        }\n+        )*\n+    }\n }\n \n+fmt_refs! { Show, String, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperExp }\n+\n impl Show for bool {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        Show::fmt(if *self { \"true\" } else { \"false\" }, f)\n+        String::fmt(self, f)\n     }\n }\n \n+impl String for bool {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        String::fmt(if *self { \"true\" } else { \"false\" }, f)\n+    }\n+}\n+\n+#[cfg(stage0)]\n+//NOTE(stage0): remove impl after snapshot\n+impl Show for str {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        String::fmt(self, f)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+//NOTE(stage0): remove cfg after snapshot\n impl Show for str {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        try!(write!(f, \"\\\"\"));\n+        for c in self.chars().flat_map(|c| c.escape_default()) {\n+            try!(write!(f, \"{}\", c));\n+        }\n+        write!(f, \"\\\"\")\n+    }\n+}\n+\n+impl String for str {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.pad(self)\n     }\n }\n \n+#[cfg(stage0)]\n+//NOTE(stage0): remove impl after snapshot\n+impl Show for char {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        String::fmt(self, f)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+//NOTE(stage0): remove cfg after snapshot\n impl Show for char {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         use char::CharExt;\n+        try!(write!(f, \"'\"));\n+        for c in self.escape_default() {\n+            try!(write!(f, \"{}\", c));\n+        }\n+        write!(f, \"'\")\n+    }\n+}\n \n+impl String for char {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n         let mut utf8 = [0u8; 4];\n         let amt = self.encode_utf8(&mut utf8).unwrap_or(0);\n         let s: &str = unsafe { mem::transmute(utf8.index(&(0..amt))) };\n-        Show::fmt(s, f)\n+        String::fmt(s, f)\n     }\n }\n \n@@ -653,7 +723,15 @@ impl<'a, T> Pointer for &'a mut T {\n }\n \n macro_rules! floating { ($ty:ident) => {\n+\n     impl Show for $ty {\n+        fn fmt(&self, fmt: &mut Formatter) -> Result {\n+            try!(String::fmt(self, fmt));\n+            fmt.write_str(stringify!($ty))\n+        }\n+    }\n+\n+    impl String for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n             use num::Float;\n \n@@ -746,7 +824,7 @@ macro_rules! tuple {\n                     if n > 0 {\n                         try!(write!(f, \", \"));\n                     }\n-                    try!(write!(f, \"{}\", *$name));\n+                    try!(write!(f, \"{:?}\", *$name));\n                     n += 1;\n                 )*\n                 if n == 1 {\n@@ -777,7 +855,7 @@ impl<T: Show> Show for [T] {\n             } else {\n                 try!(write!(f, \", \"));\n             }\n-            try!(write!(f, \"{}\", *x))\n+            try!(write!(f, \"{:?}\", *x))\n         }\n         if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n             try!(write!(f, \"]\"));\n@@ -786,6 +864,21 @@ impl<T: Show> Show for [T] {\n     }\n }\n \n+impl<T: String> String for [T] {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        let mut is_first = true;\n+        for x in self.iter() {\n+            if is_first {\n+                is_first = false;\n+            } else {\n+                try!(write!(f, \", \"));\n+            }\n+            try!(String::fmt(x, f))\n+        }\n+        Ok(())\n+    }\n+}\n+\n impl Show for () {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.pad(\"()\")\n@@ -794,23 +887,33 @@ impl Show for () {\n \n impl<T: Copy + Show> Show for Cell<T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        write!(f, \"Cell {{ value: {} }}\", self.get())\n+        write!(f, \"Cell {{ value: {:?} }}\", self.get())\n+    }\n+}\n+\n+#[unstable]\n+impl<T: Show> Show for RefCell<T> {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        match self.try_borrow() {\n+            Some(val) => write!(f, \"RefCell {{ value: {:?} }}\", val),\n+            None => write!(f, \"RefCell {{ <borrowed> }}\")\n+        }\n     }\n }\n \n impl<'b, T: Show> Show for Ref<'b, T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        (**self).fmt(f)\n+        Show::fmt(&**self, f)\n     }\n }\n \n impl<'b, T: Show> Show for RefMut<'b, T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        (*(self.deref())).fmt(f)\n+        Show::fmt(&*(self.deref()), f)\n     }\n }\n \n-impl Show for Utf8Error {\n+impl String for Utf8Error {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         match *self {\n             Utf8Error::InvalidByte(n) => {"}, {"sha": "17149aed3dbab4375e652c2203c644d010b41b8e", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 44, "deletions": 6, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -154,8 +154,22 @@ pub fn radix<T>(x: T, base: u8) -> RadixFmt<T, Radix> {\n }\n \n macro_rules! radix_fmt {\n-    ($T:ty as $U:ty, $fmt:ident) => {\n+    ($T:ty as $U:ty, $fmt:ident, $S:expr) => {\n+        #[cfg(stage0)]\n         impl fmt::Show for RadixFmt<$T, Radix> {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                fmt::String::fmt(self, f)\n+            }\n+        }\n+\n+        #[cfg(not(stage0))]\n+        impl fmt::Show for RadixFmt<$T, Radix> {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                try!(fmt::String::fmt(self, f));\n+                f.write_str($S)\n+            }\n+        }\n+        impl fmt::String for RadixFmt<$T, Radix> {\n             fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                 match *self { RadixFmt(ref x, radix) => radix.$fmt(*x as $U, f) }\n             }\n@@ -171,24 +185,48 @@ macro_rules! int_base {\n         }\n     }\n }\n+\n+macro_rules! show {\n+    ($T:ident with $S:expr) => {\n+        #[cfg(stage0)]\n+        impl fmt::Show for $T {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                fmt::String::fmt(self, f)\n+            }\n+        }\n+\n+        #[cfg(not(stage0))]\n+        impl fmt::Show for $T {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                try!(fmt::String::fmt(self, f));\n+                f.write_str($S)\n+            }\n+        }\n+    }\n+}\n macro_rules! integer {\n     ($Int:ident, $Uint:ident) => {\n-        int_base! { Show     for $Int as $Int   -> Decimal }\n+        integer! { $Int, $Uint, stringify!($Int), stringify!($Uint) }\n+    };\n+    ($Int:ident, $Uint:ident, $SI:expr, $SU:expr) => {\n+        int_base! { String   for $Int as $Int   -> Decimal }\n         int_base! { Binary   for $Int as $Uint  -> Binary }\n         int_base! { Octal    for $Int as $Uint  -> Octal }\n         int_base! { LowerHex for $Int as $Uint  -> LowerHex }\n         int_base! { UpperHex for $Int as $Uint  -> UpperHex }\n-        radix_fmt! { $Int as $Int, fmt_int }\n+        radix_fmt! { $Int as $Int, fmt_int, $SI }\n+        show! { $Int with $SI }\n \n-        int_base! { Show     for $Uint as $Uint -> Decimal }\n+        int_base! { String   for $Uint as $Uint -> Decimal }\n         int_base! { Binary   for $Uint as $Uint -> Binary }\n         int_base! { Octal    for $Uint as $Uint -> Octal }\n         int_base! { LowerHex for $Uint as $Uint -> LowerHex }\n         int_base! { UpperHex for $Uint as $Uint -> UpperHex }\n-        radix_fmt! { $Uint as $Uint, fmt_int }\n+        radix_fmt! { $Uint as $Uint, fmt_int, $SU }\n+        show! { $Uint with $SU }\n     }\n }\n-integer! { int, uint }\n+integer! { int, uint, \"i\", \"u\" }\n integer! { i8, u8 }\n integer! { i16, u16 }\n integer! { i32, u32 }"}, {"sha": "99e49cc21ed5f29d4e39c0e8d681623ad294da8c", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -83,7 +83,7 @@ macro_rules! assert_eq {\n                 if !((*left_val == *right_val) &&\n                      (*right_val == *left_val)) {\n                     panic!(\"assertion failed: `(left == right) && (right == left)` \\\n-                           (left: `{}`, right: `{}`)\", *left_val, *right_val)\n+                           (left: `{:?}`, right: `{:?}`)\", *left_val, *right_val)\n                 }\n             }\n         }"}, {"sha": "95ae6ebfb68c30b9ad26a0cb1fd2b7fa5d75d588", "filename": "src/libcore/result.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -47,10 +47,10 @@\n //! let version = parse_version(&[1, 2, 3, 4]);\n //! match version {\n //!     Ok(v) => {\n-//!         println!(\"working with version: {}\", v);\n+//!         println!(\"working with version: {:?}\", v);\n //!     }\n //!     Err(e) => {\n-//!         println!(\"error parsing header: {}\", e);\n+//!         println!(\"error parsing header: {:?}\", e);\n //!     }\n //! }\n //! ```\n@@ -743,7 +743,7 @@ impl<T, E: Show> Result<T, E> {\n         match self {\n             Ok(t) => t,\n             Err(e) =>\n-                panic!(\"called `Result::unwrap()` on an `Err` value: {}\", e)\n+                panic!(\"called `Result::unwrap()` on an `Err` value: {:?}\", e)\n         }\n     }\n }\n@@ -773,7 +773,7 @@ impl<T: Show, E> Result<T, E> {\n     pub fn unwrap_err(self) -> E {\n         match self {\n             Ok(t) =>\n-                panic!(\"called `Result::unwrap_err()` on an `Ok` value: {}\", t),\n+                panic!(\"called `Result::unwrap_err()` on an `Ok` value: {:?}\", t),\n             Err(e) => e\n         }\n     }"}, {"sha": "4d160c35577528ebfe8624e43f50c8cbd29a4865", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -143,7 +143,7 @@ Section: Creating a string\n */\n \n /// Errors which can occur when attempting to interpret a byte slice as a `str`.\n-#[derive(Copy, Eq, PartialEq, Clone)]\n+#[derive(Copy, Eq, PartialEq, Clone, Show)]\n #[unstable = \"error enumeration recently added and definitions may be refined\"]\n pub enum Utf8Error {\n     /// An invalid byte was detected at the byte offset given."}, {"sha": "c0be3a287940a9bbbac8546b48f764fcfc2f479f", "filename": "src/libcoretest/any.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcoretest%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcoretest%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fany.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -56,12 +56,12 @@ fn any_downcast_ref() {\n \n     match a.downcast_ref::<uint>() {\n         Some(&5) => {}\n-        x => panic!(\"Unexpected value {}\", x)\n+        x => panic!(\"Unexpected value {:?}\", x)\n     }\n \n     match a.downcast_ref::<Test>() {\n         None => {}\n-        x => panic!(\"Unexpected value {}\", x)\n+        x => panic!(\"Unexpected value {:?}\", x)\n     }\n }\n \n@@ -79,35 +79,35 @@ fn any_downcast_mut() {\n             assert_eq!(*x, 5u);\n             *x = 612;\n         }\n-        x => panic!(\"Unexpected value {}\", x)\n+        x => panic!(\"Unexpected value {:?}\", x)\n     }\n \n     match b_r.downcast_mut::<uint>() {\n         Some(x) => {\n             assert_eq!(*x, 7u);\n             *x = 413;\n         }\n-        x => panic!(\"Unexpected value {}\", x)\n+        x => panic!(\"Unexpected value {:?}\", x)\n     }\n \n     match a_r.downcast_mut::<Test>() {\n         None => (),\n-        x => panic!(\"Unexpected value {}\", x)\n+        x => panic!(\"Unexpected value {:?}\", x)\n     }\n \n     match b_r.downcast_mut::<Test>() {\n         None => (),\n-        x => panic!(\"Unexpected value {}\", x)\n+        x => panic!(\"Unexpected value {:?}\", x)\n     }\n \n     match a_r.downcast_mut::<uint>() {\n         Some(&612) => {}\n-        x => panic!(\"Unexpected value {}\", x)\n+        x => panic!(\"Unexpected value {:?}\", x)\n     }\n \n     match b_r.downcast_mut::<uint>() {\n         Some(&413) => {}\n-        x => panic!(\"Unexpected value {}\", x)\n+        x => panic!(\"Unexpected value {:?}\", x)\n     }\n }\n "}, {"sha": "86f34ecd15efeefdef43ac28f2712aaedbcc05e4", "filename": "src/libcoretest/cell.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcoretest%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcoretest%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcell.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -29,22 +29,22 @@ fn smoketest_cell() {\n #[test]\n fn cell_has_sensible_show() {\n     let x = Cell::new(\"foo bar\");\n-    assert!(format!(\"{}\", x).contains(x.get()));\n+    assert!(format!(\"{:?}\", x).contains(x.get()));\n \n     x.set(\"baz qux\");\n-    assert!(format!(\"{}\", x).contains(x.get()));\n+    assert!(format!(\"{:?}\", x).contains(x.get()));\n }\n \n #[test]\n fn ref_and_refmut_have_sensible_show() {\n     let refcell = RefCell::new(\"foo\");\n \n     let refcell_refmut = refcell.borrow_mut();\n-    assert!(format!(\"{}\", refcell_refmut).contains(\"foo\"));\n+    assert!(format!(\"{:?}\", refcell_refmut).contains(\"foo\"));\n     drop(refcell_refmut);\n \n     let refcell_ref = refcell.borrow();\n-    assert!(format!(\"{}\", refcell_ref).contains(\"foo\"));\n+    assert!(format!(\"{:?}\", refcell_ref).contains(\"foo\"));\n     drop(refcell_ref);\n }\n "}, {"sha": "c259e4cbb686d3da9e619ee9cd3bd6961b7658a8", "filename": "src/libcoretest/fmt/num.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcoretest%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcoretest%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Fnum.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -26,6 +26,11 @@ fn test_format_int() {\n     assert!(format!(\"{}\", -1i16) == \"-1\");\n     assert!(format!(\"{}\", -1i32) == \"-1\");\n     assert!(format!(\"{}\", -1i64) == \"-1\");\n+    assert!(format!(\"{:?}\", 1i) == \"1i\");\n+    assert!(format!(\"{:?}\", 1i8) == \"1i8\");\n+    assert!(format!(\"{:?}\", 1i16) == \"1i16\");\n+    assert!(format!(\"{:?}\", 1i32) == \"1i32\");\n+    assert!(format!(\"{:?}\", 1i64) == \"1i64\");\n     assert!(format!(\"{:b}\", 1i) == \"1\");\n     assert!(format!(\"{:b}\", 1i8) == \"1\");\n     assert!(format!(\"{:b}\", 1i16) == \"1\");\n@@ -52,6 +57,11 @@ fn test_format_int() {\n     assert!(format!(\"{}\", 1u16) == \"1\");\n     assert!(format!(\"{}\", 1u32) == \"1\");\n     assert!(format!(\"{}\", 1u64) == \"1\");\n+    assert!(format!(\"{:?}\", 1u) == \"1u\");\n+    assert!(format!(\"{:?}\", 1u8) == \"1u8\");\n+    assert!(format!(\"{:?}\", 1u16) == \"1u16\");\n+    assert!(format!(\"{:?}\", 1u32) == \"1u32\");\n+    assert!(format!(\"{:?}\", 1u64) == \"1u64\");\n     assert!(format!(\"{:b}\", 1u) == \"1\");\n     assert!(format!(\"{:b}\", 1u8) == \"1\");\n     assert!(format!(\"{:b}\", 1u16) == \"1\");\n@@ -84,12 +94,14 @@ fn test_format_int() {\n #[test]\n fn test_format_int_zero() {\n     assert!(format!(\"{}\", 0i) == \"0\");\n+    assert!(format!(\"{:?}\", 0i) == \"0i\");\n     assert!(format!(\"{:b}\", 0i) == \"0\");\n     assert!(format!(\"{:o}\", 0i) == \"0\");\n     assert!(format!(\"{:x}\", 0i) == \"0\");\n     assert!(format!(\"{:X}\", 0i) == \"0\");\n \n     assert!(format!(\"{}\", 0u) == \"0\");\n+    assert!(format!(\"{:?}\", 0u) == \"0u\");\n     assert!(format!(\"{:b}\", 0u) == \"0\");\n     assert!(format!(\"{:o}\", 0u) == \"0\");\n     assert!(format!(\"{:x}\", 0u) == \"0\");\n@@ -183,6 +195,12 @@ mod uint {\n         b.iter(|| { format!(\"{:x}\", rng.gen::<uint>()); })\n     }\n \n+    #[bench]\n+    fn format_show(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| { format!(\"{:?}\", rng.gen::<uint>()); })\n+    }\n+\n     #[bench]\n     fn format_base_36(b: &mut Bencher) {\n         let mut rng = weak_rng();\n@@ -219,6 +237,12 @@ mod int {\n         b.iter(|| { format!(\"{:x}\", rng.gen::<int>()); })\n     }\n \n+    #[bench]\n+    fn format_show(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| { format!(\"{:?}\", rng.gen::<int>()); })\n+    }\n+\n     #[bench]\n     fn format_base_36(b: &mut Bencher) {\n         let mut rng = weak_rng();"}, {"sha": "b9403598ec2b2d3b8f0ab8d2b5b5bd5545a76c39", "filename": "src/libcoretest/result.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcoretest%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcoretest%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fresult.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -95,10 +95,10 @@ pub fn test_fmt_default() {\n     let ok: Result<int, &'static str> = Ok(100);\n     let err: Result<int, &'static str> = Err(\"Err\");\n \n-    let s = format!(\"{}\", ok);\n-    assert_eq!(s, \"Ok(100)\");\n-    let s = format!(\"{}\", err);\n-    assert_eq!(s, \"Err(Err)\");\n+    let s = format!(\"{:?}\", ok);\n+    assert_eq!(s, \"Ok(100i)\");\n+    let s = format!(\"{:?}\", err);\n+    assert_eq!(s, \"Err(\\\"Err\\\")\");\n }\n \n #[test]"}, {"sha": "62eb9f4ad3480c9df71a12feb97692c735297072", "filename": "src/libcoretest/tuple.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcoretest%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibcoretest%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ftuple.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -59,10 +59,10 @@ fn test_tuple_cmp() {\n \n #[test]\n fn test_show() {\n-    let s = format!(\"{}\", (1i,));\n-    assert_eq!(s, \"(1,)\");\n-    let s = format!(\"{}\", (1i, true));\n-    assert_eq!(s, \"(1, true)\");\n-    let s = format!(\"{}\", (1i, \"hi\", true));\n-    assert_eq!(s, \"(1, hi, true)\");\n+    let s = format!(\"{:?}\", (1i,));\n+    assert_eq!(s, \"(1i,)\");\n+    let s = format!(\"{:?}\", (1i, true));\n+    assert_eq!(s, \"(1i, true)\");\n+    let s = format!(\"{:?}\", (1i, \"hi\", true));\n+    assert_eq!(s, \"(1i, \\\"hi\\\", true)\");\n }"}, {"sha": "19173baf1664baa158d9556007ea8834998a559e", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -212,10 +212,11 @@ impl<'a> Parser<'a> {\n                 self.cur.next();\n             }\n             Some((_, other)) => {\n-                self.err(format!(\"expected `{}`, found `{}`\", c, other).index(&FullRange));\n+                self.err(format!(\"expected `{:?}`, found `{:?}`\", c,\n+                                 other).index(&FullRange));\n             }\n             None => {\n-                self.err(format!(\"expected `{}` but string was terminated\",\n+                self.err(format!(\"expected `{:?}` but string was terminated\",\n                                  c).index(&FullRange));\n             }\n         }"}, {"sha": "64d4de7cc8a9b2e780b133e6b26911c2ff5de5c8", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -105,7 +105,7 @@ use std::iter::repeat;\n use std::result;\n \n /// Name of an option. Either a string or a single char.\n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq, Show)]\n pub enum Name {\n     /// A string representing the long name of an option.\n     /// For example: \"help\"\n@@ -116,7 +116,7 @@ pub enum Name {\n }\n \n /// Describes whether an option has an argument.\n-#[derive(Clone, Copy, PartialEq, Eq)]\n+#[derive(Clone, Copy, PartialEq, Eq, Show)]\n pub enum HasArg {\n     /// The option requires an argument.\n     Yes,\n@@ -127,7 +127,7 @@ pub enum HasArg {\n }\n \n /// Describes how often an option may occur.\n-#[derive(Clone, Copy, PartialEq, Eq)]\n+#[derive(Clone, Copy, PartialEq, Eq, Show)]\n pub enum Occur {\n     /// The option occurs once.\n     Req,\n@@ -138,7 +138,7 @@ pub enum Occur {\n }\n \n /// A description of a possible option.\n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq, Show)]\n pub struct Opt {\n     /// Name of the option\n     pub name: Name,\n@@ -152,7 +152,7 @@ pub struct Opt {\n \n /// One group of options, e.g., both `-h` and `--help`, along with\n /// their shared description and properties.\n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq, Show)]\n pub struct OptGroup {\n     /// Short name of the option, e.g. `h` for a `-h` option\n     pub short_name: String,\n@@ -169,15 +169,15 @@ pub struct OptGroup {\n }\n \n /// Describes whether an option is given at all or has a value.\n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq, Show)]\n enum Optval {\n     Val(String),\n     Given,\n }\n \n /// The result of checking command line arguments. Contains a vector\n /// of matches and a vector of free strings.\n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq, Show)]\n pub struct Matches {\n     /// Options that matched\n     opts: Vec<Opt>,\n@@ -190,7 +190,7 @@ pub struct Matches {\n /// The type returned when the command line does not conform to the\n /// expected format. Use the `Show` implementation to output detailed\n /// information.\n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq, Show)]\n pub enum Fail {\n     /// The option requires an argument but none was passed.\n     ArgumentMissing(String),\n@@ -205,7 +205,7 @@ pub enum Fail {\n }\n \n /// The type of failure that occurred.\n-#[derive(Copy, PartialEq, Eq)]\n+#[derive(Copy, PartialEq, Eq, Show)]\n #[allow(missing_docs)]\n pub enum FailType {\n     ArgumentMissing_,\n@@ -536,13 +536,13 @@ pub fn opt(short_name: &str,\n \n impl Fail {\n     /// Convert a `Fail` enum into an error string.\n-    #[deprecated=\"use `Show` (`{}` format specifier)\"]\n+    #[deprecated=\"use `fmt::String` (`{}` format specifier)\"]\n     pub fn to_err_msg(self) -> String {\n         self.to_string()\n     }\n }\n \n-impl fmt::Show for Fail {\n+impl fmt::String for Fail {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             ArgumentMissing(ref nm) => {"}, {"sha": "d741019aa7b9c3804e9e0ee27d12dcd5f208fabb", "filename": "src/liblog/directive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Fliblog%2Fdirective.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Fliblog%2Fdirective.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fdirective.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -84,7 +84,7 @@ pub fn parse_logging_spec(spec: &str) -> (Vec<LogDirective>, Option<Regex>) {\n         match Regex::new(filter) {\n             Ok(re) => Some(re),\n             Err(e) => {\n-                println!(\"warning: invalid regex filter - {}\", e);\n+                println!(\"warning: invalid regex filter - {:?}\", e);\n                 None\n             }\n         }"}, {"sha": "332dd5e558e3ff1116287adbd89b84373e585f6c", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -16,12 +16,12 @@\n //! #[macro_use] extern crate log;\n //!\n //! fn main() {\n-//!     debug!(\"this is a debug {}\", \"message\");\n+//!     debug!(\"this is a debug {:?}\", \"message\");\n //!     error!(\"this is printed by default\");\n //!\n //!     if log_enabled!(log::INFO) {\n //!         let x = 3i * 4i; // expensive computation\n-//!         info!(\"the answer was: {}\", x);\n+//!         info!(\"the answer was: {:?}\", x);\n //!     }\n //! }\n //! ```\n@@ -238,11 +238,17 @@ struct DefaultLogger {\n pub struct LogLevel(pub u32);\n \n impl fmt::Show for LogLevel {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, fmt)\n+    }\n+}\n+\n+impl fmt::String for LogLevel {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let LogLevel(level) = *self;\n         match LOG_LEVEL_NAMES.get(level as uint - 1) {\n-            Some(name) => name.fmt(fmt),\n-            None => level.fmt(fmt)\n+            Some(ref name) => fmt::String::fmt(name, fmt),\n+            None => fmt::String::fmt(&level, fmt)\n         }\n     }\n }\n@@ -254,7 +260,7 @@ impl Logger for DefaultLogger {\n                        record.level,\n                        record.module_path,\n                        record.args) {\n-            Err(e) => panic!(\"failed to log: {}\", e),\n+            Err(e) => panic!(\"failed to log: {:?}\", e),\n             Ok(()) => {}\n         }\n     }\n@@ -264,7 +270,7 @@ impl Drop for DefaultLogger {\n     fn drop(&mut self) {\n         // FIXME(#12628): is panicking the right thing to do?\n         match self.handle.flush() {\n-            Err(e) => panic!(\"failed to flush a logger: {}\", e),\n+            Err(e) => panic!(\"failed to flush a logger: {:?}\", e),\n             Ok(()) => {}\n         }\n     }"}, {"sha": "80a3a88f70c42eb15e9e09f9d494995ccf6ea86e", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -147,7 +147,7 @@ pub mod reader {\n             match $e {\n                 Ok(e) => e,\n                 Err(e) => {\n-                    debug!(\"ignored error: {}\", e);\n+                    debug!(\"ignored error: {:?}\", e);\n                     return $r\n                 }\n             }\n@@ -256,7 +256,7 @@ pub mod reader {\n         match maybe_get_doc(d, tg) {\n             Some(d) => d,\n             None => {\n-                error!(\"failed to find block with tag {}\", tg);\n+                error!(\"failed to find block with tag {:?}\", tg);\n                 panic!();\n             }\n         }\n@@ -351,32 +351,32 @@ pub mod reader {\n                     self.pos = r_doc.end;\n                     let str = r_doc.as_str_slice();\n                     if lbl != str {\n-                        return Err(Expected(format!(\"Expected label {} but \\\n-                                                     found {}\", lbl, str)));\n+                        return Err(Expected(format!(\"Expected label {:?} but \\\n+                                                     found {:?}\", lbl, str)));\n                     }\n                 }\n             }\n             Ok(())\n         }\n \n         fn next_doc(&mut self, exp_tag: EbmlEncoderTag) -> DecodeResult<Doc<'doc>> {\n-            debug!(\". next_doc(exp_tag={})\", exp_tag);\n+            debug!(\". next_doc(exp_tag={:?})\", exp_tag);\n             if self.pos >= self.parent.end {\n                 return Err(Expected(format!(\"no more documents in \\\n                                              current node!\")));\n             }\n             let TaggedDoc { tag: r_tag, doc: r_doc } =\n                 try!(doc_at(self.parent.data, self.pos));\n-            debug!(\"self.parent={}-{} self.pos={} r_tag={} r_doc={}-{}\",\n+            debug!(\"self.parent={:?}-{:?} self.pos={:?} r_tag={:?} r_doc={:?}-{:?}\",\n                    self.parent.start,\n                    self.parent.end,\n                    self.pos,\n                    r_tag,\n                    r_doc.start,\n                    r_doc.end);\n             if r_tag != (exp_tag as uint) {\n-                return Err(Expected(format!(\"expected EBML doc with tag {} but \\\n-                                             found tag {}\", exp_tag, r_tag)));\n+                return Err(Expected(format!(\"expected EBML doc with tag {:?} but \\\n+                                             found tag {:?}\", exp_tag, r_tag)));\n             }\n             if r_doc.end > self.parent.end {\n                 return Err(Expected(format!(\"invalid EBML, child extends to \\\n@@ -403,7 +403,7 @@ pub mod reader {\n \n         fn _next_uint(&mut self, exp_tag: EbmlEncoderTag) -> DecodeResult<uint> {\n             let r = doc_as_u32(try!(self.next_doc(exp_tag)));\n-            debug!(\"_next_uint exp_tag={} result={}\", exp_tag, r);\n+            debug!(\"_next_uint exp_tag={:?} result={:?}\", exp_tag, r);\n             Ok(r as uint)\n         }\n \n@@ -486,7 +486,7 @@ pub mod reader {\n         fn read_enum<T, F>(&mut self, name: &str, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n-            debug!(\"read_enum({})\", name);\n+            debug!(\"read_enum({:?})\", name);\n             try!(self._check_label(name));\n \n             let doc = try!(self.next_doc(EsEnum));\n@@ -508,7 +508,7 @@ pub mod reader {\n         {\n             debug!(\"read_enum_variant()\");\n             let idx = try!(self._next_uint(EsEnumVid));\n-            debug!(\"  idx={}\", idx);\n+            debug!(\"  idx={:?}\", idx);\n \n             let doc = try!(self.next_doc(EsEnumBody));\n \n@@ -526,7 +526,7 @@ pub mod reader {\n         fn read_enum_variant_arg<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n-            debug!(\"read_enum_variant_arg(idx={})\", idx);\n+            debug!(\"read_enum_variant_arg(idx={:?})\", idx);\n             f(self)\n         }\n \n@@ -536,7 +536,7 @@ pub mod reader {\n         {\n             debug!(\"read_enum_struct_variant()\");\n             let idx = try!(self._next_uint(EsEnumVid));\n-            debug!(\"  idx={}\", idx);\n+            debug!(\"  idx={:?}\", idx);\n \n             let doc = try!(self.next_doc(EsEnumBody));\n \n@@ -558,21 +558,21 @@ pub mod reader {\n                                                 -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n-                debug!(\"read_enum_struct_variant_arg(name={}, idx={})\", name, idx);\n+                debug!(\"read_enum_struct_variant_arg(name={:?}, idx={:?})\", name, idx);\n             f(self)\n         }\n \n         fn read_struct<T, F>(&mut self, name: &str, _: uint, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n-            debug!(\"read_struct(name={})\", name);\n+            debug!(\"read_struct(name={:?})\", name);\n             f(self)\n         }\n \n         fn read_struct_field<T, F>(&mut self, name: &str, idx: uint, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n-            debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n+            debug!(\"read_struct_field(name={:?}, idx={:?})\", name, idx);\n             try!(self._check_label(name));\n             f(self)\n         }\n@@ -594,14 +594,14 @@ pub mod reader {\n         fn read_tuple_arg<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n-            debug!(\"read_tuple_arg(idx={})\", idx);\n+            debug!(\"read_tuple_arg(idx={:?})\", idx);\n             self.read_seq_elt(idx, f)\n         }\n \n         fn read_tuple_struct<T, F>(&mut self, name: &str, len: uint, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n-            debug!(\"read_tuple_struct(name={})\", name);\n+            debug!(\"read_tuple_struct(name={:?})\", name);\n             self.read_tuple(len, f)\n         }\n \n@@ -611,7 +611,7 @@ pub mod reader {\n                                        -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n-            debug!(\"read_tuple_struct_arg(idx={})\", idx);\n+            debug!(\"read_tuple_struct_arg(idx={:?})\", idx);\n             self.read_tuple_arg(idx, f)\n         }\n \n@@ -638,15 +638,15 @@ pub mod reader {\n             debug!(\"read_seq()\");\n             self.push_doc(EsVec, move |d| {\n                 let len = try!(d._next_uint(EsVecLen));\n-                debug!(\"  len={}\", len);\n+                debug!(\"  len={:?}\", len);\n                 f(d, len)\n             })\n         }\n \n         fn read_seq_elt<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n-            debug!(\"read_seq_elt(idx={})\", idx);\n+            debug!(\"read_seq_elt(idx={:?})\", idx);\n             self.push_doc(EsVecElt, f)\n         }\n \n@@ -656,22 +656,22 @@ pub mod reader {\n             debug!(\"read_map()\");\n             self.push_doc(EsMap, move |d| {\n                 let len = try!(d._next_uint(EsMapLen));\n-                debug!(\"  len={}\", len);\n+                debug!(\"  len={:?}\", len);\n                 f(d, len)\n             })\n         }\n \n         fn read_map_elt_key<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n-            debug!(\"read_map_elt_key(idx={})\", idx);\n+            debug!(\"read_map_elt_key(idx={:?})\", idx);\n             self.push_doc(EsMapKey, f)\n         }\n \n         fn read_map_elt_val<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n-            debug!(\"read_map_elt_val(idx={})\", idx);\n+            debug!(\"read_map_elt_val(idx={:?})\", idx);\n             self.push_doc(EsMapVal, f)\n         }\n \n@@ -1007,7 +1007,7 @@ pub mod writer {\n         }\n \n         pub fn start_tag(&mut self, tag_id: uint) -> EncodeResult {\n-            debug!(\"Start tag {}\", tag_id);\n+            debug!(\"Start tag {:?}\", tag_id);\n \n             // Write the enum ID:\n             try!(write_vuint(self.writer, tag_id));\n@@ -1026,7 +1026,7 @@ pub mod writer {\n             try!(write_sized_vuint(self.writer, size, 4u));\n             let r = try!(self.writer.seek(cur_pos as i64, io::SeekSet));\n \n-            debug!(\"End tag (size = {})\", size);\n+            debug!(\"End tag (size = {:?})\", size);\n             Ok(r)\n         }\n \n@@ -1093,12 +1093,12 @@ pub mod writer {\n         }\n \n         pub fn wr_bytes(&mut self, b: &[u8]) -> EncodeResult {\n-            debug!(\"Write {} bytes\", b.len());\n+            debug!(\"Write {:?} bytes\", b.len());\n             self.writer.write(b)\n         }\n \n         pub fn wr_str(&mut self, s: &str) -> EncodeResult {\n-            debug!(\"Write str: {}\", s);\n+            debug!(\"Write str: {:?}\", s);\n             self.writer.write(s.as_bytes())\n         }\n     }\n@@ -1608,7 +1608,7 @@ mod tests {\n     #[test]\n     fn test_option_int() {\n         fn test_v(v: Option<int>) {\n-            debug!(\"v == {}\", v);\n+            debug!(\"v == {:?}\", v);\n             let mut wr = SeekableMemWriter::new();\n             {\n                 let mut rbml_w = writer::Encoder::new(&mut wr);\n@@ -1617,7 +1617,7 @@ mod tests {\n             let rbml_doc = Doc::new(wr.get_ref());\n             let mut deser = reader::Decoder::new(rbml_doc);\n             let v1 = Decodable::decode(&mut deser).unwrap();\n-            debug!(\"v1 == {}\", v1);\n+            debug!(\"v1 == {:?}\", v1);\n             assert_eq!(v, v1);\n         }\n "}, {"sha": "92ed048bae0db0eb45690aeb88b283989e51f474", "filename": "src/libregex/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -13,7 +13,6 @@\n //! Regular expressions implemented in Rust\n //!\n //! For official documentation, see the rust-lang/regex crate\n-\n #![crate_name = \"regex\"]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]"}, {"sha": "dd11d42b8aad60b0186701538d1554d1de626d52", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -40,7 +40,7 @@ pub struct Error {\n \n impl fmt::Show for Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Regex syntax error near position {}: {}\",\n+        write!(f, \"Regex syntax error near position {}: {:?}\",\n                self.pos, self.msg)\n     }\n }\n@@ -122,15 +122,15 @@ impl BuildAst {\n     fn flags(&self) -> Flags {\n         match *self {\n             Paren(flags, _, _) => flags,\n-            _ => panic!(\"Cannot get flags from {}\", self),\n+            _ => panic!(\"Cannot get flags from {:?}\", self),\n         }\n     }\n \n     fn capture(&self) -> Option<uint> {\n         match *self {\n             Paren(_, 0, _) => None,\n             Paren(_, c, _) => Some(c),\n-            _ => panic!(\"Cannot get capture group from {}\", self),\n+            _ => panic!(\"Cannot get capture group from {:?}\", self),\n         }\n     }\n \n@@ -144,7 +144,7 @@ impl BuildAst {\n                     Some(name.clone())\n                 }\n             }\n-            _ => panic!(\"Cannot get capture name from {}\", self),\n+            _ => panic!(\"Cannot get capture name from {:?}\", self),\n         }\n     }\n \n@@ -158,7 +158,7 @@ impl BuildAst {\n     fn unwrap(self) -> Result<Ast, Error> {\n         match self {\n             Expr(x) => Ok(x),\n-            _ => panic!(\"Tried to unwrap non-AST item: {}\", self),\n+            _ => panic!(\"Tried to unwrap non-AST item: {:?}\", self),\n         }\n     }\n }\n@@ -285,7 +285,7 @@ impl<'a> Parser<'a> {\n         match self.next_char() {\n             true => Ok(()),\n             false => {\n-                self.err(format!(\"Expected {} but got EOF.\",\n+                self.err(format!(\"Expected {:?} but got EOF.\",\n                                  expected).index(&FullRange))\n             }\n         }\n@@ -294,10 +294,10 @@ impl<'a> Parser<'a> {\n     fn expect(&mut self, expected: char) -> Result<(), Error> {\n         match self.next_char() {\n             true if self.cur() == expected => Ok(()),\n-            true => self.err(format!(\"Expected '{}' but got '{}'.\",\n+            true => self.err(format!(\"Expected '{:?}' but got '{:?}'.\",\n                                      expected, self.cur()).index(&FullRange)),\n             false => {\n-                self.err(format!(\"Expected '{}' but got EOF.\",\n+                self.err(format!(\"Expected '{:?}' but got EOF.\",\n                                  expected).index(&FullRange))\n             }\n         }\n@@ -395,7 +395,7 @@ impl<'a> Parser<'a> {\n                             continue\n                         }\n                         Some(ast) =>\n-                            panic!(\"Expected Class AST but got '{}'\", ast),\n+                            panic!(\"Expected Class AST but got '{:?}'\", ast),\n                         // Just drop down and try to add as a regular character.\n                         None => {},\n                     },\n@@ -410,7 +410,7 @@ impl<'a> Parser<'a> {\n                             return self.err(\n                                 \"\\\\A, \\\\z, \\\\b and \\\\B are not valid escape \\\n                                  sequences inside a character class.\"),\n-                        ast => panic!(\"Unexpected AST item '{}'\", ast),\n+                        ast => panic!(\"Unexpected AST item '{:?}'\", ast),\n                     }\n                 }\n                 ']' if ranges.len() > 0 || alts.len() > 0 => {\n@@ -443,7 +443,7 @@ impl<'a> Parser<'a> {\n                     match try!(self.parse_escape()) {\n                         Literal(c3, _) => c2 = c3, // allow literal escapes below\n                         ast =>\n-                            return self.err(format!(\"Expected a literal, but got {}.\",\n+                            return self.err(format!(\"Expected a literal, but got {:?}.\",\n                                                     ast).index(&FullRange)),\n                     }\n                 }\n@@ -513,7 +513,7 @@ impl<'a> Parser<'a> {\n                 None => {\n                     return self.err(format!(\"No closing brace for counted \\\n                                              repetition starting at position \\\n-                                             {}.\",\n+                                             {:?}.\",\n                                             start).index(&FullRange))\n                 }\n             };\n@@ -686,7 +686,7 @@ impl<'a> Parser<'a> {\n         match num::from_str_radix::<u32>(s.index(&FullRange), 8) {\n             Some(n) => Ok(Literal(try!(self.char_from_u32(n)), FLAG_EMPTY)),\n             None => {\n-                self.err(format!(\"Could not parse '{}' as octal number.\",\n+                self.err(format!(\"Could not parse '{:?}' as octal number.\",\n                                  s).index(&FullRange))\n             }\n         }"}, {"sha": "37f9869f3bfaf6e50e0be95965f8fe993472390c", "filename": "src/libregex/re.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -90,10 +90,19 @@ impl Clone for ExNative {\n     }\n }\n \n+#[cfg(stage0)]\n+//FIXME: remove after stage0 snapshot\n impl fmt::Show for Regex {\n     /// Shows the original regular expression.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.as_str())\n+        fmt::String::fmt(self.as_str(), f)\n+    }\n+}\n+\n+impl fmt::String for Regex {\n+    /// Shows the original regular expression.\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self.as_str(), f)\n     }\n }\n "}, {"sha": "acf0cc6bd957b5681441dcbe543dabb43ae29432", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -1629,7 +1629,6 @@ declare_lint! {\n     Warn,\n     \"detects use of #[deprecated] items\"\n }\n-\n // FIXME #6875: Change to Warn after std library stabilization is complete\n declare_lint! {\n     EXPERIMENTAL,\n@@ -1848,7 +1847,7 @@ declare_lint! {\n     \"detects transmutes of fat pointers\"\n }\n \n-declare_lint!{\n+declare_lint! {\n     pub MISSING_COPY_IMPLEMENTATIONS,\n     Warn,\n     \"detects potentially-forgotten implementations of `Copy`\""}, {"sha": "72ce61b133a2bad37f32d9f3296b26c6ddc018f8", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -246,13 +246,13 @@ pub fn get_field_type<'tcx>(tcx: &ty::ctxt<'tcx>, class_id: ast::DefId,\n     let class_doc = expect(tcx.sess.diagnostic(),\n                            decoder::maybe_find_item(class_id.node, all_items),\n                            || {\n-        (format!(\"get_field_type: class ID {} not found\",\n+        (format!(\"get_field_type: class ID {:?} not found\",\n                  class_id)).to_string()\n     });\n     let the_field = expect(tcx.sess.diagnostic(),\n         decoder::maybe_find_item(def.node, class_doc),\n         || {\n-            (format!(\"get_field_type: in class {}, field ID {} not found\",\n+            (format!(\"get_field_type: in class {:?}, field ID {:?} not found\",\n                     class_id,\n                     def)).to_string()\n         });"}, {"sha": "a13df5a220fb8acdbc0c3bde45ae0d0215dbcf0d", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -845,7 +845,7 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                     parent_id: NodeId,\n                                     ast_item_opt: Option<&ast::ImplItem>) {\n \n-    debug!(\"encode_info_for_method: {} {}\", m.def_id,\n+    debug!(\"encode_info_for_method: {:?} {:?}\", m.def_id,\n            token::get_name(m.name));\n     rbml_w.start_tag(tag_items_data_item);\n \n@@ -887,7 +887,7 @@ fn encode_info_for_associated_type(ecx: &EncodeContext,\n                                    impl_path: PathElems,\n                                    parent_id: NodeId,\n                                    typedef_opt: Option<P<ast::Typedef>>) {\n-    debug!(\"encode_info_for_associated_type({},{})\",\n+    debug!(\"encode_info_for_associated_type({:?},{:?})\",\n            associated_type.def_id,\n            token::get_name(associated_type.name));\n "}, {"sha": "a4304bf1e2d62a7d7918c9dbc003d57eb746a76b", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -738,12 +738,12 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n \n     let crate_num = match str::from_utf8(crate_part).ok().and_then(|s| s.parse::<uint>()) {\n        Some(cn) => cn as ast::CrateNum,\n-       None => panic!(\"internal error: parse_def_id: crate number expected, found {}\",\n+       None => panic!(\"internal error: parse_def_id: crate number expected, found {:?}\",\n                      crate_part)\n     };\n     let def_num = match str::from_utf8(def_part).ok().and_then(|s| s.parse::<uint>()) {\n        Some(dn) => dn as ast::NodeId,\n-       None => panic!(\"internal error: parse_def_id: id expected, found {}\",\n+       None => panic!(\"internal error: parse_def_id: id expected, found {:?}\",\n                      def_part)\n     };\n     ast::DefId { krate: crate_num, node: def_num }"}, {"sha": "39e15832bb7aa648729bc9dfe1249d65b05b7113", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -82,7 +82,7 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n         e::IIImplItemRef(_, &ast::MethodImplItem(ref m)) => m.id,\n         e::IIImplItemRef(_, &ast::TypeImplItem(ref ti)) => ti.id,\n     };\n-    debug!(\"> Encoding inlined item: {} ({})\",\n+    debug!(\"> Encoding inlined item: {} ({:?})\",\n            ecx.tcx.map.path_to_string(id),\n            rbml_w.writer.tell());\n \n@@ -96,7 +96,7 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n     encode_side_tables_for_ii(ecx, rbml_w, &ii);\n     rbml_w.end_tag();\n \n-    debug!(\"< Encoded inlined fn: {} ({})\",\n+    debug!(\"< Encoded inlined fn: {} ({:?})\",\n            ecx.tcx.map.path_to_string(id),\n            rbml_w.writer.tell());\n }\n@@ -127,7 +127,7 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n       None => Err(path),\n       Some(ast_doc) => {\n         let mut path_as_str = None;\n-        debug!(\"> Decoding inlined fn: {}::?\",\n+        debug!(\"> Decoding inlined fn: {:?}::?\",\n         {\n             // Do an Option dance to use the path after it is moved below.\n             let s = ast_map::path_to_string(ast_map::Values(path.iter()));\n@@ -1880,7 +1880,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n             NominalType | TypeWithId | RegionParameter => dcx.tr_def_id(did),\n             TypeParameter | UnboxedClosureSource => dcx.tr_intern_def_id(did)\n         };\n-        debug!(\"convert_def_id(source={}, did={})={}\", source, did, r);\n+        debug!(\"convert_def_id(source={:?}, did={:?})={:?}\", source, did, r);\n         return r;\n     }\n }"}, {"sha": "de3ce9f115e721ea51ac2aad37d902ece1593371", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -480,12 +480,12 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 let inputs = inline_asm.inputs.iter();\n                 let outputs = inline_asm.outputs.iter();\n                 let post_inputs = self.exprs(inputs.map(|a| {\n-                    debug!(\"cfg::construct InlineAsm id:{} input:{}\", expr.id, a);\n+                    debug!(\"cfg::construct InlineAsm id:{} input:{:?}\", expr.id, a);\n                     let &(_, ref expr) = a;\n                     &**expr\n                 }), pred);\n                 let post_outputs = self.exprs(outputs.map(|a| {\n-                    debug!(\"cfg::construct InlineAsm id:{} output:{}\", expr.id, a);\n+                    debug!(\"cfg::construct InlineAsm id:{} output:{:?}\", expr.id, a);\n                     let &(_, ref expr, _) = a;\n                     &**expr\n                 }), post_inputs);\n@@ -622,7 +622,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                     r => {\n                         self.tcx.sess.span_bug(\n                             expr.span,\n-                            format!(\"bad entry `{}` in def_map for label\",\n+                            format!(\"bad entry `{:?}` in def_map for label\",\n                                     r).index(&FullRange));\n                     }\n                 }"}, {"sha": "621d7274b3f7c01a41c3c386ab8c1c3cf4623c5d", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -118,7 +118,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) {\n                 DefStruct(_) | DefVariant(_, _, _) => {}\n \n                 def => {\n-                    debug!(\"(checking const) found bad def: {}\", def);\n+                    debug!(\"(checking const) found bad def: {:?}\", def);\n                     span_err!(v.tcx.sess, e.span, E0014,\n                               \"paths in constants may only refer to constants \\\n                                or functions\");"}, {"sha": "f1edfb37273bb37f73ed1229c8d3768ec45fc31d", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -574,7 +574,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n              witness: WitnessPreference)\n              -> Usefulness {\n     let &Matrix(ref rows) = matrix;\n-    debug!(\"{:}\", matrix);\n+    debug!(\"{:?}\", matrix);\n     if rows.len() == 0u {\n         return match witness {\n             ConstructWitness => UsefulWithWitness(vec!()),\n@@ -1042,7 +1042,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                         cx.tcx.sess.span_bug(\n                             p.span,\n                             format!(\"binding pattern {} is not an \\\n-                                     identifier: {}\",\n+                                     identifier: {:?}\",\n                                     p.id,\n                                     p.node).index(&FullRange));\n                     }"}, {"sha": "5ff1f36f0e06abae12e525a013003809e6539d3f", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -59,7 +59,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for RvalueContextDelegate<'a, 'tcx> {\n                span: Span,\n                cmt: mc::cmt<'tcx>,\n                _: euv::ConsumeMode) {\n-        debug!(\"consume; cmt: {}; type: {}\", *cmt, ty_to_string(self.tcx, cmt.ty));\n+        debug!(\"consume; cmt: {:?}; type: {}\", *cmt, ty_to_string(self.tcx, cmt.ty));\n         if !ty::type_is_sized(self.param_env, span, cmt.ty) {\n             span_err!(self.tcx.sess, span, E0161,\n                 \"cannot move a value of type {0}: the size of {0} cannot be statically determined\","}, {"sha": "bdd98a94fc32fba293defd79466b811d0c7fc395", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -196,7 +196,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         let words_per_id = (bits_per_id + uint::BITS - 1) / uint::BITS;\n         let num_nodes = cfg.graph.all_nodes().len();\n \n-        debug!(\"DataFlowContext::new(analysis_name: {}, id_range={}, \\\n+        debug!(\"DataFlowContext::new(analysis_name: {}, id_range={:?}, \\\n                                      bits_per_id={}, words_per_id={}) \\\n                                      num_nodes: {}\",\n                analysis_name, id_range, bits_per_id, words_per_id,\n@@ -251,7 +251,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n     fn apply_gen_kill(&self, cfgidx: CFGIndex, bits: &mut [uint]) {\n         //! Applies the gen and kill sets for `cfgidx` to `bits`\n-        debug!(\"{} apply_gen_kill(cfgidx={}, bits={}) [before]\",\n+        debug!(\"{} apply_gen_kill(cfgidx={:?}, bits={}) [before]\",\n                self.analysis_name, cfgidx, mut_bits_to_string(bits));\n         assert!(self.bits_per_id > 0);\n \n@@ -261,7 +261,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         let kills = self.kills.slice(start, end);\n         bitwise(bits, kills, &Subtract);\n \n-        debug!(\"{} apply_gen_kill(cfgidx={}, bits={}) [after]\",\n+        debug!(\"{} apply_gen_kill(cfgidx={:?}, bits={}) [after]\",\n                self.analysis_name, cfgidx, mut_bits_to_string(bits));\n     }\n \n@@ -315,7 +315,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                 temp_bits.index(&FullRange)\n             }\n         };\n-        debug!(\"{} each_bit_for_node({}, cfgidx={}) bits={}\",\n+        debug!(\"{} each_bit_for_node({:?}, cfgidx={:?}) bits={}\",\n                self.analysis_name, e, cfgidx, bits_to_string(slice));\n         self.each_bit(slice, f)\n     }\n@@ -410,7 +410,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                         }\n                     }\n                     None => {\n-                        debug!(\"{} add_kills_from_flow_exits flow_exit={} \\\n+                        debug!(\"{} add_kills_from_flow_exits flow_exit={:?} \\\n                                 no cfg_idx for exiting_scope={}\",\n                                self.analysis_name, flow_exit, node_id);\n                     }\n@@ -419,10 +419,10 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n             if changed {\n                 let bits = self.kills.slice_mut(start, end);\n-                debug!(\"{} add_kills_from_flow_exits flow_exit={} bits={} [before]\",\n+                debug!(\"{} add_kills_from_flow_exits flow_exit={:?} bits={} [before]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n                 bits.clone_from_slice(orig_kills.index(&FullRange));\n-                debug!(\"{} add_kills_from_flow_exits flow_exit={} bits={} [after]\",\n+                debug!(\"{} add_kills_from_flow_exits flow_exit={:?} bits={} [after]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n             }\n             true\n@@ -481,7 +481,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n         assert!(self.dfcx.bits_per_id > 0);\n \n         cfg.graph.each_node(|node_index, node| {\n-            debug!(\"DataFlowContext::walk_cfg idx={} id={} begin in_out={}\",\n+            debug!(\"DataFlowContext::walk_cfg idx={:?} id={} begin in_out={}\",\n                    node_index, node.data.id, bits_to_string(in_out));\n \n             let (start, end) = self.dfcx.compute_id_range(node_index);\n@@ -521,7 +521,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n                                          edge: &cfg::CFGEdge) {\n         let source = edge.source();\n         let cfgidx = edge.target();\n-        debug!(\"{} propagate_bits_into_entry_set_for(pred_bits={}, {} to {})\",\n+        debug!(\"{} propagate_bits_into_entry_set_for(pred_bits={}, {:?} to {:?})\",\n                self.dfcx.analysis_name, bits_to_string(pred_bits), source, cfgidx);\n         assert!(self.dfcx.bits_per_id > 0);\n \n@@ -532,7 +532,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n             bitwise(on_entry, pred_bits, &self.dfcx.oper)\n         };\n         if changed {\n-            debug!(\"{} changed entry set for {} to {}\",\n+            debug!(\"{} changed entry set for {:?} to {}\",\n                    self.dfcx.analysis_name, cfgidx,\n                    bits_to_string(self.dfcx.on_entry.slice(start, end)));\n             self.changed = true;"}, {"sha": "0bc899a8a62937ec3ff7c956a0c23dc5e4c77b2a", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -149,7 +149,7 @@ fn calculate_type(sess: &session::Session,\n             add_library(sess, cnum, cstore::RequireDynamic, &mut formats);\n             let deps = csearch::get_dylib_dependency_formats(&sess.cstore, cnum);\n             for &(depnum, style) in deps.iter() {\n-                debug!(\"adding {}: {}\", style,\n+                debug!(\"adding {:?}: {}\", style,\n                        sess.cstore.get_crate_data(depnum).name.clone());\n                 add_library(sess, depnum, style, &mut formats);\n             }"}, {"sha": "046271613cadafcc9225e934b845179cc02d1519", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -1019,7 +1019,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             if pat_util::pat_is_binding(def_map, pat) {\n                 let tcx = typer.tcx();\n \n-                debug!(\"binding cmt_pat={} pat={} match_mode={}\",\n+                debug!(\"binding cmt_pat={} pat={} match_mode={:?}\",\n                        cmt_pat.repr(tcx),\n                        pat.repr(tcx),\n                        match_mode);\n@@ -1155,7 +1155,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                             // pattern.\n \n                             if !tcx.sess.has_errors() {\n-                                let msg = format!(\"Pattern has unexpected type: {} and type {}\",\n+                                let msg = format!(\"Pattern has unexpected type: {:?} and type {}\",\n                                                   def,\n                                                   cmt_pat.ty.repr(tcx));\n                                 tcx.sess.span_bug(pat.span, msg.as_slice())\n@@ -1172,7 +1172,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                             // reported.\n \n                             if !tcx.sess.has_errors() {\n-                                let msg = format!(\"Pattern has unexpected def: {} and type {}\",\n+                                let msg = format!(\"Pattern has unexpected def: {:?} and type {}\",\n                                                   def,\n                                                   cmt_pat.ty.repr(tcx));\n                                 tcx.sess.span_bug(pat.span, msg.index(&FullRange))"}, {"sha": "26cafb3c3d4a3dbc54de9009e3f0571d5f104f39", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -55,7 +55,7 @@ pub struct Edge<E> {\n \n impl<E: Show> Show for Edge<E> {\n     fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n-        write!(f, \"Edge {{ next_edge: [{}, {}], source: {}, target: {}, data: {} }}\",\n+        write!(f, \"Edge {{ next_edge: [{:?}, {:?}], source: {:?}, target: {:?}, data: {:?} }}\",\n                self.next_edge[0], self.next_edge[1], self.source,\n                self.target, self.data)\n     }"}, {"sha": "9f87e73d4af9df47ace6d33f6e2d608da2e73875", "filename": "src/librustc/middle/infer/coercion.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -265,7 +265,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                                  ty::mt{ty: ty, mutbl: mt_b.mutbl});\n                             try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n-                                    AutoPtr(AutoUnsize({})))\", kind);\n+                                    AutoPtr(AutoUnsize({:?})))\", kind);\n                             Ok(Some(AdjustDerefRef(AutoDerefRef {\n                                 autoderefs: 1,\n                                 autoref: Some(ty::AutoPtr(r_borrow, mt_b.mutbl,\n@@ -288,7 +288,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                                  ty::mt{ty: ty, mutbl: mt_b.mutbl});\n                             try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n-                                    AutoPtr(AutoUnsize({})))\", kind);\n+                                    AutoPtr(AutoUnsize({:?})))\", kind);\n                             Ok(Some(AdjustDerefRef(AutoDerefRef {\n                                 autoderefs: 1,\n                                 autoref: Some(ty::AutoUnsafe(mt_b.mutbl,\n@@ -306,7 +306,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                             let ty = ty::mk_uniq(self.tcx(), ty);\n                             try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n-                                    AutoUnsizeUniq({}))\", kind);\n+                                    AutoUnsizeUniq({:?}))\", kind);\n                             Ok(Some(AdjustDerefRef(AutoDerefRef {\n                                 autoderefs: 1,\n                                 autoref: Some(ty::AutoUnsizeUniq(kind))\n@@ -328,7 +328,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                  a: Ty<'tcx>,\n                  ty_b: Ty<'tcx>)\n                  -> Option<(Ty<'tcx>, ty::UnsizeKind<'tcx>)> {\n-        debug!(\"unsize_ty(a={}, ty_b={})\", a, ty_b.repr(self.tcx()));\n+        debug!(\"unsize_ty(a={:?}, ty_b={})\", a, ty_b.repr(self.tcx()));\n \n         let tcx = self.tcx();\n \n@@ -406,7 +406,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     {\n         let tcx = self.tcx();\n \n-        debug!(\"coerce_borrowed_object(a={}, b={}, b_mutbl={})\",\n+        debug!(\"coerce_borrowed_object(a={}, b={}, b_mutbl={:?})\",\n                a.repr(tcx),\n                b.repr(tcx), b_mutbl);\n \n@@ -426,7 +426,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     {\n         let tcx = self.tcx();\n \n-        debug!(\"coerce_unsafe_object(a={}, b={}, b_mutbl={})\",\n+        debug!(\"coerce_unsafe_object(a={}, b={}, b_mutbl={:?})\",\n                a.repr(tcx),\n                b.repr(tcx), b_mutbl);\n \n@@ -449,7 +449,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         match a.sty {\n             ty::ty_rptr(_, ty::mt{ty, mutbl}) => match ty.sty {\n                 ty::ty_trait(box ty::TyTrait { ref principal, ref bounds }) => {\n-                    debug!(\"mutbl={} b_mutbl={}\", mutbl, b_mutbl);\n+                    debug!(\"mutbl={:?} b_mutbl={:?}\", mutbl, b_mutbl);\n                     let tr = ty::mk_trait(tcx, principal.clone(), bounds.clone());\n                     try!(self.subtype(mk_ty(tr), b));\n                     Ok(Some(AdjustDerefRef(AutoDerefRef {"}, {"sha": "22975f54a9fb4e73cee177ab340c947adb234393", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -361,7 +361,7 @@ pub trait Combine<'tcx> : Sized {\n                     a: ty::TraitStore,\n                     b: ty::TraitStore)\n                     -> cres<'tcx, ty::TraitStore> {\n-        debug!(\"{}.trait_stores(a={}, b={})\", self.tag(), a, b);\n+        debug!(\"{}.trait_stores(a={:?}, b={:?})\", self.tag(), a, b);\n \n         match (a, b) {\n             (ty::RegionTraitStore(a_r, a_m),\n@@ -471,7 +471,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n     let tcx = this.infcx().tcx;\n     let a_sty = &a.sty;\n     let b_sty = &b.sty;\n-    debug!(\"super_tys: a_sty={} b_sty={}\", a_sty, b_sty);\n+    debug!(\"super_tys: a_sty={:?} b_sty={:?}\", a_sty, b_sty);\n     return match (a_sty, b_sty) {\n       // The \"subtype\" ought to be handling cases involving var:\n       (&ty::ty_infer(TyVar(_)), _) |\n@@ -550,7 +550,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n \n       (&ty::ty_trait(ref a_),\n        &ty::ty_trait(ref b_)) => {\n-          debug!(\"Trying to match traits {} and {}\", a, b);\n+          debug!(\"Trying to match traits {:?} and {:?}\", a, b);\n           let principal = try!(this.binders(&a_.principal, &b_.principal));\n           let bounds = try!(this.existential_bounds(&a_.bounds, &b_.bounds));\n           Ok(ty::mk_trait(tcx, principal, bounds))\n@@ -724,7 +724,7 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n                 Some(e) => e,\n             };\n \n-            debug!(\"instantiate(a_ty={} dir={} b_vid={})\",\n+            debug!(\"instantiate(a_ty={} dir={:?} b_vid={})\",\n                    a_ty.repr(tcx),\n                    dir,\n                    b_vid.repr(tcx));\n@@ -745,7 +745,7 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n                             self.generalize(a_ty, b_vid, true)\n                         }\n                     });\n-                    debug!(\"instantiate(a_ty={}, dir={}, \\\n+                    debug!(\"instantiate(a_ty={}, dir={:?}, \\\n                                         b_vid={}, generalized_ty={})\",\n                            a_ty.repr(tcx), dir, b_vid.repr(tcx),\n                            generalized_ty.repr(tcx));"}, {"sha": "64b3c14ff699d9c53f1669d77be5bc391e9a528a", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -268,7 +268,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 }\n             }\n             let pe = ProcessedErrors(var_origins, trace_origins, same_regions);\n-            debug!(\"errors processed: {}\", pe);\n+            debug!(\"errors processed: {:?}\", pe);\n             processed_errors.push(pe);\n         }\n         return processed_errors;\n@@ -297,7 +297,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                      sub: Region,\n                                      sup: Region)\n                                      -> Option<FreeRegionsFromSameFn> {\n-            debug!(\"free_regions_from_same_fn(sub={}, sup={})\", sub, sup);\n+            debug!(\"free_regions_from_same_fn(sub={:?}, sup={:?})\", sub, sup);\n             let (scope_id, fr1, fr2) = match (sub, sup) {\n                 (ReFree(fr1), ReFree(fr2)) => {\n                     if fr1.scope != fr2.scope {"}, {"sha": "073052dd368709571097ad8e6b81add70c5ef09f", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -154,7 +154,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n             // Regions that pre-dated the LUB computation stay as they are.\n             if !is_var_in_set(new_vars, r0) {\n                 assert!(!r0.is_bound());\n-                debug!(\"generalize_region(r0={}): not new variable\", r0);\n+                debug!(\"generalize_region(r0={:?}): not new variable\", r0);\n                 return r0;\n             }\n \n@@ -164,8 +164,8 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n             // *related* to regions that pre-date the LUB computation\n             // stay as they are.\n             if !tainted.iter().all(|r| is_var_in_set(new_vars, *r)) {\n-                debug!(\"generalize_region(r0={}): \\\n-                        non-new-variables found in {}\",\n+                debug!(\"generalize_region(r0={:?}): \\\n+                        non-new-variables found in {:?}\",\n                        r0, tainted);\n                 assert!(!r0.is_bound());\n                 return r0;\n@@ -178,16 +178,16 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n             // with.\n             for (a_br, a_r) in a_map.iter() {\n                 if tainted.iter().any(|x| x == a_r) {\n-                    debug!(\"generalize_region(r0={}): \\\n-                            replacing with {}, tainted={}\",\n+                    debug!(\"generalize_region(r0={:?}): \\\n+                            replacing with {:?}, tainted={:?}\",\n                            r0, *a_br, tainted);\n                     return ty::ReLateBound(debruijn, *a_br);\n                 }\n             }\n \n             infcx.tcx.sess.span_bug(\n                 span,\n-                format!(\"region {} is not associated with \\\n+                format!(\"region {:?} is not associated with \\\n                          any bound region from A!\",\n                         r0).index(&FullRange))\n         }\n@@ -322,7 +322,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n             }\n             infcx.tcx.sess.span_bug(\n                 span,\n-                format!(\"could not find original bound region for {}\", r).index(&FullRange));\n+                format!(\"could not find original bound region for {:?}\", r).index(&FullRange));\n         }\n \n         fn fresh_bound_variable(infcx: &InferCtxt, debruijn: ty::DebruijnIndex) -> ty::Region {\n@@ -339,7 +339,7 @@ fn var_ids<'tcx, T: Combine<'tcx>>(combiner: &T,\n             r => {\n                 combiner.infcx().tcx.sess.span_bug(\n                     combiner.trace().origin.span(),\n-                    format!(\"found non-region-vid: {}\", r).index(&FullRange));\n+                    format!(\"found non-region-vid: {:?}\", r).index(&FullRange));\n             }\n         }).collect()\n }"}, {"sha": "3f18af3d768e4331319d3eab85b96569665e0230", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -989,7 +989,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                                    err: Option<&ty::type_err<'tcx>>) where\n         M: FnOnce(Option<String>, String) -> String,\n     {\n-        debug!(\"hi! expected_ty = {}, actual_ty = {}\", expected_ty, actual_ty);\n+        debug!(\"hi! expected_ty = {:?}, actual_ty = {}\", expected_ty, actual_ty);\n \n         let resolved_expected = expected_ty.map(|e_ty| self.resolve_type_vars_if_possible(&e_ty));\n \n@@ -1219,7 +1219,7 @@ impl<'tcx> Repr<'tcx> for SubregionOrigin<'tcx> {\n             }\n             Reborrow(a) => format!(\"Reborrow({})\", a.repr(tcx)),\n             ReborrowUpvar(a, b) => {\n-                format!(\"ReborrowUpvar({},{})\", a.repr(tcx), b)\n+                format!(\"ReborrowUpvar({},{:?})\", a.repr(tcx), b)\n             }\n             ReferenceOutlivesReferent(_, a) => {\n                 format!(\"ReferenceOutlivesReferent({})\", a.repr(tcx))\n@@ -1277,7 +1277,7 @@ impl<'tcx> Repr<'tcx> for RegionVariableOrigin<'tcx> {\n                 format!(\"EarlyBoundRegion({},{})\", a.repr(tcx), b.repr(tcx))\n             }\n             LateBoundRegion(a, b, c) => {\n-                format!(\"LateBoundRegion({},{},{})\", a.repr(tcx), b.repr(tcx), c)\n+                format!(\"LateBoundRegion({},{},{:?})\", a.repr(tcx), b.repr(tcx), c)\n             }\n             BoundRegionInCoherence(a) => {\n                 format!(\"bound_regionInCoherence({})\", a.repr(tcx))"}, {"sha": "16169610b52e948ed66e93492702e8cc5ae30231", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -67,7 +67,7 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n     }\n \n     let requested_output = os::getenv(\"RUST_REGION_GRAPH\");\n-    debug!(\"requested_output: {} requested_node: {}\",\n+    debug!(\"requested_output: {:?} requested_node: {:?}\",\n            requested_output, requested_node);\n \n     let output_path = {\n@@ -166,7 +166,7 @@ impl<'a, 'tcx> dot::Labeller<'a, Node, Edge> for ConstraintGraph<'a, 'tcx> {\n     fn node_label(&self, n: &Node) -> dot::LabelText {\n         match *n {\n             Node::RegionVid(n_vid) =>\n-                dot::LabelText::label(format!(\"{}\", n_vid)),\n+                dot::LabelText::label(format!(\"{:?}\", n_vid)),\n             Node::Region(n_rgn) =>\n                 dot::LabelText::label(format!(\"{}\", n_rgn.repr(self.tcx))),\n         }\n@@ -204,12 +204,12 @@ impl<'a, 'tcx> dot::GraphWalk<'a, Node, Edge> for ConstraintGraph<'a, 'tcx> {\n     }\n     fn source(&self, edge: &Edge) -> Node {\n         let (n1, _) = constraint_to_nodes(edge);\n-        debug!(\"edge {} has source {}\", edge, n1);\n+        debug!(\"edge {:?} has source {:?}\", edge, n1);\n         n1\n     }\n     fn target(&self, edge: &Edge) -> Node {\n         let (_, n2) = constraint_to_nodes(edge);\n-        debug!(\"edge {} has target {}\", edge, n2);\n+        debug!(\"edge {:?} has target {:?}\", edge, n2);\n         n2\n     }\n }"}, {"sha": "bdc787e4d589cc010a05eb29e8476d07e4c9e945", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -273,7 +273,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     pub fn rollback_to(&self, snapshot: RegionSnapshot) {\n-        debug!(\"RegionVarBindings: rollback_to({})\", snapshot);\n+        debug!(\"RegionVarBindings: rollback_to({:?})\", snapshot);\n         let mut undo_log = self.undo_log.borrow_mut();\n         assert!(undo_log.len() > snapshot.length);\n         assert!((*undo_log)[snapshot.length] == OpenSnapshot);\n@@ -325,7 +325,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         if self.in_snapshot() {\n             self.undo_log.borrow_mut().push(AddVar(vid));\n         }\n-        debug!(\"created new region variable {} with origin {}\",\n+        debug!(\"created new region variable {:?} with origin {}\",\n                vid, origin.repr(self.tcx));\n         return vid;\n     }\n@@ -427,7 +427,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n         let mut givens = self.givens.borrow_mut();\n         if givens.insert((sub, sup)) {\n-            debug!(\"add_given({} <= {})\",\n+            debug!(\"add_given({} <= {:?})\",\n                    sub.repr(self.tcx),\n                    sup);\n \n@@ -565,7 +565,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             }\n             Some(ref values) => {\n                 let r = lookup(values, rid);\n-                debug!(\"resolve_var({}) = {}\", rid, r.repr(self.tcx));\n+                debug!(\"resolve_var({:?}) = {}\", rid, r.repr(self.tcx));\n                 r\n             }\n         }\n@@ -602,7 +602,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n         relate(self, a, ReInfer(ReVar(c)));\n         relate(self, b, ReInfer(ReVar(c)));\n-        debug!(\"combine_vars() c={}\", c);\n+        debug!(\"combine_vars() c={:?}\", c);\n         ReInfer(ReVar(c))\n     }\n \n@@ -623,7 +623,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     /// made---`r0` itself will be the first entry. This is used when checking whether skolemized\n     /// regions are being improperly related to other regions.\n     pub fn tainted(&self, mark: &RegionSnapshot, r0: Region) -> Vec<Region> {\n-        debug!(\"tainted(mark={}, r0={})\", mark, r0.repr(self.tcx));\n+        debug!(\"tainted(mark={:?}, r0={})\", mark, r0.repr(self.tcx));\n         let _indenter = indenter();\n \n         // `result_set` acts as a worklist: we explore all outgoing\n@@ -634,7 +634,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         while result_index < result_set.len() {\n             // nb: can't use uint::range() here because result_set grows\n             let r = result_set[result_index];\n-            debug!(\"result_index={}, r={}\", result_index, r);\n+            debug!(\"result_index={}, r={:?}\", result_index, r);\n \n             for undo_entry in\n                 self.undo_log.borrow().slice_from(mark.length).iter()\n@@ -751,7 +751,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             self.tcx.sess.span_bug(\n                 (*self.var_origins.borrow())[v_id.index as uint].span(),\n                 format!(\"lub_concrete_regions invoked with \\\n-                         non-concrete regions: {}, {}\",\n+                         non-concrete regions: {:?}, {:?}\",\n                         a,\n                         b).index(&FullRange));\n           }\n@@ -827,7 +827,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                             a: Region,\n                             b: Region)\n                          -> cres<'tcx, Region> {\n-        debug!(\"glb_concrete_regions({}, {})\", a, b);\n+        debug!(\"glb_concrete_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n             (ReLateBound(..), _) |\n             (_, ReLateBound(..)) |\n@@ -854,7 +854,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 self.tcx.sess.span_bug(\n                     (*self.var_origins.borrow())[v_id.index as uint].span(),\n                     format!(\"glb_concrete_regions invoked with \\\n-                             non-concrete regions: {}, {}\",\n+                             non-concrete regions: {:?}, {:?}\",\n                             a,\n                             b).index(&FullRange));\n             }\n@@ -932,7 +932,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // scopes or two free regions.  So, if one of\n         // these scopes is a subscope of the other, return\n         // it. Otherwise fail.\n-        debug!(\"intersect_scopes(scope_a={}, scope_b={}, region_a={}, region_b={})\",\n+        debug!(\"intersect_scopes(scope_a={:?}, scope_b={:?}, region_a={:?}, region_b={:?})\",\n                scope_a, scope_b, region_a, region_b);\n         match self.tcx.region_maps.nearest_common_ancestor(scope_a, scope_b) {\n             Some(r_id) if scope_a == r_id => Ok(ReScope(scope_b)),\n@@ -971,7 +971,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n         // Dorky hack to cause `dump_constraints` to only get called\n         // if debug mode is enabled:\n-        debug!(\"----() End constraint listing {}---\", self.dump_constraints());\n+        debug!(\"----() End constraint listing {:?}---\", self.dump_constraints());\n         graphviz::maybe_print_constraints_for(self, subject);\n \n         self.expansion(var_data.as_mut_slice());\n@@ -1039,7 +1039,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                    b_data: &mut VarData)\n                    -> bool\n     {\n-        debug!(\"expand_node({}, {} == {})\",\n+        debug!(\"expand_node({}, {:?} == {})\",\n                a_region.repr(self.tcx),\n                b_vid,\n                b_data.value.repr(self.tcx));\n@@ -1058,7 +1058,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         b_data.classification = Expanding;\n         match b_data.value {\n           NoValue => {\n-            debug!(\"Setting initial value of {} to {}\",\n+            debug!(\"Setting initial value of {:?} to {}\",\n                    b_vid, a_region.repr(self.tcx));\n \n             b_data.value = Value(a_region);\n@@ -1071,7 +1071,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 return false;\n             }\n \n-            debug!(\"Expanding value of {} from {} to {}\",\n+            debug!(\"Expanding value of {:?} from {} to {}\",\n                    b_vid,\n                    cur_region.repr(self.tcx),\n                    lub.repr(self.tcx));\n@@ -1122,7 +1122,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                      a_data: &mut VarData,\n                      b_region: Region)\n                      -> bool {\n-        debug!(\"contract_node({} == {}/{}, {})\",\n+        debug!(\"contract_node({:?} == {}/{:?}, {})\",\n                a_vid, a_data.value.repr(self.tcx),\n                a_data.classification, b_region.repr(self.tcx));\n \n@@ -1156,7 +1156,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                       b_region: Region)\n                    -> bool {\n             if !this.is_subregion_of(a_region, b_region) {\n-                debug!(\"Setting {} to ErrorValue: {} not subregion of {}\",\n+                debug!(\"Setting {:?} to ErrorValue: {} not subregion of {}\",\n                        a_vid,\n                        a_region.repr(this.tcx),\n                        b_region.repr(this.tcx));\n@@ -1176,7 +1176,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     if glb == a_region {\n                         false\n                     } else {\n-                        debug!(\"Contracting value of {} from {} to {}\",\n+                        debug!(\"Contracting value of {:?} from {} to {}\",\n                                a_vid,\n                                a_region.repr(this.tcx),\n                                glb.repr(this.tcx));\n@@ -1185,7 +1185,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     }\n                 }\n                 Err(_) => {\n-                    debug!(\"Setting {} to ErrorValue: no glb of {}, {}\",\n+                    debug!(\"Setting {:?} to ErrorValue: no glb of {}, {}\",\n                            a_vid,\n                            a_region.repr(this.tcx),\n                            b_region.repr(this.tcx));\n@@ -1412,7 +1412,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         self.tcx.sess.span_bug(\n             (*self.var_origins.borrow())[node_idx.index as uint].span(),\n             format!(\"collect_error_for_expanding_node() could not find error \\\n-                    for var {}, lower_bounds={}, upper_bounds={}\",\n+                    for var {:?}, lower_bounds={}, upper_bounds={}\",\n                     node_idx,\n                     lower_bounds.repr(self.tcx),\n                     upper_bounds.repr(self.tcx)).index(&FullRange));\n@@ -1457,7 +1457,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         self.tcx.sess.span_bug(\n             (*self.var_origins.borrow())[node_idx.index as uint].span(),\n             format!(\"collect_error_for_contracting_node() could not find error \\\n-                     for var {}, upper_bounds={}\",\n+                     for var {:?}, upper_bounds={}\",\n                     node_idx,\n                     upper_bounds.repr(self.tcx)).index(&FullRange));\n     }\n@@ -1498,8 +1498,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 state.dup_found = true;\n             }\n \n-            debug!(\"collect_concrete_regions(orig_node_idx={}, node_idx={}, \\\n-                    classification={})\",\n+            debug!(\"collect_concrete_regions(orig_node_idx={:?}, node_idx={:?}, \\\n+                    classification={:?})\",\n                    orig_node_idx, node_idx, classification);\n \n             // figure out the direction from which this node takes its\n@@ -1520,7 +1520,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                          graph: &RegionGraph,\n                          source_vid: RegionVid,\n                          dir: Direction) {\n-            debug!(\"process_edges(source_vid={}, dir={})\", source_vid, dir);\n+            debug!(\"process_edges(source_vid={:?}, dir={:?})\", source_vid, dir);\n \n             let source_node_index = NodeIndex(source_vid.index as uint);\n             graph.each_adjacent_edge(source_node_index, dir, |_, edge| {"}, {"sha": "3f3e4c50e70479591b86bb15a3b67ac4cc94b8f4", "filename": "src/librustc/middle/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -184,7 +184,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n                         let escaping_type = self.probe(vid).unwrap();\n                         escaping_types.push(escaping_type);\n                     }\n-                    debug!(\"SpecifyVar({}) new_elem_threshold={}\", vid, new_elem_threshold);\n+                    debug!(\"SpecifyVar({:?}) new_elem_threshold={}\", vid, new_elem_threshold);\n                 }\n \n                 _ => { }"}, {"sha": "2d70e2cdc4dc97bc30d88c22903b9568de5be36f", "filename": "src/librustc/middle/infer/unify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -129,7 +129,7 @@ impl<'tcx, V:PartialEq+Clone+Repr<'tcx>, K:UnifyKey<'tcx, V>> UnificationTable<K\n     pub fn new_key(&mut self, value: V) -> K {\n         let index = self.values.push(Root(value, 0));\n         let k = UnifyKey::from_index(index);\n-        debug!(\"{}: created new key: {}\",\n+        debug!(\"{}: created new key: {:?}\",\n                UnifyKey::tag(None::<K>),\n                k);\n         k"}, {"sha": "41f293cfca52c5a895d54c243340a32d1334784d", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -209,7 +209,7 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n             }\n \n             Some((space, index, &param_ty)) => {\n-                debug!(\"with_each_combination: space={}, index={}, param_ty={}\",\n+                debug!(\"with_each_combination: space={:?}, index={}, param_ty={}\",\n                        space, index, param_ty.repr(self.tcx));\n \n                 if !ty::type_is_sized(param_env, span, param_ty) {"}, {"sha": "dab8faa3f78f1cccc685f86dc08668f1267f1e64", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -289,7 +289,7 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n         self.lnks.push(lnk);\n         self.num_live_nodes += 1;\n \n-        debug!(\"{} is of kind {}\", ln.to_string(),\n+        debug!(\"{:?} is of kind {}\", ln,\n                live_node_kind_to_string(lnk, self.tcx));\n \n         ln\n@@ -299,7 +299,7 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n         let ln = self.add_live_node(lnk);\n         self.live_node_map.insert(node_id, ln);\n \n-        debug!(\"{} is node {}\", ln.to_string(), node_id);\n+        debug!(\"{:?} is node {}\", ln, node_id);\n     }\n \n     fn add_variable(&mut self, vk: VarKind) -> Variable {\n@@ -314,7 +314,7 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n             ImplicitRet | CleanExit => {}\n         }\n \n-        debug!(\"{} is {}\", v.to_string(), vk);\n+        debug!(\"{:?} is {:?}\", v, vk);\n \n         v\n     }\n@@ -377,7 +377,7 @@ fn visit_fn(ir: &mut IrMaps,\n     // swap in a new set of IR maps for this function body:\n     let mut fn_maps = IrMaps::new(ir.tcx);\n \n-    debug!(\"creating fn_maps: {}\", &fn_maps as *const IrMaps);\n+    debug!(\"creating fn_maps: {:?}\", &fn_maps as *const IrMaps);\n \n     for arg in decl.inputs.iter() {\n         pat_util::pat_bindings(&ir.tcx.def_map,\n@@ -430,7 +430,7 @@ fn visit_local(ir: &mut IrMaps, local: &ast::Local) {\n fn visit_arm(ir: &mut IrMaps, arm: &ast::Arm) {\n     for pat in arm.pats.iter() {\n         pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n-            debug!(\"adding local variable {} from match with bm {}\",\n+            debug!(\"adding local variable {} from match with bm {:?}\",\n                    p_id, bm);\n             let name = path1.node;\n             ir.add_live_node_for_node(p_id, VarDefNode(sp));\n@@ -448,7 +448,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       // live nodes required for uses or definitions of variables:\n       ast::ExprPath(_) => {\n         let def = ir.tcx.def_map.borrow()[expr.id].clone();\n-        debug!(\"expr {}: path that leads to {}\", expr.id, def);\n+        debug!(\"expr {}: path that leads to {:?}\", expr.id, def);\n         if let DefLocal(..) = def {\n             ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         }\n@@ -491,7 +491,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       }\n       ast::ExprForLoop(ref pat, _, _, _) => {\n         pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n-            debug!(\"adding local variable {} from for loop with bm {}\",\n+            debug!(\"adding local variable {} from for loop with bm {:?}\",\n                    p_id, bm);\n             let name = path1.node;\n             ir.add_live_node_for_node(p_id, VarDefNode(sp));\n@@ -702,7 +702,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         for var_idx in range(0u, self.ir.num_vars) {\n             let idx = node_base_idx + var_idx;\n             if test(idx).is_valid() {\n-                try!(write!(wr, \" {}\", Variable(var_idx).to_string()));\n+                try!(write!(wr, \" {:?}\", Variable(var_idx)));\n             }\n         }\n         Ok(())\n@@ -740,11 +740,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         let mut wr = Vec::new();\n         {\n             let wr = &mut wr as &mut io::Writer;\n-            write!(wr, \"[ln({}) of kind {} reads\", ln.get(), self.ir.lnk(ln));\n+            write!(wr, \"[ln({:?}) of kind {:?} reads\", ln.get(), self.ir.lnk(ln));\n             self.write_vars(wr, ln, |idx| self.users[idx].reader);\n             write!(wr, \"  writes\");\n             self.write_vars(wr, ln, |idx| self.users[idx].writer);\n-            write!(wr, \"  precedes {}]\", self.successors[ln.get()].to_string());\n+            write!(wr, \"  precedes {:?}]\", self.successors[ln.get()]);\n         }\n         String::from_utf8(wr).unwrap()\n     }\n@@ -792,8 +792,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n         });\n \n-        debug!(\"merge_from_succ(ln={}, succ={}, first_merge={}, changed={})\",\n-               ln.to_string(), self.ln_str(succ_ln), first_merge, changed);\n+        debug!(\"merge_from_succ(ln={:?}, succ={}, first_merge={}, changed={})\",\n+               ln, self.ln_str(succ_ln), first_merge, changed);\n         return changed;\n \n         fn copy_if_invalid(src: LiveNode, dst: &mut LiveNode) -> bool {\n@@ -814,14 +814,14 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         self.users[idx].reader = invalid_node();\n         self.users[idx].writer = invalid_node();\n \n-        debug!(\"{} defines {} (idx={}): {}\", writer.to_string(), var.to_string(),\n+        debug!(\"{:?} defines {:?} (idx={}): {}\", writer, var,\n                idx, self.ln_str(writer));\n     }\n \n     // Either read, write, or both depending on the acc bitset\n     fn acc(&mut self, ln: LiveNode, var: Variable, acc: uint) {\n-        debug!(\"{} accesses[{:x}] {}: {}\",\n-               ln.to_string(), acc, var.to_string(), self.ln_str(ln));\n+        debug!(\"{:?} accesses[{:x}] {:?}: {}\",\n+               ln, acc, var, self.ln_str(ln));\n \n         let idx = self.idx(ln, var);\n         let user = &mut self.users[idx];\n@@ -857,14 +857,14 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               |this| this.propagate_through_fn_block(decl, body));\n \n         // hack to skip the loop unless debug! is enabled:\n-        debug!(\"^^ liveness computation results for body {} (entry={})\",\n+        debug!(\"^^ liveness computation results for body {} (entry={:?})\",\n                {\n                    for ln_idx in range(0u, self.ir.num_live_nodes) {\n-                       debug!(\"{}\", self.ln_str(LiveNode(ln_idx)));\n+                       debug!(\"{:?}\", self.ln_str(LiveNode(ln_idx)));\n                    }\n                    body.id\n                },\n-               entry_ln.to_string());\n+               entry_ln);\n \n         entry_ln\n     }"}, {"sha": "c472ea4a8140c108a0a1719ab9b0d567b5c464a9", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -539,7 +539,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                    expr_ty: Ty<'tcx>,\n                    def: def::Def)\n                    -> McResult<cmt<'tcx>> {\n-        debug!(\"cat_def: id={} expr={} def={}\",\n+        debug!(\"cat_def: id={} expr={} def={:?}\",\n                id, expr_ty.repr(self.tcx()), def);\n \n         match def {\n@@ -852,7 +852,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         };\n         let method_ty = self.typer.node_method_ty(method_call);\n \n-        debug!(\"cat_deref: method_call={} method_ty={}\",\n+        debug!(\"cat_deref: method_call={:?} method_ty={:?}\",\n                method_call, method_ty.map(|ty| ty.repr(self.tcx())));\n \n         let base_cmt = match method_ty {\n@@ -1447,7 +1447,7 @@ impl<'tcx> cmt_<'tcx> {\n \n impl<'tcx> Repr<'tcx> for cmt_<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"{{{} id:{} m:{} ty:{}}}\",\n+        format!(\"{{{} id:{} m:{:?} ty:{}}}\",\n                 self.cat.repr(tcx),\n                 self.id,\n                 self.mutbl,\n@@ -1462,7 +1462,7 @@ impl<'tcx> Repr<'tcx> for categorization<'tcx> {\n             cat_rvalue(..) |\n             cat_local(..) |\n             cat_upvar(..) => {\n-                format!(\"{}\", *self)\n+                format!(\"{:?}\", *self)\n             }\n             cat_deref(ref cmt, derefs, ptr) => {\n                 format!(\"{}-{}{}->\", cmt.cat.repr(tcx), ptr_sigil(ptr), derefs)"}, {"sha": "861c4a2c85e356b52f6750833e6fe10cc4fc4024", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -435,28 +435,28 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     fn def_privacy(&self, did: ast::DefId) -> PrivacyResult {\n         if !is_local(did) {\n             if self.external_exports.contains(&did) {\n-                debug!(\"privacy - {} was externally exported\", did);\n+                debug!(\"privacy - {:?} was externally exported\", did);\n                 return Allowable;\n             }\n-            debug!(\"privacy - is {} a public method\", did);\n+            debug!(\"privacy - is {:?} a public method\", did);\n \n             return match self.tcx.impl_or_trait_items.borrow().get(&did) {\n                 Some(&ty::MethodTraitItem(ref meth)) => {\n-                    debug!(\"privacy - well at least it's a method: {}\",\n+                    debug!(\"privacy - well at least it's a method: {:?}\",\n                            *meth);\n                     match meth.container {\n                         ty::TraitContainer(id) => {\n-                            debug!(\"privacy - recursing on trait {}\", id);\n+                            debug!(\"privacy - recursing on trait {:?}\", id);\n                             self.def_privacy(id)\n                         }\n                         ty::ImplContainer(id) => {\n                             match ty::impl_trait_ref(self.tcx, id) {\n                                 Some(t) => {\n-                                    debug!(\"privacy - impl of trait {}\", id);\n+                                    debug!(\"privacy - impl of trait {:?}\", id);\n                                     self.def_privacy(t.def_id)\n                                 }\n                                 None => {\n-                                    debug!(\"privacy - found a method {}\",\n+                                    debug!(\"privacy - found a method {:?}\",\n                                             meth.vis);\n                                     if meth.vis == ast::Public {\n                                         Allowable\n@@ -471,17 +471,17 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 Some(&ty::TypeTraitItem(ref typedef)) => {\n                     match typedef.container {\n                         ty::TraitContainer(id) => {\n-                            debug!(\"privacy - recursing on trait {}\", id);\n+                            debug!(\"privacy - recursing on trait {:?}\", id);\n                             self.def_privacy(id)\n                         }\n                         ty::ImplContainer(id) => {\n                             match ty::impl_trait_ref(self.tcx, id) {\n                                 Some(t) => {\n-                                    debug!(\"privacy - impl of trait {}\", id);\n+                                    debug!(\"privacy - impl of trait {:?}\", id);\n                                     self.def_privacy(t.def_id)\n                                 }\n                                 None => {\n-                                    debug!(\"privacy - found a typedef {}\",\n+                                    debug!(\"privacy - found a typedef {:?}\",\n                                             typedef.vis);\n                                     if typedef.vis == ast::Public {\n                                         Allowable\n@@ -696,7 +696,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         let fields = ty::lookup_struct_fields(self.tcx, id);\n         let field = match name {\n             NamedField(ident) => {\n-                debug!(\"privacy - check named field {} in struct {}\", ident.name, id);\n+                debug!(\"privacy - check named field {} in struct {:?}\", ident.name, id);\n                 fields.iter().find(|f| f.name == ident.name).unwrap()\n             }\n             UnnamedField(idx) => &fields[idx]"}, {"sha": "5d18843097f37f7f4491faba54220232a2347c36", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -146,24 +146,24 @@ impl RegionMaps {\n             None => {}\n         }\n \n-        debug!(\"relate_free_regions(sub={}, sup={})\", sub, sup);\n+        debug!(\"relate_free_regions(sub={:?}, sup={:?})\", sub, sup);\n         self.free_region_map.borrow_mut().insert(sub, vec!(sup));\n     }\n \n     pub fn record_encl_scope(&self, sub: CodeExtent, sup: CodeExtent) {\n-        debug!(\"record_encl_scope(sub={}, sup={})\", sub, sup);\n+        debug!(\"record_encl_scope(sub={:?}, sup={:?})\", sub, sup);\n         assert!(sub != sup);\n         self.scope_map.borrow_mut().insert(sub, sup);\n     }\n \n     pub fn record_var_scope(&self, var: ast::NodeId, lifetime: CodeExtent) {\n-        debug!(\"record_var_scope(sub={}, sup={})\", var, lifetime);\n+        debug!(\"record_var_scope(sub={:?}, sup={:?})\", var, lifetime);\n         assert!(var != lifetime.node_id());\n         self.var_map.borrow_mut().insert(var, lifetime);\n     }\n \n     pub fn record_rvalue_scope(&self, var: ast::NodeId, lifetime: CodeExtent) {\n-        debug!(\"record_rvalue_scope(sub={}, sup={})\", var, lifetime);\n+        debug!(\"record_rvalue_scope(sub={:?}, sup={:?})\", var, lifetime);\n         assert!(var != lifetime.node_id());\n         self.rvalue_scopes.borrow_mut().insert(var, lifetime);\n     }\n@@ -172,7 +172,7 @@ impl RegionMaps {\n     /// e.g. by an expression like `a().f` -- they will be freed within the innermost terminating\n     /// scope.\n     pub fn mark_as_terminating_scope(&self, scope_id: CodeExtent) {\n-        debug!(\"record_terminating_scope(scope_id={})\", scope_id);\n+        debug!(\"record_terminating_scope(scope_id={:?})\", scope_id);\n         self.terminating_scopes.borrow_mut().insert(scope_id);\n     }\n \n@@ -186,15 +186,15 @@ impl RegionMaps {\n         //! Returns the narrowest scope that encloses `id`, if any.\n         match self.scope_map.borrow().get(&id) {\n             Some(&r) => r,\n-            None => { panic!(\"no enclosing scope for id {}\", id); }\n+            None => { panic!(\"no enclosing scope for id {:?}\", id); }\n         }\n     }\n \n     /// Returns the lifetime of the local variable `var_id`\n     pub fn var_scope(&self, var_id: ast::NodeId) -> CodeExtent {\n         match self.var_map.borrow().get(&var_id) {\n             Some(&r) => r,\n-            None => { panic!(\"no enclosing scope for id {}\", var_id); }\n+            None => { panic!(\"no enclosing scope for id {:?}\", var_id); }\n         }\n     }\n \n@@ -204,7 +204,7 @@ impl RegionMaps {\n         // check for a designated rvalue scope\n         match self.rvalue_scopes.borrow().get(&expr_id) {\n             Some(&s) => {\n-                debug!(\"temporary_scope({}) = {} [custom]\", expr_id, s);\n+                debug!(\"temporary_scope({:?}) = {:?} [custom]\", expr_id, s);\n                 return Some(s);\n             }\n             None => { }\n@@ -225,20 +225,20 @@ impl RegionMaps {\n                     id = p;\n                 }\n                 None => {\n-                    debug!(\"temporary_scope({}) = None\", expr_id);\n+                    debug!(\"temporary_scope({:?}) = None\", expr_id);\n                     return None;\n                 }\n             }\n         }\n-        debug!(\"temporary_scope({}) = {} [enclosing]\", expr_id, id);\n+        debug!(\"temporary_scope({:?}) = {:?} [enclosing]\", expr_id, id);\n         return Some(id);\n     }\n \n     pub fn var_region(&self, id: ast::NodeId) -> ty::Region {\n         //! Returns the lifetime of the variable `id`.\n \n         let scope = ty::ReScope(self.var_scope(id));\n-        debug!(\"var_region({}) = {}\", id, scope);\n+        debug!(\"var_region({:?}) = {:?}\", id, scope);\n         scope\n     }\n \n@@ -258,7 +258,7 @@ impl RegionMaps {\n         while superscope != s {\n             match self.scope_map.borrow().get(&s) {\n                 None => {\n-                    debug!(\"is_subscope_of({}, {}, s={})=false\",\n+                    debug!(\"is_subscope_of({:?}, {:?}, s={:?})=false\",\n                            subscope, superscope, s);\n \n                     return false;\n@@ -267,7 +267,7 @@ impl RegionMaps {\n             }\n         }\n \n-        debug!(\"is_subscope_of({}, {})=true\",\n+        debug!(\"is_subscope_of({:?}, {:?})=true\",\n                subscope, superscope);\n \n         return true;\n@@ -287,7 +287,7 @@ impl RegionMaps {\n                            sub_region: ty::Region,\n                            super_region: ty::Region)\n                            -> bool {\n-        debug!(\"is_subregion_of(sub_region={}, super_region={})\",\n+        debug!(\"is_subregion_of(sub_region={:?}, super_region={:?})\",\n                sub_region, super_region);\n \n         sub_region == super_region || {\n@@ -365,7 +365,7 @@ impl RegionMaps {\n \n         fn ancestors_of(this: &RegionMaps, scope: CodeExtent)\n             -> Vec<CodeExtent> {\n-            // debug!(\"ancestors_of(scope={})\", scope);\n+            // debug!(\"ancestors_of(scope={:?})\", scope);\n             let mut result = vec!(scope);\n             let mut scope = scope;\n             loop {\n@@ -376,7 +376,7 @@ impl RegionMaps {\n                         scope = superscope;\n                     }\n                 }\n-                // debug!(\"ancestors_of_loop(scope={})\", scope);\n+                // debug!(\"ancestors_of_loop(scope={:?})\", scope);\n             }\n         }\n     }\n@@ -414,7 +414,7 @@ fn record_var_lifetime(visitor: &mut RegionResolutionVisitor,\n }\n \n fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &ast::Block) {\n-    debug!(\"resolve_block(blk.id={})\", blk.id);\n+    debug!(\"resolve_block(blk.id={:?})\", blk.id);\n \n     // Record the parent of this block.\n     record_superlifetime(visitor, blk.id, blk.span);\n@@ -466,7 +466,7 @@ fn resolve_pat(visitor: &mut RegionResolutionVisitor, pat: &ast::Pat) {\n \n fn resolve_stmt(visitor: &mut RegionResolutionVisitor, stmt: &ast::Stmt) {\n     let stmt_id = stmt_id(stmt);\n-    debug!(\"resolve_stmt(stmt.id={})\", stmt_id);\n+    debug!(\"resolve_stmt(stmt.id={:?})\", stmt_id);\n \n     let stmt_scope = CodeExtent::from_node_id(stmt_id);\n     visitor.region_maps.mark_as_terminating_scope(stmt_scope);\n@@ -479,7 +479,7 @@ fn resolve_stmt(visitor: &mut RegionResolutionVisitor, stmt: &ast::Stmt) {\n }\n \n fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n-    debug!(\"resolve_expr(expr.id={})\", expr.id);\n+    debug!(\"resolve_expr(expr.id={:?})\", expr.id);\n \n     record_superlifetime(visitor, expr.id, expr.span);\n \n@@ -566,7 +566,7 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n }\n \n fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n-    debug!(\"resolve_local(local.id={},local.init={})\",\n+    debug!(\"resolve_local(local.id={:?},local.init={:?})\",\n            local.id,local.init.is_some());\n \n     let blk_id = match visitor.cx.var_parent {\n@@ -815,10 +815,10 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n               body: &ast::Block,\n               sp: Span,\n               id: ast::NodeId) {\n-    debug!(\"region::resolve_fn(id={}, \\\n-                               span={}, \\\n-                               body.id={}, \\\n-                               cx.parent={})\",\n+    debug!(\"region::resolve_fn(id={:?}, \\\n+                               span={:?}, \\\n+                               body.id={:?}, \\\n+                               cx.parent={:?})\",\n            id,\n            visitor.sess.codemap().span_to_string(sp),\n            body.id,"}, {"sha": "8e03d774b812418544b92ac685941282cf1dfdf1", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -223,7 +223,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     fn visit_poly_trait_ref(&mut self, trait_ref:\n                             &ast::PolyTraitRef,\n                             _modifier: &ast::TraitBoundModifier) {\n-        debug!(\"visit_poly_trait_ref trait_ref={}\", trait_ref);\n+        debug!(\"visit_poly_trait_ref trait_ref={:?}\", trait_ref);\n \n         self.with(LateScope(&trait_ref.bound_lifetimes, self.scope), |old_scope, this| {\n             this.check_lifetime_defs(old_scope, &trait_ref.bound_lifetimes);\n@@ -250,9 +250,9 @@ impl<'a> LifetimeContext<'a> {\n             scope: &wrap_scope,\n             def_map: self.def_map,\n         };\n-        debug!(\"entering scope {}\", this.scope);\n+        debug!(\"entering scope {:?}\", this.scope);\n         f(self.scope, &mut this);\n-        debug!(\"exiting scope {}\", this.scope);\n+        debug!(\"exiting scope {:?}\", this.scope);\n     }\n \n     /// Visits self by adding a scope and handling recursive walk over the contents with `walk`.\n@@ -281,7 +281,7 @@ impl<'a> LifetimeContext<'a> {\n     {\n         let referenced_idents = early_bound_lifetime_names(generics);\n \n-        debug!(\"visit_early_late: referenced_idents={}\",\n+        debug!(\"visit_early_late: referenced_idents={:?}\",\n                referenced_idents);\n \n         let (early, late): (Vec<_>, _) = generics.lifetimes.iter().cloned().partition(\n@@ -488,7 +488,7 @@ impl<'a> LifetimeContext<'a> {\n                                probably a bug in syntax::fold\");\n         }\n \n-        debug!(\"lifetime_ref={} id={} resolved to {}\",\n+        debug!(\"lifetime_ref={:?} id={:?} resolved to {:?}\",\n                 lifetime_to_string(lifetime_ref),\n                 lifetime_ref.id,\n                 def);\n@@ -605,9 +605,9 @@ fn early_bound_lifetime_names(generics: &ast::Generics) -> Vec<ast::Name> {\n impl<'a> fmt::Show for ScopeChain<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            EarlyScope(space, defs, _) => write!(fmt, \"EarlyScope({}, {})\", space, defs),\n-            LateScope(defs, _) => write!(fmt, \"LateScope({})\", defs),\n-            BlockScope(id, _) => write!(fmt, \"BlockScope({})\", id),\n+            EarlyScope(space, defs, _) => write!(fmt, \"EarlyScope({:?}, {:?})\", space, defs),\n+            LateScope(defs, _) => write!(fmt, \"LateScope({:?})\", defs),\n+            BlockScope(id, _) => write!(fmt, \"BlockScope({:?})\", id),\n             RootScope => write!(fmt, \"RootScope\"),\n         }\n     }"}, {"sha": "359ad8d394129c09b027f503c0201de8b6827928", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -161,7 +161,7 @@ pub fn lookup(tcx: &ty::ctxt, id: DefId) -> Option<Stability> {\n     // is this definition the implementation of a trait method?\n     match ty::trait_item_of_item(tcx, id) {\n         Some(ty::MethodTraitItemId(trait_method_id)) if trait_method_id != id => {\n-            debug!(\"lookup: trait_method_id={}\", trait_method_id);\n+            debug!(\"lookup: trait_method_id={:?}\", trait_method_id);\n             return lookup(tcx, trait_method_id)\n         }\n         _ => {}\n@@ -182,7 +182,7 @@ pub fn lookup(tcx: &ty::ctxt, id: DefId) -> Option<Stability> {\n             // stability of the trait to determine the stability of any\n             // unmarked impls for it. See FIXME above for more details.\n \n-            debug!(\"lookup: trait_id={}\", trait_id);\n+            debug!(\"lookup: trait_id={:?}\", trait_id);\n             lookup(tcx, trait_id)\n         } else {\n             None"}, {"sha": "98bb0645befd10f488e7c0844f5926fe08a59ab7", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -242,7 +242,7 @@ impl<T:fmt::Show> fmt::Show for VecPerParamSpace<T> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(fmt, \"VecPerParamSpace {{\"));\n         for space in ParamSpace::all().iter() {\n-            try!(write!(fmt, \"{}: {}, \", *space, self.get_slice(*space)));\n+            try!(write!(fmt, \"{:?}: {:?}, \", *space, self.get_slice(*space)));\n         }\n         try!(write!(fmt, \"}}\"));\n         Ok(())\n@@ -601,7 +601,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                                     span,\n                                     format!(\"Type parameter out of range \\\n                                      when substituting in region {} (root type={}) \\\n-                                     (space={}, index={})\",\n+                                     (space={:?}, index={})\",\n                                     region_name.as_str(),\n                                     self.root_ty.repr(self.tcx()),\n                                     space, i).index(&FullRange));\n@@ -654,7 +654,7 @@ impl<'a,'tcx> SubstFolder<'a,'tcx> {\n                 let span = self.span.unwrap_or(DUMMY_SP);\n                 self.tcx().sess.span_bug(\n                     span,\n-                    format!(\"Type parameter `{}` ({}/{}/{}) out of range \\\n+                    format!(\"Type parameter `{}` ({}/{:?}/{}) out of range \\\n                                  when substituting (root type={}) substs={}\",\n                             p.repr(self.tcx()),\n                             source_ty.repr(self.tcx()),\n@@ -711,15 +711,15 @@ impl<'a,'tcx> SubstFolder<'a,'tcx> {\n     /// first case we do not increase the Debruijn index and in the second case we do. The reason\n     /// is that only in the second case have we passed through a fn binder.\n     fn shift_regions_through_binders(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        debug!(\"shift_regions(ty={}, region_binders_passed={}, type_has_escaping_regions={})\",\n+        debug!(\"shift_regions(ty={:?}, region_binders_passed={:?}, type_has_escaping_regions={:?})\",\n                ty.repr(self.tcx()), self.region_binders_passed, ty::type_has_escaping_regions(ty));\n \n         if self.region_binders_passed == 0 || !ty::type_has_escaping_regions(ty) {\n             return ty;\n         }\n \n         let result = ty_fold::shift_regions(self.tcx(), self.region_binders_passed, &ty);\n-        debug!(\"shift_regions: shifted result = {}\", result.repr(self.tcx()));\n+        debug!(\"shift_regions: shifted result = {:?}\", result.repr(self.tcx()));\n \n         result\n     }"}, {"sha": "3ef6694ce31c76f3793920dae07c55b44b47c02a", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -297,7 +297,7 @@ pub fn evaluate_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n                                        span: Span)\n                                        -> SelectionResult<'tcx, ()>\n {\n-    debug!(\"type_known_to_meet_builtin_bound(ty={}, bound={})\",\n+    debug!(\"type_known_to_meet_builtin_bound(ty={}, bound={:?})\",\n            ty.repr(infcx.tcx),\n            bound);\n \n@@ -347,7 +347,7 @@ pub fn evaluate_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n         }\n     };\n \n-    debug!(\"type_known_to_meet_builtin_bound: ty={} bound={} result={}\",\n+    debug!(\"type_known_to_meet_builtin_bound: ty={} bound={:?} result={:?}\",\n            ty.repr(infcx.tcx),\n            bound,\n            result);"}, {"sha": "beb3340e3c44a069818ff9569afc88d8642c5803", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -295,7 +295,7 @@ impl<'tcx> Repr<'tcx> for ObjectSafetyViolation<'tcx> {\n             ObjectSafetyViolation::SizedSelf =>\n                 format!(\"SizedSelf\"),\n             ObjectSafetyViolation::Method(ref m, code) =>\n-                format!(\"Method({},{})\", m.repr(tcx), code),\n+                format!(\"Method({},{:?})\", m.repr(tcx), code),\n         }\n     }\n }"}, {"sha": "25a33de1cc7f018defafcdedef785a2b2ee4a16e", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -368,7 +368,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let result = self.evaluate_stack(&stack);\n \n-        debug!(\"result: {}\", result);\n+        debug!(\"result: {:?}\", result);\n         result\n     }\n \n@@ -944,14 +944,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             _ => { return Ok(()); }\n         };\n \n-        debug!(\"assemble_unboxed_candidates: self_ty={} kind={} obligation={}\",\n+        debug!(\"assemble_unboxed_candidates: self_ty={} kind={:?} obligation={}\",\n                self_ty.repr(self.tcx()),\n                kind,\n                obligation.repr(self.tcx()));\n \n         let closure_kind = self.closure_typer.unboxed_closure_kind(closure_def_id);\n \n-        debug!(\"closure_kind = {}\", closure_kind);\n+        debug!(\"closure_kind = {:?}\", closure_kind);\n \n         if closure_kind == kind {\n             candidates.vec.push(UnboxedClosureCandidate(closure_def_id, substs.clone()));\n@@ -1102,7 +1102,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Err(error) => EvaluatedToErr(error),\n             }\n         });\n-        debug!(\"winnow_candidate depth={} result={}\",\n+        debug!(\"winnow_candidate depth={} result={:?}\",\n                stack.obligation.recursion_depth, result);\n         result\n     }\n@@ -1716,7 +1716,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             let substs =\n                 self.rematch_impl(impl_def_id, obligation,\n                                   snapshot, &skol_map, skol_obligation_trait_ref.trait_ref);\n-            debug!(\"confirm_impl_candidate substs={}\", substs);\n+            debug!(\"confirm_impl_candidate substs={:?}\", substs);\n             Ok(self.vtable_impl(impl_def_id, substs, obligation.cause.clone(),\n                                 obligation.recursion_depth + 1, skol_map, snapshot))\n         })\n@@ -2225,7 +2225,7 @@ impl<'tcx> Repr<'tcx> for SelectionCandidate<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             ErrorCandidate => format!(\"ErrorCandidate\"),\n-            BuiltinCandidate(b) => format!(\"BuiltinCandidate({})\", b),\n+            BuiltinCandidate(b) => format!(\"BuiltinCandidate({:?})\", b),\n             ParamCandidate(ref a) => format!(\"ParamCandidate({})\", a.repr(tcx)),\n             ImplCandidate(a) => format!(\"ImplCandidate({})\", a.repr(tcx)),\n             ProjectionCandidate => format!(\"ProjectionCandidate\"),\n@@ -2234,7 +2234,7 @@ impl<'tcx> Repr<'tcx> for SelectionCandidate<'tcx> {\n                 format!(\"ObjectCandidate\")\n             }\n             UnboxedClosureCandidate(c, ref s) => {\n-                format!(\"UnboxedClosureCandidate({},{})\", c, s.repr(tcx))\n+                format!(\"UnboxedClosureCandidate({:?},{})\", c, s.repr(tcx))\n             }\n         }\n     }"}, {"sha": "272447027afd8f6d56e4269d44962e2560731274", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -238,7 +238,7 @@ pub fn fresh_substs_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n \n impl<'tcx, N> fmt::Show for VtableImplData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableImpl({})\", self.impl_def_id)\n+        write!(f, \"VtableImpl({:?})\", self.impl_def_id)\n     }\n }\n \n@@ -451,8 +451,8 @@ impl<'tcx> Repr<'tcx> for super::FulfillmentErrorCode<'tcx> {\n impl<'tcx> fmt::Show for super::FulfillmentErrorCode<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            super::CodeSelectionError(ref e) => write!(f, \"{}\", e),\n-            super::CodeProjectionError(ref e) => write!(f, \"{}\", e),\n+            super::CodeSelectionError(ref e) => write!(f, \"{:?}\", e),\n+            super::CodeProjectionError(ref e) => write!(f, \"{:?}\", e),\n             super::CodeAmbiguity => write!(f, \"Ambiguity\")\n         }\n     }"}, {"sha": "593c144f88886f594889d25a60ca9b9d1385c2d0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -1709,8 +1709,8 @@ impl fmt::Show for InferTy {\n             TyVar(ref v) => v.fmt(f),\n             IntVar(ref v) => v.fmt(f),\n             FloatVar(ref v) => v.fmt(f),\n-            FreshTy(v) => write!(f, \"FreshTy({})\", v),\n-            FreshIntTy(v) => write!(f, \"FreshIntTy({})\", v),\n+            FreshTy(v) => write!(f, \"FreshTy({:?})\", v),\n+            FreshIntTy(v) => write!(f, \"FreshIntTy({:?})\", v),\n         }\n     }\n }\n@@ -2470,7 +2470,7 @@ fn intern_ty<'tcx>(type_arena: &'tcx TypedArena<TyS<'tcx>>,\n         region_depth: flags.depth,\n     });\n \n-    debug!(\"Interned type: {} Pointer: {}\",\n+    debug!(\"Interned type: {:?} Pointer: {:?}\",\n            ty, ty as *const _);\n \n     interner.insert(InternedTy { ty: ty }, ty);\n@@ -3532,7 +3532,7 @@ fn type_impls_bound<'a,'tcx>(param_env: &ParameterEnvironment<'a,'tcx>,\n         match cache.borrow().get(&ty) {\n             None => {}\n             Some(&result) => {\n-                debug!(\"type_impls_bound({}, {}) = {} (cached)\",\n+                debug!(\"type_impls_bound({}, {:?}) = {:?} (cached)\",\n                        ty.repr(param_env.tcx),\n                        bound,\n                        result);\n@@ -3545,7 +3545,7 @@ fn type_impls_bound<'a,'tcx>(param_env: &ParameterEnvironment<'a,'tcx>,\n \n     let is_impld = traits::type_known_to_meet_builtin_bound(&infcx, param_env, ty, bound, span);\n \n-    debug!(\"type_impls_bound({}, {}) = {}\",\n+    debug!(\"type_impls_bound({}, {:?}) = {:?}\",\n            ty.repr(param_env.tcx),\n            bound,\n            is_impld);\n@@ -3584,13 +3584,13 @@ pub fn is_ffi_safe<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n     fn type_requires<'tcx>(cx: &ctxt<'tcx>, seen: &mut Vec<DefId>,\n                            r_ty: Ty<'tcx>, ty: Ty<'tcx>) -> bool {\n-        debug!(\"type_requires({}, {})?\",\n+        debug!(\"type_requires({:?}, {:?})?\",\n                ::util::ppaux::ty_to_string(cx, r_ty),\n                ::util::ppaux::ty_to_string(cx, ty));\n \n         let r = r_ty == ty || subtypes_require(cx, seen, r_ty, ty);\n \n-        debug!(\"type_requires({}, {})? {}\",\n+        debug!(\"type_requires({:?}, {:?})? {:?}\",\n                ::util::ppaux::ty_to_string(cx, r_ty),\n                ::util::ppaux::ty_to_string(cx, ty),\n                r);\n@@ -3599,7 +3599,7 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n \n     fn subtypes_require<'tcx>(cx: &ctxt<'tcx>, seen: &mut Vec<DefId>,\n                               r_ty: Ty<'tcx>, ty: Ty<'tcx>) -> bool {\n-        debug!(\"subtypes_require({}, {})?\",\n+        debug!(\"subtypes_require({:?}, {:?})?\",\n                ::util::ppaux::ty_to_string(cx, r_ty),\n                ::util::ppaux::ty_to_string(cx, ty));\n \n@@ -3654,7 +3654,7 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n             ty_unboxed_closure(..) => {\n                 // this check is run on type definitions, so we don't expect to see\n                 // inference by-products or unboxed closure types\n-                cx.sess.bug(format!(\"requires check invoked on inapplicable type: {}\",\n+                cx.sess.bug(format!(\"requires check invoked on inapplicable type: {:?}\",\n                                     ty).as_slice())\n             }\n \n@@ -3680,7 +3680,7 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n             }\n         };\n \n-        debug!(\"subtypes_require({}, {})? {}\",\n+        debug!(\"subtypes_require({:?}, {:?})? {:?}\",\n                ::util::ppaux::ty_to_string(cx, r_ty),\n                ::util::ppaux::ty_to_string(cx, ty),\n                r);\n@@ -3748,7 +3748,7 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n             ty_unboxed_closure(..) => {\n                 // this check is run on type definitions, so we don't expect to see\n                 // unboxed closure types\n-                cx.sess.bug(format!(\"requires check invoked on inapplicable type: {}\",\n+                cx.sess.bug(format!(\"requires check invoked on inapplicable type: {:?}\",\n                                     ty).as_slice())\n             }\n             _ => Representable,\n@@ -3790,7 +3790,7 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n     fn is_type_structurally_recursive<'tcx>(cx: &ctxt<'tcx>, sp: Span,\n                                             seen: &mut Vec<Ty<'tcx>>,\n                                             ty: Ty<'tcx>) -> Representability {\n-        debug!(\"is_type_structurally_recursive: {}\",\n+        debug!(\"is_type_structurally_recursive: {:?}\",\n                ::util::ppaux::ty_to_string(cx, ty));\n \n         match ty.sty {\n@@ -3810,7 +3810,7 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n                     match iter.next() {\n                         Some(&seen_type) => {\n                             if same_struct_or_enum_def_id(seen_type, did) {\n-                                debug!(\"SelfRecursive: {} contains {}\",\n+                                debug!(\"SelfRecursive: {:?} contains {:?}\",\n                                        ::util::ppaux::ty_to_string(cx, seen_type),\n                                        ::util::ppaux::ty_to_string(cx, ty));\n                                 return SelfRecursive;\n@@ -3830,7 +3830,7 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n \n                     for &seen_type in iter {\n                         if same_type(ty, seen_type) {\n-                            debug!(\"ContainsRecursive: {} contains {}\",\n+                            debug!(\"ContainsRecursive: {:?} contains {:?}\",\n                                    ::util::ppaux::ty_to_string(cx, seen_type),\n                                    ::util::ppaux::ty_to_string(cx, ty));\n                             return ContainsRecursive;\n@@ -3852,15 +3852,15 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n         }\n     }\n \n-    debug!(\"is_type_representable: {}\",\n+    debug!(\"is_type_representable: {:?}\",\n            ::util::ppaux::ty_to_string(cx, ty));\n \n     // To avoid a stack overflow when checking an enum variant or struct that\n     // contains a different, structurally recursive type, maintain a stack\n     // of seen types and check recursion for each of them (issues #3008, #3779).\n     let mut seen: Vec<Ty> = Vec::new();\n     let r = is_type_structurally_recursive(cx, sp, &mut seen, ty);\n-    debug!(\"is_type_representable: {} is {}\",\n+    debug!(\"is_type_representable: {:?} is {:?}\",\n            ::util::ppaux::ty_to_string(cx, ty), r);\n     r\n }\n@@ -4123,7 +4123,7 @@ pub fn fn_is_variadic(fty: Ty) -> bool {\n     match fty.sty {\n         ty_bare_fn(_, ref f) => f.sig.0.variadic,\n         ref s => {\n-            panic!(\"fn_is_variadic() called on non-fn type: {}\", s)\n+            panic!(\"fn_is_variadic() called on non-fn type: {:?}\", s)\n         }\n     }\n }\n@@ -4132,7 +4132,7 @@ pub fn ty_fn_sig<'tcx>(fty: Ty<'tcx>) -> &'tcx PolyFnSig<'tcx> {\n     match fty.sty {\n         ty_bare_fn(_, ref f) => &f.sig,\n         ref s => {\n-            panic!(\"ty_fn_sig() called on non-fn type: {}\", s)\n+            panic!(\"ty_fn_sig() called on non-fn type: {:?}\", s)\n         }\n     }\n }\n@@ -4158,7 +4158,7 @@ pub fn ty_closure_store(fty: Ty) -> TraitStore {\n             UniqTraitStore\n         }\n         ref s => {\n-            panic!(\"ty_closure_store() called on non-closure type: {}\", s)\n+            panic!(\"ty_closure_store() called on non-closure type: {:?}\", s)\n         }\n     }\n }\n@@ -4167,7 +4167,7 @@ pub fn ty_fn_ret<'tcx>(fty: Ty<'tcx>) -> FnOutput<'tcx> {\n     match fty.sty {\n         ty_bare_fn(_, ref f) => f.sig.0.output,\n         ref s => {\n-            panic!(\"ty_fn_ret() called on non-fn type: {}\", s)\n+            panic!(\"ty_fn_ret() called on non-fn type: {:?}\", s)\n         }\n     }\n }\n@@ -4187,7 +4187,7 @@ pub fn ty_region(tcx: &ctxt,\n         ref s => {\n             tcx.sess.span_bug(\n                 span,\n-                format!(\"ty_region() invoked on an inappropriate ty: {}\",\n+                format!(\"ty_region() invoked on an inappropriate ty: {:?}\",\n                         s).index(&FullRange));\n         }\n     }\n@@ -4247,7 +4247,7 @@ pub fn expr_span(cx: &ctxt, id: NodeId) -> Span {\n             e.span\n         }\n         Some(f) => {\n-            cx.sess.bug(format!(\"Node id {} is not an expr: {}\",\n+            cx.sess.bug(format!(\"Node id {} is not an expr: {:?}\",\n                                 id,\n                                 f).index(&FullRange));\n         }\n@@ -4267,14 +4267,14 @@ pub fn local_var_name_str(cx: &ctxt, id: NodeId) -> InternedString {\n                 }\n                 _ => {\n                     cx.sess.bug(\n-                        format!(\"Variable id {} maps to {}, not local\",\n+                        format!(\"Variable id {} maps to {:?}, not local\",\n                                 id,\n                                 pat).index(&FullRange));\n                 }\n             }\n         }\n         r => {\n-            cx.sess.bug(format!(\"Variable id {} maps to {}, not local\",\n+            cx.sess.bug(format!(\"Variable id {} maps to {:?}, not local\",\n                                 id,\n                                 r).index(&FullRange));\n         }\n@@ -4298,15 +4298,15 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n     return match adjustment {\n         Some(adjustment) => {\n             match *adjustment {\n-                AdjustReifyFnPointer(_) => {\n+               AdjustReifyFnPointer(_) => {\n                     match unadjusted_ty.sty {\n                         ty::ty_bare_fn(Some(_), b) => {\n                             ty::mk_bare_fn(cx, None, b)\n                         }\n                         ref b => {\n                             cx.sess.bug(\n                                 format!(\"AdjustReifyFnPointer adjustment on non-fn-item: \\\n-                                         {}\",\n+                                         {:?}\",\n                                         b).index(&FullRange));\n                         }\n                     }\n@@ -4397,7 +4397,7 @@ pub fn unsize_ty<'tcx>(cx: &ctxt<'tcx>,\n                 mk_vec(cx, ty, None)\n             }\n             _ => cx.sess.span_bug(span,\n-                                  format!(\"UnsizeLength with bad sty: {}\",\n+                                  format!(\"UnsizeLength with bad sty: {:?}\",\n                                           ty_to_string(cx, ty)).index(&FullRange))\n         },\n         &UnsizeStruct(box ref k, tp_index) => match ty.sty {\n@@ -4409,7 +4409,7 @@ pub fn unsize_ty<'tcx>(cx: &ctxt<'tcx>,\n                 mk_struct(cx, did, cx.mk_substs(unsized_substs))\n             }\n             _ => cx.sess.span_bug(span,\n-                                  format!(\"UnsizeStruct with bad sty: {}\",\n+                                  format!(\"UnsizeStruct with bad sty: {:?}\",\n                                           ty_to_string(cx, ty)).index(&FullRange))\n         },\n         &UnsizeVtable(TyTrait { ref principal, ref bounds }, _) => {\n@@ -4516,7 +4516,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                 def => {\n                     tcx.sess.span_bug(\n                         expr.span,\n-                        format!(\"uncategorized def for expr {}: {}\",\n+                        format!(\"uncategorized def for expr {}: {:?}\",\n                                 expr.id,\n                                 def).index(&FullRange));\n                 }\n@@ -4639,7 +4639,7 @@ pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n     let mut i = 0u;\n     for f in fields.iter() { if f.name == name { return i; } i += 1u; }\n     tcx.sess.bug(format!(\n-        \"no field named `{}` found in the list of fields `{}`\",\n+        \"no field named `{}` found in the list of fields `{:?}`\",\n         token::get_name(name),\n         fields.iter()\n               .map(|f| token::get_name(f.name).get().to_string())\n@@ -4716,18 +4716,18 @@ pub fn type_err_to_str<'tcx>(cx: &ctxt<'tcx>, err: &type_err<'tcx>) -> String {\n         terr_mismatch => \"types differ\".to_string(),\n         terr_unsafety_mismatch(values) => {\n             format!(\"expected {} fn, found {} fn\",\n-                    values.expected.to_string(),\n-                    values.found.to_string())\n+                    values.expected,\n+                    values.found)\n         }\n         terr_abi_mismatch(values) => {\n             format!(\"expected {} fn, found {} fn\",\n-                    values.expected.to_string(),\n-                    values.found.to_string())\n+                    values.expected,\n+                    values.found)\n         }\n         terr_onceness_mismatch(values) => {\n             format!(\"expected {} fn, found {} fn\",\n-                    values.expected.to_string(),\n-                    values.found.to_string())\n+                    values.expected,\n+                    values.found)\n         }\n         terr_sigil_mismatch(values) => {\n             format!(\"expected {}, found {}\",\n@@ -4819,14 +4819,14 @@ pub fn type_err_to_str<'tcx>(cx: &ctxt<'tcx>, err: &type_err<'tcx>) -> String {\n             \"expected an integral type, found `char`\".to_string()\n         }\n         terr_int_mismatch(ref values) => {\n-            format!(\"expected `{}`, found `{}`\",\n-                    values.expected.to_string(),\n-                    values.found.to_string())\n+            format!(\"expected `{:?}`, found `{:?}`\",\n+                    values.expected,\n+                    values.found)\n         }\n         terr_float_mismatch(ref values) => {\n-            format!(\"expected `{}`, found `{}`\",\n-                    values.expected.to_string(),\n-                    values.found.to_string())\n+            format!(\"expected `{:?}`, found `{:?}`\",\n+                    values.expected,\n+                    values.found)\n         }\n         terr_variadic_mismatch(ref values) => {\n             format!(\"expected {} fn, found {} function\",\n@@ -4915,14 +4915,14 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                          }).collect()\n                     }\n                     _ => {\n-                        cx.sess.bug(format!(\"provided_trait_methods: `{}` is \\\n+                        cx.sess.bug(format!(\"provided_trait_methods: `{:?}` is \\\n                                              not a trait\",\n                                             id).index(&FullRange))\n                     }\n                 }\n             }\n             _ => {\n-                cx.sess.bug(format!(\"provided_trait_methods: `{}` is not a \\\n+                cx.sess.bug(format!(\"provided_trait_methods: `{:?}` is not a \\\n                                      trait\",\n                                     id).index(&FullRange))\n             }\n@@ -4951,7 +4951,7 @@ fn lookup_locally_or_in_crate_store<V, F>(descr: &str,\n     }\n \n     if def_id.krate == ast::LOCAL_CRATE {\n-        panic!(\"No def'n found for {} in tcx.{}\", def_id, descr);\n+        panic!(\"No def'n found for {:?} in tcx.{}\", def_id, descr);\n     }\n     let v = load_external();\n     map.insert(def_id, v.clone());\n@@ -5058,7 +5058,7 @@ pub fn impl_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                             -> Option<Rc<TraitRef<'tcx>>> {\n     memoized(&cx.impl_trait_cache, id, |id: ast::DefId| {\n         if id.krate == ast::LOCAL_CRATE {\n-            debug!(\"(impl_trait_ref) searching for trait impl {}\", id);\n+            debug!(\"(impl_trait_ref) searching for trait impl {:?}\", id);\n             match cx.map.find(id.node) {\n                 Some(ast_map::NodeItem(item)) => {\n                     match item.node {\n@@ -5378,7 +5378,7 @@ pub fn predicates_for_trait_ref<'tcx>(tcx: &ctxt<'tcx>,\n {\n     let trait_def = lookup_trait_def(tcx, trait_ref.def_id());\n \n-    debug!(\"bounds_for_trait_ref(trait_def={}, trait_ref={})\",\n+    debug!(\"bounds_for_trait_ref(trait_def={:?}, trait_ref={:?})\",\n            trait_def.repr(tcx), trait_ref.repr(tcx));\n \n     // The interaction between HRTB and supertraits is not entirely\n@@ -5930,7 +5930,7 @@ pub fn required_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n                                     predicates: Vec<ty::Predicate<'tcx>>)\n                                     -> Vec<ty::Region>\n {\n-    debug!(\"required_region_bounds(erased_self_ty={}, predicates={})\",\n+    debug!(\"required_region_bounds(erased_self_ty={:?}, predicates={:?})\",\n            erased_self_ty.repr(tcx),\n            predicates.repr(tcx));\n \n@@ -6008,7 +6008,7 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n         return\n     }\n \n-    debug!(\"populate_implementations_for_type_if_necessary: searching for {}\", type_id);\n+    debug!(\"populate_implementations_for_type_if_necessary: searching for {:?}\", type_id);\n \n     let mut inherent_impls = Vec::new();\n     csearch::each_implementation_for_type(&tcx.sess.cstore, type_id,\n@@ -6369,7 +6369,7 @@ pub fn construct_parameter_environment<'a,'tcx>(\n \n     record_region_bounds(tcx, &bounds);\n \n-    debug!(\"construct_parameter_environment: free_id={} free_subst={} bounds={}\",\n+    debug!(\"construct_parameter_environment: free_id={:?} free_subst={:?} bounds={:?}\",\n            free_id,\n            free_substs.repr(tcx),\n            bounds.repr(tcx));\n@@ -6395,15 +6395,15 @@ pub fn construct_parameter_environment<'a,'tcx>(\n                                   types: &mut VecPerParamSpace<Ty<'tcx>>,\n                                   defs: &[TypeParameterDef<'tcx>]) {\n         for def in defs.iter() {\n-            debug!(\"construct_parameter_environment(): push_types_from_defs: def={}\",\n+            debug!(\"construct_parameter_environment(): push_types_from_defs: def={:?}\",\n                    def.repr(tcx));\n             let ty = ty::mk_param_from_def(tcx, def);\n             types.push(def.space, ty);\n-        }\n+       }\n     }\n \n     fn record_region_bounds<'tcx>(tcx: &ty::ctxt<'tcx>, bounds: &GenericBounds<'tcx>) {\n-        debug!(\"record_region_bounds(bounds={})\", bounds.repr(tcx));\n+        debug!(\"record_region_bounds(bounds={:?})\", bounds.repr(tcx));\n \n         for predicate in bounds.predicates.iter() {\n             match *predicate {\n@@ -6757,7 +6757,7 @@ pub fn replace_late_bound_regions<'tcx, T, F>(\n         }\n     });\n \n-    debug!(\"resulting map: {} value: {}\", map, value.repr(tcx));\n+    debug!(\"resulting map: {:?} value: {:?}\", map, value.repr(tcx));\n     (value, map)\n }\n \n@@ -6805,7 +6805,7 @@ impl<'tcx> Repr<'tcx> for AutoRef<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         match *self {\n             AutoPtr(a, b, ref c) => {\n-                format!(\"AutoPtr({},{},{})\", a.repr(tcx), b, c.repr(tcx))\n+                format!(\"AutoPtr({},{:?},{})\", a.repr(tcx), b, c.repr(tcx))\n             }\n             AutoUnsize(ref a) => {\n                 format!(\"AutoUnsize({})\", a.repr(tcx))\n@@ -6814,7 +6814,7 @@ impl<'tcx> Repr<'tcx> for AutoRef<'tcx> {\n                 format!(\"AutoUnsizeUniq({})\", a.repr(tcx))\n             }\n             AutoUnsafe(ref a, ref b) => {\n-                format!(\"AutoUnsafe({},{})\", a, b.repr(tcx))\n+                format!(\"AutoUnsafe({:?},{})\", a, b.repr(tcx))\n             }\n         }\n     }\n@@ -6844,19 +6844,19 @@ impl<'tcx> Repr<'tcx> for vtable_origin<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             vtable_static(def_id, ref tys, ref vtable_res) => {\n-                format!(\"vtable_static({}:{}, {}, {})\",\n+                format!(\"vtable_static({:?}:{}, {}, {})\",\n                         def_id,\n                         ty::item_path_str(tcx, def_id),\n                         tys.repr(tcx),\n                         vtable_res.repr(tcx))\n             }\n \n             vtable_param(x, y) => {\n-                format!(\"vtable_param({}, {})\", x, y)\n+                format!(\"vtable_param({:?}, {})\", x, y)\n             }\n \n             vtable_unboxed_closure(def_id) => {\n-                format!(\"vtable_unboxed_closure({})\", def_id)\n+                format!(\"vtable_unboxed_closure({:?})\", def_id)\n             }\n \n             vtable_error => {\n@@ -7287,7 +7287,7 @@ impl ReferencesError for Region\n \n impl<'tcx> Repr<'tcx> for ClosureTy<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"ClosureTy({},{},{},{},{},{})\",\n+        format!(\"ClosureTy({},{},{:?},{},{},{})\",\n                 self.unsafety,\n                 self.onceness,\n                 self.store,"}, {"sha": "28975c7341659cb9692f5891be91655e3fa331cb", "filename": "src/librustc/middle/ty_walk.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_walk.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -95,15 +95,15 @@ impl<'tcx> Iterator for TypeWalker<'tcx> {\n     type Item = Ty<'tcx>;\n \n     fn next(&mut self) -> Option<Ty<'tcx>> {\n-        debug!(\"next(): stack={}\", self.stack);\n+        debug!(\"next(): stack={:?}\", self.stack);\n         match self.stack.pop() {\n             None => {\n                 return None;\n             }\n             Some(ty) => {\n                 self.last_subtree = self.stack.len();\n                 self.push_subtypes(ty);\n-                debug!(\"next: stack={}\", self.stack);\n+                debug!(\"next: stack={:?}\", self.stack);\n                 Some(ty)\n             }\n         }"}, {"sha": "26f98e28a8d950473db969dcbd06af9aee27510e", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -64,7 +64,7 @@ pub fn indent<R, F>(op: F) -> R where\n     // to make debug output more readable.\n     debug!(\">>\");\n     let r = op();\n-    debug!(\"<< (Result = {})\", r);\n+    debug!(\"<< (Result = {:?})\", r);\n     r\n }\n "}, {"sha": "ded8713079a837d98443bdf3d98902ce6ed90416", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -111,7 +111,7 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n           }\n           Some(_) | None => {\n             // this really should not happen\n-            (format!(\"unknown scope: {}.  Please report a bug.\", scope), None)\n+            (format!(\"unknown scope: {:?}.  Please report a bug.\", scope), None)\n           }\n         }\n       }\n@@ -140,7 +140,7 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n           }\n           Some(_) | None => {\n               // this really should not happen\n-              (format!(\"{} unknown free region bounded by scope {}\", prefix, fr.scope), None)\n+              (format!(\"{} unknown free region bounded by scope {:?}\", prefix, fr.scope), None)\n           }\n         }\n       }\n@@ -156,7 +156,7 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n       // I believe these cases should not occur (except when debugging,\n       // perhaps)\n       ty::ReInfer(_) | ty::ReLateBound(..) => {\n-        (format!(\"lifetime {}\", region), None)\n+        (format!(\"lifetime {:?}\", region), None)\n       }\n     };\n \n@@ -653,13 +653,13 @@ impl<'tcx, T:UserString<'tcx>> UserString<'tcx> for Vec<T> {\n \n impl<'tcx> Repr<'tcx> for def::Def {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n impl<'tcx> Repr<'tcx> for ty::TypeParameterDef<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"TypeParameterDef({}, {}, {}/{})\",\n+        format!(\"TypeParameterDef({:?}, {}, {:?}/{})\",\n                 self.def_id,\n                 self.bounds.repr(tcx),\n                 self.space,\n@@ -854,31 +854,31 @@ impl<'tcx> Repr<'tcx> for ty::Region {\n     fn repr(&self, tcx: &ctxt) -> String {\n         match *self {\n             ty::ReEarlyBound(id, space, index, name) => {\n-                format!(\"ReEarlyBound({}, {}, {}, {})\",\n+                format!(\"ReEarlyBound({}, {:?}, {}, {})\",\n                                id,\n                                space,\n                                index,\n                                token::get_name(name))\n             }\n \n             ty::ReLateBound(binder_id, ref bound_region) => {\n-                format!(\"ReLateBound({}, {})\",\n+                format!(\"ReLateBound({:?}, {})\",\n                         binder_id,\n                         bound_region.repr(tcx))\n             }\n \n             ty::ReFree(ref fr) => fr.repr(tcx),\n \n             ty::ReScope(id) => {\n-                format!(\"ReScope({})\", id)\n+                format!(\"ReScope({:?})\", id)\n             }\n \n             ty::ReStatic => {\n                 \"ReStatic\".to_string()\n             }\n \n             ty::ReInfer(ReVar(ref vid)) => {\n-                format!(\"{}\", vid)\n+                format!(\"{:?}\", vid)\n             }\n \n             ty::ReInfer(ReSkolemized(id, ref bound_region)) => {\n@@ -920,14 +920,14 @@ impl<'tcx> Repr<'tcx> for ast::DefId {\n                 Some(ast_map::NodeVariant(..)) |\n                 Some(ast_map::NodeStructCtor(..)) => {\n                     return format!(\n-                                \"{}:{}\",\n+                                \"{:?}:{}\",\n                                 *self,\n                                 ty::item_path_str(tcx, *self))\n                 }\n                 _ => {}\n             }\n         }\n-        return format!(\"{}\", *self)\n+        return format!(\"{:?}\", *self)\n     }\n }\n \n@@ -1007,13 +1007,13 @@ impl<'tcx> Repr<'tcx> for ast::Ident {\n \n impl<'tcx> Repr<'tcx> for ast::ExplicitSelf_ {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n impl<'tcx> Repr<'tcx> for ast::Visibility {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n@@ -1026,6 +1026,7 @@ impl<'tcx> Repr<'tcx> for ty::BareFnTy<'tcx> {\n     }\n }\n \n+\n impl<'tcx> Repr<'tcx> for ty::FnSig<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"fn{} -> {}\", self.inputs.repr(tcx), self.output.repr(tcx))\n@@ -1096,7 +1097,7 @@ impl<'tcx> Repr<'tcx> for ty::TraitStore {\n \n impl<'tcx> Repr<'tcx> for ty::BuiltinBound {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n@@ -1251,13 +1252,13 @@ impl<'tcx> Repr<'tcx> for ty::UpvarId {\n \n impl<'tcx> Repr<'tcx> for ast::Mutability {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n impl<'tcx> Repr<'tcx> for ty::BorrowKind {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n@@ -1271,49 +1272,49 @@ impl<'tcx> Repr<'tcx> for ty::UpvarBorrow {\n \n impl<'tcx> Repr<'tcx> for ty::IntVid {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", self)\n+        format!(\"{:?}\", self)\n     }\n }\n \n impl<'tcx> Repr<'tcx> for ty::FloatVid {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", self)\n+        format!(\"{:?}\", self)\n     }\n }\n \n impl<'tcx> Repr<'tcx> for ty::RegionVid {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", self)\n+        format!(\"{:?}\", self)\n     }\n }\n \n impl<'tcx> Repr<'tcx> for ty::TyVid {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", self)\n+        format!(\"{:?}\", self)\n     }\n }\n \n impl<'tcx> Repr<'tcx> for ty::IntVarValue {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n impl<'tcx> Repr<'tcx> for ast::IntTy {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n impl<'tcx> Repr<'tcx> for ast::UintTy {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n impl<'tcx> Repr<'tcx> for ast::FloatTy {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n@@ -1332,7 +1333,7 @@ impl<'tcx> UserString<'tcx> for ParamTy {\n impl<'tcx> Repr<'tcx> for ParamTy {\n     fn repr(&self, tcx: &ctxt) -> String {\n         let ident = self.user_string(tcx);\n-        format!(\"{}/{}.{}\", ident, self.space, self.idx)\n+        format!(\"{}/{:?}.{}\", ident, self.space, self.idx)\n     }\n }\n "}, {"sha": "48004acaac0878825b6ec0e05ba2d1ad8ee01c1d", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -64,7 +64,7 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n     match cwd {\n         Some(p) => {\n             cmd.cwd(p);\n-            debug!(\"inside {}\", p.display());\n+            debug!(\"inside {:?}\", p.display());\n         }\n         None => {}\n     }\n@@ -105,7 +105,7 @@ pub fn find_library(name: &str, osprefix: &str, ossuffix: &str,\n     let unixlibname = format!(\"lib{}.a\", name);\n \n     for path in search_paths.iter() {\n-        debug!(\"looking for {} inside {}\", name, path.display());\n+        debug!(\"looking for {} inside {:?}\", name, path.display());\n         let test = path.join(oslibname.index(&FullRange));\n         if test.exists() { return test }\n         if oslibname != unixlibname {"}, {"sha": "db1dfa6b6eed88fc689bacfac752eab6cebea636", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -61,10 +61,10 @@ fn get_rpaths<F, G>(mut config: RPathConfig<F, G>, libs: &[Path]) -> Vec<String>\n     F: FnOnce() -> Path,\n     G: FnMut(&Path) -> Result<Path, IoError>,\n {\n-    debug!(\"output: {}\", config.out_filename.display());\n+    debug!(\"output: {:?}\", config.out_filename.display());\n     debug!(\"libs:\");\n     for libpath in libs.iter() {\n-        debug!(\"    {}\", libpath.display());\n+        debug!(\"    {:?}\", libpath.display());\n     }\n \n     // Use relative paths to the libraries. Binaries can be moved"}, {"sha": "863c1a7c865f3b5fbcac9f6b8f45a8b1e8a5b5e9", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -119,6 +119,14 @@ impl Svh {\n }\n \n impl fmt::Show for Svh {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        //NOTE(stage0): uncomment after snapshot\n+        //write!(f, \"Svh {{ {} }}\", self.as_str())\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for Svh {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(self.as_str())\n     }"}, {"sha": "23c8fc7de51b550391bbc7621c5c127c6ad40acd", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -301,8 +301,8 @@ impl Target {\n         use serialize::json;\n \n         fn load_file(path: &Path) -> Result<Target, String> {\n-            let mut f = try!(File::open(path).map_err(|e| e.to_string()));\n-            let obj = try!(json::from_reader(&mut f).map_err(|e| e.to_string()));\n+            let mut f = try!(File::open(path).map_err(|e| format!(\"{:?}\", e)));\n+            let obj = try!(json::from_reader(&mut f).map_err(|e| format!(\"{:?}\", e)));\n             Ok(Target::from_json(obj))\n         }\n \n@@ -315,7 +315,7 @@ impl Target {\n                     $(\n                         else if target == stringify!($name) {\n                             let t = $name::target();\n-                            debug!(\"Got builtin target: {}\", t);\n+                            debug!(\"Got builtin target: {:?}\", t);\n                             return Ok(t);\n                         }\n                     )*\n@@ -379,6 +379,6 @@ impl Target {\n             }\n         }\n \n-        Err(format!(\"Could not find specification for target {}\", target))\n+        Err(format!(\"Could not find specification for target {:?}\", target))\n     }\n }"}, {"sha": "d942581ca62f22b71a1ff72d4b1267b0a6eb10cb", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -96,7 +96,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                consume_span: Span,\n                cmt: mc::cmt<'tcx>,\n                mode: euv::ConsumeMode) {\n-        debug!(\"consume(consume_id={}, cmt={}, mode={})\",\n+        debug!(\"consume(consume_id={}, cmt={}, mode={:?})\",\n                consume_id, cmt.repr(self.tcx()), mode);\n \n         self.consume_common(consume_id, consume_span, cmt, mode);\n@@ -111,7 +111,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                    consume_pat: &ast::Pat,\n                    cmt: mc::cmt<'tcx>,\n                    mode: euv::ConsumeMode) {\n-        debug!(\"consume_pat(consume_pat={}, cmt={}, mode={})\",\n+        debug!(\"consume_pat(consume_pat={}, cmt={}, mode={:?})\",\n                consume_pat.repr(self.tcx()),\n                cmt.repr(self.tcx()),\n                mode);\n@@ -127,8 +127,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause)\n     {\n-        debug!(\"borrow(borrow_id={}, cmt={}, loan_region={}, \\\n-               bk={}, loan_cause={})\",\n+        debug!(\"borrow(borrow_id={}, cmt={}, loan_region={:?}, \\\n+               bk={:?}, loan_cause={:?})\",\n                borrow_id, cmt.repr(self.tcx()), loan_region,\n                bk, loan_cause);\n \n@@ -355,10 +355,10 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         //! (Note that some loans can be *issued* without necessarily\n         //! taking effect yet.)\n \n-        debug!(\"check_for_conflicting_loans(scope={})\", scope);\n+        debug!(\"check_for_conflicting_loans(scope={:?})\", scope);\n \n         let new_loan_indices = self.loans_generated_by(scope);\n-        debug!(\"new_loan_indices = {}\", new_loan_indices);\n+        debug!(\"new_loan_indices = {:?}\", new_loan_indices);\n \n         self.each_issued_loan(scope, |issued_loan| {\n             for &new_loan_index in new_loan_indices.iter() {\n@@ -696,7 +696,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                               span: Span,\n                               use_kind: MovedValueUseKind,\n                               lp: &Rc<LoanPath<'tcx>>) {\n-        debug!(\"check_if_path_is_moved(id={}, use_kind={}, lp={})\",\n+        debug!(\"check_if_path_is_moved(id={}, use_kind={:?}, lp={})\",\n                id, use_kind, lp.repr(self.bccx.tcx));\n         let base_lp = owned_ptr_base_path_rc(lp);\n         self.move_data.each_move_of(id, &base_lp, |the_move, moved_lp| {"}, {"sha": "d7527487465895db0aea649a865ba5f807cea5f4", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -198,11 +198,11 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n     // First, filter out duplicates\n     moved.sort();\n     moved.dedup();\n-    debug!(\"fragments 1 moved: {}\", path_lps(moved.index(&FullRange)));\n+    debug!(\"fragments 1 moved: {:?}\", path_lps(moved.index(&FullRange)));\n \n     assigned.sort();\n     assigned.dedup();\n-    debug!(\"fragments 1 assigned: {}\", path_lps(assigned.index(&FullRange)));\n+    debug!(\"fragments 1 assigned: {:?}\", path_lps(assigned.index(&FullRange)));\n \n     // Second, build parents from the moved and assigned.\n     for m in moved.iter() {\n@@ -222,14 +222,14 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n \n     parents.sort();\n     parents.dedup();\n-    debug!(\"fragments 2 parents: {}\", path_lps(parents.index(&FullRange)));\n+    debug!(\"fragments 2 parents: {:?}\", path_lps(parents.index(&FullRange)));\n \n     // Third, filter the moved and assigned fragments down to just the non-parents\n     moved.retain(|f| non_member(*f, parents.index(&FullRange)));\n-    debug!(\"fragments 3 moved: {}\", path_lps(moved.index(&FullRange)));\n+    debug!(\"fragments 3 moved: {:?}\", path_lps(moved.index(&FullRange)));\n \n     assigned.retain(|f| non_member(*f, parents.index(&FullRange)));\n-    debug!(\"fragments 3 assigned: {}\", path_lps(assigned.index(&FullRange)));\n+    debug!(\"fragments 3 assigned: {:?}\", path_lps(assigned.index(&FullRange)));\n \n     // Fourth, build the leftover from the moved, assigned, and parents.\n     for m in moved.iter() {\n@@ -247,7 +247,7 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n \n     unmoved.sort();\n     unmoved.dedup();\n-    debug!(\"fragments 4 unmoved: {}\", frag_lps(unmoved.index(&FullRange)));\n+    debug!(\"fragments 4 unmoved: {:?}\", frag_lps(unmoved.index(&FullRange)));\n \n     // Fifth, filter the leftover fragments down to its core.\n     unmoved.retain(|f| match *f {\n@@ -256,7 +256,7 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n             non_member(mpi, moved.index(&FullRange)) &&\n             non_member(mpi, assigned.index(&FullRange))\n     });\n-    debug!(\"fragments 5 unmoved: {}\", frag_lps(unmoved.index(&FullRange)));\n+    debug!(\"fragments 5 unmoved: {:?}\", frag_lps(unmoved.index(&FullRange)));\n \n     // Swap contents back in.\n     fragments.unmoved_fragments = unmoved;\n@@ -430,7 +430,7 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n         }\n \n         ref sty_and_variant_info => {\n-            let msg = format!(\"type {} ({}) is not fragmentable\",\n+            let msg = format!(\"type {} ({:?}) is not fragmentable\",\n                               parent_ty.repr(tcx), sty_and_variant_info);\n             let opt_span = origin_id.and_then(|id|tcx.map.opt_span(id));\n             tcx.sess.opt_span_bug(opt_span, msg.index(&FullRange))"}, {"sha": "ca1fba53de42aa11f6fa1c39929017abaa371e91", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -65,7 +65,7 @@ pub fn gather_match_variant<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                       cmt: mc::cmt<'tcx>,\n                                       mode: euv::MatchMode) {\n     let tcx = bccx.tcx;\n-    debug!(\"gather_match_variant(move_pat={}, cmt={}, mode={})\",\n+    debug!(\"gather_match_variant(move_pat={}, cmt={}, mode={:?})\",\n            move_pat.id, cmt.repr(tcx), mode);\n \n     let opt_lp = opt_loan_path(&cmt);"}, {"sha": "2c48e0da01d77e48f7e51213e564acdd25f264eb", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -76,7 +76,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                _consume_span: Span,\n                cmt: mc::cmt<'tcx>,\n                mode: euv::ConsumeMode) {\n-        debug!(\"consume(consume_id={}, cmt={}, mode={})\",\n+        debug!(\"consume(consume_id={}, cmt={}, mode={:?})\",\n                consume_id, cmt.repr(self.tcx()), mode);\n \n         match mode {\n@@ -93,7 +93,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                    matched_pat: &ast::Pat,\n                    cmt: mc::cmt<'tcx>,\n                    mode: euv::MatchMode) {\n-        debug!(\"matched_pat(matched_pat={}, cmt={}, mode={})\",\n+        debug!(\"matched_pat(matched_pat={}, cmt={}, mode={:?})\",\n                matched_pat.repr(self.tcx()),\n                cmt.repr(self.tcx()),\n                mode);\n@@ -109,7 +109,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                    consume_pat: &ast::Pat,\n                    cmt: mc::cmt<'tcx>,\n                    mode: euv::ConsumeMode) {\n-        debug!(\"consume_pat(consume_pat={}, cmt={}, mode={})\",\n+        debug!(\"consume_pat(consume_pat={}, cmt={}, mode={:?})\",\n                consume_pat.repr(self.tcx()),\n                cmt.repr(self.tcx()),\n                mode);\n@@ -132,8 +132,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause)\n     {\n-        debug!(\"borrow(borrow_id={}, cmt={}, loan_region={}, \\\n-               bk={}, loan_cause={})\",\n+        debug!(\"borrow(borrow_id={}, cmt={}, loan_region={:?}, \\\n+               bk={:?}, loan_cause={:?})\",\n                borrow_id, cmt.repr(self.tcx()), loan_region,\n                bk, loan_cause);\n \n@@ -235,7 +235,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                        loan_region: ty::Region,\n                        cause: euv::LoanCause) {\n         debug!(\"guarantee_valid(borrow_id={}, cmt={}, \\\n-                req_mutbl={}, loan_region={})\",\n+                req_mutbl={:?}, loan_region={:?})\",\n                borrow_id,\n                cmt.repr(self.tcx()),\n                req_kind,\n@@ -273,7 +273,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n             self.bccx, borrow_span, cause,\n             cmt.clone(), loan_region);\n \n-        debug!(\"guarantee_valid(): restrictions={}\", restr);\n+        debug!(\"guarantee_valid(): restrictions={:?}\", restr);\n \n         // Create the loan record (if needed).\n         let loan = match restr {\n@@ -306,18 +306,18 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                     ty::ReInfer(..) => {\n                         self.tcx().sess.span_bug(\n                             cmt.span,\n-                            format!(\"invalid borrow lifetime: {}\",\n+                            format!(\"invalid borrow lifetime: {:?}\",\n                                     loan_region).index(&FullRange));\n                     }\n                 };\n-                debug!(\"loan_scope = {}\", loan_scope);\n+                debug!(\"loan_scope = {:?}\", loan_scope);\n \n                 let borrow_scope = region::CodeExtent::from_node_id(borrow_id);\n                 let gen_scope = self.compute_gen_scope(borrow_scope, loan_scope);\n-                debug!(\"gen_scope = {}\", gen_scope);\n+                debug!(\"gen_scope = {:?}\", gen_scope);\n \n                 let kill_scope = self.compute_kill_scope(loan_scope, &*loan_path);\n-                debug!(\"kill_scope = {}\", kill_scope);\n+                debug!(\"kill_scope = {:?}\", kill_scope);\n \n                 if req_kind == ty::MutBorrow {\n                     self.mark_loan_path_as_mutated(&*loan_path);"}, {"sha": "88f56f6862218b276c227945c733e9d897e047f1", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -586,7 +586,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     }\n                     r => {\n                         self.tcx.sess.bug(format!(\"MoveExpr({}) maps to \\\n-                                                   {}, not Expr\",\n+                                                   {:?}, not Expr\",\n                                                   the_move.id,\n                                                   r).index(&FullRange))\n                     }\n@@ -624,7 +624,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     }\n                     r => {\n                         self.tcx.sess.bug(format!(\"Captured({}) maps to \\\n-                                                   {}, not Expr\",\n+                                                   {:?}, not Expr\",\n                                                   the_move.id,\n                                                   r).index(&FullRange))\n                     }\n@@ -1005,7 +1005,7 @@ impl DataFlowOperator for LoanDataFlowOperator {\n \n impl<'tcx> Repr<'tcx> for Loan<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"Loan_{}({}, {}, {}-{}, {})\",\n+        format!(\"Loan_{}({}, {:?}, {:?}-{:?}, {})\",\n                  self.index,\n                  self.loan_path.repr(tcx),\n                  self.kind,"}, {"sha": "21b3c910d328a72ec814ec97dd18969308bf9421", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -311,7 +311,7 @@ impl<'tcx> MoveData<'tcx> {\n             }\n         };\n \n-        debug!(\"move_path(lp={}, index={})\",\n+        debug!(\"move_path(lp={}, index={:?})\",\n                lp.repr(tcx),\n                index);\n \n@@ -362,7 +362,7 @@ impl<'tcx> MoveData<'tcx> {\n                     lp: Rc<LoanPath<'tcx>>,\n                     id: ast::NodeId,\n                     kind: MoveKind) {\n-        debug!(\"add_move(lp={}, id={}, kind={})\",\n+        debug!(\"add_move(lp={}, id={}, kind={:?})\",\n                lp.repr(tcx),\n                id,\n                kind);\n@@ -413,12 +413,12 @@ impl<'tcx> MoveData<'tcx> {\n         };\n \n         if self.is_var_path(path_index) {\n-            debug!(\"add_assignment[var](lp={}, assignment={}, path_index={})\",\n+            debug!(\"add_assignment[var](lp={}, assignment={}, path_index={:?})\",\n                    lp.repr(tcx), self.var_assignments.borrow().len(), path_index);\n \n             self.var_assignments.borrow_mut().push(assignment);\n         } else {\n-            debug!(\"add_assignment[path](lp={}, path_index={})\",\n+            debug!(\"add_assignment[path](lp={}, path_index={:?})\",\n                    lp.repr(tcx), path_index);\n \n             self.path_assignments.borrow_mut().push(assignment);"}, {"sha": "647a5dd559c1dcd60c65357eac00976439824d72", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -53,7 +53,7 @@ pub struct DataflowLabeller<'a, 'tcx: 'a> {\n impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n     fn dataflow_for(&self, e: EntryOrExit, n: &Node<'a>) -> String {\n         let id = n.1.data.id;\n-        debug!(\"dataflow_for({}, id={}) {}\", e, id, self.variants);\n+        debug!(\"dataflow_for({:?}, id={}) {:?}\", e, id, self.variants);\n         let mut sets = \"\".to_string();\n         let mut seen_one = false;\n         for &variant in self.variants.iter() {"}, {"sha": "52d49924d05d51fe43421d5f524d156ae0daf792", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -726,7 +726,7 @@ pub fn collect_crate_types(session: &Session,\n         let res = !link::invalid_output_for_target(session, *crate_type);\n \n         if !res {\n-            session.warn(format!(\"dropping unsupported crate type `{}` \\\n+            session.warn(format!(\"dropping unsupported crate type `{:?}` \\\n                                    for target `{}`\",\n                                  *crate_type, session.opts.target_triple).index(&FullRange));\n         }"}, {"sha": "44a35ef6be70be5178bd20d83cb3257c6c36f763", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -548,7 +548,7 @@ pub fn pretty_print_input(sess: Session,\n         (PpmSource(s), None) =>\n             s.call_with_pp_support(\n                 sess, ast_map, &arenas, id, out, |annotation, out| {\n-                    debug!(\"pretty printing source code {}\", s);\n+                    debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     pprust::print_crate(sess.codemap(),\n                                         sess.diagnostic(),\n@@ -563,7 +563,7 @@ pub fn pretty_print_input(sess: Session,\n         (PpmSource(s), Some(uii)) =>\n             s.call_with_pp_support(\n                 sess, ast_map, &arenas, id, (out,uii), |annotation, (out,uii)| {\n-                    debug!(\"pretty printing source code {}\", s);\n+                    debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     let ast_map = annotation.ast_map()\n                         .expect(\"--pretty missing ast_map\");\n@@ -586,7 +586,7 @@ pub fn pretty_print_input(sess: Session,\n                 }),\n \n         (PpmFlowGraph, opt_uii) => {\n-            debug!(\"pretty printing flow graph for {}\", opt_uii);\n+            debug!(\"pretty printing flow graph for {:?}\", opt_uii);\n             let uii = opt_uii.unwrap_or_else(|| {\n                 sess.fatal(format!(\"`pretty flowgraph=..` needs NodeId (int) or\n                                      unique path suffix (b::c::d)\").index(&FullRange))\n@@ -609,7 +609,7 @@ pub fn pretty_print_input(sess: Session,\n                 }\n                 None => {\n                     let message = format!(\"--pretty=flowgraph needs \\\n-                                           block, fn, or method; got {}\",\n+                                           block, fn, or method; got {:?}\",\n                                           node);\n \n                     // point to what was found, if there's an"}, {"sha": "ca6b1469f856934a55b78568a915e7a7cb04f859", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -845,7 +845,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                            name: Name,\n                            new_parent: &Rc<Module>) {\n         debug!(\"(building reduced graph for \\\n-                external crate) building external def, priv {}\",\n+                external crate) building external def, priv {:?}\",\n                vis);\n         let is_public = vis == ast::Public;\n         let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n@@ -989,7 +989,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n           DefLocal(..) | DefPrimTy(..) | DefTyParam(..) |\n           DefUse(..) | DefUpvar(..) | DefRegion(..) |\n           DefTyParamBinder(..) | DefLabel(..) | DefSelfTy(..) => {\n-            panic!(\"didn't expect `{}`\", def);\n+            panic!(\"didn't expect `{:?}`\", def);\n           }\n         }\n     }"}, {"sha": "18066a7b94bd82fff2ab5bc6c03b8fa3062b0689", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -58,7 +58,7 @@ impl<'a, 'b, 'tcx> UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n     // public or private item, we will check the correct thing, dependent on how the import\n     // is used.\n     fn finalize_import(&mut self, id: ast::NodeId, span: Span) {\n-        debug!(\"finalizing import uses for {}\",\n+        debug!(\"finalizing import uses for {:?}\",\n                 self.session.codemap().span_to_snippet(span));\n \n         if !self.used_imports.contains(&(id, TypeNS)) &&"}, {"sha": "dc13f2e331be4f2210fbad315297043b48756816", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -548,7 +548,7 @@ impl Module {\n \n impl fmt::Show for Module {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}, kind: {}, {}\",\n+        write!(f, \"{:?}, kind: {:?}, {}\",\n                self.def_id,\n                self.kind,\n                if self.is_public { \"public\" } else { \"private\" } )\n@@ -689,7 +689,7 @@ impl NameBindings {\n \n     /// Records a type definition.\n     fn define_type(&self, def: Def, sp: Span, modifiers: DefModifiers) {\n-        debug!(\"defining type for def {} with modifiers {}\", def, modifiers);\n+        debug!(\"defining type for def {:?} with modifiers {:?}\", def, modifiers);\n         // Merges the type with the existing type def or creates a new one.\n         let type_def = self.type_def.borrow().clone();\n         match type_def {\n@@ -714,7 +714,7 @@ impl NameBindings {\n \n     /// Records a value definition.\n     fn define_value(&self, def: Def, sp: Span, modifiers: DefModifiers) {\n-        debug!(\"defining value for def {} with modifiers {}\", def, modifiers);\n+        debug!(\"defining value for def {:?} with modifiers {:?}\", def, modifiers);\n         *self.value_def.borrow_mut() = Some(ValueNsDef {\n             def: def,\n             value_span: Some(sp),\n@@ -1274,7 +1274,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                              lp: LastPrivate)\n                                  -> ResolveResult<()> {\n         debug!(\"(resolving single import) resolving `{}` = `{}::{}` from \\\n-                `{}` id {}, last private {}\",\n+                `{}` id {}, last private {:?}\",\n                token::get_name(target),\n                self.module_to_string(&*containing_module),\n                token::get_name(source),\n@@ -1377,7 +1377,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     shadowable: _\n                                 }) => {\n                                     debug!(\"(resolving single import) found \\\n-                                            import in ns {}\", namespace);\n+                                            import in ns {:?}\", namespace);\n                                     let id = import_resolution.id(namespace);\n                                     // track used imports and extern crates as well\n                                     this.used_imports.insert((id, namespace));\n@@ -1486,7 +1486,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 match *result {\n                     BoundResult(ref target_module, ref name_bindings) => {\n-                        debug!(\"(resolving single import) found {} target: {}\",\n+                        debug!(\"(resolving single import) found {:?} target: {:?}\",\n                                namespace_name,\n                                name_bindings.def_for_namespace(namespace));\n                         self.check_for_conflicting_import(\n@@ -1510,7 +1510,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                     UnboundResult => { /* Continue. */ }\n                     UnknownResult => {\n-                        panic!(\"{} result should be known at this point\", namespace_name);\n+                        panic!(\"{:?} result should be known at this point\", namespace_name);\n                     }\n                 }\n             };\n@@ -2167,7 +2167,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                      namespace: Namespace)\n                                     -> ResolveResult<(Target, bool)> {\n         debug!(\"(resolving item in lexical scope) resolving `{}` in \\\n-                namespace {} in `{}`\",\n+                namespace {:?} in `{}`\",\n                token::get_name(name),\n                namespace,\n                self.module_to_string(&*module_));\n@@ -2197,7 +2197,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 None => {\n                     // Not found; continue.\n                     debug!(\"(resolving item in lexical scope) found \\\n-                            import resolution, but not in namespace {}\",\n+                            import resolution, but not in namespace {:?}\",\n                            namespace);\n                 }\n                 Some(target) => {\n@@ -2477,7 +2477,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 match import_resolution.target_for_namespace(namespace) {\n                     None => {\n                         debug!(\"(resolving name in module) name found, \\\n-                                but not in namespace {}\",\n+                                but not in namespace {:?}\",\n                                namespace);\n                     }\n                     Some(target) => {\n@@ -2622,7 +2622,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match def_like {\n             DlDef(d @ DefUpvar(..)) => {\n                 self.session.span_bug(span,\n-                    format!(\"unexpected {} in bindings\", d).index(&FullRange))\n+                    format!(\"unexpected {:?} in bindings\", d).index(&FullRange))\n             }\n             DlDef(d @ DefLocal(_)) => {\n                 let node_id = d.def_id().node;\n@@ -3189,7 +3189,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Some(def) => {\n                 match def {\n                     (DefTrait(_), _) => {\n-                        debug!(\"(resolving trait) found trait def: {}\", def);\n+                        debug!(\"(resolving trait) found trait def: {:?}\", def);\n                         self.record_def(trait_reference.ref_id, def);\n                     }\n                     (def, _) => {\n@@ -3580,8 +3580,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     None => {\n                         match self.resolve_path(ty.id, path, TypeNS, true) {\n                             Some(def) => {\n-                                debug!(\"(resolving type) resolved `{}` to \\\n-                                        type {}\",\n+                                debug!(\"(resolving type) resolved `{:?}` to \\\n+                                        type {:?}\",\n                                        token::get_ident(path.segments.last().unwrap() .identifier),\n                                        def);\n                                 result_def = Some(def);\n@@ -3799,7 +3799,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         }\n                         result => {\n                             debug!(\"(resolving pattern) didn't find struct \\\n-                                    def: {}\", result);\n+                                    def: {:?}\", result);\n                             let msg = format!(\"`{}` does not name a structure\",\n                                               self.path_names_to_string(path));\n                             self.resolve_error(path.span, msg.index(&FullRange));\n@@ -3823,7 +3823,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                  ValueNS) {\n             Success((target, _)) => {\n                 debug!(\"(resolve bare identifier pattern) succeeded in \\\n-                         finding {} at {}\",\n+                         finding {} at {:?}\",\n                         token::get_name(name),\n                         target.bindings.value_def.borrow());\n                 match *target.bindings.value_def.borrow() {\n@@ -4181,7 +4181,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match search_result {\n             Some(DlDef(def)) => {\n                 debug!(\"(resolving path in local ribs) resolved `{}` to \\\n-                        local: {}\",\n+                        local: {:?}\",\n                        token::get_ident(ident),\n                        def);\n                 return Some(def);\n@@ -4532,7 +4532,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     Some(definition) => self.record_def(expr.id, definition),\n                     result => {\n                         debug!(\"(resolving expression) didn't find struct \\\n-                                def: {}\", result);\n+                                def: {:?}\", result);\n                         let msg = format!(\"`{}` does not name a structure\",\n                                           self.path_names_to_string(path));\n                         self.resolve_error(path.span, msg.index(&FullRange));\n@@ -4719,7 +4719,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     fn record_def(&mut self, node_id: NodeId, (def, lp): (Def, LastPrivate)) {\n-        debug!(\"(recording def) recording {} for {}, last private {}\",\n+        debug!(\"(recording def) recording {:?} for {}, last private {:?}\",\n                 def, node_id, lp);\n         assert!(match lp {LastImport{..} => false, _ => true},\n                 \"Import should only be used for `use` directives\");\n@@ -4731,8 +4731,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             // the same conclusion! - nmatsakis\n             Occupied(entry) => if def != *entry.get() {\n                 self.session\n-                    .bug(format!(\"node_id {} resolved first to {} and \\\n-                                  then {}\",\n+                    .bug(format!(\"node_id {} resolved first to {:?} and \\\n+                                  then {:?}\",\n                                  node_id,\n                                  *entry.get(),\n                                  def).index(&FullRange));"}, {"sha": "67bcf152eb78cfa5d20d71d413f79dabfad1d766", "filename": "src/librustc_resolve/record_exports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_resolve%2Frecord_exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_resolve%2Frecord_exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Frecord_exports.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -117,15 +117,15 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n                                    ns: Namespace) {\n         match namebindings.def_for_namespace(ns) {\n             Some(d) => {\n-                debug!(\"(computing exports) YES: export '{}' => {}\",\n+                debug!(\"(computing exports) YES: export '{}' => {:?}\",\n                        name, d.def_id());\n                 exports.push(Export {\n                     name: name,\n                     def_id: d.def_id()\n                 });\n             }\n             d_opt => {\n-                debug!(\"(computing exports) NO: {}\", d_opt);\n+                debug!(\"(computing exports) NO: {:?}\", d_opt);\n             }\n         }\n     }"}, {"sha": "26241ace76f4889e28b18338465e94034eef80a3", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -171,7 +171,7 @@ pub fn build_link_meta(sess: &Session, krate: &ast::Crate,\n         crate_name: name,\n         crate_hash: Svh::calculate(&sess.opts.cg.metadata, krate),\n     };\n-    info!(\"{}\", r);\n+    info!(\"{:?}\", r);\n     return r;\n }\n \n@@ -373,7 +373,7 @@ pub fn link_binary(sess: &Session,\n     let mut out_filenames = Vec::new();\n     for &crate_type in sess.crate_types.borrow().iter() {\n         if invalid_output_for_target(sess, crate_type) {\n-            sess.bug(format!(\"invalid output type `{}` for target os `{}`\",\n+            sess.bug(format!(\"invalid output type `{:?}` for target os `{}`\",\n                              crate_type, sess.opts.target_triple).index(&FullRange));\n         }\n         let out_file = link_binary_output(sess, trans, crate_type, outputs,"}, {"sha": "452e81e2e0e6c7d5125ffe5145457621c99bc9ec", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -174,7 +174,7 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n         \"default\" => llvm::RelocDefault,\n         \"dynamic-no-pic\" => llvm::RelocDynamicNoPic,\n         _ => {\n-            sess.err(format!(\"{} is not a valid relocation mode\",\n+            sess.err(format!(\"{:?} is not a valid relocation mode\",\n                              sess.opts\n                                  .cg\n                                  .relocation_model).index(&FullRange));\n@@ -209,7 +209,7 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n         \"medium\" => llvm::CodeModelMedium,\n         \"large\" => llvm::CodeModelLarge,\n         _ => {\n-            sess.err(format!(\"{} is not a valid code model\",\n+            sess.err(format!(\"{:?} is not a valid code model\",\n                              sess.opts\n                                  .cg\n                                  .code_model).index(&FullRange));"}, {"sha": "35f168f092a700d5d57dda2dc011504defa3fd1a", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -240,7 +240,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefUse(_) |\n             def::DefMethod(..) |\n             def::DefPrimTy(_) => {\n-                self.sess.span_bug(span, format!(\"lookup_def_kind for unexpected item: {}\",\n+                self.sess.span_bug(span, format!(\"lookup_def_kind for unexpected item: {:?}\",\n                                                  def).index(&FullRange));\n             },\n         }\n@@ -308,7 +308,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 },\n                 _ => {\n                     self.sess.span_bug(method.span,\n-                                       format!(\"Container {} for method {} is not a node item {}\",\n+                                       format!(\"Container {} for method {} is not a node item {:?}\",\n                                                impl_id.node,\n                                                method.id,\n                                                self.analysis.ty_cx.map.get(impl_id.node)\n@@ -1444,7 +1444,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 // FIXME(nrc) what are these doing here?\n                 def::DefStatic(_, _) => {}\n                 def::DefConst(..) => {}\n-                _ => error!(\"unexpected definition kind when processing collected paths: {}\", *def)\n+                _ => error!(\"unexpected definition kind when processing collected paths: {:?}\",\n+                            *def)\n             }\n         }\n         for &(id, span, ref path, ref_kind) in paths_to_process.iter() {"}, {"sha": "49b9ef5a40adebf2e6add1ac35d25a37a17c6690", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -518,7 +518,7 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n              variant_size: uint,\n              val: ValueRef)\n              -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n-    debug!(\"enter_opt(bcx={}, m={}, opt={}, col={}, val={})\",\n+    debug!(\"enter_opt(bcx={}, m={}, opt={:?}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            *opt,\n@@ -1046,7 +1046,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     // Decide what kind of branch we need\n     let opts = get_branches(bcx, m, col);\n-    debug!(\"options={}\", opts);\n+    debug!(\"options={:?}\", opts);\n     let mut kind = NoBranch;\n     let mut test_val = val;\n     debug!(\"test_val={}\", bcx.val_to_string(test_val));"}, {"sha": "231de71848a1d44e6179b564f08210f809b11ca9", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -145,7 +145,7 @@ pub fn represent_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n \n     let repr = Rc::new(represent_type_uncached(cx, t));\n-    debug!(\"Represented as: {}\", repr);\n+    debug!(\"Represented as: {:?}\", repr);\n     cx.adt_reprs().borrow_mut().insert(t, repr.clone());\n     repr\n }\n@@ -482,7 +482,7 @@ fn mk_cenum<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n }\n \n fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntType {\n-    debug!(\"range_to_inttype: {} {}\", hint, bounds);\n+    debug!(\"range_to_inttype: {:?} {:?}\", hint, bounds);\n     // Lists of sizes to try.  u64 is always allowed as a fallback.\n     #[allow(non_upper_case_globals)]\n     static choose_shortest: &'static[IntType] = &[\n@@ -533,7 +533,7 @@ pub fn ll_inttype(cx: &CrateContext, ity: IntType) -> Type {\n }\n \n fn bounds_usable(cx: &CrateContext, ity: IntType, bounds: &IntBounds) -> bool {\n-    debug!(\"bounds_usable: {} {}\", ity, bounds);\n+    debug!(\"bounds_usable: {:?} {:?}\", ity, bounds);\n     match ity {\n         attr::SignedInt(_) => {\n             let lllo = C_integral(ll_inttype(cx, ity), bounds.slo as u64, true);\n@@ -731,7 +731,7 @@ pub fn trans_get_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n     -> ValueRef {\n     let signed;\n     let val;\n-    debug!(\"trans_get_discr r: {}\", r);\n+    debug!(\"trans_get_discr r: {:?}\", r);\n     match *r {\n         CEnum(ity, min, max) => {\n             val = load_discr(bcx, ity, scrutinee, min, max);"}, {"sha": "b0339529fd827be7f05b654f174e6e02ac3d522c", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -976,7 +976,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     if need_invoke(bcx) {\n-        debug!(\"invoking {} at {}\", bcx.val_to_string(llfn), bcx.llbb);\n+        debug!(\"invoking {} at {:?}\", bcx.val_to_string(llfn), bcx.llbb);\n         for &llarg in llargs.iter() {\n             debug!(\"arg: {}\", bcx.val_to_string(llarg));\n         }\n@@ -996,7 +996,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               Some(attributes));\n         return (llresult, normal_bcx);\n     } else {\n-        debug!(\"calling {} at {}\", bcx.val_to_string(llfn), bcx.llbb);\n+        debug!(\"calling {} at {:?}\", bcx.val_to_string(llfn), bcx.llbb);\n         for &llarg in llargs.iter() {\n             debug!(\"arg: {}\", bcx.val_to_string(llarg));\n         }\n@@ -2742,7 +2742,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n     }\n \n     let item = ccx.tcx().map.get(id);\n-    debug!(\"get_item_val: id={} item={}\", id, item);\n+    debug!(\"get_item_val: id={} item={:?}\", id, item);\n     let val = match item {\n         ast_map::NodeItem(i) => {\n             let ty = ty::node_id_to_type(ccx.tcx(), i.id);\n@@ -2917,7 +2917,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n         }\n \n         ref variant => {\n-            ccx.sess().bug(format!(\"get_item_val(): unexpected variant: {}\",\n+            ccx.sess().bug(format!(\"get_item_val(): unexpected variant: {:?}\",\n                                    variant).index(&FullRange))\n         }\n     };"}, {"sha": "7b38f26913dc89f8616a5503d6be20acf4ea5847", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -206,7 +206,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n             def::DefSelfTy(..) | def::DefAssociatedPath(..) => {\n                 bcx.tcx().sess.span_bug(\n                     ref_expr.span,\n-                    format!(\"cannot translate def {} \\\n+                    format!(\"cannot translate def {:?} \\\n                              to a callable thing!\", def).index(&FullRange));\n             }\n         }\n@@ -223,7 +223,7 @@ pub fn trans_fn_ref<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let _icx = push_ctxt(\"trans_fn_ref\");\n \n     let substs = node_id_substs(ccx, node, param_substs);\n-    debug!(\"trans_fn_ref(def_id={}, node={}, substs={})\",\n+    debug!(\"trans_fn_ref(def_id={}, node={:?}, substs={})\",\n            def_id.repr(ccx.tcx()),\n            node,\n            substs.repr(ccx.tcx()));\n@@ -386,7 +386,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     let _icx = push_ctxt(\"trans_fn_ref_with_substs\");\n     let tcx = ccx.tcx();\n \n-    debug!(\"trans_fn_ref_with_substs(def_id={}, node={}, \\\n+    debug!(\"trans_fn_ref_with_substs(def_id={}, node={:?}, \\\n             param_substs={}, substs={})\",\n            def_id.repr(tcx),\n            node,"}, {"sha": "92a96cd02b501c67f64af211a42772724a82e2ea", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -227,7 +227,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                                           bcx: Block<'blk, 'tcx>,\n                                           custom_scope: CustomScopeIndex)\n                                           -> Block<'blk, 'tcx> {\n-        debug!(\"pop_and_trans_custom_cleanup_scope({})\", custom_scope);\n+        debug!(\"pop_and_trans_custom_cleanup_scope({:?})\", custom_scope);\n         assert!(self.is_valid_to_pop_custom_scope(custom_scope));\n \n         let scope = self.pop_scope();\n@@ -265,7 +265,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             ptr: val,\n         };\n \n-        debug!(\"schedule_lifetime_end({}, val={})\",\n+        debug!(\"schedule_lifetime_end({:?}, val={})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val));\n \n@@ -286,7 +286,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             zero: false\n         };\n \n-        debug!(\"schedule_drop_mem({}, val={}, ty={})\",\n+        debug!(\"schedule_drop_mem({:?}, val={}, ty={})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n                ty.repr(self.ccx.tcx()));\n@@ -308,7 +308,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             zero: true\n         };\n \n-        debug!(\"schedule_drop_and_zero_mem({}, val={}, ty={}, zero={})\",\n+        debug!(\"schedule_drop_and_zero_mem({:?}, val={}, ty={}, zero={})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n                ty.repr(self.ccx.tcx()),\n@@ -332,7 +332,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             zero: false\n         };\n \n-        debug!(\"schedule_drop_immediate({}, val={}, ty={})\",\n+        debug!(\"schedule_drop_immediate({:?}, val={}, ty={:?})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n                ty.repr(self.ccx.tcx()));\n@@ -348,7 +348,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                            content_ty: Ty<'tcx>) {\n         let drop = box FreeValue { ptr: val, heap: heap, content_ty: content_ty };\n \n-        debug!(\"schedule_free_value({}, val={}, heap={})\",\n+        debug!(\"schedule_free_value({:?}, val={}, heap={:?})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n                heap);\n@@ -365,7 +365,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                            heap: Heap) {\n         let drop = box FreeSlice { ptr: val, size: size, align: align, heap: heap };\n \n-        debug!(\"schedule_free_slice({}, val={}, heap={})\",\n+        debug!(\"schedule_free_slice({:?}, val={}, heap={:?})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n                heap);\n@@ -549,7 +549,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n     fn trans_cleanups_to_exit_scope(&'blk self,\n                                     label: EarlyExitLabel)\n                                     -> BasicBlockRef {\n-        debug!(\"trans_cleanups_to_exit_scope label={} scopes={}\",\n+        debug!(\"trans_cleanups_to_exit_scope label={:?} scopes={}\",\n                label, self.scopes_len());\n \n         let orig_scopes_len = self.scopes_len();\n@@ -675,7 +675,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n             self.push_scope(scope);\n         }\n \n-        debug!(\"trans_cleanups_to_exit_scope: prev_llbb={}\", prev_llbb);\n+        debug!(\"trans_cleanups_to_exit_scope: prev_llbb={:?}\", prev_llbb);\n \n         assert_eq!(self.scopes_len(), orig_scopes_len);\n         prev_llbb\n@@ -1018,7 +1018,7 @@ pub fn temporary_scope(tcx: &ty::ctxt,\n     match tcx.region_maps.temporary_scope(id) {\n         Some(scope) => {\n             let r = AstScope(scope.node_id());\n-            debug!(\"temporary_scope({}) = {}\", id, r);\n+            debug!(\"temporary_scope({}) = {:?}\", id, r);\n             r\n         }\n         None => {\n@@ -1032,7 +1032,7 @@ pub fn var_scope(tcx: &ty::ctxt,\n                  id: ast::NodeId)\n                  -> ScopeId {\n     let r = AstScope(tcx.region_maps.var_scope(id).node_id());\n-    debug!(\"var_scope({}) = {}\", id, r);\n+    debug!(\"var_scope({}) = {:?}\", id, r);\n     r\n }\n "}, {"sha": "f057d4bcab812a1f616d0cd12f5d43a144e1844a", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -108,7 +108,7 @@ pub struct EnvValue<'tcx> {\n \n impl<'tcx> EnvValue<'tcx> {\n     pub fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n-        format!(\"{}({})\", self.action, self.datum.to_string(ccx))\n+        format!(\"{:?}({})\", self.action, self.datum.to_string(ccx))\n     }\n }\n \n@@ -495,7 +495,7 @@ pub fn get_or_create_declaration_if_unboxed_closure<'a, 'tcx>(ccx: &CrateContext\n     set_inline_hint(llfn);\n \n     debug!(\"get_or_create_declaration_if_unboxed_closure(): inserting new \\\n-            closure {} (type {})\",\n+            closure {:?} (type {})\",\n            mono_id,\n            ccx.tn().type_to_string(val_ty(llfn)));\n     ccx.unboxed_closure_vals().borrow_mut().insert(mono_id, llfn);"}, {"sha": "5d3eeb39e31575ecf367f8b5ed73c0f0b03249be", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 709, "deletions": 709, "changes": 1418, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -60,234 +60,234 @@ pub use trans::context::CrateContext;\n \n // Is the type's representation size known at compile time?\n pub fn type_is_sized<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty::type_contents(cx, ty).is_sized(cx)\n+ty::type_contents(cx, ty).is_sized(cx)\n }\n \n pub fn lltype_is_sized<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.sty {\n-        ty::ty_open(_) => true,\n-        _ => type_is_sized(cx, ty),\n-    }\n+match ty.sty {\n+    ty::ty_open(_) => true,\n+    _ => type_is_sized(cx, ty),\n+}\n }\n \n pub fn type_is_fat_ptr<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.sty {\n-        ty::ty_ptr(ty::mt{ty, ..}) |\n-        ty::ty_rptr(_, ty::mt{ty, ..}) |\n-        ty::ty_uniq(ty) => {\n-            !type_is_sized(cx, ty)\n-        }\n-        _ => {\n-            false\n-        }\n+match ty.sty {\n+    ty::ty_ptr(ty::mt{ty, ..}) |\n+    ty::ty_rptr(_, ty::mt{ty, ..}) |\n+    ty::ty_uniq(ty) => {\n+        !type_is_sized(cx, ty)\n     }\n+    _ => {\n+        false\n+    }\n+}\n }\n \n // Return the smallest part of `ty` which is unsized. Fails if `ty` is sized.\n // 'Smallest' here means component of the static representation of the type; not\n // the size of an object at runtime.\n pub fn unsized_part_of_type<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-    match ty.sty {\n-        ty::ty_str | ty::ty_trait(..) | ty::ty_vec(..) => ty,\n-        ty::ty_struct(def_id, substs) => {\n-            let unsized_fields: Vec<_> =\n-                ty::struct_fields(cx, def_id, substs)\n-                .iter()\n-                .map(|f| f.mt.ty)\n-                .filter(|ty| !type_is_sized(cx, *ty))\n-                .collect();\n-\n-            // Exactly one of the fields must be unsized.\n-            assert!(unsized_fields.len() == 1);\n-\n-            unsized_part_of_type(cx, unsized_fields[0])\n-        }\n-        _ => {\n-            assert!(type_is_sized(cx, ty),\n-                    \"unsized_part_of_type failed even though ty is unsized\");\n-            panic!(\"called unsized_part_of_type with sized ty\");\n-        }\n+match ty.sty {\n+    ty::ty_str | ty::ty_trait(..) | ty::ty_vec(..) => ty,\n+    ty::ty_struct(def_id, substs) => {\n+        let unsized_fields: Vec<_> =\n+            ty::struct_fields(cx, def_id, substs)\n+            .iter()\n+            .map(|f| f.mt.ty)\n+            .filter(|ty| !type_is_sized(cx, *ty))\n+            .collect();\n+\n+        // Exactly one of the fields must be unsized.\n+        assert!(unsized_fields.len() == 1);\n+\n+        unsized_part_of_type(cx, unsized_fields[0])\n+    }\n+    _ => {\n+        assert!(type_is_sized(cx, ty),\n+                \"unsized_part_of_type failed even though ty is unsized\");\n+        panic!(\"called unsized_part_of_type with sized ty\");\n     }\n }\n+}\n \n // Some things don't need cleanups during unwinding because the\n // task can free them all at once later. Currently only things\n // that only contain scalars and shared boxes can avoid unwind\n // cleanups.\n pub fn type_needs_unwind_cleanup<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    return memoized(ccx.needs_unwind_cleanup_cache(), ty, |ty| {\n-        type_needs_unwind_cleanup_(ccx.tcx(), ty, &mut FnvHashSet::new())\n-    });\n+return memoized(ccx.needs_unwind_cleanup_cache(), ty, |ty| {\n+    type_needs_unwind_cleanup_(ccx.tcx(), ty, &mut FnvHashSet::new())\n+});\n+\n+fn type_needs_unwind_cleanup_<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                    ty: Ty<'tcx>,\n+                                    tycache: &mut FnvHashSet<Ty<'tcx>>)\n+                                    -> bool\n+{\n+    // Prevent infinite recursion\n+    if !tycache.insert(ty) {\n+        return false;\n+    }\n \n-    fn type_needs_unwind_cleanup_<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                        ty: Ty<'tcx>,\n-                                        tycache: &mut FnvHashSet<Ty<'tcx>>)\n-                                        -> bool\n-    {\n-        // Prevent infinite recursion\n-        if !tycache.insert(ty) {\n-            return false;\n-        }\n+    let mut needs_unwind_cleanup = false;\n+    ty::maybe_walk_ty(ty, |ty| {\n+        needs_unwind_cleanup |= match ty.sty {\n+            ty::ty_bool | ty::ty_int(_) | ty::ty_uint(_) |\n+            ty::ty_float(_) | ty::ty_tup(_) | ty::ty_ptr(_) => false,\n \n-        let mut needs_unwind_cleanup = false;\n-        ty::maybe_walk_ty(ty, |ty| {\n-            needs_unwind_cleanup |= match ty.sty {\n-                ty::ty_bool | ty::ty_int(_) | ty::ty_uint(_) |\n-                ty::ty_float(_) | ty::ty_tup(_) | ty::ty_ptr(_) => false,\n-\n-                ty::ty_enum(did, substs) =>\n-                    ty::enum_variants(tcx, did).iter().any(|v|\n-                        v.args.iter().any(|&aty| {\n-                            let t = aty.subst(tcx, substs);\n-                            type_needs_unwind_cleanup_(tcx, t, tycache)\n-                        })\n-                    ),\n-\n-                _ => true\n-            };\n-            !needs_unwind_cleanup\n-        });\n-        needs_unwind_cleanup\n-    }\n+            ty::ty_enum(did, substs) =>\n+                ty::enum_variants(tcx, did).iter().any(|v|\n+                    v.args.iter().any(|&aty| {\n+                        let t = aty.subst(tcx, substs);\n+                        type_needs_unwind_cleanup_(tcx, t, tycache)\n+                    })\n+                ),\n+\n+            _ => true\n+        };\n+        !needs_unwind_cleanup\n+    });\n+    needs_unwind_cleanup\n+}\n }\n \n pub fn type_needs_drop<'tcx>(cx: &ty::ctxt<'tcx>,\n-                             ty: Ty<'tcx>)\n-                             -> bool {\n-    ty::type_contents(cx, ty).needs_drop(cx)\n+                         ty: Ty<'tcx>)\n+                         -> bool {\n+ty::type_contents(cx, ty).needs_drop(cx)\n }\n \n fn type_is_newtype_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                       ty: Ty<'tcx>) -> bool {\n-    match ty.sty {\n-        ty::ty_struct(def_id, substs) => {\n-            let fields = ty::struct_fields(ccx.tcx(), def_id, substs);\n-            fields.len() == 1 &&\n-                fields[0].name ==\n-                    token::special_idents::unnamed_field.name &&\n-                type_is_immediate(ccx, fields[0].mt.ty)\n-        }\n-        _ => false\n+                                   ty: Ty<'tcx>) -> bool {\n+match ty.sty {\n+    ty::ty_struct(def_id, substs) => {\n+        let fields = ty::struct_fields(ccx.tcx(), def_id, substs);\n+        fields.len() == 1 &&\n+            fields[0].name ==\n+                token::special_idents::unnamed_field.name &&\n+            type_is_immediate(ccx, fields[0].mt.ty)\n     }\n+    _ => false\n+}\n }\n \n pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    use trans::machine::llsize_of_alloc;\n-    use trans::type_of::sizing_type_of;\n-\n-    let tcx = ccx.tcx();\n-    let simple = ty::type_is_scalar(ty) ||\n-        ty::type_is_unique(ty) || ty::type_is_region_ptr(ty) ||\n-        type_is_newtype_immediate(ccx, ty) ||\n-        ty::type_is_simd(tcx, ty);\n-    if simple && !type_is_fat_ptr(tcx, ty) {\n-        return true;\n-    }\n-    if !type_is_sized(tcx, ty) {\n-        return false;\n-    }\n-    match ty.sty {\n-        ty::ty_struct(..) | ty::ty_enum(..) | ty::ty_tup(..) |\n-        ty::ty_unboxed_closure(..) => {\n-            let llty = sizing_type_of(ccx, ty);\n-            llsize_of_alloc(ccx, llty) <= llsize_of_alloc(ccx, ccx.int_type())\n-        }\n-        _ => type_is_zero_size(ccx, ty)\n+use trans::machine::llsize_of_alloc;\n+use trans::type_of::sizing_type_of;\n+\n+let tcx = ccx.tcx();\n+let simple = ty::type_is_scalar(ty) ||\n+    ty::type_is_unique(ty) || ty::type_is_region_ptr(ty) ||\n+    type_is_newtype_immediate(ccx, ty) ||\n+    ty::type_is_simd(tcx, ty);\n+if simple && !type_is_fat_ptr(tcx, ty) {\n+    return true;\n+}\n+if !type_is_sized(tcx, ty) {\n+    return false;\n+}\n+match ty.sty {\n+    ty::ty_struct(..) | ty::ty_enum(..) | ty::ty_tup(..) |\n+    ty::ty_unboxed_closure(..) => {\n+        let llty = sizing_type_of(ccx, ty);\n+        llsize_of_alloc(ccx, llty) <= llsize_of_alloc(ccx, ccx.int_type())\n     }\n+    _ => type_is_zero_size(ccx, ty)\n+}\n }\n \n /// Identify types which have size zero at runtime.\n pub fn type_is_zero_size<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    use trans::machine::llsize_of_alloc;\n-    use trans::type_of::sizing_type_of;\n-    let llty = sizing_type_of(ccx, ty);\n-    llsize_of_alloc(ccx, llty) == 0\n+use trans::machine::llsize_of_alloc;\n+use trans::type_of::sizing_type_of;\n+let llty = sizing_type_of(ccx, ty);\n+llsize_of_alloc(ccx, llty) == 0\n }\n \n /// Identifies types which we declare to be equivalent to `void` in C for the purpose of function\n /// return types. These are `()`, bot, and uninhabited enums. Note that all such types are also\n /// zero-size, but not all zero-size types use a `void` return type (in order to aid with C ABI\n /// compatibility).\n pub fn return_type_is_void(ccx: &CrateContext, ty: Ty) -> bool {\n-    ty::type_is_nil(ty) || ty::type_is_empty(ccx.tcx(), ty)\n+ty::type_is_nil(ty) || ty::type_is_empty(ccx.tcx(), ty)\n }\n \n /// Generates a unique symbol based off the name given. This is used to create\n /// unique symbols for things like closures.\n pub fn gensym_name(name: &str) -> PathElem {\n-    let num = token::gensym(name).uint();\n-    // use one colon which will get translated to a period by the mangler, and\n-    // we're guaranteed that `num` is globally unique for this crate.\n-    PathName(token::gensym(format!(\"{}:{}\", name, num).index(&FullRange)))\n+let num = token::gensym(name).uint();\n+// use one colon which will get translated to a period by the mangler, and\n+// we're guaranteed that `num` is globally unique for this crate.\n+PathName(token::gensym(format!(\"{}:{}\", name, num).index(&FullRange)))\n }\n \n #[derive(Copy)]\n pub struct tydesc_info<'tcx> {\n-    pub ty: Ty<'tcx>,\n-    pub tydesc: ValueRef,\n-    pub size: ValueRef,\n-    pub align: ValueRef,\n-    pub name: ValueRef,\n+pub ty: Ty<'tcx>,\n+pub tydesc: ValueRef,\n+pub size: ValueRef,\n+pub align: ValueRef,\n+pub name: ValueRef,\n }\n \n /*\n- * A note on nomenclature of linking: \"extern\", \"foreign\", and \"upcall\".\n- *\n- * An \"extern\" is an LLVM symbol we wind up emitting an undefined external\n- * reference to. This means \"we don't have the thing in this compilation unit,\n- * please make sure you link it in at runtime\". This could be a reference to\n- * C code found in a C library, or rust code found in a rust crate.\n- *\n- * Most \"externs\" are implicitly declared (automatically) as a result of a\n- * user declaring an extern _module_ dependency; this causes the rust driver\n- * to locate an extern crate, scan its compilation metadata, and emit extern\n- * declarations for any symbols used by the declaring crate.\n- *\n- * A \"foreign\" is an extern that references C (or other non-rust ABI) code.\n- * There is no metadata to scan for extern references so in these cases either\n- * a header-digester like bindgen, or manual function prototypes, have to\n- * serve as declarators. So these are usually given explicitly as prototype\n- * declarations, in rust code, with ABI attributes on them noting which ABI to\n- * link via.\n- *\n- * An \"upcall\" is a foreign call generated by the compiler (not corresponding\n- * to any user-written call in the code) into the runtime library, to perform\n- * some helper task such as bringing a task to life, allocating memory, etc.\n- *\n- */\n+* A note on nomenclature of linking: \"extern\", \"foreign\", and \"upcall\".\n+*\n+* An \"extern\" is an LLVM symbol we wind up emitting an undefined external\n+* reference to. This means \"we don't have the thing in this compilation unit,\n+* please make sure you link it in at runtime\". This could be a reference to\n+* C code found in a C library, or rust code found in a rust crate.\n+*\n+* Most \"externs\" are implicitly declared (automatically) as a result of a\n+* user declaring an extern _module_ dependency; this causes the rust driver\n+* to locate an extern crate, scan its compilation metadata, and emit extern\n+* declarations for any symbols used by the declaring crate.\n+*\n+* A \"foreign\" is an extern that references C (or other non-rust ABI) code.\n+* There is no metadata to scan for extern references so in these cases either\n+* a header-digester like bindgen, or manual function prototypes, have to\n+* serve as declarators. So these are usually given explicitly as prototype\n+* declarations, in rust code, with ABI attributes on them noting which ABI to\n+* link via.\n+*\n+* An \"upcall\" is a foreign call generated by the compiler (not corresponding\n+* to any user-written call in the code) into the runtime library, to perform\n+* some helper task such as bringing a task to life, allocating memory, etc.\n+*\n+*/\n \n #[derive(Copy)]\n pub struct NodeInfo {\n-    pub id: ast::NodeId,\n-    pub span: Span,\n+pub id: ast::NodeId,\n+pub span: Span,\n }\n \n pub fn expr_info(expr: &ast::Expr) -> NodeInfo {\n-    NodeInfo { id: expr.id, span: expr.span }\n+NodeInfo { id: expr.id, span: expr.span }\n }\n \n pub struct BuilderRef_res {\n-    pub b: BuilderRef,\n+pub b: BuilderRef,\n }\n \n impl Drop for BuilderRef_res {\n-    fn drop(&mut self) {\n-        unsafe {\n-            llvm::LLVMDisposeBuilder(self.b);\n-        }\n+fn drop(&mut self) {\n+    unsafe {\n+        llvm::LLVMDisposeBuilder(self.b);\n     }\n }\n+}\n \n pub fn BuilderRef_res(b: BuilderRef) -> BuilderRef_res {\n-    BuilderRef_res {\n-        b: b\n-    }\n+BuilderRef_res {\n+    b: b\n+}\n }\n \n pub type ExternMap = FnvHashMap<String, ValueRef>;\n \n pub fn validate_substs(substs: &Substs) {\n-    assert!(substs.types.all(|t| !ty::type_needs_infer(*t)));\n+assert!(substs.types.all(|t| !ty::type_needs_infer(*t)));\n }\n \n // work around bizarre resolve errors\n@@ -297,183 +297,183 @@ type LvalueDatum<'tcx> = datum::Datum<'tcx, datum::Lvalue>;\n // Function context.  Every LLVM function we create will have one of\n // these.\n pub struct FunctionContext<'a, 'tcx: 'a> {\n-    // The ValueRef returned from a call to llvm::LLVMAddFunction; the\n-    // address of the first instruction in the sequence of\n-    // instructions for this function that will go in the .text\n-    // section of the executable we're generating.\n-    pub llfn: ValueRef,\n+// The ValueRef returned from a call to llvm::LLVMAddFunction; the\n+// address of the first instruction in the sequence of\n+// instructions for this function that will go in the .text\n+// section of the executable we're generating.\n+pub llfn: ValueRef,\n \n-    // always an empty parameter-environment\n-    pub param_env: ty::ParameterEnvironment<'a, 'tcx>,\n+// always an empty parameter-environment\n+pub param_env: ty::ParameterEnvironment<'a, 'tcx>,\n \n-    // The environment argument in a closure.\n-    pub llenv: Option<ValueRef>,\n+// The environment argument in a closure.\n+pub llenv: Option<ValueRef>,\n \n-    // A pointer to where to store the return value. If the return type is\n-    // immediate, this points to an alloca in the function. Otherwise, it's a\n-    // pointer to the hidden first parameter of the function. After function\n-    // construction, this should always be Some.\n-    pub llretslotptr: Cell<Option<ValueRef>>,\n+// A pointer to where to store the return value. If the return type is\n+// immediate, this points to an alloca in the function. Otherwise, it's a\n+// pointer to the hidden first parameter of the function. After function\n+// construction, this should always be Some.\n+pub llretslotptr: Cell<Option<ValueRef>>,\n \n-    // These pub elements: \"hoisted basic blocks\" containing\n-    // administrative activities that have to happen in only one place in\n-    // the function, due to LLVM's quirks.\n-    // A marker for the place where we want to insert the function's static\n-    // allocas, so that LLVM will coalesce them into a single alloca call.\n-    pub alloca_insert_pt: Cell<Option<ValueRef>>,\n-    pub llreturn: Cell<Option<BasicBlockRef>>,\n+// These pub elements: \"hoisted basic blocks\" containing\n+// administrative activities that have to happen in only one place in\n+// the function, due to LLVM's quirks.\n+// A marker for the place where we want to insert the function's static\n+// allocas, so that LLVM will coalesce them into a single alloca call.\n+pub alloca_insert_pt: Cell<Option<ValueRef>>,\n+pub llreturn: Cell<Option<BasicBlockRef>>,\n \n-    // If the function has any nested return's, including something like:\n-    // fn foo() -> Option<Foo> { Some(Foo { x: return None }) }, then\n-    // we use a separate alloca for each return\n-    pub needs_ret_allocas: bool,\n+// If the function has any nested return's, including something like:\n+// fn foo() -> Option<Foo> { Some(Foo { x: return None }) }, then\n+// we use a separate alloca for each return\n+pub needs_ret_allocas: bool,\n \n-    // The a value alloca'd for calls to upcalls.rust_personality. Used when\n-    // outputting the resume instruction.\n-    pub personality: Cell<Option<ValueRef>>,\n+// The a value alloca'd for calls to upcalls.rust_personality. Used when\n+// outputting the resume instruction.\n+pub personality: Cell<Option<ValueRef>>,\n \n-    // True if the caller expects this fn to use the out pointer to\n-    // return. Either way, your code should write into the slot llretslotptr\n-    // points to, but if this value is false, that slot will be a local alloca.\n-    pub caller_expects_out_pointer: bool,\n+// True if the caller expects this fn to use the out pointer to\n+// return. Either way, your code should write into the slot llretslotptr\n+// points to, but if this value is false, that slot will be a local alloca.\n+pub caller_expects_out_pointer: bool,\n \n-    // Maps the DefId's for local variables to the allocas created for\n-    // them in llallocas.\n-    pub lllocals: RefCell<NodeMap<LvalueDatum<'tcx>>>,\n+// Maps the DefId's for local variables to the allocas created for\n+// them in llallocas.\n+pub lllocals: RefCell<NodeMap<LvalueDatum<'tcx>>>,\n \n-    // Same as above, but for closure upvars\n-    pub llupvars: RefCell<NodeMap<ValueRef>>,\n+// Same as above, but for closure upvars\n+pub llupvars: RefCell<NodeMap<ValueRef>>,\n \n-    // The NodeId of the function, or -1 if it doesn't correspond to\n-    // a user-defined function.\n-    pub id: ast::NodeId,\n+// The NodeId of the function, or -1 if it doesn't correspond to\n+// a user-defined function.\n+pub id: ast::NodeId,\n \n-    // If this function is being monomorphized, this contains the type\n-    // substitutions used.\n-    pub param_substs: &'a Substs<'tcx>,\n+// If this function is being monomorphized, this contains the type\n+// substitutions used.\n+pub param_substs: &'a Substs<'tcx>,\n \n-    // The source span and nesting context where this function comes from, for\n-    // error reporting and symbol generation.\n-    pub span: Option<Span>,\n+// The source span and nesting context where this function comes from, for\n+// error reporting and symbol generation.\n+pub span: Option<Span>,\n \n-    // The arena that blocks are allocated from.\n-    pub block_arena: &'a TypedArena<BlockS<'a, 'tcx>>,\n+// The arena that blocks are allocated from.\n+pub block_arena: &'a TypedArena<BlockS<'a, 'tcx>>,\n \n-    // This function's enclosing crate context.\n-    pub ccx: &'a CrateContext<'a, 'tcx>,\n+// This function's enclosing crate context.\n+pub ccx: &'a CrateContext<'a, 'tcx>,\n \n-    // Used and maintained by the debuginfo module.\n-    pub debug_context: debuginfo::FunctionDebugContext,\n+// Used and maintained by the debuginfo module.\n+pub debug_context: debuginfo::FunctionDebugContext,\n \n-    // Cleanup scopes.\n-    pub scopes: RefCell<Vec<cleanup::CleanupScope<'a, 'tcx>>>,\n+// Cleanup scopes.\n+pub scopes: RefCell<Vec<cleanup::CleanupScope<'a, 'tcx>>>,\n \n-    pub cfg: Option<cfg::CFG>,\n+pub cfg: Option<cfg::CFG>,\n }\n \n impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n-    pub fn arg_pos(&self, arg: uint) -> uint {\n-        let arg = self.env_arg_pos() + arg;\n-        if self.llenv.is_some() {\n-            arg + 1\n-        } else {\n-            arg\n-        }\n+pub fn arg_pos(&self, arg: uint) -> uint {\n+    let arg = self.env_arg_pos() + arg;\n+    if self.llenv.is_some() {\n+        arg + 1\n+    } else {\n+        arg\n     }\n+}\n \n-    pub fn env_arg_pos(&self) -> uint {\n-        if self.caller_expects_out_pointer {\n-            1u\n-        } else {\n-            0u\n-        }\n+pub fn env_arg_pos(&self) -> uint {\n+    if self.caller_expects_out_pointer {\n+        1u\n+    } else {\n+        0u\n     }\n+}\n \n-    pub fn cleanup(&self) {\n-        unsafe {\n-            llvm::LLVMInstructionEraseFromParent(self.alloca_insert_pt\n-                                                     .get()\n-                                                     .unwrap());\n-        }\n+pub fn cleanup(&self) {\n+    unsafe {\n+        llvm::LLVMInstructionEraseFromParent(self.alloca_insert_pt\n+                                                 .get()\n+                                                 .unwrap());\n     }\n+}\n \n-    pub fn get_llreturn(&self) -> BasicBlockRef {\n-        if self.llreturn.get().is_none() {\n+pub fn get_llreturn(&self) -> BasicBlockRef {\n+    if self.llreturn.get().is_none() {\n \n-            self.llreturn.set(Some(unsafe {\n-                llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(), self.llfn,\n-                                                    \"return\\0\".as_ptr() as *const _)\n-            }))\n-        }\n-\n-        self.llreturn.get().unwrap()\n+        self.llreturn.set(Some(unsafe {\n+            llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(), self.llfn,\n+                                                \"return\\0\".as_ptr() as *const _)\n+        }))\n     }\n \n-    pub fn get_ret_slot(&self, bcx: Block<'a, 'tcx>,\n-                        output: ty::FnOutput<'tcx>,\n-                        name: &str) -> ValueRef {\n-        if self.needs_ret_allocas {\n-            base::alloca_no_lifetime(bcx, match output {\n-                ty::FnConverging(output_type) => type_of::type_of(bcx.ccx(), output_type),\n-                ty::FnDiverging => Type::void(bcx.ccx())\n-            }, name)\n-        } else {\n-            self.llretslotptr.get().unwrap()\n-        }\n-    }\n+    self.llreturn.get().unwrap()\n+}\n \n-    pub fn new_block(&'a self,\n-                     is_lpad: bool,\n-                     name: &str,\n-                     opt_node_id: Option<ast::NodeId>)\n-                     -> Block<'a, 'tcx> {\n-        unsafe {\n-            let name = CString::from_slice(name.as_bytes());\n-            let llbb = llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(),\n-                                                           self.llfn,\n-                                                           name.as_ptr());\n-            BlockS::new(llbb, is_lpad, opt_node_id, self)\n-        }\n+pub fn get_ret_slot(&self, bcx: Block<'a, 'tcx>,\n+                    output: ty::FnOutput<'tcx>,\n+                    name: &str) -> ValueRef {\n+    if self.needs_ret_allocas {\n+        base::alloca_no_lifetime(bcx, match output {\n+            ty::FnConverging(output_type) => type_of::type_of(bcx.ccx(), output_type),\n+            ty::FnDiverging => Type::void(bcx.ccx())\n+        }, name)\n+    } else {\n+        self.llretslotptr.get().unwrap()\n     }\n+}\n \n-    pub fn new_id_block(&'a self,\n-                        name: &str,\n-                        node_id: ast::NodeId)\n-                        -> Block<'a, 'tcx> {\n-        self.new_block(false, name, Some(node_id))\n+pub fn new_block(&'a self,\n+                 is_lpad: bool,\n+                 name: &str,\n+                 opt_node_id: Option<ast::NodeId>)\n+                 -> Block<'a, 'tcx> {\n+    unsafe {\n+        let name = CString::from_slice(name.as_bytes());\n+        let llbb = llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(),\n+                                                       self.llfn,\n+                                                       name.as_ptr());\n+        BlockS::new(llbb, is_lpad, opt_node_id, self)\n     }\n+}\n \n-    pub fn new_temp_block(&'a self,\n-                          name: &str)\n-                          -> Block<'a, 'tcx> {\n-        self.new_block(false, name, None)\n-    }\n+pub fn new_id_block(&'a self,\n+                    name: &str,\n+                    node_id: ast::NodeId)\n+                    -> Block<'a, 'tcx> {\n+    self.new_block(false, name, Some(node_id))\n+}\n \n-    pub fn join_blocks(&'a self,\n-                       id: ast::NodeId,\n-                       in_cxs: &[Block<'a, 'tcx>])\n-                       -> Block<'a, 'tcx> {\n-        let out = self.new_id_block(\"join\", id);\n-        let mut reachable = false;\n-        for bcx in in_cxs.iter() {\n-            if !bcx.unreachable.get() {\n-                build::Br(*bcx, out.llbb);\n-                reachable = true;\n-            }\n-        }\n-        if !reachable {\n-            build::Unreachable(out);\n+pub fn new_temp_block(&'a self,\n+                      name: &str)\n+                      -> Block<'a, 'tcx> {\n+    self.new_block(false, name, None)\n+}\n+\n+pub fn join_blocks(&'a self,\n+                   id: ast::NodeId,\n+                   in_cxs: &[Block<'a, 'tcx>])\n+                   -> Block<'a, 'tcx> {\n+    let out = self.new_id_block(\"join\", id);\n+    let mut reachable = false;\n+    for bcx in in_cxs.iter() {\n+        if !bcx.unreachable.get() {\n+            build::Br(*bcx, out.llbb);\n+            reachable = true;\n         }\n-        return out;\n     }\n-\n-    pub fn monomorphize<T>(&self, value: &T) -> T\n-        where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n-    {\n-        monomorphize::apply_param_substs(self.ccx.tcx(),\n-                                         self.param_substs,\n-                                         value)\n+    if !reachable {\n+        build::Unreachable(out);\n     }\n+    return out;\n+}\n+\n+pub fn monomorphize<T>(&self, value: &T) -> T\n+    where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n+{\n+    monomorphize::apply_param_substs(self.ccx.tcx(),\n+                                     self.param_substs,\n+                                     value)\n+}\n }\n \n // Basic block context.  We create a block context for each basic block\n@@ -482,277 +482,277 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n // with many basic blocks per function.  All the basic blocks attached to a\n // function are organized as a directed graph.\n pub struct BlockS<'blk, 'tcx: 'blk> {\n-    // The BasicBlockRef returned from a call to\n-    // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic\n-    // block to the function pointed to by llfn.  We insert\n-    // instructions into that block by way of this block context.\n-    // The block pointing to this one in the function's digraph.\n-    pub llbb: BasicBlockRef,\n-    pub terminated: Cell<bool>,\n-    pub unreachable: Cell<bool>,\n+// The BasicBlockRef returned from a call to\n+// llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic\n+// block to the function pointed to by llfn.  We insert\n+// instructions into that block by way of this block context.\n+// The block pointing to this one in the function's digraph.\n+pub llbb: BasicBlockRef,\n+pub terminated: Cell<bool>,\n+pub unreachable: Cell<bool>,\n \n-    // Is this block part of a landing pad?\n-    pub is_lpad: bool,\n+// Is this block part of a landing pad?\n+pub is_lpad: bool,\n \n-    // AST node-id associated with this block, if any. Used for\n-    // debugging purposes only.\n-    pub opt_node_id: Option<ast::NodeId>,\n+// AST node-id associated with this block, if any. Used for\n+// debugging purposes only.\n+pub opt_node_id: Option<ast::NodeId>,\n \n-    // The function context for the function to which this block is\n-    // attached.\n-    pub fcx: &'blk FunctionContext<'blk, 'tcx>,\n+// The function context for the function to which this block is\n+// attached.\n+pub fcx: &'blk FunctionContext<'blk, 'tcx>,\n }\n \n pub type Block<'blk, 'tcx> = &'blk BlockS<'blk, 'tcx>;\n \n impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n-    pub fn new(llbb: BasicBlockRef,\n-               is_lpad: bool,\n-               opt_node_id: Option<ast::NodeId>,\n-               fcx: &'blk FunctionContext<'blk, 'tcx>)\n-               -> Block<'blk, 'tcx> {\n-        fcx.block_arena.alloc(BlockS {\n-            llbb: llbb,\n-            terminated: Cell::new(false),\n-            unreachable: Cell::new(false),\n-            is_lpad: is_lpad,\n-            opt_node_id: opt_node_id,\n-            fcx: fcx\n-        })\n-    }\n+pub fn new(llbb: BasicBlockRef,\n+           is_lpad: bool,\n+           opt_node_id: Option<ast::NodeId>,\n+           fcx: &'blk FunctionContext<'blk, 'tcx>)\n+           -> Block<'blk, 'tcx> {\n+    fcx.block_arena.alloc(BlockS {\n+        llbb: llbb,\n+        terminated: Cell::new(false),\n+        unreachable: Cell::new(false),\n+        is_lpad: is_lpad,\n+        opt_node_id: opt_node_id,\n+        fcx: fcx\n+    })\n+}\n \n-    pub fn ccx(&self) -> &'blk CrateContext<'blk, 'tcx> {\n-        self.fcx.ccx\n-    }\n-    pub fn tcx(&self) -> &'blk ty::ctxt<'tcx> {\n-        self.fcx.ccx.tcx()\n-    }\n-    pub fn sess(&self) -> &'blk Session { self.fcx.ccx.sess() }\n+pub fn ccx(&self) -> &'blk CrateContext<'blk, 'tcx> {\n+    self.fcx.ccx\n+}\n+pub fn tcx(&self) -> &'blk ty::ctxt<'tcx> {\n+    self.fcx.ccx.tcx()\n+}\n+pub fn sess(&self) -> &'blk Session { self.fcx.ccx.sess() }\n \n-    pub fn ident(&self, ident: Ident) -> String {\n-        token::get_ident(ident).get().to_string()\n-    }\n+pub fn ident(&self, ident: Ident) -> String {\n+    token::get_ident(ident).get().to_string()\n+}\n \n-    pub fn node_id_to_string(&self, id: ast::NodeId) -> String {\n-        self.tcx().map.node_to_string(id).to_string()\n-    }\n+pub fn node_id_to_string(&self, id: ast::NodeId) -> String {\n+    self.tcx().map.node_to_string(id).to_string()\n+}\n \n-    pub fn expr_to_string(&self, e: &ast::Expr) -> String {\n-        e.repr(self.tcx())\n-    }\n+pub fn expr_to_string(&self, e: &ast::Expr) -> String {\n+    e.repr(self.tcx())\n+}\n \n-    pub fn def(&self, nid: ast::NodeId) -> def::Def {\n-        match self.tcx().def_map.borrow().get(&nid) {\n-            Some(v) => v.clone(),\n-            None => {\n-                self.tcx().sess.bug(format!(\n-                    \"no def associated with node id {}\", nid).index(&FullRange));\n-            }\n+pub fn def(&self, nid: ast::NodeId) -> def::Def {\n+    match self.tcx().def_map.borrow().get(&nid) {\n+        Some(v) => v.clone(),\n+        None => {\n+            self.tcx().sess.bug(format!(\n+                \"no def associated with node id {}\", nid).index(&FullRange));\n         }\n     }\n+}\n \n-    pub fn val_to_string(&self, val: ValueRef) -> String {\n-        self.ccx().tn().val_to_string(val)\n-    }\n+pub fn val_to_string(&self, val: ValueRef) -> String {\n+    self.ccx().tn().val_to_string(val)\n+}\n \n-    pub fn llty_str(&self, ty: Type) -> String {\n-        self.ccx().tn().type_to_string(ty)\n-    }\n+pub fn llty_str(&self, ty: Type) -> String {\n+    self.ccx().tn().type_to_string(ty)\n+}\n \n-    pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n-        t.repr(self.tcx())\n-    }\n+pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n+    t.repr(self.tcx())\n+}\n \n-    pub fn to_str(&self) -> String {\n-        format!(\"[block {:p}]\", self)\n-    }\n+pub fn to_str(&self) -> String {\n+    format!(\"[block {:p}]\", self)\n+}\n \n-    pub fn monomorphize<T>(&self, value: &T) -> T\n-        where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n-    {\n-        monomorphize::apply_param_substs(self.tcx(),\n-                                         self.fcx.param_substs,\n-                                         value)\n-    }\n+pub fn monomorphize<T>(&self, value: &T) -> T\n+    where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n+{\n+    monomorphize::apply_param_substs(self.tcx(),\n+                                     self.fcx.param_substs,\n+                                     value)\n+}\n }\n \n impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n-        self.tcx()\n-    }\n+fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n+    self.tcx()\n+}\n \n-    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty<'tcx>> {\n-        Ok(node_id_type(self, id))\n-    }\n+fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty<'tcx>> {\n+    Ok(node_id_type(self, id))\n+}\n \n-    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> mc::McResult<Ty<'tcx>> {\n-        Ok(expr_ty_adjusted(self, expr))\n-    }\n+fn expr_ty_adjusted(&self, expr: &ast::Expr) -> mc::McResult<Ty<'tcx>> {\n+    Ok(expr_ty_adjusted(self, expr))\n+}\n \n-    fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>> {\n-        self.tcx()\n-            .method_map\n-            .borrow()\n-            .get(&method_call)\n-            .map(|method| monomorphize_type(self, method.ty))\n-    }\n+fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>> {\n+    self.tcx()\n+        .method_map\n+        .borrow()\n+        .get(&method_call)\n+        .map(|method| monomorphize_type(self, method.ty))\n+}\n \n-    fn node_method_origin(&self, method_call: ty::MethodCall)\n-                          -> Option<ty::MethodOrigin<'tcx>>\n-    {\n-        self.tcx()\n-            .method_map\n-            .borrow()\n-            .get(&method_call)\n-            .map(|method| method.origin.clone())\n-    }\n+fn node_method_origin(&self, method_call: ty::MethodCall)\n+                      -> Option<ty::MethodOrigin<'tcx>>\n+{\n+    self.tcx()\n+        .method_map\n+        .borrow()\n+        .get(&method_call)\n+        .map(|method| method.origin.clone())\n+}\n \n-    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n-        &self.tcx().adjustments\n-    }\n+fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n+    &self.tcx().adjustments\n+}\n \n-    fn is_method_call(&self, id: ast::NodeId) -> bool {\n-        self.tcx().method_map.borrow().contains_key(&ty::MethodCall::expr(id))\n-    }\n+fn is_method_call(&self, id: ast::NodeId) -> bool {\n+    self.tcx().method_map.borrow().contains_key(&ty::MethodCall::expr(id))\n+}\n \n-    fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<region::CodeExtent> {\n-        self.tcx().region_maps.temporary_scope(rvalue_id)\n-    }\n+fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<region::CodeExtent> {\n+    self.tcx().region_maps.temporary_scope(rvalue_id)\n+}\n \n-    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarBorrow> {\n-        Some(self.tcx().upvar_borrow_map.borrow()[upvar_id].clone())\n-    }\n+fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarBorrow> {\n+    Some(self.tcx().upvar_borrow_map.borrow()[upvar_id].clone())\n+}\n \n-    fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                    -> ast::CaptureClause {\n-        self.tcx().capture_modes.borrow()[closure_expr_id].clone()\n-    }\n+fn capture_mode(&self, closure_expr_id: ast::NodeId)\n+                -> ast::CaptureClause {\n+    self.tcx().capture_modes.borrow()[closure_expr_id].clone()\n+}\n \n-    fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool {\n-        self.fcx.param_env.type_moves_by_default(span, ty)\n-    }\n+fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool {\n+    self.fcx.param_env.type_moves_by_default(span, ty)\n+}\n }\n \n impl<'blk, 'tcx> ty::UnboxedClosureTyper<'tcx> for BlockS<'blk, 'tcx> {\n-    fn param_env<'a>(&'a self) -> &'a ty::ParameterEnvironment<'a, 'tcx> {\n-        &self.fcx.param_env\n-    }\n+fn param_env<'a>(&'a self) -> &'a ty::ParameterEnvironment<'a, 'tcx> {\n+    &self.fcx.param_env\n+}\n \n-    fn unboxed_closure_kind(&self,\n-                            def_id: ast::DefId)\n-                            -> ty::UnboxedClosureKind\n-    {\n-        let typer = NormalizingUnboxedClosureTyper::new(self.tcx());\n-        typer.unboxed_closure_kind(def_id)\n-    }\n+fn unboxed_closure_kind(&self,\n+                        def_id: ast::DefId)\n+                        -> ty::UnboxedClosureKind\n+{\n+    let typer = NormalizingUnboxedClosureTyper::new(self.tcx());\n+    typer.unboxed_closure_kind(def_id)\n+}\n \n-    fn unboxed_closure_type(&self,\n-                            def_id: ast::DefId,\n-                            substs: &subst::Substs<'tcx>)\n-                            -> ty::ClosureTy<'tcx>\n-    {\n-        let typer = NormalizingUnboxedClosureTyper::new(self.tcx());\n-        typer.unboxed_closure_type(def_id, substs)\n-    }\n+fn unboxed_closure_type(&self,\n+                        def_id: ast::DefId,\n+                        substs: &subst::Substs<'tcx>)\n+                        -> ty::ClosureTy<'tcx>\n+{\n+    let typer = NormalizingUnboxedClosureTyper::new(self.tcx());\n+    typer.unboxed_closure_type(def_id, substs)\n+}\n \n-    fn unboxed_closure_upvars(&self,\n-                              def_id: ast::DefId,\n-                              substs: &Substs<'tcx>)\n-                              -> Option<Vec<ty::UnboxedClosureUpvar<'tcx>>>\n-    {\n-        let typer = NormalizingUnboxedClosureTyper::new(self.tcx());\n-        typer.unboxed_closure_upvars(def_id, substs)\n-    }\n+fn unboxed_closure_upvars(&self,\n+                          def_id: ast::DefId,\n+                          substs: &Substs<'tcx>)\n+                          -> Option<Vec<ty::UnboxedClosureUpvar<'tcx>>>\n+{\n+    let typer = NormalizingUnboxedClosureTyper::new(self.tcx());\n+    typer.unboxed_closure_upvars(def_id, substs)\n+}\n }\n \n pub struct Result<'blk, 'tcx: 'blk> {\n-    pub bcx: Block<'blk, 'tcx>,\n-    pub val: ValueRef\n+pub bcx: Block<'blk, 'tcx>,\n+pub val: ValueRef\n }\n \n impl<'b, 'tcx> Result<'b, 'tcx> {\n-    pub fn new(bcx: Block<'b, 'tcx>, val: ValueRef) -> Result<'b, 'tcx> {\n-        Result {\n-            bcx: bcx,\n-            val: val,\n-        }\n+pub fn new(bcx: Block<'b, 'tcx>, val: ValueRef) -> Result<'b, 'tcx> {\n+    Result {\n+        bcx: bcx,\n+        val: val,\n     }\n }\n+}\n \n pub fn val_ty(v: ValueRef) -> Type {\n-    unsafe {\n-        Type::from_ref(llvm::LLVMTypeOf(v))\n-    }\n+unsafe {\n+    Type::from_ref(llvm::LLVMTypeOf(v))\n+}\n }\n \n // LLVM constant constructors.\n pub fn C_null(t: Type) -> ValueRef {\n-    unsafe {\n-        llvm::LLVMConstNull(t.to_ref())\n-    }\n+unsafe {\n+    llvm::LLVMConstNull(t.to_ref())\n+}\n }\n \n pub fn C_undef(t: Type) -> ValueRef {\n-    unsafe {\n-        llvm::LLVMGetUndef(t.to_ref())\n-    }\n+unsafe {\n+    llvm::LLVMGetUndef(t.to_ref())\n+}\n }\n \n pub fn C_integral(t: Type, u: u64, sign_extend: bool) -> ValueRef {\n-    unsafe {\n-        llvm::LLVMConstInt(t.to_ref(), u, sign_extend as Bool)\n-    }\n+unsafe {\n+    llvm::LLVMConstInt(t.to_ref(), u, sign_extend as Bool)\n+}\n }\n \n pub fn C_floating(s: &str, t: Type) -> ValueRef {\n-    unsafe {\n-        let s = CString::from_slice(s.as_bytes());\n-        llvm::LLVMConstRealOfString(t.to_ref(), s.as_ptr())\n-    }\n+unsafe {\n+    let s = CString::from_slice(s.as_bytes());\n+    llvm::LLVMConstRealOfString(t.to_ref(), s.as_ptr())\n+}\n }\n \n pub fn C_nil(ccx: &CrateContext) -> ValueRef {\n-    C_struct(ccx, &[], false)\n+C_struct(ccx, &[], false)\n }\n \n pub fn C_bool(ccx: &CrateContext, val: bool) -> ValueRef {\n-    C_integral(Type::i1(ccx), val as u64, false)\n+C_integral(Type::i1(ccx), val as u64, false)\n }\n \n pub fn C_i32(ccx: &CrateContext, i: i32) -> ValueRef {\n-    C_integral(Type::i32(ccx), i as u64, true)\n+C_integral(Type::i32(ccx), i as u64, true)\n }\n \n pub fn C_i64(ccx: &CrateContext, i: i64) -> ValueRef {\n-    C_integral(Type::i64(ccx), i as u64, true)\n+C_integral(Type::i64(ccx), i as u64, true)\n }\n \n pub fn C_u64(ccx: &CrateContext, i: u64) -> ValueRef {\n-    C_integral(Type::i64(ccx), i, false)\n+C_integral(Type::i64(ccx), i, false)\n }\n \n pub fn C_int<I: AsI64>(ccx: &CrateContext, i: I) -> ValueRef {\n-    let v = i.as_i64();\n+let v = i.as_i64();\n \n-    match machine::llbitsize_of_real(ccx, ccx.int_type()) {\n-        32 => assert!(v < (1<<31) && v >= -(1<<31)),\n-        64 => {},\n-        n => panic!(\"unsupported target size: {}\", n)\n-    }\n+match machine::llbitsize_of_real(ccx, ccx.int_type()) {\n+    32 => assert!(v < (1<<31) && v >= -(1<<31)),\n+    64 => {},\n+    n => panic!(\"unsupported target size: {}\", n)\n+}\n \n-    C_integral(ccx.int_type(), v as u64, true)\n+C_integral(ccx.int_type(), v as u64, true)\n }\n \n pub fn C_uint<I: AsU64>(ccx: &CrateContext, i: I) -> ValueRef {\n-    let v = i.as_u64();\n+let v = i.as_u64();\n \n-    match machine::llbitsize_of_real(ccx, ccx.int_type()) {\n-        32 => assert!(v < (1<<32)),\n-        64 => {},\n-        n => panic!(\"unsupported target size: {}\", n)\n-    }\n+match machine::llbitsize_of_real(ccx, ccx.int_type()) {\n+    32 => assert!(v < (1<<32)),\n+    64 => {},\n+    n => panic!(\"unsupported target size: {}\", n)\n+}\n \n-    C_integral(ccx.int_type(), v, false)\n+C_integral(ccx.int_type(), v, false)\n }\n \n pub trait AsI64 { fn as_i64(self) -> i64; }\n@@ -769,346 +769,346 @@ impl AsU64 for u32  { fn as_u64(self) -> u64 { self as u64 }}\n impl AsU64 for uint { fn as_u64(self) -> u64 { self as u64 }}\n \n pub fn C_u8(ccx: &CrateContext, i: uint) -> ValueRef {\n-    C_integral(Type::i8(ccx), i as u64, false)\n+C_integral(Type::i8(ccx), i as u64, false)\n }\n \n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> ValueRef {\n-    unsafe {\n-        match cx.const_cstr_cache().borrow().get(&s) {\n-            Some(&llval) => return llval,\n-            None => ()\n-        }\n+unsafe {\n+    match cx.const_cstr_cache().borrow().get(&s) {\n+        Some(&llval) => return llval,\n+        None => ()\n+    }\n \n-        let sc = llvm::LLVMConstStringInContext(cx.llcx(),\n-                                                s.get().as_ptr() as *const c_char,\n-                                                s.get().len() as c_uint,\n-                                                !null_terminated as Bool);\n+    let sc = llvm::LLVMConstStringInContext(cx.llcx(),\n+                                            s.get().as_ptr() as *const c_char,\n+                                            s.get().len() as c_uint,\n+                                            !null_terminated as Bool);\n \n-        let gsym = token::gensym(\"str\");\n-        let buf = CString::from_vec(format!(\"str{}\", gsym.uint()).into_bytes());\n-        let g = llvm::LLVMAddGlobal(cx.llmod(), val_ty(sc).to_ref(), buf.as_ptr());\n-        llvm::LLVMSetInitializer(g, sc);\n-        llvm::LLVMSetGlobalConstant(g, True);\n-        llvm::SetLinkage(g, llvm::InternalLinkage);\n+    let gsym = token::gensym(\"str\");\n+    let buf = CString::from_vec(format!(\"str{}\", gsym.uint()).into_bytes());\n+    let g = llvm::LLVMAddGlobal(cx.llmod(), val_ty(sc).to_ref(), buf.as_ptr());\n+    llvm::LLVMSetInitializer(g, sc);\n+    llvm::LLVMSetGlobalConstant(g, True);\n+    llvm::SetLinkage(g, llvm::InternalLinkage);\n \n-        cx.const_cstr_cache().borrow_mut().insert(s, g);\n-        g\n-    }\n+    cx.const_cstr_cache().borrow_mut().insert(s, g);\n+    g\n+}\n }\n \n // NB: Do not use `do_spill_noroot` to make this into a constant string, or\n // you will be kicked off fast isel. See issue #4352 for an example of this.\n pub fn C_str_slice(cx: &CrateContext, s: InternedString) -> ValueRef {\n-    let len = s.get().len();\n-    let cs = consts::ptrcast(C_cstr(cx, s, false), Type::i8p(cx));\n-    C_named_struct(cx.tn().find_type(\"str_slice\").unwrap(), &[cs, C_uint(cx, len)])\n+let len = s.get().len();\n+let cs = consts::ptrcast(C_cstr(cx, s, false), Type::i8p(cx));\n+C_named_struct(cx.tn().find_type(\"str_slice\").unwrap(), &[cs, C_uint(cx, len)])\n }\n \n pub fn C_binary_slice(cx: &CrateContext, data: &[u8]) -> ValueRef {\n-    unsafe {\n-        let len = data.len();\n-        let lldata = C_bytes(cx, data);\n-\n-        let gsym = token::gensym(\"binary\");\n-        let name = format!(\"binary{}\", gsym.uint());\n-        let name = CString::from_vec(name.into_bytes());\n-        let g = llvm::LLVMAddGlobal(cx.llmod(), val_ty(lldata).to_ref(),\n-                                    name.as_ptr());\n-        llvm::LLVMSetInitializer(g, lldata);\n-        llvm::LLVMSetGlobalConstant(g, True);\n-        llvm::SetLinkage(g, llvm::InternalLinkage);\n-\n-        let cs = consts::ptrcast(g, Type::i8p(cx));\n-        C_struct(cx, &[cs, C_uint(cx, len)], false)\n-    }\n+unsafe {\n+    let len = data.len();\n+    let lldata = C_bytes(cx, data);\n+\n+    let gsym = token::gensym(\"binary\");\n+    let name = format!(\"binary{}\", gsym.uint());\n+    let name = CString::from_vec(name.into_bytes());\n+    let g = llvm::LLVMAddGlobal(cx.llmod(), val_ty(lldata).to_ref(),\n+                                name.as_ptr());\n+    llvm::LLVMSetInitializer(g, lldata);\n+    llvm::LLVMSetGlobalConstant(g, True);\n+    llvm::SetLinkage(g, llvm::InternalLinkage);\n+\n+    let cs = consts::ptrcast(g, Type::i8p(cx));\n+    C_struct(cx, &[cs, C_uint(cx, len)], false)\n+}\n }\n \n pub fn C_struct(cx: &CrateContext, elts: &[ValueRef], packed: bool) -> ValueRef {\n-    C_struct_in_context(cx.llcx(), elts, packed)\n+C_struct_in_context(cx.llcx(), elts, packed)\n }\n \n pub fn C_struct_in_context(llcx: ContextRef, elts: &[ValueRef], packed: bool) -> ValueRef {\n-    unsafe {\n-        llvm::LLVMConstStructInContext(llcx,\n-                                       elts.as_ptr(), elts.len() as c_uint,\n-                                       packed as Bool)\n-    }\n+unsafe {\n+    llvm::LLVMConstStructInContext(llcx,\n+                                   elts.as_ptr(), elts.len() as c_uint,\n+                                   packed as Bool)\n+}\n }\n \n pub fn C_named_struct(t: Type, elts: &[ValueRef]) -> ValueRef {\n-    unsafe {\n-        llvm::LLVMConstNamedStruct(t.to_ref(), elts.as_ptr(), elts.len() as c_uint)\n-    }\n+unsafe {\n+    llvm::LLVMConstNamedStruct(t.to_ref(), elts.as_ptr(), elts.len() as c_uint)\n+}\n }\n \n pub fn C_array(ty: Type, elts: &[ValueRef]) -> ValueRef {\n-    unsafe {\n-        return llvm::LLVMConstArray(ty.to_ref(), elts.as_ptr(), elts.len() as c_uint);\n-    }\n+unsafe {\n+    return llvm::LLVMConstArray(ty.to_ref(), elts.as_ptr(), elts.len() as c_uint);\n+}\n }\n \n pub fn C_bytes(cx: &CrateContext, bytes: &[u8]) -> ValueRef {\n-    C_bytes_in_context(cx.llcx(), bytes)\n+C_bytes_in_context(cx.llcx(), bytes)\n }\n \n pub fn C_bytes_in_context(llcx: ContextRef, bytes: &[u8]) -> ValueRef {\n-    unsafe {\n-        let ptr = bytes.as_ptr() as *const c_char;\n-        return llvm::LLVMConstStringInContext(llcx, ptr, bytes.len() as c_uint, True);\n-    }\n+unsafe {\n+    let ptr = bytes.as_ptr() as *const c_char;\n+    return llvm::LLVMConstStringInContext(llcx, ptr, bytes.len() as c_uint, True);\n+}\n }\n \n pub fn const_get_elt(cx: &CrateContext, v: ValueRef, us: &[c_uint])\n-                  -> ValueRef {\n-    unsafe {\n-        let r = llvm::LLVMConstExtractValue(v, us.as_ptr(), us.len() as c_uint);\n+              -> ValueRef {\n+unsafe {\n+    let r = llvm::LLVMConstExtractValue(v, us.as_ptr(), us.len() as c_uint);\n \n-        debug!(\"const_get_elt(v={}, us={}, r={})\",\n-               cx.tn().val_to_string(v), us, cx.tn().val_to_string(r));\n+    debug!(\"const_get_elt(v={}, us={:?}, r={})\",\n+           cx.tn().val_to_string(v), us, cx.tn().val_to_string(r));\n \n-        return r;\n-    }\n+    return r;\n+}\n }\n \n pub fn is_const(v: ValueRef) -> bool {\n-    unsafe {\n-        llvm::LLVMIsConstant(v) == True\n-    }\n+unsafe {\n+    llvm::LLVMIsConstant(v) == True\n+}\n }\n \n pub fn const_to_int(v: ValueRef) -> i64 {\n-    unsafe {\n-        llvm::LLVMConstIntGetSExtValue(v)\n-    }\n+unsafe {\n+    llvm::LLVMConstIntGetSExtValue(v)\n+}\n }\n \n pub fn const_to_uint(v: ValueRef) -> u64 {\n-    unsafe {\n-        llvm::LLVMConstIntGetZExtValue(v)\n-    }\n+unsafe {\n+    llvm::LLVMConstIntGetZExtValue(v)\n+}\n }\n \n pub fn is_undef(val: ValueRef) -> bool {\n-    unsafe {\n-        llvm::LLVMIsUndef(val) != False\n-    }\n+unsafe {\n+    llvm::LLVMIsUndef(val) != False\n+}\n }\n \n #[allow(dead_code)] // potentially useful\n pub fn is_null(val: ValueRef) -> bool {\n-    unsafe {\n-        llvm::LLVMIsNull(val) != False\n-    }\n+unsafe {\n+    llvm::LLVMIsNull(val) != False\n+}\n }\n \n pub fn monomorphize_type<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, t: Ty<'tcx>) -> Ty<'tcx> {\n-    bcx.fcx.monomorphize(&t)\n+bcx.fcx.monomorphize(&t)\n }\n \n pub fn node_id_type<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, id: ast::NodeId) -> Ty<'tcx> {\n-    let tcx = bcx.tcx();\n-    let t = ty::node_id_to_type(tcx, id);\n-    monomorphize_type(bcx, t)\n+let tcx = bcx.tcx();\n+let t = ty::node_id_to_type(tcx, id);\n+monomorphize_type(bcx, t)\n }\n \n pub fn expr_ty<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, ex: &ast::Expr) -> Ty<'tcx> {\n-    node_id_type(bcx, ex.id)\n+node_id_type(bcx, ex.id)\n }\n \n pub fn expr_ty_adjusted<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, ex: &ast::Expr) -> Ty<'tcx> {\n-    monomorphize_type(bcx, ty::expr_ty_adjusted(bcx.tcx(), ex))\n+monomorphize_type(bcx, ty::expr_ty_adjusted(bcx.tcx(), ex))\n }\n \n /// Attempts to resolve an obligation. The result is a shallow vtable resolution -- meaning that we\n /// do not (necessarily) resolve all nested obligations on the impl. Note that type check should\n /// guarantee to us that all nested obligations *could be* resolved if we wanted to.\n pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                    span: Span,\n-                                    trait_ref: ty::PolyTraitRef<'tcx>)\n-                                    -> traits::Vtable<'tcx, ()>\n+                                span: Span,\n+                                trait_ref: ty::PolyTraitRef<'tcx>)\n+                                -> traits::Vtable<'tcx, ()>\n {\n-    let tcx = ccx.tcx();\n-\n-    // Remove any references to regions; this helps improve caching.\n-    let trait_ref = ty_fold::erase_regions(tcx, trait_ref);\n-\n-    // First check the cache.\n-    match ccx.trait_cache().borrow().get(&trait_ref) {\n-        Some(vtable) => {\n-            info!(\"Cache hit: {}\", trait_ref.repr(ccx.tcx()));\n-            return (*vtable).clone();\n-        }\n-        None => { }\n-    }\n-\n-    debug!(\"trans fulfill_obligation: trait_ref={}\", trait_ref.repr(ccx.tcx()));\n-\n-    ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id());\n-    let infcx = infer::new_infer_ctxt(tcx);\n-\n-    // Do the initial selection for the obligation. This yields the\n-    // shallow result we are looking for -- that is, what specific impl.\n-    let typer = NormalizingUnboxedClosureTyper::new(tcx);\n-    let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n-    let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n-                                             trait_ref.to_poly_trait_predicate());\n-    let selection = match selcx.select(&obligation) {\n-        Ok(Some(selection)) => selection,\n-        Ok(None) => {\n-            // Ambiguity can happen when monomorphizing during trans\n-            // expands to some humongo type that never occurred\n-            // statically -- this humongo type can then overflow,\n-            // leading to an ambiguous result. So report this as an\n-            // overflow bug, since I believe this is the only case\n-            // where ambiguity can result.\n-            debug!(\"Encountered ambiguity selecting `{}` during trans, \\\n-                    presuming due to overflow\",\n-                   trait_ref.repr(tcx));\n-            ccx.sess().span_fatal(\n-                span,\n-                \"reached the recursion limit during monomorphization\");\n-        }\n-        Err(e) => {\n-            tcx.sess.span_bug(\n-                span,\n-                format!(\"Encountered error `{}` selecting `{}` during trans\",\n-                        e.repr(tcx),\n-                        trait_ref.repr(tcx)).index(&FullRange))\n-        }\n-    };\n-\n-    // Currently, we use a fulfillment context to completely resolve\n-    // all nested obligations. This is because they can inform the\n-    // inference of the impl's type parameters.\n-    let mut fulfill_cx = traits::FulfillmentContext::new();\n-    let vtable = selection.map_move_nested(|predicate| {\n-        fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-    });\n-    let vtable = drain_fulfillment_cx(span, &infcx, &mut fulfill_cx, &vtable);\n-\n-    info!(\"Cache miss: {}\", trait_ref.repr(ccx.tcx()));\n-    ccx.trait_cache().borrow_mut().insert(trait_ref,\n-                                          vtable.clone());\n-\n-    vtable\n+let tcx = ccx.tcx();\n+\n+// Remove any references to regions; this helps improve caching.\n+let trait_ref = ty_fold::erase_regions(tcx, trait_ref);\n+\n+// First check the cache.\n+match ccx.trait_cache().borrow().get(&trait_ref) {\n+    Some(vtable) => {\n+        info!(\"Cache hit: {}\", trait_ref.repr(ccx.tcx()));\n+        return (*vtable).clone();\n+    }\n+    None => { }\n+}\n+\n+debug!(\"trans fulfill_obligation: trait_ref={}\", trait_ref.repr(ccx.tcx()));\n+\n+ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id());\n+let infcx = infer::new_infer_ctxt(tcx);\n+\n+// Do the initial selection for the obligation. This yields the\n+// shallow result we are looking for -- that is, what specific impl.\n+let typer = NormalizingUnboxedClosureTyper::new(tcx);\n+let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n+let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n+                                         trait_ref.to_poly_trait_predicate());\n+let selection = match selcx.select(&obligation) {\n+    Ok(Some(selection)) => selection,\n+    Ok(None) => {\n+        // Ambiguity can happen when monomorphizing during trans\n+        // expands to some humongo type that never occurred\n+        // statically -- this humongo type can then overflow,\n+        // leading to an ambiguous result. So report this as an\n+        // overflow bug, since I believe this is the only case\n+        // where ambiguity can result.\n+        debug!(\"Encountered ambiguity selecting `{}` during trans, \\\n+                presuming due to overflow\",\n+               trait_ref.repr(tcx));\n+        ccx.sess().span_fatal(\n+            span,\n+            \"reached the recursion limit during monomorphization\");\n+    }\n+    Err(e) => {\n+        tcx.sess.span_bug(\n+            span,\n+            format!(\"Encountered error `{}` selecting `{}` during trans\",\n+                    e.repr(tcx),\n+                    trait_ref.repr(tcx)).index(&FullRange))\n+    }\n+};\n+\n+// Currently, we use a fulfillment context to completely resolve\n+// all nested obligations. This is because they can inform the\n+// inference of the impl's type parameters.\n+let mut fulfill_cx = traits::FulfillmentContext::new();\n+let vtable = selection.map_move_nested(|predicate| {\n+    fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+});\n+let vtable = drain_fulfillment_cx(span, &infcx, &mut fulfill_cx, &vtable);\n+\n+info!(\"Cache miss: {}\", trait_ref.repr(ccx.tcx()));\n+ccx.trait_cache().borrow_mut().insert(trait_ref,\n+                                      vtable.clone());\n+\n+vtable\n }\n \n pub struct NormalizingUnboxedClosureTyper<'a,'tcx:'a> {\n-    param_env: ty::ParameterEnvironment<'a, 'tcx>\n+param_env: ty::ParameterEnvironment<'a, 'tcx>\n }\n \n impl<'a,'tcx> NormalizingUnboxedClosureTyper<'a,'tcx> {\n-    pub fn new(tcx: &'a ty::ctxt<'tcx>) -> NormalizingUnboxedClosureTyper<'a,'tcx> {\n-        // Parameter environment is used to give details about type parameters,\n-        // but since we are in trans, everything is fully monomorphized.\n-        NormalizingUnboxedClosureTyper { param_env: ty::empty_parameter_environment(tcx) }\n-    }\n+pub fn new(tcx: &'a ty::ctxt<'tcx>) -> NormalizingUnboxedClosureTyper<'a,'tcx> {\n+    // Parameter environment is used to give details about type parameters,\n+    // but since we are in trans, everything is fully monomorphized.\n+    NormalizingUnboxedClosureTyper { param_env: ty::empty_parameter_environment(tcx) }\n+}\n }\n \n impl<'a,'tcx> ty::UnboxedClosureTyper<'tcx> for NormalizingUnboxedClosureTyper<'a,'tcx> {\n-    fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n-        &self.param_env\n-    }\n+fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n+    &self.param_env\n+}\n \n-    fn unboxed_closure_kind(&self,\n-                            def_id: ast::DefId)\n-                            -> ty::UnboxedClosureKind\n-    {\n-        self.param_env.tcx.unboxed_closure_kind(def_id)\n-    }\n+fn unboxed_closure_kind(&self,\n+                        def_id: ast::DefId)\n+                        -> ty::UnboxedClosureKind\n+{\n+    self.param_env.tcx.unboxed_closure_kind(def_id)\n+}\n \n-    fn unboxed_closure_type(&self,\n-                            def_id: ast::DefId,\n-                            substs: &subst::Substs<'tcx>)\n-                            -> ty::ClosureTy<'tcx>\n-    {\n-        // the substitutions in `substs` are already monomorphized,\n-        // but we still must normalize associated types\n-        let closure_ty = self.param_env.tcx.unboxed_closure_type(def_id, substs);\n-        monomorphize::normalize_associated_type(self.param_env.tcx, &closure_ty)\n-    }\n+fn unboxed_closure_type(&self,\n+                        def_id: ast::DefId,\n+                        substs: &subst::Substs<'tcx>)\n+                        -> ty::ClosureTy<'tcx>\n+{\n+    // the substitutions in `substs` are already monomorphized,\n+    // but we still must normalize associated types\n+    let closure_ty = self.param_env.tcx.unboxed_closure_type(def_id, substs);\n+    monomorphize::normalize_associated_type(self.param_env.tcx, &closure_ty)\n+}\n \n-    fn unboxed_closure_upvars(&self,\n-                              def_id: ast::DefId,\n-                              substs: &Substs<'tcx>)\n-                              -> Option<Vec<ty::UnboxedClosureUpvar<'tcx>>>\n-    {\n-        // the substitutions in `substs` are already monomorphized,\n-        // but we still must normalize associated types\n-        let result = ty::unboxed_closure_upvars(&self.param_env, def_id, substs);\n-        monomorphize::normalize_associated_type(self.param_env.tcx, &result)\n-    }\n+fn unboxed_closure_upvars(&self,\n+                          def_id: ast::DefId,\n+                          substs: &Substs<'tcx>)\n+                          -> Option<Vec<ty::UnboxedClosureUpvar<'tcx>>>\n+{\n+    // the substitutions in `substs` are already monomorphized,\n+    // but we still must normalize associated types\n+    let result = ty::unboxed_closure_upvars(&self.param_env, def_id, substs);\n+    monomorphize::normalize_associated_type(self.param_env.tcx, &result)\n+}\n }\n \n pub fn drain_fulfillment_cx<'a,'tcx,T>(span: Span,\n-                                       infcx: &infer::InferCtxt<'a,'tcx>,\n-                                       fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n-                                       result: &T)\n-                                       -> T\n-    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+                                   infcx: &infer::InferCtxt<'a,'tcx>,\n+                                   fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n+                                   result: &T)\n+                                   -> T\n+where T : TypeFoldable<'tcx> + Repr<'tcx>\n {\n-    debug!(\"drain_fulfillment_cx(result={})\",\n-           result.repr(infcx.tcx));\n-\n-    // In principle, we only need to do this so long as `result`\n-    // contains unbound type parameters. It could be a slight\n-    // optimization to stop iterating early.\n-    let typer = NormalizingUnboxedClosureTyper::new(infcx.tcx);\n-    match fulfill_cx.select_all_or_error(infcx, &typer) {\n-        Ok(()) => { }\n-        Err(errors) => {\n-            if errors.iter().all(|e| e.is_overflow()) {\n-                // See Ok(None) case above.\n-                infcx.tcx.sess.span_fatal(\n-                    span,\n-                    \"reached the recursion limit during monomorphization\");\n-            } else {\n-                infcx.tcx.sess.span_bug(\n-                    span,\n-                    format!(\"Encountered errors `{}` fulfilling during trans\",\n-                            errors.repr(infcx.tcx)).index(&FullRange));\n-            }\n+debug!(\"drain_fulfillment_cx(result={})\",\n+       result.repr(infcx.tcx));\n+\n+// In principle, we only need to do this so long as `result`\n+// contains unbound type parameters. It could be a slight\n+// optimization to stop iterating early.\n+let typer = NormalizingUnboxedClosureTyper::new(infcx.tcx);\n+match fulfill_cx.select_all_or_error(infcx, &typer) {\n+    Ok(()) => { }\n+    Err(errors) => {\n+        if errors.iter().all(|e| e.is_overflow()) {\n+            // See Ok(None) case above.\n+            infcx.tcx.sess.span_fatal(\n+                span,\n+                \"reached the recursion limit during monomorphization\");\n+        } else {\n+            infcx.tcx.sess.span_bug(\n+                span,\n+                format!(\"Encountered errors `{}` fulfilling during trans\",\n+                        errors.repr(infcx.tcx)).index(&FullRange));\n         }\n     }\n+}\n \n-    // Use freshen to simultaneously replace all type variables with\n-    // their bindings and replace all regions with 'static.  This is\n-    // sort of overkill because we do not expect there to be any\n-    // unbound type variables, hence no `TyFresh` types should ever be\n-    // inserted.\n-    result.fold_with(&mut infcx.freshener())\n+// Use freshen to simultaneously replace all type variables with\n+// their bindings and replace all regions with 'static.  This is\n+// sort of overkill because we do not expect there to be any\n+// unbound type variables, hence no `TyFresh` types should ever be\n+// inserted.\n+result.fold_with(&mut infcx.freshener())\n }\n \n // Key used to lookup values supplied for type parameters in an expr.\n #[derive(Copy, PartialEq, Show)]\n pub enum ExprOrMethodCall {\n-    // Type parameters for a path like `None::<int>`\n-    ExprId(ast::NodeId),\n+// Type parameters for a path like `None::<int>`\n+ExprId(ast::NodeId),\n \n-    // Type parameters for a method call like `a.foo::<int>()`\n-    MethodCallKey(ty::MethodCall)\n+// Type parameters for a method call like `a.foo::<int>()`\n+MethodCallKey(ty::MethodCall)\n }\n \n pub fn node_id_substs<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                node: ExprOrMethodCall,\n-                                param_substs: &subst::Substs<'tcx>)\n-                                -> subst::Substs<'tcx> {\n-    let tcx = ccx.tcx();\n-\n-    let substs = match node {\n-        ExprId(id) => {\n-            ty::node_id_item_substs(tcx, id).substs\n-        }\n-        MethodCallKey(method_call) => {\n-            (*tcx.method_map.borrow())[method_call].substs.clone()\n-        }\n-    };\n+                            node: ExprOrMethodCall,\n+                            param_substs: &subst::Substs<'tcx>)\n+                            -> subst::Substs<'tcx> {\n+let tcx = ccx.tcx();\n+\n+let substs = match node {\n+    ExprId(id) => {\n+        ty::node_id_item_substs(tcx, id).substs\n+    }\n+    MethodCallKey(method_call) => {\n+        (*tcx.method_map.borrow())[method_call].substs.clone()\n+    }\n+};\n \n-    if substs.types.any(|t| ty::type_needs_infer(*t)) {\n-        tcx.sess.bug(format!(\"type parameters for node {} include inference types: {}\",\n+if substs.types.any(|t| ty::type_needs_infer(*t)) {\n+        tcx.sess.bug(format!(\"type parameters for node {:?} include inference types: {:?}\",\n                              node, substs.repr(tcx)).index(&FullRange));\n     }\n "}, {"sha": "b0474d7e011a5fcc17e8d8a3788cb4de41acdb19", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -32,7 +32,7 @@ use syntax::ptr::P;\n pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n     -> ValueRef {\n     let _icx = push_ctxt(\"trans_lit\");\n-    debug!(\"const_lit: {}\", lit);\n+    debug!(\"const_lit: {:?}\", lit);\n     match lit.node {\n         ast::LitByte(b) => C_integral(Type::uint_from_ty(cx, ast::TyU8), b as u64, false),\n         ast::LitChar(i) => C_integral(Type::char(cx), i as u64, false),\n@@ -187,7 +187,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, e: &ast::Expr)\n         None => { }\n         Some(adj) => {\n             match adj {\n-                ty::AdjustReifyFnPointer(_def_id) => {\n+               ty::AdjustReifyFnPointer(_def_id) => {\n                     // FIXME(#19925) once fn item types are\n                     // zero-sized, we'll need to do something here\n                 }\n@@ -259,7 +259,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, e: &ast::Expr)\n                                     cx.sess()\n                                       .span_bug(e.span,\n                                                 format!(\"unimplemented const \\\n-                                                         autoref {}\",\n+                                                         autoref {:?}\",\n                                                         autoref).index(&FullRange))\n                                 }\n                             }"}, {"sha": "86f0cbf79338e48b443719bc20dde361295dae56", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -436,7 +436,7 @@ pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             match bcx.tcx().def_map.borrow().get(&expr_id) {\n                 Some(&def::DefLabel(loop_id)) => loop_id,\n                 ref r => {\n-                    bcx.tcx().sess.bug(format!(\"{} in def-map for label\",\n+                    bcx.tcx().sess.bug(format!(\"{:?} in def-map for label\",\n                                                r).index(&FullRange))\n                 }\n             }"}, {"sha": "26518d4092fa3d7b2710d5b38760ba5356cf0100", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -552,7 +552,7 @@ impl<'tcx, K: KindOps + fmt::Show> Datum<'tcx, K> {\n \n     #[allow(dead_code)] // useful for debugging\n     pub fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n-        format!(\"Datum({}, {}, {})\",\n+        format!(\"Datum({}, {}, {:?})\",\n                 ccx.tn().val_to_string(self.val),\n                 ty_to_string(ccx.tcx(), self.ty),\n                 self.kind)"}, {"sha": "dd612a06bcaeb4d3196e5ae954183d513650b97d", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -473,7 +473,7 @@ impl<'tcx> TypeMap<'tcx> {\n                                                         &mut unique_type_id);\n             },\n             _ => {\n-                cx.sess().bug(format!(\"get_unique_type_id_of_type() - unexpected type: {}, {}\",\n+                cx.sess().bug(format!(\"get_unique_type_id_of_type() - unexpected type: {}, {:?}\",\n                                       ppaux::ty_to_string(cx.tcx(), type_).index(&FullRange),\n                                       type_.sty).index(&FullRange))\n             }\n@@ -798,14 +798,14 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n                                 format!(\"debuginfo::\\\n                                          create_global_var_metadata() -\n                                          Captured var-id refers to \\\n-                                         unexpected ast_item variant: {}\",\n+                                         unexpected ast_item variant: {:?}\",\n                                         var_item).index(&FullRange))\n                 }\n             }\n         },\n         _ => cx.sess().bug(format!(\"debuginfo::create_global_var_metadata() \\\n                                     - Captured var-id refers to unexpected \\\n-                                    ast_map variant: {}\",\n+                                    ast_map variant: {:?}\",\n                                    var_item).index(&FullRange))\n     };\n \n@@ -914,7 +914,7 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 format!(\n                                 \"debuginfo::create_captured_var_metadata() - \\\n                                  Captured var-id refers to unexpected \\\n-                                 ast_map variant: {}\",\n+                                 ast_map variant: {:?}\",\n                                  ast_item).index(&FullRange));\n                 }\n             }\n@@ -924,7 +924,7 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n               .span_bug(span,\n                         format!(\"debuginfo::create_captured_var_metadata() - \\\n                                  Captured var-id refers to unexpected \\\n-                                 ast_map variant: {}\",\n+                                 ast_map variant: {:?}\",\n                                 ast_item).index(&FullRange));\n         }\n     };\n@@ -1321,7 +1321,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 _ => {\n                     cx.sess()\n                       .bug(format!(\"create_function_debug_context: \\\n-                                    unexpected sort of node: {}\",\n+                                    unexpected sort of node: {:?}\",\n                                     fnitem).index(&FullRange))\n                 }\n             }\n@@ -1332,7 +1332,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             return FunctionDebugContext::FunctionWithoutDebugInfo;\n         }\n         _ => cx.sess().bug(format!(\"create_function_debug_context: \\\n-                                    unexpected sort of node: {}\",\n+                                    unexpected sort of node: {:?}\",\n                                    fnitem).index(&FullRange))\n     };\n \n@@ -1615,7 +1615,7 @@ fn compile_unit_metadata(cx: &CrateContext) -> DIDescriptor {\n         }\n     };\n \n-    debug!(\"compile_unit_metadata: {}\", compile_unit_name);\n+    debug!(\"compile_unit_metadata: {:?}\", compile_unit_name);\n     let producer = format!(\"rustc version {}\",\n                            (option_env!(\"CFG_VERSION\")).expect(\"CFG_VERSION\"));\n \n@@ -1769,7 +1769,7 @@ fn scope_metadata(fcx: &FunctionContext,\n             let node = fcx.ccx.tcx().map.get(node_id);\n \n             fcx.ccx.sess().span_bug(error_reporting_span,\n-                format!(\"debuginfo: Could not find scope info for node {}\",\n+                format!(\"debuginfo: Could not find scope info for node {:?}\",\n                         node).index(&FullRange));\n         }\n     }\n@@ -1789,7 +1789,7 @@ fn diverging_type_metadata(cx: &CrateContext) -> DIType {\n fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                  t: Ty<'tcx>) -> DIType {\n \n-    debug!(\"basic_type_metadata: {}\", t);\n+    debug!(\"basic_type_metadata: {:?}\", t);\n \n     let (name, encoding) = match t.sty {\n         ty::ty_tup(ref elements) if elements.is_empty() =>\n@@ -2931,7 +2931,7 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n     };\n \n-    debug!(\"type_metadata: {}\", t);\n+    debug!(\"type_metadata: {:?}\", t);\n \n     let sty = &t.sty;\n     let MetadataCreationResult { metadata, already_stored_in_typemap } = match *sty {\n@@ -3011,7 +3011,7 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    usage_site_span).finalize(cx)\n         }\n         _ => {\n-            cx.sess().bug(format!(\"debuginfo: unexpected type in type_metadata: {}\",\n+            cx.sess().bug(format!(\"debuginfo: unexpected type in type_metadata: {:?}\",\n                                   sty).index(&FullRange))\n         }\n     };\n@@ -4022,7 +4022,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n             Some(node) => node,\n             None => {\n                 cx.sess().bug(format!(\"debuginfo::namespace_for_item(): \\\n-                                       path too short for {}\",\n+                                       path too short for {:?}\",\n                                       def_id).index(&FullRange));\n             }\n         }"}, {"sha": "c8db661e9c6a65c29999d60843d83f45c550b94a", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -306,7 +306,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // FIXME(#19596) workaround: `|t| t` causes monomorphization recursion\n         fn identity<T>(t: T) -> T { t }\n \n-        debug!(\"unsized_info(kind={}, id={}, unadjusted_ty={})\",\n+        debug!(\"unsized_info(kind={:?}, id={}, unadjusted_ty={})\",\n                kind, id, unadjusted_ty.repr(bcx.tcx()));\n         match kind {\n             &ty::UnsizeLength(len) => C_uint(bcx.ccx(), len),\n@@ -623,7 +623,7 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n                 format!(\"trans_rvalue_datum_unadjusted reached \\\n-                         fall-through case: {}\",\n+                         fall-through case: {:?}\",\n                         expr.node).index(&FullRange));\n         }\n     }\n@@ -972,7 +972,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n                 format!(\"trans_rvalue_stmt_unadjusted reached \\\n-                         fall-through case: {}\",\n+                         fall-through case: {:?}\",\n                         expr.node).index(&FullRange));\n         }\n     }\n@@ -1177,7 +1177,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n                 format!(\"trans_rvalue_dps_unadjusted reached fall-through \\\n-                         case: {}\",\n+                         case: {:?}\",\n                         expr.node).index(&FullRange));\n         }\n     }\n@@ -1227,7 +1227,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         _ => {\n             bcx.tcx().sess.span_bug(ref_expr.span, format!(\n-                \"Non-DPS def {} referened by {}\",\n+                \"Non-DPS def {:?} referened by {}\",\n                 def, bcx.node_id_to_string(ref_expr.id)).index(&FullRange));\n         }\n     }\n@@ -1255,7 +1255,7 @@ pub fn trans_def_fn_unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n         _ => {\n             ccx.tcx().sess.span_bug(ref_expr.span, format!(\n-                    \"trans_def_fn_unadjusted invoked on: {} for {}\",\n+                    \"trans_def_fn_unadjusted invoked on: {:?} for {}\",\n                     def,\n                     ref_expr.repr(ccx.tcx())).index(&FullRange));\n         }\n@@ -1296,7 +1296,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         _ => {\n             bcx.sess().unimpl(format!(\n-                \"unsupported def type in trans_local_var: {}\",\n+                \"unsupported def type in trans_local_var: {:?}\",\n                 def).index(&FullRange));\n         }\n     }\n@@ -2042,7 +2042,7 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 cast_float => SIToFP(bcx, lldiscrim_a, ll_t_out),\n                 _ => {\n                     ccx.sess().bug(format!(\"translating unsupported cast: \\\n-                                            {} ({}) -> {} ({})\",\n+                                            {} ({:?}) -> {} ({:?})\",\n                                             t_in.repr(bcx.tcx()),\n                                             k_in,\n                                             t_out.repr(bcx.tcx()),\n@@ -2051,7 +2051,7 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         _ => ccx.sess().bug(format!(\"translating unsupported cast: \\\n-                                    {} ({}) -> {} ({})\",\n+                                    {} ({:?}) -> {} ({:?})\",\n                                     t_in.repr(bcx.tcx()),\n                                     k_in,\n                                     t_out.repr(bcx.tcx()),\n@@ -2137,7 +2137,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                           -> DatumBlock<'blk, 'tcx, Expr> {\n     let ccx = bcx.ccx();\n \n-    debug!(\"deref_once(expr={}, datum={}, method_call={})\",\n+    debug!(\"deref_once(expr={}, datum={}, method_call={:?})\",\n            expr.repr(bcx.tcx()),\n            datum.to_string(ccx),\n            method_call);\n@@ -2221,7 +2221,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n     };\n \n-    debug!(\"deref_once(expr={}, method_call={}, result={})\",\n+    debug!(\"deref_once(expr={}, method_call={:?}, result={})\",\n            expr.id, method_call, r.datum.to_string(ccx));\n \n     return r;"}, {"sha": "1dcdad302d3a83e4fd90f60550637277c369dcc7", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -135,7 +135,7 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }) => {\n             let trait_ref = ty::Binder(bcx.monomorphize(trait_ref));\n             let span = bcx.tcx().map.span(method_call.expr_id);\n-            debug!(\"method_call={} trait_ref={}\",\n+            debug!(\"method_call={:?} trait_ref={}\",\n                    method_call,\n                    trait_ref.repr(bcx.tcx()));\n             let origin = fulfill_obligation(bcx.ccx(),\n@@ -177,7 +177,7 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let _icx = push_ctxt(\"meth::trans_static_method_callee\");\n     let tcx = ccx.tcx();\n \n-    debug!(\"trans_static_method_callee(method_id={}, trait_id={}, \\\n+    debug!(\"trans_static_method_callee(method_id={:?}, trait_id={}, \\\n             expr_id={})\",\n            method_id,\n            ty::item_path_str(tcx, trait_id),\n@@ -201,7 +201,7 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     } else {\n         csearch::get_item_path(tcx, method_id).last().unwrap().name()\n     };\n-    debug!(\"trans_static_method_callee: method_id={}, expr_id={}, \\\n+    debug!(\"trans_static_method_callee: method_id={:?}, expr_id={}, \\\n             name={}\", method_id, expr_id, token::get_name(mname));\n \n     // Find the substitutions for the fn itself. This includes"}, {"sha": "e2594765f4fdaaa929286bec3529642466a168b2", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -42,7 +42,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"monomorphic_fn(\\\n             fn_id={}, \\\n             real_substs={}, \\\n-            ref_id={})\",\n+            ref_id={:?})\",\n            fn_id.repr(ccx.tcx()),\n            psubsts.repr(ccx.tcx()),\n            ref_id);\n@@ -73,7 +73,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"monomorphic_fn(\\\n             fn_id={}, \\\n             psubsts={}, \\\n-            hash_id={})\",\n+            hash_id={:?})\",\n            fn_id.repr(ccx.tcx()),\n            psubsts.repr(ccx.tcx()),\n            hash_id);\n@@ -83,7 +83,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ccx.sess(),\n         ccx.tcx().map.find(fn_id.node),\n         || {\n-            format!(\"while monomorphizing {}, couldn't find it in \\\n+            format!(\"while monomorphizing {:?}, couldn't find it in \\\n                      the item map (may have attempted to monomorphize \\\n                      an item defined in a different crate?)\",\n                     fn_id)\n@@ -249,7 +249,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     d\n                 }\n                 _ => {\n-                    ccx.sess().bug(format!(\"can't monomorphize a {}\",\n+                    ccx.sess().bug(format!(\"can't monomorphize a {:?}\",\n                                            map_node).index(&FullRange))\n                 }\n             }\n@@ -275,7 +275,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ast_map::NodeBlock(..) |\n         ast_map::NodePat(..) |\n         ast_map::NodeLocal(..) => {\n-            ccx.sess().bug(format!(\"can't monomorphize a {}\",\n+            ccx.sess().bug(format!(\"can't monomorphize a {:?}\",\n                                    map_node).index(&FullRange))\n         }\n     };"}, {"sha": "40cf11783adfa6a5f4c3387fae79ed86c7008808", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -277,7 +277,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n         None => ()\n     }\n \n-    debug!(\"type_of {} {}\", t.repr(cx.tcx()), t.sty);\n+    debug!(\"type_of {} {:?}\", t.repr(cx.tcx()), t.sty);\n \n     // Replace any typedef'd types with their equivalent non-typedef\n     // type. This ensures that all LLVM nominal types that contain\n@@ -288,7 +288,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n \n     if t != t_norm {\n         let llty = type_of(cx, t_norm);\n-        debug!(\"--> normalized {} {} to {} {} llty={}\",\n+        debug!(\"--> normalized {} {:?} to {} {:?} llty={}\",\n                 t.repr(cx.tcx()),\n                 t,\n                 t_norm.repr(cx.tcx()),\n@@ -407,7 +407,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n       ty::ty_err(..) => cx.sess().bug(\"type_of with ty_err\"),\n     };\n \n-    debug!(\"--> mapped t={} {} to llty={}\",\n+    debug!(\"--> mapped t={} {:?} to llty={}\",\n             t.repr(cx.tcx()),\n             t,\n             cx.tn().type_to_string(llty));\n@@ -457,7 +457,7 @@ pub fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let tstr = if strings.is_empty() {\n         base\n     } else {\n-        format!(\"{}<{}>\", base, strings)\n+        format!(\"{}<{:?}>\", base, strings)\n     };\n \n     if did.krate == 0 {"}, {"sha": "265ebe00d539fe807441720b88f748f1b030a0c1", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -571,7 +571,7 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n     mut projections: Option<&mut Vec<ty::ProjectionPredicate<'tcx>>>)\n     -> Rc<ty::TraitRef<'tcx>>\n {\n-    debug!(\"ast_path_to_trait_ref {}\", path);\n+    debug!(\"ast_path_to_trait_ref {:?}\", path);\n     let trait_def = this.get_trait_def(trait_def_id);\n \n     // the trait reference introduces a binding level here, so\n@@ -1185,7 +1185,7 @@ pub fn ast_ty_to_ty<'tcx>(\n                     _ => {\n                         tcx.sess.span_fatal(ast_ty.span,\n                                             format!(\"found value name used \\\n-                                                     as a type: {}\",\n+                                                     as a type: {:?}\",\n                                                     a_def).index(&FullRange));\n                     }\n                 }\n@@ -1631,7 +1631,7 @@ fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                   builtin_bounds: ty::BuiltinBounds)\n                                   -> Option<ty::Region>\n {\n-    debug!(\"compute_opt_region_bound(explicit_region_bounds={}, \\\n+    debug!(\"compute_opt_region_bound(explicit_region_bounds={:?}, \\\n            principal_trait_ref={}, builtin_bounds={})\",\n            explicit_region_bounds,\n            principal_trait_ref.repr(tcx),"}, {"sha": "0079115756993771f4a5cb7b26f1db59b1779f23", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -82,7 +82,7 @@ fn check_unboxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                                   expected_sig: Option<ty::FnSig<'tcx>>) {\n     let expr_def_id = ast_util::local_def(expr.id);\n \n-    debug!(\"check_unboxed_closure kind={} expected_sig={}\",\n+    debug!(\"check_unboxed_closure kind={:?} expected_sig={}\",\n            kind,\n            expected_sig.repr(fcx.tcx()));\n \n@@ -134,7 +134,7 @@ fn check_unboxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     // the `unboxed_closures` table.\n     fn_ty.sig.0.inputs = vec![ty::mk_tup(fcx.tcx(), fn_ty.sig.0.inputs)];\n \n-    debug!(\"unboxed_closure for {} --> sig={} kind={}\",\n+    debug!(\"unboxed_closure for {} --> sig={} kind={:?}\",\n            expr_def_id.repr(fcx.tcx()),\n            fn_ty.sig.repr(fcx.tcx()),\n            kind);\n@@ -186,7 +186,7 @@ fn deduce_unboxed_closure_expectations_from_trait_ref<'a,'tcx>(\n         None => { return None; }\n     };\n \n-    debug!(\"found object type {}\", kind);\n+    debug!(\"found object type {:?}\", kind);\n \n     let arg_param_ty = *trait_ref.substs().types.get(subst::TypeSpace, 0);\n     let arg_param_ty = fcx.infcx().resolve_type_vars_if_possible(&arg_param_ty);"}, {"sha": "2471bc85bc9380df50fd30c1d5a27b5bd2ea60f2", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -200,7 +200,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         match pick.kind {\n             probe::InherentImplPick(impl_def_id) => {\n                 assert!(ty::impl_trait_ref(self.tcx(), impl_def_id).is_none(),\n-                        \"impl {} is not an inherent impl\", impl_def_id);\n+                        \"impl {:?} is not an inherent impl\", impl_def_id);\n                 let impl_polytype = check::impl_self_ty(self.fcx, self.span, impl_def_id);\n \n                 (impl_polytype.substs, MethodStatic(pick.method_ty.def_id))"}, {"sha": "87ea082b6b20b5b1a8a615977afb6edfe716c7bd", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -231,7 +231,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n \n         Some(self_expr) => {\n             debug!(\"lookup_in_trait_adjusted: inserting adjustment if needed \\\n-                   (self-id={}, base adjustment={}, explicit_self={})\",\n+                   (self-id={}, base adjustment={:?}, explicit_self={:?})\",\n                    self_expr.id, autoderefref, method_ty.explicit_self);\n \n             match method_ty.explicit_self {\n@@ -275,7 +275,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                     fcx.tcx().sess.span_bug(\n                         span,\n                         format!(\n-                            \"unexpected explicit self type in operator method: {}\",\n+                            \"unexpected explicit self type in operator method: {:?}\",\n                             method_ty.explicit_self).index(&FullRange));\n                 }\n             }"}, {"sha": "4ba161fa83563af1d670b32f62878de083087a76", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -267,7 +267,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             return; // already visited\n         }\n \n-        debug!(\"assemble_inherent_impl_probe {}\", impl_def_id);\n+        debug!(\"assemble_inherent_impl_probe {:?}\", impl_def_id);\n \n         let method = match impl_method(self.tcx(), impl_def_id, self.method_name) {\n             Some(m) => m,\n@@ -1024,7 +1024,7 @@ fn trait_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                       -> Option<(uint, Rc<ty::Method<'tcx>>)>\n {\n     let trait_items = ty::trait_items(tcx, trait_def_id);\n-    debug!(\"trait_method; items: {}\", trait_items);\n+    debug!(\"trait_method; items: {:?}\", trait_items);\n     trait_items\n         .iter()\n         .filter(|item|\n@@ -1126,27 +1126,27 @@ impl<'tcx> Repr<'tcx> for CandidateKind<'tcx> {\n \n impl<'tcx> Repr<'tcx> for CandidateStep<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"CandidateStep({},{})\",\n+        format!(\"CandidateStep({},{:?})\",\n                 self.self_ty.repr(tcx),\n                 self.adjustment)\n     }\n }\n \n impl<'tcx> Repr<'tcx> for PickAdjustment {\n     fn repr(&self, _tcx: &ty::ctxt) -> String {\n-        format!(\"{}\", self)\n+        format!(\"{:?}\", self)\n     }\n }\n \n impl<'tcx> Repr<'tcx> for PickKind<'tcx> {\n     fn repr(&self, _tcx: &ty::ctxt) -> String {\n-        format!(\"{}\", self)\n+        format!(\"{:?}\", self)\n     }\n }\n \n impl<'tcx> Repr<'tcx> for Pick<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"Pick(method_ty={}, adjustment={}, kind={})\",\n+        format!(\"Pick(method_ty={}, adjustment={:?}, kind={:?})\",\n                 self.method_ty.repr(tcx),\n                 self.adjustment,\n                 self.kind)"}, {"sha": "c60851b92283f65f8aedea9f87d6c01002b72dd4", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -1690,7 +1690,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn tag(&self) -> String {\n-        format!(\"{}\", self as *const FnCtxt)\n+        format!(\"{:?}\", self as *const FnCtxt)\n     }\n \n     pub fn local_ty(&self, span: Span, nid: ast::NodeId) -> Ty<'tcx> {\n@@ -1886,7 +1886,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn register_unsize_obligations(&self,\n                                    span: Span,\n                                    unsize: &ty::UnsizeKind<'tcx>) {\n-        debug!(\"register_unsize_obligations: unsize={}\", unsize);\n+        debug!(\"register_unsize_obligations: unsize={:?}\", unsize);\n \n         match *unsize {\n             ty::UnsizeLength(..) => {}\n@@ -2392,7 +2392,7 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                             -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)>\n {\n     let tcx = fcx.tcx();\n-    debug!(\"try_index_step(expr={}, base_expr.id={}, adjusted_ty={}, adjustment={}, index_ty={})\",\n+    debug!(\"try_index_step(expr={}, base_expr.id={}, adjusted_ty={}, adjustment={:?}, index_ty={})\",\n            expr.repr(tcx),\n            base_expr.repr(tcx),\n            adjusted_ty.repr(tcx),\n@@ -2651,7 +2651,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         err_args(fcx.tcx(), supplied_arg_count)\n     };\n \n-    debug!(\"check_argument_types: formal_tys={}\",\n+    debug!(\"check_argument_types: formal_tys={:?}\",\n            formal_tys.iter().map(|t| fcx.infcx().ty_to_string(*t)).collect::<Vec<String>>());\n \n     // Check the arguments.\n@@ -3101,7 +3101,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     }\n                 };\n \n-                debug!(\"adjusted_ty={} adjustment={}\",\n+                debug!(\"adjusted_ty={} adjustment={:?}\",\n                        adj_ty.repr(fcx.tcx()),\n                        adjustment);\n \n@@ -5052,7 +5052,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n     assert_eq!(segment_spaces.len(), path.segments.len());\n \n-    debug!(\"segment_spaces={}\", segment_spaces);\n+    debug!(\"segment_spaces={:?}\", segment_spaces);\n \n     // Next, examine the definition, and determine how many type\n     // parameters we expect from each space.\n@@ -5276,7 +5276,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                               .take_while(|d| d.default.is_none())\n                               .count();\n \n-        debug!(\"adjust_type_parameters(space={}, \\\n+        debug!(\"adjust_type_parameters(space={:?}, \\\n                provided_len={}, \\\n                desired_len={}, \\\n                required_len={})\","}, {"sha": "7974e99c5211ec0b95a690e01e995495c76e22e0", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -188,7 +188,7 @@ fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n             }\n         }\n         _ => {\n-            tcx.sess.bug(format!(\"unexpected def in region_of_def: {}\",\n+            tcx.sess.bug(format!(\"unexpected def in region_of_def: {:?}\",\n                                  def).index(&FullRange))\n         }\n     }\n@@ -484,7 +484,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n \n     // Check any autoderefs or autorefs that appear.\n     for &adjustment in rcx.fcx.inh.adjustments.borrow().get(&expr.id).iter() {\n-        debug!(\"adjustment={}\", adjustment);\n+        debug!(\"adjustment={:?}\", adjustment);\n         match *adjustment {\n             ty::AdjustDerefRef(ty::AutoDerefRef {autoderefs, autoref: ref opt_autoref}) => {\n                 let expr_ty = rcx.resolve_node_type(expr.id);\n@@ -828,7 +828,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n         debug!(\"constrain_free_variables({}, {})\",\n                region_bound.repr(tcx), expr.repr(tcx));\n         for freevar in freevars.iter() {\n-            debug!(\"freevar def is {}\", freevar.def);\n+            debug!(\"freevar def is {:?}\", freevar.def);\n \n             // Identify the variable being closed over and its node-id.\n             let def = freevar.def;\n@@ -1038,7 +1038,7 @@ fn type_of_node_must_outlive<'a, 'tcx>(\n                            rcx.fcx.inh.adjustments.borrow().get(&id),\n                            |method_call| rcx.resolve_method_type(method_call));\n     debug!(\"constrain_regions_in_type_of_node(\\\n-            ty={}, ty0={}, id={}, minimum_lifetime={})\",\n+            ty={}, ty0={}, id={}, minimum_lifetime={:?})\",\n            ty_to_string(tcx, ty), ty_to_string(tcx, ty0),\n            id, minimum_lifetime);\n     type_must_outlive(rcx, origin, ty, minimum_lifetime);\n@@ -1090,7 +1090,7 @@ fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n /// then ensures that the lifetime of the resulting pointer is\n /// linked to the lifetime of its guarantor (if any).\n fn link_fn_args(rcx: &Rcx, body_scope: CodeExtent, args: &[ast::Arg]) {\n-    debug!(\"regionck::link_fn_args(body_scope={})\", body_scope);\n+    debug!(\"regionck::link_fn_args(body_scope={:?})\", body_scope);\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n     for arg in args.iter() {\n         let arg_ty = rcx.fcx.node_ty(arg.id);\n@@ -1144,7 +1144,7 @@ fn link_autoref(rcx: &Rcx,\n                 autoderefs: uint,\n                 autoref: &ty::AutoRef) {\n \n-    debug!(\"link_autoref(autoref={})\", autoref);\n+    debug!(\"link_autoref(autoref={:?})\", autoref);\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n     let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n     debug!(\"expr_cmt={}\", expr_cmt.repr(rcx.tcx()));\n@@ -1165,7 +1165,7 @@ fn link_by_ref(rcx: &Rcx,\n                expr: &ast::Expr,\n                callee_scope: CodeExtent) {\n     let tcx = rcx.tcx();\n-    debug!(\"link_by_ref(expr={}, callee_scope={})\",\n+    debug!(\"link_by_ref(expr={}, callee_scope={:?})\",\n            expr.repr(tcx), callee_scope);\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n     let expr_cmt = ignore_err!(mc.cat_expr(expr));"}, {"sha": "ec44d765a8e683d5de02b7072414b8781428c75a", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -134,7 +134,7 @@ impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n                         let var_node_id = freevar.def.local_node_id();\n                         let upvar_id = ty::UpvarId { var_id: var_node_id,\n                                                      closure_expr_id: expr.id };\n-                        debug!(\"seed upvar_id {}\", upvar_id);\n+                        debug!(\"seed upvar_id {:?}\", upvar_id);\n                         let origin = UpvarRegion(upvar_id, expr.span);\n                         let freevar_region = self.infcx().next_region_var(origin);\n                         let upvar_borrow = ty::UpvarBorrow { kind: ty::ImmBorrow,\n@@ -269,7 +269,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx>{\n                                 upvar_id: ty::UpvarId,\n                                 upvar_borrow: &mut ty::UpvarBorrow,\n                                 kind: ty::BorrowKind) {\n-        debug!(\"adjust_upvar_borrow_kind: id={} kind=({} -> {})\",\n+        debug!(\"adjust_upvar_borrow_kind: id={:?} kind=({:?} -> {:?})\",\n                upvar_id, upvar_borrow.kind, kind);\n \n         match (upvar_borrow.kind, kind) {\n@@ -337,7 +337,7 @@ impl<'a,'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a,'tcx> {\n               bk: ty::BorrowKind,\n               _loan_cause: euv::LoanCause)\n     {\n-        debug!(\"borrow(borrow_id={}, cmt={}, bk={})\",\n+        debug!(\"borrow(borrow_id={}, cmt={}, bk={:?})\",\n                borrow_id, cmt.repr(self.tcx()), bk);\n \n         match bk {"}, {"sha": "82da22eab98373c137a107e4881c89193f02b56b", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -287,7 +287,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                         })\n                     }\n                 };\n-                debug!(\"Adjustments for node {}: {}\", id, resolved_adjustment);\n+                debug!(\"Adjustments for node {}: {:?}\", id, resolved_adjustment);\n                 self.tcx().adjustments.borrow_mut().insert(\n                     id, resolved_adjustment);\n             }\n@@ -300,7 +300,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         // Resolve any method map entry\n         match self.fcx.inh.method_map.borrow_mut().remove(&method_call) {\n             Some(method) => {\n-                debug!(\"writeback::resolve_method_map_entry(call={}, entry={})\",\n+                debug!(\"writeback::resolve_method_map_entry(call={:?}, entry={})\",\n                        method_call,\n                        method.repr(self.tcx()));\n                 let new_method = MethodCallee {"}, {"sha": "a0f30788bbddcc72cba8f5129641a427fa4db5ef", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -204,7 +204,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             trait_ref: &ty::TraitRef<'tcx>,\n             all_impl_items: &mut Vec<ImplOrTraitItemId>) {\n         let tcx = self.crate_context.tcx;\n-        debug!(\"instantiate_default_methods(impl_id={}, trait_ref={})\",\n+        debug!(\"instantiate_default_methods(impl_id={:?}, trait_ref={})\",\n                impl_id, trait_ref.repr(tcx));\n \n         let impl_type_scheme = ty::lookup_item_type(tcx, impl_id);\n@@ -215,7 +215,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             let new_id = tcx.sess.next_node_id();\n             let new_did = local_def(new_id);\n \n-            debug!(\"new_did={} trait_method={}\", new_did, trait_method.repr(tcx));\n+            debug!(\"new_did={:?} trait_method={}\", new_did, trait_method.repr(tcx));\n \n             // Create substitutions for the various trait parameters.\n             let new_method_ty =\n@@ -268,7 +268,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     }\n \n     fn add_trait_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n-        debug!(\"add_trait_impl: base_def_id={} impl_def_id={}\",\n+        debug!(\"add_trait_impl: base_def_id={:?} impl_def_id={:?}\",\n                base_def_id, impl_def_id);\n         ty::record_trait_implementation(self.crate_context.tcx,\n                                         base_def_id,"}, {"sha": "7c13696118aedfa991698228a3dbe18d2ff8f6b8", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -169,8 +169,8 @@ impl<'a, 'tcx> AstConv<'tcx> for CollectCtxt<'a, 'tcx> {\n             }\n             x => {\n                 self.tcx.sess.bug(format!(\"unexpected sort of node \\\n-                                           in get_item_type_scheme(): {}\",\n-                                          x).as_slice());\n+                                           in get_item_type_scheme(): {:?}\",\n+                                          x)[]);\n             }\n         }\n     }\n@@ -475,7 +475,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CollectCtxt<'a, 'tcx>,\n \n         write_ty_to_tcx(tcx, m.id, fty);\n \n-        debug!(\"writing method type: def_id={} mty={}\",\n+        debug!(\"writing method type: def_id={:?} mty={}\",\n                mty.def_id, mty.repr(ccx.tcx));\n \n         tcx.impl_or_trait_items\n@@ -840,7 +840,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n         ref s => {\n             tcx.sess.span_bug(\n                 it.span,\n-                format!(\"trait_def_of_item invoked on {}\", s).index(&FullRange));\n+                format!(\"trait_def_of_item invoked on {:?}\", s).index(&FullRange));\n         }\n     };\n \n@@ -1201,7 +1201,7 @@ fn ty_generics<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                                            index: i as u32,\n                                            def_id: local_def(l.lifetime.id),\n                                            bounds: bounds };\n-        debug!(\"ty_generics: def for region param: {}\", def);\n+        debug!(\"ty_generics: def for region param: {:?}\", def);\n         result.regions.push(space, def);\n     }\n \n@@ -1213,7 +1213,7 @@ fn ty_generics<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                                                    space,\n                                                    param,\n                                                    i as u32);\n-        debug!(\"ty_generics: def for type param: {}, {}\",\n+        debug!(\"ty_generics: def for type param: {}, {:?}\",\n                def.repr(ccx.tcx),\n                space);\n         result.types.push(space, def);"}, {"sha": "14243b8e773b2850776160228dd8ac17f7c63a32", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -243,8 +243,8 @@ enum VarianceTerm<'a> {\n impl<'a> fmt::Show for VarianceTerm<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            ConstantTerm(c1) => write!(f, \"{}\", c1),\n-            TransformTerm(v1, v2) => write!(f, \"({} \\u{00D7} {})\", v1, v2),\n+            ConstantTerm(c1) => write!(f, \"{:?}\", c1),\n+            TransformTerm(v1, v2) => write!(f, \"({:?} \\u{00D7} {:?})\", v1, v2),\n             InferredTerm(id) => write!(f, \"[{}]\", { let InferredIndex(i) = id; i })\n         }\n     }\n@@ -323,10 +323,10 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n         assert!(newly_added);\n \n         debug!(\"add_inferred(item_id={}, \\\n-                kind={}, \\\n+                kind={:?}, \\\n                 index={}, \\\n                 param_id={},\n-                inf_index={})\",\n+                inf_index={:?})\",\n                 item_id, kind, index, param_id, inf_index);\n     }\n \n@@ -673,8 +673,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     fn add_constraint(&mut self,\n                       InferredIndex(index): InferredIndex,\n                       variance: VarianceTermPtr<'a>) {\n-        debug!(\"add_constraint(index={}, variance={})\",\n-                index, variance.to_string());\n+        debug!(\"add_constraint(index={}, variance={:?})\",\n+                index, variance);\n         self.constraints.push(Constraint { inferred: InferredIndex(index),\n                                            variance: variance });\n     }\n@@ -854,7 +854,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                    region_param_defs: &[ty::RegionParameterDef],\n                                    substs: &subst::Substs<'tcx>,\n                                    variance: VarianceTermPtr<'a>) {\n-        debug!(\"add_constraints_from_substs(def_id={})\", def_id);\n+        debug!(\"add_constraints_from_substs(def_id={:?})\", def_id);\n \n         for p in type_param_defs.iter() {\n             let variance_decl =\n@@ -988,14 +988,14 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                 let new_value = glb(variance, old_value);\n                 if old_value != new_value {\n                     debug!(\"Updating inferred {} (node {}) \\\n-                            from {} to {} due to {}\",\n+                            from {:?} to {:?} due to {:?}\",\n                             inferred,\n                             self.terms_cx\n                                 .inferred_infos[inferred]\n                                 .param_id,\n                             old_value,\n                             new_value,\n-                            term.to_string());\n+                            term);\n \n                     self.solutions[inferred] = new_value;\n                     changed = true;\n@@ -1028,7 +1028,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                   inferred_infos[index].item_id == item_id {\n                 let info = &inferred_infos[index];\n                 let variance = solutions[index];\n-                debug!(\"Index {} Info {} / {} / {} Variance {}\",\n+                debug!(\"Index {} Info {} / {:?} / {:?} Variance {:?}\",\n                        index, info.index, info.kind, info.space, variance);\n                 match info.kind {\n                     TypeParam => {"}, {"sha": "3e2474468adb696c8edc83717f67794a538c0973", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -397,9 +397,9 @@ fn build_const(cx: &DocContext, tcx: &ty::ctxt,\n     use syntax::print::pprust;\n \n     let expr = const_eval::lookup_const_by_id(tcx, did).unwrap_or_else(|| {\n-        panic!(\"expected lookup_const_by_id to succeed for {}\", did);\n+        panic!(\"expected lookup_const_by_id to succeed for {:?}\", did);\n     });\n-    debug!(\"converting constant expr {} to snippet\", expr);\n+    debug!(\"converting constant expr {:?} to snippet\", expr);\n     let sn = pprust::expr_to_string(expr);\n     debug!(\"got snippet {}\", sn);\n "}, {"sha": "bf2664bba6ad3b973442ccb637bf4b905c5506da", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -397,7 +397,7 @@ impl Clean<Item> for doctree::Module {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n pub enum Attribute {\n     Word(String),\n     List(String, Vec<Attribute> ),\n@@ -450,7 +450,7 @@ impl<'a> attr::AttrMetaMethods for &'a Attribute {\n     fn meta_item_list(&self) -> Option<&[P<ast::MetaItem>]> { None }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n pub struct TyParam {\n     pub name: String,\n     pub did: ast::DefId,\n@@ -483,7 +483,7 @@ impl<'tcx> Clean<TyParam> for ty::TypeParameterDef<'tcx> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n pub enum TyParamBound {\n     RegionBound(Lifetime),\n     TraitBound(PolyTrait, ast::TraitBoundModifier)\n@@ -621,7 +621,7 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n         cx.external_paths.borrow_mut().as_mut().unwrap().insert(self.def_id,\n                                                             (fqn, TypeTrait));\n \n-        debug!(\"ty::TraitRef\\n  substs.types(TypeSpace): {}\\n\",\n+        debug!(\"ty::TraitRef\\n  substs.types(TypeSpace): {:?}\\n\",\n                self.substs.types.get_slice(ParamSpace::TypeSpace));\n \n         // collect any late bound regions\n@@ -632,7 +632,7 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n                 for &ty_s in ts.iter() {\n                     if let sty::ty_rptr(ref reg, _) = ty_s.sty {\n                         if let &Region::ReLateBound(_, _) = *reg {\n-                            debug!(\"  hit an ReLateBound {}\", reg);\n+                            debug!(\"  hit an ReLateBound {:?}\", reg);\n                             if let Some(lt) = reg.clean(cx) {\n                                 late_bounds.push(lt)\n                             }\n@@ -674,7 +674,7 @@ impl<'tcx> Clean<Option<Vec<TyParamBound>>> for subst::Substs<'tcx> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n pub struct Lifetime(String);\n \n impl Lifetime {\n@@ -724,7 +724,7 @@ impl Clean<Option<Lifetime>> for ty::Region {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n pub enum WherePredicate {\n     BoundPredicate { ty: Type, bounds: Vec<TyParamBound> },\n     RegionPredicate { lifetime: Lifetime, bounds: Vec<Lifetime>},\n@@ -757,7 +757,7 @@ impl Clean<WherePredicate> for ast::WherePredicate {\n }\n \n // maybe use a Generic enum and use ~[Generic]?\n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n pub struct Generics {\n     pub lifetimes: Vec<Lifetime>,\n     pub type_params: Vec<TyParam>,\n@@ -908,7 +908,7 @@ impl Clean<Item> for doctree::Function {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n pub struct ClosureDecl {\n     pub lifetimes: Vec<Lifetime>,\n     pub decl: FnDecl,\n@@ -929,14 +929,14 @@ impl Clean<ClosureDecl> for ast::ClosureTy {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n pub struct FnDecl {\n     pub inputs: Arguments,\n     pub output: FunctionRetTy,\n     pub attrs: Vec<Attribute>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n pub struct Arguments {\n     pub values: Vec<Argument>,\n }\n@@ -989,7 +989,7 @@ impl<'a, 'tcx> Clean<FnDecl> for (ast::DefId, &'a ty::PolyFnSig<'tcx>) {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n pub struct Argument {\n     pub type_: Type,\n     pub name: String,\n@@ -1006,7 +1006,7 @@ impl Clean<Argument> for ast::Arg {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n pub enum FunctionRetTy {\n     Return(Type),\n     NoReturn\n@@ -1181,7 +1181,7 @@ impl<'tcx> Clean<Item> for ty::ImplOrTraitItem<'tcx> {\n }\n \n /// A trait reference, which may have higher ranked lifetimes.\n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n pub struct PolyTrait {\n     pub trait_: Type,\n     pub lifetimes: Vec<Lifetime>\n@@ -1190,7 +1190,7 @@ pub struct PolyTrait {\n /// A representation of a Type suitable for hyperlinking purposes. Ideally one can get the original\n /// type out of the AST/ty::ctxt given one of these, if more information is needed. Most importantly\n /// it does not preserve mutability or boxes.\n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n pub enum Type {\n     /// structs/enums/traits (anything that'd be an ast::TyPath)\n     ResolvedPath {\n@@ -1236,7 +1236,7 @@ pub enum Type {\n     PolyTraitRef(Vec<TyParamBound>),\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Copy, Show)]\n pub enum PrimitiveType {\n     Isize, I8, I16, I32, I64,\n     Usize, U8, U16, U32, U64,\n@@ -1376,7 +1376,7 @@ impl Clean<Type> for ast::Ty {\n                 Infer\n             },\n             TyTypeof(..) => {\n-                panic!(\"Unimplemented type {}\", self.node)\n+                panic!(\"Unimplemented type {:?}\", self.node)\n             },\n         }\n     }\n@@ -1746,7 +1746,7 @@ impl Clean<Span> for syntax::codemap::Span {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n pub struct Path {\n     pub global: bool,\n     pub segments: Vec<PathSegment>,\n@@ -1761,7 +1761,7 @@ impl Clean<Path> for ast::Path {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n pub enum PathParameters {\n     AngleBracketed {\n         lifetimes: Vec<Lifetime>,\n@@ -1793,7 +1793,7 @@ impl Clean<PathParameters> for ast::PathParameters {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n pub struct PathSegment {\n     pub name: String,\n     pub params: PathParameters\n@@ -1857,7 +1857,7 @@ impl Clean<Item> for doctree::Typedef {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n pub struct BareFunctionDecl {\n     pub unsafety: ast::Unsafety,\n     pub generics: Generics,\n@@ -1892,7 +1892,7 @@ pub struct Static {\n \n impl Clean<Item> for doctree::Static {\n     fn clean(&self, cx: &DocContext) -> Item {\n-        debug!(\"claning static {}: {}\", self.name.clean(cx), self);\n+        debug!(\"cleaning static {}: {:?}\", self.name.clean(cx), self);\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -2170,7 +2170,7 @@ trait ToSource {\n \n impl ToSource for syntax::codemap::Span {\n     fn to_src(&self, cx: &DocContext) -> String {\n-        debug!(\"converting span {} to snippet\", self.clean(cx));\n+        debug!(\"converting span {:?} to snippet\", self.clean(cx));\n         let sn = match cx.sess().codemap().span_to_snippet(*self) {\n             Some(x) => x.to_string(),\n             None    => \"\".to_string()\n@@ -2183,7 +2183,7 @@ impl ToSource for syntax::codemap::Span {\n fn lit_to_string(lit: &ast::Lit) -> String {\n     match lit.node {\n         ast::LitStr(ref st, _) => st.get().to_string(),\n-        ast::LitBinary(ref data) => format!(\"{}\", data),\n+        ast::LitBinary(ref data) => format!(\"{:?}\", data),\n         ast::LitByte(b) => {\n             let mut res = String::from_str(\"b'\");\n             for c in (b as char).escape_default() {\n@@ -2202,7 +2202,7 @@ fn lit_to_string(lit: &ast::Lit) -> String {\n \n fn name_from_pat(p: &ast::Pat) -> String {\n     use syntax::ast::*;\n-    debug!(\"Trying to get a name from pattern: {}\", p);\n+    debug!(\"Trying to get a name from pattern: {:?}\", p);\n \n     match p.node {\n         PatWild(PatWildSingle) => \"_\".to_string(),"}, {"sha": "46c212a9f2dbcc4dab77ec64754ce8abf4d07925", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -136,7 +136,7 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n         inlined: RefCell::new(Some(HashSet::new())),\n         populated_crate_impls: RefCell::new(HashSet::new()),\n     };\n-    debug!(\"crate: {}\", ctxt.krate);\n+    debug!(\"crate: {:?}\", ctxt.krate);\n \n     let analysis = CrateAnalysis {\n         exported_items: exported_items,"}, {"sha": "99cd467cdfccca508e9921b68c35d7a8828f66ba", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -19,7 +19,15 @@ use std::fmt;\n /// string when passed to a format string.\n pub struct Escape<'a>(pub &'a str);\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl<'a> fmt::Show for Escape<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl<'a> fmt::String for Escape<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         // Because the internet is always right, turns out there's not that many\n         // characters to escape: http://stackoverflow.com/questions/7381974"}, {"sha": "b24e7a7a4cf81a06d6fb25572293a787c1c56b5f", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 197, "deletions": 4, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -10,7 +10,7 @@\n \n //! HTML formatting module\n //!\n-//! This module contains a large number of `fmt::Show` implementations for\n+//! This module contains a large number of `fmt::String` implementations for\n //! various types in `rustdoc::clean`. These implementations all currently\n //! assume that HTML output is desired, although it may be possible to redesign\n //! them in the future to instead emit any format desired.\n@@ -64,7 +64,15 @@ impl UnsafetySpace {\n     }\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl<'a> fmt::Show for TyParamBounds<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl<'a> fmt::String for TyParamBounds<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let &TyParamBounds(bounds) = self;\n         for (i, bound) in bounds.iter().enumerate() {\n@@ -77,7 +85,15 @@ impl<'a> fmt::Show for TyParamBounds<'a> {\n     }\n }\n \n-impl fmt::Show for clean::Generics {\n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n+impl fmt::Show for clean::Generic {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for clean::Generics {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.lifetimes.len() == 0 && self.type_params.len() == 0 { return Ok(()) }\n         try!(f.write_str(\"&lt;\"));\n@@ -114,7 +130,15 @@ impl fmt::Show for clean::Generics {\n     }\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl<'a> fmt::Show for WhereClause<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl<'a> fmt::String for WhereClause<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let &WhereClause(gens) = self;\n         if gens.where_predicates.len() == 0 {\n@@ -151,14 +175,30 @@ impl<'a> fmt::Show for WhereClause<'a> {\n     }\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl fmt::Show for clean::Lifetime {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for clean::Lifetime {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(f.write_str(self.get_ref()));\n         Ok(())\n     }\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl fmt::Show for clean::PolyTrait {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for clean::PolyTrait {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.lifetimes.len() > 0 {\n             try!(f.write_str(\"for&lt;\"));\n@@ -174,7 +214,15 @@ impl fmt::Show for clean::PolyTrait {\n     }\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl fmt::Show for clean::TyParamBound {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for clean::TyParamBound {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             clean::RegionBound(ref lt) => {\n@@ -191,7 +239,15 @@ impl fmt::Show for clean::TyParamBound {\n     }\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl fmt::Show for clean::PathParameters {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for clean::PathParameters {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             clean::PathParameters::AngleBracketed { ref lifetimes, ref types } => {\n@@ -236,14 +292,30 @@ impl fmt::Show for clean::PathParameters {\n     }\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl fmt::Show for clean::PathSegment {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for clean::PathSegment {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(f.write_str(self.name.as_slice()));\n         write!(f, \"{}\", self.params)\n     }\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl fmt::Show for clean::Path {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for clean::Path {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.global {\n             try!(f.write_str(\"::\"))\n@@ -429,7 +501,15 @@ fn tybounds(w: &mut fmt::Formatter,\n     }\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl fmt::Show for clean::Type {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for clean::Type {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             clean::TyParamBinder(id) => {\n@@ -570,7 +650,16 @@ impl fmt::Show for clean::Type {\n     }\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl fmt::Show for clean::Arguments {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+\n+impl fmt::String for clean::Arguments {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         for (i, input) in self.values.iter().enumerate() {\n             if i > 0 { try!(write!(f, \", \")); }\n@@ -583,7 +672,15 @@ impl fmt::Show for clean::Arguments {\n     }\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl fmt::Show for clean::FunctionRetTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for clean::FunctionRetTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             clean::Return(clean::Tuple(ref tys)) if tys.is_empty() => Ok(()),\n@@ -593,13 +690,29 @@ impl fmt::Show for clean::FunctionRetTy {\n     }\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl fmt::Show for clean::FnDecl {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for clean::FnDecl {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"({args}){arrow}\", args = self.inputs, arrow = self.output)\n     }\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl<'a> fmt::Show for Method<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl<'a> fmt::String for Method<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let Method(selfty, d) = *self;\n         let mut args = String::new();\n@@ -629,7 +742,15 @@ impl<'a> fmt::Show for Method<'a> {\n     }\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl fmt::Show for VisSpace {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for VisSpace {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.get() {\n             Some(ast::Public) => write!(f, \"pub \"),\n@@ -638,7 +759,15 @@ impl fmt::Show for VisSpace {\n     }\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl fmt::Show for UnsafetySpace {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for UnsafetySpace {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.get() {\n             ast::Unsafety::Unsafe => write!(f, \"unsafe \"),\n@@ -647,7 +776,15 @@ impl fmt::Show for UnsafetySpace {\n     }\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl fmt::Show for clean::ViewPath {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for clean::ViewPath {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             clean::SimpleImport(ref name, ref src) => {\n@@ -674,7 +811,15 @@ impl fmt::Show for clean::ViewPath {\n     }\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl fmt::Show for clean::ImportSource {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for clean::ImportSource {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.did {\n             Some(did) => resolved_path(f, did, &self.path, true),\n@@ -691,7 +836,15 @@ impl fmt::Show for clean::ImportSource {\n     }\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl fmt::Show for clean::ViewListIdent {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for clean::ViewListIdent {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.source {\n             Some(did) => {\n@@ -712,7 +865,15 @@ impl fmt::Show for clean::ViewListIdent {\n     }\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl fmt::Show for MutableSpace {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for MutableSpace {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             MutableSpace(clean::Immutable) => Ok(()),\n@@ -721,7 +882,15 @@ impl fmt::Show for MutableSpace {\n     }\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl fmt::Show for RawMutableSpace {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for RawMutableSpace {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             RawMutableSpace(clean::Immutable) => write!(f, \"const \"),\n@@ -730,27 +899,43 @@ impl fmt::Show for RawMutableSpace {\n     }\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl<'a> fmt::Show for Stability<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl<'a> fmt::String for Stability<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let Stability(stab) = *self;\n         match *stab {\n             Some(ref stability) => {\n                 write!(f, \"<a class='stability {lvl}' title='{reason}'>{lvl}</a>\",\n-                       lvl = stability.level.to_string(),\n+                       lvl = stability.level,\n                        reason = stability.text)\n             }\n             None => Ok(())\n         }\n     }\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl<'a> fmt::Show for ConciseStability<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl<'a> fmt::String for ConciseStability<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let ConciseStability(stab) = *self;\n         match *stab {\n             Some(ref stability) => {\n                 write!(f, \"<a class='stability {lvl}' title='{lvl}{colon}{reason}'></a>\",\n-                       lvl = stability.level.to_string(),\n+                       lvl = stability.level,\n                        colon = if stability.text.len() > 0 { \": \" } else { \"\" },\n                        reason = stability.text)\n             }\n@@ -761,7 +946,15 @@ impl<'a> fmt::Show for ConciseStability<'a> {\n     }\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl fmt::Show for ModuleSummary {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for ModuleSummary {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fn fmt_inner<'a>(f: &mut fmt::Formatter,\n                          context: &mut Vec<&'a str>,"}, {"sha": "13a06f842a2767111f6882327797a4a4b3180736", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -103,7 +103,15 @@ impl ItemType {\n     }\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl fmt::Show for ItemType {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for ItemType {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.to_static_str().fmt(f)\n     }"}, {"sha": "f75ab3f431c2a23455f6a471fa2f814e3711b506", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -30,7 +30,7 @@ pub struct Page<'a> {\n     pub keywords: &'a str\n }\n \n-pub fn render<T: fmt::Show, S: fmt::Show>(\n+pub fn render<T: fmt::String, S: fmt::String>(\n     dst: &mut io::Writer, layout: &Layout, page: &Page, sidebar: &S, t: &T)\n     -> io::IoResult<()>\n {"}, {"sha": "f4660a81be496e315ce4fd92b44873091f21094e", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -14,7 +14,7 @@\n //! (bundled into the rust runtime). This module self-contains the C bindings\n //! and necessary legwork to render markdown, and exposes all of the\n //! functionality through a unit-struct, `Markdown`, which has an implementation\n-//! of `fmt::Show`. Example usage:\n+//! of `fmt::String`. Example usage:\n //!\n //! ```rust,ignore\n //! use rustdoc::html::markdown::Markdown;\n@@ -41,7 +41,7 @@ use html::highlight;\n use html::escape::Escape;\n use test;\n \n-/// A unit struct which has the `fmt::Show` trait implemented. When\n+/// A unit struct which has the `fmt::String` trait implemented. When\n /// formatted, this struct will emit the HTML corresponding to the rendered\n /// version of the contained markdown string.\n pub struct Markdown<'a>(pub &'a str);\n@@ -172,7 +172,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n             let text = slice::from_raw_buf(&(*orig_text).data,\n                                            (*orig_text).size as uint);\n             let origtext = str::from_utf8(text).unwrap();\n-            debug!(\"docblock: ==============\\n{}\\n=======\", text);\n+            debug!(\"docblock: ==============\\n{:?}\\n=======\", text);\n             let rendered = if lang.is_null() {\n                 false\n             } else {\n@@ -435,7 +435,15 @@ pub fn reset_headers() {\n     TEST_IDX.with(|s| s.set(0));\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl<'a> fmt::Show for Markdown<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl<'a> fmt::String for Markdown<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let Markdown(md) = *self;\n         // This is actually common enough to special-case\n@@ -444,7 +452,15 @@ impl<'a> fmt::Show for Markdown<'a> {\n     }\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl<'a> fmt::Show for MarkdownWithToc<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl<'a> fmt::String for MarkdownWithToc<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let MarkdownWithToc(md) = *self;\n         render(fmt, md.as_slice(), true)"}, {"sha": "17b1c09fb17a37280e6a6bc68b234de49e11859e", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -1051,7 +1051,7 @@ impl Context {\n         F: FnOnce(&mut Context) -> T,\n     {\n         if s.len() == 0 {\n-            panic!(\"Unexpected empty destination: {}\", self.current);\n+            panic!(\"Unexpected empty destination: {:?}\", self.current);\n         }\n         let prev = self.dst.clone();\n         self.dst.push(s.as_slice());\n@@ -1351,8 +1351,15 @@ impl<'a> Item<'a> {\n }\n \n \n-\n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl<'a> fmt::Show for Item<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl<'a> fmt::String for Item<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         // Write the breadcrumb trail header for the top\n         try!(write!(fmt, \"\\n<h1 class='fqn'><span class='in-band'>\"));\n@@ -1542,7 +1549,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n \n     indices.sort_by(|&i1, &i2| cmp(&items[i1], &items[i2], i1, i2));\n \n-    debug!(\"{}\", indices);\n+    debug!(\"{:?}\", indices);\n     let mut curty = None;\n     for &idx in indices.iter() {\n         let myitem = &items[idx];\n@@ -1626,7 +1633,16 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n }\n \n struct Initializer<'a>(&'a str);\n+\n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl<'a> fmt::Show for Initializer<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl<'a> fmt::String for Initializer<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let Initializer(s) = *self;\n         if s.len() == 0 { return Ok(()); }\n@@ -2127,7 +2143,7 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl) -> fmt::Result {\n                 try!(assoc_type(w, item, typaram));\n                 try!(write!(w, \"</code></h4>\\n\"));\n             }\n-            _ => panic!(\"can't make docs for trait item with name {}\", item.name)\n+            _ => panic!(\"can't make docs for trait item with name {:?}\", item.name)\n         }\n         match item.doc_value() {\n             Some(s) if dox => {\n@@ -2188,7 +2204,15 @@ fn item_typedef(w: &mut fmt::Formatter, it: &clean::Item,\n     document(w, it)\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl<'a> fmt::Show for Sidebar<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl<'a> fmt::String for Sidebar<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let cx = self.cx;\n         let it = self.item;\n@@ -2243,7 +2267,15 @@ impl<'a> fmt::Show for Sidebar<'a> {\n     }\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl<'a> fmt::Show for Source<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl<'a> fmt::String for Source<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let Source(s) = *self;\n         let lines = s.lines().count();"}, {"sha": "17d3f511d09288237e8e3fcec74a3b6375770cb5", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -176,7 +176,15 @@ impl TocBuilder {\n     }\n }\n \n+//NOTE(stage0): remove impl after snapshot\n+#[cfg(stage0)]\n impl fmt::Show for Toc {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for Toc {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(fmt, \"<ul>\"));\n         for entry in self.entries.iter() {"}, {"sha": "99c5fde47ea9c71b9f40b4189f5108f067e45986", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -445,7 +445,7 @@ fn json_input(input: &str) -> Result<Output, String> {\n         }\n     };\n     match json::from_reader(&mut input) {\n-        Err(s) => Err(s.to_string()),\n+        Err(s) => Err(format!(\"{:?}\", s)),\n         Ok(Json::Object(obj)) => {\n             let mut obj = obj;\n             // Make sure the schema is what we expect\n@@ -505,7 +505,7 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n     let crate_json_str = format!(\"{}\", json::as_json(&krate));\n     let crate_json = match json::from_str(crate_json_str.as_slice()) {\n         Ok(j) => j,\n-        Err(e) => panic!(\"Rust generated JSON is invalid: {}\", e)\n+        Err(e) => panic!(\"Rust generated JSON is invalid: {:?}\", e)\n     };\n \n     json.insert(\"crate\".to_string(), crate_json);"}, {"sha": "9d39b463bdd7615ab3033b219f32943a5d7575ca", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -201,7 +201,7 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n             if should_fail && out.status.success() {\n                 panic!(\"test executable succeeded when it should have failed\");\n             } else if !should_fail && !out.status.success() {\n-                panic!(\"test executable failed:\\n{}\",\n+                panic!(\"test executable failed:\\n{:?}\",\n                       str::from_utf8(out.error.as_slice()));\n             }\n         }"}, {"sha": "428b4e92a681f18dbb77154424347809b319a03b", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -265,7 +265,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n     pub fn visit_item(&mut self, item: &ast::Item,\n                       renamed: Option<ast::Ident>, om: &mut Module) {\n-        debug!(\"Visiting item {}\", item);\n+        debug!(\"Visiting item {:?}\", item);\n         let name = renamed.unwrap_or(item.ident);\n         match item.node {\n             ast::ItemMod(ref m) => {"}, {"sha": "d13d110320e1754302d4c2664d3a20a3acffb860", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -204,7 +204,7 @@ impl error::Error for FromBase64Error {\n     }\n \n     fn detail(&self) -> Option<String> {\n-        Some(self.to_string())\n+        Some(format!(\"{:?}\", self))\n     }\n }\n "}, {"sha": "a11eb3f789875563904e24a1c57fb491f3dcce3a", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -88,7 +88,7 @@ impl error::Error for FromHexError {\n     }\n \n     fn detail(&self) -> Option<String> {\n-        Some(self.to_string())\n+        Some(format!(\"{:?}\", self))\n     }\n }\n \n@@ -112,7 +112,7 @@ impl FromHex for str {\n     ///     let hello_str = \"Hello, World\".as_bytes().to_hex();\n     ///     println!(\"{}\", hello_str);\n     ///     let bytes = hello_str.as_slice().from_hex().unwrap();\n-    ///     println!(\"{}\", bytes);\n+    ///     println!(\"{:?}\", bytes);\n     ///     let result_str = String::from_utf8(bytes).unwrap();\n     ///     println!(\"{}\", result_str);\n     /// }"}, {"sha": "2ffcbcccbd4de4bc91d4b9232a59bbdff7fd1910", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -214,7 +214,7 @@ use unicode::str::Utf16Item;\n use Encodable;\n \n /// Represents a json value\n-#[derive(Clone, PartialEq, PartialOrd)]\n+#[derive(Clone, PartialEq, PartialOrd, Show)]\n pub enum Json {\n     I64(i64),\n     U64(u64),\n@@ -331,7 +331,7 @@ fn io_error_to_error(io: io::IoError) -> ParserError {\n \n impl std::error::Error for DecoderError {\n     fn description(&self) -> &str { \"decoder error\" }\n-    fn detail(&self) -> Option<std::string::String> { Some(self.to_string()) }\n+    fn detail(&self) -> Option<std::string::String> { Some(format!(\"{:?}\", self)) }\n }\n \n pub type EncodeResult = fmt::Result;\n@@ -1890,7 +1890,7 @@ impl<T: Iterator<Item=char>> Builder<T> {\n         match self.token {\n             None => {}\n             Some(Error(e)) => { return Err(e); }\n-            ref tok => { panic!(\"unexpected token {}\", tok.clone()); }\n+            ref tok => { panic!(\"unexpected token {:?}\", tok.clone()); }\n         }\n         result\n     }\n@@ -2005,15 +2005,15 @@ macro_rules! expect {\n         match $e {\n             Json::Null => Ok(()),\n             other => Err(ExpectedError(\"Null\".to_string(),\n-                                       format!(\"{}\", other)))\n+                                       format!(\"{:?}\", other)))\n         }\n     });\n     ($e:expr, $t:ident) => ({\n         match $e {\n             Json::$t(v) => Ok(v),\n             other => {\n                 Err(ExpectedError(stringify!($t).to_string(),\n-                                  format!(\"{}\", other)))\n+                                  format!(\"{:?}\", other)))\n             }\n         }\n     })\n@@ -2025,20 +2025,20 @@ macro_rules! read_primitive {\n             match self.pop() {\n                 Json::I64(f) => match num::cast(f) {\n                     Some(f) => Ok(f),\n-                    None => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", f))),\n+                    None => Err(ExpectedError(\"Number\".to_string(), format!(\"{:?}\", f))),\n                 },\n                 Json::U64(f) => match num::cast(f) {\n                     Some(f) => Ok(f),\n-                    None => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", f))),\n+                    None => Err(ExpectedError(\"Number\".to_string(), format!(\"{:?}\", f))),\n                 },\n-                Json::F64(f) => Err(ExpectedError(\"Integer\".to_string(), format!(\"{}\", f))),\n+                Json::F64(f) => Err(ExpectedError(\"Integer\".to_string(), format!(\"{:?}\", f))),\n                 // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n                 // is going to have a string here, as per JSON spec.\n                 Json::String(s) => match s.parse() {\n                     Some(f) => Ok(f),\n                     None => Err(ExpectedError(\"Number\".to_string(), s)),\n                 },\n-                value => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", value))),\n+                value => Err(ExpectedError(\"Number\".to_string(), format!(\"{:?}\", value))),\n             }\n         }\n     }\n@@ -2078,7 +2078,7 @@ impl ::Decoder for Decoder {\n                 }\n             },\n             Json::Null => Ok(f64::NAN),\n-            value => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", value)))\n+            value => Err(ExpectedError(\"Number\".to_string(), format!(\"{:?}\", value)))\n         }\n     }\n \n@@ -2096,7 +2096,7 @@ impl ::Decoder for Decoder {\n                 _ => ()\n             }\n         }\n-        Err(ExpectedError(\"single character string\".to_string(), format!(\"{}\", s)))\n+        Err(ExpectedError(\"single character string\".to_string(), format!(\"{:?}\", s)))\n     }\n \n     fn read_str(&mut self) -> DecodeResult<string::String> {\n@@ -2119,7 +2119,7 @@ impl ::Decoder for Decoder {\n                 let n = match o.remove(&\"variant\".to_string()) {\n                     Some(Json::String(s)) => s,\n                     Some(val) => {\n-                        return Err(ExpectedError(\"String\".to_string(), format!(\"{}\", val)))\n+                        return Err(ExpectedError(\"String\".to_string(), format!(\"{:?}\", val)))\n                     }\n                     None => {\n                         return Err(MissingFieldError(\"variant\".to_string()))\n@@ -2132,7 +2132,7 @@ impl ::Decoder for Decoder {\n                         }\n                     },\n                     Some(val) => {\n-                        return Err(ExpectedError(\"Array\".to_string(), format!(\"{}\", val)))\n+                        return Err(ExpectedError(\"Array\".to_string(), format!(\"{:?}\", val)))\n                     }\n                     None => {\n                         return Err(MissingFieldError(\"fields\".to_string()))\n@@ -2141,7 +2141,7 @@ impl ::Decoder for Decoder {\n                 n\n             }\n             json => {\n-                return Err(ExpectedError(\"String or Object\".to_string(), format!(\"{}\", json)))\n+                return Err(ExpectedError(\"String or Object\".to_string(), format!(\"{:?}\", json)))\n             }\n         };\n         let idx = match names.iter().position(|n| *n == name.index(&FullRange)) {\n@@ -2440,7 +2440,7 @@ impl<'a, 'b> fmt::Writer for FormatShim<'a, 'b> {\n     }\n }\n \n-impl fmt::Show for Json {\n+impl fmt::String for Json {\n     /// Encodes a json value into a string\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };\n@@ -2449,7 +2449,7 @@ impl fmt::Show for Json {\n     }\n }\n \n-impl<'a> fmt::Show for PrettyJson<'a> {\n+impl<'a> fmt::String for PrettyJson<'a> {\n     /// Encodes a json value into a string\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };\n@@ -2458,7 +2458,15 @@ impl<'a> fmt::Show for PrettyJson<'a> {\n     }\n }\n \n+#[cfg(stage0)]\n+//NOTE(stage0): remove impl after snapshot\n impl<'a, T: Encodable> fmt::Show for AsJson<'a, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl<'a, T: Encodable> fmt::String for AsJson<'a, T> {\n     /// Encodes a json value into a string\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };\n@@ -2475,7 +2483,7 @@ impl<'a, T> AsPrettyJson<'a, T> {\n     }\n }\n \n-impl<'a, T: Encodable> fmt::Show for AsPrettyJson<'a, T> {\n+impl<'a, T: Encodable> fmt::String for AsPrettyJson<'a, T> {\n     /// Encodes a json value into a string\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };\n@@ -3141,9 +3149,9 @@ mod tests {\n             Ok(json) => Decodable::decode(&mut Decoder::new(json))\n         };\n         match res {\n-            Ok(_) => panic!(\"`{}` parsed & decoded ok, expecting error `{}`\",\n+            Ok(_) => panic!(\"`{:?}` parsed & decoded ok, expecting error `{:?}`\",\n                               to_parse, expected),\n-            Err(ParseError(e)) => panic!(\"`{}` is not valid json: {}\",\n+            Err(ParseError(e)) => panic!(\"`{:?}` is not valid json: {:?}\",\n                                            to_parse, e),\n             Err(e) => {\n                 assert_eq!(e, expected);\n@@ -3354,7 +3362,7 @@ mod tests {\n         write!(&mut mem_buf, \"{}\", super::as_pretty_json(&hm)).unwrap();\n         let json_str = from_utf8(mem_buf.index(&FullRange)).unwrap();\n         match from_str(json_str) {\n-            Err(_) => panic!(\"Unable to parse json_str: {}\", json_str),\n+            Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n             _ => {} // it parsed and we are good to go\n         }\n     }\n@@ -3370,7 +3378,7 @@ mod tests {\n         write!(&mut mem_buf, \"{}\", super::as_pretty_json(&hm)).unwrap();\n         let json_str = from_utf8(mem_buf.index(&FullRange)).unwrap();\n         match from_str(json_str) {\n-            Err(_) => panic!(\"Unable to parse json_str: {}\", json_str),\n+            Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n             _ => {} // it parsed and we are good to go\n         }\n     }\n@@ -3433,7 +3441,7 @@ mod tests {\n         use Decodable;\n         let json_str = \"{\\\"1\\\":true}\";\n         let json_obj = match from_str(json_str) {\n-            Err(_) => panic!(\"Unable to parse json_str: {}\", json_str),\n+            Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n             Ok(o) => o\n         };\n         let mut decoder = Decoder::new(json_obj);\n@@ -3446,7 +3454,7 @@ mod tests {\n         use Decodable;\n         let json_str = \"{\\\"a\\\":true}\";\n         let json_obj = match from_str(json_str) {\n-            Err(_) => panic!(\"Unable to parse json_str: {}\", json_str),\n+            Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n             Ok(o) => o\n         };\n         let mut decoder = Decoder::new(json_obj);\n@@ -3465,7 +3473,7 @@ mod tests {\n             };\n             let (ref expected_evt, ref expected_stack) = expected[i];\n             if !parser.stack().is_equal_to(expected_stack.as_slice()) {\n-                panic!(\"Parser stack is not equal to {}\", expected_stack);\n+                panic!(\"Parser stack is not equal to {:?}\", expected_stack);\n             }\n             assert_eq!(&evt, expected_evt);\n             i+=1;"}, {"sha": "681f2454fa04ccd447faede936bca5b5f8956b3f", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -292,7 +292,7 @@ fn test_resize_policy() {\n ///\n /// // Use derived implementation to print the status of the vikings.\n /// for (viking, health) in vikings.iter() {\n-///     println!(\"{} has {} hp\", viking, health);\n+///     println!(\"{:?} has {} hp\", viking, health);\n /// }\n /// ```\n #[derive(Clone)]\n@@ -1207,11 +1207,11 @@ impl<K: Eq + Hash<S>, V: Eq, S, H: Hasher<S>> Eq for HashMap<K, V, H> {}\n #[stable]\n impl<K: Eq + Hash<S> + Show, V: Show, S, H: Hasher<S>> Show for HashMap<K, V, H> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{{\"));\n+        try!(write!(f, \"HashMap {{\"));\n \n         for (i, (k, v)) in self.iter().enumerate() {\n             if i != 0 { try!(write!(f, \", \")); }\n-            try!(write!(f, \"{}: {}\", *k, *v));\n+            try!(write!(f, \"{:?}: {:?}\", *k, *v));\n         }\n \n         write!(f, \"}}\")\n@@ -1891,10 +1891,10 @@ mod test_map {\n         map.insert(1i, 2i);\n         map.insert(3i, 4i);\n \n-        let map_str = format!(\"{}\", map);\n+        let map_str = format!(\"{:?}\", map);\n \n-        assert!(map_str == \"{1: 2, 3: 4}\" || map_str == \"{3: 4, 1: 2}\");\n-        assert_eq!(format!(\"{}\", empty), \"{}\");\n+        assert!(map_str == \"HashMap {1i: 2i, 3i: 4i}\" || map_str == \"{3i: 4i, 1i: 2i}\");\n+        assert_eq!(format!(\"{:?}\", empty), \"HashMap {}\");\n     }\n \n     #[test]"}, {"sha": "10e8ca6c6225f173cb674bd9bd56c44de8e017d1", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -88,7 +88,7 @@ use super::map::{self, HashMap, Keys, INITIAL_CAPACITY};\n ///\n /// // Use derived implementation to print the vikings.\n /// for x in vikings.iter() {\n-///     println!(\"{}\", x);\n+///     println!(\"{:?}\", x);\n /// }\n /// ```\n #[derive(Clone)]\n@@ -585,11 +585,11 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> Eq for HashSet<T, H> {}\n #[stable]\n impl<T: Eq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{{\"));\n+        try!(write!(f, \"HashSet {{\"));\n \n         for (i, x) in self.iter().enumerate() {\n             if i != 0 { try!(write!(f, \", \")); }\n-            try!(write!(f, \"{}\", *x));\n+            try!(write!(f, \"{:?}\", *x));\n         }\n \n         write!(f, \"}}\")\n@@ -1116,10 +1116,10 @@ mod test_set {\n         set.insert(1i);\n         set.insert(2);\n \n-        let set_str = format!(\"{}\", set);\n+        let set_str = format!(\"{:?}\", set);\n \n-        assert!(set_str == \"{1, 2}\" || set_str == \"{2, 1}\");\n-        assert_eq!(format!(\"{}\", empty), \"{}\");\n+        assert!(set_str == \"HashSet {1i, 2i}\" || set_str == \"{2i, 1i}\");\n+        assert_eq!(format!(\"{:?}\", empty), \"HashSet {}\");\n     }\n \n     #[test]"}, {"sha": "d014f67172ce7279fde695f253420619224ff636", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -31,7 +31,7 @@\n //! format!(\"Hello\");                  // => \"Hello\"\n //! format!(\"Hello, {}!\", \"world\");    // => \"Hello, world!\"\n //! format!(\"The number is {}\", 1i);   // => \"The number is 1\"\n-//! format!(\"{}\", (3i, 4i));           // => \"(3, 4)\"\n+//! format!(\"{:?}\", (3i, 4i));         // => \"(3i, 4i)\"\n //! format!(\"{value}\", value=4i);      // => \"4\"\n //! format!(\"{} {}\", 1i, 2u);          // => \"1 2\"\n //! # }\n@@ -87,7 +87,7 @@\n //! # fn main() {\n //! format!(\"{argument}\", argument = \"test\");   // => \"test\"\n //! format!(\"{name} {}\", 1i, name = 2i);        // => \"2 1\"\n-//! format!(\"{a} {c} {b}\", a=\"a\", b=(), c=3i);  // => \"a 3 ()\"\n+//! format!(\"{a} {c} {b}\", a=\"a\", b='b', c=3i);  // => \"a 3 b\"\n //! # }\n //! ```\n //!\n@@ -127,7 +127,8 @@\n //! This allows multiple actual types to be formatted via `{:x}` (like `i8` as\n //! well as `int`).  The current mapping of types to traits is:\n //!\n-//! * *nothing* \u21d2 `Show`\n+//! * *nothing* \u21d2 `String`\n+//! * `?` \u21d2 `Show`\n //! * `o` \u21d2 `Octal`\n //! * `x` \u21d2 `LowerHex`\n //! * `X` \u21d2 `UpperHex`\n@@ -140,8 +141,7 @@\n //! `std::fmt::Binary` trait can then be formatted with `{:b}`. Implementations\n //! are provided for these traits for a number of primitive types by the\n //! standard library as well. If no format is specified (as in `{}` or `{:6}`),\n-//! then the format trait used is the `Show` trait. This is one of the more\n-//! commonly implemented traits when formatting a custom type.\n+//! then the format trait used is the `String` trait.\n //!\n //! When implementing a format trait for your own type, you will have to\n //! implement a method of the signature:\n@@ -175,12 +175,13 @@\n //! use std::f64;\n //! use std::num::Float;\n //!\n+//! #[deriving(Show)]\n //! struct Vector2D {\n //!     x: int,\n //!     y: int,\n //! }\n //!\n-//! impl fmt::Show for Vector2D {\n+//! impl fmt::String for Vector2D {\n //!     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n //!         // The `f` value implements the `Writer` trait, which is what the\n //!         // write! macro is expecting. Note that this formatting ignores the\n@@ -209,10 +210,31 @@\n //!     let myvector = Vector2D { x: 3, y: 4 };\n //!\n //!     println!(\"{}\", myvector);       // => \"(3, 4)\"\n+//!     println!(\"{:?}\", myvector);     // => \"Vector2D {x: 3i, y:4i}\"\n //!     println!(\"{:10.3b}\", myvector); // => \"     5.000\"\n //! }\n //! ```\n //!\n+//! #### fmt::String vs fmt::Show\n+//!\n+//! These two formatting traits have distinct purposes:\n+//!\n+//! - `fmt::String` implementations assert that the type can be faithfully\n+//!   represented as a UTF-8 string at all times. It is **not** expected that\n+//!   all types implement the `String` trait.\n+//! - `fmt::Show` implementations should be implemented for **all** public types.\n+//!   Output will typically represent the internal state as faithfully as possible.\n+//!   The purpose of the `Show` trait is to facilitate debugging Rust code. In\n+//!   most cases, using `#[deriving(Show)]` is sufficient and recommended.\n+//!\n+//! Some examples of the output from both traits:\n+//!\n+//! ```\n+//! assert_eq(format!(\"{} {:?}\", 3i32, 4i32), \"3 4i32\");\n+//! assert_eq(format!(\"{} {:?}\", 'a', 'b'), \"a 'b'\");\n+//! assert_eq(format!(\"{} {:?}\", \"foo\\n\", \"bar\\n\"), \"foo\\n \\\"bar\\\\n\\\"\");\n+//! ```\n+//!\n //! ### Related macros\n //!\n //! There are a number of related macros in the `format!` family. The ones that\n@@ -393,7 +415,7 @@\n use string;\n \n pub use core::fmt::{Formatter, Result, Writer, rt};\n-pub use core::fmt::{Show, Octal, Binary};\n+pub use core::fmt::{Show, String, Octal, Binary};\n pub use core::fmt::{LowerHex, UpperHex, Pointer};\n pub use core::fmt::{LowerExp, UpperExp};\n pub use core::fmt::Error;"}, {"sha": "1556ef43eb7f802c09d43028bb95389c6e0c81e0", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -107,7 +107,7 @@ impl File {\n     ///\n     /// let file = match File::open_mode(&p, Open, ReadWrite) {\n     ///     Ok(f) => f,\n-    ///     Err(e) => panic!(\"file error: {}\", e),\n+    ///     Err(e) => panic!(\"file error: {:?}\", e),\n     /// };\n     /// // do some stuff with that file\n     ///\n@@ -156,7 +156,7 @@ impl File {\n                 })\n             }\n         }).update_err(\"couldn't open path as file\", |e| {\n-            format!(\"{}; path={}; mode={}; access={}\", e, path.display(),\n+            format!(\"{:?}; path={:?}; mode={}; access={}\", e, path.display(),\n                 mode_string(mode), access_string(access))\n         })\n     }\n@@ -211,7 +211,7 @@ impl File {\n     pub fn fsync(&mut self) -> IoResult<()> {\n         self.fd.fsync()\n             .update_err(\"couldn't fsync file\",\n-                        |e| format!(\"{}; path={}\", e, self.path.display()))\n+                        |e| format!(\"{:?}; path={:?}\", e, self.path.display()))\n     }\n \n     /// This function is similar to `fsync`, except that it may not synchronize\n@@ -221,7 +221,7 @@ impl File {\n     pub fn datasync(&mut self) -> IoResult<()> {\n         self.fd.datasync()\n             .update_err(\"couldn't datasync file\",\n-                        |e| format!(\"{}; path={}\", e, self.path.display()))\n+                        |e| format!(\"{:?}; path={:?}\", e, self.path.display()))\n     }\n \n     /// Either truncates or extends the underlying file, updating the size of\n@@ -235,7 +235,7 @@ impl File {\n     pub fn truncate(&mut self, size: i64) -> IoResult<()> {\n         self.fd.truncate(size)\n             .update_err(\"couldn't truncate file\", |e|\n-                format!(\"{}; path={}; size={}\", e, self.path.display(), size))\n+                format!(\"{:?}; path={:?}; size={:?}\", e, self.path.display(), size))\n     }\n \n     /// Returns true if the stream has reached the end of the file.\n@@ -255,7 +255,7 @@ impl File {\n     pub fn stat(&self) -> IoResult<FileStat> {\n         self.fd.fstat()\n             .update_err(\"couldn't fstat file\", |e|\n-                format!(\"{}; path={}\", e, self.path.display()))\n+                format!(\"{:?}; path={:?}\", e, self.path.display()))\n     }\n }\n \n@@ -283,7 +283,7 @@ impl File {\n pub fn unlink(path: &Path) -> IoResult<()> {\n     fs_imp::unlink(path)\n            .update_err(\"couldn't unlink path\", |e|\n-               format!(\"{}; path={}\", e, path.display()))\n+               format!(\"{:?}; path={:?}\", e, path.display()))\n }\n \n /// Given a path, query the file system to get information about a file,\n@@ -310,7 +310,7 @@ pub fn unlink(path: &Path) -> IoResult<()> {\n pub fn stat(path: &Path) -> IoResult<FileStat> {\n     fs_imp::stat(path)\n            .update_err(\"couldn't stat path\", |e|\n-               format!(\"{}; path={}\", e, path.display()))\n+               format!(\"{:?}; path={:?}\", e, path.display()))\n }\n \n /// Perform the same operation as the `stat` function, except that this\n@@ -324,7 +324,7 @@ pub fn stat(path: &Path) -> IoResult<FileStat> {\n pub fn lstat(path: &Path) -> IoResult<FileStat> {\n     fs_imp::lstat(path)\n            .update_err(\"couldn't lstat path\", |e|\n-               format!(\"{}; path={}\", e, path.display()))\n+               format!(\"{:?}; path={:?}\", e, path.display()))\n }\n \n /// Rename a file or directory to a new name.\n@@ -346,7 +346,7 @@ pub fn lstat(path: &Path) -> IoResult<FileStat> {\n pub fn rename(from: &Path, to: &Path) -> IoResult<()> {\n     fs_imp::rename(from, to)\n            .update_err(\"couldn't rename path\", |e|\n-               format!(\"{}; from={}; to={}\", e, from.display(), to.display()))\n+               format!(\"{:?}; from={:?}; to={:?}\", e, from.display(), to.display()))\n }\n \n /// Copies the contents of one file to another. This function will also\n@@ -380,7 +380,7 @@ pub fn rename(from: &Path, to: &Path) -> IoResult<()> {\n pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n     fn update_err<T>(result: IoResult<T>, from: &Path, to: &Path) -> IoResult<T> {\n         result.update_err(\"couldn't copy path\", |e| {\n-            format!(\"{}; from={}; to={}\", e, from.display(), to.display())\n+            format!(\"{:?}; from={:?}; to={:?}\", e, from.display(), to.display())\n         })\n     }\n \n@@ -424,14 +424,14 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n pub fn chmod(path: &Path, mode: io::FilePermission) -> IoResult<()> {\n     fs_imp::chmod(path, mode.bits() as uint)\n            .update_err(\"couldn't chmod path\", |e|\n-               format!(\"{}; path={}; mode={}\", e, path.display(), mode))\n+               format!(\"{:?}; path={:?}; mode={:?}\", e, path.display(), mode))\n }\n \n /// Change the user and group owners of a file at the specified path.\n pub fn chown(path: &Path, uid: int, gid: int) -> IoResult<()> {\n     fs_imp::chown(path, uid, gid)\n            .update_err(\"couldn't chown path\", |e|\n-               format!(\"{}; path={}; uid={}; gid={}\", e, path.display(), uid, gid))\n+               format!(\"{:?}; path={:?}; uid={:?}; gid={:?}\", e, path.display(), uid, gid))\n }\n \n /// Creates a new hard link on the filesystem. The `dst` path will be a\n@@ -440,15 +440,15 @@ pub fn chown(path: &Path, uid: int, gid: int) -> IoResult<()> {\n pub fn link(src: &Path, dst: &Path) -> IoResult<()> {\n     fs_imp::link(src, dst)\n            .update_err(\"couldn't link path\", |e|\n-               format!(\"{}; src={}; dest={}\", e, src.display(), dst.display()))\n+               format!(\"{:?}; src={:?}; dest={:?}\", e, src.display(), dst.display()))\n }\n \n /// Creates a new symbolic link on the filesystem. The `dst` path will be a\n /// symlink pointing to the `src` path.\n pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n     fs_imp::symlink(src, dst)\n            .update_err(\"couldn't symlink path\", |e|\n-               format!(\"{}; src={}; dest={}\", e, src.display(), dst.display()))\n+               format!(\"{:?}; src={:?}; dest={:?}\", e, src.display(), dst.display()))\n }\n \n /// Reads a symlink, returning the file that the symlink points to.\n@@ -460,7 +460,7 @@ pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n pub fn readlink(path: &Path) -> IoResult<Path> {\n     fs_imp::readlink(path)\n            .update_err(\"couldn't resolve symlink for path\", |e|\n-               format!(\"{}; path={}\", e, path.display()))\n+               format!(\"{:?}; path={:?}\", e, path.display()))\n }\n \n /// Create a new, empty directory at the provided path\n@@ -483,7 +483,7 @@ pub fn readlink(path: &Path) -> IoResult<Path> {\n pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n     fs_imp::mkdir(path, mode.bits() as uint)\n            .update_err(\"couldn't create directory\", |e|\n-               format!(\"{}; path={}; mode={}\", e, path.display(), mode))\n+               format!(\"{:?}; path={:?}; mode={:?}\", e, path.display(), mode))\n }\n \n /// Remove an existing, empty directory\n@@ -505,7 +505,7 @@ pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n pub fn rmdir(path: &Path) -> IoResult<()> {\n     fs_imp::rmdir(path)\n            .update_err(\"couldn't remove directory\", |e|\n-               format!(\"{}; path={}\", e, path.display()))\n+               format!(\"{:?}; path={:?}\", e, path.display()))\n }\n \n /// Retrieve a vector containing all entries within a provided directory\n@@ -545,7 +545,7 @@ pub fn rmdir(path: &Path) -> IoResult<()> {\n pub fn readdir(path: &Path) -> IoResult<Vec<Path>> {\n     fs_imp::readdir(path)\n            .update_err(\"couldn't read directory\",\n-                       |e| format!(\"{}; path={}\", e, path.display()))\n+                       |e| format!(\"{:?}; path={:?}\", e, path.display()))\n }\n \n /// Returns an iterator that will recursively walk the directory structure\n@@ -555,7 +555,7 @@ pub fn readdir(path: &Path) -> IoResult<Vec<Path>> {\n pub fn walk_dir(path: &Path) -> IoResult<Directories> {\n     Ok(Directories {\n         stack: try!(readdir(path).update_err(\"couldn't walk directory\",\n-                                             |e| format!(\"{}; path={}\", e, path.display())))\n+                                             |e| format!(\"{:?}; path={:?}\", e, path.display())))\n     })\n }\n \n@@ -605,7 +605,7 @@ pub fn mkdir_recursive(path: &Path, mode: FilePermission) -> IoResult<()> {\n \n         let result = mkdir(&curpath, mode)\n             .update_err(\"couldn't recursively mkdir\",\n-                        |e| format!(\"{}; path={}\", e, path.display()));\n+                        |e| format!(\"{:?}; path={:?}\", e, path.display()));\n \n         match result {\n             Err(mkdir_err) => {\n@@ -632,7 +632,7 @@ pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n     rm_stack.push(path.clone());\n \n     fn rmdir_failed(err: &IoError, path: &Path) -> String {\n-        format!(\"rmdir_recursive failed; path={}; cause={}\",\n+        format!(\"rmdir_recursive failed; path={:?}; cause={:?}\",\n                 path.display(), err)\n     }\n \n@@ -692,14 +692,14 @@ pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n pub fn change_file_times(path: &Path, atime: u64, mtime: u64) -> IoResult<()> {\n     fs_imp::utime(path, atime, mtime)\n            .update_err(\"couldn't change_file_times\", |e|\n-               format!(\"{}; path={}\", e, path.display()))\n+               format!(\"{:?}; path={:?}\", e, path.display()))\n }\n \n impl Reader for File {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         fn update_err<T>(result: IoResult<T>, file: &File) -> IoResult<T> {\n             result.update_err(\"couldn't read file\",\n-                              |e| format!(\"{}; path={}\",\n+                              |e| format!(\"{:?}; path={:?}\",\n                                           e, file.path.display()))\n         }\n \n@@ -722,15 +722,15 @@ impl Writer for File {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.fd.write(buf)\n             .update_err(\"couldn't write to file\",\n-                        |e| format!(\"{}; path={}\", e, self.path.display()))\n+                        |e| format!(\"{:?}; path={:?}\", e, self.path.display()))\n     }\n }\n \n impl Seek for File {\n     fn tell(&self) -> IoResult<u64> {\n         self.fd.tell()\n             .update_err(\"couldn't retrieve file cursor (`tell`)\",\n-                        |e| format!(\"{}; path={}\", e, self.path.display()))\n+                        |e| format!(\"{:?}; path={:?}\", e, self.path.display()))\n     }\n \n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n@@ -743,7 +743,7 @@ impl Seek for File {\n             Err(e) => Err(e),\n         };\n         err.update_err(\"couldn't seek in file\",\n-                       |e| format!(\"{}; path={}\", e, self.path.display()))\n+                       |e| format!(\"{:?}; path={:?}\", e, self.path.display()))\n     }\n }\n \n@@ -832,15 +832,15 @@ mod test {\n     macro_rules! check { ($e:expr) => (\n         match $e {\n             Ok(t) => t,\n-            Err(e) => panic!(\"{} failed with: {}\", stringify!($e), e),\n+            Err(e) => panic!(\"{} failed with: {:?}\", stringify!($e), e),\n         }\n     ) }\n \n     macro_rules! error { ($e:expr, $s:expr) => (\n         match $e {\n-            Ok(_) => panic!(\"Unexpected success. Should've been: {}\", $s),\n+            Ok(_) => panic!(\"Unexpected success. Should've been: {:?}\", $s),\n             Err(ref err) => assert!(err.to_string().contains($s.as_slice()),\n-                                    format!(\"`{}` did not contain `{}`\", err, $s))\n+                                    format!(\"`{:?}` did not contain `{:?}`\", err, $s))\n         }\n     ) }\n \n@@ -906,7 +906,7 @@ mod test {\n         if cfg!(unix) {\n             error!(result, \"no such file or directory\");\n         }\n-        error!(result, format!(\"path={}; mode=open; access=read\", filename.display()));\n+        error!(result, format!(\"path={:?}; mode=open; access=read\", filename.display()));\n     }\n \n     #[test]\n@@ -920,7 +920,7 @@ mod test {\n         if cfg!(unix) {\n             error!(result, \"no such file or directory\");\n         }\n-        error!(result, format!(\"path={}\", filename.display()));\n+        error!(result, format!(\"path={:?}\", filename.display()));\n     }\n \n     #[test]\n@@ -1188,7 +1188,7 @@ mod test {\n         error!(result, \"couldn't recursively mkdir\");\n         error!(result, \"couldn't create directory\");\n         error!(result, \"mode=0700\");\n-        error!(result, format!(\"path={}\", file.display()));\n+        error!(result, format!(\"path={:?}\", file.display()));\n     }\n \n     #[test]\n@@ -1255,7 +1255,7 @@ mod test {\n \n         error!(copy(&from, &to),\n             format!(\"couldn't copy path (the source path is not an \\\n-                    existing file; from={}; to={})\",\n+                    existing file; from={:?}; to={:?})\",\n                     from.display(), to.display()));\n \n         match copy(&from, &to) {"}, {"sha": "010cb8147329cf6fa0bdfa92b638fbfb22e809b3", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -302,7 +302,7 @@ pub type IoResult<T> = Result<T, IoError>;\n /// # FIXME\n ///\n /// Is something like this sufficient? It's kind of archaic\n-#[derive(PartialEq, Eq, Clone)]\n+#[derive(PartialEq, Eq, Clone, Show)]\n pub struct IoError {\n     /// An enumeration which can be matched against for determining the flavor\n     /// of error.\n@@ -339,7 +339,7 @@ impl IoError {\n     }\n }\n \n-impl fmt::Show for IoError {\n+impl fmt::String for IoError {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             IoError { kind: OtherIoError, desc: \"unknown error\", detail: Some(ref detail) } =>\n@@ -1656,7 +1656,7 @@ pub fn standard_error(kind: IoErrorKind) -> IoError {\n /// A mode specifies how a file should be opened or created. These modes are\n /// passed to `File::open_mode` and are used to control where the file is\n /// positioned when it is initially opened.\n-#[derive(Copy, Clone, PartialEq, Eq)]\n+#[derive(Copy, Clone, PartialEq, Eq, Show)]\n pub enum FileMode {\n     /// Opens a file positioned at the beginning.\n     Open,\n@@ -1668,7 +1668,7 @@ pub enum FileMode {\n \n /// Access permissions with which the file should be opened. `File`s\n /// opened with `Read` will return an error if written to.\n-#[derive(Copy, Clone, PartialEq, Eq)]\n+#[derive(Copy, Clone, PartialEq, Eq, Show)]\n pub enum FileAccess {\n     /// Read-only access, requests to write will result in an error\n     Read,\n@@ -1825,6 +1825,12 @@ impl Default for FilePermission {\n }\n \n impl fmt::Show for FilePermission {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for FilePermission {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{:04o}\", self.bits)\n     }"}, {"sha": "7825a4e16e161d5b0a46c46f386e9ccea7be772a", "filename": "src/libstd/io/net/addrinfo.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -29,7 +29,7 @@ use sys;\n use vec::Vec;\n \n /// Hints to the types of sockets that are desired when looking up hosts\n-#[derive(Copy)]\n+#[derive(Copy, Show)]\n pub enum SocketType {\n     Stream, Datagram, Raw\n }\n@@ -38,7 +38,7 @@ pub enum SocketType {\n /// to manipulate how a query is performed.\n ///\n /// The meaning of each of these flags can be found with `man -s 3 getaddrinfo`\n-#[derive(Copy)]\n+#[derive(Copy, Show)]\n pub enum Flag {\n     AddrConfig,\n     All,\n@@ -51,7 +51,7 @@ pub enum Flag {\n \n /// A transport protocol associated with either a hint or a return value of\n /// `lookup`\n-#[derive(Copy)]\n+#[derive(Copy, Show)]\n pub enum Protocol {\n     TCP, UDP\n }\n@@ -61,15 +61,15 @@ pub enum Protocol {\n ///\n /// For details on these fields, see their corresponding definitions via\n /// `man -s 3 getaddrinfo`\n-#[derive(Copy)]\n+#[derive(Copy, Show)]\n pub struct Hint {\n     pub family: uint,\n     pub socktype: Option<SocketType>,\n     pub protocol: Option<Protocol>,\n     pub flags: uint,\n }\n \n-#[derive(Copy)]\n+#[derive(Copy, Show)]\n pub struct Info {\n     pub address: SocketAddr,\n     pub family: uint,"}, {"sha": "b9f653f86c2b0b514fd6aee236feacb79671d26b", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -32,13 +32,13 @@ use vec::Vec;\n \n pub type Port = u16;\n \n-#[derive(Copy, PartialEq, Eq, Clone, Hash)]\n+#[derive(Copy, PartialEq, Eq, Clone, Hash, Show)]\n pub enum IpAddr {\n     Ipv4Addr(u8, u8, u8, u8),\n     Ipv6Addr(u16, u16, u16, u16, u16, u16, u16, u16)\n }\n \n-impl fmt::Show for IpAddr {\n+impl fmt::String for IpAddr {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             Ipv4Addr(a, b, c, d) =>\n@@ -63,13 +63,13 @@ impl fmt::Show for IpAddr {\n     }\n }\n \n-#[derive(Copy, PartialEq, Eq, Clone, Hash)]\n+#[derive(Copy, PartialEq, Eq, Clone, Hash, Show)]\n pub struct SocketAddr {\n     pub ip: IpAddr,\n     pub port: Port,\n }\n \n-impl fmt::Show for SocketAddr {\n+impl fmt::String for SocketAddr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.ip {\n             Ipv4Addr(..) => write!(f, \"{}:{}\", self.ip, self.port),"}, {"sha": "efb573416208e0051165a9c365348dfe258a3922", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -395,7 +395,14 @@ impl Command {\n     }\n }\n \n+#[cfg(stage0)]\n impl fmt::Show for Command {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for Command {\n     /// Format the program and arguments of a Command for display. Any\n     /// non-utf8 data is lossily converted using the utf8 replacement\n     /// character.\n@@ -504,6 +511,14 @@ pub enum ProcessExit {\n }\n \n impl fmt::Show for ProcessExit {\n+    /// Format a ProcessExit enum, to nicely present the information.\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+\n+impl fmt::String for ProcessExit {\n     /// Format a ProcessExit enum, to nicely present the information.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {"}, {"sha": "d7bc572106e011760de9122d4ff5b6f64d720852", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -349,7 +349,7 @@ fn with_task_stdout<F>(f: F) where F: FnOnce(&mut Writer) -> IoResult<()> {\n     });\n     match result {\n         Ok(()) => {}\n-        Err(e) => panic!(\"failed printing to stdout: {}\", e),\n+        Err(e) => panic!(\"failed printing to stdout: {:?}\", e),\n     }\n }\n "}, {"sha": "be3e49c0b824cc2eec907a8f2392d9d6152a0c4c", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -111,7 +111,7 @@ macro_rules! assert_eq {\n                 if !((*left_val == *right_val) &&\n                      (*right_val == *left_val)) {\n                     panic!(\"assertion failed: `(left == right) && (right == left)` \\\n-                           (left: `{}`, right: `{}`)\", *left_val, *right_val)\n+                           (left: `{:?}`, right: `{:?}`)\", *left_val, *right_val)\n                 }\n             }\n         }"}, {"sha": "5d23f2a9b93c10e37fd0868886e000e7f51e63bb", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -93,7 +93,7 @@ pub const TMPBUF_SZ : uint = 1000u;\n ///\n /// // We assume that we are in a valid directory.\n /// let current_working_directory = os::getcwd().unwrap();\n-/// println!(\"The current directory is {}\", current_working_directory.display());\n+/// println!(\"The current directory is {:?}\", current_working_directory.display());\n /// ```\n pub fn getcwd() -> IoResult<Path> {\n     sys::os::getcwd()\n@@ -934,7 +934,7 @@ impl fmt::Show for MapError {\n \n impl Error for MapError {\n     fn description(&self) -> &str { \"memory map error\" }\n-    fn detail(&self) -> Option<String> { Some(self.to_string()) }\n+    fn detail(&self) -> Option<String> { Some(format!(\"{:?}\", self)) }\n }\n \n impl FromError<MapError> for Box<Error> {"}, {"sha": "0448e6907e31c5f62fc3d9e8c802f5c1e0bbe44e", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -460,7 +460,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # #[cfg(unix)] fn foo() {\n     /// let mut p = Path::new(\"abc/def.txt\");\n     /// p.set_extension(\"csv\");\n-    /// assert!(p == Path::new(\"abc/def.csv\"));\n+    /// assert_eq!(p, Path::new(\"abc/def.csv\"));\n     /// # }\n     /// ```\n     ///\n@@ -509,7 +509,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # #[cfg(windows)] fn foo() {}\n     /// # #[cfg(unix)] fn foo() {\n     /// let mut p = Path::new(\"abc/def.txt\");\n-    /// assert!(p.with_filename(\"foo.dat\") == Path::new(\"abc/foo.dat\"));\n+    /// assert_eq!(p.with_filename(\"foo.dat\"), Path::new(\"abc/foo.dat\"));\n     /// # }\n     /// ```\n     ///\n@@ -534,7 +534,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # #[cfg(windows)] fn foo() {}\n     /// # #[cfg(unix)] fn foo() {\n     /// let mut p = Path::new(\"abc/def.txt\");\n-    /// assert!(p.with_extension(\"csv\") == Path::new(\"abc/def.csv\"));\n+    /// assert_eq!(p.with_extension(\"csv\"), Path::new(\"abc/def.csv\"));\n     /// # }\n     /// ```\n     ///\n@@ -558,7 +558,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # #[cfg(windows)] fn foo() {}\n     /// # #[cfg(unix)] fn foo() {\n     /// let p = Path::new(\"abc/def/ghi\");\n-    /// assert!(p.dir_path() == Path::new(\"abc/def\"));\n+    /// assert_eq!(p.dir_path(), Path::new(\"abc/def\"));\n     /// # }\n     /// ```\n     fn dir_path(&self) -> Self {\n@@ -576,8 +576,8 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n     /// # #[cfg(unix)] fn foo() {\n-    /// assert!(Path::new(\"abc/def\").root_path() == None);\n-    /// assert!(Path::new(\"/abc/def\").root_path() == Some(Path::new(\"/\")));\n+    /// assert_eq!(Path::new(\"abc/def\").root_path(), None);\n+    /// assert_eq!(Path::new(\"/abc/def\").root_path(), Some(Path::new(\"/\")));\n     /// # }\n     /// ```\n     fn root_path(&self) -> Option<Self>;\n@@ -593,7 +593,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # #[cfg(unix)] fn foo() {\n     /// let mut p = Path::new(\"foo/bar\");\n     /// p.push(\"baz.txt\");\n-    /// assert!(p == Path::new(\"foo/bar/baz.txt\"));\n+    /// assert_eq!(p, Path::new(\"foo/bar/baz.txt\"));\n     /// # }\n     /// ```\n     ///\n@@ -617,7 +617,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # #[cfg(unix)] fn foo() {\n     /// let mut p = Path::new(\"foo\");\n     /// p.push_many(&[\"bar\", \"baz.txt\"]);\n-    /// assert!(p == Path::new(\"foo/bar/baz.txt\"));\n+    /// assert_eq!(p, Path::new(\"foo/bar/baz.txt\"));\n     /// # }\n     /// ```\n     #[inline]\n@@ -646,7 +646,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # #[cfg(unix)] fn foo() {\n     /// let mut p = Path::new(\"foo/bar/baz.txt\");\n     /// p.pop();\n-    /// assert!(p == Path::new(\"foo/bar\"));\n+    /// assert_eq!(p, Path::new(\"foo/bar\"));\n     /// # }\n     /// ```\n     fn pop(&mut self) -> bool;\n@@ -662,7 +662,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # #[cfg(windows)] fn foo() {}\n     /// # #[cfg(unix)] fn foo() {\n     /// let p = Path::new(\"/foo\");\n-    /// assert!(p.join(\"bar.txt\") == Path::new(\"/foo/bar.txt\"));\n+    /// assert_eq!(p.join(\"bar.txt\"), Path::new(\"/foo/bar.txt\"));\n     /// # }\n     /// ```\n     ///\n@@ -688,7 +688,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # #[cfg(unix)] fn foo() {\n     /// let p = Path::new(\"foo\");\n     /// let fbbq = Path::new(\"foo/bar/baz/quux.txt\");\n-    /// assert!(p.join_many(&[\"bar\", \"baz\", \"quux.txt\"]) == fbbq);\n+    /// assert_eq!(p.join_many(&[\"bar\", \"baz\", \"quux.txt\"]), fbbq);\n     /// # }\n     /// ```\n     #[inline]\n@@ -765,7 +765,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// let p = Path::new(\"foo/bar/baz/quux.txt\");\n     /// let fb = Path::new(\"foo/bar\");\n     /// let bq = Path::new(\"baz/quux.txt\");\n-    /// assert!(p.path_relative_from(&fb) == Some(bq));\n+    /// assert_eq!(p.path_relative_from(&fb), Some(bq));\n     /// # }\n     /// ```\n     fn path_relative_from(&self, base: &Self) -> Option<Self>;\n@@ -823,7 +823,14 @@ pub struct Display<'a, P:'a> {\n     filename: bool\n }\n \n+//NOTE(stage0): replace with deriving(Show) after snapshot\n impl<'a, P: GenericPath> fmt::Show for Display<'a, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl<'a, P: GenericPath> fmt::String for Display<'a, P> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.as_cow().fmt(f)\n     }"}, {"sha": "7c5455ed3fc1ce8199e0c654720d93f22bbbb9f1", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 47, "deletions": 54, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -12,6 +12,7 @@\n \n use clone::Clone;\n use cmp::{Ordering, Eq, Ord, PartialEq, PartialOrd};\n+use fmt;\n use hash;\n use io::Writer;\n use iter::{AdditiveIterator, Extend};\n@@ -57,6 +58,12 @@ pub fn is_sep(c: char) -> bool {\n     c == SEP\n }\n \n+impl fmt::Show for Path {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"Path {{ {} }}\", self.display())\n+    }\n+}\n+\n impl PartialEq for Path {\n     #[inline]\n     fn eq(&self, other: &Path) -> bool {\n@@ -439,13 +446,13 @@ mod tests {\n         (s: $path:expr, $exp:expr) => (\n             {\n                 let path = $path;\n-                assert!(path.as_str() == Some($exp));\n+                assert_eq!(path.as_str(), Some($exp));\n             }\n         );\n         (v: $path:expr, $exp:expr) => (\n             {\n                 let path = $path;\n-                assert!(path.as_vec() == $exp);\n+                assert_eq!(path.as_vec(), $exp);\n             }\n         )\n     }\n@@ -459,7 +466,7 @@ mod tests {\n         t!(v: Path::new(b\"a/b/c\\xFF\"), b\"a/b/c\\xFF\");\n         t!(v: Path::new(b\"\\xFF/../foo\\x80\"), b\"foo\\x80\");\n         let p = Path::new(b\"a/b/c\\xFF\");\n-        assert!(p.as_str() == None);\n+        assert!(p.as_str().is_none());\n \n         t!(s: Path::new(\"\"), \".\");\n         t!(s: Path::new(\"/\"), \"/\");\n@@ -489,14 +496,14 @@ mod tests {\n                    b\"/bar\");\n \n         let p = Path::new(b\"foo/bar\\x80\");\n-        assert!(p.as_str() == None);\n+        assert!(p.as_str().is_none());\n     }\n \n     #[test]\n     fn test_opt_paths() {\n-        assert!(Path::new_opt(b\"foo/bar\\0\") == None);\n+        assert!(Path::new_opt(b\"foo/bar\\0\").is_none());\n         t!(v: Path::new_opt(b\"foo/bar\").unwrap(), b\"foo/bar\");\n-        assert!(Path::new_opt(\"foo/bar\\0\") == None);\n+        assert!(Path::new_opt(\"foo/bar\\0\").is_none());\n         t!(s: Path::new_opt(\"foo/bar\").unwrap(), \"foo/bar\");\n     }\n \n@@ -525,7 +532,7 @@ mod tests {\n             ($path:expr, $disp:ident, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n-                    assert!(path.$disp().to_string() == $exp);\n+                    assert_eq!(path.$disp().to_string(), $exp);\n                 }\n             )\n         }\n@@ -541,14 +548,14 @@ mod tests {\n                 {\n                     let path = Path::new($path);\n                     let mo = path.display().as_cow();\n-                    assert!(mo.as_slice() == $exp);\n+                    assert_eq!(mo.as_slice(), $exp);\n                 }\n             );\n             ($path:expr, $exp:expr, filename) => (\n                 {\n                     let path = Path::new($path);\n                     let mo = path.filename_display().as_cow();\n-                    assert!(mo.as_slice() == $exp);\n+                    assert_eq!(mo.as_slice(), $exp);\n                 }\n             )\n         }\n@@ -568,9 +575,9 @@ mod tests {\n                 {\n                     let path = Path::new($path);\n                     let f = format!(\"{}\", path.display());\n-                    assert!(f == $exp);\n+                    assert_eq!(f, $exp);\n                     let f = format!(\"{}\", path.filename_display());\n-                    assert!(f == $expf);\n+                    assert_eq!(f, $expf);\n                 }\n             )\n         }\n@@ -590,21 +597,21 @@ mod tests {\n             (s: $path:expr, $op:ident, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n-                    assert!(path.$op() == ($exp).as_bytes());\n+                    assert_eq!(path.$op(), ($exp).as_bytes());\n                 }\n             );\n             (s: $path:expr, $op:ident, $exp:expr, opt) => (\n                 {\n                     let path = Path::new($path);\n                     let left = path.$op().map(|x| str::from_utf8(x).unwrap());\n-                    assert!(left == $exp);\n+                    assert_eq!(left, $exp);\n                 }\n             );\n             (v: $path:expr, $op:ident, $exp:expr) => (\n                 {\n                     let arg = $path;\n                     let path = Path::new(arg);\n-                    assert!(path.$op() == $exp);\n+                    assert_eq!(path.$op(), $exp);\n                 }\n             );\n         }\n@@ -678,7 +685,7 @@ mod tests {\n                     let mut p1 = Path::new(path);\n                     let p2 = p1.clone();\n                     p1.push(join);\n-                    assert!(p1 == p2.join(join));\n+                    assert_eq!(p1, p2.join(join));\n                 }\n             )\n         }\n@@ -697,7 +704,7 @@ mod tests {\n                     let mut p = Path::new($path);\n                     let push = Path::new($push);\n                     p.push(&push);\n-                    assert!(p.as_str() == Some($exp));\n+                    assert_eq!(p.as_str(), Some($exp));\n                 }\n             )\n         }\n@@ -717,14 +724,14 @@ mod tests {\n                 {\n                     let mut p = Path::new($path);\n                     p.push_many(&$push);\n-                    assert!(p.as_str() == Some($exp));\n+                    assert_eq!(p.as_str(), Some($exp));\n                 }\n             );\n             (v: $path:expr, $push:expr, $exp:expr) => (\n                 {\n                     let mut p = Path::new($path);\n                     p.push_many(&$push);\n-                    assert!(p.as_vec() == $exp);\n+                    assert_eq!(p.as_vec(), $exp);\n                 }\n             )\n         }\n@@ -745,16 +752,16 @@ mod tests {\n                 {\n                     let mut p = Path::new($path);\n                     let result = p.pop();\n-                    assert!(p.as_str() == Some($left));\n-                    assert!(result == $right);\n+                    assert_eq!(p.as_str(), Some($left));\n+                    assert_eq!(result, $right);\n                 }\n             );\n             (b: $path:expr, $left:expr, $right:expr) => (\n                 {\n                     let mut p = Path::new($path);\n                     let result = p.pop();\n-                    assert!(p.as_vec() == $left);\n-                    assert!(result == $right);\n+                    assert_eq!(p.as_vec(), $left);\n+                    assert_eq!(result, $right);\n                 }\n             )\n         }\n@@ -777,8 +784,8 @@ mod tests {\n \n     #[test]\n     fn test_root_path() {\n-        assert!(Path::new(b\"a/b/c\").root_path() == None);\n-        assert!(Path::new(b\"/a/b/c\").root_path() == Some(Path::new(\"/\")));\n+        assert_eq!(Path::new(b\"a/b/c\").root_path(), None);\n+        assert_eq!(Path::new(b\"/a/b/c\").root_path(), Some(Path::new(\"/\")));\n     }\n \n     #[test]\n@@ -802,7 +809,7 @@ mod tests {\n                     let path = Path::new($path);\n                     let join = Path::new($join);\n                     let res = path.join(&join);\n-                    assert!(res.as_str() == Some($exp));\n+                    assert_eq!(res.as_str(), Some($exp));\n                 }\n             )\n         }\n@@ -822,14 +829,14 @@ mod tests {\n                 {\n                     let path = Path::new($path);\n                     let res = path.join_many(&$join);\n-                    assert!(res.as_str() == Some($exp));\n+                    assert_eq!(res.as_str(), Some($exp));\n                 }\n             );\n             (v: $path:expr, $join:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n                     let res = path.join_many(&$join);\n-                    assert!(res.as_vec() == $exp);\n+                    assert_eq!(res.as_vec(), $exp);\n                 }\n             )\n         }\n@@ -903,7 +910,7 @@ mod tests {\n                     let mut p1 = Path::new(path);\n                     p1.$set(arg);\n                     let p2 = Path::new(path);\n-                    assert!(p1 == p2.$with(arg));\n+                    assert_eq!(p1, p2.$with(arg));\n                 }\n             );\n             (v: $path:expr, $set:ident, $with:ident, $arg:expr) => (\n@@ -913,7 +920,7 @@ mod tests {\n                     let mut p1 = Path::new(path);\n                     p1.$set(arg);\n                     let p2 = Path::new(path);\n-                    assert!(p1 == p2.$with(arg));\n+                    assert_eq!(p1, p2.$with(arg));\n                 }\n             )\n         }\n@@ -943,31 +950,19 @@ mod tests {\n             (s: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n                 {\n                     let path = $path;\n-                    let filename = $filename;\n-                    assert!(path.filename_str() == filename,\n-                            \"{}.filename_str(): Expected `{}`, found {}\",\n-                            path.as_str().unwrap(), filename, path.filename_str());\n-                    let dirname = $dirname;\n-                    assert!(path.dirname_str() == dirname,\n-                            \"`{}`.dirname_str(): Expected `{}`, found `{}`\",\n-                            path.as_str().unwrap(), dirname, path.dirname_str());\n-                    let filestem = $filestem;\n-                    assert!(path.filestem_str() == filestem,\n-                            \"`{}`.filestem_str(): Expected `{}`, found `{}`\",\n-                            path.as_str().unwrap(), filestem, path.filestem_str());\n-                    let ext = $ext;\n-                    assert!(path.extension_str() == ext,\n-                            \"`{}`.extension_str(): Expected `{}`, found `{}`\",\n-                            path.as_str().unwrap(), ext, path.extension_str());\n-                }\n+                    assert_eq!(path.filename_str(), $filename);\n+                    assert_eq!(path.dirname_str(), $dirname);\n+                    assert_eq!(path.filestem_str(), $filestem);\n+                    assert_eq!(path.extension_str(), $ext);\n+               }\n             );\n             (v: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n                 {\n                     let path = $path;\n-                    assert!(path.filename() == $filename);\n-                    assert!(path.dirname() == $dirname);\n-                    assert!(path.filestem() == $filestem);\n-                    assert!(path.extension() == $ext);\n+                    assert_eq!(path.filename(), $filename);\n+                    assert_eq!(path.dirname(), $dirname);\n+                    assert_eq!(path.filestem(), $filestem);\n+                    assert_eq!(path.extension(), $ext);\n                 }\n             )\n         }\n@@ -1155,12 +1150,10 @@ mod tests {\n                     let comps = path.components().collect::<Vec<&[u8]>>();\n                     let exp: &[&str] = &$exp;\n                     let exps = exp.iter().map(|x| x.as_bytes()).collect::<Vec<&[u8]>>();\n-                    assert!(comps == exps, \"components: Expected {}, found {}\",\n-                            comps, exps);\n+                    assert_eq!(comps, exprs);\n                     let comps = path.components().rev().collect::<Vec<&[u8]>>();\n                     let exps = exps.into_iter().rev().collect::<Vec<&[u8]>>();\n-                    assert!(comps == exps, \"rev_components: Expected {}, found {}\",\n-                            comps, exps);\n+                    assert_eq!(comps, exps);\n                 }\n             );\n             (b: $arg:expr, [$($exp:expr),*]) => ("}, {"sha": "ff269b734765ae918afb47bff205188b3200177b", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 47, "deletions": 72, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -18,6 +18,7 @@ use ascii::AsciiExt;\n use char::CharExt;\n use clone::Clone;\n use cmp::{Ordering, Eq, Ord, PartialEq, PartialOrd};\n+use fmt;\n use hash;\n use io::Writer;\n use iter::{AdditiveIterator, Extend};\n@@ -84,6 +85,12 @@ pub struct Path {\n     sepidx: Option<uint> // index of the final separator in the non-prefix portion of repr\n }\n \n+impl fmt::Show for Path {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"Path {{ {} }}\", self.display())\n+    }\n+}\n+\n impl PartialEq for Path {\n     #[inline]\n     fn eq(&self, other: &Path) -> bool {\n@@ -1119,13 +1126,13 @@ mod tests {\n         (s: $path:expr, $exp:expr) => (\n             {\n                 let path = $path;\n-                assert!(path.as_str() == Some($exp));\n+                assert_eq!(path.as_str(), Some($exp));\n             }\n         );\n         (v: $path:expr, $exp:expr) => (\n             {\n                 let path = $path;\n-                assert!(path.as_vec() == $exp);\n+                assert_eq!(path.as_vec(), $exp);\n             }\n         )\n     }\n@@ -1138,8 +1145,7 @@ mod tests {\n                     let path = $path;\n                     let exp = $exp;\n                     let res = parse_prefix(path);\n-                    assert!(res == exp,\n-                            \"parse_prefix(\\\"{}\\\"): expected {}, found {}\", path, exp, res);\n+                    assert_eq!(res, exp);\n                 }\n             )\n         }\n@@ -1355,22 +1361,22 @@ mod tests {\n                 {\n                     let path = $path;\n                     let path = Path::new(path);\n-                    assert!(path.$op() == Some($exp));\n+                    assert_eq!(path.$op(), Some($exp));\n                 }\n             );\n             (s: $path:expr, $op:ident, $exp:expr, opt) => (\n                 {\n                     let path = $path;\n                     let path = Path::new(path);\n                     let left = path.$op();\n-                    assert!(left == $exp);\n+                    assert_eq!(left, $exp);\n                 }\n             );\n             (v: $path:expr, $op:ident, $exp:expr) => (\n                 {\n                     let path = $path;\n                     let path = Path::new(path);\n-                    assert!(path.$op() == $exp);\n+                    assert_eq!(path.$op(), $exp);\n                 }\n             )\n         }\n@@ -1481,7 +1487,7 @@ mod tests {\n                     let mut p1 = Path::new(path);\n                     let p2 = p1.clone();\n                     p1.push(join);\n-                    assert!(p1 == p2.join(join));\n+                    assert_eq!(p1, p2.join(join));\n                 }\n             )\n         }\n@@ -1495,9 +1501,9 @@ mod tests {\n \n         // we do want to check one odd case though to ensure the prefix is re-parsed\n         let mut p = Path::new(\"\\\\\\\\?\\\\C:\");\n-        assert!(prefix(&p) == Some(VerbatimPrefix(2)));\n+        assert_eq!(prefix(&p), Some(VerbatimPrefix(2)));\n         p.push(\"foo\");\n-        assert!(prefix(&p) == Some(VerbatimDiskPrefix));\n+        assert_eq!(prefix(&p), Some(VerbatimDiskPrefix));\n         assert_eq!(p.as_str(), Some(\"\\\\\\\\?\\\\C:\\\\foo\"));\n \n         // and another with verbatim non-normalized paths\n@@ -1596,18 +1602,16 @@ mod tests {\n                     let mut p = Path::new(pstr);\n                     let result = p.pop();\n                     let left = $left;\n-                    assert!(p.as_str() == Some(left),\n-                        \"`{}`.pop() failed; expected remainder `{}`, found `{}`\",\n-                        pstr, left, p.as_str().unwrap());\n-                    assert!(result == $right);\n+                    assert_eq!(p.as_str(), Some(left));\n+                    assert_eq!(result, $right);\n                 }\n             );\n             (b: $path:expr, $left:expr, $right:expr) => (\n                 {\n                     let mut p = Path::new($path);\n                     let result = p.pop();\n                     assert_eq!(p.as_vec(), $left);\n-                    assert!(result == $right);\n+                    assert_eq!(result, $right);\n                 }\n             )\n         }\n@@ -1650,16 +1654,16 @@ mod tests {\n \n     #[test]\n     fn test_root_path() {\n-        assert!(Path::new(\"a\\\\b\\\\c\").root_path() == None);\n-        assert!(Path::new(\"\\\\a\\\\b\\\\c\").root_path() == Some(Path::new(\"\\\\\")));\n-        assert!(Path::new(\"C:a\").root_path() == Some(Path::new(\"C:\")));\n-        assert!(Path::new(\"C:\\\\a\").root_path() == Some(Path::new(\"C:\\\\\")));\n-        assert!(Path::new(\"\\\\\\\\a\\\\b\\\\c\").root_path() == Some(Path::new(\"\\\\\\\\a\\\\b\")));\n-        assert!(Path::new(\"\\\\\\\\?\\\\a\\\\b\").root_path() == Some(Path::new(\"\\\\\\\\?\\\\a\")));\n-        assert!(Path::new(\"\\\\\\\\?\\\\C:\\\\a\").root_path() == Some(Path::new(\"\\\\\\\\?\\\\C:\\\\\")));\n-        assert!(Path::new(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\").root_path() ==\n+        assert_eq!(Path::new(\"a\\\\b\\\\c\").root_path(),  None);\n+        assert_eq!(Path::new(\"\\\\a\\\\b\\\\c\").root_path(), Some(Path::new(\"\\\\\")));\n+        assert_eq!(Path::new(\"C:a\").root_path(), Some(Path::new(\"C:\")));\n+        assert_eq!(Path::new(\"C:\\\\a\").root_path(), Some(Path::new(\"C:\\\\\")));\n+        assert_eq!(Path::new(\"\\\\\\\\a\\\\b\\\\c\").root_path(), Some(Path::new(\"\\\\\\\\a\\\\b\")));\n+        assert_eq!(Path::new(\"\\\\\\\\?\\\\a\\\\b\").root_path(), Some(Path::new(\"\\\\\\\\?\\\\a\")));\n+        assert_eq!(Path::new(\"\\\\\\\\?\\\\C:\\\\a\").root_path(), Some(Path::new(\"\\\\\\\\?\\\\C:\\\\\")));\n+        assert_eq!(Path::new(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\").root_path(),\n                 Some(Path::new(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\")));\n-        assert!(Path::new(\"\\\\\\\\.\\\\a\\\\b\").root_path() == Some(Path::new(\"\\\\\\\\.\\\\a\")));\n+        assert_eq!(Path::new(\"\\\\\\\\.\\\\a\\\\b\").root_path(), Some(Path::new(\"\\\\\\\\.\\\\a\")));\n     }\n \n     #[test]\n@@ -1737,9 +1741,7 @@ mod tests {\n                     let arg = $arg;\n                     let res = path.$op(arg);\n                     let exp = $res;\n-                    assert!(res.as_str() == Some(exp),\n-                            \"`{}`.{}(\\\"{}\\\"): Expected `{}`, found `{}`\",\n-                            pstr, stringify!($op), arg, exp, res.as_str().unwrap());\n+                    assert_eq!(Path::new($path).$op($arg), $res);\n                 }\n             )\n         }\n@@ -1822,7 +1824,7 @@ mod tests {\n                     let mut p1 = Path::new(path);\n                     p1.$set(arg);\n                     let p2 = Path::new(path);\n-                    assert!(p1 == p2.$with(arg));\n+                    assert_eq!(p1, p2.$with(arg));\n                 }\n             );\n             (v: $path:expr, $set:ident, $with:ident, $arg:expr) => (\n@@ -1832,7 +1834,7 @@ mod tests {\n                     let mut p1 = Path::new(path);\n                     p1.$set(arg);\n                     let p2 = Path::new(path);\n-                    assert!(p1 == p2.$with(arg));\n+                    assert_eq!(p1, p2.$with(arg));\n                 }\n             )\n         }\n@@ -1863,31 +1865,19 @@ mod tests {\n             (s: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n                 {\n                     let path = $path;\n-                    let filename = $filename;\n-                    assert!(path.filename_str() == filename,\n-                            \"`{}`.filename_str(): Expected `{}`, found `{}`\",\n-                            path.as_str().unwrap(), filename, path.filename_str());\n-                    let dirname = $dirname;\n-                    assert!(path.dirname_str() == dirname,\n-                            \"`{}`.dirname_str(): Expected `{}`, found `{}`\",\n-                            path.as_str().unwrap(), dirname, path.dirname_str());\n-                    let filestem = $filestem;\n-                    assert!(path.filestem_str() == filestem,\n-                            \"`{}`.filestem_str(): Expected `{}`, found `{}`\",\n-                            path.as_str().unwrap(), filestem, path.filestem_str());\n-                    let ext = $ext;\n-                    assert!(path.extension_str() == ext,\n-                            \"`{}`.extension_str(): Expected `{}`, found `{}`\",\n-                            path.as_str().unwrap(), ext, path.extension_str());\n+                    assert_eq!(path.filename_str(), $filename);\n+                    assert_eq!(path.dirname_str(), $dirname);\n+                    assert_eq!(path.filestem_str(), $filestem);\n+                    assert_eq!(path.extension_str(), $ext);\n                 }\n             );\n             (v: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n                 {\n                     let path = $path;\n-                    assert!(path.filename() == $filename);\n-                    assert!(path.dirname() == $dirname);\n-                    assert!(path.filestem() == $filestem);\n-                    assert!(path.extension() == $ext);\n+                    assert_eq!(path.filename(), $filename);\n+                    assert_eq!(path.dirname(), $dirname);\n+                    assert_eq!(path.filestem(), $filestem);\n+                    assert_eq!(path.extension(), $ext);\n                 }\n             )\n         }\n@@ -1931,17 +1921,10 @@ mod tests {\n                     let path = Path::new($path);\n                     let (abs, vol, cwd, rel) = ($abs, $vol, $cwd, $rel);\n                     let b = path.is_absolute();\n-                    assert!(b == abs, \"Path '{}'.is_absolute(): expected {}, found {}\",\n-                            path.as_str().unwrap(), abs, b);\n-                    let b = is_vol_relative(&path);\n-                    assert!(b == vol, \"is_vol_relative('{}'): expected {}, found {}\",\n-                            path.as_str().unwrap(), vol, b);\n-                    let b = is_cwd_relative(&path);\n-                    assert!(b == cwd, \"is_cwd_relative('{}'): expected {}, found {}\",\n-                            path.as_str().unwrap(), cwd, b);\n-                    let b = path.is_relative();\n-                    assert!(b == rel, \"Path '{}'.is_relativf(): expected {}, found {}\",\n-                            path.as_str().unwrap(), rel, b);\n+                    assert_eq!(path.is_absolute(), asb);\n+                    assert_eq!(is_vol_relative(&path), vol);\n+                    assert_eq!(is_cwd_relative(&path), cwd);\n+                    assert_eq!(path.is_relative(), rel);\n                 }\n             )\n         }\n@@ -1972,9 +1955,7 @@ mod tests {\n                     let dest = Path::new($dest);\n                     let exp = $exp;\n                     let res = path.is_ancestor_of(&dest);\n-                    assert!(res == exp,\n-                            \"`{}`.is_ancestor_of(`{}`): Expected {}, found {}\",\n-                            path.as_str().unwrap(), dest.as_str().unwrap(), exp, res);\n+                    assert_eq!(Path::new($path).is_ancestor_of(Path::new($dest)), $exp);\n                 }\n             )\n         }\n@@ -2103,14 +2084,8 @@ mod tests {\n         macro_rules! t {\n             (s: $path:expr, $other:expr, $exp:expr) => (\n                 {\n-                    let path = Path::new($path);\n-                    let other = Path::new($other);\n-                    let res = path.path_relative_from(&other);\n-                    let exp = $exp;\n-                    assert!(res.as_ref().and_then(|x| x.as_str()) == exp,\n-                            \"`{}`.path_relative_from(`{}`): Expected {}, got {}\",\n-                            path.as_str().unwrap(), other.as_str().unwrap(), exp,\n-                            res.as_ref().and_then(|x| x.as_str()));\n+                    assert_eq!(Path::new($path).path_relative_from(Path::new($other))\n+                              .as_ref().and_then(|x| x.as_str()), $exp);\n                 }\n             )\n         }\n@@ -2319,7 +2294,7 @@ mod tests {\n                     let path = Path::new($path);\n                     let exp: Option<&str> = $exp;\n                     let exp = exp.map(|s| Path::new(s));\n-                    assert!(make_non_verbatim(&path) == exp);\n+                    assert_eq!(make_non_verbatim(&path), exp);\n                 }\n             )\n         }"}, {"sha": "fc257b12bb6a2468637c84e5e59ea5311c102b52", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -303,7 +303,7 @@ impl<'a> SeedableRng<&'a [uint]> for StdRng {\n pub fn weak_rng() -> XorShiftRng {\n     match OsRng::new() {\n         Ok(mut r) => r.gen(),\n-        Err(e) => panic!(\"weak_rng: failed to create seeded RNG: {}\", e)\n+        Err(e) => panic!(\"weak_rng: failed to create seeded RNG: {:?}\", e)\n     }\n }\n \n@@ -490,7 +490,7 @@ mod test {\n         let mut r = thread_rng();\n         let a = r.gen::<f64>();\n         let b = r.gen::<f64>();\n-        debug!(\"{}\", (a, b));\n+        debug!(\"{:?}\", (a, b));\n     }\n \n     #[test]"}, {"sha": "177b7380831f2d450c4904c67aef7711c408385c", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -67,7 +67,7 @@ impl<R: Reader> Rng for ReaderRng<R> {\n         if v.len() == 0 { return }\n         match self.reader.read_at_least(v.len(), v) {\n             Ok(_) => {}\n-            Err(e) => panic!(\"ReaderRng.fill_bytes error: {}\", e)\n+            Err(e) => panic!(\"ReaderRng.fill_bytes error: {:?}\", e)\n         }\n     }\n }"}, {"sha": "7164931c55acd0fea51d1ae90705753707282380", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -370,7 +370,7 @@ fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n // Finally, after all that work above, we can emit a symbol.\n fn output(w: &mut Writer, idx: int, addr: *mut libc::c_void,\n           s: Option<&[u8]>) -> IoResult<()> {\n-    try!(write!(w, \"  {:2}: {:2$} - \", idx, addr, HEX_WIDTH));\n+    try!(write!(w, \"  {:2}: {:2$?} - \", idx, addr, HEX_WIDTH));\n     match s.and_then(|s| str::from_utf8(s).ok()) {\n         Some(string) => try!(demangle(w, string)),\n         None => try!(write!(w, \"<unknown>\")),"}, {"sha": "c53f9d22790dd44de154e192b33d872bbd287ec6", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -381,7 +381,7 @@ mod tests {\n                 assert_eq!(buf[2], 's' as u8);\n                 assert_eq!(buf[3], 't' as u8);\n             }\n-            r => panic!(\"invalid read: {}\", r),\n+            r => panic!(\"invalid read: {:?}\", r),\n         }\n \n         assert!(writer.read(&mut buf).is_err());"}, {"sha": "1357bbdd5a3710dfb8fb7e3e126909ffdafc71f3", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -125,15 +125,15 @@ impl Process {\n                     return match input.read(&mut bytes) {\n                         Ok(8) => {\n                             assert!(combine(CLOEXEC_MSG_FOOTER) == combine(bytes.slice(4, 8)),\n-                                \"Validation on the CLOEXEC pipe failed: {}\", bytes);\n+                                \"Validation on the CLOEXEC pipe failed: {:?}\", bytes);\n                             let errno = combine(bytes.slice(0, 4));\n                             assert!(p.wait(0).is_ok(), \"wait(0) should either return Ok or panic\");\n                             Err(super::decode_error(errno))\n                         }\n                         Err(ref e) if e.kind == EndOfFile => Ok(p),\n                         Err(e) => {\n                             assert!(p.wait(0).is_ok(), \"wait(0) should either return Ok or panic\");\n-                            panic!(\"the CLOEXEC pipe failed: {}\", e)\n+                            panic!(\"the CLOEXEC pipe failed: {:?}\", e)\n                         },\n                         Ok(..) => { // pipe I/O up to PIPE_BUF bytes should be atomic\n                             assert!(p.wait(0).is_ok(), \"wait(0) should either return Ok or panic\");\n@@ -285,7 +285,7 @@ impl Process {\n         let mut status = 0 as c_int;\n         if deadline == 0 {\n             return match retry(|| unsafe { c::waitpid(self.pid, &mut status, 0) }) {\n-                -1 => panic!(\"unknown waitpid error: {}\", super::last_error()),\n+                -1 => panic!(\"unknown waitpid error: {:?}\", super::last_error()),\n                 _ => Ok(translate_status(status)),\n             }\n         }\n@@ -410,7 +410,7 @@ impl Process {\n                         continue\n                     }\n \n-                    n => panic!(\"error in select {} ({})\", os::errno(), n),\n+                    n => panic!(\"error in select {:?} ({:?})\", os::errno(), n),\n                 }\n \n                 // Process any pending messages\n@@ -491,7 +491,7 @@ impl Process {\n                     n if n > 0 => { ret = true; }\n                     0 => return true,\n                     -1 if wouldblock() => return ret,\n-                    n => panic!(\"bad read {} ({})\", os::last_os_error(), n),\n+                    n => panic!(\"bad read {:?} ({:?})\", os::last_os_error(), n),\n                 }\n             }\n         }\n@@ -514,7 +514,7 @@ impl Process {\n             } {\n                 1 => {}\n                 -1 if wouldblock() => {} // see above comments\n-                n => panic!(\"bad error on write fd: {} {}\", n, os::errno()),\n+                n => panic!(\"bad error on write fd: {:?} {:?}\", n, os::errno()),\n             }\n         }\n     }\n@@ -526,7 +526,7 @@ impl Process {\n         }) {\n             n if n == self.pid => Some(translate_status(status)),\n             0 => None,\n-            n => panic!(\"unknown waitpid error `{}`: {}\", n,\n+            n => panic!(\"unknown waitpid error `{:?}`: {:?}\", n,\n                        super::last_error()),\n         }\n     }"}, {"sha": "9bd6f78300e76fd6670e20443c5cddfbc3b909df", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -48,7 +48,7 @@ macro_rules! try_opt {\n \n /// ISO 8601 time duration with nanosecond precision.\n /// This also allows for the negative duration; see individual methods for details.\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Show)]\n pub struct Duration {\n     secs: i64,\n     nanos: i32, // Always 0 <= nanos < NANOS_PER_SEC\n@@ -337,7 +337,7 @@ impl Div<i32> for Duration {\n     }\n }\n \n-impl fmt::Show for Duration {\n+impl fmt::String for Duration {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // technically speaking, negative duration is not valid ISO 8601,\n         // but we need to print it anyway."}, {"sha": "09235ee209c46e4eb67efa49cfe33f0c62e2af51", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -47,7 +47,7 @@ pub enum Abi {\n }\n \n #[allow(non_camel_case_types)]\n-#[derive(Copy, PartialEq)]\n+#[derive(Copy, PartialEq, Show)]\n pub enum Architecture {\n     X86,\n     X86_64,\n@@ -120,12 +120,24 @@ impl Abi {\n }\n \n impl fmt::Show for Abi {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for Abi {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"\\\"{}\\\"\", self.name())\n     }\n }\n \n impl fmt::Show for Os {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for Os {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             OsLinux => \"linux\".fmt(f),"}, {"sha": "10cdea791b805a2debefe21e723e273dc8c5b682", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 55, "deletions": 12, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -100,13 +100,26 @@ impl Ident {\n     }\n }\n \n-impl Show for Ident {\n+//NOTE(stage0): remove after snapshot\n+impl fmt::Show for Ident {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for Ident {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}#{}\", self.name, self.ctxt)\n     }\n }\n \n-impl Show for Name {\n+impl fmt::Show for Name {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for Name {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let Name(nm) = *self;\n         write!(f, \"\\\"{}\\\"({})\", token::get_name(*self).get(), nm)\n@@ -1094,7 +1107,14 @@ pub enum IntTy {\n     TyI64,\n }\n \n+//NOTE(stage0): remove after snapshot\n impl fmt::Show for IntTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for IntTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}\", ast_util::int_ty_to_string(*self, None))\n     }\n@@ -1129,7 +1149,14 @@ impl UintTy {\n     }\n }\n \n+//NOTE(stage0): remove after snapshot\n impl fmt::Show for UintTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for UintTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}\", ast_util::uint_ty_to_string(*self, None))\n     }\n@@ -1141,7 +1168,14 @@ pub enum FloatTy {\n     TyF64,\n }\n \n+//NOTE(stage0): remove after snapshot\n impl fmt::Show for FloatTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for FloatTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}\", ast_util::float_ty_to_string(*self))\n     }\n@@ -1192,10 +1226,19 @@ pub enum Onceness {\n \n impl fmt::Show for Onceness {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            Once => \"once\".fmt(f),\n-            Many => \"many\".fmt(f),\n-        }\n+        fmt::String::fmt(match *self {\n+            Once => \"once\",\n+            Many => \"many\",\n+        }, f)\n+    }\n+}\n+\n+impl fmt::String for Onceness {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(match *self {\n+            Once => \"once\",\n+            Many => \"many\",\n+        }, f)\n     }\n }\n \n@@ -1305,18 +1348,18 @@ pub struct FnDecl {\n     pub variadic: bool\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n pub enum Unsafety {\n     Unsafe,\n     Normal,\n }\n \n-impl fmt::Show for Unsafety {\n+impl fmt::String for Unsafety {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            Unsafety::Normal => \"normal\".fmt(f),\n-            Unsafety::Unsafe => \"unsafe\".fmt(f),\n-        }\n+        fmt::String::fmt(match *self {\n+            Unsafety::Normal => \"normal\",\n+            Unsafety::Unsafe => \"unsafe\",\n+        }, f)\n     }\n }\n "}, {"sha": "7496a0f9f26db1a5097eaa99aeb9db15bf48d744", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -46,7 +46,14 @@ impl PathElem {\n     }\n }\n \n+//NOTE(stage0): replace with deriving(Show) after snapshot\n impl fmt::Show for PathElem {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for PathElem {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let slot = token::get_name(self.name());\n         write!(f, \"{}\", slot)\n@@ -396,7 +403,7 @@ impl<'ast> Map<'ast> {\n                                 PathName(ident.name)\n                             }\n                             MethMac(_) => {\n-                                panic!(\"no path elem for {}\", node)\n+                                panic!(\"no path elem for {:?}\", node)\n                             }\n                         }\n                     }\n@@ -410,15 +417,15 @@ impl<'ast> Map<'ast> {\n                         MethDecl(ident, _, _, _, _, _, _, _) => {\n                             PathName(ident.name)\n                         }\n-                        MethMac(_) => panic!(\"no path elem for {}\", node),\n+                        MethMac(_) => panic!(\"no path elem for {:?}\", node),\n                     }\n                 }\n                 TypeTraitItem(ref m) => {\n                     PathName(m.ty_param.ident.name)\n                 }\n             },\n             NodeVariant(v) => PathName(v.node.name.name),\n-            _ => panic!(\"no path elem for {}\", node)\n+            _ => panic!(\"no path elem for {:?}\", node)\n         }\n     }\n \n@@ -549,7 +556,7 @@ impl<'ast> Map<'ast> {\n \n     pub fn span(&self, id: NodeId) -> Span {\n         self.opt_span(id)\n-            .unwrap_or_else(|| panic!(\"AstMap.span: could not find span for id {}\", id))\n+            .unwrap_or_else(|| panic!(\"AstMap.span: could not find span for id {:?}\", id))\n     }\n \n     pub fn def_id_span(&self, def_id: DefId, fallback: Span) -> Span {\n@@ -729,7 +736,7 @@ struct NodeCollector<'ast> {\n \n impl<'ast> NodeCollector<'ast> {\n     fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'ast>) {\n-        debug!(\"ast_map: {} => {}\", id, entry);\n+        debug!(\"ast_map: {:?} => {:?}\", id, entry);\n         let len = self.map.len();\n         if id as uint >= len {\n             self.map.extend(repeat(NotPresent).take(id as uint - len + 1));"}, {"sha": "416fc8c2278a0947cbd03d76f934e8b888048ffa", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -28,6 +28,7 @@ use ptr::P;\n use std::cell::{RefCell, Cell};\n use std::collections::BitvSet;\n use std::collections::HashSet;\n+use std::fmt;\n \n thread_local! { static USED_ATTRS: RefCell<BitvSet> = RefCell::new(BitvSet::new()) }\n \n@@ -357,6 +358,12 @@ pub enum StabilityLevel {\n     Locked\n }\n \n+impl fmt::String for StabilityLevel {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Show::fmt(self, f)\n+    }\n+}\n+\n pub fn find_stability_generic<'a,\n                               AM: AttrMetaMethods,\n                               I: Iterator<Item=&'a AM>>"}, {"sha": "04753bdf65298b5b854b54c5c5c7aec68ccaadcd", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -488,7 +488,7 @@ impl CodeMap {\n         let mut total_extra_bytes = 0;\n \n         for mbc in map.multibyte_chars.borrow().iter() {\n-            debug!(\"{}-byte char at {}\", mbc.bytes, mbc.pos);\n+            debug!(\"{}-byte char at {:?}\", mbc.bytes, mbc.pos);\n             if mbc.pos < bpos {\n                 // every character is at least one byte, so we only\n                 // count the actual extra bytes.\n@@ -566,9 +566,9 @@ impl CodeMap {\n         let chpos = self.bytepos_to_file_charpos(pos);\n         let linebpos = (*f.lines.borrow())[a];\n         let linechpos = self.bytepos_to_file_charpos(linebpos);\n-        debug!(\"byte pos {} is on the line at byte pos {}\",\n+        debug!(\"byte pos {:?} is on the line at byte pos {:?}\",\n                pos, linebpos);\n-        debug!(\"char pos {} is on the line at char pos {}\",\n+        debug!(\"char pos {:?} is on the line at char pos {:?}\",\n                chpos, linechpos);\n         debug!(\"byte is on line: {}\", line);\n         assert!(chpos >= linechpos);"}, {"sha": "fde2fdb3c558c476a84d835664fc5d2462074007", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -222,7 +222,7 @@ pub fn mk_handler(e: Box<Emitter + Send>) -> Handler {\n     }\n }\n \n-#[derive(Copy, PartialEq, Clone)]\n+#[derive(Copy, PartialEq, Clone, Show)]\n pub enum Level {\n     Bug,\n     Fatal,\n@@ -232,9 +232,9 @@ pub enum Level {\n     Help,\n }\n \n-impl fmt::Show for Level {\n+impl fmt::String for Level {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        use std::fmt::Show;\n+        use std::fmt::String;\n \n         match *self {\n             Bug => \"error: internal compiler error\".fmt(f),\n@@ -374,15 +374,15 @@ impl Emitter for EmitterWriter {\n \n         match error {\n             Ok(()) => {}\n-            Err(e) => panic!(\"failed to print diagnostics: {}\", e),\n+            Err(e) => panic!(\"failed to print diagnostics: {:?}\", e),\n         }\n     }\n \n     fn custom_emit(&mut self, cm: &codemap::CodeMap,\n                    sp: RenderSpan, msg: &str, lvl: Level) {\n         match emit(self, cm, sp, msg, None, lvl, true) {\n             Ok(()) => {}\n-            Err(e) => panic!(\"failed to print diagnostics: {}\", e),\n+            Err(e) => panic!(\"failed to print diagnostics: {:?}\", e),\n         }\n     }\n }"}, {"sha": "fa9a7899a1228ec94b5e454ea14f94d6ffc791f6", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -90,7 +90,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n                 for (i, field) in fields.iter().enumerate() {\n                     if i != 0 { format_string.push_str(\", \"); }\n \n-                    format_string.push_str(\"{}\");\n+                    format_string.push_str(\"{:?}\");\n \n                     exprs.push(field.self_.clone());\n                 }\n@@ -107,7 +107,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n                     let name = token::get_ident(field.name.unwrap());\n                     format_string.push_str(\" \");\n                     format_string.push_str(name.get());\n-                    format_string.push_str(\": {}\");\n+                    format_string.push_str(\": {:?}\");\n \n                     exprs.push(field.self_.clone());\n                 }"}, {"sha": "3e1bccf394aa0cea398265d75fc73a4547c294cc", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -36,7 +36,7 @@ pub fn expand_type(t: P<ast::Ty>,\n                    fld: &mut MacroExpander,\n                    impl_ty: Option<P<ast::Ty>>)\n                    -> P<ast::Ty> {\n-    debug!(\"expanding type {} with impl_ty {}\", t, impl_ty);\n+    debug!(\"expanding type {:?} with impl_ty {:?}\", t, impl_ty);\n     let t = match (t.node.clone(), impl_ty) {\n         // Expand uses of `Self` in impls to the concrete type.\n         (ast::Ty_::TyPath(ref path, _), Some(ref impl_ty)) => {"}, {"sha": "44a596d2657ef28214b99924540e06dd7f7dd8ed", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -607,7 +607,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         let trait_ = match *ty {\n             Known(ref tyname) => {\n                 match tyname.index(&FullRange) {\n-                    \"\"  => \"Show\",\n+                    \"\"  => \"String\",\n                     \"?\" => \"Show\",\n                     \"e\" => \"LowerExp\",\n                     \"E\" => \"UpperExp\","}, {"sha": "d7d768a007e75f1d200b0862a4b3da5f595209d6", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -121,7 +121,7 @@ fn new_sctable_internal() -> SCTable {\n pub fn display_sctable(table: &SCTable) {\n     error!(\"SC table:\");\n     for (idx,val) in table.table.borrow().iter().enumerate() {\n-        error!(\"{:4} : {}\",idx,val);\n+        error!(\"{:4} : {:?}\",idx,val);\n     }\n }\n "}, {"sha": "1ba91dd371c60ed39b2cab2205e2925effa71848", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -135,7 +135,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     let bytes = match File::open(&file).read_to_end() {\n         Err(e) => {\n             cx.span_err(sp,\n-                        format!(\"couldn't read {}: {}\",\n+                        format!(\"couldn't read {:?}: {}\",\n                                 file.display(),\n                                 e).index(&FullRange));\n             return DummyResult::expr(sp);\n@@ -146,15 +146,15 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         Ok(src) => {\n             // Add this input file to the code map to make it available as\n             // dependency information\n-            let filename = file.display().to_string();\n+            let filename = format!(\"{:?}\", file.display());\n             let interned = token::intern_and_get_ident(src.index(&FullRange));\n             cx.codemap().new_filemap(filename, src);\n \n             base::MacExpr::new(cx.expr_str(sp, interned))\n         }\n         Err(_) => {\n             cx.span_err(sp,\n-                        format!(\"{} wasn't a utf-8 file\",\n+                        format!(\"{:?} wasn't a utf-8 file\",\n                                 file.display()).index(&FullRange));\n             return DummyResult::expr(sp);\n         }\n@@ -177,7 +177,7 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     match File::open(&file).read_to_end() {\n         Err(e) => {\n             cx.span_err(sp,\n-                        format!(\"couldn't read {}: {}\", file.display(), e).index(&FullRange));\n+                        format!(\"couldn't read {:?}: {}\", file.display(), e).index(&FullRange));\n             return DummyResult::expr(sp);\n         }\n         Ok(bytes) => {"}, {"sha": "b3bb5cdd897f2a170d8b34eb258d05988325c010", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -128,7 +128,7 @@ impl Add for LockstepIterSize {\n                     let l_n = token::get_ident(l_id.clone());\n                     let r_n = token::get_ident(r_id);\n                     LisContradiction(format!(\"inconsistent lockstep iteration: \\\n-                                              '{}' has {} items, but '{}' has {}\",\n+                                              '{:?}' has {} items, but '{:?}' has {}\",\n                                               l_n, l_len, r_n, r_len).to_string())\n                 }\n             },\n@@ -296,7 +296,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                             MatchedSeq(..) => {\n                                 r.sp_diag.span_fatal(\n                                     r.cur_span, /* blame the macro writer */\n-                                    format!(\"variable '{}' is still repeating at this depth\",\n+                                    format!(\"variable '{:?}' is still repeating at this depth\",\n                                             token::get_ident(ident)).index(&FullRange));\n                             }\n                         }"}, {"sha": "4aad7f911dbb7a40f5506c72fdd2c47f8734413a", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -32,7 +32,7 @@ impl<'a> ParserAttr for Parser<'a> {\n     fn parse_outer_attributes(&mut self) -> Vec<ast::Attribute> {\n         let mut attrs: Vec<ast::Attribute> = Vec::new();\n         loop {\n-            debug!(\"parse_outer_attributes: self.token={}\",\n+            debug!(\"parse_outer_attributes: self.token={:?}\",\n                    self.token);\n             match self.token {\n               token::Pound => {\n@@ -62,7 +62,7 @@ impl<'a> ParserAttr for Parser<'a> {\n     /// If permit_inner is true, then a leading `!` indicates an inner\n     /// attribute\n     fn parse_attribute(&mut self, permit_inner: bool) -> ast::Attribute {\n-        debug!(\"parse_attributes: permit_inner={} self.token={}\",\n+        debug!(\"parse_attributes: permit_inner={:?} self.token={:?}\",\n                permit_inner, self.token);\n         let (span, value, mut style) = match self.token {\n             token::Pound => {"}, {"sha": "e6331cc085b6422b525326fd19d288e74ed8a546", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -111,7 +111,7 @@ impl<'a> Reader for TtReader<'a> {\n     }\n     fn next_token(&mut self) -> TokenAndSpan {\n         let r = tt_next_token(self);\n-        debug!(\"TtReader: r={}\", r);\n+        debug!(\"TtReader: r={:?}\", r);\n         r\n     }\n     fn fatal(&self, m: &str) -> ! {\n@@ -256,13 +256,13 @@ impl<'a> StringReader<'a> {\n     /// adjusted 1 towards each other (assumes that on either side there is a\n     /// single-byte delimiter).\n     pub fn name_from(&self, start: BytePos) -> ast::Name {\n-        debug!(\"taking an ident from {} to {}\", start, self.last_pos);\n+        debug!(\"taking an ident from {:?} to {:?}\", start, self.last_pos);\n         self.with_str_from(start, token::intern)\n     }\n \n     /// As name_from, with an explicit endpoint.\n     pub fn name_from_to(&self, start: BytePos, end: BytePos) -> ast::Name {\n-        debug!(\"taking an ident from {} to {}\", start, end);\n+        debug!(\"taking an ident from {:?} to {:?}\", start, end);\n         self.with_str_from_to(start, end, token::intern)\n     }\n \n@@ -496,7 +496,7 @@ impl<'a> StringReader<'a> {\n             // for skipping over all \"junk\"\n             '/' | '#' => {\n                 let c = self.scan_comment();\n-                debug!(\"scanning a comment {}\", c);\n+                debug!(\"scanning a comment {:?}\", c);\n                 c\n             },\n             c if is_whitespace(Some(c)) => {\n@@ -506,7 +506,7 @@ impl<'a> StringReader<'a> {\n                     tok: token::Whitespace,\n                     sp: codemap::mk_sp(start_bpos, self.last_pos)\n                 });\n-                debug!(\"scanning whitespace: {}\", c);\n+                debug!(\"scanning whitespace: {:?}\", c);\n                 c\n             },\n             _ => None\n@@ -592,8 +592,8 @@ impl<'a> StringReader<'a> {\n                                                whence: &str) {\n             match r.curr {\n                 Some(r_c) if r_c == c => r.bump(),\n-                Some(r_c) => panic!(\"expected {}, hit {}, {}\", described_c, r_c, whence),\n-                None      => panic!(\"expected {}, hit EOF, {}\", described_c, whence),\n+                Some(r_c) => panic!(\"expected {:?}, hit {:?}, {}\", described_c, r_c, whence),\n+                None      => panic!(\"expected {:?}, hit EOF, {}\", described_c, whence),\n             }\n         }\n \n@@ -614,7 +614,7 @@ impl<'a> StringReader<'a> {\n         self.scan_digits(base);\n         let encoded_name : u32 = self.with_str_from(start_bpos, |s| {\n             num::from_str_radix(s, 10).unwrap_or_else(|| {\n-                panic!(\"expected digits representing a name, got `{}`, {}, range [{},{}]\",\n+                panic!(\"expected digits representing a name, got {:?}, {}, range [{:?},{:?}]\",\n                       s, whence, start_bpos, self.last_pos);\n             })\n         });\n@@ -632,7 +632,7 @@ impl<'a> StringReader<'a> {\n         self.scan_digits(base);\n         let encoded_ctxt : ast::SyntaxContext = self.with_str_from(start_bpos, |s| {\n             num::from_str_radix(s, 10).unwrap_or_else(|| {\n-                panic!(\"expected digits representing a ctxt, got `{}`, {}\", s, whence);\n+                panic!(\"expected digits representing a ctxt, got {:?}, {}\", s, whence);\n             })\n         });\n \n@@ -652,7 +652,7 @@ impl<'a> StringReader<'a> {\n             if c == Some('_') { debug!(\"skipping a _\"); self.bump(); continue; }\n             match c.and_then(|cc| cc.to_digit(radix)) {\n                 Some(_) => {\n-                    debug!(\"{} in scan_digits\", c);\n+                    debug!(\"{:?} in scan_digits\", c);\n                     len += 1;\n                     self.bump();\n                 }\n@@ -728,7 +728,7 @@ impl<'a> StringReader<'a> {\n                        delim: char,\n                        below_0x7f_only: bool)\n                        -> bool {\n-        debug!(\"scanning {} digits until {}\", n_digits, delim);\n+        debug!(\"scanning {} digits until {:?}\", n_digits, delim);\n         let start_bpos = self.last_pos;\n         let mut accum_int = 0;\n \n@@ -990,7 +990,7 @@ impl<'a> StringReader<'a> {\n         if is_dec_digit(c) {\n             let num = self.scan_number(c.unwrap());\n             let suffix = self.scan_optional_raw_name();\n-            debug!(\"next_token_inner: scanned number {}, {}\", num, suffix);\n+            debug!(\"next_token_inner: scanned number {:?}, {:?}\", num, suffix);\n             return token::Literal(num, suffix)\n         }\n \n@@ -1444,14 +1444,14 @@ fn is_dec_digit(c: Option<char>) -> bool { return in_range(c, '0', '9'); }\n pub fn is_doc_comment(s: &str) -> bool {\n     let res = (s.starts_with(\"///\") && *s.as_bytes().get(3).unwrap_or(&b' ') != b'/')\n               || s.starts_with(\"//!\");\n-    debug!(\"is `{}` a doc comment? {}\", s, res);\n+    debug!(\"is {:?} a doc comment? {}\", s, res);\n     res\n }\n \n pub fn is_block_doc_comment(s: &str) -> bool {\n     let res = (s.starts_with(\"/**\") && *s.as_bytes().get(3).unwrap_or(&b' ') != b'*')\n               || s.starts_with(\"/*!\");\n-    debug!(\"is `{}` a doc comment? {}\", s, res);\n+    debug!(\"is {:?} a doc comment? {}\", s, res);\n     res\n }\n "}, {"sha": "82e2c8136a46ea64382633eaefae6ccb94f2f90b", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -254,7 +254,7 @@ pub fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n     let bytes = match File::open(path).read_to_end() {\n         Ok(bytes) => bytes,\n         Err(e) => {\n-            err(format!(\"couldn't read {}: {}\",\n+            err(format!(\"couldn't read {:?}: {:?}\",\n                         path.display(),\n                         e).index(&FullRange));\n             unreachable!()\n@@ -266,7 +266,7 @@ pub fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n                                      path.as_str().unwrap().to_string())\n         }\n         None => {\n-            err(format!(\"{} is not UTF-8 encoded\", path.display()).index(&FullRange))\n+            err(format!(\"{:?} is not UTF-8 encoded\", path.display()).index(&FullRange))\n         }\n     }\n     unreachable!()\n@@ -539,7 +539,7 @@ fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n \n fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n                       sd: &SpanHandler, sp: Span) -> ast::Lit_ {\n-    debug!(\"filtered_float_lit: {}, {}\", data, suffix);\n+    debug!(\"filtered_float_lit: {}, {:?}\", data, suffix);\n     match suffix {\n         Some(\"f32\") => ast::LitFloat(data, ast::TyF32),\n         Some(\"f64\") => ast::LitFloat(data, ast::TyF64),\n@@ -559,7 +559,7 @@ fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n     }\n }\n pub fn float_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) -> ast::Lit_ {\n-    debug!(\"float_lit: {}, {}\", s, suffix);\n+    debug!(\"float_lit: {:?}, {:?}\", s, suffix);\n     // FIXME #2252: bounds checking float literals is defered until trans\n     let s = s.chars().filter(|&c| c != '_').collect::<String>();\n     let data = token::intern_and_get_ident(&*s);\n@@ -664,7 +664,7 @@ pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) ->\n     let s2 = s.chars().filter(|&c| c != '_').collect::<String>();\n     let mut s = s2.index(&FullRange);\n \n-    debug!(\"integer_lit: {}, {}\", s, suffix);\n+    debug!(\"integer_lit: {}, {:?}\", s, suffix);\n \n     let mut base = 10;\n     let orig = s;\n@@ -729,8 +729,8 @@ pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) ->\n         }\n     }\n \n-    debug!(\"integer_lit: the type is {}, base {}, the new string is {}, the original \\\n-           string was {}, the original suffix was {}\", ty, base, s, orig, suffix);\n+    debug!(\"integer_lit: the type is {:?}, base {:?}, the new string is {:?}, the original \\\n+           string was {:?}, the original suffix was {:?}\", ty, base, s, orig, suffix);\n \n     let res: u64 = match ::std::num::from_str_radix(s, base) {\n         Some(r) => r,"}, {"sha": "7d7e10e181e332a4a528b364b8fe6d20a60dd8b1", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -488,7 +488,7 @@ impl<'a> Parser<'a> {\n     /// followed by some token from the set edible + inedible.  Recover\n     /// from anticipated input errors, discarding erroneous characters.\n     pub fn commit_expr(&mut self, e: &Expr, edible: &[token::Token], inedible: &[token::Token]) {\n-        debug!(\"commit_expr {}\", e);\n+        debug!(\"commit_expr {:?}\", e);\n         if let ExprPath(..) = e.node {\n             // might be unit-struct construction; check for recoverableinput error.\n             let mut expected = edible.iter().map(|x| x.clone()).collect::<Vec<_>>();\n@@ -5054,7 +5054,7 @@ impl<'a> Parser<'a> {\n                 attrs = tmp;\n                 first = false;\n             }\n-            debug!(\"parse_mod_items: parse_item_or_view_item(attrs={})\",\n+            debug!(\"parse_mod_items: parse_item_or_view_item(attrs={:?})\",\n                    attrs);\n             match self.parse_item_or_view_item(attrs,\n                                                true /* macros allowed */) {\n@@ -5191,7 +5191,7 @@ impl<'a> Parser<'a> {\n                                              format!(\"file not found for module `{}`\",\n                                                      mod_name).index(&FullRange),\n                                              format!(\"name the file either {} or {} inside \\\n-                                                     the directory {}\",\n+                                                     the directory {:?}\",\n                                                      default_path_str,\n                                                      secondary_path_str,\n                                                      dir_path.display()).index(&FullRange));"}, {"sha": "306ab303411f1da79db69a11bab2f723c0099c3e", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -651,6 +651,12 @@ impl BytesContainer for InternedString {\n }\n \n impl fmt::Show for InternedString {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::String for InternedString {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}\", self.string.index(&FullRange))\n     }"}, {"sha": "711715355e9503a1972419b104c809596d9dbf4c", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -194,7 +194,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n             if !self.cx.path.is_empty() {\n                 self.tested_submods.push((self.cx.path[self.cx.path.len()-1], sym));\n             } else {\n-                debug!(\"pushing nothing, sym: {}\", sym);\n+                debug!(\"pushing nothing, sym: {:?}\", sym);\n                 self.cx.toplevel_reexport = Some(sym);\n             }\n         }"}, {"sha": "f2dcdc6160aa9e3b9f00848d9a6a3dcd8f18cd95", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -190,14 +190,14 @@ impl<T: Writer+Send> TerminfoTerminal<T> {\n                                                   ti: msys_terminfo(),\n                                                   num_colors: 8} as Box<Terminal<T>+Send>);\n             }\n-            debug!(\"error finding terminfo entry: {}\", entry.err().unwrap());\n+            debug!(\"error finding terminfo entry: {:?}\", entry.err().unwrap());\n             return None;\n         }\n \n         let mut file = entry.unwrap();\n         let ti = parse(&mut file, false);\n         if ti.is_err() {\n-            debug!(\"error parsing terminfo entry: {}\", ti.unwrap_err());\n+            debug!(\"error parsing terminfo entry: {:?}\", ti.unwrap_err());\n             return None;\n         }\n "}, {"sha": "b0bce8f31120f94d6412b47d66966066eac47764", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -290,7 +290,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     ';' => (),\n \n                     _ => {\n-                        return Err(format!(\"unrecognized format option {}\", cur))\n+                        return Err(format!(\"unrecognized format option {:?}\", cur))\n                     }\n                 }\n             },\n@@ -552,7 +552,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n                     s\n                 }\n                 _ => {\n-                    return Err(format!(\"non-string on stack with %{}\",\n+                    return Err(format!(\"non-string on stack with %{:?}\",\n                                        op.to_char()))\n                 }\n             }\n@@ -636,7 +636,7 @@ mod test {\n                     \"Binop {} succeeded incorrectly with 1 stack entry\", cap);\n             let res = get_res(\"%{1}%{2}\", cap, &[], vars);\n             assert!(res.is_ok(),\n-                    \"Binop {} failed with 2 stack entries: {}\", cap, res.unwrap_err());\n+                    \"Binop {} failed with 2 stack entries: {:?}\", cap, res.unwrap_err());\n         }\n     }\n "}, {"sha": "7a06849abd161a7fac3c56685f62b98376520781", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -163,7 +163,7 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n     macro_rules! try { ($e:expr) => (\n         match $e {\n             Ok(e) => e,\n-            Err(e) => return Err(format!(\"{}\", e))\n+            Err(e) => return Err(format!(\"{:?}\", e))\n         }\n     ) }\n "}, {"sha": "2651be1ebb8f570a856e6b044a7215696fde7698", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -82,11 +82,11 @@ pub fn open(term: &str) -> Result<File, String> {\n         Some(x) => {\n             match File::open(&*x) {\n                 Ok(file) => Ok(file),\n-                Err(e) => Err(format!(\"error opening file: {}\", e)),\n+                Err(e) => Err(format!(\"error opening file: {:?}\", e)),\n             }\n         }\n         None => {\n-            Err(format!(\"could not find terminfo entry for {}\", term))\n+            Err(format!(\"could not find terminfo entry for {:?}\", term))\n         }\n     }\n }"}, {"sha": "3ee2b1b2224632afcdd8f632c4a40821bf4b5103", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -95,7 +95,11 @@ pub mod stats;\n // colons. This way if some test runner wants to arrange the tests\n // hierarchically it may.\n \n+<<<<<<< HEAD\n #[derive(Clone, PartialEq, Eq, Hash)]\n+=======\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n+>>>>>>> core: split into fmt::Show and fmt::String\n pub enum TestName {\n     StaticTestName(&'static str),\n     DynTestName(String)\n@@ -108,9 +112,9 @@ impl TestName {\n         }\n     }\n }\n-impl Show for TestName {\n+impl fmt::String for TestName {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.as_slice().fmt(f)\n+        fmt::String::fmt(self.as_slice(), f)\n     }\n }\n \n@@ -257,13 +261,13 @@ pub fn test_main(args: &[String], tests: Vec<TestDescAndFn> ) {\n     let opts =\n         match parse_opts(args) {\n             Some(Ok(o)) => o,\n-            Some(Err(msg)) => panic!(\"{}\", msg),\n+            Some(Err(msg)) => panic!(\"{:?}\", msg),\n             None => return\n         };\n     match run_tests_console(&opts, tests) {\n         Ok(true) => {}\n         Ok(false) => panic!(\"Some tests failed\"),\n-        Err(e) => panic!(\"io error when running tests: {}\", e),\n+        Err(e) => panic!(\"io error when running tests: {:?}\", e),\n     }\n }\n \n@@ -410,7 +414,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         let s = matches.free[0].as_slice();\n         match Regex::new(s) {\n             Ok(re) => Some(re),\n-            Err(e) => return Some(Err(format!(\"could not parse /{}/: {}\", s, e)))\n+            Err(e) => return Some(Err(format!(\"could not parse /{}/: {:?}\", s, e)))\n         }\n     } else {\n         None\n@@ -793,7 +797,7 @@ impl<T: Writer> ConsoleTestState<T> {\n         let ratchet_success = match *ratchet_metrics {\n             None => true,\n             Some(ref pth) => {\n-                try!(self.write_plain(format!(\"\\nusing metrics ratchet: {}\\n\",\n+                try!(self.write_plain(format!(\"\\nusing metrics ratchet: {:?}\\n\",\n                                               pth.display()).as_slice()));\n                 match ratchet_pct {\n                     None => (),\n@@ -912,7 +916,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn> ) -> io::IoR\n         None => (),\n         Some(ref pth) => {\n             try!(st.metrics.save(pth));\n-            try!(st.write_plain(format!(\"\\nmetrics saved to: {}\",\n+            try!(st.write_plain(format!(\"\\nmetrics saved to: {:?}\",\n                                           pth.display()).as_slice()));\n         }\n     }\n@@ -1206,7 +1210,7 @@ impl MetricMap {\n         let mut decoder = json::Decoder::new(value);\n         MetricMap(match Decodable::decode(&mut decoder) {\n             Ok(t) => t,\n-            Err(e) => panic!(\"failure decoding JSON: {}\", e)\n+            Err(e) => panic!(\"failure decoding JSON: {:?}\", e)\n         })\n     }\n "}, {"sha": "3e7e379cd78074249128b345363dae1ac96e5cd2", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -13,7 +13,7 @@\n use std::cmp::Ordering::{self, Less, Greater, Equal};\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::collections::hash_map;\n-use std::fmt::Show;\n+use std::fmt;\n use std::hash::Hash;\n use std::io;\n use std::mem;\n@@ -333,7 +333,7 @@ pub fn winsorize<T: Float + FromPrimitive>(samples: &mut [T], pct: T) {\n }\n \n /// Render writes the min, max and quartiles of the provided `Summary` to the provided `Writer`.\n-pub fn write_5_number_summary<W: Writer, T: Float + Show>(w: &mut W,\n+pub fn write_5_number_summary<W: Writer, T: Float + fmt::String + fmt::Show>(w: &mut W,\n                                                           s: &Summary<T>) -> io::IoResult<()> {\n     let (q1,q2,q3) = s.quartiles;\n     write!(w, \"(min={}, q1={}, med={}, q3={}, max={})\",\n@@ -355,7 +355,7 @@ pub fn write_5_number_summary<W: Writer, T: Float + Show>(w: &mut W,\n /// ```{.ignore}\n ///   10 |        [--****#******----------]          | 40\n /// ```\n-pub fn write_boxplot<W: Writer, T: Float + Show + FromPrimitive>(\n+pub fn write_boxplot<W: Writer, T: Float + fmt::String + fmt::Show + FromPrimitive>(\n                      w: &mut W,\n                      s: &Summary<T>,\n                      width_hint: uint)"}, {"sha": "ec1fdb3b9d3b1fb9e1dae97a65dd3a13db9bfb23", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -1 +1 @@\n-Subproject commit b820135911e17c7a46b901db56baa48e5155bf46\n+Subproject commit ec1fdb3b9d3b1fb9e1dae97a65dd3a13db9bfb23"}, {"sha": "3a37981744a5af2433fed551f742465c78c9af7f", "filename": "src/rust-installer", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frust-installer?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -1 +1 @@\n-Subproject commit b5ac4cd44321da10dfd70f070dbc9094ca3f92ff\n+Subproject commit 3a37981744a5af2433fed551f742465c78c9af7f"}, {"sha": "0a888d2bd112f81f720d3ee241d51e320c403504", "filename": "src/test/auxiliary/cci_class_cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -17,7 +17,7 @@ pub mod kitty {\n       pub name : String,\n     }\n \n-    impl fmt::Show for cat {\n+    impl fmt::String for cat {\n         fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n             write!(f, \"{}\", self.name)\n         }"}, {"sha": "23ef5331b495f0fabcbee953aee4da5a4f22df9e", "filename": "src/test/compile-fail/borrowck-move-out-of-vec-tail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -35,7 +35,7 @@ pub fn main() {\n                 }\n             }\n             let z = tail[0].clone();\n-            println!(\"{}\", z);\n+            println!(\"{:?}\", z);\n         }\n         _ => {\n             unreachable!();"}, {"sha": "01c6970506cd36543a05e3fe6b4ef58531307113", "filename": "src/test/compile-fail/copy-a-resource.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -27,5 +27,5 @@ fn main() {\n     let x = foo(10);\n     let _y = x.clone();\n     //~^ ERROR does not implement any method in scope\n-    println!(\"{}\", x);\n+    println!(\"{:?}\", x);\n }"}, {"sha": "7c929d2db16e73f044b9bc17198bcac098484334", "filename": "src/test/compile-fail/ifmt-bad-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -46,7 +46,7 @@ fn main() {\n \n     // bad syntax of the format string\n \n-    format!(\"{\"); //~ ERROR: expected `}` but string was terminated\n+    format!(\"{\"); //~ ERROR: expected `'}'` but string was terminated\n \n     format!(\"foo } bar\"); //~ ERROR: unmatched `}` found\n     format!(\"foo }\"); //~ ERROR: unmatched `}` found"}, {"sha": "3d8ebc1ecdf19e517bb197f93fe36bbece65ca47", "filename": "src/test/compile-fail/issue-14853.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fissue-14853.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fissue-14853.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14853.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -27,5 +27,5 @@ impl Something for X {\n \n fn main() {\n     let arr = &[\"one\", \"two\", \"three\"];\n-    println!(\"{}\", Something::yay(None::<X>, arr));\n+    println!(\"{:?}\", Something::yay(None::<X>, arr));\n }"}, {"sha": "5292848f8ee45fcc38b5c8492464f070c47b040b", "filename": "src/test/compile-fail/issue-15094.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fissue-15094.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fissue-15094.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15094.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -19,7 +19,7 @@ struct Shower<T> {\n impl<T: fmt::Show> ops::Fn<(), ()> for Shower<T> {\n     fn call(&self, _args: ()) {\n //~^ ERROR `call` has an incompatible type for trait: expected \"rust-call\" fn, found \"Rust\" fn\n-        println!(\"{}\", self.x);\n+        println!(\"{:?}\", self.x);\n     }\n }\n "}, {"sha": "66ef7b807f7c652665e5e473d6d4a2a78944447e", "filename": "src/test/compile-fail/issue-17728.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -123,8 +123,8 @@ fn str_to_direction(to_parse: &str) -> RoomDirection {\n fn main() {\n     let mut player = Player::new(\"Test player\");\n     let mut room = Room::new(\"A test room\");\n-    println!(\"Made a player: {}\", player);\n-    println!(\"Direction parse: {}\", str_to_direction(\"east\"));\n+    println!(\"Made a player: {:?}\", player);\n+    println!(\"Direction parse: {:?}\", str_to_direction(\"east\"));\n     match player.attemptTraverse(&room, \"west\") {\n         Ok(_) => println!(\"Was able to move west\"),\n         Err(msg) => println!(\"Not able to move west: {}\", msg)"}, {"sha": "7bf3449a664b103adb9a1ae411445e06607c992f", "filename": "src/test/compile-fail/issue-5062.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fissue-5062.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fissue-5062.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5062.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -8,5 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn main() { format!(\"{}\", None); }\n+fn main() { format!(\"{:?}\", None); }\n     //~^ ERROR type annotations required"}, {"sha": "0143c75bfc6045687d631f3d1779249b25aa13ee", "filename": "src/test/compile-fail/issue-6458-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fissue-6458-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fissue-6458-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458-2.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -10,6 +10,6 @@\n \n fn main() {\n     // Unconstrained type:\n-    format!(\"{}\", None);\n+    format!(\"{:?}\", None);\n     //~^ ERROR type annotations required\n }"}, {"sha": "c75c7002e5e0f95910ea14f431ab99e2d0ec53d7", "filename": "src/test/compile-fail/linkage3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Flinkage3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Flinkage3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flinkage3.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -16,6 +16,6 @@ extern {\n }\n \n fn main() {\n-    println!(\"{}\", foo);\n+    println!(\"{:?}\", foo);\n }\n "}, {"sha": "b6eda8635c2f400a5cba28a5d738e9580f936ad6", "filename": "src/test/compile-fail/lint-uppercase-variables.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -32,7 +32,7 @@ fn main() {\n     let mut buff = [0u8; 16];\n     match f.read(&mut buff) {\n         Ok(cnt) => println!(\"read this many bytes: {}\", cnt),\n-        Err(IoError{ kind: EndOfFile, .. }) => println!(\"Got end of file: {}\", EndOfFile.to_string()),\n+        Err(IoError{ kind: EndOfFile, .. }) => println!(\"Got end of file: {:?}\", EndOfFile),\n //~^ ERROR variable `EndOfFile` should have a snake case name such as `end_of_file`\n //~^^ WARN `EndOfFile` is named the same as one of the variants of the type `std::io::IoErrorKind`\n     }"}, {"sha": "44d45463f19f0e21a78b2b5bf0841831419a9220", "filename": "src/test/compile-fail/liveness-use-after-send.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n fn send<T:Send + std::fmt::Show>(ch: _chan<T>, data: T) {\n-    println!(\"{}\", ch);\n-    println!(\"{}\", data);\n+    println!(\"{:?}\", ch);\n+    println!(\"{:?}\", data);\n     panic!();\n }\n "}, {"sha": "6f5741788ee2d5a4a9d224d8df7fc58867a3c6f0", "filename": "src/test/compile-fail/no-send-res-ports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -39,6 +39,6 @@ fn main() {\n         //~^ ERROR `core::kinds::Send` is not implemented\n         //~^^ ERROR `core::kinds::Send` is not implemented\n         let y = x;\n-        println!(\"{}\", y);\n+        println!(\"{:?}\", y);\n     });\n }"}, {"sha": "ec8369d6736fb0af32f6d62f0e2af61b6093034b", "filename": "src/test/compile-fail/noncopyable-class.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -42,5 +42,5 @@ fn foo(i:int) -> foo {\n fn main() {\n     let x = foo(10);\n     let _y = x.clone(); //~ ERROR does not implement any method in scope\n-    println!(\"{}\", x);\n+    println!(\"{:?}\", x);\n }"}, {"sha": "200c8a5137a8b46ff89bed6ed5e9fa7a543e5557", "filename": "src/test/compile-fail/packed-struct-transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fpacked-struct-transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fpacked-struct-transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpacked-struct-transmute.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -33,6 +33,6 @@ fn main() {\n     let foo = Foo { bar: 1, baz: 10 };\n     unsafe {\n         let oof: Oof = mem::transmute(foo);\n-        println!(\"{}\", oof);\n+        println!(\"{:?}\", oof);\n     }\n }"}, {"sha": "460154f25d7fcb5354b27b7a32b717cc279f4751", "filename": "src/test/compile-fail/static-reference-to-fn-2.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fstatic-reference-to-fn-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fstatic-reference-to-fn-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-reference-to-fn-2.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -53,9 +53,9 @@ fn state_iter() -> StateMachineIter<'static> {\n \n fn main() {\n     let mut it = state_iter();\n-    println!(\"{}\",it.next());\n-    println!(\"{}\",it.next());\n-    println!(\"{}\",it.next());\n-    println!(\"{}\",it.next());\n-    println!(\"{}\",it.next());\n+    println!(\"{:?}\",it.next());\n+    println!(\"{:?}\",it.next());\n+    println!(\"{:?}\",it.next());\n+    println!(\"{:?}\",it.next());\n+    println!(\"{:?}\",it.next());\n }"}, {"sha": "d306d171ca85556d32d93b1cf0be1ee2f3b58a6e", "filename": "src/test/compile-fail/unique-pinned-nocopy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -20,5 +20,5 @@ impl Drop for r {\n fn main() {\n     let i = box r { b: true };\n     let _j = i.clone(); //~ ERROR not implement\n-    println!(\"{}\", i);\n+    println!(\"{:?}\", i);\n }"}, {"sha": "4848c988300abde3142d8a357e568eb2fb6c25e9", "filename": "src/test/compile-fail/unique-vec-res.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -39,6 +39,6 @@ fn main() {\n     f(clone(&r1), clone(&r2));\n     //~^ ERROR the trait `core::clone::Clone` is not implemented for the type\n     //~^^ ERROR the trait `core::clone::Clone` is not implemented for the type\n-    println!(\"{}\", (r2, i1.get()));\n-    println!(\"{}\", (r1, i2.get()));\n+    println!(\"{:?}\", (r2, i1.get()));\n+    println!(\"{:?}\", (r1, i2.get()));\n }"}, {"sha": "364bfc42985990862bbd42429967f35ec566051a", "filename": "src/test/compile-fail/use-after-move-implicity-coerced-object.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fuse-after-move-implicity-coerced-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fuse-after-move-implicity-coerced-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move-implicity-coerced-object.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -16,7 +16,7 @@ struct Number {\n     n: i64\n }\n \n-impl fmt::Show for Number {\n+impl fmt::String for Number {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}\", self.n)\n     }"}, {"sha": "dc166f9fd9d26d99c2fe22795c1d5d58d58f829c", "filename": "src/test/compile-fail/vec-res-add.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -25,5 +25,5 @@ fn main() {\n     let j = vec!(r(1));\n     let k = i + j;\n     //~^ ERROR binary operation `+` cannot be applied to type\n-    println!(\"{}\", j);\n+    println!(\"{:?}\", j);\n }"}, {"sha": "4b1a420cb788087fafbee2a077c3e5d15f886b44", "filename": "src/test/run-fail/assert-eq-macro-panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-fail%2Fassert-eq-macro-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-fail%2Fassert-eq-macro-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fassert-eq-macro-panic.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:assertion failed: `(left == right) && (right == left)` (left: `14`, right: `15`)\n+// error-pattern:assertion failed: `(left == right) && (right == left)` (left: `14i`, right: `15i`)\n \n fn main() {\n     assert_eq!(14i,15i);"}, {"sha": "c586ff2c93ab3215bd9d20bdd87ebe3c9eceb252", "filename": "src/test/run-pass/borrowck-mut-uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -32,9 +32,9 @@ pub fn main() {\n     add_int(&mut *ints, 44);\n \n     iter_ints(&*ints, |i| {\n-        println!(\"int = {}\", *i);\n+        println!(\"int = {:?}\", *i);\n         true\n     });\n \n-    println!(\"ints={}\", ints);\n+    println!(\"ints={:?}\", ints);\n }"}, {"sha": "9c7913dc0b0b1d69f58fbd9ab07a4f78cabb75a1", "filename": "src/test/run-pass/class-separate-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -51,7 +51,7 @@ fn cat(in_x : uint, in_y : int, in_name: String) -> cat {\n     }\n }\n \n-impl fmt::Show for cat {\n+impl fmt::String for cat {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}\", self.name)\n     }"}, {"sha": "b5a5f57d07abda322171f642cf19c29b7a9eec5f", "filename": "src/test/run-pass/conditional-debug-macro-off.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fconditional-debug-macro-off.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fconditional-debug-macro-off.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconditional-debug-macro-off.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -16,5 +16,5 @@ extern crate log;\n \n pub fn main() {\n     // only panics if println! evaluates its argument.\n-    debug!(\"{}\", { if true { panic!() } });\n+    debug!(\"{:?}\", { if true { panic!() } });\n }"}, {"sha": "b335e20f91d932df7a127b37a6eca2e56c4b73f8", "filename": "src/test/run-pass/conditional-debug-macro-on.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fconditional-debug-macro-on.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fconditional-debug-macro-on.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconditional-debug-macro-on.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -13,7 +13,7 @@\n pub fn main() {\n     // exits early if println! evaluates its arguments, otherwise it\n     // will hit the panic.\n-    println!(\"{}\", { if true { return; } });\n+    println!(\"{:?}\", { if true { return; } });\n \n     panic!();\n }"}, {"sha": "cd79f84b7cbc31f99353b08b166c556cfea8716d", "filename": "src/test/run-pass/deriving-in-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fderiving-in-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fderiving-in-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-in-fn.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -15,5 +15,5 @@ pub fn main() {\n     }\n \n     let f = Foo { foo: 10 };\n-    format!(\"{}\", f);\n+    format!(\"{:?}\", f);\n }"}, {"sha": "8465f521e43992de43cf5845a2db206b44c10f33", "filename": "src/test/run-pass/deriving-show-2.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fderiving-show-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fderiving-show-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-show-2.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -38,16 +38,25 @@ impl fmt::Show for Custom {\n     }\n }\n \n+trait ToShow {\n+    fn to_show(&self) -> String;\n+}\n+\n+impl<T: fmt::Show> ToShow for T {\n+    fn to_show(&self) -> String {\n+        format!(\"{:?}\", self)\n+    }\n+}\n+\n pub fn main() {\n-    assert_eq!(B::B1.to_string(), \"B1\".to_string());\n-    assert_eq!(B::B2.to_string(), \"B2\".to_string());\n-    assert_eq!(C::C1(3).to_string(), \"C1(3)\".to_string());\n-    assert_eq!(C::C2(B::B2).to_string(), \"C2(B2)\".to_string());\n-    assert_eq!(D::D1{ a: 2 }.to_string(), \"D1 { a: 2 }\".to_string());\n-    assert_eq!(E.to_string(), \"E\".to_string());\n-    assert_eq!(F(3).to_string(), \"F(3)\".to_string());\n-    assert_eq!(G(3, 4).to_string(), \"G(3, 4)\".to_string());\n-    assert_eq!(G(3, 4).to_string(), \"G(3, 4)\".to_string());\n-    assert_eq!(I{ a: 2, b: 4 }.to_string(), \"I { a: 2, b: 4 }\".to_string());\n-    assert_eq!(J(Custom).to_string(), \"J(yay)\".to_string());\n+    assert_eq!(B::B1.to_show(), \"B1\".to_string());\n+    assert_eq!(B::B2.to_show(), \"B2\".to_string());\n+    assert_eq!(C::C1(3).to_show(), \"C1(3i)\".to_string());\n+    assert_eq!(C::C2(B::B2).to_show(), \"C2(B2)\".to_string());\n+    assert_eq!(D::D1{ a: 2 }.to_show(), \"D1 { a: 2i }\".to_string());\n+    assert_eq!(E.to_show(), \"E\".to_string());\n+    assert_eq!(F(3).to_show(), \"F(3i)\".to_string());\n+    assert_eq!(G(3, 4).to_show(), \"G(3i, 4i)\".to_string());\n+    assert_eq!(I{ a: 2, b: 4 }.to_show(), \"I { a: 2i, b: 4i }\".to_string());\n+    assert_eq!(J(Custom).to_show(), \"J(yay)\".to_string());\n }"}, {"sha": "99c73dd94a6b6a06f71e1c969b2264812448d2ed", "filename": "src/test/run-pass/deriving-show.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fderiving-show.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fderiving-show.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-show.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -26,15 +26,15 @@ enum Enum {\n \n macro_rules! t {\n     ($x:expr, $expected:expr) => {\n-        assert_eq!(format!(\"{}\", $x), $expected.to_string())\n+        assert_eq!(format!(\"{:?}\", $x), $expected.to_string())\n     }\n }\n \n pub fn main() {\n     t!(Unit, \"Unit\");\n-    t!(Tuple(1, 2), \"Tuple(1, 2)\");\n-    t!(Struct { x: 1, y: 2 }, \"Struct { x: 1, y: 2 }\");\n+    t!(Tuple(1, 2), \"Tuple(1i, 2u)\");\n+    t!(Struct { x: 1, y: 2 }, \"Struct { x: 1i, y: 2u }\");\n     t!(Enum::Nullary, \"Nullary\");\n-    t!(Enum::Variant(1, 2), \"Variant(1, 2)\");\n-    t!(Enum::StructVariant { x: 1, y: 2 }, \"StructVariant { x: 1, y: 2 }\");\n+    t!(Enum::Variant(1, 2), \"Variant(1i, 2u)\");\n+    t!(Enum::StructVariant { x: 1, y: 2 }, \"StructVariant { x: 1i, y: 2u }\");\n }"}, {"sha": "6f8574ccfa2144e1066752b87baeeb0143ca60d3", "filename": "src/test/run-pass/dst-index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fdst-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fdst-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-index.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -37,5 +37,5 @@ impl Index<uint> for T {\n \n fn main() {\n     assert_eq!(&S[0], \"hello\");\n-    assert_eq!(format!(\"{}\", &T[0]).as_slice(), \"42\");\n+    assert_eq!(format!(\"{:?}\", &T[0]), \"42u\");\n }"}, {"sha": "73559af79de0a7bd1c819e3b69ed333b9238a22e", "filename": "src/test/run-pass/enum-discrim-width-stuff.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -23,8 +23,8 @@ macro_rules! check {\n                 assert_eq!(size_of::<E>(), size_of::<$t>());\n                 assert_eq!(E::V as $t, $v as $t);\n                 assert_eq!(C as $t, $v as $t);\n-                assert_eq!(format!(\"{}\", E::V), \"V\".to_string());\n-                assert_eq!(format!(\"{}\", C), \"V\".to_string());\n+                assert_eq!(format!(\"{:?}\", E::V), \"V\".to_string());\n+                assert_eq!(format!(\"{:?}\", C), \"V\".to_string());\n             }\n         }\n         $m::check();"}, {"sha": "5f2ebc6cbed3e1a11300b107b74708955bcda0cf", "filename": "src/test/run-pass/functional-struct-upd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Ffunctional-struct-upd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Ffunctional-struct-upd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffunctional-struct-upd.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -17,5 +17,5 @@ struct Foo {\n pub fn main() {\n     let a = Foo { x: 1, y: 2 };\n     let c = Foo { x: 4, .. a};\n-    println!(\"{}\", c);\n+    println!(\"{:?}\", c);\n }"}, {"sha": "cd438b5e339b37f2241816ad0ecaffb46a283825", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -30,7 +30,7 @@ impl fmt::UpperHex for B {\n         f.write_str(\"adios\")\n     }\n }\n-impl fmt::Show for C {\n+impl fmt::String for C {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad_integral(true, \"\u2603\", \"123\")\n     }\n@@ -58,9 +58,12 @@ pub fn main() {\n     t!(format!(\"{}\", true), \"true\");\n     t!(format!(\"{}\", '\u2603'), \"\u2603\");\n     t!(format!(\"{}\", 10i), \"10\");\n-    t!(format!(\"{}\", 10i), \"10\");\n     t!(format!(\"{}\", 10u), \"10\");\n-    t!(format!(\"{:?}\", true), \"true\");\n+    t!(format!(\"{:?}\", '\u2603'), \"'\\\\u{2603}'\");\n+    t!(format!(\"{:?}\", 10i), \"10i\");\n+    t!(format!(\"{:?}\", 10u), \"10u\");\n+    t!(format!(\"{:?}\", \"true\"), \"\\\"true\\\"\");\n+    t!(format!(\"{:?}\", \"foo\\nbar\"), \"\\\"foo\\\\nbar\\\"\");\n     t!(format!(\"{:o}\", 10u), \"12\");\n     t!(format!(\"{:x}\", 10u), \"a\");\n     t!(format!(\"{:X}\", 10u), \"A\");\n@@ -80,7 +83,8 @@ pub fn main() {\n     t!(format!(\"{:#4}\", C), \"\u2603123\");\n \n     let a: &fmt::Show = &1i;\n-    t!(format!(\"{}\", a), \"1\");\n+    t!(format!(\"{:?}\", a), \"1i\");\n+\n \n     // Formatting strings and their arguments\n     t!(format!(\"{}\", \"a\"), \"a\");"}, {"sha": "308783f0d4b596f634df56349788f03c2ac7e883", "filename": "src/test/run-pass/issue-10396.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-10396.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-10396.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10396.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -15,7 +15,7 @@ enum Foo<'s> {\n \n fn f(arr: &[&Foo]) {\n     for &f in arr.iter() {\n-        println!(\"{}\", f);\n+        println!(\"{:?}\", f);\n     }\n }\n "}, {"sha": "b06799444f4c797ed6fe603d09774d22c922fa48", "filename": "src/test/run-pass/issue-10626.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-10626.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-10626.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10626.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -30,5 +30,5 @@ pub fn main () {\n \n     let mut p = process::Command::new(args[0].as_slice());\n     p.arg(\"child\").stdout(process::Ignored).stderr(process::Ignored);\n-    println!(\"{}\", p.spawn().unwrap().wait());\n+    println!(\"{:?}\", p.spawn().unwrap().wait());\n }"}, {"sha": "6fb2c532e0c0b1f48300f3d3740138c80e6092da", "filename": "src/test/run-pass/issue-11267.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-11267.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-11267.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11267.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -20,7 +20,7 @@ impl T<int> for Empty {\n }\n \n fn do_something_with(a : &mut T<int>) {\n-    println!(\"{}\", a.next())\n+    println!(\"{:?}\", a.next())\n }\n \n pub fn main() {"}, {"sha": "a91dbd2b716b66da21ed7593a8c593a7e0d2ddb7", "filename": "src/test/run-pass/issue-12744.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-12744.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-12744.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12744.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -10,5 +10,5 @@\n \n fn main() {\n     fn test() -> Box<std::any::Any + 'static> { box 1i }\n-    println!(\"{}\", test())\n+    println!(\"{:?}\", test())\n }"}, {"sha": "35e487539fab98a050cbdf72d3cfefffd72bddee", "filename": "src/test/run-pass/issue-13434.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-13434.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-13434.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13434.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -26,5 +26,5 @@ fn do_stuff<R: Repro>(r: R) -> String {\n }\n \n pub fn main() {\n-  assert_eq!(\"MyStruct\".to_string(), do_stuff(|: s: MyStruct| format!(\"{}\", s)));\n+  assert_eq!(\"MyStruct\".to_string(), do_stuff(|: s: MyStruct| format!(\"{:?}\", s)));\n }"}, {"sha": "40e112d6fbf7637ab56636048881c872456cb5de", "filename": "src/test/run-pass/issue-1696.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-1696.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-1696.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1696.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -15,5 +15,5 @@ use std::collections::HashMap;\n pub fn main() {\n     let mut m = HashMap::new();\n     m.insert(b\"foo\".to_vec(), b\"bar\".to_vec());\n-    println!(\"{}\", m);\n+    println!(\"{:?}\", m);\n }"}, {"sha": "c90880ff120bbcaef7558d7633359cba19774c1c", "filename": "src/test/run-pass/issue-19135.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-19135.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-19135.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-19135.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -14,7 +14,7 @@\n struct LifetimeStruct<'a>;\n \n fn main() {\n-    takes_hrtb_closure(|&mut: lts| println!(\"{}\", lts));\n+    takes_hrtb_closure(|&mut: lts| println!(\"{:?}\", lts));\n }\n \n fn takes_hrtb_closure<F: for<'a>FnMut(LifetimeStruct<'a>)>(mut f: F) {"}, {"sha": "360934821750dd8a83044d3193334dfac15658d3", "filename": "src/test/run-pass/issue-19358.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-19358.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-19358.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-19358.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -25,5 +25,5 @@ impl Trait for int {}\n fn main() {\n     let a = Foo { foo: 12i };\n     let b = Bar { bar: 12i };\n-    println!(\"{} {}\", a, b);\n+    println!(\"{:?} {:?}\", a, b);\n }"}, {"sha": "dc22ebce804e643d6fea7c1482c61dadb5acb820", "filename": "src/test/run-pass/issue-3109.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-3109.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-3109.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3109.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n pub fn main() {\n-    println!(\"{}\", (\"hi there!\", \"you\"));\n+    println!(\"{:?}\", (\"hi there!\", \"you\"));\n }"}, {"sha": "3448273e14424709c730969cdda7d38857757276", "filename": "src/test/run-pass/issue-3556.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-3556.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-3556.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3556.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -43,6 +43,6 @@ pub fn main()\n                     \"foo\".to_string(),\n                     \"foo\".to_string(), \"foo\".to_string(), \"foo\".to_string(),\n                     \"foo\".to_string());\n-    let v = format!(\"{}\", u);    // this is the line that causes the seg fault\n+    let v = format!(\"{:?}\", u);    // this is the line that causes the seg fault\n     assert!(v.len() > 0);\n }"}, {"sha": "633832f424c858757cbb93c5eadbe0123fd263fd", "filename": "src/test/run-pass/issue-3559.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-3559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-3559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3559.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -24,6 +24,6 @@ pub fn main() {\n     let mut table = HashMap::new();\n     table.insert(\"one\".to_string(), 1i);\n     table.insert(\"two\".to_string(), 2i);\n-    assert!(check_strs(table.to_string().as_slice(), \"{one: 1, two: 2}\") ||\n-            check_strs(table.to_string().as_slice(), \"{two: 2, one: 1}\"));\n+    assert!(check_strs(format!(\"{:?}\", table).as_slice(), \"HashMap {\\\"one\\\": 1i, \\\"two\\\": 2i}\") ||\n+            check_strs(format!(\"{:?}\", table).as_slice(), \"HashMap {\\\"two\\\": 2i, \\\"one\\\": 1i}\"));\n }"}, {"sha": "3fe6e02dcefba1f39750156f9bf1045b25029164", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -104,7 +104,7 @@ impl AsciiArt {\n \n // Allows AsciiArt to be converted to a string using the libcore ToString trait.\n // Note that the %s fmt! specifier will not call this automatically.\n-impl fmt::Show for AsciiArt {\n+impl fmt::String for AsciiArt {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // Convert each line into a string.\n         let lines = self.lines.iter()"}, {"sha": "926b53cf92c0d1bc2ded84dc93d61c9b1c544874", "filename": "src/test/run-pass/issue-3794.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-3794.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-3794.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3794.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -19,7 +19,7 @@ struct S {\n \n impl T for S {\n     fn print(&self) {\n-        println!(\"{}\", self);\n+        println!(\"{:?}\", self);\n     }\n }\n "}, {"sha": "3606aff05ff5e0805747f77dfdb7d61fcd40c2ba", "filename": "src/test/run-pass/issue-4252.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-4252.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-4252.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4252.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -13,7 +13,7 @@\n trait X {\n     fn call<T: std::fmt::Show>(&self, x: &T);\n     fn default_method<T: std::fmt::Show>(&self, x: &T) {\n-        println!(\"X::default_method {}\", x);\n+        println!(\"X::default_method {:?}\", x);\n     }\n }\n \n@@ -27,7 +27,7 @@ struct Z<T> {\n \n impl X for Y {\n     fn call<T: std::fmt::Show>(&self, x: &T) {\n-        println!(\"X::call {} {}\", self, x);\n+        println!(\"X::call {:?} {:?}\", self, x);\n     }\n }\n "}, {"sha": "734d131ffdff002b223262c7c14b6da42a85b977", "filename": "src/test/run-pass/issue-7563.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-7563.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-7563.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7563.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -31,6 +31,6 @@ pub fn main() {\n     let sa = A { a: 100 };\n     let sb = B { b: 200, pa: &sa };\n \n-    println!(\"sa is {}\", sa);\n-    println!(\"sb is {}\", sb);\n+    println!(\"sa is {:?}\", sa);\n+    println!(\"sb is {:?}\", sb);\n }"}, {"sha": "0ca63d52bd849f224066ce63e163e4bc70b388e0", "filename": "src/test/run-pass/issue-8898.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-8898.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fissue-8898.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8898.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -11,7 +11,7 @@\n #![feature(slicing_syntax)]\n \n fn assert_repr_eq<T: std::fmt::Show>(obj : T, expected : String) {\n-    assert_eq!(expected, format!(\"{}\", obj));\n+    assert_eq!(expected, format!(\"{:?}\", obj));\n }\n \n pub fn main() {\n@@ -20,7 +20,7 @@ pub fn main() {\n     let x  = [(), ()];\n     let slice = &x[0..1];\n \n-    assert_repr_eq(&abc[], \"[1, 2, 3]\".to_string());\n+    assert_repr_eq(&abc[], \"[1i, 2i, 3i]\".to_string());\n     assert_repr_eq(&tf[], \"[true, false]\".to_string());\n     assert_repr_eq(&x[], \"[(), ()]\".to_string());\n     assert_repr_eq(slice, \"[()]\".to_string());"}, {"sha": "7fb2390b84b701df5bd5b713dba811a12610675c", "filename": "src/test/run-pass/log-knows-the-names-of-variants-in-std.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants-in-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants-in-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants-in-std.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -15,19 +15,19 @@ enum foo {\n }\n \n fn check_log<T: std::fmt::Show>(exp: String, v: T) {\n-    assert_eq!(exp, format!(\"{}\", v));\n+    assert_eq!(exp, format!(\"{:?}\", v));\n }\n \n pub fn main() {\n     let mut x = Some(foo::a(22u));\n-    let exp = \"Some(a(22))\".to_string();\n-    let act = format!(\"{}\", x);\n+    let exp = \"Some(a(22u))\".to_string();\n+    let act = format!(\"{:?}\", x);\n     assert_eq!(act, exp);\n     check_log(exp, x);\n \n     x = None;\n     let exp = \"None\".to_string();\n-    let act = format!(\"{}\", x);\n+    let act = format!(\"{:?}\", x);\n     assert_eq!(act, exp);\n     check_log(exp, x);\n }"}, {"sha": "45fd2098dc42e8b91b49709f5c25cb0241fbe667", "filename": "src/test/run-pass/log-knows-the-names-of-variants.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -21,7 +21,7 @@ enum bar {\n }\n \n pub fn main() {\n-    assert_eq!(\"a(22)\".to_string(), format!(\"{}\", foo::a(22u)));\n-    assert_eq!(\"c\".to_string(), format!(\"{}\", foo::c));\n-    assert_eq!(\"d\".to_string(), format!(\"{}\", bar::d));\n+    assert_eq!(\"a(22u)\".to_string(), format!(\"{:?}\", foo::a(22u)));\n+    assert_eq!(\"c\".to_string(), format!(\"{:?}\", foo::c));\n+    assert_eq!(\"d\".to_string(), format!(\"{:?}\", bar::d));\n }"}, {"sha": "a6a99d6fc92a73e247d99b2b0655ded4c3998a56", "filename": "src/test/run-pass/log-poly.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Flog-poly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Flog-poly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flog-poly.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -14,8 +14,8 @@ enum Numbers {\n }\n \n pub fn main() {\n-    println!(\"{}\", 1i);\n-    println!(\"{}\", 2.0f64);\n-    println!(\"{}\", Numbers::Three);\n-    println!(\"{}\", vec!(4i));\n+    println!(\"{:?}\", 1i);\n+    println!(\"{:?}\", 2.0f64);\n+    println!(\"{:?}\", Numbers::Three);\n+    println!(\"{:?}\", vec!(4i));\n }"}, {"sha": "787d0e98e2bfcd79bd97337dc40c90b8f91a3a96", "filename": "src/test/run-pass/logging-only-prints-once.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -29,7 +29,7 @@ impl fmt::Show for Foo {\n pub fn main() {\n     Thread::spawn(move|| {\n         let mut f = Foo(Cell::new(0));\n-        println!(\"{}\", f);\n+        println!(\"{:?}\", f);\n         let Foo(ref mut f) = f;\n         assert!(f.get() == 1);\n     }).join().ok().unwrap();"}, {"sha": "84d2083cedd71532fd7c19bb90ef51b5a012cb21", "filename": "src/test/run-pass/new-impl-syntax.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fnew-impl-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fnew-impl-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnew-impl-syntax.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -17,7 +17,7 @@ struct Thingy {\n \n impl fmt::Show for Thingy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{{ x: {}, y: {} }}\", self.x, self.y)\n+        write!(f, \"{{ x: {:?}, y: {:?} }}\", self.x, self.y)\n     }\n }\n \n@@ -27,11 +27,11 @@ struct PolymorphicThingy<T> {\n \n impl<T:fmt::Show> fmt::Show for PolymorphicThingy<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.x)\n+        write!(f, \"{:?}\", self.x)\n     }\n }\n \n pub fn main() {\n-    println!(\"{}\", Thingy { x: 1, y: 2 }.to_string());\n-    println!(\"{}\", PolymorphicThingy { x: Thingy { x: 1, y: 2 } }.to_string());\n+    println!(\"{:?}\", Thingy { x: 1, y: 2 });\n+    println!(\"{:?}\", PolymorphicThingy { x: Thingy { x: 1, y: 2 } });\n }"}, {"sha": "2e044227eb135b90141acdd0b8fe405c1fd171ad", "filename": "src/test/run-pass/overloaded-index-assoc-list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Foverloaded-index-assoc-list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Foverloaded-index-assoc-list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-index-assoc-list.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -37,7 +37,7 @@ impl<K: PartialEq + std::fmt::Show, V:Clone> Index<K> for AssociationList<K,V> {\n                 return &pair.value\n             }\n         }\n-        panic!(\"No value found for key: {}\", index);\n+        panic!(\"No value found for key: {:?}\", index);\n     }\n }\n "}, {"sha": "5b91d5e930f9bef1b0afb4b7888476b8a386a36b", "filename": "src/test/run-pass/rec-align-u32.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Frec-align-u32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Frec-align-u32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec-align-u32.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -53,11 +53,11 @@ pub fn main() {\n         let x = Outer {c8: 22u8, t: Inner {c64: 44u32}};\n \n         // Send it through the shape code\n-        let y = format!(\"{}\", x);\n+        let y = format!(\"{:?}\", x);\n \n-        println!(\"align inner = {}\", rusti::min_align_of::<Inner>());\n-        println!(\"size outer = {}\", mem::size_of::<Outer>());\n-        println!(\"y = {}\", y);\n+        println!(\"align inner = {:?}\", rusti::min_align_of::<Inner>());\n+        println!(\"size outer = {:?}\", mem::size_of::<Outer>());\n+        println!(\"y = {:?}\", y);\n \n         // per clang/gcc the alignment of `inner` is 4 on x86.\n         assert_eq!(rusti::min_align_of::<Inner>(), m::align());\n@@ -66,6 +66,6 @@ pub fn main() {\n         // because `inner`s alignment was 4.\n         assert_eq!(mem::size_of::<Outer>(), m::size());\n \n-        assert_eq!(y, \"Outer { c8: 22, t: Inner { c64: 44 } }\".to_string());\n+        assert_eq!(y, \"Outer { c8: 22u8, t: Inner { c64: 44u32 } }\".to_string());\n     }\n }"}, {"sha": "27941542d000e532366c6d601b01b804fd68a651", "filename": "src/test/run-pass/rec-align-u64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Frec-align-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Frec-align-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec-align-u64.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -82,11 +82,11 @@ pub fn main() {\n     unsafe {\n         let x = Outer {c8: 22u8, t: Inner {c64: 44u64}};\n \n-        let y = format!(\"{}\", x);\n+        let y = format!(\"{:?}\", x);\n \n-        println!(\"align inner = {}\", rusti::min_align_of::<Inner>());\n-        println!(\"size outer = {}\", mem::size_of::<Outer>());\n-        println!(\"y = {}\", y);\n+        println!(\"align inner = {:?}\", rusti::min_align_of::<Inner>());\n+        println!(\"size outer = {:?}\", mem::size_of::<Outer>());\n+        println!(\"y = {:?}\", y);\n \n         // per clang/gcc the alignment of `Inner` is 4 on x86.\n         assert_eq!(rusti::min_align_of::<Inner>(), m::m::align());\n@@ -95,6 +95,6 @@ pub fn main() {\n         // because `Inner`s alignment was 4.\n         assert_eq!(mem::size_of::<Outer>(), m::m::size());\n \n-        assert_eq!(y, \"Outer { c8: 22, t: Inner { c64: 44 } }\".to_string());\n+        assert_eq!(y, \"Outer { c8: 22u8, t: Inner { c64: 44u64 } }\".to_string());\n     }\n }"}, {"sha": "57f72b23adfa3e74b3cf38c9283b1d096e7d4bce", "filename": "src/test/run-pass/resource-assign-is-not-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fresource-assign-is-not-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fresource-assign-is-not-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-assign-is-not-copy.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -37,7 +37,7 @@ pub fn main() {\n         let a = r(i);\n         let b = (a, 10i);\n         let (c, _d) = b;\n-        println!(\"{}\", c);\n+        println!(\"{:?}\", c);\n     }\n     assert_eq!(i.get(), 1);\n }"}, {"sha": "d6c25672cdbbc720ca1a68ca9cb917ab0c915711", "filename": "src/test/run-pass/running-with-no-runtime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -57,7 +57,7 @@ fn start(argc: int, argv: *const *const u8) -> int {\n \n fn pass(output: ProcessOutput) {\n     if !output.status.success() {\n-        println!(\"{}\", str::from_utf8(output.output.as_slice()));\n-        println!(\"{}\", str::from_utf8(output.error.as_slice()));\n+        println!(\"{:?}\", str::from_utf8(output.output.as_slice()));\n+        println!(\"{:?}\", str::from_utf8(output.error.as_slice()));\n     }\n }"}, {"sha": "e0d005a485bc0c15cdff2983fbf3b5146798b8cb", "filename": "src/test/run-pass/show-boxed-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fshow-boxed-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fshow-boxed-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fshow-boxed-slice.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -12,5 +12,5 @@\n struct Foo(Box<[u8]>);\n \n pub fn main() {\n-    println!(\"{}\", Foo(box [0, 1, 2]));\n+    println!(\"{:?}\", Foo(box [0, 1, 2]));\n }"}, {"sha": "c793deaae2b29acaad8b27571d44463f1532ac65", "filename": "src/test/run-pass/small-enums-with-fields.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fsmall-enums-with-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fsmall-enums-with-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmall-enums-with-fields.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -20,23 +20,23 @@ macro_rules! check {\n             static S: $t = $e;\n             let v: $t = $e;\n             assert_eq!(S, v);\n-            assert_eq!(format!(\"{}\", v).as_slice(), $s);\n-            assert_eq!(format!(\"{}\", S).as_slice(), $s);\n+            assert_eq!(format!(\"{:?}\", v).as_slice(), $s);\n+            assert_eq!(format!(\"{:?}\", S).as_slice(), $s);\n         });*\n     }}\n }\n \n pub fn main() {\n     check!(Option<u8>, 2,\n            None, \"None\",\n-           Some(129u8), \"Some(129)\");\n+           Some(129u8), \"Some(129u8)\");\n     check!(Option<i16>, 4,\n            None, \"None\",\n-           Some(-20000i16), \"Some(-20000)\");\n+           Some(-20000i16), \"Some(-20000i16)\");\n     check!(Either<u8, i8>, 2,\n-           Either::Left(132u8), \"Left(132)\",\n-           Either::Right(-32i8), \"Right(-32)\");\n+           Either::Left(132u8), \"Left(132u8)\",\n+           Either::Right(-32i8), \"Right(-32i8)\");\n     check!(Either<u8, i16>, 4,\n-           Either::Left(132u8), \"Left(132)\",\n-           Either::Right(-20000i16), \"Right(-20000)\");\n+           Either::Left(132u8), \"Left(132u8)\",\n+           Either::Right(-20000i16), \"Right(-20000i16)\");\n }"}, {"sha": "7cba4533c7f59ce0a88b525a6248c990c2c026e3", "filename": "src/test/run-pass/supported-cast.rs", "status": "modified", "additions": 204, "deletions": 204, "changes": 408, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fsupported-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fsupported-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsupported-cast.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -12,208 +12,208 @@ extern crate libc;\n \n pub fn main() {\n   let f = 1u as *const libc::FILE;\n-  println!(\"{}\", f as int);\n-  println!(\"{}\", f as uint);\n-  println!(\"{}\", f as i8);\n-  println!(\"{}\", f as i16);\n-  println!(\"{}\", f as i32);\n-  println!(\"{}\", f as i64);\n-  println!(\"{}\", f as u8);\n-  println!(\"{}\", f as u16);\n-  println!(\"{}\", f as u32);\n-  println!(\"{}\", f as u64);\n-\n-  println!(\"{}\", 1 as int);\n-  println!(\"{}\", 1 as uint);\n-  println!(\"{}\", 1 as *const libc::FILE);\n-  println!(\"{}\", 1 as i8);\n-  println!(\"{}\", 1 as i16);\n-  println!(\"{}\", 1 as i32);\n-  println!(\"{}\", 1 as i64);\n-  println!(\"{}\", 1 as u8);\n-  println!(\"{}\", 1 as u16);\n-  println!(\"{}\", 1 as u32);\n-  println!(\"{}\", 1 as u64);\n-  println!(\"{}\", 1i as f32);\n-  println!(\"{}\", 1i as f64);\n-\n-  println!(\"{}\", 1u as int);\n-  println!(\"{}\", 1u as uint);\n-  println!(\"{}\", 1u as *const libc::FILE);\n-  println!(\"{}\", 1u as i8);\n-  println!(\"{}\", 1u as i16);\n-  println!(\"{}\", 1u as i32);\n-  println!(\"{}\", 1u as i64);\n-  println!(\"{}\", 1u as u8);\n-  println!(\"{}\", 1u as u16);\n-  println!(\"{}\", 1u as u32);\n-  println!(\"{}\", 1u as u64);\n-  println!(\"{}\", 1u as f32);\n-  println!(\"{}\", 1u as f64);\n-\n-  println!(\"{}\", 1i8 as int);\n-  println!(\"{}\", 1i8 as uint);\n-  println!(\"{}\", 1i8 as *const libc::FILE);\n-  println!(\"{}\", 1i8 as i8);\n-  println!(\"{}\", 1i8 as i16);\n-  println!(\"{}\", 1i8 as i32);\n-  println!(\"{}\", 1i8 as i64);\n-  println!(\"{}\", 1i8 as u8);\n-  println!(\"{}\", 1i8 as u16);\n-  println!(\"{}\", 1i8 as u32);\n-  println!(\"{}\", 1i8 as u64);\n-  println!(\"{}\", 1i8 as f32);\n-  println!(\"{}\", 1i8 as f64);\n-\n-  println!(\"{}\", 1u8 as int);\n-  println!(\"{}\", 1u8 as uint);\n-  println!(\"{}\", 1u8 as *const libc::FILE);\n-  println!(\"{}\", 1u8 as i8);\n-  println!(\"{}\", 1u8 as i16);\n-  println!(\"{}\", 1u8 as i32);\n-  println!(\"{}\", 1u8 as i64);\n-  println!(\"{}\", 1u8 as u8);\n-  println!(\"{}\", 1u8 as u16);\n-  println!(\"{}\", 1u8 as u32);\n-  println!(\"{}\", 1u8 as u64);\n-  println!(\"{}\", 1u8 as f32);\n-  println!(\"{}\", 1u8 as f64);\n-\n-  println!(\"{}\", 1i16 as int);\n-  println!(\"{}\", 1i16 as uint);\n-  println!(\"{}\", 1i16 as *const libc::FILE);\n-  println!(\"{}\", 1i16 as i8);\n-  println!(\"{}\", 1i16 as i16);\n-  println!(\"{}\", 1i16 as i32);\n-  println!(\"{}\", 1i16 as i64);\n-  println!(\"{}\", 1i16 as u8);\n-  println!(\"{}\", 1i16 as u16);\n-  println!(\"{}\", 1i16 as u32);\n-  println!(\"{}\", 1i16 as u64);\n-  println!(\"{}\", 1i16 as f32);\n-  println!(\"{}\", 1i16 as f64);\n-\n-  println!(\"{}\", 1u16 as int);\n-  println!(\"{}\", 1u16 as uint);\n-  println!(\"{}\", 1u16 as *const libc::FILE);\n-  println!(\"{}\", 1u16 as i8);\n-  println!(\"{}\", 1u16 as i16);\n-  println!(\"{}\", 1u16 as i32);\n-  println!(\"{}\", 1u16 as i64);\n-  println!(\"{}\", 1u16 as u8);\n-  println!(\"{}\", 1u16 as u16);\n-  println!(\"{}\", 1u16 as u32);\n-  println!(\"{}\", 1u16 as u64);\n-  println!(\"{}\", 1u16 as f32);\n-  println!(\"{}\", 1u16 as f64);\n-\n-  println!(\"{}\", 1i32 as int);\n-  println!(\"{}\", 1i32 as uint);\n-  println!(\"{}\", 1i32 as *const libc::FILE);\n-  println!(\"{}\", 1i32 as i8);\n-  println!(\"{}\", 1i32 as i16);\n-  println!(\"{}\", 1i32 as i32);\n-  println!(\"{}\", 1i32 as i64);\n-  println!(\"{}\", 1i32 as u8);\n-  println!(\"{}\", 1i32 as u16);\n-  println!(\"{}\", 1i32 as u32);\n-  println!(\"{}\", 1i32 as u64);\n-  println!(\"{}\", 1i32 as f32);\n-  println!(\"{}\", 1i32 as f64);\n-\n-  println!(\"{}\", 1u32 as int);\n-  println!(\"{}\", 1u32 as uint);\n-  println!(\"{}\", 1u32 as *const libc::FILE);\n-  println!(\"{}\", 1u32 as i8);\n-  println!(\"{}\", 1u32 as i16);\n-  println!(\"{}\", 1u32 as i32);\n-  println!(\"{}\", 1u32 as i64);\n-  println!(\"{}\", 1u32 as u8);\n-  println!(\"{}\", 1u32 as u16);\n-  println!(\"{}\", 1u32 as u32);\n-  println!(\"{}\", 1u32 as u64);\n-  println!(\"{}\", 1u32 as f32);\n-  println!(\"{}\", 1u32 as f64);\n-\n-  println!(\"{}\", 1i64 as int);\n-  println!(\"{}\", 1i64 as uint);\n-  println!(\"{}\", 1i64 as *const libc::FILE);\n-  println!(\"{}\", 1i64 as i8);\n-  println!(\"{}\", 1i64 as i16);\n-  println!(\"{}\", 1i64 as i32);\n-  println!(\"{}\", 1i64 as i64);\n-  println!(\"{}\", 1i64 as u8);\n-  println!(\"{}\", 1i64 as u16);\n-  println!(\"{}\", 1i64 as u32);\n-  println!(\"{}\", 1i64 as u64);\n-  println!(\"{}\", 1i64 as f32);\n-  println!(\"{}\", 1i64 as f64);\n-\n-  println!(\"{}\", 1u64 as int);\n-  println!(\"{}\", 1u64 as uint);\n-  println!(\"{}\", 1u64 as *const libc::FILE);\n-  println!(\"{}\", 1u64 as i8);\n-  println!(\"{}\", 1u64 as i16);\n-  println!(\"{}\", 1u64 as i32);\n-  println!(\"{}\", 1u64 as i64);\n-  println!(\"{}\", 1u64 as u8);\n-  println!(\"{}\", 1u64 as u16);\n-  println!(\"{}\", 1u64 as u32);\n-  println!(\"{}\", 1u64 as u64);\n-  println!(\"{}\", 1u64 as f32);\n-  println!(\"{}\", 1u64 as f64);\n-\n-  println!(\"{}\", 1u64 as int);\n-  println!(\"{}\", 1u64 as uint);\n-  println!(\"{}\", 1u64 as *const libc::FILE);\n-  println!(\"{}\", 1u64 as i8);\n-  println!(\"{}\", 1u64 as i16);\n-  println!(\"{}\", 1u64 as i32);\n-  println!(\"{}\", 1u64 as i64);\n-  println!(\"{}\", 1u64 as u8);\n-  println!(\"{}\", 1u64 as u16);\n-  println!(\"{}\", 1u64 as u32);\n-  println!(\"{}\", 1u64 as u64);\n-  println!(\"{}\", 1u64 as f32);\n-  println!(\"{}\", 1u64 as f64);\n-\n-  println!(\"{}\", true as int);\n-  println!(\"{}\", true as uint);\n-  println!(\"{}\", true as *const libc::FILE);\n-  println!(\"{}\", true as i8);\n-  println!(\"{}\", true as i16);\n-  println!(\"{}\", true as i32);\n-  println!(\"{}\", true as i64);\n-  println!(\"{}\", true as u8);\n-  println!(\"{}\", true as u16);\n-  println!(\"{}\", true as u32);\n-  println!(\"{}\", true as u64);\n-  println!(\"{}\", true as f32);\n-  println!(\"{}\", true as f64);\n-\n-  println!(\"{}\", 1f32 as int);\n-  println!(\"{}\", 1f32 as uint);\n-  println!(\"{}\", 1f32 as i8);\n-  println!(\"{}\", 1f32 as i16);\n-  println!(\"{}\", 1f32 as i32);\n-  println!(\"{}\", 1f32 as i64);\n-  println!(\"{}\", 1f32 as u8);\n-  println!(\"{}\", 1f32 as u16);\n-  println!(\"{}\", 1f32 as u32);\n-  println!(\"{}\", 1f32 as u64);\n-  println!(\"{}\", 1f32 as f32);\n-  println!(\"{}\", 1f32 as f64);\n-\n-  println!(\"{}\", 1f64 as int);\n-  println!(\"{}\", 1f64 as uint);\n-  println!(\"{}\", 1f64 as i8);\n-  println!(\"{}\", 1f64 as i16);\n-  println!(\"{}\", 1f64 as i32);\n-  println!(\"{}\", 1f64 as i64);\n-  println!(\"{}\", 1f64 as u8);\n-  println!(\"{}\", 1f64 as u16);\n-  println!(\"{}\", 1f64 as u32);\n-  println!(\"{}\", 1f64 as u64);\n-  println!(\"{}\", 1f64 as f32);\n-  println!(\"{}\", 1f64 as f64);\n+  println!(\"{:?}\", f as int);\n+  println!(\"{:?}\", f as uint);\n+  println!(\"{:?}\", f as i8);\n+  println!(\"{:?}\", f as i16);\n+  println!(\"{:?}\", f as i32);\n+  println!(\"{:?}\", f as i64);\n+  println!(\"{:?}\", f as u8);\n+  println!(\"{:?}\", f as u16);\n+  println!(\"{:?}\", f as u32);\n+  println!(\"{:?}\", f as u64);\n+\n+  println!(\"{:?}\", 1 as int);\n+  println!(\"{:?}\", 1 as uint);\n+  println!(\"{:?}\", 1 as *const libc::FILE);\n+  println!(\"{:?}\", 1 as i8);\n+  println!(\"{:?}\", 1 as i16);\n+  println!(\"{:?}\", 1 as i32);\n+  println!(\"{:?}\", 1 as i64);\n+  println!(\"{:?}\", 1 as u8);\n+  println!(\"{:?}\", 1 as u16);\n+  println!(\"{:?}\", 1 as u32);\n+  println!(\"{:?}\", 1 as u64);\n+  println!(\"{:?}\", 1i as f32);\n+  println!(\"{:?}\", 1i as f64);\n+\n+  println!(\"{:?}\", 1u as int);\n+  println!(\"{:?}\", 1u as uint);\n+  println!(\"{:?}\", 1u as *const libc::FILE);\n+  println!(\"{:?}\", 1u as i8);\n+  println!(\"{:?}\", 1u as i16);\n+  println!(\"{:?}\", 1u as i32);\n+  println!(\"{:?}\", 1u as i64);\n+  println!(\"{:?}\", 1u as u8);\n+  println!(\"{:?}\", 1u as u16);\n+  println!(\"{:?}\", 1u as u32);\n+  println!(\"{:?}\", 1u as u64);\n+  println!(\"{:?}\", 1u as f32);\n+  println!(\"{:?}\", 1u as f64);\n+\n+  println!(\"{:?}\", 1i8 as int);\n+  println!(\"{:?}\", 1i8 as uint);\n+  println!(\"{:?}\", 1i8 as *const libc::FILE);\n+  println!(\"{:?}\", 1i8 as i8);\n+  println!(\"{:?}\", 1i8 as i16);\n+  println!(\"{:?}\", 1i8 as i32);\n+  println!(\"{:?}\", 1i8 as i64);\n+  println!(\"{:?}\", 1i8 as u8);\n+  println!(\"{:?}\", 1i8 as u16);\n+  println!(\"{:?}\", 1i8 as u32);\n+  println!(\"{:?}\", 1i8 as u64);\n+  println!(\"{:?}\", 1i8 as f32);\n+  println!(\"{:?}\", 1i8 as f64);\n+\n+  println!(\"{:?}\", 1u8 as int);\n+  println!(\"{:?}\", 1u8 as uint);\n+  println!(\"{:?}\", 1u8 as *const libc::FILE);\n+  println!(\"{:?}\", 1u8 as i8);\n+  println!(\"{:?}\", 1u8 as i16);\n+  println!(\"{:?}\", 1u8 as i32);\n+  println!(\"{:?}\", 1u8 as i64);\n+  println!(\"{:?}\", 1u8 as u8);\n+  println!(\"{:?}\", 1u8 as u16);\n+  println!(\"{:?}\", 1u8 as u32);\n+  println!(\"{:?}\", 1u8 as u64);\n+  println!(\"{:?}\", 1u8 as f32);\n+  println!(\"{:?}\", 1u8 as f64);\n+\n+  println!(\"{:?}\", 1i16 as int);\n+  println!(\"{:?}\", 1i16 as uint);\n+  println!(\"{:?}\", 1i16 as *const libc::FILE);\n+  println!(\"{:?}\", 1i16 as i8);\n+  println!(\"{:?}\", 1i16 as i16);\n+  println!(\"{:?}\", 1i16 as i32);\n+  println!(\"{:?}\", 1i16 as i64);\n+  println!(\"{:?}\", 1i16 as u8);\n+  println!(\"{:?}\", 1i16 as u16);\n+  println!(\"{:?}\", 1i16 as u32);\n+  println!(\"{:?}\", 1i16 as u64);\n+  println!(\"{:?}\", 1i16 as f32);\n+  println!(\"{:?}\", 1i16 as f64);\n+\n+  println!(\"{:?}\", 1u16 as int);\n+  println!(\"{:?}\", 1u16 as uint);\n+  println!(\"{:?}\", 1u16 as *const libc::FILE);\n+  println!(\"{:?}\", 1u16 as i8);\n+  println!(\"{:?}\", 1u16 as i16);\n+  println!(\"{:?}\", 1u16 as i32);\n+  println!(\"{:?}\", 1u16 as i64);\n+  println!(\"{:?}\", 1u16 as u8);\n+  println!(\"{:?}\", 1u16 as u16);\n+  println!(\"{:?}\", 1u16 as u32);\n+  println!(\"{:?}\", 1u16 as u64);\n+  println!(\"{:?}\", 1u16 as f32);\n+  println!(\"{:?}\", 1u16 as f64);\n+\n+  println!(\"{:?}\", 1i32 as int);\n+  println!(\"{:?}\", 1i32 as uint);\n+  println!(\"{:?}\", 1i32 as *const libc::FILE);\n+  println!(\"{:?}\", 1i32 as i8);\n+  println!(\"{:?}\", 1i32 as i16);\n+  println!(\"{:?}\", 1i32 as i32);\n+  println!(\"{:?}\", 1i32 as i64);\n+  println!(\"{:?}\", 1i32 as u8);\n+  println!(\"{:?}\", 1i32 as u16);\n+  println!(\"{:?}\", 1i32 as u32);\n+  println!(\"{:?}\", 1i32 as u64);\n+  println!(\"{:?}\", 1i32 as f32);\n+  println!(\"{:?}\", 1i32 as f64);\n+\n+  println!(\"{:?}\", 1u32 as int);\n+  println!(\"{:?}\", 1u32 as uint);\n+  println!(\"{:?}\", 1u32 as *const libc::FILE);\n+  println!(\"{:?}\", 1u32 as i8);\n+  println!(\"{:?}\", 1u32 as i16);\n+  println!(\"{:?}\", 1u32 as i32);\n+  println!(\"{:?}\", 1u32 as i64);\n+  println!(\"{:?}\", 1u32 as u8);\n+  println!(\"{:?}\", 1u32 as u16);\n+  println!(\"{:?}\", 1u32 as u32);\n+  println!(\"{:?}\", 1u32 as u64);\n+  println!(\"{:?}\", 1u32 as f32);\n+  println!(\"{:?}\", 1u32 as f64);\n+\n+  println!(\"{:?}\", 1i64 as int);\n+  println!(\"{:?}\", 1i64 as uint);\n+  println!(\"{:?}\", 1i64 as *const libc::FILE);\n+  println!(\"{:?}\", 1i64 as i8);\n+  println!(\"{:?}\", 1i64 as i16);\n+  println!(\"{:?}\", 1i64 as i32);\n+  println!(\"{:?}\", 1i64 as i64);\n+  println!(\"{:?}\", 1i64 as u8);\n+  println!(\"{:?}\", 1i64 as u16);\n+  println!(\"{:?}\", 1i64 as u32);\n+  println!(\"{:?}\", 1i64 as u64);\n+  println!(\"{:?}\", 1i64 as f32);\n+  println!(\"{:?}\", 1i64 as f64);\n+\n+  println!(\"{:?}\", 1u64 as int);\n+  println!(\"{:?}\", 1u64 as uint);\n+  println!(\"{:?}\", 1u64 as *const libc::FILE);\n+  println!(\"{:?}\", 1u64 as i8);\n+  println!(\"{:?}\", 1u64 as i16);\n+  println!(\"{:?}\", 1u64 as i32);\n+  println!(\"{:?}\", 1u64 as i64);\n+  println!(\"{:?}\", 1u64 as u8);\n+  println!(\"{:?}\", 1u64 as u16);\n+  println!(\"{:?}\", 1u64 as u32);\n+  println!(\"{:?}\", 1u64 as u64);\n+  println!(\"{:?}\", 1u64 as f32);\n+  println!(\"{:?}\", 1u64 as f64);\n+\n+  println!(\"{:?}\", 1u64 as int);\n+  println!(\"{:?}\", 1u64 as uint);\n+  println!(\"{:?}\", 1u64 as *const libc::FILE);\n+  println!(\"{:?}\", 1u64 as i8);\n+  println!(\"{:?}\", 1u64 as i16);\n+  println!(\"{:?}\", 1u64 as i32);\n+  println!(\"{:?}\", 1u64 as i64);\n+  println!(\"{:?}\", 1u64 as u8);\n+  println!(\"{:?}\", 1u64 as u16);\n+  println!(\"{:?}\", 1u64 as u32);\n+  println!(\"{:?}\", 1u64 as u64);\n+  println!(\"{:?}\", 1u64 as f32);\n+  println!(\"{:?}\", 1u64 as f64);\n+\n+  println!(\"{:?}\", true as int);\n+  println!(\"{:?}\", true as uint);\n+  println!(\"{:?}\", true as *const libc::FILE);\n+  println!(\"{:?}\", true as i8);\n+  println!(\"{:?}\", true as i16);\n+  println!(\"{:?}\", true as i32);\n+  println!(\"{:?}\", true as i64);\n+  println!(\"{:?}\", true as u8);\n+  println!(\"{:?}\", true as u16);\n+  println!(\"{:?}\", true as u32);\n+  println!(\"{:?}\", true as u64);\n+  println!(\"{:?}\", true as f32);\n+  println!(\"{:?}\", true as f64);\n+\n+  println!(\"{:?}\", 1f32 as int);\n+  println!(\"{:?}\", 1f32 as uint);\n+  println!(\"{:?}\", 1f32 as i8);\n+  println!(\"{:?}\", 1f32 as i16);\n+  println!(\"{:?}\", 1f32 as i32);\n+  println!(\"{:?}\", 1f32 as i64);\n+  println!(\"{:?}\", 1f32 as u8);\n+  println!(\"{:?}\", 1f32 as u16);\n+  println!(\"{:?}\", 1f32 as u32);\n+  println!(\"{:?}\", 1f32 as u64);\n+  println!(\"{:?}\", 1f32 as f32);\n+  println!(\"{:?}\", 1f32 as f64);\n+\n+  println!(\"{:?}\", 1f64 as int);\n+  println!(\"{:?}\", 1f64 as uint);\n+  println!(\"{:?}\", 1f64 as i8);\n+  println!(\"{:?}\", 1f64 as i16);\n+  println!(\"{:?}\", 1f64 as i32);\n+  println!(\"{:?}\", 1f64 as i64);\n+  println!(\"{:?}\", 1f64 as u8);\n+  println!(\"{:?}\", 1f64 as u16);\n+  println!(\"{:?}\", 1f64 as u32);\n+  println!(\"{:?}\", 1f64 as u64);\n+  println!(\"{:?}\", 1f64 as f32);\n+  println!(\"{:?}\", 1f64 as f64);\n }"}, {"sha": "b88357252d8ed617e260e55a123850cdb9babc28", "filename": "src/test/run-pass/tag-align-shape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Ftag-align-shape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Ftag-align-shape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-align-shape.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -21,7 +21,7 @@ struct t_rec {\n \n pub fn main() {\n     let x = t_rec {c8: 22u8, t: a_tag::a_tag_var(44u64)};\n-    let y = format!(\"{}\", x);\n-    println!(\"y = {}\", y);\n-    assert_eq!(y, \"t_rec { c8: 22, t: a_tag_var(44) }\".to_string());\n+    let y = format!(\"{:?}\", x);\n+    println!(\"y = {:?}\", y);\n+    assert_eq!(y, \"t_rec { c8: 22u8, t: a_tag_var(44u64) }\".to_string());\n }"}, {"sha": "049e4bb9a38ef084d3a7550e002131273bdd08da", "filename": "src/test/run-pass/tag-disr-val-shape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Ftag-disr-val-shape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Ftag-disr-val-shape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-disr-val-shape.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -18,9 +18,9 @@ enum color {\n }\n \n pub fn main() {\n-    let act = format!(\"{}\", color::red);\n+    let act = format!(\"{:?}\", color::red);\n     println!(\"{}\", act);\n     assert_eq!(\"red\".to_string(), act);\n-    assert_eq!(\"green\".to_string(), format!(\"{}\", color::green));\n-    assert_eq!(\"white\".to_string(), format!(\"{}\", color::white));\n+    assert_eq!(\"green\".to_string(), format!(\"{:?}\", color::green));\n+    assert_eq!(\"white\".to_string(), format!(\"{:?}\", color::white));\n }"}, {"sha": "df8efb42e30e5bdfcedf2dd13ccf167259491aab", "filename": "src/test/run-pass/trivial-message.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Ftrivial-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Ftrivial-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrivial-message.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -19,5 +19,5 @@ pub fn main() {\n     let (tx, rx) = channel();\n     tx.send(42i);\n     let r = rx.recv();\n-    println!(\"{}\", r);\n+    println!(\"{:?}\", r);\n }"}, {"sha": "d7a78dbc4119ba9ca29008a204457d2ca79b67d7", "filename": "src/test/run-pass/tuple-struct-construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Ftuple-struct-construct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Ftuple-struct-construct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftuple-struct-construct.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -13,5 +13,5 @@ struct Foo(int, int);\n \n pub fn main() {\n     let x = Foo(1, 2);\n-    println!(\"{}\", x);\n+    println!(\"{:?}\", x);\n }"}, {"sha": "0a65cd3a7ac95049b3fcdb7c3e8309fa8e80d73f", "filename": "src/test/run-pass/vec-to_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fvec-to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Ftest%2Frun-pass%2Fvec-to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-to_str.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n pub fn main() {\n-    assert_eq!((vec!(0i, 1)).to_string(), \"[0, 1]\".to_string());\n+    assert_eq!((vec!(0i, 1)).to_string(), \"0, 1\".to_string());\n \n     let foo = vec!(3i, 4);\n     let bar: &[int] = &[4, 5];\n \n-    assert_eq!(foo.to_string(), \"[3, 4]\".to_string());\n-    assert_eq!(bar.to_string(), \"[4, 5]\".to_string());\n+    assert_eq!(foo.to_string(), \"3, 4\".to_string());\n+    assert_eq!(bar.to_string(), \"4, 5\".to_string());\n }"}]}