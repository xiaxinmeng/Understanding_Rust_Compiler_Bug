{"sha": "b565fe241e9a3a29d725468fdf8da65622665444", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1NjVmZTI0MWU5YTNhMjlkNzI1NDY4ZmRmOGRhNjU2MjI2NjU0NDQ=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-12-01T10:50:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-12-01T10:50:02Z"}, "message": "Rollup merge of #79038 - CDirkx:move-ui-tests, r=dtolnay\n\nChange ui test that are run-pass and that do not test the compiler to library tests\n\nPart of #76268, these are some of the relevant ui tests I found that can be replaced by library tests.\n\nNote: this PR just moves the tests, I have not checked for any overlap between these tests and existing library tests. The only test I changed is `env_home_dir`, where I added code to restore the old home dir after testing.\n\nAll moved tests:\n\n| ui test | library test file | test |\n| --- | --- | --- |\n| `const\\ascii_ctype.rs` | `core\\tests\\ascii.rs` | `ascii_ctype_const` |\n| `const\\const-str-ptr.rs` | `alloc\\tests\\str.rs` | `const_str_ptr` |\n| `assert-eq-trailing-comma.rs` | `core\\tests\\macros.rs` | `assert_eq_trailing_comma` |\n| `assert-escape.rs` | `core\\tests\\macros.rs` | `assert_escape` |\n| `assert-ne-trailing-comma.rs` | `core\\tests\\macros.rs` | `assert_ne_trailing_comma` |\n| `atomic-access-bool.rs` | `core\\tests\\atomic.rs` | `atomic_access_bool` |\n| `atomic-alignment.rs` | `core\\tests\\atomic.rs` | `atomic_alignment` |\n| `atomic-compare_exchange.rs` | `core\\tests\\atomic.rs` | `atomic_compare_exchange` |\n| ~~`atomic-print.rs`~~ | ~~`std\\tests\\process.rs`~~ | ~~`atomic_print`~~ |\n| `bool.rs` | `core\\tests\\bool.rs` | `test_bool` |\n| `bool_not.rs` | `core\\tests\\bool.rs` | `test_bool_not` |\n| `char_unicode.rs` | `core\\tests\\unicode.rs` | `version` |\n| `cmp-default.rs` | `core\\tests\\cmp.rs` | `cmp_default` |\n| `deref-mut-on-ref.rs` | `core\\tests\\ops.rs` | `deref_mut_on_ref` |\n| `deref-on-ref.rs` | `core\\tests\\ops.rs` | `deref_on_ref` |\n| `env-home-dir.rs` | `std\\tests\\env.rs` | `env_home_dir` |\n| ~~`env-vars.rs`~~ | ~~`std\\tests\\env.rs`~~ | ~~`env_vars`~~ |\n| `extend-for-unit.rs` | `core\\tests\\iter.rs` | `extend_for_unit` |\n| `offset_from.rs` | `core\\tests\\ptr.rs` | `offset_from` |\n| `option-ext.rs` | `core\\tests\\option.rs` | `option_ext` |\n| `result-opt-conversions.rs` | `core\\tests\\result.rs` | `result_opt_conversions` |\n| `sleep.rs` | `std\\tests\\thread.rs` | `sleep` |\n| ~~`try-wait.rs`~~ | ~~`std\\tests\\process.rs`~~ | ~~`try_wait`~~ |\n| `utf8.rs` | `alloc\\tests\\str.rs` | `utf8` |\n| `utf8_chars.rs` | `alloc\\tests\\str.rs` | `utf8_chars` |\n| `wrapping-int-api.rs` | `core\\tests\\num\\wrapping.rs` | `wrapping_int_api` |", "tree": {"sha": "7d04db6fb82a39d5724074b6e0e98914295cf4f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d04db6fb82a39d5724074b6e0e98914295cf4f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b565fe241e9a3a29d725468fdf8da65622665444", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfxh/bCRBK7hj4Ov3rIwAAdHIIAKG0Zsp3Hl2v+2etq5HrwfWs\ndee1RTuuZszExPYSMtgDTCxhbDmlxCrWMXWt4EYF/0JKnRdYRChCbCOmArhHAtjj\n3eWFn7q5pzd+z9HxCIOF7KpCzbxsCEJ3Y0u3aZnSR9jj8IKuzcd53iBDSkrm1UMn\nAGTJSjoK/zPpBgAMuKyEOutEehEsNf/JQnGB6hS6ftdWRL5KpRGnIUljAPpksqTt\n3EPsRXzkeasAkquatb68rE/CUTnxGrXIhH1Hebl94J3fbcJoVLnJAIbFXD+MUYQo\neh/zJW5ZtdDNf8rM7T6ODSWfN7f6kBmwc5vpD/QxIjEOqh+pmVbn34a8RZElAgU=\n=narM\n-----END PGP SIGNATURE-----\n", "payload": "tree 7d04db6fb82a39d5724074b6e0e98914295cf4f3\nparent c4926d01ada661d4fbffb0e5b1708ae5463d47b3\nparent be554c4101df2a9ac65d40962ee37ece85d517bf\nauthor Mara Bos <m-ou.se@m-ou.se> 1606819802 +0000\ncommitter GitHub <noreply@github.com> 1606819802 +0000\n\nRollup merge of #79038 - CDirkx:move-ui-tests, r=dtolnay\n\nChange ui test that are run-pass and that do not test the compiler to library tests\n\nPart of #76268, these are some of the relevant ui tests I found that can be replaced by library tests.\n\nNote: this PR just moves the tests, I have not checked for any overlap between these tests and existing library tests. The only test I changed is `env_home_dir`, where I added code to restore the old home dir after testing.\n\nAll moved tests:\n\n| ui test | library test file | test |\n| --- | --- | --- |\n| `const\\ascii_ctype.rs` | `core\\tests\\ascii.rs` | `ascii_ctype_const` |\n| `const\\const-str-ptr.rs` | `alloc\\tests\\str.rs` | `const_str_ptr` |\n| `assert-eq-trailing-comma.rs` | `core\\tests\\macros.rs` | `assert_eq_trailing_comma` |\n| `assert-escape.rs` | `core\\tests\\macros.rs` | `assert_escape` |\n| `assert-ne-trailing-comma.rs` | `core\\tests\\macros.rs` | `assert_ne_trailing_comma` |\n| `atomic-access-bool.rs` | `core\\tests\\atomic.rs` | `atomic_access_bool` |\n| `atomic-alignment.rs` | `core\\tests\\atomic.rs` | `atomic_alignment` |\n| `atomic-compare_exchange.rs` | `core\\tests\\atomic.rs` | `atomic_compare_exchange` |\n| ~~`atomic-print.rs`~~ | ~~`std\\tests\\process.rs`~~ | ~~`atomic_print`~~ |\n| `bool.rs` | `core\\tests\\bool.rs` | `test_bool` |\n| `bool_not.rs` | `core\\tests\\bool.rs` | `test_bool_not` |\n| `char_unicode.rs` | `core\\tests\\unicode.rs` | `version` |\n| `cmp-default.rs` | `core\\tests\\cmp.rs` | `cmp_default` |\n| `deref-mut-on-ref.rs` | `core\\tests\\ops.rs` | `deref_mut_on_ref` |\n| `deref-on-ref.rs` | `core\\tests\\ops.rs` | `deref_on_ref` |\n| `env-home-dir.rs` | `std\\tests\\env.rs` | `env_home_dir` |\n| ~~`env-vars.rs`~~ | ~~`std\\tests\\env.rs`~~ | ~~`env_vars`~~ |\n| `extend-for-unit.rs` | `core\\tests\\iter.rs` | `extend_for_unit` |\n| `offset_from.rs` | `core\\tests\\ptr.rs` | `offset_from` |\n| `option-ext.rs` | `core\\tests\\option.rs` | `option_ext` |\n| `result-opt-conversions.rs` | `core\\tests\\result.rs` | `result_opt_conversions` |\n| `sleep.rs` | `std\\tests\\thread.rs` | `sleep` |\n| ~~`try-wait.rs`~~ | ~~`std\\tests\\process.rs`~~ | ~~`try_wait`~~ |\n| `utf8.rs` | `alloc\\tests\\str.rs` | `utf8` |\n| `utf8_chars.rs` | `alloc\\tests\\str.rs` | `utf8_chars` |\n| `wrapping-int-api.rs` | `core\\tests\\num\\wrapping.rs` | `wrapping_int_api` |\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b565fe241e9a3a29d725468fdf8da65622665444", "html_url": "https://github.com/rust-lang/rust/commit/b565fe241e9a3a29d725468fdf8da65622665444", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b565fe241e9a3a29d725468fdf8da65622665444/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "html_url": "https://github.com/rust-lang/rust/commit/c4926d01ada661d4fbffb0e5b1708ae5463d47b3"}, {"sha": "be554c4101df2a9ac65d40962ee37ece85d517bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/be554c4101df2a9ac65d40962ee37ece85d517bf", "html_url": "https://github.com/rust-lang/rust/commit/be554c4101df2a9ac65d40962ee37ece85d517bf"}], "stats": {"total": 1632, "additions": 812, "deletions": 820}, "files": [{"sha": "b13019146568cc35fa1043f458496ffc3b75b1aa", "filename": "library/alloc/tests/str.rs", "status": "modified", "additions": 95, "deletions": 1, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/b565fe241e9a3a29d725468fdf8da65622665444/library%2Falloc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565fe241e9a3a29d725468fdf8da65622665444/library%2Falloc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstr.rs?ref=b565fe241e9a3a29d725468fdf8da65622665444", "patch": "@@ -1,6 +1,6 @@\n use std::borrow::Cow;\n use std::cmp::Ordering::{Equal, Greater, Less};\n-use std::str::from_utf8;\n+use std::str::{from_utf8, from_utf8_unchecked};\n \n #[test]\n fn test_le() {\n@@ -1971,3 +1971,97 @@ fn test_str_escapes() {\n     \";\n     assert_eq!(x, r\"\\\\\"); // extraneous whitespace stripped\n }\n+\n+#[test]\n+fn const_str_ptr() {\n+    const A: [u8; 2] = ['h' as u8, 'i' as u8];\n+    const B: &'static [u8; 2] = &A;\n+    const C: *const u8 = B as *const u8;\n+\n+    unsafe {\n+        let foo = &A as *const u8;\n+        assert_eq!(foo, C);\n+        assert_eq!(from_utf8_unchecked(&A), \"hi\");\n+        assert_eq!(*C, A[0]);\n+        assert_eq!(*(&B[0] as *const u8), A[0]);\n+    }\n+}\n+\n+#[test]\n+fn utf8() {\n+    let yen: char = '\u00a5'; // 0xa5\n+    let c_cedilla: char = '\u00e7'; // 0xe7\n+    let thorn: char = '\u00fe'; // 0xfe\n+    let y_diaeresis: char = '\u00ff'; // 0xff\n+    let pi: char = '\u03a0'; // 0x3a0\n+\n+    assert_eq!(yen as isize, 0xa5);\n+    assert_eq!(c_cedilla as isize, 0xe7);\n+    assert_eq!(thorn as isize, 0xfe);\n+    assert_eq!(y_diaeresis as isize, 0xff);\n+    assert_eq!(pi as isize, 0x3a0);\n+\n+    assert_eq!(pi as isize, '\\u{3a0}' as isize);\n+    assert_eq!('\\x0a' as isize, '\\n' as isize);\n+\n+    let bhutan: String = \"\u0f60\u0f56\u0fb2\u0f74\u0f42\u0f0b\u0f61\u0f74\u0f63\u0f0d\".to_string();\n+    let japan: String = \"\u65e5\u672c\".to_string();\n+    let uzbekistan: String = \"\u040e\u0437\u0431\u0435\u043a\u0438\u0441\u0442\u043e\u043d\".to_string();\n+    let austria: String = \"\u00d6sterreich\".to_string();\n+\n+    let bhutan_e: String =\n+        \"\\u{f60}\\u{f56}\\u{fb2}\\u{f74}\\u{f42}\\u{f0b}\\u{f61}\\u{f74}\\u{f63}\\u{f0d}\".to_string();\n+    let japan_e: String = \"\\u{65e5}\\u{672c}\".to_string();\n+    let uzbekistan_e: String =\n+        \"\\u{40e}\\u{437}\\u{431}\\u{435}\\u{43a}\\u{438}\\u{441}\\u{442}\\u{43e}\\u{43d}\".to_string();\n+    let austria_e: String = \"\\u{d6}sterreich\".to_string();\n+\n+    let oo: char = '\u00d6';\n+    assert_eq!(oo as isize, 0xd6);\n+\n+    fn check_str_eq(a: String, b: String) {\n+        let mut i: isize = 0;\n+        for ab in a.bytes() {\n+            println!(\"{}\", i);\n+            println!(\"{}\", ab);\n+            let bb: u8 = b.as_bytes()[i as usize];\n+            println!(\"{}\", bb);\n+            assert_eq!(ab, bb);\n+            i += 1;\n+        }\n+    }\n+\n+    check_str_eq(bhutan, bhutan_e);\n+    check_str_eq(japan, japan_e);\n+    check_str_eq(uzbekistan, uzbekistan_e);\n+    check_str_eq(austria, austria_e);\n+}\n+\n+#[test]\n+fn utf8_chars() {\n+    // Chars of 1, 2, 3, and 4 bytes\n+    let chs: Vec<char> = vec!['e', '\u00e9', '\u20ac', '\\u{10000}'];\n+    let s: String = chs.iter().cloned().collect();\n+    let schs: Vec<char> = s.chars().collect();\n+\n+    assert_eq!(s.len(), 10);\n+    assert_eq!(s.chars().count(), 4);\n+    assert_eq!(schs.len(), 4);\n+    assert_eq!(schs.iter().cloned().collect::<String>(), s);\n+\n+    assert!((from_utf8(s.as_bytes()).is_ok()));\n+    // invalid prefix\n+    assert!((!from_utf8(&[0x80]).is_ok()));\n+    // invalid 2 byte prefix\n+    assert!((!from_utf8(&[0xc0]).is_ok()));\n+    assert!((!from_utf8(&[0xc0, 0x10]).is_ok()));\n+    // invalid 3 byte prefix\n+    assert!((!from_utf8(&[0xe0]).is_ok()));\n+    assert!((!from_utf8(&[0xe0, 0x10]).is_ok()));\n+    assert!((!from_utf8(&[0xe0, 0xff, 0x10]).is_ok()));\n+    // invalid 4 byte prefix\n+    assert!((!from_utf8(&[0xf0]).is_ok()));\n+    assert!((!from_utf8(&[0xf0, 0x10]).is_ok()));\n+    assert!((!from_utf8(&[0xf0, 0xff, 0x10]).is_ok()));\n+    assert!((!from_utf8(&[0xf0, 0xff, 0xff, 0x10]).is_ok()));\n+}"}, {"sha": "66c25e449df2b9f7035404899ede8c331f53ed13", "filename": "library/core/tests/ascii.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fcore%2Ftests%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fcore%2Ftests%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fascii.rs?ref=b565fe241e9a3a29d725468fdf8da65622665444", "patch": "@@ -408,3 +408,56 @@ fn ascii_const() {\n     const BYTE_IS_ASCII: bool = 97u8.is_ascii();\n     assert!(BYTE_IS_ASCII);\n }\n+\n+#[test]\n+fn ascii_ctype_const() {\n+    macro_rules! suite {\n+        ( $( $fn:ident => [$a:ident, $A:ident, $nine:ident, $dot:ident, $space:ident]; )* ) => {\n+            $(\n+                mod $fn {\n+                    const CHAR_A_LOWER: bool = 'a'.$fn();\n+                    const CHAR_A_UPPER: bool = 'A'.$fn();\n+                    const CHAR_NINE: bool = '9'.$fn();\n+                    const CHAR_DOT: bool = '.'.$fn();\n+                    const CHAR_SPACE: bool = ' '.$fn();\n+\n+                    const U8_A_LOWER: bool = b'a'.$fn();\n+                    const U8_A_UPPER: bool = b'A'.$fn();\n+                    const U8_NINE: bool = b'9'.$fn();\n+                    const U8_DOT: bool = b'.'.$fn();\n+                    const U8_SPACE: bool = b' '.$fn();\n+\n+                    pub fn run() {\n+                        assert_eq!(CHAR_A_LOWER, $a);\n+                        assert_eq!(CHAR_A_UPPER, $A);\n+                        assert_eq!(CHAR_NINE, $nine);\n+                        assert_eq!(CHAR_DOT, $dot);\n+                        assert_eq!(CHAR_SPACE, $space);\n+\n+                        assert_eq!(U8_A_LOWER, $a);\n+                        assert_eq!(U8_A_UPPER, $A);\n+                        assert_eq!(U8_NINE, $nine);\n+                        assert_eq!(U8_DOT, $dot);\n+                        assert_eq!(U8_SPACE, $space);\n+                    }\n+                }\n+            )*\n+\n+            $( $fn::run(); )*\n+        }\n+    }\n+\n+    suite! {\n+        //                        'a'    'A'    '9'    '.'    ' '\n+        is_ascii_alphabetic   => [true,  true,  false, false, false];\n+        is_ascii_uppercase    => [false, true,  false, false, false];\n+        is_ascii_lowercase    => [true,  false, false, false, false];\n+        is_ascii_alphanumeric => [true,  true,  true,  false, false];\n+        is_ascii_digit        => [false, false, true,  false, false];\n+        is_ascii_hexdigit     => [true,  true,  true,  false, false];\n+        is_ascii_punctuation  => [false, false, false, true,  false];\n+        is_ascii_graphic      => [true,  true,  true,  true,  false];\n+        is_ascii_whitespace   => [false, false, false, false, true];\n+        is_ascii_control      => [false, false, false, false, false];\n+    }\n+}"}, {"sha": "75528ebb54eafdeebef52ac4d6c0030739ad3868", "filename": "library/core/tests/atomic.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fcore%2Ftests%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fcore%2Ftests%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fatomic.rs?ref=b565fe241e9a3a29d725468fdf8da65622665444", "patch": "@@ -101,3 +101,82 @@ fn static_init() {\n     assert!(S_INT.fetch_add(1, SeqCst) == 0);\n     assert!(S_UINT.fetch_add(1, SeqCst) == 0);\n }\n+\n+#[test]\n+fn atomic_access_bool() {\n+    static mut ATOMIC: AtomicBool = AtomicBool::new(false);\n+\n+    unsafe {\n+        assert_eq!(*ATOMIC.get_mut(), false);\n+        ATOMIC.store(true, SeqCst);\n+        assert_eq!(*ATOMIC.get_mut(), true);\n+        ATOMIC.fetch_or(false, SeqCst);\n+        assert_eq!(*ATOMIC.get_mut(), true);\n+        ATOMIC.fetch_and(false, SeqCst);\n+        assert_eq!(*ATOMIC.get_mut(), false);\n+        ATOMIC.fetch_nand(true, SeqCst);\n+        assert_eq!(*ATOMIC.get_mut(), true);\n+        ATOMIC.fetch_xor(true, SeqCst);\n+        assert_eq!(*ATOMIC.get_mut(), false);\n+    }\n+}\n+\n+#[test]\n+fn atomic_alignment() {\n+    use std::mem::{align_of, size_of};\n+\n+    #[cfg(target_has_atomic = \"8\")]\n+    assert_eq!(align_of::<AtomicBool>(), size_of::<AtomicBool>());\n+    #[cfg(target_has_atomic = \"ptr\")]\n+    assert_eq!(align_of::<AtomicPtr<u8>>(), size_of::<AtomicPtr<u8>>());\n+    #[cfg(target_has_atomic = \"8\")]\n+    assert_eq!(align_of::<AtomicU8>(), size_of::<AtomicU8>());\n+    #[cfg(target_has_atomic = \"8\")]\n+    assert_eq!(align_of::<AtomicI8>(), size_of::<AtomicI8>());\n+    #[cfg(target_has_atomic = \"16\")]\n+    assert_eq!(align_of::<AtomicU16>(), size_of::<AtomicU16>());\n+    #[cfg(target_has_atomic = \"16\")]\n+    assert_eq!(align_of::<AtomicI16>(), size_of::<AtomicI16>());\n+    #[cfg(target_has_atomic = \"32\")]\n+    assert_eq!(align_of::<AtomicU32>(), size_of::<AtomicU32>());\n+    #[cfg(target_has_atomic = \"32\")]\n+    assert_eq!(align_of::<AtomicI32>(), size_of::<AtomicI32>());\n+    #[cfg(target_has_atomic = \"64\")]\n+    assert_eq!(align_of::<AtomicU64>(), size_of::<AtomicU64>());\n+    #[cfg(target_has_atomic = \"64\")]\n+    assert_eq!(align_of::<AtomicI64>(), size_of::<AtomicI64>());\n+    #[cfg(target_has_atomic = \"128\")]\n+    assert_eq!(align_of::<AtomicU128>(), size_of::<AtomicU128>());\n+    #[cfg(target_has_atomic = \"128\")]\n+    assert_eq!(align_of::<AtomicI128>(), size_of::<AtomicI128>());\n+    #[cfg(target_has_atomic = \"ptr\")]\n+    assert_eq!(align_of::<AtomicUsize>(), size_of::<AtomicUsize>());\n+    #[cfg(target_has_atomic = \"ptr\")]\n+    assert_eq!(align_of::<AtomicIsize>(), size_of::<AtomicIsize>());\n+}\n+\n+#[test]\n+fn atomic_compare_exchange() {\n+    use Ordering::*;\n+\n+    static ATOMIC: AtomicIsize = AtomicIsize::new(0);\n+\n+    ATOMIC.compare_exchange(0, 1, Relaxed, Relaxed).ok();\n+    ATOMIC.compare_exchange(0, 1, Acquire, Relaxed).ok();\n+    ATOMIC.compare_exchange(0, 1, Release, Relaxed).ok();\n+    ATOMIC.compare_exchange(0, 1, AcqRel, Relaxed).ok();\n+    ATOMIC.compare_exchange(0, 1, SeqCst, Relaxed).ok();\n+    ATOMIC.compare_exchange(0, 1, Acquire, Acquire).ok();\n+    ATOMIC.compare_exchange(0, 1, AcqRel, Acquire).ok();\n+    ATOMIC.compare_exchange(0, 1, SeqCst, Acquire).ok();\n+    ATOMIC.compare_exchange(0, 1, SeqCst, SeqCst).ok();\n+    ATOMIC.compare_exchange_weak(0, 1, Relaxed, Relaxed).ok();\n+    ATOMIC.compare_exchange_weak(0, 1, Acquire, Relaxed).ok();\n+    ATOMIC.compare_exchange_weak(0, 1, Release, Relaxed).ok();\n+    ATOMIC.compare_exchange_weak(0, 1, AcqRel, Relaxed).ok();\n+    ATOMIC.compare_exchange_weak(0, 1, SeqCst, Relaxed).ok();\n+    ATOMIC.compare_exchange_weak(0, 1, Acquire, Acquire).ok();\n+    ATOMIC.compare_exchange_weak(0, 1, AcqRel, Acquire).ok();\n+    ATOMIC.compare_exchange_weak(0, 1, SeqCst, Acquire).ok();\n+    ATOMIC.compare_exchange_weak(0, 1, SeqCst, SeqCst).ok();\n+}"}, {"sha": "e40f0482aee3e2f1f87b7d48c4da73e665a8eda6", "filename": "library/core/tests/bool.rs", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fcore%2Ftests%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fcore%2Ftests%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fbool.rs?ref=b565fe241e9a3a29d725468fdf8da65622665444", "patch": "@@ -1,3 +1,87 @@\n+use core::cmp::Ordering::{Equal, Greater, Less};\n+use core::ops::{BitAnd, BitOr, BitXor};\n+\n+#[test]\n+fn test_bool() {\n+    assert_eq!(false.eq(&true), false);\n+    assert_eq!(false == false, true);\n+    assert_eq!(false != true, true);\n+    assert_eq!(false.ne(&false), false);\n+\n+    assert_eq!(false.bitand(false), false);\n+    assert_eq!(true.bitand(false), false);\n+    assert_eq!(false.bitand(true), false);\n+    assert_eq!(true.bitand(true), true);\n+\n+    assert_eq!(false & false, false);\n+    assert_eq!(true & false, false);\n+    assert_eq!(false & true, false);\n+    assert_eq!(true & true, true);\n+\n+    assert_eq!(false.bitor(false), false);\n+    assert_eq!(true.bitor(false), true);\n+    assert_eq!(false.bitor(true), true);\n+    assert_eq!(true.bitor(true), true);\n+\n+    assert_eq!(false | false, false);\n+    assert_eq!(true | false, true);\n+    assert_eq!(false | true, true);\n+    assert_eq!(true | true, true);\n+\n+    assert_eq!(false.bitxor(false), false);\n+    assert_eq!(true.bitxor(false), true);\n+    assert_eq!(false.bitxor(true), true);\n+    assert_eq!(true.bitxor(true), false);\n+\n+    assert_eq!(false ^ false, false);\n+    assert_eq!(true ^ false, true);\n+    assert_eq!(false ^ true, true);\n+    assert_eq!(true ^ true, false);\n+\n+    assert_eq!(!true, false);\n+    assert_eq!(!false, true);\n+\n+    let s = false.to_string();\n+    assert_eq!(s, \"false\");\n+    let s = true.to_string();\n+    assert_eq!(s, \"true\");\n+\n+    assert!(true > false);\n+    assert!(!(false > true));\n+\n+    assert!(false < true);\n+    assert!(!(true < false));\n+\n+    assert!(false <= false);\n+    assert!(false >= false);\n+    assert!(true <= true);\n+    assert!(true >= true);\n+\n+    assert!(false <= true);\n+    assert!(!(false >= true));\n+    assert!(true >= false);\n+    assert!(!(true <= false));\n+\n+    assert_eq!(true.cmp(&true), Equal);\n+    assert_eq!(false.cmp(&false), Equal);\n+    assert_eq!(true.cmp(&false), Greater);\n+    assert_eq!(false.cmp(&true), Less);\n+}\n+\n+#[test]\n+pub fn test_bool_not() {\n+    if !false {\n+        assert!((true));\n+    } else {\n+        assert!((false));\n+    }\n+    if !true {\n+        assert!((false));\n+    } else {\n+        assert!((true));\n+    }\n+}\n+\n #[test]\n fn test_bool_to_option() {\n     assert_eq!(false.then_some(0), None);"}, {"sha": "11cf7add07ada9076ec3c9e1533343bf17c0ce95", "filename": "library/core/tests/cmp.rs", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fcore%2Ftests%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fcore%2Ftests%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fcmp.rs?ref=b565fe241e9a3a29d725468fdf8da65622665444", "patch": "@@ -132,3 +132,74 @@ fn ordering_const() {\n     const THEN: Ordering = Equal.then(ORDERING);\n     assert_eq!(THEN, Greater);\n }\n+\n+#[test]\n+fn cmp_default() {\n+    // Test default methods in PartialOrd and PartialEq\n+\n+    #[derive(Debug)]\n+    struct Fool(bool);\n+\n+    impl PartialEq for Fool {\n+        fn eq(&self, other: &Fool) -> bool {\n+            let Fool(this) = *self;\n+            let Fool(other) = *other;\n+            this != other\n+        }\n+    }\n+\n+    struct Int(isize);\n+\n+    impl PartialEq for Int {\n+        fn eq(&self, other: &Int) -> bool {\n+            let Int(this) = *self;\n+            let Int(other) = *other;\n+            this == other\n+        }\n+    }\n+\n+    impl PartialOrd for Int {\n+        fn partial_cmp(&self, other: &Int) -> Option<Ordering> {\n+            let Int(this) = *self;\n+            let Int(other) = *other;\n+            this.partial_cmp(&other)\n+        }\n+    }\n+\n+    struct RevInt(isize);\n+\n+    impl PartialEq for RevInt {\n+        fn eq(&self, other: &RevInt) -> bool {\n+            let RevInt(this) = *self;\n+            let RevInt(other) = *other;\n+            this == other\n+        }\n+    }\n+\n+    impl PartialOrd for RevInt {\n+        fn partial_cmp(&self, other: &RevInt) -> Option<Ordering> {\n+            let RevInt(this) = *self;\n+            let RevInt(other) = *other;\n+            other.partial_cmp(&this)\n+        }\n+    }\n+\n+    assert!(Int(2) > Int(1));\n+    assert!(Int(2) >= Int(1));\n+    assert!(Int(1) >= Int(1));\n+    assert!(Int(1) < Int(2));\n+    assert!(Int(1) <= Int(2));\n+    assert!(Int(1) <= Int(1));\n+\n+    assert!(RevInt(2) < RevInt(1));\n+    assert!(RevInt(2) <= RevInt(1));\n+    assert!(RevInt(1) <= RevInt(1));\n+    assert!(RevInt(1) > RevInt(2));\n+    assert!(RevInt(1) >= RevInt(2));\n+    assert!(RevInt(1) >= RevInt(1));\n+\n+    assert_eq!(Fool(true), Fool(false));\n+    assert!(Fool(true) != Fool(true));\n+    assert!(Fool(false) != Fool(false));\n+    assert_eq!(Fool(false), Fool(true));\n+}"}, {"sha": "ec4b49da384c3da21c29feda2540d12704f16d32", "filename": "library/core/tests/iter.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter.rs?ref=b565fe241e9a3a29d725468fdf8da65622665444", "patch": "@@ -3493,3 +3493,15 @@ fn test_flatten_non_fused_inner() {\n     assert_eq!(iter.next(), Some(1));\n     assert_eq!(iter.next(), None);\n }\n+\n+#[test]\n+pub fn extend_for_unit() {\n+    let mut x = 0;\n+    {\n+        let iter = (0..5).map(|_| {\n+            x += 1;\n+        });\n+        ().extend(iter);\n+    }\n+    assert_eq!(x, 5);\n+}"}, {"sha": "106c9fe5da3e6255a5964abe96a1df7a496365fe", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=b565fe241e9a3a29d725468fdf8da65622665444", "patch": "@@ -8,6 +8,7 @@\n #![feature(bound_cloned)]\n #![feature(box_syntax)]\n #![feature(cell_update)]\n+#![feature(cfg_target_has_atomic)]\n #![feature(const_assume)]\n #![feature(const_cell_into_inner)]\n #![feature(core_intrinsics)]\n@@ -63,6 +64,7 @@\n #![feature(int_bits_const)]\n #![feature(nonzero_leading_trailing_zeros)]\n #![feature(const_option)]\n+#![feature(integer_atomics)]\n #![deny(unsafe_op_in_unsafe_fn)]\n \n extern crate test;\n@@ -82,6 +84,7 @@ mod hash;\n mod intrinsics;\n mod iter;\n mod lazy;\n+mod macros;\n mod manually_drop;\n mod mem;\n mod nonzero;\n@@ -98,3 +101,4 @@ mod str_lossy;\n mod task;\n mod time;\n mod tuple;\n+mod unicode;"}, {"sha": "482f3c1c99840655ed982a22cebbca63d3e1ad58", "filename": "library/core/tests/macros.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fcore%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fcore%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fmacros.rs?ref=b565fe241e9a3a29d725468fdf8da65622665444", "patch": "@@ -0,0 +1,14 @@\n+#[test]\n+fn assert_eq_trailing_comma() {\n+    assert_eq!(1, 1,);\n+}\n+\n+#[test]\n+fn assert_escape() {\n+    assert!(r#\"\u2603\\backslash\"#.contains(\"\\\\\"));\n+}\n+\n+#[test]\n+fn assert_ne_trailing_comma() {\n+    assert_ne!(1, 2,);\n+}"}, {"sha": "01defab2b38f02f9b054438b3e96607c97fcbf93", "filename": "library/core/tests/num/wrapping.rs", "status": "modified", "additions": 233, "deletions": 0, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fcore%2Ftests%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fcore%2Ftests%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fwrapping.rs?ref=b565fe241e9a3a29d725468fdf8da65622665444", "patch": "@@ -74,3 +74,236 @@ wrapping_test!(u64, u64::MIN, u64::MAX);\n #[cfg(not(target_os = \"emscripten\"))]\n wrapping_test!(u128, u128::MIN, u128::MAX);\n wrapping_test!(usize, usize::MIN, usize::MAX);\n+\n+// Don't warn about overflowing ops on 32-bit platforms\n+#[cfg_attr(target_pointer_width = \"32\", allow(const_err))]\n+fn wrapping_int_api() {\n+    assert_eq!(i8::MAX.wrapping_add(1), i8::MIN);\n+    assert_eq!(i16::MAX.wrapping_add(1), i16::MIN);\n+    assert_eq!(i32::MAX.wrapping_add(1), i32::MIN);\n+    assert_eq!(i64::MAX.wrapping_add(1), i64::MIN);\n+    assert_eq!(isize::MAX.wrapping_add(1), isize::MIN);\n+\n+    assert_eq!(i8::MIN.wrapping_sub(1), i8::MAX);\n+    assert_eq!(i16::MIN.wrapping_sub(1), i16::MAX);\n+    assert_eq!(i32::MIN.wrapping_sub(1), i32::MAX);\n+    assert_eq!(i64::MIN.wrapping_sub(1), i64::MAX);\n+    assert_eq!(isize::MIN.wrapping_sub(1), isize::MAX);\n+\n+    assert_eq!(u8::MAX.wrapping_add(1), u8::MIN);\n+    assert_eq!(u16::MAX.wrapping_add(1), u16::MIN);\n+    assert_eq!(u32::MAX.wrapping_add(1), u32::MIN);\n+    assert_eq!(u64::MAX.wrapping_add(1), u64::MIN);\n+    assert_eq!(usize::MAX.wrapping_add(1), usize::MIN);\n+\n+    assert_eq!(u8::MIN.wrapping_sub(1), u8::MAX);\n+    assert_eq!(u16::MIN.wrapping_sub(1), u16::MAX);\n+    assert_eq!(u32::MIN.wrapping_sub(1), u32::MAX);\n+    assert_eq!(u64::MIN.wrapping_sub(1), u64::MAX);\n+    assert_eq!(usize::MIN.wrapping_sub(1), usize::MAX);\n+\n+    assert_eq!((0xfe_u8 as i8).wrapping_mul(16), (0xe0_u8 as i8));\n+    assert_eq!((0xfedc_u16 as i16).wrapping_mul(16), (0xedc0_u16 as i16));\n+    assert_eq!((0xfedc_ba98_u32 as i32).wrapping_mul(16), (0xedcb_a980_u32 as i32));\n+    assert_eq!(\n+        (0xfedc_ba98_7654_3217_u64 as i64).wrapping_mul(16),\n+        (0xedcb_a987_6543_2170_u64 as i64)\n+    );\n+\n+    match () {\n+        #[cfg(target_pointer_width = \"32\")]\n+        () => {\n+            assert_eq!((0xfedc_ba98_u32 as isize).wrapping_mul(16), (0xedcb_a980_u32 as isize));\n+        }\n+        #[cfg(target_pointer_width = \"64\")]\n+        () => {\n+            assert_eq!(\n+                (0xfedc_ba98_7654_3217_u64 as isize).wrapping_mul(16),\n+                (0xedcb_a987_6543_2170_u64 as isize)\n+            );\n+        }\n+    }\n+\n+    assert_eq!((0xfe as u8).wrapping_mul(16), (0xe0 as u8));\n+    assert_eq!((0xfedc as u16).wrapping_mul(16), (0xedc0 as u16));\n+    assert_eq!((0xfedc_ba98 as u32).wrapping_mul(16), (0xedcb_a980 as u32));\n+    assert_eq!((0xfedc_ba98_7654_3217 as u64).wrapping_mul(16), (0xedcb_a987_6543_2170 as u64));\n+\n+    match () {\n+        #[cfg(target_pointer_width = \"32\")]\n+        () => {\n+            assert_eq!((0xfedc_ba98 as usize).wrapping_mul(16), (0xedcb_a980 as usize));\n+        }\n+        #[cfg(target_pointer_width = \"64\")]\n+        () => {\n+            assert_eq!(\n+                (0xfedc_ba98_7654_3217 as usize).wrapping_mul(16),\n+                (0xedcb_a987_6543_2170 as usize)\n+            );\n+        }\n+    }\n+\n+    macro_rules! check_mul_no_wrap {\n+        ($e:expr, $f:expr) => {\n+            assert_eq!(($e).wrapping_mul($f), ($e) * $f);\n+        };\n+    }\n+    macro_rules! check_mul_wraps {\n+        ($e:expr, $f:expr) => {\n+            assert_eq!(($e).wrapping_mul($f), $e);\n+        };\n+    }\n+\n+    check_mul_no_wrap!(0xfe_u8 as i8, -1);\n+    check_mul_no_wrap!(0xfedc_u16 as i16, -1);\n+    check_mul_no_wrap!(0xfedc_ba98_u32 as i32, -1);\n+    check_mul_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, -1);\n+    check_mul_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize, -1);\n+\n+    check_mul_no_wrap!(0xfe_u8 as i8, -2);\n+    check_mul_no_wrap!(0xfedc_u16 as i16, -2);\n+    check_mul_no_wrap!(0xfedc_ba98_u32 as i32, -2);\n+    check_mul_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, -2);\n+    check_mul_no_wrap!(0xfedc_ba98_fedc_ba98_u64 as u64 as isize, -2);\n+\n+    check_mul_no_wrap!(0xfe_u8 as i8, 2);\n+    check_mul_no_wrap!(0xfedc_u16 as i16, 2);\n+    check_mul_no_wrap!(0xfedc_ba98_u32 as i32, 2);\n+    check_mul_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, 2);\n+    check_mul_no_wrap!(0xfedc_ba98_fedc_ba98_u64 as u64 as isize, 2);\n+\n+    check_mul_wraps!(0x80_u8 as i8, -1);\n+    check_mul_wraps!(0x8000_u16 as i16, -1);\n+    check_mul_wraps!(0x8000_0000_u32 as i32, -1);\n+    check_mul_wraps!(0x8000_0000_0000_0000_u64 as i64, -1);\n+    match () {\n+        #[cfg(target_pointer_width = \"32\")]\n+        () => {\n+            check_mul_wraps!(0x8000_0000_u32 as isize, -1);\n+        }\n+        #[cfg(target_pointer_width = \"64\")]\n+        () => {\n+            check_mul_wraps!(0x8000_0000_0000_0000_u64 as isize, -1);\n+        }\n+    }\n+\n+    macro_rules! check_div_no_wrap {\n+        ($e:expr, $f:expr) => {\n+            assert_eq!(($e).wrapping_div($f), ($e) / $f);\n+        };\n+    }\n+    macro_rules! check_div_wraps {\n+        ($e:expr, $f:expr) => {\n+            assert_eq!(($e).wrapping_div($f), $e);\n+        };\n+    }\n+\n+    check_div_no_wrap!(0xfe_u8 as i8, -1);\n+    check_div_no_wrap!(0xfedc_u16 as i16, -1);\n+    check_div_no_wrap!(0xfedc_ba98_u32 as i32, -1);\n+    check_div_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, -1);\n+    check_div_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize, -1);\n+\n+    check_div_no_wrap!(0xfe_u8 as i8, -2);\n+    check_div_no_wrap!(0xfedc_u16 as i16, -2);\n+    check_div_no_wrap!(0xfedc_ba98_u32 as i32, -2);\n+    check_div_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, -2);\n+    check_div_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize, -2);\n+\n+    check_div_no_wrap!(0xfe_u8 as i8, 2);\n+    check_div_no_wrap!(0xfedc_u16 as i16, 2);\n+    check_div_no_wrap!(0xfedc_ba98_u32 as i32, 2);\n+    check_div_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, 2);\n+    check_div_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize, 2);\n+\n+    check_div_wraps!(-128 as i8, -1);\n+    check_div_wraps!(0x8000_u16 as i16, -1);\n+    check_div_wraps!(0x8000_0000_u32 as i32, -1);\n+    check_div_wraps!(0x8000_0000_0000_0000_u64 as i64, -1);\n+    match () {\n+        #[cfg(target_pointer_width = \"32\")]\n+        () => {\n+            check_div_wraps!(0x8000_0000_u32 as isize, -1);\n+        }\n+        #[cfg(target_pointer_width = \"64\")]\n+        () => {\n+            check_div_wraps!(0x8000_0000_0000_0000_u64 as isize, -1);\n+        }\n+    }\n+\n+    macro_rules! check_rem_no_wrap {\n+        ($e:expr, $f:expr) => {\n+            assert_eq!(($e).wrapping_rem($f), ($e) % $f);\n+        };\n+    }\n+    macro_rules! check_rem_wraps {\n+        ($e:expr, $f:expr) => {\n+            assert_eq!(($e).wrapping_rem($f), 0);\n+        };\n+    }\n+\n+    check_rem_no_wrap!(0xfe_u8 as i8, -1);\n+    check_rem_no_wrap!(0xfedc_u16 as i16, -1);\n+    check_rem_no_wrap!(0xfedc_ba98_u32 as i32, -1);\n+    check_rem_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, -1);\n+    check_rem_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize, -1);\n+\n+    check_rem_no_wrap!(0xfe_u8 as i8, -2);\n+    check_rem_no_wrap!(0xfedc_u16 as i16, -2);\n+    check_rem_no_wrap!(0xfedc_ba98_u32 as i32, -2);\n+    check_rem_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, -2);\n+    check_rem_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize, -2);\n+\n+    check_rem_no_wrap!(0xfe_u8 as i8, 2);\n+    check_rem_no_wrap!(0xfedc_u16 as i16, 2);\n+    check_rem_no_wrap!(0xfedc_ba98_u32 as i32, 2);\n+    check_rem_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, 2);\n+    check_rem_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize, 2);\n+\n+    check_rem_wraps!(0x80_u8 as i8, -1);\n+    check_rem_wraps!(0x8000_u16 as i16, -1);\n+    check_rem_wraps!(0x8000_0000_u32 as i32, -1);\n+    check_rem_wraps!(0x8000_0000_0000_0000_u64 as i64, -1);\n+    match () {\n+        #[cfg(target_pointer_width = \"32\")]\n+        () => {\n+            check_rem_wraps!(0x8000_0000_u32 as isize, -1);\n+        }\n+        #[cfg(target_pointer_width = \"64\")]\n+        () => {\n+            check_rem_wraps!(0x8000_0000_0000_0000_u64 as isize, -1);\n+        }\n+    }\n+\n+    macro_rules! check_neg_no_wrap {\n+        ($e:expr) => {\n+            assert_eq!(($e).wrapping_neg(), -($e));\n+        };\n+    }\n+    macro_rules! check_neg_wraps {\n+        ($e:expr) => {\n+            assert_eq!(($e).wrapping_neg(), ($e));\n+        };\n+    }\n+\n+    check_neg_no_wrap!(0xfe_u8 as i8);\n+    check_neg_no_wrap!(0xfedc_u16 as i16);\n+    check_neg_no_wrap!(0xfedc_ba98_u32 as i32);\n+    check_neg_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64);\n+    check_neg_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize);\n+\n+    check_neg_wraps!(0x80_u8 as i8);\n+    check_neg_wraps!(0x8000_u16 as i16);\n+    check_neg_wraps!(0x8000_0000_u32 as i32);\n+    check_neg_wraps!(0x8000_0000_0000_0000_u64 as i64);\n+    match () {\n+        #[cfg(target_pointer_width = \"32\")]\n+        () => {\n+            check_neg_wraps!(0x8000_0000_u32 as isize);\n+        }\n+        #[cfg(target_pointer_width = \"64\")]\n+        () => {\n+            check_neg_wraps!(0x8000_0000_0000_0000_u64 as isize);\n+        }\n+    }\n+}"}, {"sha": "53e5539fad91c5f5b0ba47a9f041e50586496d27", "filename": "library/core/tests/ops.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fcore%2Ftests%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fcore%2Ftests%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fops.rs?ref=b565fe241e9a3a29d725468fdf8da65622665444", "patch": "@@ -1,4 +1,5 @@\n use core::ops::{Bound, Range, RangeFrom, RangeFull, RangeInclusive, RangeTo, RangeToInclusive};\n+use core::ops::{Deref, DerefMut};\n \n // Test the Range structs and syntax.\n \n@@ -197,3 +198,35 @@ fn range_structural_match() {\n         _ => unreachable!(),\n     }\n }\n+\n+// Test Deref implementations\n+\n+#[test]\n+fn deref_mut_on_ref() {\n+    // Test that `&mut T` implements `DerefMut<T>`\n+\n+    fn inc<T: Deref<Target = isize> + DerefMut>(mut t: T) {\n+        *t += 1;\n+    }\n+\n+    let mut x: isize = 5;\n+    inc(&mut x);\n+    assert_eq!(x, 6);\n+}\n+\n+#[test]\n+fn deref_on_ref() {\n+    // Test that `&T` and `&mut T` implement `Deref<T>`\n+\n+    fn deref<U: Copy, T: Deref<Target = U>>(t: T) -> U {\n+        *t\n+    }\n+\n+    let x: isize = 3;\n+    let y = deref(&x);\n+    assert_eq!(y, 3);\n+\n+    let mut x: isize = 4;\n+    let y = deref(&mut x);\n+    assert_eq!(y, 4);\n+}"}, {"sha": "5388b4756245a668cd0d18a11e5a4af07ae2cb55", "filename": "library/core/tests/option.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fcore%2Ftests%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fcore%2Ftests%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Foption.rs?ref=b565fe241e9a3a29d725468fdf8da65622665444", "patch": "@@ -402,3 +402,13 @@ fn test_unwrap_drop() {\n \n     assert_eq!(x.get(), 0);\n }\n+\n+#[test]\n+pub fn option_ext() {\n+    let thing = \"{{ f }}\";\n+    let f = thing.find(\"{{\");\n+\n+    if f.is_none() {\n+        println!(\"None!\");\n+    }\n+}"}, {"sha": "57c2fb06c16dd2d3e298cb3b4a1475cc78bc4354", "filename": "library/core/tests/ptr.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fptr.rs?ref=b565fe241e9a3a29d725468fdf8da65622665444", "patch": "@@ -400,3 +400,16 @@ fn align_offset_weird_strides() {\n     }\n     assert!(!x);\n }\n+\n+#[test]\n+fn offset_from() {\n+    let mut a = [0; 5];\n+    let ptr1: *mut i32 = &mut a[1];\n+    let ptr2: *mut i32 = &mut a[3];\n+    unsafe {\n+        assert_eq!(ptr2.offset_from(ptr1), 2);\n+        assert_eq!(ptr1.offset_from(ptr2), -2);\n+        assert_eq!(ptr1.offset(2), ptr2);\n+        assert_eq!(ptr2.offset(-2), ptr1);\n+    }\n+}"}, {"sha": "81660870e95e477bc6c189603e9eb11cd835602e", "filename": "library/core/tests/result.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fcore%2Ftests%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fcore%2Ftests%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fresult.rs?ref=b565fe241e9a3a29d725468fdf8da65622665444", "patch": "@@ -320,3 +320,41 @@ fn result_const() {\n     const IS_ERR: bool = RESULT.is_err();\n     assert!(!IS_ERR)\n }\n+\n+#[test]\n+fn result_opt_conversions() {\n+    #[derive(Copy, Clone, Debug, PartialEq)]\n+    struct BadNumErr;\n+\n+    fn try_num(x: i32) -> Result<i32, BadNumErr> {\n+        if x <= 5 { Ok(x + 1) } else { Err(BadNumErr) }\n+    }\n+\n+    type ResOpt = Result<Option<i32>, BadNumErr>;\n+    type OptRes = Option<Result<i32, BadNumErr>>;\n+\n+    let mut x: ResOpt = Ok(Some(5));\n+    let mut y: OptRes = Some(Ok(5));\n+    assert_eq!(x, y.transpose());\n+    assert_eq!(x.transpose(), y);\n+\n+    x = Ok(None);\n+    y = None;\n+    assert_eq!(x, y.transpose());\n+    assert_eq!(x.transpose(), y);\n+\n+    x = Err(BadNumErr);\n+    y = Some(Err(BadNumErr));\n+    assert_eq!(x, y.transpose());\n+    assert_eq!(x.transpose(), y);\n+\n+    let res: Result<Vec<i32>, BadNumErr> = (0..10)\n+        .map(|x| {\n+            let y = try_num(x)?;\n+            Ok(if y % 2 == 0 { Some(y - 1) } else { None })\n+        })\n+        .filter_map(Result::transpose)\n+        .collect();\n+\n+    assert_eq!(res, Err(BadNumErr))\n+}"}, {"sha": "c28ea859115e13e8d0c10491a39ebbe27e5e0f01", "filename": "library/core/tests/unicode.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fcore%2Ftests%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fcore%2Ftests%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Funicode.rs?ref=b565fe241e9a3a29d725468fdf8da65622665444", "patch": "@@ -0,0 +1,5 @@\n+#[test]\n+pub fn version() {\n+    let (major, _minor, _update) = core::unicode::UNICODE_VERSION;\n+    assert!(major >= 10);\n+}"}, {"sha": "0e55ec648c9c5707e942c727f7605e8482845303", "filename": "library/std/tests/env.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fstd%2Ftests%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fstd%2Ftests%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Ftests%2Fenv.rs?ref=b565fe241e9a3a29d725468fdf8da65622665444", "patch": "@@ -1,5 +1,6 @@\n use std::env::*;\n use std::ffi::{OsStr, OsString};\n+use std::path::PathBuf;\n \n use rand::distributions::Alphanumeric;\n use rand::{thread_rng, Rng};\n@@ -76,3 +77,63 @@ fn test_env_set_var() {\n \n     assert!(vars_os().any(|(k, v)| { &*k == &*n && &*v == \"VALUE\" }));\n }\n+\n+#[test]\n+#[cfg_attr(any(target_os = \"emscripten\", target_env = \"sgx\"), ignore)]\n+#[allow(deprecated)]\n+fn env_home_dir() {\n+    fn var_to_os_string(var: Result<String, VarError>) -> Option<OsString> {\n+        match var {\n+            Ok(var) => Some(OsString::from(var)),\n+            Err(VarError::NotUnicode(var)) => Some(var),\n+            _ => None,\n+        }\n+    }\n+\n+    cfg_if::cfg_if! {\n+        if #[cfg(unix)] {\n+            let oldhome = var_to_os_string(var(\"HOME\"));\n+\n+            set_var(\"HOME\", \"/home/MountainView\");\n+            assert_eq!(home_dir(), Some(PathBuf::from(\"/home/MountainView\")));\n+\n+            remove_var(\"HOME\");\n+            if cfg!(target_os = \"android\") {\n+                assert!(home_dir().is_none());\n+            } else {\n+                // When HOME is not set, some platforms return `None`,\n+                // but others return `Some` with a default.\n+                // Just check that it is not \"/home/MountainView\".\n+                assert_ne!(home_dir(), Some(PathBuf::from(\"/home/MountainView\")));\n+            }\n+\n+            if let Some(oldhome) = oldhome { set_var(\"HOME\", oldhome); }\n+        } else if #[cfg(windows)] {\n+            let oldhome = var_to_os_string(var(\"HOME\"));\n+            let olduserprofile = var_to_os_string(var(\"USERPROFILE\"));\n+\n+            remove_var(\"HOME\");\n+            remove_var(\"USERPROFILE\");\n+\n+            assert!(home_dir().is_some());\n+\n+            set_var(\"HOME\", \"/home/MountainView\");\n+            assert_eq!(home_dir(), Some(PathBuf::from(\"/home/MountainView\")));\n+\n+            remove_var(\"HOME\");\n+\n+            set_var(\"USERPROFILE\", \"/home/MountainView\");\n+            assert_eq!(home_dir(), Some(PathBuf::from(\"/home/MountainView\")));\n+\n+            set_var(\"HOME\", \"/home/MountainView\");\n+            set_var(\"USERPROFILE\", \"/home/PaloAlto\");\n+            assert_eq!(home_dir(), Some(PathBuf::from(\"/home/MountainView\")));\n+\n+            remove_var(\"HOME\");\n+            remove_var(\"USERPROFILE\");\n+\n+            if let Some(oldhome) = oldhome { set_var(\"HOME\", oldhome); }\n+            if let Some(olduserprofile) = olduserprofile { set_var(\"USERPROFILE\", olduserprofile); }\n+        }\n+    }\n+}"}, {"sha": "754b264c6ad9394bcc1b6b27e485ee28593cde2b", "filename": "library/std/tests/thread.rs", "status": "renamed", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fstd%2Ftests%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565fe241e9a3a29d725468fdf8da65622665444/library%2Fstd%2Ftests%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Ftests%2Fthread.rs?ref=b565fe241e9a3a29d725468fdf8da65622665444", "patch": "@@ -1,17 +1,16 @@\n-// run-pass\n-// ignore-emscripten no threads support\n-\n-use std::thread::{self, sleep};\n-use std::time::Duration;\n use std::sync::{Arc, Mutex};\n+use std::thread;\n+use std::time::Duration;\n \n-fn main() {\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)]\n+fn sleep() {\n     let finished = Arc::new(Mutex::new(false));\n     let t_finished = finished.clone();\n     thread::spawn(move || {\n-        sleep(Duration::new(u64::MAX, 0));\n+        thread::sleep(Duration::new(u64::MAX, 0));\n         *t_finished.lock().unwrap() = true;\n     });\n-    sleep(Duration::from_millis(100));\n+    thread::sleep(Duration::from_millis(100));\n     assert_eq!(*finished.lock().unwrap(), false);\n }", "previous_filename": "src/test/ui/sleep.rs"}, {"sha": "7071f80d7f7babc5131db864b7a9f14cb9749251", "filename": "src/test/ui/assert-eq-trailing-comma.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fassert-eq-trailing-comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fassert-eq-trailing-comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassert-eq-trailing-comma.rs?ref=c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "patch": "@@ -1,5 +0,0 @@\n-// run-pass\n-\n-fn main() {\n-    assert_eq!(1, 1,);\n-}"}, {"sha": "00e51d42cab9e06a1992e73d5cfdc836dd94f26f", "filename": "src/test/ui/assert-escape.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fassert-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fassert-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassert-escape.rs?ref=c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "patch": "@@ -1,5 +0,0 @@\n-// run-pass\n-\n-fn main() {\n-    assert!(r#\"\u2603\\backslash\"#.contains(\"\\\\\"));\n-}"}, {"sha": "03308db9a1feec614f266d4d32fb88e0384683b5", "filename": "src/test/ui/assert-ne-trailing-comma.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fassert-ne-trailing-comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fassert-ne-trailing-comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassert-ne-trailing-comma.rs?ref=c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "patch": "@@ -1,5 +0,0 @@\n-// run-pass\n-\n-fn main() {\n-    assert_ne!(1, 2,);\n-}"}, {"sha": "e9d48bb3b43d82057c1210bbdbeea984b208a171", "filename": "src/test/ui/atomic-access-bool.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fatomic-access-bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fatomic-access-bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fatomic-access-bool.rs?ref=c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "patch": "@@ -1,24 +0,0 @@\n-// run-pass\n-\n-#![allow(stable_features)]\n-#![feature(atomic_access)]\n-use std::sync::atomic::AtomicBool;\n-use std::sync::atomic::Ordering::*;\n-\n-static mut ATOMIC: AtomicBool = AtomicBool::new(false);\n-\n-fn main() {\n-    unsafe {\n-        assert_eq!(*ATOMIC.get_mut(), false);\n-        ATOMIC.store(true, SeqCst);\n-        assert_eq!(*ATOMIC.get_mut(), true);\n-        ATOMIC.fetch_or(false, SeqCst);\n-        assert_eq!(*ATOMIC.get_mut(), true);\n-        ATOMIC.fetch_and(false, SeqCst);\n-        assert_eq!(*ATOMIC.get_mut(), false);\n-        ATOMIC.fetch_nand(true, SeqCst);\n-        assert_eq!(*ATOMIC.get_mut(), true);\n-        ATOMIC.fetch_xor(true, SeqCst);\n-        assert_eq!(*ATOMIC.get_mut(), false);\n-    }\n-}"}, {"sha": "5bda90d2eab02a36e9c4685f225a4674ff2ea3ad", "filename": "src/test/ui/atomic-alignment.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fatomic-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fatomic-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fatomic-alignment.rs?ref=c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "patch": "@@ -1,38 +0,0 @@\n-// run-pass\n-\n-#![feature(cfg_target_has_atomic)]\n-#![feature(integer_atomics)]\n-\n-use std::mem::{align_of, size_of};\n-use std::sync::atomic::*;\n-\n-fn main() {\n-    #[cfg(target_has_atomic = \"8\")]\n-    assert_eq!(align_of::<AtomicBool>(), size_of::<AtomicBool>());\n-    #[cfg(target_has_atomic = \"ptr\")]\n-    assert_eq!(align_of::<AtomicPtr<u8>>(), size_of::<AtomicPtr<u8>>());\n-    #[cfg(target_has_atomic = \"8\")]\n-    assert_eq!(align_of::<AtomicU8>(), size_of::<AtomicU8>());\n-    #[cfg(target_has_atomic = \"8\")]\n-    assert_eq!(align_of::<AtomicI8>(), size_of::<AtomicI8>());\n-    #[cfg(target_has_atomic = \"16\")]\n-    assert_eq!(align_of::<AtomicU16>(), size_of::<AtomicU16>());\n-    #[cfg(target_has_atomic = \"16\")]\n-    assert_eq!(align_of::<AtomicI16>(), size_of::<AtomicI16>());\n-    #[cfg(target_has_atomic = \"32\")]\n-    assert_eq!(align_of::<AtomicU32>(), size_of::<AtomicU32>());\n-    #[cfg(target_has_atomic = \"32\")]\n-    assert_eq!(align_of::<AtomicI32>(), size_of::<AtomicI32>());\n-    #[cfg(target_has_atomic = \"64\")]\n-    assert_eq!(align_of::<AtomicU64>(), size_of::<AtomicU64>());\n-    #[cfg(target_has_atomic = \"64\")]\n-    assert_eq!(align_of::<AtomicI64>(), size_of::<AtomicI64>());\n-    #[cfg(target_has_atomic = \"128\")]\n-    assert_eq!(align_of::<AtomicU128>(), size_of::<AtomicU128>());\n-    #[cfg(target_has_atomic = \"128\")]\n-    assert_eq!(align_of::<AtomicI128>(), size_of::<AtomicI128>());\n-    #[cfg(target_has_atomic = \"ptr\")]\n-    assert_eq!(align_of::<AtomicUsize>(), size_of::<AtomicUsize>());\n-    #[cfg(target_has_atomic = \"ptr\")]\n-    assert_eq!(align_of::<AtomicIsize>(), size_of::<AtomicIsize>());\n-}"}, {"sha": "9b327eef3c8946be9c4815b7870e679be9073e5a", "filename": "src/test/ui/atomic-compare_exchange.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fatomic-compare_exchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fatomic-compare_exchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fatomic-compare_exchange.rs?ref=c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "patch": "@@ -1,31 +0,0 @@\n-// run-pass\n-\n-#![allow(stable_features)]\n-\n-#![feature(extended_compare_and_swap)]\n-use std::sync::atomic::AtomicIsize;\n-use std::sync::atomic::Ordering::*;\n-\n-static ATOMIC: AtomicIsize = AtomicIsize::new(0);\n-\n-fn main() {\n-    // Make sure codegen can emit all the intrinsics correctly\n-    ATOMIC.compare_exchange(0, 1, Relaxed, Relaxed).ok();\n-    ATOMIC.compare_exchange(0, 1, Acquire, Relaxed).ok();\n-    ATOMIC.compare_exchange(0, 1, Release, Relaxed).ok();\n-    ATOMIC.compare_exchange(0, 1, AcqRel, Relaxed).ok();\n-    ATOMIC.compare_exchange(0, 1, SeqCst, Relaxed).ok();\n-    ATOMIC.compare_exchange(0, 1, Acquire, Acquire).ok();\n-    ATOMIC.compare_exchange(0, 1, AcqRel, Acquire).ok();\n-    ATOMIC.compare_exchange(0, 1, SeqCst, Acquire).ok();\n-    ATOMIC.compare_exchange(0, 1, SeqCst, SeqCst).ok();\n-    ATOMIC.compare_exchange_weak(0, 1, Relaxed, Relaxed).ok();\n-    ATOMIC.compare_exchange_weak(0, 1, Acquire, Relaxed).ok();\n-    ATOMIC.compare_exchange_weak(0, 1, Release, Relaxed).ok();\n-    ATOMIC.compare_exchange_weak(0, 1, AcqRel, Relaxed).ok();\n-    ATOMIC.compare_exchange_weak(0, 1, SeqCst, Relaxed).ok();\n-    ATOMIC.compare_exchange_weak(0, 1, Acquire, Acquire).ok();\n-    ATOMIC.compare_exchange_weak(0, 1, AcqRel, Acquire).ok();\n-    ATOMIC.compare_exchange_weak(0, 1, SeqCst, Acquire).ok();\n-    ATOMIC.compare_exchange_weak(0, 1, SeqCst, SeqCst).ok();\n-}"}, {"sha": "84713d6818a3ecc30e8be933d91b54842c5f8f79", "filename": "src/test/ui/bool-not.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fbool-not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fbool-not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbool-not.rs?ref=c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "patch": "@@ -1,6 +0,0 @@\n-// run-pass\n-\n-pub fn main() {\n-    if !false { assert!((true)); } else { assert!((false)); }\n-    if !true { assert!((false)); } else { assert!((true)); }\n-}"}, {"sha": "92f36c8fd25ad418aa33dbe011a5b5df0609246f", "filename": "src/test/ui/bool.rs", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbool.rs?ref=c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "patch": "@@ -1,72 +0,0 @@\n-// run-pass\n-// Basic boolean tests\n-\n-\n-use std::cmp::Ordering::{Equal, Greater, Less};\n-use std::ops::{BitAnd, BitOr, BitXor};\n-\n-fn main() {\n-    assert_eq!(false.eq(&true), false);\n-    assert_eq!(false == false, true);\n-    assert_eq!(false != true, true);\n-    assert_eq!(false.ne(&false), false);\n-\n-    assert_eq!(false.bitand(false), false);\n-    assert_eq!(true.bitand(false), false);\n-    assert_eq!(false.bitand(true), false);\n-    assert_eq!(true.bitand(true), true);\n-\n-    assert_eq!(false & false, false);\n-    assert_eq!(true & false, false);\n-    assert_eq!(false & true, false);\n-    assert_eq!(true & true, true);\n-\n-    assert_eq!(false.bitor(false), false);\n-    assert_eq!(true.bitor(false), true);\n-    assert_eq!(false.bitor(true), true);\n-    assert_eq!(true.bitor(true), true);\n-\n-    assert_eq!(false | false, false);\n-    assert_eq!(true | false, true);\n-    assert_eq!(false | true, true);\n-    assert_eq!(true | true, true);\n-\n-    assert_eq!(false.bitxor(false), false);\n-    assert_eq!(true.bitxor(false), true);\n-    assert_eq!(false.bitxor(true), true);\n-    assert_eq!(true.bitxor(true), false);\n-\n-    assert_eq!(false ^ false, false);\n-    assert_eq!(true ^ false, true);\n-    assert_eq!(false ^ true, true);\n-    assert_eq!(true ^ true, false);\n-\n-    assert_eq!(!true, false);\n-    assert_eq!(!false, true);\n-\n-    let s = false.to_string();\n-    assert_eq!(s, \"false\");\n-    let s = true.to_string();\n-    assert_eq!(s, \"true\");\n-\n-    assert!(true > false);\n-    assert!(!(false > true));\n-\n-    assert!(false < true);\n-    assert!(!(true < false));\n-\n-    assert!(false <= false);\n-    assert!(false >= false);\n-    assert!(true <= true);\n-    assert!(true >= true);\n-\n-    assert!(false <= true);\n-    assert!(!(false >= true));\n-    assert!(true >= false);\n-    assert!(!(true <= false));\n-\n-    assert_eq!(true.cmp(&true), Equal);\n-    assert_eq!(false.cmp(&false), Equal);\n-    assert_eq!(true.cmp(&false), Greater);\n-    assert_eq!(false.cmp(&true), Less);\n-}"}, {"sha": "65dda47066f4eac62a56a73010e2b9d046d438dc", "filename": "src/test/ui/char_unicode.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fchar_unicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fchar_unicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchar_unicode.rs?ref=c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "patch": "@@ -1,10 +0,0 @@\n-// run-pass\n-\n-/// Tests access to the Unicode version constant.\n-pub fn main() {\n-    check(std::char::UNICODE_VERSION);\n-}\n-\n-pub fn check(unicode_version: (u8, u8, u8)) {\n-    assert!(unicode_version.0 >= 10);\n-}"}, {"sha": "bb5c39f5cdea9737b078f0b35cfa19846c89a958", "filename": "src/test/ui/cmp-default.rs", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fcmp-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fcmp-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcmp-default.rs?ref=c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "patch": "@@ -1,73 +0,0 @@\n-// run-pass\n-\n-use std::cmp::Ordering;\n-\n-// Test default methods in PartialOrd and PartialEq\n-//\n-#[derive(Debug)]\n-struct Fool(bool);\n-\n-impl PartialEq for Fool {\n-    fn eq(&self, other: &Fool) -> bool {\n-        let Fool(this) = *self;\n-        let Fool(other) = *other;\n-        this != other\n-    }\n-}\n-\n-struct Int(isize);\n-\n-impl PartialEq for Int {\n-    fn eq(&self, other: &Int) -> bool {\n-        let Int(this) = *self;\n-        let Int(other) = *other;\n-        this == other\n-    }\n-}\n-\n-impl PartialOrd for Int {\n-    fn partial_cmp(&self, other: &Int) -> Option<Ordering> {\n-        let Int(this) = *self;\n-        let Int(other) = *other;\n-        this.partial_cmp(&other)\n-    }\n-}\n-\n-struct RevInt(isize);\n-\n-impl PartialEq for RevInt {\n-    fn eq(&self, other: &RevInt) -> bool {\n-        let RevInt(this) = *self;\n-        let RevInt(other) = *other;\n-        this == other\n-    }\n-}\n-\n-impl PartialOrd for RevInt {\n-    fn partial_cmp(&self, other: &RevInt) -> Option<Ordering> {\n-        let RevInt(this) = *self;\n-        let RevInt(other) = *other;\n-        other.partial_cmp(&this)\n-    }\n-}\n-\n-pub fn main() {\n-    assert!(Int(2) >  Int(1));\n-    assert!(Int(2) >= Int(1));\n-    assert!(Int(1) >= Int(1));\n-    assert!(Int(1) <  Int(2));\n-    assert!(Int(1) <= Int(2));\n-    assert!(Int(1) <= Int(1));\n-\n-    assert!(RevInt(2) <  RevInt(1));\n-    assert!(RevInt(2) <= RevInt(1));\n-    assert!(RevInt(1) <= RevInt(1));\n-    assert!(RevInt(1) >  RevInt(2));\n-    assert!(RevInt(1) >= RevInt(2));\n-    assert!(RevInt(1) >= RevInt(1));\n-\n-    assert_eq!(Fool(true), Fool(false));\n-    assert!(Fool(true)  != Fool(true));\n-    assert!(Fool(false) != Fool(false));\n-    assert_eq!(Fool(false), Fool(true));\n-}"}, {"sha": "ef2f7322f2718941fb27767fb5d3b4efa84b1aee", "filename": "src/test/ui/consts/ascii_ctype.rs", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fconsts%2Fascii_ctype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fconsts%2Fascii_ctype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fascii_ctype.rs?ref=c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "patch": "@@ -1,53 +0,0 @@\n-// run-pass\n-\n-macro_rules! suite {\n-    ( $( $fn:ident => [$a:ident, $A:ident, $nine:ident, $dot:ident, $space:ident]; )* ) => {\n-        $(\n-            mod $fn {\n-                const CHAR_A_LOWER: bool = 'a'.$fn();\n-                const CHAR_A_UPPER: bool = 'A'.$fn();\n-                const CHAR_NINE: bool = '9'.$fn();\n-                const CHAR_DOT: bool = '.'.$fn();\n-                const CHAR_SPACE: bool = ' '.$fn();\n-\n-                const U8_A_LOWER: bool = b'a'.$fn();\n-                const U8_A_UPPER: bool = b'A'.$fn();\n-                const U8_NINE: bool = b'9'.$fn();\n-                const U8_DOT: bool = b'.'.$fn();\n-                const U8_SPACE: bool = b' '.$fn();\n-\n-                pub fn run() {\n-                    assert_eq!(CHAR_A_LOWER, $a);\n-                    assert_eq!(CHAR_A_UPPER, $A);\n-                    assert_eq!(CHAR_NINE, $nine);\n-                    assert_eq!(CHAR_DOT, $dot);\n-                    assert_eq!(CHAR_SPACE, $space);\n-\n-                    assert_eq!(U8_A_LOWER, $a);\n-                    assert_eq!(U8_A_UPPER, $A);\n-                    assert_eq!(U8_NINE, $nine);\n-                    assert_eq!(U8_DOT, $dot);\n-                    assert_eq!(U8_SPACE, $space);\n-                }\n-            }\n-        )*\n-\n-        fn main() {\n-            $( $fn::run(); )*\n-        }\n-    }\n-}\n-\n-suite! {\n-    //                        'a'    'A'    '9'    '.'    ' '\n-    is_ascii_alphabetic   => [true,  true,  false, false, false];\n-    is_ascii_uppercase    => [false, true,  false, false, false];\n-    is_ascii_lowercase    => [true,  false, false, false, false];\n-    is_ascii_alphanumeric => [true,  true,  true,  false, false];\n-    is_ascii_digit        => [false, false, true,  false, false];\n-    is_ascii_hexdigit     => [true,  true,  true,  false, false];\n-    is_ascii_punctuation  => [false, false, false, true,  false];\n-    is_ascii_graphic      => [true,  true,  true,  true,  false];\n-    is_ascii_whitespace   => [false, false, false, false, true];\n-    is_ascii_control      => [false, false, false, false, false];\n-}"}, {"sha": "56fd9d9f55ffcaa0b27b54a86c8c92667eb15e2c", "filename": "src/test/ui/consts/const-str-ptr.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fconsts%2Fconst-str-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fconsts%2Fconst-str-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-str-ptr.rs?ref=c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "patch": "@@ -1,17 +0,0 @@\n-// run-pass\n-#![allow(unused_imports)]\n-use std::{str, string};\n-\n-const A: [u8; 2] = ['h' as u8, 'i' as u8];\n-const B: &'static [u8; 2] = &A;\n-const C: *const u8 = B as *const u8;\n-\n-pub fn main() {\n-    unsafe {\n-        let foo = &A as *const u8;\n-        assert_eq!(foo, C);\n-        assert_eq!(str::from_utf8_unchecked(&A), \"hi\");\n-        assert_eq!(*C, A[0]);\n-        assert_eq!(*(&B[0] as *const u8), A[0]);\n-    }\n-}"}, {"sha": "a6df5495a27758ae20c696438dd1875c6b2740ff", "filename": "src/test/ui/deref-mut-on-ref.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fderef-mut-on-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fderef-mut-on-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderef-mut-on-ref.rs?ref=c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "patch": "@@ -1,15 +0,0 @@\n-// run-pass\n-// Test that `&mut T` implements `DerefMut<T>`\n-\n-\n-use std::ops::{Deref, DerefMut};\n-\n-fn inc<T: Deref<Target=isize> + DerefMut>(mut t: T) {\n-    *t += 1;\n-}\n-\n-fn main() {\n-    let mut x: isize = 5;\n-    inc(&mut x);\n-    assert_eq!(x, 6);\n-}"}, {"sha": "973e61c9d59fa4ff8f11e0f8ed3287b10db9c7da", "filename": "src/test/ui/deref-on-ref.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fderef-on-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fderef-on-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderef-on-ref.rs?ref=c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "patch": "@@ -1,19 +0,0 @@\n-// run-pass\n-// Test that `&T` and `&mut T` implement `Deref<T>`\n-\n-\n-use std::ops::Deref;\n-\n-fn deref<U:Copy,T:Deref<Target=U>>(t: T) -> U {\n-    *t\n-}\n-\n-fn main() {\n-    let x: isize = 3;\n-    let y = deref(&x);\n-    assert_eq!(y, 3);\n-\n-    let mut x: isize = 4;\n-    let y = deref(&mut x);\n-    assert_eq!(y, 4);\n-}"}, {"sha": "c597b4732d15861c52035059abcc39570fd46d1b", "filename": "src/test/ui/env-home-dir.rs", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fenv-home-dir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fenv-home-dir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenv-home-dir.rs?ref=c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "patch": "@@ -1,50 +0,0 @@\n-// run-pass\n-\n-#![allow(unused_variables)]\n-#![allow(deprecated)]\n-// ignore-emscripten env vars don't work?\n-// ignore-sgx env vars cannot be modified\n-\n-use std::env::*;\n-use std::path::PathBuf;\n-\n-#[cfg(unix)]\n-fn main() {\n-    let oldhome = var(\"HOME\");\n-\n-    set_var(\"HOME\", \"/home/MountainView\");\n-    assert_eq!(home_dir(), Some(PathBuf::from(\"/home/MountainView\")));\n-\n-    remove_var(\"HOME\");\n-    if cfg!(target_os = \"android\") {\n-        assert!(home_dir().is_none());\n-    } else {\n-        // When HOME is not set, some platforms return `None`,\n-        // but others return `Some` with a default.\n-        // Just check that it is not \"/home/MountainView\".\n-        assert_ne!(home_dir(), Some(PathBuf::from(\"/home/MountainView\")));\n-    }\n-}\n-\n-#[cfg(windows)]\n-fn main() {\n-    let oldhome = var(\"HOME\");\n-    let olduserprofile = var(\"USERPROFILE\");\n-\n-    remove_var(\"HOME\");\n-    remove_var(\"USERPROFILE\");\n-\n-    assert!(home_dir().is_some());\n-\n-    set_var(\"HOME\", \"/home/MountainView\");\n-    assert_eq!(home_dir(), Some(PathBuf::from(\"/home/MountainView\")));\n-\n-    remove_var(\"HOME\");\n-\n-    set_var(\"USERPROFILE\", \"/home/MountainView\");\n-    assert_eq!(home_dir(), Some(PathBuf::from(\"/home/MountainView\")));\n-\n-    set_var(\"HOME\", \"/home/MountainView\");\n-    set_var(\"USERPROFILE\", \"/home/PaloAlto\");\n-    assert_eq!(home_dir(), Some(PathBuf::from(\"/home/MountainView\")));\n-}"}, {"sha": "01d743f70bc0a72472b0117304a893fa3a1288ac", "filename": "src/test/ui/extend-for-unit.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fextend-for-unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fextend-for-unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextend-for-unit.rs?ref=c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "patch": "@@ -1,12 +0,0 @@\n-// run-pass\n-\n-pub fn main() {\n-    let mut x = 0;\n-    {\n-        let iter = (0..5).map(|_| {\n-            x += 1;\n-        });\n-        ().extend(iter);\n-    }\n-    assert_eq!(x, 5);\n-}"}, {"sha": "aa59c119706ea690ad56a1288b4fd0f4ea8ce259", "filename": "src/test/ui/offset_from.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Foffset_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Foffset_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Foffset_from.rs?ref=c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "patch": "@@ -1,13 +0,0 @@\n-// run-pass\n-\n-fn main() {\n-    let mut a = [0; 5];\n-    let ptr1: *mut i32 = &mut a[1];\n-    let ptr2: *mut i32 = &mut a[3];\n-    unsafe {\n-        assert_eq!(ptr2.offset_from(ptr1), 2);\n-        assert_eq!(ptr1.offset_from(ptr2), -2);\n-        assert_eq!(ptr1.offset(2), ptr2);\n-        assert_eq!(ptr2.offset(-2), ptr1);\n-    }\n-}"}, {"sha": "76d0cf43984b337adb7c2d39d910a5981b6ea938", "filename": "src/test/ui/option-ext.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Foption-ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Foption-ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Foption-ext.rs?ref=c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "patch": "@@ -1,10 +0,0 @@\n-// run-pass\n-\n-pub fn main() {\n-    let thing = \"{{ f }}\";\n-    let f = thing.find(\"{{\");\n-\n-    if f.is_none() {\n-        println!(\"None!\");\n-    }\n-}"}, {"sha": "57f258aab654a6c4e588c82378a6d1540898821e", "filename": "src/test/ui/result-opt-conversions.rs", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fresult-opt-conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fresult-opt-conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresult-opt-conversions.rs?ref=c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "patch": "@@ -1,47 +0,0 @@\n-// run-pass\n-\n-#[derive(Copy, Clone, Debug, PartialEq)]\n-struct BadNumErr;\n-\n-fn try_num(x: i32) -> Result<i32, BadNumErr> {\n-    if x <= 5 {\n-        Ok(x + 1)\n-    } else {\n-        Err(BadNumErr)\n-    }\n-}\n-\n-type ResOpt = Result<Option<i32>, BadNumErr>;\n-type OptRes = Option<Result<i32, BadNumErr>>;\n-\n-fn main() {\n-    let mut x: ResOpt = Ok(Some(5));\n-    let mut y: OptRes = Some(Ok(5));\n-    assert_eq!(x, y.transpose());\n-    assert_eq!(x.transpose(), y);\n-\n-    x = Ok(None);\n-    y = None;\n-    assert_eq!(x, y.transpose());\n-    assert_eq!(x.transpose(), y);\n-\n-    x = Err(BadNumErr);\n-    y = Some(Err(BadNumErr));\n-    assert_eq!(x, y.transpose());\n-    assert_eq!(x.transpose(), y);\n-\n-    let res: Result<Vec<i32>, BadNumErr> =\n-        (0..10)\n-            .map(|x| {\n-                let y = try_num(x)?;\n-                Ok(if y % 2 == 0 {\n-                    Some(y - 1)\n-                } else {\n-                    None\n-                })\n-            })\n-            .filter_map(Result::transpose)\n-            .collect();\n-\n-    assert_eq!(res, Err(BadNumErr))\n-}"}, {"sha": "75b6ddf7895c73253a6ee280be23a014448f4d91", "filename": "src/test/ui/utf8.rs", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Futf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Futf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Futf8.rs?ref=c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "patch": "@@ -1,50 +0,0 @@\n-// run-pass\n-\n-pub fn main() {\n-    let yen: char = '\u00a5'; // 0xa5\n-    let c_cedilla: char = '\u00e7'; // 0xe7\n-    let thorn: char = '\u00fe'; // 0xfe\n-    let y_diaeresis: char = '\u00ff'; // 0xff\n-    let pi: char = '\u03a0'; // 0x3a0\n-\n-    assert_eq!(yen as isize, 0xa5);\n-    assert_eq!(c_cedilla as isize, 0xe7);\n-    assert_eq!(thorn as isize, 0xfe);\n-    assert_eq!(y_diaeresis as isize, 0xff);\n-    assert_eq!(pi as isize, 0x3a0);\n-\n-    assert_eq!(pi as isize, '\\u{3a0}' as isize);\n-    assert_eq!('\\x0a' as isize, '\\n' as isize);\n-\n-    let bhutan: String = \"\u0f60\u0f56\u0fb2\u0f74\u0f42\u0f0b\u0f61\u0f74\u0f63\u0f0d\".to_string();\n-    let japan: String = \"\u65e5\u672c\".to_string();\n-    let uzbekistan: String = \"\u040e\u0437\u0431\u0435\u043a\u0438\u0441\u0442\u043e\u043d\".to_string();\n-    let austria: String = \"\u00d6sterreich\".to_string();\n-\n-    let bhutan_e: String =\n-        \"\\u{f60}\\u{f56}\\u{fb2}\\u{f74}\\u{f42}\\u{f0b}\\u{f61}\\u{f74}\\u{f63}\\u{f0d}\".to_string();\n-    let japan_e: String = \"\\u{65e5}\\u{672c}\".to_string();\n-    let uzbekistan_e: String =\n-        \"\\u{40e}\\u{437}\\u{431}\\u{435}\\u{43a}\\u{438}\\u{441}\\u{442}\\u{43e}\\u{43d}\".to_string();\n-    let austria_e: String = \"\\u{d6}sterreich\".to_string();\n-\n-    let oo: char = '\u00d6';\n-    assert_eq!(oo as isize, 0xd6);\n-\n-    fn check_str_eq(a: String, b: String) {\n-        let mut i: isize = 0;\n-        for ab in a.bytes() {\n-            println!(\"{}\", i);\n-            println!(\"{}\", ab);\n-            let bb: u8 = b.as_bytes()[i as usize];\n-            println!(\"{}\", bb);\n-            assert_eq!(ab, bb);\n-            i += 1;\n-        }\n-    }\n-\n-    check_str_eq(bhutan, bhutan_e);\n-    check_str_eq(japan, japan_e);\n-    check_str_eq(uzbekistan, uzbekistan_e);\n-    check_str_eq(austria, austria_e);\n-}"}, {"sha": "d764509813de117cd5ee310ed1a3ec6efddadbf1", "filename": "src/test/ui/utf8_chars.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Futf8_chars.rs?ref=c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "patch": "@@ -1,31 +0,0 @@\n-// run-pass\n-\n-use std::str;\n-\n-pub fn main() {\n-    // Chars of 1, 2, 3, and 4 bytes\n-    let chs: Vec<char> = vec!['e', '\u00e9', '\u20ac', '\\u{10000}'];\n-    let s: String = chs.iter().cloned().collect();\n-    let schs: Vec<char> = s.chars().collect();\n-\n-    assert_eq!(s.len(), 10);\n-    assert_eq!(s.chars().count(), 4);\n-    assert_eq!(schs.len(), 4);\n-    assert_eq!(schs.iter().cloned().collect::<String>(), s);\n-\n-    assert!((str::from_utf8(s.as_bytes()).is_ok()));\n-    // invalid prefix\n-    assert!((!str::from_utf8(&[0x80]).is_ok()));\n-    // invalid 2 byte prefix\n-    assert!((!str::from_utf8(&[0xc0]).is_ok()));\n-    assert!((!str::from_utf8(&[0xc0, 0x10]).is_ok()));\n-    // invalid 3 byte prefix\n-    assert!((!str::from_utf8(&[0xe0]).is_ok()));\n-    assert!((!str::from_utf8(&[0xe0, 0x10]).is_ok()));\n-    assert!((!str::from_utf8(&[0xe0, 0xff, 0x10]).is_ok()));\n-    // invalid 4 byte prefix\n-    assert!((!str::from_utf8(&[0xf0]).is_ok()));\n-    assert!((!str::from_utf8(&[0xf0, 0x10]).is_ok()));\n-    assert!((!str::from_utf8(&[0xf0, 0xff, 0x10]).is_ok()));\n-    assert!((!str::from_utf8(&[0xf0, 0xff, 0xff, 0x10]).is_ok()));\n-}"}, {"sha": "6e2fc7f80b9c480404b05b788ee408bba2d9ec56", "filename": "src/test/ui/wrapping-int-api.rs", "status": "removed", "additions": 0, "deletions": 225, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fwrapping-int-api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fwrapping-int-api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwrapping-int-api.rs?ref=c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "patch": "@@ -1,225 +0,0 @@\n-// run-pass\n-// Test inherent wrapping_* methods for {i,u}{size,8,16,32,64}.\n-\n-// Don't warn about overflowing ops on 32-bit platforms\n-#![cfg_attr(target_pointer_width = \"32\", allow(const_err))]\n-\n-fn main() {\n-    assert_eq!(   i8::MAX.wrapping_add(1),    i8::MIN);\n-    assert_eq!(  i16::MAX.wrapping_add(1),   i16::MIN);\n-    assert_eq!(  i32::MAX.wrapping_add(1),   i32::MIN);\n-    assert_eq!(  i64::MAX.wrapping_add(1),   i64::MIN);\n-    assert_eq!(isize::MAX.wrapping_add(1), isize::MIN);\n-\n-    assert_eq!(   i8::MIN.wrapping_sub(1),    i8::MAX);\n-    assert_eq!(  i16::MIN.wrapping_sub(1),   i16::MAX);\n-    assert_eq!(  i32::MIN.wrapping_sub(1),   i32::MAX);\n-    assert_eq!(  i64::MIN.wrapping_sub(1),   i64::MAX);\n-    assert_eq!(isize::MIN.wrapping_sub(1), isize::MAX);\n-\n-    assert_eq!(   u8::MAX.wrapping_add(1),    u8::MIN);\n-    assert_eq!(  u16::MAX.wrapping_add(1),   u16::MIN);\n-    assert_eq!(  u32::MAX.wrapping_add(1),   u32::MIN);\n-    assert_eq!(  u64::MAX.wrapping_add(1),   u64::MIN);\n-    assert_eq!(usize::MAX.wrapping_add(1), usize::MIN);\n-\n-    assert_eq!(   u8::MIN.wrapping_sub(1),    u8::MAX);\n-    assert_eq!(  u16::MIN.wrapping_sub(1),   u16::MAX);\n-    assert_eq!(  u32::MIN.wrapping_sub(1),   u32::MAX);\n-    assert_eq!(  u64::MIN.wrapping_sub(1),   u64::MAX);\n-    assert_eq!(usize::MIN.wrapping_sub(1), usize::MAX);\n-\n-    assert_eq!((0xfe_u8 as i8).wrapping_mul(16),\n-               (0xe0_u8 as i8));\n-    assert_eq!((0xfedc_u16 as i16).wrapping_mul(16),\n-               (0xedc0_u16 as i16));\n-    assert_eq!((0xfedc_ba98_u32 as i32).wrapping_mul(16),\n-               (0xedcb_a980_u32 as i32));\n-    assert_eq!((0xfedc_ba98_7654_3217_u64 as i64).wrapping_mul(16),\n-               (0xedcb_a987_6543_2170_u64 as i64));\n-\n-    match () {\n-        #[cfg(target_pointer_width = \"32\")]\n-        () => {\n-            assert_eq!((0xfedc_ba98_u32 as isize).wrapping_mul(16),\n-                       (0xedcb_a980_u32 as isize));\n-        }\n-        #[cfg(target_pointer_width = \"64\")]\n-        () => {\n-            assert_eq!((0xfedc_ba98_7654_3217_u64 as isize).wrapping_mul(16),\n-                       (0xedcb_a987_6543_2170_u64 as isize));\n-        }\n-    }\n-\n-    assert_eq!((0xfe as u8).wrapping_mul(16),\n-               (0xe0 as u8));\n-    assert_eq!((0xfedc as u16).wrapping_mul(16),\n-               (0xedc0 as u16));\n-    assert_eq!((0xfedc_ba98 as u32).wrapping_mul(16),\n-               (0xedcb_a980 as u32));\n-    assert_eq!((0xfedc_ba98_7654_3217 as u64).wrapping_mul(16),\n-               (0xedcb_a987_6543_2170 as u64));\n-\n-    match () {\n-        #[cfg(target_pointer_width = \"32\")]\n-        () => {\n-            assert_eq!((0xfedc_ba98 as usize).wrapping_mul(16),\n-                       (0xedcb_a980 as usize));\n-        }\n-        #[cfg(target_pointer_width = \"64\")]\n-        () => {\n-            assert_eq!((0xfedc_ba98_7654_3217 as usize).wrapping_mul(16),\n-                       (0xedcb_a987_6543_2170 as usize));\n-        }\n-    }\n-\n-    macro_rules! check_mul_no_wrap {\n-        ($e:expr, $f:expr) => { assert_eq!(($e).wrapping_mul($f), ($e) * $f); }\n-    }\n-    macro_rules! check_mul_wraps {\n-        ($e:expr, $f:expr) => { assert_eq!(($e).wrapping_mul($f), $e); }\n-    }\n-\n-    check_mul_no_wrap!(0xfe_u8 as i8, -1);\n-    check_mul_no_wrap!(0xfedc_u16 as i16, -1);\n-    check_mul_no_wrap!(0xfedc_ba98_u32 as i32, -1);\n-    check_mul_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, -1);\n-    check_mul_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize, -1);\n-\n-    check_mul_no_wrap!(0xfe_u8 as i8, -2);\n-    check_mul_no_wrap!(0xfedc_u16 as i16, -2);\n-    check_mul_no_wrap!(0xfedc_ba98_u32 as i32, -2);\n-    check_mul_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, -2);\n-    check_mul_no_wrap!(0xfedc_ba98_fedc_ba98_u64 as u64 as isize, -2);\n-\n-    check_mul_no_wrap!(0xfe_u8 as i8, 2);\n-    check_mul_no_wrap!(0xfedc_u16 as i16, 2);\n-    check_mul_no_wrap!(0xfedc_ba98_u32 as i32, 2);\n-    check_mul_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, 2);\n-    check_mul_no_wrap!(0xfedc_ba98_fedc_ba98_u64 as u64 as isize, 2);\n-\n-    check_mul_wraps!(0x80_u8 as i8, -1);\n-    check_mul_wraps!(0x8000_u16 as i16, -1);\n-    check_mul_wraps!(0x8000_0000_u32 as i32, -1);\n-    check_mul_wraps!(0x8000_0000_0000_0000_u64 as i64, -1);\n-    match () {\n-        #[cfg(target_pointer_width = \"32\")]\n-        () => {\n-            check_mul_wraps!(0x8000_0000_u32 as isize, -1);\n-        }\n-        #[cfg(target_pointer_width = \"64\")]\n-        () => {\n-            check_mul_wraps!(0x8000_0000_0000_0000_u64 as isize, -1);\n-        }\n-    }\n-\n-    macro_rules! check_div_no_wrap {\n-        ($e:expr, $f:expr) => { assert_eq!(($e).wrapping_div($f), ($e) / $f); }\n-    }\n-    macro_rules! check_div_wraps {\n-        ($e:expr, $f:expr) => { assert_eq!(($e).wrapping_div($f), $e); }\n-    }\n-\n-    check_div_no_wrap!(0xfe_u8 as i8, -1);\n-    check_div_no_wrap!(0xfedc_u16 as i16, -1);\n-    check_div_no_wrap!(0xfedc_ba98_u32 as i32, -1);\n-    check_div_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, -1);\n-    check_div_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize, -1);\n-\n-    check_div_no_wrap!(0xfe_u8 as i8, -2);\n-    check_div_no_wrap!(0xfedc_u16 as i16, -2);\n-    check_div_no_wrap!(0xfedc_ba98_u32 as i32, -2);\n-    check_div_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, -2);\n-    check_div_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize, -2);\n-\n-    check_div_no_wrap!(0xfe_u8 as i8, 2);\n-    check_div_no_wrap!(0xfedc_u16 as i16, 2);\n-    check_div_no_wrap!(0xfedc_ba98_u32 as i32, 2);\n-    check_div_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, 2);\n-    check_div_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize, 2);\n-\n-    check_div_wraps!(-128 as i8, -1);\n-    check_div_wraps!(0x8000_u16 as i16, -1);\n-    check_div_wraps!(0x8000_0000_u32 as i32, -1);\n-    check_div_wraps!(0x8000_0000_0000_0000_u64 as i64, -1);\n-    match () {\n-        #[cfg(target_pointer_width = \"32\")]\n-        () => {\n-            check_div_wraps!(0x8000_0000_u32 as isize, -1);\n-        }\n-        #[cfg(target_pointer_width = \"64\")]\n-        () => {\n-            check_div_wraps!(0x8000_0000_0000_0000_u64 as isize, -1);\n-        }\n-    }\n-\n-\n-    macro_rules! check_rem_no_wrap {\n-        ($e:expr, $f:expr) => { assert_eq!(($e).wrapping_rem($f), ($e) % $f); }\n-    }\n-    macro_rules! check_rem_wraps {\n-        ($e:expr, $f:expr) => { assert_eq!(($e).wrapping_rem($f), 0); }\n-    }\n-\n-    check_rem_no_wrap!(0xfe_u8 as i8, -1);\n-    check_rem_no_wrap!(0xfedc_u16 as i16, -1);\n-    check_rem_no_wrap!(0xfedc_ba98_u32 as i32, -1);\n-    check_rem_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, -1);\n-    check_rem_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize, -1);\n-\n-    check_rem_no_wrap!(0xfe_u8 as i8, -2);\n-    check_rem_no_wrap!(0xfedc_u16 as i16, -2);\n-    check_rem_no_wrap!(0xfedc_ba98_u32 as i32, -2);\n-    check_rem_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, -2);\n-    check_rem_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize, -2);\n-\n-    check_rem_no_wrap!(0xfe_u8 as i8, 2);\n-    check_rem_no_wrap!(0xfedc_u16 as i16, 2);\n-    check_rem_no_wrap!(0xfedc_ba98_u32 as i32, 2);\n-    check_rem_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, 2);\n-    check_rem_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize, 2);\n-\n-    check_rem_wraps!(0x80_u8 as i8, -1);\n-    check_rem_wraps!(0x8000_u16 as i16, -1);\n-    check_rem_wraps!(0x8000_0000_u32 as i32, -1);\n-    check_rem_wraps!(0x8000_0000_0000_0000_u64 as i64, -1);\n-    match () {\n-        #[cfg(target_pointer_width = \"32\")]\n-        () => {\n-            check_rem_wraps!(0x8000_0000_u32 as isize, -1);\n-        }\n-        #[cfg(target_pointer_width = \"64\")]\n-        () => {\n-            check_rem_wraps!(0x8000_0000_0000_0000_u64 as isize, -1);\n-        }\n-    }\n-\n-    macro_rules! check_neg_no_wrap {\n-        ($e:expr) => { assert_eq!(($e).wrapping_neg(), -($e)); }\n-    }\n-    macro_rules! check_neg_wraps {\n-        ($e:expr) => { assert_eq!(($e).wrapping_neg(),  ($e)); }\n-    }\n-\n-    check_neg_no_wrap!(0xfe_u8 as i8);\n-    check_neg_no_wrap!(0xfedc_u16 as i16);\n-    check_neg_no_wrap!(0xfedc_ba98_u32 as i32);\n-    check_neg_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64);\n-    check_neg_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize);\n-\n-    check_neg_wraps!(0x80_u8 as i8);\n-    check_neg_wraps!(0x8000_u16 as i16);\n-    check_neg_wraps!(0x8000_0000_u32 as i32);\n-    check_neg_wraps!(0x8000_0000_0000_0000_u64 as i64);\n-    match () {\n-        #[cfg(target_pointer_width = \"32\")]\n-        () => {\n-            check_neg_wraps!(0x8000_0000_u32 as isize);\n-        }\n-        #[cfg(target_pointer_width = \"64\")]\n-        () => {\n-            check_neg_wraps!(0x8000_0000_0000_0000_u64 as isize);\n-        }\n-    }\n-\n-}"}]}