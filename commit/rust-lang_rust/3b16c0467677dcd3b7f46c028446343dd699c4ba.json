{"sha": "3b16c0467677dcd3b7f46c028446343dd699c4ba", "node_id": "C_kwDOAAsO6NoAKDNiMTZjMDQ2NzY3N2RjZDNiN2Y0NmMwMjg0NDYzNDNkZDY5OWM0YmE", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2022-10-24T00:02:50Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2022-10-24T00:32:36Z"}, "message": "`unchecked_{shl|shr}` should use `u32` as the RHS", "tree": {"sha": "e70116be406e6592e6308a70aa97a88f20e5e381", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e70116be406e6592e6308a70aa97a88f20e5e381"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b16c0467677dcd3b7f46c028446343dd699c4ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b16c0467677dcd3b7f46c028446343dd699c4ba", "html_url": "https://github.com/rust-lang/rust/commit/3b16c0467677dcd3b7f46c028446343dd699c4ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b16c0467677dcd3b7f46c028446343dd699c4ba/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ca6777c014813e3bdb98d155562fc3d111d86dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ca6777c014813e3bdb98d155562fc3d111d86dd", "html_url": "https://github.com/rust-lang/rust/commit/1ca6777c014813e3bdb98d155562fc3d111d86dd"}], "stats": {"total": 99, "additions": 87, "deletions": 12}, "files": [{"sha": "357a2ea6775cfb795fdaf686224c6066be4d8a30", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3b16c0467677dcd3b7f46c028446343dd699c4ba/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b16c0467677dcd3b7f46c028446343dd699c4ba/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=3b16c0467677dcd3b7f46c028446343dd699c4ba", "patch": "@@ -130,6 +130,7 @@\n #![feature(const_pin)]\n #![feature(const_ptr_sub_ptr)]\n #![feature(const_replace)]\n+#![feature(const_result_drop)]\n #![feature(const_ptr_as_ref)]\n #![feature(const_ptr_is_null)]\n #![feature(const_ptr_read)]"}, {"sha": "451484df99f235c735c588942edd099f7929d39a", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3b16c0467677dcd3b7f46c028446343dd699c4ba/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b16c0467677dcd3b7f46c028446343dd699c4ba/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=3b16c0467677dcd3b7f46c028446343dd699c4ba", "patch": "@@ -757,10 +757,11 @@ macro_rules! int_impl {\n         #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n         #[inline(always)]\n         #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n-        pub const unsafe fn unchecked_shl(self, rhs: Self) -> Self {\n+        pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {\n             // SAFETY: the caller must uphold the safety contract for\n             // `unchecked_shl`.\n-            unsafe { intrinsics::unchecked_shl(self, rhs) }\n+            // Any legal shift amount is losslessly representable in the self type.\n+            unsafe { intrinsics::unchecked_shl(self, rhs.try_into().ok().unwrap_unchecked()) }\n         }\n \n         /// Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is\n@@ -804,10 +805,11 @@ macro_rules! int_impl {\n         #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n         #[inline(always)]\n         #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n-        pub const unsafe fn unchecked_shr(self, rhs: Self) -> Self {\n+        pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {\n             // SAFETY: the caller must uphold the safety contract for\n             // `unchecked_shr`.\n-            unsafe { intrinsics::unchecked_shr(self, rhs) }\n+            // Any legal shift amount is losslessly representable in the self type.\n+            unsafe { intrinsics::unchecked_shr(self, rhs.try_into().ok().unwrap_unchecked()) }\n         }\n \n         /// Checked absolute value. Computes `self.abs()`, returning `None` if\n@@ -1354,11 +1356,12 @@ macro_rules! int_impl {\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline(always)]\n+        #[rustc_allow_const_fn_unstable(const_inherent_unchecked_arith)]\n         pub const fn wrapping_shl(self, rhs: u32) -> Self {\n             // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n             // out of bounds\n             unsafe {\n-                intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n+                self.unchecked_shl(rhs & ($BITS - 1))\n             }\n         }\n \n@@ -1383,11 +1386,12 @@ macro_rules! int_impl {\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline(always)]\n+        #[rustc_allow_const_fn_unstable(const_inherent_unchecked_arith)]\n         pub const fn wrapping_shr(self, rhs: u32) -> Self {\n             // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n             // out of bounds\n             unsafe {\n-                intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n+                self.unchecked_shr(rhs & ($BITS - 1))\n             }\n         }\n "}, {"sha": "b2328b001de904368ad0adb8ef7ee8a98a080d67", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3b16c0467677dcd3b7f46c028446343dd699c4ba/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b16c0467677dcd3b7f46c028446343dd699c4ba/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=3b16c0467677dcd3b7f46c028446343dd699c4ba", "patch": "@@ -3,6 +3,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::ascii;\n+use crate::convert::TryInto;\n use crate::error::Error;\n use crate::intrinsics;\n use crate::mem;"}, {"sha": "1b728af79d99bd0506db3111ef17d2f000299b40", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3b16c0467677dcd3b7f46c028446343dd699c4ba/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b16c0467677dcd3b7f46c028446343dd699c4ba/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=3b16c0467677dcd3b7f46c028446343dd699c4ba", "patch": "@@ -901,10 +901,11 @@ macro_rules! uint_impl {\n         #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n         #[inline(always)]\n         #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n-        pub const unsafe fn unchecked_shl(self, rhs: Self) -> Self {\n+        pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {\n             // SAFETY: the caller must uphold the safety contract for\n             // `unchecked_shl`.\n-            unsafe { intrinsics::unchecked_shl(self, rhs) }\n+            // Any legal shift amount is losslessly representable in the self type.\n+            unsafe { intrinsics::unchecked_shl(self, rhs.try_into().ok().unwrap_unchecked()) }\n         }\n \n         /// Checked shift right. Computes `self >> rhs`, returning `None`\n@@ -948,10 +949,11 @@ macro_rules! uint_impl {\n         #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n         #[inline(always)]\n         #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n-        pub const unsafe fn unchecked_shr(self, rhs: Self) -> Self {\n+        pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {\n             // SAFETY: the caller must uphold the safety contract for\n             // `unchecked_shr`.\n-            unsafe { intrinsics::unchecked_shr(self, rhs) }\n+            // Any legal shift amount is losslessly representable in the self type.\n+            unsafe { intrinsics::unchecked_shr(self, rhs.try_into().ok().unwrap_unchecked()) }\n         }\n \n         /// Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n@@ -1367,11 +1369,12 @@ macro_rules! uint_impl {\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline(always)]\n+        #[rustc_allow_const_fn_unstable(const_inherent_unchecked_arith)]\n         pub const fn wrapping_shl(self, rhs: u32) -> Self {\n             // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n             // out of bounds\n             unsafe {\n-                intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n+                self.unchecked_shl(rhs & ($BITS - 1))\n             }\n         }\n \n@@ -1399,11 +1402,12 @@ macro_rules! uint_impl {\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline(always)]\n+        #[rustc_allow_const_fn_unstable(const_inherent_unchecked_arith)]\n         pub const fn wrapping_shr(self, rhs: u32) -> Self {\n             // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n             // out of bounds\n             unsafe {\n-                intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n+                self.unchecked_shr(rhs & ($BITS - 1))\n             }\n         }\n "}, {"sha": "d67d3a88000d898956d682a104a14b6f25eeca80", "filename": "src/test/codegen/unchecked_shifts.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/3b16c0467677dcd3b7f46c028446343dd699c4ba/src%2Ftest%2Fcodegen%2Funchecked_shifts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b16c0467677dcd3b7f46c028446343dd699c4ba/src%2Ftest%2Fcodegen%2Funchecked_shifts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funchecked_shifts.rs?ref=3b16c0467677dcd3b7f46c028446343dd699c4ba", "patch": "@@ -0,0 +1,65 @@\n+// compile-flags: -O\n+// min-llvm-version: 15.0 (LLVM 13 in CI does this differently from submodule LLVM)\n+\n+#![crate_type = \"lib\"]\n+#![feature(unchecked_math)]\n+\n+// CHECK-LABEL: @unchecked_shl_unsigned_same\n+#[no_mangle]\n+pub unsafe fn unchecked_shl_unsigned_same(a: u32, b: u32) -> u32 {\n+    // CHECK-NOT: and i32\n+    // CHECK: shl i32 %a, %b\n+    // CHECK-NOT: and i32\n+    a.unchecked_shl(b)\n+}\n+\n+// CHECK-LABEL: @unchecked_shl_unsigned_smaller\n+#[no_mangle]\n+pub unsafe fn unchecked_shl_unsigned_smaller(a: u16, b: u32) -> u16 {\n+    // This uses -DAG to avoid failing on irrelevant reorderings,\n+    // like emitting the truncation earlier.\n+\n+    // CHECK-DAG: %[[INRANGE:.+]] = icmp ult i32 %b, 65536\n+    // CHECK-DAG: tail call void @llvm.assume(i1 %[[INRANGE]])\n+    // CHECK-DAG: %[[TRUNC:.+]] = trunc i32 %b to i16\n+    // CHECK-DAG: shl i16 %a, %[[TRUNC]]\n+    a.unchecked_shl(b)\n+}\n+\n+// CHECK-LABEL: @unchecked_shl_unsigned_bigger\n+#[no_mangle]\n+pub unsafe fn unchecked_shl_unsigned_bigger(a: u64, b: u32) -> u64 {\n+    // CHECK: %[[EXT:.+]] = zext i32 %b to i64\n+    // CHECK: shl i64 %a, %[[EXT]]\n+    a.unchecked_shl(b)\n+}\n+\n+// CHECK-LABEL: @unchecked_shr_signed_same\n+#[no_mangle]\n+pub unsafe fn unchecked_shr_signed_same(a: i32, b: u32) -> i32 {\n+    // CHECK-NOT: and i32\n+    // CHECK: ashr i32 %a, %b\n+    // CHECK-NOT: and i32\n+    a.unchecked_shr(b)\n+}\n+\n+// CHECK-LABEL: @unchecked_shr_signed_smaller\n+#[no_mangle]\n+pub unsafe fn unchecked_shr_signed_smaller(a: i16, b: u32) -> i16 {\n+    // This uses -DAG to avoid failing on irrelevant reorderings,\n+    // like emitting the truncation earlier.\n+\n+    // CHECK-DAG: %[[INRANGE:.+]] = icmp ult i32 %b, 32768\n+    // CHECK-DAG: tail call void @llvm.assume(i1 %[[INRANGE]])\n+    // CHECK-DAG: %[[TRUNC:.+]] = trunc i32 %b to i16\n+    // CHECK-DAG: ashr i16 %a, %[[TRUNC]]\n+    a.unchecked_shr(b)\n+}\n+\n+// CHECK-LABEL: @unchecked_shr_signed_bigger\n+#[no_mangle]\n+pub unsafe fn unchecked_shr_signed_bigger(a: i64, b: u32) -> i64 {\n+    // CHECK: %[[EXT:.+]] = zext i32 %b to i64\n+    // CHECK: ashr i64 %a, %[[EXT]]\n+    a.unchecked_shr(b)\n+}"}]}