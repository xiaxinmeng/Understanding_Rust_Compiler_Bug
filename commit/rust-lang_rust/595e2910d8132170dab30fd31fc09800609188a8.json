{"sha": "595e2910d8132170dab30fd31fc09800609188a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5NWUyOTEwZDgxMzIxNzBkYWIzMGZkMzFmYzA5ODAwNjA5MTg4YTg=", "commit": {"author": {"name": "Kevin Butler", "email": "haqkrs@gmail.com", "date": "2014-05-08T21:35:09Z"}, "committer": {"name": "Kevin Butler", "email": "haqkrs@gmail.com", "date": "2014-05-14T18:18:18Z"}, "message": "rustc: Improve error messages for resolve failures.", "tree": {"sha": "e18669c12442bee7212447c2efbd45d4de142ef6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e18669c12442bee7212447c2efbd45d4de142ef6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/595e2910d8132170dab30fd31fc09800609188a8", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/595e2910d8132170dab30fd31fc09800609188a8", "html_url": "https://github.com/rust-lang/rust/commit/595e2910d8132170dab30fd31fc09800609188a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/595e2910d8132170dab30fd31fc09800609188a8/comments", "author": {"login": "Ryman", "id": 994978, "node_id": "MDQ6VXNlcjk5NDk3OA==", "avatar_url": "https://avatars.githubusercontent.com/u/994978?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ryman", "html_url": "https://github.com/Ryman", "followers_url": "https://api.github.com/users/Ryman/followers", "following_url": "https://api.github.com/users/Ryman/following{/other_user}", "gists_url": "https://api.github.com/users/Ryman/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ryman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ryman/subscriptions", "organizations_url": "https://api.github.com/users/Ryman/orgs", "repos_url": "https://api.github.com/users/Ryman/repos", "events_url": "https://api.github.com/users/Ryman/events{/privacy}", "received_events_url": "https://api.github.com/users/Ryman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Ryman", "id": 994978, "node_id": "MDQ6VXNlcjk5NDk3OA==", "avatar_url": "https://avatars.githubusercontent.com/u/994978?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ryman", "html_url": "https://github.com/Ryman", "followers_url": "https://api.github.com/users/Ryman/followers", "following_url": "https://api.github.com/users/Ryman/following{/other_user}", "gists_url": "https://api.github.com/users/Ryman/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ryman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ryman/subscriptions", "organizations_url": "https://api.github.com/users/Ryman/orgs", "repos_url": "https://api.github.com/users/Ryman/repos", "events_url": "https://api.github.com/users/Ryman/events{/privacy}", "received_events_url": "https://api.github.com/users/Ryman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb115ac2d4f57d8b590c8d46d8f9e2958ed9a527", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb115ac2d4f57d8b590c8d46d8f9e2958ed9a527", "html_url": "https://github.com/rust-lang/rust/commit/cb115ac2d4f57d8b590c8d46d8f9e2958ed9a527"}], "stats": {"total": 441, "additions": 325, "deletions": 116}, "files": [{"sha": "471e290d9145e54b13598f57fa958dc6c3b14f1f", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 250, "deletions": 112, "changes": 362, "blob_url": "https://github.com/rust-lang/rust/blob/595e2910d8132170dab30fd31fc09800609188a8/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/595e2910d8132170dab30fd31fc09800609188a8/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=595e2910d8132170dab30fd31fc09800609188a8", "patch": "@@ -216,6 +216,15 @@ impl<T> ResolveResult<T> {\n     }\n }\n \n+enum FallbackSuggestion {\n+    NoSuggestion,\n+    Field,\n+    Method,\n+    TraitMethod,\n+    StaticMethod(StrBuf),\n+    StaticTraitMethod(StrBuf),\n+}\n+\n enum TypeParameters<'a> {\n     NoTypeParameters,                   //< No type parameters.\n     HasTypeParameters(&'a Generics,  //< Type parameters.\n@@ -822,7 +831,7 @@ fn Resolver<'a>(session: &'a Session,\n         graph_root: graph_root,\n \n         method_map: RefCell::new(FnvHashMap::new()),\n-        structs: HashSet::new(),\n+        structs: FnvHashMap::new(),\n \n         unresolved_imports: 0,\n \n@@ -831,7 +840,8 @@ fn Resolver<'a>(session: &'a Session,\n         type_ribs: RefCell::new(Vec::new()),\n         label_ribs: RefCell::new(Vec::new()),\n \n-        current_trait_refs: None,\n+        current_trait_ref: None,\n+        current_self_type: None,\n \n         self_ident: special_idents::self_,\n         type_self_ident: special_idents::type_self,\n@@ -861,7 +871,7 @@ struct Resolver<'a> {\n     graph_root: NameBindings,\n \n     method_map: RefCell<FnvHashMap<(Name, DefId), ast::ExplicitSelf_>>,\n-    structs: HashSet<DefId>,\n+    structs: FnvHashMap<DefId, Vec<Name>>,\n \n     // The number of imports that are currently unresolved.\n     unresolved_imports: uint,\n@@ -880,7 +890,10 @@ struct Resolver<'a> {\n     label_ribs: RefCell<Vec<Rib>>,\n \n     // The trait that the current context can refer to.\n-    current_trait_refs: Option<Vec<DefId> >,\n+    current_trait_ref: Option<(DefId, TraitRef)>,\n+\n+    // The current self type if inside an impl (used for better errors).\n+    current_self_type: Option<Ty>,\n \n     // The ident for the keyword \"self\".\n     self_ident: Ident,\n@@ -1229,8 +1242,14 @@ impl<'a> Resolver<'a> {\n                     None\n                 });\n \n-                // Record the def ID of this struct.\n-                self.structs.insert(local_def(item.id));\n+                // Record the def ID and fields of this struct.\n+                let named_fields = struct_def.fields.iter().filter_map(|f| {\n+                    match f.node.kind {\n+                        NamedField(ident, _) => Some(ident.name),\n+                        UnnamedField(_) => None\n+                    }\n+                }).collect();\n+                self.structs.insert(local_def(item.id), named_fields);\n \n                 parent\n             }\n@@ -1405,7 +1424,9 @@ impl<'a> Resolver<'a> {\n                 child.define_type(DefVariant(item_id,\n                                              local_def(variant.node.id), true),\n                                   variant.span, is_public);\n-                self.structs.insert(local_def(variant.node.id));\n+\n+                // Not adding fields for variants as they are not accessed with a self receiver\n+                self.structs.insert(local_def(variant.node.id), Vec::new());\n             }\n         }\n     }\n@@ -1631,7 +1652,8 @@ impl<'a> Resolver<'a> {\n                               self.external_exports.contains(&enum_did);\n             if is_struct {\n                 child_name_bindings.define_type(def, DUMMY_SP, is_exported);\n-                self.structs.insert(variant_id);\n+                // Not adding fields for variants as they are not accessed with a self receiver\n+                self.structs.insert(variant_id, Vec::new());\n             } else {\n                 child_name_bindings.define_value(def, DUMMY_SP, is_exported);\n             }\n@@ -1689,10 +1711,16 @@ impl<'a> Resolver<'a> {\n                     crate) building type and value for {}\",\n                    final_ident);\n             child_name_bindings.define_type(def, DUMMY_SP, is_public);\n-            if csearch::get_struct_fields(&self.session.cstore, def_id).len() == 0 {\n+            let fields = csearch::get_struct_fields(&self.session.cstore, def_id).iter().map(|f| {\n+                f.name\n+            }).collect::<Vec<_>>();\n+\n+            if fields.len() == 0 {\n                 child_name_bindings.define_value(def, DUMMY_SP, is_public);\n             }\n-            self.structs.insert(def_id);\n+\n+            // Record the def ID and fields of this struct.\n+            self.structs.insert(def_id, fields);\n           }\n           DefMethod(..) => {\n               debug!(\"(building reduced graph for external crate) \\\n@@ -2046,7 +2074,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn idents_to_str(&mut self, idents: &[Ident]) -> StrBuf {\n+    fn idents_to_str(&self, idents: &[Ident]) -> StrBuf {\n         let mut first = true;\n         let mut result = StrBuf::new();\n         for ident in idents.iter() {\n@@ -2060,7 +2088,7 @@ impl<'a> Resolver<'a> {\n         result\n     }\n \n-    fn path_idents_to_str(&mut self, path: &Path) -> StrBuf {\n+    fn path_idents_to_str(&self, path: &Path) -> StrBuf {\n         let identifiers: Vec<ast::Ident> = path.segments\n                                              .iter()\n                                              .map(|seg| seg.identifier)\n@@ -2611,7 +2639,7 @@ impl<'a> Resolver<'a> {\n         while index < module_path_len {\n             let name = module_path[index];\n             match self.resolve_name_in_module(search_module.clone(),\n-                                              name,\n+                                              name.name,\n                                               TypeNS,\n                                               name_search_type,\n                                               false) {\n@@ -2924,7 +2952,7 @@ impl<'a> Resolver<'a> {\n \n             // Resolve the name in the parent module.\n             match self.resolve_name_in_module(search_module.clone(),\n-                                              name,\n+                                              name.name,\n                                               namespace,\n                                               PathSearch,\n                                               true) {\n@@ -3090,19 +3118,19 @@ impl<'a> Resolver<'a> {\n     /// passed through a public re-export proxy.\n     fn resolve_name_in_module(&mut self,\n                               module_: Rc<Module>,\n-                              name: Ident,\n+                              name: Name,\n                               namespace: Namespace,\n                               name_search_type: NameSearchType,\n                               allow_private_imports: bool)\n                               -> ResolveResult<(Target, bool)> {\n         debug!(\"(resolving name in module) resolving `{}` in `{}`\",\n-               token::get_ident(name),\n+               token::get_name(name).get(),\n                self.module_to_str(&*module_));\n \n         // First, check the direct children of the module.\n         self.populate_module_if_necessary(&module_);\n \n-        match module_.children.borrow().find(&name.name) {\n+        match module_.children.borrow().find(&name) {\n             Some(name_bindings)\n                     if name_bindings.defined_in_namespace(namespace) => {\n                 debug!(\"(resolving name in module) found node as child\");\n@@ -3123,7 +3151,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         // Check the list of resolved imports.\n-        match module_.import_resolutions.borrow().find(&name.name) {\n+        match module_.import_resolutions.borrow().find(&name) {\n             Some(import_resolution) if allow_private_imports ||\n                                        import_resolution.is_public => {\n \n@@ -3152,7 +3180,7 @@ impl<'a> Resolver<'a> {\n \n         // Finally, search through external children.\n         if namespace == TypeNS {\n-            match module_.external_module_children.borrow().find_copy(&name.name) {\n+            match module_.external_module_children.borrow().find_copy(&name) {\n                 None => {}\n                 Some(module) => {\n                     let name_bindings =\n@@ -3164,7 +3192,7 @@ impl<'a> Resolver<'a> {\n \n         // We're out of luck.\n         debug!(\"(resolving name in module) failed to resolve `{}`\",\n-               token::get_ident(name));\n+               token::get_name(name).get());\n         return Failed;\n     }\n \n@@ -3881,7 +3909,7 @@ impl<'a> Resolver<'a> {\n                 Some(t) => match t.node {\n                     TyPath(ref path, None, path_id) => {\n                         match this.resolve_path(id, path, TypeNS, true) {\n-                            Some((DefTy(def_id), lp)) if this.structs.contains(&def_id) => {\n+                            Some((DefTy(def_id), lp)) if this.structs.contains_key(&def_id) => {\n                                 let def = DefStruct(def_id);\n                                 debug!(\"(resolving struct) resolved `{}` to type {:?}\",\n                                        token::get_ident(path.segments\n@@ -3932,6 +3960,37 @@ impl<'a> Resolver<'a> {\n         self.resolve_function(rib_kind, Some(method.decl), type_parameters, method.body);\n     }\n \n+    fn with_current_self_type<T>(&mut self, self_type: &Ty, f: |&mut Resolver| -> T) -> T {\n+        // Handle nested impls (inside fn bodies)\n+        let previous_value = replace(&mut self.current_self_type, Some(self_type.clone()));\n+        let result = f(self);\n+        self.current_self_type = previous_value;\n+        result\n+    }\n+\n+    fn with_optional_trait_ref<T>(&mut self, id: NodeId,\n+                                  opt_trait_ref: &Option<TraitRef>,\n+                                  f: |&mut Resolver| -> T) -> T {\n+        let new_val = match *opt_trait_ref {\n+            Some(ref trait_ref) => {\n+                self.resolve_trait_reference(id, trait_ref, TraitImplementation);\n+\n+                match self.def_map.borrow().find(&trait_ref.ref_id) {\n+                    Some(def) => {\n+                        let did = def_id_of_def(*def);\n+                        Some((did, trait_ref.clone()))\n+                    }\n+                    None => None\n+                }\n+            }\n+            None => None\n+        };\n+        let original_trait_ref = replace(&mut self.current_trait_ref, new_val);\n+        let result = f(self);\n+        self.current_trait_ref = original_trait_ref;\n+        result\n+    }\n+\n     fn resolve_implementation(&mut self,\n                                   id: NodeId,\n                                   generics: &Generics,\n@@ -3949,58 +4008,19 @@ impl<'a> Resolver<'a> {\n             this.resolve_type_parameters(&generics.ty_params);\n \n             // Resolve the trait reference, if necessary.\n-            let original_trait_refs;\n-            match opt_trait_reference {\n-                &Some(ref trait_reference) => {\n-                    this.resolve_trait_reference(id, trait_reference,\n-                        TraitImplementation);\n-\n-                    // Record the current set of trait references.\n-                    let mut new_trait_refs = Vec::new();\n-                    for &def in this.def_map.borrow()\n-                                    .find(&trait_reference.ref_id).iter() {\n-                        new_trait_refs.push(def_id_of_def(*def));\n+            this.with_optional_trait_ref(id, opt_trait_reference, |this| {\n+                // Resolve the self type.\n+                this.resolve_type(self_type);\n+\n+                this.with_current_self_type(self_type, |this| {\n+                    for method in methods.iter() {\n+                        // We also need a new scope for the method-specific type parameters.\n+                        this.resolve_method(MethodRibKind(id, Provided(method.id)),\n+                                            *method,\n+                                            outer_type_parameter_count);\n                     }\n-                    original_trait_refs = Some(replace(\n-                        &mut this.current_trait_refs,\n-                        Some(new_trait_refs)));\n-                }\n-                &None => {\n-                    original_trait_refs = None;\n-                }\n-            }\n-\n-            // Resolve the self type.\n-            this.resolve_type(self_type);\n-\n-            for method in methods.iter() {\n-                // We also need a new scope for the method-specific\n-                // type parameters.\n-                this.resolve_method(MethodRibKind(\n-                    id,\n-                    Provided(method.id)),\n-                    *method,\n-                    outer_type_parameter_count);\n-/*\n-                    let borrowed_type_parameters = &method.tps;\n-                    self.resolve_function(MethodRibKind(\n-                                          id,\n-                                          Provided(method.id)),\n-                                          Some(method.decl),\n-                                          HasTypeParameters\n-                                            (borrowed_type_parameters,\n-                                             method.id,\n-                                             outer_type_parameter_count,\n-                                             NormalRibKind),\n-                                          method.body);\n-*/\n-            }\n-\n-            // Restore the original trait references.\n-            match original_trait_refs {\n-                Some(r) => { this.current_trait_refs = r; }\n-                None => ()\n-            }\n+                });\n+            });\n         });\n     }\n \n@@ -4459,16 +4479,16 @@ impl<'a> Resolver<'a> {\n                 PatStruct(ref path, _, _) => {\n                     match self.resolve_path(pat_id, path, TypeNS, false) {\n                         Some((DefTy(class_id), lp))\n-                                if self.structs.contains(&class_id) => {\n+                                if self.structs.contains_key(&class_id) => {\n                             let class_def = DefStruct(class_id);\n                             self.record_def(pattern.id, (class_def, lp));\n                         }\n                         Some(definition @ (DefStruct(class_id), _)) => {\n-                            assert!(self.structs.contains(&class_id));\n+                            assert!(self.structs.contains_key(&class_id));\n                             self.record_def(pattern.id, definition);\n                         }\n                         Some(definition @ (DefVariant(_, variant_id, _), _))\n-                                if self.structs.contains(&variant_id) => {\n+                                if self.structs.contains_key(&variant_id) => {\n                             self.record_def(pattern.id, definition);\n                         }\n                         result => {\n@@ -4607,13 +4627,13 @@ impl<'a> Resolver<'a> {\n     // FIXME #4952: Merge me with resolve_name_in_module?\n     fn resolve_definition_of_name_in_module(&mut self,\n                                             containing_module: Rc<Module>,\n-                                            name: Ident,\n+                                            name: Name,\n                                             namespace: Namespace)\n                                                 -> NameDefinition {\n         // First, search children.\n         self.populate_module_if_necessary(&containing_module);\n \n-        match containing_module.children.borrow().find(&name.name) {\n+        match containing_module.children.borrow().find(&name) {\n             Some(child_name_bindings) => {\n                 match child_name_bindings.def_for_namespace(namespace) {\n                     Some(def) => {\n@@ -4632,7 +4652,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         // Next, search import resolutions.\n-        match containing_module.import_resolutions.borrow().find(&name.name) {\n+        match containing_module.import_resolutions.borrow().find(&name) {\n             Some(import_resolution) if import_resolution.is_public => {\n                 match (*import_resolution).target_for_namespace(namespace) {\n                     Some(target) => {\n@@ -4658,7 +4678,7 @@ impl<'a> Resolver<'a> {\n         // Finally, search through external children.\n         if namespace == TypeNS {\n             match containing_module.external_module_children.borrow()\n-                                   .find_copy(&name.name) {\n+                                   .find_copy(&name) {\n                 None => {}\n                 Some(module) => {\n                     match module.def_id.get() {\n@@ -4713,7 +4733,7 @@ impl<'a> Resolver<'a> {\n \n         let ident = path.segments.last().unwrap().identifier;\n         let def = match self.resolve_definition_of_name_in_module(containing_module.clone(),\n-                                                        ident,\n+                                                        ident.name,\n                                                         namespace) {\n             NoNameDefinition => {\n                 // We failed to resolve the name. Report an error.\n@@ -4782,7 +4802,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        let name = path.segments.last().unwrap().identifier;\n+        let name = path.segments.last().unwrap().identifier.name;\n         match self.resolve_definition_of_name_in_module(containing_module,\n                                                         name,\n                                                         namespace) {\n@@ -4883,6 +4903,99 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    fn find_fallback_in_self_type(&mut self, name: Name) -> FallbackSuggestion {\n+        fn get_module(this: &mut Resolver, span: Span, ident_path: &[ast::Ident])\n+                            -> Option<Rc<Module>> {\n+            let root = this.current_module.clone();\n+            let last_name = ident_path.last().unwrap().name;\n+\n+            if ident_path.len() == 1 {\n+                match this.primitive_type_table.primitive_types.find(&last_name) {\n+                    Some(_) => None,\n+                    None => {\n+                        match this.current_module.children.borrow().find(&last_name) {\n+                            Some(child) => child.get_module_if_available(),\n+                            None => None\n+                        }\n+                    }\n+                }\n+            } else {\n+                match this.resolve_module_path(root,\n+                                                ident_path.as_slice(),\n+                                                UseLexicalScope,\n+                                                span,\n+                                                PathSearch) {\n+                    Success((module, _)) => Some(module),\n+                    _ => None\n+                }\n+            }\n+        }\n+\n+        let (path, node_id) = match self.current_self_type {\n+            Some(ref ty) => match ty.node {\n+                TyPath(ref path, _, node_id) => (path.clone(), node_id),\n+                _ => unreachable!(),\n+            },\n+            None => return NoSuggestion,\n+        };\n+\n+        // Look for a field with the same name in the current self_type.\n+        match self.def_map.borrow().find(&node_id) {\n+             Some(&DefTy(did))\n+            | Some(&DefStruct(did))\n+            | Some(&DefVariant(_, did, _)) => match self.structs.find(&did) {\n+                None => {}\n+                Some(fields) => {\n+                    if fields.iter().any(|&field_name| name == field_name) {\n+                        return Field;\n+                    }\n+                }\n+            },\n+            _ => {} // Self type didn't resolve properly\n+        }\n+\n+        let ident_path = path.segments.iter().map(|seg| seg.identifier).collect::<Vec<_>>();\n+\n+        // Look for a method in the current self type's impl module.\n+        match get_module(self, path.span, ident_path.as_slice()) {\n+            Some(module) => match module.children.borrow().find(&name) {\n+                Some(binding) => {\n+                    let p_str = self.path_idents_to_str(&path);\n+                    match binding.def_for_namespace(ValueNS) {\n+                        Some(DefStaticMethod(_, provenance, _)) => {\n+                            match provenance {\n+                                FromImpl(_) => return StaticMethod(p_str),\n+                                FromTrait(_) => unreachable!()\n+                            }\n+                        }\n+                        Some(DefMethod(_, None)) => return Method,\n+                        Some(DefMethod(_, _)) => return TraitMethod,\n+                        _ => ()\n+                    }\n+                }\n+                None => {}\n+            },\n+            None => {}\n+        }\n+\n+        // Look for a method in the current trait.\n+        let method_map = self.method_map.borrow();\n+        match self.current_trait_ref {\n+            Some((did, ref trait_ref)) => {\n+                let path_str = self.path_idents_to_str(&trait_ref.path);\n+\n+                match method_map.find(&(name, did)) {\n+                    Some(&SelfStatic) => return StaticTraitMethod(path_str),\n+                    Some(_) => return TraitMethod,\n+                    None => {}\n+                }\n+            }\n+            None => {}\n+        }\n+\n+        NoSuggestion\n+    }\n+\n     fn find_best_match_for_name(&mut self, name: &str, max_distance: uint)\n                                 -> Option<StrBuf> {\n         let this = &mut *self;\n@@ -4970,7 +5083,7 @@ impl<'a> Resolver<'a> {\n                         match self.with_no_errors(|this|\n                             this.resolve_path(expr.id, path, TypeNS, false)) {\n                             Some((DefTy(struct_id), _))\n-                              if self.structs.contains(&struct_id) => {\n+                              if self.structs.contains_key(&struct_id) => {\n                                 self.resolve_error(expr.span,\n                                         format!(\"`{}` is a structure name, but \\\n                                                  this expression \\\n@@ -4983,25 +5096,53 @@ impl<'a> Resolver<'a> {\n                                             wrong_name));\n \n                             }\n-                            _ =>\n-                               // limit search to 5 to reduce the number\n-                               // of stupid suggestions\n-                               match self.find_best_match_for_name(\n-                                        wrong_name.as_slice(),\n-                                        5) {\n-                                   Some(m) => {\n-                                       self.resolve_error(expr.span,\n-                                           format!(\"unresolved name `{}`. \\\n-                                                    Did you mean `{}`?\",\n-                                                    wrong_name,\n-                                                    m));\n-                                   }\n-                                   None => {\n-                                       self.resolve_error(expr.span,\n-                                            format!(\"unresolved name `{}`.\",\n-                                                    wrong_name.as_slice()));\n-                                   }\n-                               }\n+                            _ => {\n+                                let mut method_scope = false;\n+                                self.value_ribs.borrow().iter().rev().advance(|rib| {\n+                                    let res = match *rib {\n+                                        Rib { bindings: _, kind: MethodRibKind(_, _) } => true,\n+                                        Rib { bindings: _, kind: OpaqueFunctionRibKind } => false,\n+                                        _ => return true, // Keep advancing\n+                                    };\n+\n+                                    method_scope = res;\n+                                    false // Stop advancing\n+                                });\n+\n+                                if method_scope && token::get_name(self.self_ident.name).get()\n+                                                                        == wrong_name.as_slice() {\n+                                        self.resolve_error(expr.span,\n+                                                            format!(\"`self` is not available in a \\\n+                                                                    static method. Maybe a `self` \\\n+                                                                    argument is missing?\"));\n+                                } else {\n+                                    let name = path_to_ident(path).name;\n+                                    let mut msg = match self.find_fallback_in_self_type(name) {\n+                                        NoSuggestion => {\n+                                            // limit search to 5 to reduce the number\n+                                            // of stupid suggestions\n+                                            self.find_best_match_for_name(wrong_name.as_slice(), 5)\n+                                                                .map_or(\"\".into_owned(),\n+                                                                        |x| format!(\"`{}`\", x))\n+                                        }\n+                                        Field =>\n+                                            format!(\"`self.{}`\", wrong_name),\n+                                        Method\n+                                        | TraitMethod =>\n+                                            format!(\"to call `self.{}`\", wrong_name),\n+                                        StaticTraitMethod(path_str)\n+                                        | StaticMethod(path_str) =>\n+                                            format!(\"to call `{}::{}`\", path_str, wrong_name)\n+                                    };\n+\n+                                    if msg.len() > 0 {\n+                                        msg = format!(\" Did you mean {}?\", msg)\n+                                    }\n+\n+                                    self.resolve_error(expr.span, format!(\"unresolved name `{}`.{}\",\n+                                                                            wrong_name, msg));\n+                                }\n+                            }\n                         }\n                     }\n                 }\n@@ -5020,12 +5161,12 @@ impl<'a> Resolver<'a> {\n                 // Resolve the path to the structure it goes to.\n                 match self.resolve_path(expr.id, path, TypeNS, false) {\n                     Some((DefTy(class_id), lp)) | Some((DefStruct(class_id), lp))\n-                            if self.structs.contains(&class_id) => {\n+                            if self.structs.contains_key(&class_id) => {\n                         let class_def = DefStruct(class_id);\n                         self.record_def(expr.id, (class_def, lp));\n                     }\n                     Some(definition @ (DefVariant(_, class_id, _), _))\n-                            if self.structs.contains(&class_id) => {\n+                            if self.structs.contains_key(&class_id) => {\n                         self.record_def(expr.id, definition);\n                     }\n                     result => {\n@@ -5125,18 +5266,15 @@ impl<'a> Resolver<'a> {\n         let mut search_module = self.current_module.clone();\n         loop {\n             // Look for the current trait.\n-            match self.current_trait_refs {\n-                Some(ref trait_def_ids) => {\n+            match self.current_trait_ref {\n+                Some((trait_def_id, _)) => {\n                     let method_map = self.method_map.borrow();\n-                    for &trait_def_id in trait_def_ids.iter() {\n-                        if method_map.contains_key(&(name, trait_def_id)) {\n-                            add_trait_info(&mut found_traits, trait_def_id, name);\n-                        }\n+\n+                    if method_map.contains_key(&(name, trait_def_id)) {\n+                        add_trait_info(&mut found_traits, trait_def_id, name);\n                     }\n                 }\n-                None => {\n-                    // Nothing to do.\n-                }\n+                None => {} // Nothing to do.\n             }\n \n             // Look for trait children."}, {"sha": "4d9e56a21f804c1f790680a169dfce9dfb598259", "filename": "src/test/compile-fail/issue-2356.rs", "status": "modified", "additions": 75, "deletions": 4, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/595e2910d8132170dab30fd31fc09800609188a8/src%2Ftest%2Fcompile-fail%2Fissue-2356.rs", "raw_url": "https://github.com/rust-lang/rust/raw/595e2910d8132170dab30fd31fc09800609188a8/src%2Ftest%2Fcompile-fail%2Fissue-2356.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2356.rs?ref=595e2910d8132170dab30fd31fc09800609188a8", "patch": "@@ -8,12 +8,83 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-test Resolve code for classes knew how to do this, impls don't\n+trait Groom {\n+    fn shave();\n+}\n+\n+pub struct cat {\n+  whiskers: int,\n+}\n+\n+pub enum MaybeDog {\n+    Dog,\n+    NoDog\n+}\n+\n+impl MaybeDog {\n+  fn bark() {\n+    // If this provides a suggestion, it's a bug as MaybeDog doesn't impl Groom\n+    shave();\n+    //~^ ERROR: unresolved name `shave`.\n+  }\n+}\n+\n+impl Groom for cat {\n+  fn shave(&self, other: uint) {\n+    whiskers -= other;\n+    //~^ ERROR: unresolved name `whiskers`. Did you mean `self.whiskers`?\n+    shave(4);\n+    //~^ ERROR: unresolved name `shave`. Did you mean to call `Groom::shave`?\n+    purr();\n+    //~^ ERROR: unresolved name `purr`. Did you mean to call `self.purr`?\n+  }\n+}\n+\n+impl cat {\n+    fn static_method() {}\n \n-struct cat {\n-  tail: int,\n+    fn purr_louder() {\n+        static_method();\n+        //~^ ERROR: unresolved name `static_method`. Did you mean to call `cat::static_method`\n+        purr();\n+        //~^ ERROR: unresolved name `purr`. Did you mean to call `self.purr`?\n+        purr();\n+        //~^ ERROR: unresolved name `purr`. Did you mean to call `self.purr`?\n+        purr();\n+        //~^ ERROR: unresolved name `purr`. Did you mean to call `self.purr`?\n+    }\n }\n \n impl cat {\n-  pub fn meow() { tail += 1; } //~ ERROR: Did you mean: `self.tail`\n+  fn meow() {\n+    if self.whiskers > 3 {\n+        //~^ ERROR: `self` is not available in a static method. Maybe a `self` argument is missing?\n+        println!(\"MEOW\");\n+    }\n+  }\n+\n+  fn purr(&self) {\n+    grow_older();\n+    //~^ ERROR: unresolved name `grow_older`. Did you mean to call `cat::grow_older`\n+    shave();\n+    //~^ ERROR: unresolved name `shave`.\n+  }\n+\n+  fn burn_whiskers(&mut self) {\n+    whiskers = 0;\n+    //~^ ERROR: unresolved name `whiskers`. Did you mean `self.whiskers`?\n+  }\n+\n+  pub fn grow_older(other:uint) {\n+    whiskers = 4;\n+    //~^ ERROR: unresolved name `whiskers`. Did you mean `self.whiskers`?\n+    purr_louder();\n+    //~^ ERROR: unresolved name `purr_louder`. Did you mean to call `cat::purr_louder`\n+  }\n+}\n+\n+fn main() {\n+    self += 1;\n+    //~^ ERROR: unresolved name `self`.\n+    // it's a bug if this suggests a missing `self` as we're not in a method\n }"}]}