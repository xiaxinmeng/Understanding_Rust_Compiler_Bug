{"sha": "d7c82ba4a19a44ddb505daa9833cad8b6a624ec6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3YzgyYmE0YTE5YTQ0ZGRiNTA1ZGFhOTgzM2NhZDhiNmE2MjRlYzY=", "commit": {"author": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2021-04-28T15:31:33Z"}, "committer": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2021-07-30T17:39:56Z"}, "message": "Split core::panic module to subdirectory", "tree": {"sha": "c33aa14f355726615b3279e6ff0f25a5c093d1be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c33aa14f355726615b3279e6ff0f25a5c093d1be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7c82ba4a19a44ddb505daa9833cad8b6a624ec6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEERijF2Cz/ZdaBZKeK+boUO5X/bYIFAmEEOWwACgkQ+boUO5X/\nbYKgfhAAhwQy0dxDlWsmgCY5OxRlxMZhlYoA22w5BxWM3lnvFfiMvBXXOIkuphzW\npaGC9SxKdszIN+PJQQRyf1G0fvpv/yoGqCCUH2VLA8rlda6Jy3GPQ1cNk/y2jacW\nGABjYqyWVhOgscZ8mwIEWtMKzB2rE25nNNGL48xJ9fO+29R2sGi2nwypMITEUELB\nRHxBEfh4yj5rDSwKYbEWdV73/T568AGTuIMvSjYXSibW06vfy5IoJ6+AzZzCdj2b\nzk4rOtlLqvMIcZ/2iAnHwrNcmX3ps1J/HqeWytq9raV6zdq/npKN6dQQi5IUJSr2\nS7m63nvjQG4HWplGVMTFCd4ELN+3J+HPKOb++drmJPYxQ+rRYgrxvbnsVyazj6MH\nqz7MFwKGudaQwb0XKaDdjkYx9jKq5cg/rSsYDGvTJheiz0AGbspYXvjwEIkQq3Cn\nK0pJGpd2ArkGdlvX7dU+zQpUY5dMutz1d/88MG9vMPAb83Vf4vMpc9MaRfWBxLad\nZsAsRq/5KCIcp/JgALGu7To45QlVSzvJFLLxokKst/OdiKE/nXRiONHaAze+iGt0\no8qTqf2nzuTtjph560O2CorBrHKfvynksnR0L4MeveGs3O/DwXipD9D5YBNfea/+\nuRHPwlPQr68xvp4oZoZyV8ur7H8LUKFSecHs1zgwve9Yv/8pP1c=\n=SQ7K\n-----END PGP SIGNATURE-----", "payload": "tree c33aa14f355726615b3279e6ff0f25a5c093d1be\nparent f3f8e758f2b2abd84b76bcb4ec0b6ae263e1e7b9\nauthor David Tolnay <dtolnay@gmail.com> 1619623893 -0700\ncommitter David Tolnay <dtolnay@gmail.com> 1627666796 -0700\n\nSplit core::panic module to subdirectory\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7c82ba4a19a44ddb505daa9833cad8b6a624ec6", "html_url": "https://github.com/rust-lang/rust/commit/d7c82ba4a19a44ddb505daa9833cad8b6a624ec6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7c82ba4a19a44ddb505daa9833cad8b6a624ec6/comments", "author": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3f8e758f2b2abd84b76bcb4ec0b6ae263e1e7b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3f8e758f2b2abd84b76bcb4ec0b6ae263e1e7b9", "html_url": "https://github.com/rust-lang/rust/commit/f3f8e758f2b2abd84b76bcb4ec0b6ae263e1e7b9"}], "stats": {"total": 669, "additions": 340, "deletions": 329}, "files": [{"sha": "87325eabed31ec36e8f11933b64a84acd00b270d", "filename": "library/core/src/panic.rs", "status": "modified", "additions": 8, "deletions": 329, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/d7c82ba4a19a44ddb505daa9833cad8b6a624ec6/library%2Fcore%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7c82ba4a19a44ddb505daa9833cad8b6a624ec6/library%2Fcore%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanic.rs?ref=d7c82ba4a19a44ddb505daa9833cad8b6a624ec6", "patch": "@@ -2,8 +2,15 @@\n \n #![stable(feature = \"core_panic_info\", since = \"1.41.0\")]\n \n+mod location;\n+mod panic_info;\n+\n use crate::any::Any;\n-use crate::fmt;\n+\n+#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n+pub use self::location::Location;\n+#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n+pub use self::panic_info::PanicInfo;\n \n #[doc(hidden)]\n #[unstable(feature = \"edition_panic\", issue = \"none\", reason = \"use panic!() instead\")]\n@@ -39,334 +46,6 @@ pub macro panic_2021 {\n     ),\n }\n \n-/// A struct providing information about a panic.\n-///\n-/// `PanicInfo` structure is passed to a panic hook set by the [`set_hook`]\n-/// function.\n-///\n-/// [`set_hook`]: ../../std/panic/fn.set_hook.html\n-///\n-/// # Examples\n-///\n-/// ```should_panic\n-/// use std::panic;\n-///\n-/// panic::set_hook(Box::new(|panic_info| {\n-///     if let Some(s) = panic_info.payload().downcast_ref::<&str>() {\n-///         println!(\"panic occurred: {:?}\", s);\n-///     } else {\n-///         println!(\"panic occurred\");\n-///     }\n-/// }));\n-///\n-/// panic!(\"Normal panic\");\n-/// ```\n-#[lang = \"panic_info\"]\n-#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n-#[derive(Debug)]\n-pub struct PanicInfo<'a> {\n-    payload: &'a (dyn Any + Send),\n-    message: Option<&'a fmt::Arguments<'a>>,\n-    location: &'a Location<'a>,\n-}\n-\n-impl<'a> PanicInfo<'a> {\n-    #[unstable(\n-        feature = \"panic_internals\",\n-        reason = \"internal details of the implementation of the `panic!` and related macros\",\n-        issue = \"none\"\n-    )]\n-    #[doc(hidden)]\n-    #[inline]\n-    pub fn internal_constructor(\n-        message: Option<&'a fmt::Arguments<'a>>,\n-        location: &'a Location<'a>,\n-    ) -> Self {\n-        struct NoPayload;\n-        PanicInfo { location, message, payload: &NoPayload }\n-    }\n-\n-    #[unstable(\n-        feature = \"panic_internals\",\n-        reason = \"internal details of the implementation of the `panic!` and related macros\",\n-        issue = \"none\"\n-    )]\n-    #[doc(hidden)]\n-    #[inline]\n-    pub fn set_payload(&mut self, info: &'a (dyn Any + Send)) {\n-        self.payload = info;\n-    }\n-\n-    /// Returns the payload associated with the panic.\n-    ///\n-    /// This will commonly, but not always, be a `&'static str` or [`String`].\n-    ///\n-    /// [`String`]: ../../std/string/struct.String.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```should_panic\n-    /// use std::panic;\n-    ///\n-    /// panic::set_hook(Box::new(|panic_info| {\n-    ///     if let Some(s) = panic_info.payload().downcast_ref::<&str>() {\n-    ///         println!(\"panic occurred: {:?}\", s);\n-    ///     } else {\n-    ///         println!(\"panic occurred\");\n-    ///     }\n-    /// }));\n-    ///\n-    /// panic!(\"Normal panic\");\n-    /// ```\n-    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n-    pub fn payload(&self) -> &(dyn Any + Send) {\n-        self.payload\n-    }\n-\n-    /// If the `panic!` macro from the `core` crate (not from `std`)\n-    /// was used with a formatting string and some additional arguments,\n-    /// returns that message ready to be used for example with [`fmt::write`]\n-    #[unstable(feature = \"panic_info_message\", issue = \"66745\")]\n-    pub fn message(&self) -> Option<&fmt::Arguments<'_>> {\n-        self.message\n-    }\n-\n-    /// Returns information about the location from which the panic originated,\n-    /// if available.\n-    ///\n-    /// This method will currently always return [`Some`], but this may change\n-    /// in future versions.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```should_panic\n-    /// use std::panic;\n-    ///\n-    /// panic::set_hook(Box::new(|panic_info| {\n-    ///     if let Some(location) = panic_info.location() {\n-    ///         println!(\"panic occurred in file '{}' at line {}\",\n-    ///             location.file(),\n-    ///             location.line(),\n-    ///         );\n-    ///     } else {\n-    ///         println!(\"panic occurred but can't get location information...\");\n-    ///     }\n-    /// }));\n-    ///\n-    /// panic!(\"Normal panic\");\n-    /// ```\n-    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n-    pub fn location(&self) -> Option<&Location<'_>> {\n-        // NOTE: If this is changed to sometimes return None,\n-        // deal with that case in std::panicking::default_hook and std::panicking::begin_panic_fmt.\n-        Some(&self.location)\n-    }\n-}\n-\n-#[stable(feature = \"panic_hook_display\", since = \"1.26.0\")]\n-impl fmt::Display for PanicInfo<'_> {\n-    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        formatter.write_str(\"panicked at \")?;\n-        if let Some(message) = self.message {\n-            write!(formatter, \"'{}', \", message)?\n-        } else if let Some(payload) = self.payload.downcast_ref::<&'static str>() {\n-            write!(formatter, \"'{}', \", payload)?\n-        }\n-        // NOTE: we cannot use downcast_ref::<String>() here\n-        // since String is not available in libcore!\n-        // The payload is a String when `std::panic!` is called with multiple arguments,\n-        // but in that case the message is also available.\n-\n-        self.location.fmt(formatter)\n-    }\n-}\n-\n-/// A struct containing information about the location of a panic.\n-///\n-/// This structure is created by [`PanicInfo::location()`].\n-///\n-/// # Examples\n-///\n-/// ```should_panic\n-/// use std::panic;\n-///\n-/// panic::set_hook(Box::new(|panic_info| {\n-///     if let Some(location) = panic_info.location() {\n-///         println!(\"panic occurred in file '{}' at line {}\", location.file(), location.line());\n-///     } else {\n-///         println!(\"panic occurred but can't get location information...\");\n-///     }\n-/// }));\n-///\n-/// panic!(\"Normal panic\");\n-/// ```\n-///\n-/// # Comparisons\n-///\n-/// Comparisons for equality and ordering are made in file, line, then column priority.\n-/// Files are compared as strings, not `Path`, which could be unexpected.\n-/// See [`Location::file`]'s documentation for more discussion.\n-#[lang = \"panic_location\"]\n-#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n-#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n-pub struct Location<'a> {\n-    file: &'a str,\n-    line: u32,\n-    col: u32,\n-}\n-\n-impl<'a> Location<'a> {\n-    /// Returns the source location of the caller of this function. If that function's caller is\n-    /// annotated then its call location will be returned, and so on up the stack to the first call\n-    /// within a non-tracked function body.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::panic::Location;\n-    ///\n-    /// /// Returns the [`Location`] at which it is called.\n-    /// #[track_caller]\n-    /// fn get_caller_location() -> &'static Location<'static> {\n-    ///     Location::caller()\n-    /// }\n-    ///\n-    /// /// Returns a [`Location`] from within this function's definition.\n-    /// fn get_just_one_location() -> &'static Location<'static> {\n-    ///     get_caller_location()\n-    /// }\n-    ///\n-    /// let fixed_location = get_just_one_location();\n-    /// assert_eq!(fixed_location.file(), file!());\n-    /// assert_eq!(fixed_location.line(), 14);\n-    /// assert_eq!(fixed_location.column(), 5);\n-    ///\n-    /// // running the same untracked function in a different location gives us the same result\n-    /// let second_fixed_location = get_just_one_location();\n-    /// assert_eq!(fixed_location.file(), second_fixed_location.file());\n-    /// assert_eq!(fixed_location.line(), second_fixed_location.line());\n-    /// assert_eq!(fixed_location.column(), second_fixed_location.column());\n-    ///\n-    /// let this_location = get_caller_location();\n-    /// assert_eq!(this_location.file(), file!());\n-    /// assert_eq!(this_location.line(), 28);\n-    /// assert_eq!(this_location.column(), 21);\n-    ///\n-    /// // running the tracked function in a different location produces a different value\n-    /// let another_location = get_caller_location();\n-    /// assert_eq!(this_location.file(), another_location.file());\n-    /// assert_ne!(this_location.line(), another_location.line());\n-    /// assert_ne!(this_location.column(), another_location.column());\n-    /// ```\n-    #[stable(feature = \"track_caller\", since = \"1.46.0\")]\n-    #[rustc_const_unstable(feature = \"const_caller_location\", issue = \"76156\")]\n-    #[track_caller]\n-    pub const fn caller() -> &'static Location<'static> {\n-        crate::intrinsics::caller_location()\n-    }\n-}\n-\n-impl<'a> Location<'a> {\n-    #![unstable(\n-        feature = \"panic_internals\",\n-        reason = \"internal details of the implementation of the `panic!` and related macros\",\n-        issue = \"none\"\n-    )]\n-    #[doc(hidden)]\n-    pub const fn internal_constructor(file: &'a str, line: u32, col: u32) -> Self {\n-        Location { file, line, col }\n-    }\n-\n-    /// Returns the name of the source file from which the panic originated.\n-    ///\n-    /// # `&str`, not `&Path`\n-    ///\n-    /// The returned name refers to a source path on the compiling system, but it isn't valid to\n-    /// represent this directly as a `&Path`. The compiled code may run on a different system with\n-    /// a different `Path` implementation than the system providing the contents and this library\n-    /// does not currently have a different \"host path\" type.\n-    ///\n-    /// The most surprising behavior occurs when \"the same\" file is reachable via multiple paths in\n-    /// the module system (usually using the `#[path = \"...\"]` attribute or similar), which can\n-    /// cause what appears to be identical code to return differing values from this function.\n-    ///\n-    /// # Cross-compilation\n-    ///\n-    /// This value is not suitable for passing to `Path::new` or similar constructors when the host\n-    /// platform and target platform differ.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```should_panic\n-    /// use std::panic;\n-    ///\n-    /// panic::set_hook(Box::new(|panic_info| {\n-    ///     if let Some(location) = panic_info.location() {\n-    ///         println!(\"panic occurred in file '{}'\", location.file());\n-    ///     } else {\n-    ///         println!(\"panic occurred but can't get location information...\");\n-    ///     }\n-    /// }));\n-    ///\n-    /// panic!(\"Normal panic\");\n-    /// ```\n-    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n-    pub fn file(&self) -> &str {\n-        self.file\n-    }\n-\n-    /// Returns the line number from which the panic originated.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```should_panic\n-    /// use std::panic;\n-    ///\n-    /// panic::set_hook(Box::new(|panic_info| {\n-    ///     if let Some(location) = panic_info.location() {\n-    ///         println!(\"panic occurred at line {}\", location.line());\n-    ///     } else {\n-    ///         println!(\"panic occurred but can't get location information...\");\n-    ///     }\n-    /// }));\n-    ///\n-    /// panic!(\"Normal panic\");\n-    /// ```\n-    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n-    pub fn line(&self) -> u32 {\n-        self.line\n-    }\n-\n-    /// Returns the column from which the panic originated.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```should_panic\n-    /// use std::panic;\n-    ///\n-    /// panic::set_hook(Box::new(|panic_info| {\n-    ///     if let Some(location) = panic_info.location() {\n-    ///         println!(\"panic occurred at column {}\", location.column());\n-    ///     } else {\n-    ///         println!(\"panic occurred but can't get location information...\");\n-    ///     }\n-    /// }));\n-    ///\n-    /// panic!(\"Normal panic\");\n-    /// ```\n-    #[stable(feature = \"panic_col\", since = \"1.25.0\")]\n-    pub fn column(&self) -> u32 {\n-        self.col\n-    }\n-}\n-\n-#[stable(feature = \"panic_hook_display\", since = \"1.26.0\")]\n-impl fmt::Display for Location<'_> {\n-    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(formatter, \"{}:{}:{}\", self.file, self.line, self.col)\n-    }\n-}\n-\n /// An internal trait used by libstd to pass data from libstd to `panic_unwind`\n /// and other panic runtimes. Not intended to be stabilized any time soon, do\n /// not use."}, {"sha": "6c1dc8bd0457649d6b4d0443b255a2a5d58bea96", "filename": "library/core/src/panic/location.rs", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/d7c82ba4a19a44ddb505daa9833cad8b6a624ec6/library%2Fcore%2Fsrc%2Fpanic%2Flocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7c82ba4a19a44ddb505daa9833cad8b6a624ec6/library%2Fcore%2Fsrc%2Fpanic%2Flocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanic%2Flocation.rs?ref=d7c82ba4a19a44ddb505daa9833cad8b6a624ec6", "patch": "@@ -0,0 +1,187 @@\n+use crate::fmt;\n+\n+/// A struct containing information about the location of a panic.\n+///\n+/// This structure is created by [`PanicInfo::location()`].\n+///\n+/// # Examples\n+///\n+/// ```should_panic\n+/// use std::panic;\n+///\n+/// panic::set_hook(Box::new(|panic_info| {\n+///     if let Some(location) = panic_info.location() {\n+///         println!(\"panic occurred in file '{}' at line {}\", location.file(), location.line());\n+///     } else {\n+///         println!(\"panic occurred but can't get location information...\");\n+///     }\n+/// }));\n+///\n+/// panic!(\"Normal panic\");\n+/// ```\n+///\n+/// # Comparisons\n+///\n+/// Comparisons for equality and ordering are made in file, line, then column priority.\n+/// Files are compared as strings, not `Path`, which could be unexpected.\n+/// See [`Location::file`]'s documentation for more discussion.\n+#[lang = \"panic_location\"]\n+#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n+#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n+pub struct Location<'a> {\n+    file: &'a str,\n+    line: u32,\n+    col: u32,\n+}\n+\n+impl<'a> Location<'a> {\n+    /// Returns the source location of the caller of this function. If that function's caller is\n+    /// annotated then its call location will be returned, and so on up the stack to the first call\n+    /// within a non-tracked function body.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::panic::Location;\n+    ///\n+    /// /// Returns the [`Location`] at which it is called.\n+    /// #[track_caller]\n+    /// fn get_caller_location() -> &'static Location<'static> {\n+    ///     Location::caller()\n+    /// }\n+    ///\n+    /// /// Returns a [`Location`] from within this function's definition.\n+    /// fn get_just_one_location() -> &'static Location<'static> {\n+    ///     get_caller_location()\n+    /// }\n+    ///\n+    /// let fixed_location = get_just_one_location();\n+    /// assert_eq!(fixed_location.file(), file!());\n+    /// assert_eq!(fixed_location.line(), 14);\n+    /// assert_eq!(fixed_location.column(), 5);\n+    ///\n+    /// // running the same untracked function in a different location gives us the same result\n+    /// let second_fixed_location = get_just_one_location();\n+    /// assert_eq!(fixed_location.file(), second_fixed_location.file());\n+    /// assert_eq!(fixed_location.line(), second_fixed_location.line());\n+    /// assert_eq!(fixed_location.column(), second_fixed_location.column());\n+    ///\n+    /// let this_location = get_caller_location();\n+    /// assert_eq!(this_location.file(), file!());\n+    /// assert_eq!(this_location.line(), 28);\n+    /// assert_eq!(this_location.column(), 21);\n+    ///\n+    /// // running the tracked function in a different location produces a different value\n+    /// let another_location = get_caller_location();\n+    /// assert_eq!(this_location.file(), another_location.file());\n+    /// assert_ne!(this_location.line(), another_location.line());\n+    /// assert_ne!(this_location.column(), another_location.column());\n+    /// ```\n+    #[stable(feature = \"track_caller\", since = \"1.46.0\")]\n+    #[rustc_const_unstable(feature = \"const_caller_location\", issue = \"76156\")]\n+    #[track_caller]\n+    pub const fn caller() -> &'static Location<'static> {\n+        crate::intrinsics::caller_location()\n+    }\n+}\n+\n+impl<'a> Location<'a> {\n+    #![unstable(\n+        feature = \"panic_internals\",\n+        reason = \"internal details of the implementation of the `panic!` and related macros\",\n+        issue = \"none\"\n+    )]\n+    #[doc(hidden)]\n+    pub const fn internal_constructor(file: &'a str, line: u32, col: u32) -> Self {\n+        Location { file, line, col }\n+    }\n+\n+    /// Returns the name of the source file from which the panic originated.\n+    ///\n+    /// # `&str`, not `&Path`\n+    ///\n+    /// The returned name refers to a source path on the compiling system, but it isn't valid to\n+    /// represent this directly as a `&Path`. The compiled code may run on a different system with\n+    /// a different `Path` implementation than the system providing the contents and this library\n+    /// does not currently have a different \"host path\" type.\n+    ///\n+    /// The most surprising behavior occurs when \"the same\" file is reachable via multiple paths in\n+    /// the module system (usually using the `#[path = \"...\"]` attribute or similar), which can\n+    /// cause what appears to be identical code to return differing values from this function.\n+    ///\n+    /// # Cross-compilation\n+    ///\n+    /// This value is not suitable for passing to `Path::new` or similar constructors when the host\n+    /// platform and target platform differ.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```should_panic\n+    /// use std::panic;\n+    ///\n+    /// panic::set_hook(Box::new(|panic_info| {\n+    ///     if let Some(location) = panic_info.location() {\n+    ///         println!(\"panic occurred in file '{}'\", location.file());\n+    ///     } else {\n+    ///         println!(\"panic occurred but can't get location information...\");\n+    ///     }\n+    /// }));\n+    ///\n+    /// panic!(\"Normal panic\");\n+    /// ```\n+    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n+    pub fn file(&self) -> &str {\n+        self.file\n+    }\n+\n+    /// Returns the line number from which the panic originated.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```should_panic\n+    /// use std::panic;\n+    ///\n+    /// panic::set_hook(Box::new(|panic_info| {\n+    ///     if let Some(location) = panic_info.location() {\n+    ///         println!(\"panic occurred at line {}\", location.line());\n+    ///     } else {\n+    ///         println!(\"panic occurred but can't get location information...\");\n+    ///     }\n+    /// }));\n+    ///\n+    /// panic!(\"Normal panic\");\n+    /// ```\n+    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n+    pub fn line(&self) -> u32 {\n+        self.line\n+    }\n+\n+    /// Returns the column from which the panic originated.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```should_panic\n+    /// use std::panic;\n+    ///\n+    /// panic::set_hook(Box::new(|panic_info| {\n+    ///     if let Some(location) = panic_info.location() {\n+    ///         println!(\"panic occurred at column {}\", location.column());\n+    ///     } else {\n+    ///         println!(\"panic occurred but can't get location information...\");\n+    ///     }\n+    /// }));\n+    ///\n+    /// panic!(\"Normal panic\");\n+    /// ```\n+    #[stable(feature = \"panic_col\", since = \"1.25.0\")]\n+    pub fn column(&self) -> u32 {\n+        self.col\n+    }\n+}\n+\n+#[stable(feature = \"panic_hook_display\", since = \"1.26.0\")]\n+impl fmt::Display for Location<'_> {\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(formatter, \"{}:{}:{}\", self.file, self.line, self.col)\n+    }\n+}"}, {"sha": "a52a0022e5d2bd7c2b02ba67d9d81e0597edc6e5", "filename": "library/core/src/panic/panic_info.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/d7c82ba4a19a44ddb505daa9833cad8b6a624ec6/library%2Fcore%2Fsrc%2Fpanic%2Fpanic_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7c82ba4a19a44ddb505daa9833cad8b6a624ec6/library%2Fcore%2Fsrc%2Fpanic%2Fpanic_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanic%2Fpanic_info.rs?ref=d7c82ba4a19a44ddb505daa9833cad8b6a624ec6", "patch": "@@ -0,0 +1,145 @@\n+use crate::any::Any;\n+use crate::fmt;\n+use crate::panic::Location;\n+\n+/// A struct providing information about a panic.\n+///\n+/// `PanicInfo` structure is passed to a panic hook set by the [`set_hook`]\n+/// function.\n+///\n+/// [`set_hook`]: ../../std/panic/fn.set_hook.html\n+///\n+/// # Examples\n+///\n+/// ```should_panic\n+/// use std::panic;\n+///\n+/// panic::set_hook(Box::new(|panic_info| {\n+///     if let Some(s) = panic_info.payload().downcast_ref::<&str>() {\n+///         println!(\"panic occurred: {:?}\", s);\n+///     } else {\n+///         println!(\"panic occurred\");\n+///     }\n+/// }));\n+///\n+/// panic!(\"Normal panic\");\n+/// ```\n+#[lang = \"panic_info\"]\n+#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n+#[derive(Debug)]\n+pub struct PanicInfo<'a> {\n+    payload: &'a (dyn Any + Send),\n+    message: Option<&'a fmt::Arguments<'a>>,\n+    location: &'a Location<'a>,\n+}\n+\n+impl<'a> PanicInfo<'a> {\n+    #[unstable(\n+        feature = \"panic_internals\",\n+        reason = \"internal details of the implementation of the `panic!` and related macros\",\n+        issue = \"none\"\n+    )]\n+    #[doc(hidden)]\n+    #[inline]\n+    pub fn internal_constructor(\n+        message: Option<&'a fmt::Arguments<'a>>,\n+        location: &'a Location<'a>,\n+    ) -> Self {\n+        struct NoPayload;\n+        PanicInfo { location, message, payload: &NoPayload }\n+    }\n+\n+    #[unstable(\n+        feature = \"panic_internals\",\n+        reason = \"internal details of the implementation of the `panic!` and related macros\",\n+        issue = \"none\"\n+    )]\n+    #[doc(hidden)]\n+    #[inline]\n+    pub fn set_payload(&mut self, info: &'a (dyn Any + Send)) {\n+        self.payload = info;\n+    }\n+\n+    /// Returns the payload associated with the panic.\n+    ///\n+    /// This will commonly, but not always, be a `&'static str` or [`String`].\n+    ///\n+    /// [`String`]: ../../std/string/struct.String.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```should_panic\n+    /// use std::panic;\n+    ///\n+    /// panic::set_hook(Box::new(|panic_info| {\n+    ///     if let Some(s) = panic_info.payload().downcast_ref::<&str>() {\n+    ///         println!(\"panic occurred: {:?}\", s);\n+    ///     } else {\n+    ///         println!(\"panic occurred\");\n+    ///     }\n+    /// }));\n+    ///\n+    /// panic!(\"Normal panic\");\n+    /// ```\n+    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n+    pub fn payload(&self) -> &(dyn Any + Send) {\n+        self.payload\n+    }\n+\n+    /// If the `panic!` macro from the `core` crate (not from `std`)\n+    /// was used with a formatting string and some additional arguments,\n+    /// returns that message ready to be used for example with [`fmt::write`]\n+    #[unstable(feature = \"panic_info_message\", issue = \"66745\")]\n+    pub fn message(&self) -> Option<&fmt::Arguments<'_>> {\n+        self.message\n+    }\n+\n+    /// Returns information about the location from which the panic originated,\n+    /// if available.\n+    ///\n+    /// This method will currently always return [`Some`], but this may change\n+    /// in future versions.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```should_panic\n+    /// use std::panic;\n+    ///\n+    /// panic::set_hook(Box::new(|panic_info| {\n+    ///     if let Some(location) = panic_info.location() {\n+    ///         println!(\"panic occurred in file '{}' at line {}\",\n+    ///             location.file(),\n+    ///             location.line(),\n+    ///         );\n+    ///     } else {\n+    ///         println!(\"panic occurred but can't get location information...\");\n+    ///     }\n+    /// }));\n+    ///\n+    /// panic!(\"Normal panic\");\n+    /// ```\n+    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n+    pub fn location(&self) -> Option<&Location<'_>> {\n+        // NOTE: If this is changed to sometimes return None,\n+        // deal with that case in std::panicking::default_hook and std::panicking::begin_panic_fmt.\n+        Some(&self.location)\n+    }\n+}\n+\n+#[stable(feature = \"panic_hook_display\", since = \"1.26.0\")]\n+impl fmt::Display for PanicInfo<'_> {\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        formatter.write_str(\"panicked at \")?;\n+        if let Some(message) = self.message {\n+            write!(formatter, \"'{}', \", message)?\n+        } else if let Some(payload) = self.payload.downcast_ref::<&'static str>() {\n+            write!(formatter, \"'{}', \", payload)?\n+        }\n+        // NOTE: we cannot use downcast_ref::<String>() here\n+        // since String is not available in libcore!\n+        // The payload is a String when `std::panic!` is called with multiple arguments,\n+        // but in that case the message is also available.\n+\n+        self.location.fmt(formatter)\n+    }\n+}"}]}