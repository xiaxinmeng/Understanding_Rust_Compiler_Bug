{"sha": "5ac4ffbc121c8231fe3ea5c2bb918f7aae60f197", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhYzRmZmJjMTIxYzgyMzFmZTNlYTVjMmJiOTE4ZjdhYWU2MGYxOTc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-11T09:52:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-11T09:52:56Z"}, "message": "Merge #2211\n\n2211: Refactor highlighting to use classify_name r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "6c3ff58d750bf23678b2d124c4e4aba3b4c04e0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c3ff58d750bf23678b2d124c4e4aba3b4c04e0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ac4ffbc121c8231fe3ea5c2bb918f7aae60f197", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdyS94CRBK7hj4Ov3rIwAAdHIIALFVXc9x+cMob/Fgo7THPUwi\nNLNpLDrVLS/8JTLzTVRnkViWjZ3N/Fkekmaik54hqRYyuRRU8msBNxFGQIS7Hqy3\nfApVktNF+/UZHewsdvwDOPr7aLdAel6luSiiZzb+9tpNiYRgoDOTWvT6bi6hoV2t\nSrK11s7GOH+OYN9XSJLeaPrX7ufH0fkQhS8pnLJBSqZ5nLjYJMkNSqTbU9RMjCpe\nAp2Kc7JCPGzlW6WSCE3P7mPiNr6231YlKGkpaXs0RqLVSFpaifdeUQFyKZRqERdq\nVeEe/OY+TlxNR1onNzDVCqjYKsuQbFbQvgT63eUk0PpYkh+DtEymVLikMoQWAXM=\n=LWgS\n-----END PGP SIGNATURE-----\n", "payload": "tree 6c3ff58d750bf23678b2d124c4e4aba3b4c04e0c\nparent 3dff405443e23a551429d224b6a676361cc6574d\nparent ef70925f5f4f89f56f113c11bca44fd1a7764d50\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1573465976 +0000\ncommitter GitHub <noreply@github.com> 1573465976 +0000\n\nMerge #2211\n\n2211: Refactor highlighting to use classify_name r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ac4ffbc121c8231fe3ea5c2bb918f7aae60f197", "html_url": "https://github.com/rust-lang/rust/commit/5ac4ffbc121c8231fe3ea5c2bb918f7aae60f197", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ac4ffbc121c8231fe3ea5c2bb918f7aae60f197/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3dff405443e23a551429d224b6a676361cc6574d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dff405443e23a551429d224b6a676361cc6574d", "html_url": "https://github.com/rust-lang/rust/commit/3dff405443e23a551429d224b6a676361cc6574d"}, {"sha": "ef70925f5f4f89f56f113c11bca44fd1a7764d50", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef70925f5f4f89f56f113c11bca44fd1a7764d50", "html_url": "https://github.com/rust-lang/rust/commit/ef70925f5f4f89f56f113c11bca44fd1a7764d50"}], "stats": {"total": 145, "additions": 73, "deletions": 72}, "files": [{"sha": "1ee68abe20e8d150a20272a6a5c8497cac7d2aa7", "filename": "crates/ra_ide_api/src/syntax_highlighting.rs", "status": "modified", "additions": 73, "deletions": 72, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/5ac4ffbc121c8231fe3ea5c2bb918f7aae60f197/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ac4ffbc121c8231fe3ea5c2bb918f7aae60f197/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs?ref=5ac4ffbc121c8231fe3ea5c2bb918f7aae60f197", "patch": "@@ -9,12 +9,15 @@ use ra_syntax::{\n     ast::{self, NameOwner},\n     AstNode, Direction, SmolStr, SyntaxElement, SyntaxKind,\n     SyntaxKind::*,\n-    TextRange, T,\n+    SyntaxNode, TextRange, T,\n };\n \n use crate::{\n     db::RootDatabase,\n-    references::{classify_name_ref, NameKind::*},\n+    references::{\n+        classify_name, classify_name_ref,\n+        NameKind::{self, *},\n+    },\n     FileId,\n };\n \n@@ -100,81 +103,43 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n                 if node.ancestors().any(|it| it.kind() == ATTR) {\n                     continue;\n                 }\n-                if let Some(name_ref) = node.as_node().cloned().and_then(ast::NameRef::cast) {\n-                    let name_kind = classify_name_ref(db, file_id, &name_ref).map(|d| d.kind);\n-                    match name_kind {\n-                        Some(Macro(_)) => \"macro\",\n-                        Some(Field(_)) => \"field\",\n-                        Some(AssocItem(hir::AssocItem::Function(_))) => \"function\",\n-                        Some(AssocItem(hir::AssocItem::Const(_))) => \"constant\",\n-                        Some(AssocItem(hir::AssocItem::TypeAlias(_))) => \"type\",\n-                        Some(Def(hir::ModuleDef::Module(_))) => \"module\",\n-                        Some(Def(hir::ModuleDef::Function(_))) => \"function\",\n-                        Some(Def(hir::ModuleDef::Adt(_))) => \"type\",\n-                        Some(Def(hir::ModuleDef::EnumVariant(_))) => \"constant\",\n-                        Some(Def(hir::ModuleDef::Const(_))) => \"constant\",\n-                        Some(Def(hir::ModuleDef::Static(_))) => \"constant\",\n-                        Some(Def(hir::ModuleDef::Trait(_))) => \"type\",\n-                        Some(Def(hir::ModuleDef::TypeAlias(_))) => \"type\",\n-                        Some(Def(hir::ModuleDef::BuiltinType(_))) => \"type\",\n-                        Some(SelfType(_)) => \"type\",\n-                        Some(Pat((_, ptr))) => {\n-                            let pat = ptr.to_node(&root);\n-                            if let Some(name) = pat.name() {\n-                                let text = name.text();\n-                                let shadow_count =\n-                                    bindings_shadow_count.entry(text.clone()).or_default();\n-                                binding_hash =\n-                                    Some(calc_binding_hash(file_id, &text, *shadow_count))\n-                            }\n \n-                            let analyzer =\n-                                hir::SourceAnalyzer::new(db, file_id, name_ref.syntax(), None);\n-                            if is_variable_mutable(db, &analyzer, ptr.to_node(&root)) {\n-                                \"variable.mut\"\n-                            } else {\n-                                \"variable\"\n-                            }\n-                        }\n-                        Some(SelfParam(_)) => \"type\",\n-                        Some(GenericParam(_)) => \"type\",\n-                        None => \"text\",\n+                let name_ref = node.as_node().cloned().and_then(ast::NameRef::cast).unwrap();\n+                let name_kind = classify_name_ref(db, file_id, &name_ref).map(|d| d.kind);\n+\n+                if let Some(Pat((_, ptr))) = &name_kind {\n+                    let pat = ptr.to_node(&root);\n+                    if let Some(name) = pat.name() {\n+                        let text = name.text();\n+                        let shadow_count = bindings_shadow_count.entry(text.clone()).or_default();\n+                        binding_hash = Some(calc_binding_hash(file_id, &text, *shadow_count))\n                     }\n-                } else {\n-                    \"text\"\n-                }\n+                };\n+\n+                name_kind\n+                    .map_or(\"text\", |it| highlight_name(db, file_id, name_ref.syntax(), &root, it))\n             }\n             NAME => {\n-                if let Some(name) = node.as_node().cloned().and_then(ast::Name::cast) {\n-                    let analyzer = hir::SourceAnalyzer::new(db, file_id, name.syntax(), None);\n-                    if let Some(pat) = name.syntax().ancestors().find_map(ast::BindPat::cast) {\n-                        if let Some(name) = pat.name() {\n-                            let text = name.text();\n-                            let shadow_count =\n-                                bindings_shadow_count.entry(text.clone()).or_default();\n-                            *shadow_count += 1;\n-                            binding_hash = Some(calc_binding_hash(file_id, &text, *shadow_count))\n-                        }\n-\n-                        if is_variable_mutable(db, &analyzer, pat) {\n-                            \"variable.mut\"\n-                        } else {\n-                            \"variable\"\n-                        }\n-                    } else {\n-                        name.syntax()\n-                            .parent()\n-                            .map(|x| match x.kind() {\n-                                TYPE_PARAM | STRUCT_DEF | ENUM_DEF | TRAIT_DEF | TYPE_ALIAS_DEF => {\n-                                    \"type\"\n-                                }\n-                                RECORD_FIELD_DEF => \"field\",\n-                                _ => \"function\",\n-                            })\n-                            .unwrap_or(\"function\")\n+                let name = node.as_node().cloned().and_then(ast::Name::cast).unwrap();\n+                let name_kind = classify_name(db, file_id, &name).map(|d| d.kind);\n+\n+                if let Some(Pat((_, ptr))) = &name_kind {\n+                    let pat = ptr.to_node(&root);\n+                    if let Some(name) = pat.name() {\n+                        let text = name.text();\n+                        let shadow_count = bindings_shadow_count.entry(text.clone()).or_default();\n+                        *shadow_count += 1;\n+                        binding_hash = Some(calc_binding_hash(file_id, &text, *shadow_count))\n                     }\n-                } else {\n-                    \"text\"\n+                };\n+\n+                match name_kind {\n+                    Some(name_kind) => highlight_name(db, file_id, name.syntax(), &root, name_kind),\n+                    None => name.syntax().parent().map_or(\"function\", |x| match x.kind() {\n+                        TYPE_PARAM | STRUCT_DEF | ENUM_DEF | TRAIT_DEF | TYPE_ALIAS_DEF => \"type\",\n+                        RECORD_FIELD_DEF => \"field\",\n+                        _ => \"function\",\n+                    }),\n                 }\n             }\n             INT_NUMBER | FLOAT_NUMBER | CHAR | BYTE => \"literal\",\n@@ -272,6 +237,42 @@ pub(crate) fn highlight_as_html(db: &RootDatabase, file_id: FileId, rainbow: boo\n     buf\n }\n \n+fn highlight_name(\n+    db: &RootDatabase,\n+    file_id: FileId,\n+    node: &SyntaxNode,\n+    root: &SyntaxNode,\n+    name_kind: NameKind,\n+) -> &'static str {\n+    match name_kind {\n+        Macro(_) => \"macro\",\n+        Field(_) => \"field\",\n+        AssocItem(hir::AssocItem::Function(_)) => \"function\",\n+        AssocItem(hir::AssocItem::Const(_)) => \"constant\",\n+        AssocItem(hir::AssocItem::TypeAlias(_)) => \"type\",\n+        Def(hir::ModuleDef::Module(_)) => \"module\",\n+        Def(hir::ModuleDef::Function(_)) => \"function\",\n+        Def(hir::ModuleDef::Adt(_)) => \"type\",\n+        Def(hir::ModuleDef::EnumVariant(_)) => \"constant\",\n+        Def(hir::ModuleDef::Const(_)) => \"constant\",\n+        Def(hir::ModuleDef::Static(_)) => \"constant\",\n+        Def(hir::ModuleDef::Trait(_)) => \"type\",\n+        Def(hir::ModuleDef::TypeAlias(_)) => \"type\",\n+        Def(hir::ModuleDef::BuiltinType(_)) => \"type\",\n+        SelfType(_) => \"type\",\n+        SelfParam(_) => \"type\",\n+        GenericParam(_) => \"type\",\n+        Pat((_, ptr)) => {\n+            let analyzer = hir::SourceAnalyzer::new(db, file_id, node, None);\n+            if is_variable_mutable(db, &analyzer, ptr.to_node(&root)) {\n+                \"variable.mut\"\n+            } else {\n+                \"variable\"\n+            }\n+        }\n+    }\n+}\n+\n //FIXME: like, real html escaping\n fn html_escape(text: &str) -> String {\n     text.replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")"}]}