{"sha": "20a6938c08f32bdf5db474866be1dce3952fd9d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwYTY5MzhjMDhmMzJiZGY1ZGI0NzQ4NjZiZTFkY2UzOTUyZmQ5ZDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-16T23:28:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-16T23:28:14Z"}, "message": "Auto merge of #28683 - GuillaumeGomez:rustdoc_error, r=alexcrichton\n\nThis PR solves the following issues (or at least help users to understand the problem):\r\n\r\n```Rust\r\n#![crate_name = \"b\"]\r\n#![crate_type = \"rlib\"]\r\n\r\npub fn his_function_has_a_very_long_name_and_should_make_cargo_doc_explodes_because_it_will_want_to_make_a_filename_with_it_in_excess_of_the_max_filename_length_for_most_filesystem_this_is_not_yet_long_enough_i_need_moreis_function_has_a_very_long_name_and_should_make_cargo_doc_explodes_because_it_will_want_to_make_a_filename_with_it_in_excess_of_the_max_filename_length_for_most_filesystem_this_is_not_yet_long_enough_i_need_more_() {}\r\n```\r\n\r\n```Rust\r\n#![crate_name = \"b\"]\r\n#![crate_type = \"rlib\"]\r\n\r\npub struct his_function_has_a_very_long_name_and_should_make_cargo_doc_explodes_because_it_will_want_to_make_a_filename_with_it_in_excess_of_the_max_filename_length_for_most_filesystem_this_is_not_yet_long_enough_i_need_moreis_function_has_a_very_long_name_and_should_make_cargo_doc_explodes_because_it_will_want_to_make_a_filename_with_it_in_excess_of_the_max_filename_length_for_most_filesystem_this_is_not_yet_long_enough_i_need_more_;\r\n```\r\n\r\nFor the maximum filename length chosen, @gkoz gave me [this link](http://unix.stackexchange.com/a/32834).", "tree": {"sha": "92a27688000d23a942725857c6263204ec5ae452", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92a27688000d23a942725857c6263204ec5ae452"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20a6938c08f32bdf5db474866be1dce3952fd9d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20a6938c08f32bdf5db474866be1dce3952fd9d4", "html_url": "https://github.com/rust-lang/rust/commit/20a6938c08f32bdf5db474866be1dce3952fd9d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20a6938c08f32bdf5db474866be1dce3952fd9d4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be9104291391d9adff91c9ece2b562150979a899", "url": "https://api.github.com/repos/rust-lang/rust/commits/be9104291391d9adff91c9ece2b562150979a899", "html_url": "https://github.com/rust-lang/rust/commit/be9104291391d9adff91c9ece2b562150979a899"}, {"sha": "42c01d740b53bf84fd636e82e5afea0853e23620", "url": "https://api.github.com/repos/rust-lang/rust/commits/42c01d740b53bf84fd636e82e5afea0853e23620", "html_url": "https://github.com/rust-lang/rust/commit/42c01d740b53bf84fd636e82e5afea0853e23620"}], "stats": {"total": 171, "additions": 107, "deletions": 64}, "files": [{"sha": "49228ac91f6b9082d0d6934e3cf2b0a7be1d1566", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 107, "deletions": 64, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/20a6938c08f32bdf5db474866be1dce3952fd9d4/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20a6938c08f32bdf5db474866be1dce3952fd9d4/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=20a6938c08f32bdf5db474866be1dce3952fd9d4", "patch": "@@ -39,7 +39,8 @@ use std::cell::RefCell;\n use std::cmp::Ordering;\n use std::collections::{BTreeMap, HashMap, HashSet};\n use std::default::Default;\n-use std::fmt;\n+use std::error;\n+use std::fmt::{self, Display, Formatter};\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io::{self, BufWriter, BufReader};\n@@ -145,6 +146,42 @@ impl Impl {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct Error {\n+    file: PathBuf,\n+    error: io::Error,\n+}\n+\n+impl error::Error for Error {\n+    fn description(&self) -> &str {\n+        self.error.description()\n+    }\n+}\n+\n+impl Display for Error {\n+    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n+        write!(f, \"\\\"{}\\\": {}\", self.file.display(), self.error)\n+    }\n+}\n+\n+impl Error {\n+    pub fn new(e: io::Error, file: &Path) -> Error {\n+        Error {\n+            file: file.to_path_buf(),\n+            error: e,\n+        }\n+    }\n+}\n+\n+macro_rules! try_err {\n+    ($e:expr, $file:expr) => ({\n+        match $e {\n+            Ok(e) => e,\n+            Err(e) => return Err(Error::new(e, $file)),\n+        }\n+    })\n+}\n+\n /// This cache is used to store information about the `clean::Crate` being\n /// rendered in order to provide more useful documentation. This contains\n /// information like all implementors of a trait, all traits a type implements,\n@@ -310,7 +347,7 @@ thread_local!(pub static CURRENT_LOCATION_KEY: RefCell<Vec<String>> =\n pub fn run(mut krate: clean::Crate,\n            external_html: &ExternalHtml,\n            dst: PathBuf,\n-           passes: HashSet<String>) -> io::Result<()> {\n+           passes: HashSet<String>) -> Result<(), Error> {\n     let src_root = match krate.src.parent() {\n         Some(p) => p.to_path_buf(),\n         None => PathBuf::new(),\n@@ -333,7 +370,7 @@ pub fn run(mut krate: clean::Crate,\n         issue_tracker_base_url: None,\n     };\n \n-    try!(mkdir(&cx.dst));\n+    try_err!(mkdir(&cx.dst), &cx.dst);\n \n     // Crawl the crate attributes looking for attributes which control how we're\n     // going to emit HTML\n@@ -435,7 +472,7 @@ pub fn run(mut krate: clean::Crate,\n     krate = cache.fold_crate(krate);\n \n     // Build our search index\n-    let index = try!(build_index(&krate, &mut cache));\n+    let index = build_index(&krate, &mut cache);\n \n     // Freeze the cache now that the index has been built. Put an Arc into TLS\n     // for future parallelization opportunities\n@@ -450,7 +487,7 @@ pub fn run(mut krate: clean::Crate,\n     cx.krate(krate)\n }\n \n-fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::Result<String> {\n+fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     // Build the search index from the collected metadata\n     let mut nodeid_to_pathid = HashMap::new();\n     let mut pathid_to_nodeid = Vec::new();\n@@ -477,7 +514,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::Result<String> {\n                 },\n                 None => {}\n             }\n-        };\n+        }\n \n         // Reduce `NodeId` in paths into smaller sequential numbers,\n         // and prune the paths that do not appear in the index.\n@@ -498,7 +535,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::Result<String> {\n \n     // Collect the index into a string\n     let mut w = io::Cursor::new(Vec::new());\n-    try!(write!(&mut w, r#\"searchIndex['{}'] = {{\"items\":[\"#, krate.name));\n+    write!(&mut w, r#\"searchIndex['{}'] = {{\"items\":[\"#, krate.name).unwrap();\n \n     let mut lastpath = \"\".to_string();\n     for (i, item) in cache.search_index.iter().enumerate() {\n@@ -512,58 +549,61 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::Result<String> {\n         };\n \n         if i > 0 {\n-            try!(write!(&mut w, \",\"));\n+            write!(&mut w, \",\").unwrap();\n         }\n-        try!(write!(&mut w, r#\"[{},\"{}\",\"{}\",{}\"#,\n-                    item.ty as usize, item.name, path,\n-                    item.desc.to_json().to_string()));\n+        write!(&mut w, r#\"[{},\"{}\",\"{}\",{}\"#,\n+               item.ty as usize, item.name, path,\n+               item.desc.to_json().to_string()).unwrap();\n         match item.parent {\n             Some(nodeid) => {\n                 let pathid = *nodeid_to_pathid.get(&nodeid).unwrap();\n-                try!(write!(&mut w, \",{}\", pathid));\n+                write!(&mut w, \",{}\", pathid).unwrap();\n             }\n-            None => try!(write!(&mut w, \",null\"))\n+            None => write!(&mut w, \",null\").unwrap()\n         }\n         match item.search_type {\n-            Some(ref t) => try!(write!(&mut w, \",{}\", t)),\n-            None => try!(write!(&mut w, \",null\"))\n+            Some(ref t) => write!(&mut w, \",{}\", t).unwrap(),\n+            None => write!(&mut w, \",null\").unwrap()\n         }\n-        try!(write!(&mut w, \"]\"));\n+        write!(&mut w, \"]\").unwrap();\n     }\n \n-    try!(write!(&mut w, r#\"],\"paths\":[\"#));\n+    write!(&mut w, r#\"],\"paths\":[\"#).unwrap();\n \n     for (i, &did) in pathid_to_nodeid.iter().enumerate() {\n         let &(ref fqp, short) = cache.paths.get(&did).unwrap();\n         if i > 0 {\n-            try!(write!(&mut w, \",\"));\n+            write!(&mut w, \",\").unwrap();\n         }\n-        try!(write!(&mut w, r#\"[{},\"{}\"]\"#,\n-                    short as usize, *fqp.last().unwrap()));\n+        write!(&mut w, r#\"[{},\"{}\"]\"#,\n+               short as usize, *fqp.last().unwrap()).unwrap();\n     }\n \n-    try!(write!(&mut w, \"]}};\"));\n+    write!(&mut w, \"]}};\").unwrap();\n \n-    Ok(String::from_utf8(w.into_inner()).unwrap())\n+    String::from_utf8(w.into_inner()).unwrap()\n }\n \n fn write_shared(cx: &Context,\n                 krate: &clean::Crate,\n                 cache: &Cache,\n-                search_index: String) -> io::Result<()> {\n+                search_index: String) -> Result<(), Error> {\n     // Write out the shared files. Note that these are shared among all rustdoc\n     // docs placed in the output directory, so this needs to be a synchronized\n     // operation with respect to all other rustdocs running around.\n-    try!(mkdir(&cx.dst));\n+    try_err!(mkdir(&cx.dst), &cx.dst);\n     let _lock = ::flock::Lock::new(&cx.dst.join(\".lock\"));\n \n     // Add all the static files. These may already exist, but we just\n     // overwrite them anyway to make sure that they're fresh and up-to-date.\n     try!(write(cx.dst.join(\"jquery.js\"),\n                include_bytes!(\"static/jquery-2.1.4.min.js\")));\n-    try!(write(cx.dst.join(\"main.js\"), include_bytes!(\"static/main.js\")));\n-    try!(write(cx.dst.join(\"playpen.js\"), include_bytes!(\"static/playpen.js\")));\n-    try!(write(cx.dst.join(\"main.css\"), include_bytes!(\"static/main.css\")));\n+    try!(write(cx.dst.join(\"main.js\"),\n+               include_bytes!(\"static/main.js\")));\n+    try!(write(cx.dst.join(\"playpen.js\"),\n+               include_bytes!(\"static/playpen.js\")));\n+    try!(write(cx.dst.join(\"main.css\"),\n+               include_bytes!(\"static/main.css\")));\n     try!(write(cx.dst.join(\"normalize.css\"),\n                include_bytes!(\"static/normalize.css\")));\n     try!(write(cx.dst.join(\"FiraSans-Regular.woff\"),\n@@ -615,18 +655,18 @@ fn write_shared(cx: &Context,\n \n     // Update the search index\n     let dst = cx.dst.join(\"search-index.js\");\n-    let all_indexes = try!(collect(&dst, &krate.name, \"searchIndex\"));\n-    let mut w = try!(File::create(&dst));\n-    try!(writeln!(&mut w, \"var searchIndex = {{}};\"));\n-    try!(writeln!(&mut w, \"{}\", search_index));\n+    let all_indexes = try_err!(collect(&dst, &krate.name, \"searchIndex\"), &dst);\n+    let mut w = try_err!(File::create(&dst), &dst);\n+    try_err!(writeln!(&mut w, \"var searchIndex = {{}};\"), &dst);\n+    try_err!(writeln!(&mut w, \"{}\", search_index), &dst);\n     for index in &all_indexes {\n-        try!(writeln!(&mut w, \"{}\", *index));\n+        try_err!(writeln!(&mut w, \"{}\", *index), &dst);\n     }\n-    try!(writeln!(&mut w, \"initSearch(searchIndex);\"));\n+    try_err!(writeln!(&mut w, \"initSearch(searchIndex);\"), &dst);\n \n     // Update the list of all implementors for traits\n     let dst = cx.dst.join(\"implementors\");\n-    try!(mkdir(&dst));\n+    try_err!(mkdir(&dst), &dst);\n     for (&did, imps) in &cache.implementors {\n         // Private modules can leak through to this phase of rustdoc, which\n         // could contain implementations for otherwise private types. In some\n@@ -643,51 +683,53 @@ fn write_shared(cx: &Context,\n         let mut mydst = dst.clone();\n         for part in &remote_path[..remote_path.len() - 1] {\n             mydst.push(part);\n-            try!(mkdir(&mydst));\n+            try_err!(mkdir(&mydst), &mydst);\n         }\n         mydst.push(&format!(\"{}.{}.js\",\n                             remote_item_type.to_static_str(),\n                             remote_path[remote_path.len() - 1]));\n-        let all_implementors = try!(collect(&mydst, &krate.name,\n-                                            \"implementors\"));\n+        let all_implementors = try_err!(collect(&mydst, &krate.name,\n+                                                \"implementors\"),\n+                                        &mydst);\n \n-        try!(mkdir(mydst.parent().unwrap()));\n-        let mut f = BufWriter::new(try!(File::create(&mydst)));\n-        try!(writeln!(&mut f, \"(function() {{var implementors = {{}};\"));\n+        try_err!(mkdir(mydst.parent().unwrap()),\n+                 &mydst.parent().unwrap().to_path_buf());\n+        let mut f = BufWriter::new(try_err!(File::create(&mydst), &mydst));\n+        try_err!(writeln!(&mut f, \"(function() {{var implementors = {{}};\"), &mydst);\n \n         for implementor in &all_implementors {\n-            try!(write!(&mut f, \"{}\", *implementor));\n+            try_err!(write!(&mut f, \"{}\", *implementor), &mydst);\n         }\n \n-        try!(write!(&mut f, r\"implementors['{}'] = [\", krate.name));\n+        try_err!(write!(&mut f, r\"implementors['{}'] = [\", krate.name), &mydst);\n         for imp in imps {\n             // If the trait and implementation are in the same crate, then\n             // there's no need to emit information about it (there's inlining\n             // going on). If they're in different crates then the crate defining\n             // the trait will be interested in our implementation.\n             if imp.def_id.krate == did.krate { continue }\n-            try!(write!(&mut f, r#\"\"{}\",\"#, imp.impl_));\n+            try_err!(write!(&mut f, r#\"\"{}\",\"#, imp.impl_), &mydst);\n         }\n-        try!(writeln!(&mut f, r\"];\"));\n-        try!(writeln!(&mut f, \"{}\", r\"\n+        try_err!(writeln!(&mut f, r\"];\"), &mydst);\n+        try_err!(writeln!(&mut f, \"{}\", r\"\n             if (window.register_implementors) {\n                 window.register_implementors(implementors);\n             } else {\n                 window.pending_implementors = implementors;\n             }\n-        \"));\n-        try!(writeln!(&mut f, r\"}})()\"));\n+        \"), &mydst);\n+        try_err!(writeln!(&mut f, r\"}})()\"), &mydst);\n     }\n     Ok(())\n }\n \n fn render_sources(cx: &mut Context,\n-                  krate: clean::Crate) -> io::Result<clean::Crate> {\n+                  krate: clean::Crate) -> Result<clean::Crate, Error> {\n     info!(\"emitting source files\");\n     let dst = cx.dst.join(\"src\");\n-    try!(mkdir(&dst));\n+    try_err!(mkdir(&dst), &dst);\n     let dst = dst.join(&krate.name);\n-    try!(mkdir(&dst));\n+    try_err!(mkdir(&dst), &dst);\n     let mut folder = SourceCollector {\n         dst: dst,\n         seen: HashSet::new(),\n@@ -700,8 +742,8 @@ fn render_sources(cx: &mut Context,\n \n /// Writes the entire contents of a string to a destination, not attempting to\n /// catch any errors.\n-fn write(dst: PathBuf, contents: &[u8]) -> io::Result<()> {\n-    try!(File::create(&dst)).write_all(contents)\n+fn write(dst: PathBuf, contents: &[u8]) -> Result<(), Error> {\n+    Ok(try_err!(try_err!(File::create(&dst), &dst).write_all(contents), &dst))\n }\n \n /// Makes a directory on the filesystem, failing the thread if an error occurs and\n@@ -850,7 +892,6 @@ impl<'a> SourceCollector<'a> {\n         fname.push(\".html\");\n         cur.push(&fname[..]);\n         let mut w = BufWriter::new(try!(File::create(&cur)));\n-\n         let title = format!(\"{} -- source\", cur.file_name().unwrap()\n                                                .to_string_lossy());\n         let desc = format!(\"Source to the Rust file `{}`.\", filename);\n@@ -1167,7 +1208,7 @@ impl Context {\n     ///\n     /// This currently isn't parallelized, but it'd be pretty easy to add\n     /// parallelization to this function.\n-    fn krate(self, mut krate: clean::Crate) -> io::Result<()> {\n+    fn krate(self, mut krate: clean::Crate) -> Result<(), Error> {\n         let mut item = match krate.module.take() {\n             Some(i) => i,\n             None => return Ok(())\n@@ -1193,7 +1234,7 @@ impl Context {\n     /// all sub-items which need to be rendered.\n     ///\n     /// The rendering driver uses this closure to queue up more work.\n-    fn item<F>(&mut self, item: clean::Item, mut f: F) -> io::Result<()> where\n+    fn item<F>(&mut self, item: clean::Item, mut f: F) -> Result<(), Error> where\n         F: FnMut(&mut Context, clean::Item),\n     {\n         fn render(w: File, cx: &Context, it: &clean::Item,\n@@ -1280,9 +1321,9 @@ impl Context {\n                 let mut item = Some(item);\n                 self.recurse(name, |this| {\n                     let item = item.take().unwrap();\n-                    let dst = this.dst.join(\"index.html\");\n-                    let dst = try!(File::create(&dst));\n-                    try!(render(dst, this, &item, false));\n+                    let joint_dst = this.dst.join(\"index.html\");\n+                    let dst = try_err!(File::create(&joint_dst), &joint_dst);\n+                    try_err!(render(dst, this, &item, false), &joint_dst);\n \n                     let m = match item.inner {\n                         clean::ModuleItem(m) => m,\n@@ -1293,9 +1334,9 @@ impl Context {\n                     {\n                         let items = this.build_sidebar_items(&m);\n                         let js_dst = this.dst.join(\"sidebar-items.js\");\n-                        let mut js_out = BufWriter::new(try!(File::create(&js_dst)));\n-                        try!(write!(&mut js_out, \"initSidebarItems({});\",\n-                                    json::as_json(&items)));\n+                        let mut js_out = BufWriter::new(try_err!(File::create(&js_dst), &js_dst));\n+                        try_err!(write!(&mut js_out, \"initSidebarItems({});\",\n+                                    json::as_json(&items)), &js_dst);\n                     }\n \n                     for item in m.items {\n@@ -1308,9 +1349,11 @@ impl Context {\n             // Things which don't have names (like impls) don't get special\n             // pages dedicated to them.\n             _ if item.name.is_some() => {\n-                let dst = self.dst.join(&item_path(&item));\n-                let dst = try!(File::create(&dst));\n-                render(dst, self, &item, true)\n+                let joint_dst = self.dst.join(&item_path(&item));\n+\n+                let dst = try_err!(File::create(&joint_dst), &joint_dst);\n+                try_err!(render(dst, self, &item, true), &joint_dst);\n+                Ok(())\n             }\n \n             _ => Ok(())"}]}