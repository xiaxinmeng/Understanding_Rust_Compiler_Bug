{"sha": "0a9c13624d2fede5c6ce8e5aa7f486403098bde6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhOWMxMzYyNGQyZmVkZTVjNmNlOGU1YWE3ZjQ4NjQwMzA5OGJkZTY=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2017-06-30T18:34:53Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2017-06-30T18:34:53Z"}, "message": "Revert \"Stabilize RangeArgument\"\n\nThis reverts commit 143206d54d7558c2326212df99efc98110904fdb.", "tree": {"sha": "0eab912d432fe03866fdaf362710bd7bf0752703", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0eab912d432fe03866fdaf362710bd7bf0752703"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a9c13624d2fede5c6ce8e5aa7f486403098bde6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a9c13624d2fede5c6ce8e5aa7f486403098bde6", "html_url": "https://github.com/rust-lang/rust/commit/0a9c13624d2fede5c6ce8e5aa7f486403098bde6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e72580cf091190c6258648e4cfbca083f20ece3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e72580cf091190c6258648e4cfbca083f20ece3d", "html_url": "https://github.com/rust-lang/rust/commit/e72580cf091190c6258648e4cfbca083f20ece3d"}], "stats": {"total": 404, "additions": 217, "deletions": 187}, "files": [{"sha": "a51c70159db4d788c2a5454e161f22fe92627393", "filename": "src/liballoc/btree/map.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Fliballoc%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Fliballoc%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fmap.rs?ref=0a9c13624d2fede5c6ce8e5aa7f486403098bde6", "patch": "@@ -13,11 +13,12 @@ use core::fmt::Debug;\n use core::hash::{Hash, Hasher};\n use core::iter::{FromIterator, Peekable, FusedIterator};\n use core::marker::PhantomData;\n-use core::ops::{Index, RangeArgument};\n-use core::ops::Bound::{Excluded, Included, Unbounded};\n+use core::ops::Index;\n use core::{fmt, intrinsics, mem, ptr};\n \n use borrow::Borrow;\n+use Bound::{Excluded, Included, Unbounded};\n+use range::RangeArgument;\n \n use super::node::{self, Handle, NodeRef, marker};\n use super::search;"}, {"sha": "d32460da9392342e12834e28d1e5684956297b0a", "filename": "src/liballoc/btree/set.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Fliballoc%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Fliballoc%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fset.rs?ref=0a9c13624d2fede5c6ce8e5aa7f486403098bde6", "patch": "@@ -16,11 +16,12 @@ use core::cmp::{min, max};\n use core::fmt::Debug;\n use core::fmt;\n use core::iter::{Peekable, FromIterator, FusedIterator};\n-use core::ops::{BitOr, BitAnd, BitXor, Sub, RangeArgument};\n+use core::ops::{BitOr, BitAnd, BitXor, Sub};\n \n use borrow::Borrow;\n use btree_map::{BTreeMap, Keys};\n use super::Recover;\n+use range::RangeArgument;\n \n // FIXME(conventions): implement bounded iterators\n "}, {"sha": "ca52943ea97e32b57a7279fc5b8fb57e2ba0aeee", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=0a9c13624d2fede5c6ce8e5aa7f486403098bde6", "patch": "@@ -203,7 +203,56 @@ mod std {\n     pub use core::ops;      // RangeFull\n }\n \n-pub use core::ops::Bound;\n+/// An endpoint of a range of keys.\n+///\n+/// # Examples\n+///\n+/// `Bound`s are range endpoints:\n+///\n+/// ```\n+/// #![feature(collections_range)]\n+///\n+/// use std::collections::range::RangeArgument;\n+/// use std::collections::Bound::*;\n+///\n+/// assert_eq!((..100).start(), Unbounded);\n+/// assert_eq!((1..12).start(), Included(&1));\n+/// assert_eq!((1..12).end(), Excluded(&12));\n+/// ```\n+///\n+/// Using a tuple of `Bound`s as an argument to [`BTreeMap::range`].\n+/// Note that in most cases, it's better to use range syntax (`1..5`) instead.\n+///\n+/// ```\n+/// use std::collections::BTreeMap;\n+/// use std::collections::Bound::{Excluded, Included, Unbounded};\n+///\n+/// let mut map = BTreeMap::new();\n+/// map.insert(3, \"a\");\n+/// map.insert(5, \"b\");\n+/// map.insert(8, \"c\");\n+///\n+/// for (key, value) in map.range((Excluded(3), Included(8))) {\n+///     println!(\"{}: {}\", key, value);\n+/// }\n+///\n+/// assert_eq!(Some((&3, &\"a\")), map.range((Unbounded, Included(5))).next());\n+/// ```\n+///\n+/// [`BTreeMap::range`]: btree_map/struct.BTreeMap.html#method.range\n+#[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n+#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq)]\n+pub enum Bound<T> {\n+    /// An inclusive bound.\n+    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n+    Included(T),\n+    /// An exclusive bound.\n+    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n+    Excluded(T),\n+    /// An infinite endpoint. Indicates that there is no bound in this direction.\n+    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n+    Unbounded,\n+}\n \n /// An intermediate trait for specialization of `Extend`.\n #[doc(hidden)]"}, {"sha": "f862da0d61e012ed816811947a14f3fcab5005a5", "filename": "src/liballoc/range.rs", "status": "modified", "additions": 136, "deletions": 2, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Fliballoc%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Fliballoc%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frange.rs?ref=0a9c13624d2fede5c6ce8e5aa7f486403098bde6", "patch": "@@ -11,8 +11,142 @@\n #![unstable(feature = \"collections_range\",\n             reason = \"waiting for dust to settle on inclusive ranges\",\n             issue = \"30877\")]\n-#![rustc_deprecated(reason = \"moved to core::ops\", since = \"1.19.0\")]\n \n //! Range syntax.\n \n-pub use core::ops::RangeArgument;\n+use core::ops::{RangeFull, Range, RangeTo, RangeFrom, RangeInclusive, RangeToInclusive};\n+use Bound::{self, Excluded, Included, Unbounded};\n+\n+/// `RangeArgument` is implemented by Rust's built-in range types, produced\n+/// by range syntax like `..`, `a..`, `..b` or `c..d`.\n+pub trait RangeArgument<T: ?Sized> {\n+    /// Start index bound.\n+    ///\n+    /// Returns the start value as a `Bound`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(alloc)]\n+    /// #![feature(collections_range)]\n+    ///\n+    /// extern crate alloc;\n+    ///\n+    /// # fn main() {\n+    /// use alloc::range::RangeArgument;\n+    /// use alloc::Bound::*;\n+    ///\n+    /// assert_eq!((..10).start(), Unbounded);\n+    /// assert_eq!((3..10).start(), Included(&3));\n+    /// # }\n+    /// ```\n+    fn start(&self) -> Bound<&T>;\n+\n+    /// End index bound.\n+    ///\n+    /// Returns the end value as a `Bound`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(alloc)]\n+    /// #![feature(collections_range)]\n+    ///\n+    /// extern crate alloc;\n+    ///\n+    /// # fn main() {\n+    /// use alloc::range::RangeArgument;\n+    /// use alloc::Bound::*;\n+    ///\n+    /// assert_eq!((3..).end(), Unbounded);\n+    /// assert_eq!((3..10).end(), Excluded(&10));\n+    /// # }\n+    /// ```\n+    fn end(&self) -> Bound<&T>;\n+}\n+\n+// FIXME add inclusive ranges to RangeArgument\n+\n+impl<T: ?Sized> RangeArgument<T> for RangeFull {\n+    fn start(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+}\n+\n+impl<T> RangeArgument<T> for RangeFrom<T> {\n+    fn start(&self) -> Bound<&T> {\n+        Included(&self.start)\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+}\n+\n+impl<T> RangeArgument<T> for RangeTo<T> {\n+    fn start(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Excluded(&self.end)\n+    }\n+}\n+\n+impl<T> RangeArgument<T> for Range<T> {\n+    fn start(&self) -> Bound<&T> {\n+        Included(&self.start)\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Excluded(&self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<T> RangeArgument<T> for RangeInclusive<T> {\n+    fn start(&self) -> Bound<&T> {\n+        Included(&self.start)\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Included(&self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<T> RangeArgument<T> for RangeToInclusive<T> {\n+    fn start(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Included(&self.end)\n+    }\n+}\n+\n+impl<T> RangeArgument<T> for (Bound<T>, Bound<T>) {\n+    fn start(&self) -> Bound<&T> {\n+        match *self {\n+            (Included(ref start), _) => Included(start),\n+            (Excluded(ref start), _) => Excluded(start),\n+            (Unbounded, _)           => Unbounded,\n+        }\n+    }\n+\n+    fn end(&self) -> Bound<&T> {\n+        match *self {\n+            (_, Included(ref end)) => Included(end),\n+            (_, Excluded(ref end)) => Excluded(end),\n+            (_, Unbounded)         => Unbounded,\n+        }\n+    }\n+}\n+\n+impl<'a, T: ?Sized + 'a> RangeArgument<T> for (Bound<&'a T>, Bound<&'a T>) {\n+    fn start(&self) -> Bound<&T> {\n+        self.0\n+    }\n+\n+    fn end(&self) -> Bound<&T> {\n+        self.1\n+    }\n+}"}, {"sha": "79d1ccf637d3753a1cff9a3dd5e8813c713a50a0", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=0a9c13624d2fede5c6ce8e5aa7f486403098bde6", "patch": "@@ -59,14 +59,15 @@\n use core::fmt;\n use core::hash;\n use core::iter::{FromIterator, FusedIterator};\n-use core::ops::{self, Add, AddAssign, Index, IndexMut, RangeArgument};\n-use core::ops::Bound::{Excluded, Included, Unbounded};\n+use core::ops::{self, Add, AddAssign, Index, IndexMut};\n use core::ptr;\n use core::str::pattern::Pattern;\n use std_unicode::lossy;\n use std_unicode::char::{decode_utf16, REPLACEMENT_CHARACTER};\n \n use borrow::{Cow, ToOwned};\n+use range::RangeArgument;\n+use Bound::{Excluded, Included, Unbounded};\n use str::{self, from_boxed_utf8_unchecked, FromStr, Utf8Error, Chars};\n use vec::Vec;\n use boxed::Box;"}, {"sha": "5d1999a42629a2c54fe4bf5f56419ca5f3322cdc", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=0a9c13624d2fede5c6ce8e5aa7f486403098bde6", "patch": "@@ -74,8 +74,7 @@ use core::iter::{FromIterator, FusedIterator, TrustedLen};\n use core::mem;\n #[cfg(not(test))]\n use core::num::Float;\n-use core::ops::{InPlace, Index, IndexMut, Place, Placer, RangeArgument};\n-use core::ops::Bound::{Excluded, Included, Unbounded};\n+use core::ops::{InPlace, Index, IndexMut, Place, Placer};\n use core::ops;\n use core::ptr;\n use core::ptr::Shared;\n@@ -85,6 +84,8 @@ use borrow::ToOwned;\n use borrow::Cow;\n use boxed::Box;\n use raw_vec::RawVec;\n+use super::range::RangeArgument;\n+use Bound::{Excluded, Included, Unbounded};\n \n /// A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\n ///"}, {"sha": "18175a5d01bd2bc7bb13400a2a7aedae265d6437", "filename": "src/liballoc/vec_deque.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Fliballoc%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Fliballoc%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec_deque.rs?ref=0a9c13624d2fede5c6ce8e5aa7f486403098bde6", "patch": "@@ -21,8 +21,7 @@ use core::cmp::Ordering;\n use core::fmt;\n use core::iter::{repeat, FromIterator, FusedIterator};\n use core::mem;\n-use core::ops::{Index, IndexMut, Place, Placer, InPlace, RangeArgument};\n-use core::ops::Bound::{Excluded, Included, Unbounded};\n+use core::ops::{Index, IndexMut, Place, Placer, InPlace};\n use core::ptr;\n use core::ptr::Shared;\n use core::slice;\n@@ -32,6 +31,8 @@ use core::cmp;\n \n use raw_vec::RawVec;\n \n+use super::range::RangeArgument;\n+use Bound::{Excluded, Included, Unbounded};\n use super::vec::Vec;\n \n const INITIAL_CAPACITY: usize = 7; // 2^3 - 1"}, {"sha": "de5d6df328cbd4fd7ca975e115c925b21c8b7fbe", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=0a9c13624d2fede5c6ce8e5aa7f486403098bde6", "patch": "@@ -46,7 +46,6 @@ pub use alloc::binary_heap;\n pub use alloc::borrow;\n pub use alloc::fmt;\n pub use alloc::linked_list;\n-#[allow(deprecated)]\n pub use alloc::range;\n pub use alloc::slice;\n pub use alloc::str;"}, {"sha": "a78f4fe28a6b411078325ada32db8f4381561c3c", "filename": "src/libcore/ops/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Flibcore%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Flibcore%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fmod.rs?ref=0a9c13624d2fede5c6ce8e5aa7f486403098bde6", "patch": "@@ -183,9 +183,6 @@ pub use self::index::{Index, IndexMut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::range::{Range, RangeFrom, RangeFull, RangeTo};\n \n-#[stable(feature = \"range_argument\", since = \"1.19.0\")]\n-pub use self::range::{RangeArgument, Bound};\n-\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n pub use self::range::{RangeInclusive, RangeToInclusive};\n "}, {"sha": "33258b7a875c599aa584d85db0a3d1965ab979c6", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 9, "deletions": 165, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=0a9c13624d2fede5c6ce8e5aa7f486403098bde6", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use fmt;\n-use ops::Bound::{Included, Excluded, Unbounded};\n \n /// An unbounded range. Use `..` (two dots) for its shorthand.\n ///\n@@ -72,8 +71,7 @@ impl fmt::Debug for RangeFull {\n ///     assert_eq!(arr[1..3], [  1,2  ]);  // Range\n /// }\n /// ```\n-#[derive(Clone, PartialEq, Eq, Hash)]\n-// not Copy -- see #27186\n+#[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Range<Idx> {\n     /// The lower bound of the range (inclusive).\n@@ -136,8 +134,7 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n ///     assert_eq!(arr[1..3], [  1,2  ]);\n /// }\n /// ```\n-#[derive(Clone, PartialEq, Eq, Hash)]\n-// not Copy -- see #27186\n+#[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeFrom<Idx> {\n     /// The lower bound of the range (inclusive).\n@@ -253,16 +250,17 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n ///     assert_eq!(arr[1...2], [  1,2  ]);  // RangeInclusive\n /// }\n /// ```\n-#[derive(Clone, PartialEq, Eq, Hash)]\n-// not Copy -- see #27186\n+#[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n pub struct RangeInclusive<Idx> {\n     /// The lower bound of the range (inclusive).\n-    #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\",\n+    #[unstable(feature = \"inclusive_range\",\n+               reason = \"recently added, follows RFC\",\n                issue = \"28237\")]\n     pub start: Idx,\n     /// The upper bound of the range (inclusive).\n-    #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\",\n+    #[unstable(feature = \"inclusive_range\",\n+               reason = \"recently added, follows RFC\",\n                issue = \"28237\")]\n     pub end: Idx,\n }\n@@ -335,7 +333,8 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n pub struct RangeToInclusive<Idx> {\n     /// The upper bound of the range (inclusive)\n-    #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\",\n+    #[unstable(feature = \"inclusive_range\",\n+               reason = \"recently added, follows RFC\",\n                issue = \"28237\")]\n     pub end: Idx,\n }\n@@ -366,158 +365,3 @@ impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n \n // RangeToInclusive<Idx> cannot impl From<RangeTo<Idx>>\n // because underflow would be possible with (..0).into()\n-\n-/// `RangeArgument` is implemented by Rust's built-in range types, produced\n-/// by range syntax like `..`, `a..`, `..b` or `c..d`.\n-#[stable(feature = \"range_argument\", since = \"1.19.0\")]\n-pub trait RangeArgument<T: ?Sized> {\n-    /// Start index bound.\n-    ///\n-    /// Returns the start value as a `Bound`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::ops::RangeArgument;\n-    /// use std::ops::Bound::*;\n-    ///\n-    /// assert_eq!((..10).start(), Unbounded);\n-    /// assert_eq!((3..10).start(), Included(&3));\n-    /// ```\n-    #[stable(feature = \"range_argument\", since = \"1.19.0\")]\n-    fn start(&self) -> Bound<&T>;\n-\n-    /// End index bound.\n-    ///\n-    /// Returns the end value as a `Bound`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::ops::RangeArgument;\n-    /// use std::ops::Bound::*;\n-    ///\n-    /// assert_eq!((3..).end(), Unbounded);\n-    /// assert_eq!((3..10).end(), Excluded(&10));\n-    /// ```\n-    #[stable(feature = \"range_argument\", since = \"1.19.0\")]\n-    fn end(&self) -> Bound<&T>;\n-}\n-\n-#[stable(feature = \"range_argument\", since = \"1.19.0\")]\n-impl<T: ?Sized> RangeArgument<T> for RangeFull {\n-    fn start(&self) -> Bound<&T> {\n-        Unbounded\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Unbounded\n-    }\n-}\n-\n-#[stable(feature = \"range_argument\", since = \"1.19.0\")]\n-impl<T> RangeArgument<T> for RangeFrom<T> {\n-    fn start(&self) -> Bound<&T> {\n-        Included(&self.start)\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Unbounded\n-    }\n-}\n-\n-#[stable(feature = \"range_argument\", since = \"1.19.0\")]\n-impl<T> RangeArgument<T> for RangeTo<T> {\n-    fn start(&self) -> Bound<&T> {\n-        Unbounded\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Excluded(&self.end)\n-    }\n-}\n-\n-#[stable(feature = \"range_argument\", since = \"1.19.0\")]\n-impl<T> RangeArgument<T> for Range<T> {\n-    fn start(&self) -> Bound<&T> {\n-        Included(&self.start)\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Excluded(&self.end)\n-    }\n-}\n-\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-impl<T> RangeArgument<T> for RangeInclusive<T> {\n-    fn start(&self) -> Bound<&T> {\n-        Included(&self.start)\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Included(&self.end)\n-    }\n-}\n-\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-impl<T> RangeArgument<T> for RangeToInclusive<T> {\n-    fn start(&self) -> Bound<&T> {\n-        Unbounded\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Included(&self.end)\n-    }\n-}\n-\n-#[stable(feature = \"range_argument\", since = \"1.19.0\")]\n-impl<T> RangeArgument<T> for (Bound<T>, Bound<T>) {\n-    fn start(&self) -> Bound<&T> {\n-        match *self {\n-            (Included(ref start), _) => Included(start),\n-            (Excluded(ref start), _) => Excluded(start),\n-            (Unbounded, _) => Unbounded,\n-        }\n-    }\n-\n-    fn end(&self) -> Bound<&T> {\n-        match *self {\n-            (_, Included(ref end)) => Included(end),\n-            (_, Excluded(ref end)) => Excluded(end),\n-            (_, Unbounded) => Unbounded,\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"range_argument\", since = \"1.19.0\")]\n-impl<'a, T: ?Sized + 'a> RangeArgument<T> for (Bound<&'a T>, Bound<&'a T>) {\n-    fn start(&self) -> Bound<&T> {\n-        self.0\n-    }\n-\n-    fn end(&self) -> Bound<&T> {\n-        self.1\n-    }\n-}\n-\n-/// An endpoint of a range of keys.\n-///\n-/// # Examples\n-///\n-/// `Bound`s are range endpoints:\n-///\n-/// ```\n-/// use std::ops::RangeArgument;\n-/// use std::ops::Bound::*;\n-///\n-/// assert_eq!((..100).start(), Unbounded);\n-/// assert_eq!((1..12).start(), Included(&1));\n-/// assert_eq!((1..12).end(), Excluded(&12));\n-/// ```\n-#[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n-#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq)]\n-pub enum Bound<T> {\n-    /// An inclusive bound.\n-    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n-    Included(T),\n-    /// An exclusive bound.\n-    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n-    Excluded(T),\n-    /// An infinite endpoint. Indicates that there is no bound in this direction.\n-    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n-    Unbounded,\n-}"}, {"sha": "c03c2890ba34c6cb4723c3eb00ed514a8bf2e5a5", "filename": "src/librustc_data_structures/accumulate_vec.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Flibrustc_data_structures%2Faccumulate_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Flibrustc_data_structures%2Faccumulate_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Faccumulate_vec.rs?ref=0a9c13624d2fede5c6ce8e5aa7f486403098bde6", "patch": "@@ -15,10 +15,11 @@\n //!\n //! The N above is determined by Array's implementor, by way of an associatated constant.\n \n-use std::ops::{Deref, DerefMut, RangeArgument};\n+use std::ops::{Deref, DerefMut};\n use std::iter::{self, IntoIterator, FromIterator};\n use std::slice;\n use std::vec;\n+use std::collections::range::RangeArgument;\n \n use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n "}, {"sha": "078bb801751d0b2bf4bd54d43a2c4f8944888ed1", "filename": "src/librustc_data_structures/array_vec.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=0a9c13624d2fede5c6ce8e5aa7f486403098bde6", "patch": "@@ -13,12 +13,13 @@\n use std::marker::Unsize;\n use std::iter::Extend;\n use std::ptr::{self, drop_in_place, Shared};\n-use std::ops::{Deref, DerefMut, Range, RangeArgument};\n-use std::ops::Bound::{Excluded, Included, Unbounded};\n+use std::ops::{Deref, DerefMut, Range};\n use std::hash::{Hash, Hasher};\n use std::slice;\n use std::fmt;\n use std::mem;\n+use std::collections::range::RangeArgument;\n+use std::collections::Bound::{Excluded, Included, Unbounded};\n use std::mem::ManuallyDrop;\n \n pub unsafe trait Array {"}, {"sha": "29ac650aa7053110e374dfa6859919913b9cf067", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=0a9c13624d2fede5c6ce8e5aa7f486403098bde6", "patch": "@@ -8,11 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::collections::range::RangeArgument;\n use std::fmt::Debug;\n use std::iter::{self, FromIterator};\n use std::slice;\n use std::marker::PhantomData;\n-use std::ops::{Index, IndexMut, Range, RangeArgument};\n+use std::ops::{Index, IndexMut, Range};\n use std::fmt;\n use std::vec;\n use std::u32;"}, {"sha": "d63b4c9c31b5bc8081c76593cd2e927a4d9de09d", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=0a9c13624d2fede5c6ce8e5aa7f486403098bde6", "patch": "@@ -25,6 +25,7 @@\n #![deny(warnings)]\n \n #![feature(shared)]\n+#![feature(collections_range)]\n #![feature(nonzero)]\n #![feature(unboxed_closures)]\n #![feature(fn_traits)]"}, {"sha": "b8a6a66eaa65d60201d107319749cc7336af40a6", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a9c13624d2fede5c6ce8e5aa7f486403098bde6/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=0a9c13624d2fede5c6ce8e5aa7f486403098bde6", "patch": "@@ -436,8 +436,6 @@ pub use self::hash_map::HashMap;\n pub use self::hash_set::HashSet;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_deprecated(reason = \"moved to std::ops\", since = \"1.19.0\")]\n-#[allow(deprecated)]\n pub use alloc::range;\n \n mod hash;"}]}