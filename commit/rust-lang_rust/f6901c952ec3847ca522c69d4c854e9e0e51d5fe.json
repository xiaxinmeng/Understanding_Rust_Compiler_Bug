{"sha": "f6901c952ec3847ca522c69d4c854e9e0e51d5fe", "node_id": "C_kwDOAAsO6NoAKGY2OTAxYzk1MmVjMzg0N2NhNTIyYzY5ZDRjODU0ZTllMGU1MWQ1ZmU", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-02-24T20:59:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-24T20:59:27Z"}, "message": "Merge #11462\n\n11462: 11422 highlight continue and break r=Veykril a=HansAuger\n\nCloses #11422 \n\nCo-authored-by: Moritz Vetter <mv@3yourmind.com>", "tree": {"sha": "02fb8068534878848e494366548b921dff1335a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02fb8068534878848e494366548b921dff1335a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6901c952ec3847ca522c69d4c854e9e0e51d5fe", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiF/GvCRBK7hj4Ov3rIwAASKkIAJYEbNy0BJ40ZSfWrcKi5trF\nWfDfcm0tZVY+5ZYaEZ9rvPvlzPY8E9Gyt0yJJ+1OhEOWL8oUtKQEeGZy2g8KW0PW\nUu9/D2T2LswL4AnUnP5Iy1G9RJBX/QXUsJx/VOn3LkYjDKug5TZLUMUhYJiDR6XO\n0lZerM8wFOpgQD5TPPLjpz3BeFUd9VK6epvDuMpLbtZHKGC0eVed9PnF7KKWLJPi\nEKf/9UOFcviPmQ4bKPbX8PQSIRjmtE4GHoiyslAZBhc5Drr4hx5BDhZIqPguoB1j\nZtOhXRllwnOETOsgkorDhO0ms1w9HTfgS2SMWufjqgcwJwzkz2GUkV6wh1gTeCM=\n=bluv\n-----END PGP SIGNATURE-----\n", "payload": "tree 02fb8068534878848e494366548b921dff1335a5\nparent 90f7899903238930633b8de620a12e8bfbafa8d7\nparent 71d158b6bab007f56b9f80c56125063a62d06fd4\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1645736367 +0000\ncommitter GitHub <noreply@github.com> 1645736367 +0000\n\nMerge #11462\n\n11462: 11422 highlight continue and break r=Veykril a=HansAuger\n\nCloses #11422 \n\nCo-authored-by: Moritz Vetter <mv@3yourmind.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6901c952ec3847ca522c69d4c854e9e0e51d5fe", "html_url": "https://github.com/rust-lang/rust/commit/f6901c952ec3847ca522c69d4c854e9e0e51d5fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6901c952ec3847ca522c69d4c854e9e0e51d5fe/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90f7899903238930633b8de620a12e8bfbafa8d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/90f7899903238930633b8de620a12e8bfbafa8d7", "html_url": "https://github.com/rust-lang/rust/commit/90f7899903238930633b8de620a12e8bfbafa8d7"}, {"sha": "71d158b6bab007f56b9f80c56125063a62d06fd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/71d158b6bab007f56b9f80c56125063a62d06fd4", "html_url": "https://github.com/rust-lang/rust/commit/71d158b6bab007f56b9f80c56125063a62d06fd4"}], "stats": {"total": 303, "additions": 249, "deletions": 54}, "files": [{"sha": "f886ff7837b4a8e50eea608f6a0a1c95b5d26b02", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 155, "deletions": 18, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/f6901c952ec3847ca522c69d4c854e9e0e51d5fe/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6901c952ec3847ca522c69d4c854e9e0e51d5fe/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=f6901c952ec3847ca522c69d4c854e9e0e51d5fe", "patch": "@@ -2,15 +2,17 @@ use hir::Semantics;\n use ide_db::{\n     base_db::{FileId, FilePosition},\n     defs::{Definition, IdentClass},\n-    helpers::{for_each_break_expr, for_each_tail_expr, node_ext::walk_expr, pick_best_token},\n+    helpers::{\n+        for_each_break_and_continue_expr, for_each_tail_expr, node_ext::walk_expr, pick_best_token,\n+    },\n     search::{FileReference, ReferenceCategory, SearchScope},\n     RootDatabase,\n };\n use rustc_hash::FxHashSet;\n use syntax::{\n     ast::{self, HasLoopBody},\n     match_ast, AstNode,\n-    SyntaxKind::{IDENT, INT_NUMBER},\n+    SyntaxKind::{self, IDENT, INT_NUMBER},\n     SyntaxNode, SyntaxToken, TextRange, T,\n };\n \n@@ -66,7 +68,9 @@ pub(crate) fn highlight_related(\n         T![for] if config.break_points && token.parent().and_then(ast::ForExpr::cast).is_some() => {\n             highlight_break_points(token)\n         }\n-        T![break] | T![loop] | T![while] if config.break_points => highlight_break_points(token),\n+        T![break] | T![loop] | T![while] | T![continue] if config.break_points => {\n+            highlight_break_points(token)\n+        }\n         _ if config.references => highlight_references(sema, &syntax, token, file_id),\n         _ => None,\n     }\n@@ -187,6 +191,7 @@ fn highlight_exit_points(\n \n fn highlight_break_points(token: SyntaxToken) -> Option<Vec<HighlightedRange>> {\n     fn hl(\n+        cursor_token_kind: SyntaxKind,\n         token: Option<SyntaxToken>,\n         label: Option<ast::Label>,\n         body: Option<ast::StmtList>,\n@@ -197,11 +202,23 @@ fn highlight_break_points(token: SyntaxToken) -> Option<Vec<HighlightedRange>> {\n             label.as_ref().map(|it| it.syntax().text_range()),\n         );\n         highlights.extend(range.map(|range| HighlightedRange { category: None, range }));\n-        for_each_break_expr(label, body, &mut |break_| {\n-            let range = cover_range(\n-                break_.break_token().map(|it| it.text_range()),\n-                break_.lifetime().map(|it| it.syntax().text_range()),\n-            );\n+        for_each_break_and_continue_expr(label, body, &mut |expr| {\n+            let range: Option<TextRange> = match (cursor_token_kind, expr) {\n+                (T![for] | T![while] | T![loop] | T![break], ast::Expr::BreakExpr(break_)) => {\n+                    cover_range(\n+                        break_.break_token().map(|it| it.text_range()),\n+                        break_.lifetime().map(|it| it.syntax().text_range()),\n+                    )\n+                }\n+                (\n+                    T![for] | T![while] | T![loop] | T![continue],\n+                    ast::Expr::ContinueExpr(continue_),\n+                ) => cover_range(\n+                    continue_.continue_token().map(|it| it.text_range()),\n+                    continue_.lifetime().map(|it| it.syntax().text_range()),\n+                ),\n+                _ => None,\n+            };\n             highlights.extend(range.map(|range| HighlightedRange { category: None, range }));\n         });\n         Some(highlights)\n@@ -210,6 +227,7 @@ fn highlight_break_points(token: SyntaxToken) -> Option<Vec<HighlightedRange>> {\n     let lbl = match_ast! {\n         match parent {\n             ast::BreakExpr(b) => b.lifetime(),\n+            ast::ContinueExpr(c) => c.lifetime(),\n             ast::LoopExpr(l) => l.label().and_then(|it| it.lifetime()),\n             ast::ForExpr(f) => f.label().and_then(|it| it.lifetime()),\n             ast::WhileExpr(w) => w.label().and_then(|it| it.lifetime()),\n@@ -224,19 +242,29 @@ fn highlight_break_points(token: SyntaxToken) -> Option<Vec<HighlightedRange>> {\n         }\n         None => true,\n     };\n+    let token_kind = token.kind();\n     for anc in token.ancestors().flat_map(ast::Expr::cast) {\n         return match anc {\n-            ast::Expr::LoopExpr(l) if label_matches(l.label()) => {\n-                hl(l.loop_token(), l.label(), l.loop_body().and_then(|it| it.stmt_list()))\n-            }\n-            ast::Expr::ForExpr(f) if label_matches(f.label()) => {\n-                hl(f.for_token(), f.label(), f.loop_body().and_then(|it| it.stmt_list()))\n-            }\n-            ast::Expr::WhileExpr(w) if label_matches(w.label()) => {\n-                hl(w.while_token(), w.label(), w.loop_body().and_then(|it| it.stmt_list()))\n-            }\n+            ast::Expr::LoopExpr(l) if label_matches(l.label()) => hl(\n+                token_kind,\n+                l.loop_token(),\n+                l.label(),\n+                l.loop_body().and_then(|it| it.stmt_list()),\n+            ),\n+            ast::Expr::ForExpr(f) if label_matches(f.label()) => hl(\n+                token_kind,\n+                f.for_token(),\n+                f.label(),\n+                f.loop_body().and_then(|it| it.stmt_list()),\n+            ),\n+            ast::Expr::WhileExpr(w) if label_matches(w.label()) => hl(\n+                token_kind,\n+                w.while_token(),\n+                w.label(),\n+                w.loop_body().and_then(|it| it.stmt_list()),\n+            ),\n             ast::Expr::BlockExpr(e) if e.label().is_some() && label_matches(e.label()) => {\n-                hl(None, e.label(), e.stmt_list())\n+                hl(token_kind, None, e.label(), e.stmt_list())\n             }\n             _ => continue,\n         };\n@@ -804,6 +832,115 @@ fn foo() {\n         );\n     }\n \n+    #[test]\n+    fn test_hl_break_for_but_not_continue() {\n+        check(\n+            r#\"\n+fn foo() {\n+    'outer: for _ in () {\n+ // ^^^^^^^^^^^\n+        break;\n+     // ^^^^^\n+        continue;\n+        'inner: for _ in () {\n+            break;\n+            continue;\n+            'innermost: for _ in () {\n+                continue 'outer;\n+                break 'outer;\n+             // ^^^^^^^^^^^^\n+                continue 'inner;\n+                break 'inner;\n+            }\n+            break$0 'outer;\n+         // ^^^^^^^^^^^^\n+            continue 'outer;\n+            break;\n+            continue;\n+        }\n+        break;\n+     // ^^^^^\n+        continue;\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_continue_for_but_not_break() {\n+        check(\n+            r#\"\n+fn foo() {\n+    'outer: for _ in () {\n+ // ^^^^^^^^^^^\n+        break;\n+        continue;\n+     // ^^^^^^^^\n+        'inner: for _ in () {\n+            break;\n+            continue;\n+            'innermost: for _ in () {\n+                continue 'outer;\n+             // ^^^^^^^^^^^^^^^\n+                break 'outer;\n+                continue 'inner;\n+                break 'inner;\n+            }\n+            break 'outer;\n+            continue$0 'outer;\n+         // ^^^^^^^^^^^^^^^\n+            break;\n+            continue;\n+        }\n+        break;\n+        continue;\n+     // ^^^^^^^^\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_break_and_continue() {\n+        check(\n+            r#\"\n+fn foo() {\n+    'outer: fo$0r _ in () {\n+ // ^^^^^^^^^^^\n+        break;\n+     // ^^^^^\n+        continue;\n+     // ^^^^^^^^\n+        'inner: for _ in () {\n+            break;\n+            continue;\n+            'innermost: for _ in () {\n+                continue 'outer;\n+             // ^^^^^^^^^^^^^^^\n+                break 'outer;\n+             // ^^^^^^^^^^^^\n+                continue 'inner;\n+                break 'inner;\n+            }\n+            break 'outer;\n+         // ^^^^^^^^^^^^\n+            continue 'outer;\n+         // ^^^^^^^^^^^^^^^\n+            break;\n+            continue;\n+        }\n+        break;\n+     // ^^^^^\n+        continue;\n+     // ^^^^^^^^\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_hl_break_while() {\n         check("}, {"sha": "fcad172984831ed1145dd5ffb75f839cbb173132", "filename": "crates/ide_db/src/helpers.rs", "status": "modified", "additions": 90, "deletions": 33, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/f6901c952ec3847ca522c69d4c854e9e0e51d5fe/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6901c952ec3847ca522c69d4c854e9e0e51d5fe/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers.rs?ref=f6901c952ec3847ca522c69d4c854e9e0e51d5fe", "patch": "@@ -16,7 +16,8 @@ use hir::{ItemInNs, MacroDef, ModuleDef, Name, Semantics};\n use itertools::Itertools;\n use syntax::{\n     ast::{self, make, HasLoopBody},\n-    AstNode, AstToken, SyntaxKind, SyntaxToken, TokenAtOffset, WalkEvent, T,\n+    AstNode, AstToken, Preorder, RustLanguage, SyntaxKind, SyntaxToken, TokenAtOffset, WalkEvent,\n+    T,\n };\n \n use crate::{defs::Definition, RootDatabase};\n@@ -190,46 +191,102 @@ pub fn for_each_tail_expr(expr: &ast::Expr, cb: &mut dyn FnMut(&ast::Expr)) {\n     }\n }\n \n-/// Calls `cb` on each break expr inside of `body` that is applicable for the given label.\n-pub fn for_each_break_expr(\n+pub fn for_each_break_and_continue_expr(\n+    label: Option<ast::Label>,\n+    body: Option<ast::StmtList>,\n+    cb: &mut dyn FnMut(ast::Expr),\n+) {\n+    let label = label.and_then(|lbl| lbl.lifetime());\n+    if let Some(b) = body {\n+        let tree_depth_iterator = TreeWithDepthIterator::new(b);\n+        for (expr, depth) in tree_depth_iterator {\n+            match expr {\n+                ast::Expr::BreakExpr(b)\n+                    if (depth == 0 && b.lifetime().is_none())\n+                        || eq_label_lt(&label, &b.lifetime()) =>\n+                {\n+                    cb(ast::Expr::BreakExpr(b));\n+                }\n+                ast::Expr::ContinueExpr(c)\n+                    if (depth == 0 && c.lifetime().is_none())\n+                        || eq_label_lt(&label, &c.lifetime()) =>\n+                {\n+                    cb(ast::Expr::ContinueExpr(c));\n+                }\n+                _ => (),\n+            }\n+        }\n+    }\n+}\n+\n+fn for_each_break_expr(\n     label: Option<ast::Label>,\n     body: Option<ast::StmtList>,\n     cb: &mut dyn FnMut(ast::BreakExpr),\n ) {\n     let label = label.and_then(|lbl| lbl.lifetime());\n-    let mut depth = 0;\n     if let Some(b) = body {\n-        let preorder = &mut b.syntax().preorder();\n-        let ev_as_expr = |ev| match ev {\n-            WalkEvent::Enter(it) => Some(WalkEvent::Enter(ast::Expr::cast(it)?)),\n-            WalkEvent::Leave(it) => Some(WalkEvent::Leave(ast::Expr::cast(it)?)),\n-        };\n-        let eq_label = |lt: Option<ast::Lifetime>| {\n-            lt.zip(label.as_ref()).map_or(false, |(lt, lbl)| lt.text() == lbl.text())\n-        };\n-        while let Some(node) = preorder.find_map(ev_as_expr) {\n-            match node {\n-                WalkEvent::Enter(expr) => match expr {\n-                    ast::Expr::LoopExpr(_) | ast::Expr::WhileExpr(_) | ast::Expr::ForExpr(_) => {\n-                        depth += 1\n-                    }\n-                    ast::Expr::BlockExpr(e) if e.label().is_some() => depth += 1,\n-                    ast::Expr::BreakExpr(b)\n-                        if (depth == 0 && b.lifetime().is_none()) || eq_label(b.lifetime()) =>\n-                    {\n-                        cb(b);\n-                    }\n-                    _ => (),\n-                },\n-                WalkEvent::Leave(expr) => match expr {\n-                    ast::Expr::LoopExpr(_) | ast::Expr::WhileExpr(_) | ast::Expr::ForExpr(_) => {\n-                        depth -= 1\n-                    }\n-                    ast::Expr::BlockExpr(e) if e.label().is_some() => depth -= 1,\n-                    _ => (),\n-                },\n+        let tree_depth_iterator = TreeWithDepthIterator::new(b);\n+        for (expr, depth) in tree_depth_iterator {\n+            match expr {\n+                ast::Expr::BreakExpr(b)\n+                    if (depth == 0 && b.lifetime().is_none())\n+                        || eq_label_lt(&label, &b.lifetime()) =>\n+                {\n+                    cb(b);\n+                }\n+                _ => (),\n+            }\n+        }\n+    }\n+}\n+\n+fn eq_label_lt(lt1: &Option<ast::Lifetime>, lt2: &Option<ast::Lifetime>) -> bool {\n+    lt1.as_ref().zip(lt2.as_ref()).map_or(false, |(lt, lbl)| lt.text() == lbl.text())\n+}\n+\n+struct TreeWithDepthIterator {\n+    preorder: Preorder<RustLanguage>,\n+    depth: u32,\n+}\n+\n+impl TreeWithDepthIterator {\n+    fn new(body: ast::StmtList) -> Self {\n+        let preorder = body.syntax().preorder();\n+        Self { preorder, depth: 0 }\n+    }\n+}\n+\n+impl<'a> Iterator for TreeWithDepthIterator {\n+    type Item = (ast::Expr, u32);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        while let Some(event) = self.preorder.find_map(|ev| match ev {\n+            WalkEvent::Enter(it) => ast::Expr::cast(it).map(WalkEvent::Enter),\n+            WalkEvent::Leave(it) => ast::Expr::cast(it).map(WalkEvent::Leave),\n+        }) {\n+            match event {\n+                WalkEvent::Enter(\n+                    ast::Expr::LoopExpr(_) | ast::Expr::WhileExpr(_) | ast::Expr::ForExpr(_),\n+                ) => {\n+                    self.depth += 1;\n+                }\n+                WalkEvent::Leave(\n+                    ast::Expr::LoopExpr(_) | ast::Expr::WhileExpr(_) | ast::Expr::ForExpr(_),\n+                ) => {\n+                    self.depth -= 1;\n+                }\n+                WalkEvent::Enter(ast::Expr::BlockExpr(e)) if e.label().is_some() => {\n+                    self.depth += 1;\n+                }\n+                WalkEvent::Leave(ast::Expr::BlockExpr(e)) if e.label().is_some() => {\n+                    self.depth -= 1;\n+                }\n+                WalkEvent::Enter(expr) => return Some((expr, self.depth)),\n+                _ => (),\n             }\n         }\n+        None\n     }\n }\n "}, {"sha": "e30f6cd79c3edadd5fb31eb86216c8b7932a3912", "filename": "crates/syntax/src/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f6901c952ec3847ca522c69d4c854e9e0e51d5fe/crates%2Fsyntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6901c952ec3847ca522c69d4c854e9e0e51d5fe/crates%2Fsyntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Flib.rs?ref=f6901c952ec3847ca522c69d4c854e9e0e51d5fe", "patch": "@@ -52,14 +52,15 @@ pub use crate::{\n     ptr::{AstPtr, SyntaxNodePtr},\n     syntax_error::SyntaxError,\n     syntax_node::{\n-        PreorderWithTokens, SyntaxElement, SyntaxElementChildren, SyntaxNode, SyntaxNodeChildren,\n-        SyntaxToken, SyntaxTreeBuilder,\n+        PreorderWithTokens, RustLanguage, SyntaxElement, SyntaxElementChildren, SyntaxNode,\n+        SyntaxNodeChildren, SyntaxToken, SyntaxTreeBuilder,\n     },\n     token_text::TokenText,\n };\n pub use parser::{SyntaxKind, T};\n pub use rowan::{\n-    Direction, GreenNode, NodeOrToken, SyntaxText, TextRange, TextSize, TokenAtOffset, WalkEvent,\n+    api::Preorder, Direction, GreenNode, NodeOrToken, SyntaxText, TextRange, TextSize,\n+    TokenAtOffset, WalkEvent,\n };\n pub use smol_str::SmolStr;\n "}]}