{"sha": "29a2d6b50536cee777ca5454b5f9bd1a58b5fc17", "node_id": "C_kwDOAAsO6NoAKDI5YTJkNmI1MDUzNmNlZTc3N2NhNTQ1NGI1ZjliZDFhNThiNWZjMTc", "commit": {"author": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2022-01-08T22:48:25Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2022-01-19T00:05:12Z"}, "message": "intra-doc: Use the impl's assoc item where possible\n\nBefore, the trait's associated item would be used. Now, the impl's\nassociated item is used. The only exception is for impls that use\ndefault values for associated items set by the trait. In that case,\nthe trait's associated item is still used.\n\nAs an example of the old and new behavior, take this code:\n\n    trait MyTrait {\n        type AssocTy;\n    }\n\n    impl MyTrait for String {\n        type AssocTy = u8;\n    }\n\nBefore, when resolving a link to `String::AssocTy`,\n`resolve_associated_trait_item` would return the associated item for\n`MyTrait::AssocTy`. Now, it would return the associated item for\n`<String as MyTrait>::AssocTy`, as it claims in its docs.", "tree": {"sha": "c8c5861fe5c34f9fc0f498cb92178868758b3a68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8c5861fe5c34f9fc0f498cb92178868758b3a68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29a2d6b50536cee777ca5454b5f9bd1a58b5fc17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29a2d6b50536cee777ca5454b5f9bd1a58b5fc17", "html_url": "https://github.com/rust-lang/rust/commit/29a2d6b50536cee777ca5454b5f9bd1a58b5fc17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29a2d6b50536cee777ca5454b5f9bd1a58b5fc17/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "html_url": "https://github.com/rust-lang/rust/commit/9ad5d82f822b3cb67637f11be2e65c5662b66ec0"}], "stats": {"total": 88, "additions": 53, "deletions": 35}, "files": [{"sha": "7dbf00420de126c3eec76c09640a3e5ffb766092", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 53, "deletions": 35, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/29a2d6b50536cee777ca5454b5f9bd1a58b5fc17/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a2d6b50536cee777ca5454b5f9bd1a58b5fc17/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=29a2d6b50536cee777ca5454b5f9bd1a58b5fc17", "patch": "@@ -305,16 +305,15 @@ crate enum FragmentKind {\n \n impl ItemFragment {\n     /// Create a fragment for an associated item.\n-    ///\n-    /// `is_prototype` is whether this associated item is a trait method\n-    /// without a default definition.\n-    fn from_assoc_item(def_id: DefId, kind: ty::AssocKind, is_prototype: bool) -> Self {\n-        match kind {\n+    #[instrument(level = \"debug\")]\n+    fn from_assoc_item(item: &ty::AssocItem) -> Self {\n+        let def_id = item.def_id;\n+        match item.kind {\n             ty::AssocKind::Fn => {\n-                if is_prototype {\n-                    ItemFragment(FragmentKind::TyMethod, def_id)\n-                } else {\n+                if item.defaultness.has_value() {\n                     ItemFragment(FragmentKind::Method, def_id)\n+                } else {\n+                    ItemFragment(FragmentKind::TyMethod, def_id)\n                 }\n             }\n             ty::AssocKind::Const => ItemFragment(FragmentKind::AssociatedConstant, def_id),\n@@ -473,8 +472,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             tcx.associated_items(impl_)\n                 .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, impl_)\n                 .map(|item| {\n-                    let kind = item.kind;\n-                    let fragment = ItemFragment::from_assoc_item(item.def_id, kind, false);\n+                    let fragment = ItemFragment::from_assoc_item(item);\n                     (Res::Primitive(prim_ty), fragment)\n                 })\n         })\n@@ -726,8 +724,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         .flatten();\n \n                     assoc_item.map(|item| {\n-                        let kind = item.kind;\n-                        let fragment = ItemFragment::from_assoc_item(item.def_id, kind, false);\n+                        let fragment = ItemFragment::from_assoc_item(&item);\n                         (root_res, fragment)\n                     })\n                 })\n@@ -765,20 +762,19 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     // To handle that properly resolve() would have to support\n                     // something like [`ambi_fn`](<SomeStruct as SomeTrait>::ambi_fn)\n                     .or_else(|| {\n-                        let item = resolve_associated_trait_item(\n+                        resolve_associated_trait_item(\n                             tcx.type_of(did),\n                             module_id,\n                             item_name,\n                             ns,\n                             self.cx,\n-                        );\n-                        debug!(\"got associated item {:?}\", item);\n-                        item\n+                        )\n                     });\n \n+                debug!(\"got associated item {:?}\", assoc_item);\n+\n                 if let Some(item) = assoc_item {\n-                    let kind = item.kind;\n-                    let fragment = ItemFragment::from_assoc_item(item.def_id, kind, false);\n+                    let fragment = ItemFragment::from_assoc_item(&item);\n                     return Some((root_res, fragment));\n                 }\n \n@@ -813,11 +809,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 .associated_items(did)\n                 .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, did)\n                 .map(|item| {\n-                    let fragment = ItemFragment::from_assoc_item(\n-                        item.def_id,\n-                        item.kind,\n-                        !item.defaultness.has_value(),\n-                    );\n+                    let fragment = ItemFragment::from_assoc_item(item);\n                     let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n                     (res, fragment)\n                 }),\n@@ -883,30 +875,56 @@ fn resolve_associated_trait_item<'a>(\n \n     // Next consider explicit impls: `impl MyTrait for MyType`\n     // Give precedence to inherent impls.\n-    let traits = traits_implemented_by(cx, ty, module);\n+    let traits = trait_impls_for(cx, ty, module);\n     debug!(\"considering traits {:?}\", traits);\n-    let mut candidates = traits.iter().filter_map(|&trait_| {\n-        cx.tcx.associated_items(trait_).find_by_name_and_namespace(\n-            cx.tcx,\n-            Ident::with_dummy_span(item_name),\n-            ns,\n-            trait_,\n-        )\n+    let mut candidates = traits.iter().filter_map(|&(impl_, trait_)| {\n+        cx.tcx\n+            .associated_items(trait_)\n+            .find_by_name_and_namespace(cx.tcx, Ident::with_dummy_span(item_name), ns, trait_)\n+            .map(|trait_assoc| {\n+                trait_assoc_to_impl_assoc_item(cx.tcx, impl_, trait_assoc.def_id)\n+                    .unwrap_or(trait_assoc)\n+            })\n     });\n     // FIXME(#74563): warn about ambiguity\n     debug!(\"the candidates were {:?}\", candidates.clone().collect::<Vec<_>>());\n     candidates.next().copied()\n }\n \n-/// Given a type, return all traits in scope in `module` implemented by that type.\n+/// Find the associated item in the impl `impl_id` that corresponds to the\n+/// trait associated item `trait_assoc_id`.\n+///\n+/// This function returns `None` if no associated item was found in the impl.\n+/// This can occur when the trait associated item has a default value that is\n+/// not overriden in the impl.\n+///\n+/// This is just a wrapper around [`TyCtxt::impl_item_implementor_ids()`] and\n+/// [`TyCtxt::associated_item()`] (with some helpful logging added).\n+#[instrument(level = \"debug\", skip(tcx))]\n+fn trait_assoc_to_impl_assoc_item<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    impl_id: DefId,\n+    trait_assoc_id: DefId,\n+) -> Option<&'tcx ty::AssocItem> {\n+    let trait_to_impl_assoc_map = tcx.impl_item_implementor_ids(impl_id);\n+    debug!(?trait_to_impl_assoc_map);\n+    let impl_assoc_id = *trait_to_impl_assoc_map.get(&trait_assoc_id)?;\n+    debug!(?impl_assoc_id);\n+    let impl_assoc = tcx.associated_item(impl_assoc_id);\n+    debug!(?impl_assoc);\n+    Some(impl_assoc)\n+}\n+\n+/// Given a type, return all trait impls in scope in `module` for that type.\n+/// Returns a set of pairs of `(impl_id, trait_id)`.\n ///\n /// NOTE: this cannot be a query because more traits could be available when more crates are compiled!\n /// So it is not stable to serialize cross-crate.\n-fn traits_implemented_by<'a>(\n+fn trait_impls_for<'a>(\n     cx: &mut DocContext<'a>,\n     ty: Ty<'a>,\n     module: DefId,\n-) -> FxHashSet<DefId> {\n+) -> FxHashSet<(DefId, DefId)> {\n     let mut resolver = cx.resolver.borrow_mut();\n     let in_scope_traits = cx.module_trait_cache.entry(module).or_insert_with(|| {\n         resolver.access(|resolver| {\n@@ -948,7 +966,7 @@ fn traits_implemented_by<'a>(\n                     _ => false,\n                 };\n \n-            if saw_impl { Some(trait_) } else { None }\n+            if saw_impl { Some((impl_, trait_)) } else { None }\n         })\n     });\n     iter.collect()"}]}