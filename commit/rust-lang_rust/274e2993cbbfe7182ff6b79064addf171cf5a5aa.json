{"sha": "274e2993cbbfe7182ff6b79064addf171cf5a5aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3NGUyOTkzY2JiZmU3MTgyZmY2Yjc5MDY0YWRkZjE3MWNmNWE1YWE=", "commit": {"author": {"name": "Ian Jackson", "email": "ijackson@chiark.greenend.org.uk", "date": "2020-10-12T14:52:46Z"}, "committer": {"name": "Ian Jackson", "email": "ijackson@chiark.greenend.org.uk", "date": "2020-12-27T00:50:46Z"}, "message": "Stablize slice::strip_prefix and strip_suffix, with SlicePattern\n\nWe hope later to extend `core::str::Pattern` to slices too, perhaps as\npart of stabilising that.  We want to minimise the amount of type\ninference breakage when we do that, so we don't want to stabilise\nstrip_prefix and strip_suffix taking a simple `&[T]`.\n\n@KodrAus suggested the approach of introducing a new perma-unstable\ntrait, which reduces this future inference break risk.\n\nI found it necessary to make two impls of this trait, as the unsize\ncoercion don't apply when hunting for trait implementations.\n\nSince SlicePattern's only method returns a reference, and the whole\ntrait is just a wrapper for slices, I made the trait type be the\nnon-reference type [T] or [T;N] rather than the reference.  Otherwise\nthe trait would have a lifetime parameter.\n\nI marked both the no-op conversion functions `#[inline]`.  I'm not\nsure if that is necessary but it seemed at the very least harmless.\n\nSigned-off-by: Ian Jackson <ijackson@chiark.greenend.org.uk>", "tree": {"sha": "f042c71f96fa3b3f8f337642b08c437cd04265bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f042c71f96fa3b3f8f337642b08c437cd04265bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/274e2993cbbfe7182ff6b79064addf171cf5a5aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/274e2993cbbfe7182ff6b79064addf171cf5a5aa", "html_url": "https://github.com/rust-lang/rust/commit/274e2993cbbfe7182ff6b79064addf171cf5a5aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/274e2993cbbfe7182ff6b79064addf171cf5a5aa/comments", "author": {"login": "ijackson", "id": 2090772, "node_id": "MDQ6VXNlcjIwOTA3NzI=", "avatar_url": "https://avatars.githubusercontent.com/u/2090772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ijackson", "html_url": "https://github.com/ijackson", "followers_url": "https://api.github.com/users/ijackson/followers", "following_url": "https://api.github.com/users/ijackson/following{/other_user}", "gists_url": "https://api.github.com/users/ijackson/gists{/gist_id}", "starred_url": "https://api.github.com/users/ijackson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ijackson/subscriptions", "organizations_url": "https://api.github.com/users/ijackson/orgs", "repos_url": "https://api.github.com/users/ijackson/repos", "events_url": "https://api.github.com/users/ijackson/events{/privacy}", "received_events_url": "https://api.github.com/users/ijackson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ijackson", "id": 2090772, "node_id": "MDQ6VXNlcjIwOTA3NzI=", "avatar_url": "https://avatars.githubusercontent.com/u/2090772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ijackson", "html_url": "https://github.com/ijackson", "followers_url": "https://api.github.com/users/ijackson/followers", "following_url": "https://api.github.com/users/ijackson/following{/other_user}", "gists_url": "https://api.github.com/users/ijackson/gists{/gist_id}", "starred_url": "https://api.github.com/users/ijackson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ijackson/subscriptions", "organizations_url": "https://api.github.com/users/ijackson/orgs", "repos_url": "https://api.github.com/users/ijackson/repos", "events_url": "https://api.github.com/users/ijackson/events{/privacy}", "received_events_url": "https://api.github.com/users/ijackson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b644e419681835bd0f5871c3bfbd648aa04f157", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b644e419681835bd0f5871c3bfbd648aa04f157", "html_url": "https://github.com/rust-lang/rust/commit/0b644e419681835bd0f5871c3bfbd648aa04f157"}], "stats": {"total": 49, "additions": 41, "deletions": 8}, "files": [{"sha": "0556bb1e633db05f38441d8d3128c431611bf3e1", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 41, "deletions": 7, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/274e2993cbbfe7182ff6b79064addf171cf5a5aa/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/274e2993cbbfe7182ff6b79064addf171cf5a5aa/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=274e2993cbbfe7182ff6b79064addf171cf5a5aa", "patch": "@@ -1778,20 +1778,21 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(slice_strip)]\n     /// let v = &[10, 40, 30];\n     /// assert_eq!(v.strip_prefix(&[10]), Some(&[40, 30][..]));\n     /// assert_eq!(v.strip_prefix(&[10, 40]), Some(&[30][..]));\n     /// assert_eq!(v.strip_prefix(&[50]), None);\n     /// assert_eq!(v.strip_prefix(&[10, 50]), None);\n     /// ```\n     #[must_use = \"returns the subslice without modifying the original\"]\n-    #[unstable(feature = \"slice_strip\", issue = \"73413\")]\n-    pub fn strip_prefix(&self, prefix: &[T]) -> Option<&[T]>\n+    #[stable(feature = \"slice_strip\", since = \"1.50.0\")]\n+    pub fn strip_prefix<P: SlicePattern<Item = T>>(&self, prefix: &P) -> Option<&[T]>\n     where\n         T: PartialEq,\n     {\n-        let n = prefix.len();\n+        // This function will need rewriting if and when SlicePattern becomes more sophisticated.\n+        let prefix = prefix.as_slice();\n+        let n = prefix.as_slice().len();\n         if n <= self.len() {\n             let (head, tail) = self.split_at(n);\n             if head == prefix {\n@@ -1811,19 +1812,20 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(slice_strip)]\n     /// let v = &[10, 40, 30];\n     /// assert_eq!(v.strip_suffix(&[30]), Some(&[10, 40][..]));\n     /// assert_eq!(v.strip_suffix(&[40, 30]), Some(&[10][..]));\n     /// assert_eq!(v.strip_suffix(&[50]), None);\n     /// assert_eq!(v.strip_suffix(&[50, 30]), None);\n     /// ```\n     #[must_use = \"returns the subslice without modifying the original\"]\n-    #[unstable(feature = \"slice_strip\", issue = \"73413\")]\n-    pub fn strip_suffix(&self, suffix: &[T]) -> Option<&[T]>\n+    #[stable(feature = \"slice_strip\", since = \"1.50.0\")]\n+    pub fn strip_suffix<P: SlicePattern<Item = T>>(&self, suffix: &P) -> Option<&[T]>\n     where\n         T: PartialEq,\n     {\n+        // This function will need rewriting if and when SlicePattern becomes more sophisticated.\n+        let suffix = suffix.as_slice();\n         let (len, n) = (self.len(), suffix.len());\n         if n <= len {\n             let (head, tail) = self.split_at(len - n);\n@@ -3216,3 +3218,35 @@ impl<T> Default for &mut [T] {\n         &mut []\n     }\n }\n+\n+#[unstable(feature = \"x\", issue = \"none\")]\n+/// Patterns in slices - currently, only used by `strip_prefix` and `strip_suffix`.  At a future\n+/// point, we hope to generalise `core::str::Pattern` (which at the time of writing is limited to\n+/// `str`) to slices, and then this trait will be replaced or abolished.\n+pub trait SlicePattern {\n+    /// The element type of the slice being matched on.\n+    type Item;\n+\n+    /// Currently, the consumers of `SlicePattern` need a slice.\n+    fn as_slice(&self) -> &[Self::Item];\n+}\n+\n+#[stable(feature = \"slice_strip\", since = \"1.50.0\")]\n+impl<T> SlicePattern for [T] {\n+    type Item = T;\n+\n+    #[inline]\n+    fn as_slice(&self) -> &[Self::Item] {\n+        self\n+    }\n+}\n+\n+#[stable(feature = \"slice_strip\", since = \"1.50.0\")]\n+impl<T, const N: usize> SlicePattern for [T; N] {\n+    type Item = T;\n+\n+    #[inline]\n+    fn as_slice(&self) -> &[Self::Item] {\n+        self\n+    }\n+}"}, {"sha": "6c3c2fd53d8ca2ee621e1a7468f4f46f39f863b2", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/274e2993cbbfe7182ff6b79064addf171cf5a5aa/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/274e2993cbbfe7182ff6b79064addf171cf5a5aa/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=274e2993cbbfe7182ff6b79064addf171cf5a5aa", "patch": "@@ -307,7 +307,6 @@\n #![feature(slice_internals)]\n #![feature(slice_ptr_get)]\n #![feature(slice_ptr_len)]\n-#![feature(slice_strip)]\n #![feature(staged_api)]\n #![feature(std_internals)]\n #![feature(stdsimd)]"}]}