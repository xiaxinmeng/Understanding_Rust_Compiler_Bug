{"sha": "37275b6fc3635291d19331974e361c1ccd02a467", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3Mjc1YjZmYzM2MzUyOTFkMTkzMzE5NzRlMzYxYzFjY2QwMmE0Njc=", "commit": {"author": {"name": "lukaramu", "email": "lukaramu@gmail.com", "date": "2017-04-06T21:39:32Z"}, "committer": {"name": "lukaramu", "email": "lukaramu@gmail.com", "date": "2017-04-06T21:39:32Z"}, "message": "improved std::hash::Hash docs\n\nPart of #29357.\n* merged \"Derivable\" and \"How can I implement `Hash`?\" sections into one\n  \"Implementing `Hash`\" section to aid coherency\n* added an example for `#[derive(Hash)]`\n* moved part about relation between `Hash` and `Eq` into a new \"`Hash` and\n  `Eq`\" section; changed wording to be more consistent with `HashMap` and\n  `HashSet`'s\n* explicitly mentioned `#[derive(PartialEq, Eq, Hash)]` in the new section\n* changed method summaries for consistency, adding links and examples", "tree": {"sha": "040c52ddae40179c18b8fa2bee3ff8c960666577", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/040c52ddae40179c18b8fa2bee3ff8c960666577"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37275b6fc3635291d19331974e361c1ccd02a467", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37275b6fc3635291d19331974e361c1ccd02a467", "html_url": "https://github.com/rust-lang/rust/commit/37275b6fc3635291d19331974e361c1ccd02a467", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37275b6fc3635291d19331974e361c1ccd02a467/comments", "author": {"login": "chordowl", "id": 3811822, "node_id": "MDQ6VXNlcjM4MTE4MjI=", "avatar_url": "https://avatars.githubusercontent.com/u/3811822?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chordowl", "html_url": "https://github.com/chordowl", "followers_url": "https://api.github.com/users/chordowl/followers", "following_url": "https://api.github.com/users/chordowl/following{/other_user}", "gists_url": "https://api.github.com/users/chordowl/gists{/gist_id}", "starred_url": "https://api.github.com/users/chordowl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chordowl/subscriptions", "organizations_url": "https://api.github.com/users/chordowl/orgs", "repos_url": "https://api.github.com/users/chordowl/repos", "events_url": "https://api.github.com/users/chordowl/events{/privacy}", "received_events_url": "https://api.github.com/users/chordowl/received_events", "type": "User", "site_admin": false}, "committer": {"login": "chordowl", "id": 3811822, "node_id": "MDQ6VXNlcjM4MTE4MjI=", "avatar_url": "https://avatars.githubusercontent.com/u/3811822?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chordowl", "html_url": "https://github.com/chordowl", "followers_url": "https://api.github.com/users/chordowl/followers", "following_url": "https://api.github.com/users/chordowl/following{/other_user}", "gists_url": "https://api.github.com/users/chordowl/gists{/gist_id}", "starred_url": "https://api.github.com/users/chordowl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chordowl/subscriptions", "organizations_url": "https://api.github.com/users/chordowl/orgs", "repos_url": "https://api.github.com/users/chordowl/repos", "events_url": "https://api.github.com/users/chordowl/events{/privacy}", "received_events_url": "https://api.github.com/users/chordowl/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e88a511fd50276b2d88edf9a7a7bbf6a89ca9f68", "url": "https://api.github.com/repos/rust-lang/rust/commits/e88a511fd50276b2d88edf9a7a7bbf6a89ca9f68", "html_url": "https://github.com/rust-lang/rust/commit/e88a511fd50276b2d88edf9a7a7bbf6a89ca9f68"}], "stats": {"total": 83, "additions": 61, "deletions": 22}, "files": [{"sha": "130a75a7027ac1e21d79d8c4ffe63e815a4ed648", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 61, "deletions": 22, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/37275b6fc3635291d19331974e361c1ccd02a467/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37275b6fc3635291d19331974e361c1ccd02a467/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=37275b6fc3635291d19331974e361c1ccd02a467", "patch": "@@ -107,29 +107,25 @@ mod sip;\n \n /// A hashable type.\n ///\n-/// The `H` type parameter is an abstract hash state that is used by the `Hash`\n-/// to compute the hash.\n+/// Types implementing `Hash` are able to be [`hash`]ed with an instance of\n+/// [`Hasher`].\n ///\n-/// If you are also implementing [`Eq`], there is an additional property that\n-/// is important:\n+/// ## Implementing `Hash`\n ///\n-/// ```text\n-/// k1 == k2 -> hash(k1) == hash(k2)\n-/// ```\n-///\n-/// In other words, if two keys are equal, their hashes should also be equal.\n-/// [`HashMap`] and [`HashSet`] both rely on this behavior.\n+/// You can derive `Hash` with `#[derive(Hash)]` if all fields implement `Hash`.\n+/// The resulting hash will be the combination of the values from calling\n+/// [`hash`] on each field.\n ///\n-/// ## Derivable\n-///\n-/// This trait can be used with `#[derive]` if all fields implement `Hash`.\n-/// When `derive`d, the resulting hash will be the combination of the values\n-/// from calling [`.hash`] on each field.\n-///\n-/// ## How can I implement `Hash`?\n+/// ```\n+/// #[derive(Hash)]\n+/// struct Rustacean {\n+///    name: String,\n+///    country: String,\n+/// }\n+/// ```\n ///\n-/// If you need more control over how a value is hashed, you need to implement\n-/// the `Hash` trait:\n+/// If you need more control over how a value is hash, you can of course\n+/// implement the `Hash` trait yourself:\n ///\n /// ```\n /// use std::hash::{Hash, Hasher};\n@@ -148,17 +144,60 @@ mod sip;\n /// }\n /// ```\n ///\n+/// ## `Hash` and `Eq`\n+///\n+/// When implementing both `Hash` and [`Eq`], it is important that the following\n+/// property holds:\n+///\n+/// ```text\n+/// k1 == k2 -> hash(k1) == hash(k2)\n+/// ```\n+///\n+/// In other words, if two keys are equal, their hashes must also be equal.\n+/// [`HashMap`] and [`HashSet`] both rely on this behavior.\n+///\n+/// Thankfully, you won't need to worry about upholding this property when\n+/// deriving both [`Eq`] and `Hash` with `#[derive(PartialEq, Eq, Hash)]`.\n+///\n /// [`Eq`]: ../../std/cmp/trait.Eq.html\n+/// [`Hasher`]: trait.Hasher.html\n /// [`HashMap`]: ../../std/collections/struct.HashMap.html\n /// [`HashSet`]: ../../std/collections/struct.HashSet.html\n-/// [`.hash`]: #tymethod.hash\n+/// [`hash`]: #tymethod.hash\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Hash {\n-    /// Feeds this value into the state given, updating the hasher as necessary.\n+    /// Feeds this value into the given [`Hasher`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::hash_map::DefaultHasher;\n+    /// use std::hash::{Hash, Hasher};\n+    ///\n+    /// let mut hasher = DefaultHasher::new();\n+    /// 7920.hash(&mut hasher);\n+    /// println!(\"Hash is {:x}!\", hasher.finish());\n+    /// ```\n+    ///\n+    /// [`Hasher`]: trait.Hasher.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn hash<H: Hasher>(&self, state: &mut H);\n \n-    /// Feeds a slice of this type into the state provided.\n+    /// Feeds a slice of this type into the given [`Hasher`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::hash_map::DefaultHasher;\n+    /// use std::hash::{Hash, Hasher};\n+    ///\n+    /// let mut hasher = DefaultHasher::new();\n+    /// let numbers = [6, 28, 496, 8128];\n+    /// Hash::hash_slice(&numbers, &mut hasher);\n+    /// println!(\"Hash is {:x}!\", hasher.finish());\n+    /// ```\n+    ///\n+    /// [`Hasher`]: trait.Hasher.html\n     #[stable(feature = \"hash_slice\", since = \"1.3.0\")]\n     fn hash_slice<H: Hasher>(data: &[Self], state: &mut H)\n         where Self: Sized"}]}