{"sha": "4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0ODY3OTVkMDJiZmYzYmQ0ZWY0MzI3YTNkZmUzYzVjNWY4N2Y4YWM=", "commit": {"author": {"name": "Charles Lew", "email": "crlf0710@gmail.com", "date": "2021-07-18T07:35:37Z"}, "committer": {"name": "Charles Lew", "email": "crlf0710@gmail.com", "date": "2021-07-18T14:00:41Z"}, "message": "Remove unused stuff and switch to pub(crate) whenever possible.", "tree": {"sha": "68c1909a8ed84e390868dc8ddb93e3de701ec766", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68c1909a8ed84e390868dc8ddb93e3de701ec766"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac", "html_url": "https://github.com/rust-lang/rust/commit/4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac/comments", "author": {"login": "crlf0710", "id": 451806, "node_id": "MDQ6VXNlcjQ1MTgwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/451806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crlf0710", "html_url": "https://github.com/crlf0710", "followers_url": "https://api.github.com/users/crlf0710/followers", "following_url": "https://api.github.com/users/crlf0710/following{/other_user}", "gists_url": "https://api.github.com/users/crlf0710/gists{/gist_id}", "starred_url": "https://api.github.com/users/crlf0710/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crlf0710/subscriptions", "organizations_url": "https://api.github.com/users/crlf0710/orgs", "repos_url": "https://api.github.com/users/crlf0710/repos", "events_url": "https://api.github.com/users/crlf0710/events{/privacy}", "received_events_url": "https://api.github.com/users/crlf0710/received_events", "type": "User", "site_admin": false}, "committer": {"login": "crlf0710", "id": 451806, "node_id": "MDQ6VXNlcjQ1MTgwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/451806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crlf0710", "html_url": "https://github.com/crlf0710", "followers_url": "https://api.github.com/users/crlf0710/followers", "following_url": "https://api.github.com/users/crlf0710/following{/other_user}", "gists_url": "https://api.github.com/users/crlf0710/gists{/gist_id}", "starred_url": "https://api.github.com/users/crlf0710/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crlf0710/subscriptions", "organizations_url": "https://api.github.com/users/crlf0710/orgs", "repos_url": "https://api.github.com/users/crlf0710/repos", "events_url": "https://api.github.com/users/crlf0710/events{/privacy}", "received_events_url": "https://api.github.com/users/crlf0710/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "950f569c91d17fa162a3a3fcb63ff0eb8626bc14", "url": "https://api.github.com/repos/rust-lang/rust/commits/950f569c91d17fa162a3a3fcb63ff0eb8626bc14", "html_url": "https://github.com/rust-lang/rust/commit/950f569c91d17fa162a3a3fcb63ff0eb8626bc14"}], "stats": {"total": 357, "additions": 58, "deletions": 299}, "files": [{"sha": "b256ab7b8f82872942e11bb81d7894eb3a8323a6", "filename": "library/test/src/term.rs", "status": "modified", "additions": 19, "deletions": 108, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac/library%2Ftest%2Fsrc%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac/library%2Ftest%2Fsrc%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fterm.rs?ref=4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac", "patch": "@@ -6,123 +6,62 @@\n //! a [terminfo][ti] database, and `WinConsole`, which uses the [Win32 Console\n //! API][win].\n //!\n-//! ```\n-//!\n //! [ansi]: https://en.wikipedia.org/wiki/ANSI_escape_code\n //! [win]: https://docs.microsoft.com/en-us/windows/console/character-mode-applications\n //! [ti]: https://en.wikipedia.org/wiki/Terminfo\n \n #![deny(missing_docs)]\n \n-use std::io::prelude::*;\n-use std::io::{self, Stderr, Stdout};\n+use std::io::{self, prelude::*};\n \n-pub use terminfo::TerminfoTerminal;\n+pub(crate) use terminfo::TerminfoTerminal;\n #[cfg(windows)]\n-pub use win::WinConsole;\n+pub(crate) use win::WinConsole;\n \n-pub mod terminfo;\n+pub(crate) mod terminfo;\n \n #[cfg(windows)]\n mod win;\n \n /// Alias for stdout terminals.\n-pub type StdoutTerminal = dyn Terminal<Output = Stdout> + Send;\n-/// Alias for stderr terminals.\n-pub type StderrTerminal = dyn Terminal<Output = Stderr> + Send;\n+pub(crate) type StdoutTerminal = dyn Terminal + Send;\n \n #[cfg(not(windows))]\n /// Returns a Terminal wrapping stdout, or None if a terminal couldn't be\n /// opened.\n-pub fn stdout() -> Option<Box<StdoutTerminal>> {\n+pub(crate) fn stdout() -> Option<Box<StdoutTerminal>> {\n     TerminfoTerminal::new(io::stdout()).map(|t| Box::new(t) as Box<StdoutTerminal>)\n }\n \n #[cfg(windows)]\n /// Returns a Terminal wrapping stdout, or None if a terminal couldn't be\n /// opened.\n-pub fn stdout() -> Option<Box<StdoutTerminal>> {\n+pub(crate) fn stdout() -> Option<Box<StdoutTerminal>> {\n     TerminfoTerminal::new(io::stdout())\n         .map(|t| Box::new(t) as Box<StdoutTerminal>)\n         .or_else(|| WinConsole::new(io::stdout()).ok().map(|t| Box::new(t) as Box<StdoutTerminal>))\n }\n \n-#[cfg(not(windows))]\n-/// Returns a Terminal wrapping stderr, or None if a terminal couldn't be\n-/// opened.\n-pub fn stderr() -> Option<Box<StderrTerminal>> {\n-    TerminfoTerminal::new(io::stderr()).map(|t| Box::new(t) as Box<StderrTerminal>)\n-}\n-\n-#[cfg(windows)]\n-/// Returns a Terminal wrapping stderr, or None if a terminal couldn't be\n-/// opened.\n-pub fn stderr() -> Option<Box<StderrTerminal>> {\n-    TerminfoTerminal::new(io::stderr())\n-        .map(|t| Box::new(t) as Box<StderrTerminal>)\n-        .or_else(|| WinConsole::new(io::stderr()).ok().map(|t| Box::new(t) as Box<StderrTerminal>))\n-}\n-\n /// Terminal color definitions\n #[allow(missing_docs)]\n-pub mod color {\n+#[cfg_attr(not(windows), allow(dead_code))]\n+pub(crate) mod color {\n     /// Number for a terminal color\n-    pub type Color = u32;\n-\n-    pub const BLACK: Color = 0;\n-    pub const RED: Color = 1;\n-    pub const GREEN: Color = 2;\n-    pub const YELLOW: Color = 3;\n-    pub const BLUE: Color = 4;\n-    pub const MAGENTA: Color = 5;\n-    pub const CYAN: Color = 6;\n-    pub const WHITE: Color = 7;\n-\n-    pub const BRIGHT_BLACK: Color = 8;\n-    pub const BRIGHT_RED: Color = 9;\n-    pub const BRIGHT_GREEN: Color = 10;\n-    pub const BRIGHT_YELLOW: Color = 11;\n-    pub const BRIGHT_BLUE: Color = 12;\n-    pub const BRIGHT_MAGENTA: Color = 13;\n-    pub const BRIGHT_CYAN: Color = 14;\n-    pub const BRIGHT_WHITE: Color = 15;\n-}\n-\n-/// Terminal attributes for use with term.attr().\n-///\n-/// Most attributes can only be turned on and must be turned off with term.reset().\n-/// The ones that can be turned off explicitly take a boolean value.\n-/// Color is also represented as an attribute for convenience.\n-#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n-pub enum Attr {\n-    /// Bold (or possibly bright) mode\n-    Bold,\n-    /// Dim mode, also called faint or half-bright. Often not supported\n-    Dim,\n-    /// Italics mode. Often not supported\n-    Italic(bool),\n-    /// Underline mode\n-    Underline(bool),\n-    /// Blink mode\n-    Blink,\n-    /// Standout mode. Often implemented as Reverse, sometimes coupled with Bold\n-    Standout(bool),\n-    /// Reverse mode, inverts the foreground and background colors\n-    Reverse,\n-    /// Secure mode, also called invis mode. Hides the printed text\n-    Secure,\n-    /// Convenience attribute to set the foreground color\n-    ForegroundColor(color::Color),\n-    /// Convenience attribute to set the background color\n-    BackgroundColor(color::Color),\n+    pub(crate) type Color = u32;\n+\n+    pub(crate) const BLACK: Color = 0;\n+    pub(crate) const RED: Color = 1;\n+    pub(crate) const GREEN: Color = 2;\n+    pub(crate) const YELLOW: Color = 3;\n+    pub(crate) const BLUE: Color = 4;\n+    pub(crate) const MAGENTA: Color = 5;\n+    pub(crate) const CYAN: Color = 6;\n+    pub(crate) const WHITE: Color = 7;\n }\n \n /// A terminal with similar capabilities to an ANSI Terminal\n /// (foreground/background colors etc).\n pub trait Terminal: Write {\n-    /// The terminal's output writer type.\n-    type Output: Write;\n-\n     /// Sets the foreground color to the given color.\n     ///\n     /// If the color is a bright color, but the terminal only supports 8 colors,\n@@ -132,23 +71,6 @@ pub trait Terminal: Write {\n     /// if there was an I/O error.\n     fn fg(&mut self, color: color::Color) -> io::Result<bool>;\n \n-    /// Sets the background color to the given color.\n-    ///\n-    /// If the color is a bright color, but the terminal only supports 8 colors,\n-    /// the corresponding normal color will be used instead.\n-    ///\n-    /// Returns `Ok(true)` if the color was set, `Ok(false)` otherwise, and `Err(e)`\n-    /// if there was an I/O error.\n-    fn bg(&mut self, color: color::Color) -> io::Result<bool>;\n-\n-    /// Sets the given terminal attribute, if supported. Returns `Ok(true)`\n-    /// if the attribute was supported, `Ok(false)` otherwise, and `Err(e)` if\n-    /// there was an I/O error.\n-    fn attr(&mut self, attr: Attr) -> io::Result<bool>;\n-\n-    /// Returns `true` if the given terminal attribute is supported.\n-    fn supports_attr(&self, attr: Attr) -> bool;\n-\n     /// Resets all terminal attributes and colors to their defaults.\n     ///\n     /// Returns `Ok(true)` if the terminal was reset, `Ok(false)` otherwise, and `Err(e)` if there\n@@ -160,15 +82,4 @@ pub trait Terminal: Write {\n     /// else that might flush stdout's buffer (e.g., writing a line of text), you should flush after\n     /// calling reset.\n     fn reset(&mut self) -> io::Result<bool>;\n-\n-    /// Gets an immutable reference to the stream inside\n-    fn get_ref(&self) -> &Self::Output;\n-\n-    /// Gets a mutable reference to the stream inside\n-    fn get_mut(&mut self) -> &mut Self::Output;\n-\n-    /// Returns the contained stream, destroying the `Terminal`\n-    fn into_inner(self) -> Self::Output\n-    where\n-        Self: Sized;\n }"}, {"sha": "f4c5a05d1e2cebbd97f717274c5d40c434887b78", "filename": "library/test/src/term/terminfo/mod.rs", "status": "modified", "additions": 16, "deletions": 77, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fmod.rs?ref=4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac", "patch": "@@ -9,7 +9,6 @@ use std::io::{self, prelude::*, BufReader};\n use std::path::Path;\n \n use super::color;\n-use super::Attr;\n use super::Terminal;\n \n use parm::{expand, Param, Variables};\n@@ -18,20 +17,20 @@ use searcher::get_dbpath_for_term;\n \n /// A parsed terminfo database entry.\n #[derive(Debug)]\n-pub struct TermInfo {\n+pub(crate) struct TermInfo {\n     /// Names for the terminal\n-    pub names: Vec<String>,\n+    pub(crate) names: Vec<String>,\n     /// Map of capability name to boolean value\n-    pub bools: HashMap<String, bool>,\n+    pub(crate) bools: HashMap<String, bool>,\n     /// Map of capability name to numeric value\n-    pub numbers: HashMap<String, u32>,\n+    pub(crate) numbers: HashMap<String, u32>,\n     /// Map of capability name to raw (unexpanded) string\n-    pub strings: HashMap<String, Vec<u8>>,\n+    pub(crate) strings: HashMap<String, Vec<u8>>,\n }\n \n /// A terminfo creation error.\n #[derive(Debug)]\n-pub enum Error {\n+pub(crate) enum Error {\n     /// TermUnset Indicates that the environment doesn't include enough information to find\n     /// the terminfo entry.\n     TermUnset,\n@@ -64,7 +63,7 @@ impl fmt::Display for Error {\n \n impl TermInfo {\n     /// Creates a TermInfo based on current environment.\n-    pub fn from_env() -> Result<TermInfo, Error> {\n+    pub(crate) fn from_env() -> Result<TermInfo, Error> {\n         let term = match env::var(\"TERM\") {\n             Ok(name) => TermInfo::from_name(&name),\n             Err(..) => return Err(Error::TermUnset),\n@@ -79,7 +78,7 @@ impl TermInfo {\n     }\n \n     /// Creates a TermInfo for the named terminal.\n-    pub fn from_name(name: &str) -> Result<TermInfo, Error> {\n+    pub(crate) fn from_name(name: &str) -> Result<TermInfo, Error> {\n         get_dbpath_for_term(name)\n             .ok_or_else(|| {\n                 Error::IoError(io::Error::new(io::ErrorKind::NotFound, \"terminfo file not found\"))\n@@ -88,7 +87,7 @@ impl TermInfo {\n     }\n \n     /// Parse the given TermInfo.\n-    pub fn from_path<P: AsRef<Path>>(path: P) -> Result<TermInfo, Error> {\n+    pub(crate) fn from_path<P: AsRef<Path>>(path: P) -> Result<TermInfo, Error> {\n         Self::_from_path(path.as_ref())\n     }\n     // Keep the metadata small\n@@ -99,43 +98,24 @@ impl TermInfo {\n     }\n }\n \n-pub mod searcher;\n+pub(crate) mod searcher;\n \n /// TermInfo format parsing.\n-pub mod parser {\n+pub(crate) mod parser {\n     //! ncurses-compatible compiled terminfo format parsing (term(5))\n-    pub mod compiled;\n-}\n-pub mod parm;\n-\n-fn cap_for_attr(attr: Attr) -> &'static str {\n-    match attr {\n-        Attr::Bold => \"bold\",\n-        Attr::Dim => \"dim\",\n-        Attr::Italic(true) => \"sitm\",\n-        Attr::Italic(false) => \"ritm\",\n-        Attr::Underline(true) => \"smul\",\n-        Attr::Underline(false) => \"rmul\",\n-        Attr::Blink => \"blink\",\n-        Attr::Standout(true) => \"smso\",\n-        Attr::Standout(false) => \"rmso\",\n-        Attr::Reverse => \"rev\",\n-        Attr::Secure => \"invis\",\n-        Attr::ForegroundColor(_) => \"setaf\",\n-        Attr::BackgroundColor(_) => \"setab\",\n-    }\n+    pub(crate) mod compiled;\n }\n+pub(crate) mod parm;\n \n /// A Terminal that knows how many colors it supports, with a reference to its\n /// parsed Terminfo database record.\n-pub struct TerminfoTerminal<T> {\n+pub(crate) struct TerminfoTerminal<T> {\n     num_colors: u32,\n     out: T,\n     ti: TermInfo,\n }\n \n impl<T: Write + Send> Terminal for TerminfoTerminal<T> {\n-    type Output = T;\n     fn fg(&mut self, color: color::Color) -> io::Result<bool> {\n         let color = self.dim_if_necessary(color);\n         if self.num_colors > color {\n@@ -144,32 +124,6 @@ impl<T: Write + Send> Terminal for TerminfoTerminal<T> {\n         Ok(false)\n     }\n \n-    fn bg(&mut self, color: color::Color) -> io::Result<bool> {\n-        let color = self.dim_if_necessary(color);\n-        if self.num_colors > color {\n-            return self.apply_cap(\"setab\", &[Param::Number(color as i32)]);\n-        }\n-        Ok(false)\n-    }\n-\n-    fn attr(&mut self, attr: Attr) -> io::Result<bool> {\n-        match attr {\n-            Attr::ForegroundColor(c) => self.fg(c),\n-            Attr::BackgroundColor(c) => self.bg(c),\n-            _ => self.apply_cap(cap_for_attr(attr), &[]),\n-        }\n-    }\n-\n-    fn supports_attr(&self, attr: Attr) -> bool {\n-        match attr {\n-            Attr::ForegroundColor(_) | Attr::BackgroundColor(_) => self.num_colors > 0,\n-            _ => {\n-                let cap = cap_for_attr(attr);\n-                self.ti.strings.get(cap).is_some()\n-            }\n-        }\n-    }\n-\n     fn reset(&mut self) -> io::Result<bool> {\n         // are there any terminals that have color/attrs and not sgr0?\n         // Try falling back to sgr, then op\n@@ -182,26 +136,11 @@ impl<T: Write + Send> Terminal for TerminfoTerminal<T> {\n         };\n         self.out.write_all(&cmd).and(Ok(true))\n     }\n-\n-    fn get_ref(&self) -> &T {\n-        &self.out\n-    }\n-\n-    fn get_mut(&mut self) -> &mut T {\n-        &mut self.out\n-    }\n-\n-    fn into_inner(self) -> T\n-    where\n-        Self: Sized,\n-    {\n-        self.out\n-    }\n }\n \n impl<T: Write + Send> TerminfoTerminal<T> {\n     /// Creates a new TerminfoTerminal with the given TermInfo and Write.\n-    pub fn new_with_terminfo(out: T, terminfo: TermInfo) -> TerminfoTerminal<T> {\n+    pub(crate) fn new_with_terminfo(out: T, terminfo: TermInfo) -> TerminfoTerminal<T> {\n         let nc = if terminfo.strings.contains_key(\"setaf\") && terminfo.strings.contains_key(\"setab\")\n         {\n             terminfo.numbers.get(\"colors\").map_or(0, |&n| n)\n@@ -215,7 +154,7 @@ impl<T: Write + Send> TerminfoTerminal<T> {\n     /// Creates a new TerminfoTerminal for the current environment with the given Write.\n     ///\n     /// Returns `None` when the terminfo cannot be found or parsed.\n-    pub fn new(out: T) -> Option<TerminfoTerminal<T>> {\n+    pub(crate) fn new(out: T) -> Option<TerminfoTerminal<T>> {\n         TermInfo::from_env().map(move |ti| TerminfoTerminal::new_with_terminfo(out, ti)).ok()\n     }\n "}, {"sha": "0d37eb7359d85cd50963a5e4e2dee17b700db786", "filename": "library/test/src/term/terminfo/parm.rs", "status": "modified", "additions": 8, "deletions": 35, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fparm.rs?ref=4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac", "patch": "@@ -35,13 +35,12 @@ enum FormatState {\n /// Types of parameters a capability can use\n #[allow(missing_docs)]\n #[derive(Clone)]\n-pub enum Param {\n-    Words(String),\n+pub(crate) enum Param {\n     Number(i32),\n }\n \n /// Container for static and dynamic variable arrays\n-pub struct Variables {\n+pub(crate) struct Variables {\n     /// Static variables A-Z\n     sta_va: [Param; 26],\n     /// Dynamic variables a-z\n@@ -50,7 +49,7 @@ pub struct Variables {\n \n impl Variables {\n     /// Returns a new zero-initialized Variables\n-    pub fn new() -> Variables {\n+    pub(crate) fn new() -> Variables {\n         Variables {\n             sta_va: [\n                 Number(0),\n@@ -121,7 +120,11 @@ impl Variables {\n ///\n /// To be compatible with ncurses, `vars` should be the same between calls to `expand` for\n /// multiple capabilities for the same terminal.\n-pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<u8>, String> {\n+pub(crate) fn expand(\n+    cap: &[u8],\n+    params: &[Param],\n+    vars: &mut Variables,\n+) -> Result<Vec<u8>, String> {\n     let mut state = Nothing;\n \n     // expanded cap will only rarely be larger than the cap itself\n@@ -168,7 +171,6 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<\n                             Some(Number(0)) => output.push(128u8),\n                             // Don't check bounds. ncurses just casts and truncates.\n                             Some(Number(c)) => output.push(c as u8),\n-                            Some(_) => return Err(\"a non-char was used with %c\".to_string()),\n                             None => return Err(\"stack is empty\".to_string()),\n                         }\n                     }\n@@ -178,7 +180,6 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<\n                     '\\'' => state = CharConstant,\n                     '{' => state = IntConstant(0),\n                     'l' => match stack.pop() {\n-                        Some(Words(s)) => stack.push(Number(s.len() as i32)),\n                         Some(_) => return Err(\"a non-str was used with %l\".to_string()),\n                         None => return Err(\"stack is empty\".to_string()),\n                     },\n@@ -195,9 +196,6 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<\n                                 'm' => x % y,\n                                 _ => unreachable!(\"All cases handled\"),\n                             })),\n-                            (Some(_), Some(_)) => {\n-                                return Err(format!(\"non-numbers on stack with {}\", cur));\n-                            }\n                             _ => return Err(\"stack is empty\".to_string()),\n                         }\n                     }\n@@ -216,9 +214,6 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<\n                                 0\n                             },\n                         )),\n-                        (Some(_), Some(_)) => {\n-                            return Err(format!(\"non-numbers on stack with {}\", cur));\n-                        }\n                         _ => return Err(\"stack is empty\".to_string()),\n                     },\n                     '!' | '~' => match stack.pop() {\n@@ -228,15 +223,13 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<\n                             '~' => !x,\n                             _ => unreachable!(),\n                         })),\n-                        Some(_) => return Err(format!(\"non-numbers on stack with {}\", cur)),\n                         None => return Err(\"stack is empty\".to_string()),\n                     },\n                     'i' => match (&mparams[0], &mparams[1]) {\n                         (&Number(x), &Number(y)) => {\n                             mparams[0] = Number(x + 1);\n                             mparams[1] = Number(y + 1);\n                         }\n-                        _ => return Err(\"first two params not numbers with %i\".to_string()),\n                     },\n \n                     // printf-style support for %doxXs\n@@ -271,7 +264,6 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<\n                     't' => match stack.pop() {\n                         Some(Number(0)) => state = SeekIfElse(0),\n                         Some(Number(_)) => (),\n-                        Some(_) => return Err(\"non-number on stack with conditional\".to_string()),\n                         None => return Err(\"stack is empty\".to_string()),\n                     },\n                     'e' => state = SeekIfEnd(0),\n@@ -480,15 +472,6 @@ impl FormatOp {\n             _ => panic!(\"bad FormatOp char\"),\n         }\n     }\n-    fn to_char(self) -> char {\n-        match self {\n-            FormatOp::Digit => 'd',\n-            FormatOp::Octal => 'o',\n-            FormatOp::LowerHex => 'x',\n-            FormatOp::UpperHex => 'X',\n-            FormatOp::String => 's',\n-        }\n-    }\n }\n \n fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8>, String> {\n@@ -533,16 +516,6 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8>, String> {\n             }\n             .into_bytes()\n         }\n-        Words(s) => match op {\n-            FormatOp::String => {\n-                let mut s = s.into_bytes();\n-                if flags.precision > 0 && flags.precision < s.len() {\n-                    s.truncate(flags.precision);\n-                }\n-                s\n-            }\n-            _ => return Err(format!(\"non-string on stack with %{}\", op.to_char())),\n-        },\n     };\n     if flags.width > s.len() {\n         let n = flags.width - s.len();"}, {"sha": "256d1aaf446d96f962e0d29f0285d75ef2b5f9c5", "filename": "library/test/src/term/terminfo/parm/tests.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fparm%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fparm%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fparm%2Ftests.rs?ref=4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac", "patch": "@@ -51,7 +51,10 @@ fn test_param_stack_failure_conditions() {\n     for &cap in caps.iter() {\n         let res = get_res(\"\", cap, &[], vars);\n         assert!(res.is_err(), \"Op {} succeeded incorrectly with 0 stack entries\", cap);\n-        let p = if cap == \"%s\" || cap == \"%l\" { Words(\"foo\".to_string()) } else { Number(97) };\n+        if cap == \"%s\" || cap == \"%l\" {\n+            continue;\n+        }\n+        let p = Number(97);\n         let res = get_res(\"%p1\", cap, &[p], vars);\n         assert!(res.is_ok(), \"Op {} failed with 1 stack entry: {}\", cap, res.unwrap_err());\n     }\n@@ -109,23 +112,6 @@ fn test_conditionals() {\n fn test_format() {\n     let mut varstruct = Variables::new();\n     let vars = &mut varstruct;\n-    assert_eq!(\n-        expand(\n-            b\"%p1%s%p2%2s%p3%2s%p4%.2s\",\n-            &[\n-                Words(\"foo\".to_string()),\n-                Words(\"foo\".to_string()),\n-                Words(\"f\".to_string()),\n-                Words(\"foo\".to_string())\n-            ],\n-            vars\n-        ),\n-        Ok(\"foofoo ffo\".bytes().collect::<Vec<_>>())\n-    );\n-    assert_eq!(\n-        expand(b\"%p1%:-4.2s\", &[Words(\"foo\".to_string())], vars),\n-        Ok(\"fo  \".bytes().collect::<Vec<_>>())\n-    );\n \n     assert_eq!(\n         expand(b\"%p1%d%p1%.3d%p1%5d%p1%:+d\", &[Number(1)], vars),"}, {"sha": "b24f3f8b05e708cd9bb606d8f1de07f3a485c3ca", "filename": "library/test/src/term/terminfo/parser/compiled.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac", "patch": "@@ -13,7 +13,7 @@ mod tests;\n // These are the orders ncurses uses in its compiled format (as of 5.9). Not sure if portable.\n \n #[rustfmt::skip]\n-pub static boolfnames: &[&str] = &[\"auto_left_margin\", \"auto_right_margin\",\n+pub(crate) static boolfnames: &[&str] = &[\"auto_left_margin\", \"auto_right_margin\",\n     \"no_esc_ctlc\", \"ceol_standout_glitch\", \"eat_newline_glitch\", \"erase_overstrike\", \"generic_type\",\n     \"hard_copy\", \"has_meta_key\", \"has_status_line\", \"insert_null_glitch\", \"memory_above\",\n     \"memory_below\", \"move_insert_mode\", \"move_standout_mode\", \"over_strike\", \"status_line_esc_ok\",\n@@ -26,13 +26,13 @@ pub static boolfnames: &[&str] = &[\"auto_left_margin\", \"auto_right_margin\",\n     \"return_does_clr_eol\"];\n \n #[rustfmt::skip]\n-pub static boolnames: &[&str] = &[\"bw\", \"am\", \"xsb\", \"xhp\", \"xenl\", \"eo\",\n+pub(crate) static boolnames: &[&str] = &[\"bw\", \"am\", \"xsb\", \"xhp\", \"xenl\", \"eo\",\n     \"gn\", \"hc\", \"km\", \"hs\", \"in\", \"db\", \"da\", \"mir\", \"msgr\", \"os\", \"eslok\", \"xt\", \"hz\", \"ul\", \"xon\",\n     \"nxon\", \"mc5i\", \"chts\", \"nrrmc\", \"npc\", \"ndscr\", \"ccc\", \"bce\", \"hls\", \"xhpa\", \"crxm\", \"daisy\",\n     \"xvpa\", \"sam\", \"cpix\", \"lpix\", \"OTbs\", \"OTns\", \"OTnc\", \"OTMT\", \"OTNL\", \"OTpt\", \"OTxr\"];\n \n #[rustfmt::skip]\n-pub static numfnames: &[&str] = &[ \"columns\", \"init_tabs\", \"lines\",\n+pub(crate) static numfnames: &[&str] = &[ \"columns\", \"init_tabs\", \"lines\",\n     \"lines_of_memory\", \"magic_cookie_glitch\", \"padding_baud_rate\", \"virtual_terminal\",\n     \"width_status_line\", \"num_labels\", \"label_height\", \"label_width\", \"max_attributes\",\n     \"maximum_windows\", \"max_colors\", \"max_pairs\", \"no_color_video\", \"buffer_capacity\",\n@@ -43,13 +43,13 @@ pub static numfnames: &[&str] = &[ \"columns\", \"init_tabs\", \"lines\",\n     \"new_line_delay\", \"backspace_delay\", \"horizontal_tab_delay\", \"number_of_function_keys\"];\n \n #[rustfmt::skip]\n-pub static numnames: &[&str] = &[ \"cols\", \"it\", \"lines\", \"lm\", \"xmc\", \"pb\",\n+pub(crate) static numnames: &[&str] = &[ \"cols\", \"it\", \"lines\", \"lm\", \"xmc\", \"pb\",\n     \"vt\", \"wsl\", \"nlab\", \"lh\", \"lw\", \"ma\", \"wnum\", \"colors\", \"pairs\", \"ncv\", \"bufsz\", \"spinv\",\n     \"spinh\", \"maddr\", \"mjump\", \"mcs\", \"mls\", \"npins\", \"orc\", \"orl\", \"orhi\", \"orvi\", \"cps\", \"widcs\",\n     \"btns\", \"bitwin\", \"bitype\", \"UTug\", \"OTdC\", \"OTdN\", \"OTdB\", \"OTdT\", \"OTkn\"];\n \n #[rustfmt::skip]\n-pub static stringfnames: &[&str] = &[ \"back_tab\", \"bell\", \"carriage_return\",\n+pub(crate) static stringfnames: &[&str] = &[ \"back_tab\", \"bell\", \"carriage_return\",\n     \"change_scroll_region\", \"clear_all_tabs\", \"clear_screen\", \"clr_eol\", \"clr_eos\",\n     \"column_address\", \"command_character\", \"cursor_address\", \"cursor_down\", \"cursor_home\",\n     \"cursor_invisible\", \"cursor_left\", \"cursor_mem_address\", \"cursor_normal\", \"cursor_right\",\n@@ -123,7 +123,7 @@ pub static stringfnames: &[&str] = &[ \"back_tab\", \"bell\", \"carriage_return\",\n     \"acs_plus\", \"memory_lock\", \"memory_unlock\", \"box_chars_1\"];\n \n #[rustfmt::skip]\n-pub static stringnames: &[&str] = &[ \"cbt\", \"_\", \"cr\", \"csr\", \"tbc\", \"clear\",\n+pub(crate) static stringnames: &[&str] = &[ \"cbt\", \"_\", \"cr\", \"csr\", \"tbc\", \"clear\",\n     \"_\", \"_\", \"hpa\", \"cmdch\", \"cup\", \"cud1\", \"home\", \"civis\", \"cub1\", \"mrcup\", \"cnorm\", \"cuf1\",\n     \"ll\", \"cuu1\", \"cvvis\", \"dch1\", \"dl1\", \"dsl\", \"hd\", \"smacs\", \"blink\", \"bold\", \"smcup\", \"smdc\",\n     \"dim\", \"smir\", \"invis\", \"prot\", \"rev\", \"smso\", \"smul\", \"ech\", \"rmacs\", \"sgr0\", \"rmcup\", \"rmdc\",\n@@ -178,7 +178,7 @@ fn read_byte(r: &mut dyn io::Read) -> io::Result<u8> {\n \n /// Parse a compiled terminfo entry, using long capability names if `longnames`\n /// is true\n-pub fn parse(file: &mut dyn io::Read, longnames: bool) -> Result<TermInfo, String> {\n+pub(crate) fn parse(file: &mut dyn io::Read, longnames: bool) -> Result<TermInfo, String> {\n     macro_rules! t( ($e:expr) => (\n         match $e {\n             Ok(e) => e,\n@@ -317,7 +317,7 @@ pub fn parse(file: &mut dyn io::Read, longnames: bool) -> Result<TermInfo, Strin\n }\n \n /// Creates a dummy TermInfo struct for msys terminals\n-pub fn msys_terminfo() -> TermInfo {\n+pub(crate) fn msys_terminfo() -> TermInfo {\n     let mut strings = HashMap::new();\n     strings.insert(\"sgr0\".to_string(), b\"\\x1B[0m\".to_vec());\n     strings.insert(\"bold\".to_string(), b\"\\x1B[1m\".to_vec());"}, {"sha": "68e181a6895799ef1bcbb5fe224f1354a4e74dea", "filename": "library/test/src/term/terminfo/searcher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fsearcher.rs?ref=4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac", "patch": "@@ -11,7 +11,7 @@ mod tests;\n \n /// Return path to database entry for `term`\n #[allow(deprecated)]\n-pub fn get_dbpath_for_term(term: &str) -> Option<PathBuf> {\n+pub(crate) fn get_dbpath_for_term(term: &str) -> Option<PathBuf> {\n     let mut dirs_to_search = Vec::new();\n     let first_char = term.chars().next()?;\n "}, {"sha": "4bdbd6ee75f527139d1f8d90e46a6a369463871e", "filename": "library/test/src/term/win.rs", "status": "modified", "additions": 2, "deletions": 52, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac/library%2Ftest%2Fsrc%2Fterm%2Fwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac/library%2Ftest%2Fsrc%2Fterm%2Fwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fterm%2Fwin.rs?ref=4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac", "patch": "@@ -6,11 +6,10 @@ use std::io;\n use std::io::prelude::*;\n \n use super::color;\n-use super::Attr;\n use super::Terminal;\n \n /// A Terminal implementation that uses the Win32 Console API.\n-pub struct WinConsole<T> {\n+pub(crate) struct WinConsole<T> {\n     buf: T,\n     def_foreground: color::Color,\n     def_background: color::Color,\n@@ -115,7 +114,7 @@ impl<T: Write + Send + 'static> WinConsole<T> {\n     }\n \n     /// Returns `None` whenever the terminal cannot be created for some reason.\n-    pub fn new(out: T) -> io::Result<WinConsole<T>> {\n+    pub(crate) fn new(out: T) -> io::Result<WinConsole<T>> {\n         use std::mem::MaybeUninit;\n \n         let fg;\n@@ -154,67 +153,18 @@ impl<T: Write> Write for WinConsole<T> {\n }\n \n impl<T: Write + Send + 'static> Terminal for WinConsole<T> {\n-    type Output = T;\n-\n     fn fg(&mut self, color: color::Color) -> io::Result<bool> {\n         self.foreground = color;\n         self.apply();\n \n         Ok(true)\n     }\n \n-    fn bg(&mut self, color: color::Color) -> io::Result<bool> {\n-        self.background = color;\n-        self.apply();\n-\n-        Ok(true)\n-    }\n-\n-    fn attr(&mut self, attr: Attr) -> io::Result<bool> {\n-        match attr {\n-            Attr::ForegroundColor(f) => {\n-                self.foreground = f;\n-                self.apply();\n-                Ok(true)\n-            }\n-            Attr::BackgroundColor(b) => {\n-                self.background = b;\n-                self.apply();\n-                Ok(true)\n-            }\n-            _ => Ok(false),\n-        }\n-    }\n-\n-    fn supports_attr(&self, attr: Attr) -> bool {\n-        // it claims support for underscore and reverse video, but I can't get\n-        // it to do anything -cmr\n-        match attr {\n-            Attr::ForegroundColor(_) | Attr::BackgroundColor(_) => true,\n-            _ => false,\n-        }\n-    }\n-\n     fn reset(&mut self) -> io::Result<bool> {\n         self.foreground = self.def_foreground;\n         self.background = self.def_background;\n         self.apply();\n \n         Ok(true)\n     }\n-\n-    fn get_ref(&self) -> &T {\n-        &self.buf\n-    }\n-\n-    fn get_mut(&mut self) -> &mut T {\n-        &mut self.buf\n-    }\n-\n-    fn into_inner(self) -> T\n-    where\n-        Self: Sized,\n-    {\n-        self.buf\n-    }\n }"}]}