{"sha": "ea15fb2177b0c33352363c130bc296a0dd1a794a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhMTVmYjIxNzdiMGMzMzM1MjM2M2MxMzBiYzI5NmEwZGQxYTc5NGE=", "commit": {"author": {"name": "Mateusz Gacek", "email": "96mateusz.gacek@gmail.com", "date": "2021-03-17T14:52:14Z"}, "committer": {"name": "Mateusz Gacek", "email": "96mateusz.gacek@gmail.com", "date": "2021-03-17T21:00:46Z"}, "message": "wrong_self_convention: `to_` respects `Copy` types\n\nMore details here:\nhttps://rust-lang.github.io/api-guidelines/naming.html#ad-hoc-conversions-follow-as_-to_-into_-conventions-c-conv", "tree": {"sha": "f13aa1fdd3cbec17c9669e3624beec4b7aac234f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f13aa1fdd3cbec17c9669e3624beec4b7aac234f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea15fb2177b0c33352363c130bc296a0dd1a794a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea15fb2177b0c33352363c130bc296a0dd1a794a", "html_url": "https://github.com/rust-lang/rust/commit/ea15fb2177b0c33352363c130bc296a0dd1a794a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea15fb2177b0c33352363c130bc296a0dd1a794a/comments", "author": {"login": "mgacek8", "id": 24357739, "node_id": "MDQ6VXNlcjI0MzU3NzM5", "avatar_url": "https://avatars.githubusercontent.com/u/24357739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mgacek8", "html_url": "https://github.com/mgacek8", "followers_url": "https://api.github.com/users/mgacek8/followers", "following_url": "https://api.github.com/users/mgacek8/following{/other_user}", "gists_url": "https://api.github.com/users/mgacek8/gists{/gist_id}", "starred_url": "https://api.github.com/users/mgacek8/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mgacek8/subscriptions", "organizations_url": "https://api.github.com/users/mgacek8/orgs", "repos_url": "https://api.github.com/users/mgacek8/repos", "events_url": "https://api.github.com/users/mgacek8/events{/privacy}", "received_events_url": "https://api.github.com/users/mgacek8/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mgacek8", "id": 24357739, "node_id": "MDQ6VXNlcjI0MzU3NzM5", "avatar_url": "https://avatars.githubusercontent.com/u/24357739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mgacek8", "html_url": "https://github.com/mgacek8", "followers_url": "https://api.github.com/users/mgacek8/followers", "following_url": "https://api.github.com/users/mgacek8/following{/other_user}", "gists_url": "https://api.github.com/users/mgacek8/gists{/gist_id}", "starred_url": "https://api.github.com/users/mgacek8/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mgacek8/subscriptions", "organizations_url": "https://api.github.com/users/mgacek8/orgs", "repos_url": "https://api.github.com/users/mgacek8/repos", "events_url": "https://api.github.com/users/mgacek8/events{/privacy}", "received_events_url": "https://api.github.com/users/mgacek8/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56161b2982a4e6513e6765d6cc951ccc0f297a89", "url": "https://api.github.com/repos/rust-lang/rust/commits/56161b2982a4e6513e6765d6cc951ccc0f297a89", "html_url": "https://github.com/rust-lang/rust/commit/56161b2982a4e6513e6765d6cc951ccc0f297a89"}], "stats": {"total": 233, "additions": 143, "deletions": 90}, "files": [{"sha": "722effc29b2286662084fc460aa63f8e1c3cbeea", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ea15fb2177b0c33352363c130bc296a0dd1a794a/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea15fb2177b0c33352363c130bc296a0dd1a794a/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=ea15fb2177b0c33352363c130bc296a0dd1a794a", "patch": "@@ -193,14 +193,18 @@ declare_clippy_lint! {\n     /// **What it does:** Checks for methods with certain name prefixes and which\n     /// doesn't match how self is taken. The actual rules are:\n     ///\n-    /// |Prefix |Postfix     |`self` taken          |\n-    /// |-------|------------|----------------------|\n-    /// |`as_`  | none       |`&self` or `&mut self`|\n-    /// |`from_`| none       | none                 |\n-    /// |`into_`| none       |`self`                |\n-    /// |`is_`  | none       |`&self` or none       |\n-    /// |`to_`  | `_mut`     |`&mut &self`          |\n-    /// |`to_`  | not `_mut` |`&self`               |\n+    /// |Prefix |Postfix     |`self` taken           | `self` type  |\n+    /// |-------|------------|-----------------------|--------------|\n+    /// |`as_`  | none       |`&self` or `&mut self` | any          |\n+    /// |`from_`| none       | none                  | any          |\n+    /// |`into_`| none       |`self`                 | any          |\n+    /// |`is_`  | none       |`&self` or none        | any          |\n+    /// |`to_`  | `_mut`     |`&mut self`            | any          |\n+    /// |`to_`  | not `_mut` |`self`                 | `Copy`       |\n+    /// |`to_`  | not `_mut` |`&self`                | not `Copy`   |\n+    ///\n+    /// Please find more info here:\n+    /// https://rust-lang.github.io/api-guidelines/naming.html#ad-hoc-conversions-follow-as_-to_-into_-conventions-c-conv\n     ///\n     /// **Why is this bad?** Consistency breeds readability. If you follow the\n     /// conventions, your users won't be surprised that they, e.g., need to supply a\n@@ -1837,10 +1841,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n         let item = cx.tcx.hir().expect_item(parent);\n         let self_ty = cx.tcx.type_of(item.def_id);\n \n-        // if this impl block implements a trait, lint in trait definition instead\n-        if let hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }) = item.kind {\n-            return;\n-        }\n+        let implements_trait = matches!(item.kind, hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }));\n \n         if_chain! {\n             if let hir::ImplItemKind::Fn(ref sig, id) = impl_item.kind;\n@@ -1855,7 +1856,8 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             if let Some(first_arg_ty) = first_arg_ty;\n \n             then {\n-                if cx.access_levels.is_exported(impl_item.hir_id()) {\n+                // if this impl block implements a trait, lint in trait definition instead\n+                if !implements_trait && cx.access_levels.is_exported(impl_item.hir_id()) {\n                     // check missing trait implementations\n                     for method_config in &TRAIT_METHODS {\n                         if name == method_config.method_name &&\n@@ -1891,11 +1893,17 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                     item.vis.node.is_pub(),\n                     self_ty,\n                     first_arg_ty,\n-                    first_arg.pat.span\n+                    first_arg.pat.span,\n+                    false\n                 );\n             }\n         }\n \n+        // if this impl block implements a trait, lint in trait definition instead\n+        if implements_trait {\n+            return;\n+        }\n+\n         if let hir::ImplItemKind::Fn(_, _) = impl_item.kind {\n             let ret_ty = return_ty(cx, impl_item.hir_id());\n \n@@ -1947,7 +1955,8 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                     false,\n                     self_ty,\n                     first_arg_ty,\n-                    first_arg_span\n+                    first_arg_span,\n+                    true\n                 );\n             }\n         }"}, {"sha": "bece8f251daf16920bbf1554a1c7001719c0989d", "filename": "clippy_lints/src/methods/wrong_self_convention.rs", "status": "modified", "additions": 42, "deletions": 32, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/ea15fb2177b0c33352363c130bc296a0dd1a794a/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea15fb2177b0c33352363c130bc296a0dd1a794a/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs?ref=ea15fb2177b0c33352363c130bc296a0dd1a794a", "patch": "@@ -1,5 +1,6 @@\n use crate::methods::SelfKind;\n use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::ty::is_copy;\n use rustc_lint::LateContext;\n use rustc_middle::ty::TyS;\n use rustc_span::source_map::Span;\n@@ -9,32 +10,40 @@ use super::WRONG_PUB_SELF_CONVENTION;\n use super::WRONG_SELF_CONVENTION;\n \n #[rustfmt::skip]\n-const CONVENTIONS: [(&[Convention], &[SelfKind]); 8] = [\n+const CONVENTIONS: [(&[Convention], &[SelfKind]); 9] = [\n     (&[Convention::Eq(\"new\")], &[SelfKind::No]),\n     (&[Convention::StartsWith(\"as_\")], &[SelfKind::Ref, SelfKind::RefMut]),\n     (&[Convention::StartsWith(\"from_\")], &[SelfKind::No]),\n     (&[Convention::StartsWith(\"into_\")], &[SelfKind::Value]),\n     (&[Convention::StartsWith(\"is_\")], &[SelfKind::Ref, SelfKind::No]),\n     (&[Convention::Eq(\"to_mut\")], &[SelfKind::RefMut]),\n     (&[Convention::StartsWith(\"to_\"), Convention::EndsWith(\"_mut\")], &[SelfKind::RefMut]),\n-    (&[Convention::StartsWith(\"to_\"), Convention::NotEndsWith(\"_mut\")], &[SelfKind::Ref]),\n+\n+    // Conversion using `to_` can use borrowed (non-Copy types) or owned (Copy types).\n+    // Source: https://rust-lang.github.io/api-guidelines/naming.html#ad-hoc-conversions-follow-as_-to_-into_-conventions-c-conv\n+    (&[Convention::StartsWith(\"to_\"), Convention::NotEndsWith(\"_mut\"), Convention::IsSelfTypeCopy(false), Convention::ImplementsTrait(false)], &[SelfKind::Ref]),\n+    (&[Convention::StartsWith(\"to_\"), Convention::NotEndsWith(\"_mut\"), Convention::IsSelfTypeCopy(true), Convention::ImplementsTrait(false)], &[SelfKind::Value]),\n ];\n \n enum Convention {\n     Eq(&'static str),\n     StartsWith(&'static str),\n     EndsWith(&'static str),\n     NotEndsWith(&'static str),\n+    IsSelfTypeCopy(bool),\n+    ImplementsTrait(bool),\n }\n \n impl Convention {\n     #[must_use]\n-    fn check(&self, other: &str) -> bool {\n+    fn check<'tcx>(&self, cx: &LateContext<'tcx>, self_ty: &'tcx TyS<'tcx>, other: &str, is_trait_def: bool) -> bool {\n         match *self {\n             Self::Eq(this) => this == other,\n             Self::StartsWith(this) => other.starts_with(this) && this != other,\n             Self::EndsWith(this) => other.ends_with(this) && this != other,\n-            Self::NotEndsWith(this) => !Self::EndsWith(this).check(other),\n+            Self::NotEndsWith(this) => !Self::EndsWith(this).check(cx, self_ty, other, is_trait_def),\n+            Self::IsSelfTypeCopy(is_true) => is_true == is_copy(cx, self_ty),\n+            Self::ImplementsTrait(is_true) => is_true == is_trait_def,\n         }\n     }\n }\n@@ -46,6 +55,10 @@ impl fmt::Display for Convention {\n             Self::StartsWith(this) => this.fmt(f).and_then(|_| '*'.fmt(f)),\n             Self::EndsWith(this) => '*'.fmt(f).and_then(|_| this.fmt(f)),\n             Self::NotEndsWith(this) => '~'.fmt(f).and_then(|_| this.fmt(f)),\n+            Self::IsSelfTypeCopy(is_true) => format!(\"self type is {} Copy\", if is_true { \"\" } else { \"not\" }).fmt(f),\n+            Self::ImplementsTrait(is_true) => {\n+                format!(\"Method {} implement a trait\", if is_true { \"\" } else { \"do not\" }).fmt(f)\n+            },\n         }\n     }\n }\n@@ -57,45 +70,42 @@ pub(super) fn check<'tcx>(\n     self_ty: &'tcx TyS<'tcx>,\n     first_arg_ty: &'tcx TyS<'tcx>,\n     first_arg_span: Span,\n+    is_trait_item: bool,\n ) {\n     let lint = if is_pub {\n         WRONG_PUB_SELF_CONVENTION\n     } else {\n         WRONG_SELF_CONVENTION\n     };\n-    if let Some((conventions, self_kinds)) = &CONVENTIONS\n-        .iter()\n-        .find(|(convs, _)| convs.iter().all(|conv| conv.check(item_name)))\n-    {\n+    if let Some((conventions, self_kinds)) = &CONVENTIONS.iter().find(|(convs, _)| {\n+        convs\n+            .iter()\n+            .all(|conv| conv.check(cx, self_ty, item_name, is_trait_item))\n+    }) {\n         if !self_kinds.iter().any(|k| k.matches(cx, self_ty, first_arg_ty)) {\n             let suggestion = {\n                 if conventions.len() > 1 {\n-                    let special_case = {\n-                        // Don't mention `NotEndsWith` when there is also `StartsWith` convention present\n-                        if conventions.len() == 2 {\n-                            match conventions {\n-                                [Convention::StartsWith(starts_with), Convention::NotEndsWith(_)]\n-                                | [Convention::NotEndsWith(_), Convention::StartsWith(starts_with)] => {\n-                                    Some(format!(\"methods called `{}`\", Convention::StartsWith(starts_with)))\n-                                },\n-                                _ => None,\n-                            }\n-                        } else {\n-                            None\n-                        }\n-                    };\n-\n-                    if let Some(suggestion) = special_case {\n-                        suggestion\n-                    } else {\n-                        let s = conventions\n+                    // Don't mention `NotEndsWith` when there is also `StartsWith` convention present\n+                    let cut_ends_with_conv = conventions.iter().any(|conv| matches!(conv, Convention::StartsWith(_)))\n+                        && conventions\n                             .iter()\n-                            .map(|c| format!(\"`{}`\", &c.to_string()))\n-                            .collect::<Vec<_>>()\n-                            .join(\" and \");\n+                            .any(|conv| matches!(conv, Convention::NotEndsWith(_)));\n+\n+                    let s = conventions\n+                        .iter()\n+                        .filter_map(|conv| {\n+                            if (cut_ends_with_conv && matches!(conv, Convention::NotEndsWith(_)))\n+                                || matches!(conv, Convention::ImplementsTrait(_))\n+                            {\n+                                None\n+                            } else {\n+                                Some(format!(\"`{}`\", &conv.to_string()))\n+                            }\n+                        })\n+                        .collect::<Vec<_>>()\n+                        .join(\" and \");\n \n-                        format!(\"methods called like this: ({})\", &s)\n-                    }\n+                    format!(\"methods with the following characteristics: ({})\", &s)\n                 } else {\n                     format!(\"methods called `{}`\", &conventions[0])\n                 }"}, {"sha": "1986b54e66c6d9c72f55a9bb2ca6eaab033e369c", "filename": "tests/ui/use_self.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ea15fb2177b0c33352363c130bc296a0dd1a794a/tests%2Fui%2Fuse_self.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ea15fb2177b0c33352363c130bc296a0dd1a794a/tests%2Fui%2Fuse_self.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.fixed?ref=ea15fb2177b0c33352363c130bc296a0dd1a794a", "patch": "@@ -79,6 +79,7 @@ mod issue2894 {\n     }\n \n     // This should not be linted\n+    #[allow(clippy::wrong_self_convention)]\n     impl IntoBytes for u8 {\n         fn to_bytes(&self) -> Vec<u8> {\n             vec![*self]"}, {"sha": "acc18280f1a536bac770e8a9fe968da0720b5f8a", "filename": "tests/ui/use_self.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ea15fb2177b0c33352363c130bc296a0dd1a794a/tests%2Fui%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea15fb2177b0c33352363c130bc296a0dd1a794a/tests%2Fui%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.rs?ref=ea15fb2177b0c33352363c130bc296a0dd1a794a", "patch": "@@ -79,6 +79,7 @@ mod issue2894 {\n     }\n \n     // This should not be linted\n+    #[allow(clippy::wrong_self_convention)]\n     impl IntoBytes for u8 {\n         fn to_bytes(&self) -> Vec<u8> {\n             vec![*self]"}, {"sha": "a2c959634878dbda66d06b1450c57bce8ccc4a0e", "filename": "tests/ui/use_self.stderr", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ea15fb2177b0c33352363c130bc296a0dd1a794a/tests%2Fui%2Fuse_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea15fb2177b0c33352363c130bc296a0dd1a794a/tests%2Fui%2Fuse_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.stderr?ref=ea15fb2177b0c33352363c130bc296a0dd1a794a", "patch": "@@ -37,139 +37,139 @@ LL |             Foo::new()\n    |             ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:93:24\n+  --> $DIR/use_self.rs:94:24\n    |\n LL |         fn bad(foos: &[Foo]) -> impl Iterator<Item = &Foo> {\n    |                        ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:93:55\n+  --> $DIR/use_self.rs:94:55\n    |\n LL |         fn bad(foos: &[Foo]) -> impl Iterator<Item = &Foo> {\n    |                                                       ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:108:13\n+  --> $DIR/use_self.rs:109:13\n    |\n LL |             TS(0)\n    |             ^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:143:29\n+  --> $DIR/use_self.rs:144:29\n    |\n LL |                 fn bar() -> Bar {\n    |                             ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:144:21\n+  --> $DIR/use_self.rs:145:21\n    |\n LL |                     Bar { foo: Foo {} }\n    |                     ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:155:21\n+  --> $DIR/use_self.rs:156:21\n    |\n LL |         fn baz() -> Foo {\n    |                     ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:156:13\n+  --> $DIR/use_self.rs:157:13\n    |\n LL |             Foo {}\n    |             ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:173:21\n+  --> $DIR/use_self.rs:174:21\n    |\n LL |             let _ = Enum::B(42);\n    |                     ^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:174:21\n+  --> $DIR/use_self.rs:175:21\n    |\n LL |             let _ = Enum::C { field: true };\n    |                     ^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:175:21\n+  --> $DIR/use_self.rs:176:21\n    |\n LL |             let _ = Enum::A;\n    |                     ^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:217:13\n+  --> $DIR/use_self.rs:218:13\n    |\n LL |             nested::A::fun_1();\n    |             ^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:218:13\n+  --> $DIR/use_self.rs:219:13\n    |\n LL |             nested::A::A;\n    |             ^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:220:13\n+  --> $DIR/use_self.rs:221:13\n    |\n LL |             nested::A {};\n    |             ^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:239:13\n+  --> $DIR/use_self.rs:240:13\n    |\n LL |             TestStruct::from_something()\n    |             ^^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:253:25\n+  --> $DIR/use_self.rs:254:25\n    |\n LL |         async fn g() -> S {\n    |                         ^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:254:13\n+  --> $DIR/use_self.rs:255:13\n    |\n LL |             S {}\n    |             ^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:258:16\n+  --> $DIR/use_self.rs:259:16\n    |\n LL |             &p[S::A..S::B]\n    |                ^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:258:22\n+  --> $DIR/use_self.rs:259:22\n    |\n LL |             &p[S::A..S::B]\n    |                      ^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:281:29\n+  --> $DIR/use_self.rs:282:29\n    |\n LL |         fn foo(value: T) -> Foo<T> {\n    |                             ^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:282:13\n+  --> $DIR/use_self.rs:283:13\n    |\n LL |             Foo { value }\n    |             ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:319:21\n+  --> $DIR/use_self.rs:320:21\n    |\n LL |         type From = T::From;\n    |                     ^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:320:19\n+  --> $DIR/use_self.rs:321:19\n    |\n LL |         type To = T::To;\n    |                   ^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:453:13\n+  --> $DIR/use_self.rs:454:13\n    |\n LL |             A::new::<submod::B>(submod::B {})\n    |             ^ help: use the applicable keyword: `Self`"}, {"sha": "ba9e19a17220ff55d214e1628350d6bf10cfb7e3", "filename": "tests/ui/wrong_self_convention.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ea15fb2177b0c33352363c130bc296a0dd1a794a/tests%2Fui%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea15fb2177b0c33352363c130bc296a0dd1a794a/tests%2Fui%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrong_self_convention.rs?ref=ea15fb2177b0c33352363c130bc296a0dd1a794a", "patch": "@@ -163,3 +163,35 @@ mod issue6307 {\n         fn to_mut(&mut self);\n     }\n }\n+\n+mod issue6727 {\n+    trait ToU64 {\n+        fn to_u64(self) -> u64;\n+        fn to_u64_v2(&self) -> u64;\n+    }\n+\n+    #[derive(Clone, Copy)]\n+    struct FooCopy;\n+\n+    impl ToU64 for FooCopy {\n+        fn to_u64(self) -> u64 {\n+            1\n+        }\n+        // trigger lint\n+        fn to_u64_v2(&self) -> u64 {\n+            1\n+        }\n+    }\n+\n+    struct FooNoCopy;\n+\n+    impl ToU64 for FooNoCopy {\n+        // trigger lint\n+        fn to_u64(self) -> u64 {\n+            2\n+        }\n+        fn to_u64_v2(&self) -> u64 {\n+            2\n+        }\n+    }\n+}"}, {"sha": "6daa334ed48779f07238263d11c67035d1e38276", "filename": "tests/ui/wrong_self_convention.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ea15fb2177b0c33352363c130bc296a0dd1a794a/tests%2Fui%2Fwrong_self_convention.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea15fb2177b0c33352363c130bc296a0dd1a794a/tests%2Fui%2Fwrong_self_convention.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrong_self_convention.stderr?ref=ea15fb2177b0c33352363c130bc296a0dd1a794a", "patch": "@@ -39,7 +39,7 @@ LL |     fn is_i32(self) {}\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `to_*` usually take self by reference\n+error: methods with the following characteristics: (`to_*` and `self type is not Copy`) usually take self by reference\n   --> $DIR/wrong_self_convention.rs:42:15\n    |\n LL |     fn to_i32(self) {}\n@@ -79,7 +79,7 @@ LL |     pub fn is_i64(self) {}\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `to_*` usually take self by reference\n+error: methods with the following characteristics: (`to_*` and `self type is not Copy`) usually take self by reference\n   --> $DIR/wrong_self_convention.rs:49:19\n    |\n LL |     pub fn to_i64(self) {}\n@@ -119,14 +119,6 @@ LL |         fn is_i32(self) {}\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `to_*` usually take self by reference\n-  --> $DIR/wrong_self_convention.rs:102:19\n-   |\n-LL |         fn to_i32(self) {}\n-   |                   ^^^^\n-   |\n-   = help: consider choosing a less ambiguous name\n-\n error: methods called `from_*` usually take no self\n   --> $DIR/wrong_self_convention.rs:104:21\n    |\n@@ -159,14 +151,6 @@ LL |         fn is_i32(self);\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `to_*` usually take self by reference\n-  --> $DIR/wrong_self_convention.rs:126:19\n-   |\n-LL |         fn to_i32(self);\n-   |                   ^^^^\n-   |\n-   = help: consider choosing a less ambiguous name\n-\n error: methods called `from_*` usually take no self\n   --> $DIR/wrong_self_convention.rs:128:21\n    |\n@@ -191,5 +175,21 @@ LL |         fn from_i32(self);\n    |\n    = help: consider choosing a less ambiguous name\n \n+error: methods with the following characteristics: (`to_*` and `self type is  Copy`) usually take self by value\n+  --> $DIR/wrong_self_convention.rs:181:22\n+   |\n+LL |         fn to_u64_v2(&self) -> u64 {\n+   |                      ^^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n+\n+error: methods with the following characteristics: (`to_*` and `self type is not Copy`) usually take self by reference\n+  --> $DIR/wrong_self_convention.rs:190:19\n+   |\n+LL |         fn to_u64(self) -> u64 {\n+   |                   ^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n+\n error: aborting due to 24 previous errors\n "}, {"sha": "8095188758c3eee2f3897f50cd9bc78b699fc8a4", "filename": "tests/ui/wrong_self_conventions_mut.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea15fb2177b0c33352363c130bc296a0dd1a794a/tests%2Fui%2Fwrong_self_conventions_mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea15fb2177b0c33352363c130bc296a0dd1a794a/tests%2Fui%2Fwrong_self_conventions_mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrong_self_conventions_mut.stderr?ref=ea15fb2177b0c33352363c130bc296a0dd1a794a", "patch": "@@ -1,4 +1,4 @@\n-error: methods called `to_*` usually take self by reference\n+error: methods with the following characteristics: (`to_*` and `self type is not Copy`) usually take self by reference\n   --> $DIR/wrong_self_conventions_mut.rs:15:24\n    |\n LL |         pub fn to_many(&mut self) -> Option<&mut [T]> {\n@@ -7,7 +7,7 @@ LL |         pub fn to_many(&mut self) -> Option<&mut [T]> {\n    = note: `-D clippy::wrong-self-convention` implied by `-D warnings`\n    = help: consider choosing a less ambiguous name\n \n-error: methods called like this: (`to_*` and `*_mut`) usually take self by mutable reference\n+error: methods with the following characteristics: (`to_*` and `*_mut`) usually take self by mutable reference\n   --> $DIR/wrong_self_conventions_mut.rs:23:28\n    |\n LL |         pub fn to_many_mut(&self) -> Option<&[T]> {"}]}