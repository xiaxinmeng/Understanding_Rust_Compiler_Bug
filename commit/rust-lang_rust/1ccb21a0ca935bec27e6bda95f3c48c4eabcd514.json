{"sha": "1ccb21a0ca935bec27e6bda95f3c48c4eabcd514", "node_id": "C_kwDOAAsO6NoAKDFjY2IyMWEwY2E5MzViZWMyN2U2YmRhOTVmM2M0OGM0ZWFiY2Q1MTQ", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-09-25T16:39:43Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-09-25T16:39:43Z"}, "message": "feat: Implement inline callers assist", "tree": {"sha": "4d4dbc854ab82e03bd4074e88042285173dd28d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d4dbc854ab82e03bd4074e88042285173dd28d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ccb21a0ca935bec27e6bda95f3c48c4eabcd514", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ccb21a0ca935bec27e6bda95f3c48c4eabcd514", "html_url": "https://github.com/rust-lang/rust/commit/1ccb21a0ca935bec27e6bda95f3c48c4eabcd514", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ccb21a0ca935bec27e6bda95f3c48c4eabcd514/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13da3d93f9be7200dda0635b0822e56b965194c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/13da3d93f9be7200dda0635b0822e56b965194c5", "html_url": "https://github.com/rust-lang/rust/commit/13da3d93f9be7200dda0635b0822e56b965194c5"}], "stats": {"total": 595, "additions": 455, "deletions": 140}, "files": [{"sha": "cc1de54dfb34b62810cd861f627f6e715dda793e", "filename": "crates/base_db/src/fixture.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1ccb21a0ca935bec27e6bda95f3c48c4eabcd514/crates%2Fbase_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ccb21a0ca935bec27e6bda95f3c48c4eabcd514/crates%2Fbase_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Ffixture.rs?ref=1ccb21a0ca935bec27e6bda95f3c48c4eabcd514", "patch": "@@ -161,7 +161,8 @@ impl ChangeFixture {\n         }\n \n         if crates.is_empty() {\n-            let crate_root = default_crate_root.unwrap();\n+            let crate_root = default_crate_root\n+                .expect(\"missing default crate root, specify a main.rs or lib.rs\");\n             crate_graph.add_crate_root(\n                 crate_root,\n                 Edition::CURRENT,"}, {"sha": "40231bd9480145382ba2315ac079bc85c7f670e7", "filename": "crates/ide_assists/src/handlers/inline_call.rs", "status": "modified", "additions": 415, "deletions": 139, "changes": 554, "blob_url": "https://github.com/rust-lang/rust/blob/1ccb21a0ca935bec27e6bda95f3c48c4eabcd514/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ccb21a0ca935bec27e6bda95f3c48c4eabcd514/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs?ref=1ccb21a0ca935bec27e6bda95f3c48c4eabcd514", "patch": "@@ -1,17 +1,146 @@\n use ast::make;\n-use hir::{HasSource, PathResolution, TypeInfo};\n-use ide_db::{defs::Definition, path_transform::PathTransform, search::FileReference};\n+use hir::{db::HirDatabase, HasSource, PathResolution, Semantics, TypeInfo};\n+use ide_db::{\n+    base_db::FileId, defs::Definition, path_transform::PathTransform, search::FileReference,\n+    RootDatabase,\n+};\n use itertools::izip;\n use syntax::{\n     ast::{self, edit_in_place::Indent, ArgListOwner},\n-    ted, AstNode,\n+    ted, AstNode, SyntaxNode,\n };\n \n use crate::{\n     assist_context::{AssistContext, Assists},\n     AssistId, AssistKind,\n };\n \n+// Assist: inline_into_callers\n+//\n+// Inline a function or method body into all of its callers where possible, creating a `let` statement per parameter\n+// unless the parameter can be inlined. The parameter will be inlined either if it the supplied argument is a simple local\n+// or if the parameter is only accessed inside the function body once.\n+// If all calls can be inlined the function will be removed.\n+//\n+// ```\n+// fn print(_: &str) {}\n+// fn foo$0(word: &str) {\n+//     if !word.is_empty() {\n+//         print(word);\n+//     }\n+// }\n+// fn bar() {\n+//     foo(\"\uc548\ub155\ud558\uc138\uc694\");\n+//     foo(\"\uc5ec\ub7ec\ubd84\");\n+// }\n+// ```\n+// ->\n+// ```\n+// fn print(_: &str) {}\n+//\n+// fn bar() {\n+//     {\n+//         let word = \"\uc548\ub155\ud558\uc138\uc694\";\n+//         if !word.is_empty() {\n+//             print(word);\n+//         }\n+//     };\n+//     {\n+//         let word = \"\uc5ec\ub7ec\ubd84\";\n+//         if !word.is_empty() {\n+//             print(word);\n+//         }\n+//     };\n+// }\n+// ```\n+pub(crate) fn inline_into_callers(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let name = ctx.find_node_at_offset::<ast::Name>()?;\n+    let func_syn = name.syntax().parent().and_then(ast::Fn::cast)?;\n+    let func_body = func_syn.body()?;\n+    let param_list = func_syn.param_list()?;\n+    let function = ctx.sema.to_def(&func_syn)?;\n+    let params = get_fn_params(ctx.sema.db, function, &param_list)?;\n+\n+    let usages = Definition::ModuleDef(hir::ModuleDef::Function(function)).usages(&ctx.sema);\n+    if !usages.at_least_one() {\n+        return None;\n+    }\n+\n+    acc.add(\n+        AssistId(\"inline_into_callers\", AssistKind::RefactorInline),\n+        \"Inline into all callers\",\n+        name.syntax().text_range(),\n+        |builder| {\n+            let def_file = ctx.frange.file_id;\n+            let usages =\n+                Definition::ModuleDef(hir::ModuleDef::Function(function)).usages(&ctx.sema);\n+            let mut usages = usages.all();\n+            let current_file_usage = usages.references.remove(&def_file);\n+\n+            let mut can_remove = true;\n+            let mut inline_refs = |file_id, refs: Vec<FileReference>| {\n+                builder.edit_file(file_id);\n+                let count = refs.len();\n+                let name_refs = refs.into_iter().filter_map(|file_ref| match file_ref.name {\n+                    ast::NameLike::NameRef(name_ref) => Some(name_ref),\n+                    _ => None,\n+                });\n+                let call_infos = name_refs.filter_map(|name_ref| {\n+                    let parent = name_ref.syntax().parent()?;\n+                    if let Some(call) = ast::MethodCallExpr::cast(parent.clone()) {\n+                        let receiver = call.receiver()?;\n+                        let mut arguments = vec![receiver];\n+                        arguments.extend(call.arg_list()?.args());\n+                        Some(CallInfo {\n+                            generic_arg_list: call.generic_arg_list(),\n+                            node: CallExprNode::MethodCallExpr(call),\n+                            arguments,\n+                        })\n+                    } else if let Some(segment) = ast::PathSegment::cast(parent) {\n+                        let path = segment.syntax().parent().and_then(ast::Path::cast)?;\n+                        let path = path.syntax().parent().and_then(ast::PathExpr::cast)?;\n+                        let call = path.syntax().parent().and_then(ast::CallExpr::cast)?;\n+\n+                        Some(CallInfo {\n+                            arguments: call.arg_list()?.args().collect(),\n+                            node: CallExprNode::Call(call),\n+                            generic_arg_list: segment.generic_arg_list(),\n+                        })\n+                    } else {\n+                        None\n+                    }\n+                });\n+                let replaced = call_infos\n+                    .map(|call_info| {\n+                        let replacement =\n+                            inline(&ctx.sema, def_file, function, &func_body, &params, &call_info);\n+\n+                        builder.replace_ast(\n+                            match call_info.node {\n+                                CallExprNode::Call(it) => ast::Expr::CallExpr(it),\n+                                CallExprNode::MethodCallExpr(it) => ast::Expr::MethodCallExpr(it),\n+                            },\n+                            replacement,\n+                        );\n+                    })\n+                    .count();\n+                can_remove &= replaced == count;\n+            };\n+            for (file_id, refs) in usages.into_iter() {\n+                inline_refs(file_id, refs);\n+            }\n+            if let Some(refs) = current_file_usage {\n+                inline_refs(def_file, refs);\n+            } else {\n+                builder.edit_file(def_file);\n+            }\n+            if can_remove {\n+                builder.delete(func_syn.syntax().text_range());\n+            }\n+        },\n+    )\n+}\n+\n // Assist: inline_call\n //\n // Inlines a function or method body creating a `let` statement per parameter unless the parameter\n@@ -34,8 +163,9 @@ use crate::{\n // }\n // ```\n pub(crate) fn inline_call(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let (label, function, arguments, generic_arg_list, expr) =\n+    let (label, function, call_info) =\n         if let Some(path_expr) = ctx.find_node_at_offset::<ast::PathExpr>() {\n+            // FIXME make applicable only on nameref\n             let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n             let path = path_expr.path()?;\n \n@@ -47,9 +177,11 @@ pub(crate) fn inline_call(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n             (\n                 format!(\"Inline `{}`\", path),\n                 function,\n-                call.arg_list()?.args().collect(),\n-                path.segment().and_then(|it| it.generic_arg_list()),\n-                ast::Expr::CallExpr(call),\n+                CallInfo {\n+                    arguments: call.arg_list()?.args().collect(),\n+                    node: CallExprNode::Call(call),\n+                    generic_arg_list: path.segment().and_then(|it| it.generic_arg_list()),\n+                },\n             )\n         } else {\n             let name_ref: ast::NameRef = ctx.find_node_at_offset()?;\n@@ -61,27 +193,73 @@ pub(crate) fn inline_call(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n             (\n                 format!(\"Inline `{}`\", name_ref),\n                 function,\n-                arguments,\n-                call.generic_arg_list(),\n-                ast::Expr::MethodCallExpr(call),\n+                CallInfo {\n+                    generic_arg_list: call.generic_arg_list(),\n+                    node: CallExprNode::MethodCallExpr(call),\n+                    arguments,\n+                },\n             )\n         };\n \n-    inline_(acc, ctx, label, function, arguments, expr, generic_arg_list)\n+    let hir::InFile { value: function_source, file_id } = function.source(ctx.db())?;\n+    let fn_body = function_source.body()?;\n+    let param_list = function_source.param_list()?;\n+\n+    let params = get_fn_params(ctx.sema.db, function, &param_list)?;\n+\n+    if call_info.arguments.len() != params.len() {\n+        // Can't inline the function because they've passed the wrong number of\n+        // arguments to this function\n+        cov_mark::hit!(inline_call_incorrect_number_of_arguments);\n+        return None;\n+    }\n+\n+    let syntax = call_info.node.syntax().clone();\n+    acc.add(\n+        AssistId(\"inline_call\", AssistKind::RefactorInline),\n+        label,\n+        syntax.text_range(),\n+        |builder| {\n+            let file_id = file_id.original_file(ctx.sema.db);\n+            let replacement = inline(&ctx.sema, file_id, function, &fn_body, &params, &call_info);\n+\n+            builder.replace_ast(\n+                match call_info.node {\n+                    CallExprNode::Call(it) => ast::Expr::CallExpr(it),\n+                    CallExprNode::MethodCallExpr(it) => ast::Expr::MethodCallExpr(it),\n+                },\n+                replacement,\n+            );\n+        },\n+    )\n }\n \n-pub(crate) fn inline_(\n-    acc: &mut Assists,\n-    ctx: &AssistContext,\n-    label: String,\n-    function: hir::Function,\n-    arg_list: Vec<ast::Expr>,\n-    expr: ast::Expr,\n+enum CallExprNode {\n+    Call(ast::CallExpr),\n+    MethodCallExpr(ast::MethodCallExpr),\n+}\n+\n+impl CallExprNode {\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            CallExprNode::Call(it) => it.syntax(),\n+            CallExprNode::MethodCallExpr(it) => it.syntax(),\n+        }\n+    }\n+}\n+\n+struct CallInfo {\n+    node: CallExprNode,\n+    arguments: Vec<ast::Expr>,\n     generic_arg_list: Option<ast::GenericArgList>,\n-) -> Option<()> {\n-    let hir::InFile { value: function_source, file_id } = function.source(ctx.db())?;\n-    let param_list = function_source.param_list()?;\n-    let mut assoc_fn_params = function.assoc_fn_params(ctx.sema.db).into_iter();\n+}\n+\n+fn get_fn_params(\n+    db: &dyn HirDatabase,\n+    function: hir::Function,\n+    param_list: &ast::ParamList,\n+) -> Option<Vec<(ast::Pat, Option<ast::Type>, hir::Param)>> {\n+    let mut assoc_fn_params = function.assoc_fn_params(db).into_iter();\n \n     let mut params = Vec::new();\n     if let Some(self_param) = param_list.self_param() {\n@@ -101,131 +279,116 @@ pub(crate) fn inline_(\n         params.push((param.pat()?, param.ty(), assoc_fn_params.next()?));\n     }\n \n-    if arg_list.len() != params.len() {\n-        // Can't inline the function because they've passed the wrong number of\n-        // arguments to this function\n-        cov_mark::hit!(inline_call_incorrect_number_of_arguments);\n-        return None;\n-    }\n-\n-    let fn_body = function_source.body()?;\n-\n-    acc.add(\n-        AssistId(\"inline_call\", AssistKind::RefactorInline),\n-        label,\n-        expr.syntax().text_range(),\n-        |builder| {\n-            let body = fn_body.clone_for_update();\n+    Some(params)\n+}\n \n-            let file_id = file_id.original_file(ctx.sema.db);\n-            let usages_for_locals = |local| {\n-                Definition::Local(local)\n-                    .usages(&ctx.sema)\n-                    .all()\n-                    .references\n-                    .remove(&file_id)\n-                    .unwrap_or_default()\n-                    .into_iter()\n-            };\n-            // Contains the nodes of usages of parameters.\n-            // If the inner Vec for a parameter is empty it either means there are no usages or that the parameter\n-            // has a pattern that does not allow inlining\n-            let param_use_nodes: Vec<Vec<_>> = params\n-                .iter()\n-                .map(|(pat, _, param)| {\n-                    if !matches!(pat, ast::Pat::IdentPat(pat) if pat.is_simple_ident()) {\n-                        return Vec::new();\n-                    }\n-                    usages_for_locals(param.as_local(ctx.sema.db))\n-                        .map(|FileReference { name, range, .. }| match name {\n-                            ast::NameLike::NameRef(_) => body\n-                                .syntax()\n-                                .covering_element(range)\n-                                .ancestors()\n-                                .nth(3)\n-                                .and_then(ast::PathExpr::cast),\n-                            _ => None,\n-                        })\n-                        .collect::<Option<Vec<_>>>()\n-                        .unwrap_or_default()\n-                })\n-                .collect();\n-\n-            // Rewrite `self` to `this`\n-            if param_list.self_param().is_some() {\n-                let this = || make::name_ref(\"this\").syntax().clone_for_update();\n-                usages_for_locals(params[0].2.as_local(ctx.sema.db))\n-                    .flat_map(|FileReference { name, range, .. }| match name {\n-                        ast::NameLike::NameRef(_) => Some(body.syntax().covering_element(range)),\n-                        _ => None,\n-                    })\n-                    .for_each(|it| {\n-                        ted::replace(it, &this());\n-                    })\n+fn inline(\n+    sema: &Semantics<RootDatabase>,\n+    function_def_file_id: FileId,\n+    function: hir::Function,\n+    fn_body: &ast::BlockExpr,\n+    params: &[(ast::Pat, Option<ast::Type>, hir::Param)],\n+    CallInfo { node, arguments, generic_arg_list }: &CallInfo,\n+) -> ast::Expr {\n+    let body = fn_body.clone_for_update();\n+    let usages_for_locals = |local| {\n+        Definition::Local(local)\n+            .usages(&sema)\n+            .all()\n+            .references\n+            .remove(&function_def_file_id)\n+            .unwrap_or_default()\n+            .into_iter()\n+    };\n+    let param_use_nodes: Vec<Vec<_>> = params\n+        .iter()\n+        .map(|(pat, _, param)| {\n+            if !matches!(pat, ast::Pat::IdentPat(pat) if pat.is_simple_ident()) {\n+                return Vec::new();\n             }\n-\n-            // Inline parameter expressions or generate `let` statements depending on whether inlining works or not.\n-            for ((pat, param_ty, _), usages, expr) in izip!(params, param_use_nodes, arg_list).rev()\n+            usages_for_locals(param.as_local(sema.db))\n+                .map(|FileReference { name, range, .. }| match name {\n+                    ast::NameLike::NameRef(_) => body\n+                        .syntax()\n+                        .covering_element(range)\n+                        .ancestors()\n+                        .nth(3)\n+                        .and_then(ast::PathExpr::cast),\n+                    _ => None,\n+                })\n+                .collect::<Option<Vec<_>>>()\n+                .unwrap_or_default()\n+        })\n+        .collect();\n+    if function.self_param(sema.db).is_some() {\n+        let this = || make::name_ref(\"this\").syntax().clone_for_update();\n+        usages_for_locals(params[0].2.as_local(sema.db))\n+            .flat_map(|FileReference { name, range, .. }| match name {\n+                ast::NameLike::NameRef(_) => Some(body.syntax().covering_element(range)),\n+                _ => None,\n+            })\n+            .for_each(|it| {\n+                ted::replace(it, &this());\n+            })\n+    }\n+    // Inline parameter expressions or generate `let` statements depending on whether inlining works or not.\n+    for ((pat, param_ty, _), usages, expr) in izip!(params, param_use_nodes, arguments).rev() {\n+        let expr_is_name_ref = matches!(&expr,\n+            ast::Expr::PathExpr(expr)\n+                if expr.path().and_then(|path| path.as_single_name_ref()).is_some()\n+        );\n+        match &*usages {\n+            // inline single use closure arguments\n+            [usage]\n+                if matches!(expr, ast::Expr::ClosureExpr(_))\n+                    && usage.syntax().parent().and_then(ast::Expr::cast).is_some() =>\n             {\n-                let expr_is_name_ref = matches!(&expr,\n-                    ast::Expr::PathExpr(expr)\n-                        if expr.path().and_then(|path| path.as_single_name_ref()).is_some()\n-                );\n-                match &*usages {\n-                    // inline single use closure arguments\n-                    [usage]\n-                        if matches!(expr, ast::Expr::ClosureExpr(_))\n-                            && usage.syntax().parent().and_then(ast::Expr::cast).is_some() =>\n-                    {\n-                        cov_mark::hit!(inline_call_inline_closure);\n-                        let expr = make::expr_paren(expr);\n-                        ted::replace(usage.syntax(), expr.syntax().clone_for_update());\n-                    }\n-                    // inline single use literals\n-                    [usage] if matches!(expr, ast::Expr::Literal(_)) => {\n-                        cov_mark::hit!(inline_call_inline_literal);\n-                        ted::replace(usage.syntax(), expr.syntax().clone_for_update());\n-                    }\n-                    // inline direct local arguments\n-                    [_, ..] if expr_is_name_ref => {\n-                        cov_mark::hit!(inline_call_inline_locals);\n-                        usages.into_iter().for_each(|usage| {\n-                            ted::replace(usage.syntax(), &expr.syntax().clone_for_update());\n-                        });\n-                    }\n-                    // cant inline, emit a let statement\n-                    _ => {\n-                        let ty = ctx\n-                            .sema\n-                            .type_of_expr(&expr)\n-                            .filter(TypeInfo::has_adjustment)\n-                            .and(param_ty);\n-                        body.push_front(\n-                            make::let_stmt(pat, ty, Some(expr)).clone_for_update().into(),\n-                        )\n-                    }\n-                }\n+                cov_mark::hit!(inline_call_inline_closure);\n+                let expr = make::expr_paren(expr.clone());\n+                ted::replace(usage.syntax(), expr.syntax().clone_for_update());\n+            }\n+            // inline single use literals\n+            [usage] if matches!(expr, ast::Expr::Literal(_)) => {\n+                cov_mark::hit!(inline_call_inline_literal);\n+                ted::replace(usage.syntax(), expr.syntax().clone_for_update());\n             }\n-            if let Some(generic_arg_list) = generic_arg_list {\n-                PathTransform::function_call(\n-                    &ctx.sema.scope(expr.syntax()),\n-                    &ctx.sema.scope(fn_body.syntax()),\n-                    function,\n-                    generic_arg_list,\n+            // inline direct local arguments\n+            [_, ..] if expr_is_name_ref => {\n+                cov_mark::hit!(inline_call_inline_locals);\n+                usages.into_iter().for_each(|usage| {\n+                    ted::replace(usage.syntax(), &expr.syntax().clone_for_update());\n+                });\n+            }\n+            // cant inline, emit a let statement\n+            _ => {\n+                let ty =\n+                    sema.type_of_expr(expr).filter(TypeInfo::has_adjustment).and(param_ty.clone());\n+                body.push_front(\n+                    make::let_stmt(pat.clone(), ty, Some(expr.clone())).clone_for_update().into(),\n                 )\n-                .apply(body.syntax());\n             }\n+        }\n+    }\n+    if let Some(generic_arg_list) = generic_arg_list.clone() {\n+        PathTransform::function_call(\n+            &sema.scope(node.syntax()),\n+            &sema.scope(fn_body.syntax()),\n+            function,\n+            generic_arg_list,\n+        )\n+        .apply(body.syntax());\n+    }\n \n-            let original_indentation = expr.indent_level();\n-            body.reindent_to(original_indentation);\n+    let original_indentation = match node {\n+        CallExprNode::Call(it) => it.indent_level(),\n+        CallExprNode::MethodCallExpr(it) => it.indent_level(),\n+    };\n+    body.reindent_to(original_indentation);\n \n-            let replacement = match body.tail_expr() {\n-                Some(expr) if body.statements().next().is_none() => expr,\n-                _ => ast::Expr::BlockExpr(body),\n-            };\n-            builder.replace_ast(expr, replacement);\n-        },\n-    )\n+    match body.tail_expr() {\n+        Some(expr) if body.statements().next().is_none() => expr,\n+        _ => ast::Expr::BlockExpr(body),\n+    }\n }\n \n #[cfg(test)]\n@@ -691,6 +854,119 @@ fn bar<U, const M: usize>() {}\n fn main() {\n     bar::<usize, N>();\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn inline_callers() {\n+        check_assist(\n+            inline_into_callers,\n+            r#\"\n+fn do_the_math$0(b: u32) -> u32 {\n+    let foo = 10;\n+    foo * b + foo\n+}\n+fn foo() {\n+    do_the_math(0);\n+    let bar = 10;\n+    do_the_math(bar);\n+}\n+\"#,\n+            r#\"\n+\n+fn foo() {\n+    {\n+        let foo = 10;\n+        foo * 0 + foo\n+    };\n+    let bar = 10;\n+    {\n+        let foo = 10;\n+        foo * bar + foo\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn inline_callers_across_files() {\n+        check_assist(\n+            inline_into_callers,\n+            r#\"\n+//- /lib.rs\n+mod foo;\n+fn do_the_math$0(b: u32) -> u32 {\n+    let foo = 10;\n+    foo * b + foo\n+}\n+//- /foo.rs\n+use super::do_the_math;\n+fn foo() {\n+    do_the_math(0);\n+    let bar = 10;\n+    do_the_math(bar);\n+}\n+\"#,\n+            r#\"\n+use super::do_the_math;\n+fn foo() {\n+    {\n+        let foo = 10;\n+        foo * 0 + foo\n+    };\n+    let bar = 10;\n+    {\n+        let foo = 10;\n+        foo * bar + foo\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn inline_callers_across_files_with_def_file() {\n+        check_assist(\n+            inline_into_callers,\n+            r#\"\n+//- /lib.rs\n+mod foo;\n+fn do_the_math$0(b: u32) -> u32 {\n+    let foo = 10;\n+    foo * b + foo\n+}\n+fn bar(a: u32, b: u32) -> u32 {\n+    do_the_math(0);\n+}\n+//- /foo.rs\n+use super::do_the_math;\n+fn foo() {\n+    do_the_math(0);\n+}\n+\"#,\n+            r#\"\n+//- /lib.rs\n+mod foo;\n+fn do_the_math(b: u32) -> u32 {\n+    let foo = 10;\n+    foo * b + foo\n+}\n+fn bar(a: u32, b: u32) -> u32 {\n+    {\n+        let foo = 10;\n+        foo * 0 + foo\n+    };\n+}\n+//- /foo.rs\n+use super::do_the_math;\n+fn foo() {\n+    {\n+        let foo = 10;\n+        foo * 0 + foo\n+    };\n+}\n \"#,\n         );\n     }"}, {"sha": "cad2a6d8530e4b3aee6dfab18d0ea92e595de857", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1ccb21a0ca935bec27e6bda95f3c48c4eabcd514/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ccb21a0ca935bec27e6bda95f3c48c4eabcd514/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=1ccb21a0ca935bec27e6bda95f3c48c4eabcd514", "patch": "@@ -216,6 +216,7 @@ mod handlers {\n             generate_is_empty_from_len::generate_is_empty_from_len,\n             generate_new::generate_new,\n             inline_call::inline_call,\n+            inline_call::inline_into_callers,\n             inline_local_variable::inline_local_variable,\n             introduce_named_generic::introduce_named_generic,\n             introduce_named_lifetime::introduce_named_lifetime,"}, {"sha": "8974b8099d0ea6d9ca15c4db3ae42197cdba7fd2", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1ccb21a0ca935bec27e6bda95f3c48c4eabcd514/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ccb21a0ca935bec27e6bda95f3c48c4eabcd514/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=1ccb21a0ca935bec27e6bda95f3c48c4eabcd514", "patch": "@@ -1051,6 +1051,43 @@ fn foo(name: Option<&str>) {\n     )\n }\n \n+#[test]\n+fn doctest_inline_into_callers() {\n+    check_doc_test(\n+        \"inline_into_callers\",\n+        r#####\"\n+fn print(_: &str) {}\n+fn foo$0(word: &str) {\n+    if !word.is_empty() {\n+        print(word);\n+    }\n+}\n+fn bar() {\n+    foo(\"\uc548\ub155\ud558\uc138\uc694\");\n+    foo(\"\uc5ec\ub7ec\ubd84\");\n+}\n+\"#####,\n+        r#####\"\n+fn print(_: &str) {}\n+\n+fn bar() {\n+    {\n+        let word = \"\uc548\ub155\ud558\uc138\uc694\";\n+        if !word.is_empty() {\n+            print(word);\n+        }\n+    };\n+    {\n+        let word = \"\uc5ec\ub7ec\ubd84\";\n+        if !word.is_empty() {\n+            print(word);\n+        }\n+    };\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_inline_local_variable() {\n     check_doc_test("}]}