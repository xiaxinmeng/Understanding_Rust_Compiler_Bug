{"sha": "3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmMmFlNDRiYTQzYTliNTkxZjg2YzFhNWQ5ZTBiOGI3MjBjZmEyMGE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-08T21:31:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-08T21:31:20Z"}, "message": "Rollup merge of #65081 - Mark-Simulacrum:remove-profile-queries, r=michaelwoerister\n\nRemove -Zprofile-queries\n\nr? @michaelwoerister\n\nPer [zulip thread](https://zulip-archive.rust-lang.org/131828tcompiler/57361RemoveZprofilequeries.html).", "tree": {"sha": "7699407e2c4ef645fc37ba9a320182eeedf3982f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7699407e2c4ef645fc37ba9a320182eeedf3982f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdnQApCRBK7hj4Ov3rIwAAdHIIAGZtAHwmKdInb+lG0JOa5751\nq8J8WisOfD//nWyMEBvFcSrS5brndhxb8/8bWsqrP5TWcwz4i9TxvYFsufeBHywQ\nWEv4Nd7HADBzYCm1m1sJoekak5e07fjLl+sIOpVe975o/6idT2s/3TgkqXNpRJRJ\n9vU9dokf9H1SXg+a+G0p5Cb0JpLQukx7pYUIwS6BNGp6K4u58CQ9kOvoPoZp5LiH\nLM3dIfMHj6hSS9QryyXj38WcilvihdWDgjkjmnCjEJlY8AGAgV0Iinz2IOV/ZSXo\n57KTGHQ9V3xNppHqEER4nQIkTmGh124Qk446T5EzR0U+zaQ/fwirHpV/8hcMiNE=\n=jdit\n-----END PGP SIGNATURE-----\n", "payload": "tree 7699407e2c4ef645fc37ba9a320182eeedf3982f\nparent fc068222d06ac3ff656c4c9ef2b98428c1c4537b\nparent e85089b63a2b67f4048da207b39cc265887e018f\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1570570280 +0200\ncommitter GitHub <noreply@github.com> 1570570280 +0200\n\nRollup merge of #65081 - Mark-Simulacrum:remove-profile-queries, r=michaelwoerister\n\nRemove -Zprofile-queries\n\nr? @michaelwoerister\n\nPer [zulip thread](https://zulip-archive.rust-lang.org/131828tcompiler/57361RemoveZprofilequeries.html).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a", "html_url": "https://github.com/rust-lang/rust/commit/3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc068222d06ac3ff656c4c9ef2b98428c1c4537b", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc068222d06ac3ff656c4c9ef2b98428c1c4537b", "html_url": "https://github.com/rust-lang/rust/commit/fc068222d06ac3ff656c4c9ef2b98428c1c4537b"}, {"sha": "e85089b63a2b67f4048da207b39cc265887e018f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e85089b63a2b67f4048da207b39cc265887e018f", "html_url": "https://github.com/rust-lang/rust/commit/e85089b63a2b67f4048da207b39cc265887e018f"}], "stats": {"total": 782, "additions": 11, "deletions": 771}, "files": [{"sha": "e0cb00cf697f4bcf83dcd6d0efcd1d956acea6b5", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a", "patch": "@@ -9,7 +9,6 @@ use std::hash::Hash;\n use std::collections::hash_map::Entry;\n use std::mem;\n use crate::ty::{self, TyCtxt};\n-use crate::util::common::{ProfileQueriesMsg, profq_msg};\n use parking_lot::{Mutex, Condvar};\n \n use crate::ich::{StableHashingContext, StableHashingContextProvider, Fingerprint};\n@@ -256,10 +255,6 @@ impl DepGraph {\n             //  - we can get an idea of the runtime cost.\n             let mut hcx = cx.get_stable_hashing_context();\n \n-            if cfg!(debug_assertions) {\n-                profq_msg(hcx.sess(), ProfileQueriesMsg::TaskBegin(key.clone()))\n-            };\n-\n             let result = if no_tcx {\n                 task(cx, arg)\n             } else {\n@@ -275,10 +270,6 @@ impl DepGraph {\n                 })\n             };\n \n-            if cfg!(debug_assertions) {\n-                profq_msg(hcx.sess(), ProfileQueriesMsg::TaskEnd)\n-            };\n-\n             let current_fingerprint = hash_result(&mut hcx, &result);\n \n             let dep_node_index = finish_task_and_alloc_depnode("}, {"sha": "4618a6277edffd538c97f8613389828d2fef3d2b", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a", "patch": "@@ -1316,10 +1316,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"dump the dependency graph to $RUST_DEP_GRAPH (default: /tmp/dep_graph.gv)\"),\n     query_dep_graph: bool = (false, parse_bool, [UNTRACKED],\n         \"enable queries of the dependency graph for regression testing\"),\n-    profile_queries: bool = (false, parse_bool, [UNTRACKED],\n-        \"trace and profile the queries of the incremental compilation framework\"),\n-    profile_queries_and_keys: bool = (false, parse_bool, [UNTRACKED],\n-        \"trace and profile the queries and keys of the incremental compilation framework\"),\n     no_analysis: bool = (false, parse_bool, [UNTRACKED],\n         \"parse and expand the source, but run no analysis\"),\n     extra_plugins: Vec<String> = (Vec::new(), parse_list, [TRACKED],"}, {"sha": "9d60221fa3d753a83acc72155a737a27ba5f444c", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a", "patch": "@@ -11,7 +11,6 @@ use crate::session::config::{OutputType, PrintRequest, SwitchWithOptPath};\n use crate::session::search_paths::{PathKind, SearchPath};\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n use crate::util::common::{duration_to_secs_str, ErrorReported};\n-use crate::util::common::ProfileQueriesMsg;\n \n use rustc_data_structures::base_n;\n use rustc_data_structures::sync::{\n@@ -46,7 +45,7 @@ use std::fmt;\n use std::io::Write;\n use std::path::PathBuf;\n use std::time::Duration;\n-use std::sync::{Arc, mpsc};\n+use std::sync::Arc;\n \n mod code_stats;\n pub mod config;\n@@ -125,9 +124,6 @@ pub struct Session {\n     /// `-Zquery-dep-graph` is specified.\n     pub cgu_reuse_tracker: CguReuseTracker,\n \n-    /// Used by `-Z profile-queries` in `util::common`.\n-    pub profile_channel: Lock<Option<mpsc::Sender<ProfileQueriesMsg>>>,\n-\n     /// Used by `-Z self-profile`.\n     pub prof: SelfProfilerRef,\n \n@@ -509,13 +505,6 @@ impl Session {\n     pub fn time_extended(&self) -> bool {\n         self.opts.debugging_opts.time_passes\n     }\n-    pub fn profile_queries(&self) -> bool {\n-        self.opts.debugging_opts.profile_queries\n-            || self.opts.debugging_opts.profile_queries_and_keys\n-    }\n-    pub fn profile_queries_and_keys(&self) -> bool {\n-        self.opts.debugging_opts.profile_queries_and_keys\n-    }\n     pub fn instrument_mcount(&self) -> bool {\n         self.opts.debugging_opts.instrument_mcount\n     }\n@@ -1234,7 +1223,6 @@ fn build_session_(\n         incr_comp_session: OneThread::new(RefCell::new(IncrCompSession::NotInitialized)),\n         cgu_reuse_tracker,\n         prof: SelfProfilerRef::new(self_profiler),\n-        profile_channel: Lock::new(None),\n         perf_stats: PerfStats {\n             symbol_hash_time: Lock::new(Duration::from_secs(0)),\n             decode_def_path_tables_time: Lock::new(Duration::from_secs(0)),"}, {"sha": "1bba7fdd863ea5653b64528319983a4986dfacd5", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a", "patch": "@@ -1075,7 +1075,7 @@ where\n     let desc = &format!(\"encode_query_results for {}\",\n         ::std::any::type_name::<Q>());\n \n-    time_ext(tcx.sess.time_extended(), Some(tcx.sess), desc, || {\n+    time_ext(tcx.sess.time_extended(), desc, || {\n         let shards = Q::query_cache(tcx).lock_shards();\n         assert!(shards.iter().all(|shard| shard.active.is_empty()));\n         for (key, entry) in shards.iter().flat_map(|shard| shard.results.iter()) {"}, {"sha": "7f05e553bc9765273d91dfd4f7157cad4873bf68", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a", "patch": "@@ -9,8 +9,6 @@ use crate::ty::query::Query;\n use crate::ty::query::config::{QueryConfig, QueryDescription};\n use crate::ty::query::job::{QueryJob, QueryResult, QueryInfo};\n \n-use crate::util::common::{profq_msg, ProfileQueriesMsg, QueryMsg};\n-\n use errors::DiagnosticBuilder;\n use errors::Level;\n use errors::Diagnostic;\n@@ -62,33 +60,6 @@ impl<'tcx, M: QueryConfig<'tcx>> Default for QueryCache<'tcx, M> {\n     }\n }\n \n-// If enabled, sends a message to the profile-queries thread.\n-macro_rules! profq_msg {\n-    ($tcx:expr, $msg:expr) => {\n-        if cfg!(debug_assertions) {\n-            if $tcx.sess.profile_queries() {\n-                profq_msg($tcx.sess, $msg)\n-            }\n-        }\n-    }\n-}\n-\n-// If enabled, formats a key using its debug string, which can be\n-// expensive to compute (in terms of time).\n-macro_rules! profq_query_msg {\n-    ($query:expr, $tcx:expr, $key:expr) => {{\n-        let msg = if cfg!(debug_assertions) {\n-            if $tcx.sess.profile_queries_and_keys() {\n-                Some(format!(\"{:?}\", $key))\n-            } else { None }\n-        } else { None };\n-        QueryMsg {\n-            query: $query,\n-            msg,\n-        }\n-    }}\n-}\n-\n /// A type representing the responsibility to execute the job in the `job` field.\n /// This will poison the relevant query if dropped.\n pub(super) struct JobOwner<'a, 'tcx, Q: QueryDescription<'tcx>> {\n@@ -111,7 +82,6 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n         loop {\n             let mut lock = cache.get_shard_by_value(key).lock();\n             if let Some(value) = lock.results.get(key) {\n-                profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n                 tcx.prof.query_cache_hit(Q::NAME);\n                 let result = (value.value.clone(), value.index);\n                 #[cfg(debug_assertions)]\n@@ -358,13 +328,6 @@ impl<'tcx> TyCtxt<'tcx> {\n                key,\n                span);\n \n-        profq_msg!(self,\n-            ProfileQueriesMsg::QueryBegin(\n-                span.data(),\n-                profq_query_msg!(Q::NAME.as_str(), self, key),\n-            )\n-        );\n-\n         let job = match JobOwner::try_get(self, span, &key) {\n             TryGetJob::NotYetStarted(job) => job,\n             TryGetJob::Cycle(result) => return result,\n@@ -383,7 +346,6 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         if Q::ANON {\n \n-            profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n             let prof_timer = self.prof.query_provider(Q::NAME);\n \n             let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n@@ -395,7 +357,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             });\n \n             drop(prof_timer);\n-            profq_msg!(self, ProfileQueriesMsg::ProviderEnd);\n \n             self.dep_graph.read_index(dep_node_index);\n \n@@ -468,7 +429,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         };\n \n         let result = if let Some(result) = result {\n-            profq_msg!(self, ProfileQueriesMsg::CacheHit);\n             result\n         } else {\n             // We could not load a result from the on-disk cache, so\n@@ -542,7 +502,6 @@ impl<'tcx> TyCtxt<'tcx> {\n                  - dep-node: {:?}\",\n                 key, dep_node);\n \n-        profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n         let prof_timer = self.prof.query_provider(Q::NAME);\n \n         let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n@@ -564,7 +523,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         });\n \n         drop(prof_timer);\n-        profq_msg!(self, ProfileQueriesMsg::ProviderEnd);\n \n         if unlikely!(!diagnostics.is_empty()) {\n             if dep_node.kind != crate::dep_graph::DepKind::Null {\n@@ -606,19 +564,12 @@ impl<'tcx> TyCtxt<'tcx> {\n \n             let _ = self.get_query::<Q>(DUMMY_SP, key);\n         } else {\n-            profq_msg!(self, ProfileQueriesMsg::CacheHit);\n             self.prof.query_cache_hit(Q::NAME);\n         }\n     }\n \n     #[allow(dead_code)]\n     fn force_query<Q: QueryDescription<'tcx>>(self, key: Q::Key, span: Span, dep_node: DepNode) {\n-        profq_msg!(\n-            self,\n-            ProfileQueriesMsg::QueryBegin(span.data(),\n-                                          profq_query_msg!(Q::NAME.as_str(), self, key))\n-        );\n-\n         // We may be concurrently trying both execute and force a query.\n         // Ensure that only one of them runs the query.\n         let job = match JobOwner::try_get(self, span, &key) {"}, {"sha": "3e52a6aa50850c12901e0f9b8c5cac6e418a5374", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 73, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a", "patch": "@@ -6,11 +6,8 @@ use std::cell::Cell;\n use std::fmt::Debug;\n use std::time::{Duration, Instant};\n \n-use std::sync::mpsc::{Sender};\n-use syntax_pos::{SpanData};\n use syntax::symbol::{Symbol, sym};\n use rustc_macros::HashStable;\n-use crate::dep_graph::{DepNode};\n use crate::session::Session;\n \n #[cfg(test)]\n@@ -26,71 +23,13 @@ pub struct ErrorReported;\n \n thread_local!(static TIME_DEPTH: Cell<usize> = Cell::new(0));\n \n-/// Parameters to the `Dump` variant of type `ProfileQueriesMsg`.\n-#[derive(Clone,Debug)]\n-pub struct ProfQDumpParams {\n-    /// A base path for the files we will dump.\n-    pub path:String,\n-    /// To ensure that the compiler waits for us to finish our dumps.\n-    pub ack:Sender<()>,\n-    /// Toggle dumping a log file with every `ProfileQueriesMsg`.\n-    pub dump_profq_msg_log:bool,\n-}\n-\n #[allow(nonstandard_style)]\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct QueryMsg {\n     pub query: &'static str,\n     pub msg: Option<String>,\n }\n \n-/// A sequence of these messages induce a trace of query-based incremental compilation.\n-// FIXME(matthewhammer): Determine whether we should include cycle detection here or not.\n-#[derive(Clone,Debug)]\n-pub enum ProfileQueriesMsg {\n-    /// Begin a timed pass.\n-    TimeBegin(String),\n-    /// End a timed pass.\n-    TimeEnd,\n-    /// Begin a task (see `dep_graph::graph::with_task`).\n-    TaskBegin(DepNode),\n-    /// End a task.\n-    TaskEnd,\n-    /// Begin a new query.\n-    /// Cannot use `Span` because queries are sent to other thread.\n-    QueryBegin(SpanData, QueryMsg),\n-    /// Query is satisfied by using an already-known value for the given key.\n-    CacheHit,\n-    /// Query requires running a provider; providers may nest, permitting queries to nest.\n-    ProviderBegin,\n-    /// Query is satisfied by a provider terminating with a value.\n-    ProviderEnd,\n-    /// Dump a record of the queries to the given path.\n-    Dump(ProfQDumpParams),\n-    /// Halt the profiling/monitoring background thread.\n-    Halt\n-}\n-\n-/// If enabled, send a message to the profile-queries thread.\n-pub fn profq_msg(sess: &Session, msg: ProfileQueriesMsg) {\n-    if let Some(s) = sess.profile_channel.borrow().as_ref() {\n-        s.send(msg).unwrap()\n-    } else {\n-        // Do nothing.\n-    }\n-}\n-\n-/// Set channel for profile queries channel.\n-pub fn profq_set_chan(sess: &Session, s: Sender<ProfileQueriesMsg>) -> bool {\n-    let mut channel = sess.profile_channel.borrow_mut();\n-    if channel.is_none() {\n-        *channel = Some(s);\n-        true\n-    } else {\n-        false\n-    }\n-}\n-\n /// Read the current depth of `time()` calls. This is used to\n /// encourage indentation across threads.\n pub fn time_depth() -> usize {\n@@ -107,10 +46,10 @@ pub fn set_time_depth(depth: usize) {\n pub fn time<T, F>(sess: &Session, what: &str, f: F) -> T where\n     F: FnOnce() -> T,\n {\n-    time_ext(sess.time_passes(), Some(sess), what, f)\n+    time_ext(sess.time_passes(), what, f)\n }\n \n-pub fn time_ext<T, F>(do_it: bool, sess: Option<&Session>, what: &str, f: F) -> T where\n+pub fn time_ext<T, F>(do_it: bool, what: &str, f: F) -> T where\n     F: FnOnce() -> T,\n {\n     if !do_it { return f(); }\n@@ -121,19 +60,9 @@ pub fn time_ext<T, F>(do_it: bool, sess: Option<&Session>, what: &str, f: F) ->\n         r\n     });\n \n-    if let Some(sess) = sess {\n-        if cfg!(debug_assertions) {\n-            profq_msg(sess, ProfileQueriesMsg::TimeBegin(what.to_string()))\n-        }\n-    }\n     let start = Instant::now();\n     let rv = f();\n     let dur = start.elapsed();\n-    if let Some(sess) = sess {\n-        if cfg!(debug_assertions) {\n-            profq_msg(sess, ProfileQueriesMsg::TimeEnd)\n-        }\n-    }\n \n     print_time_passes_entry(true, what, dur);\n "}, {"sha": "7437b1e3c8a32e2f7c31599d57a117fd86015de7", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a", "patch": "@@ -116,7 +116,7 @@ fn prepare_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n                 info!(\"adding bytecode {}\", name);\n                 let bc_encoded = data.data();\n \n-                let (bc, id) = time_ext(cgcx.time_passes, None, &format!(\"decode {}\", name), || {\n+                let (bc, id) = time_ext(cgcx.time_passes, &format!(\"decode {}\", name), || {\n                     match DecodedBytecode::new(bc_encoded) {\n                         Ok(b) => Ok((b.bytecode(), b.identifier().to_string())),\n                         Err(e) => Err(diag_handler.fatal(&e)),\n@@ -295,7 +295,7 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         for (bc_decoded, name) in serialized_modules {\n             let _timer = cgcx.prof.generic_activity(\"LLVM_fat_lto_link_module\");\n             info!(\"linking {:?}\", name);\n-            time_ext(cgcx.time_passes, None, &format!(\"ll link {:?}\", name), || {\n+            time_ext(cgcx.time_passes, &format!(\"ll link {:?}\", name), || {\n                 let data = bc_decoded.data();\n                 linker.add(&data).map_err(|()| {\n                     let msg = format!(\"failed to load bc of {:?}\", name);\n@@ -590,7 +590,7 @@ pub(crate) fn run_pass_manager(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             llvm::LLVMRustAddPass(pm, pass.unwrap());\n         }\n \n-        time_ext(cgcx.time_passes, None, \"LTO passes\", ||\n+        time_ext(cgcx.time_passes, \"LTO passes\", ||\n              llvm::LLVMRunPassManager(pm, module.module_llvm.llmod()));\n \n         llvm::LLVMDisposePassManager(pm);"}, {"sha": "52f3a1cbb5c30b06959ddd66d120f79557fe2b4a", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a", "patch": "@@ -427,7 +427,6 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         {\n             let _timer = cgcx.prof.generic_activity(\"LLVM_module_optimize_function_passes\");\n             time_ext(config.time_passes,\n-                        None,\n                         &format!(\"llvm function passes [{}]\", module_name.unwrap()),\n                         || {\n                 llvm::LLVMRustRunFunctionPassManager(fpm, llmod)\n@@ -436,7 +435,6 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         {\n             let _timer = cgcx.prof.generic_activity(\"LLVM_module_optimize_module_passes\");\n             time_ext(config.time_passes,\n-                    None,\n                     &format!(\"llvm module passes [{}]\", module_name.unwrap()),\n                     || {\n                 llvm::LLVMRunPassManager(mpm, llmod)\n@@ -538,7 +536,7 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             embed_bitcode(cgcx, llcx, llmod, None);\n         }\n \n-        time_ext(config.time_passes, None, &format!(\"codegen passes [{}]\", module_name.unwrap()),\n+        time_ext(config.time_passes, &format!(\"codegen passes [{}]\", module_name.unwrap()),\n             || -> Result<(), FatalError> {\n             if config.emit_ir {\n                 let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_ir\");"}, {"sha": "1c5d3b1a890ee76dfcfcd60966208b55aeed3bfe", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a", "patch": "@@ -1535,7 +1535,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n         let name = cratepath.file_name().unwrap().to_str().unwrap();\n         let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n \n-        time_ext(sess.time_extended(), Some(sess), &format!(\"altering {}.rlib\", name), || {\n+        time_ext(sess.time_extended(), &format!(\"altering {}.rlib\", name), || {\n             let mut archive = <B as ArchiveBuilder>::new(sess, &dst, Some(cratepath));\n             archive.update_symbols();\n "}, {"sha": "b7f4df62b494b637ee266acf3d4fa856163af937", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a", "patch": "@@ -160,7 +160,7 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n     }\n \n     MaybeAsync::Async(std::thread::spawn(move || {\n-        time_ext(time_passes, None, \"background load prev dep-graph\", move || {\n+        time_ext(time_passes, \"background load prev dep-graph\", move || {\n             match load_data(report_incremental_info, &path) {\n                 LoadResult::DataOutOfDate => LoadResult::DataOutOfDate,\n                 LoadResult::Error { message } => LoadResult::Error { message },"}, {"sha": "b26bd75c974c6b67edae5cdc985ab475cf77d484", "filename": "src/librustc_interface/interface.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a", "patch": "@@ -1,6 +1,5 @@\n use crate::queries::Queries;\n use crate::util;\n-use crate::profile;\n pub use crate::passes::BoxedResolver;\n \n use rustc::lint;\n@@ -115,17 +114,7 @@ where\n         compiler.sess.diagnostic().print_error_count(&util::diagnostics_registry());\n     });\n \n-    if compiler.sess.profile_queries() {\n-        profile::begin(&compiler.sess);\n-    }\n-\n-    let r = f(&compiler);\n-\n-    if compiler.sess.profile_queries() {\n-        profile::dump(&compiler.sess, \"profile_queries\".to_string())\n-    }\n-\n-    r\n+    f(&compiler)\n }\n \n pub fn run_compiler<F, R>(mut config: Config, f: F) -> R"}, {"sha": "6be36e9b9001b80d608950547b3b07a7f7b865ad", "filename": "src/librustc_interface/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a/src%2Flibrustc_interface%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a/src%2Flibrustc_interface%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Flib.rs?ref=3f2ae44ba43a9b591f86c1a5d9e0b8b720cfa20a", "patch": "@@ -16,6 +16,5 @@ mod passes;\n mod queries;\n pub mod util;\n mod proc_macro_decls;\n-mod profile;\n \n pub use interface::{run_compiler, Config};"}, {"sha": "2e71d46f4154c6384c5f1a0768df2761b0ba0be6", "filename": "src/librustc_interface/profile/mod.rs", "status": "removed", "additions": 0, "deletions": 297, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/fc068222d06ac3ff656c4c9ef2b98428c1c4537b/src%2Flibrustc_interface%2Fprofile%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc068222d06ac3ff656c4c9ef2b98428c1c4537b/src%2Flibrustc_interface%2Fprofile%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fprofile%2Fmod.rs?ref=fc068222d06ac3ff656c4c9ef2b98428c1c4537b", "patch": "@@ -1,297 +0,0 @@\n-use log::debug;\n-use rustc::dep_graph::DepNode;\n-use rustc::session::Session;\n-use rustc::util::common::{ProfQDumpParams, ProfileQueriesMsg, profq_msg, profq_set_chan};\n-use std::sync::mpsc::{Receiver};\n-use std::io::{Write};\n-use std::time::{Duration, Instant};\n-\n-pub mod trace;\n-\n-/// begin a profile thread, if not already running\n-pub fn begin(sess: &Session) {\n-    use std::thread;\n-    use std::sync::mpsc::{channel};\n-    let (tx, rx) = channel();\n-    if profq_set_chan(sess, tx) {\n-        thread::spawn(move || profile_queries_thread(rx));\n-    }\n-}\n-\n-/// dump files with profiling information to the given base path, and\n-/// wait for this dump to complete.\n-///\n-/// wraps the RPC (send/recv channel logic) of requesting a dump.\n-pub fn dump(sess: &Session, path: String) {\n-    use std::sync::mpsc::{channel};\n-    let (tx, rx) = channel();\n-    let params = ProfQDumpParams {\n-        path,\n-        ack: tx,\n-        // FIXME: Add another compiler flag to toggle whether this log\n-        // is written; false for now\n-        dump_profq_msg_log: true,\n-    };\n-    profq_msg(sess, ProfileQueriesMsg::Dump(params));\n-    let _ = rx.recv().unwrap();\n-}\n-\n-// State for parsing recursive trace structure in separate thread, via messages\n-#[derive(Clone, Eq, PartialEq)]\n-enum ParseState {\n-    // No (local) parse state; may be parsing a tree, focused on a\n-    // sub-tree that could be anything.\n-    Clear,\n-    // Have Query information from the last message\n-    HaveQuery(trace::Query, Instant),\n-    // Have \"time-begin\" information from the last message (doit flag, and message)\n-    HaveTimeBegin(String, Instant),\n-    // Have \"task-begin\" information from the last message\n-    HaveTaskBegin(DepNode, Instant),\n-}\n-struct StackFrame {\n-    pub parse_st: ParseState,\n-    pub traces:   Vec<trace::Rec>,\n-}\n-\n-fn total_duration(traces: &[trace::Rec]) -> Duration {\n-    Duration::new(0, 0) + traces.iter().map(|t| t.dur_total).sum()\n-}\n-\n-// profiling thread; retains state (in local variables) and dump traces, upon request.\n-fn profile_queries_thread(r: Receiver<ProfileQueriesMsg>) {\n-    use self::trace::*;\n-    use std::fs::File;\n-\n-    let mut profq_msgs: Vec<ProfileQueriesMsg> = vec![];\n-    let mut frame: StackFrame = StackFrame { parse_st: ParseState::Clear, traces: vec![] };\n-    let mut stack: Vec<StackFrame> = vec![];\n-    loop {\n-        let msg = r.recv();\n-        if let Err(_recv_err) = msg {\n-            // FIXME: Perhaps do something smarter than simply quitting?\n-            break\n-        };\n-        let msg = msg.unwrap();\n-        debug!(\"profile_queries_thread: {:?}\", msg);\n-\n-        // Meta-level versus _actual_ queries messages\n-        match msg {\n-            ProfileQueriesMsg::Halt => return,\n-            ProfileQueriesMsg::Dump(params) => {\n-                assert!(stack.is_empty());\n-                assert!(frame.parse_st == ParseState::Clear);\n-\n-                // write log of all messages\n-                if params.dump_profq_msg_log {\n-                    let mut log_file =\n-                        File::create(format!(\"{}.log.txt\", params.path)).unwrap();\n-                    for m in profq_msgs.iter() {\n-                        writeln!(&mut log_file, \"{:?}\", m).unwrap()\n-                    };\n-                }\n-\n-                // write HTML file, and counts file\n-                let html_path = format!(\"{}.html\", params.path);\n-                let mut html_file = File::create(&html_path).unwrap();\n-\n-                let counts_path = format!(\"{}.counts.txt\", params.path);\n-                let mut counts_file = File::create(&counts_path).unwrap();\n-\n-                writeln!(html_file,\n-                    \"<html>\\n<head>\\n<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{}\\\">\",\n-                    \"profile_queries.css\").unwrap();\n-                writeln!(html_file, \"<style>\").unwrap();\n-                trace::write_style(&mut html_file);\n-                writeln!(html_file, \"</style>\\n</head>\\n<body>\").unwrap();\n-                trace::write_traces(&mut html_file, &mut counts_file, &frame.traces);\n-                writeln!(html_file, \"</body>\\n</html>\").unwrap();\n-\n-                let ack_path = format!(\"{}.ack\", params.path);\n-                let ack_file = File::create(&ack_path).unwrap();\n-                drop(ack_file);\n-\n-                // Tell main thread that we are done, e.g., so it can exit\n-                params.ack.send(()).unwrap();\n-            }\n-            // Actual query message:\n-            msg => {\n-                // Record msg in our log\n-                profq_msgs.push(msg.clone());\n-                // Respond to the message, knowing that we've already handled Halt and Dump, above.\n-                match (frame.parse_st.clone(), msg) {\n-                    (_, ProfileQueriesMsg::Halt) | (_, ProfileQueriesMsg::Dump(_)) => {\n-                        unreachable!();\n-                    },\n-                    // Parse State: Clear\n-                    (ParseState::Clear,\n-                     ProfileQueriesMsg::QueryBegin(span, querymsg)) => {\n-                        let start = Instant::now();\n-                        frame.parse_st = ParseState::HaveQuery\n-                            (Query { span, msg: querymsg }, start)\n-                    },\n-                    (ParseState::Clear,\n-                     ProfileQueriesMsg::CacheHit) => {\n-                        panic!(\"parse error: unexpected CacheHit; expected QueryBegin\")\n-                    },\n-                    (ParseState::Clear,\n-                     ProfileQueriesMsg::ProviderBegin) => {\n-                        panic!(\"parse error: expected QueryBegin before beginning a provider\")\n-                    },\n-                    (ParseState::Clear,\n-                     ProfileQueriesMsg::ProviderEnd) => {\n-                        let provider_extent = frame.traces;\n-                        match stack.pop() {\n-                            None =>\n-                                panic!(\"parse error: expected a stack frame; found an empty stack\"),\n-                            Some(old_frame) => {\n-                                match old_frame.parse_st {\n-                                    ParseState::HaveQuery(q, start) => {\n-                                        let duration = start.elapsed();\n-                                        frame = StackFrame{\n-                                            parse_st: ParseState::Clear,\n-                                            traces: old_frame.traces\n-                                        };\n-                                        let dur_extent = total_duration(&provider_extent);\n-                                        let trace = Rec {\n-                                            effect: Effect::QueryBegin(q, CacheCase::Miss),\n-                                            extent: Box::new(provider_extent),\n-                                            start: start,\n-                                            dur_self: duration - dur_extent,\n-                                            dur_total: duration,\n-                                        };\n-                                        frame.traces.push( trace );\n-                                    },\n-                                    _ => panic!(\"internal parse error: malformed parse stack\")\n-                                }\n-                            }\n-                        }\n-                    },\n-                    (ParseState::Clear,\n-                     ProfileQueriesMsg::TimeBegin(msg)) => {\n-                        let start = Instant::now();\n-                        frame.parse_st = ParseState::HaveTimeBegin(msg, start);\n-                        stack.push(frame);\n-                        frame = StackFrame{parse_st: ParseState::Clear, traces: vec![]};\n-                    },\n-                    (_, ProfileQueriesMsg::TimeBegin(_)) => {\n-                        panic!(\"parse error; did not expect time begin here\");\n-                    },\n-                    (ParseState::Clear,\n-                     ProfileQueriesMsg::TimeEnd) => {\n-                        let provider_extent = frame.traces;\n-                        match stack.pop() {\n-                            None =>\n-                                panic!(\"parse error: expected a stack frame; found an empty stack\"),\n-                            Some(old_frame) => {\n-                                match old_frame.parse_st {\n-                                    ParseState::HaveTimeBegin(msg, start) => {\n-                                        let duration = start.elapsed();\n-                                        frame = StackFrame{\n-                                            parse_st: ParseState::Clear,\n-                                            traces: old_frame.traces\n-                                        };\n-                                        let dur_extent = total_duration(&provider_extent);\n-                                        let trace = Rec {\n-                                            effect: Effect::TimeBegin(msg),\n-                                            extent: Box::new(provider_extent),\n-                                            start: start,\n-                                            dur_total: duration,\n-                                            dur_self: duration - dur_extent,\n-                                        };\n-                                        frame.traces.push( trace );\n-                                    },\n-                                    _ => panic!(\"internal parse error: malformed parse stack\")\n-                                }\n-                            }\n-                        }\n-                    },\n-                    (_, ProfileQueriesMsg::TimeEnd) => {\n-                        panic!(\"parse error\")\n-                    },\n-                    (ParseState::Clear,\n-                     ProfileQueriesMsg::TaskBegin(key)) => {\n-                        let start = Instant::now();\n-                        frame.parse_st = ParseState::HaveTaskBegin(key, start);\n-                        stack.push(frame);\n-                        frame = StackFrame{ parse_st: ParseState::Clear, traces: vec![] };\n-                    },\n-                    (_, ProfileQueriesMsg::TaskBegin(_)) => {\n-                        panic!(\"parse error; did not expect time begin here\");\n-                    },\n-                    (ParseState::Clear,\n-                     ProfileQueriesMsg::TaskEnd) => {\n-                        let provider_extent = frame.traces;\n-                        match stack.pop() {\n-                            None =>\n-                                panic!(\"parse error: expected a stack frame; found an empty stack\"),\n-                            Some(old_frame) => {\n-                                match old_frame.parse_st {\n-                                    ParseState::HaveTaskBegin(key, start) => {\n-                                        let duration = start.elapsed();\n-                                        frame = StackFrame{\n-                                            parse_st: ParseState::Clear,\n-                                            traces: old_frame.traces\n-                                        };\n-                                        let dur_extent = total_duration(&provider_extent);\n-                                        let trace = Rec {\n-                                            effect: Effect::TaskBegin(key),\n-                                            extent: Box::new(provider_extent),\n-                                            start: start,\n-                                            dur_total: duration,\n-                                            dur_self: duration - dur_extent,\n-                                        };\n-                                        frame.traces.push( trace );\n-                                    },\n-                                    _ => panic!(\"internal parse error: malformed parse stack\")\n-                                }\n-                            }\n-                        }\n-                    },\n-                    (_, ProfileQueriesMsg::TaskEnd) => {\n-                        panic!(\"parse error\")\n-                    },\n-                    // Parse State: HaveQuery\n-                    (ParseState::HaveQuery(q,start),\n-                     ProfileQueriesMsg::CacheHit) => {\n-                        let duration = start.elapsed();\n-                        let trace : Rec = Rec{\n-                            effect: Effect::QueryBegin(q, CacheCase::Hit),\n-                            extent: Box::new(vec![]),\n-                            start: start,\n-                            dur_self: duration,\n-                            dur_total: duration,\n-                        };\n-                        frame.traces.push( trace );\n-                        frame.parse_st = ParseState::Clear;\n-                    },\n-                    (ParseState::HaveQuery(_, _),\n-                     ProfileQueriesMsg::ProviderBegin) => {\n-                        stack.push(frame);\n-                        frame = StackFrame{ parse_st: ParseState::Clear, traces: vec![] };\n-                    },\n-\n-                    // Parse errors:\n-\n-                    (ParseState::HaveQuery(q, _),\n-                     ProfileQueriesMsg::ProviderEnd) => {\n-                        panic!(\"parse error: unexpected ProviderEnd; \\\n-                                expected something else to follow BeginQuery for {:?}\", q)\n-                    },\n-                    (ParseState::HaveQuery(q1, _),\n-                     ProfileQueriesMsg::QueryBegin(span2, querymsg2)) => {\n-                        panic!(\"parse error: unexpected QueryBegin; \\\n-                                earlier query is unfinished: {:?} and now {:?}\",\n-                               q1, Query{span:span2, msg: querymsg2})\n-                    },\n-                    (ParseState::HaveTimeBegin(_, _), _) => {\n-                        unreachable!()\n-                    },\n-                    (ParseState::HaveTaskBegin(_, _), _) => {\n-                        unreachable!()\n-                    },\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "95c4ea6ff23478ffd6868c06238be7d7e94d5190", "filename": "src/librustc_interface/profile/trace.rs", "status": "removed", "additions": 0, "deletions": 304, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/fc068222d06ac3ff656c4c9ef2b98428c1c4537b/src%2Flibrustc_interface%2Fprofile%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc068222d06ac3ff656c4c9ef2b98428c1c4537b/src%2Flibrustc_interface%2Fprofile%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fprofile%2Ftrace.rs?ref=fc068222d06ac3ff656c4c9ef2b98428c1c4537b", "patch": "@@ -1,304 +0,0 @@\n-use super::*;\n-use syntax_pos::SpanData;\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc::util::common::QueryMsg;\n-use std::fs::File;\n-use std::time::{Duration, Instant};\n-use rustc::dep_graph::{DepNode};\n-\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub struct Query {\n-    pub span: SpanData,\n-    pub msg: QueryMsg,\n-}\n-pub enum Effect {\n-    QueryBegin(Query, CacheCase),\n-    TimeBegin(String),\n-    TaskBegin(DepNode),\n-}\n-pub enum CacheCase {\n-    Hit, Miss\n-}\n-/// Recursive trace structure\n-pub struct Rec {\n-    pub effect: Effect,\n-    pub start: Instant,\n-    pub dur_self: Duration,\n-    pub dur_total: Duration,\n-    pub extent: Box<Vec<Rec>>,\n-}\n-pub struct QueryMetric {\n-    pub count: usize,\n-    pub dur_self: Duration,\n-    pub dur_total: Duration,\n-}\n-\n-fn cons(s: &str) -> String {\n-    let first = s.split(|d| d == '(' || d == '{').next();\n-    assert!(first.is_some() && first != Some(\"\"));\n-    first.unwrap().to_owned()\n-}\n-\n-pub fn cons_of_query_msg(q: &trace::Query) -> String {\n-    cons(&format!(\"{:?}\", q.msg))\n-}\n-\n-pub fn cons_of_key(k: &DepNode) -> String {\n-    cons(&format!(\"{:?}\", k))\n-}\n-\n-// First return value is text; second return value is a CSS class\n-pub fn html_of_effect(eff: &Effect) -> (String, String) {\n-    match *eff {\n-        Effect::TimeBegin(ref msg) => {\n-            (msg.clone(),\n-             \"time-begin\".to_string())\n-        },\n-        Effect::TaskBegin(ref key) => {\n-            let cons = cons_of_key(key);\n-            (cons.clone(), format!(\"{} task-begin\", cons))\n-        },\n-        Effect::QueryBegin(ref qmsg, ref cc) => {\n-            let cons = cons_of_query_msg(qmsg);\n-            (cons.clone(),\n-             format!(\"{} {}\",\n-                     cons,\n-                     match *cc {\n-                         CacheCase::Hit => \"hit\",\n-                         CacheCase::Miss => \"miss\",\n-                     }))\n-        }\n-    }\n-}\n-\n-// First return value is text; second return value is a CSS class\n-fn html_of_duration(_start: &Instant, dur: &Duration) -> (String, String) {\n-    use rustc::util::common::duration_to_secs_str;\n-    (duration_to_secs_str(dur.clone()), String::new())\n-}\n-\n-fn html_of_fraction(frac: f64) -> (String, &'static str) {\n-    let css = {\n-        if       frac > 0.50  { \"frac-50\" }\n-        else if  frac > 0.40  { \"frac-40\" }\n-        else if  frac > 0.30  { \"frac-30\" }\n-        else if  frac > 0.20  { \"frac-20\" }\n-        else if  frac > 0.10  { \"frac-10\" }\n-        else if  frac > 0.05  { \"frac-05\" }\n-        else if  frac > 0.02  { \"frac-02\" }\n-        else if  frac > 0.01  { \"frac-01\" }\n-        else if  frac > 0.001 { \"frac-001\" }\n-        else                  { \"frac-0\" }\n-    };\n-    let percent = frac * 100.0;\n-\n-    if percent > 0.1 {\n-        (format!(\"{:.1}%\", percent), css)\n-    } else {\n-        (\"< 0.1%\".to_string(), css)\n-    }\n-}\n-\n-fn total_duration(traces: &[Rec]) -> Duration {\n-    Duration::new(0, 0) + traces.iter().map(|t| t.dur_total).sum()\n-}\n-\n-fn duration_div(nom: Duration, den: Duration) -> f64 {\n-    fn to_nanos(d: Duration) -> u64 {\n-        d.as_secs() * 1_000_000_000 + d.subsec_nanos() as u64\n-    }\n-\n-    to_nanos(nom) as f64 / to_nanos(den) as f64\n-}\n-\n-fn write_traces_rec(file: &mut File, traces: &[Rec], total: Duration, depth: usize) {\n-    for t in traces {\n-        let (eff_text, eff_css_classes) = html_of_effect(&t.effect);\n-        let (dur_text, dur_css_classes) = html_of_duration(&t.start, &t.dur_total);\n-        let fraction = duration_div(t.dur_total, total);\n-        let percent = fraction * 100.0;\n-        let (frc_text, frc_css_classes) = html_of_fraction(fraction);\n-        writeln!(file, \"<div class=\\\"trace depth-{} extent-{}{} {} {} {}\\\">\",\n-                 depth,\n-                 t.extent.len(),\n-                 /* Heuristic for 'important' CSS class: */\n-                 if t.extent.len() > 5 || percent >= 1.0 { \" important\" } else { \"\" },\n-                 eff_css_classes,\n-                 dur_css_classes,\n-                 frc_css_classes,\n-        ).unwrap();\n-        writeln!(file, \"<div class=\\\"eff\\\">{}</div>\", eff_text).unwrap();\n-        writeln!(file, \"<div class=\\\"dur\\\">{}</div>\", dur_text).unwrap();\n-        writeln!(file, \"<div class=\\\"frc\\\">{}</div>\", frc_text).unwrap();\n-        write_traces_rec(file, &t.extent, total, depth + 1);\n-        writeln!(file, \"</div>\").unwrap();\n-    }\n-}\n-\n-fn compute_counts_rec(counts: &mut FxHashMap<String,QueryMetric>, traces: &[Rec]) {\n-    counts.reserve(traces.len());\n-    for t in traces.iter() {\n-        match t.effect {\n-            Effect::TimeBegin(ref msg) => {\n-                let qm = match counts.get(msg) {\n-                    Some(_qm) => panic!(\"TimeBegin with non-unique, repeat message\"),\n-                    None => QueryMetric {\n-                        count: 1,\n-                        dur_self: t.dur_self,\n-                        dur_total: t.dur_total,\n-                    }\n-                };\n-                counts.insert(msg.clone(), qm);\n-            },\n-            Effect::TaskBegin(ref key) => {\n-                let cons = cons_of_key(key);\n-                let qm = match counts.get(&cons) {\n-                    Some(qm) =>\n-                        QueryMetric {\n-                            count: qm.count + 1,\n-                            dur_self: qm.dur_self + t.dur_self,\n-                            dur_total: qm.dur_total + t.dur_total,\n-                        },\n-                    None => QueryMetric {\n-                        count: 1,\n-                        dur_self: t.dur_self,\n-                        dur_total: t.dur_total,\n-                    }\n-                };\n-                counts.insert(cons, qm);\n-            },\n-            Effect::QueryBegin(ref qmsg, ref _cc) => {\n-                let qcons = cons_of_query_msg(qmsg);\n-                let qm = match counts.get(&qcons) {\n-                    Some(qm) =>\n-                        QueryMetric {\n-                            count: qm.count + 1,\n-                            dur_total: qm.dur_total + t.dur_total,\n-                            dur_self: qm.dur_self + t.dur_self\n-                        },\n-                    None => QueryMetric {\n-                        count: 1,\n-                        dur_total: t.dur_total,\n-                        dur_self: t.dur_self,\n-                    }\n-                };\n-                counts.insert(qcons, qm);\n-            }\n-        }\n-        compute_counts_rec(counts, &t.extent)\n-    }\n-}\n-\n-pub fn write_counts(count_file: &mut File, counts: &mut FxHashMap<String, QueryMetric>) {\n-    use rustc::util::common::duration_to_secs_str;\n-    use std::cmp::Reverse;\n-\n-    let mut data = counts.iter().map(|(ref cons, ref qm)|\n-        (cons.clone(), qm.count.clone(), qm.dur_total.clone(), qm.dur_self.clone())\n-    ).collect::<Vec<_>>();\n-\n-    data.sort_by_key(|k| Reverse(k.3));\n-    for (cons, count, dur_total, dur_self) in data {\n-        writeln!(count_file, \"{}, {}, {}, {}\",\n-                 cons, count,\n-                 duration_to_secs_str(dur_total),\n-                 duration_to_secs_str(dur_self)\n-        ).unwrap();\n-    }\n-}\n-\n-pub fn write_traces(html_file: &mut File, counts_file: &mut File, traces: &[Rec]) {\n-    let capacity = traces.iter().fold(0, |acc, t| acc + 1 + t.extent.len());\n-    let mut counts = FxHashMap::with_capacity_and_hasher(capacity, Default::default());\n-    compute_counts_rec(&mut counts, traces);\n-    write_counts(counts_file, &mut counts);\n-\n-    let total: Duration = total_duration(traces);\n-    write_traces_rec(html_file, traces, total, 0)\n-}\n-\n-pub fn write_style(html_file: &mut File) {\n-    write!(html_file, \"{}\", \"\n-body {\n-    font-family: sans-serif;\n-    background: black;\n-}\n-.trace {\n-    color: black;\n-    display: inline-block;\n-    border-style: solid;\n-    border-color: red;\n-    border-width: 1px;\n-    border-radius: 5px;\n-    padding: 0px;\n-    margin: 1px;\n-    font-size: 0px;\n-}\n-.task-begin {\n-    border-width: 1px;\n-    color: white;\n-    border-color: #ff8;\n-    font-size: 0px;\n-}\n-.miss {\n-    border-color: red;\n-    border-width: 1px;\n-}\n-.extent-0 {\n-    padding: 2px;\n-}\n-.time-begin {\n-    border-width: 4px;\n-    font-size: 12px;\n-    color: white;\n-    border-color: #afa;\n-}\n-.important {\n-    border-width: 3px;\n-    font-size: 12px;\n-    color: white;\n-    border-color: #f77;\n-}\n-.hit {\n-    padding: 0px;\n-    border-color: blue;\n-    border-width: 3px;\n-}\n-.eff {\n-  color: #fff;\n-  display: inline-block;\n-}\n-.frc {\n-  color: #7f7;\n-  display: inline-block;\n-}\n-.dur {\n-  display: none\n-}\n-.frac-50 {\n-  padding: 10px;\n-  border-width: 10px;\n-  font-size: 32px;\n-}\n-.frac-40 {\n-  padding: 8px;\n-  border-width: 8px;\n-  font-size: 24px;\n-}\n-.frac-30 {\n-  padding: 6px;\n-  border-width: 6px;\n-  font-size: 18px;\n-}\n-.frac-20 {\n-  padding: 4px;\n-  border-width: 6px;\n-  font-size: 16px;\n-}\n-.frac-10 {\n-  padding: 2px;\n-  border-width: 6px;\n-  font-size: 14px;\n-}\n-\").unwrap();\n-}"}]}