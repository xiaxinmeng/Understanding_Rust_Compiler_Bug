{"sha": "1dad4b6bb5dcdcda8060d0a662824a50a9f22e82", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkYWQ0YjZiYjVkY2RjZGE4MDYwZDBhNjYyODI0YTUwYTlmMjJlODI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-11-08T20:55:57Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-11-08T20:55:57Z"}, "message": "add more comment", "tree": {"sha": "eed5ba7af42ffc428278b28eca91ca70afc0bc92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eed5ba7af42ffc428278b28eca91ca70afc0bc92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1dad4b6bb5dcdcda8060d0a662824a50a9f22e82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1dad4b6bb5dcdcda8060d0a662824a50a9f22e82", "html_url": "https://github.com/rust-lang/rust/commit/1dad4b6bb5dcdcda8060d0a662824a50a9f22e82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1dad4b6bb5dcdcda8060d0a662824a50a9f22e82/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3ddb85eb1de721373b96d86a1a2dbf33dda3497", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3ddb85eb1de721373b96d86a1a2dbf33dda3497", "html_url": "https://github.com/rust-lang/rust/commit/d3ddb85eb1de721373b96d86a1a2dbf33dda3497"}], "stats": {"total": 75, "additions": 61, "deletions": 14}, "files": [{"sha": "6f01e9b1487d5d4be2421ba096277e1bee48cf18", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 61, "deletions": 14, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/1dad4b6bb5dcdcda8060d0a662824a50a9f22e82/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dad4b6bb5dcdcda8060d0a662824a50a9f22e82/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=1dad4b6bb5dcdcda8060d0a662824a50a9f22e82", "patch": "@@ -419,34 +419,81 @@ fn all_constructors(_cx: &mut MatchCheckCtxt, pcx: PatternContext) -> Vec<Constr\n     }\n }\n \n-fn max_slice_length<'a: 'b, 'b, 'tcx, I>(\n+fn max_slice_length<'a, 'tcx, I>(\n     _cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     patterns: I) -> usize\n-    where I: Iterator<Item=&'b [&'a Pattern<'tcx>]>\n+    where I: Iterator<Item=&'a Pattern<'tcx>>\n {\n     // The exhaustiveness-checking paper does not include any details on\n     // checking variable-length slice patterns. However, they are matched\n     // by an infinite collection of fixed-length array patterns.\n     //\n-    // To check that infinite set, we notice that for every length\n-    // larger than the length of the maximum fixed-length pattern,\n-    // only variable-length patterns apply.\n+    // Checking the infinite set directly would take an infinite amount\n+    // of time. However, it turns out that for each finite set of\n+    // patterns `P`, all sufficiently large array lengths are equivalent:\n     //\n-    // For variable length patterns, all elements after the first\n-    // `prefix_len` but before the last `suffix_len` are matched by\n-    // the wildcard \"middle\" pattern, and therefore can be added/removed\n-    // without affecting the match result.\n+    // Each slice `s` with a \"sufficiently-large\" length `l \u2265 L` that applies\n+    // to exactly the subset `P\u209c` of `P` can be transformed to a slice\n+    // `s\u2098` for each sufficiently-large length `m` that applies to exactly\n+    // the same subset of `P`.\n     //\n-    // This means that all patterns with length at least\n-    // `max(max_fixed+1,max_prefix+max_suffix)` are equivalent, so we\n-    // only need to check patterns from that length and below.\n+    // Because of that, each witness for reachability-checking from one\n+    // of the sufficiently-large lengths can be transformed to an\n+    // equally-valid witness from any other length, so we only have\n+    // to check slice lengths from the \"minimal sufficiently-large length\"\n+    // and below.\n+    //\n+    // Note that the fact that there is a *single* `s\u2098` for each `m`\n+    // not depending on the specific pattern in `P` is important: if\n+    // you look at the pair of patterns\n+    //     `[true, ..]`\n+    //     `[.., false]`\n+    // Then any slice of length \u22651 that matches one of these two\n+    // patterns can be  be trivially turned to a slice of any\n+    // other length \u22651 that matches them and vice-versa - for\n+    // but the slice from length 2 `[false, true]` that matches neither\n+    // of these patterns can't be turned to a slice from length 1 that\n+    // matches neither of these patterns, so we have to consider\n+    // slices from length 2 there.\n+    //\n+    // Now, to see that that length exists and find it, observe that slice\n+    // patterns are either \"fixed-length\" patterns (`[_, _, _]`) or\n+    // \"variable-length\" patterns (`[_, .., _]`).\n+    //\n+    // For fixed-length patterns, all slices with lengths *longer* than\n+    // the pattern's length have the same outcome (of not matching), so\n+    // as long as `L` is greater than the pattern's length we can pick\n+    // any `s\u2098` from that length and get the same result.\n+    //\n+    // For variable-length patterns, the situation is more complicated,\n+    // because as seen above the precise value of `s\u2098` matters.\n+    //\n+    // However, for each variable-length pattern `p` with a prefix of length\n+    // `pl\u209a` and suffix of length `sl\u209a`, only the first `pl\u209a` and the last\n+    // `sl\u209a` elements are examined.\n+    //\n+    // Therefore, as long as `L` is positive (to avoid concerns about empty\n+    // types), all elements after the maximum prefix length and before\n+    // the maximum suffix length are not examined by any variable-length\n+    // pattern, and therefore can be added/removed without affecting\n+    // them - creating equivalent patterns from any sufficiently-large\n+    // length.\n+    //\n+    // Of course, if fixed-length patterns exist, we must be sure\n+    // that our length is large enough to miss them all, so\n+    // we can pick `L = max(FIXED_LEN+1 \u222a {max(PREFIX_LEN) + max(SUFFIX_LEN)})`\n+    //\n+    // for example, with the above pair of patterns, all elements\n+    // but the first and last can be added/removed, so any\n+    // witness of length \u22652 (say, `[false, false, true]`) can be\n+    // turned to a witness from any other length \u22652.\n \n     let mut max_prefix_len = 0;\n     let mut max_suffix_len = 0;\n     let mut max_fixed_len = 0;\n \n     for row in patterns {\n-        match *row[0].kind {\n+        match *row.kind {\n             PatternKind::Constant { value: ConstVal::ByteStr(ref data) } => {\n                 max_fixed_len = cmp::max(max_fixed_len, data.len());\n             }\n@@ -504,7 +551,7 @@ pub fn is_useful<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     let pcx = PatternContext {\n         ty: rows.iter().map(|r| r[0].ty).find(|ty| !ty.references_error())\n             .unwrap_or(v[0].ty),\n-        max_slice_length: max_slice_length(cx, rows.iter().map(|r| &**r).chain(Some(v)))\n+        max_slice_length: max_slice_length(cx, rows.iter().map(|r| r[0]).chain(Some(v[0])))\n     };\n \n     debug!(\"is_useful_expand_first_col: pcx={:?}, expanding {:?}\", pcx, v[0]);"}]}