{"sha": "151db2559949dd09f58b5e5a0f741000c31c66e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1MWRiMjU1OTk0OWRkMDlmNThiNWU1YTBmNzQxMDAwYzMxYzY2ZTk=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-10-29T16:05:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-29T16:05:17Z"}, "message": "Rollup merge of #78423 - tgnottingham:caching_source_map_bounds_check, r=oli-obk\n\nrustc_span: improve bounds checks in byte_pos_to_line_and_col\n\nThe effect of this change is to consider edge-case spans that start or\nend at the position one past the end of a file to be valid during span\nhashing and encoding. This change means that these spans will be\npreserved across incremental compilation sessions when they are part of\na serialized query result, instead of causing the dummy span to be used.", "tree": {"sha": "08df1c0a6dad587b4a57dda28098ca899da42eb7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08df1c0a6dad587b4a57dda28098ca899da42eb7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/151db2559949dd09f58b5e5a0f741000c31c66e9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfmug+CRBK7hj4Ov3rIwAAdHIIAKavBlD0V5vdFtgEn3DiHZXl\nGmo/sbxn7lDKR2QDGVIel1a2A6fi8/bN5G77S3etrBM5npERVLnnHX4qo8NR25R3\n+MRmaDFwbisxkNyQAzgUcEmiNmSU+0TCZ2AwWofD/kxtCKhrM4sTNKE+f5y67PQq\nhyiCvcfIQFGJnNAxAxOm53XXIA7BSh24bUxmxJd3QqkFloQEJuCJiYhYAfZypACm\n3QJr8jLrWyTdIslsiA1YwWnS7yQpZDGULbpBV0CIqQRB21g0r85wQwwFdG9z3Utk\nz17JG5WzK1TFTiJwSpvZxoclbRmNZb/Jt+onoCopqRbHKjLGYhQx6oZVgeqALSA=\n=Wnii\n-----END PGP SIGNATURE-----\n", "payload": "tree 08df1c0a6dad587b4a57dda28098ca899da42eb7\nparent 7fa9e3968222d5c0c81e4d08aae7a1487d3647ef\nparent 47dad31a04724b969d260c32f136bda47fcba63f\nauthor Jonas Schievink <jonasschievink@gmail.com> 1603987517 +0100\ncommitter GitHub <noreply@github.com> 1603987517 +0100\n\nRollup merge of #78423 - tgnottingham:caching_source_map_bounds_check, r=oli-obk\n\nrustc_span: improve bounds checks in byte_pos_to_line_and_col\n\nThe effect of this change is to consider edge-case spans that start or\nend at the position one past the end of a file to be valid during span\nhashing and encoding. This change means that these spans will be\npreserved across incremental compilation sessions when they are part of\na serialized query result, instead of causing the dummy span to be used.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/151db2559949dd09f58b5e5a0f741000c31c66e9", "html_url": "https://github.com/rust-lang/rust/commit/151db2559949dd09f58b5e5a0f741000c31c66e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/151db2559949dd09f58b5e5a0f741000c31c66e9/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fa9e3968222d5c0c81e4d08aae7a1487d3647ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fa9e3968222d5c0c81e4d08aae7a1487d3647ef", "html_url": "https://github.com/rust-lang/rust/commit/7fa9e3968222d5c0c81e4d08aae7a1487d3647ef"}, {"sha": "47dad31a04724b969d260c32f136bda47fcba63f", "url": "https://api.github.com/repos/rust-lang/rust/commits/47dad31a04724b969d260c32f136bda47fcba63f", "html_url": "https://github.com/rust-lang/rust/commit/47dad31a04724b969d260c32f136bda47fcba63f"}], "stats": {"total": 63, "additions": 46, "deletions": 17}, "files": [{"sha": "15dd00fb483e786c0c896e1fa8fa4fca80beeb2e", "filename": "compiler/rustc_span/src/caching_source_map_view.rs", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/151db2559949dd09f58b5e5a0f741000c31c66e9/compiler%2Frustc_span%2Fsrc%2Fcaching_source_map_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151db2559949dd09f58b5e5a0f741000c31c66e9/compiler%2Frustc_span%2Fsrc%2Fcaching_source_map_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fcaching_source_map_view.rs?ref=151db2559949dd09f58b5e5a0f741000c31c66e9", "patch": "@@ -1,13 +1,25 @@\n use crate::source_map::SourceMap;\n use crate::{BytePos, SourceFile};\n use rustc_data_structures::sync::Lrc;\n+use std::ops::Range;\n \n #[derive(Clone)]\n struct CacheEntry {\n     time_stamp: usize,\n     line_number: usize,\n-    line_start: BytePos,\n-    line_end: BytePos,\n+    // The line's byte position range in the `SourceMap`. This range will fail to contain a valid\n+    // position in certain edge cases. Spans often start/end one past something, and when that\n+    // something is the last character of a file (this can happen when a file doesn't end in a\n+    // newline, for example), we'd still like for the position to be considered within the last\n+    // line. However, it isn't according to the exclusive upper bound of this range. We cannot\n+    // change the upper bound to be inclusive, because for most lines, the upper bound is the same\n+    // as the lower bound of the next line, so there would be an ambiguity.\n+    //\n+    // Since the containment aspect of this range is only used to see whether or not the cache\n+    // entry contains a position, the only ramification of the above is that we will get cache\n+    // misses for these rare positions. A line lookup for the position via `SourceMap::lookup_line`\n+    // after a cache miss will produce the last line number, as desired.\n+    line: Range<BytePos>,\n     file: Lrc<SourceFile>,\n     file_index: usize,\n }\n@@ -26,8 +38,7 @@ impl<'sm> CachingSourceMapView<'sm> {\n         let entry = CacheEntry {\n             time_stamp: 0,\n             line_number: 0,\n-            line_start: BytePos(0),\n-            line_end: BytePos(0),\n+            line: BytePos(0)..BytePos(0),\n             file: first_file,\n             file_index: 0,\n         };\n@@ -47,13 +58,13 @@ impl<'sm> CachingSourceMapView<'sm> {\n \n         // Check if the position is in one of the cached lines\n         for cache_entry in self.line_cache.iter_mut() {\n-            if pos >= cache_entry.line_start && pos < cache_entry.line_end {\n+            if cache_entry.line.contains(&pos) {\n                 cache_entry.time_stamp = self.time_stamp;\n \n                 return Some((\n                     cache_entry.file.clone(),\n                     cache_entry.line_number,\n-                    pos - cache_entry.line_start,\n+                    pos - cache_entry.line.start,\n                 ));\n             }\n         }\n@@ -69,13 +80,13 @@ impl<'sm> CachingSourceMapView<'sm> {\n         let cache_entry = &mut self.line_cache[oldest];\n \n         // If the entry doesn't point to the correct file, fix it up\n-        if pos < cache_entry.file.start_pos || pos >= cache_entry.file.end_pos {\n+        if !file_contains(&cache_entry.file, pos) {\n             let file_valid;\n             if self.source_map.files().len() > 0 {\n                 let file_index = self.source_map.lookup_source_file_idx(pos);\n                 let file = self.source_map.files()[file_index].clone();\n \n-                if pos >= file.start_pos && pos < file.end_pos {\n+                if file_contains(&file, pos) {\n                     cache_entry.file = file;\n                     cache_entry.file_index = file_index;\n                     file_valid = true;\n@@ -95,10 +106,19 @@ impl<'sm> CachingSourceMapView<'sm> {\n         let line_bounds = cache_entry.file.line_bounds(line_index);\n \n         cache_entry.line_number = line_index + 1;\n-        cache_entry.line_start = line_bounds.0;\n-        cache_entry.line_end = line_bounds.1;\n+        cache_entry.line = line_bounds;\n         cache_entry.time_stamp = self.time_stamp;\n \n-        Some((cache_entry.file.clone(), cache_entry.line_number, pos - cache_entry.line_start))\n+        Some((cache_entry.file.clone(), cache_entry.line_number, pos - cache_entry.line.start))\n     }\n }\n+\n+#[inline]\n+fn file_contains(file: &SourceFile, pos: BytePos) -> bool {\n+    // `SourceMap::lookup_source_file_idx` and `SourceFile::contains` both consider the position\n+    // one past the end of a file to belong to it. Normally, that's what we want. But for the\n+    // purposes of converting a byte position to a line and column number, we can't come up with a\n+    // line and column number if the file is empty, because an empty file doesn't contain any\n+    // lines. So for our purposes, we don't consider empty files to contain any byte position.\n+    file.contains(pos) && !file.is_empty()\n+}"}, {"sha": "0e3027273abbc4421357c766a12bdbc65a148f81", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/151db2559949dd09f58b5e5a0f741000c31c66e9/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/151db2559949dd09f58b5e5a0f741000c31c66e9/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=151db2559949dd09f58b5e5a0f741000c31c66e9", "patch": "@@ -52,7 +52,7 @@ use std::cell::RefCell;\n use std::cmp::{self, Ordering};\n use std::fmt;\n use std::hash::Hash;\n-use std::ops::{Add, Sub};\n+use std::ops::{Add, Range, Sub};\n use std::path::{Path, PathBuf};\n use std::str::FromStr;\n \n@@ -1426,24 +1426,33 @@ impl SourceFile {\n         if line_index >= 0 { Some(line_index as usize) } else { None }\n     }\n \n-    pub fn line_bounds(&self, line_index: usize) -> (BytePos, BytePos) {\n-        if self.start_pos == self.end_pos {\n-            return (self.start_pos, self.end_pos);\n+    pub fn line_bounds(&self, line_index: usize) -> Range<BytePos> {\n+        if self.is_empty() {\n+            return self.start_pos..self.end_pos;\n         }\n \n         assert!(line_index < self.lines.len());\n         if line_index == (self.lines.len() - 1) {\n-            (self.lines[line_index], self.end_pos)\n+            self.lines[line_index]..self.end_pos\n         } else {\n-            (self.lines[line_index], self.lines[line_index + 1])\n+            self.lines[line_index]..self.lines[line_index + 1]\n         }\n     }\n \n+    /// Returns whether or not the file contains the given `SourceMap` byte\n+    /// position. The position one past the end of the file is considered to be\n+    /// contained by the file. This implies that files for which `is_empty`\n+    /// returns true still contain one byte position according to this function.\n     #[inline]\n     pub fn contains(&self, byte_pos: BytePos) -> bool {\n         byte_pos >= self.start_pos && byte_pos <= self.end_pos\n     }\n \n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        self.start_pos == self.end_pos\n+    }\n+\n     /// Calculates the original byte position relative to the start of the file\n     /// based on the given byte position.\n     pub fn original_relative_byte_pos(&self, pos: BytePos) -> BytePos {"}]}