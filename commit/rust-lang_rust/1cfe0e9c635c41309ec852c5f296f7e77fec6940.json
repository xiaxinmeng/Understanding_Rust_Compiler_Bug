{"sha": "1cfe0e9c635c41309ec852c5f296f7e77fec6940", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjZmUwZTljNjM1YzQxMzA5ZWM4NTJjNWYyOTZmN2U3N2ZlYzY5NDA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-29T19:58:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-29T19:58:22Z"}, "message": "Rollup merge of #71500 - josephlr:offset, r=oli-obk,RalfJung\n\nMake pointer offset methods/intrinsics const\n\nImplements #71499 using [the implementations from miri](https://github.com/rust-lang/miri/blob/52f5d202bdcfe8986f0615845f8d1647ab8a2c6a/src/shims/intrinsics.rs#L96-L112).\n\nI added some tests what's allowed and what's UB. Let me know if any other cases should be added.\n\nCC: @RalfJung @oli-obk", "tree": {"sha": "f41ae6454e76f77ff5fa2e2fe765033e6a672937", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f41ae6454e76f77ff5fa2e2fe765033e6a672937"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cfe0e9c635c41309ec852c5f296f7e77fec6940", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe0WleCRBK7hj4Ov3rIwAAdHIIACcRl/qcSplGvlvYfcFj3UyP\nlG3SKBan0B1UVIRGVpgU6BASst5aFPULeP1Q96bF9KHRy5RPxR9MWmT4tNYyCWJs\nbCVQgDtc/lUhdHvaHYAUeSHrOCx9Irq2SiZdTjPs/O6xPaAZ5imJ+JQENb2gJGhJ\nsvcvxcl/Towem+OqH0wRmNJ8q47ICj/J/I29NQtQGjIQL2c6ruNKlqU8hsKm2yxt\nP2Kpw6+9JaLUX/t0iO5yY0OH0VQwP/WpVFbG4+c+eJ1J4QoGG4Tpgf3qaTeCeb3B\nTImzGuoDFvrtMWk1ZdukDK5pEjL1enAgfBTgmb5O9lxCCtYdNay5HhU74SNxsZk=\n=mpBU\n-----END PGP SIGNATURE-----\n", "payload": "tree f41ae6454e76f77ff5fa2e2fe765033e6a672937\nparent b387a1163691a97abb47db0b99dc6073a8076675\nparent 7d5415b5a2faf5b8f76156eedfd66f94b91660a0\nauthor Ralf Jung <post@ralfj.de> 1590782302 +0200\ncommitter GitHub <noreply@github.com> 1590782302 +0200\n\nRollup merge of #71500 - josephlr:offset, r=oli-obk,RalfJung\n\nMake pointer offset methods/intrinsics const\n\nImplements #71499 using [the implementations from miri](https://github.com/rust-lang/miri/blob/52f5d202bdcfe8986f0615845f8d1647ab8a2c6a/src/shims/intrinsics.rs#L96-L112).\n\nI added some tests what's allowed and what's UB. Let me know if any other cases should be added.\n\nCC: @RalfJung @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cfe0e9c635c41309ec852c5f296f7e77fec6940", "html_url": "https://github.com/rust-lang/rust/commit/1cfe0e9c635c41309ec852c5f296f7e77fec6940", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cfe0e9c635c41309ec852c5f296f7e77fec6940/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b387a1163691a97abb47db0b99dc6073a8076675", "url": "https://api.github.com/repos/rust-lang/rust/commits/b387a1163691a97abb47db0b99dc6073a8076675", "html_url": "https://github.com/rust-lang/rust/commit/b387a1163691a97abb47db0b99dc6073a8076675"}, {"sha": "7d5415b5a2faf5b8f76156eedfd66f94b91660a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d5415b5a2faf5b8f76156eedfd66f94b91660a0", "html_url": "https://github.com/rust-lang/rust/commit/7d5415b5a2faf5b8f76156eedfd66f94b91660a0"}], "stats": {"total": 473, "additions": 424, "deletions": 49}, "files": [{"sha": "2d97fecf8a76673130965c2c52dae989bb0b1ff9", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cfe0e9c635c41309ec852c5f296f7e77fec6940/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cfe0e9c635c41309ec852c5f296f7e77fec6940/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=1cfe0e9c635c41309ec852c5f296f7e77fec6940", "patch": "@@ -1314,6 +1314,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is\n     /// [`std::pointer::offset`](../../std/primitive.pointer.html#method.offset).\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     pub fn offset<T>(dst: *const T, offset: isize) -> *const T;\n \n     /// Calculates the offset from a pointer, potentially wrapping.\n@@ -1331,6 +1332,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is\n     /// [`std::pointer::wrapping_offset`](../../std/primitive.pointer.html#method.wrapping_offset).\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     pub fn arith_offset<T>(dst: *const T, offset: isize) -> *const T;\n \n     /// Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with"}, {"sha": "7d21f9a9a66d0479038e91284f0d03fc638e103b", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1cfe0e9c635c41309ec852c5f296f7e77fec6940/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cfe0e9c635c41309ec852c5f296f7e77fec6940/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=1cfe0e9c635c41309ec852c5f296f7e77fec6940", "patch": "@@ -85,6 +85,7 @@\n #![feature(const_panic)]\n #![feature(const_fn_union)]\n #![feature(const_generics)]\n+#![feature(const_ptr_offset)]\n #![feature(const_ptr_offset_from)]\n #![feature(const_result)]\n #![feature(const_slice_from_raw_parts)]"}, {"sha": "835183d171a794877d1167a2a238c1173f6f6e7a", "filename": "src/libcore/ptr/const_ptr.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1cfe0e9c635c41309ec852c5f296f7e77fec6940/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cfe0e9c635c41309ec852c5f296f7e77fec6940/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fconst_ptr.rs?ref=1cfe0e9c635c41309ec852c5f296f7e77fec6940", "patch": "@@ -151,8 +151,9 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub unsafe fn offset(self, count: isize) -> *const T\n+    pub const unsafe fn offset(self, count: isize) -> *const T\n     where\n         T: Sized,\n     {\n@@ -210,8 +211,9 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[stable(feature = \"ptr_wrapping_offset\", since = \"1.16.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub fn wrapping_offset(self, count: isize) -> *const T\n+    pub const fn wrapping_offset(self, count: isize) -> *const T\n     where\n         T: Sized,\n     {\n@@ -393,8 +395,9 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub unsafe fn add(self, count: usize) -> Self\n+    pub const unsafe fn add(self, count: usize) -> Self\n     where\n         T: Sized,\n     {\n@@ -455,8 +458,9 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub unsafe fn sub(self, count: usize) -> Self\n+    pub const unsafe fn sub(self, count: usize) -> Self\n     where\n         T: Sized,\n     {\n@@ -511,8 +515,9 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub fn wrapping_add(self, count: usize) -> Self\n+    pub const fn wrapping_add(self, count: usize) -> Self\n     where\n         T: Sized,\n     {\n@@ -567,8 +572,9 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub fn wrapping_sub(self, count: usize) -> Self\n+    pub const fn wrapping_sub(self, count: usize) -> Self\n     where\n         T: Sized,\n     {"}, {"sha": "40b5e4e22340e9844ae05862645811a2c110980b", "filename": "src/libcore/ptr/mut_ptr.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1cfe0e9c635c41309ec852c5f296f7e77fec6940/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cfe0e9c635c41309ec852c5f296f7e77fec6940/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmut_ptr.rs?ref=1cfe0e9c635c41309ec852c5f296f7e77fec6940", "patch": "@@ -145,8 +145,9 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub unsafe fn offset(self, count: isize) -> *mut T\n+    pub const unsafe fn offset(self, count: isize) -> *mut T\n     where\n         T: Sized,\n     {\n@@ -203,8 +204,9 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[stable(feature = \"ptr_wrapping_offset\", since = \"1.16.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub fn wrapping_offset(self, count: isize) -> *mut T\n+    pub const fn wrapping_offset(self, count: isize) -> *mut T\n     where\n         T: Sized,\n     {\n@@ -439,8 +441,9 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub unsafe fn add(self, count: usize) -> Self\n+    pub const unsafe fn add(self, count: usize) -> Self\n     where\n         T: Sized,\n     {\n@@ -501,8 +504,9 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub unsafe fn sub(self, count: usize) -> Self\n+    pub const unsafe fn sub(self, count: usize) -> Self\n     where\n         T: Sized,\n     {\n@@ -557,8 +561,9 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub fn wrapping_add(self, count: usize) -> Self\n+    pub const fn wrapping_add(self, count: usize) -> Self\n     where\n         T: Sized,\n     {\n@@ -613,8 +618,9 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub fn wrapping_sub(self, count: usize) -> Self\n+    pub const fn wrapping_sub(self, count: usize) -> Self\n     where\n         T: Sized,\n     {"}, {"sha": "061bc9750e1c27d033961bc17cc400e60237719a", "filename": "src/librustc_middle/mir/interpret/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1cfe0e9c635c41309ec852c5f296f7e77fec6940/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cfe0e9c635c41309ec852c5f296f7e77fec6940/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs?ref=1cfe0e9c635c41309ec852c5f296f7e77fec6940", "patch": "@@ -598,3 +598,12 @@ pub fn truncate(value: u128, size: Size) -> u128 {\n     // Truncate (shift left to drop out leftover values, shift right to fill with zeroes).\n     (value << shift) >> shift\n }\n+\n+/// Computes the unsigned absolute value without wrapping or panicking.\n+#[inline]\n+pub fn uabs(value: i64) -> u64 {\n+    // The only tricky part here is if value == i64::MIN. In that case,\n+    // wrapping_abs() returns i64::MIN == -2^63. Casting this value to a u64\n+    // gives 2^63, the correct value.\n+    value.wrapping_abs() as u64\n+}"}, {"sha": "ccad4f0a135a16d3557c7d5603b6222d39149709", "filename": "src/librustc_middle/mir/interpret/pointer.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1cfe0e9c635c41309ec852c5f296f7e77fec6940/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cfe0e9c635c41309ec852c5f296f7e77fec6940/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fpointer.rs?ref=1cfe0e9c635c41309ec852c5f296f7e77fec6940", "patch": "@@ -1,4 +1,4 @@\n-use super::{AllocId, InterpResult};\n+use super::{uabs, AllocId, InterpResult};\n \n use rustc_macros::HashStable;\n use rustc_target::abi::{HasDataLayout, Size};\n@@ -24,6 +24,12 @@ pub trait PointerArithmetic: HasDataLayout {\n         u64::try_from(max_usize_plus_1 - 1).unwrap()\n     }\n \n+    #[inline]\n+    fn machine_isize_min(&self) -> i64 {\n+        let max_isize_plus_1 = 1i128 << (self.pointer_size().bits() - 1);\n+        i64::try_from(-max_isize_plus_1).unwrap()\n+    }\n+\n     #[inline]\n     fn machine_isize_max(&self) -> i64 {\n         let max_isize_plus_1 = 1u128 << (self.pointer_size().bits() - 1);\n@@ -42,21 +48,23 @@ pub trait PointerArithmetic: HasDataLayout {\n \n     #[inline]\n     fn overflowing_offset(&self, val: u64, i: u64) -> (u64, bool) {\n+        // We do not need to check if i fits in a machine usize. If it doesn't,\n+        // either the wrapping_add will wrap or res will not fit in a pointer.\n         let res = val.overflowing_add(i);\n         self.truncate_to_ptr(res)\n     }\n \n     #[inline]\n     fn overflowing_signed_offset(&self, val: u64, i: i64) -> (u64, bool) {\n-        if i < 0 {\n-            // Trickery to ensure that `i64::MIN` works fine: compute `n = -i`.\n-            // This formula only works for true negative values; it overflows for zero!\n-            let n = u64::MAX - (i as u64) + 1;\n-            let res = val.overflowing_sub(n);\n-            self.truncate_to_ptr(res)\n+        // We need to make sure that i fits in a machine isize.\n+        let n = uabs(i);\n+        if i >= 0 {\n+            let (val, over) = self.overflowing_offset(val, n);\n+            (val, over || i > self.machine_isize_max())\n         } else {\n-            // `i >= 0`, so the cast is safe.\n-            self.overflowing_offset(val, i as u64)\n+            let res = val.overflowing_sub(n);\n+            let (val, over) = self.truncate_to_ptr(res);\n+            (val, over || i < self.machine_isize_min())\n         }\n     }\n "}, {"sha": "55f254f57326159992af8525e22d346daa243c96", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 54, "deletions": 3, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/1cfe0e9c635c41309ec852c5f296f7e77fec6940/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cfe0e9c635c41309ec852c5f296f7e77fec6940/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=1cfe0e9c635c41309ec852c5f296f7e77fec6940", "patch": "@@ -2,19 +2,21 @@\n //! looking at their MIR. Intrinsics/functions supported here are shared by CTFE\n //! and miri.\n \n+use std::convert::TryFrom;\n+\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::{\n     self,\n-    interpret::{ConstValue, GlobalId, InterpResult, Scalar},\n+    interpret::{uabs, ConstValue, GlobalId, InterpResult, Scalar},\n     BinOp,\n };\n use rustc_middle::ty;\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{Ty, TyCtxt};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_target::abi::{Abi, LayoutOf as _, Primitive, Size};\n \n-use super::{ImmTy, InterpCx, Machine, OpTy, PlaceTy};\n+use super::{CheckInAllocMsg, ImmTy, InterpCx, Machine, OpTy, PlaceTy};\n \n mod caller_location;\n mod type_name;\n@@ -279,7 +281,24 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let result = Scalar::from_uint(truncated_bits, layout.size);\n                 self.write_scalar(result, dest)?;\n             }\n+            sym::offset => {\n+                let ptr = self.read_scalar(args[0])?.not_undef()?;\n+                let offset_count = self.read_scalar(args[1])?.to_machine_isize(self)?;\n+                let pointee_ty = substs.type_at(0);\n+\n+                let offset_ptr = self.ptr_offset_inbounds(ptr, pointee_ty, offset_count)?;\n+                self.write_scalar(offset_ptr, dest)?;\n+            }\n+            sym::arith_offset => {\n+                let ptr = self.read_scalar(args[0])?.not_undef()?;\n+                let offset_count = self.read_scalar(args[1])?.to_machine_isize(self)?;\n+                let pointee_ty = substs.type_at(0);\n \n+                let pointee_size = i64::try_from(self.layout_of(pointee_ty)?.size.bytes()).unwrap();\n+                let offset_bytes = offset_count.wrapping_mul(pointee_size);\n+                let offset_ptr = ptr.ptr_wrapping_signed_offset(offset_bytes, self);\n+                self.write_scalar(offset_ptr, dest)?;\n+            }\n             sym::ptr_offset_from => {\n                 let a = self.read_immediate(args[0])?.to_scalar()?;\n                 let b = self.read_immediate(args[1])?.to_scalar()?;\n@@ -409,4 +428,36 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // `Rem` says this is all right, so we can let `Div` do its job.\n         self.binop_ignore_overflow(BinOp::Div, a, b, dest)\n     }\n+\n+    /// Offsets a pointer by some multiple of its type, returning an error if the pointer leaves its\n+    /// allocation. For integer pointers, we consider each of them their own tiny allocation of size\n+    /// 0, so offset-by-0 (and only 0) is okay -- except that NULL cannot be offset by _any_ value.\n+    pub fn ptr_offset_inbounds(\n+        &self,\n+        ptr: Scalar<M::PointerTag>,\n+        pointee_ty: Ty<'tcx>,\n+        offset_count: i64,\n+    ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n+        // We cannot overflow i64 as a type's size must be <= isize::MAX.\n+        let pointee_size = i64::try_from(self.layout_of(pointee_ty)?.size.bytes()).unwrap();\n+        // The computed offset, in bytes, cannot overflow an isize.\n+        let offset_bytes =\n+            offset_count.checked_mul(pointee_size).ok_or(err_ub!(PointerArithOverflow))?;\n+        // The offset being in bounds cannot rely on \"wrapping around\" the address space.\n+        // So, first rule out overflows in the pointer arithmetic.\n+        let offset_ptr = ptr.ptr_signed_offset(offset_bytes, self)?;\n+        // ptr and offset_ptr must be in bounds of the same allocated object. This means all of the\n+        // memory between these pointers must be accessible. Note that we do not require the\n+        // pointers to be properly aligned (unlike a read/write operation).\n+        let min_ptr = if offset_bytes >= 0 { ptr } else { offset_ptr };\n+        let size: u64 = uabs(offset_bytes);\n+        // This call handles checking for integer/NULL pointers.\n+        self.memory.check_ptr_access_align(\n+            min_ptr,\n+            Size::from_bytes(size),\n+            None,\n+            CheckInAllocMsg::InboundsTest,\n+        )?;\n+        Ok(offset_ptr)\n+    }\n }"}, {"sha": "9b055beb99dfd8d5581591c140e91f9c06974898", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cfe0e9c635c41309ec852c5f296f7e77fec6940/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cfe0e9c635c41309ec852c5f296f7e77fec6940/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=1cfe0e9c635c41309ec852c5f296f7e77fec6940", "patch": "@@ -147,6 +147,7 @@ symbols! {\n         Arc,\n         Arguments,\n         ArgumentV1,\n+        arith_offset,\n         arm_target_feature,\n         asm,\n         assert,\n@@ -516,6 +517,7 @@ symbols! {\n         not,\n         note,\n         object_safe_for_dispatch,\n+        offset,\n         Ok,\n         omit_gdb_pretty_printer_section,\n         on,"}, {"sha": "65fc49c0b27a6b44a8bb1c765c23b3aca130e1dd", "filename": "src/test/ui/consts/miri_unleashed/ptr_arith.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1cfe0e9c635c41309ec852c5f296f7e77fec6940/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cfe0e9c635c41309ec852c5f296f7e77fec6940/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.rs?ref=1cfe0e9c635c41309ec852c5f296f7e77fec6940", "patch": "@@ -2,8 +2,7 @@\n #![feature(core_intrinsics)]\n #![allow(const_err)]\n \n-// A test demonstrating that we prevent doing even trivial\n-// pointer arithmetic or comparison during CTFE.\n+// During CTFE, we prevent pointer comparison and pointer-to-int casts.\n \n static CMP: () = {\n     let x = &0 as *const _;\n@@ -19,11 +18,4 @@ static INT_PTR_ARITH: () = unsafe {\n     //~| NOTE pointer-to-integer cast\n };\n \n-static PTR_ARITH: () = unsafe {\n-    let x = &0 as *const _;\n-    let _v = core::intrinsics::offset(x, 0);\n-    //~^ ERROR could not evaluate static initializer\n-    //~| NOTE calling intrinsic `offset`\n-};\n-\n fn main() {}"}, {"sha": "805ba9c6b0307f724a1d31e746a3e780a7c27054", "filename": "src/test/ui/consts/miri_unleashed/ptr_arith.stderr", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1cfe0e9c635c41309ec852c5f296f7e77fec6940/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1cfe0e9c635c41309ec852c5f296f7e77fec6940/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr?ref=1cfe0e9c635c41309ec852c5f296f7e77fec6940", "patch": "@@ -1,39 +1,28 @@\n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ptr_arith.rs:10:14\n+  --> $DIR/ptr_arith.rs:9:14\n    |\n LL |     let _v = x == x;\n    |              ^^^^^^ \"pointer arithmetic or comparison\" needs an rfc before being allowed inside constants\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ptr_arith.rs:17:14\n+  --> $DIR/ptr_arith.rs:16:14\n    |\n LL |     let _v = x + 0;\n    |              ^^^^^ \"pointer-to-integer cast\" needs an rfc before being allowed inside constants\n \n-error[E0080]: could not evaluate static initializer\n-  --> $DIR/ptr_arith.rs:24:14\n-   |\n-LL |     let _v = core::intrinsics::offset(x, 0);\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ \"calling intrinsic `offset`\" needs an rfc before being allowed inside constants\n-\n warning: skipping const checks\n    |\n help: skipping check for `const_compare_raw_pointers` feature\n-  --> $DIR/ptr_arith.rs:10:14\n+  --> $DIR/ptr_arith.rs:9:14\n    |\n LL |     let _v = x == x;\n    |              ^^^^^^\n help: skipping check that does not even have a feature gate\n-  --> $DIR/ptr_arith.rs:16:20\n+  --> $DIR/ptr_arith.rs:15:20\n    |\n LL |     let x: usize = std::mem::transmute(&0);\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^\n-help: skipping check that does not even have a feature gate\n-  --> $DIR/ptr_arith.rs:24:14\n-   |\n-LL |     let _v = core::intrinsics::offset(x, 0);\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 3 previous errors; 1 warning emitted\n+error: aborting due to 2 previous errors; 1 warning emitted\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "f64242d568e318a8b43cfb945030877e74788ae6", "filename": "src/test/ui/consts/offset.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/1cfe0e9c635c41309ec852c5f296f7e77fec6940/src%2Ftest%2Fui%2Fconsts%2Foffset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cfe0e9c635c41309ec852c5f296f7e77fec6940/src%2Ftest%2Fui%2Fconsts%2Foffset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset.rs?ref=1cfe0e9c635c41309ec852c5f296f7e77fec6940", "patch": "@@ -0,0 +1,115 @@\n+// run-pass\n+#![feature(const_ptr_offset)]\n+#![feature(const_ptr_offset_from)]\n+#![feature(ptr_offset_from)]\n+use std::ptr;\n+\n+#[repr(C)]\n+struct Struct {\n+    a: u32,\n+    b: u32,\n+    c: u32,\n+}\n+static S: Struct = Struct { a: 0, b: 0, c: 0 };\n+\n+// For these tests we use offset_from to check that two pointers are equal.\n+// Rust doesn't currently support comparing pointers in const fn.\n+\n+static OFFSET_NO_CHANGE: bool = unsafe {\n+    let p1 = &S.b as *const u32;\n+    let p2 = p1.offset(2).offset(-2);\n+    p1.offset_from(p2) == 0\n+};\n+static OFFSET_MIDDLE: bool = unsafe {\n+    let p1 = (&S.a as *const u32).offset(1);\n+    let p2 = (&S.c as *const u32).offset(-1);\n+    p1.offset_from(p2) == 0\n+};\n+// Pointing to the end of the allocation is OK\n+static OFFSET_END: bool = unsafe {\n+    let p1 = (&S.a as *const u32).offset(3);\n+    let p2 = (&S.c as *const u32).offset(1);\n+    p1.offset_from(p2) == 0\n+};\n+// Casting though a differently sized type is OK\n+static OFFSET_U8_PTR: bool = unsafe {\n+    let p1 = (&S.a as *const u32 as *const u8).offset(5);\n+    let p2 = (&S.c as *const u32 as *const u8).offset(-3);\n+    p1.offset_from(p2) == 0\n+};\n+// Any offset with a ZST does nothing\n+const OFFSET_ZST: bool = unsafe {\n+    let pz = &() as *const ();\n+    // offset_from can't work with ZSTs, so cast to u8 ptr\n+    let p1 = pz.offset(5) as *const u8;\n+    let p2 = pz.offset(isize::MIN) as *const u8;\n+    p1.offset_from(p2) == 0\n+};\n+const OFFSET_ZERO: bool = unsafe {\n+    let p = [0u8; 0].as_ptr();\n+    p.offset(0).offset_from(p) == 0\n+};\n+const OFFSET_ONE: bool = unsafe {\n+    let p = &42u32 as *const u32;\n+    p.offset(1).offset_from(p) == 1\n+};\n+const OFFSET_DANGLING: bool = unsafe {\n+    let p = ptr::NonNull::<u8>::dangling().as_ptr();\n+    p.offset(0).offset_from(p) == 0\n+};\n+const OFFSET_UNALIGNED: bool = unsafe {\n+    let arr = [0u8; 32];\n+    let p1 = arr.as_ptr();\n+    let p2 = (p1.offset(2) as *const u32).offset(1);\n+    (p2 as *const u8).offset_from(p1) == 6\n+};\n+\n+const WRAP_OFFSET_NO_CHANGE: bool = unsafe {\n+    let p1 = &42u32 as *const u32;\n+    let p2 = p1.wrapping_offset(1000).wrapping_offset(-1000);\n+    let p3 = p1.wrapping_offset(-1000).wrapping_offset(1000);\n+    (p1.offset_from(p2) == 0) & (p1.offset_from(p3) == 0)\n+};\n+const WRAP_ADDRESS_SPACE: bool = unsafe {\n+    let p1 = &42u8 as *const u8;\n+    let p2 = p1.wrapping_offset(isize::MIN).wrapping_offset(isize::MIN);\n+    p1.offset_from(p2) == 0\n+};\n+// Wrap on the count*size_of::<T>() calculation.\n+const WRAP_SIZE_OF: bool = unsafe {\n+    // Make sure that if p1 moves backwards, we are still in range\n+    let arr = [0u32; 2];\n+    let p = &arr[1] as *const u32;\n+    // With wrapping arithmetic, isize::MAX * 4 == -4\n+    let wrapped = p.wrapping_offset(isize::MAX);\n+    let backward = p.wrapping_offset(-1);\n+    wrapped.offset_from(backward) == 0\n+};\n+const WRAP_INTEGER_POINTER: bool = unsafe {\n+    let p1 = (0x42 as *const u32).wrapping_offset(4);\n+    let p2 = 0x52 as *const u32;\n+    p1.offset_from(p2) == 0\n+};\n+const WRAP_NULL: bool = unsafe {\n+    let p1 = ptr::null::<u32>().wrapping_offset(1);\n+    let p2 = 0x4 as *const u32;\n+    p1.offset_from(p2) == 0\n+};\n+\n+fn main() {\n+    assert!(OFFSET_NO_CHANGE);\n+    assert!(OFFSET_MIDDLE);\n+    assert!(OFFSET_END);\n+    assert!(OFFSET_U8_PTR);\n+    assert!(OFFSET_ZST);\n+    assert!(OFFSET_ZERO);\n+    assert!(OFFSET_ONE);\n+    assert!(OFFSET_DANGLING);\n+    assert!(OFFSET_UNALIGNED);\n+\n+    assert!(WRAP_OFFSET_NO_CHANGE);\n+    assert!(WRAP_ADDRESS_SPACE);\n+    assert!(WRAP_SIZE_OF);\n+    assert!(WRAP_INTEGER_POINTER);\n+    assert!(WRAP_NULL);\n+}"}, {"sha": "4f943ed9ad194867f4d96894b0a5d762fb0bd602", "filename": "src/test/ui/consts/offset_ub.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1cfe0e9c635c41309ec852c5f296f7e77fec6940/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cfe0e9c635c41309ec852c5f296f7e77fec6940/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.rs?ref=1cfe0e9c635c41309ec852c5f296f7e77fec6940", "patch": "@@ -0,0 +1,25 @@\n+// ignore-tidy-linelength\n+#![feature(const_ptr_offset)]\n+use std::ptr;\n+\n+// normalize-stderr-test \"alloc\\d+\" -> \"allocN\"\n+\n+pub const BEFORE_START: *const u8 = unsafe { (&0u8 as *const u8).offset(-1) }; //~NOTE\n+pub const AFTER_END: *const u8 = unsafe { (&0u8 as *const u8).offset(2) }; //~NOTE\n+pub const AFTER_ARRAY: *const u8 = unsafe { [0u8; 100].as_ptr().offset(101) }; //~NOTE\n+\n+pub const OVERFLOW: *const u16 = unsafe { [0u16; 1].as_ptr().offset(isize::MAX) }; //~NOTE\n+pub const UNDERFLOW: *const u16 = unsafe { [0u16; 1].as_ptr().offset(isize::MIN) }; //~NOTE\n+pub const OVERFLOW_ADDRESS_SPACE: *const u8 = unsafe { (usize::MAX as *const u8).offset(2) }; //~NOTE\n+pub const UNDERFLOW_ADDRESS_SPACE: *const u8 = unsafe { (1 as *const u8).offset(-2) }; //~NOTE\n+\n+pub const ZERO_SIZED_ALLOC: *const u8 = unsafe { [0u8; 0].as_ptr().offset(1) }; //~NOTE\n+pub const DANGLING: *const u8 = unsafe { ptr::NonNull::<u8>::dangling().as_ptr().offset(4) }; //~NOTE\n+\n+// Right now, a zero offset from null is UB\n+pub const NULL_OFFSET_ZERO: *const u8 = unsafe { ptr::null::<u8>().offset(0) }; //~NOTE\n+\n+// Make sure that we don't panic when computing abs(offset*size_of::<T>())\n+pub const UNDERFLOW_ABS: *const u8 = unsafe { (usize::MAX as *const u8).offset(isize::MIN) }; //~NOTE\n+\n+fn main() {}"}, {"sha": "0ab81cc0c5b31bd5af05f6e90f62a2d65b34a864", "filename": "src/test/ui/consts/offset_ub.stderr", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/1cfe0e9c635c41309ec852c5f296f7e77fec6940/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1cfe0e9c635c41309ec852c5f296f7e77fec6940/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.stderr?ref=1cfe0e9c635c41309ec852c5f296f7e77fec6940", "patch": "@@ -0,0 +1,169 @@\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         overflowing in-bounds pointer arithmetic\n+   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `BEFORE_START` at $DIR/offset_ub.rs:7:46\n+   | \n+  ::: $DIR/offset_ub.rs:7:1\n+   |\n+LL | pub const BEFORE_START: *const u8 = unsafe { (&0u8 as *const u8).offset(-1) };\n+   | ------------------------------------------------------------------------------\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         inbounds test failed: pointer must be in-bounds at offset 2, but is outside bounds of allocN which has size 1\n+   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `AFTER_END` at $DIR/offset_ub.rs:8:43\n+   | \n+  ::: $DIR/offset_ub.rs:8:1\n+   |\n+LL | pub const AFTER_END: *const u8 = unsafe { (&0u8 as *const u8).offset(2) };\n+   | --------------------------------------------------------------------------\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         inbounds test failed: pointer must be in-bounds at offset 101, but is outside bounds of allocN which has size 100\n+   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `AFTER_ARRAY` at $DIR/offset_ub.rs:9:45\n+   | \n+  ::: $DIR/offset_ub.rs:9:1\n+   |\n+LL | pub const AFTER_ARRAY: *const u8 = unsafe { [0u8; 100].as_ptr().offset(101) };\n+   | ------------------------------------------------------------------------------\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         overflowing in-bounds pointer arithmetic\n+   |         inside `std::ptr::const_ptr::<impl *const u16>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `OVERFLOW` at $DIR/offset_ub.rs:11:43\n+   | \n+  ::: $DIR/offset_ub.rs:11:1\n+   |\n+LL | pub const OVERFLOW: *const u16 = unsafe { [0u16; 1].as_ptr().offset(isize::MAX) };\n+   | ----------------------------------------------------------------------------------\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         overflowing in-bounds pointer arithmetic\n+   |         inside `std::ptr::const_ptr::<impl *const u16>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `UNDERFLOW` at $DIR/offset_ub.rs:12:44\n+   | \n+  ::: $DIR/offset_ub.rs:12:1\n+   |\n+LL | pub const UNDERFLOW: *const u16 = unsafe { [0u16; 1].as_ptr().offset(isize::MIN) };\n+   | -----------------------------------------------------------------------------------\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         overflowing in-bounds pointer arithmetic\n+   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `OVERFLOW_ADDRESS_SPACE` at $DIR/offset_ub.rs:13:56\n+   | \n+  ::: $DIR/offset_ub.rs:13:1\n+   |\n+LL | pub const OVERFLOW_ADDRESS_SPACE: *const u8 = unsafe { (usize::MAX as *const u8).offset(2) };\n+   | ---------------------------------------------------------------------------------------------\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         overflowing in-bounds pointer arithmetic\n+   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `UNDERFLOW_ADDRESS_SPACE` at $DIR/offset_ub.rs:14:57\n+   | \n+  ::: $DIR/offset_ub.rs:14:1\n+   |\n+LL | pub const UNDERFLOW_ADDRESS_SPACE: *const u8 = unsafe { (1 as *const u8).offset(-2) };\n+   | --------------------------------------------------------------------------------------\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         inbounds test failed: pointer must be in-bounds at offset 1, but is outside bounds of allocN which has size 0\n+   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `ZERO_SIZED_ALLOC` at $DIR/offset_ub.rs:16:50\n+   | \n+  ::: $DIR/offset_ub.rs:16:1\n+   |\n+LL | pub const ZERO_SIZED_ALLOC: *const u8 = unsafe { [0u8; 0].as_ptr().offset(1) };\n+   | -------------------------------------------------------------------------------\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/mut_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count) as *mut T\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         unable to turn bytes into a pointer\n+   |         inside `std::ptr::mut_ptr::<impl *mut u8>::offset` at $SRC_DIR/libcore/ptr/mut_ptr.rs:LL:COL\n+   |         inside `DANGLING` at $DIR/offset_ub.rs:17:42\n+   | \n+  ::: $DIR/offset_ub.rs:17:1\n+   |\n+LL | pub const DANGLING: *const u8 = unsafe { ptr::NonNull::<u8>::dangling().as_ptr().offset(4) };\n+   | ---------------------------------------------------------------------------------------------\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         inbounds test failed: 0x0 is not a valid pointer\n+   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `NULL_OFFSET_ZERO` at $DIR/offset_ub.rs:20:50\n+   | \n+  ::: $DIR/offset_ub.rs:20:1\n+   |\n+LL | pub const NULL_OFFSET_ZERO: *const u8 = unsafe { ptr::null::<u8>().offset(0) };\n+   | -------------------------------------------------------------------------------\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         unable to turn bytes into a pointer\n+   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `UNDERFLOW_ABS` at $DIR/offset_ub.rs:23:47\n+   | \n+  ::: $DIR/offset_ub.rs:23:1\n+   |\n+LL | pub const UNDERFLOW_ABS: *const u8 = unsafe { (usize::MAX as *const u8).offset(isize::MIN) };\n+   | ---------------------------------------------------------------------------------------------\n+\n+error: aborting due to 11 previous errors\n+"}]}