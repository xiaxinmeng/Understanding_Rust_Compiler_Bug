{"sha": "d935f621721212ae1d5329a72bead46de1c9339c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5MzVmNjIxNzIxMjEyYWUxZDUzMjlhNzJiZWFkNDZkZTFjOTMzOWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-06T13:55:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-06T13:55:53Z"}, "message": "Auto merge of #1157 - divergentdave:shim-pthread-try-lock, r=RalfJung\n\nAdd shims for RwLock::try_read/RwLock::try_write\n\nThis implements proper locking so that we can check for reentrancy and implement the `try_*` methods.\n\nFixes https://github.com/rust-lang/miri/issues/781", "tree": {"sha": "cf7ad6c684a28fd95d0b8d99a94e694f8e6648a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf7ad6c684a28fd95d0b8d99a94e694f8e6648a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d935f621721212ae1d5329a72bead46de1c9339c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d935f621721212ae1d5329a72bead46de1c9339c", "html_url": "https://github.com/rust-lang/rust/commit/d935f621721212ae1d5329a72bead46de1c9339c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d935f621721212ae1d5329a72bead46de1c9339c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d25589f0bdcbde0b270c6d251f3fe850e7759233", "url": "https://api.github.com/repos/rust-lang/rust/commits/d25589f0bdcbde0b270c6d251f3fe850e7759233", "html_url": "https://github.com/rust-lang/rust/commit/d25589f0bdcbde0b270c6d251f3fe850e7759233"}, {"sha": "80497e5d3c5fe08e95bcbe114fae39661a909e16", "url": "https://api.github.com/repos/rust-lang/rust/commits/80497e5d3c5fe08e95bcbe114fae39661a909e16", "html_url": "https://github.com/rust-lang/rust/commit/80497e5d3c5fe08e95bcbe114fae39661a909e16"}], "stats": {"total": 933, "additions": 891, "deletions": 42}, "files": [{"sha": "2b53efe864e541b7454429cb1b316342b0113d6e", "filename": "src/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d935f621721212ae1d5329a72bead46de1c9339c/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d935f621721212ae1d5329a72bead46de1c9339c/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=d935f621721212ae1d5329a72bead46de1c9339c", "patch": "@@ -12,7 +12,8 @@ pub enum TerminationInfo {\n     Exit(i64),\n     Abort(Option<String>),\n     UnsupportedInIsolation(String),\n-    ExperimentalUb { msg: String, url: String }\n+    ExperimentalUb { msg: String, url: String },\n+    Deadlock,\n }\n \n impl fmt::Debug for TerminationInfo {\n@@ -29,6 +30,8 @@ impl fmt::Debug for TerminationInfo {\n                 write!(f, \"{}\", msg),\n             ExperimentalUb { msg, .. } =>\n                 write!(f, \"{}\", msg),\n+            Deadlock =>\n+                write!(f, \"the evaluated program deadlocked\"),\n         }\n     }\n }\n@@ -60,6 +63,7 @@ pub fn report_error<'tcx, 'mir>(\n                     \"unsupported operation\",\n                 ExperimentalUb { .. } =>\n                     \"Undefined Behavior\",\n+                Deadlock => \"deadlock\",\n             };\n             let helps = match info {\n                 UnsupportedInIsolation(_) =>"}, {"sha": "c3510188e3cb225e7c92ad0fc38a97413451c326", "filename": "src/eval.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d935f621721212ae1d5329a72bead46de1c9339c/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d935f621721212ae1d5329a72bead46de1c9339c/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=d935f621721212ae1d5329a72bead46de1c9339c", "patch": "@@ -1,14 +1,14 @@\n //! Main evaluator loop and setting up the initial stack frame.\n \n-use std::ffi::OsStr;\n use std::convert::TryFrom;\n+use std::ffi::OsStr;\n \n use rand::rngs::StdRng;\n use rand::SeedableRng;\n \n-use rustc_target::abi::LayoutOf;\n-use rustc_middle::ty::{self, TyCtxt};\n use rustc_hir::def_id::DefId;\n+use rustc_middle::ty::{self, layout::LayoutCx, TyCtxt};\n+use rustc_target::abi::LayoutOf;\n \n use crate::*;\n \n@@ -60,10 +60,13 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     main_id: DefId,\n     config: MiriConfig,\n ) -> InterpResult<'tcx, (InterpCx<'mir, 'tcx, Evaluator<'tcx>>, MPlaceTy<'tcx, Tag>)> {\n+    let tcx_at = tcx.at(rustc_span::source_map::DUMMY_SP);\n+    let param_env = ty::ParamEnv::reveal_all();\n+    let layout_cx = LayoutCx { tcx, param_env };\n     let mut ecx = InterpCx::new(\n-        tcx.at(rustc_span::source_map::DUMMY_SP),\n-        ty::ParamEnv::reveal_all(),\n-        Evaluator::new(config.communicate, config.validate),\n+        tcx_at,\n+        param_env,\n+        Evaluator::new(config.communicate, config.validate, layout_cx),\n         MemoryExtra::new(\n             StdRng::seed_from_u64(config.seed.unwrap_or(0)),\n             config.stacked_borrows,"}, {"sha": "2f381b4a34546f7868ed5dd82cff3175820814a3", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d935f621721212ae1d5329a72bead46de1c9339c/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d935f621721212ae1d5329a72bead46de1c9339c/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=d935f621721212ae1d5329a72bead46de1c9339c", "patch": "@@ -39,6 +39,7 @@ pub use crate::shims::fs::{DirHandler, EvalContextExt as FileEvalContextExt, Fil\n pub use crate::shims::intrinsics::EvalContextExt as IntrinsicsEvalContextExt;\n pub use crate::shims::os_str::EvalContextExt as OsStrEvalContextExt;\n pub use crate::shims::panic::{CatchUnwindData, EvalContextExt as PanicEvalContextExt};\n+pub use crate::shims::sync::{EvalContextExt as SyncEvalContextExt};\n pub use crate::shims::time::EvalContextExt as TimeEvalContextExt;\n pub use crate::shims::tls::{EvalContextExt as TlsEvalContextExt, TlsData};\n pub use crate::shims::EvalContextExt as ShimsEvalContextExt;"}, {"sha": "26ff23511f73375f3d095aa29891113eef982c23", "filename": "src/machine.rs", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d935f621721212ae1d5329a72bead46de1c9339c/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d935f621721212ae1d5329a72bead46de1c9339c/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=d935f621721212ae1d5329a72bead46de1c9339c", "patch": "@@ -10,11 +10,18 @@ use std::time::Instant;\n use log::trace;\n use rand::rngs::StdRng;\n \n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_middle::{mir, ty};\n-use rustc_target::abi::{LayoutOf, Size};\n use rustc_ast::attr;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::{\n+    mir,\n+    ty::{\n+        self,\n+        layout::{LayoutCx, LayoutError, TyAndLayout},\n+        TyCtxt,\n+    },\n+};\n use rustc_span::symbol::{sym, Symbol};\n+use rustc_target::abi::{LayoutOf, Size};\n \n use crate::*;\n \n@@ -146,6 +153,21 @@ impl MemoryExtra {\n     }\n }\n \n+/// Precomputed layouts of primitive types\n+pub(crate) struct PrimitiveLayouts<'tcx> {\n+    pub(crate) i32: TyAndLayout<'tcx>,\n+    pub(crate) u32: TyAndLayout<'tcx>,\n+}\n+\n+impl<'mir, 'tcx: 'mir> PrimitiveLayouts<'tcx> {\n+    fn new(layout_cx: LayoutCx<'tcx, TyCtxt<'tcx>>) -> Result<Self, LayoutError<'tcx>> {\n+        Ok(Self {\n+            i32: layout_cx.layout_of(layout_cx.tcx.types.i32)?,\n+            u32: layout_cx.layout_of(layout_cx.tcx.types.u32)?,\n+        })\n+    }\n+}\n+\n /// The machine itself.\n pub struct Evaluator<'tcx> {\n     /// Environment variables set by `setenv`.\n@@ -182,10 +204,21 @@ pub struct Evaluator<'tcx> {\n \n     /// The \"time anchor\" for this machine's monotone clock (for `Instant` simulation).\n     pub(crate) time_anchor: Instant,\n+\n+    /// Precomputed `TyLayout`s for primitive data types that are commonly used inside Miri.\n+    /// FIXME: Search through the rest of the codebase for more layout_of() calls that\n+    /// could be stored here.\n+    pub(crate) layouts: PrimitiveLayouts<'tcx>,\n }\n \n impl<'tcx> Evaluator<'tcx> {\n-    pub(crate) fn new(communicate: bool, validate: bool) -> Self {\n+    pub(crate) fn new(\n+        communicate: bool,\n+        validate: bool,\n+        layout_cx: LayoutCx<'tcx, TyCtxt<'tcx>>,\n+    ) -> Self {\n+        let layouts = PrimitiveLayouts::new(layout_cx)\n+            .expect(\"Couldn't get layouts of primitive types\");\n         Evaluator {\n             // `env_vars` could be initialized properly here if `Memory` were available before\n             // calling this method.\n@@ -201,6 +234,7 @@ impl<'tcx> Evaluator<'tcx> {\n             dir_handler: Default::default(),\n             panic_payload: None,\n             time_anchor: Instant::now(),\n+            layouts,\n         }\n     }\n }"}, {"sha": "3ececb9c20bbdb684696ce88a503dd4f9895afb8", "filename": "src/shims/foreign_items/posix.rs", "status": "modified", "additions": 61, "deletions": 15, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/d935f621721212ae1d5329a72bead46de1c9339c/src%2Fshims%2Fforeign_items%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d935f621721212ae1d5329a72bead46de1c9339c/src%2Fshims%2Fforeign_items%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix.rs?ref=d935f621721212ae1d5329a72bead46de1c9339c", "patch": "@@ -233,6 +233,64 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n \n+            // Synchronization primitives\n+            \"pthread_mutexattr_init\" => {\n+                let result = this.pthread_mutexattr_init(args[0])?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_mutexattr_settype\" => {\n+                let result = this.pthread_mutexattr_settype(args[0], args[1])?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_mutexattr_destroy\" => {\n+                let result = this.pthread_mutexattr_destroy(args[0])?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_mutex_init\" => {\n+                let result = this.pthread_mutex_init(args[0], args[1])?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_mutex_lock\" => {\n+                let result = this.pthread_mutex_lock(args[0])?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_mutex_trylock\" => {\n+                let result = this.pthread_mutex_trylock(args[0])?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_mutex_unlock\" => {\n+                let result = this.pthread_mutex_unlock(args[0])?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_mutex_destroy\" => {\n+                let result = this.pthread_mutex_destroy(args[0])?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_rwlock_rdlock\" => {\n+                let result = this.pthread_rwlock_rdlock(args[0])?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_rwlock_tryrdlock\" => {\n+                let result = this.pthread_rwlock_tryrdlock(args[0])?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_rwlock_wrlock\" => {\n+                let result = this.pthread_rwlock_wrlock(args[0])?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_rwlock_trywrlock\" => {\n+                let result = this.pthread_rwlock_trywrlock(args[0])?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_rwlock_unlock\" => {\n+                let result = this.pthread_rwlock_unlock(args[0])?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+            \"pthread_rwlock_destroy\" => {\n+                let result = this.pthread_rwlock_destroy(args[0])?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+\n             // Better error for attempts to create a thread\n             \"pthread_create\" => {\n                 throw_unsup_format!(\"Miri does not support threading\");\n@@ -255,25 +313,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n \n-            // Incomplete shims that we \"stub out\" just to get pre-main initialziation code to work.\n+            // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n             // These shims are enabled only when the caller is in the standard library.\n             | \"pthread_attr_init\"\n             | \"pthread_attr_destroy\"\n             | \"pthread_self\"\n-            | \"pthread_attr_setstacksize\" if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n-                this.write_null(dest)?;\n-            }\n-            | \"pthread_mutexattr_init\"\n-            | \"pthread_mutexattr_settype\"\n-            | \"pthread_mutex_init\"\n-            | \"pthread_mutexattr_destroy\"\n-            | \"pthread_mutex_lock\"\n-            | \"pthread_mutex_unlock\"\n-            | \"pthread_mutex_destroy\"\n-            | \"pthread_rwlock_rdlock\"\n-            | \"pthread_rwlock_unlock\"\n-            | \"pthread_rwlock_wrlock\"\n-            | \"pthread_rwlock_destroy\"\n+            | \"pthread_attr_setstacksize\"\n             | \"pthread_condattr_init\"\n             | \"pthread_condattr_setclock\"\n             | \"pthread_cond_init\"\n@@ -282,6 +327,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             => {\n                 this.write_null(dest)?;\n             }\n+\n             | \"signal\"\n             | \"sigaction\"\n             | \"sigaltstack\""}, {"sha": "16c6c002b69c570cfbc0ea7c6addbade74be91ff", "filename": "src/shims/foreign_items/posix/linux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d935f621721212ae1d5329a72bead46de1c9339c/src%2Fshims%2Fforeign_items%2Fposix%2Flinux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d935f621721212ae1d5329a72bead46de1c9339c/src%2Fshims%2Fforeign_items%2Fposix%2Flinux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix%2Flinux.rs?ref=d935f621721212ae1d5329a72bead46de1c9339c", "patch": "@@ -113,7 +113,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_i32(-1), dest)?;\n             }\n \n-            // Incomplete shims that we \"stub out\" just to get pre-main initialziation code to work.\n+            // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n             // These shims are enabled only when the caller is in the standard library.\n             \"pthread_getattr_np\" if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n                 this.write_null(dest)?;"}, {"sha": "9810a77ffde18066e6e66304a827f6fa8ee6d790", "filename": "src/shims/foreign_items/posix/macos.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d935f621721212ae1d5329a72bead46de1c9339c/src%2Fshims%2Fforeign_items%2Fposix%2Fmacos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d935f621721212ae1d5329a72bead46de1c9339c/src%2Fshims%2Fforeign_items%2Fposix%2Fmacos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix%2Fmacos.rs?ref=d935f621721212ae1d5329a72bead46de1c9339c", "patch": "@@ -88,7 +88,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(stack_size, dest)?;\n             }\n \n-            // Incomplete shims that we \"stub out\" just to get pre-main initialziation code to work.\n+            // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n             // These shims are enabled only when the caller is in the standard library.\n             \"mmap\" if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n                 // This is a horrible hack, but since the guard page mechanism calls mmap and expects a particular return value, we just give it that value."}, {"sha": "1d17cbcefdeec7357cc2b378d741904940088204", "filename": "src/shims/foreign_items/windows.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d935f621721212ae1d5329a72bead46de1c9339c/src%2Fshims%2Fforeign_items%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d935f621721212ae1d5329a72bead46de1c9339c/src%2Fshims%2Fforeign_items%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fwindows.rs?ref=d935f621721212ae1d5329a72bead46de1c9339c", "patch": "@@ -207,7 +207,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 throw_unsup_format!(\"Miri does not support threading\");\n             }\n \n-            // Incomplete shims that we \"stub out\" just to get pre-main initialziation code to work.\n+            // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n             // These shims are enabled only when the caller is in the standard library.\n             \"GetProcessHeap\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n                 // Just fake a HANDLE\n@@ -233,6 +233,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // (Windows locks are reentrant, and we have only 1 thread,\n                 // so not doing any futher checks here is at least not incorrect.)\n             }\n+            \"TryEnterCriticalSection\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\")\n+            => {\n+                // There is only one thread, so this always succeeds and returns TRUE\n+                this.write_scalar(Scalar::from_i32(1), dest)?;\n+            }\n \n             _ => throw_unsup_format!(\"can't call foreign function: {}\", link_name),\n         }"}, {"sha": "764e404141e4d0dbb4f8173a98580268349cf6e1", "filename": "src/shims/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d935f621721212ae1d5329a72bead46de1c9339c/src%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d935f621721212ae1d5329a72bead46de1c9339c/src%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fmod.rs?ref=d935f621721212ae1d5329a72bead46de1c9339c", "patch": "@@ -5,6 +5,7 @@ pub mod fs;\n pub mod intrinsics;\n pub mod os_str;\n pub mod panic;\n+pub mod sync;\n pub mod time;\n pub mod tls;\n "}, {"sha": "b03dcbfd8969a2bc310fe08a8f8803eba6b9485a", "filename": "src/shims/sync.rs", "status": "added", "additions": 467, "deletions": 0, "changes": 467, "blob_url": "https://github.com/rust-lang/rust/blob/d935f621721212ae1d5329a72bead46de1c9339c/src%2Fshims%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d935f621721212ae1d5329a72bead46de1c9339c/src%2Fshims%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fsync.rs?ref=d935f621721212ae1d5329a72bead46de1c9339c", "patch": "@@ -0,0 +1,467 @@\n+use rustc_middle::ty::{TyKind, TypeAndMut};\n+use rustc_target::abi::{LayoutOf, Size};\n+\n+use crate::stacked_borrows::Tag;\n+use crate::*;\n+\n+fn assert_ptr_target_min_size<'mir, 'tcx: 'mir>(\n+    ecx: &MiriEvalContext<'mir, 'tcx>,\n+    operand: OpTy<'tcx, Tag>,\n+    min_size: u64,\n+) -> InterpResult<'tcx, ()> {\n+    let target_ty = match operand.layout.ty.kind {\n+        TyKind::RawPtr(TypeAndMut { ty, mutbl: _ }) => ty,\n+        _ => panic!(\"Argument to pthread function was not a raw pointer\"),\n+    };\n+    let target_layout = ecx.layout_of(target_ty)?;\n+    assert!(target_layout.size.bytes() >= min_size);\n+    Ok(())\n+}\n+\n+// pthread_mutexattr_t is either 4 or 8 bytes, depending on the platform.\n+\n+// Our chosen memory layout for emulation (does not have to match the platform layout!):\n+// store an i32 in the first four bytes equal to the corresponding libc mutex kind constant\n+// (e.g. PTHREAD_MUTEX_NORMAL).\n+\n+fn mutexattr_get_kind<'mir, 'tcx: 'mir>(\n+    ecx: &MiriEvalContext<'mir, 'tcx>,\n+    attr_op: OpTy<'tcx, Tag>,\n+) -> InterpResult<'tcx, ScalarMaybeUndef<Tag>> {\n+    // Ensure that the following read at an offset to the attr pointer is within bounds\n+    assert_ptr_target_min_size(ecx, attr_op, 4)?;\n+    let attr_place = ecx.deref_operand(attr_op)?;\n+    let kind_place =\n+        attr_place.offset(Size::ZERO, MemPlaceMeta::None, ecx.machine.layouts.i32, ecx)?;\n+    ecx.read_scalar(kind_place.into())\n+}\n+\n+fn mutexattr_set_kind<'mir, 'tcx: 'mir>(\n+    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+    attr_op: OpTy<'tcx, Tag>,\n+    kind: impl Into<ScalarMaybeUndef<Tag>>,\n+) -> InterpResult<'tcx, ()> {\n+    // Ensure that the following write at an offset to the attr pointer is within bounds\n+    assert_ptr_target_min_size(ecx, attr_op, 4)?;\n+    let attr_place = ecx.deref_operand(attr_op)?;\n+    let kind_place =\n+        attr_place.offset(Size::ZERO, MemPlaceMeta::None, ecx.machine.layouts.i32, ecx)?;\n+    ecx.write_scalar(kind.into(), kind_place.into())\n+}\n+\n+// pthread_mutex_t is between 24 and 48 bytes, depending on the platform.\n+\n+// Our chosen memory layout for the emulated mutex (does not have to match the platform layout!):\n+// bytes 0-3: reserved for signature on macOS\n+// (need to avoid this because it is set by static initializer macros)\n+// bytes 4-7: count of how many times this mutex has been locked, as a u32\n+// bytes 12-15 or 16-19 (depending on platform): mutex kind, as an i32\n+// (the kind has to be at its offset for compatibility with static initializer macros)\n+\n+fn mutex_get_locked_count<'mir, 'tcx: 'mir>(\n+    ecx: &MiriEvalContext<'mir, 'tcx>,\n+    mutex_op: OpTy<'tcx, Tag>,\n+) -> InterpResult<'tcx, ScalarMaybeUndef<Tag>> {\n+    // Ensure that the following read at an offset to the mutex pointer is within bounds\n+    assert_ptr_target_min_size(ecx, mutex_op, 20)?;\n+    let mutex_place = ecx.deref_operand(mutex_op)?;\n+    let locked_count_place = mutex_place.offset(\n+        Size::from_bytes(4),\n+        MemPlaceMeta::None,\n+        ecx.machine.layouts.u32,\n+        ecx,\n+    )?;\n+    ecx.read_scalar(locked_count_place.into())\n+}\n+\n+fn mutex_set_locked_count<'mir, 'tcx: 'mir>(\n+    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+    mutex_op: OpTy<'tcx, Tag>,\n+    locked_count: impl Into<ScalarMaybeUndef<Tag>>,\n+) -> InterpResult<'tcx, ()> {\n+    // Ensure that the following write at an offset to the mutex pointer is within bounds\n+    assert_ptr_target_min_size(ecx, mutex_op, 20)?;\n+    let mutex_place = ecx.deref_operand(mutex_op)?;\n+    let locked_count_place = mutex_place.offset(\n+        Size::from_bytes(4),\n+        MemPlaceMeta::None,\n+        ecx.machine.layouts.u32,\n+        ecx,\n+    )?;\n+    ecx.write_scalar(locked_count.into(), locked_count_place.into())\n+}\n+\n+fn mutex_get_kind<'mir, 'tcx: 'mir>(\n+    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+    mutex_op: OpTy<'tcx, Tag>,\n+) -> InterpResult<'tcx, ScalarMaybeUndef<Tag>> {\n+    // Ensure that the following read at an offset to the mutex pointer is within bounds\n+    assert_ptr_target_min_size(ecx, mutex_op, 20)?;\n+    let mutex_place = ecx.deref_operand(mutex_op)?;\n+    let kind_offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };\n+    let kind_place = mutex_place.offset(\n+        Size::from_bytes(kind_offset),\n+        MemPlaceMeta::None,\n+        ecx.machine.layouts.i32,\n+        ecx,\n+    )?;\n+    ecx.read_scalar(kind_place.into())\n+}\n+\n+fn mutex_set_kind<'mir, 'tcx: 'mir>(\n+    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+    mutex_op: OpTy<'tcx, Tag>,\n+    kind: impl Into<ScalarMaybeUndef<Tag>>,\n+) -> InterpResult<'tcx, ()> {\n+    // Ensure that the following write at an offset to the mutex pointer is within bounds\n+    assert_ptr_target_min_size(ecx, mutex_op, 20)?;\n+    let mutex_place = ecx.deref_operand(mutex_op)?;\n+    let kind_offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };\n+    let kind_place = mutex_place.offset(\n+        Size::from_bytes(kind_offset),\n+        MemPlaceMeta::None,\n+        ecx.machine.layouts.i32,\n+        ecx,\n+    )?;\n+    ecx.write_scalar(kind.into(), kind_place.into())\n+}\n+\n+// pthread_rwlock_t is between 32 and 56 bytes, depending on the platform.\n+\n+// Our chosen memory layout for the emulated rwlock (does not have to match the platform layout!):\n+// bytes 0-3: reserved for signature on macOS\n+// (need to avoid this because it is set by static initializer macros)\n+// bytes 4-7: reader count, as a u32\n+// bytes 8-11: writer count, as a u32\n+\n+fn rwlock_get_readers<'mir, 'tcx: 'mir>(\n+    ecx: &MiriEvalContext<'mir, 'tcx>,\n+    rwlock_op: OpTy<'tcx, Tag>,\n+) -> InterpResult<'tcx, ScalarMaybeUndef<Tag>> {\n+    // Ensure that the following read at an offset to the rwlock pointer is within bounds\n+    assert_ptr_target_min_size(ecx, rwlock_op, 12)?;\n+    let rwlock_place = ecx.deref_operand(rwlock_op)?;\n+    let readers_place = rwlock_place.offset(\n+        Size::from_bytes(4),\n+        MemPlaceMeta::None,\n+        ecx.machine.layouts.u32,\n+        ecx,\n+    )?;\n+    ecx.read_scalar(readers_place.into())\n+}\n+\n+fn rwlock_set_readers<'mir, 'tcx: 'mir>(\n+    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+    rwlock_op: OpTy<'tcx, Tag>,\n+    readers: impl Into<ScalarMaybeUndef<Tag>>,\n+) -> InterpResult<'tcx, ()> {\n+    // Ensure that the following write at an offset to the rwlock pointer is within bounds\n+    assert_ptr_target_min_size(ecx, rwlock_op, 12)?;\n+    let rwlock_place = ecx.deref_operand(rwlock_op)?;\n+    let readers_place = rwlock_place.offset(\n+        Size::from_bytes(4),\n+        MemPlaceMeta::None,\n+        ecx.machine.layouts.u32,\n+        ecx,\n+    )?;\n+    ecx.write_scalar(readers.into(), readers_place.into())\n+}\n+\n+fn rwlock_get_writers<'mir, 'tcx: 'mir>(\n+    ecx: &MiriEvalContext<'mir, 'tcx>,\n+    rwlock_op: OpTy<'tcx, Tag>,\n+) -> InterpResult<'tcx, ScalarMaybeUndef<Tag>> {\n+    // Ensure that the following read at an offset to the rwlock pointer is within bounds\n+    assert_ptr_target_min_size(ecx, rwlock_op, 12)?;\n+    let rwlock_place = ecx.deref_operand(rwlock_op)?;\n+    let writers_place = rwlock_place.offset(\n+        Size::from_bytes(8),\n+        MemPlaceMeta::None,\n+        ecx.machine.layouts.u32,\n+        ecx,\n+    )?;\n+    ecx.read_scalar(writers_place.into())\n+}\n+\n+fn rwlock_set_writers<'mir, 'tcx: 'mir>(\n+    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+    rwlock_op: OpTy<'tcx, Tag>,\n+    writers: impl Into<ScalarMaybeUndef<Tag>>,\n+) -> InterpResult<'tcx, ()> {\n+    // Ensure that the following write at an offset to the rwlock pointer is within bounds\n+    assert_ptr_target_min_size(ecx, rwlock_op, 12)?;\n+    let rwlock_place = ecx.deref_operand(rwlock_op)?;\n+    let writers_place = rwlock_place.offset(\n+        Size::from_bytes(8),\n+        MemPlaceMeta::None,\n+        ecx.machine.layouts.u32,\n+        ecx,\n+    )?;\n+    ecx.write_scalar(writers.into(), writers_place.into())\n+}\n+\n+impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    fn pthread_mutexattr_init(&mut self, attr_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        let default_kind = this.eval_libc(\"PTHREAD_MUTEX_DEFAULT\")?;\n+        mutexattr_set_kind(this, attr_op, default_kind)?;\n+\n+        Ok(0)\n+    }\n+\n+    fn pthread_mutexattr_settype(\n+        &mut self,\n+        attr_op: OpTy<'tcx, Tag>,\n+        kind_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        let kind = this.read_scalar(kind_op)?.not_undef()?;\n+        if kind == this.eval_libc(\"PTHREAD_MUTEX_NORMAL\")?\n+            || kind == this.eval_libc(\"PTHREAD_MUTEX_ERRORCHECK\")?\n+            || kind == this.eval_libc(\"PTHREAD_MUTEX_RECURSIVE\")?\n+        {\n+            mutexattr_set_kind(this, attr_op, kind)?;\n+        } else {\n+            let einval = this.eval_libc_i32(\"EINVAL\")?;\n+            return Ok(einval);\n+        }\n+\n+        Ok(0)\n+    }\n+\n+    fn pthread_mutexattr_destroy(&mut self, attr_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        mutexattr_set_kind(this, attr_op, ScalarMaybeUndef::Undef)?;\n+\n+        Ok(0)\n+    }\n+\n+    fn pthread_mutex_init(\n+        &mut self,\n+        mutex_op: OpTy<'tcx, Tag>,\n+        attr_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        let attr = this.read_scalar(attr_op)?.not_undef()?;\n+        let kind = if this.is_null(attr)? {\n+            this.eval_libc(\"PTHREAD_MUTEX_DEFAULT\")?\n+        } else {\n+            mutexattr_get_kind(this, attr_op)?.not_undef()?\n+        };\n+\n+        mutex_set_locked_count(this, mutex_op, Scalar::from_u32(0))?;\n+        mutex_set_kind(this, mutex_op, kind)?;\n+\n+        Ok(0)\n+    }\n+\n+    fn pthread_mutex_lock(&mut self, mutex_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        let kind = mutex_get_kind(this, mutex_op)?.not_undef()?;\n+        let locked_count = mutex_get_locked_count(this, mutex_op)?.to_u32()?;\n+\n+        if kind == this.eval_libc(\"PTHREAD_MUTEX_NORMAL\")? {\n+            if locked_count == 0 {\n+                mutex_set_locked_count(this, mutex_op, Scalar::from_u32(1))?;\n+                Ok(0)\n+            } else {\n+                throw_machine_stop!(TerminationInfo::Deadlock);\n+            }\n+        } else if kind == this.eval_libc(\"PTHREAD_MUTEX_ERRORCHECK\")? {\n+            if locked_count == 0 {\n+                mutex_set_locked_count(this, mutex_op, Scalar::from_u32(1))?;\n+                Ok(0)\n+            } else {\n+                this.eval_libc_i32(\"EDEADLK\")\n+            }\n+        } else if kind == this.eval_libc(\"PTHREAD_MUTEX_RECURSIVE\")? {\n+            match locked_count.checked_add(1) {\n+                Some(new_count) => {\n+                    mutex_set_locked_count(this, mutex_op, Scalar::from_u32(new_count))?;\n+                    Ok(0)\n+                }\n+                None => this.eval_libc_i32(\"EAGAIN\"),\n+            }\n+        } else {\n+            throw_ub_format!(\"called pthread_mutex_lock on an unsupported type of mutex\");\n+        }\n+    }\n+\n+    fn pthread_mutex_trylock(&mut self, mutex_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        let kind = mutex_get_kind(this, mutex_op)?.not_undef()?;\n+        let locked_count = mutex_get_locked_count(this, mutex_op)?.to_u32()?;\n+\n+        if kind == this.eval_libc(\"PTHREAD_MUTEX_NORMAL\")?\n+            || kind == this.eval_libc(\"PTHREAD_MUTEX_ERRORCHECK\")?\n+        {\n+            if locked_count == 0 {\n+                mutex_set_locked_count(this, mutex_op, Scalar::from_u32(1))?;\n+                Ok(0)\n+            } else {\n+                this.eval_libc_i32(\"EBUSY\")\n+            }\n+        } else if kind == this.eval_libc(\"PTHREAD_MUTEX_RECURSIVE\")? {\n+            match locked_count.checked_add(1) {\n+                Some(new_count) => {\n+                    mutex_set_locked_count(this, mutex_op, Scalar::from_u32(new_count))?;\n+                    Ok(0)\n+                }\n+                None => this.eval_libc_i32(\"EAGAIN\"),\n+            }\n+        } else {\n+            throw_ub_format!(\"called pthread_mutex_trylock on an unsupported type of mutex\");\n+        }\n+    }\n+\n+    fn pthread_mutex_unlock(&mut self, mutex_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        let kind = mutex_get_kind(this, mutex_op)?.not_undef()?;\n+        let locked_count = mutex_get_locked_count(this, mutex_op)?.to_u32()?;\n+\n+        if kind == this.eval_libc(\"PTHREAD_MUTEX_NORMAL\")? {\n+            if locked_count != 0 {\n+                mutex_set_locked_count(this, mutex_op, Scalar::from_u32(0))?;\n+                Ok(0)\n+            } else {\n+                throw_ub_format!(\"unlocked a PTHREAD_MUTEX_NORMAL mutex that was not locked\");\n+            }\n+        } else if kind == this.eval_libc(\"PTHREAD_MUTEX_ERRORCHECK\")? {\n+            if locked_count != 0 {\n+                mutex_set_locked_count(this, mutex_op, Scalar::from_u32(0))?;\n+                Ok(0)\n+            } else {\n+                this.eval_libc_i32(\"EPERM\")\n+            }\n+        } else if kind == this.eval_libc(\"PTHREAD_MUTEX_RECURSIVE\")? {\n+            match locked_count.checked_sub(1) {\n+                Some(new_count) => {\n+                    mutex_set_locked_count(this, mutex_op, Scalar::from_u32(new_count))?;\n+                    Ok(0)\n+                }\n+                None => {\n+                    // locked_count was already zero\n+                    this.eval_libc_i32(\"EPERM\")\n+                }\n+            }\n+        } else {\n+            throw_ub_format!(\"called pthread_mutex_unlock on an unsupported type of mutex\");\n+        }\n+    }\n+\n+    fn pthread_mutex_destroy(&mut self, mutex_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        if mutex_get_locked_count(this, mutex_op)?.to_u32()? != 0 {\n+            throw_ub_format!(\"destroyed a locked mutex\");\n+        }\n+\n+        mutex_set_kind(this, mutex_op, ScalarMaybeUndef::Undef)?;\n+        mutex_set_locked_count(this, mutex_op, ScalarMaybeUndef::Undef)?;\n+\n+        Ok(0)\n+    }\n+\n+    fn pthread_rwlock_rdlock(&mut self, rwlock_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        let readers = rwlock_get_readers(this, rwlock_op)?.to_u32()?;\n+        let writers = rwlock_get_writers(this, rwlock_op)?.to_u32()?;\n+        if writers != 0 {\n+            throw_machine_stop!(TerminationInfo::Deadlock);\n+        } else {\n+            match readers.checked_add(1) {\n+                Some(new_readers) => {\n+                    rwlock_set_readers(this, rwlock_op, Scalar::from_u32(new_readers))?;\n+                    Ok(0)\n+                }\n+                None => this.eval_libc_i32(\"EAGAIN\"),\n+            }\n+        }\n+    }\n+\n+    fn pthread_rwlock_tryrdlock(&mut self, rwlock_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        let readers = rwlock_get_readers(this, rwlock_op)?.to_u32()?;\n+        let writers = rwlock_get_writers(this, rwlock_op)?.to_u32()?;\n+        if writers != 0 {\n+            this.eval_libc_i32(\"EBUSY\")\n+        } else {\n+            match readers.checked_add(1) {\n+                Some(new_readers) => {\n+                    rwlock_set_readers(this, rwlock_op, Scalar::from_u32(new_readers))?;\n+                    Ok(0)\n+                }\n+                None => this.eval_libc_i32(\"EAGAIN\"),\n+            }\n+        }\n+    }\n+\n+    fn pthread_rwlock_wrlock(&mut self, rwlock_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        let readers = rwlock_get_readers(this, rwlock_op)?.to_u32()?;\n+        let writers = rwlock_get_writers(this, rwlock_op)?.to_u32()?;\n+        if readers != 0 {\n+            throw_machine_stop!(TerminationInfo::Deadlock);\n+        } else if writers != 0 {\n+            throw_machine_stop!(TerminationInfo::Deadlock);\n+        } else {\n+            rwlock_set_writers(this, rwlock_op, Scalar::from_u32(1))?;\n+            Ok(0)\n+        }\n+    }\n+\n+    fn pthread_rwlock_trywrlock(&mut self, rwlock_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        let readers = rwlock_get_readers(this, rwlock_op)?.to_u32()?;\n+        let writers = rwlock_get_writers(this, rwlock_op)?.to_u32()?;\n+        if readers != 0 || writers != 0 {\n+            this.eval_libc_i32(\"EBUSY\")\n+        } else {\n+            rwlock_set_writers(this, rwlock_op, Scalar::from_u32(1))?;\n+            Ok(0)\n+        }\n+    }\n+\n+    fn pthread_rwlock_unlock(&mut self, rwlock_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        let readers = rwlock_get_readers(this, rwlock_op)?.to_u32()?;\n+        let writers = rwlock_get_writers(this, rwlock_op)?.to_u32()?;\n+        if let Some(new_readers) = readers.checked_sub(1) {\n+            rwlock_set_readers(this, rwlock_op, Scalar::from_u32(new_readers))?;\n+            Ok(0)\n+        } else if writers != 0 {\n+            rwlock_set_writers(this, rwlock_op, Scalar::from_u32(0))?;\n+            Ok(0)\n+        } else {\n+            throw_ub_format!(\"unlocked an rwlock that was not locked\");\n+        }\n+    }\n+\n+    fn pthread_rwlock_destroy(&mut self, rwlock_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        if rwlock_get_readers(this, rwlock_op)?.to_u32()? != 0\n+            || rwlock_get_writers(this, rwlock_op)?.to_u32()? != 0\n+        {\n+            throw_ub_format!(\"destroyed a locked rwlock\");\n+        }\n+\n+        rwlock_set_readers(this, rwlock_op, ScalarMaybeUndef::Undef)?;\n+        rwlock_set_writers(this, rwlock_op, ScalarMaybeUndef::Undef)?;\n+\n+        Ok(0)\n+    }\n+}"}, {"sha": "e7ed8ad296211a9dbacf7cb917c84ac7bee382b4", "filename": "tests/compile-fail/libc_pthread_mutex_destroy_locked.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d935f621721212ae1d5329a72bead46de1c9339c/tests%2Fcompile-fail%2Flibc_pthread_mutex_destroy_locked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d935f621721212ae1d5329a72bead46de1c9339c/tests%2Fcompile-fail%2Flibc_pthread_mutex_destroy_locked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Flibc_pthread_mutex_destroy_locked.rs?ref=d935f621721212ae1d5329a72bead46de1c9339c", "patch": "@@ -0,0 +1,16 @@\n+// ignore-windows: No libc on Windows\n+\n+#![feature(rustc_private)]\n+\n+extern crate libc;\n+\n+fn main() {\n+    unsafe {\n+        let mut mutexattr: libc::pthread_mutexattr_t = std::mem::zeroed();\n+        assert_eq!(libc::pthread_mutexattr_settype(&mut mutexattr as *mut _, libc::PTHREAD_MUTEX_NORMAL), 0);\n+        let mut mutex: libc::pthread_mutex_t = std::mem::zeroed();\n+        assert_eq!(libc::pthread_mutex_init(&mut mutex as *mut _, &mutexattr as *const _), 0);\n+        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n+        libc::pthread_mutex_destroy(&mut mutex as *mut _); //~ ERROR destroyed a locked mutex\n+    }\n+}"}, {"sha": "7034bf64ec9019fdb65d07570e5ad084ecc0a20e", "filename": "tests/compile-fail/libc_pthread_mutex_normal_deadlock.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d935f621721212ae1d5329a72bead46de1c9339c/tests%2Fcompile-fail%2Flibc_pthread_mutex_normal_deadlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d935f621721212ae1d5329a72bead46de1c9339c/tests%2Fcompile-fail%2Flibc_pthread_mutex_normal_deadlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Flibc_pthread_mutex_normal_deadlock.rs?ref=d935f621721212ae1d5329a72bead46de1c9339c", "patch": "@@ -0,0 +1,16 @@\n+// ignore-windows: No libc on Windows\n+\n+#![feature(rustc_private)]\n+\n+extern crate libc;\n+\n+fn main() {\n+    unsafe {\n+        let mut mutexattr: libc::pthread_mutexattr_t = std::mem::zeroed();\n+        assert_eq!(libc::pthread_mutexattr_settype(&mut mutexattr as *mut _, libc::PTHREAD_MUTEX_NORMAL), 0);\n+        let mut mutex: libc::pthread_mutex_t = std::mem::zeroed();\n+        assert_eq!(libc::pthread_mutex_init(&mut mutex as *mut _, &mutexattr as *const _), 0);\n+        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n+        libc::pthread_mutex_lock(&mut mutex as *mut _); //~ ERROR deadlock\n+    }\n+}"}, {"sha": "65de62484d5ed9a809c96fb25cb03e11d6f4b546", "filename": "tests/compile-fail/libc_pthread_mutex_normal_unlock_unlocked.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d935f621721212ae1d5329a72bead46de1c9339c/tests%2Fcompile-fail%2Flibc_pthread_mutex_normal_unlock_unlocked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d935f621721212ae1d5329a72bead46de1c9339c/tests%2Fcompile-fail%2Flibc_pthread_mutex_normal_unlock_unlocked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Flibc_pthread_mutex_normal_unlock_unlocked.rs?ref=d935f621721212ae1d5329a72bead46de1c9339c", "patch": "@@ -0,0 +1,17 @@\n+// ignore-windows: No libc on Windows\n+\n+#![feature(rustc_private)]\n+\n+extern crate libc;\n+\n+fn main() {\n+    unsafe {\n+        let mut mutexattr: libc::pthread_mutexattr_t = std::mem::zeroed();\n+        assert_eq!(libc::pthread_mutexattr_settype(&mut mutexattr as *mut _, libc::PTHREAD_MUTEX_NORMAL), 0);\n+        let mut mutex: libc::pthread_mutex_t = std::mem::zeroed();\n+        assert_eq!(libc::pthread_mutex_init(&mut mutex as *mut _, &mutexattr as *const _), 0);\n+        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        libc::pthread_mutex_unlock(&mut mutex as *mut _); //~ ERROR was not locked\n+    }\n+}"}, {"sha": "8750a7388fca231d414160b053317ed559d9be16", "filename": "tests/compile-fail/libc_pthread_rwlock_destroy_read_locked.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d935f621721212ae1d5329a72bead46de1c9339c/tests%2Fcompile-fail%2Flibc_pthread_rwlock_destroy_read_locked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d935f621721212ae1d5329a72bead46de1c9339c/tests%2Fcompile-fail%2Flibc_pthread_rwlock_destroy_read_locked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Flibc_pthread_rwlock_destroy_read_locked.rs?ref=d935f621721212ae1d5329a72bead46de1c9339c", "patch": "@@ -0,0 +1,13 @@\n+// ignore-windows: No libc on Windows\n+\n+#![feature(rustc_private)]\n+\n+extern crate libc;\n+\n+fn main() {\n+    let rw = std::cell::UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER);\n+    unsafe {\n+        assert_eq!(libc::pthread_rwlock_rdlock(rw.get()), 0);\n+        libc::pthread_rwlock_destroy(rw.get()); //~ ERROR destroyed a locked rwlock\n+    }\n+}"}, {"sha": "aecccfa5031035e873baac2c7a91a80b6e9dfe0c", "filename": "tests/compile-fail/libc_pthread_rwlock_destroy_write_locked.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d935f621721212ae1d5329a72bead46de1c9339c/tests%2Fcompile-fail%2Flibc_pthread_rwlock_destroy_write_locked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d935f621721212ae1d5329a72bead46de1c9339c/tests%2Fcompile-fail%2Flibc_pthread_rwlock_destroy_write_locked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Flibc_pthread_rwlock_destroy_write_locked.rs?ref=d935f621721212ae1d5329a72bead46de1c9339c", "patch": "@@ -0,0 +1,13 @@\n+// ignore-windows: No libc on Windows\n+\n+#![feature(rustc_private)]\n+\n+extern crate libc;\n+\n+fn main() {\n+    let rw = std::cell::UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER);\n+    unsafe {\n+        assert_eq!(libc::pthread_rwlock_wrlock(rw.get()), 0);\n+        libc::pthread_rwlock_destroy(rw.get()); //~ ERROR destroyed a locked rwlock\n+    }\n+}"}, {"sha": "dd4707d60e4ca1c6700f81af58a426539328f708", "filename": "tests/compile-fail/libc_pthread_rwlock_read_write_deadlock.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d935f621721212ae1d5329a72bead46de1c9339c/tests%2Fcompile-fail%2Flibc_pthread_rwlock_read_write_deadlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d935f621721212ae1d5329a72bead46de1c9339c/tests%2Fcompile-fail%2Flibc_pthread_rwlock_read_write_deadlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Flibc_pthread_rwlock_read_write_deadlock.rs?ref=d935f621721212ae1d5329a72bead46de1c9339c", "patch": "@@ -0,0 +1,13 @@\n+// ignore-windows: No libc on Windows\n+\n+#![feature(rustc_private)]\n+\n+extern crate libc;\n+\n+fn main() {\n+    let rw = std::cell::UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER);\n+    unsafe {\n+        assert_eq!(libc::pthread_rwlock_rdlock(rw.get()), 0);\n+        libc::pthread_rwlock_wrlock(rw.get()); //~ ERROR: deadlock\n+    }\n+}"}, {"sha": "8b3de53828df66452950cf549a54bfb33b5762bc", "filename": "tests/compile-fail/libc_pthread_rwlock_unlock_unlocked.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d935f621721212ae1d5329a72bead46de1c9339c/tests%2Fcompile-fail%2Flibc_pthread_rwlock_unlock_unlocked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d935f621721212ae1d5329a72bead46de1c9339c/tests%2Fcompile-fail%2Flibc_pthread_rwlock_unlock_unlocked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Flibc_pthread_rwlock_unlock_unlocked.rs?ref=d935f621721212ae1d5329a72bead46de1c9339c", "patch": "@@ -0,0 +1,12 @@\n+// ignore-windows: No libc on Windows\n+\n+#![feature(rustc_private)]\n+\n+extern crate libc;\n+\n+fn main() {\n+    let rw = std::cell::UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER);\n+    unsafe {\n+        libc::pthread_rwlock_unlock(rw.get()); //~ ERROR was not locked\n+    }\n+}"}, {"sha": "1b460e7174d28f40f8c56fc89fc15d7762ff4596", "filename": "tests/compile-fail/libc_pthread_rwlock_write_read_deadlock.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d935f621721212ae1d5329a72bead46de1c9339c/tests%2Fcompile-fail%2Flibc_pthread_rwlock_write_read_deadlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d935f621721212ae1d5329a72bead46de1c9339c/tests%2Fcompile-fail%2Flibc_pthread_rwlock_write_read_deadlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Flibc_pthread_rwlock_write_read_deadlock.rs?ref=d935f621721212ae1d5329a72bead46de1c9339c", "patch": "@@ -0,0 +1,13 @@\n+// ignore-windows: No libc on Windows\n+\n+#![feature(rustc_private)]\n+\n+extern crate libc;\n+\n+fn main() {\n+    let rw = std::cell::UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER);\n+    unsafe {\n+        assert_eq!(libc::pthread_rwlock_wrlock(rw.get()), 0);\n+        libc::pthread_rwlock_rdlock(rw.get()); //~ ERROR: deadlock\n+    }\n+}"}, {"sha": "cc327ec46bc2989ed0302bb1d91afec0230d6662", "filename": "tests/compile-fail/libc_pthread_rwlock_write_write_deadlock.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d935f621721212ae1d5329a72bead46de1c9339c/tests%2Fcompile-fail%2Flibc_pthread_rwlock_write_write_deadlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d935f621721212ae1d5329a72bead46de1c9339c/tests%2Fcompile-fail%2Flibc_pthread_rwlock_write_write_deadlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Flibc_pthread_rwlock_write_write_deadlock.rs?ref=d935f621721212ae1d5329a72bead46de1c9339c", "patch": "@@ -0,0 +1,13 @@\n+// ignore-windows: No libc on Windows\n+\n+#![feature(rustc_private)]\n+\n+extern crate libc;\n+\n+fn main() {\n+    let rw = std::cell::UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER);\n+    unsafe {\n+        assert_eq!(libc::pthread_rwlock_wrlock(rw.get()), 0);\n+        libc::pthread_rwlock_wrlock(rw.get()); //~ ERROR: deadlock\n+    }\n+}"}, {"sha": "fc154c05c8fc38c1797d27e82af2d0ca56f1d8a9", "filename": "tests/run-pass/libc.rs", "status": "modified", "additions": 112, "deletions": 3, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/d935f621721212ae1d5329a72bead46de1c9339c/tests%2Frun-pass%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d935f621721212ae1d5329a72bead46de1c9339c/tests%2Frun-pass%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Flibc.rs?ref=d935f621721212ae1d5329a72bead46de1c9339c", "patch": "@@ -12,10 +12,10 @@ fn tmp() -> PathBuf {\n     std::env::var(\"MIRI_TEMP\").map(PathBuf::from).unwrap_or_else(|_| std::env::temp_dir())\n }\n \n-#[cfg(not(target_os = \"macos\"))]\n+#[cfg(target_os = \"linux\")]\n fn test_posix_fadvise() {\n     use std::convert::TryInto;\n-    use std::fs::{File, remove_file};\n+    use std::fs::{remove_file, File};\n     use std::io::Write;\n     use std::os::unix::io::AsRawFd;\n \n@@ -42,7 +42,116 @@ fn test_posix_fadvise() {\n     assert_eq!(result, 0);\n }\n \n+fn test_mutex_libc_init_recursive() {\n+    unsafe {\n+        let mut attr: libc::pthread_mutexattr_t = std::mem::zeroed();\n+        assert_eq!(libc::pthread_mutexattr_init(&mut attr as *mut _), 0);\n+        assert_eq!(libc::pthread_mutexattr_settype(&mut attr as *mut _, libc::PTHREAD_MUTEX_RECURSIVE), 0);\n+        let mut mutex: libc::pthread_mutex_t = std::mem::zeroed();\n+        assert_eq!(libc::pthread_mutex_init(&mut mutex as *mut _, &mut attr as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), libc::EPERM);\n+        assert_eq!(libc::pthread_mutex_destroy(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutexattr_destroy(&mut attr as *mut _), 0);\n+    }\n+}\n+\n+fn test_mutex_libc_init_normal() {\n+    unsafe {\n+        let mut mutexattr: libc::pthread_mutexattr_t = std::mem::zeroed();\n+        assert_eq!(libc::pthread_mutexattr_settype(&mut mutexattr as *mut _, 0x12345678), libc::EINVAL);\n+        assert_eq!(libc::pthread_mutexattr_settype(&mut mutexattr as *mut _, libc::PTHREAD_MUTEX_NORMAL), 0);\n+        let mut mutex: libc::pthread_mutex_t = std::mem::zeroed();\n+        assert_eq!(libc::pthread_mutex_init(&mut mutex as *mut _, &mutexattr as *const _), 0);\n+        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), libc::EBUSY);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_destroy(&mut mutex as *mut _), 0);\n+    }\n+}\n+\n+fn test_mutex_libc_init_errorcheck() {\n+    unsafe {\n+        let mut mutexattr: libc::pthread_mutexattr_t = std::mem::zeroed();\n+        assert_eq!(libc::pthread_mutexattr_settype(&mut mutexattr as *mut _, libc::PTHREAD_MUTEX_ERRORCHECK), 0);\n+        let mut mutex: libc::pthread_mutex_t = std::mem::zeroed();\n+        assert_eq!(libc::pthread_mutex_init(&mut mutex as *mut _, &mutexattr as *const _), 0);\n+        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), libc::EBUSY);\n+        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), libc::EDEADLK);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), libc::EPERM);\n+        assert_eq!(libc::pthread_mutex_destroy(&mut mutex as *mut _), 0);\n+    }\n+}\n+\n+// Only linux provides PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP,\n+// libc for macOS just has the default PTHREAD_MUTEX_INITIALIZER.\n+#[cfg(target_os = \"linux\")]\n+fn test_mutex_libc_static_initializer_recursive() {\n+    let mutex = std::cell::UnsafeCell::new(libc::PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP);\n+    unsafe {\n+        assert_eq!(libc::pthread_mutex_lock(mutex.get()), 0);\n+        assert_eq!(libc::pthread_mutex_trylock(mutex.get()), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(mutex.get()), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(mutex.get()), 0);\n+        assert_eq!(libc::pthread_mutex_trylock(mutex.get()), 0);\n+        assert_eq!(libc::pthread_mutex_lock(mutex.get()), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(mutex.get()), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(mutex.get()), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(mutex.get()), libc::EPERM);\n+        assert_eq!(libc::pthread_mutex_destroy(mutex.get()), 0);\n+    }\n+}\n+\n+// Testing the behavior of std::sync::RwLock does not fully exercise the pthread rwlock shims, we\n+// need to go a layer deeper and test the behavior of the libc functions, because\n+// std::sys::unix::rwlock::RWLock itself keeps track of write_locked and num_readers.\n+fn test_rwlock_libc_static_initializer() {\n+    let rw = std::cell::UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER);\n+    unsafe {\n+        assert_eq!(libc::pthread_rwlock_rdlock(rw.get()), 0);\n+        assert_eq!(libc::pthread_rwlock_rdlock(rw.get()), 0);\n+        assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n+        assert_eq!(libc::pthread_rwlock_tryrdlock(rw.get()), 0);\n+        assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n+        assert_eq!(libc::pthread_rwlock_trywrlock(rw.get()), libc::EBUSY);\n+        assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n+\n+        assert_eq!(libc::pthread_rwlock_wrlock(rw.get()), 0);\n+        assert_eq!(libc::pthread_rwlock_tryrdlock(rw.get()), libc::EBUSY);\n+        assert_eq!(libc::pthread_rwlock_trywrlock(rw.get()), libc::EBUSY);\n+        assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n+\n+        assert_eq!(libc::pthread_rwlock_trywrlock(rw.get()), 0);\n+        assert_eq!(libc::pthread_rwlock_tryrdlock(rw.get()), libc::EBUSY);\n+        assert_eq!(libc::pthread_rwlock_trywrlock(rw.get()), libc::EBUSY);\n+        assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n+\n+        assert_eq!(libc::pthread_rwlock_destroy(rw.get()), 0);\n+    }\n+}\n+\n fn main() {\n-    #[cfg(not(target_os = \"macos\"))]\n+    #[cfg(target_os = \"linux\")]\n     test_posix_fadvise();\n+\n+    test_mutex_libc_init_recursive();\n+    test_mutex_libc_init_normal();\n+    test_mutex_libc_init_errorcheck();\n+    test_rwlock_libc_static_initializer();\n+\n+    #[cfg(target_os = \"linux\")]\n+    test_mutex_libc_static_initializer_recursive();\n }"}, {"sha": "e73e82b8ec9ed3704b857eb743fddc5e84cfbb44", "filename": "tests/run-pass/reentrant-println.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d935f621721212ae1d5329a72bead46de1c9339c/tests%2Frun-pass%2Freentrant-println.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d935f621721212ae1d5329a72bead46de1c9339c/tests%2Frun-pass%2Freentrant-println.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Freentrant-println.rs?ref=d935f621721212ae1d5329a72bead46de1c9339c", "patch": "@@ -0,0 +1,17 @@\n+use std::fmt::{Display, Error, Formatter};\n+\n+// This test case exercises std::sys_common::remutex::ReentrantMutex\n+// by calling println!() from inside fmt.\n+\n+struct InterruptingCow;\n+\n+impl Display for InterruptingCow {\n+    fn fmt(&self, _f: &mut Formatter<'_>) -> Result<(), Error> {\n+        println!(\"Moo\");\n+        Ok(())\n+    }\n+}\n+\n+fn main() {\n+    println!(\"\\\"Knock knock\\\" \\\"Who's {} there?\\\"\", InterruptingCow);\n+}"}, {"sha": "8a57d32f84ca6b979c5105f364357ffa9f6d2d1f", "filename": "tests/run-pass/reentrant-println.stdout", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d935f621721212ae1d5329a72bead46de1c9339c/tests%2Frun-pass%2Freentrant-println.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/d935f621721212ae1d5329a72bead46de1c9339c/tests%2Frun-pass%2Freentrant-println.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Freentrant-println.stdout?ref=d935f621721212ae1d5329a72bead46de1c9339c", "patch": "@@ -0,0 +1,2 @@\n+\"Knock knock\" \"Who's Moo\n+ there?\""}, {"sha": "1ede5d42bb4babb595c061b2ba3c1a4356bbff6b", "filename": "tests/run-pass/sync.rs", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d935f621721212ae1d5329a72bead46de1c9339c/tests%2Frun-pass%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d935f621721212ae1d5329a72bead46de1c9339c/tests%2Frun-pass%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fsync.rs?ref=d935f621721212ae1d5329a72bead46de1c9339c", "patch": "@@ -1,18 +1,52 @@\n-// Just instantiate some data structures to make sure we got all their foreign items covered.\n-// Requires full MIR on Windows.\n+#![feature(rustc_private)]\n \n-use std::sync;\n+use std::sync::{Mutex, TryLockError};\n \n fn main() {\n-    let m = sync::Mutex::new(0);\n-    drop(m.lock());\n+    test_mutex_stdlib();\n+    #[cfg(not(target_os = \"windows\"))] // TODO: implement RwLock on Windows\n+    {\n+        test_rwlock_stdlib();\n+    }\n+}\n+\n+fn test_mutex_stdlib() {\n+    let m = Mutex::new(0);\n+    {\n+        let _guard = m.lock();\n+        assert!(m.try_lock().unwrap_err().would_block());\n+    }\n+    drop(m.try_lock().unwrap());\n     drop(m);\n+}\n \n-    #[cfg(not(target_os = \"windows\"))] // TODO: implement RwLock on Windows\n+#[cfg(not(target_os = \"windows\"))]\n+fn test_rwlock_stdlib() {\n+    use std::sync::RwLock;\n+    let rw = RwLock::new(0);\n     {\n-        let rw = sync::RwLock::new(0);\n-        drop(rw.read());\n-        drop(rw.write());\n-        drop(rw);\n+        let _read_guard = rw.read().unwrap();\n+        drop(rw.read().unwrap());\n+        drop(rw.try_read().unwrap());\n+        assert!(rw.try_write().unwrap_err().would_block());\n+    }\n+\n+    {\n+        let _write_guard = rw.write().unwrap();\n+        assert!(rw.try_read().unwrap_err().would_block());\n+        assert!(rw.try_write().unwrap_err().would_block());\n+    }\n+}\n+\n+trait TryLockErrorExt<T> {\n+    fn would_block(&self) -> bool;\n+}\n+\n+impl<T> TryLockErrorExt<T> for TryLockError<T> {\n+    fn would_block(&self) -> bool {\n+        match self {\n+            TryLockError::WouldBlock => true,\n+            TryLockError::Poisoned(_) => false,\n+        }\n     }\n }"}]}