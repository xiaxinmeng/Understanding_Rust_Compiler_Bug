{"sha": "324547140e0b67b109b43dfa79cc39cdf06151e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyNDU0NzE0MGUwYjY3YjEwOWI0M2RmYTc5Y2MzOWNkZjA2MTUxZTU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-28T19:37:04Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-28T19:37:04Z"}, "message": "syntax: Refactor diagnostics to focus on Writers\n\nThis commit alters the diagnostic emission machinery to be focused around a\nWriter for emitting errors. This allows it to not hard-code emission of errors\nto stderr (useful for other applications).", "tree": {"sha": "961e5a21bcf963ae184d7de40ab44bb84dfdff1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/961e5a21bcf963ae184d7de40ab44bb84dfdff1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/324547140e0b67b109b43dfa79cc39cdf06151e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/324547140e0b67b109b43dfa79cc39cdf06151e5", "html_url": "https://github.com/rust-lang/rust/commit/324547140e0b67b109b43dfa79cc39cdf06151e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/324547140e0b67b109b43dfa79cc39cdf06151e5/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b1be3d182e361697117bf79fadca7697f8b5aec", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b1be3d182e361697117bf79fadca7697f8b5aec", "html_url": "https://github.com/rust-lang/rust/commit/9b1be3d182e361697117bf79fadca7697f8b5aec"}], "stats": {"total": 233, "additions": 122, "deletions": 111}, "files": [{"sha": "cfd1d38fcff28ec7f49eafd063b41f0cc4368536", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/324547140e0b67b109b43dfa79cc39cdf06151e5/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/324547140e0b67b109b43dfa79cc39cdf06151e5/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=324547140e0b67b109b43dfa79cc39cdf06151e5", "patch": "@@ -931,7 +931,7 @@ pub fn build_session(sopts: @session::Options,\n                      -> Session {\n     let codemap = @codemap::CodeMap::new();\n     let diagnostic_handler =\n-        diagnostic::mk_handler();\n+        diagnostic::default_handler();\n     let span_diagnostic_handler =\n         diagnostic::mk_span_handler(diagnostic_handler, codemap);\n \n@@ -1149,7 +1149,8 @@ pub fn build_output_filenames(input: &Input,\n }\n \n pub fn early_error(msg: &str) -> ! {\n-    diagnostic::DefaultEmitter.emit(None, msg, diagnostic::Fatal);\n+    let mut emitter = diagnostic::EmitterWriter::stderr();\n+    emitter.emit(None, msg, diagnostic::Fatal);\n     fail!(diagnostic::FatalError);\n }\n "}, {"sha": "f1c9f9eea6f2110adecb90084e59cc571d4bc52d", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/324547140e0b67b109b43dfa79cc39cdf06151e5/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/324547140e0b67b109b43dfa79cc39cdf06151e5/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=324547140e0b67b109b43dfa79cc39cdf06151e5", "patch": "@@ -394,7 +394,8 @@ pub fn monitor(f: proc()) {\n         Err(value) => {\n             // Task failed without emitting a fatal diagnostic\n             if !value.is::<diagnostic::FatalError>() {\n-                diagnostic::DefaultEmitter.emit(\n+                let mut emitter = diagnostic::EmitterWriter::stderr();\n+                emitter.emit(\n                     None,\n                     diagnostic::ice_msg(\"unexpected failure\"),\n                     diagnostic::Error);\n@@ -404,9 +405,7 @@ pub fn monitor(f: proc()) {\n                      this is a bug\",\n                 ];\n                 for note in xs.iter() {\n-                    diagnostic::DefaultEmitter.emit(None,\n-                                                    *note,\n-                                                    diagnostic::Note)\n+                    emitter.emit(None, *note, diagnostic::Note)\n                 }\n \n                 println!(\"{}\", r.read_to_str());"}, {"sha": "179a848b7d0657489dfdf050dad79a8a692a103b", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/324547140e0b67b109b43dfa79cc39cdf06151e5/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/324547140e0b67b109b43dfa79cc39cdf06151e5/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=324547140e0b67b109b43dfa79cc39cdf06151e5", "patch": "@@ -25,6 +25,7 @@ use rustc::metadata::creader::Loader;\n use getopts;\n use syntax::diagnostic;\n use syntax::parse;\n+use syntax::codemap::CodeMap;\n \n use core;\n use clean;\n@@ -35,7 +36,6 @@ use passes;\n use visit_ast::RustdocVisitor;\n \n pub fn run(input: &str, matches: &getopts::Matches) -> int {\n-    let parsesess = parse::new_parse_sess();\n     let input_path = Path::new(input);\n     let input = driver::FileInput(input_path.clone());\n     let libs = matches.opt_strs(\"L\").map(|s| Path::new(s.as_slice()));\n@@ -49,9 +49,12 @@ pub fn run(input: &str, matches: &getopts::Matches) -> int {\n     };\n \n \n+    let cm = @CodeMap::new();\n     let diagnostic_handler = diagnostic::mk_handler();\n     let span_diagnostic_handler =\n-        diagnostic::mk_span_handler(diagnostic_handler, parsesess.cm);\n+        diagnostic::mk_span_handler(diagnostic_handler, cm);\n+    let parsesess = parse::new_parse_sess_special_handler(span_diagnostic_handler,\n+                                                          cm);\n \n     let sess = driver::build_session_(sessopts,\n                                       Some(input_path),"}, {"sha": "affeb86f782a3890d97e45305f32fe81fc11c9f7", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 109, "deletions": 101, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/324547140e0b67b109b43dfa79cc39cdf06151e5/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/324547140e0b67b109b43dfa79cc39cdf06151e5/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=324547140e0b67b109b43dfa79cc39cdf06151e5", "patch": "@@ -11,12 +11,10 @@\n use codemap::{Pos, Span};\n use codemap;\n \n-use std::cell::Cell;\n+use std::cell::{RefCell, Cell};\n use std::fmt;\n-use std::io::stdio::StdWriter;\n use std::io;\n use std::iter::range;\n-use std::local_data;\n use term;\n \n static BUG_REPORT_URL: &'static str =\n@@ -25,9 +23,9 @@ static BUG_REPORT_URL: &'static str =\n static MAX_LINES: uint = 6u;\n \n pub trait Emitter {\n-    fn emit(&self, cmsp: Option<(&codemap::CodeMap, Span)>,\n+    fn emit(&mut self, cmsp: Option<(&codemap::CodeMap, Span)>,\n             msg: &str, lvl: Level);\n-    fn custom_emit(&self, cm: &codemap::CodeMap,\n+    fn custom_emit(&mut self, cm: &codemap::CodeMap,\n                    sp: Span, msg: &str, lvl: Level);\n }\n \n@@ -78,16 +76,16 @@ impl SpanHandler {\n // others log errors for later reporting.\n pub struct Handler {\n     err_count: Cell<uint>,\n-    emit: DefaultEmitter,\n+    emit: RefCell<~Emitter>,\n }\n \n impl Handler {\n     pub fn fatal(&self, msg: &str) -> ! {\n-        self.emit.emit(None, msg, Fatal);\n+        self.emit.borrow_mut().get().emit(None, msg, Fatal);\n         fail!(FatalError);\n     }\n     pub fn err(&self, msg: &str) {\n-        self.emit.emit(None, msg, Error);\n+        self.emit.borrow_mut().get().emit(None, msg, Error);\n         self.bump_err_count();\n     }\n     pub fn bump_err_count(&self) {\n@@ -112,10 +110,10 @@ impl Handler {\n         self.fatal(s);\n     }\n     pub fn warn(&self, msg: &str) {\n-        self.emit.emit(None, msg, Warning);\n+        self.emit.borrow_mut().get().emit(None, msg, Warning);\n     }\n     pub fn note(&self, msg: &str) {\n-        self.emit.emit(None, msg, Note);\n+        self.emit.borrow_mut().get().emit(None, msg, Note);\n     }\n     pub fn bug(&self, msg: &str) -> ! {\n         self.fatal(ice_msg(msg));\n@@ -127,11 +125,11 @@ impl Handler {\n                 cmsp: Option<(&codemap::CodeMap, Span)>,\n                 msg: &str,\n                 lvl: Level) {\n-        self.emit.emit(cmsp, msg, lvl);\n+        self.emit.borrow_mut().get().emit(cmsp, msg, lvl);\n     }\n     pub fn custom_emit(&self, cm: &codemap::CodeMap,\n                        sp: Span, msg: &str, lvl: Level) {\n-        self.emit.custom_emit(cm, sp, msg, lvl);\n+        self.emit.borrow_mut().get().custom_emit(cm, sp, msg, lvl);\n     }\n }\n \n@@ -148,10 +146,14 @@ pub fn mk_span_handler(handler: @Handler, cm: @codemap::CodeMap)\n     }\n }\n \n-pub fn mk_handler() -> @Handler {\n+pub fn default_handler() -> @Handler {\n+    mk_handler(~EmitterWriter::stderr())\n+}\n+\n+pub fn mk_handler(e: ~Emitter) -> @Handler {\n     @Handler {\n         err_count: Cell::new(0),\n-        emit: DefaultEmitter,\n+        emit: RefCell::new(e),\n     }\n }\n \n@@ -185,73 +187,79 @@ impl Level {\n     }\n }\n \n-fn print_maybe_styled(msg: &str, color: term::attr::Attr) -> io::IoResult<()> {\n-    local_data_key!(tls_terminal: Option<term::Terminal<StdWriter>>)\n-\n-\n-    fn is_stderr_screen() -> bool {\n-        use std::libc;\n-        unsafe { libc::isatty(libc::STDERR_FILENO) != 0 }\n-    }\n-    fn write_pretty<T: Writer>(term: &mut term::Terminal<T>, s: &str,\n-                               c: term::attr::Attr) -> io::IoResult<()> {\n-        try!(term.attr(c));\n-        try!(term.write(s.as_bytes()));\n-        try!(term.reset());\n-        Ok(())\n-    }\n-\n-    if is_stderr_screen() {\n-        local_data::get_mut(tls_terminal, |term| {\n-            match term {\n-                Some(term) => {\n-                    match *term {\n-                        Some(ref mut term) => write_pretty(term, msg, color),\n-                        None => io::stderr().write(msg.as_bytes())\n-                    }\n-                }\n-                None => {\n-                    let (t, ret) = match term::Terminal::new(io::stderr()) {\n-                        Ok(mut term) => {\n-                            let r = write_pretty(&mut term, msg, color);\n-                            (Some(term), r)\n-                        }\n-                        Err(_) => {\n-                            (None, io::stderr().write(msg.as_bytes()))\n-                        }\n-                    };\n-                    local_data::set(tls_terminal, t);\n-                    ret\n-                }\n-            }\n-        })\n-    } else {\n-        io::stderr().write(msg.as_bytes())\n+fn print_maybe_styled(w: &mut EmitterWriter,\n+                      msg: &str,\n+                      color: term::attr::Attr) -> io::IoResult<()> {\n+    match w.dst {\n+        Terminal(ref mut t) => {\n+            try!(t.attr(color));\n+            try!(t.write_str(msg));\n+            try!(t.reset());\n+            Ok(())\n+        }\n+        Raw(ref mut w) => {\n+            w.write_str(msg)\n+        }\n     }\n }\n \n-fn print_diagnostic(topic: &str, lvl: Level, msg: &str) -> io::IoResult<()> {\n+fn print_diagnostic(dst: &mut EmitterWriter,\n+                    topic: &str, lvl: Level, msg: &str) -> io::IoResult<()> {\n     if !topic.is_empty() {\n-        let mut stderr = io::stderr();\n-        try!(write!(&mut stderr as &mut io::Writer, \"{} \", topic));\n+        try!(write!(&mut dst.dst, \"{} \", topic));\n     }\n \n-    try!(print_maybe_styled(format!(\"{}: \", lvl.to_str()),\n-                              term::attr::ForegroundColor(lvl.color())));\n-    try!(print_maybe_styled(format!(\"{}\\n\", msg), term::attr::Bold));\n+    try!(print_maybe_styled(dst, format!(\"{}: \", lvl.to_str()),\n+                            term::attr::ForegroundColor(lvl.color())));\n+    try!(print_maybe_styled(dst, format!(\"{}\\n\", msg), term::attr::Bold));\n     Ok(())\n }\n \n-pub struct DefaultEmitter;\n+pub struct EmitterWriter {\n+    priv dst: Destination,\n+}\n+\n+enum Destination {\n+    Terminal(term::Terminal<io::stdio::StdWriter>),\n+    Raw(~Writer),\n+}\n+\n+impl EmitterWriter {\n+    pub fn stderr() -> EmitterWriter {\n+        let stderr = io::stderr();\n+        if stderr.isatty() {\n+            let dst = match term::Terminal::new(stderr) {\n+                Ok(t) => Terminal(t),\n+                Err(..) => Raw(~io::stderr()),\n+            };\n+            EmitterWriter { dst: dst }\n+        } else {\n+            EmitterWriter { dst: Raw(~stderr) }\n+        }\n+    }\n+\n+    pub fn new(dst: ~Writer) -> EmitterWriter {\n+        EmitterWriter { dst: Raw(dst) }\n+    }\n+}\n+\n+impl Writer for Destination {\n+    fn write(&mut self, bytes: &[u8]) -> io::IoResult<()> {\n+        match *self {\n+            Terminal(ref mut t) => t.write(bytes),\n+            Raw(ref mut w) => w.write(bytes),\n+        }\n+    }\n+}\n \n-impl Emitter for DefaultEmitter {\n-    fn emit(&self,\n+impl Emitter for EmitterWriter {\n+    fn emit(&mut self,\n             cmsp: Option<(&codemap::CodeMap, Span)>,\n             msg: &str,\n             lvl: Level) {\n         let error = match cmsp {\n-            Some((cm, sp)) => emit(cm, sp, msg, lvl, false),\n-            None => print_diagnostic(\"\", lvl, msg),\n+            Some((cm, sp)) => emit(self, cm, sp, msg, lvl, false),\n+            None => print_diagnostic(self, \"\", lvl, msg),\n         };\n \n         match error {\n@@ -260,16 +268,16 @@ impl Emitter for DefaultEmitter {\n         }\n     }\n \n-    fn custom_emit(&self, cm: &codemap::CodeMap,\n+    fn custom_emit(&mut self, cm: &codemap::CodeMap,\n                    sp: Span, msg: &str, lvl: Level) {\n-        match emit(cm, sp, msg, lvl, true) {\n+        match emit(self, cm, sp, msg, lvl, true) {\n             Ok(()) => {}\n             Err(e) => fail!(\"failed to print diagnostics: {}\", e),\n         }\n     }\n }\n \n-fn emit(cm: &codemap::CodeMap, sp: Span,\n+fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, sp: Span,\n         msg: &str, lvl: Level, custom: bool) -> io::IoResult<()> {\n     let ss = cm.span_to_str(sp);\n     let lines = cm.span_to_lines(sp);\n@@ -279,22 +287,21 @@ fn emit(cm: &codemap::CodeMap, sp: Span,\n         // the span)\n         let span_end = Span { lo: sp.hi, hi: sp.hi, expn_info: sp.expn_info};\n         let ses = cm.span_to_str(span_end);\n-        try!(print_diagnostic(ses, lvl, msg));\n-        try!(custom_highlight_lines(cm, sp, lvl, lines));\n+        try!(print_diagnostic(dst, ses, lvl, msg));\n+        try!(custom_highlight_lines(dst, cm, sp, lvl, lines));\n     } else {\n-        try!(print_diagnostic(ss, lvl, msg));\n-        try!(highlight_lines(cm, sp, lvl, lines));\n+        try!(print_diagnostic(dst, ss, lvl, msg));\n+        try!(highlight_lines(dst, cm, sp, lvl, lines));\n     }\n-    print_macro_backtrace(cm, sp)\n+    print_macro_backtrace(dst, cm, sp)\n }\n \n-fn highlight_lines(cm: &codemap::CodeMap,\n+fn highlight_lines(err: &mut EmitterWriter,\n+                   cm: &codemap::CodeMap,\n                    sp: Span,\n                    lvl: Level,\n                    lines: &codemap::FileLines) -> io::IoResult<()> {\n     let fm = lines.file;\n-    let mut err = io::stderr();\n-    let err = &mut err as &mut io::Writer;\n \n     let mut elided = false;\n     let mut display_lines = lines.lines.as_slice();\n@@ -304,13 +311,13 @@ fn highlight_lines(cm: &codemap::CodeMap,\n     }\n     // Print the offending lines\n     for line in display_lines.iter() {\n-        try!(write!(err, \"{}:{} {}\\n\", fm.name, *line + 1,\n-                      fm.get_line(*line as int)));\n+        try!(write!(&mut err.dst, \"{}:{} {}\\n\", fm.name, *line + 1,\n+                    fm.get_line(*line as int)));\n     }\n     if elided {\n         let last_line = display_lines[display_lines.len() - 1u];\n         let s = format!(\"{}:{} \", fm.name, last_line + 1u);\n-        try!(write!(err, \"{0:1$}...\\n\", \"\", s.len()));\n+        try!(write!(&mut err.dst, \"{0:1$}...\\n\", \"\", s.len()));\n     }\n \n     // FIXME (#3260)\n@@ -342,16 +349,16 @@ fn highlight_lines(cm: &codemap::CodeMap,\n                 _ => s.push_char(' '),\n             };\n         }\n-        try!(write!(err, \"{}\", s));\n+        try!(write!(&mut err.dst, \"{}\", s));\n         let mut s = ~\"^\";\n         let hi = cm.lookup_char_pos(sp.hi);\n         if hi.col != lo.col {\n             // the ^ already takes up one space\n             let num_squigglies = hi.col.to_uint()-lo.col.to_uint()-1u;\n             for _ in range(0, num_squigglies) { s.push_char('~'); }\n         }\n-        try!(print_maybe_styled(s + \"\\n\",\n-                                  term::attr::ForegroundColor(lvl.color())));\n+        try!(print_maybe_styled(err, s + \"\\n\",\n+                                term::attr::ForegroundColor(lvl.color())));\n     }\n     Ok(())\n }\n@@ -362,26 +369,25 @@ fn highlight_lines(cm: &codemap::CodeMap,\n // than 6 lines), `custom_highlight_lines` will print the first line, then\n // dot dot dot, then last line, whereas `highlight_lines` prints the first\n // six lines.\n-fn custom_highlight_lines(cm: &codemap::CodeMap,\n+fn custom_highlight_lines(w: &mut EmitterWriter,\n+                          cm: &codemap::CodeMap,\n                           sp: Span,\n                           lvl: Level,\n                           lines: &codemap::FileLines) -> io::IoResult<()> {\n     let fm = lines.file;\n-    let mut err = io::stderr();\n-    let err = &mut err as &mut io::Writer;\n \n     let lines = lines.lines.as_slice();\n     if lines.len() > MAX_LINES {\n-        try!(write!(err, \"{}:{} {}\\n\", fm.name,\n-                      lines[0] + 1, fm.get_line(lines[0] as int)));\n-        try!(write!(err, \"...\\n\"));\n+        try!(write!(&mut w.dst, \"{}:{} {}\\n\", fm.name,\n+                    lines[0] + 1, fm.get_line(lines[0] as int)));\n+        try!(write!(&mut w.dst, \"...\\n\"));\n         let last_line = lines[lines.len()-1];\n-        try!(write!(err, \"{}:{} {}\\n\", fm.name,\n-                      last_line + 1, fm.get_line(last_line as int)));\n+        try!(write!(&mut w.dst, \"{}:{} {}\\n\", fm.name,\n+                    last_line + 1, fm.get_line(last_line as int)));\n     } else {\n         for line in lines.iter() {\n-            try!(write!(err, \"{}:{} {}\\n\", fm.name,\n-                          *line + 1, fm.get_line(*line as int)));\n+            try!(write!(&mut w.dst, \"{}:{} {}\\n\", fm.name,\n+                        *line + 1, fm.get_line(*line as int)));\n         }\n     }\n     let last_line_start = format!(\"{}:{} \", fm.name, lines[lines.len()-1]+1);\n@@ -391,22 +397,24 @@ fn custom_highlight_lines(cm: &codemap::CodeMap,\n     let mut s = ~\"\";\n     for _ in range(0, skip) { s.push_char(' '); }\n     s.push_char('^');\n-    print_maybe_styled(s + \"\\n\", term::attr::ForegroundColor(lvl.color()))\n+    print_maybe_styled(w, s + \"\\n\", term::attr::ForegroundColor(lvl.color()))\n }\n \n-fn print_macro_backtrace(cm: &codemap::CodeMap, sp: Span) -> io::IoResult<()> {\n+fn print_macro_backtrace(w: &mut EmitterWriter,\n+                         cm: &codemap::CodeMap,\n+                         sp: Span) -> io::IoResult<()> {\n     for ei in sp.expn_info.iter() {\n         let ss = ei.callee.span.as_ref().map_or(~\"\", |span| cm.span_to_str(*span));\n         let (pre, post) = match ei.callee.format {\n             codemap::MacroAttribute => (\"#[\", \"]\"),\n             codemap::MacroBang => (\"\", \"!\")\n         };\n-        try!(print_diagnostic(ss, Note,\n-                                format!(\"in expansion of {}{}{}\", pre,\n-                                        ei.callee.name, post)));\n+        try!(print_diagnostic(w, ss, Note,\n+                              format!(\"in expansion of {}{}{}\", pre,\n+                                      ei.callee.name, post)));\n         let ss = cm.span_to_str(ei.call_site);\n-        try!(print_diagnostic(ss, Note, \"expansion site\"));\n-        try!(print_macro_backtrace(cm, ei.call_site));\n+        try!(print_diagnostic(w, ss, Note, \"expansion site\"));\n+        try!(print_macro_backtrace(w, cm, ei.call_site));\n     }\n     Ok(())\n }"}, {"sha": "2d1c327ec3d9acf44df421a1adcff26be4c5e57e", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/324547140e0b67b109b43dfa79cc39cdf06151e5/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/324547140e0b67b109b43dfa79cc39cdf06151e5/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=324547140e0b67b109b43dfa79cc39cdf06151e5", "patch": "@@ -14,7 +14,7 @@\n use ast;\n use codemap::{Span, CodeMap, FileMap};\n use codemap;\n-use diagnostic::{SpanHandler, mk_span_handler, mk_handler};\n+use diagnostic::{SpanHandler, mk_span_handler, default_handler};\n use parse::attr::ParserAttr;\n use parse::parser::Parser;\n \n@@ -49,7 +49,7 @@ pub fn new_parse_sess() -> @ParseSess {\n     let cm = @CodeMap::new();\n     @ParseSess {\n         cm: cm,\n-        span_diagnostic: mk_span_handler(mk_handler(), cm),\n+        span_diagnostic: mk_span_handler(default_handler(), cm),\n         included_mod_stack: RefCell::new(~[]),\n     }\n }"}]}