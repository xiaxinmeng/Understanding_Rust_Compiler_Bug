{"sha": "7ed4ee272e5adf8cd267278acb62b9d9312ee34b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlZDRlZTI3MmU1YWRmOGNkMjY3Mjc4YWNiNjJiOWQ5MzEyZWUzNGI=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-06-21T23:03:14Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-07-04T13:31:55Z"}, "message": "Clean up and restructure sanity checking.", "tree": {"sha": "df0713f757893f835e9a40397b4e80338f14e789", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df0713f757893f835e9a40397b4e80338f14e789"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ed4ee272e5adf8cd267278acb62b9d9312ee34b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ed4ee272e5adf8cd267278acb62b9d9312ee34b", "html_url": "https://github.com/rust-lang/rust/commit/7ed4ee272e5adf8cd267278acb62b9d9312ee34b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ed4ee272e5adf8cd267278acb62b9d9312ee34b/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01e83a362ca2eee456e222e72cc6b65b951920dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/01e83a362ca2eee456e222e72cc6b65b951920dc", "html_url": "https://github.com/rust-lang/rust/commit/01e83a362ca2eee456e222e72cc6b65b951920dc"}], "stats": {"total": 146, "additions": 69, "deletions": 77}, "files": [{"sha": "12862e136dabe5337a03856751aaabe0f82b8515", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ed4ee272e5adf8cd267278acb62b9d9312ee34b/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed4ee272e5adf8cd267278acb62b9d9312ee34b/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=7ed4ee272e5adf8cd267278acb62b9d9312ee34b", "patch": "@@ -119,6 +119,7 @@ pub struct Config {\n /// Per-target configuration stored in the global configuration structure.\n #[derive(Default)]\n pub struct Target {\n+    /// Some(path to llvm-config) if using an external LLVM.\n     pub llvm_config: Option<PathBuf>,\n     pub jemalloc: Option<PathBuf>,\n     pub cc: Option<PathBuf>,"}, {"sha": "029118eb647b0a605a98a7cb9e18fb710084cbc9", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ed4ee272e5adf8cd267278acb62b9d9312ee34b/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed4ee272e5adf8cd267278acb62b9d9312ee34b/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=7ed4ee272e5adf8cd267278acb62b9d9312ee34b", "patch": "@@ -163,7 +163,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n         let mut pass_sanity_check = true;\n         match matches.free.get(0) {\n             Some(check_subcommand) => {\n-                if &check_subcommand != subcommand {\n+                if check_subcommand != subcommand {\n                     pass_sanity_check = false;\n                 }\n             },"}, {"sha": "41482ac57f9c5a6484eb80b646ce2e8fd4f4588e", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 67, "deletions": 76, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/7ed4ee272e5adf8cd267278acb62b9d9312ee34b/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed4ee272e5adf8cd267278acb62b9d9312ee34b/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=7ed4ee272e5adf8cd267278acb62b9d9312ee34b", "patch": "@@ -18,9 +18,9 @@\n //! In theory if we get past this phase it's a bug if a build fails, but in\n //! practice that's likely not true!\n \n-use std::collections::HashSet;\n+use std::collections::HashMap;\n use std::env;\n-use std::ffi::{OsStr, OsString};\n+use std::ffi::{OsString, OsStr};\n use std::fs;\n use std::process::Command;\n use std::path::PathBuf;\n@@ -29,9 +29,46 @@ use build_helper::output;\n \n use Build;\n \n+struct Finder {\n+    cache: HashMap<OsString, Option<PathBuf>>,\n+    path: OsString,\n+}\n+\n+impl Finder {\n+    fn new() -> Self {\n+        Self {\n+            cache: HashMap::new(),\n+            path: env::var_os(\"PATH\").unwrap_or_default()\n+        }\n+    }\n+\n+    fn maybe_have<S: AsRef<OsStr>>(&mut self, cmd: S) -> Option<PathBuf> {\n+        let cmd: OsString = cmd.as_ref().into();\n+        let path = self.path.clone();\n+        self.cache.entry(cmd.clone()).or_insert_with(|| {\n+            for path in env::split_paths(&path) {\n+                let target = path.join(&cmd);\n+                let mut cmd_alt = cmd.clone();\n+                cmd_alt.push(\".exe\");\n+                if target.is_file() || // some/path/git\n+                target.with_extension(\"exe\").exists() || // some/path/git.exe\n+                target.join(&cmd_alt).exists() { // some/path/git/git.exe\n+                    return Some(target);\n+                }\n+            }\n+            return None;\n+        }).clone()\n+    }\n+\n+    fn must_have<S: AsRef<OsStr>>(&mut self, cmd: S) -> PathBuf {\n+        self.maybe_have(&cmd).unwrap_or_else(|| {\n+            panic!(\"\\n\\ncouldn't find required command: {:?}\\n\\n\", cmd.as_ref());\n+        })\n+    }\n+}\n+\n pub fn check(build: &mut Build) {\n-    let mut checked = HashSet::new();\n-    let path = env::var_os(\"PATH\").unwrap_or(OsString::new());\n+    let path = env::var_os(\"PATH\").unwrap_or_default();\n     // On Windows, quotes are invalid characters for filename paths, and if\n     // one is present as part of the PATH then that can lead to the system\n     // being unable to identify the files properly. See\n@@ -41,110 +78,65 @@ pub fn check(build: &mut Build) {\n             panic!(\"PATH contains invalid character '\\\"'\");\n         }\n     }\n-    let have_cmd = |cmd: &OsStr| {\n-        for path in env::split_paths(&path) {\n-            let target = path.join(cmd);\n-            let mut cmd_alt = cmd.to_os_string();\n-            cmd_alt.push(\".exe\");\n-            if target.is_file() ||\n-               target.with_extension(\"exe\").exists() ||\n-               target.join(cmd_alt).exists() {\n-                return Some(target);\n-            }\n-        }\n-        return None;\n-    };\n-\n-    let mut need_cmd = |cmd: &OsStr| {\n-        if !checked.insert(cmd.to_owned()) {\n-            return\n-        }\n-        if have_cmd(cmd).is_none() {\n-            panic!(\"\\n\\ncouldn't find required command: {:?}\\n\\n\", cmd);\n-        }\n-    };\n \n+    let mut cmd_finder = Finder::new();\n     // If we've got a git directory we're gona need git to update\n     // submodules and learn about various other aspects.\n     if build.src_is_git {\n-        need_cmd(\"git\".as_ref());\n+        cmd_finder.must_have(\"git\");\n     }\n \n     // We need cmake, but only if we're actually building LLVM or sanitizers.\n     let building_llvm = build.config.host.iter()\n         .filter_map(|host| build.config.target_config.get(host))\n         .any(|config| config.llvm_config.is_none());\n     if building_llvm || build.config.sanitizers {\n-        need_cmd(\"cmake\".as_ref());\n+        cmd_finder.must_have(\"cmake\");\n     }\n \n     // Ninja is currently only used for LLVM itself.\n     if building_llvm && build.config.ninja {\n         // Some Linux distros rename `ninja` to `ninja-build`.\n         // CMake can work with either binary name.\n-        if have_cmd(\"ninja-build\".as_ref()).is_none() {\n-            need_cmd(\"ninja\".as_ref());\n+        if cmd_finder.maybe_have(\"ninja-build\").is_none() {\n+            cmd_finder.must_have(\"ninja\");\n         }\n     }\n \n-    if build.config.python.is_none() {\n-        // set by bootstrap.py\n-        if let Some(v) = env::var_os(\"BOOTSTRAP_PYTHON\") {\n-            build.config.python = Some(PathBuf::from(v));\n-        }\n-    }\n-    if build.config.python.is_none() {\n-        build.config.python = have_cmd(\"python2.7\".as_ref());\n-    }\n-    if build.config.python.is_none() {\n-        build.config.python = have_cmd(\"python2\".as_ref());\n-    }\n-    if build.config.python.is_none() {\n-        need_cmd(\"python\".as_ref());\n-        build.config.python = Some(\"python\".into());\n-    }\n-    need_cmd(build.config.python.as_ref().unwrap().as_ref());\n-\n+    build.config.python = build.config.python.take().map(|p| cmd_finder.must_have(p))\n+        .or_else(|| env::var_os(\"BOOTSTRAP_PYTHON\").map(PathBuf::from)) // set by bootstrap.py\n+        .or_else(|| cmd_finder.maybe_have(\"python2.7\"))\n+        .or_else(|| cmd_finder.maybe_have(\"python2\"))\n+        .or_else(|| Some(cmd_finder.must_have(\"python\")));\n \n-    if let Some(ref s) = build.config.nodejs {\n-        need_cmd(s.as_ref());\n-    } else {\n-        // Look for the nodejs command, needed for emscripten testing\n-        if let Some(node) = have_cmd(\"node\".as_ref()) {\n-            build.config.nodejs = Some(node);\n-        } else if let Some(node) = have_cmd(\"nodejs\".as_ref()) {\n-            build.config.nodejs = Some(node);\n-        }\n-    }\n+    build.config.nodejs = build.config.nodejs.take().map(|p| cmd_finder.must_have(p))\n+        .or_else(|| cmd_finder.maybe_have(\"node\"))\n+        .or_else(|| cmd_finder.maybe_have(\"nodejs\"));\n \n-    if let Some(ref gdb) = build.config.gdb {\n-        need_cmd(gdb.as_ref());\n-    } else {\n-        build.config.gdb = have_cmd(\"gdb\".as_ref());\n-    }\n+    build.config.gdb = build.config.gdb.take().map(|p| cmd_finder.must_have(p))\n+        .or_else(|| cmd_finder.maybe_have(\"gdb\"));\n \n     // We're gonna build some custom C code here and there, host triples\n     // also build some C++ shims for LLVM so we need a C++ compiler.\n-    for target in build.config.target.iter() {\n+    for target in &build.config.target {\n         // On emscripten we don't actually need the C compiler to just\n         // build the target artifacts, only for testing. For the sake\n         // of easier bot configuration, just skip detection.\n         if target.contains(\"emscripten\") {\n             continue;\n         }\n \n-        need_cmd(build.cc(target).as_ref());\n+        cmd_finder.must_have(build.cc(target));\n         if let Some(ar) = build.ar(target) {\n-            need_cmd(ar.as_ref());\n+            cmd_finder.must_have(ar);\n         }\n     }\n-    for host in build.config.host.iter() {\n-        need_cmd(build.cxx(host).unwrap().as_ref());\n-    }\n \n-    // The msvc hosts don't use jemalloc, turn it off globally to\n-    // avoid packaging the dummy liballoc_jemalloc on that platform.\n     for host in build.config.host.iter() {\n+        cmd_finder.must_have(build.cxx(host).unwrap());\n+\n+        // The msvc hosts don't use jemalloc, turn it off globally to\n+        // avoid packaging the dummy liballoc_jemalloc on that platform.\n         if host.contains(\"msvc\") {\n             build.config.use_jemalloc = false;\n         }\n@@ -156,7 +148,7 @@ pub fn check(build: &mut Build) {\n         panic!(\"FileCheck executable {:?} does not exist\", filecheck);\n     }\n \n-    for target in build.config.target.iter() {\n+    for target in &build.config.target {\n         // Can't compile for iOS unless we're on macOS\n         if target.contains(\"apple-ios\") &&\n            !build.config.build.contains(\"apple-darwin\") {\n@@ -208,13 +200,12 @@ $ pacman -R cmake && pacman -S mingw-w64-x86_64-cmake\n \n     for host in build.flags.host.iter() {\n         if !build.config.host.contains(host) {\n-            panic!(\"specified host `{}` is not in the ./configure list\", host);\n+            panic!(\"specified host `{}` is not in configuration\", host);\n         }\n     }\n     for target in build.flags.target.iter() {\n         if !build.config.target.contains(target) {\n-            panic!(\"specified target `{}` is not in the ./configure list\",\n-                   target);\n+            panic!(\"specified target `{}` is not in configuration\", target);\n         }\n     }\n \n@@ -231,6 +222,6 @@ $ pacman -R cmake && pacman -S mingw-w64-x86_64-cmake\n     }\n \n     if let Some(ref s) = build.config.ccache {\n-        need_cmd(s.as_ref());\n+        cmd_finder.must_have(s);\n     }\n }"}]}