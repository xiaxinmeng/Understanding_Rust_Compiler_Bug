{"sha": "1dd2f1ec03f41e9ce15fdfe2c729b74f74df2e64", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkZDJmMWVjMDNmNDFlOWNlMTVmZGZlMmM3MjliNzRmNzRkZjJlNjQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-14T13:38:25Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-16T10:46:57Z"}, "message": "Get very simple impl method calls to compile\n\nResolution is still dumb, and no self support yet.", "tree": {"sha": "7578d955b5478408dcf1b653032e6b02bb38f85b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7578d955b5478408dcf1b653032e6b02bb38f85b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1dd2f1ec03f41e9ce15fdfe2c729b74f74df2e64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1dd2f1ec03f41e9ce15fdfe2c729b74f74df2e64", "html_url": "https://github.com/rust-lang/rust/commit/1dd2f1ec03f41e9ce15fdfe2c729b74f74df2e64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1dd2f1ec03f41e9ce15fdfe2c729b74f74df2e64/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a16f57c0a3f37d86b4c8e074f0796669fcd9528", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a16f57c0a3f37d86b4c8e074f0796669fcd9528", "html_url": "https://github.com/rust-lang/rust/commit/6a16f57c0a3f37d86b4c8e074f0796669fcd9528"}], "stats": {"total": 163, "additions": 103, "deletions": 60}, "files": [{"sha": "758f9bf85b6c2d2d79df665a4dd5db4d1d4a4481", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1dd2f1ec03f41e9ce15fdfe2c729b74f74df2e64/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dd2f1ec03f41e9ce15fdfe2c729b74f74df2e64/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=1dd2f1ec03f41e9ce15fdfe2c729b74f74df2e64", "patch": "@@ -171,8 +171,8 @@ fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n     time(time_passes, \"const checking\",\n          bind middle::check_const::check_crate(sess, crate));\n     let ty_cx = ty::mk_ctxt(sess, def_map, ext_map, ast_map, freevars);\n-    time(time_passes, \"typechecking\",\n-         bind typeck::check_crate(ty_cx, impl_map, crate));\n+    let method_map = time(time_passes, \"typechecking\",\n+                          bind typeck::check_crate(ty_cx, impl_map, crate));\n     time(time_passes, \"block-use checking\",\n          bind middle::block_use::check_crate(ty_cx, crate));\n     time(time_passes, \"function usage\",\n@@ -190,7 +190,7 @@ fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n     let last_uses = time(time_passes, \"last use finding\",\n         bind last_use::find_last_uses(crate, def_map, ref_map, ty_cx));\n     time(time_passes, \"kind checking\",\n-         bind kind::check_crate(ty_cx, last_uses, crate));\n+         bind kind::check_crate(ty_cx, method_map, last_uses, crate));\n     if sess.get_opts().no_trans { ret; }\n \n     let outputs = build_output_filenames(input, outdir, output, sess);\n@@ -199,7 +199,8 @@ fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n         time(time_passes, \"translation\",\n              bind trans::trans_crate(sess, crate, ty_cx,\n                                      outputs.obj_filename, exp_map, ast_map,\n-                                     mut_map, copy_map, last_uses));\n+                                     mut_map, copy_map, last_uses,\n+                                     method_map));\n     time(time_passes, \"LLVM passes\",\n          bind link::write::run_passes(sess, llmod, outputs.obj_filename));\n "}, {"sha": "863d02d3d92cc3d4f4633b54d11fd3ef52b60e9b", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1dd2f1ec03f41e9ce15fdfe2c729b74f74df2e64/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dd2f1ec03f41e9ce15fdfe2c729b74f74df2e64/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=1dd2f1ec03f41e9ce15fdfe2c729b74f74df2e64", "patch": "@@ -30,12 +30,15 @@ type rval_map = std::map::hashmap<node_id, ()>;\n \n type ctx = {tcx: ty::ctxt,\n             rval_map: rval_map,\n+            method_map: typeck::method_map,\n             last_uses: last_use::last_uses};\n \n-fn check_crate(tcx: ty::ctxt, last_uses: last_use::last_uses,\n-               crate: @crate) -> rval_map {\n+fn check_crate(tcx: ty::ctxt, method_map: typeck::method_map,\n+               last_uses: last_use::last_uses, crate: @crate)\n+    -> rval_map {\n     let ctx = {tcx: tcx,\n                rval_map: std::map::new_int_hash(),\n+               method_map: method_map,\n                last_uses: last_uses};\n     let visit = visit::mk_vt(@{\n         visit_expr: check_expr,\n@@ -150,7 +153,8 @@ fn maybe_copy(cx: ctx, ex: @expr) {\n }\n \n fn check_copy_ex(cx: ctx, ex: @expr, _warn: bool) {\n-    if ty::expr_is_lval(cx.tcx, ex) && !cx.last_uses.contains_key(ex.id) {\n+    if ty::expr_is_lval(cx.method_map, cx.tcx, ex) &&\n+       !cx.last_uses.contains_key(ex.id) {\n         let ty = ty::expr_ty(cx.tcx, ex);\n         check_copy(cx, ty, ex.span);\n         // FIXME turn this on again once vector types are no longer unique."}, {"sha": "886a8da204858677cab96fd903e9c4efd8ba8cc6", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 62, "deletions": 33, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/1dd2f1ec03f41e9ce15fdfe2c729b74f74df2e64/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dd2f1ec03f41e9ce15fdfe2c729b74f74df2e64/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=1dd2f1ec03f41e9ce15fdfe2c729b74f74df2e64", "patch": "@@ -13,7 +13,7 @@\n //     but many TypeRefs correspond to one ty::t; for instance, tup(int, int,\n //     int) and rec(x=int, y=int, z=int) will have the same TypeRef.\n \n-import core::{either, str, uint, option, vec};\n+import core::{either, str, int, uint, option, vec};\n import std::{map, time};\n import std::map::hashmap;\n import std::map::{new_int_hash, new_str_hash};\n@@ -948,8 +948,6 @@ fn get_derived_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n                       &static_ti: option::t<@tydesc_info>) -> result {\n     alt cx.fcx.derived_tydescs.find(t) {\n       some(info) {\n-\n-\n         // If the tydesc escapes in this context, the cached derived\n         // tydesc also has to be one that was marked as escaping.\n         if !(escapes && !info.escapes) && storage == tps_normal {\n@@ -2606,8 +2604,9 @@ fn trans_external_path(cx: @block_ctxt, did: ast::def_id,\n                          type_of_ty_param_kinds_and_ty(lcx, cx.sp, tpt));\n }\n \n-fn lval_static_fn(bcx: @block_ctxt, tpt: ty::ty_param_kinds_and_ty,\n-                  fn_id: ast::def_id, id: ast::node_id) -> lval_maybe_callee {\n+fn lval_static_fn(bcx: @block_ctxt, fn_id: ast::def_id, id: ast::node_id)\n+    -> lval_maybe_callee {\n+    let tpt = ty::lookup_item_type(bcx_tcx(bcx), fn_id);\n     let val = if fn_id.crate == ast::local_crate {\n         // Internal reference.\n         assert (bcx_ccx(bcx).item_ids.contains_key(fn_id.node));\n@@ -2698,17 +2697,13 @@ fn trans_var(cx: @block_ctxt, sp: span, def: ast::def, id: ast::node_id)\n     let ccx = bcx_ccx(cx);\n     alt def {\n       ast::def_fn(did, _) | ast::def_native_fn(did, _) {\n-        let tyt = ty::lookup_item_type(ccx.tcx, did);\n-        ret lval_static_fn(cx, tyt, did, id);\n+        ret lval_static_fn(cx, did, id);\n       }\n       ast::def_variant(tid, vid) {\n-        let v_tyt = ty::lookup_item_type(ccx.tcx, vid);\n-        alt ty::struct(ccx.tcx, v_tyt.ty) {\n-          ty::ty_fn(_, _, _, _, _) {\n+        if vec::len(ty::tag_variant_with_id(ccx.tcx, tid, vid).args) > 0u {\n             // N-ary variant.\n-            ret lval_static_fn(cx, v_tyt, vid, id);\n-          }\n-          _ {\n+            ret lval_static_fn(cx, vid, id);\n+        } else {\n             // Nullary variant.\n             let tag_ty = node_id_type(ccx, id);\n             let alloc_result = alloc_ty(cx, tag_ty);\n@@ -2724,7 +2719,6 @@ fn trans_var(cx: @block_ctxt, sp: span, def: ast::def, id: ast::node_id)\n             } else { C_int(ccx, 0) };\n             Store(bcx, d, lldiscrimptr);\n             ret lval_no_env(bcx, lltagptr, temporary);\n-          }\n         }\n       }\n       ast::def_const(did) {\n@@ -2838,15 +2832,30 @@ fn trans_index(cx: @block_ctxt, sp: span, base: @ast::expr, idx: @ast::expr,\n     ret lval_owned(next_cx, elt);\n }\n \n+// This is for impl methods, not obj methods.\n+fn trans_method_callee(bcx: @block_ctxt, e: @ast::expr, base: @ast::expr,\n+                       did: ast::def_id) -> lval_maybe_callee {\n+    let bcx = trans_expr(bcx, base, ignore); // FIXME pass self\n+    lval_static_fn(bcx, did, e.id)\n+}\n+\n fn trans_callee(bcx: @block_ctxt, e: @ast::expr) -> lval_maybe_callee {\n     alt e.node {\n       ast::expr_path(p) { ret trans_path(bcx, p, e.id); }\n       ast::expr_field(base, ident) {\n+        let method_map = bcx_ccx(bcx).method_map;\n         // Lval means this is a record field, so not a method\n-        if !ty::expr_is_lval(bcx_tcx(bcx), e) {\n-            let of = trans_object_field(bcx, base, ident);\n-            ret {bcx: of.bcx, val: of.mthptr, kind: owned,\n-                 env: obj_env(of.objptr), generic: none};\n+        if !ty::expr_is_lval(method_map, bcx_tcx(bcx), e) {\n+            alt method_map.find(e.id) {\n+              some(did) { // An impl method\n+                ret trans_method_callee(bcx, e, base, did);\n+              }\n+              none. { // An object method\n+                let of = trans_object_field(bcx, base, ident);\n+                ret {bcx: of.bcx, val: of.mthptr, kind: owned,\n+                     env: obj_env(of.objptr), generic: none};\n+              }\n+            }\n         }\n       }\n       ast::expr_self_method(ident) {\n@@ -3466,7 +3475,7 @@ fn trans_expr_save_in(bcx: @block_ctxt, e: @ast::expr, dest: ValueRef)\n // use trans_temp_expr.\n fn trans_temp_lval(bcx: @block_ctxt, e: @ast::expr) -> lval_result {\n     let bcx = bcx;\n-    if ty::expr_is_lval(bcx_tcx(bcx), e) {\n+    if ty::expr_is_lval(bcx_ccx(bcx).method_map, bcx_tcx(bcx), e) {\n         ret trans_lval(bcx, e);\n     } else {\n         let tcx = bcx_tcx(bcx);\n@@ -3504,7 +3513,9 @@ fn trans_temp_expr(bcx: @block_ctxt, e: @ast::expr) -> result {\n // - exprs with non-immediate type never get dest=by_val\n fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n     let tcx = bcx_tcx(bcx);\n-    if ty::expr_is_lval(tcx, e) { ret lval_to_dps(bcx, e, dest); }\n+    if ty::expr_is_lval(bcx_ccx(bcx).method_map, tcx, e) {\n+        ret lval_to_dps(bcx, e, dest);\n+    }\n \n     alt e.node {\n       ast::expr_if(cond, thn, els) | ast::expr_if_check(cond, thn, els) {\n@@ -3544,7 +3555,9 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         ret trans_closure::trans_bind(bcx, f, args, e.id, dest);\n       }\n       ast::expr_copy(a) {\n-        if !ty::expr_is_lval(tcx, a) { ret trans_expr(bcx, a, dest); }\n+        if !ty::expr_is_lval(bcx_ccx(bcx).method_map, tcx, a) {\n+            ret trans_expr(bcx, a, dest);\n+        }\n         else { ret lval_to_dps(bcx, a, dest); }\n       }\n       ast::expr_cast(val, _) {\n@@ -3945,7 +3958,8 @@ fn init_local(bcx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n     alt local.node.init {\n       some(init) {\n         if init.op == ast::init_assign ||\n-           !ty::expr_is_lval(bcx_tcx(bcx), init.expr) {\n+           !ty::expr_is_lval(bcx_ccx(bcx).method_map, bcx_tcx(bcx),\n+                             init.expr) {\n             bcx = trans_expr_save_in(bcx, init.expr, llptr);\n         } else { // This is a move from an lval, must perform an actual move\n             let sub = trans_lval(bcx, init.expr);\n@@ -4641,6 +4655,18 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n     finish_fn(fcx, lltop);\n }\n \n+fn trans_impl(cx: @local_ctxt, name: ast::ident, methods: [@ast::method]) {\n+    let sub_cx = extend_path(cx, name);\n+    for m in methods {\n+        alt cx.ccx.item_ids.find(m.node.id) {\n+          some(llfndecl) {\n+            trans_fn(extend_path(sub_cx, m.node.ident), m.span, m.node.meth,\n+                     llfndecl, none, [], m.node.id);\n+          }\n+        }\n+    }\n+}\n+\n \n // FIXME: this should do some structural hash-consing to avoid\n // duplicate constants. I think. Maybe LLVM has a magical mode\n@@ -4949,10 +4975,7 @@ fn trans_item(cx: @local_ctxt, item: ast::item) {\n                  with *extend_path(cx, item.ident)};\n         trans_obj(sub_cx, item.span, ob, ctor_id, tps);\n       }\n-      ast::item_impl(_, _, _) {\n-        \n-        fail \"FIXME[impl]\";\n-      }\n+      ast::item_impl(_, _, ms) { trans_impl(cx, item.ident, ms); }\n       ast::item_res(dtor, dtor_id, tps, ctor_id) {\n         trans_res_ctor(cx, item.span, dtor, ctor_id, tps);\n \n@@ -5167,8 +5190,6 @@ fn raw_native_fn_type(ccx: @crate_ctxt, sp: span, args: [ty::arg],\n     ret T_fn(type_of_explicit_args(ccx, sp, args), type_of(ccx, sp, ret_ty));\n }\n \n-fn item_path(item: @ast::item) -> [str] { ret [item.ident]; }\n-\n fn link_name(i: @ast::native_item) -> str {\n     alt attr::get_meta_item_value_str_by_name(i.attrs, \"link_name\") {\n       none. { ret i.ident; }\n@@ -5259,12 +5280,12 @@ fn collect_item_1(ccx: @crate_ctxt, abi: @mutable option::t<ast::native_abi>,\n       }\n       _ { }\n     }\n-    visit::visit_item(i, pt + item_path(i), v);\n+    visit::visit_item(i, pt + [i.ident], v);\n }\n \n fn collect_item_2(ccx: @crate_ctxt, i: @ast::item, &&pt: [str],\n                   v: vt<[str]>) {\n-    let new_pt = pt + item_path(i);\n+    let new_pt = pt + [i.ident];\n     visit::visit_item(i, new_pt, v);\n     alt i.node {\n       ast::item_fn(f, tps) {\n@@ -5278,6 +5299,13 @@ fn collect_item_2(ccx: @crate_ctxt, i: @ast::item, &&pt: [str],\n             ccx.obj_methods.insert(m.node.id, ());\n         }\n       }\n+      ast::item_impl(_, _, methods) {\n+        let name = ccx.names.next(i.ident);\n+        for m in methods {\n+            register_fn(ccx, i.span, pt + [name, m.node.ident],\n+                        \"impl_method\", [], m.node.id);\n+        }\n+      }\n       ast::item_res(_, dtor_id, tps, ctor_id) {\n         register_fn(ccx, i.span, new_pt, \"res_ctor\", tps, ctor_id);\n         // Note that the destructor is associated with the item's id, not\n@@ -5307,7 +5335,7 @@ fn collect_items(ccx: @crate_ctxt, crate: @ast::crate) {\n \n fn collect_tag_ctor(ccx: @crate_ctxt, i: @ast::item, &&pt: [str],\n                     v: vt<[str]>) {\n-    let new_pt = pt + item_path(i);\n+    let new_pt = pt + [i.ident];\n     visit::visit_item(i, new_pt, v);\n     alt i.node {\n       ast::item_tag(variants, tps) {\n@@ -5333,7 +5361,7 @@ fn collect_tag_ctors(ccx: @crate_ctxt, crate: @ast::crate) {\n // The constant translation pass.\n fn trans_constant(ccx: @crate_ctxt, it: @ast::item, &&pt: [str],\n                   v: vt<[str]>) {\n-    let new_pt = pt + item_path(it);\n+    let new_pt = pt + [it.ident];\n     visit::visit_item(it, new_pt, v);\n     alt it.node {\n       ast::item_tag(variants, _) {\n@@ -5520,7 +5548,7 @@ fn write_abi_version(ccx: @crate_ctxt) {\n fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n                output: str, emap: resolve::exp_map, amap: ast_map::map,\n                mut_map: mut::mut_map, copy_map: alias::copy_map,\n-               last_uses: last_use::last_uses)\n+               last_uses: last_use::last_uses, method_map: typeck::method_map)\n     -> (ModuleRef, link::link_meta) {\n     let sha = std::sha1::mk_sha1();\n     let link_meta = link::build_link_meta(sess, *crate, output, sha);\n@@ -5595,6 +5623,7 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           mut_map: mut_map,\n           copy_map: copy_map,\n           last_uses: last_uses,\n+          method_map: method_map,\n           stats:\n               {mutable n_static_tydescs: 0u,\n                mutable n_derived_tydescs: 0u,"}, {"sha": "19f439235e421eeaf391e2abda046120e65150eb", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1dd2f1ec03f41e9ce15fdfe2c729b74f74df2e64/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dd2f1ec03f41e9ce15fdfe2c729b74f74df2e64/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=1dd2f1ec03f41e9ce15fdfe2c729b74f74df2e64", "patch": "@@ -104,6 +104,7 @@ type crate_ctxt =\n      mut_map: mut::mut_map,\n      copy_map: alias::copy_map,\n      last_uses: last_use::last_uses,\n+     method_map: typeck::method_map,\n      stats: stats,\n      upcalls: @upcall::upcalls,\n      rust_object_type: TypeRef,"}, {"sha": "4265044c29607991a6a549f36e3735dccc81dec3", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1dd2f1ec03f41e9ce15fdfe2c729b74f74df2e64/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dd2f1ec03f41e9ce15fdfe2c729b74f74df2e64/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=1dd2f1ec03f41e9ce15fdfe2c729b74f74df2e64", "patch": "@@ -1672,15 +1672,18 @@ fn expr_has_ty_params(cx: ctxt, expr: @ast::expr) -> bool {\n     ret node_id_has_type_params(cx, expr.id);\n }\n \n-fn expr_is_lval(tcx: ty::ctxt, e: @ast::expr) -> bool {\n+fn expr_is_lval(method_map: typeck::method_map, tcx: ty::ctxt,\n+                e: @ast::expr) -> bool {\n     alt e.node {\n       ast::expr_path(_) | ast::expr_index(_, _) |\n       ast::expr_unary(ast::deref., _) { true }\n       ast::expr_field(base, ident) {\n-        let basety = type_autoderef(tcx, expr_ty(tcx, base));\n-        alt struct(tcx, basety) {\n-          ty_obj(_) { false }\n-          ty_rec(_) { true }\n+        method_map.contains_key(e.id) ? false : {\n+            let basety = type_autoderef(tcx, expr_ty(tcx, base));\n+            alt struct(tcx, basety) {\n+              ty_obj(_) { false }\n+              ty_rec(_) { true }\n+            }\n         }\n       }\n       _ { false }"}, {"sha": "03b7f40470d1ad887c7c782e6056a3a41b4a59cd", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1dd2f1ec03f41e9ce15fdfe2c729b74f74df2e64/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dd2f1ec03f41e9ce15fdfe2c729b74f74df2e64/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=1dd2f1ec03f41e9ce15fdfe2c729b74f74df2e64", "patch": "@@ -18,7 +18,9 @@ import std::map::{hashmap, new_int_hash};\n import option::{none, some};\n import syntax::print::pprust::*;\n \n-export check_crate;\n+export check_crate, method_map;\n+\n+type method_map = hashmap<ast::node_id, ast::def_id>;\n \n type ty_table = hashmap<ast::def_id, ty::t>;\n \n@@ -35,6 +37,7 @@ tag obj_info {\n \n type crate_ctxt = {mutable obj_infos: [obj_info],\n                    impl_map: resolve::impl_map,\n+                   method_map: method_map,\n                    tcx: ty::ctxt};\n \n type fn_ctxt =\n@@ -74,22 +77,21 @@ fn lookup_def(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> ast::def {\n // Returns the type parameter count and the type for the given definition.\n fn ty_param_kinds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n    ty_param_kinds_and_ty {\n-    let no_kinds: [ast::kind] = [];\n     alt defn {\n       ast::def_arg(id, _) {\n         assert (fcx.locals.contains_key(id.node));\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id.node));\n-        ret {kinds: no_kinds, ty: typ};\n+        ret {kinds: [], ty: typ};\n       }\n       ast::def_local(id, _) {\n         assert (fcx.locals.contains_key(id.node));\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id.node));\n-        ret {kinds: no_kinds, ty: typ};\n+        ret {kinds: [], ty: typ};\n       }\n       ast::def_obj_field(id, _) {\n         assert (fcx.locals.contains_key(id.node));\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id.node));\n-        ret {kinds: no_kinds, ty: typ};\n+        ret {kinds: [], ty: typ};\n       }\n       ast::def_self(id) { fail \"FIXME[impl]\"; }\n       ast::def_fn(id, _) { ret ty::lookup_item_type(fcx.ccx.tcx, id); }\n@@ -99,12 +101,12 @@ fn ty_param_kinds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n       ast::def_binding(id) {\n         assert (fcx.locals.contains_key(id.node));\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id.node));\n-        ret {kinds: no_kinds, ty: typ};\n+        ret {kinds: [], ty: typ};\n       }\n       ast::def_mod(_) {\n         // Hopefully part of a path.\n         // TODO: return a type that's more poisonous, perhaps?\n-        ret {kinds: no_kinds, ty: ty::mk_nil(fcx.ccx.tcx)};\n+        ret {kinds: [], ty: ty::mk_nil(fcx.ccx.tcx)};\n       }\n       ast::def_ty(_) {\n         fcx.ccx.tcx.sess.span_fatal(sp, \"expected value but found type\");\n@@ -410,11 +412,10 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n \n fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n     -> ty::ty_param_kinds_and_ty {\n-    let no_kinds: [ast::kind] = [];\n     alt it.node {\n       ast::item_const(t, _) {\n         let typ = ast_ty_to_ty(tcx, mode, t);\n-        let tpt = {kinds: no_kinds, ty: typ};\n+        let tpt = {kinds: [], ty: typ};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n@@ -463,7 +464,6 @@ fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n }\n fn ty_of_native_item(tcx: ty::ctxt, mode: mode, it: @ast::native_item)\n     -> ty::ty_param_kinds_and_ty {\n-    let no_kinds: [ast::kind] = [];\n     alt it.node {\n       ast::native_item_fn(fn_decl, params) {\n         ret ty_of_native_fn_decl(tcx, mode, fn_decl, params,\n@@ -475,7 +475,7 @@ fn ty_of_native_item(tcx: ty::ctxt, mode: mode, it: @ast::native_item)\n           none. { }\n         }\n         let t = ty::mk_native(tcx, ast_util::local_def(it.id));\n-        let tpt = {kinds: no_kinds, ty: t};\n+        let tpt = {kinds: [], ty: t};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n@@ -698,9 +698,11 @@ mod collect {\n           }\n           ast::item_impl(_, _, ms) {\n             for m in ms {\n-                write::ty_only(cx.tcx, m.node.id, \n-                               ty::method_ty_to_fn_ty(cx.tcx, ty_of_method(\n-                                   cx.tcx, m_collect, m)));\n+                let ty = ty::method_ty_to_fn_ty(\n+                    cx.tcx, ty_of_method(cx.tcx, m_collect, m));\n+                cx.tcx.tcache.insert(local_def(m.node.id),\n+                                     {kinds: [], ty: ty});\n+                write::ty_only(cx.tcx, m.node.id, ty);\n             }\n           }\n           ast::item_obj(object, ty_params, ctor_id) {\n@@ -2179,6 +2181,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             let f_ty = ty::mk_fn(fcx.ccx.tcx, mt.proto, mt.inputs,\n                                  mt.output, mt.cf, mt.constrs);\n             write::ty_only_fixup(fcx, id, f_ty);\n+            fcx.ccx.method_map.insert(id, local_def(method.node.id));\n           }\n           _ {\n             base_t = do_autoderef(fcx, expr.span, base_t);\n@@ -2695,20 +2698,22 @@ fn check_for_main_fn(tcx: ty::ctxt, crate: @ast::crate) {\n }\n \n fn check_crate(tcx: ty::ctxt, impl_map: resolve::impl_map,\n-               crate: @ast::crate) {\n+               crate: @ast::crate) -> method_map {\n     collect::collect_item_types(tcx, crate);\n \n     let obj_infos: [obj_info] = [];\n \n     let ccx = @{mutable obj_infos: obj_infos,\n                 impl_map: impl_map,\n+                method_map: std::map::new_int_hash(),\n                 tcx: tcx};\n     let visit =\n         visit::mk_simple_visitor(@{visit_item: bind check_item(ccx, _)\n                                       with *visit::default_simple_visitor()});\n     visit::visit_crate(*crate, (), visit);\n     check_for_main_fn(tcx, crate);\n     tcx.sess.abort_if_errors();\n+    ccx.method_map\n }\n //\n // Local Variables:"}]}