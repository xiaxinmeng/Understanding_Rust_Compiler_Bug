{"sha": "4caffa8526b2d359aff853964b08aebb9683bcdb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjYWZmYTg1MjZiMmQzNTlhZmY4NTM5NjRiMDhhZWJiOTY4M2JjZGI=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-15T04:39:41Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-15T04:39:41Z"}, "message": "libs: fix #[stable] inheritance fallout\n\nA recent change turned off inheritance for the #[stable] by default, but\nfailed to catch all the cases where this was being used in std. This\npatch fixes that problem.", "tree": {"sha": "83d5bd1ff349ad16014843ee9fa4172ce52f3858", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83d5bd1ff349ad16014843ee9fa4172ce52f3858"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4caffa8526b2d359aff853964b08aebb9683bcdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4caffa8526b2d359aff853964b08aebb9683bcdb", "html_url": "https://github.com/rust-lang/rust/commit/4caffa8526b2d359aff853964b08aebb9683bcdb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4caffa8526b2d359aff853964b08aebb9683bcdb/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bf06495443584539b958873e04cc2f864ab10e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bf06495443584539b958873e04cc2f864ab10e4", "html_url": "https://github.com/rust-lang/rust/commit/1bf06495443584539b958873e04cc2f864ab10e4"}], "stats": {"total": 77, "additions": 62, "deletions": 15}, "files": [{"sha": "501f915461a27844cf162732f8a3848d7e9f1017", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4caffa8526b2d359aff853964b08aebb9683bcdb/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4caffa8526b2d359aff853964b08aebb9683bcdb/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=4caffa8526b2d359aff853964b08aebb9683bcdb", "patch": "@@ -179,9 +179,9 @@ pub struct Rc<T> {\n     _noshare: marker::NoSync\n }\n \n-#[stable]\n impl<T> Rc<T> {\n     /// Constructs a new reference-counted pointer.\n+    #[stable]\n     pub fn new(value: T) -> Rc<T> {\n         unsafe {\n             Rc {\n@@ -200,9 +200,7 @@ impl<T> Rc<T> {\n             }\n         }\n     }\n-}\n \n-impl<T> Rc<T> {\n     /// Downgrades the reference-counted pointer to a weak reference.\n     #[experimental = \"Weak pointers may not belong in this module\"]\n     pub fn downgrade(&self) -> Weak<T> {"}, {"sha": "15e1031f69dbf2c8bc2e8a86e9d288b55917d80e", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4caffa8526b2d359aff853964b08aebb9683bcdb/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4caffa8526b2d359aff853964b08aebb9683bcdb/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=4caffa8526b2d359aff853964b08aebb9683bcdb", "patch": "@@ -645,7 +645,6 @@ impl<T> Vec<T> {\n     /// assert!(vec.capacity() >= 3);\n     /// ```\n     #[stable]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn shrink_to_fit(&mut self) {\n         if mem::size_of::<T>() == 0 { return }\n "}, {"sha": "5511266b4cd2276600c3b8fdf9232fa903c3f37a", "filename": "src/libcore/any.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4caffa8526b2d359aff853964b08aebb9683bcdb/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4caffa8526b2d359aff853964b08aebb9683bcdb/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=4caffa8526b2d359aff853964b08aebb9683bcdb", "patch": "@@ -88,6 +88,7 @@ use intrinsics::TypeId;\n #[stable]\n pub trait Any: 'static {\n     /// Get the `TypeId` of `self`\n+    #[stable]\n     fn get_type_id(&self) -> TypeId;\n }\n \n@@ -117,7 +118,6 @@ pub trait AnyRefExt<'a> {\n #[stable]\n impl<'a> AnyRefExt<'a> for &'a Any {\n     #[inline]\n-    #[stable]\n     fn is<T: 'static>(self) -> bool {\n         // Get TypeId of the type this function is instantiated with\n         let t = TypeId::of::<T>();\n@@ -130,7 +130,6 @@ impl<'a> AnyRefExt<'a> for &'a Any {\n     }\n \n     #[inline]\n-    #[unstable = \"naming conventions around acquiring references may change\"]\n     fn downcast_ref<T: 'static>(self) -> Option<&'a T> {\n         if self.is::<T>() {\n             unsafe {\n@@ -159,7 +158,6 @@ pub trait AnyMutRefExt<'a> {\n #[stable]\n impl<'a> AnyMutRefExt<'a> for &'a mut Any {\n     #[inline]\n-    #[unstable = \"naming conventions around acquiring references may change\"]\n     fn downcast_mut<T: 'static>(self) -> Option<&'a mut T> {\n         if self.is::<T>() {\n             unsafe {"}, {"sha": "d25a43ee2fec9364ccd61d18bbd7e927e6206965", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 48, "deletions": 4, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4caffa8526b2d359aff853964b08aebb9683bcdb/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4caffa8526b2d359aff853964b08aebb9683bcdb/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=4caffa8526b2d359aff853964b08aebb9683bcdb", "patch": "@@ -58,20 +58,25 @@ pub struct AtomicPtr<T> {\n #[stable]\n pub enum Ordering {\n     /// No ordering constraints, only atomic operations\n+    #[stable]\n     Relaxed,\n     /// When coupled with a store, all previous writes become visible\n     /// to another thread that performs a load with `Acquire` ordering\n     /// on the same value\n+    #[stable]\n     Release,\n     /// When coupled with a load, all subsequent loads will see data\n     /// written before a store with `Release` ordering on the same value\n     /// in another thread\n+    #[stable]\n     Acquire,\n     /// When coupled with a load, uses `Acquire` ordering, and with a store\n     /// `Release` ordering\n+    #[stable]\n     AcqRel,\n     /// Like `AcqRel` with the additional guarantee that all threads see all\n     /// sequentially consistent operations in the same order.\n+    #[stable]\n     SeqCst\n }\n \n@@ -91,10 +96,10 @@ pub const INIT_ATOMIC_UINT: AtomicUint =\n // NB: Needs to be -1 (0b11111111...) to make fetch_nand work correctly\n const UINT_TRUE: uint = -1;\n \n-#[stable]\n impl AtomicBool {\n     /// Create a new `AtomicBool`\n     #[inline]\n+    #[stable]\n     pub fn new(v: bool) -> AtomicBool {\n         let val = if v { UINT_TRUE } else { 0 };\n         AtomicBool { v: UnsafeCell::new(val), nocopy: marker::NoCopy }\n@@ -106,6 +111,7 @@ impl AtomicBool {\n     ///\n     /// Fails if `order` is `Release` or `AcqRel`.\n     #[inline]\n+    #[stable]\n     pub fn load(&self, order: Ordering) -> bool {\n         unsafe { atomic_load(self.v.get() as *const uint, order) > 0 }\n     }\n@@ -116,6 +122,7 @@ impl AtomicBool {\n     ///\n     /// Fails if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n+    #[stable]\n     pub fn store(&self, val: bool, order: Ordering) {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -124,6 +131,7 @@ impl AtomicBool {\n \n     /// Store a value, returning the old value\n     #[inline]\n+    #[stable]\n     pub fn swap(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -174,6 +182,7 @@ impl AtomicBool {\n     /// }\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn compare_and_swap(&self, old: bool, new: bool, order: Ordering) -> bool {\n         let old = if old { UINT_TRUE } else { 0 };\n         let new = if new { UINT_TRUE } else { 0 };\n@@ -205,6 +214,7 @@ impl AtomicBool {\n     /// assert_eq!(false, foo.load(SeqCst));\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -236,6 +246,7 @@ impl AtomicBool {\n     /// assert_eq!(true, foo.load(SeqCst));\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -266,6 +277,7 @@ impl AtomicBool {\n     /// assert_eq!(false, foo.load(SeqCst));\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -296,17 +308,18 @@ impl AtomicBool {\n     /// assert_eq!(false, foo.load(SeqCst));\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n         unsafe { atomic_xor(self.v.get(), val, order) > 0 }\n     }\n }\n \n-#[stable]\n impl AtomicInt {\n     /// Create a new `AtomicInt`\n     #[inline]\n+    #[stable]\n     pub fn new(v: int) -> AtomicInt {\n         AtomicInt {v: UnsafeCell::new(v), nocopy: marker::NoCopy}\n     }\n@@ -317,6 +330,7 @@ impl AtomicInt {\n     ///\n     /// Fails if `order` is `Release` or `AcqRel`.\n     #[inline]\n+    #[stable]\n     pub fn load(&self, order: Ordering) -> int {\n         unsafe { atomic_load(self.v.get() as *const int, order) }\n     }\n@@ -327,12 +341,14 @@ impl AtomicInt {\n     ///\n     /// Fails if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n+    #[stable]\n     pub fn store(&self, val: int, order: Ordering) {\n         unsafe { atomic_store(self.v.get(), val, order); }\n     }\n \n     /// Store a value, returning the old value\n     #[inline]\n+    #[stable]\n     pub fn swap(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n@@ -343,6 +359,7 @@ impl AtomicInt {\n     /// replace the current value with `new`. Return the previous value.\n     /// If the return value is equal to `old` then the value was updated.\n     #[inline]\n+    #[stable]\n     pub fn compare_and_swap(&self, old: int, new: int, order: Ordering) -> int {\n         unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n     }\n@@ -359,6 +376,7 @@ impl AtomicInt {\n     /// assert_eq!(10, foo.load(SeqCst));\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn fetch_add(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_add(self.v.get(), val, order) }\n     }\n@@ -375,6 +393,7 @@ impl AtomicInt {\n     /// assert_eq!(-10, foo.load(SeqCst));\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn fetch_sub(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_sub(self.v.get(), val, order) }\n     }\n@@ -390,6 +409,7 @@ impl AtomicInt {\n     /// assert_eq!(0b101101, foo.fetch_and(0b110011, SeqCst));\n     /// assert_eq!(0b100001, foo.load(SeqCst));\n     #[inline]\n+    #[stable]\n     pub fn fetch_and(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_and(self.v.get(), val, order) }\n     }\n@@ -405,6 +425,7 @@ impl AtomicInt {\n     /// assert_eq!(0b101101, foo.fetch_or(0b110011, SeqCst));\n     /// assert_eq!(0b111111, foo.load(SeqCst));\n     #[inline]\n+    #[stable]\n     pub fn fetch_or(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_or(self.v.get(), val, order) }\n     }\n@@ -420,15 +441,16 @@ impl AtomicInt {\n     /// assert_eq!(0b101101, foo.fetch_xor(0b110011, SeqCst));\n     /// assert_eq!(0b011110, foo.load(SeqCst));\n     #[inline]\n+    #[stable]\n     pub fn fetch_xor(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_xor(self.v.get(), val, order) }\n     }\n }\n \n-#[stable]\n impl AtomicUint {\n     /// Create a new `AtomicUint`\n     #[inline]\n+    #[stable]\n     pub fn new(v: uint) -> AtomicUint {\n         AtomicUint { v: UnsafeCell::new(v), nocopy: marker::NoCopy }\n     }\n@@ -439,6 +461,7 @@ impl AtomicUint {\n     ///\n     /// Fails if `order` is `Release` or `AcqRel`.\n     #[inline]\n+    #[stable]\n     pub fn load(&self, order: Ordering) -> uint {\n         unsafe { atomic_load(self.v.get() as *const uint, order) }\n     }\n@@ -449,12 +472,14 @@ impl AtomicUint {\n     ///\n     /// Fails if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n+    #[stable]\n     pub fn store(&self, val: uint, order: Ordering) {\n         unsafe { atomic_store(self.v.get(), val, order); }\n     }\n \n     /// Store a value, returning the old value\n     #[inline]\n+    #[stable]\n     pub fn swap(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n@@ -465,6 +490,7 @@ impl AtomicUint {\n     /// replace the current value with `new`. Return the previous value.\n     /// If the return value is equal to `old` then the value was updated.\n     #[inline]\n+    #[stable]\n     pub fn compare_and_swap(&self, old: uint, new: uint, order: Ordering) -> uint {\n         unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n     }\n@@ -481,6 +507,7 @@ impl AtomicUint {\n     /// assert_eq!(10, foo.load(SeqCst));\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn fetch_add(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_add(self.v.get(), val, order) }\n     }\n@@ -497,6 +524,7 @@ impl AtomicUint {\n     /// assert_eq!(0, foo.load(SeqCst));\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn fetch_sub(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_sub(self.v.get(), val, order) }\n     }\n@@ -512,6 +540,7 @@ impl AtomicUint {\n     /// assert_eq!(0b101101, foo.fetch_and(0b110011, SeqCst));\n     /// assert_eq!(0b100001, foo.load(SeqCst));\n     #[inline]\n+    #[stable]\n     pub fn fetch_and(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_and(self.v.get(), val, order) }\n     }\n@@ -527,6 +556,7 @@ impl AtomicUint {\n     /// assert_eq!(0b101101, foo.fetch_or(0b110011, SeqCst));\n     /// assert_eq!(0b111111, foo.load(SeqCst));\n     #[inline]\n+    #[stable]\n     pub fn fetch_or(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_or(self.v.get(), val, order) }\n     }\n@@ -542,15 +572,16 @@ impl AtomicUint {\n     /// assert_eq!(0b101101, foo.fetch_xor(0b110011, SeqCst));\n     /// assert_eq!(0b011110, foo.load(SeqCst));\n     #[inline]\n+    #[stable]\n     pub fn fetch_xor(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_xor(self.v.get(), val, order) }\n     }\n }\n \n-#[stable]\n impl<T> AtomicPtr<T> {\n     /// Create a new `AtomicPtr`\n     #[inline]\n+    #[stable]\n     pub fn new(p: *mut T) -> AtomicPtr<T> {\n         AtomicPtr { p: UnsafeCell::new(p as uint), nocopy: marker::NoCopy }\n     }\n@@ -561,6 +592,7 @@ impl<T> AtomicPtr<T> {\n     ///\n     /// Fails if `order` is `Release` or `AcqRel`.\n     #[inline]\n+    #[stable]\n     pub fn load(&self, order: Ordering) -> *mut T {\n         unsafe {\n             atomic_load(self.p.get() as *const *mut T, order) as *mut T\n@@ -573,12 +605,14 @@ impl<T> AtomicPtr<T> {\n     ///\n     /// Fails if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n+    #[stable]\n     pub fn store(&self, ptr: *mut T, order: Ordering) {\n         unsafe { atomic_store(self.p.get(), ptr as uint, order); }\n     }\n \n     /// Store a value, returning the old value\n     #[inline]\n+    #[stable]\n     pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n         unsafe { atomic_swap(self.p.get(), ptr as uint, order) as *mut T }\n     }\n@@ -589,6 +623,7 @@ impl<T> AtomicPtr<T> {\n     /// replace the current value with `new`. Return the previous value.\n     /// If the return value is equal to `old` then the value was updated.\n     #[inline]\n+    #[stable]\n     pub fn compare_and_swap(&self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         unsafe {\n             atomic_compare_and_swap(self.p.get(), old as uint,\n@@ -609,6 +644,7 @@ unsafe fn atomic_store<T>(dst: *mut T, val: T, order:Ordering) {\n }\n \n #[inline]\n+#[stable]\n unsafe fn atomic_load<T>(dst: *const T, order:Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_load_acq(dst),\n@@ -620,6 +656,7 @@ unsafe fn atomic_load<T>(dst: *const T, order:Ordering) -> T {\n }\n \n #[inline]\n+#[stable]\n unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xchg_acq(dst, val),\n@@ -632,6 +669,7 @@ unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the old value (like __sync_fetch_and_add).\n #[inline]\n+#[stable]\n unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xadd_acq(dst, val),\n@@ -644,6 +682,7 @@ unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the old value (like __sync_fetch_and_sub).\n #[inline]\n+#[stable]\n unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xsub_acq(dst, val),\n@@ -655,6 +694,7 @@ unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n+#[stable]\n unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_cxchg_acq(dst, old, new),\n@@ -666,6 +706,7 @@ unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering)\n }\n \n #[inline]\n+#[stable]\n unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_and_acq(dst, val),\n@@ -677,6 +718,7 @@ unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n+#[stable]\n unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_nand_acq(dst, val),\n@@ -689,6 +731,7 @@ unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n \n #[inline]\n+#[stable]\n unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_or_acq(dst, val),\n@@ -701,6 +744,7 @@ unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n \n #[inline]\n+#[stable]\n unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xor_acq(dst, val),"}, {"sha": "dfef079d10025578d45768f79828ff996d6e8f91", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4caffa8526b2d359aff853964b08aebb9683bcdb/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4caffa8526b2d359aff853964b08aebb9683bcdb/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=4caffa8526b2d359aff853964b08aebb9683bcdb", "patch": "@@ -168,9 +168,9 @@ pub struct Cell<T> {\n     noshare: marker::NoSync,\n }\n \n-#[stable]\n impl<T:Copy> Cell<T> {\n     /// Creates a new `Cell` containing the given value.\n+    #[stable]\n     pub fn new(value: T) -> Cell<T> {\n         Cell {\n             value: UnsafeCell::new(value),\n@@ -180,12 +180,14 @@ impl<T:Copy> Cell<T> {\n \n     /// Returns a copy of the contained value.\n     #[inline]\n+    #[stable]\n     pub fn get(&self) -> T {\n         unsafe{ *self.value.get() }\n     }\n \n     /// Sets the contained value.\n     #[inline]\n+    #[stable]\n     pub fn set(&self, value: T) {\n         unsafe {\n             *self.value.get() = value;"}, {"sha": "d41dbb11adb198cc0fe905bc56905cfe07e097f5", "filename": "src/libcore/option.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4caffa8526b2d359aff853964b08aebb9683bcdb/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4caffa8526b2d359aff853964b08aebb9683bcdb/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=4caffa8526b2d359aff853964b08aebb9683bcdb", "patch": "@@ -716,7 +716,6 @@ impl<T: Default> Option<T> {\n impl<T> AsSlice<T> for Option<T> {\n     /// Convert from `Option<T>` to `&[T]` (without copying)\n     #[inline]\n-    #[stable]\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         match *self {\n             Some(ref x) => slice::ref_slice(x),\n@@ -728,6 +727,7 @@ impl<T> AsSlice<T> for Option<T> {\n     }\n }\n \n+#[stable]\n impl<T> Default for Option<T> {\n     #[inline]\n     fn default() -> Option<T> { None }\n@@ -772,9 +772,10 @@ impl<A> DoubleEndedIterator<A> for Item<A> {\n impl<A> ExactSize<A> for Item<A> {}\n \n /////////////////////////////////////////////////////////////////////////////\n-// Free functions\n+// FromIterator\n /////////////////////////////////////////////////////////////////////////////\n \n+#[stable]\n impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// Takes each element in the `Iterator`: if it is `None`, no further\n     /// elements are taken, and the `None` is returned. Should no `None` occur, a"}, {"sha": "6c591fbcc38ef70ecae1ac55a60aa351e45e71b6", "filename": "src/libcore/result.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4caffa8526b2d359aff853964b08aebb9683bcdb/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4caffa8526b2d359aff853964b08aebb9683bcdb/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=4caffa8526b2d359aff853964b08aebb9683bcdb", "patch": "@@ -878,9 +878,10 @@ impl<A> DoubleEndedIterator<A> for Item<A> {\n impl<A> ExactSize<A> for Item<A> {}\n \n /////////////////////////////////////////////////////////////////////////////\n-// Free functions\n+// FromIterator\n /////////////////////////////////////////////////////////////////////////////\n \n+#[stable]\n impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n     /// Takes each element in the `Iterator`: if it is an `Err`, no further\n     /// elements are taken, and the `Err` is returned. Should no `Err` occur, a\n@@ -933,6 +934,10 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n     }\n }\n \n+/////////////////////////////////////////////////////////////////////////////\n+// FromIterator\n+/////////////////////////////////////////////////////////////////////////////\n+\n /// Perform a fold operation over the result values from an iterator.\n ///\n /// If an `Err` is encountered, it is immediately returned."}]}