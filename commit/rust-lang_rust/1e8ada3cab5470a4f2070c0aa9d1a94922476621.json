{"sha": "1e8ada3cab5470a4f2070c0aa9d1a94922476621", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlOGFkYTNjYWI1NDcwYTRmMjA3MGMwYWE5ZDFhOTQ5MjI0NzY2MjE=", "commit": {"author": {"name": "Takayuki Nakata", "email": "f.seasons017@gmail.com", "date": "2020-07-18T14:28:31Z"}, "committer": {"name": "Takayuki Nakata", "email": "f.seasons017@gmail.com", "date": "2020-08-05T13:51:38Z"}, "message": "Add lint `same_item_push`", "tree": {"sha": "2c83f469a848cdffbf94678617c3972e76990c7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c83f469a848cdffbf94678617c3972e76990c7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e8ada3cab5470a4f2070c0aa9d1a94922476621", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e8ada3cab5470a4f2070c0aa9d1a94922476621", "html_url": "https://github.com/rust-lang/rust/commit/1e8ada3cab5470a4f2070c0aa9d1a94922476621", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e8ada3cab5470a4f2070c0aa9d1a94922476621/comments", "author": {"login": "giraffate", "id": 17407489, "node_id": "MDQ6VXNlcjE3NDA3NDg5", "avatar_url": "https://avatars.githubusercontent.com/u/17407489?v=4", "gravatar_id": "", "url": "https://api.github.com/users/giraffate", "html_url": "https://github.com/giraffate", "followers_url": "https://api.github.com/users/giraffate/followers", "following_url": "https://api.github.com/users/giraffate/following{/other_user}", "gists_url": "https://api.github.com/users/giraffate/gists{/gist_id}", "starred_url": "https://api.github.com/users/giraffate/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/giraffate/subscriptions", "organizations_url": "https://api.github.com/users/giraffate/orgs", "repos_url": "https://api.github.com/users/giraffate/repos", "events_url": "https://api.github.com/users/giraffate/events{/privacy}", "received_events_url": "https://api.github.com/users/giraffate/received_events", "type": "User", "site_admin": false}, "committer": {"login": "giraffate", "id": 17407489, "node_id": "MDQ6VXNlcjE3NDA3NDg5", "avatar_url": "https://avatars.githubusercontent.com/u/17407489?v=4", "gravatar_id": "", "url": "https://api.github.com/users/giraffate", "html_url": "https://github.com/giraffate", "followers_url": "https://api.github.com/users/giraffate/followers", "following_url": "https://api.github.com/users/giraffate/following{/other_user}", "gists_url": "https://api.github.com/users/giraffate/gists{/gist_id}", "starred_url": "https://api.github.com/users/giraffate/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/giraffate/subscriptions", "organizations_url": "https://api.github.com/users/giraffate/orgs", "repos_url": "https://api.github.com/users/giraffate/repos", "events_url": "https://api.github.com/users/giraffate/events{/privacy}", "received_events_url": "https://api.github.com/users/giraffate/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d7e3fdffd380d0d98f63e878b3ef9948b9452ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d7e3fdffd380d0d98f63e878b3ef9948b9452ca", "html_url": "https://github.com/rust-lang/rust/commit/3d7e3fdffd380d0d98f63e878b3ef9948b9452ca"}], "stats": {"total": 388, "additions": 388, "deletions": 0}, "files": [{"sha": "fbc783f1c2c25100bd744ee10d70a3dda05efbe3", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1e8ada3cab5470a4f2070c0aa9d1a94922476621/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/1e8ada3cab5470a4f2070c0aa9d1a94922476621/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=1e8ada3cab5470a4f2070c0aa9d1a94922476621", "patch": "@@ -1687,6 +1687,7 @@ Released 2018-09-13\n [`result_map_unit_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_map_unit_fn\n [`reversed_empty_ranges`]: https://rust-lang.github.io/rust-clippy/master/index.html#reversed_empty_ranges\n [`same_functions_in_if_condition`]: https://rust-lang.github.io/rust-clippy/master/index.html#same_functions_in_if_condition\n+[`same_item_push`]: https://rust-lang.github.io/rust-clippy/master/index.html#same_item_push\n [`search_is_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#search_is_some\n [`serde_api_misuse`]: https://rust-lang.github.io/rust-clippy/master/index.html#serde_api_misuse\n [`shadow_reuse`]: https://rust-lang.github.io/rust-clippy/master/index.html#shadow_reuse"}, {"sha": "2bd5ae0ed98fba6ba271755f32f4af677be84f5a", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1e8ada3cab5470a4f2070c0aa9d1a94922476621/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8ada3cab5470a4f2070c0aa9d1a94922476621/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=1e8ada3cab5470a4f2070c0aa9d1a94922476621", "patch": "@@ -610,6 +610,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &loops::WHILE_IMMUTABLE_CONDITION,\n         &loops::WHILE_LET_LOOP,\n         &loops::WHILE_LET_ON_ITERATOR,\n+        &loops::SAME_ITEM_PUSH,\n         &macro_use::MACRO_USE_IMPORTS,\n         &main_recursion::MAIN_RECURSION,\n         &manual_async_fn::MANUAL_ASYNC_FN,\n@@ -1405,6 +1406,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&repeat_once::REPEAT_ONCE),\n         LintId::of(&returns::NEEDLESS_RETURN),\n         LintId::of(&returns::UNUSED_UNIT),\n+        LintId::of(&loops::SAME_ITEM_PUSH),\n         LintId::of(&serde_api::SERDE_API_MISUSE),\n         LintId::of(&single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n         LintId::of(&slow_vector_initialization::SLOW_VECTOR_INITIALIZATION),\n@@ -1543,6 +1545,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&regex::TRIVIAL_REGEX),\n         LintId::of(&returns::NEEDLESS_RETURN),\n         LintId::of(&returns::UNUSED_UNIT),\n+        LintId::of(&loops::SAME_ITEM_PUSH),\n         LintId::of(&single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n         LintId::of(&strings::STRING_LIT_AS_BYTES),\n         LintId::of(&tabs_in_doc_comments::TABS_IN_DOC_COMMENTS),"}, {"sha": "48891a59c00037afb9aef1a9259e1d2b3d0e7180", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/1e8ada3cab5470a4f2070c0aa9d1a94922476621/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8ada3cab5470a4f2070c0aa9d1a94922476621/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=1e8ada3cab5470a4f2070c0aa9d1a94922476621", "patch": "@@ -419,6 +419,39 @@ declare_clippy_lint! {\n     \"variables used within while expression are not mutated in the body\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks whether a for loop is being used to push a constant\n+    /// value into a Vec.\n+    ///\n+    /// **Why is this bad?** This kind of operation can be expressed more succinctly with\n+    /// `vec![item;SIZE]` or `vec.resize(NEW_SIZE, item)` and using these alternatives may also\n+    /// have better performance.\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let item1 = 2;\n+    /// let item2 = 3;\n+    /// let mut vec: Vec<u8> = Vec::new();\n+    /// for _ in 0..20 {\n+    ///    vec.push(item1);\n+    /// }\n+    /// for _ in 0..30 {\n+    ///     vec.push(item2);\n+    /// }\n+    /// ```\n+    /// could be written as\n+    /// ```rust\n+    /// let item1 = 2;\n+    /// let item2 = 3;\n+    /// let mut vec: Vec<u8> = vec![item1; 20];\n+    /// vec.resize(20 + 30, item2);\n+    /// ```\n+    pub SAME_ITEM_PUSH,\n+    style,\n+    \"the same item is pushed inside of a for loop\"\n+}\n+\n declare_lint_pass!(Loops => [\n     MANUAL_MEMCPY,\n     NEEDLESS_RANGE_LOOP,\n@@ -435,6 +468,7 @@ declare_lint_pass!(Loops => [\n     NEVER_LOOP,\n     MUT_RANGE_BOUND,\n     WHILE_IMMUTABLE_CONDITION,\n+    SAME_ITEM_PUSH,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Loops {\n@@ -740,6 +774,7 @@ fn check_for_loop<'tcx>(\n     check_for_loop_over_map_kv(cx, pat, arg, body, expr);\n     check_for_mut_range_bound(cx, arg, body);\n     detect_manual_memcpy(cx, pat, arg, body, expr);\n+    detect_same_item_push(cx, pat, arg, body, expr);\n }\n \n fn same_var<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, var: HirId) -> bool {\n@@ -1016,6 +1051,236 @@ fn detect_manual_memcpy<'tcx>(\n     }\n }\n \n+// Delegate that traverses expression and detects mutable variables being used\n+struct UsesMutableDelegate {\n+    found_mutable: bool,\n+}\n+\n+impl<'tcx> Delegate<'tcx> for UsesMutableDelegate {\n+    fn consume(&mut self, _: &PlaceWithHirId<'tcx>, _: ConsumeMode) {}\n+\n+    fn borrow(&mut self, _: &PlaceWithHirId<'tcx>, bk: ty::BorrowKind) {\n+        // Mutable variable is found\n+        if let ty::BorrowKind::MutBorrow = bk {\n+            self.found_mutable = true;\n+        }\n+    }\n+\n+    fn mutate(&mut self, _: &PlaceWithHirId<'tcx>) {}\n+}\n+\n+// Uses UsesMutableDelegate to find mutable variables in an expression expr\n+fn has_mutable_variables<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+    let mut delegate = UsesMutableDelegate { found_mutable: false };\n+    let def_id = expr.hir_id.owner.to_def_id();\n+    cx.tcx.infer_ctxt().enter(|infcx| {\n+        ExprUseVisitor::new(\n+            &mut delegate,\n+            &infcx,\n+            def_id.expect_local(),\n+            cx.param_env,\n+            cx.tables(),\n+        ).walk_expr(expr);\n+    });\n+\n+    delegate.found_mutable\n+}\n+\n+// Scans for the usage of the for loop pattern\n+struct ForPatternVisitor<'a, 'tcx> {\n+    found_pattern: bool,\n+    // Pattern that we are searching for\n+    for_pattern: &'a Pat<'tcx>,\n+    cx: &'a LateContext<'tcx>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for ForPatternVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        // Recursively explore an expression until a ExprKind::Path is found\n+        match &expr.kind {\n+            ExprKind::Array(expr_list) | ExprKind::MethodCall(_, _, expr_list, _) | ExprKind::Tup(expr_list) => {\n+                for expr in *expr_list {\n+                    self.visit_expr(expr)\n+                }\n+            },\n+            ExprKind::Binary(_, lhs_expr, rhs_expr) => {\n+                self.visit_expr(lhs_expr);\n+                self.visit_expr(rhs_expr);\n+            },\n+            ExprKind::Box(expr)\n+            | ExprKind::Unary(_, expr)\n+            | ExprKind::Cast(expr, _)\n+            | ExprKind::Type(expr, _)\n+            | ExprKind::AddrOf(_, _, expr)\n+            | ExprKind::Struct(_, _, Some(expr)) => self.visit_expr(expr),\n+            _ => {\n+                // Exploration cannot continue ... calculate the hir_id of the current\n+                // expr assuming it is a Path\n+                if let Some(hir_id) = var_def_id(self.cx, &expr) {\n+                    // Pattern is found\n+                    if hir_id == self.for_pattern.hir_id {\n+                        self.found_pattern = true;\n+                    }\n+                    // If the for loop pattern is a tuple, determine whether the current\n+                    // expr is inside that tuple pattern\n+                    if let PatKind::Tuple(pat_list, _) = &self.for_pattern.kind {\n+                        let hir_id_list: Vec<HirId> = pat_list.iter().map(|p| p.hir_id).collect();\n+                        if hir_id_list.contains(&hir_id) {\n+                            self.found_pattern = true;\n+                        }\n+                    }\n+                }\n+            },\n+        }\n+    }\n+\n+    // This is triggered by walk_expr() for the case of vec.push(pat)\n+    fn visit_qpath(&mut self, qpath: &'tcx QPath<'_>, _: HirId, _: Span) {\n+        if_chain! {\n+            if let QPath::Resolved(_, path) = qpath;\n+            if let Res::Local(hir_id) = &path.res;\n+            then {\n+                if *hir_id == self.for_pattern.hir_id{\n+                    self.found_pattern = true;\n+                }\n+\n+                if let PatKind::Tuple(pat_list, _) = &self.for_pattern.kind {\n+                    let hir_id_list: Vec<HirId> = pat_list.iter().map(|p| p.hir_id).collect();\n+                    if hir_id_list.contains(&hir_id) {\n+                        self.found_pattern = true;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+// Scans the body of the for loop and determines whether lint should be given\n+struct SameItemPushVisitor<'a, 'tcx> {\n+    should_lint: bool,\n+    // this field holds the last vec push operation visited, which should be the only push seen\n+    vec_push: Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)>,\n+    cx: &'a LateContext<'tcx>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for SameItemPushVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        match &expr.kind {\n+            // Non-determinism may occur ... don't give a lint\n+            ExprKind::Loop(_, _, _) | ExprKind::Match(_, _, _) => self.should_lint = false,\n+            ExprKind::Block(block, _) => self.visit_block(block),\n+            _ => {},\n+        }\n+    }\n+\n+    fn visit_block(&mut self, b: &'tcx Block<'_>) {\n+        for stmt in b.stmts.iter() {\n+            self.visit_stmt(stmt);\n+        }\n+    }\n+\n+    fn visit_stmt(&mut self, s: &'tcx Stmt<'_>) {\n+        let vec_push_option = get_vec_push(self.cx, s);\n+        if vec_push_option.is_none() {\n+            // Current statement is not a push so visit inside\n+            match &s.kind {\n+                StmtKind::Expr(expr) | StmtKind::Semi(expr) => self.visit_expr(&expr),\n+                _ => {},\n+            }\n+        } else {\n+            // Current statement is a push ...check whether another\n+            // push had been previously done\n+            if self.vec_push.is_none() {\n+                self.vec_push = vec_push_option;\n+            } else {\n+                // There are multiple pushes ... don't lint\n+                self.should_lint = false;\n+            }\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+// Given some statement, determine if that statement is a push on a Vec. If it is, return\n+// the Vec being pushed into and the item being pushed\n+fn get_vec_push<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)> {\n+    if_chain! {\n+            // Extract method being called\n+            if let StmtKind::Semi(semi_stmt) = &stmt.kind;\n+            if let ExprKind::MethodCall(path, _, args, _) = &semi_stmt.kind;\n+            // Figure out the parameters for the method call\n+            if let Some(self_expr) = args.get(0);\n+            if let Some(pushed_item) = args.get(1);\n+            // Check that the method being called is push() on a Vec\n+            if match_type(cx, cx.tables().expr_ty(self_expr), &paths::VEC);\n+            if path.ident.name.as_str() == \"push\";\n+            then {\n+                return Some((self_expr, pushed_item))\n+            }\n+    }\n+    None\n+}\n+\n+/// Detects for loop pushing the same item into a Vec\n+fn detect_same_item_push<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    _: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    _: &'tcx Expr<'_>,\n+) {\n+    // Determine whether it is safe to lint the body\n+    let mut same_item_push_visitor = SameItemPushVisitor {\n+        should_lint: true,\n+        vec_push: None,\n+        cx,\n+    };\n+    walk_expr(&mut same_item_push_visitor, body);\n+    if same_item_push_visitor.should_lint {\n+        if let Some((vec, pushed_item)) = same_item_push_visitor.vec_push {\n+            // Make sure that the push does not involve possibly mutating values\n+            if !has_mutable_variables(cx, pushed_item) {\n+                // Walk through the expression being pushed and make sure that it\n+                // does not contain the for loop pattern\n+                let mut for_pat_visitor = ForPatternVisitor {\n+                    found_pattern: false,\n+                    for_pattern: pat,\n+                    cx,\n+                };\n+                walk_expr(&mut for_pat_visitor, pushed_item);\n+\n+                if !for_pat_visitor.found_pattern {\n+                    let vec_str = snippet(cx, vec.span, \"\");\n+                    let item_str = snippet(cx, pushed_item.span, \"\");\n+\n+                    span_lint_and_help(\n+                        cx,\n+                        SAME_ITEM_PUSH,\n+                        vec.span,\n+                        \"it looks like the same item is being pushed into this Vec\",\n+                        None, \n+                        &format!(\n+                            \"try using vec![{};SIZE] or {}.resize(NEW_SIZE, {})\",\n+                            item_str, vec_str, item_str\n+                        ),\n+                    )\n+                }\n+            }\n+        }\n+    }\n+}\n+\n /// Checks for looping over a range and then indexing a sequence with it.\n /// The iteratee must be a range literal.\n #[allow(clippy::too_many_lines)]"}, {"sha": "1b10226c930f062b26a8eb8a1f321f345c351b36", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1e8ada3cab5470a4f2070c0aa9d1a94922476621/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8ada3cab5470a4f2070c0aa9d1a94922476621/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=1e8ada3cab5470a4f2070c0aa9d1a94922476621", "patch": "@@ -1935,6 +1935,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"copies\",\n     },\n+    Lint {\n+        name: \"same_item_push\",\n+        group: \"style\",\n+        desc: \"default lint description\",\n+        deprecation: None,\n+        module: \"same_item_push\",\n+    },\n     Lint {\n         name: \"search_is_some\",\n         group: \"complexity\","}, {"sha": "e3a5a647f7639e5d4bafc38310d3478e3d081741", "filename": "tests/ui/same_item_push.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/1e8ada3cab5470a4f2070c0aa9d1a94922476621/tests%2Fui%2Fsame_item_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8ada3cab5470a4f2070c0aa9d1a94922476621/tests%2Fui%2Fsame_item_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsame_item_push.rs?ref=1e8ada3cab5470a4f2070c0aa9d1a94922476621", "patch": "@@ -0,0 +1,77 @@\n+#![warn(clippy::same_item_push)]\n+\n+fn mutate_increment(x: &mut u8) -> u8 {\n+    *x += 1;\n+    *x\n+}\n+\n+fn increment(x: u8) -> u8 {\n+    x + 1\n+}\n+\n+fn main() {\n+    // Test for basic case\n+    let mut spaces = Vec::with_capacity(10);\n+    for _ in 0..10 {\n+        spaces.push(vec![b' ']);\n+    }\n+\n+    let mut vec2: Vec<u8> = Vec::new();\n+    let item = 2;\n+    for _ in 5..=20 {\n+        vec2.push(item);\n+    }\n+\n+    let mut vec3: Vec<u8> = Vec::new();\n+    for _ in 0..15 {\n+        let item = 2;\n+        vec3.push(item);\n+    }\n+\n+    let mut vec4: Vec<u8> = Vec::new();\n+    for _ in 0..15 {\n+        vec4.push(13);\n+    }\n+\n+    // Suggestion should not be given as pushed variable can mutate\n+    let mut vec5: Vec<u8> = Vec::new();\n+    let mut item: u8 = 2;\n+    for _ in 0..30 {\n+        vec5.push(mutate_increment(&mut item));\n+    }\n+\n+    let mut vec6: Vec<u8> = Vec::new();\n+    let mut item: u8 = 2;\n+    let mut item2 = &mut mutate_increment(&mut item);\n+    for _ in 0..30 {\n+        vec6.push(mutate_increment(item2));\n+    }\n+\n+    let mut vec7: Vec<usize> = Vec::new();\n+    for (a, b) in [0, 1, 4, 9, 16].iter().enumerate() {\n+        vec7.push(a);\n+    }\n+\n+    let mut vec8: Vec<u8> = Vec::new();\n+    for i in 0..30 {\n+        vec8.push(increment(i));\n+    }\n+\n+    let mut vec9: Vec<u8> = Vec::new();\n+    for i in 0..30 {\n+        vec9.push(i + i * i);\n+    }\n+\n+    // Suggestion should not be given as there are multiple pushes that are not the same\n+    let mut vec10: Vec<u8> = Vec::new();\n+    let item: u8 = 2;\n+    for _ in 0..30 {\n+        vec10.push(item);\n+        vec10.push(item * 2);\n+    }\n+\n+    // Suggestion should not be given as Vec is not involved\n+    for _ in 0..5 {\n+        println!(\"Same Item Push\");\n+    }\n+}"}, {"sha": "559cc450b9de8ab4e418ca4f4b06797c2c47ec80", "filename": "tests/ui/same_item_push.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1e8ada3cab5470a4f2070c0aa9d1a94922476621/tests%2Fui%2Fsame_item_push.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e8ada3cab5470a4f2070c0aa9d1a94922476621/tests%2Fui%2Fsame_item_push.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsame_item_push.stderr?ref=1e8ada3cab5470a4f2070c0aa9d1a94922476621", "patch": "@@ -0,0 +1,35 @@\n+error: it looks like the same item is being pushed into this Vec\n+  --> $DIR/same_item_push.rs:16:9\n+   |\n+LL |         spaces.push(vec![b' ']);\n+   |         ^^^^^^\n+   |\n+   = note: `-D clippy::same-item-push` implied by `-D warnings`\n+   = help: try using vec![<[_]>::into_vec(box [$($x),+]);SIZE] or spaces.resize(NEW_SIZE, <[_]>::into_vec(box [$($x),+]))\n+\n+error: it looks like the same item is being pushed into this Vec\n+  --> $DIR/same_item_push.rs:22:9\n+   |\n+LL |         vec2.push(item);\n+   |         ^^^^\n+   |\n+   = help: try using vec![item;SIZE] or vec2.resize(NEW_SIZE, item)\n+\n+error: it looks like the same item is being pushed into this Vec\n+  --> $DIR/same_item_push.rs:28:9\n+   |\n+LL |         vec3.push(item);\n+   |         ^^^^\n+   |\n+   = help: try using vec![item;SIZE] or vec3.resize(NEW_SIZE, item)\n+\n+error: it looks like the same item is being pushed into this Vec\n+  --> $DIR/same_item_push.rs:33:9\n+   |\n+LL |         vec4.push(13);\n+   |         ^^^^\n+   |\n+   = help: try using vec![13;SIZE] or vec4.resize(NEW_SIZE, 13)\n+\n+error: aborting due to 4 previous errors\n+"}]}