{"sha": "b74e97cf42e647d87d67a03c134a0494b6aaa811", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3NGU5N2NmNDJlNjQ3ZDg3ZDY3YTAzYzEzNGEwNDk0YjZhYWE4MTE=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-02-27T16:11:14Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-03-02T09:48:52Z"}, "message": "Replace Rc with Lrc for shared data", "tree": {"sha": "a66e948a4d31dd9681cb6984a3b1fb774bebae4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a66e948a4d31dd9681cb6984a3b1fb774bebae4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b74e97cf42e647d87d67a03c134a0494b6aaa811", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b74e97cf42e647d87d67a03c134a0494b6aaa811", "html_url": "https://github.com/rust-lang/rust/commit/b74e97cf42e647d87d67a03c134a0494b6aaa811", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b74e97cf42e647d87d67a03c134a0494b6aaa811/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "878f5b05147480182ea4d8a855acc55bfeb16c22", "url": "https://api.github.com/repos/rust-lang/rust/commits/878f5b05147480182ea4d8a855acc55bfeb16c22", "html_url": "https://github.com/rust-lang/rust/commit/878f5b05147480182ea4d8a855acc55bfeb16c22"}], "stats": {"total": 848, "additions": 435, "deletions": 413}, "files": [{"sha": "7b4bfecea3fa2661e609b60c56f336c8e03a25a8", "filename": "src/Cargo.lock", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -1407,6 +1407,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n name = \"proc_macro\"\n version = \"0.0.0\"\n dependencies = [\n+ \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n@@ -1833,6 +1834,7 @@ dependencies = [\n  \"graphviz 0.0.0\",\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_mir 0.0.0\",\n  \"syntax 0.0.0\",\n@@ -2029,6 +2031,7 @@ dependencies = [\n  \"rustc 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n@@ -2054,6 +2057,7 @@ name = \"rustc_privacy\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustc 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n  \"rustc_typeck 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n@@ -2445,6 +2449,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"fmt_macros 0.0.0\",\n  \"proc_macro 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\","}, {"sha": "c1b2622520b112eb4519d786d4a9bbe11258dca0", "filename": "src/libproc_macro/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibproc_macro%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibproc_macro%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2FCargo.toml?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -11,3 +11,4 @@ crate-type = [\"dylib\"]\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc_errors = { path = \"../librustc_errors\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "cf1d4024373544d8e8600adeda554487fa1e9b3c", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -43,14 +43,15 @@\n extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc_errors;\n+extern crate rustc_data_structures;\n \n mod diagnostic;\n \n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n pub use diagnostic::{Diagnostic, Level};\n \n use std::{ascii, fmt, iter};\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use std::str::FromStr;\n \n use syntax::ast;\n@@ -306,7 +307,7 @@ pub struct LineColumn {\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n #[derive(Clone)]\n pub struct SourceFile {\n-    filemap: Rc<FileMap>,\n+    filemap: Lrc<FileMap>,\n }\n \n impl SourceFile {\n@@ -356,7 +357,7 @@ impl fmt::Debug for SourceFile {\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl PartialEq for SourceFile {\n     fn eq(&self, other: &Self) -> bool {\n-        Rc::ptr_eq(&self.filemap, &other.filemap)\n+        Lrc::ptr_eq(&self.filemap, &other.filemap)\n     }\n }\n "}, {"sha": "07c6c85b89dab5b8ffc4d2b4188ec040f111bea1", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -13,10 +13,10 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHashingContextProvider};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::sync::Lrc;\n use std::cell::{Ref, RefCell};\n use std::env;\n use std::hash::Hash;\n-use std::rc::Rc;\n use ty::TyCtxt;\n use util::common::{ProfileQueriesMsg, profq_msg};\n \n@@ -32,13 +32,13 @@ use super::prev::PreviousDepGraph;\n \n #[derive(Clone)]\n pub struct DepGraph {\n-    data: Option<Rc<DepGraphData>>,\n+    data: Option<Lrc<DepGraphData>>,\n \n     // A vector mapping depnodes from the current graph to their associated\n     // result value fingerprints. Do not rely on the length of this vector\n     // being the same as the number of nodes in the graph. The vector can\n     // contain an arbitrary number of zero-entries at the end.\n-    fingerprints: Rc<RefCell<IndexVec<DepNodeIndex, Fingerprint>>>\n+    fingerprints: Lrc<RefCell<IndexVec<DepNodeIndex, Fingerprint>>>\n }\n \n \n@@ -102,7 +102,7 @@ impl DepGraph {\n         let fingerprints = IndexVec::from_elem_n(Fingerprint::ZERO,\n                                                  (prev_graph_node_count * 115) / 100);\n         DepGraph {\n-            data: Some(Rc::new(DepGraphData {\n+            data: Some(Lrc::new(DepGraphData {\n                 previous_work_products: RefCell::new(FxHashMap()),\n                 work_products: RefCell::new(FxHashMap()),\n                 dep_node_debug: RefCell::new(FxHashMap()),\n@@ -111,14 +111,14 @@ impl DepGraph {\n                 colors: RefCell::new(DepNodeColorMap::new(prev_graph_node_count)),\n                 loaded_from_cache: RefCell::new(FxHashMap()),\n             })),\n-            fingerprints: Rc::new(RefCell::new(fingerprints)),\n+            fingerprints: Lrc::new(RefCell::new(fingerprints)),\n         }\n     }\n \n     pub fn new_disabled() -> DepGraph {\n         DepGraph {\n             data: None,\n-            fingerprints: Rc::new(RefCell::new(IndexVec::new())),\n+            fingerprints: Lrc::new(RefCell::new(IndexVec::new())),\n         }\n     }\n "}, {"sha": "e5bf384d253c526c386455bd52907f789d5952f2", "filename": "src/librustc/ich/caching_codemap_view.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use syntax::codemap::CodeMap;\n use syntax_pos::{BytePos, FileMap};\n \n@@ -18,7 +18,7 @@ struct CacheEntry {\n     line_number: usize,\n     line_start: BytePos,\n     line_end: BytePos,\n-    file: Rc<FileMap>,\n+    file: Lrc<FileMap>,\n     file_index: usize,\n }\n \n@@ -51,7 +51,7 @@ impl<'cm> CachingCodemapView<'cm> {\n \n     pub fn byte_pos_to_line_and_col(&mut self,\n                                     pos: BytePos)\n-                                    -> Option<(Rc<FileMap>, usize, BytePos)> {\n+                                    -> Option<(Lrc<FileMap>, usize, BytePos)> {\n         self.time_stamp += 1;\n \n         // Check if the position is in one of the cached lines"}, {"sha": "edea87c888c914692daa78f64582fd6dacad85e1", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -31,7 +31,7 @@\n pub use self::Level::*;\n pub use self::LintSource::*;\n \n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n \n use errors::{DiagnosticBuilder, DiagnosticId};\n use hir::def_id::{CrateNum, LOCAL_CRATE};\n@@ -505,7 +505,7 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n }\n \n fn lint_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, cnum: CrateNum)\n-    -> Rc<LintLevelMap>\n+    -> Lrc<LintLevelMap>\n {\n     assert_eq!(cnum, LOCAL_CRATE);\n     let mut builder = LintLevelMapBuilder {\n@@ -518,7 +518,7 @@ fn lint_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, cnum: CrateNum)\n         intravisit::walk_crate(builder, krate);\n     });\n \n-    Rc::new(builder.levels.build_map())\n+    Lrc::new(builder.levels.build_map())\n }\n \n struct LintLevelMapBuilder<'a, 'tcx: 'a> {"}, {"sha": "7f068e8f71b4bbbaf9167d1e475ded059a1d7d0b", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -37,13 +37,13 @@ use util::nodemap::NodeSet;\n use std::any::Any;\n use std::collections::BTreeMap;\n use std::path::{Path, PathBuf};\n-use std::rc::Rc;\n use rustc_data_structures::owning_ref::ErasedBoxRef;\n use syntax::ast;\n use syntax::ext::base::SyntaxExtension;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use rustc_back::target::Target;\n+use rustc_data_structures::sync::Lrc;\n \n pub use self::NativeLibraryKind::*;\n \n@@ -139,7 +139,7 @@ pub struct NativeLibrary {\n \n pub enum LoadedMacro {\n     MacroDef(ast::Item),\n-    ProcMacro(Rc<SyntaxExtension>),\n+    ProcMacro(Lrc<SyntaxExtension>),\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -206,7 +206,7 @@ pub struct ExternConstBody<'tcx> {\n \n #[derive(Clone)]\n pub struct ExternBodyNestedBodies {\n-    pub nested_bodies: Rc<BTreeMap<hir::BodyId, hir::Body>>,\n+    pub nested_bodies: Lrc<BTreeMap<hir::BodyId, hir::Body>>,\n \n     // It would require a lot of infrastructure to enable stable-hashing Bodies\n     // from other crates, so we hash on export and just store the fingerprint\n@@ -225,7 +225,7 @@ pub struct ExternBodyNestedBodies {\n /// (it'd break incremental compilation) and should only be called pre-HIR (e.g.\n /// during resolve)\n pub trait CrateStore {\n-    fn crate_data_as_rc_any(&self, krate: CrateNum) -> Rc<Any>;\n+    fn crate_data_as_rc_any(&self, krate: CrateNum) -> Lrc<Any>;\n \n     // access to the metadata loader\n     fn metadata_loader(&self) -> &MetadataLoader;\n@@ -234,7 +234,7 @@ pub trait CrateStore {\n     fn def_key(&self, def: DefId) -> DefKey;\n     fn def_path(&self, def: DefId) -> hir_map::DefPath;\n     fn def_path_hash(&self, def: DefId) -> hir_map::DefPathHash;\n-    fn def_path_table(&self, cnum: CrateNum) -> Rc<DefPathTable>;\n+    fn def_path_table(&self, cnum: CrateNum) -> Lrc<DefPathTable>;\n \n     // \"queries\" used in resolve that aren't tracked for incremental compilation\n     fn visibility_untracked(&self, def: DefId) -> ty::Visibility;\n@@ -297,7 +297,7 @@ pub struct DummyCrateStore;\n \n #[allow(unused_variables)]\n impl CrateStore for DummyCrateStore {\n-    fn crate_data_as_rc_any(&self, krate: CrateNum) -> Rc<Any>\n+    fn crate_data_as_rc_any(&self, krate: CrateNum) -> Lrc<Any>\n         { bug!(\"crate_data_as_rc_any\") }\n     // item info\n     fn visibility_untracked(&self, def: DefId) -> ty::Visibility { bug!(\"visibility\") }\n@@ -325,7 +325,7 @@ impl CrateStore for DummyCrateStore {\n     fn def_path_hash(&self, def: DefId) -> hir_map::DefPathHash {\n         bug!(\"def_path_hash\")\n     }\n-    fn def_path_table(&self, cnum: CrateNum) -> Rc<DefPathTable> {\n+    fn def_path_table(&self, cnum: CrateNum) -> Lrc<DefPathTable> {\n         bug!(\"def_path_table\")\n     }\n     fn struct_field_names_untracked(&self, def: DefId) -> Vec<ast::Name> {\n@@ -398,7 +398,7 @@ pub fn used_crates(tcx: TyCtxt, prefer: LinkagePreference)\n         })\n         .collect::<Vec<_>>();\n     let mut ordering = tcx.postorder_cnums(LOCAL_CRATE);\n-    Rc::make_mut(&mut ordering).reverse();\n+    Lrc::make_mut(&mut ordering).reverse();\n     libs.sort_by_key(|&(a, _)| {\n         ordering.iter().position(|x| *x == a)\n     });"}, {"sha": "b65046022b7f49b7ca6c0c07cefa6690ef345d74", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -27,7 +27,7 @@ use middle::region;\n use ty::{self, TyCtxt, adjustment};\n \n use hir::{self, PatKind};\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n use syntax::ptr::P;\n use syntax_pos::Span;\n@@ -279,7 +279,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx, 'tcx> {\n                param_env: ty::ParamEnv<'tcx>,\n                region_scope_tree: &'a region::ScopeTree,\n                tables: &'a ty::TypeckTables<'tcx>,\n-               rvalue_promotable_map: Option<Rc<ItemLocalSet>>)\n+               rvalue_promotable_map: Option<Lrc<ItemLocalSet>>)\n                -> Self\n     {\n         ExprUseVisitor {"}, {"sha": "c532427cc9b429add7e040e538dae2b638a7c9b0", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -85,6 +85,7 @@ use syntax::ast;\n use syntax_pos::Span;\n \n use std::fmt;\n+use rustc_data_structures::sync::Lrc;\n use std::rc::Rc;\n use util::nodemap::ItemLocalSet;\n \n@@ -286,7 +287,7 @@ pub struct MemCategorizationContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     pub region_scope_tree: &'a region::ScopeTree,\n     pub tables: &'a ty::TypeckTables<'tcx>,\n-    rvalue_promotable_map: Option<Rc<ItemLocalSet>>,\n+    rvalue_promotable_map: Option<Lrc<ItemLocalSet>>,\n     infcx: Option<&'a InferCtxt<'a, 'gcx, 'tcx>>,\n }\n \n@@ -395,7 +396,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                region_scope_tree: &'a region::ScopeTree,\n                tables: &'a ty::TypeckTables<'tcx>,\n-               rvalue_promotable_map: Option<Rc<ItemLocalSet>>)\n+               rvalue_promotable_map: Option<Lrc<ItemLocalSet>>)\n                -> MemCategorizationContext<'a, 'tcx, 'tcx> {\n         MemCategorizationContext {\n             tcx,"}, {"sha": "749685182a8f4fd6a19b95726523e0c76d527a97", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -18,7 +18,7 @@\n use hir::map as hir_map;\n use hir::def::Def;\n use hir::def_id::{DefId, CrateNum};\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use ty::{self, TyCtxt};\n use ty::maps::Providers;\n use middle::privacy;\n@@ -377,7 +377,7 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n // We introduce a new-type here, so we can have a specialized HashStable\n // implementation for it.\n #[derive(Clone)]\n-pub struct ReachableSet(pub Rc<NodeSet>);\n+pub struct ReachableSet(pub Lrc<NodeSet>);\n \n \n fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) -> ReachableSet {\n@@ -425,7 +425,7 @@ fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) ->\n     reachable_context.propagate();\n \n     // Return the set of reachable symbols.\n-    ReachableSet(Rc::new(reachable_context.reachable_symbols))\n+    ReachableSet(Lrc::new(reachable_context.reachable_symbols))\n }\n \n pub fn provide(providers: &mut Providers) {"}, {"sha": "812ee0dc72fd67e605f04f9afaae7aafedaed49c", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -20,7 +20,7 @@ use ty;\n \n use std::fmt;\n use std::mem;\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use syntax::codemap;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -1436,7 +1436,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n }\n \n fn region_scope_tree<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-    -> Rc<ScopeTree>\n+    -> Lrc<ScopeTree>\n {\n     let closure_base_def_id = tcx.closure_base_def_id(def_id);\n     if closure_base_def_id != def_id {\n@@ -1478,7 +1478,7 @@ fn region_scope_tree<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n         ScopeTree::default()\n     };\n \n-    Rc::new(scope_tree)\n+    Lrc::new(scope_tree)\n }\n \n pub fn provide(providers: &mut Providers) {"}, {"sha": "f8fb2e5a1c821d0dfa0ba8aa3eaf619a9c98cbf4", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -23,7 +23,7 @@ use ty::{self, TyCtxt};\n \n use std::cell::Cell;\n use std::mem::replace;\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n use syntax::attr;\n use syntax::ptr::P;\n@@ -212,10 +212,10 @@ struct NamedRegionMap {\n \n /// See `NamedRegionMap`.\n pub struct ResolveLifetimes {\n-    defs: FxHashMap<LocalDefId, Rc<FxHashMap<ItemLocalId, Region>>>,\n-    late_bound: FxHashMap<LocalDefId, Rc<FxHashSet<ItemLocalId>>>,\n+    defs: FxHashMap<LocalDefId, Lrc<FxHashMap<ItemLocalId, Region>>>,\n+    late_bound: FxHashMap<LocalDefId, Lrc<FxHashSet<ItemLocalId>>>,\n     object_lifetime_defaults:\n-        FxHashMap<LocalDefId, Rc<FxHashMap<ItemLocalId, Rc<Vec<ObjectLifetimeDefault>>>>>,\n+        FxHashMap<LocalDefId, Lrc<FxHashMap<ItemLocalId, Lrc<Vec<ObjectLifetimeDefault>>>>>,\n }\n \n impl_stable_hash_for!(struct ::middle::resolve_lifetime::ResolveLifetimes {\n@@ -376,7 +376,7 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n fn resolve_lifetimes<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     for_krate: CrateNum,\n-) -> Rc<ResolveLifetimes> {\n+) -> Lrc<ResolveLifetimes> {\n     assert_eq!(for_krate, LOCAL_CRATE);\n \n     let named_region_map = krate(tcx);\n@@ -385,29 +385,29 @@ fn resolve_lifetimes<'tcx>(\n     for (k, v) in named_region_map.defs {\n         let hir_id = tcx.hir.node_to_hir_id(k);\n         let map = defs.entry(hir_id.owner_local_def_id())\n-            .or_insert_with(|| Rc::new(FxHashMap()));\n-        Rc::get_mut(map).unwrap().insert(hir_id.local_id, v);\n+            .or_insert_with(|| Lrc::new(FxHashMap()));\n+        Lrc::get_mut(map).unwrap().insert(hir_id.local_id, v);\n     }\n     let mut late_bound = FxHashMap();\n     for k in named_region_map.late_bound {\n         let hir_id = tcx.hir.node_to_hir_id(k);\n         let map = late_bound\n             .entry(hir_id.owner_local_def_id())\n-            .or_insert_with(|| Rc::new(FxHashSet()));\n-        Rc::get_mut(map).unwrap().insert(hir_id.local_id);\n+            .or_insert_with(|| Lrc::new(FxHashSet()));\n+        Lrc::get_mut(map).unwrap().insert(hir_id.local_id);\n     }\n     let mut object_lifetime_defaults = FxHashMap();\n     for (k, v) in named_region_map.object_lifetime_defaults {\n         let hir_id = tcx.hir.node_to_hir_id(k);\n         let map = object_lifetime_defaults\n             .entry(hir_id.owner_local_def_id())\n-            .or_insert_with(|| Rc::new(FxHashMap()));\n-        Rc::get_mut(map)\n+            .or_insert_with(|| Lrc::new(FxHashMap()));\n+        Lrc::get_mut(map)\n             .unwrap()\n-            .insert(hir_id.local_id, Rc::new(v));\n+            .insert(hir_id.local_id, Lrc::new(v));\n     }\n \n-    Rc::new(ResolveLifetimes {\n+    Lrc::new(ResolveLifetimes {\n         defs,\n         late_bound,\n         object_lifetime_defaults,"}, {"sha": "7c9feb506afd098c9c5b34b770cb418df3ddb4fd", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -16,6 +16,7 @@ use graphviz::IntoCow;\n use middle::const_val::ConstVal;\n use middle::region;\n use rustc_const_math::{ConstUsize, ConstInt, ConstMathErr};\n+use rustc_data_structures::sync::{Lrc};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_data_structures::control_flow_graph::dominators::{Dominators, dominators};\n use rustc_data_structures::control_flow_graph::{GraphPredecessors, GraphSuccessors};\n@@ -36,7 +37,6 @@ use std::cell::Ref;\n use std::fmt::{self, Debug, Formatter, Write};\n use std::{iter, mem, u32};\n use std::ops::{Index, IndexMut};\n-use std::rc::Rc;\n use std::vec::IntoIter;\n use syntax::ast::{self, Name};\n use syntax::symbol::InternedString;\n@@ -1970,10 +1970,10 @@ pub struct UnsafetyViolation {\n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct UnsafetyCheckResult {\n     /// Violations that are propagated *upwards* from this function\n-    pub violations: Rc<[UnsafetyViolation]>,\n+    pub violations: Lrc<[UnsafetyViolation]>,\n     /// unsafe blocks in this function, along with whether they are used. This is\n     /// used for the \"unused_unsafe\" lint.\n-    pub unsafe_blocks: Rc<[(ast::NodeId, bool)]>,\n+    pub unsafe_blocks: Lrc<[(ast::NodeId, bool)]>,\n }\n \n /// The layout of generator state"}, {"sha": "db699349be6bb5c507fbd4153dd8fae833b872a1", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -25,6 +25,8 @@ use ty::tls;\n use util::nodemap::{FxHashMap, FxHashSet};\n use util::common::{duration_to_secs_str, ErrorReported};\n \n+use rustc_data_structures::sync::Lrc;\n+\n use syntax::ast::NodeId;\n use errors::{self, DiagnosticBuilder, DiagnosticId};\n use errors::emitter::{Emitter, EmitterWriter};\n@@ -48,7 +50,6 @@ use std::env;\n use std::fmt;\n use std::io::Write;\n use std::path::{Path, PathBuf};\n-use std::rc::Rc;\n use std::sync::{Once, ONCE_INIT};\n use std::time::Duration;\n \n@@ -896,14 +897,14 @@ pub fn build_session(sopts: config::Options,\n     build_session_with_codemap(sopts,\n                                local_crate_source_file,\n                                registry,\n-                               Rc::new(codemap::CodeMap::new(file_path_mapping)),\n+                               Lrc::new(codemap::CodeMap::new(file_path_mapping)),\n                                None)\n }\n \n pub fn build_session_with_codemap(sopts: config::Options,\n                                   local_crate_source_file: Option<PathBuf>,\n                                   registry: errors::registry::Registry,\n-                                  codemap: Rc<codemap::CodeMap>,\n+                                  codemap: Lrc<codemap::CodeMap>,\n                                   emitter_dest: Option<Box<Write + Send>>)\n                                   -> Session {\n     // FIXME: This is not general enough to make the warning lint completely override\n@@ -971,7 +972,7 @@ pub fn build_session_with_codemap(sopts: config::Options,\n pub fn build_session_(sopts: config::Options,\n                       local_crate_source_file: Option<PathBuf>,\n                       span_diagnostic: errors::Handler,\n-                      codemap: Rc<codemap::CodeMap>)\n+                      codemap: Lrc<codemap::CodeMap>)\n                       -> Session {\n     let host = match Target::search(config::host_triple()) {\n         Ok(t) => t,"}, {"sha": "b9ae4599d808ea1ce2d1ef1e944be169138ee588", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -27,6 +27,7 @@ use ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable, ToPredicate};\n use ty::error::{ExpectedFound, TypeError};\n use infer::{InferCtxt};\n \n+use rustc_data_structures::sync::Lrc;\n use std::rc::Rc;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -740,11 +741,11 @@ fn substitute_normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n fn vtable_methods<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>)\n-    -> Rc<Vec<Option<(DefId, &'tcx Substs<'tcx>)>>>\n+    -> Lrc<Vec<Option<(DefId, &'tcx Substs<'tcx>)>>>\n {\n     debug!(\"vtable_methods({:?})\", trait_ref);\n \n-    Rc::new(\n+    Lrc::new(\n         supertraits(tcx, trait_ref).flat_map(move |trait_ref| {\n             let trait_methods = tcx.associated_items(trait_ref.def_id())\n                 .filter(|item| item.kind == ty::AssociatedKind::Method);"}, {"sha": "43940d7cea3ed6a24a5cf841c2374f87f02dd64e", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -30,7 +30,7 @@ use traits::{self, Reveal, ObligationCause};\n use traits::select::IntercrateAmbiguityCause;\n use ty::{self, TyCtxt, TypeFoldable};\n use syntax_pos::DUMMY_SP;\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n \n use lint;\n \n@@ -308,7 +308,7 @@ impl SpecializesCache {\n // Query provider for `specialization_graph_of`.\n pub(super) fn specialization_graph_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                       trait_id: DefId)\n-                                                      -> Rc<specialization_graph::Graph> {\n+                                                      -> Lrc<specialization_graph::Graph> {\n     let mut sg = specialization_graph::Graph::new();\n \n     let mut trait_impls = Vec::new();\n@@ -392,7 +392,7 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n         }\n     }\n \n-    Rc::new(sg)\n+    Lrc::new(sg)\n }\n \n /// Recovers the \"impl X for Y\" signature from `impl_def_id` and returns it as a"}, {"sha": "a9b38d6a8d877d0ca091dc397c60a87796e60850", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -17,7 +17,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n use traits;\n use ty::{self, TyCtxt, TypeFoldable};\n use ty::fast_reject::{self, SimplifiedType};\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use syntax::ast::Name;\n use util::nodemap::{DefIdMap, FxHashMap};\n \n@@ -327,7 +327,7 @@ impl<'a, 'gcx, 'tcx> Node {\n \n pub struct Ancestors {\n     trait_def_id: DefId,\n-    specialization_graph: Rc<Graph>,\n+    specialization_graph: Lrc<Graph>,\n     current_source: Option<Node>,\n }\n "}, {"sha": "3ad8df879f20f381a292bd643bd80d7975d01827", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -55,6 +55,7 @@ use rustc_data_structures::stable_hasher::{HashStable, hash_stable_hashmap,\n use arena::{TypedArena, DroplessArena};\n use rustc_const_math::{ConstInt, ConstUsize};\n use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::sync::Lrc;\n use std::any::Any;\n use std::borrow::Borrow;\n use std::cell::{Cell, RefCell};\n@@ -64,7 +65,6 @@ use std::hash::{Hash, Hasher};\n use std::mem;\n use std::ops::Deref;\n use std::iter;\n-use std::rc::Rc;\n use std::sync::mpsc;\n use std::sync::Arc;\n use syntax::abi;\n@@ -397,9 +397,9 @@ pub struct TypeckTables<'tcx> {\n \n     /// Set of trait imports actually used in the method resolution.\n     /// This is used for warning unused imports. During type\n-    /// checking, this `Rc` should not be cloned: it must have a ref-count\n+    /// checking, this `Lrc` should not be cloned: it must have a ref-count\n     /// of 1 so that we can insert things into the set mutably.\n-    pub used_trait_imports: Rc<DefIdSet>,\n+    pub used_trait_imports: Lrc<DefIdSet>,\n \n     /// If any errors occurred while type-checking this body,\n     /// this field will be set to `true`.\n@@ -426,7 +426,7 @@ impl<'tcx> TypeckTables<'tcx> {\n             liberated_fn_sigs: ItemLocalMap(),\n             fru_field_types: ItemLocalMap(),\n             cast_kinds: ItemLocalMap(),\n-            used_trait_imports: Rc::new(DefIdSet()),\n+            used_trait_imports: Lrc::new(DefIdSet()),\n             tainted_by_errors: false,\n             free_region_map: FreeRegionMap::new(),\n         }\n@@ -816,11 +816,11 @@ pub struct GlobalCtxt<'tcx> {\n     /// Map indicating what traits are in scope for places where this\n     /// is relevant; generated by resolve.\n     trait_map: FxHashMap<DefIndex,\n-                         Rc<FxHashMap<ItemLocalId,\n-                                      Rc<StableVec<TraitCandidate>>>>>,\n+                         Lrc<FxHashMap<ItemLocalId,\n+                                       Lrc<StableVec<TraitCandidate>>>>>,\n \n     /// Export map produced by name resolution.\n-    export_map: FxHashMap<DefId, Rc<Vec<Export>>>,\n+    export_map: FxHashMap<DefId, Lrc<Vec<Export>>>,\n \n     pub hir: hir_map::Map<'tcx>,\n \n@@ -833,7 +833,7 @@ pub struct GlobalCtxt<'tcx> {\n     // Records the free variables refrenced by every closure\n     // expression. Do not track deps for this, just recompute it from\n     // scratch every time.\n-    freevars: FxHashMap<DefId, Rc<Vec<hir::Freevar>>>,\n+    freevars: FxHashMap<DefId, Lrc<Vec<hir::Freevar>>>,\n \n     maybe_unused_trait_imports: FxHashSet<DefId>,\n \n@@ -1153,7 +1153,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         providers[LOCAL_CRATE] = local_providers;\n \n         let def_path_hash_to_def_id = if s.opts.build_dep_graph() {\n-            let upstream_def_path_tables: Vec<(CrateNum, Rc<_>)> = cstore\n+            let upstream_def_path_tables: Vec<(CrateNum, Lrc<_>)> = cstore\n                 .crates_untracked()\n                 .iter()\n                 .map(|&cnum| (cnum, cstore.def_path_table(cnum)))\n@@ -1188,10 +1188,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         for (k, v) in resolutions.trait_map {\n             let hir_id = hir.node_to_hir_id(k);\n             let map = trait_map.entry(hir_id.owner)\n-                .or_insert_with(|| Rc::new(FxHashMap()));\n-            Rc::get_mut(map).unwrap()\n+                .or_insert_with(|| Lrc::new(FxHashMap()));\n+            Lrc::get_mut(map).unwrap()\n                             .insert(hir_id.local_id,\n-                                    Rc::new(StableVec::new(v)));\n+                                    Lrc::new(StableVec::new(v)));\n         }\n \n         tls::enter_global(GlobalCtxt {\n@@ -1204,10 +1204,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             types: common_types,\n             trait_map,\n             export_map: resolutions.export_map.into_iter().map(|(k, v)| {\n-                (k, Rc::new(v))\n+                (k, Lrc::new(v))\n             }).collect(),\n             freevars: resolutions.freevars.into_iter().map(|(k, v)| {\n-                (hir.local_def_id(k), Rc::new(v))\n+                (hir.local_def_id(k), Lrc::new(v))\n             }).collect(),\n             maybe_unused_trait_imports:\n                 resolutions.maybe_unused_trait_imports\n@@ -1243,15 +1243,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.sess.consider_optimizing(&cname, msg)\n     }\n \n-    pub fn lang_items(self) -> Rc<middle::lang_items::LanguageItems> {\n+    pub fn lang_items(self) -> Lrc<middle::lang_items::LanguageItems> {\n         self.get_lang_items(LOCAL_CRATE)\n     }\n \n-    pub fn stability(self) -> Rc<stability::Index<'tcx>> {\n+    pub fn stability(self) -> Lrc<stability::Index<'tcx>> {\n         self.stability_index(LOCAL_CRATE)\n     }\n \n-    pub fn crates(self) -> Rc<Vec<CrateNum>> {\n+    pub fn crates(self) -> Lrc<Vec<CrateNum>> {\n         self.all_crate_nums(LOCAL_CRATE)\n     }\n \n@@ -1312,7 +1312,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     // Note that this is *untracked* and should only be used within the query\n     // system if the result is otherwise tracked through queries\n-    pub fn crate_data_as_rc_any(self, cnum: CrateNum) -> Rc<Any> {\n+    pub fn crate_data_as_rc_any(self, cnum: CrateNum) -> Lrc<Any> {\n         self.cstore.crate_data_as_rc_any(cnum)\n     }\n \n@@ -2264,7 +2264,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         lint::struct_lint_level(self.sess, lint, level, src, None, msg)\n     }\n \n-    pub fn in_scope_traits(self, id: HirId) -> Option<Rc<StableVec<TraitCandidate>>> {\n+    pub fn in_scope_traits(self, id: HirId) -> Option<Lrc<StableVec<TraitCandidate>>> {\n         self.in_scope_traits_map(id.owner)\n             .and_then(|map| map.get(&id.local_id).cloned())\n     }\n@@ -2281,7 +2281,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn object_lifetime_defaults(self, id: HirId)\n-        -> Option<Rc<Vec<ObjectLifetimeDefault>>>\n+        -> Option<Lrc<Vec<ObjectLifetimeDefault>>>\n     {\n         self.object_lifetime_defaults_map(id.owner)\n             .and_then(|map| map.get(&id.local_id).cloned())\n@@ -2352,20 +2352,20 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         // Once red/green incremental compilation lands we should be able to\n         // remove this because while the crate changes often the lint level map\n         // will change rarely.\n-        tcx.dep_graph.with_ignore(|| Rc::new(middle::lang_items::collect(tcx)))\n+        tcx.dep_graph.with_ignore(|| Lrc::new(middle::lang_items::collect(tcx)))\n     };\n     providers.freevars = |tcx, id| tcx.gcx.freevars.get(&id).cloned();\n     providers.maybe_unused_trait_import = |tcx, id| {\n         tcx.maybe_unused_trait_imports.contains(&id)\n     };\n     providers.maybe_unused_extern_crates = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        Rc::new(tcx.maybe_unused_extern_crates.clone())\n+        Lrc::new(tcx.maybe_unused_extern_crates.clone())\n     };\n \n     providers.stability_index = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        Rc::new(stability::Index::new(tcx))\n+        Lrc::new(stability::Index::new(tcx))\n     };\n     providers.lookup_stability = |tcx, id| {\n         assert_eq!(id.krate, LOCAL_CRATE);\n@@ -2383,11 +2383,11 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n     };\n     providers.all_crate_nums = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        Rc::new(tcx.cstore.crates_untracked())\n+        Lrc::new(tcx.cstore.crates_untracked())\n     };\n     providers.postorder_cnums = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        Rc::new(tcx.cstore.postorder_cnums_untracked())\n+        Lrc::new(tcx.cstore.postorder_cnums_untracked())\n     };\n     providers.output_filenames = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);"}, {"sha": "6edb1d9be35db855baf1678756634ba05c282eab", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -46,7 +46,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stable_hasher::StableVec;\n \n use std::ops::Deref;\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use std::sync::Arc;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax_pos::symbol::InternedString;\n@@ -119,17 +119,17 @@ define_maps! { <'tcx>\n \n     /// Get a map with the variance of every item; use `item_variance`\n     /// instead.\n-    [] fn crate_variances: crate_variances(CrateNum) -> Rc<ty::CrateVariancesMap>,\n+    [] fn crate_variances: crate_variances(CrateNum) -> Lrc<ty::CrateVariancesMap>,\n \n     /// Maps from def-id of a type or region parameter to its\n     /// (inferred) variance.\n-    [] fn variances_of: ItemVariances(DefId) -> Rc<Vec<ty::Variance>>,\n+    [] fn variances_of: ItemVariances(DefId) -> Lrc<Vec<ty::Variance>>,\n \n     /// Maps from def-id of a type to its (inferred) outlives.\n     [] fn inferred_outlives_of: InferredOutlivesOf(DefId) -> Vec<ty::Predicate<'tcx>>,\n \n     /// Maps from an impl/trait def-id to a list of the def-ids of its items\n-    [] fn associated_item_def_ids: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>>,\n+    [] fn associated_item_def_ids: AssociatedItemDefIds(DefId) -> Lrc<Vec<DefId>>,\n \n     /// Maps from a trait item to the trait item \"descriptor\"\n     [] fn associated_item: AssociatedItems(DefId) -> ty::AssociatedItem,\n@@ -140,17 +140,17 @@ define_maps! { <'tcx>\n     /// Maps a DefId of a type to a list of its inherent impls.\n     /// Contains implementations of methods that are inherent to a type.\n     /// Methods in these implementations don't need to be exported.\n-    [] fn inherent_impls: InherentImpls(DefId) -> Rc<Vec<DefId>>,\n+    [] fn inherent_impls: InherentImpls(DefId) -> Lrc<Vec<DefId>>,\n \n     /// Set of all the def-ids in this crate that have MIR associated with\n     /// them. This includes all the body owners, but also things like struct\n     /// constructors.\n-    [] fn mir_keys: mir_keys(CrateNum) -> Rc<DefIdSet>,\n+    [] fn mir_keys: mir_keys(CrateNum) -> Lrc<DefIdSet>,\n \n     /// Maps DefId's that have an associated Mir to the result\n     /// of the MIR qualify_consts pass. The actual meaning of\n     /// the value isn't known except to the pass itself.\n-    [] fn mir_const_qualif: MirConstQualif(DefId) -> (u8, Rc<IdxSetBuf<mir::Local>>),\n+    [] fn mir_const_qualif: MirConstQualif(DefId) -> (u8, Lrc<IdxSetBuf<mir::Local>>),\n \n     /// Fetch the MIR for a given def-id right after it's built - this includes\n     /// unreachable code.\n@@ -185,13 +185,13 @@ define_maps! { <'tcx>\n \n     [] fn typeck_tables_of: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n \n-    [] fn used_trait_imports: UsedTraitImports(DefId) -> Rc<DefIdSet>,\n+    [] fn used_trait_imports: UsedTraitImports(DefId) -> Lrc<DefIdSet>,\n \n     [] fn has_typeck_tables: HasTypeckTables(DefId) -> bool,\n \n     [] fn coherent_trait: CoherenceCheckTrait(DefId) -> (),\n \n-    [] fn borrowck: BorrowCheck(DefId) -> Rc<BorrowCheckResult>,\n+    [] fn borrowck: BorrowCheck(DefId) -> Lrc<BorrowCheckResult>,\n \n     /// Borrow checks the function body. If this is a closure, returns\n     /// additional requirements that the closure's creator must verify.\n@@ -216,13 +216,13 @@ define_maps! { <'tcx>\n         -> Result<(), ErrorReported>,\n \n     /// Performs the privacy check and computes \"access levels\".\n-    [] fn privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Rc<AccessLevels>,\n+    [] fn privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Lrc<AccessLevels>,\n \n     [] fn reachable_set: reachability_dep_node(CrateNum) -> ReachableSet,\n \n     /// Per-body `region::ScopeTree`. The `DefId` should be the owner-def-id for the body;\n     /// in the case of closures, this will be redirected to the enclosing function.\n-    [] fn region_scope_tree: RegionScopeTree(DefId) -> Rc<region::ScopeTree>,\n+    [] fn region_scope_tree: RegionScopeTree(DefId) -> Lrc<region::ScopeTree>,\n \n     [] fn mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx mir::Mir<'tcx>,\n \n@@ -233,22 +233,22 @@ define_maps! { <'tcx>\n     [] fn def_span: DefSpan(DefId) -> Span,\n     [] fn lookup_stability: LookupStability(DefId) -> Option<&'tcx attr::Stability>,\n     [] fn lookup_deprecation_entry: LookupDeprecationEntry(DefId) -> Option<DeprecationEntry>,\n-    [] fn item_attrs: ItemAttrs(DefId) -> Rc<[ast::Attribute]>,\n+    [] fn item_attrs: ItemAttrs(DefId) -> Lrc<[ast::Attribute]>,\n     [] fn fn_arg_names: FnArgNames(DefId) -> Vec<ast::Name>,\n     [] fn impl_parent: ImplParent(DefId) -> Option<DefId>,\n     [] fn trait_of_item: TraitOfItem(DefId) -> Option<DefId>,\n     [] fn is_exported_symbol: IsExportedSymbol(DefId) -> bool,\n     [] fn item_body_nested_bodies: ItemBodyNestedBodies(DefId) -> ExternBodyNestedBodies,\n     [] fn const_is_rvalue_promotable_to_static: ConstIsRvaluePromotableToStatic(DefId) -> bool,\n-    [] fn rvalue_promotable_map: RvaluePromotableMap(DefId) -> Rc<ItemLocalSet>,\n+    [] fn rvalue_promotable_map: RvaluePromotableMap(DefId) -> Lrc<ItemLocalSet>,\n     [] fn is_mir_available: IsMirAvailable(DefId) -> bool,\n     [] fn vtable_methods: vtable_methods_node(ty::PolyTraitRef<'tcx>)\n-                          -> Rc<Vec<Option<(DefId, &'tcx Substs<'tcx>)>>>,\n+                          -> Lrc<Vec<Option<(DefId, &'tcx Substs<'tcx>)>>>,\n \n     [] fn trans_fulfill_obligation: fulfill_obligation_dep_node(\n         (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)) -> Vtable<'tcx, ()>,\n-    [] fn trait_impls_of: TraitImpls(DefId) -> Rc<ty::trait_def::TraitImpls>,\n-    [] fn specialization_graph_of: SpecializationGraph(DefId) -> Rc<specialization_graph::Graph>,\n+    [] fn trait_impls_of: TraitImpls(DefId) -> Lrc<ty::trait_def::TraitImpls>,\n+    [] fn specialization_graph_of: SpecializationGraph(DefId) -> Lrc<specialization_graph::Graph>,\n     [] fn is_object_safe: ObjectSafety(DefId) -> bool,\n \n     // Get the ParameterEnvironment for a given item; this environment\n@@ -270,7 +270,7 @@ define_maps! { <'tcx>\n                                             ty::layout::LayoutError<'tcx>>,\n \n     [] fn dylib_dependency_formats: DylibDepFormats(CrateNum)\n-                                    -> Rc<Vec<(CrateNum, LinkagePreference)>>,\n+                                    -> Lrc<Vec<(CrateNum, LinkagePreference)>>,\n \n     [fatal_cycle] fn is_panic_runtime: IsPanicRuntime(CrateNum) -> bool,\n     [fatal_cycle] fn is_compiler_builtins: IsCompilerBuiltins(CrateNum) -> bool,\n@@ -280,66 +280,66 @@ define_maps! { <'tcx>\n     [fatal_cycle] fn panic_strategy: GetPanicStrategy(CrateNum) -> PanicStrategy,\n     [fatal_cycle] fn is_no_builtins: IsNoBuiltins(CrateNum) -> bool,\n \n-    [] fn extern_crate: ExternCrate(DefId) -> Rc<Option<ExternCrate>>,\n+    [] fn extern_crate: ExternCrate(DefId) -> Lrc<Option<ExternCrate>>,\n \n     [] fn specializes: specializes_node((DefId, DefId)) -> bool,\n     [] fn in_scope_traits_map: InScopeTraits(DefIndex)\n-        -> Option<Rc<FxHashMap<ItemLocalId, Rc<StableVec<TraitCandidate>>>>>,\n-    [] fn module_exports: ModuleExports(DefId) -> Option<Rc<Vec<Export>>>,\n-    [] fn lint_levels: lint_levels_node(CrateNum) -> Rc<lint::LintLevelMap>,\n+        -> Option<Lrc<FxHashMap<ItemLocalId, Lrc<StableVec<TraitCandidate>>>>>,\n+    [] fn module_exports: ModuleExports(DefId) -> Option<Lrc<Vec<Export>>>,\n+    [] fn lint_levels: lint_levels_node(CrateNum) -> Lrc<lint::LintLevelMap>,\n \n     [] fn impl_defaultness: ImplDefaultness(DefId) -> hir::Defaultness,\n-    [] fn exported_symbol_ids: ExportedSymbolIds(CrateNum) -> Rc<DefIdSet>,\n-    [] fn native_libraries: NativeLibraries(CrateNum) -> Rc<Vec<NativeLibrary>>,\n+    [] fn exported_symbol_ids: ExportedSymbolIds(CrateNum) -> Lrc<DefIdSet>,\n+    [] fn native_libraries: NativeLibraries(CrateNum) -> Lrc<Vec<NativeLibrary>>,\n     [] fn plugin_registrar_fn: PluginRegistrarFn(CrateNum) -> Option<DefId>,\n     [] fn derive_registrar_fn: DeriveRegistrarFn(CrateNum) -> Option<DefId>,\n     [] fn crate_disambiguator: CrateDisambiguator(CrateNum) -> CrateDisambiguator,\n     [] fn crate_hash: CrateHash(CrateNum) -> Svh,\n     [] fn original_crate_name: OriginalCrateName(CrateNum) -> Symbol,\n \n     [] fn implementations_of_trait: implementations_of_trait_node((CrateNum, DefId))\n-        -> Rc<Vec<DefId>>,\n+        -> Lrc<Vec<DefId>>,\n     [] fn all_trait_implementations: AllTraitImplementations(CrateNum)\n-        -> Rc<Vec<DefId>>,\n+        -> Lrc<Vec<DefId>>,\n \n     [] fn is_dllimport_foreign_item: IsDllimportForeignItem(DefId) -> bool,\n     [] fn is_statically_included_foreign_item: IsStaticallyIncludedForeignItem(DefId) -> bool,\n     [] fn native_library_kind: NativeLibraryKind(DefId)\n         -> Option<NativeLibraryKind>,\n-    [] fn link_args: link_args_node(CrateNum) -> Rc<Vec<String>>,\n+    [] fn link_args: link_args_node(CrateNum) -> Lrc<Vec<String>>,\n \n     // Lifetime resolution. See `middle::resolve_lifetimes`.\n-    [] fn resolve_lifetimes: ResolveLifetimes(CrateNum) -> Rc<ResolveLifetimes>,\n+    [] fn resolve_lifetimes: ResolveLifetimes(CrateNum) -> Lrc<ResolveLifetimes>,\n     [] fn named_region_map: NamedRegion(DefIndex) ->\n-        Option<Rc<FxHashMap<ItemLocalId, Region>>>,\n+        Option<Lrc<FxHashMap<ItemLocalId, Region>>>,\n     [] fn is_late_bound_map: IsLateBound(DefIndex) ->\n-        Option<Rc<FxHashSet<ItemLocalId>>>,\n+        Option<Lrc<FxHashSet<ItemLocalId>>>,\n     [] fn object_lifetime_defaults_map: ObjectLifetimeDefaults(DefIndex)\n-        -> Option<Rc<FxHashMap<ItemLocalId, Rc<Vec<ObjectLifetimeDefault>>>>>,\n+        -> Option<Lrc<FxHashMap<ItemLocalId, Lrc<Vec<ObjectLifetimeDefault>>>>>,\n \n     [] fn visibility: Visibility(DefId) -> ty::Visibility,\n     [] fn dep_kind: DepKind(CrateNum) -> DepKind,\n     [] fn crate_name: CrateName(CrateNum) -> Symbol,\n-    [] fn item_children: ItemChildren(DefId) -> Rc<Vec<Export>>,\n+    [] fn item_children: ItemChildren(DefId) -> Lrc<Vec<Export>>,\n     [] fn extern_mod_stmt_cnum: ExternModStmtCnum(DefId) -> Option<CrateNum>,\n \n-    [] fn get_lang_items: get_lang_items_node(CrateNum) -> Rc<LanguageItems>,\n-    [] fn defined_lang_items: DefinedLangItems(CrateNum) -> Rc<Vec<(DefId, usize)>>,\n-    [] fn missing_lang_items: MissingLangItems(CrateNum) -> Rc<Vec<LangItem>>,\n+    [] fn get_lang_items: get_lang_items_node(CrateNum) -> Lrc<LanguageItems>,\n+    [] fn defined_lang_items: DefinedLangItems(CrateNum) -> Lrc<Vec<(DefId, usize)>>,\n+    [] fn missing_lang_items: MissingLangItems(CrateNum) -> Lrc<Vec<LangItem>>,\n     [] fn extern_const_body: ExternConstBody(DefId) -> ExternConstBody<'tcx>,\n     [] fn visible_parent_map: visible_parent_map_node(CrateNum)\n-        -> Rc<DefIdMap<DefId>>,\n+        -> Lrc<DefIdMap<DefId>>,\n     [] fn missing_extern_crate_item: MissingExternCrateItem(CrateNum) -> bool,\n-    [] fn used_crate_source: UsedCrateSource(CrateNum) -> Rc<CrateSource>,\n-    [] fn postorder_cnums: postorder_cnums_node(CrateNum) -> Rc<Vec<CrateNum>>,\n+    [] fn used_crate_source: UsedCrateSource(CrateNum) -> Lrc<CrateSource>,\n+    [] fn postorder_cnums: postorder_cnums_node(CrateNum) -> Lrc<Vec<CrateNum>>,\n \n-    [] fn freevars: Freevars(DefId) -> Option<Rc<Vec<hir::Freevar>>>,\n+    [] fn freevars: Freevars(DefId) -> Option<Lrc<Vec<hir::Freevar>>>,\n     [] fn maybe_unused_trait_import: MaybeUnusedTraitImport(DefId) -> bool,\n     [] fn maybe_unused_extern_crates: maybe_unused_extern_crates_node(CrateNum)\n-        -> Rc<Vec<(DefId, Span)>>,\n+        -> Lrc<Vec<(DefId, Span)>>,\n \n-    [] fn stability_index: stability_index_node(CrateNum) -> Rc<stability::Index<'tcx>>,\n-    [] fn all_crate_nums: all_crate_nums_node(CrateNum) -> Rc<Vec<CrateNum>>,\n+    [] fn stability_index: stability_index_node(CrateNum) -> Lrc<stability::Index<'tcx>>,\n+    [] fn all_crate_nums: all_crate_nums_node(CrateNum) -> Lrc<Vec<CrateNum>>,\n \n     [] fn exported_symbols: ExportedSymbols(CrateNum)\n         -> Arc<Vec<(String, Option<DefId>, SymbolExportLevel)>>,\n@@ -368,8 +368,8 @@ define_maps! { <'tcx>\n         substitute_normalize_and_test_predicates_node((DefId, &'tcx Substs<'tcx>)) -> bool,\n \n     [] fn target_features_whitelist:\n-        target_features_whitelist_node(CrateNum) -> Rc<FxHashSet<String>>,\n-    [] fn target_features_enabled: TargetFeaturesEnabled(DefId) -> Rc<Vec<String>>,\n+        target_features_whitelist_node(CrateNum) -> Lrc<FxHashSet<String>>,\n+    [] fn target_features_enabled: TargetFeaturesEnabled(DefId) -> Lrc<Vec<String>>,\n \n     // Get an estimate of the size of an InstanceDef based on its MIR for CGU partitioning.\n     [] fn instance_def_size_estimate: instance_def_size_estimate_dep_node(ty::InstanceDef<'tcx>)"}, {"sha": "65f2d476475e979eae28a4e212939938fb5e93d7", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -17,14 +17,14 @@ use hir::map::definitions::DefPathHash;\n use ich::{CachingCodemapView, Fingerprint};\n use mir;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder, opaque,\n                       SpecializedDecoder, SpecializedEncoder,\n                       UseSpecializedDecodable, UseSpecializedEncodable};\n use session::{CrateDisambiguator, Session};\n use std::cell::RefCell;\n use std::mem;\n-use std::rc::Rc;\n use syntax::ast::NodeId;\n use syntax::codemap::{CodeMap, StableFilemapId};\n use syntax_pos::{BytePos, Span, DUMMY_SP, FileMap};\n@@ -65,7 +65,7 @@ pub struct OnDiskCache<'sess> {\n     file_index_to_stable_id: FxHashMap<FileMapIndex, StableFilemapId>,\n \n     // These two fields caches that are populated lazily during decoding.\n-    file_index_to_file: RefCell<FxHashMap<FileMapIndex, Rc<FileMap>>>,\n+    file_index_to_file: RefCell<FxHashMap<FileMapIndex, Lrc<FileMap>>>,\n     synthetic_expansion_infos: RefCell<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n \n     // A map from dep-node to the position of the cached query result in\n@@ -421,12 +421,12 @@ struct CacheDecoder<'a, 'tcx: 'a, 'x> {\n     codemap: &'x CodeMap,\n     cnum_map: &'x IndexVec<CrateNum, Option<CrateNum>>,\n     synthetic_expansion_infos: &'x RefCell<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n-    file_index_to_file: &'x RefCell<FxHashMap<FileMapIndex, Rc<FileMap>>>,\n+    file_index_to_file: &'x RefCell<FxHashMap<FileMapIndex, Lrc<FileMap>>>,\n     file_index_to_stable_id: &'x FxHashMap<FileMapIndex, StableFilemapId>,\n }\n \n impl<'a, 'tcx, 'x> CacheDecoder<'a, 'tcx, 'x> {\n-    fn file_index_to_file(&self, index: FileMapIndex) -> Rc<FileMap> {\n+    fn file_index_to_file(&self, index: FileMapIndex) -> Lrc<FileMap> {\n         let CacheDecoder {\n             ref file_index_to_file,\n             ref file_index_to_stable_id,\n@@ -710,7 +710,7 @@ struct CacheEncoder<'enc, 'a, 'tcx, E>\n impl<'enc, 'a, 'tcx, E> CacheEncoder<'enc, 'a, 'tcx, E>\n     where E: 'enc + ty_codec::TyEncoder\n {\n-    fn filemap_index(&mut self, filemap: Rc<FileMap>) -> FileMapIndex {\n+    fn filemap_index(&mut self, filemap: Lrc<FileMap>) -> FileMapIndex {\n         self.file_to_file_index[&(&*filemap as *const FileMap)]\n     }\n "}, {"sha": "9ba33a57c20505329bfba80b2283ccfbd76d573b", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -43,7 +43,7 @@ use std::fmt;\n use std::hash::{Hash, Hasher};\n use std::iter::FromIterator;\n use std::ops::Deref;\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use std::slice;\n use std::vec::IntoIter;\n use std::mem;\n@@ -125,7 +125,7 @@ mod sty;\n /// *on-demand* infrastructure.\n #[derive(Clone)]\n pub struct CrateAnalysis {\n-    pub access_levels: Rc<AccessLevels>,\n+    pub access_levels: Lrc<AccessLevels>,\n     pub name: String,\n     pub glob_map: Option<hir::GlobMap>,\n }\n@@ -337,10 +337,10 @@ pub struct CrateVariancesMap {\n     /// For each item with generics, maps to a vector of the variance\n     /// of its generics.  If an item has no generics, it will have no\n     /// entry.\n-    pub variances: FxHashMap<DefId, Rc<Vec<ty::Variance>>>,\n+    pub variances: FxHashMap<DefId, Lrc<Vec<ty::Variance>>>,\n \n     /// An empty vector, useful for cloning.\n-    pub empty_variance: Rc<Vec<ty::Variance>>,\n+    pub empty_variance: Lrc<Vec<ty::Variance>>,\n }\n \n impl Variance {\n@@ -2198,7 +2198,7 @@ impl BorrowKind {\n \n #[derive(Debug, Clone)]\n pub enum Attributes<'gcx> {\n-    Owned(Rc<[ast::Attribute]>),\n+    Owned(Lrc<[ast::Attribute]>),\n     Borrowed(&'gcx [ast::Attribute])\n }\n \n@@ -2627,7 +2627,7 @@ fn adt_dtorck_constraint<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n fn associated_item_def_ids<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      def_id: DefId)\n-                                     -> Rc<Vec<DefId>> {\n+                                     -> Lrc<Vec<DefId>> {\n     let id = tcx.hir.as_local_node_id(def_id).unwrap();\n     let item = tcx.hir.expect_item(id);\n     let vec: Vec<_> = match item.node {\n@@ -2646,7 +2646,7 @@ fn associated_item_def_ids<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         hir::ItemTraitAlias(..) => vec![],\n         _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\")\n     };\n-    Rc::new(vec)\n+    Lrc::new(vec)\n }\n \n fn def_span<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Span {\n@@ -2760,7 +2760,7 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n /// (constructing this map requires touching the entire crate).\n #[derive(Clone, Debug)]\n pub struct CrateInherentImpls {\n-    pub inherent_impls: DefIdMap<Rc<Vec<DefId>>>,\n+    pub inherent_impls: DefIdMap<Lrc<Vec<DefId>>>,\n }\n \n /// A set of constraints that need to be satisfied in order for"}, {"sha": "62d3c8dc87da39d237aa1d1bafa66537dca219c4", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -20,7 +20,7 @@ use ty::{Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n \n /// A trait's definition with type information.\n pub struct TraitDef {\n@@ -142,7 +142,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n // Query provider for `trait_impls_of`.\n pub(super) fn trait_impls_of_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 trait_id: DefId)\n-                                                -> Rc<TraitImpls> {\n+                                                -> Lrc<TraitImpls> {\n     let mut remote_impls = Vec::new();\n \n     // Traits defined in the current crate can't have impls in upstream\n@@ -180,7 +180,7 @@ pub(super) fn trait_impls_of_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    Rc::new(TraitImpls {\n+    Lrc::new(TraitImpls {\n         blanket_impls: blanket_impls,\n         non_blanket_impls: non_blanket_impls,\n     })"}, {"sha": "3368bbf3855a5546c27bcfb9360051239f18fa1f", "filename": "src/librustc_borrowck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_borrowck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_borrowck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2FCargo.toml?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -17,3 +17,4 @@ graphviz = { path = \"../libgraphviz\" }\n rustc = { path = \"../librustc\" }\n rustc_mir = { path = \"../librustc_mir\" }\n rustc_errors = { path = \"../librustc_errors\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n\\ No newline at end of file"}, {"sha": "4fe6ee45295a3c06b5210194f641056f53bc056b", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -44,6 +44,7 @@ use rustc::util::nodemap::FxHashSet;\n use std::cell::RefCell;\n use std::fmt;\n use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use std::hash::{Hash, Hasher};\n use syntax::ast;\n use syntax_pos::{MultiSpan, Span};\n@@ -86,7 +87,7 @@ pub struct AnalysisData<'a, 'tcx: 'a> {\n }\n \n fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId)\n-    -> Rc<BorrowCheckResult>\n+    -> Lrc<BorrowCheckResult>\n {\n     debug!(\"borrowck(body_owner_def_id={:?})\", owner_def_id);\n \n@@ -99,7 +100,7 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId)\n             // those things (notably the synthesized constructors from\n             // tuple structs/variants) do not have an associated body\n             // and do not need borrowchecking.\n-            return Rc::new(BorrowCheckResult {\n+            return Lrc::new(BorrowCheckResult {\n                 used_mut_nodes: FxHashSet(),\n             })\n         }\n@@ -145,7 +146,7 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId)\n     }\n     unused::check(&mut bccx, body);\n \n-    Rc::new(BorrowCheckResult {\n+    Lrc::new(BorrowCheckResult {\n         used_mut_nodes: bccx.used_mut_nodes.into_inner(),\n     })\n }\n@@ -243,7 +244,7 @@ pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n     // Some in `borrowck_fn` and cleared later\n     tables: &'a ty::TypeckTables<'tcx>,\n \n-    region_scope_tree: Rc<region::ScopeTree>,\n+    region_scope_tree: Lrc<region::ScopeTree>,\n \n     owner_def_id: DefId,\n "}, {"sha": "2bdee3198f22a3e725bab9a6c7f745ff9e8ebdf6", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -23,6 +23,7 @@\n extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc_errors as errors;\n+extern crate rustc_data_structures;\n \n // for \"clarity\", rename the graphviz crate to dot; graphviz within `borrowck`\n // refers to the borrowck-specific graphviz adapter traits."}, {"sha": "15afea19213865a727e30d48fb568f16b172cd55", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -49,7 +49,7 @@ use std::fs;\n use std::io::{self, Write};\n use std::iter;\n use std::path::{Path, PathBuf};\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use std::sync::mpsc;\n use syntax::{self, ast, attr, diagnostics, visit};\n use syntax::ext::base::ExtCtxt;\n@@ -621,7 +621,7 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n                 },\n \n                 analysis: ty::CrateAnalysis {\n-                    access_levels: Rc::new(AccessLevels::default()),\n+                    access_levels: Lrc::new(AccessLevels::default()),\n                     name: crate_name.to_string(),\n                     glob_map: if resolver.make_glob_map { Some(resolver.glob_map) } else { None },\n                 },"}, {"sha": "4d1ec111c470de18f77371fd66ae6d9ce546f7f4", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -62,6 +62,7 @@ use pretty::{PpMode, UserIdentifiedItem};\n use rustc_resolve as resolve;\n use rustc_save_analysis as save;\n use rustc_save_analysis::DumpHandler;\n+use rustc_data_structures::sync::Lrc;\n use rustc::session::{self, config, Session, build_session, CompileResult};\n use rustc::session::CompileIncomplete;\n use rustc::session::config::{Input, PrintRequest, ErrorOutputType};\n@@ -92,7 +93,6 @@ use std::mem;\n use std::panic;\n use std::path::{PathBuf, Path};\n use std::process::{self, Command, Stdio};\n-use std::rc::Rc;\n use std::str;\n use std::sync::atomic::{AtomicBool, ATOMIC_BOOL_INIT, Ordering};\n use std::sync::{Once, ONCE_INIT};\n@@ -482,7 +482,7 @@ pub fn run_compiler<'a>(args: &[String],\n     };\n \n     let loader = file_loader.unwrap_or(box RealFileLoader);\n-    let codemap = Rc::new(CodeMap::with_file_loader(loader, sopts.file_path_mapping()));\n+    let codemap = Lrc::new(CodeMap::with_file_loader(loader, sopts.file_path_mapping()));\n     let mut sess = session::build_session_with_codemap(\n         sopts, input_file_path.clone(), descriptions, codemap, emitter_dest,\n     );"}, {"sha": "becdbb54e5beb2bd1dcddc1ad157d09d86c5200a", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -28,7 +28,7 @@ use rustc_metadata::cstore::CStore;\n use rustc::hir::map as hir_map;\n use rustc::session::{self, config};\n use rustc::session::config::{OutputFilenames, OutputTypes};\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n use syntax::abi::Abi;\n use syntax::codemap::{CodeMap, FilePathMapping, FileName};\n@@ -105,8 +105,8 @@ fn test_env<F>(source_string: &str,\n     let sess = session::build_session_(options,\n                                        None,\n                                        diagnostic_handler,\n-                                       Rc::new(CodeMap::new(FilePathMapping::empty())));\n-    let cstore = Rc::new(CStore::new(::get_trans(&sess).metadata_loader()));\n+                                       Lrc::new(CodeMap::new(FilePathMapping::empty())));\n+    let cstore = CStore::new(::get_trans(&sess).metadata_loader());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let input = config::Input::Str {\n         name: FileName::Anon,\n@@ -128,7 +128,7 @@ fn test_env<F>(source_string: &str,\n     };\n \n     let arenas = ty::AllArenas::new();\n-    let hir_map = hir_map::map_crate(&sess, &*cstore, &mut hir_forest, &defs);\n+    let hir_map = hir_map::map_crate(&sess, &cstore, &mut hir_forest, &defs);\n \n     // run just enough stuff to build a tcx:\n     let (tx, _rx) = mpsc::channel();\n@@ -140,7 +140,7 @@ fn test_env<F>(source_string: &str,\n         outputs: OutputTypes::new(&[]),\n     };\n     TyCtxt::create_and_enter(&sess,\n-                             &*cstore,\n+                             &cstore,\n                              ty::maps::Providers::default(),\n                              ty::maps::Providers::default(),\n                              &arenas,"}, {"sha": "33fce7b1968adfd8f4bb9b5d735a52c29915f71c", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -16,10 +16,10 @@ use {Level, CodeSuggestion, DiagnosticBuilder, SubDiagnostic, CodeMapper, Diagno\n use snippet::{Annotation, AnnotationType, Line, MultilineAnnotation, StyledString, Style};\n use styled_buffer::StyledBuffer;\n \n+use rustc_data_structures::sync::Lrc;\n use std::borrow::Cow;\n use std::io::prelude::*;\n use std::io;\n-use std::rc::Rc;\n use term;\n use std::collections::{HashMap, HashSet};\n use std::cmp::min;\n@@ -106,15 +106,15 @@ impl ColorConfig {\n \n pub struct EmitterWriter {\n     dst: Destination,\n-    cm: Option<Rc<CodeMapper>>,\n+    cm: Option<Lrc<CodeMapper>>,\n     short_message: bool,\n     teach: bool,\n     error_codes: HashSet<String>,\n     ui_testing: bool,\n }\n \n struct FileWithAnnotatedLines {\n-    file: Rc<FileMap>,\n+    file: Lrc<FileMap>,\n     lines: Vec<Line>,\n     multiline_depth: usize,\n }\n@@ -148,7 +148,7 @@ impl Drop for EmitterWriter {\n \n impl EmitterWriter {\n     pub fn stderr(color_config: ColorConfig,\n-                  code_map: Option<Rc<CodeMapper>>,\n+                  code_map: Option<Lrc<CodeMapper>>,\n                   short_message: bool,\n                   teach: bool)\n                   -> EmitterWriter {\n@@ -175,7 +175,7 @@ impl EmitterWriter {\n     }\n \n     pub fn new(dst: Box<Write + Send>,\n-               code_map: Option<Rc<CodeMapper>>,\n+               code_map: Option<Lrc<CodeMapper>>,\n                short_message: bool,\n                teach: bool)\n                -> EmitterWriter {\n@@ -204,7 +204,7 @@ impl EmitterWriter {\n \n     fn preprocess_annotations(&mut self, msp: &MultiSpan) -> Vec<FileWithAnnotatedLines> {\n         fn add_annotation_to_file(file_vec: &mut Vec<FileWithAnnotatedLines>,\n-                                  file: Rc<FileMap>,\n+                                  file: Lrc<FileMap>,\n                                   line_index: usize,\n                                   ann: Annotation) {\n \n@@ -336,7 +336,7 @@ impl EmitterWriter {\n \n     fn render_source_line(&self,\n                           buffer: &mut StyledBuffer,\n-                          file: Rc<FileMap>,\n+                          file: Lrc<FileMap>,\n                           line: &Line,\n                           width_offset: usize,\n                           code_offset: usize) -> Vec<(usize, Style)> {"}, {"sha": "3eea311a5af5e69f34346c79eed4f701ae2b308f", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -35,13 +35,13 @@ use self::Level::*;\n \n use emitter::{Emitter, EmitterWriter};\n \n+use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::stable_hasher::StableHasher;\n \n use std::borrow::Cow;\n use std::cell::{RefCell, Cell};\n use std::mem;\n-use std::rc::Rc;\n use std::{error, fmt};\n use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering::SeqCst;\n@@ -110,7 +110,7 @@ pub trait CodeMapper {\n     fn span_to_filename(&self, sp: Span) -> FileName;\n     fn merge_spans(&self, sp_lhs: Span, sp_rhs: Span) -> Option<Span>;\n     fn call_span_if_macro(&self, sp: Span) -> Span;\n-    fn ensure_filemap_source_present(&self, file_map: Rc<FileMap>) -> bool;\n+    fn ensure_filemap_source_present(&self, file_map: Lrc<FileMap>) -> bool;\n     fn doctest_offset_line(&self, line: usize) -> usize;\n }\n \n@@ -287,7 +287,7 @@ impl Handler {\n     pub fn with_tty_emitter(color_config: ColorConfig,\n                             can_emit_warnings: bool,\n                             treat_err_as_bug: bool,\n-                            cm: Option<Rc<CodeMapper>>)\n+                            cm: Option<Lrc<CodeMapper>>)\n                             -> Handler {\n         Handler::with_tty_emitter_and_flags(\n             color_config,\n@@ -300,7 +300,7 @@ impl Handler {\n     }\n \n     pub fn with_tty_emitter_and_flags(color_config: ColorConfig,\n-                                      cm: Option<Rc<CodeMapper>>,\n+                                      cm: Option<Lrc<CodeMapper>>,\n                                       flags: HandlerFlags)\n                                       -> Handler {\n         let emitter = Box::new(EmitterWriter::stderr(color_config, cm, false, false));"}, {"sha": "876e7e8dc31ae8dfbf7ef37b1c80d70d602c4eb4", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -14,6 +14,7 @@ use cstore::{self, CStore, CrateSource, MetadataBlob};\n use locator::{self, CratePaths};\n use native_libs::relevant_lib;\n use schema::CrateRoot;\n+use rustc_data_structures::sync::Lrc;\n \n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX};\n use rustc::hir::svh::Svh;\n@@ -32,7 +33,6 @@ use rustc::hir::map::Definitions;\n use std::cell::{RefCell, Cell};\n use std::ops::Deref;\n use std::path::PathBuf;\n-use std::rc::Rc;\n use std::{cmp, fs};\n \n use syntax::ast;\n@@ -79,7 +79,7 @@ struct ExtensionCrate {\n }\n \n enum PMDSource {\n-    Registered(Rc<cstore::CrateMetadata>),\n+    Registered(Lrc<cstore::CrateMetadata>),\n     Owned(Library),\n }\n \n@@ -194,7 +194,7 @@ impl<'a> CrateLoader<'a> {\n                       span: Span,\n                       lib: Library,\n                       dep_kind: DepKind)\n-                      -> (CrateNum, Rc<cstore::CrateMetadata>) {\n+                      -> (CrateNum, Lrc<cstore::CrateMetadata>) {\n         info!(\"register crate `extern crate {} as {}`\", name, ident);\n         let crate_root = lib.metadata.get_root();\n         self.verify_no_symbol_conflicts(span, &crate_root);\n@@ -237,7 +237,7 @@ impl<'a> CrateLoader<'a> {\n         let mut cmeta = cstore::CrateMetadata {\n             name,\n             extern_crate: Cell::new(None),\n-            def_path_table: Rc::new(def_path_table),\n+            def_path_table: Lrc::new(def_path_table),\n             exported_symbols,\n             trait_impls,\n             proc_macros: crate_root.macro_derive_registrar.map(|_| {\n@@ -274,7 +274,7 @@ impl<'a> CrateLoader<'a> {\n \n         cmeta.dllimport_foreign_items = dllimports;\n \n-        let cmeta = Rc::new(cmeta);\n+        let cmeta = Lrc::new(cmeta);\n         self.cstore.set_crate_data(cnum, cmeta.clone());\n         (cnum, cmeta)\n     }\n@@ -287,7 +287,7 @@ impl<'a> CrateLoader<'a> {\n                      span: Span,\n                      path_kind: PathKind,\n                      mut dep_kind: DepKind)\n-                     -> (CrateNum, Rc<cstore::CrateMetadata>) {\n+                     -> (CrateNum, Lrc<cstore::CrateMetadata>) {\n         info!(\"resolving crate `extern crate {} as {}`\", name, ident);\n         let result = if let Some(cnum) = self.existing_match(name, hash, path_kind) {\n             LoadResult::Previous(cnum)\n@@ -513,7 +513,7 @@ impl<'a> CrateLoader<'a> {\n     /// custom derive (and other macro-1.1 style features) are implemented via\n     /// executables and custom IPC.\n     fn load_derive_macros(&mut self, root: &CrateRoot, dylib: Option<PathBuf>, span: Span)\n-                          -> Vec<(ast::Name, Rc<SyntaxExtension>)> {\n+                          -> Vec<(ast::Name, Lrc<SyntaxExtension>)> {\n         use std::{env, mem};\n         use proc_macro::TokenStream;\n         use proc_macro::__internal::Registry;\n@@ -541,7 +541,7 @@ impl<'a> CrateLoader<'a> {\n             mem::transmute::<*mut u8, fn(&mut Registry)>(sym)\n         };\n \n-        struct MyRegistrar(Vec<(ast::Name, Rc<SyntaxExtension>)>);\n+        struct MyRegistrar(Vec<(ast::Name, Lrc<SyntaxExtension>)>);\n \n         impl Registry for MyRegistrar {\n             fn register_custom_derive(&mut self,\n@@ -551,7 +551,7 @@ impl<'a> CrateLoader<'a> {\n                 let attrs = attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n                 let derive = ProcMacroDerive::new(expand, attrs.clone());\n                 let derive = SyntaxExtension::ProcMacroDerive(Box::new(derive), attrs);\n-                self.0.push((Symbol::intern(trait_name), Rc::new(derive)));\n+                self.0.push((Symbol::intern(trait_name), Lrc::new(derive)));\n             }\n \n             fn register_attr_proc_macro(&mut self,\n@@ -560,7 +560,7 @@ impl<'a> CrateLoader<'a> {\n                 let expand = SyntaxExtension::AttrProcMacro(\n                     Box::new(AttrProcMacro { inner: expand })\n                 );\n-                self.0.push((Symbol::intern(name), Rc::new(expand)));\n+                self.0.push((Symbol::intern(name), Lrc::new(expand)));\n             }\n \n             fn register_bang_proc_macro(&mut self,\n@@ -569,7 +569,7 @@ impl<'a> CrateLoader<'a> {\n                 let expand = SyntaxExtension::ProcMacro(\n                     Box::new(BangProcMacro { inner: expand })\n                 );\n-                self.0.push((Symbol::intern(name), Rc::new(expand)));\n+                self.0.push((Symbol::intern(name), Lrc::new(expand)));\n             }\n         }\n "}, {"sha": "8b59eec0190508017e99b0b0381b7a7bc19bf79c", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -23,7 +23,7 @@ use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::util::nodemap::{FxHashMap, FxHashSet, NodeMap};\n \n use std::cell::{RefCell, Cell};\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::owning_ref::ErasedBoxRef;\n use syntax::{ast, attr};\n use syntax::ext::base::SyntaxExtension;\n@@ -52,7 +52,7 @@ pub struct ImportedFileMap {\n     /// The end of this FileMap within the codemap of its original crate\n     pub original_end_pos: syntax_pos::BytePos,\n     /// The imported FileMap's representation within the local codemap\n-    pub translated_filemap: Rc<syntax_pos::FileMap>,\n+    pub translated_filemap: Lrc<syntax_pos::FileMap>,\n }\n \n pub struct CrateMetadata {\n@@ -67,7 +67,7 @@ pub struct CrateMetadata {\n     pub cnum_map: RefCell<CrateNumMap>,\n     pub cnum: CrateNum,\n     pub codemap_import_info: RefCell<Vec<ImportedFileMap>>,\n-    pub attribute_cache: RefCell<[Vec<Option<Rc<[ast::Attribute]>>>; 2]>,\n+    pub attribute_cache: RefCell<[Vec<Option<Lrc<[ast::Attribute]>>>; 2]>,\n \n     pub root: schema::CrateRoot,\n \n@@ -76,7 +76,7 @@ pub struct CrateMetadata {\n     /// hashmap, which gives the reverse mapping.  This allows us to\n     /// quickly retrace a `DefPath`, which is needed for incremental\n     /// compilation support.\n-    pub def_path_table: Rc<DefPathTable>,\n+    pub def_path_table: Lrc<DefPathTable>,\n \n     pub exported_symbols: FxHashSet<DefIndex>,\n \n@@ -85,13 +85,13 @@ pub struct CrateMetadata {\n     pub dep_kind: Cell<DepKind>,\n     pub source: CrateSource,\n \n-    pub proc_macros: Option<Vec<(ast::Name, Rc<SyntaxExtension>)>>,\n+    pub proc_macros: Option<Vec<(ast::Name, Lrc<SyntaxExtension>)>>,\n     // Foreign items imported from a dylib (Windows only)\n     pub dllimport_foreign_items: FxHashSet<DefIndex>,\n }\n \n pub struct CStore {\n-    metas: RefCell<IndexVec<CrateNum, Option<Rc<CrateMetadata>>>>,\n+    metas: RefCell<IndexVec<CrateNum, Option<Lrc<CrateMetadata>>>>,\n     /// Map from NodeId's of local extern crate statements to crate numbers\n     extern_mod_crate_map: RefCell<NodeMap<CrateNum>>,\n     pub metadata_loader: Box<MetadataLoader>,\n@@ -110,11 +110,11 @@ impl CStore {\n         CrateNum::new(self.metas.borrow().len() + 1)\n     }\n \n-    pub fn get_crate_data(&self, cnum: CrateNum) -> Rc<CrateMetadata> {\n+    pub fn get_crate_data(&self, cnum: CrateNum) -> Lrc<CrateMetadata> {\n         self.metas.borrow()[cnum].clone().unwrap()\n     }\n \n-    pub fn set_crate_data(&self, cnum: CrateNum, data: Rc<CrateMetadata>) {\n+    pub fn set_crate_data(&self, cnum: CrateNum, data: Lrc<CrateMetadata>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         let mut met = self.metas.borrow_mut();\n         while met.len() <= cnum.index() {\n@@ -124,7 +124,7 @@ impl CStore {\n     }\n \n     pub fn iter_crate_data<I>(&self, mut i: I)\n-        where I: FnMut(CrateNum, &Rc<CrateMetadata>)\n+        where I: FnMut(CrateNum, &Lrc<CrateMetadata>)\n     {\n         for (k, v) in self.metas.borrow().iter_enumerated() {\n             if let &Some(ref v) = v {"}, {"sha": "7b8194d9eab2fb4107415a8a3ef29198056cf2cc", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -30,7 +30,7 @@ use rustc::hir::map::definitions::DefPathTable;\n use rustc::util::nodemap::{NodeSet, DefIdMap};\n \n use std::any::Any;\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n \n use syntax::ast;\n use syntax::attr;\n@@ -112,12 +112,12 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         let _ = cdata;\n         tcx.calculate_dtor(def_id, &mut |_,_| Ok(()))\n     }\n-    variances_of => { Rc::new(cdata.get_item_variances(def_id.index)) }\n+    variances_of => { Lrc::new(cdata.get_item_variances(def_id.index)) }\n     associated_item_def_ids => {\n         let mut result = vec![];\n         cdata.each_child_of_item(def_id.index,\n           |child| result.push(child.def.def_id()), tcx.sess);\n-        Rc::new(result)\n+        Lrc::new(result)\n     }\n     associated_item => { cdata.get_associated_item(def_id.index) }\n     impl_trait_ref => { cdata.get_impl_trait(def_id.index, tcx) }\n@@ -137,11 +137,11 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         mir\n     }\n     mir_const_qualif => {\n-        (cdata.mir_const_qualif(def_id.index), Rc::new(IdxSetBuf::new_empty(0)))\n+        (cdata.mir_const_qualif(def_id.index), Lrc::new(IdxSetBuf::new_empty(0)))\n     }\n     typeck_tables_of => { cdata.item_body_tables(def_id.index, tcx) }\n     fn_sig => { cdata.fn_sig(def_id.index, tcx) }\n-    inherent_impls => { Rc::new(cdata.get_inherent_implementations_for_type(def_id.index)) }\n+    inherent_impls => { Lrc::new(cdata.get_inherent_implementations_for_type(def_id.index)) }\n     is_const_fn => { cdata.is_const_fn(def_id.index) }\n     is_foreign_item => { cdata.is_foreign_item(def_id.index) }\n     describe_def => { cdata.get_def(def_id.index) }\n@@ -169,18 +169,18 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     }\n     is_mir_available => { cdata.is_item_mir_available(def_id.index) }\n \n-    dylib_dependency_formats => { Rc::new(cdata.get_dylib_dependency_formats()) }\n+    dylib_dependency_formats => { Lrc::new(cdata.get_dylib_dependency_formats()) }\n     is_panic_runtime => { cdata.is_panic_runtime(tcx.sess) }\n     is_compiler_builtins => { cdata.is_compiler_builtins(tcx.sess) }\n     has_global_allocator => { cdata.has_global_allocator() }\n     is_sanitizer_runtime => { cdata.is_sanitizer_runtime(tcx.sess) }\n     is_profiler_runtime => { cdata.is_profiler_runtime(tcx.sess) }\n     panic_strategy => { cdata.panic_strategy() }\n-    extern_crate => { Rc::new(cdata.extern_crate.get()) }\n+    extern_crate => { Lrc::new(cdata.extern_crate.get()) }\n     is_no_builtins => { cdata.is_no_builtins(tcx.sess) }\n     impl_defaultness => { cdata.get_impl_defaultness(def_id.index) }\n-    exported_symbol_ids => { Rc::new(cdata.get_exported_symbols()) }\n-    native_libraries => { Rc::new(cdata.get_native_libraries(tcx.sess)) }\n+    exported_symbol_ids => { Lrc::new(cdata.get_exported_symbols()) }\n+    native_libraries => { Lrc::new(cdata.get_native_libraries(tcx.sess)) }\n     plugin_registrar_fn => {\n         cdata.root.plugin_registrar_fn.map(|index| {\n             DefId { krate: def_id.krate, index }\n@@ -199,13 +199,13 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         let mut result = vec![];\n         let filter = Some(other);\n         cdata.get_implementations_for_trait(filter, &mut result);\n-        Rc::new(result)\n+        Lrc::new(result)\n     }\n \n     all_trait_implementations => {\n         let mut result = vec![];\n         cdata.get_implementations_for_trait(None, &mut result);\n-        Rc::new(result)\n+        Lrc::new(result)\n     }\n \n     is_dllimport_foreign_item => {\n@@ -217,10 +217,10 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     item_children => {\n         let mut result = vec![];\n         cdata.each_child_of_item(def_id.index, |child| result.push(child), tcx.sess);\n-        Rc::new(result)\n+        Lrc::new(result)\n     }\n-    defined_lang_items => { Rc::new(cdata.get_lang_items()) }\n-    missing_lang_items => { Rc::new(cdata.get_missing_lang_items()) }\n+    defined_lang_items => { Lrc::new(cdata.get_lang_items()) }\n+    missing_lang_items => { Lrc::new(cdata.get_missing_lang_items()) }\n \n     extern_const_body => {\n         debug!(\"item_body({:?}): inlining item\", def_id);\n@@ -234,7 +234,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         }\n     }\n \n-    used_crate_source => { Rc::new(cdata.source.clone()) }\n+    used_crate_source => { Lrc::new(cdata.source.clone()) }\n \n     has_copy_closures => { cdata.has_copy_closures(tcx.sess) }\n     has_clone_closures => { cdata.has_clone_closures(tcx.sess) }\n@@ -276,11 +276,11 @@ pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n         },\n         native_libraries: |tcx, cnum| {\n             assert_eq!(cnum, LOCAL_CRATE);\n-            Rc::new(native_libs::collect(tcx))\n+            Lrc::new(native_libs::collect(tcx))\n         },\n         link_args: |tcx, cnum| {\n             assert_eq!(cnum, LOCAL_CRATE);\n-            Rc::new(link_args::collect(tcx))\n+            Lrc::new(link_args::collect(tcx))\n         },\n \n         // Returns a map from a sufficiently visible external item (i.e. an\n@@ -362,15 +362,15 @@ pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n                 }\n             }\n \n-            Rc::new(visible_parent_map)\n+            Lrc::new(visible_parent_map)\n         },\n \n         ..*providers\n     };\n }\n \n impl CrateStore for cstore::CStore {\n-    fn crate_data_as_rc_any(&self, krate: CrateNum) -> Rc<Any> {\n+    fn crate_data_as_rc_any(&self, krate: CrateNum) -> Lrc<Any> {\n         self.get_crate_data(krate)\n     }\n \n@@ -443,7 +443,7 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(def.krate).def_path_hash(def.index)\n     }\n \n-    fn def_path_table(&self, cnum: CrateNum) -> Rc<DefPathTable> {\n+    fn def_path_table(&self, cnum: CrateNum) -> Lrc<DefPathTable> {\n         self.get_crate_data(cnum).def_path_table.clone()\n     }\n \n@@ -467,7 +467,7 @@ impl CrateStore for cstore::CStore {\n         } else if data.name == \"proc_macro\" &&\n                   self.get_crate_data(id.krate).item_name(id.index) == \"quote\" {\n             let ext = SyntaxExtension::ProcMacro(Box::new(::proc_macro::__internal::Quoter));\n-            return LoadedMacro::ProcMacro(Rc::new(ext));\n+            return LoadedMacro::ProcMacro(Lrc::new(ext));\n         }\n \n         let (name, def) = data.get_macro(id.index);"}, {"sha": "0c6a286e227612b819a8a465d1f0de2e2030379e", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -13,6 +13,7 @@\n use cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary};\n use schema::*;\n \n+use rustc_data_structures::sync::Lrc;\n use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc::hir;\n use rustc::middle::cstore::{LinkagePreference, ExternConstBody,\n@@ -33,7 +34,6 @@ use std::cell::Ref;\n use std::collections::BTreeMap;\n use std::io;\n use std::mem;\n-use std::rc::Rc;\n use std::u32;\n \n use rustc_serialize::{Decodable, Decoder, SpecializedDecoder, opaque};\n@@ -773,12 +773,12 @@ impl<'a, 'tcx> CrateMetadata {\n                                                    .map(|body| (body.id(), body))\n                                                    .collect();\n             ExternBodyNestedBodies {\n-                nested_bodies: Rc::new(nested_bodies),\n+                nested_bodies: Lrc::new(nested_bodies),\n                 fingerprint: ast.stable_bodies_hash,\n             }\n         } else {\n             ExternBodyNestedBodies {\n-                nested_bodies: Rc::new(BTreeMap::new()),\n+                nested_bodies: Lrc::new(BTreeMap::new()),\n                 fingerprint: Fingerprint::ZERO,\n             }\n         }\n@@ -868,11 +868,11 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_item_attrs(&self, node_id: DefIndex, sess: &Session) -> Rc<[ast::Attribute]> {\n+    pub fn get_item_attrs(&self, node_id: DefIndex, sess: &Session) -> Lrc<[ast::Attribute]> {\n         let (node_as, node_index) =\n             (node_id.address_space().index(), node_id.as_array_index());\n         if self.is_proc_macro(node_id) {\n-            return Rc::new([]);\n+            return Lrc::new([]);\n         }\n \n         if let Some(&Some(ref val)) =\n@@ -888,7 +888,7 @@ impl<'a, 'tcx> CrateMetadata {\n         if def_key.disambiguated_data.data == DefPathData::StructCtor {\n             item = self.entry(def_key.parent.unwrap());\n         }\n-        let result: Rc<[ast::Attribute]> = Rc::from(self.get_attributes(&item, sess));\n+        let result: Lrc<[ast::Attribute]> = Lrc::from(self.get_attributes(&item, sess));\n         let vec_ = &mut self.attribute_cache.borrow_mut()[node_as];\n         if vec_.len() < node_index + 1 {\n             vec_.resize(node_index + 1, None);"}, {"sha": "d3f046c554416e261e5300341aec6bd4527cd6d4", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -36,7 +36,7 @@ use std::hash::Hash;\n use std::io::prelude::*;\n use std::io::Cursor;\n use std::path::Path;\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use std::u32;\n use syntax::ast::{self, CRATE_NODE_ID};\n use syntax::codemap::Spanned;\n@@ -60,7 +60,7 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n \n     // This is used to speed up Span encoding.\n-    filemap_cache: Rc<FileMap>,\n+    filemap_cache: Lrc<FileMap>,\n }\n \n macro_rules! encoder_methods {\n@@ -342,7 +342,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                                 adapted.name.hash(&mut hasher);\n                                 hasher.finish()\n                             };\n-                            Rc::new(adapted)\n+                            Lrc::new(adapted)\n                         }\n                     },\n                     // expanded code, not from a file"}, {"sha": "182c9b751968b18d59e3936eaa65d3d74bdf8ed6", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -14,8 +14,7 @@ use rustc::mir::{BorrowKind, Field, Local, LocalKind, Location, Operand};\n use rustc::mir::{Place, ProjectionElem, Rvalue, Statement, StatementKind};\n use rustc::ty::{self, RegionKind};\n use rustc_data_structures::indexed_vec::Idx;\n-\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n \n use super::{MirBorrowckCtxt, Context};\n use super::{InitializationRequiringAction, PrefixSet};\n@@ -444,7 +443,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         &mut self,\n         context: Context,\n         name: &String,\n-        _scope_tree: &Rc<ScopeTree>,\n+        _scope_tree: &Lrc<ScopeTree>,\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n         borrow_span: Span,\n@@ -466,7 +465,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn report_scoped_temporary_value_does_not_live_long_enough(\n         &mut self,\n         context: Context,\n-        _scope_tree: &Rc<ScopeTree>,\n+        _scope_tree: &Lrc<ScopeTree>,\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n         _borrow_span: Span,\n@@ -490,7 +489,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         &mut self,\n         context: Context,\n         name: &String,\n-        scope_tree: &Rc<ScopeTree>,\n+        scope_tree: &Lrc<ScopeTree>,\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n         borrow_span: Span,\n@@ -512,7 +511,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn report_unscoped_temporary_value_does_not_live_long_enough(\n         &mut self,\n         context: Context,\n-        scope_tree: &Rc<ScopeTree>,\n+        scope_tree: &Lrc<ScopeTree>,\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n         _borrow_span: Span,"}, {"sha": "533bad18c38a82861be17650bda22543fdfc2533", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -22,6 +22,7 @@ use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::bitslice::{BitwiseOperator};\n use rustc_data_structures::indexed_set::{IdxSet};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::sync::Lrc;\n \n use dataflow::{BitDenotation, BlockSets, InitialFlow};\n pub use dataflow::indexes::{BorrowIndex, ReserveOrActivateIndex};\n@@ -44,7 +45,7 @@ use std::rc::Rc;\n pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n-    scope_tree: Rc<region::ScopeTree>,\n+    scope_tree: Lrc<region::ScopeTree>,\n     root_scope: Option<region::Scope>,\n \n     /// The fundamental map relating bitvector indexes to the borrows\n@@ -273,7 +274,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n \n     pub fn borrows(&self) -> &IndexVec<BorrowIndex, BorrowData<'tcx>> { &self.borrows }\n \n-    pub fn scope_tree(&self) -> &Rc<region::ScopeTree> { &self.scope_tree }\n+    pub fn scope_tree(&self) -> &Lrc<region::ScopeTree> { &self.scope_tree }\n \n     pub fn location(&self, idx: BorrowIndex) -> &Location {\n         &self.borrows[idx].location"}, {"sha": "44c413561175e768aff88d45dd257ad34c792ce5", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -31,7 +31,7 @@ use syntax::attr;\n use syntax::symbol::Symbol;\n use rustc::hir;\n use rustc_const_math::{ConstInt, ConstUsize};\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n \n #[derive(Clone)]\n pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n@@ -44,7 +44,7 @@ pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     /// Identity `Substs` for use with const-evaluation.\n     pub identity_substs: &'gcx Substs<'gcx>,\n \n-    pub region_scope_tree: Rc<region::ScopeTree>,\n+    pub region_scope_tree: Lrc<region::ScopeTree>,\n     pub tables: &'a ty::TypeckTables<'gcx>,\n \n     /// This is `Constness::Const` if we are compiling a `static`,"}, {"sha": "0bef9f0602d86c295967549fb2a6933e0e2b4dc6", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -10,6 +10,7 @@\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::sync::Lrc;\n \n use rustc::ty::maps::Providers;\n use rustc::ty::{self, TyCtxt};\n@@ -22,7 +23,6 @@ use rustc::mir::visit::{PlaceContext, Visitor};\n use syntax::ast;\n use syntax::symbol::Symbol;\n \n-use std::rc::Rc;\n use util;\n \n pub struct UnsafetyChecker<'a, 'tcx: 'a> {\n@@ -338,8 +338,8 @@ fn unsafety_check_result<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n         ClearCrossCrate::Clear => {\n             debug!(\"unsafety_violations: {:?} - remote, skipping\", def_id);\n             return UnsafetyCheckResult {\n-                violations: Rc::new([]),\n-                unsafe_blocks: Rc::new([])\n+                violations: Lrc::new([]),\n+                unsafe_blocks: Lrc::new([])\n             }\n         }\n     };"}, {"sha": "e933a6cd700dcb074c80e3e0af563154211751e8", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -18,8 +18,8 @@ use rustc::ty::steal::Steal;\n use rustc::hir;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::util::nodemap::DefIdSet;\n+use rustc_data_structures::sync::Lrc;\n use std::borrow::Cow;\n-use std::rc::Rc;\n use syntax::ast;\n use syntax_pos::Span;\n \n@@ -67,7 +67,7 @@ fn is_mir_available<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> boo\n /// Finds the full set of def-ids within the current crate that have\n /// MIR associated with them.\n fn mir_keys<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, krate: CrateNum)\n-                      -> Rc<DefIdSet> {\n+                      -> Lrc<DefIdSet> {\n     assert_eq!(krate, LOCAL_CRATE);\n \n     let mut set = DefIdSet();\n@@ -102,7 +102,7 @@ fn mir_keys<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, krate: CrateNum)\n         set: &mut set,\n     }.as_deep_visitor());\n \n-    Rc::new(set)\n+    Lrc::new(set)\n }\n \n fn mir_built<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Mir<'tcx>> {"}, {"sha": "0b0ce1fb4d48b593eadf1ce64ab5cfb5bc3cdf8b", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -36,7 +36,7 @@ use syntax::feature_gate::UnstableFeatures;\n use syntax_pos::{Span, DUMMY_SP};\n \n use std::fmt;\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use std::usize;\n \n use transform::{MirPass, MirSource};\n@@ -319,7 +319,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n     }\n \n     /// Qualify a whole const, static initializer or const fn.\n-    fn qualify_const(&mut self) -> (Qualif, Rc<IdxSetBuf<Local>>) {\n+    fn qualify_const(&mut self) -> (Qualif, Lrc<IdxSetBuf<Local>>) {\n         debug!(\"qualifying {} {:?}\", self.mode, self.def_id);\n \n         let mir = self.mir;\n@@ -436,7 +436,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             }\n         }\n \n-        (self.qualif, Rc::new(promoted_temps))\n+        (self.qualif, Lrc::new(promoted_temps))\n     }\n }\n \n@@ -1121,7 +1121,7 @@ pub fn provide(providers: &mut Providers) {\n \n fn mir_const_qualif<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               def_id: DefId)\n-                              -> (u8, Rc<IdxSetBuf<Local>>) {\n+                              -> (u8, Lrc<IdxSetBuf<Local>>) {\n     // NB: This `borrow()` is guaranteed to be valid (i.e., the value\n     // cannot yet be stolen), because `mir_validated()`, which steals\n     // from `mir_const(), forces this query to execute before\n@@ -1130,7 +1130,7 @@ fn mir_const_qualif<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     if mir.return_ty().references_error() {\n         tcx.sess.delay_span_bug(mir.span, \"mir_const_qualif: Mir had errors\");\n-        return (Qualif::NOT_CONST.bits(), Rc::new(IdxSetBuf::new_empty(0)));\n+        return (Qualif::NOT_CONST.bits(), Lrc::new(IdxSetBuf::new_empty(0)));\n     }\n \n     let mut qualifier = Qualifier::new(tcx, def_id, mir, Mode::Const);"}, {"sha": "e87e976eac3eb18b5ccd0652c736f97750f3aa8d", "filename": "src/librustc_passes/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2FCargo.toml?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -13,6 +13,7 @@ log = \"0.4\"\n rustc = { path = \"../librustc\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "b93b759fdf869ecc4dd6159265f2c72f17b237ad", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -45,7 +45,7 @@ use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::{ItemLocalSet, NodeSet};\n use rustc::lint::builtin::CONST_ERR;\n use rustc::hir::{self, PatKind, RangeEnd};\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n@@ -83,7 +83,7 @@ fn const_is_rvalue_promotable_to_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n fn rvalue_promotable_map<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    def_id: DefId)\n-                                   -> Rc<ItemLocalSet>\n+                                   -> Lrc<ItemLocalSet>\n {\n     let outer_def_id = tcx.closure_base_def_id(def_id);\n     if outer_def_id != def_id {\n@@ -108,7 +108,7 @@ fn rvalue_promotable_map<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let body_id = tcx.hir.body_owned_by(node_id);\n     visitor.visit_nested_body(body_id);\n \n-    Rc::new(visitor.result)\n+    Lrc::new(visitor.result)\n }\n \n struct CheckCrateVisitor<'a, 'tcx: 'a> {"}, {"sha": "8bd9598288770b60565ea1c789342a769802baba", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -25,6 +25,7 @@\n extern crate rustc;\n extern crate rustc_const_eval;\n extern crate rustc_const_math;\n+extern crate rustc_data_structures;\n \n #[macro_use]\n extern crate log;"}, {"sha": "62eab40f3ec9a0aa2a459382b5f6238a71408243", "filename": "src/librustc_privacy/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_privacy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_privacy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2FCargo.toml?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -13,3 +13,4 @@ rustc = { path = \"../librustc\" }\n rustc_typeck = { path = \"../librustc_typeck\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n\\ No newline at end of file"}, {"sha": "95be691b30c791f640b8dc12b926122a8b600388", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -19,6 +19,7 @@\n #[macro_use] extern crate syntax;\n extern crate rustc_typeck;\n extern crate syntax_pos;\n+extern crate rustc_data_structures;\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::def::Def;\n@@ -38,7 +39,7 @@ use syntax_pos::hygiene::SyntaxContext;\n \n use std::cmp;\n use std::mem::replace;\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n \n mod diagnostics;\n \n@@ -1646,13 +1647,13 @@ pub fn provide(providers: &mut Providers) {\n     };\n }\n \n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Rc<AccessLevels> {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Lrc<AccessLevels> {\n     tcx.privacy_access_levels(LOCAL_CRATE)\n }\n \n fn privacy_access_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    krate: CrateNum)\n-                                   -> Rc<AccessLevels> {\n+                                   -> Lrc<AccessLevels> {\n     assert_eq!(krate, LOCAL_CRATE);\n \n     let krate = tcx.hir.krate();\n@@ -1726,7 +1727,7 @@ fn privacy_access_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         krate.visit_all_item_likes(&mut DeepVisitor::new(&mut visitor));\n     }\n \n-    Rc::new(visitor.access_levels)\n+    Lrc::new(visitor.access_levels)\n }\n \n __build_diagnostic_array! { librustc_privacy, DIAGNOSTICS }"}, {"sha": "b9899f499148dbd39602fb5804af7077bb4c4df2", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -27,7 +27,7 @@ use rustc::hir::def_id::{BUILTIN_MACROS_CRATE, CRATE_DEF_INDEX, LOCAL_CRATE, Def\n use rustc::ty;\n \n use std::cell::Cell;\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n \n use syntax::ast::{Name, Ident};\n use syntax::attr;\n@@ -575,7 +575,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    pub fn get_macro(&mut self, def: Def) -> Rc<SyntaxExtension> {\n+    pub fn get_macro(&mut self, def: Def) -> Lrc<SyntaxExtension> {\n         let def_id = match def {\n             Def::Macro(def_id, ..) => def_id,\n             _ => panic!(\"Expected Def::Macro(..)\"),\n@@ -589,7 +589,7 @@ impl<'a> Resolver<'a> {\n             LoadedMacro::ProcMacro(ext) => return ext,\n         };\n \n-        let ext = Rc::new(macro_rules::compile(&self.session.parse_sess,\n+        let ext = Lrc::new(macro_rules::compile(&self.session.parse_sess,\n                                                &self.session.features,\n                                                &macro_def));\n         self.macro_map.insert(def_id, ext.clone());"}, {"sha": "317bd9217b59167500f517121cb460dc6d1b9948", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -70,7 +70,7 @@ use std::collections::BTreeSet;\n use std::fmt;\n use std::iter;\n use std::mem::replace;\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n \n use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution, ImportResolver};\n use macros::{InvocationData, LegacyBinding, LegacyScope, MacroBinding};\n@@ -1118,7 +1118,7 @@ impl<'a> NameBinding<'a> {\n         }\n     }\n \n-    fn get_macro(&self, resolver: &mut Resolver<'a>) -> Rc<SyntaxExtension> {\n+    fn get_macro(&self, resolver: &mut Resolver<'a>) -> Lrc<SyntaxExtension> {\n         resolver.get_macro(self.def_ignoring_ambiguity())\n     }\n \n@@ -1324,7 +1324,7 @@ pub struct Resolver<'a> {\n     global_macros: FxHashMap<Name, &'a NameBinding<'a>>,\n     pub all_macros: FxHashMap<Name, Def>,\n     lexical_macro_resolutions: Vec<(Ident, &'a Cell<LegacyScope<'a>>)>,\n-    macro_map: FxHashMap<DefId, Rc<SyntaxExtension>>,\n+    macro_map: FxHashMap<DefId, Lrc<SyntaxExtension>>,\n     macro_defs: FxHashMap<Mark, DefId>,\n     local_macro_def_scopes: FxHashMap<NodeId, Module<'a>>,\n     macro_exports: Vec<Export>,"}, {"sha": "81cc5e59bbbf7d319d4855c9fd9015543f7ebe89", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -40,7 +40,7 @@ use syntax_pos::{Span, DUMMY_SP};\n \n use std::cell::Cell;\n use std::mem;\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n \n #[derive(Clone)]\n pub struct InvocationData<'a> {\n@@ -185,7 +185,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         invocation.expansion.set(visitor.legacy_scope);\n     }\n \n-    fn add_builtin(&mut self, ident: ast::Ident, ext: Rc<SyntaxExtension>) {\n+    fn add_builtin(&mut self, ident: ast::Ident, ext: Lrc<SyntaxExtension>) {\n         let def_id = DefId {\n             krate: BUILTIN_MACROS_CRATE,\n             index: DefIndex::from_array_index(self.macro_map.len(),\n@@ -293,7 +293,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     fn resolve_invoc(&mut self, invoc: &mut Invocation, scope: Mark, force: bool)\n-                     -> Result<Option<Rc<SyntaxExtension>>, Determinacy> {\n+                     -> Result<Option<Lrc<SyntaxExtension>>, Determinacy> {\n         let def = match invoc.kind {\n             InvocationKind::Attr { attr: None, .. } => return Ok(None),\n             _ => self.resolve_invoc_to_def(invoc, scope, force)?,\n@@ -316,7 +316,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)\n-                     -> Result<Rc<SyntaxExtension>, Determinacy> {\n+                     -> Result<Lrc<SyntaxExtension>, Determinacy> {\n         self.resolve_macro_to_def(scope, path, kind, force).map(|def| {\n             self.unused_macros.remove(&def.def_id());\n             self.get_macro(def)\n@@ -743,7 +743,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         let def_id = self.definitions.local_def_id(item.id);\n-        let ext = Rc::new(macro_rules::compile(&self.session.parse_sess,\n+        let ext = Lrc::new(macro_rules::compile(&self.session.parse_sess,\n                                                &self.session.features,\n                                                item));\n         self.macro_map.insert(def_id, ext);"}, {"sha": "ffa3f7f401164d2664a86a349148a6fc7909f165", "filename": "src/librustc_trans/attributes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_trans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_trans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fattributes.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -10,14 +10,14 @@\n //! Set and unset common attributes on LLVM values.\n \n use std::ffi::{CStr, CString};\n-use std::rc::Rc;\n \n use rustc::hir::Unsafety;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::session::config::Sanitizer;\n use rustc::ty::TyCtxt;\n use rustc::ty::maps::Providers;\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::sync::Lrc;\n \n use llvm::{self, Attribute, ValueRef};\n use llvm::AttributePlace::Function;\n@@ -140,7 +140,7 @@ fn cstr(s: &'static str) -> &CStr {\n pub fn provide(providers: &mut Providers) {\n     providers.target_features_whitelist = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        Rc::new(llvm_util::target_feature_whitelist(tcx.sess)\n+        Lrc::new(llvm_util::target_feature_whitelist(tcx.sess)\n             .iter()\n             .map(|c| c.to_string())\n             .collect())\n@@ -173,7 +173,7 @@ pub fn provide(providers: &mut Providers) {\n             }\n             from_target_feature(tcx, attr, &whitelist, &mut target_features);\n         }\n-        Rc::new(target_features)\n+        Lrc::new(target_features)\n     };\n }\n "}, {"sha": "68c0ba02650024291a9f903b84da097b10ba3162", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use std::sync::Arc;\n \n use base;\n@@ -64,7 +64,7 @@ pub fn crates_export_threshold(crate_types: &[config::CrateType])\n pub fn provide(providers: &mut Providers) {\n     providers.exported_symbol_ids = |tcx, cnum| {\n         let export_threshold = threshold(tcx);\n-        Rc::new(tcx.exported_symbols(cnum)\n+        Lrc::new(tcx.exported_symbols(cnum)\n             .iter()\n             .filter_map(|&(_, id, level)| {\n                 id.and_then(|id| {"}, {"sha": "6cb9d2027c74796f08d13d01cee24f4e39bd4096", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -73,8 +73,8 @@ pub use llvm_util::target_features;\n \n use std::any::Any;\n use std::path::PathBuf;\n-use std::rc::Rc;\n use std::sync::mpsc;\n+use rustc_data_structures::sync::Lrc;\n \n use rustc::dep_graph::DepGraph;\n use rustc::hir::def_id::CrateNum;\n@@ -394,11 +394,11 @@ struct CrateInfo {\n     profiler_runtime: Option<CrateNum>,\n     sanitizer_runtime: Option<CrateNum>,\n     is_no_builtins: FxHashSet<CrateNum>,\n-    native_libraries: FxHashMap<CrateNum, Rc<Vec<NativeLibrary>>>,\n+    native_libraries: FxHashMap<CrateNum, Lrc<Vec<NativeLibrary>>>,\n     crate_name: FxHashMap<CrateNum, String>,\n-    used_libraries: Rc<Vec<NativeLibrary>>,\n-    link_args: Rc<Vec<String>>,\n-    used_crate_source: FxHashMap<CrateNum, Rc<CrateSource>>,\n+    used_libraries: Lrc<Vec<NativeLibrary>>,\n+    link_args: Lrc<Vec<String>>,\n+    used_crate_source: FxHashMap<CrateNum, Lrc<CrateSource>>,\n     used_crates_static: Vec<(CrateNum, LibSource)>,\n     used_crates_dynamic: Vec<(CrateNum, LibSource)>,\n }"}, {"sha": "419371ba3e339b8f148ed3f8d638f79dc255e15b", "filename": "src/librustc_trans_utils/trans_crate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Ftrans_crate.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -26,10 +26,10 @@ use std::io::prelude::*;\n use std::io::{self, Cursor};\n use std::fs::File;\n use std::path::Path;\n-use std::rc::Rc;\n use std::sync::mpsc;\n \n use rustc_data_structures::owning_ref::{ErasedBoxRef, OwningRef};\n+use rustc_data_structures::sync::Lrc;\n use ar::{Archive, Builder, Header};\n use flate2::Compression;\n use flate2::write::DeflateEncoder;\n@@ -199,7 +199,7 @@ impl TransCrate for MetadataOnlyTransCrate {\n     fn provide(&self, providers: &mut Providers) {\n         ::symbol_names::provide(providers);\n         providers.target_features_enabled = |_tcx, _id| {\n-            Rc::new(Vec::new()) // Just a dummy\n+            Lrc::new(Vec::new()) // Just a dummy\n         };\n     }\n     fn provide_extern(&self, _providers: &mut Providers) {}"}, {"sha": "c50ee13723f8fb52ddac85bf897c327c2b8f2358", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -18,15 +18,15 @@ use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::{self, Pat, PatKind, Expr};\n use rustc::middle::region;\n use rustc::ty::{self, Ty, GeneratorInterior};\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use syntax_pos::Span;\n use super::FnCtxt;\n use util::nodemap::FxHashMap;\n \n struct InteriorVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     types: FxHashMap<Ty<'tcx>, usize>,\n-    region_scope_tree: Rc<region::ScopeTree>,\n+    region_scope_tree: Lrc<region::ScopeTree>,\n     expr_count: usize,\n }\n "}, {"sha": "f7bb1a6a232399c965f59bd76d61ff454fa7007f", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -25,7 +25,7 @@ use syntax_pos::Span;\n \n use rustc::hir;\n \n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n \n pub use self::MethodError::*;\n pub use self::CandidateSource::*;\n@@ -165,7 +165,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let Some(import_id) = pick.import_id {\n             let import_def_id = self.tcx.hir.local_def_id(import_id);\n             debug!(\"used_trait_import: {:?}\", import_def_id);\n-            Rc::get_mut(&mut self.tables.borrow_mut().used_trait_imports)\n+            Lrc::get_mut(&mut self.tables.borrow_mut().used_trait_imports)\n                                         .unwrap().insert(import_def_id);\n         }\n \n@@ -364,7 +364,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let Some(import_id) = pick.import_id {\n             let import_def_id = self.tcx.hir.local_def_id(import_id);\n             debug!(\"used_trait_import: {:?}\", import_def_id);\n-            Rc::get_mut(&mut self.tables.borrow_mut().used_trait_imports)\n+            Lrc::get_mut(&mut self.tables.borrow_mut().used_trait_imports)\n                                         .unwrap().insert(import_def_id);\n         }\n "}, {"sha": "db5a458bb8ce49c42882c53526bfc25f67849acb", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -110,7 +110,7 @@ use util::common::{ErrorReported, indenter};\n use util::nodemap::{DefIdMap, DefIdSet, FxHashMap, NodeMap};\n \n use std::cell::{Cell, RefCell, Ref, RefMut};\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use std::collections::hash_map::Entry;\n use std::cmp;\n use std::fmt::Display;\n@@ -814,7 +814,7 @@ fn has_typeck_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n fn used_trait_imports<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               def_id: DefId)\n-                              -> Rc<DefIdSet> {\n+                              -> Lrc<DefIdSet> {\n     tcx.typeck_tables_of(def_id).used_trait_imports.clone()\n }\n "}, {"sha": "cfe8aa99bfa08285c6456f4331f893110e4b8d64", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -96,7 +96,7 @@ use rustc::ty::adjustment;\n \n use std::mem;\n use std::ops::Deref;\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n@@ -189,7 +189,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n pub struct RegionCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     pub fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n \n-    pub region_scope_tree: Rc<region::ScopeTree>,\n+    pub region_scope_tree: Lrc<region::ScopeTree>,\n \n     outlives_environment: OutlivesEnvironment<'tcx>,\n "}, {"sha": "862b15743c701d60aa769128bb96a57563fbc221", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -24,7 +24,7 @@ use rustc::util::nodemap::DefIdSet;\n use syntax::ast;\n use syntax_pos::Span;\n use std::mem;\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n \n ///////////////////////////////////////////////////////////////////////////\n // Entry point\n@@ -49,7 +49,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let used_trait_imports = mem::replace(\n             &mut self.tables.borrow_mut().used_trait_imports,\n-            Rc::new(DefIdSet()),\n+            Lrc::new(DefIdSet()),\n         );\n         debug!(\n             \"used_trait_imports({:?}) = {:?}\","}, {"sha": "d43ab0d3713cb93c9dc11b155818ae290cd7402e", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -24,7 +24,7 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::{self, CrateInherentImpls, TyCtxt};\n use rustc::util::nodemap::DefIdMap;\n \n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n use syntax_pos::Span;\n \n@@ -48,7 +48,7 @@ pub fn crate_inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// On-demand query: yields a vector of the inherent impls for a specific type.\n pub fn inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 ty_def_id: DefId)\n-                                -> Rc<Vec<DefId>> {\n+                                -> Lrc<Vec<DefId>> {\n     assert!(ty_def_id.is_local());\n \n     // NB. Until we adopt the red-green dep-tracking algorithm (see\n@@ -67,7 +67,7 @@ pub fn inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // [the plan]: https://github.com/rust-lang/rust-roadmap/issues/4\n \n     thread_local! {\n-        static EMPTY_DEF_ID_VEC: Rc<Vec<DefId>> = Rc::new(vec![])\n+        static EMPTY_DEF_ID_VEC: Lrc<Vec<DefId>> = Lrc::new(vec![])\n     }\n \n     let result = tcx.dep_graph.with_ignore(|| {\n@@ -284,11 +284,11 @@ impl<'a, 'tcx> InherentCollect<'a, 'tcx> {\n             let impl_def_id = self.tcx.hir.local_def_id(item.id);\n             let mut rc_vec = self.impls_map.inherent_impls\n                                            .entry(def_id)\n-                                           .or_insert_with(|| Rc::new(vec![]));\n+                                           .or_insert_with(|| Lrc::new(vec![]));\n \n             // At this point, there should not be any clones of the\n-            // `Rc`, so we can still safely push into it in place:\n-            Rc::get_mut(&mut rc_vec).unwrap().push(impl_def_id);\n+            // `Lrc`, so we can still safely push into it in place:\n+            Lrc::get_mut(&mut rc_vec).unwrap().push(impl_def_id);\n         } else {\n             struct_span_err!(self.tcx.sess,\n                              item.span,"}, {"sha": "da243650c839a5040ad60508887d5bb7e0a915af", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -16,7 +16,7 @@ use rustc::hir;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::ty::{self, CrateVariancesMap, TyCtxt};\n use rustc::ty::maps::Providers;\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n \n /// Defines the `TermsContext` basically houses an arena where we can\n /// allocate terms.\n@@ -43,16 +43,16 @@ pub fn provide(providers: &mut Providers) {\n }\n \n fn crate_variances<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum)\n-                             -> Rc<CrateVariancesMap> {\n+                             -> Lrc<CrateVariancesMap> {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     let mut arena = arena::TypedArena::new();\n     let terms_cx = terms::determine_parameters_to_be_inferred(tcx, &mut arena);\n     let constraints_cx = constraints::add_constraints_from_crate(terms_cx);\n-    Rc::new(solve::solve_constraints(constraints_cx))\n+    Lrc::new(solve::solve_constraints(constraints_cx))\n }\n \n fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n-                            -> Rc<Vec<ty::Variance>> {\n+                            -> Lrc<Vec<ty::Variance>> {\n     let id = tcx.hir.as_local_node_id(item_def_id).expect(\"expected local def-id\");\n     let unsupported = || {\n         // Variance not relevant."}, {"sha": "340a7b1d08ede4989026f51b505ab8e70b090401", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -18,7 +18,7 @@\n use rustc::hir::def_id::DefId;\n use rustc::ty;\n use rustc_data_structures::fx::FxHashMap;\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n \n use super::constraints::*;\n use super::terms::*;\n@@ -51,7 +51,7 @@ pub fn solve_constraints(constraints_cx: ConstraintContext) -> ty::CrateVariance\n     };\n     solutions_cx.solve();\n     let variances = solutions_cx.create_map();\n-    let empty_variance = Rc::new(Vec::new());\n+    let empty_variance = Lrc::new(Vec::new());\n \n     ty::CrateVariancesMap { variances, empty_variance }\n }\n@@ -88,7 +88,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n         }\n     }\n \n-    fn create_map(&self) -> FxHashMap<DefId, Rc<Vec<ty::Variance>>> {\n+    fn create_map(&self) -> FxHashMap<DefId, Lrc<Vec<ty::Variance>>> {\n         let tcx = self.terms_cx.tcx;\n \n         let solutions = &self.solutions;\n@@ -109,7 +109,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                 }\n             }\n \n-            (def_id, Rc::new(variances))\n+            (def_id, Lrc::new(variances))\n         }).collect()\n     }\n "}, {"sha": "090adc27ef01083d609abe5cd99954b7ea573c53", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -12,8 +12,8 @@\n \n use std::collections::BTreeMap;\n use std::io;\n-use std::rc::Rc;\n use std::iter::once;\n+use rustc_data_structures::sync::Lrc;\n \n use syntax::ast;\n use rustc::hir;\n@@ -409,7 +409,7 @@ fn build_module(cx: &DocContext, did: DefId) -> clean::Module {\n }\n \n struct InlinedConst {\n-    nested_bodies: Rc<BTreeMap<hir::BodyId, hir::Body>>\n+    nested_bodies: Lrc<BTreeMap<hir::BodyId, hir::Body>>\n }\n \n impl hir::print::PpAnn for InlinedConst {"}, {"sha": "f9f1c3304949d08f6cc8cd4c18d4b7f4ce59bb87", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -55,6 +55,7 @@ use rustc_const_math::ConstInt;\n use std::default::Default;\n use std::{mem, slice, vec};\n use std::iter::{FromIterator, once};\n+use rustc_data_structures::sync::Lrc;\n use std::rc::Rc;\n use std::cell::RefCell;\n use std::sync::Arc;\n@@ -3899,7 +3900,7 @@ pub fn path_to_def(tcx: &TyCtxt, path: &[&str]) -> Option<DefId> {\n                 None => return None,\n             };\n \n-            for item in mem::replace(&mut items, Rc::new(vec![])).iter() {\n+            for item in mem::replace(&mut items, Lrc::new(vec![])).iter() {\n                 if item.ident.name == *segment {\n                     if path_it.peek().is_none() {\n                         return match item.def {"}, {"sha": "1e0fafc8d9dfd98cf6fe199b6ee2a0e4281b3ca6", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -31,6 +31,7 @@ use errors::emitter::ColorConfig;\n \n use std::cell::{RefCell, Cell};\n use std::mem;\n+use rustc_data_structures::sync::Lrc;\n use std::rc::Rc;\n use std::path::PathBuf;\n \n@@ -148,7 +149,7 @@ pub fn run_core(search_paths: SearchPaths,\n         ..config::basic_options().clone()\n     };\n \n-    let codemap = Rc::new(codemap::CodeMap::new(sessopts.file_path_mapping()));\n+    let codemap = Lrc::new(codemap::CodeMap::new(sessopts.file_path_mapping()));\n     let diagnostic_handler = errors::Handler::with_tty_emitter(ColorConfig::Auto,\n                                                                true,\n                                                                false,\n@@ -202,7 +203,7 @@ pub fn run_core(search_paths: SearchPaths,\n         maybe_unused_extern_crates: resolver.maybe_unused_extern_crates.clone(),\n     };\n     let analysis = ty::CrateAnalysis {\n-        access_levels: Rc::new(AccessLevels::default()),\n+        access_levels: Lrc::new(AccessLevels::default()),\n         name: name.to_string(),\n         glob_map: if resolver.make_glob_map { Some(resolver.glob_map.clone()) } else { None },\n     };"}, {"sha": "f4c9d556c8abf3ea9830d97c9915d8fc0dd2cbfe", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -15,8 +15,8 @@ use std::io;\n use std::path::{Path, PathBuf};\n use std::panic::{self, AssertUnwindSafe};\n use std::process::Command;\n-use std::rc::Rc;\n use std::str;\n+use rustc_data_structures::sync::Lrc;\n use std::sync::{Arc, Mutex};\n \n use testing;\n@@ -72,7 +72,7 @@ pub fn run(input_path: &Path,\n         ..config::basic_options().clone()\n     };\n \n-    let codemap = Rc::new(CodeMap::new(sessopts.file_path_mapping()));\n+    let codemap = Lrc::new(CodeMap::new(sessopts.file_path_mapping()));\n     let handler =\n         errors::Handler::with_tty_emitter(ColorConfig::Auto,\n                                           true, false,\n@@ -82,7 +82,7 @@ pub fn run(input_path: &Path,\n         sessopts, Some(input_path.to_owned()), handler, codemap.clone(),\n     );\n     let trans = rustc_driver::get_trans(&sess);\n-    let cstore = Rc::new(CStore::new(trans.metadata_loader()));\n+    let cstore = CStore::new(trans.metadata_loader());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     sess.parse_sess.config =\n         config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n@@ -119,7 +119,7 @@ pub fn run(input_path: &Path,\n                                        linker);\n \n     {\n-        let map = hir::map::map_crate(&sess, &*cstore, &mut hir_forest, &defs);\n+        let map = hir::map::map_crate(&sess, &cstore, &mut hir_forest, &defs);\n         let krate = map.krate();\n         let mut hir_collector = HirCollector {\n             sess: &sess,\n@@ -230,7 +230,7 @@ fn run_test(test: &str, cratename: &str, filename: &FileName, line: usize,\n         }\n     }\n     let data = Arc::new(Mutex::new(Vec::new()));\n-    let codemap = Rc::new(CodeMap::new_doctest(\n+    let codemap = Lrc::new(CodeMap::new_doctest(\n         sessopts.file_path_mapping(), filename.clone(), line as isize - line_offset as isize\n     ));\n     let emitter = errors::emitter::EmitterWriter::new(box Sink(data.clone()),\n@@ -247,7 +247,7 @@ fn run_test(test: &str, cratename: &str, filename: &FileName, line: usize,\n         sessopts, None, diagnostic_handler, codemap,\n     );\n     let trans = rustc_driver::get_trans(&sess);\n-    let cstore = Rc::new(CStore::new(trans.metadata_loader()));\n+    let cstore = CStore::new(trans.metadata_loader());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let outdir = Mutex::new(TempDir::new(\"rustdoctest\").ok().expect(\"rustdoc needs a tempdir\"));\n@@ -462,15 +462,15 @@ pub struct Collector {\n     opts: TestOptions,\n     maybe_sysroot: Option<PathBuf>,\n     position: Span,\n-    codemap: Option<Rc<CodeMap>>,\n+    codemap: Option<Lrc<CodeMap>>,\n     filename: Option<PathBuf>,\n     linker: Option<PathBuf>,\n }\n \n impl Collector {\n     pub fn new(cratename: String, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n                use_headers: bool, opts: TestOptions, maybe_sysroot: Option<PathBuf>,\n-               codemap: Option<Rc<CodeMap>>, filename: Option<PathBuf>,\n+               codemap: Option<Lrc<CodeMap>>, filename: Option<PathBuf>,\n                linker: Option<PathBuf>) -> Collector {\n         Collector {\n             tests: Vec::new(),"}, {"sha": "10b8e121f831292b77c456d27e81cfecd5f0885b", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -30,7 +30,7 @@ use tokenstream::{ThinTokenStream, TokenStream};\n use serialize::{self, Encoder, Decoder};\n use std::collections::HashSet;\n use std::fmt;\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use std::u32;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n@@ -1274,7 +1274,7 @@ pub enum LitKind {\n     /// A string literal (`\"foo\"`)\n     Str(Symbol, StrStyle),\n     /// A byte string (`b\"foo\"`)\n-    ByteStr(Rc<Vec<u8>>),\n+    ByteStr(Lrc<Vec<u8>>),\n     /// A byte char (`b'f'`)\n     Byte(u8),\n     /// A character literal (`'a'`)"}, {"sha": "53ddbfbfd4a2cc0dd0dc99626ddc2baa7ef67b0a", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -24,11 +24,11 @@ pub use self::ExpnFormat::*;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::StableHasher;\n+use rustc_data_structures::sync::Lrc;\n use std::cell::{RefCell, Ref};\n use std::cmp;\n use std::hash::Hash;\n use std::path::{Path, PathBuf};\n-use std::rc::Rc;\n \n use std::env;\n use std::fs;\n@@ -126,12 +126,12 @@ impl StableFilemapId {\n //\n \n pub struct CodeMap {\n-    pub(super) files: RefCell<Vec<Rc<FileMap>>>,\n+    pub(super) files: RefCell<Vec<Lrc<FileMap>>>,\n     file_loader: Box<FileLoader>,\n     // This is used to apply the file path remapping as specified via\n     // --remap-path-prefix to all FileMaps allocated within this CodeMap.\n     path_mapping: FilePathMapping,\n-    stable_id_to_filemap: RefCell<FxHashMap<StableFilemapId, Rc<FileMap>>>,\n+    stable_id_to_filemap: RefCell<FxHashMap<StableFilemapId, Lrc<FileMap>>>,\n     /// In case we are in a doctest, replace all file names with the PathBuf,\n     /// and add the given offsets to the line info\n     doctest_offset: Option<(FileName, isize)>,\n@@ -177,7 +177,7 @@ impl CodeMap {\n         self.file_loader.file_exists(path)\n     }\n \n-    pub fn load_file(&self, path: &Path) -> io::Result<Rc<FileMap>> {\n+    pub fn load_file(&self, path: &Path) -> io::Result<Lrc<FileMap>> {\n         let src = self.file_loader.read_file(path)?;\n         let filename = if let Some((ref name, _)) = self.doctest_offset {\n             name.clone()\n@@ -187,11 +187,11 @@ impl CodeMap {\n         Ok(self.new_filemap(filename, src))\n     }\n \n-    pub fn files(&self) -> Ref<Vec<Rc<FileMap>>> {\n+    pub fn files(&self) -> Ref<Vec<Lrc<FileMap>>> {\n         self.files.borrow()\n     }\n \n-    pub fn filemap_by_stable_id(&self, stable_id: StableFilemapId) -> Option<Rc<FileMap>> {\n+    pub fn filemap_by_stable_id(&self, stable_id: StableFilemapId) -> Option<Lrc<FileMap>> {\n         self.stable_id_to_filemap.borrow().get(&stable_id).map(|fm| fm.clone())\n     }\n \n@@ -207,7 +207,7 @@ impl CodeMap {\n \n     /// Creates a new filemap without setting its line information. If you don't\n     /// intend to set the line information yourself, you should use new_filemap_and_lines.\n-    pub fn new_filemap(&self, filename: FileName, src: String) -> Rc<FileMap> {\n+    pub fn new_filemap(&self, filename: FileName, src: String) -> Lrc<FileMap> {\n         let start_pos = self.next_start_pos();\n         let mut files = self.files.borrow_mut();\n \n@@ -225,7 +225,7 @@ impl CodeMap {\n             },\n             other => (other, false),\n         };\n-        let filemap = Rc::new(FileMap::new(\n+        let filemap = Lrc::new(FileMap::new(\n             filename,\n             was_remapped,\n             unmapped_path,\n@@ -243,7 +243,7 @@ impl CodeMap {\n     }\n \n     /// Creates a new filemap and sets its line information.\n-    pub fn new_filemap_and_lines(&self, filename: &Path, src: &str) -> Rc<FileMap> {\n+    pub fn new_filemap_and_lines(&self, filename: &Path, src: &str) -> Lrc<FileMap> {\n         let fm = self.new_filemap(filename.to_owned().into(), src.to_owned());\n         let mut byte_pos: u32 = fm.start_pos.0;\n         for line in src.lines() {\n@@ -271,7 +271,7 @@ impl CodeMap {\n                                 mut file_local_lines: Vec<BytePos>,\n                                 mut file_local_multibyte_chars: Vec<MultiByteChar>,\n                                 mut file_local_non_narrow_chars: Vec<NonNarrowChar>)\n-                                -> Rc<FileMap> {\n+                                -> Lrc<FileMap> {\n         let start_pos = self.next_start_pos();\n         let mut files = self.files.borrow_mut();\n \n@@ -290,7 +290,7 @@ impl CodeMap {\n             *swc = *swc + start_pos;\n         }\n \n-        let filemap = Rc::new(FileMap {\n+        let filemap = Lrc::new(FileMap {\n             name: filename,\n             name_was_remapped,\n             unmapped_path: None,\n@@ -398,7 +398,7 @@ impl CodeMap {\n     }\n \n     // If the relevant filemap is empty, we don't return a line number.\n-    pub fn lookup_line(&self, pos: BytePos) -> Result<FileMapAndLine, Rc<FileMap>> {\n+    pub fn lookup_line(&self, pos: BytePos) -> Result<FileMapAndLine, Lrc<FileMap>> {\n         let idx = self.lookup_filemap_idx(pos);\n \n         let files = self.files.borrow();\n@@ -730,7 +730,7 @@ impl CodeMap {\n         }\n     }\n \n-    pub fn get_filemap(&self, filename: &FileName) -> Option<Rc<FileMap>> {\n+    pub fn get_filemap(&self, filename: &FileName) -> Option<Lrc<FileMap>> {\n         for fm in self.files.borrow().iter() {\n             if *filename == fm.name {\n                 return Some(fm.clone());\n@@ -827,7 +827,7 @@ impl CodeMapper for CodeMap {\n         }\n         sp\n     }\n-    fn ensure_filemap_source_present(&self, file_map: Rc<FileMap>) -> bool {\n+    fn ensure_filemap_source_present(&self, file_map: Lrc<FileMap>) -> bool {\n         file_map.add_external_src(\n             || match file_map.name {\n                 FileName::Real(ref name) => self.file_loader.read_file(name).ok(),\n@@ -883,7 +883,7 @@ impl FilePathMapping {\n mod tests {\n     use super::*;\n     use std::borrow::Cow;\n-    use std::rc::Rc;\n+    use rustc_data_structures::sync::Lrc;\n \n     #[test]\n     fn t1 () {\n@@ -1104,7 +1104,7 @@ mod tests {\n     /// `substring` in `source_text`.\n     trait CodeMapExtension {\n         fn span_substr(&self,\n-                    file: &Rc<FileMap>,\n+                    file: &Lrc<FileMap>,\n                     source_text: &str,\n                     substring: &str,\n                     n: usize)\n@@ -1113,7 +1113,7 @@ mod tests {\n \n     impl CodeMapExtension for CodeMap {\n         fn span_substr(&self,\n-                    file: &Rc<FileMap>,\n+                    file: &Lrc<FileMap>,\n                     source_text: &str,\n                     substring: &str,\n                     n: usize)"}, {"sha": "7b333270d041c202a584f1ad11fc113cd2c4bd7b", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -28,6 +28,7 @@ use std::collections::HashMap;\n use std::iter;\n use std::path::PathBuf;\n use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use std::default::Default;\n use tokenstream::{self, TokenStream};\n \n@@ -615,15 +616,15 @@ pub trait Resolver {\n     fn is_whitelisted_legacy_custom_derive(&self, name: Name) -> bool;\n \n     fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion, derives: &[Mark]);\n-    fn add_builtin(&mut self, ident: ast::Ident, ext: Rc<SyntaxExtension>);\n+    fn add_builtin(&mut self, ident: ast::Ident, ext: Lrc<SyntaxExtension>);\n \n     fn resolve_imports(&mut self);\n     // Resolves attribute and derive legacy macros from `#![plugin(..)]`.\n     fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<Attribute>) -> Option<Attribute>;\n     fn resolve_invoc(&mut self, invoc: &mut Invocation, scope: Mark, force: bool)\n-                     -> Result<Option<Rc<SyntaxExtension>>, Determinacy>;\n+                     -> Result<Option<Lrc<SyntaxExtension>>, Determinacy>;\n     fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)\n-                     -> Result<Rc<SyntaxExtension>, Determinacy>;\n+                     -> Result<Lrc<SyntaxExtension>, Determinacy>;\n     fn check_unused_macros(&self);\n }\n \n@@ -642,16 +643,16 @@ impl Resolver for DummyResolver {\n     fn is_whitelisted_legacy_custom_derive(&self, _name: Name) -> bool { false }\n \n     fn visit_expansion(&mut self, _invoc: Mark, _expansion: &Expansion, _derives: &[Mark]) {}\n-    fn add_builtin(&mut self, _ident: ast::Ident, _ext: Rc<SyntaxExtension>) {}\n+    fn add_builtin(&mut self, _ident: ast::Ident, _ext: Lrc<SyntaxExtension>) {}\n \n     fn resolve_imports(&mut self) {}\n     fn find_legacy_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>) -> Option<Attribute> { None }\n     fn resolve_invoc(&mut self, _invoc: &mut Invocation, _scope: Mark, _force: bool)\n-                     -> Result<Option<Rc<SyntaxExtension>>, Determinacy> {\n+                     -> Result<Option<Lrc<SyntaxExtension>>, Determinacy> {\n         Err(Determinacy::Determined)\n     }\n     fn resolve_macro(&mut self, _scope: Mark, _path: &ast::Path, _kind: MacroKind,\n-                     _force: bool) -> Result<Rc<SyntaxExtension>, Determinacy> {\n+                     _force: bool) -> Result<Lrc<SyntaxExtension>, Determinacy> {\n         Err(Determinacy::Determined)\n     }\n     fn check_unused_macros(&self) {}"}, {"sha": "377f47a3ea5a114141846655a6fcbe5358b041f7", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -305,7 +305,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             let (expansion, new_invocations) = if let Some(ext) = ext {\n                 if let Some(ext) = ext {\n                     let dummy = invoc.expansion_kind.dummy(invoc.span()).unwrap();\n-                    let expansion = self.expand_invoc(invoc, ext).unwrap_or(dummy);\n+                    let expansion = self.expand_invoc(invoc, &*ext).unwrap_or(dummy);\n                     self.collect_invocations(expansion, &[])\n                 } else if let InvocationKind::Attr { attr: None, traits, item } = invoc.kind {\n                     if !item.derive_allowed() {\n@@ -437,7 +437,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n     }\n \n-    fn expand_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Option<Expansion> {\n+    fn expand_invoc(&mut self, invoc: Invocation, ext: &SyntaxExtension) -> Option<Expansion> {\n         let result = match invoc.kind {\n             InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc, ext)?,\n             InvocationKind::Attr { .. } => self.expand_attr_invoc(invoc, ext)?,\n@@ -463,7 +463,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n     fn expand_attr_invoc(&mut self,\n                          invoc: Invocation,\n-                         ext: Rc<SyntaxExtension>)\n+                         ext: &SyntaxExtension)\n                          -> Option<Expansion> {\n         let Invocation { expansion_kind: kind, .. } = invoc;\n         let (attr, item) = match invoc.kind {\n@@ -521,7 +521,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     /// Expand a macro invocation. Returns the result of expansion.\n     fn expand_bang_invoc(&mut self,\n                          invoc: Invocation,\n-                         ext: Rc<SyntaxExtension>)\n+                         ext: &SyntaxExtension)\n                          -> Option<Expansion> {\n         let (mark, kind) = (invoc.expansion_data.mark, invoc.expansion_kind);\n         let (mac, ident, span) = match invoc.kind {\n@@ -654,7 +654,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     /// Expand a derive invocation. Returns the result of expansion.\n     fn expand_derive_invoc(&mut self,\n                            invoc: Invocation,\n-                           ext: Rc<SyntaxExtension>)\n+                           ext: &SyntaxExtension)\n                            -> Option<Expansion> {\n         let Invocation { expansion_kind: kind, .. } = invoc;\n         let (path, item) = match invoc.kind {"}, {"sha": "d6dce63ea5e4b8d63c16fd2f9ef58529835a20ed", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -24,7 +24,7 @@ use util::small_vector::SmallVector;\n use std::fs::File;\n use std::io::prelude::*;\n use std::path::PathBuf;\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n \n // These macros all relate to the file system; they either return\n // the column/row/filename of the expression, or they include\n@@ -184,7 +184,7 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::Toke\n             // dependency information, but don't enter it's contents\n             cx.codemap().new_filemap_and_lines(&file, \"\");\n \n-            base::MacEager::expr(cx.expr_lit(sp, ast::LitKind::ByteStr(Rc::new(bytes))))\n+            base::MacEager::expr(cx.expr_lit(sp, ast::LitKind::ByteStr(Lrc::new(bytes))))\n         }\n     }\n }"}, {"sha": "728b3e4076d1ba93b7b3b3aba652fe81b51485eb", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -29,7 +29,8 @@ use tokenstream::{TokenStream, TokenTree};\n use std::cell::RefCell;\n use std::collections::HashMap;\n use std::collections::hash_map::Entry;\n-use std::rc::Rc;\n+\n+use rustc_data_structures::sync::Lrc;\n \n pub struct ParserAnyMacro<'a> {\n     parser: Parser<'a>,\n@@ -199,7 +200,7 @@ pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item)\n     // ...quasiquoting this would be nice.\n     // These spans won't matter, anyways\n     let argument_gram = vec![\n-        quoted::TokenTree::Sequence(DUMMY_SP, Rc::new(quoted::SequenceRepetition {\n+        quoted::TokenTree::Sequence(DUMMY_SP, Lrc::new(quoted::SequenceRepetition {\n             tts: vec![\n                 quoted::TokenTree::MetaVarDecl(DUMMY_SP, lhs_nm, ast::Ident::from_str(\"tt\")),\n                 quoted::TokenTree::Token(DUMMY_SP, token::FatArrow),\n@@ -210,7 +211,7 @@ pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item)\n             num_captures: 2,\n         })),\n         // to phase into semicolon-termination instead of semicolon-separation\n-        quoted::TokenTree::Sequence(DUMMY_SP, Rc::new(quoted::SequenceRepetition {\n+        quoted::TokenTree::Sequence(DUMMY_SP, Lrc::new(quoted::SequenceRepetition {\n             tts: vec![quoted::TokenTree::Token(DUMMY_SP, token::Semi)],\n             separator: None,\n             op: quoted::KleeneOp::ZeroOrMore,"}, {"sha": "c9d7f78c2e303142016552176c26098c7da2738f", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -19,7 +19,7 @@ use tokenstream;\n \n use std::cell::RefCell;\n use std::iter::Peekable;\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n \n /// Contains the sub-token-trees of a \"delimited\" token tree, such as the contents of `(`. Note\n /// that the delimiter itself might be `NoDelim`.\n@@ -89,9 +89,9 @@ pub enum KleeneOp {\n #[derive(Debug, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub enum TokenTree {\n     Token(Span, token::Token),\n-    Delimited(Span, Rc<Delimited>),\n+    Delimited(Span, Lrc<Delimited>),\n     /// A kleene-style repetition sequence\n-    Sequence(Span, Rc<SequenceRepetition>),\n+    Sequence(Span, Lrc<SequenceRepetition>),\n     /// E.g. `$var`\n     MetaVar(Span, ast::Ident),\n     /// E.g. `$var:expr`. This is only used in the left hand side of MBE macros.\n@@ -278,7 +278,7 @@ where\n                 let name_captures = macro_parser::count_names(&sequence);\n                 TokenTree::Sequence(\n                     span,\n-                    Rc::new(SequenceRepetition {\n+                    Lrc::new(SequenceRepetition {\n                         tts: sequence,\n                         separator,\n                         op,\n@@ -324,7 +324,7 @@ where\n         // descend into the delimited set and further parse it.\n         tokenstream::TokenTree::Delimited(span, delimited) => TokenTree::Delimited(\n             span,\n-            Rc::new(Delimited {\n+            Lrc::new(Delimited {\n                 delim: delimited.delim,\n                 tts: parse(delimited.tts.into(), expect_matchers, sess, features, attrs),\n             }),"}, {"sha": "7883c4bbc1648e66c9043711fbdb505e0daca0d6", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -20,27 +20,28 @@ use tokenstream::{TokenStream, TokenTree, Delimited};\n use util::small_vector::SmallVector;\n \n use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use std::mem;\n use std::ops::Add;\n use std::collections::HashMap;\n \n // An iterator over the token trees in a delimited token tree (`{ ... }`) or a sequence (`$(...)`).\n enum Frame {\n     Delimited {\n-        forest: Rc<quoted::Delimited>,\n+        forest: Lrc<quoted::Delimited>,\n         idx: usize,\n         span: Span,\n     },\n     Sequence {\n-        forest: Rc<quoted::SequenceRepetition>,\n+        forest: Lrc<quoted::SequenceRepetition>,\n         idx: usize,\n         sep: Option<Token>,\n     },\n }\n \n impl Frame {\n     fn new(tts: Vec<quoted::TokenTree>) -> Frame {\n-        let forest = Rc::new(quoted::Delimited { delim: token::NoDelim, tts: tts });\n+        let forest = Lrc::new(quoted::Delimited { delim: token::NoDelim, tts: tts });\n         Frame::Delimited { forest: forest, idx: 0, span: DUMMY_SP }\n     }\n }"}, {"sha": "bc1854d3cd8924949b4bb61db4c45ffbde8fb203", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -29,7 +29,7 @@ use tokenstream::*;\n use util::small_vector::SmallVector;\n use util::move_map::MoveMap;\n \n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n \n pub trait Folder : Sized {\n     // Any additions to this trait should happen in form\n@@ -580,7 +580,7 @@ pub fn noop_fold_token<T: Folder>(t: token::Token, fld: &mut T) -> token::Token\n         token::Ident(id) => token::Ident(fld.fold_ident(id)),\n         token::Lifetime(id) => token::Lifetime(fld.fold_ident(id)),\n         token::Interpolated(nt) => {\n-            let nt = match Rc::try_unwrap(nt) {\n+            let nt = match Lrc::try_unwrap(nt) {\n                 Ok(nt) => nt,\n                 Err(nt) => (*nt).clone(),\n             };"}, {"sha": "eed3c6914054d20c473fa7f7a95af4ca1aea6de5", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -26,7 +26,7 @@ use errors::{DiagnosticBuilder, SubDiagnostic, CodeSuggestion, CodeMapper};\n use errors::DiagnosticId;\n use errors::emitter::{Emitter, EmitterWriter};\n \n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use std::io::{self, Write};\n use std::vec;\n use std::sync::{Arc, Mutex};\n@@ -36,7 +36,7 @@ use rustc_serialize::json::{as_json, as_pretty_json};\n pub struct JsonEmitter {\n     dst: Box<Write + Send>,\n     registry: Option<Registry>,\n-    cm: Rc<CodeMapper + 'static>,\n+    cm: Lrc<CodeMapper + 'static>,\n     pretty: bool,\n     /// Whether \"approximate suggestions\" are enabled in the config\n     approximate_suggestions: bool,\n@@ -45,7 +45,7 @@ pub struct JsonEmitter {\n \n impl JsonEmitter {\n     pub fn stderr(registry: Option<Registry>,\n-                  code_map: Rc<CodeMap>,\n+                  code_map: Lrc<CodeMap>,\n                   pretty: bool,\n                   approximate_suggestions: bool) -> JsonEmitter {\n         JsonEmitter {\n@@ -60,13 +60,13 @@ impl JsonEmitter {\n \n     pub fn basic(pretty: bool) -> JsonEmitter {\n         let file_path_mapping = FilePathMapping::empty();\n-        JsonEmitter::stderr(None, Rc::new(CodeMap::new(file_path_mapping)),\n+        JsonEmitter::stderr(None, Lrc::new(CodeMap::new(file_path_mapping)),\n                             pretty, false)\n     }\n \n     pub fn new(dst: Box<Write + Send>,\n                registry: Option<Registry>,\n-               code_map: Rc<CodeMap>,\n+               code_map: Lrc<CodeMap>,\n                pretty: bool,\n                approximate_suggestions: bool) -> JsonEmitter {\n         JsonEmitter {"}, {"sha": "b5368b3ecabdd6fd4894eb3f72dc34e702843219", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -20,7 +20,7 @@ use std_unicode::property::Pattern_White_Space;\n use std::borrow::Cow;\n use std::char;\n use std::mem::replace;\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n \n pub mod comments;\n mod tokentrees;\n@@ -48,7 +48,7 @@ pub struct StringReader<'a> {\n     pub col: CharPos,\n     /// The current character (which has been read from self.pos)\n     pub ch: Option<char>,\n-    pub filemap: Rc<syntax_pos::FileMap>,\n+    pub filemap: Lrc<syntax_pos::FileMap>,\n     /// If Some, stop reading the source at this position (inclusive).\n     pub terminator: Option<BytePos>,\n     /// Whether to record new-lines and multibyte chars in filemap.\n@@ -61,7 +61,7 @@ pub struct StringReader<'a> {\n     pub fatal_errs: Vec<DiagnosticBuilder<'a>>,\n     // cache a direct reference to the source text, so that we don't have to\n     // retrieve it via `self.filemap.src.as_ref().unwrap()` all the time.\n-    source_text: Rc<String>,\n+    source_text: Lrc<String>,\n     /// Stack of open delimiters and their spans. Used for error message.\n     token: token::Token,\n     span: Span,\n@@ -152,13 +152,13 @@ impl<'a> StringReader<'a> {\n \n impl<'a> StringReader<'a> {\n     /// For comments.rs, which hackily pokes into next_pos and ch\n-    pub fn new_raw(sess: &'a ParseSess, filemap: Rc<syntax_pos::FileMap>) -> Self {\n+    pub fn new_raw(sess: &'a ParseSess, filemap: Lrc<syntax_pos::FileMap>) -> Self {\n         let mut sr = StringReader::new_raw_internal(sess, filemap);\n         sr.bump();\n         sr\n     }\n \n-    fn new_raw_internal(sess: &'a ParseSess, filemap: Rc<syntax_pos::FileMap>) -> Self {\n+    fn new_raw_internal(sess: &'a ParseSess, filemap: Lrc<syntax_pos::FileMap>) -> Self {\n         if filemap.src.is_none() {\n             sess.span_diagnostic.bug(&format!(\"Cannot lex filemap without source: {}\",\n                                               filemap.name));\n@@ -187,7 +187,7 @@ impl<'a> StringReader<'a> {\n         }\n     }\n \n-    pub fn new(sess: &'a ParseSess, filemap: Rc<syntax_pos::FileMap>) -> Self {\n+    pub fn new(sess: &'a ParseSess, filemap: Lrc<syntax_pos::FileMap>) -> Self {\n         let mut sr = StringReader::new_raw(sess, filemap);\n         if sr.advance_token().is_err() {\n             sr.emit_fatal_errors();\n@@ -1747,9 +1747,7 @@ mod tests {\n     use std::collections::HashSet;\n     use std::io;\n     use std::path::PathBuf;\n-    use std::rc::Rc;\n-\n-    fn mk_sess(cm: Rc<CodeMap>) -> ParseSess {\n+    fn mk_sess(cm: Lrc<CodeMap>) -> ParseSess {\n         let emitter = errors::emitter::EmitterWriter::new(Box::new(io::sink()),\n                                                           Some(cm.clone()),\n                                                           false,\n@@ -1776,7 +1774,7 @@ mod tests {\n \n     #[test]\n     fn t1() {\n-        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n+        let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         let mut string_reader = setup(&cm,\n                                       &sh,\n@@ -1820,71 +1818,71 @@ mod tests {\n \n     #[test]\n     fn doublecolonparsing() {\n-        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n+        let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         check_tokenization(setup(&cm, &sh, \"a b\".to_string()),\n                            vec![mk_ident(\"a\"), token::Whitespace, mk_ident(\"b\")]);\n     }\n \n     #[test]\n     fn dcparsing_2() {\n-        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n+        let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         check_tokenization(setup(&cm, &sh, \"a::b\".to_string()),\n                            vec![mk_ident(\"a\"), token::ModSep, mk_ident(\"b\")]);\n     }\n \n     #[test]\n     fn dcparsing_3() {\n-        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n+        let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         check_tokenization(setup(&cm, &sh, \"a ::b\".to_string()),\n                            vec![mk_ident(\"a\"), token::Whitespace, token::ModSep, mk_ident(\"b\")]);\n     }\n \n     #[test]\n     fn dcparsing_4() {\n-        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n+        let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         check_tokenization(setup(&cm, &sh, \"a:: b\".to_string()),\n                            vec![mk_ident(\"a\"), token::ModSep, token::Whitespace, mk_ident(\"b\")]);\n     }\n \n     #[test]\n     fn character_a() {\n-        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n+        let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         assert_eq!(setup(&cm, &sh, \"'a'\".to_string()).next_token().tok,\n                    token::Literal(token::Char(Symbol::intern(\"a\")), None));\n     }\n \n     #[test]\n     fn character_space() {\n-        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n+        let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         assert_eq!(setup(&cm, &sh, \"' '\".to_string()).next_token().tok,\n                    token::Literal(token::Char(Symbol::intern(\" \")), None));\n     }\n \n     #[test]\n     fn character_escaped() {\n-        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n+        let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         assert_eq!(setup(&cm, &sh, \"'\\\\n'\".to_string()).next_token().tok,\n                    token::Literal(token::Char(Symbol::intern(\"\\\\n\")), None));\n     }\n \n     #[test]\n     fn lifetime_name() {\n-        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n+        let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         assert_eq!(setup(&cm, &sh, \"'abc\".to_string()).next_token().tok,\n                    token::Lifetime(Ident::from_str(\"'abc\")));\n     }\n \n     #[test]\n     fn raw_string() {\n-        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n+        let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         assert_eq!(setup(&cm, &sh, \"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\".to_string())\n                        .next_token()\n@@ -1894,7 +1892,7 @@ mod tests {\n \n     #[test]\n     fn literal_suffixes() {\n-        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n+        let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         macro_rules! test {\n             ($input: expr, $tok_type: ident, $tok_contents: expr) => {{\n@@ -1938,7 +1936,7 @@ mod tests {\n \n     #[test]\n     fn nested_block_comments() {\n-        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n+        let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         let mut lexer = setup(&cm, &sh, \"/* /* */ */'a'\".to_string());\n         match lexer.next_token().tok {\n@@ -1951,7 +1949,7 @@ mod tests {\n \n     #[test]\n     fn crlf_comments() {\n-        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n+        let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         let mut lexer = setup(&cm, &sh, \"// test\\r\\n/// test\\r\\n\".to_string());\n         let comment = lexer.next_token();"}, {"sha": "1d9af682fec8a66c2ee2c9e1c80a6fb91e35abb7", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -10,6 +10,7 @@\n \n //! The main parser interface\n \n+use rustc_data_structures::sync::Lrc;\n use ast::{self, CrateConfig};\n use codemap::{CodeMap, FilePathMapping};\n use syntax_pos::{self, Span, FileMap, NO_EXPANSION, FileName};\n@@ -25,7 +26,6 @@ use std::cell::RefCell;\n use std::collections::HashSet;\n use std::iter;\n use std::path::{Path, PathBuf};\n-use std::rc::Rc;\n use std::str;\n \n pub type PResult<'a, T> = Result<T, DiagnosticBuilder<'a>>;\n@@ -52,20 +52,20 @@ pub struct ParseSess {\n     pub non_modrs_mods: RefCell<Vec<(ast::Ident, Span)>>,\n     /// Used to determine and report recursive mod inclusions\n     included_mod_stack: RefCell<Vec<PathBuf>>,\n-    code_map: Rc<CodeMap>,\n+    code_map: Lrc<CodeMap>,\n }\n \n impl ParseSess {\n     pub fn new(file_path_mapping: FilePathMapping) -> Self {\n-        let cm = Rc::new(CodeMap::new(file_path_mapping));\n+        let cm = Lrc::new(CodeMap::new(file_path_mapping));\n         let handler = Handler::with_tty_emitter(ColorConfig::Auto,\n                                                 true,\n                                                 false,\n                                                 Some(cm.clone()));\n         ParseSess::with_span_handler(handler, cm)\n     }\n \n-    pub fn with_span_handler(handler: Handler, code_map: Rc<CodeMap>) -> ParseSess {\n+    pub fn with_span_handler(handler: Handler, code_map: Lrc<CodeMap>) -> ParseSess {\n         ParseSess {\n             span_diagnostic: handler,\n             unstable_features: UnstableFeatures::from_environment(),\n@@ -183,7 +183,7 @@ pub fn new_sub_parser_from_file<'a>(sess: &'a ParseSess,\n }\n \n /// Given a filemap and config, return a parser\n-pub fn filemap_to_parser(sess: & ParseSess, filemap: Rc<FileMap>, ) -> Parser {\n+pub fn filemap_to_parser(sess: & ParseSess, filemap: Lrc<FileMap>) -> Parser {\n     let end_pos = filemap.end_pos;\n     let mut parser = stream_to_parser(sess, filemap_to_stream(sess, filemap, None));\n \n@@ -206,7 +206,7 @@ pub fn new_parser_from_tts(sess: &ParseSess, tts: Vec<TokenTree>) -> Parser {\n /// Given a session and a path and an optional span (for error reporting),\n /// add the path to the session's codemap and return the new filemap.\n fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n-                   -> Rc<FileMap> {\n+                   -> Lrc<FileMap> {\n     match sess.codemap().load_file(path) {\n         Ok(filemap) => filemap,\n         Err(e) => {\n@@ -220,7 +220,7 @@ fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n }\n \n /// Given a filemap, produce a sequence of token-trees\n-pub fn filemap_to_stream(sess: &ParseSess, filemap: Rc<FileMap>, override_span: Option<Span>)\n+pub fn filemap_to_stream(sess: &ParseSess, filemap: Lrc<FileMap>, override_span: Option<Span>)\n                          -> TokenStream {\n     let mut srdr = lexer::StringReader::new(sess, filemap);\n     srdr.override_span = override_span;\n@@ -422,7 +422,7 @@ pub fn lit_token(lit: token::Lit, suf: Option<Symbol>, diag: Option<(Span, &Hand\n             (true, Some(LitKind::ByteStr(byte_str_lit(&i.as_str()))))\n         }\n         token::ByteStrRaw(i, _) => {\n-            (true, Some(LitKind::ByteStr(Rc::new(i.to_string().into_bytes()))))\n+            (true, Some(LitKind::ByteStr(Lrc::new(i.to_string().into_bytes()))))\n         }\n     }\n }\n@@ -496,7 +496,7 @@ pub fn byte_lit(lit: &str) -> (u8, usize) {\n     }\n }\n \n-pub fn byte_str_lit(lit: &str) -> Rc<Vec<u8>> {\n+pub fn byte_str_lit(lit: &str) -> Lrc<Vec<u8>> {\n     let mut res = Vec::with_capacity(lit.len());\n \n     // FIXME #8372: This could be a for-loop if it didn't borrow the iterator\n@@ -553,7 +553,7 @@ pub fn byte_str_lit(lit: &str) -> Rc<Vec<u8>> {\n         }\n     }\n \n-    Rc::new(res)\n+    Lrc::new(res)\n }\n \n pub fn integer_lit(s: &str, suffix: Option<Symbol>, diag: Option<(Span, &Handler)>)"}, {"sha": "097a2eb89fdf4d7d8eca68764e9e1977fceb28dc", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -27,7 +27,7 @@ use tokenstream;\n \n use std::cell::Cell;\n use std::{cmp, fmt};\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n pub enum BinOpToken {\n@@ -180,7 +180,7 @@ pub enum Token {\n \n     // The `LazyTokenStream` is a pure function of the `Nonterminal`,\n     // and so the `LazyTokenStream` can be ignored by Eq, Hash, etc.\n-    Interpolated(Rc<(Nonterminal, LazyTokenStream)>),\n+    Interpolated(Lrc<(Nonterminal, LazyTokenStream)>),\n     // Can be expanded into several tokens.\n     /// Doc comment\n     DocComment(ast::Name),\n@@ -200,7 +200,7 @@ pub enum Token {\n \n impl Token {\n     pub fn interpolated(nt: Nonterminal) -> Token {\n-        Token::Interpolated(Rc::new((nt, LazyTokenStream::new())))\n+        Token::Interpolated(Lrc::new((nt, LazyTokenStream::new())))\n     }\n \n     /// Returns `true` if the token starts with '>'."}, {"sha": "39306229c82b2e8f28cc73a957946c67f1b910c5", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -21,7 +21,6 @@ use std::mem;\n use std::vec;\n use attr::{self, HasAttrs};\n use syntax_pos::{self, DUMMY_SP, NO_EXPANSION, Span, FileMap, BytePos};\n-use std::rc::Rc;\n \n use codemap::{self, CodeMap, ExpnInfo, NameAndSpan, MacroAttribute, dummy_spanned};\n use errors;"}, {"sha": "772334e3ef133594877a662dcbabd07ba8219c32", "filename": "src/libsyntax/test_snippet.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Ftest_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Ftest_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest_snippet.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -13,7 +13,7 @@ use errors::Handler;\n use errors::emitter::EmitterWriter;\n use std::io;\n use std::io::prelude::*;\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use std::str;\n use std::sync::{Arc, Mutex};\n use std::path::Path;\n@@ -48,7 +48,7 @@ impl<T: Write> Write for Shared<T> {\n fn test_harness(file_text: &str, span_labels: Vec<SpanLabel>, expected_output: &str) {\n     let output = Arc::new(Mutex::new(Vec::new()));\n \n-    let code_map = Rc::new(CodeMap::new(FilePathMapping::empty()));\n+    let code_map = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n     code_map.new_filemap_and_lines(Path::new(\"test.rs\"), &file_text);\n \n     let primary_span = make_span(&file_text, &span_labels[0].start, &span_labels[0].end);"}, {"sha": "520b7a48e3025a205128dd86f37e21ef5309129d", "filename": "src/libsyntax/util/rc_slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Futil%2Frc_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax%2Futil%2Frc_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Frc_slice.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -10,14 +10,14 @@\n \n use std::fmt;\n use std::ops::{Deref, Range};\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n \n use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n                                            HashStable};\n \n #[derive(Clone)]\n pub struct RcSlice<T> {\n-    data: Rc<Box<[T]>>,\n+    data: Lrc<Box<[T]>>,\n     offset: u32,\n     len: u32,\n }\n@@ -27,7 +27,7 @@ impl<T> RcSlice<T> {\n         RcSlice {\n             offset: 0,\n             len: vec.len() as u32,\n-            data: Rc::new(vec.into_boxed_slice()),\n+            data: Lrc::new(vec.into_boxed_slice()),\n         }\n     }\n "}, {"sha": "d8eeb5ed2554ab4a0a2aac172bcf2b1a79357205", "filename": "src/libsyntax_ext/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax_ext%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax_ext%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2FCargo.toml?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -14,3 +14,4 @@ proc_macro = { path = \"../libproc_macro\" }\n rustc_errors = { path = \"../librustc_errors\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n\\ No newline at end of file"}, {"sha": "6bc4ee0b399f9e412dfed2643b12762ef1dcb092", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -10,7 +10,7 @@\n \n //! The compiler code necessary to implement the `#[derive]` extensions.\n \n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxExtension, Resolver};\n use syntax::ext::build::AstBuilder;\n@@ -65,7 +65,7 @@ macro_rules! derive_traits {\n             $(\n                 resolver.add_builtin(\n                     ast::Ident::with_empty_ctxt(Symbol::intern($name)),\n-                    Rc::new(SyntaxExtension::BuiltinDerive($func))\n+                    Lrc::new(SyntaxExtension::BuiltinDerive($func))\n                 );\n             )*\n         }"}, {"sha": "772dec72ab98edd300a034fbc9ca5afb175a8a6a", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -23,6 +23,7 @@ extern crate fmt_macros;\n extern crate syntax;\n extern crate syntax_pos;\n extern crate proc_macro;\n+extern crate rustc_data_structures;\n extern crate rustc_errors as errors;\n \n mod asm;\n@@ -44,7 +45,7 @@ pub mod deriving;\n \n pub mod proc_macro_impl;\n \n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n use syntax::ext::base::{MacroExpanderFn, NormalTT, NamedSyntaxExtension};\n use syntax::symbol::Symbol;\n@@ -55,7 +56,7 @@ pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n     deriving::register_builtin_derives(resolver);\n \n     let mut register = |name, ext| {\n-        resolver.add_builtin(ast::Ident::with_empty_ctxt(name), Rc::new(ext));\n+        resolver.add_builtin(ast::Ident::with_empty_ctxt(name), Lrc::new(ext));\n     };\n \n     macro_rules! register {"}, {"sha": "9f746adbe65732e90a4e40853945c937725a0772", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -33,9 +33,9 @@ use std::fmt;\n use std::hash::{Hasher, Hash};\n use std::ops::{Add, Sub};\n use std::path::PathBuf;\n-use std::rc::Rc;\n \n use rustc_data_structures::stable_hasher::StableHasher;\n+use rustc_data_structures::sync::Lrc;\n \n extern crate rustc_data_structures;\n \n@@ -678,7 +678,7 @@ pub struct FileMap {\n     /// Indicates which crate this FileMap was imported from.\n     pub crate_of_origin: u32,\n     /// The complete source code\n-    pub src: Option<Rc<String>>,\n+    pub src: Option<Lrc<String>>,\n     /// The source code's hash\n     pub src_hash: u128,\n     /// The external source code (used for external crates, which will have a `None`\n@@ -864,7 +864,7 @@ impl FileMap {\n             name_was_remapped,\n             unmapped_path: Some(unmapped_path),\n             crate_of_origin: 0,\n-            src: Some(Rc::new(src)),\n+            src: Some(Lrc::new(src)),\n             src_hash,\n             external_src: RefCell::new(ExternalSource::Unneeded),\n             start_pos,\n@@ -1127,7 +1127,7 @@ impl Sub for CharPos {\n #[derive(Debug, Clone)]\n pub struct Loc {\n     /// Information about the original source\n-    pub file: Rc<FileMap>,\n+    pub file: Lrc<FileMap>,\n     /// The (1-based) line number\n     pub line: usize,\n     /// The (0-based) column offset\n@@ -1144,14 +1144,14 @@ pub struct LocWithOpt {\n     pub filename: FileName,\n     pub line: usize,\n     pub col: CharPos,\n-    pub file: Option<Rc<FileMap>>,\n+    pub file: Option<Lrc<FileMap>>,\n }\n \n // used to be structural records. Better names, anyone?\n #[derive(Debug)]\n-pub struct FileMapAndLine { pub fm: Rc<FileMap>, pub line: usize }\n+pub struct FileMapAndLine { pub fm: Lrc<FileMap>, pub line: usize }\n #[derive(Debug)]\n-pub struct FileMapAndBytePos { pub fm: Rc<FileMap>, pub pos: BytePos }\n+pub struct FileMapAndBytePos { pub fm: Lrc<FileMap>, pub pos: BytePos }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct LineInfo {\n@@ -1166,7 +1166,7 @@ pub struct LineInfo {\n }\n \n pub struct FileLines {\n-    pub file: Rc<FileMap>,\n+    pub file: Lrc<FileMap>,\n     pub lines: Vec<LineInfo>\n }\n "}, {"sha": "07d4bd2fe151ca3dcae285d690cd0f47467c7ac2", "filename": "src/test/run-pass-fulldeps/issue-35829.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Ftest%2Frun-pass-fulldeps%2Fissue-35829.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74e97cf42e647d87d67a03c134a0494b6aaa811/src%2Ftest%2Frun-pass-fulldeps%2Fissue-35829.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-35829.rs?ref=b74e97cf42e647d87d67a03c134a0494b6aaa811", "patch": "@@ -13,6 +13,7 @@\n #![feature(quote, rustc_private)]\n \n extern crate syntax;\n+extern crate rustc_data_structures;\n \n use syntax::ext::base::{ExtCtxt, DummyResolver};\n use syntax::ext::expand::ExpansionConfig;\n@@ -23,7 +24,7 @@ use syntax::ast::{Expr, ExprKind, LitKind, StrStyle, RangeLimits};\n use syntax::symbol::Symbol;\n use syntax::ptr::P;\n \n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n \n fn main() {\n     let parse_sess = ParseSess::new(FilePathMapping::empty());\n@@ -33,12 +34,12 @@ fn main() {\n \n     // check byte string\n     let byte_string = quote_expr!(&cx, b\"one\");\n-    let byte_string_lit_kind = LitKind::ByteStr(Rc::new(b\"one\".to_vec()));\n+    let byte_string_lit_kind = LitKind::ByteStr(Lrc::new(b\"one\".to_vec()));\n     assert_eq!(byte_string.node, ExprKind::Lit(P(dummy_spanned(byte_string_lit_kind))));\n \n     // check raw byte string\n     let raw_byte_string = quote_expr!(&cx, br###\"#\"two\"#\"###);\n-    let raw_byte_string_lit_kind = LitKind::ByteStr(Rc::new(b\"#\\\"two\\\"#\".to_vec()));\n+    let raw_byte_string_lit_kind = LitKind::ByteStr(Lrc::new(b\"#\\\"two\\\"#\".to_vec()));\n     assert_eq!(raw_byte_string.node, ExprKind::Lit(P(dummy_spanned(raw_byte_string_lit_kind))));\n \n     // check dotdoteq"}]}