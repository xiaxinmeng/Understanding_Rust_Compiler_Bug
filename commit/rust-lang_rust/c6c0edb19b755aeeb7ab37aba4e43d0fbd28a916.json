{"sha": "c6c0edb19b755aeeb7ab37aba4e43d0fbd28a916", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2YzBlZGIxOWI3NTVhZWViN2FiMzdhYmE0ZTQzZDBmYmQyOGE5MTY=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-01-21T17:19:02Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-01-21T18:56:31Z"}, "message": "Add a lint about deriving Hash and implementing PartialEq", "tree": {"sha": "d0303b80d5772a90adc8ec9a53604840540e41a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0303b80d5772a90adc8ec9a53604840540e41a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6c0edb19b755aeeb7ab37aba4e43d0fbd28a916", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6c0edb19b755aeeb7ab37aba4e43d0fbd28a916", "html_url": "https://github.com/rust-lang/rust/commit/c6c0edb19b755aeeb7ab37aba4e43d0fbd28a916", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6c0edb19b755aeeb7ab37aba4e43d0fbd28a916/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c570fc60790289148b5f1dfba87c3e730c45ab51", "url": "https://api.github.com/repos/rust-lang/rust/commits/c570fc60790289148b5f1dfba87c3e730c45ab51", "html_url": "https://github.com/rust-lang/rust/commit/c570fc60790289148b5f1dfba87c3e730c45ab51"}], "stats": {"total": 134, "additions": 133, "deletions": 1}, "files": [{"sha": "c45acf4af77c8cd94f2d840af1ac5afc910f7b89", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6c0edb19b755aeeb7ab37aba4e43d0fbd28a916/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/c6c0edb19b755aeeb7ab37aba4e43d0fbd28a916/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=c6c0edb19b755aeeb7ab37aba4e43d0fbd28a916", "patch": "@@ -6,7 +6,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 95 lints included in this crate:\n+There are 96 lints included in this crate:\n \n name                                                                                                           | default | meaning\n ---------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -26,6 +26,7 @@ name\n [collapsible_if](https://github.com/Manishearth/rust-clippy/wiki#collapsible_if)                               | warn    | two nested `if`-expressions can be collapsed into one, e.g. `if x { if y { foo() } }` can be written as `if x && y { foo() }`\n [cyclomatic_complexity](https://github.com/Manishearth/rust-clippy/wiki#cyclomatic_complexity)                 | warn    | finds functions that should be split up into multiple functions\n [deprecated_semver](https://github.com/Manishearth/rust-clippy/wiki#deprecated_semver)                         | warn    | `Warn` on `#[deprecated(since = \"x\")]` where x is not semver\n+[derive_hash_not_eq](https://github.com/Manishearth/rust-clippy/wiki#derive_hash_not_eq)                       | warn    | deriving `Hash` but implementing `PartialEq` explicitly\n [duplicate_underscore_argument](https://github.com/Manishearth/rust-clippy/wiki#duplicate_underscore_argument) | warn    | Function arguments having names which only differ by an underscore\n [empty_loop](https://github.com/Manishearth/rust-clippy/wiki#empty_loop)                                       | warn    | empty `loop {}` detected\n [eq_op](https://github.com/Manishearth/rust-clippy/wiki#eq_op)                                                 | warn    | equal operands on both sides of a comparison or bitwise combination (e.g. `x == x`)"}, {"sha": "6306bb8f09d5d252d42d44c830382bf03f55a424", "filename": "src/derive.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/c6c0edb19b755aeeb7ab37aba4e43d0fbd28a916/src%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c0edb19b755aeeb7ab37aba4e43d0fbd28a916/src%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fderive.rs?ref=c6c0edb19b755aeeb7ab37aba4e43d0fbd28a916", "patch": "@@ -0,0 +1,98 @@\n+use rustc::lint::*;\n+use rustc_front::hir::*;\n+use syntax::ast::{Attribute, MetaItem_};\n+use utils::{match_path, span_lint_and_then};\n+use utils::HASH_PATH;\n+\n+use rustc::middle::ty::fast_reject::simplify_type;\n+\n+/// **What it does:** This lint warns about deriving `Hash` but implementing `PartialEq`\n+/// explicitely.\n+///\n+/// **Why is this bad?** The implementation of these traits must agree (for example for use with\n+/// `HashMap`) so it\u2019s probably a bad idea to use a default-generated `Hash` implementation  with\n+/// an explicitely defined `PartialEq`. In particular, the following must hold for any type:\n+///\n+/// ```rust\n+/// k1 == k2 -> hash(k1) == hash(k2)\n+/// ```\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// #[derive(Hash)]\n+/// struct Foo;\n+///\n+/// impl PartialEq for Foo {\n+///     ..\n+/// }\n+declare_lint! {\n+    pub DERIVE_HASH_NOT_EQ,\n+    Warn,\n+    \"deriving `Hash` but implementing `PartialEq` explicitly\"\n+}\n+\n+pub struct Derive;\n+\n+impl LintPass for Derive {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(DERIVE_HASH_NOT_EQ)\n+    }\n+}\n+\n+impl LateLintPass for Derive {\n+    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+        /// A `#[derive]`d implementation has a `#[automatically_derived]` attribute.\n+        fn is_automatically_derived(attr: &Attribute) -> bool {\n+            if let MetaItem_::MetaWord(ref word) = attr.node.value.node {\n+                word == &\"automatically_derived\"\n+            }\n+            else {\n+                false\n+            }\n+        }\n+\n+        // If `item` is an automatically derived `Hash` implementation\n+        if_let_chain! {[\n+            let ItemImpl(_, _, _, Some(ref trait_ref), ref ast_ty, _) = item.node,\n+            match_path(&trait_ref.path, &HASH_PATH),\n+            item.attrs.iter().any(is_automatically_derived),\n+            let Some(peq_trait_def_id) = cx.tcx.lang_items.eq_trait()\n+        ], {\n+            let peq_trait_def = cx.tcx.lookup_trait_def(peq_trait_def_id);\n+\n+            cx.tcx.populate_implementations_for_trait_if_necessary(peq_trait_def.trait_ref.def_id);\n+            let peq_impls = peq_trait_def.borrow_impl_lists(cx.tcx).1;\n+            let ast_ty_to_ty_cache = cx.tcx.ast_ty_to_ty_cache.borrow();\n+\n+\n+            // Look for the PartialEq implementations for `ty`\n+            if_let_chain! {[\n+                let Some(ty) = ast_ty_to_ty_cache.get(&ast_ty.id),\n+                let Some(simpl_ty) = simplify_type(cx.tcx, ty, false),\n+                let Some(impl_ids) = peq_impls.get(&simpl_ty)\n+            ], {\n+                for &impl_id in impl_ids {\n+                    let trait_ref = cx.tcx.impl_trait_ref(impl_id).expect(\"must be a trait implementation\");\n+\n+                    // Only care about `impl PartialEq<Foo> for Foo`\n+                    if trait_ref.input_types()[0] == *ty &&\n+                      !cx.tcx.get_attrs(impl_id).iter().any(is_automatically_derived) {\n+                        span_lint_and_then(\n+                            cx, DERIVE_HASH_NOT_EQ, item.span,\n+                            &format!(\"you are deriving `Hash` but have implemented \\\n+                                      `PartialEq` explicitely\"), |db| {\n+                            if let Some(node_id) = cx.tcx.map.as_local_node_id(impl_id) {\n+                                db.span_note(\n+                                    cx.tcx.map.span(node_id),\n+                                    \"`PartialEq` implemented here\"\n+                                );\n+                            }\n+                        });\n+                    }\n+                }\n+            }}\n+        }}\n+    }\n+}"}, {"sha": "4a832cc7b89300ac69ea68a4315e50b1e3d9c449", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6c0edb19b755aeeb7ab37aba4e43d0fbd28a916/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c0edb19b755aeeb7ab37aba4e43d0fbd28a916/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=c6c0edb19b755aeeb7ab37aba4e43d0fbd28a916", "patch": "@@ -75,6 +75,7 @@ pub mod entry;\n pub mod misc_early;\n pub mod array_indexing;\n pub mod panic;\n+pub mod derive;\n \n mod reexport {\n     pub use syntax::ast::{Name, NodeId};\n@@ -136,6 +137,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box array_indexing::ArrayIndexing);\n     reg.register_late_lint_pass(box panic::PanicPass);\n     reg.register_late_lint_pass(box strings::StringLitAsBytes);\n+    reg.register_late_lint_pass(box derive::Derive);\n \n \n     reg.register_lint_group(\"clippy_pedantic\", vec![\n@@ -168,6 +170,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         block_in_if_condition::BLOCK_IN_IF_CONDITION_STMT,\n         collapsible_if::COLLAPSIBLE_IF,\n         cyclomatic_complexity::CYCLOMATIC_COMPLEXITY,\n+        derive::DERIVE_HASH_NOT_EQ,\n         entry::MAP_ENTRY,\n         eq_op::EQ_OP,\n         escape::BOXED_LOCAL,"}, {"sha": "c5483997f90a0fdf8b97c8f7e3f41635712e70ba", "filename": "src/utils.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6c0edb19b755aeeb7ab37aba4e43d0fbd28a916/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c0edb19b755aeeb7ab37aba4e43d0fbd28a916/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=c6c0edb19b755aeeb7ab37aba4e43d0fbd28a916", "patch": "@@ -27,6 +27,7 @@ pub const COW_PATH: [&'static str; 3] = [\"collections\", \"borrow\", \"Cow\"];\n pub const DEFAULT_TRAIT_PATH: [&'static str; 3] = [\"core\", \"default\", \"Default\"];\n pub const HASHMAP_ENTRY_PATH: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n pub const HASHMAP_PATH: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n+pub const HASH_PATH: [&'static str; 2] = [\"hash\", \"Hash\"];\n pub const LL_PATH: [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedList\"];\n pub const MUTEX_PATH: [&'static str; 4] = [\"std\", \"sync\", \"mutex\", \"Mutex\"];\n pub const OPEN_OPTIONS_PATH: [&'static str; 3] = [\"std\", \"fs\", \"OpenOptions\"];"}, {"sha": "a879be282925d736b027fffd1d572536c545f66f", "filename": "tests/compile-fail/derive.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c6c0edb19b755aeeb7ab37aba4e43d0fbd28a916/tests%2Fcompile-fail%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c0edb19b755aeeb7ab37aba4e43d0fbd28a916/tests%2Fcompile-fail%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fderive.rs?ref=c6c0edb19b755aeeb7ab37aba4e43d0fbd28a916", "patch": "@@ -0,0 +1,29 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#![deny(warnings)]\n+\n+#[derive(PartialEq, Hash)]\n+struct Foo;\n+\n+impl PartialEq<u64> for Foo {\n+    fn eq(&self, _: &u64) -> bool { true }\n+}\n+\n+#[derive(Hash)]\n+//~^ ERROR you are deriving `Hash` but have implemented `PartialEq` explicitely\n+struct Bar;\n+\n+impl PartialEq for Bar {\n+    fn eq(&self, _: &Bar) -> bool { true }\n+}\n+\n+#[derive(Hash)]\n+//~^ ERROR you are deriving `Hash` but have implemented `PartialEq` explicitely\n+struct Baz;\n+\n+impl PartialEq<Baz> for Baz {\n+    fn eq(&self, _: &Baz) -> bool { true }\n+}\n+\n+fn main() {}"}]}