{"sha": "53e8bd641a4d3495fb4ffb12e732390d9b4ff93e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzZThiZDY0MWE0ZDM0OTVmYjRmZmIxMmU3MzIzOTBkOWI0ZmY5M2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-04T08:52:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-04T08:52:47Z"}, "message": "auto merge of #19449 : nikomatsakis/rust/unboxed-closure-fn-impl, r=pcwalton\n\nImplement the `Fn` trait for bare fn pointers in the compiler rather\r\nthan doing it using hard-coded impls. This means that it works also\r\nfor more complex fn types involving bound regions.", "tree": {"sha": "06bb72cfc78e0956825adc0c3de2d9c7b5d8c19c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06bb72cfc78e0956825adc0c3de2d9c7b5d8c19c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e", "html_url": "https://github.com/rust-lang/rust/commit/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c89031e1f213030f0514c8dcb9e6fa19ddbd323", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c89031e1f213030f0514c8dcb9e6fa19ddbd323", "html_url": "https://github.com/rust-lang/rust/commit/3c89031e1f213030f0514c8dcb9e6fa19ddbd323"}, {"sha": "f2731ffb52a5873800df4ef2dfa28da9c4302976", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2731ffb52a5873800df4ef2dfa28da9c4302976", "html_url": "https://github.com/rust-lang/rust/commit/f2731ffb52a5873800df4ef2dfa28da9c4302976"}], "stats": {"total": 532, "additions": 458, "deletions": 74}, "files": [{"sha": "4f4ec4867972eeceaa147f2a8c827f73b4c82467", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 42, "deletions": 38, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=53e8bd641a4d3495fb4ffb12e732390d9b4ff93e", "patch": "@@ -833,48 +833,52 @@ impl<F,A,R> FnOnce<A,R> for F\n     }\n }\n \n-\n-impl<Result> Fn<(),Result> for extern \"Rust\" fn() -> Result {\n-    #[allow(non_snake_case)]\n-    extern \"rust-call\" fn call(&self, _args: ()) -> Result {\n-        (*self)()\n+#[cfg(stage0)]\n+mod fn_impls {\n+    use super::Fn;\n+\n+    impl<Result> Fn<(),Result> for extern \"Rust\" fn() -> Result {\n+        #[allow(non_snake_case)]\n+        extern \"rust-call\" fn call(&self, _args: ()) -> Result {\n+            (*self)()\n+        }\n     }\n-}\n \n-impl<Result,A0> Fn<(A0,),Result> for extern \"Rust\" fn(A0) -> Result {\n-    #[allow(non_snake_case)]\n-    extern \"rust-call\" fn call(&self, args: (A0,)) -> Result {\n-        let (a0,) = args;\n-        (*self)(a0)\n+    impl<Result,A0> Fn<(A0,),Result> for extern \"Rust\" fn(A0) -> Result {\n+        #[allow(non_snake_case)]\n+        extern \"rust-call\" fn call(&self, args: (A0,)) -> Result {\n+            let (a0,) = args;\n+            (*self)(a0)\n+        }\n     }\n-}\n \n-macro_rules! def_fn(\n-    ($($args:ident)*) => (\n-        impl<Result$(,$args)*>\n-        Fn<($($args,)*),Result>\n-        for extern \"Rust\" fn($($args: $args,)*) -> Result {\n-            #[allow(non_snake_case)]\n-            extern \"rust-call\" fn call(&self, args: ($($args,)*)) -> Result {\n-                let ($($args,)*) = args;\n-                (*self)($($args,)*)\n+    macro_rules! def_fn(\n+        ($($args:ident)*) => (\n+            impl<Result$(,$args)*>\n+            Fn<($($args,)*),Result>\n+            for extern \"Rust\" fn($($args: $args,)*) -> Result {\n+                #[allow(non_snake_case)]\n+                extern \"rust-call\" fn call(&self, args: ($($args,)*)) -> Result {\n+                    let ($($args,)*) = args;\n+                    (*self)($($args,)*)\n+                }\n             }\n-        }\n+        )\n     )\n-)\n \n-def_fn!(A0 A1)\n-def_fn!(A0 A1 A2)\n-def_fn!(A0 A1 A2 A3)\n-def_fn!(A0 A1 A2 A3 A4)\n-def_fn!(A0 A1 A2 A3 A4 A5)\n-def_fn!(A0 A1 A2 A3 A4 A5 A6)\n-def_fn!(A0 A1 A2 A3 A4 A5 A6 A7)\n-def_fn!(A0 A1 A2 A3 A4 A5 A6 A7 A8)\n-def_fn!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9)\n-def_fn!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10)\n-def_fn!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11)\n-def_fn!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12)\n-def_fn!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13)\n-def_fn!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14)\n-def_fn!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14 A15)\n+    def_fn!(A0 A1)\n+    def_fn!(A0 A1 A2)\n+    def_fn!(A0 A1 A2 A3)\n+    def_fn!(A0 A1 A2 A3 A4)\n+    def_fn!(A0 A1 A2 A3 A4 A5)\n+    def_fn!(A0 A1 A2 A3 A4 A5 A6)\n+    def_fn!(A0 A1 A2 A3 A4 A5 A6 A7)\n+    def_fn!(A0 A1 A2 A3 A4 A5 A6 A7 A8)\n+    def_fn!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9)\n+    def_fn!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10)\n+    def_fn!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11)\n+    def_fn!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12)\n+    def_fn!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13)\n+    def_fn!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14)\n+    def_fn!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14 A15)\n+}"}, {"sha": "b8d915c06e0b7462531a26a538cab0fb95f5ae0a", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=53e8bd641a4d3495fb4ffb12e732390d9b4ff93e", "patch": "@@ -167,18 +167,21 @@ pub enum Vtable<'tcx, N> {\n     /// Vtable identifying a particular impl.\n     VtableImpl(VtableImplData<'tcx, N>),\n \n-    /// Vtable automatically generated for an unboxed closure. The def\n-    /// ID is the ID of the closure expression. This is a `VtableImpl`\n-    /// in spirit, but the impl is generated by the compiler and does\n-    /// not appear in the source.\n-    VtableUnboxedClosure(ast::DefId, subst::Substs<'tcx>),\n-\n     /// Successful resolution to an obligation provided by the caller\n     /// for some type parameter.\n     VtableParam(VtableParamData<'tcx>),\n \n     /// Successful resolution for a builtin trait.\n     VtableBuiltin(VtableBuiltinData<N>),\n+\n+    /// Vtable automatically generated for an unboxed closure. The def\n+    /// ID is the ID of the closure expression. This is a `VtableImpl`\n+    /// in spirit, but the impl is generated by the compiler and does\n+    /// not appear in the source.\n+    VtableUnboxedClosure(ast::DefId, subst::Substs<'tcx>),\n+\n+    /// Same as above, but for a fn pointer type with the given signature.\n+    VtableFnPointer(ty::Ty<'tcx>),\n }\n \n /// Identifies a particular impl in the source, along with a set of\n@@ -322,6 +325,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n     pub fn iter_nested(&self) -> Items<N> {\n         match *self {\n             VtableImpl(ref i) => i.iter_nested(),\n+            VtableFnPointer(..) => (&[]).iter(),\n             VtableUnboxedClosure(..) => (&[]).iter(),\n             VtableParam(_) => (&[]).iter(),\n             VtableBuiltin(ref i) => i.iter_nested(),\n@@ -331,6 +335,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n     pub fn map_nested<M>(&self, op: |&N| -> M) -> Vtable<'tcx, M> {\n         match *self {\n             VtableImpl(ref i) => VtableImpl(i.map_nested(op)),\n+            VtableFnPointer(ref sig) => VtableFnPointer((*sig).clone()),\n             VtableUnboxedClosure(d, ref s) => VtableUnboxedClosure(d, s.clone()),\n             VtableParam(ref p) => VtableParam((*p).clone()),\n             VtableBuiltin(ref i) => VtableBuiltin(i.map_nested(op)),\n@@ -340,6 +345,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n     pub fn map_move_nested<M>(self, op: |N| -> M) -> Vtable<'tcx, M> {\n         match self {\n             VtableImpl(i) => VtableImpl(i.map_move_nested(op)),\n+            VtableFnPointer(sig) => VtableFnPointer(sig),\n             VtableUnboxedClosure(d, s) => VtableUnboxedClosure(d, s),\n             VtableParam(p) => VtableParam(p),\n             VtableBuiltin(i) => VtableBuiltin(i.map_move_nested(op)),"}, {"sha": "2604204d9e63f9f228640b6c94e991f3f44ee25d", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 128, "deletions": 17, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=53e8bd641a4d3495fb4ffb12e732390d9b4ff93e", "patch": "@@ -22,7 +22,7 @@ use super::{SelectionError, Unimplemented, Overflow,\n             OutputTypeParameterMismatch};\n use super::{Selection};\n use super::{SelectionResult};\n-use super::{VtableBuiltin, VtableImpl, VtableParam, VtableUnboxedClosure};\n+use super::{VtableBuiltin, VtableImpl, VtableParam, VtableUnboxedClosure, VtableFnPointer};\n use super::{VtableImplData, VtableParamData, VtableBuiltinData};\n use super::{util};\n \n@@ -36,7 +36,7 @@ use middle::ty_fold::TypeFoldable;\n use std::cell::RefCell;\n use std::collections::hash_map::HashMap;\n use std::rc::Rc;\n-use syntax::ast;\n+use syntax::{abi, ast};\n use util::common::ErrorReported;\n use util::ppaux::Repr;\n \n@@ -131,7 +131,15 @@ enum Candidate<'tcx> {\n     BuiltinCandidate(ty::BuiltinBound),\n     ParamCandidate(VtableParamData<'tcx>),\n     ImplCandidate(ast::DefId),\n+\n+    /// Implementation of a `Fn`-family trait by one of the\n+    /// anonymous types generated for a `||` expression.\n     UnboxedClosureCandidate(/* closure */ ast::DefId, Substs<'tcx>),\n+\n+    /// Implementation of a `Fn`-family trait by one of the anonymous\n+    /// types generated for a fn pointer type (e.g., `fn(int)->int`)\n+    FnPointerCandidate,\n+\n     ErrorCandidate,\n }\n \n@@ -917,7 +925,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             None => {\n                 // For the time being, we ignore user-defined impls for builtin-bounds.\n                 // (And unboxed candidates only apply to the Fn/FnMut/etc traits.)\n-                try!(self.assemble_unboxed_candidates(obligation, &mut candidates));\n+                try!(self.assemble_unboxed_closure_candidates(obligation, &mut candidates));\n+                try!(self.assemble_fn_pointer_candidates(obligation, &mut candidates));\n                 try!(self.assemble_candidates_from_impls(obligation, &mut candidates));\n             }\n         }\n@@ -968,20 +977,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Note: the type parameters on an unboxed closure candidate are modeled as *output* type\n     /// parameters and hence do not affect whether this trait is a match or not. They will be\n     /// unified during the confirmation step.\n-    fn assemble_unboxed_candidates(&mut self,\n-                                   obligation: &Obligation<'tcx>,\n-                                   candidates: &mut CandidateSet<'tcx>)\n-                                   -> Result<(),SelectionError<'tcx>>\n+    fn assemble_unboxed_closure_candidates(&mut self,\n+                                           obligation: &Obligation<'tcx>,\n+                                           candidates: &mut CandidateSet<'tcx>)\n+                                           -> Result<(),SelectionError<'tcx>>\n     {\n-        let tcx = self.tcx();\n-        let kind = if Some(obligation.trait_ref.def_id) == tcx.lang_items.fn_trait() {\n-            ty::FnUnboxedClosureKind\n-        } else if Some(obligation.trait_ref.def_id) == tcx.lang_items.fn_mut_trait() {\n-            ty::FnMutUnboxedClosureKind\n-        } else if Some(obligation.trait_ref.def_id) == tcx.lang_items.fn_once_trait() {\n-            ty::FnOnceUnboxedClosureKind\n-        } else {\n-            return Ok(()); // not a fn trait, ignore\n+        let kind = match self.fn_family_trait_kind(obligation.trait_ref.def_id) {\n+            Some(k) => k,\n+            None => { return Ok(()); }\n         };\n \n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n@@ -1015,6 +1018,44 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         Ok(())\n     }\n \n+    /// Implement one of the `Fn()` family for a fn pointer.\n+    fn assemble_fn_pointer_candidates(&mut self,\n+                                      obligation: &Obligation<'tcx>,\n+                                      candidates: &mut CandidateSet<'tcx>)\n+                                      -> Result<(),SelectionError<'tcx>>\n+    {\n+        // We provide a `Fn` impl for fn pointers. There is no need to provide\n+        // the other traits (e.g. `FnMut`) since those are provided by blanket\n+        // impls.\n+        if Some(obligation.trait_ref.def_id) != self.tcx().lang_items.fn_trait() {\n+            return Ok(());\n+        }\n+\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        match self_ty.sty {\n+            ty::ty_infer(..) => {\n+                candidates.ambiguous = true; // could wind up being a fn() type\n+            }\n+\n+            // provide an impl, but only for suitable `fn` pointers\n+            ty::ty_bare_fn(ty::BareFnTy {\n+                fn_style: ast::NormalFn,\n+                abi: abi::Rust,\n+                sig: ty::FnSig {\n+                    inputs: _,\n+                    output: ty::FnConverging(_),\n+                    variadic: false\n+                }\n+            }) => {\n+                candidates.vec.push(FnPointerCandidate);\n+            }\n+\n+            _ => { }\n+        }\n+\n+        Ok(())\n+    }\n+\n     /// Search for impls that might apply to `obligation`.\n     fn assemble_candidates_from_impls(&mut self,\n                                       obligation: &Obligation<'tcx>,\n@@ -1551,6 +1592,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 try!(self.confirm_unboxed_closure_candidate(obligation, closure_def_id, &substs));\n                 Ok(VtableUnboxedClosure(closure_def_id, substs))\n             }\n+\n+            FnPointerCandidate => {\n+                let fn_type =\n+                    try!(self.confirm_fn_pointer_candidate(obligation));\n+                Ok(VtableFnPointer(fn_type))\n+            }\n         }\n     }\n \n@@ -1646,6 +1693,51 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                          nested: impl_obligations }\n     }\n \n+    fn confirm_fn_pointer_candidate(&mut self,\n+                                    obligation: &Obligation<'tcx>)\n+                                    -> Result<ty::Ty<'tcx>,SelectionError<'tcx>>\n+    {\n+        debug!(\"confirm_fn_pointer_candidate({})\",\n+               obligation.repr(self.tcx()));\n+\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        let sig = match self_ty.sty {\n+            ty::ty_bare_fn(ty::BareFnTy {\n+                fn_style: ast::NormalFn,\n+                abi: abi::Rust,\n+                ref sig\n+            }) => {\n+                sig\n+            }\n+            _ => {\n+                self.tcx().sess.span_bug(\n+                    obligation.cause.span,\n+                    format!(\"Fn pointer candidate for inappropriate self type: {}\",\n+                            self_ty.repr(self.tcx())).as_slice());\n+            }\n+        };\n+\n+        let arguments_tuple = ty::mk_tup(self.tcx(), sig.inputs.to_vec());\n+        let output_type = sig.output.unwrap();\n+        let substs =\n+            Substs::new_trait(\n+                vec![arguments_tuple, output_type],\n+                vec![],\n+                vec![],\n+                self_ty);\n+        let trait_ref = Rc::new(ty::TraitRef {\n+            def_id: obligation.trait_ref.def_id,\n+            substs: substs,\n+        });\n+\n+        let () =\n+            try!(self.confirm(obligation.cause,\n+                              obligation.trait_ref.clone(),\n+                              trait_ref));\n+\n+        Ok(self_ty)\n+    }\n+\n     fn confirm_unboxed_closure_candidate(&mut self,\n                                          obligation: &Obligation<'tcx>,\n                                          closure_def_id: ast::DefId,\n@@ -1964,6 +2056,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         util::obligations_for_generics(self.tcx(), cause, recursion_depth,\n                                        &bounds, &impl_substs.types)\n     }\n+\n+    fn fn_family_trait_kind(&self,\n+                            trait_def_id: ast::DefId)\n+                            -> Option<ty::UnboxedClosureKind>\n+    {\n+        let tcx = self.tcx();\n+        if Some(trait_def_id) == tcx.lang_items.fn_trait() {\n+            Some(ty::FnUnboxedClosureKind)\n+        } else if Some(trait_def_id) == tcx.lang_items.fn_mut_trait() {\n+            Some(ty::FnMutUnboxedClosureKind)\n+        } else if Some(trait_def_id) == tcx.lang_items.fn_once_trait() {\n+            Some(ty::FnOnceUnboxedClosureKind)\n+        } else {\n+            None\n+        }\n+    }\n }\n \n impl<'tcx> Repr<'tcx> for Candidate<'tcx> {\n@@ -1972,7 +2080,10 @@ impl<'tcx> Repr<'tcx> for Candidate<'tcx> {\n             ErrorCandidate => format!(\"ErrorCandidate\"),\n             BuiltinCandidate(b) => format!(\"BuiltinCandidate({})\", b),\n             UnboxedClosureCandidate(c, ref s) => {\n-                format!(\"MatchedUnboxedClosureCandidate({},{})\", c, s.repr(tcx))\n+                format!(\"UnboxedClosureCandidate({},{})\", c, s.repr(tcx))\n+            }\n+            FnPointerCandidate => {\n+                format!(\"FnPointerCandidate\")\n             }\n             ParamCandidate(ref a) => format!(\"ParamCandidate({})\", a.repr(tcx)),\n             ImplCandidate(a) => format!(\"ImplCandidate({})\", a.repr(tcx)),"}, {"sha": "1084807ef4a0a58dcb2350adf09c14452fac3b08", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=53e8bd641a4d3495fb4ffb12e732390d9b4ff93e", "patch": "@@ -302,6 +302,10 @@ impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::Vtable<'tcx, N> {\n                         d.repr(tcx),\n                         s.repr(tcx)),\n \n+            super::VtableFnPointer(ref d) =>\n+                format!(\"VtableFnPointer({})\",\n+                        d.repr(tcx)),\n+\n             super::VtableParam(ref v) =>\n                 format!(\"VtableParam({})\", v.repr(tcx)),\n "}, {"sha": "de9eb42649845dd9e07be5cc218ce04c4f12c46b", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=53e8bd641a4d3495fb4ffb12e732390d9b4ff93e", "patch": "@@ -466,6 +466,9 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N>\n             traits::VtableUnboxedClosure(d, ref s) => {\n                 traits::VtableUnboxedClosure(d, s.fold_with(folder))\n             }\n+            traits::VtableFnPointer(ref d) => {\n+                traits::VtableFnPointer(d.fold_with(folder))\n+            }\n             traits::VtableParam(ref p) => traits::VtableParam(p.fold_with(folder)),\n             traits::VtableBuiltin(ref d) => traits::VtableBuiltin(d.fold_with(folder)),\n         }"}, {"sha": "84a6b59934f6eeba475bce19067c0790f8e80b27", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=53e8bd641a4d3495fb4ffb12e732390d9b4ff93e", "patch": "@@ -995,9 +995,9 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     if need_invoke(bcx) {\n-        debug!(\"invoking {} at {}\", llfn, bcx.llbb);\n+        debug!(\"invoking {} at {}\", bcx.val_to_string(llfn), bcx.llbb);\n         for &llarg in llargs.iter() {\n-            debug!(\"arg: {}\", llarg);\n+            debug!(\"arg: {}\", bcx.val_to_string(llarg));\n         }\n         let normal_bcx = bcx.fcx.new_temp_block(\"normal-return\");\n         let landing_pad = bcx.fcx.get_landing_pad();\n@@ -1015,9 +1015,9 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               Some(attributes));\n         return (llresult, normal_bcx);\n     } else {\n-        debug!(\"calling {} at {}\", llfn, bcx.llbb);\n+        debug!(\"calling {} at {}\", bcx.val_to_string(llfn), bcx.llbb);\n         for &llarg in llargs.iter() {\n-            debug!(\"arg: {}\", llarg);\n+            debug!(\"arg: {}\", bcx.val_to_string(llarg));\n         }\n \n         match call_info {"}, {"sha": "176fe7096e751c885517512145b2a2fbd7309884", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=53e8bd641a4d3495fb4ffb12e732390d9b4ff93e", "patch": "@@ -242,6 +242,120 @@ fn trans_fn_ref_with_substs_to_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n+/// Translates an adapter that implements the `Fn` trait for a fn\n+/// pointer. This is basically the equivalent of something like:\n+///\n+/// ```rust\n+/// impl<'a> Fn(&'a int) -> &'a int for fn(&int) -> &int {\n+///     extern \"rust-abi\" fn call(&self, args: (&'a int,)) -> &'a int {\n+///         (*self)(args.0)\n+///     }\n+/// }\n+/// ```\n+///\n+/// but for the bare function type given.\n+pub fn trans_fn_pointer_shim<'a, 'tcx>(\n+    ccx: &'a CrateContext<'a, 'tcx>,\n+    bare_fn_ty: Ty<'tcx>)\n+    -> ValueRef\n+{\n+    let _icx = push_ctxt(\"trans_fn_pointer_shim\");\n+    let tcx = ccx.tcx();\n+\n+    let bare_fn_ty = ty::normalize_ty(tcx, bare_fn_ty);\n+    match ccx.fn_pointer_shims().borrow().get(&bare_fn_ty) {\n+        Some(&llval) => { return llval; }\n+        None => { }\n+    }\n+\n+    debug!(\"trans_fn_pointer_shim(bare_fn_ty={})\",\n+           bare_fn_ty.repr(tcx));\n+\n+    // This is an impl of `Fn` trait, so receiver is `&self`.\n+    let bare_fn_ty_ref = ty::mk_imm_rptr(tcx, ty::ReStatic, bare_fn_ty);\n+\n+    // Construct the \"tuply\" version of `bare_fn_ty`. It takes two arguments: `self`,\n+    // which is the fn pointer, and `args`, which is the arguments tuple.\n+    let (input_tys, output_ty) =\n+        match bare_fn_ty.sty {\n+            ty::ty_bare_fn(ty::BareFnTy { fn_style: ast::NormalFn,\n+                                          abi: synabi::Rust,\n+                                          sig: ty::FnSig { inputs: ref input_tys,\n+                                                           output: output_ty,\n+                                                           variadic: false }}) =>\n+            {\n+                (input_tys, output_ty)\n+            }\n+\n+            _ => {\n+                tcx.sess.bug(format!(\"trans_fn_pointer_shim invoked on invalid type: {}\",\n+                                           bare_fn_ty.repr(tcx)).as_slice());\n+            }\n+        };\n+    let tuple_input_ty = ty::mk_tup(tcx, input_tys.to_vec());\n+    let tuple_fn_ty = ty::mk_bare_fn(tcx,\n+                                     ty::BareFnTy { fn_style: ast::NormalFn,\n+                                                    abi: synabi::RustCall,\n+                                                    sig: ty::FnSig {\n+                                                        inputs: vec![bare_fn_ty_ref,\n+                                                                     tuple_input_ty],\n+                                                        output: output_ty,\n+                                                        variadic: false\n+                                                    }});\n+    debug!(\"tuple_fn_ty: {}\", tuple_fn_ty.repr(tcx));\n+\n+    //\n+    let function_name =\n+        link::mangle_internal_name_by_type_and_seq(ccx, bare_fn_ty,\n+                                                   \"fn_pointer_shim\");\n+    let llfn =\n+        decl_internal_rust_fn(ccx,\n+                              tuple_fn_ty,\n+                              function_name.as_slice());\n+\n+    //\n+    let block_arena = TypedArena::new();\n+    let empty_substs = Substs::trans_empty();\n+    let fcx = new_fn_ctxt(ccx,\n+                          llfn,\n+                          ast::DUMMY_NODE_ID,\n+                          false,\n+                          output_ty,\n+                          &empty_substs,\n+                          None,\n+                          &block_arena);\n+    let mut bcx = init_function(&fcx, false, output_ty);\n+\n+    // the first argument (`self`) will be ptr to the the fn pointer\n+    let llfnpointer =\n+        Load(bcx, get_param(fcx.llfn, fcx.arg_pos(0) as u32));\n+\n+    // the remaining arguments will be the untupled values\n+    let llargs: Vec<_> =\n+        input_tys.iter()\n+        .enumerate()\n+        .map(|(i, _)| get_param(fcx.llfn, fcx.arg_pos(i+1) as u32))\n+        .collect();\n+    assert!(!fcx.needs_ret_allocas);\n+\n+    let dest = fcx.llretslotptr.get().map(|_|\n+        expr::SaveIn(fcx.get_ret_slot(bcx, output_ty, \"ret_slot\"))\n+    );\n+\n+    bcx = trans_call_inner(bcx,\n+                           None,\n+                           bare_fn_ty,\n+                           |bcx, _| Callee { bcx: bcx, data: Fn(llfnpointer) },\n+                           ArgVals(llargs.as_slice()),\n+                           dest).bcx;\n+\n+    finish_fn(&fcx, bcx, output_ty);\n+\n+    ccx.fn_pointer_shims().borrow_mut().insert(bare_fn_ty, llfn);\n+\n+    llfn\n+}\n+\n /// Translates the adapter that deconstructs a `Box<Trait>` object into\n /// `Trait` so that a by-value self method can be called.\n pub fn trans_unboxing_shim<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,"}, {"sha": "8220645cec78b59cc17cb8dc0e4e2fc8dda0b7c9", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=53e8bd641a4d3495fb4ffb12e732390d9b4ff93e", "patch": "@@ -84,6 +84,7 @@ pub struct LocalCrateContext<'tcx> {\n     tn: TypeNames,\n     externs: RefCell<ExternMap>,\n     item_vals: RefCell<NodeMap<ValueRef>>,\n+    fn_pointer_shims: RefCell<FnvHashMap<Ty<'tcx>, ValueRef>>,\n     drop_glues: RefCell<FnvHashMap<Ty<'tcx>, ValueRef>>,\n     tydescs: RefCell<FnvHashMap<Ty<'tcx>, Rc<tydesc_info<'tcx>>>>,\n     /// Set when running emit_tydescs to enforce that no more tydescs are\n@@ -394,6 +395,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 tn: TypeNames::new(),\n                 externs: RefCell::new(FnvHashMap::new()),\n                 item_vals: RefCell::new(NodeMap::new()),\n+                fn_pointer_shims: RefCell::new(FnvHashMap::new()),\n                 drop_glues: RefCell::new(FnvHashMap::new()),\n                 tydescs: RefCell::new(FnvHashMap::new()),\n                 finished_tydescs: Cell::new(false),\n@@ -573,6 +575,10 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.shared.link_meta\n     }\n \n+    pub fn fn_pointer_shims(&self) -> &RefCell<FnvHashMap<Ty<'tcx>, ValueRef>> {\n+        &self.local.fn_pointer_shims\n+    }\n+\n     pub fn drop_glues<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, ValueRef>> {\n         &self.local.drop_glues\n     }"}, {"sha": "ef431243b31e9612848f32d2f18a81d01c2da0d2", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=53e8bd641a4d3495fb4ffb12e732390d9b4ff93e", "patch": "@@ -368,9 +368,15 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 data: Fn(llfn),\n             }\n         }\n-        _ => {\n-            bcx.tcx().sess.bug(\n-                \"vtable_param left in monomorphized function's vtable substs\");\n+        traits::VtableFnPointer(fn_ty) => {\n+            let llfn = trans_fn_pointer_shim(bcx.ccx(), fn_ty);\n+            Callee { bcx: bcx, data: Fn(llfn) }\n+        }\n+        traits::VtableBuiltin(..) |\n+        traits::VtableParam(..) => {\n+            bcx.sess().bug(\n+                format!(\"resolved vtable bad vtable {} in trans\",\n+                        vtable.repr(bcx.tcx())).as_slice());\n         }\n     }\n }\n@@ -609,6 +615,10 @@ pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n                 (vec!(llfn)).into_iter()\n             }\n+            traits::VtableFnPointer(bare_fn_ty) => {\n+                let llfn = vec![trans_fn_pointer_shim(bcx.ccx(), bare_fn_ty)];\n+                llfn.into_iter()\n+            }\n             traits::VtableParam(..) => {\n                 bcx.sess().bug(\n                     format!(\"resolved vtable for {} to bad vtable {} in trans\","}, {"sha": "935e67706589ef75f1bda27d3336776aef45d998", "filename": "src/test/compile-fail/issue-15965.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Ftest%2Fcompile-fail%2Fissue-15965.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Ftest%2Fcompile-fail%2Fissue-15965.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15965.rs?ref=53e8bd641a4d3495fb4ffb12e732390d9b4ff93e", "patch": "@@ -11,8 +11,6 @@\n fn main() {\n     return\n         { return () } //~ ERROR the type of this value must be known in this context\n-    () //~^ ERROR the type of this value must be known in this context\n-//~^^ ERROR notation; the first type parameter for the function trait is neither a tuple nor unit\n-//~^^^ ERROR overloaded calls are experimental\n+    ()\n     ;\n }"}, {"sha": "9cf922ae99002cece4c190e728b073e601c0a9be", "filename": "src/test/compile-fail/issue-18532.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Ftest%2Fcompile-fail%2Fissue-18532.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Ftest%2Fcompile-fail%2Fissue-18532.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18532.rs?ref=53e8bd641a4d3495fb4ffb12e732390d9b4ff93e", "patch": "@@ -17,6 +17,4 @@\n fn main() {\n     (return)((),());\n     //~^ ERROR the type of this value must be known\n-    //~^^ ERROR the type of this value must be known\n-    //~^^^ ERROR cannot use call notation\n }"}, {"sha": "a82689b16491ea048b4fef78840bf74298454727", "filename": "src/test/compile-fail/unboxed-closures-unsafe-extern-fn.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Ftest%2Fcompile-fail%2Funboxed-closures-unsafe-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Ftest%2Fcompile-fail%2Funboxed-closures-unsafe-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-unsafe-extern-fn.rs?ref=53e8bd641a4d3495fb4ffb12e732390d9b4ff93e", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that unsafe extern fn pointers do not implement any Fn traits.\n+\n+#![feature(unboxed_closures)]\n+\n+use std::ops::{Fn,FnMut,FnOnce};\n+\n+unsafe fn square(x: &int) -> int { (*x) * (*x) }\n+\n+fn call_it<F:Fn(&int)->int>(_: &F, _: int) -> int { 0 }\n+fn call_it_mut<F:FnMut(&int)->int>(_: &mut F, _: int) -> int { 0 }\n+fn call_it_once<F:FnOnce(&int)->int>(_: F, _: int) -> int { 0 }\n+\n+fn main() {\n+    let x = call_it(&square, 22); //~ ERROR not implemented\n+    let y = call_it_mut(&mut square, 22); //~ ERROR not implemented\n+    let z = call_it_once(square, 22); //~ ERROR not implemented\n+}\n+"}, {"sha": "920e91958ee9e002079502650fcd679cf099a349", "filename": "src/test/compile-fail/unboxed-closures-wrong-abi.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-abi.rs?ref=53e8bd641a4d3495fb4ffb12e732390d9b4ff93e", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that unsafe extern fn pointers do not implement any Fn traits.\n+\n+#![feature(unboxed_closures)]\n+\n+use std::ops::{Fn,FnMut,FnOnce};\n+\n+extern \"C\" fn square(x: &int) -> int { (*x) * (*x) }\n+\n+fn call_it<F:Fn(&int)->int>(_: &F, _: int) -> int { 0 }\n+fn call_it_mut<F:FnMut(&int)->int>(_: &mut F, _: int) -> int { 0 }\n+fn call_it_once<F:FnOnce(&int)->int>(_: F, _: int) -> int { 0 }\n+\n+fn main() {\n+    let x = call_it(&square, 22); //~ ERROR not implemented\n+    let y = call_it_mut(&mut square, 22); //~ ERROR not implemented\n+    let z = call_it_once(square, 22); //~ ERROR not implemented\n+}\n+"}, {"sha": "a7a7b1c676267a97ac0eb42e4699c00b72450424", "filename": "src/test/compile-fail/unboxed-closures-wrong-arg-type-extern-fn.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-arg-type-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-arg-type-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-arg-type-extern-fn.rs?ref=53e8bd641a4d3495fb4ffb12e732390d9b4ff93e", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that unsafe extern fn pointers do not implement any Fn traits.\n+\n+#![feature(unboxed_closures)]\n+\n+use std::ops::{Fn,FnMut,FnOnce};\n+\n+unsafe fn square(x: int) -> int { x * x }\n+// note: argument type here is `int`, not `&int`\n+\n+fn call_it<F:Fn(&int)->int>(_: &F, _: int) -> int { 0 }\n+fn call_it_mut<F:FnMut(&int)->int>(_: &mut F, _: int) -> int { 0 }\n+fn call_it_once<F:FnOnce(&int)->int>(_: F, _: int) -> int { 0 }\n+\n+fn main() {\n+    let x = call_it(&square, 22); //~ ERROR not implemented\n+    let y = call_it_mut(&mut square, 22); //~ ERROR not implemented\n+    let z = call_it_once(square, 22); //~ ERROR not implemented\n+}\n+"}, {"sha": "df753f0f33eb6550d7e4e302c84eba83155c5afe", "filename": "src/test/run-pass/unboxed-closures-extern-fn-hr.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Ftest%2Frun-pass%2Funboxed-closures-extern-fn-hr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Ftest%2Frun-pass%2Funboxed-closures-extern-fn-hr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-extern-fn-hr.rs?ref=53e8bd641a4d3495fb4ffb12e732390d9b4ff93e", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Checks that higher-ranked extern fn pointers implement the full range of Fn traits.\n+\n+#![feature(unboxed_closures)]\n+\n+use std::ops::{Fn,FnMut,FnOnce};\n+\n+fn square(x: &int) -> int { (*x) * (*x) }\n+\n+fn call_it<F:Fn(&int)->int>(f: &F, x: int) -> int {\n+    (*f)(&x)\n+}\n+\n+fn call_it_boxed(f: &Fn(&int) -> int, x: int) -> int {\n+    f.call((&x,))\n+}\n+\n+fn call_it_mut<F:FnMut(&int)->int>(f: &mut F, x: int) -> int {\n+    (*f)(&x)\n+}\n+\n+fn call_it_once<F:FnOnce(&int)->int>(f: F, x: int) -> int {\n+    f(&x)\n+}\n+\n+fn main() {\n+    let x = call_it(&square, 22);\n+    let x1 = call_it_boxed(&square, 22);\n+    let y = call_it_mut(&mut square, 22);\n+    let z = call_it_once(square, 22);\n+    assert_eq!(x, square(&22));\n+    assert_eq!(x1, square(&22));\n+    assert_eq!(y, square(&22));\n+    assert_eq!(z, square(&22));\n+}\n+"}, {"sha": "58657c2b71880dbcbdea73719ad698847e056e58", "filename": "src/test/run-pass/unboxed-closures-extern-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Ftest%2Frun-pass%2Funboxed-closures-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e/src%2Ftest%2Frun-pass%2Funboxed-closures-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-extern-fn.rs?ref=53e8bd641a4d3495fb4ffb12e732390d9b4ff93e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Checks that extern fn points implement the full range of Fn traits.\n+// Checks that extern fn pointers implement the full range of Fn traits.\n \n #![feature(unboxed_closures)]\n #![feature(unboxed_closures)]"}]}