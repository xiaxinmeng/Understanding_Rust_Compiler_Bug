{"sha": "57bb9d809bb029caf7b38042a433153bb965e1fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3YmI5ZDgwOWJiMDI5Y2FmN2IzODA0MmE0MzMxNTNiYjk2NWUxZmI=", "commit": {"author": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-02-04T16:10:04Z"}, "committer": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-02-04T16:10:04Z"}, "message": "Parse function declarations.", "tree": {"sha": "46b7b717cf6e93779b048721278e242416300a94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46b7b717cf6e93779b048721278e242416300a94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57bb9d809bb029caf7b38042a433153bb965e1fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57bb9d809bb029caf7b38042a433153bb965e1fb", "html_url": "https://github.com/rust-lang/rust/commit/57bb9d809bb029caf7b38042a433153bb965e1fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57bb9d809bb029caf7b38042a433153bb965e1fb/comments", "author": null, "committer": null, "parents": [{"sha": "302cafa81dcc868e840c78f2bfbf41929de8a487", "url": "https://api.github.com/repos/rust-lang/rust/commits/302cafa81dcc868e840c78f2bfbf41929de8a487", "html_url": "https://github.com/rust-lang/rust/commit/302cafa81dcc868e840c78f2bfbf41929de8a487"}], "stats": {"total": 144, "additions": 101, "deletions": 43}, "files": [{"sha": "1220d6abf6d57fa302223f74f22e8dfe93b43478", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/57bb9d809bb029caf7b38042a433153bb965e1fb/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57bb9d809bb029caf7b38042a433153bb965e1fb/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=57bb9d809bb029caf7b38042a433153bb965e1fb", "patch": "@@ -201,10 +201,11 @@ tag ty_ {\n }\n \n type arg = rec(mode mode, @ty ty, ident ident, def_id id);\n-type _fn = rec(effect effect,\n+type fn_decl = rec(effect effect,\n+                   vec[arg] inputs,\n+                   @ty output);\n+type _fn = rec(fn_decl decl,\n                bool is_iter,\n-               vec[arg] inputs,\n-               @ty output,\n                block body);\n \n \n@@ -254,6 +255,7 @@ tag item_ {\n type native_item = spanned[native_item_];\n tag native_item_ {\n     native_item_ty(ident, def_id);\n+    native_item_fn(ident, fn_decl, vec[ty_param], def_id);\n }\n \n fn index_view_item(mod_index index, @view_item it) {\n@@ -304,6 +306,9 @@ fn index_native_item(native_mod_index index, @native_item it) {\n         case (ast.native_item_ty(?id, _)) {\n             index.insert(id, it);\n         }\n+        case (ast.native_item_fn(?id, _, _, _)) {\n+            index.insert(id, it);\n+        }\n     }\n }\n "}, {"sha": "e04b82214b872bb74c25733fc417b1bb5b9d3a12", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/57bb9d809bb029caf7b38042a433153bb965e1fb/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57bb9d809bb029caf7b38042a433153bb965e1fb/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=57bb9d809bb029caf7b38042a433153bb965e1fb", "patch": "@@ -1441,7 +1441,7 @@ impure fn parse_ty_params(parser p) -> vec[ast.ty_param] {\n     ret ty_params;\n }\n \n-impure fn parse_fn(parser p, ast.effect eff, bool is_iter) -> ast._fn {\n+impure fn parse_fn_decl(parser p, ast.effect eff) -> ast.fn_decl {\n     auto pf = parse_arg;\n     let util.common.spanned[vec[ast.arg]] inputs =\n         // FIXME: passing parse_arg as an lval doesn't work at the\n@@ -1459,18 +1459,19 @@ impure fn parse_fn(parser p, ast.effect eff, bool is_iter) -> ast._fn {\n     } else {\n         output = @spanned(inputs.span, inputs.span, ast.ty_nil);\n     }\n+    ret rec(effect=eff, inputs=inputs.node, output=output);\n+}\n \n+impure fn parse_fn(parser p, ast.effect eff, bool is_iter) -> ast._fn {\n+    auto decl = parse_fn_decl(p, eff);\n     auto body = parse_block(p);\n-\n-    ret rec(effect = eff,\n+    ret rec(decl = decl,\n             is_iter = is_iter,\n-            inputs = inputs.node,\n-            output = output,\n             body = body);\n }\n \n-impure fn parse_item_fn_or_iter(parser p, ast.effect eff,\n-                                bool is_iter) -> @ast.item {\n+impure fn parse_fn_header(parser p, bool is_iter) -> tup(span, ast.ident,\n+                                                         vec[ast.ty_param]) {\n     auto lo = p.get_span();\n     if (is_iter) {\n         expect(p, token.ITER);\n@@ -1479,10 +1480,16 @@ impure fn parse_item_fn_or_iter(parser p, ast.effect eff,\n     }\n     auto id = parse_ident(p);\n     auto ty_params = parse_ty_params(p);\n+    ret tup(lo, id, ty_params);\n+}\n+\n+impure fn parse_item_fn_or_iter(parser p, ast.effect eff,\n+                                bool is_iter) -> @ast.item {\n+    auto t = parse_fn_header(p, is_iter);\n     auto f = parse_fn(p, eff, is_iter);\n-    auto item = ast.item_fn(id, f, ty_params,\n+    auto item = ast.item_fn(t._1, f, t._2,\n                             p.next_def_id(), ast.ann_none);\n-    ret @spanned(lo, f.body.span, item);\n+    ret @spanned(t._0, f.body.span, item);\n }\n \n \n@@ -1585,11 +1592,24 @@ impure fn parse_item_native_type(parser p) -> @ast.native_item {\n     ret @spanned(t._0, hi, item);\n }\n \n+impure fn parse_item_native_fn(parser p, ast.effect eff) -> @ast.native_item {\n+    auto t = parse_fn_header(p, false);\n+    auto decl = parse_fn_decl(p, eff);\n+    auto hi = p.get_span();\n+    expect(p, token.SEMI);\n+    auto item = ast.native_item_fn(t._1, decl, t._2, p.next_def_id());\n+    ret @spanned(t._0, hi, item);\n+}\n+\n impure fn parse_native_item(parser p) -> @ast.native_item {\n+    let ast.effect eff = parse_effect(p);\n     alt (p.peek()) {\n         case (token.TYPE) {\n             ret parse_item_native_type(p);\n         }\n+        case (token.FN) {\n+            ret parse_item_native_fn(p, eff);\n+        }\n     }\n }\n "}, {"sha": "688d21d20a34b3622c660460f2aedf4e04e14922", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 46, "deletions": 14, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/57bb9d809bb029caf7b38042a433153bb965e1fb/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57bb9d809bb029caf7b38042a433153bb965e1fb/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=57bb9d809bb029caf7b38042a433153bb965e1fb", "patch": "@@ -10,6 +10,7 @@ import util.common.ty_mach;\n import util.common.append;\n \n import front.ast;\n+import front.ast.fn_decl;\n import front.ast.ident;\n import front.ast.path;\n import front.ast.mutability;\n@@ -194,6 +195,11 @@ type ast_fold[ENV] =\n          vec[ast.ty_param] ty_params,\n          def_id id, ann a) -> @item)              fold_item_fn,\n \n+     (fn(&ENV e, &span sp, ident ident,\n+         &ast.fn_decl decl,\n+         vec[ast.ty_param] ty_params,\n+         def_id id) -> @native_item)              fold_native_item_fn,\n+\n      (fn(&ENV e, &span sp, ident ident,\n          &ast._mod m, def_id id) -> @item)        fold_item_mod,\n \n@@ -229,10 +235,13 @@ type ast_fold[ENV] =\n      (fn(&ENV e, &span sp,\n          &ast.block_) -> block)                   fold_block,\n \n-     (fn(&ENV e, ast.effect effect,\n+     (fn(&ENV e, &fn_decl decl,\n          bool is_iter,\n+         &block body) -> ast._fn)                 fold_fn,\n+\n+     (fn(&ENV e, ast.effect effect,\n          vec[arg] inputs,\n-         @ty output, &block body) -> ast._fn)     fold_fn,\n+         @ty output) -> ast.fn_decl)              fold_fn_decl,\n \n      (fn(&ENV e, &ast._mod m) -> ast._mod)        fold_mod,\n \n@@ -688,17 +697,22 @@ fn fold_arg[ENV](&ENV env, ast_fold[ENV] fld, &arg a) -> arg {\n     ret rec(ty=ty with a);\n }\n \n-\n-fn fold_fn[ENV](&ENV env, ast_fold[ENV] fld, &ast._fn f) -> ast._fn {\n-\n+fn fold_fn_decl[ENV](&ENV env, ast_fold[ENV] fld,\n+                     &ast.fn_decl decl) -> ast.fn_decl {\n     let vec[ast.arg] inputs = vec();\n-    for (ast.arg a in f.inputs) {\n+    for (ast.arg a in decl.inputs) {\n         inputs += fold_arg(env, fld, a);\n     }\n-    auto output = fold_ty[ENV](env, fld, f.output);\n+    auto output = fold_ty[ENV](env, fld, decl.output);\n+    ret fld.fold_fn_decl(env, decl.effect, inputs, output);\n+}\n+\n+fn fold_fn[ENV](&ENV env, ast_fold[ENV] fld, &ast._fn f) -> ast._fn {\n+    auto decl = fold_fn_decl(env, fld, f.decl);\n+\n     auto body = fold_block[ENV](env, fld, f.body);\n \n-    ret fld.fold_fn(env, f.effect, f.is_iter, inputs, output, body);\n+    ret fld.fold_fn(env, decl, f.is_iter, body);\n }\n \n \n@@ -857,6 +871,10 @@ fn fold_native_item[ENV](&ENV env, ast_fold[ENV] fld,\n         case (ast.native_item_ty(?ident, ?id)) {\n             ret fld.fold_native_item_ty(env_, i.span, ident, id);\n         }\n+        case (ast.native_item_fn(?ident, ?fn_decl, ?ty_params, ?id)) {\n+            ret fld.fold_native_item_fn(env_, i.span, ident, fn_decl,\n+                                        ty_params, id);\n+        }\n     }\n }\n \n@@ -1144,6 +1162,13 @@ fn identity_fold_item_fn[ENV](&ENV e, &span sp, ident i,\n     ret @respan(sp, ast.item_fn(i, f, ty_params, id, a));\n }\n \n+fn identity_fold_native_item_fn[ENV](&ENV e, &span sp, ident i,\n+                                     &ast.fn_decl decl,\n+                                     vec[ast.ty_param] ty_params,\n+                                     def_id id) -> @native_item {\n+    ret @respan(sp, ast.native_item_fn(i, decl, ty_params, id));\n+}\n+\n fn identity_fold_item_mod[ENV](&ENV e, &span sp, ident i,\n                                &ast._mod m, def_id id) -> @item {\n     ret @respan(sp, ast.item_mod(i, m, id));\n@@ -1199,14 +1224,18 @@ fn identity_fold_block[ENV](&ENV e, &span sp, &ast.block_ blk) -> block {\n     ret respan(sp, blk);\n }\n \n+fn identity_fold_fn_decl[ENV](&ENV e,\n+                              ast.effect effect,\n+                              vec[arg] inputs,\n+                              @ty output) -> ast.fn_decl {\n+    ret rec(effect=effect, inputs=inputs, output=output);\n+}\n+\n fn identity_fold_fn[ENV](&ENV e,\n-                         ast.effect effect,\n+                         &fn_decl decl,\n                          bool is_iter,\n-                         vec[arg] inputs,\n-                         @ast.ty output,\n                          &block body) -> ast._fn {\n-    ret rec(effect=effect, is_iter=is_iter, inputs=inputs,\n-            output=output, body=body);\n+    ret rec(decl=decl, is_iter=is_iter, body=body);\n }\n \n fn identity_fold_mod[ENV](&ENV e, &ast._mod m) -> ast._mod {\n@@ -1343,6 +1372,8 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n \n          fold_item_const= bind identity_fold_item_const[ENV](_,_,_,_,_,_,_),\n          fold_item_fn   = bind identity_fold_item_fn[ENV](_,_,_,_,_,_,_),\n+         fold_native_item_fn =\n+             bind identity_fold_native_item_fn[ENV](_,_,_,_,_,_),\n          fold_item_mod  = bind identity_fold_item_mod[ENV](_,_,_,_,_),\n          fold_item_native_mod =\n              bind identity_fold_item_native_mod[ENV](_,_,_,_,_),\n@@ -1358,7 +1389,8 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n              bind identity_fold_view_item_import[ENV](_,_,_,_,_,_),\n \n          fold_block = bind identity_fold_block[ENV](_,_,_),\n-         fold_fn = bind identity_fold_fn[ENV](_,_,_,_,_,_),\n+         fold_fn = bind identity_fold_fn[ENV](_,_,_,_),\n+         fold_fn_decl = bind identity_fold_fn_decl[ENV](_,_,_,_),\n          fold_mod = bind identity_fold_mod[ENV](_,_),\n          fold_native_mod = bind identity_fold_native_mod[ENV](_,_),\n          fold_crate = bind identity_fold_crate[ENV](_,_,_),"}, {"sha": "2cfbcc83eac5a4b76bc3b6488ea341c932655bd6", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57bb9d809bb029caf7b38042a433153bb965e1fb/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57bb9d809bb029caf7b38042a433153bb965e1fb/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=57bb9d809bb029caf7b38042a433153bb965e1fb", "patch": "@@ -283,7 +283,7 @@ fn lookup_name_wrapped(&env e, ast.ident i) -> option.t[tup(@env, def_wrap)] {\n             case (scope_item(?it)) {\n                 alt (it.node) {\n                     case (ast.item_fn(_, ?f, ?ty_params, _, _)) {\n-                        for (ast.arg a in f.inputs) {\n+                        for (ast.arg a in f.decl.inputs) {\n                             if (_str.eq(a.ident, i)) {\n                                 auto t = ast.def_arg(a.id);\n                                 ret some(def_wrap_other(t));"}, {"sha": "22f4109fd103ade5648c8d238c6effcdd7a27432", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57bb9d809bb029caf7b38042a433153bb965e1fb/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57bb9d809bb029caf7b38042a433153bb965e1fb/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=57bb9d809bb029caf7b38042a433153bb965e1fb", "patch": "@@ -3553,10 +3553,10 @@ fn trans_fn(@crate_ctxt cx, &ast._fn f, ast.def_id fid,\n \n     auto fcx = new_fn_ctxt(cx, cx.path, llfndecl);\n     create_llargs_for_fn_args(fcx, ty_self, ret_ty_of_fn(ann),\n-                              f.inputs, ty_params);\n+                              f.decl.inputs, ty_params);\n     auto bcx = new_top_block_ctxt(fcx);\n \n-    copy_args_to_allocas(bcx, ty_self, f.inputs,\n+    copy_args_to_allocas(bcx, ty_self, f.decl.inputs,\n                          arg_tys_of_fn(ann));\n \n     alt (fcx.llself) {"}, {"sha": "5412f13135ede742f653ff5ac6133264875f14f2", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/57bb9d809bb029caf7b38042a433153bb965e1fb/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57bb9d809bb029caf7b38042a433153bb965e1fb/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=57bb9d809bb029caf7b38042a433153bb965e1fb", "patch": "@@ -285,8 +285,8 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n         auto get = bind getter(id_to_ty_item, item_to_ty, _);\n         auto convert = bind ast_ty_to_ty(get, _);\n         auto f = bind ty_of_arg(id_to_ty_item, item_to_ty, _);\n-        auto inputs = _vec.map[ast.arg,arg](f, m.node.meth.inputs);\n-        auto output = convert(m.node.meth.output);\n+        auto inputs = _vec.map[ast.arg,arg](f, m.node.meth.decl.inputs);\n+        auto output = convert(m.node.meth.decl.output);\n         ret rec(ident=m.node.ident, inputs=inputs, output=output);\n     }\n \n@@ -339,8 +339,9 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                 // TODO: handle ty-params\n \n                 auto f = bind ty_of_arg(id_to_ty_item, item_to_ty, _);\n-                auto input_tys = _vec.map[ast.arg,arg](f, fn_info.inputs);\n-                auto output_ty = convert(fn_info.output);\n+                auto input_tys = _vec.map[ast.arg,arg](f,\n+                                                       fn_info.decl.inputs);\n+                auto output_ty = convert(fn_info.decl.output);\n \n                 auto t_fn = plain_ty(ty.ty_fn(input_tys, output_ty));\n                 item_to_ty.insert(def_id, t_fn);\n@@ -1773,9 +1774,8 @@ fn check_const(&@crate_ctxt ccx, &span sp, ast.ident ident, @ast.ty t,\n     ret @fold.respan[ast.item_](sp, item);\n }\n \n-fn check_fn(&@crate_ctxt ccx, ast.effect effect,\n-            bool is_iter, vec[ast.arg] inputs,\n-            @ast.ty output, &ast.block body) -> ast._fn {\n+fn check_fn(&@crate_ctxt ccx, &ast.fn_decl decl,\n+            bool is_iter, &ast.block body) -> ast._fn {\n     auto local_ty_table = @common.new_def_hash[@ty.t]();\n \n     // FIXME: duplicate work: the item annotation already has the arg types\n@@ -1789,21 +1789,21 @@ fn check_fn(&@crate_ctxt ccx, ast.effect effect,\n     }\n \n     // Store the type of each argument in the table.\n-    for (ast.arg arg in inputs) {\n+    for (ast.arg arg in decl.inputs) {\n         auto input_ty = ast_ty_to_ty_crate(ccx, arg.ty);\n         local_ty_table.insert(arg.id, input_ty);\n     }\n \n-    let @fn_ctxt fcx = @rec(ret_ty = ast_ty_to_ty_crate(ccx, output),\n+    let @fn_ctxt fcx = @rec(ret_ty = ast_ty_to_ty_crate(ccx, decl.output),\n                             locals = local_ty_table,\n                             ccx = ccx);\n \n     // TODO: Make sure the type of the block agrees with the function type.\n     auto block_t = check_block(fcx, body);\n     auto block_wb = writeback(fcx, block_t);\n \n-    auto fn_t = rec(effect=effect, is_iter=is_iter,\n-                    inputs=inputs, output=output, body=block_wb);\n+     auto fn_t = rec(decl=decl, is_iter=is_iter,\n+                    body=block_wb);\n     ret fn_t;\n }\n \n@@ -1816,12 +1816,12 @@ fn check_item_fn(&@crate_ctxt ccx, &span sp, ast.ident ident, &ast._fn f,\n     // again here, we can extract them.\n \n     let vec[arg] inputs = vec();\n-    for (ast.arg arg in f.inputs) {\n+    for (ast.arg arg in f.decl.inputs) {\n         auto input_ty = ast_ty_to_ty_crate(ccx, arg.ty);\n         inputs += vec(rec(mode=arg.mode, ty=input_ty));\n     }\n \n-    auto output_ty = ast_ty_to_ty_crate(ccx, f.output);\n+    auto output_ty = ast_ty_to_ty_crate(ccx, f.decl.output);\n     auto fn_sty = ty.ty_fn(inputs, output_ty);\n     auto fn_ann = ast.ann_type(plain_ty(fn_sty));\n \n@@ -1854,7 +1854,7 @@ fn check_crate(session.session sess, @ast.crate crate) -> @ast.crate {\n     auto fld = fold.new_identity_fold[@crate_ctxt]();\n \n     fld = @rec(update_env_for_item = bind update_obj_fields(_, _),\n-               fold_fn      = bind check_fn(_,_,_,_,_,_),\n+               fold_fn      = bind check_fn(_,_,_,_),\n                fold_item_fn = bind check_item_fn(_,_,_,_,_,_,_)\n                with *fld);\n     ret fold.fold_crate[@crate_ctxt](ccx, fld, result._0);"}, {"sha": "a6df93f5d87e7ec2b9da2c1fb03044f07fb92c45", "filename": "src/test/run-pass/native2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57bb9d809bb029caf7b38042a433153bb965e1fb/src%2Ftest%2Frun-pass%2Fnative2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57bb9d809bb029caf7b38042a433153bb965e1fb/src%2Ftest%2Frun-pass%2Fnative2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnative2.rs?ref=57bb9d809bb029caf7b38042a433153bb965e1fb", "patch": "@@ -1,5 +1,6 @@\n native \"rust\" mod rustrt {\n     type vbuf;\n+    fn vec_buf[T](vec[T] v, uint offset) -> vbuf;\n }\n \n fn main(vec[str] args) {"}]}