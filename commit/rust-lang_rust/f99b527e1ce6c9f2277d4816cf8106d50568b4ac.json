{"sha": "f99b527e1ce6c9f2277d4816cf8106d50568b4ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5OWI1MjdlMWNlNmM5ZjIyNzdkNDgxNmNmODEwNmQ1MDU2OGI0YWM=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-08-30T14:35:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-30T14:35:58Z"}, "message": "Merge pull request #693 from bjorn3/abi_refactor\n\nAbi handling refactor", "tree": {"sha": "88cbecfbdd562beb49c4ea8f8fb978b2d97d5eb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88cbecfbdd562beb49c4ea8f8fb978b2d97d5eb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f99b527e1ce6c9f2277d4816cf8106d50568b4ac", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdaTROCRBK7hj4Ov3rIwAAdHIIAAQp14Up9HWNgvusfO+D30EH\n8LUpduIs7ly1vc3HxVzpgp6rI4iowJM1uYnIA4ADc+Ox6rxTnBeyRgsTTMpvkMkR\nFFv4sMRGrjqfPLXeORKyLngfyktnBGMwvXTM++KHzeo5urMSyR/QRnYIhy9V7Y4t\n8O/WjogK9NVpw7YBXibdEt9OntucYgwWEGJhR64UMNhbOll4C/nTDkzW03QAv0Zz\n5mOXOb8tU9AcyJ9X+IAI3vR8X3Qy5hxwqwvl2Jy2HcEYS+lZiyiX3IquhZADP+7/\nWXmcVBaTM77weT2XL4bELa4x2ncH36tfqnCxKqiTTtmwA0crTlRDWOMYU6jyB+o=\n=Csyx\n-----END PGP SIGNATURE-----\n", "payload": "tree 88cbecfbdd562beb49c4ea8f8fb978b2d97d5eb9\nparent b3311ed4d594418632411f17a95cbe7689ab471d\nparent 15b9834d7d37d601fd77db11f8852f9ceb0804d0\nauthor bjorn3 <bjorn3@users.noreply.github.com> 1567175758 +0200\ncommitter GitHub <noreply@github.com> 1567175758 +0200\n\nMerge pull request #693 from bjorn3/abi_refactor\n\nAbi handling refactor"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f99b527e1ce6c9f2277d4816cf8106d50568b4ac", "html_url": "https://github.com/rust-lang/rust/commit/f99b527e1ce6c9f2277d4816cf8106d50568b4ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f99b527e1ce6c9f2277d4816cf8106d50568b4ac/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3311ed4d594418632411f17a95cbe7689ab471d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3311ed4d594418632411f17a95cbe7689ab471d", "html_url": "https://github.com/rust-lang/rust/commit/b3311ed4d594418632411f17a95cbe7689ab471d"}, {"sha": "15b9834d7d37d601fd77db11f8852f9ceb0804d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/15b9834d7d37d601fd77db11f8852f9ceb0804d0", "html_url": "https://github.com/rust-lang/rust/commit/15b9834d7d37d601fd77db11f8852f9ceb0804d0"}], "stats": {"total": 865, "additions": 479, "deletions": 386}, "files": [{"sha": "5878e8548d9269d1180cbba739de6b1d5d05324e", "filename": "example/example.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f99b527e1ce6c9f2277d4816cf8106d50568b4ac/example%2Fexample.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f99b527e1ce6c9f2277d4816cf8106d50568b4ac/example%2Fexample.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fexample.rs?ref=f99b527e1ce6c9f2277d4816cf8106d50568b4ac", "patch": "@@ -202,3 +202,7 @@ fn get_sized_field_ref_from_unsized_type(u: &Unsized) -> &u8 {\n fn get_unsized_field_ref_from_unsized_type(u: &Unsized) -> &str {\n     &u.1\n }\n+\n+pub fn reuse_byref_argument_storage(a: (u8, u16, u32)) -> u8 {\n+    a.0\n+}"}, {"sha": "77649e40b19acf95c30eb472cbf9719edab286b7", "filename": "src/abi/comments.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/f99b527e1ce6c9f2277d4816cf8106d50568b4ac/src%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f99b527e1ce6c9f2277d4816cf8106d50568b4ac/src%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fcomments.rs?ref=f99b527e1ce6c9f2277d4816cf8106d50568b4ac", "patch": "@@ -0,0 +1,108 @@\n+use std::borrow::Cow;\n+\n+use rustc::mir;\n+\n+use crate::prelude::*;\n+use crate::abi::pass_mode::*;\n+\n+pub fn add_args_header_comment(fx: &mut FunctionCx<impl Backend>) {\n+    fx.add_global_comment(format!(\n+        \"kind  loc.idx   param    pass mode                            ty\"\n+    ));\n+}\n+\n+pub fn add_arg_comment<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n+    kind: &str,\n+    local: mir::Local,\n+    local_field: Option<usize>,\n+    params: EmptySinglePair<Value>,\n+    pass_mode: PassMode,\n+    ty: Ty<'tcx>,\n+) {\n+    let local_field = if let Some(local_field) = local_field {\n+        Cow::Owned(format!(\".{}\", local_field))\n+    } else {\n+        Cow::Borrowed(\"\")\n+    };\n+    let params = match params {\n+        Empty => Cow::Borrowed(\"-\"),\n+        Single(param) => Cow::Owned(format!(\"= {:?}\", param)),\n+        Pair(param_a, param_b) => Cow::Owned(format!(\"= {:?}, {:?}\", param_a, param_b)),\n+    };\n+    let pass_mode = format!(\"{:?}\", pass_mode);\n+    fx.add_global_comment(format!(\n+        \"{kind:5}{local:>3}{local_field:<5} {params:10} {pass_mode:36} {ty:?}\",\n+        kind = kind,\n+        local = format!(\"{:?}\", local),\n+        local_field = local_field,\n+        params = params,\n+        pass_mode = pass_mode,\n+        ty = ty,\n+    ));\n+}\n+\n+pub fn add_locals_header_comment(fx: &mut FunctionCx<impl Backend>) {\n+    fx.add_global_comment(String::new());\n+    fx.add_global_comment(format!(\n+        \"kind  local ty                   size  align (abi,pref)\"\n+    ));\n+}\n+\n+pub fn add_local_place_comments<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n+    place: CPlace<'tcx>,\n+    local: Local,\n+) {\n+    let TyLayout { ty, details } = place.layout();\n+    let ty::layout::LayoutDetails {\n+        size,\n+        align,\n+        abi: _,\n+        variants: _,\n+        fields: _,\n+        largest_niche: _,\n+    } = details;\n+    match *place.inner() {\n+        CPlaceInner::Var(var) => {\n+            assert_eq!(local, var);\n+            fx.add_global_comment(format!(\n+                \"ssa   {:5} {:20} {:4}b {}, {}\",\n+                format!(\"{:?}\", local),\n+                format!(\"{:?}\", ty),\n+                size.bytes(),\n+                align.abi.bytes(),\n+                align.pref.bytes(),\n+            ));\n+        }\n+        CPlaceInner::Stack(stack_slot) => fx.add_entity_comment(\n+            stack_slot,\n+            format!(\n+                \"{:?}: {:?} size={} align={},{}\",\n+                local,\n+                ty,\n+                size.bytes(),\n+                align.abi.bytes(),\n+                align.pref.bytes(),\n+            ),\n+        ),\n+        CPlaceInner::NoPlace => fx.add_global_comment(format!(\n+            \"zst   {:5} {:20} {:4}b {}, {}\",\n+            format!(\"{:?}\", local),\n+            format!(\"{:?}\", ty),\n+            size.bytes(),\n+            align.abi.bytes(),\n+            align.pref.bytes(),\n+        )),\n+        CPlaceInner::Addr(addr, None) => fx.add_global_comment(format!(\n+            \"reuse {:5} {:20} {:4}b {}, {}              storage={}\",\n+            format!(\"{:?}\", local),\n+            format!(\"{:?}\", ty),\n+            size.bytes(),\n+            align.abi.bytes(),\n+            align.pref.bytes(),\n+            addr,\n+        )),\n+        CPlaceInner::Addr(_, Some(_)) => unreachable!(),\n+    }\n+}"}, {"sha": "452776947028c4e3cbf54791d4577f89a2e2d416", "filename": "src/abi/mod.rs", "status": "renamed", "additions": 68, "deletions": 386, "changes": 454, "blob_url": "https://github.com/rust-lang/rust/blob/f99b527e1ce6c9f2277d4816cf8106d50568b4ac/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f99b527e1ce6c9f2277d4816cf8106d50568b4ac/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=f99b527e1ce6c9f2277d4816cf8106d50568b4ac", "patch": "@@ -1,152 +1,14 @@\n-use std::borrow::Cow;\n+#[cfg(debug_assertions)]\n+mod comments;\n+mod returning;\n+mod pass_mode;\n \n-use rustc::ty::layout::{FloatTy, Integer, Primitive, Scalar};\n use rustc_target::spec::abi::Abi;\n \n use crate::prelude::*;\n+use self::pass_mode::*;\n \n-#[derive(Copy, Clone, Debug)]\n-enum PassMode {\n-    NoPass,\n-    ByVal(Type),\n-    ByValPair(Type, Type),\n-    ByRef,\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-enum EmptySinglePair<T> {\n-    Empty,\n-    Single(T),\n-    Pair(T, T),\n-}\n-\n-impl<T> EmptySinglePair<T> {\n-    fn into_iter(self) -> EmptySinglePairIter<T> {\n-        EmptySinglePairIter(self)\n-    }\n-\n-    fn map<U>(self, mut f: impl FnMut(T) -> U) -> EmptySinglePair<U> {\n-        match self {\n-            Empty => Empty,\n-            Single(v) => Single(f(v)),\n-            Pair(a, b) => Pair(f(a), f(b)),\n-        }\n-    }\n-}\n-\n-struct EmptySinglePairIter<T>(EmptySinglePair<T>);\n-\n-impl<T> Iterator for EmptySinglePairIter<T> {\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        match std::mem::replace(&mut self.0, Empty) {\n-            Empty => None,\n-            Single(v) => Some(v),\n-            Pair(a, b) => {\n-                self.0 = Single(b);\n-                Some(a)\n-            }\n-        }\n-    }\n-}\n-\n-impl<T: std::fmt::Debug> EmptySinglePair<T> {\n-    fn assert_single(self) -> T {\n-        match self {\n-            Single(v) => v,\n-            _ => panic!(\"Called assert_single on {:?}\", self)\n-        }\n-    }\n-\n-    fn assert_pair(self) -> (T, T) {\n-        match self {\n-            Pair(a, b) => (a, b),\n-            _ => panic!(\"Called assert_pair on {:?}\", self)\n-        }\n-    }\n-}\n-\n-use EmptySinglePair::*;\n-\n-impl PassMode {\n-    fn get_param_ty(self, fx: &FunctionCx<impl Backend>) -> EmptySinglePair<Type> {\n-        match self {\n-            PassMode::NoPass => Empty,\n-            PassMode::ByVal(clif_type) => Single(clif_type),\n-            PassMode::ByValPair(a, b) => Pair(a, b),\n-            PassMode::ByRef => Single(fx.pointer_type),\n-        }\n-    }\n-}\n-\n-pub fn scalar_to_clif_type(tcx: TyCtxt, scalar: Scalar) -> Type {\n-    match scalar.value {\n-        Primitive::Int(int, _sign) => match int {\n-            Integer::I8 => types::I8,\n-            Integer::I16 => types::I16,\n-            Integer::I32 => types::I32,\n-            Integer::I64 => types::I64,\n-            Integer::I128 => types::I128,\n-        },\n-        Primitive::Float(flt) => match flt {\n-            FloatTy::F32 => types::F32,\n-            FloatTy::F64 => types::F64,\n-        },\n-        Primitive::Pointer => pointer_ty(tcx),\n-    }\n-}\n-\n-fn get_pass_mode<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    layout: TyLayout<'tcx>,\n-) -> PassMode {\n-    assert!(!layout.is_unsized());\n-\n-    if layout.is_zst() {\n-        // WARNING zst arguments must never be passed, as that will break CastKind::ClosureFnPointer\n-        PassMode::NoPass\n-    } else {\n-        match &layout.abi {\n-            layout::Abi::Uninhabited => PassMode::NoPass,\n-            layout::Abi::Scalar(scalar) => {\n-                PassMode::ByVal(scalar_to_clif_type(tcx, scalar.clone()))\n-            }\n-            layout::Abi::ScalarPair(a, b) => {\n-                let a = scalar_to_clif_type(tcx, a.clone());\n-                let b = scalar_to_clif_type(tcx, b.clone());\n-                if a == types::I128 && b == types::I128 {\n-                    // Returning (i128, i128) by-val-pair would take 4 regs, while only 3 are\n-                    // available on x86_64. Cranelift gets confused when too many return params\n-                    // are used.\n-                    PassMode::ByRef\n-                } else {\n-                    PassMode::ByValPair(a, b)\n-                }\n-            }\n-\n-            // FIXME implement Vector Abi in a cg_llvm compatible way\n-            layout::Abi::Vector { .. } => PassMode::ByRef,\n-\n-            layout::Abi::Aggregate { .. } => PassMode::ByRef,\n-        }\n-    }\n-}\n-\n-fn adjust_arg_for_abi<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n-    arg: CValue<'tcx>,\n-) -> EmptySinglePair<Value> {\n-    match get_pass_mode(fx.tcx, arg.layout()) {\n-        PassMode::NoPass => Empty,\n-        PassMode::ByVal(_) => Single(arg.load_scalar(fx)),\n-        PassMode::ByValPair(_, _) => {\n-            let (a, b) = arg.load_scalar_pair(fx);\n-            Pair(a, b)\n-        }\n-        PassMode::ByRef => Single(arg.force_stack(fx)),\n-    }\n-}\n+pub use self::returning::codegen_return;\n \n fn clif_sig_from_fn_sig<'tcx>(tcx: TyCtxt<'tcx>, sig: FnSig<'tcx>, is_vtable_fn: bool) -> Signature {\n     let abi = match sig.abi {\n@@ -187,12 +49,7 @@ fn clif_sig_from_fn_sig<'tcx>(tcx: TyCtxt<'tcx>, sig: FnSig<'tcx>, is_vtable_fn:\n                 // See https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src/librustc/ty/layout.rs#L2519-L2572 for more info\n                 layout = tcx.layout_of(ParamEnv::reveal_all().and(tcx.mk_mut_ptr(tcx.mk_unit()))).unwrap();\n             }\n-            match get_pass_mode(tcx, layout) {\n-                PassMode::NoPass => Empty,\n-                PassMode::ByVal(clif_ty) => Single(clif_ty),\n-                PassMode::ByValPair(clif_ty_a, clif_ty_b) => Pair(clif_ty_a, clif_ty_b),\n-                PassMode::ByRef => Single(pointer_ty(tcx)),\n-            }.into_iter()\n+            get_pass_mode(tcx, layout).get_param_ty(tcx).into_iter()\n         }).flatten();\n \n     let (params, returns) = match get_pass_mode(tcx, tcx.layout_of(ParamEnv::reveal_all().and(output)).unwrap()) {\n@@ -336,47 +193,6 @@ impl<'tcx, B: Backend + 'static> FunctionCx<'_, 'tcx, B> {\n     }\n }\n \n-#[cfg(debug_assertions)]\n-fn add_arg_comment<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n-    msg: &str,\n-    local: mir::Local,\n-    local_field: Option<usize>,\n-    params: EmptySinglePair<Value>,\n-    pass_mode: PassMode,\n-    ssa: crate::analyze::Flags,\n-    ty: Ty<'tcx>,\n-) {\n-    let local_field = if let Some(local_field) = local_field {\n-        Cow::Owned(format!(\".{}\", local_field))\n-    } else {\n-        Cow::Borrowed(\"\")\n-    };\n-    let params = match params {\n-        Empty => Cow::Borrowed(\"-\"),\n-        Single(param) => Cow::Owned(format!(\"= {:?}\", param)),\n-        Pair(param_a, param_b) => Cow::Owned(format!(\"= {:?}, {:?}\", param_a, param_b)),\n-    };\n-    let pass_mode = format!(\"{:?}\", pass_mode);\n-    fx.add_global_comment(format!(\n-        \"{msg:5} {local:>3}{local_field:<5} {params:10} {pass_mode:36} {ssa:10} {ty:?}\",\n-        msg = msg,\n-        local = format!(\"{:?}\", local),\n-        local_field = local_field,\n-        params = params,\n-        pass_mode = pass_mode,\n-        ssa = format!(\"{:?}\", ssa),\n-        ty = ty,\n-    ));\n-}\n-\n-#[cfg(debug_assertions)]\n-fn add_local_header_comment(fx: &mut FunctionCx<impl Backend>) {\n-    fx.add_global_comment(format!(\n-        \"msg   loc.idx    param    pass mode                            ssa flags  ty\"\n-    ));\n-}\n-\n fn local_place<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n     local: Local,\n@@ -386,126 +202,27 @@ fn local_place<'tcx>(\n     let place = if is_ssa {\n         CPlace::new_var(fx, local, layout)\n     } else {\n-        let place = CPlace::new_stack_slot(fx, layout.ty);\n-\n-        #[cfg(debug_assertions)]\n-        {\n-            let TyLayout { ty, details } = layout;\n-            let ty::layout::LayoutDetails {\n-                size,\n-                align,\n-                abi: _,\n-                variants: _,\n-                fields: _,\n-                largest_niche: _,\n-            } = details;\n-            match *place.inner() {\n-                CPlaceInner::Stack(stack_slot) => fx.add_entity_comment(\n-                    stack_slot,\n-                    format!(\n-                        \"{:?}: {:?} size={} align={},{}\",\n-                        local,\n-                        ty,\n-                        size.bytes(),\n-                        align.abi.bytes(),\n-                        align.pref.bytes(),\n-                    ),\n-                ),\n-                CPlaceInner::NoPlace => fx.add_global_comment(format!(\n-                    \"zst    {:?}: {:?} size={} align={}, {}\",\n-                    local,\n-                    ty,\n-                    size.bytes(),\n-                    align.abi.bytes(),\n-                    align.pref.bytes(),\n-                )),\n-                _ => unreachable!(),\n-            }\n-        }\n-\n-        place\n+        CPlace::new_stack_slot(fx, layout.ty)\n     };\n \n+    #[cfg(debug_assertions)]\n+    self::comments::add_local_place_comments(fx, place, local);\n+\n     let prev_place = fx.local_map.insert(local, place);\n     debug_assert!(prev_place.is_none());\n     fx.local_map[&local]\n }\n \n-fn cvalue_for_param<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n-    start_ebb: Ebb,\n-    local: mir::Local,\n-    local_field: Option<usize>,\n-    arg_ty: Ty<'tcx>,\n-    ssa_flags: crate::analyze::Flags,\n-) -> Option<CValue<'tcx>> {\n-    let layout = fx.layout_of(arg_ty);\n-    let pass_mode = get_pass_mode(fx.tcx, fx.layout_of(arg_ty));\n-\n-    if let PassMode::NoPass = pass_mode {\n-        return None;\n-    }\n-\n-    let clif_types = pass_mode.get_param_ty(fx);\n-    let ebb_params = clif_types.map(|t| fx.bcx.append_ebb_param(start_ebb, t));\n-\n-    #[cfg(debug_assertions)]\n-    add_arg_comment(\n-        fx,\n-        \"arg\",\n-        local,\n-        local_field,\n-        ebb_params,\n-        pass_mode,\n-        ssa_flags,\n-        arg_ty,\n-    );\n-\n-    match pass_mode {\n-        PassMode::NoPass => unreachable!(),\n-        PassMode::ByVal(_) => Some(CValue::by_val(ebb_params.assert_single(), layout)),\n-        PassMode::ByValPair(_, _) => {\n-            let (a, b) = ebb_params.assert_pair();\n-            Some(CValue::by_val_pair(a, b, layout))\n-        }\n-        PassMode::ByRef => Some(CValue::by_ref(ebb_params.assert_single(), layout)),\n-    }\n-}\n-\n pub fn codegen_fn_prelude(\n     fx: &mut FunctionCx<'_, '_, impl Backend>,\n     start_ebb: Ebb,\n ) {\n     let ssa_analyzed = crate::analyze::analyze(fx);\n \n     #[cfg(debug_assertions)]\n-    fx.add_global_comment(format!(\"ssa {:?}\", ssa_analyzed));\n-\n-    let ret_layout = fx.return_layout();\n-    let output_pass_mode = get_pass_mode(fx.tcx, fx.return_layout());\n-    let ret_param = match output_pass_mode {\n-        PassMode::NoPass | PassMode::ByVal(_) | PassMode::ByValPair(_, _) => None,\n-        PassMode::ByRef => Some(fx.bcx.append_ebb_param(start_ebb, fx.pointer_type)),\n-    };\n+    self::comments::add_args_header_comment(fx);\n \n-    #[cfg(debug_assertions)]\n-    {\n-        add_local_header_comment(fx);\n-        let ret_param = match ret_param {\n-            Some(param) => Single(param),\n-            None => Empty,\n-        };\n-        add_arg_comment(\n-            fx,\n-            \"ret\",\n-            RETURN_PLACE,\n-            None,\n-            ret_param,\n-            output_pass_mode,\n-            ssa_analyzed[&RETURN_PLACE],\n-            ret_layout.ty,\n-        );\n-    }\n+    self::returning::codegen_return_param(fx, &ssa_analyzed, start_ebb);\n \n     // None means pass_mode == NoPass\n     enum ArgKind<'tcx> {\n@@ -539,42 +256,23 @@ pub fn codegen_fn_prelude(\n                         local,\n                         Some(i),\n                         arg_ty,\n-                        ssa_analyzed[&local],\n                     );\n                     params.push(param);\n                 }\n \n                 (local, ArgKind::Spread(params), arg_ty)\n             } else {\n                 let param =\n-                    cvalue_for_param(fx, start_ebb, local, None, arg_ty, ssa_analyzed[&local]);\n+                    cvalue_for_param(fx, start_ebb, local, None, arg_ty);\n                 (local, ArgKind::Normal(param), arg_ty)\n             }\n         })\n         .collect::<Vec<(Local, ArgKind, Ty)>>();\n \n     fx.bcx.switch_to_block(start_ebb);\n \n-    match output_pass_mode {\n-        PassMode::NoPass => {\n-            fx.local_map\n-                .insert(RETURN_PLACE, CPlace::no_place(ret_layout));\n-        }\n-        PassMode::ByVal(_) | PassMode::ByValPair(_, _) => {\n-            let is_ssa = !ssa_analyzed\n-                .get(&RETURN_PLACE)\n-                .unwrap()\n-                .contains(crate::analyze::Flags::NOT_SSA);\n-\n-            local_place(fx, RETURN_PLACE, ret_layout, is_ssa);\n-        }\n-        PassMode::ByRef => {\n-            fx.local_map.insert(\n-                RETURN_PLACE,\n-                CPlace::for_addr(ret_param.unwrap(), ret_layout),\n-            );\n-        }\n-    }\n+    #[cfg(debug_assertions)]\n+    self::comments::add_locals_header_comment(fx);\n \n     for (local, arg_kind, ty) in func_params {\n         let layout = fx.layout_of(ty);\n@@ -584,6 +282,34 @@ pub fn codegen_fn_prelude(\n             .unwrap()\n             .contains(crate::analyze::Flags::NOT_SSA);\n \n+        match arg_kind {\n+            ArgKind::Normal(Some(val)) => {\n+                if let Some(addr) = val.try_to_addr() {\n+                    let local_decl = &fx.mir.local_decls[local];\n+                    //                             v this ! is important\n+                    let internally_mutable = !val.layout().ty.is_freeze(\n+                        fx.tcx,\n+                        ParamEnv::reveal_all(),\n+                        local_decl.source_info.span,\n+                    );\n+                    if local_decl.mutability == mir::Mutability::Not && internally_mutable {\n+                        // We wont mutate this argument, so it is fine to borrow the backing storage\n+                        // of this argument, to prevent a copy.\n+\n+                        let place = CPlace::for_addr(addr, val.layout());\n+\n+                        #[cfg(debug_assertions)]\n+                        self::comments::add_local_place_comments(fx, place, local);\n+\n+                        let prev_place = fx.local_map.insert(local, place);\n+                        debug_assert!(prev_place.is_none());\n+                        continue;\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+\n         let place = local_place(fx, local, layout, is_ssa);\n \n         match arg_kind {\n@@ -706,18 +432,6 @@ fn codegen_call_inner<'tcx>(\n ) {\n     let fn_sig = fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &fn_ty.fn_sig(fx.tcx));\n \n-    let ret_layout = fx.layout_of(fn_sig.output());\n-\n-    let output_pass_mode = get_pass_mode(fx.tcx, fx.layout_of(fn_sig.output()));\n-    let return_ptr = match output_pass_mode {\n-        PassMode::NoPass => None,\n-        PassMode::ByRef => match ret_place {\n-            Some(ret_place) => Some(ret_place.to_addr(fx)),\n-            None => Some(fx.bcx.ins().iconst(fx.pointer_type, 43)),\n-        },\n-        PassMode::ByVal(_) | PassMode::ByValPair(_, _) => None,\n-    };\n-\n     let instance = match fn_ty.sty {\n         ty::FnDef(def_id, substs) => {\n             Some(Instance::resolve(fx.tcx, ParamEnv::reveal_all(), def_id, substs).unwrap())\n@@ -766,26 +480,30 @@ fn codegen_call_inner<'tcx>(\n         }\n     };\n \n-    let call_args: Vec<Value> = return_ptr\n-        .into_iter()\n-        .chain(first_arg.into_iter())\n-        .chain(\n-            args.into_iter()\n-                .skip(1)\n-                .map(|arg| adjust_arg_for_abi(fx, arg).into_iter())\n-                .flatten(),\n-        )\n-        .collect::<Vec<_>>();\n-\n-    let call_inst = if let Some(func_ref) = func_ref {\n-        let sig = fx\n-            .bcx\n-            .import_signature(clif_sig_from_fn_sig(fx.tcx, fn_sig, is_virtual_call));\n-        fx.bcx.ins().call_indirect(sig, func_ref, &call_args)\n-    } else {\n-        let func_ref = fx.get_function_ref(instance.expect(\"non-indirect call on non-FnDef type\"));\n-        fx.bcx.ins().call(func_ref, &call_args)\n-    };\n+    let (call_inst, call_args) = self::returning::codegen_with_call_return_arg(fx, fn_sig, ret_place, |fx, return_ptr| {\n+        let call_args: Vec<Value> = return_ptr\n+            .into_iter()\n+            .chain(first_arg.into_iter())\n+            .chain(\n+                args.into_iter()\n+                    .skip(1)\n+                    .map(|arg| adjust_arg_for_abi(fx, arg).into_iter())\n+                    .flatten(),\n+            )\n+            .collect::<Vec<_>>();\n+\n+        let call_inst = if let Some(func_ref) = func_ref {\n+            let sig = fx\n+                .bcx\n+                .import_signature(clif_sig_from_fn_sig(fx.tcx, fn_sig, is_virtual_call));\n+            fx.bcx.ins().call_indirect(sig, func_ref, &call_args)\n+        } else {\n+            let func_ref = fx.get_function_ref(instance.expect(\"non-indirect call on non-FnDef type\"));\n+            fx.bcx.ins().call(func_ref, &call_args)\n+        };\n+\n+        (call_inst, call_args)\n+    });\n \n     // FIXME find a cleaner way to support varargs\n     if fn_sig.c_variadic {\n@@ -806,24 +524,6 @@ fn codegen_call_inner<'tcx>(\n             .collect::<Vec<AbiParam>>();\n         fx.bcx.func.dfg.signatures[sig_ref].params = abi_params;\n     }\n-\n-    match output_pass_mode {\n-        PassMode::NoPass => {}\n-        PassMode::ByVal(_) => {\n-            if let Some(ret_place) = ret_place {\n-                let ret_val = fx.bcx.inst_results(call_inst)[0];\n-                ret_place.write_cvalue(fx, CValue::by_val(ret_val, ret_layout));\n-            }\n-        }\n-        PassMode::ByValPair(_, _) => {\n-            if let Some(ret_place) = ret_place {\n-                let ret_val_a = fx.bcx.inst_results(call_inst)[0];\n-                let ret_val_b = fx.bcx.inst_results(call_inst)[1];\n-                ret_place.write_cvalue(fx, CValue::by_val_pair(ret_val_a, ret_val_b, ret_layout));\n-            }\n-        }\n-        PassMode::ByRef => {}\n-    }\n }\n \n pub fn codegen_drop<'tcx>(\n@@ -875,21 +575,3 @@ pub fn codegen_drop<'tcx>(\n         }\n     }\n }\n-\n-pub fn codegen_return(fx: &mut FunctionCx<impl Backend>) {\n-    match get_pass_mode(fx.tcx, fx.return_layout()) {\n-        PassMode::NoPass | PassMode::ByRef => {\n-            fx.bcx.ins().return_(&[]);\n-        }\n-        PassMode::ByVal(_) => {\n-            let place = fx.get_local_place(RETURN_PLACE);\n-            let ret_val = place.to_cvalue(fx).load_scalar(fx);\n-            fx.bcx.ins().return_(&[ret_val]);\n-        }\n-        PassMode::ByValPair(_, _) => {\n-            let place = fx.get_local_place(RETURN_PLACE);\n-            let (ret_val_a, ret_val_b) = place.to_cvalue(fx).load_scalar_pair(fx);\n-            fx.bcx.ins().return_(&[ret_val_a, ret_val_b]);\n-        }\n-    }\n-}", "previous_filename": "src/abi.rs"}, {"sha": "411ca23a1f7896fb0fca566e4454457125e9e704", "filename": "src/abi/pass_mode.rs", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/f99b527e1ce6c9f2277d4816cf8106d50568b4ac/src%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f99b527e1ce6c9f2277d4816cf8106d50568b4ac/src%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fpass_mode.rs?ref=f99b527e1ce6c9f2277d4816cf8106d50568b4ac", "patch": "@@ -0,0 +1,166 @@\n+use crate::prelude::*;\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum PassMode {\n+    NoPass,\n+    ByVal(Type),\n+    ByValPair(Type, Type),\n+    ByRef,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum EmptySinglePair<T> {\n+    Empty,\n+    Single(T),\n+    Pair(T, T),\n+}\n+\n+impl<T> EmptySinglePair<T> {\n+    pub fn into_iter(self) -> EmptySinglePairIter<T> {\n+        EmptySinglePairIter(self)\n+    }\n+\n+    pub fn map<U>(self, mut f: impl FnMut(T) -> U) -> EmptySinglePair<U> {\n+        match self {\n+            Empty => Empty,\n+            Single(v) => Single(f(v)),\n+            Pair(a, b) => Pair(f(a), f(b)),\n+        }\n+    }\n+}\n+\n+pub struct EmptySinglePairIter<T>(EmptySinglePair<T>);\n+\n+impl<T> Iterator for EmptySinglePairIter<T> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        match std::mem::replace(&mut self.0, Empty) {\n+            Empty => None,\n+            Single(v) => Some(v),\n+            Pair(a, b) => {\n+                self.0 = Single(b);\n+                Some(a)\n+            }\n+        }\n+    }\n+}\n+\n+impl<T: std::fmt::Debug> EmptySinglePair<T> {\n+    pub fn assert_single(self) -> T {\n+        match self {\n+            Single(v) => v,\n+            _ => panic!(\"Called assert_single on {:?}\", self)\n+        }\n+    }\n+\n+    pub fn assert_pair(self) -> (T, T) {\n+        match self {\n+            Pair(a, b) => (a, b),\n+            _ => panic!(\"Called assert_pair on {:?}\", self)\n+        }\n+    }\n+}\n+\n+pub use EmptySinglePair::*;\n+\n+impl PassMode {\n+    pub fn get_param_ty(self, tcx: TyCtxt<'_>) -> EmptySinglePair<Type> {\n+        match self {\n+            PassMode::NoPass => Empty,\n+            PassMode::ByVal(clif_type) => Single(clif_type),\n+            PassMode::ByValPair(a, b) => Pair(a, b),\n+            PassMode::ByRef => Single(pointer_ty(tcx)),\n+        }\n+    }\n+}\n+\n+pub fn get_pass_mode<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    layout: TyLayout<'tcx>,\n+) -> PassMode {\n+    assert!(!layout.is_unsized());\n+\n+    if layout.is_zst() {\n+        // WARNING zst arguments must never be passed, as that will break CastKind::ClosureFnPointer\n+        PassMode::NoPass\n+    } else {\n+        match &layout.abi {\n+            layout::Abi::Uninhabited => PassMode::NoPass,\n+            layout::Abi::Scalar(scalar) => {\n+                PassMode::ByVal(scalar_to_clif_type(tcx, scalar.clone()))\n+            }\n+            layout::Abi::ScalarPair(a, b) => {\n+                let a = scalar_to_clif_type(tcx, a.clone());\n+                let b = scalar_to_clif_type(tcx, b.clone());\n+                if a == types::I128 && b == types::I128 {\n+                    // Returning (i128, i128) by-val-pair would take 4 regs, while only 3 are\n+                    // available on x86_64. Cranelift gets confused when too many return params\n+                    // are used.\n+                    PassMode::ByRef\n+                } else {\n+                    PassMode::ByValPair(a, b)\n+                }\n+            }\n+\n+            // FIXME implement Vector Abi in a cg_llvm compatible way\n+            layout::Abi::Vector { .. } => PassMode::ByRef,\n+\n+            layout::Abi::Aggregate { .. } => PassMode::ByRef,\n+        }\n+    }\n+}\n+\n+pub fn adjust_arg_for_abi<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n+    arg: CValue<'tcx>,\n+) -> EmptySinglePair<Value> {\n+    match get_pass_mode(fx.tcx, arg.layout()) {\n+        PassMode::NoPass => Empty,\n+        PassMode::ByVal(_) => Single(arg.load_scalar(fx)),\n+        PassMode::ByValPair(_, _) => {\n+            let (a, b) = arg.load_scalar_pair(fx);\n+            Pair(a, b)\n+        }\n+        PassMode::ByRef => Single(arg.force_stack(fx)),\n+    }\n+}\n+\n+pub fn cvalue_for_param<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n+    start_ebb: Ebb,\n+    local: mir::Local,\n+    local_field: Option<usize>,\n+    arg_ty: Ty<'tcx>,\n+) -> Option<CValue<'tcx>> {\n+    let layout = fx.layout_of(arg_ty);\n+    let pass_mode = get_pass_mode(fx.tcx, fx.layout_of(arg_ty));\n+\n+    if let PassMode::NoPass = pass_mode {\n+        return None;\n+    }\n+\n+    let clif_types = pass_mode.get_param_ty(fx.tcx);\n+    let ebb_params = clif_types.map(|t| fx.bcx.append_ebb_param(start_ebb, t));\n+\n+    #[cfg(debug_assertions)]\n+    crate::abi::comments::add_arg_comment(\n+        fx,\n+        \"arg\",\n+        local,\n+        local_field,\n+        ebb_params,\n+        pass_mode,\n+        arg_ty,\n+    );\n+\n+    match pass_mode {\n+        PassMode::NoPass => unreachable!(),\n+        PassMode::ByVal(_) => Some(CValue::by_val(ebb_params.assert_single(), layout)),\n+        PassMode::ByValPair(_, _) => {\n+            let (a, b) = ebb_params.assert_pair();\n+            Some(CValue::by_val_pair(a, b, layout))\n+        }\n+        PassMode::ByRef => Some(CValue::by_ref(ebb_params.assert_single(), layout)),\n+    }\n+}"}, {"sha": "3d34dbf06e269b35ad35628981627002e7a5b7f1", "filename": "src/abi/returning.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/f99b527e1ce6c9f2277d4816cf8106d50568b4ac/src%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f99b527e1ce6c9f2277d4816cf8106d50568b4ac/src%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Freturning.rs?ref=f99b527e1ce6c9f2277d4816cf8106d50568b4ac", "patch": "@@ -0,0 +1,108 @@\n+use crate::prelude::*;\n+use crate::abi::pass_mode::*;\n+\n+pub fn codegen_return_param(\n+    fx: &mut FunctionCx<impl Backend>,\n+    ssa_analyzed: &HashMap<Local, crate::analyze::Flags>,\n+    start_ebb: Ebb,\n+) {\n+    let ret_layout = fx.return_layout();\n+    let output_pass_mode = get_pass_mode(fx.tcx, fx.return_layout());\n+\n+    let ret_param = match output_pass_mode {\n+        PassMode::NoPass => {\n+            fx.local_map\n+                .insert(RETURN_PLACE, CPlace::no_place(ret_layout));\n+            Empty\n+        }\n+        PassMode::ByVal(_) | PassMode::ByValPair(_, _) => {\n+            let is_ssa = !ssa_analyzed\n+                .get(&RETURN_PLACE)\n+                .unwrap()\n+                .contains(crate::analyze::Flags::NOT_SSA);\n+\n+            super::local_place(fx, RETURN_PLACE, ret_layout, is_ssa);\n+\n+            Empty\n+        }\n+        PassMode::ByRef => {\n+            let ret_param = fx.bcx.append_ebb_param(start_ebb, fx.pointer_type);\n+            fx.local_map.insert(\n+                RETURN_PLACE,\n+                CPlace::for_addr(ret_param, ret_layout),\n+            );\n+\n+            Single(ret_param)\n+        }\n+    };\n+\n+    #[cfg(debug_assertions)]\n+    crate::abi::comments::add_arg_comment(\n+        fx,\n+        \"ret\",\n+        RETURN_PLACE,\n+        None,\n+        ret_param,\n+        output_pass_mode,\n+        ret_layout.ty,\n+    );\n+}\n+\n+pub fn codegen_with_call_return_arg<'tcx, B: Backend, T>(\n+    fx: &mut FunctionCx<'_, 'tcx, B>,\n+    fn_sig: FnSig<'tcx>,\n+    ret_place: Option<CPlace<'tcx>>,\n+    f: impl FnOnce(&mut FunctionCx<'_, 'tcx, B>, Option<Value>) -> (Inst, T),\n+) -> (Inst, T) {\n+    let ret_layout = fx.layout_of(fn_sig.output());\n+\n+    let output_pass_mode = get_pass_mode(fx.tcx, ret_layout);\n+    let return_ptr = match output_pass_mode {\n+        PassMode::NoPass => None,\n+        PassMode::ByRef => match ret_place {\n+            Some(ret_place) => Some(ret_place.to_addr(fx)),\n+            None => Some(fx.bcx.ins().iconst(fx.pointer_type, 43)),\n+        },\n+        PassMode::ByVal(_) | PassMode::ByValPair(_, _) => None,\n+    };\n+\n+    let (call_inst, meta) = f(fx, return_ptr);\n+\n+    match output_pass_mode {\n+        PassMode::NoPass => {}\n+        PassMode::ByVal(_) => {\n+            if let Some(ret_place) = ret_place {\n+                let ret_val = fx.bcx.inst_results(call_inst)[0];\n+                ret_place.write_cvalue(fx, CValue::by_val(ret_val, ret_layout));\n+            }\n+        }\n+        PassMode::ByValPair(_, _) => {\n+            if let Some(ret_place) = ret_place {\n+                let ret_val_a = fx.bcx.inst_results(call_inst)[0];\n+                let ret_val_b = fx.bcx.inst_results(call_inst)[1];\n+                ret_place.write_cvalue(fx, CValue::by_val_pair(ret_val_a, ret_val_b, ret_layout));\n+            }\n+        }\n+        PassMode::ByRef => {}\n+    }\n+\n+    (call_inst, meta)\n+}\n+\n+pub fn codegen_return(fx: &mut FunctionCx<impl Backend>) {\n+    match get_pass_mode(fx.tcx, fx.return_layout()) {\n+        PassMode::NoPass | PassMode::ByRef => {\n+            fx.bcx.ins().return_(&[]);\n+        }\n+        PassMode::ByVal(_) => {\n+            let place = fx.get_local_place(RETURN_PLACE);\n+            let ret_val = place.to_cvalue(fx).load_scalar(fx);\n+            fx.bcx.ins().return_(&[ret_val]);\n+        }\n+        PassMode::ByValPair(_, _) => {\n+            let place = fx.get_local_place(RETURN_PLACE);\n+            let (ret_val_a, ret_val_b) = place.to_cvalue(fx).load_scalar_pair(fx);\n+            fx.bcx.ins().return_(&[ret_val_a, ret_val_b]);\n+        }\n+    }\n+}"}, {"sha": "6ed979449fe63d8390376e11938399530f8dc562", "filename": "src/common.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f99b527e1ce6c9f2277d4816cf8106d50568b4ac/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f99b527e1ce6c9f2277d4816cf8106d50568b4ac/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=f99b527e1ce6c9f2277d4816cf8106d50568b4ac", "patch": "@@ -1,3 +1,4 @@\n+use rustc::ty::layout::{FloatTy, Integer, Primitive};\n use rustc_target::spec::{HasTargetSpec, Target};\n \n use cranelift::codegen::ir::{Opcode, InstructionData, ValueDef};\n@@ -17,6 +18,23 @@ pub fn pointer_ty(tcx: TyCtxt) -> types::Type {\n     }\n }\n \n+pub fn scalar_to_clif_type(tcx: TyCtxt, scalar: Scalar) -> Type {\n+    match scalar.value {\n+        Primitive::Int(int, _sign) => match int {\n+            Integer::I8 => types::I8,\n+            Integer::I16 => types::I16,\n+            Integer::I32 => types::I32,\n+            Integer::I64 => types::I64,\n+            Integer::I128 => types::I128,\n+        },\n+        Primitive::Float(flt) => match flt {\n+            FloatTy::F32 => types::F32,\n+            FloatTy::F64 => types::F64,\n+        },\n+        Primitive::Pointer => pointer_ty(tcx),\n+    }\n+}\n+\n pub fn clif_type_from_ty<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,"}, {"sha": "b1da6e2b4ea0c1a4af538675162c57d9a059fa07", "filename": "src/value_and_place.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f99b527e1ce6c9f2277d4816cf8106d50568b4ac/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f99b527e1ce6c9f2277d4816cf8106d50568b4ac/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=f99b527e1ce6c9f2277d4816cf8106d50568b4ac", "patch": "@@ -63,6 +63,13 @@ impl<'tcx> CValue<'tcx> {\n         }\n     }\n \n+    pub fn try_to_addr(self) -> Option<Value> {\n+        match self.0 {\n+            CValueInner::ByRef(addr) => Some(addr),\n+            CValueInner::ByVal(_) | CValueInner::ByValPair(_, _) => None,\n+        }\n+    }\n+\n     /// Load a value with layout.abi of scalar\n     pub fn load_scalar<'a>(self, fx: &mut FunctionCx<'_, 'tcx, impl Backend>) -> Value {\n         let layout = self.1;"}]}