{"sha": "8cddcd39ba2189da859a5164804556190906ee2a", "node_id": "C_kwDOAAsO6NoAKDhjZGRjZDM5YmEyMTg5ZGE4NTlhNTE2NDgwNDU1NjE5MDkwNmVlMmE", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2021-12-14T21:32:21Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2021-12-15T02:30:26Z"}, "message": "Remove `SymbolStr`.\n\nBy changing `as_str()` to take `&self` instead of `self`, we can just\nreturn `&str`. We're still lying about lifetimes, but it's a smaller lie\nthan before, where `SymbolStr` contained a (fake) `&'static str`!", "tree": {"sha": "80c9ffaa12dad22abec107679298920b1f07509a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80c9ffaa12dad22abec107679298920b1f07509a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cddcd39ba2189da859a5164804556190906ee2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cddcd39ba2189da859a5164804556190906ee2a", "html_url": "https://github.com/rust-lang/rust/commit/8cddcd39ba2189da859a5164804556190906ee2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cddcd39ba2189da859a5164804556190906ee2a/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22f8bde876f2fa9c5c4e95be1bce29cc271f2b51", "url": "https://api.github.com/repos/rust-lang/rust/commits/22f8bde876f2fa9c5c4e95be1bce29cc271f2b51", "html_url": "https://github.com/rust-lang/rust/commit/22f8bde876f2fa9c5c4e95be1bce29cc271f2b51"}], "stats": {"total": 307, "additions": 125, "deletions": 182}, "files": [{"sha": "9a6c45ae98d5f5aeffeb09dd2c16f36fb6ecacef", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -369,7 +369,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n             TodoItem::Static(def_id) => {\n                 //println!(\"static {:?}\", def_id);\n \n-                let section_name = tcx.codegen_fn_attrs(def_id).link_section.map(|s| s.as_str());\n+                let section_name = tcx.codegen_fn_attrs(def_id).link_section;\n \n                 let alloc = tcx.eval_static_initializer(def_id).unwrap();\n \n@@ -388,6 +388,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n \n         if let Some(section_name) = section_name {\n             let (segment_name, section_name) = if tcx.sess.target.is_like_osx {\n+                let section_name = section_name.as_str();\n                 if let Some(names) = section_name.split_once(',') {\n                     names\n                 } else {\n@@ -397,7 +398,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n                     ));\n                 }\n             } else {\n-                (\"\", &*section_name)\n+                (\"\", section_name.as_str())\n             };\n             data_ctx.set_segment_section(segment_name, section_name);\n         }"}, {"sha": "7fdde65383338e6fdbfff58289be4af3b081f903", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -2087,8 +2087,8 @@ fn prepare_enum_metadata(\n                 let item_name;\n                 let discriminant_name = match enum_type.kind() {\n                     ty::Adt(..) => {\n-                        item_name = tcx.item_name(enum_def_id).as_str();\n-                        &*item_name\n+                        item_name = tcx.item_name(enum_def_id);\n+                        item_name.as_str()\n                     }\n                     ty::Generator(..) => enum_name.as_str(),\n                     _ => bug!(),\n@@ -2563,7 +2563,8 @@ pub fn create_global_var_metadata(cx: &CodegenCx<'ll, '_>, def_id: DefId, global\n     let is_local_to_unit = is_node_local_to_unit(cx, def_id);\n     let variable_type = Instance::mono(cx.tcx, def_id).ty(cx.tcx, ty::ParamEnv::reveal_all());\n     let type_metadata = type_metadata(cx, variable_type, span);\n-    let var_name = tcx.item_name(def_id).as_str();\n+    let var_name = tcx.item_name(def_id);\n+    let var_name = var_name.as_str();\n     let linkage_name = mangled_name_of_instance(cx, Instance::mono(tcx, def_id)).name;\n     // When empty, linkage_name field is omitted,\n     // which is what we want for no_mangle statics"}, {"sha": "43fd94ce8a7c1c5b68b4a6636115b122b96744ea", "filename": "compiler/rustc_expand/src/module.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -170,8 +170,8 @@ fn mod_file_path_from_attr(\n ) -> Option<PathBuf> {\n     // Extract path string from first `#[path = \"path_string\"]` attribute.\n     let first_path = attrs.iter().find(|at| at.has_name(sym::path))?;\n-    let path_string = match first_path.value_str() {\n-        Some(s) => s.as_str(),\n+    let path_sym = match first_path.value_str() {\n+        Some(s) => s,\n         None => {\n             // This check is here mainly to catch attempting to use a macro,\n             // such as #[path = concat!(...)]. This isn't currently supported\n@@ -189,14 +189,16 @@ fn mod_file_path_from_attr(\n         }\n     };\n \n+    let path_str = path_sym.as_str();\n+\n     // On windows, the base path might have the form\n     // `\\\\?\\foo\\bar` in which case it does not tolerate\n     // mixed `/` and `\\` separators, so canonicalize\n     // `/` to `\\`.\n     #[cfg(windows)]\n-    let path_string = path_string.replace(\"/\", \"\\\\\");\n+    let path_str = path_str.replace(\"/\", \"\\\\\");\n \n-    Some(dir_path.join(&*path_string))\n+    Some(dir_path.join(path_str))\n }\n \n /// Returns a path to a module."}, {"sha": "e7ae6c7687ca6b35a1a8c78a8c396c16f18699cd", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -1049,8 +1049,8 @@ fn encode_and_write_metadata(\n \n     let need_metadata_file = tcx.sess.opts.output_types.contains_key(&OutputType::Metadata);\n     if need_metadata_file {\n-        let crate_name = &tcx.crate_name(LOCAL_CRATE).as_str();\n-        let out_filename = filename_for_metadata(tcx.sess, crate_name, outputs);\n+        let crate_name = tcx.crate_name(LOCAL_CRATE);\n+        let out_filename = filename_for_metadata(tcx.sess, crate_name.as_str(), outputs);\n         // To avoid races with another rustc process scanning the output directory,\n         // we need to write the file somewhere else and atomically move it to its\n         // final destination, with an `fs::rename` call. In order for the rename to"}, {"sha": "b63167f56b8bce22edf6633fafe15f20b621802a", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::ty::subst::InternalSubsts;\n use rustc_parse_format::{ParseMode, Parser, Piece};\n use rustc_session::lint::FutureIncompatibilityReason;\n use rustc_span::edition::Edition;\n-use rustc_span::{hygiene, sym, symbol::kw, symbol::SymbolStr, InnerSpan, Span, Symbol};\n+use rustc_span::{hygiene, sym, symbol::kw, InnerSpan, Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n \n declare_lint! {\n@@ -78,7 +78,7 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n \n     // The argument is *not* a string literal.\n \n-    let (span, panic, symbol_str) = panic_call(cx, f);\n+    let (span, panic, symbol) = panic_call(cx, f);\n \n     if in_external_macro(cx.sess(), span) {\n         // Nothing that can be done about it in the current crate.\n@@ -103,7 +103,7 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n \n     cx.struct_span_lint(NON_FMT_PANICS, arg_span, |lint| {\n         let mut l = lint.build(\"panic message is not a string literal\");\n-        l.note(&format!(\"this usage of {}!() is deprecated; it will be a hard error in Rust 2021\", symbol_str));\n+        l.note(&format!(\"this usage of {}!() is deprecated; it will be a hard error in Rust 2021\", symbol));\n         l.note(\"for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\");\n         if !is_arg_inside_call(arg_span, span) {\n             // No clue where this argument is coming from.\n@@ -112,7 +112,7 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n         }\n         if arg_macro.map_or(false, |id| cx.tcx.is_diagnostic_item(sym::format_macro, id)) {\n             // A case of `panic!(format!(..))`.\n-            l.note(format!(\"the {}!() macro supports formatting, so there's no need for the format!() macro here\", symbol_str).as_str());\n+            l.note(format!(\"the {}!() macro supports formatting, so there's no need for the format!() macro here\", symbol).as_str());\n             if let Some((open, close, _)) = find_delimiters(cx, arg_span) {\n                 l.multipart_suggestion(\n                     \"remove the `format!(..)` macro call\",\n@@ -301,7 +301,7 @@ fn find_delimiters<'tcx>(cx: &LateContext<'tcx>, span: Span) -> Option<(Span, Sp\n     ))\n }\n \n-fn panic_call<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>) -> (Span, Symbol, SymbolStr) {\n+fn panic_call<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>) -> (Span, Symbol, Symbol) {\n     let mut expn = f.span.ctxt().outer_expn_data();\n \n     let mut panic_macro = kw::Empty;\n@@ -328,7 +328,7 @@ fn panic_call<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>) -> (Span,\n \n     let macro_symbol =\n         if let hygiene::ExpnKind::Macro(_, symbol) = expn.kind { symbol } else { sym::panic };\n-    (expn.call_site, panic_macro, macro_symbol.as_str())\n+    (expn.call_site, panic_macro, macro_symbol)\n }\n \n fn is_arg_inside_call(arg: Span, call: Span) -> bool {"}, {"sha": "99927a089353f9fa35fc302f92c160dcf7e2d214", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -976,7 +976,8 @@ impl CrateError {\n                 let candidates = libraries\n                     .iter()\n                     .map(|lib| {\n-                        let crate_name = &lib.metadata.get_root().name().as_str();\n+                        let crate_name = lib.metadata.get_root().name();\n+                        let crate_name = crate_name.as_str();\n                         let mut paths = lib.source.paths();\n \n                         // This `unwrap()` should be okay because there has to be at least one"}, {"sha": "fc35cafcc77a16bc30e1080404ddb121a3b435dc", "filename": "compiler/rustc_middle/src/middle/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fmod.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -21,7 +21,7 @@ pub mod lib_features {\n                 .map(|(f, s)| (*f, Some(*s)))\n                 .chain(self.unstable.iter().map(|f| (*f, None)))\n                 .collect();\n-            all_features.sort_unstable_by_key(|f| f.0.as_str());\n+            all_features.sort_unstable_by(|a, b| a.0.as_str().partial_cmp(b.0.as_str()).unwrap());\n             all_features\n         }\n     }"}, {"sha": "acc8b92b97ac0ae298f927d2f0653dbfb789b5d0", "filename": "compiler/rustc_middle/src/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -131,8 +131,7 @@ pub fn report_unstable(\n /// deprecated (i.e., whether X is not greater than the current rustc version).\n pub fn deprecation_in_effect(depr: &Deprecation) -> bool {\n     let is_since_rustc_version = depr.is_since_rustc_version;\n-    let since = depr.since.map(Symbol::as_str);\n-    let since = since.as_deref();\n+    let since = depr.since.as_ref().map(Symbol::as_str);\n \n     fn parse_version(ver: &str) -> Vec<u32> {\n         // We ignore non-integer components of the version (e.g., \"nightly\").\n@@ -197,7 +196,7 @@ fn deprecation_message(\n     let message = if is_in_effect {\n         format!(\"use of deprecated {} `{}`\", kind, path)\n     } else {\n-        let since = since.map(Symbol::as_str);\n+        let since = since.as_ref().map(Symbol::as_str);\n \n         if since.as_deref() == Some(\"TBD\") {\n             format!(\"use of {} `{}` that will be deprecated in a future Rust version\", kind, path)"}, {"sha": "0c31adebda09229e410288e09cf9ab08347d80c7", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -1216,8 +1216,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn consider_optimizing<T: Fn() -> String>(self, msg: T) -> bool {\n-        let cname = self.crate_name(LOCAL_CRATE).as_str();\n-        self.sess.consider_optimizing(&cname, msg)\n+        let cname = self.crate_name(LOCAL_CRATE);\n+        self.sess.consider_optimizing(cname.as_str(), msg)\n     }\n \n     /// Obtain all lang items of this crate and all dependencies (recursively)"}, {"sha": "09cadc907b18a96dd566e28547ce84686f7a4827", "filename": "compiler/rustc_monomorphize/src/partitioning/merging.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmerging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmerging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmerging.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -3,7 +3,7 @@ use std::cmp;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::mir::mono::{CodegenUnit, CodegenUnitNameBuilder};\n-use rustc_span::symbol::{Symbol, SymbolStr};\n+use rustc_span::symbol::Symbol;\n \n use super::PartitioningCx;\n use crate::partitioning::PreInliningPartitioning;\n@@ -24,11 +24,11 @@ pub fn merge_codegen_units<'tcx>(\n     // smallest into each other) we're sure to start off with a deterministic\n     // order (sorted by name). This'll mean that if two cgus have the same size\n     // the stable sort below will keep everything nice and deterministic.\n-    codegen_units.sort_by_cached_key(|cgu| cgu.name().as_str());\n+    codegen_units.sort_by(|a, b| a.name().as_str().partial_cmp(b.name().as_str()).unwrap());\n \n     // This map keeps track of what got merged into what.\n-    let mut cgu_contents: FxHashMap<Symbol, Vec<SymbolStr>> =\n-        codegen_units.iter().map(|cgu| (cgu.name(), vec![cgu.name().as_str()])).collect();\n+    let mut cgu_contents: FxHashMap<Symbol, Vec<Symbol>> =\n+        codegen_units.iter().map(|cgu| (cgu.name(), vec![cgu.name()])).collect();\n \n     // Merge the two smallest codegen units until the target size is reached.\n     while codegen_units.len() > cx.target_cgu_count {\n@@ -69,7 +69,7 @@ pub fn merge_codegen_units<'tcx>(\n             // were actually modified by merging.\n             .filter(|(_, cgu_contents)| cgu_contents.len() > 1)\n             .map(|(current_cgu_name, cgu_contents)| {\n-                let mut cgu_contents: Vec<&str> = cgu_contents.iter().map(|s| &s[..]).collect();\n+                let mut cgu_contents: Vec<&str> = cgu_contents.iter().map(|s| s.as_str()).collect();\n \n                 // Sort the names, so things are deterministic and easy to\n                 // predict."}, {"sha": "cc60e7a1033d8c96004774808292d4f375033713", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -208,7 +208,7 @@ pub fn partition<'tcx>(\n         internalization_candidates: _,\n     } = post_inlining;\n \n-    result.sort_by_cached_key(|cgu| cgu.name().as_str());\n+    result.sort_by(|a, b| a.name().as_str().partial_cmp(b.name().as_str()).unwrap());\n \n     result\n }"}, {"sha": "8a2ef296c76b1d16da1e0aa46753cc5c339e4bc7", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -1679,7 +1679,8 @@ impl<'a> Parser<'a> {\n                 );\n             }\n             LitError::InvalidIntSuffix => {\n-                let suf = suffix.expect(\"suffix error with no suffix\").as_str();\n+                let suf = suffix.expect(\"suffix error with no suffix\");\n+                let suf = suf.as_str();\n                 if looks_like_width_suffix(&['i', 'u'], &suf) {\n                     // If it looks like a width, try to be helpful.\n                     let msg = format!(\"invalid width `{}` for integer literal\", &suf[1..]);\n@@ -1695,7 +1696,8 @@ impl<'a> Parser<'a> {\n                 }\n             }\n             LitError::InvalidFloatSuffix => {\n-                let suf = suffix.expect(\"suffix error with no suffix\").as_str();\n+                let suf = suffix.expect(\"suffix error with no suffix\");\n+                let suf = suf.as_str();\n                 if looks_like_width_suffix(&['f'], &suf) {\n                     // If it looks like a width, try to be helpful.\n                     let msg = format!(\"invalid width `{}` for float literal\", &suf[1..]);"}, {"sha": "cd056141508989ffabe9161e3186b2d5ab0098d6", "filename": "compiler/rustc_query_impl/src/profiling_support.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -61,8 +61,8 @@ impl<'p, 'c, 'tcx> QueryKeyStringBuilder<'p, 'c, 'tcx> {\n \n         match def_key.disambiguated_data.data {\n             DefPathData::CrateRoot => {\n-                crate_name = self.tcx.crate_name(def_id.krate).as_str();\n-                name = &*crate_name;\n+                crate_name = self.tcx.crate_name(def_id.krate);\n+                name = crate_name.as_str();\n                 dis = \"\";\n                 end_index = 3;\n             }"}, {"sha": "70e0ca0f5c83f9abc5e74a31e70d80c36be29316", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -1,4 +1,3 @@\n-use std::cmp::Reverse;\n use std::ptr;\n \n use rustc_ast::{self as ast, Path};\n@@ -784,7 +783,7 @@ impl<'a> Resolver<'a> {\n         });\n \n         // Make sure error reporting is deterministic.\n-        suggestions.sort_by_cached_key(|suggestion| suggestion.candidate.as_str());\n+        suggestions.sort_by(|a, b| a.candidate.as_str().partial_cmp(b.candidate.as_str()).unwrap());\n \n         match find_best_match_for_name(\n             &suggestions.iter().map(|suggestion| suggestion.candidate).collect::<Vec<Symbol>>(),\n@@ -1481,12 +1480,12 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             return None;\n         }\n \n-        // Sort extern crate names in reverse order to get\n+        // Sort extern crate names in *reverse* order to get\n         // 1) some consistent ordering for emitted diagnostics, and\n         // 2) `std` suggestions before `core` suggestions.\n         let mut extern_crate_names =\n             self.r.extern_prelude.iter().map(|(ident, _)| ident.name).collect::<Vec<_>>();\n-        extern_crate_names.sort_by_key(|name| Reverse(name.as_str()));\n+        extern_crate_names.sort_by(|a, b| b.as_str().partial_cmp(a.as_str()).unwrap());\n \n         for name in extern_crate_names.into_iter() {\n             // Replace first ident with a crate name and check if that is valid."}, {"sha": "3b1ca5db2cb2a941c5bfe9451cb4a9ec866b7c96", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -1353,7 +1353,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n \n         let name = path[path.len() - 1].ident.name;\n         // Make sure error reporting is deterministic.\n-        names.sort_by_cached_key(|suggestion| suggestion.candidate.as_str());\n+        names.sort_by(|a, b| a.candidate.as_str().partial_cmp(b.candidate.as_str()).unwrap());\n \n         match find_best_match_for_name(\n             &names.iter().map(|suggestion| suggestion.candidate).collect::<Vec<Symbol>>(),"}, {"sha": "662cb3aec15bf3bc167a30801d75bc0b320e1f04", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -689,11 +689,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         hir_id: hir::HirId,\n     ) {\n         let name = match fk {\n-            intravisit::FnKind::ItemFn(id, _, _, _) => id.as_str(),\n-            intravisit::FnKind::Method(id, _, _) => id.as_str(),\n-            intravisit::FnKind::Closure => Symbol::intern(\"closure\").as_str(),\n+            intravisit::FnKind::ItemFn(id, _, _, _) => id.name,\n+            intravisit::FnKind::Method(id, _, _) => id.name,\n+            intravisit::FnKind::Closure => sym::closure,\n         };\n-        let name: &str = &name;\n+        let name: &str = name.as_str();\n         let span = span!(Level::DEBUG, \"visit_fn\", name);\n         let _enter = span.enter();\n         match fk {"}, {"sha": "e879e42c2bdc4b97662d224a0784cee901474928", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 19, "deletions": 79, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -1512,9 +1512,12 @@ impl Ident {\n         Ident::new(self.name, self.span.normalize_to_macro_rules())\n     }\n \n-    /// Convert the name to a `SymbolStr`. This is a slowish operation because\n-    /// it requires locking the symbol interner.\n-    pub fn as_str(self) -> SymbolStr {\n+    /// Access the underlying string. This is a slowish operation because it\n+    /// requires locking the symbol interner.\n+    ///\n+    /// Note that the lifetime of the return value is a lie. See\n+    /// `Symbol::as_str()` for details.\n+    pub fn as_str(&self) -> &str {\n         self.name.as_str()\n     }\n }\n@@ -1650,12 +1653,17 @@ impl Symbol {\n         with_session_globals(|session_globals| session_globals.symbol_interner.intern(string))\n     }\n \n-    /// Convert to a `SymbolStr`. This is a slowish operation because it\n+    /// Access the underlying string. This is a slowish operation because it\n     /// requires locking the symbol interner.\n-    pub fn as_str(self) -> SymbolStr {\n-        with_session_globals(|session_globals| {\n-            let symbol_str = session_globals.symbol_interner.get(self);\n-            unsafe { SymbolStr { string: std::mem::transmute::<&str, &str>(symbol_str) } }\n+    ///\n+    /// Note that the lifetime of the return value is a lie. It's not the same\n+    /// as `&self`, but actually tied to the lifetime of the underlying\n+    /// interner. Interners are long-lived, and there are very few of them, and\n+    /// this function is typically used for short-lived things, so in practice\n+    /// it works out ok.\n+    pub fn as_str(&self) -> &str {\n+        with_session_globals(|session_globals| unsafe {\n+            std::mem::transmute::<&str, &str>(session_globals.symbol_interner.get(*self))\n         })\n     }\n \n@@ -1709,11 +1717,10 @@ impl<CTX> HashStable<CTX> for Symbol {\n }\n \n impl<CTX> ToStableHashKey<CTX> for Symbol {\n-    type KeyType = SymbolStr;\n-\n+    type KeyType = String;\n     #[inline]\n-    fn to_stable_hash_key(&self, _: &CTX) -> SymbolStr {\n-        self.as_str()\n+    fn to_stable_hash_key(&self, _: &CTX) -> String {\n+        self.as_str().to_string()\n     }\n }\n \n@@ -1905,70 +1912,3 @@ impl Ident {\n         self.name.can_be_raw() && self.is_reserved()\n     }\n }\n-\n-/// An alternative to [`Symbol`], useful when the chars within the symbol need to\n-/// be accessed. It deliberately has limited functionality and should only be\n-/// used for temporary values.\n-///\n-/// Because the interner outlives any thread which uses this type, we can\n-/// safely treat `string` which points to interner data, as an immortal string,\n-/// as long as this type never crosses between threads.\n-//\n-// FIXME: ensure that the interner outlives any thread which uses `SymbolStr`,\n-// by creating a new thread right after constructing the interner.\n-#[derive(Clone, Eq, PartialOrd, Ord)]\n-pub struct SymbolStr {\n-    string: &'static str,\n-}\n-\n-// This impl allows a `SymbolStr` to be directly equated with a `String` or\n-// `&str`.\n-impl<T: std::ops::Deref<Target = str>> std::cmp::PartialEq<T> for SymbolStr {\n-    fn eq(&self, other: &T) -> bool {\n-        self.string == other.deref()\n-    }\n-}\n-\n-impl !Send for SymbolStr {}\n-impl !Sync for SymbolStr {}\n-\n-/// This impl means that if `ss` is a `SymbolStr`:\n-/// - `*ss` is a `str`;\n-/// - `&*ss` is a `&str` (and `match &*ss { ... }` is a common pattern).\n-/// - `&ss as &str` is a `&str`, which means that `&ss` can be passed to a\n-///   function expecting a `&str`.\n-impl std::ops::Deref for SymbolStr {\n-    type Target = str;\n-    #[inline]\n-    fn deref(&self) -> &str {\n-        self.string\n-    }\n-}\n-\n-impl fmt::Debug for SymbolStr {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Debug::fmt(self.string, f)\n-    }\n-}\n-\n-impl fmt::Display for SymbolStr {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self.string, f)\n-    }\n-}\n-\n-impl<CTX> HashStable<CTX> for SymbolStr {\n-    #[inline]\n-    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n-        self.string.hash_stable(hcx, hasher)\n-    }\n-}\n-\n-impl<CTX> ToStableHashKey<CTX> for SymbolStr {\n-    type KeyType = SymbolStr;\n-\n-    #[inline]\n-    fn to_stable_hash_key(&self, _: &CTX) -> SymbolStr {\n-        self.clone()\n-    }\n-}"}, {"sha": "e20840398b51b0049e78c534140fc5625d956fc6", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -9,6 +9,7 @@ use rustc_middle::ty::layout::IntegerExt;\n use rustc_middle::ty::print::{Print, Printer};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n use rustc_middle::ty::{self, FloatTy, Instance, IntTy, Ty, TyCtxt, TypeFoldable, UintTy};\n+use rustc_span::symbol::kw;\n use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::Integer;\n use rustc_target::spec::abi::Abi;\n@@ -702,12 +703,11 @@ impl Printer<'tcx> for &mut SymbolMangler<'tcx> {\n                                     // just to be able to handle disambiguators.\n                                     let disambiguated_field =\n                                         self.tcx.def_key(field_def.did).disambiguated_data;\n-                                    let field_name =\n-                                        disambiguated_field.data.get_opt_name().map(|s| s.as_str());\n+                                    let field_name = disambiguated_field.data.get_opt_name();\n                                     self.push_disambiguator(\n                                         disambiguated_field.disambiguator as u64,\n                                     );\n-                                    self.push_ident(&field_name.as_ref().map_or(\"\", |s| &s[..]));\n+                                    self.push_ident(field_name.unwrap_or(kw::Empty).as_str());\n \n                                     self = field.print(self)?;\n                                 }\n@@ -736,8 +736,8 @@ impl Printer<'tcx> for &mut SymbolMangler<'tcx> {\n         self.push(\"C\");\n         let stable_crate_id = self.tcx.def_path_hash(cnum.as_def_id()).stable_crate_id();\n         self.push_disambiguator(stable_crate_id.to_u64());\n-        let name = self.tcx.crate_name(cnum).as_str();\n-        self.push_ident(&name);\n+        let name = self.tcx.crate_name(cnum);\n+        self.push_ident(name.as_str());\n         Ok(self)\n     }\n \n@@ -789,13 +789,13 @@ impl Printer<'tcx> for &mut SymbolMangler<'tcx> {\n             }\n         };\n \n-        let name = disambiguated_data.data.get_opt_name().map(|s| s.as_str());\n+        let name = disambiguated_data.data.get_opt_name();\n \n         self.path_append_ns(\n             print_prefix,\n             ns,\n             disambiguated_data.disambiguator as u64,\n-            name.as_ref().map_or(\"\", |s| &s[..]),\n+            name.unwrap_or(kw::Empty).as_str(),\n         )\n     }\n "}, {"sha": "0c2adc6400ef558e95424f44157cf88bb560898a", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -1038,7 +1038,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             .collect();\n \n         // Sort them by the name so we have a stable result.\n-        names.sort_by_cached_key(|n| n.as_str());\n+        names.sort_by(|a, b| a.as_str().partial_cmp(b.as_str()).unwrap());\n         names\n     }\n "}, {"sha": "0ba4849ec2df43e6abd9641b60523a1f4a6dce9f", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -26,7 +26,7 @@ use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::Session;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::DUMMY_SP;\n-use rustc_span::symbol::{kw, sym, Ident, Symbol, SymbolStr};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{self, FileName, Loc};\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi::Abi;\n@@ -2008,10 +2008,6 @@ impl Path {\n         self.segments.last().expect(\"segments were empty\").name\n     }\n \n-    crate fn last_name(&self) -> SymbolStr {\n-        self.segments.last().expect(\"segments were empty\").name.as_str()\n-    }\n-\n     crate fn whole_name(&self) -> String {\n         self.segments\n             .iter()"}, {"sha": "1bd4178c94a971ceb0934898962d05987293f5fb", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -666,20 +666,18 @@ fn primitive_link(\n                 needs_termination = true;\n             }\n             Some(&def_id) => {\n-                let cname_str;\n+                let cname_sym;\n                 let loc = match m.extern_locations[&def_id.krate] {\n                     ExternalLocation::Remote(ref s) => {\n-                        cname_str =\n-                            ExternalCrate { crate_num: def_id.krate }.name(cx.tcx()).as_str();\n-                        Some(vec![s.trim_end_matches('/'), &cname_str[..]])\n+                        cname_sym = ExternalCrate { crate_num: def_id.krate }.name(cx.tcx());\n+                        Some(vec![s.trim_end_matches('/'), cname_sym.as_str()])\n                     }\n                     ExternalLocation::Local => {\n-                        cname_str =\n-                            ExternalCrate { crate_num: def_id.krate }.name(cx.tcx()).as_str();\n-                        Some(if cx.current.first().map(|x| &x[..]) == Some(&cname_str[..]) {\n+                        cname_sym = ExternalCrate { crate_num: def_id.krate }.name(cx.tcx());\n+                        Some(if cx.current.first().map(|x| &x[..]) == Some(cname_sym.as_str()) {\n                             iter::repeat(\"..\").take(cx.current.len() - 1).collect()\n                         } else {\n-                            let cname = iter::once(&cname_str[..]);\n+                            let cname = iter::once(cname_sym.as_str());\n                             iter::repeat(\"..\").take(cx.current.len()).chain(cname).collect()\n                         })\n                     }\n@@ -1401,9 +1399,9 @@ impl clean::ImportSource {\n                 for seg in &self.path.segments[..self.path.segments.len() - 1] {\n                     write!(f, \"{}::\", seg.name)?;\n                 }\n-                let name = self.path.last_name();\n+                let name = self.path.last();\n                 if let hir::def::Res::PrimTy(p) = self.path.res {\n-                    primitive_link(f, PrimitiveType::from(p), &*name, cx)?;\n+                    primitive_link(f, PrimitiveType::from(p), name.as_str(), cx)?;\n                 } else {\n                     write!(f, \"{}\", name)?;\n                 }"}, {"sha": "6a1c7c0306385e582f01ca293e30701ce952174e", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -315,7 +315,7 @@ impl<'tcx> Context<'tcx> {\n         };\n         let file = &file;\n \n-        let symbol;\n+        let krate_sym;\n         let (krate, path) = if cnum == LOCAL_CRATE {\n             if let Some(path) = self.shared.local_sources.get(file) {\n                 (self.shared.layout.krate.as_str(), path)\n@@ -343,8 +343,8 @@ impl<'tcx> Context<'tcx> {\n             let mut fname = file.file_name().expect(\"source has no filename\").to_os_string();\n             fname.push(\".html\");\n             path.push_str(&fname.to_string_lossy());\n-            symbol = krate.as_str();\n-            (&*symbol, &path)\n+            krate_sym = krate;\n+            (krate_sym.as_str(), &path)\n         };\n \n         let anchor = if with_lines {"}, {"sha": "b2faf2d8b06baae8d75f232d4c21cb8d872d6618", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -1421,7 +1421,7 @@ fn render_impl(\n                     let source_id = trait_\n                         .and_then(|trait_| {\n                             trait_.items.iter().find(|item| {\n-                                item.name.map(|n| n.as_str().eq(&name.as_str())).unwrap_or(false)\n+                                item.name.map(|n| n.as_str().eq(name.as_str())).unwrap_or(false)\n                             })\n                         })\n                         .map(|item| format!(\"{}.{}\", item.type_(), name));"}, {"sha": "5f96f4cd2c2cbadf371421f410aecb0616341128", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -239,9 +239,9 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                 (true, false) => return Ordering::Greater,\n             }\n         }\n-        let lhs = i1.name.unwrap_or(kw::Empty).as_str();\n-        let rhs = i2.name.unwrap_or(kw::Empty).as_str();\n-        compare_names(&lhs, &rhs)\n+        let lhs = i1.name.unwrap_or(kw::Empty);\n+        let rhs = i2.name.unwrap_or(kw::Empty);\n+        compare_names(lhs.as_str(), rhs.as_str())\n     }\n \n     if cx.shared.sort_modules_alphabetically {"}, {"sha": "3f43a76945ecddf0880e610135439a1bce02b2f9", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -607,7 +607,7 @@ impl FromWithTcx<clean::Import> for Import {\n             },\n             Glob => Import {\n                 source: import.source.path.whole_name(),\n-                name: import.source.path.last_name().to_string(),\n+                name: import.source.path.last().to_string(),\n                 id: import.source.did.map(ItemId::from).map(from_item_id),\n                 glob: true,\n             },"}, {"sha": "af41348800ab012484b896bdcc510b65032f9577", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -2153,8 +2153,8 @@ fn privacy_error(cx: &DocContext<'_>, diag_info: &DiagnosticInfo<'_>, path_str:\n     let sym;\n     let item_name = match diag_info.item.name {\n         Some(name) => {\n-            sym = name.as_str();\n-            &*sym\n+            sym = name;\n+            sym.as_str()\n         }\n         None => \"<unknown>\",\n     };"}, {"sha": "06a99ff5418f761179a07781bd7e73ea7367c807", "filename": "src/tools/clippy/clippy_lints/src/attrs.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -17,7 +17,7 @@ use rustc_semver::RustcVersion;\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n use rustc_span::sym;\n-use rustc_span::symbol::{Symbol, SymbolStr};\n+use rustc_span::symbol::Symbol;\n use semver::Version;\n \n static UNIX_SYSTEMS: &[&str] = &[\n@@ -310,8 +310,8 @@ impl<'tcx> LateLintPass<'tcx> for Attributes {\n                                             || is_word(lint, sym::deprecated)\n                                             || is_word(lint, sym!(unreachable_pub))\n                                             || is_word(lint, sym!(unused))\n-                                            || extract_clippy_lint(lint).map_or(false, |s| s == \"wildcard_imports\")\n-                                            || extract_clippy_lint(lint).map_or(false, |s| s == \"enum_glob_use\")\n+                                            || extract_clippy_lint(lint).map_or(false, |s| s.as_str() == \"wildcard_imports\")\n+                                            || extract_clippy_lint(lint).map_or(false, |s| s.as_str() == \"enum_glob_use\")\n                                         {\n                                             return;\n                                         }\n@@ -370,15 +370,15 @@ impl<'tcx> LateLintPass<'tcx> for Attributes {\n }\n \n /// Returns the lint name if it is clippy lint.\n-fn extract_clippy_lint(lint: &NestedMetaItem) -> Option<SymbolStr> {\n+fn extract_clippy_lint(lint: &NestedMetaItem) -> Option<Symbol> {\n     if_chain! {\n         if let Some(meta_item) = lint.meta_item();\n         if meta_item.path.segments.len() > 1;\n         if let tool_name = meta_item.path.segments[0].ident;\n         if tool_name.name == sym::clippy;\n         then {\n             let lint_name = meta_item.path.segments.last().unwrap().ident.name;\n-            return Some(lint_name.as_str());\n+            return Some(lint_name);\n         }\n     }\n     None\n@@ -387,7 +387,7 @@ fn extract_clippy_lint(lint: &NestedMetaItem) -> Option<SymbolStr> {\n fn check_clippy_lint_names(cx: &LateContext<'_>, name: Symbol, items: &[NestedMetaItem]) {\n     for lint in items {\n         if let Some(lint_name) = extract_clippy_lint(lint) {\n-            if lint_name == \"restriction\" && name != sym::allow {\n+            if lint_name.as_str() == \"restriction\" && name != sym::allow {\n                 span_lint_and_help(\n                     cx,\n                     BLANKET_CLIPPY_RESTRICTION_LINTS,"}, {"sha": "2412838518990fbcbd7642832eeb4b965fd20b62", "filename": "src/tools/clippy/clippy_lints/src/match_str_case_mismatch.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_str_case_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_str_case_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_str_case_mismatch.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::symbol::SymbolStr;\n+use rustc_span::symbol::Symbol;\n use rustc_span::{sym, Span};\n \n declare_clippy_lint! {\n@@ -71,8 +71,8 @@ impl LateLintPass<'_> for MatchStrCaseMismatch {\n                 visitor.visit_expr(match_expr);\n \n                 if let Some(case_method) = visitor.case_method {\n-                    if let Some((bad_case_span, bad_case_str)) = verify_case(&case_method, arms) {\n-                        lint(cx, &case_method, bad_case_span, &bad_case_str);\n+                    if let Some((bad_case_span, bad_case_sym)) = verify_case(&case_method, arms) {\n+                        lint(cx, &case_method, bad_case_span, bad_case_sym.as_str());\n                     }\n                 }\n             }\n@@ -126,7 +126,7 @@ fn get_case_method(segment_ident_str: &str) -> Option<CaseMethod> {\n     }\n }\n \n-fn verify_case<'a>(case_method: &'a CaseMethod, arms: &'a [Arm<'_>]) -> Option<(Span, SymbolStr)> {\n+fn verify_case<'a>(case_method: &'a CaseMethod, arms: &'a [Arm<'_>]) -> Option<(Span, Symbol)> {\n     let case_check = match case_method {\n         CaseMethod::LowerCase => |input: &str| -> bool { input.chars().all(|c| c.to_lowercase().next() == Some(c)) },\n         CaseMethod::AsciiLowerCase => |input: &str| -> bool { !input.chars().any(|c| c.is_ascii_uppercase()) },\n@@ -144,7 +144,7 @@ fn verify_case<'a>(case_method: &'a CaseMethod, arms: &'a [Arm<'_>]) -> Option<(\n             let input = symbol.as_str();\n             if !case_check(&input);\n             then {\n-                return Some((lit.span, input));\n+                return Some((lit.span, symbol));\n             }\n         }\n     }"}, {"sha": "e1b1828f7fe86f8ab50532ca19a6b818b361b759", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -78,7 +78,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, TraitRef, Ty, TyS};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::symbol::SymbolStr;\n+use rustc_span::symbol::Symbol;\n use rustc_span::{sym, Span};\n use rustc_typeck::hir_ty_to_ty;\n \n@@ -1968,21 +1968,21 @@ impl_lint_pass!(Methods => [\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n-fn method_call<'tcx>(recv: &'tcx hir::Expr<'tcx>) -> Option<(SymbolStr, &'tcx [hir::Expr<'tcx>], Span)> {\n+fn method_call<'tcx>(recv: &'tcx hir::Expr<'tcx>) -> Option<(Symbol, &'tcx [hir::Expr<'tcx>], Span)> {\n     if let ExprKind::MethodCall(path, span, args, _) = recv.kind {\n         if !args.iter().any(|e| e.span.from_expansion()) {\n-            return Some((path.ident.name.as_str(), args, span));\n+            return Some((path.ident.name, args, span));\n         }\n     }\n     None\n }\n \n-/// Same as `method_call` but the `SymbolStr` is dereferenced into a temporary `&str`\n+/// Same as `method_call` but the `Symbol` is dereferenced into a temporary `&str`\n macro_rules! method_call {\n     ($expr:expr) => {\n         method_call($expr)\n             .as_ref()\n-            .map(|&(ref name, args, span)| (&**name, args, span))\n+            .map(|&(ref name, args, span)| (name.as_str(), args, span))\n     };\n }\n "}, {"sha": "401dc27811dc3aa05ca5de9c822c9bb41c7a7bd5", "filename": "src/tools/clippy/clippy_lints/src/misc.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -407,6 +407,7 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n             // Don't lint things expanded by #[derive(...)], etc or `await` desugaring\n             return;\n         }\n+        let sym;\n         let binding = match expr.kind {\n             ExprKind::Path(ref qpath) if !matches!(qpath, hir::QPath::LangItem(..)) => {\n                 let binding = last_path_segment(qpath).ident.as_str();\n@@ -423,7 +424,8 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n                 }\n             },\n             ExprKind::Field(_, ident) => {\n-                let name = ident.as_str();\n+                sym = ident.name;\n+                let name = sym.as_str();\n                 if name.starts_with('_') && !name.starts_with(\"__\") {\n                     Some(name)\n                 } else {"}, {"sha": "1f9db39cf8ca6a7e9742a2761d4bb89b466614f6", "filename": "src/tools/clippy/clippy_lints/src/multiple_crate_versions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmultiple_crate_versions.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -48,15 +48,15 @@ impl LateLintPass<'_> for MultipleCrateVersions {\n         }\n \n         let metadata = unwrap_cargo_metadata!(cx, MULTIPLE_CRATE_VERSIONS, true);\n-        let local_name = cx.tcx.crate_name(LOCAL_CRATE).as_str();\n+        let local_name = cx.tcx.crate_name(LOCAL_CRATE);\n         let mut packages = metadata.packages;\n         packages.sort_by(|a, b| a.name.cmp(&b.name));\n \n         if_chain! {\n             if let Some(resolve) = &metadata.resolve;\n             if let Some(local_id) = packages\n                 .iter()\n-                .find_map(|p| if p.name == *local_name { Some(&p.id) } else { None });\n+                .find_map(|p| if p.name == local_name.as_str() { Some(&p.id) } else { None });\n             then {\n                 for (name, group) in &packages.iter().group_by(|p| p.name.clone()) {\n                     let group: Vec<&Package> = group.collect();"}, {"sha": "dc5ec5f229518eda886895e80a633a30aefb8052", "filename": "src/tools/clippy/clippy_utils/src/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -319,8 +319,8 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n                     if let ExprKind::Path(qpath) = &callee.kind;\n                     let res = self.typeck_results.qpath_res(qpath, callee.hir_id);\n                     if let Some(def_id) = res.opt_def_id();\n-                    let def_path: Vec<_> = self.lcx.get_def_path(def_id).into_iter().map(Symbol::as_str).collect();\n-                    let def_path: Vec<&str> = def_path.iter().take(4).map(|s| &**s).collect();\n+                    let def_path = self.lcx.get_def_path(def_id);\n+                    let def_path: Vec<&str> = def_path.iter().take(4).map(|s| s.as_str()).collect();\n                     if let [\"core\", \"num\", int_impl, \"max_value\"] = *def_path;\n                     then {\n                        let value = match int_impl {"}, {"sha": "fe8e5c6b61e16ba5417f68d1b2b4d7c6b5072c26", "filename": "src/tools/rustfmt/src/reorder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/src%2Ftools%2Frustfmt%2Fsrc%2Freorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/src%2Ftools%2Frustfmt%2Fsrc%2Freorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Freorder.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -31,9 +31,9 @@ fn compare_items(a: &ast::Item, b: &ast::Item) -> Ordering {\n         (&ast::ItemKind::ExternCrate(ref a_name), &ast::ItemKind::ExternCrate(ref b_name)) => {\n             // `extern crate foo as bar;`\n             //               ^^^ Comparing this.\n-            let a_orig_name = a_name.map_or_else(|| a.ident.as_str(), rustc_span::Symbol::as_str);\n-            let b_orig_name = b_name.map_or_else(|| b.ident.as_str(), rustc_span::Symbol::as_str);\n-            let result = a_orig_name.cmp(&b_orig_name);\n+            let a_orig_name = a_name.unwrap_or(a.ident.name);\n+            let b_orig_name = b_name.unwrap_or(b.ident.name);\n+            let result = a_orig_name.as_str().cmp(b_orig_name.as_str());\n             if result != Ordering::Equal {\n                 return result;\n             }"}, {"sha": "23d065c9cc95ae3113ddf12a53e5a12f8fc3cd03", "filename": "src/tools/rustfmt/src/syntux/parser.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8cddcd39ba2189da859a5164804556190906ee2a/src%2Ftools%2Frustfmt%2Fsrc%2Fsyntux%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cddcd39ba2189da859a5164804556190906ee2a/src%2Ftools%2Frustfmt%2Fsrc%2Fsyntux%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fsyntux%2Fparser.rs?ref=8cddcd39ba2189da859a5164804556190906ee2a", "patch": "@@ -95,15 +95,17 @@ pub(crate) enum ParserError {\n \n impl<'a> Parser<'a> {\n     pub(crate) fn submod_path_from_attr(attrs: &[ast::Attribute], path: &Path) -> Option<PathBuf> {\n-        let path_string = first_attr_value_str_by_name(attrs, sym::path)?.as_str();\n+        let path_sym = first_attr_value_str_by_name(attrs, sym::path)?;\n+        let path_str = path_sym.as_str();\n+\n         // On windows, the base path might have the form\n         // `\\\\?\\foo\\bar` in which case it does not tolerate\n         // mixed `/` and `\\` separators, so canonicalize\n         // `/` to `\\`.\n         #[cfg(windows)]\n-        let path_string = path_string.replace(\"/\", \"\\\\\");\n+        let path_str = path_str.replace(\"/\", \"\\\\\");\n \n-        Some(path.join(&*path_string))\n+        Some(path.join(path_str))\n     }\n \n     pub(crate) fn parse_file_as_module("}]}