{"sha": "4589597785c4e485db82bc06c2c44ac2ebcced6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1ODk1OTc3ODVjNGU0ODVkYjgyYmMwNmMyYzQ0YWMyZWJjY2VkNmE=", "commit": {"author": {"name": "Ben Striegel", "email": "ben.striegel@gmail.com", "date": "2012-11-14T02:38:18Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-15T00:15:34Z"}, "message": "Convert libstd to use the Drop trait", "tree": {"sha": "35053801b2b14b52e1ab6f05e0f06f2c3863ad68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35053801b2b14b52e1ab6f05e0f06f2c3863ad68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4589597785c4e485db82bc06c2c44ac2ebcced6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4589597785c4e485db82bc06c2c44ac2ebcced6a", "html_url": "https://github.com/rust-lang/rust/commit/4589597785c4e485db82bc06c2c44ac2ebcced6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4589597785c4e485db82bc06c2c44ac2ebcced6a/comments", "author": {"login": "bstrie", "id": 865233, "node_id": "MDQ6VXNlcjg2NTIzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/865233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bstrie", "html_url": "https://github.com/bstrie", "followers_url": "https://api.github.com/users/bstrie/followers", "following_url": "https://api.github.com/users/bstrie/following{/other_user}", "gists_url": "https://api.github.com/users/bstrie/gists{/gist_id}", "starred_url": "https://api.github.com/users/bstrie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bstrie/subscriptions", "organizations_url": "https://api.github.com/users/bstrie/orgs", "repos_url": "https://api.github.com/users/bstrie/repos", "events_url": "https://api.github.com/users/bstrie/events{/privacy}", "received_events_url": "https://api.github.com/users/bstrie/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b0e1336b26b5bc29e14370e55d4811f15b1dce8", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b0e1336b26b5bc29e14370e55d4811f15b1dce8", "html_url": "https://github.com/rust-lang/rust/commit/4b0e1336b26b5bc29e14370e55d4811f15b1dce8"}], "stats": {"total": 159, "additions": 107, "deletions": 52}, "files": [{"sha": "503c15b46c2cd135bdf7903f9c4534d83575be3f", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4589597785c4e485db82bc06c2c44ac2ebcced6a/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4589597785c4e485db82bc06c2c44ac2ebcced6a/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=4589597785c4e485db82bc06c2c44ac2ebcced6a", "patch": "@@ -217,7 +217,10 @@ fn check_poison(is_mutex: bool, failed: bool) {\n #[doc(hidden)]\n struct PoisonOnFail {\n     failed: &mut bool,\n-    drop {\n+}\n+\n+impl PoisonOnFail : Drop {\n+    fn finalize() {\n         /* assert !*self.failed; -- might be false in case of cond.wait() */\n         if task::failing() { *self.failed = true; }\n     }"}, {"sha": "cf8bbc628f0c11f28c1192cf92071f120ba09121", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4589597785c4e485db82bc06c2c44ac2ebcced6a/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4589597785c4e485db82bc06c2c44ac2ebcced6a/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=4589597785c4e485db82bc06c2c44ac2ebcced6a", "patch": "@@ -55,7 +55,10 @@ pub struct Arena {\n     priv mut head: Chunk,\n     priv mut pod_head: Chunk,\n     priv mut chunks: @List<Chunk>,\n-    drop {\n+}\n+\n+impl Arena : Drop {\n+    fn finalize() {\n         unsafe {\n             destroy_chunk(&self.head);\n             for list::each(self.chunks) |chunk| {"}, {"sha": "2e94f07d2d88df54750c807175391f542de2eb63", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4589597785c4e485db82bc06c2c44ac2ebcced6a/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4589597785c4e485db82bc06c2c44ac2ebcced6a/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=4589597785c4e485db82bc06c2c44ac2ebcced6a", "patch": "@@ -39,12 +39,15 @@ pub enum CVec<T> {\n \n struct DtorRes {\n   dtor: Option<fn@()>,\n-  drop {\n+}\n+\n+impl DtorRes : Drop {\n+    fn finalize() {\n     match self.dtor {\n       option::None => (),\n       option::Some(f) => f()\n     }\n-  }\n+    }\n }\n \n fn DtorRes(dtor: Option<fn@()>) -> DtorRes {"}, {"sha": "17b487f16dee26fbcdf4f7ffe86bc3f24b9749e3", "filename": "src/libstd/future.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4589597785c4e485db82bc06c2c44ac2ebcced6a/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4589597785c4e485db82bc06c2c44ac2ebcced6a/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=4589597785c4e485db82bc06c2c44ac2ebcced6a", "patch": "@@ -23,10 +23,12 @@ use cast::copy_lifetime;\n #[doc = \"The future type\"]\n pub struct Future<A> {\n     /*priv*/ mut state: FutureState<A>,\n+}\n \n-    // FIXME(#2829) -- futures should not be copyable, because they close\n-    // over fn~'s that have pipes and so forth within!\n-    drop {}\n+// FIXME(#2829) -- futures should not be copyable, because they close\n+// over fn~'s that have pipes and so forth within!\n+impl<A> Future<A> : Drop {\n+    fn finalize() {}\n }\n \n priv enum FutureState<A> {"}, {"sha": "182ec2a233c97219eeebe18d9a45802cc801a615", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4589597785c4e485db82bc06c2c44ac2ebcced6a/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4589597785c4e485db82bc06c2c44ac2ebcced6a/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=4589597785c4e485db82bc06c2c44ac2ebcced6a", "patch": "@@ -27,11 +27,14 @@ extern mod rustrt {\n  */\n struct TcpSocket {\n   socket_data: @TcpSocketData,\n-  drop {\n+}\n+\n+impl TcpSocket : Drop {\n+    fn finalize() {\n     unsafe {\n         tear_down_socket_data(self.socket_data)\n     }\n-  }\n+    }\n }\n \n pub fn TcpSocket(socket_data: @TcpSocketData) -> TcpSocket {"}, {"sha": "4f06cc40c229c253ed29691f4c4ff82b9430bcb2", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4589597785c4e485db82bc06c2c44ac2ebcced6a/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4589597785c4e485db82bc06c2c44ac2ebcced6a/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=4589597785c4e485db82bc06c2c44ac2ebcced6a", "patch": "@@ -1133,7 +1133,10 @@ mod big_tests {\n         val: uint,\n         key: fn(@uint),\n \n-        drop {\n+    }\n+\n+    impl LVal : Drop {\n+        fn finalize() {\n             let x = unsafe { task::local_data::local_data_get(self.key) };\n             match x {\n                 Some(@y) => {"}, {"sha": "55f458c6f46c49608eacce3bcd693c32517e9a53", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 76, "deletions": 41, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/4589597785c4e485db82bc06c2c44ac2ebcced6a/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4589597785c4e485db82bc06c2c44ac2ebcced6a/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=4589597785c4e485db82bc06c2c44ac2ebcced6a", "patch": "@@ -150,7 +150,12 @@ impl &Sem<~[mut Waitqueue]> {\n #[doc(hidden)]\n struct SemRelease {\n     sem: &Sem<()>,\n-    drop { self.sem.release(); }\n+}\n+\n+impl SemRelease : Drop {\n+    fn finalize() {\n+        self.sem.release();\n+    }\n }\n \n fn SemRelease(sem: &r/Sem<()>) -> SemRelease/&r {\n@@ -162,7 +167,12 @@ fn SemRelease(sem: &r/Sem<()>) -> SemRelease/&r {\n #[doc(hidden)]\n struct SemAndSignalRelease {\n     sem: &Sem<~[mut Waitqueue]>,\n-    drop { self.sem.release(); }\n+}\n+\n+impl SemAndSignalRelease : Drop {\n+    fn finalize() {\n+        self.sem.release();\n+    }\n }\n \n fn SemAndSignalRelease(sem: &r/Sem<~[mut Waitqueue]>)\n@@ -173,7 +183,9 @@ fn SemAndSignalRelease(sem: &r/Sem<~[mut Waitqueue]>)\n }\n \n /// A mechanism for atomic-unlock-and-deschedule blocking and signalling.\n-pub struct Condvar { priv sem: &Sem<~[mut Waitqueue]>, drop { } }\n+pub struct Condvar { priv sem: &Sem<~[mut Waitqueue]> }\n+\n+impl Condvar : Drop { fn finalize() {} }\n \n impl &Condvar {\n     /**\n@@ -242,10 +254,15 @@ impl &Condvar {\n         // bounded in when it gets released, this shouldn't hang forever.\n         struct SemAndSignalReacquire {\n             sem: &Sem<~[mut Waitqueue]>,\n-            drop unsafe {\n-                // Needs to succeed, instead of itself dying.\n-                do task::unkillable {\n-                    self.sem.acquire();\n+        }\n+\n+        impl SemAndSignalReacquire : Drop {\n+            fn finalize() {\n+                unsafe {\n+                    // Needs to succeed, instead of itself dying.\n+                    do task::unkillable {\n+                        self.sem.acquire();\n+                    }\n                 }\n             }\n         }\n@@ -581,20 +598,25 @@ impl &RWlock {\n #[doc(hidden)]\n struct RWlockReleaseRead {\n     lock: &RWlock,\n-    drop unsafe {\n-        do task::unkillable {\n-            let mut last_reader = false;\n-            do self.lock.state.with |state| {\n-                assert state.read_mode;\n-                assert state.read_count > 0;\n-                state.read_count -= 1;\n-                if state.read_count == 0 {\n-                    last_reader = true;\n-                    state.read_mode = false;\n+}\n+\n+impl RWlockReleaseRead : Drop {\n+    fn finalize() {\n+        unsafe {\n+            do task::unkillable {\n+                let mut last_reader = false;\n+                do self.lock.state.with |state| {\n+                    assert state.read_mode;\n+                    assert state.read_count > 0;\n+                    state.read_count -= 1;\n+                    if state.read_count == 0 {\n+                        last_reader = true;\n+                        state.read_mode = false;\n+                    }\n+                }\n+                if last_reader {\n+                    (&self.lock.access_lock).release();\n                 }\n-            }\n-            if last_reader {\n-                (&self.lock.access_lock).release();\n             }\n         }\n     }\n@@ -610,27 +632,33 @@ fn RWlockReleaseRead(lock: &r/RWlock) -> RWlockReleaseRead/&r {\n #[doc(hidden)]\n struct RWlockReleaseDowngrade {\n     lock: &RWlock,\n-    drop unsafe {\n-        do task::unkillable {\n-            let mut writer_or_last_reader = false;\n-            do self.lock.state.with |state| {\n-                if state.read_mode {\n-                    assert state.read_count > 0;\n-                    state.read_count -= 1;\n-                    if state.read_count == 0 {\n-                        // Case 1: Writer downgraded & was the last reader\n-                        writer_or_last_reader = true;\n-                        state.read_mode = false;\n+}\n+\n+impl RWlockReleaseDowngrade : Drop {\n+    fn finalize() {\n+        unsafe {\n+            do task::unkillable {\n+                let mut writer_or_last_reader = false;\n+                do self.lock.state.with |state| {\n+                    if state.read_mode {\n+                        assert state.read_count > 0;\n+                        state.read_count -= 1;\n+                        if state.read_count == 0 {\n+                            // Case 1: Writer downgraded & was the last reader\n+                            writer_or_last_reader = true;\n+                            state.read_mode = false;\n+                        } else {\n+                            // Case 2: Writer downgraded & was not the last\n+                            // reader\n+                        }\n                     } else {\n-                        // Case 2: Writer downgraded & was not the last reader\n+                        // Case 3: Writer did not downgrade\n+                        writer_or_last_reader = true;\n                     }\n-                } else {\n-                    // Case 3: Writer did not downgrade\n-                    writer_or_last_reader = true;\n                 }\n-            }\n-            if writer_or_last_reader {\n-                (&self.lock.access_lock).release();\n+                if writer_or_last_reader {\n+                    (&self.lock.access_lock).release();\n+                }\n             }\n         }\n     }\n@@ -643,9 +671,11 @@ fn RWlockReleaseDowngrade(lock: &r/RWlock) -> RWlockReleaseDowngrade/&r {\n }\n \n /// The \"write permission\" token used for rwlock.write_downgrade().\n-pub struct RWlockWriteMode { /* priv */ lock: &RWlock, drop { } }\n+pub struct RWlockWriteMode { /* priv */ lock: &RWlock }\n+impl RWlockWriteMode : Drop { fn finalize() {} }\n /// The \"read permission\" token used for rwlock.write_downgrade().\n-pub struct RWlockReadMode  { priv lock: &RWlock, drop { } }\n+pub struct RWlockReadMode  { priv lock: &RWlock }\n+impl RWlockReadMode : Drop { fn finalize() {} }\n \n impl &RWlockWriteMode {\n     /// Access the pre-downgrade rwlock in write mode.\n@@ -954,7 +984,12 @@ mod tests {\n         }\n         struct SendOnFailure {\n             c: pipes::Chan<()>,\n-            drop { self.c.send(()); }\n+        }\n+\n+        impl SendOnFailure : Drop {\n+            fn finalize() {\n+                self.c.send(());\n+            }\n         }\n \n         fn SendOnFailure(c: pipes::Chan<()>) -> SendOnFailure {"}, {"sha": "f5d1a6edbf13e48a43d581851c1533cd06fc656c", "filename": "src/libstd/thread_pool.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4589597785c4e485db82bc06c2c44ac2ebcced6a/src%2Flibstd%2Fthread_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4589597785c4e485db82bc06c2c44ac2ebcced6a/src%2Flibstd%2Fthread_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_pool.rs?ref=4589597785c4e485db82bc06c2c44ac2ebcced6a", "patch": "@@ -13,7 +13,10 @@ pub struct ThreadPool<T> {\n     channels: ~[Chan<Msg<T>>],\n     mut next_index: uint,\n \n-    drop {\n+}\n+\n+impl<T> ThreadPool<T> {\n+    fn finalize() {\n         for self.channels.each |channel| {\n             channel.send(Quit);\n         }"}]}