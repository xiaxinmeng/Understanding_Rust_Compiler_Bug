{"sha": "28b5334580e5814d102b006e310ca0d1f03cdd72", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4YjUzMzQ1ODBlNTgxNGQxMDJiMDA2ZTMxMGNhMGQxZjAzY2RkNzI=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-12-16T22:42:03Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-12-16T22:42:03Z"}, "message": "Avoid querying attributes in item tree lowering\n\nItemTree is per-file, so there is no unique crate associated with it.\nThis means that it cannot know the active CfgOptions and thus couldn't\nhandle `cfg_attr`.\n\nPrepare it for `cfg_attr`s by avoiding accessing attributes.", "tree": {"sha": "da9ac7abc2f426dbe2783aa7a2a29e57d17cddf8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da9ac7abc2f426dbe2783aa7a2a29e57d17cddf8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28b5334580e5814d102b006e310ca0d1f03cdd72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28b5334580e5814d102b006e310ca0d1f03cdd72", "html_url": "https://github.com/rust-lang/rust/commit/28b5334580e5814d102b006e310ca0d1f03cdd72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28b5334580e5814d102b006e310ca0d1f03cdd72/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "067067a6c11bb5afda98f5af14bfdec4744e7812", "url": "https://api.github.com/repos/rust-lang/rust/commits/067067a6c11bb5afda98f5af14bfdec4744e7812", "html_url": "https://github.com/rust-lang/rust/commit/067067a6c11bb5afda98f5af14bfdec4744e7812"}], "stats": {"total": 66, "additions": 28, "deletions": 38}, "files": [{"sha": "b8e09e3af3138513977b95319b56074b34136d84", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28b5334580e5814d102b006e310ca0d1f03cdd72/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28b5334580e5814d102b006e310ca0d1f03cdd72/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=28b5334580e5814d102b006e310ca0d1f03cdd72", "patch": "@@ -646,12 +646,6 @@ pub struct MacroCall {\n pub struct MacroRules {\n     /// The name of the declared macro.\n     pub name: Name,\n-    /// Has `#[macro_export]`.\n-    pub is_export: bool,\n-    /// Has `#[macro_export(local_inner_macros)]`.\n-    pub is_local_inner: bool,\n-    /// Has `#[rustc_builtin_macro]`.\n-    pub is_builtin: bool,\n     pub ast_id: FileAstId<ast::MacroRules>,\n }\n \n@@ -660,8 +654,6 @@ pub struct MacroRules {\n pub struct MacroDef {\n     pub name: Name,\n     pub visibility: RawVisibilityId,\n-    /// Has `#[rustc_builtin_macro]`.\n-    pub is_builtin: bool,\n     pub ast_id: FileAstId<ast::MacroDef>,\n }\n "}, {"sha": "7de385ee83ecf8047daaa7c14c6d18538a3eb670", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/28b5334580e5814d102b006e310ca0d1f03cdd72/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28b5334580e5814d102b006e310ca0d1f03cdd72/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=28b5334580e5814d102b006e310ca0d1f03cdd72", "patch": "@@ -539,39 +539,19 @@ impl Ctx {\n \n     fn lower_macro_rules(&mut self, m: &ast::MacroRules) -> Option<FileItemTreeId<MacroRules>> {\n         let name = m.name().map(|it| it.as_name())?;\n-        let attrs = Attrs::new(m, &self.hygiene);\n-\n         let ast_id = self.source_ast_id_map.ast_id(m);\n \n-        // FIXME: cfg_attr\n-        let export_attr = attrs.by_key(\"macro_export\");\n-\n-        let is_export = export_attr.exists();\n-        let is_local_inner = if is_export {\n-            export_attr.tt_values().map(|it| &it.token_trees).flatten().any(|it| match it {\n-                tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => {\n-                    ident.text.contains(\"local_inner_macros\")\n-                }\n-                _ => false,\n-            })\n-        } else {\n-            false\n-        };\n-\n-        let is_builtin = attrs.by_key(\"rustc_builtin_macro\").exists();\n-        let res = MacroRules { name, is_export, is_builtin, is_local_inner, ast_id };\n+        let res = MacroRules { name, ast_id };\n         Some(id(self.data().macro_rules.alloc(res)))\n     }\n \n     fn lower_macro_def(&mut self, m: &ast::MacroDef) -> Option<FileItemTreeId<MacroDef>> {\n         let name = m.name().map(|it| it.as_name())?;\n-        let attrs = Attrs::new(m, &self.hygiene);\n \n         let ast_id = self.source_ast_id_map.ast_id(m);\n         let visibility = self.lower_visibility(m);\n \n-        let is_builtin = attrs.by_key(\"rustc_builtin_macro\").exists();\n-        let res = MacroDef { name, is_builtin, ast_id, visibility };\n+        let res = MacroDef { name, ast_id, visibility };\n         Some(id(self.data().macro_defs.alloc(res)))\n     }\n "}, {"sha": "1936348fb43b74bc465cc275a056a71e578e6572", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/28b5334580e5814d102b006e310ca0d1f03cdd72/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28b5334580e5814d102b006e310ca0d1f03cdd72/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=28b5334580e5814d102b006e310ca0d1f03cdd72", "patch": "@@ -26,7 +26,8 @@ use crate::{\n     db::DefDatabase,\n     item_scope::{ImportType, PerNsGlobImports},\n     item_tree::{\n-        self, ItemTree, ItemTreeId, MacroCall, MacroRules, Mod, ModItem, ModKind, StructDefKind,\n+        self, FileItemTreeId, ItemTree, ItemTreeId, MacroCall, MacroRules, Mod, ModItem, ModKind,\n+        StructDefKind,\n     },\n     nameres::{\n         diagnostics::DefDiagnostic, mod_resolution::ModDir, path_resolution::ReachedFixedPoint,\n@@ -967,14 +968,15 @@ impl ModCollector<'_, '_> {\n                     })\n                 }\n                 ModItem::MacroCall(mac) => self.collect_macro_call(&self.item_tree[mac]),\n-                ModItem::MacroRules(mac) => self.collect_macro_rules(&self.item_tree[mac]),\n+                ModItem::MacroRules(id) => self.collect_macro_rules(id),\n                 ModItem::MacroDef(id) => {\n                     let mac = &self.item_tree[id];\n                     let ast_id = InFile::new(self.file_id, mac.ast_id.upcast());\n \n                     // \"Macro 2.0\" is not currently supported by rust-analyzer, but libcore uses it\n                     // to define builtin macros, so we support at least that part.\n-                    if mac.is_builtin {\n+                    let attrs = self.item_tree.attrs(ModItem::from(id).into());\n+                    if attrs.by_key(\"rustc_builtin_macro\").exists() {\n                         let krate = self.def_collector.def_map.krate;\n                         let macro_id = find_builtin_macro(&mac.name, krate, ast_id)\n                             .or_else(|| find_builtin_derive(&mac.name, krate, ast_id));\n@@ -1300,18 +1302,34 @@ impl ModCollector<'_, '_> {\n         self.def_collector.resolve_proc_macro(&macro_name);\n     }\n \n-    fn collect_macro_rules(&mut self, mac: &MacroRules) {\n+    fn collect_macro_rules(&mut self, id: FileItemTreeId<MacroRules>) {\n+        let mac = &self.item_tree[id];\n+        let attrs = self.item_tree.attrs(ModItem::from(id).into());\n         let ast_id = InFile::new(self.file_id, mac.ast_id.upcast());\n \n+        let export_attr = attrs.by_key(\"macro_export\");\n+\n+        let is_export = export_attr.exists();\n+        let is_local_inner = if is_export {\n+            export_attr.tt_values().map(|it| &it.token_trees).flatten().any(|it| match it {\n+                tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => {\n+                    ident.text.contains(\"local_inner_macros\")\n+                }\n+                _ => false,\n+            })\n+        } else {\n+            false\n+        };\n+\n         // Case 1: builtin macros\n-        if mac.is_builtin {\n+        if attrs.by_key(\"rustc_builtin_macro\").exists() {\n             let krate = self.def_collector.def_map.krate;\n             if let Some(macro_id) = find_builtin_macro(&mac.name, krate, ast_id) {\n                 self.def_collector.define_macro(\n                     self.module_id,\n                     mac.name.clone(),\n                     macro_id,\n-                    mac.is_export,\n+                    is_export,\n                 );\n                 return;\n             }\n@@ -1322,9 +1340,9 @@ impl ModCollector<'_, '_> {\n             ast_id: Some(ast_id),\n             krate: self.def_collector.def_map.krate,\n             kind: MacroDefKind::Declarative,\n-            local_inner: mac.is_local_inner,\n+            local_inner: is_local_inner,\n         };\n-        self.def_collector.define_macro(self.module_id, mac.name.clone(), macro_id, mac.is_export);\n+        self.def_collector.define_macro(self.module_id, mac.name.clone(), macro_id, is_export);\n     }\n \n     fn collect_macro_call(&mut self, mac: &MacroCall) {"}]}