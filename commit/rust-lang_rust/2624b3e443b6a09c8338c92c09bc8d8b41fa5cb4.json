{"sha": "2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2MjRiM2U0NDNiNmEwOWM4MzM4YzkyYzA5YmM4ZDhiNDFmYTVjYjQ=", "commit": {"author": {"name": "Chris Pardy", "email": "chrispardy36@gmail.com", "date": "2020-11-23T01:03:42Z"}, "committer": {"name": "Chris Pardy", "email": "chrispardy36@gmail.com", "date": "2021-01-16T00:39:24Z"}, "message": "Improve diagnostics for Precise Capture", "tree": {"sha": "4c44cb23d6a9ebc3092c4f10bb718a6610bc7b89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c44cb23d6a9ebc3092c4f10bb718a6610bc7b89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4", "html_url": "https://github.com/rust-lang/rust/commit/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/comments", "author": {"login": "ChrisPardy", "id": 25291724, "node_id": "MDQ6VXNlcjI1MjkxNzI0", "avatar_url": "https://avatars.githubusercontent.com/u/25291724?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisPardy", "html_url": "https://github.com/ChrisPardy", "followers_url": "https://api.github.com/users/ChrisPardy/followers", "following_url": "https://api.github.com/users/ChrisPardy/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisPardy/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisPardy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisPardy/subscriptions", "organizations_url": "https://api.github.com/users/ChrisPardy/orgs", "repos_url": "https://api.github.com/users/ChrisPardy/repos", "events_url": "https://api.github.com/users/ChrisPardy/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisPardy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ChrisPardy", "id": 25291724, "node_id": "MDQ6VXNlcjI1MjkxNzI0", "avatar_url": "https://avatars.githubusercontent.com/u/25291724?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisPardy", "html_url": "https://github.com/ChrisPardy", "followers_url": "https://api.github.com/users/ChrisPardy/followers", "following_url": "https://api.github.com/users/ChrisPardy/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisPardy/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisPardy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisPardy/subscriptions", "organizations_url": "https://api.github.com/users/ChrisPardy/orgs", "repos_url": "https://api.github.com/users/ChrisPardy/repos", "events_url": "https://api.github.com/users/ChrisPardy/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisPardy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcbd305ee93f49f19313b9bbeaa25ba8837030d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcbd305ee93f49f19313b9bbeaa25ba8837030d9", "html_url": "https://github.com/rust-lang/rust/commit/fcbd305ee93f49f19313b9bbeaa25ba8837030d9"}], "stats": {"total": 612, "additions": 581, "deletions": 31}, "files": [{"sha": "82f6352872169bf18b9be15278f3915f6d152ed7", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4", "patch": "@@ -741,8 +741,20 @@ pub struct CapturedPlace<'tcx> {\n pub struct CaptureInfo<'tcx> {\n     /// Expr Id pointing to use that resulted in selecting the current capture kind\n     ///\n+    /// Eg:\n+    /// ```rust,no_run\n+    /// let mut t = (0,1);\n+    ///\n+    /// let c = || {\n+    ///     println!(\"{}\",t); // L1\n+    ///     t.1 = 4; // L2\n+    /// };\n+    /// ```\n+    /// `capture_kind_expr_id` will point to the use on L2 and `path_expr_id` will point to the\n+    /// use on L1.\n+    ///\n     /// If the user doesn't enable feature `capture_disjoint_fields` (RFC 2229) then, it is\n-    /// possible that we don't see the use of a particular place resulting in expr_id being\n+    /// possible that we don't see the use of a particular place resulting in capture_kind_expr_id being\n     /// None. In such case we fallback on uvpars_mentioned for span.\n     ///\n     /// Eg:\n@@ -756,7 +768,12 @@ pub struct CaptureInfo<'tcx> {\n     ///\n     /// In this example, if `capture_disjoint_fields` is **not** set, then x will be captured,\n     /// but we won't see it being used during capture analysis, since it's essentially a discard.\n-    pub expr_id: Option<hir::HirId>,\n+    pub capture_kind_expr_id: Option<hir::HirId>,\n+    /// Expr Id pointing to use that resulted the corresponding place being captured\n+    ///\n+    /// See `capture_kind_expr_id` for example.\n+    ///\n+    pub path_expr_id: Option<hir::HirId>,\n \n     /// Capture mode that was selected\n     pub capture_kind: UpvarCapture<'tcx>,"}, {"sha": "44652864f6ef06037e6465fe0a1792859faf2250", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 124, "deletions": 25, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4", "patch": "@@ -42,7 +42,7 @@ use rustc_infer::infer::UpvarRegion;\n use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId, ProjectionKind};\n use rustc_middle::ty::{self, Ty, TyCtxt, UpvarSubsts};\n use rustc_span::sym;\n-use rustc_span::{Span, Symbol};\n+use rustc_span::{MultiSpan, Span, Symbol};\n \n /// Describe the relationship between the paths of two places\n /// eg:\n@@ -135,7 +135,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                     let upvar_id = ty::UpvarId::new(var_hir_id, local_def_id);\n                     let capture_kind = self.init_capture_kind(capture_clause, upvar_id, span);\n-                    let info = ty::CaptureInfo { expr_id: None, capture_kind };\n+                    let info = ty::CaptureInfo {\n+                        capture_kind_expr_id: None,\n+                        path_expr_id: None,\n+                        capture_kind,\n+                    };\n \n                     capture_information.insert(place, info);\n                 }\n@@ -298,8 +302,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         if let Some(capture_kind) = upvar_capture_map.get(&upvar_id) {\n                             // upvar_capture_map only stores the UpvarCapture (CaptureKind),\n                             // so we create a fake capture info with no expression.\n-                            let fake_capture_info =\n-                                ty::CaptureInfo { expr_id: None, capture_kind: *capture_kind };\n+                            let fake_capture_info = ty::CaptureInfo {\n+                                capture_kind_expr_id: None,\n+                                path_expr_id: None,\n+                                capture_kind: *capture_kind,\n+                            };\n                             determine_capture_info(fake_capture_info, capture_info).capture_kind\n                         } else {\n                             capture_info.capture_kind\n@@ -349,20 +356,44 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///\n     /// ```\n     /// {\n-    ///       Place(base: hir_id_s, projections: [], ....) -> (hir_id_L5, ByValue),\n-    ///       Place(base: hir_id_p, projections: [Field(0, 0)], ...) -> (hir_id_L2, ByRef(MutBorrow))\n-    ///       Place(base: hir_id_p, projections: [Field(1, 0)], ...) -> (hir_id_L3, ByRef(ImmutBorrow))\n-    ///       Place(base: hir_id_p, projections: [], ...) -> (hir_id_L4, ByRef(ImmutBorrow))\n+    ///       Place(base: hir_id_s, projections: [], ....) -> {\n+    ///                                                            capture_kind_expr: hir_id_L5,\n+    ///                                                            path_expr_id: hir_id_L5,\n+    ///                                                            capture_kind: ByValue\n+    ///                                                       },\n+    ///       Place(base: hir_id_p, projections: [Field(0, 0)], ...) -> {\n+    ///                                                                     capture_kind_expr: hir_id_L2,\n+    ///                                                                     path_expr_id: hir_id_L2,\n+    ///                                                                     capture_kind: ByValue\n+    ///                                                                 },\n+    ///       Place(base: hir_id_p, projections: [Field(1, 0)], ...) -> {\n+    ///                                                                     capture_kind_expr: hir_id_L3,\n+    ///                                                                     path_expr_id: hir_id_L3,\n+    ///                                                                     capture_kind: ByValue\n+    ///                                                                 },\n+    ///       Place(base: hir_id_p, projections: [], ...) -> {\n+    ///                                                          capture_kind_expr: hir_id_L4,\n+    ///                                                          path_expr_id: hir_id_L4,\n+    ///                                                          capture_kind: ByValue\n+    ///                                                      },\n     /// ```\n     ///\n     /// After the min capture analysis, we get:\n     /// ```\n     /// {\n     ///       hir_id_s -> [\n-    ///            Place(base: hir_id_s, projections: [], ....) -> (hir_id_L4, ByValue)\n+    ///            Place(base: hir_id_s, projections: [], ....) -> {\n+    ///                                                                capture_kind_expr: hir_id_L5,\n+    ///                                                                path_expr_id: hir_id_L5,\n+    ///                                                                capture_kind: ByValue\n+    ///                                                            },\n     ///       ],\n     ///       hir_id_p -> [\n-    ///            Place(base: hir_id_p, projections: [], ...) -> (hir_id_L2, ByRef(MutBorrow)),\n+    ///            Place(base: hir_id_p, projections: [], ...) -> {\n+    ///                                                               capture_kind_expr: hir_id_L2,\n+    ///                                                               path_expr_id: hir_id_L4,\n+    ///                                                               capture_kind: ByValue\n+    ///                                                           },\n     ///       ],\n     /// ```\n     fn compute_min_captures(\n@@ -415,8 +446,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // current place is ancestor of possible_descendant\n                     PlaceAncestryRelation::Ancestor => {\n                         descendant_found = true;\n+                        let backup_path_expr_id = updated_capture_info.path_expr_id;\n+\n                         updated_capture_info =\n                             determine_capture_info(updated_capture_info, possible_descendant.info);\n+\n+                        // we need to keep the ancestor's `path_expr_id`\n+                        updated_capture_info.path_expr_id = backup_path_expr_id;\n                         false\n                     }\n \n@@ -431,9 +467,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // current place is descendant of possible_ancestor\n                         PlaceAncestryRelation::Descendant => {\n                             ancestor_found = true;\n+                            let backup_path_expr_id = possible_ancestor.info.path_expr_id;\n                             possible_ancestor.info =\n                                 determine_capture_info(possible_ancestor.info, capture_info);\n \n+                            // we need to keep the ancestor's `path_expr_id`\n+                            possible_ancestor.info.path_expr_id = backup_path_expr_id;\n+\n                             // Only one ancestor of the current place will be in the list.\n                             break;\n                         }\n@@ -508,7 +548,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let capture_str = construct_capture_info_string(self.tcx, place, capture_info);\n                 let output_str = format!(\"Capturing {}\", capture_str);\n \n-                let span = capture_info.expr_id.map_or(closure_span, |e| self.tcx.hir().span(e));\n+                let span =\n+                    capture_info.path_expr_id.map_or(closure_span, |e| self.tcx.hir().span(e));\n                 diag.span_note(span, &output_str);\n             }\n             diag.emit();\n@@ -532,9 +573,32 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             construct_capture_info_string(self.tcx, place, capture_info);\n                         let output_str = format!(\"Min Capture {}\", capture_str);\n \n-                        let span =\n-                            capture_info.expr_id.map_or(closure_span, |e| self.tcx.hir().span(e));\n-                        diag.span_note(span, &output_str);\n+                        if capture.info.path_expr_id != capture.info.capture_kind_expr_id {\n+                            let path_span = capture_info\n+                                .path_expr_id\n+                                .map_or(closure_span, |e| self.tcx.hir().span(e));\n+                            let capture_kind_span = capture_info\n+                                .capture_kind_expr_id\n+                                .map_or(closure_span, |e| self.tcx.hir().span(e));\n+\n+                            let mut multi_span: MultiSpan =\n+                                MultiSpan::from_spans(vec![path_span, capture_kind_span]);\n+\n+                            let capture_kind_label =\n+                                construct_capture_kind_reason_string(self.tcx, place, capture_info);\n+                            let path_label = construct_path_string(self.tcx, place);\n+\n+                            multi_span.push_span_label(path_span, path_label);\n+                            multi_span.push_span_label(capture_kind_span, capture_kind_label);\n+\n+                            diag.span_note(multi_span, &output_str);\n+                        } else {\n+                            let span = capture_info\n+                                .path_expr_id\n+                                .map_or(closure_span, |e| self.tcx.hir().span(e));\n+\n+                            diag.span_note(span, &output_str);\n+                        };\n                     }\n                 }\n                 diag.emit();\n@@ -632,7 +696,8 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         );\n \n         let capture_info = ty::CaptureInfo {\n-            expr_id: Some(diag_expr_id),\n+            capture_kind_expr_id: Some(diag_expr_id),\n+            path_expr_id: Some(diag_expr_id),\n             capture_kind: ty::UpvarCapture::ByValue(Some(usage_span)),\n         };\n \n@@ -752,7 +817,8 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n             let new_upvar_borrow = ty::UpvarBorrow { kind, region: curr_upvar_borrow.region };\n \n             let capture_info = ty::CaptureInfo {\n-                expr_id: Some(diag_expr_id),\n+                capture_kind_expr_id: Some(diag_expr_id),\n+                path_expr_id: Some(diag_expr_id),\n                 capture_kind: ty::UpvarCapture::ByRef(new_upvar_borrow),\n             };\n             let updated_info = determine_capture_info(curr_capture_info, capture_info);\n@@ -814,7 +880,11 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n                 self.fcx.init_capture_kind(self.capture_clause, upvar_id, self.closure_span);\n \n             let expr_id = Some(diag_expr_id);\n-            let capture_info = ty::CaptureInfo { expr_id, capture_kind };\n+            let capture_info = ty::CaptureInfo {\n+                capture_kind_expr_id: expr_id,\n+                path_expr_id: expr_id,\n+                capture_kind,\n+            };\n \n             debug!(\"Capturing new place {:?}, capture_info={:?}\", place_with_id, capture_info);\n \n@@ -880,11 +950,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n     }\n }\n \n-fn construct_capture_info_string(\n-    tcx: TyCtxt<'_>,\n-    place: &Place<'tcx>,\n-    capture_info: &ty::CaptureInfo<'tcx>,\n-) -> String {\n+fn construct_place_string(tcx: TyCtxt<'_>, place: &Place<'tcx>) -> String {\n     let variable_name = match place.base {\n         PlaceBase::Upvar(upvar_id) => var_name(tcx, upvar_id.var_path.hir_id).to_string(),\n         _ => bug!(\"Capture_information should only contain upvars\"),\n@@ -904,11 +970,42 @@ fn construct_capture_info_string(\n         projections_str.push_str(proj.as_str());\n     }\n \n+    format!(\"{}[{}]\", variable_name, projections_str)\n+}\n+\n+fn construct_capture_kind_reason_string(\n+    tcx: TyCtxt<'_>,\n+    place: &Place<'tcx>,\n+    capture_info: &ty::CaptureInfo<'tcx>,\n+) -> String {\n+    let place_str = construct_place_string(tcx, &place);\n+\n     let capture_kind_str = match capture_info.capture_kind {\n         ty::UpvarCapture::ByValue(_) => \"ByValue\".into(),\n         ty::UpvarCapture::ByRef(borrow) => format!(\"{:?}\", borrow.kind),\n     };\n-    format!(\"{}[{}] -> {}\", variable_name, projections_str, capture_kind_str)\n+\n+    format!(\"{} captured as {} here\", place_str, capture_kind_str)\n+}\n+\n+fn construct_path_string(tcx: TyCtxt<'_>, place: &Place<'tcx>) -> String {\n+    let place_str = construct_place_string(tcx, &place);\n+\n+    format!(\"{} used here\", place_str)\n+}\n+\n+fn construct_capture_info_string(\n+    tcx: TyCtxt<'_>,\n+    place: &Place<'tcx>,\n+    capture_info: &ty::CaptureInfo<'tcx>,\n+) -> String {\n+    let place_str = construct_place_string(tcx, &place);\n+\n+    let capture_kind_str = match capture_info.capture_kind {\n+        ty::UpvarCapture::ByValue(_) => \"ByValue\".into(),\n+        ty::UpvarCapture::ByRef(borrow) => format!(\"{:?}\", borrow.kind),\n+    };\n+    format!(\"{} -> {}\", place_str, capture_kind_str)\n }\n \n fn var_name(tcx: TyCtxt<'_>, var_hir_id: hir::HirId) -> Symbol {\n@@ -920,7 +1017,9 @@ fn var_name(tcx: TyCtxt<'_>, var_hir_id: hir::HirId) -> Symbol {\n /// (Note: CaptureInfo contains CaptureKind and an expression that led to capture it in that way)\n ///\n /// If both `CaptureKind`s are considered equivalent, then the CaptureInfo is selected based\n-/// on the `CaptureInfo` containing an associated expression id.\n+/// on the `CaptureInfo` containing an associated `capture_kind_expr_id`.\n+///\n+/// It is the caller's duty to figure out which path_expr_id to use.\n ///\n /// If both the CaptureKind and Expression are considered to be equivalent,\n /// then `CaptureInfo` A is preferred. This can be useful in cases where we want to priortize\n@@ -971,7 +1070,7 @@ fn determine_capture_info(\n     };\n \n     if eq_capture_kind {\n-        match (capture_info_a.expr_id, capture_info_b.expr_id) {\n+        match (capture_info_a.capture_kind_expr_id, capture_info_b.capture_kind_expr_id) {\n             (Some(_), _) | (None, None) => capture_info_a,\n             (None, Some(_)) => capture_info_b,\n         }"}, {"sha": "3612da1ffa3d198365c87100c2bcda021f0ba072", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4", "patch": "@@ -348,7 +348,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 let min_list_wb = min_list\n                     .iter()\n                     .map(|captured_place| {\n-                        let locatable = captured_place.info.expr_id.unwrap_or(\n+                        let locatable = captured_place.info.path_expr_id.unwrap_or(\n                             self.tcx().hir().local_def_id_to_hir_id(closure_def_id.expect_local()),\n                         );\n "}, {"sha": "b6f77aedc166110a94457c23627ba8725a95c9e1", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4", "patch": "@@ -630,7 +630,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                         PlaceBase::Local(*var_hir_id)\n                     };\n                     let place_with_id = PlaceWithHirId::new(\n-                        capture_info.expr_id.unwrap_or(closure_expr.hir_id),\n+                        capture_info.path_expr_id.unwrap_or(closure_expr.hir_id),\n                         place.base_ty,\n                         place_base,\n                         place.projections.clone(),"}, {"sha": "fbcba6fc200e2089c59df46fdd2a399bf882e4dc", "filename": "src/test/ui/closures/2229_closure_analysis/capture-analysis-1.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-1.rs?ref=2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4", "patch": "@@ -0,0 +1,36 @@\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+#[derive(Debug)]\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+fn main() {\n+    let p = Point { x: 10, y: 10 };\n+    let q = Point { x: 10, y: 10 };\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ First Pass analysis includes:\n+    //~| Min Capture analysis includes:\n+        println!(\"{:?}\", p);\n+        //~^ NOTE: Capturing p[] -> ImmBorrow\n+        //~| NOTE: Min Capture p[] -> ImmBorrow\n+        println!(\"{:?}\", p.x);\n+        //~^ NOTE: Capturing p[(0, 0)] -> ImmBorrow\n+\n+        println!(\"{:?}\", q.x);\n+        //~^ NOTE: Capturing q[(0, 0)] -> ImmBorrow\n+        println!(\"{:?}\", q);\n+        //~^ NOTE: Capturing q[] -> ImmBorrow\n+        //~| NOTE: Min Capture q[] -> ImmBorrow\n+    };\n+}\n\\ No newline at end of file"}, {"sha": "f15d656be64a5fce99adf01acf8121ee215e9b9d", "filename": "src/test/ui/closures/2229_closure_analysis/capture-analysis-1.stderr", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-1.stderr?ref=2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4", "patch": "@@ -0,0 +1,77 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/capture-analysis-1.rs:18:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/capture-analysis-1.rs:2:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/capture-analysis-1.rs:21:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         println!(\"{:?}\", p);\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing p[] -> ImmBorrow\n+  --> $DIR/capture-analysis-1.rs:24:26\n+   |\n+LL |         println!(\"{:?}\", p);\n+   |                          ^\n+note: Capturing p[(0, 0)] -> ImmBorrow\n+  --> $DIR/capture-analysis-1.rs:27:26\n+   |\n+LL |         println!(\"{:?}\", p.x);\n+   |                          ^^^\n+note: Capturing q[(0, 0)] -> ImmBorrow\n+  --> $DIR/capture-analysis-1.rs:30:26\n+   |\n+LL |         println!(\"{:?}\", q.x);\n+   |                          ^^^\n+note: Capturing q[] -> ImmBorrow\n+  --> $DIR/capture-analysis-1.rs:32:26\n+   |\n+LL |         println!(\"{:?}\", q);\n+   |                          ^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/capture-analysis-1.rs:21:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         println!(\"{:?}\", p);\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture p[] -> ImmBorrow\n+  --> $DIR/capture-analysis-1.rs:24:26\n+   |\n+LL |         println!(\"{:?}\", p);\n+   |                          ^\n+note: Min Capture q[] -> ImmBorrow\n+  --> $DIR/capture-analysis-1.rs:32:26\n+   |\n+LL |         println!(\"{:?}\", q);\n+   |                          ^\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "7758dac4a56352698af2d9720b9343aff1cacd41", "filename": "src/test/ui/closures/2229_closure_analysis/capture-analysis-2.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-2.rs?ref=2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4", "patch": "@@ -0,0 +1,31 @@\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+#[derive(Debug)]\n+struct Point {\n+    x: String,\n+    y: i32,\n+}\n+\n+fn main() {\n+    let mut p = Point { x: String::new(), y: 10 };\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ First Pass analysis includes:\n+    //~| Min Capture analysis includes:\n+        let _x = p.x;\n+        //~^ NOTE: Capturing p[(0, 0)] -> ByValue\n+        //~| NOTE: p[] captured as ByValue here\n+        println!(\"{:?}\", p);\n+        //~^ NOTE: Capturing p[] -> ImmBorrow\n+        //~| NOTE: Min Capture p[] -> ByValue\n+        //~| NOTE: p[] used here\n+    };\n+}\n\\ No newline at end of file"}, {"sha": "2805476d8d272e87d39d215099d3ada030960283", "filename": "src/test/ui/closures/2229_closure_analysis/capture-analysis-2.stderr", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-2.stderr?ref=2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4", "patch": "@@ -0,0 +1,65 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/capture-analysis-2.rs:17:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/capture-analysis-2.rs:2:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/capture-analysis-2.rs:20:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let _x = p.x;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing p[(0, 0)] -> ByValue\n+  --> $DIR/capture-analysis-2.rs:23:18\n+   |\n+LL |         let _x = p.x;\n+   |                  ^^^\n+note: Capturing p[] -> ImmBorrow\n+  --> $DIR/capture-analysis-2.rs:26:26\n+   |\n+LL |         println!(\"{:?}\", p);\n+   |                          ^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/capture-analysis-2.rs:20:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let _x = p.x;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture p[] -> ByValue\n+  --> $DIR/capture-analysis-2.rs:23:18\n+   |\n+LL |         let _x = p.x;\n+   |                  ^^^ p[] captured as ByValue here\n+...\n+LL |         println!(\"{:?}\", p);\n+   |                          ^ p[] used here\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "f81866bb7e0967ea8e0780517af02e5a7ded4f5f", "filename": "src/test/ui/closures/2229_closure_analysis/deep-multilevel-struct.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-struct.rs?ref=2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4", "patch": "@@ -0,0 +1,52 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+#![allow(unused)]\n+\n+#[derive(Debug)]\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+#[derive(Debug)]\n+struct Line {\n+    p: Point,\n+    q: Point\n+}\n+#[derive(Debug)]\n+struct Plane {\n+    a: Line,\n+    b: Line,\n+}\n+\n+fn main() {\n+    let mut p = Plane {\n+        a: Line {\n+            p: Point { x: 1,y: 2 },\n+            q: Point { x: 3,y: 4 },\n+        },\n+        b: Line {\n+            p: Point { x: 1,y: 2 },\n+            q: Point { x: 3,y: 4 },\n+        }\n+    };\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        let x = &p.a.p.x;\n+        //~^ NOTE: Capturing p[(0, 0),(0, 0),(0, 0)] -> ImmBorrow\n+        p.b.q.y = 9;\n+        //~^ NOTE: Capturing p[(1, 0),(1, 0),(1, 0)] -> MutBorrow\n+        //~| NOTE: p[] captured as MutBorrow here\n+        println!(\"{:?}\", p);\n+        //~^ NOTE: Capturing p[] -> ImmBorrow\n+        //~| NOTE: Min Capture p[] -> MutBorrow\n+        //~| NOTE: p[] used here\n+    };\n+}"}, {"sha": "863f1009131a161d0e963469d5dab132d85a54ba", "filename": "src/test/ui/closures/2229_closure_analysis/deep-multilevel-struct.stderr", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-struct.stderr?ref=2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4", "patch": "@@ -0,0 +1,70 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/deep-multilevel-struct.rs:36:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/deep-multilevel-struct.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/deep-multilevel-struct.rs:39:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let x = &p.a.p.x;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing p[(0, 0),(0, 0),(0, 0)] -> ImmBorrow\n+  --> $DIR/deep-multilevel-struct.rs:42:18\n+   |\n+LL |         let x = &p.a.p.x;\n+   |                  ^^^^^^^\n+note: Capturing p[(1, 0),(1, 0),(1, 0)] -> MutBorrow\n+  --> $DIR/deep-multilevel-struct.rs:44:9\n+   |\n+LL |         p.b.q.y = 9;\n+   |         ^^^^^^^\n+note: Capturing p[] -> ImmBorrow\n+  --> $DIR/deep-multilevel-struct.rs:47:26\n+   |\n+LL |         println!(\"{:?}\", p);\n+   |                          ^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/deep-multilevel-struct.rs:39:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let x = &p.a.p.x;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture p[] -> MutBorrow\n+  --> $DIR/deep-multilevel-struct.rs:44:9\n+   |\n+LL |         p.b.q.y = 9;\n+   |         ^^^^^^^ p[] captured as MutBorrow here\n+...\n+LL |         println!(\"{:?}\", p);\n+   |                          ^ p[] used here\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "8f53b2b8aa0902479e9d9175e2b582cf2cc72b6a", "filename": "src/test/ui/closures/2229_closure_analysis/deep-multilevel-tuple.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-tuple.rs?ref=2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4", "patch": "@@ -0,0 +1,28 @@\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+#![allow(unused)]\n+\n+fn main() {\n+    let mut t = (((1,2),(3,4)),((5,6),(7,8)));\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        let x = &t.0.0.0;\n+        //~^ NOTE: Capturing t[(0, 0),(0, 0),(0, 0)] -> ImmBorrow\n+        t.1.1.1 = 9;\n+        //~^ NOTE: Capturing t[(1, 0),(1, 0),(1, 0)] -> MutBorrow\n+        //~| NOTE: t[] captured as MutBorrow here\n+        println!(\"{:?}\", t);\n+        //~^ NOTE: Min Capture t[] -> MutBorrow\n+        //~| NOTE: Capturing t[] -> ImmBorrow\n+        //~| NOTE: t[] used here\n+    };\n+}"}, {"sha": "8fce18f3d6084bcfbc85b86069db9941bfc4c9b9", "filename": "src/test/ui/closures/2229_closure_analysis/deep-multilevel-tuple.stderr", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-tuple.stderr?ref=2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4", "patch": "@@ -0,0 +1,70 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/deep-multilevel-tuple.rs:12:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/deep-multilevel-tuple.rs:2:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/deep-multilevel-tuple.rs:15:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let x = &t.0.0.0;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing t[(0, 0),(0, 0),(0, 0)] -> ImmBorrow\n+  --> $DIR/deep-multilevel-tuple.rs:18:18\n+   |\n+LL |         let x = &t.0.0.0;\n+   |                  ^^^^^^^\n+note: Capturing t[(1, 0),(1, 0),(1, 0)] -> MutBorrow\n+  --> $DIR/deep-multilevel-tuple.rs:20:9\n+   |\n+LL |         t.1.1.1 = 9;\n+   |         ^^^^^^^\n+note: Capturing t[] -> ImmBorrow\n+  --> $DIR/deep-multilevel-tuple.rs:23:26\n+   |\n+LL |         println!(\"{:?}\", t);\n+   |                          ^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/deep-multilevel-tuple.rs:15:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let x = &t.0.0.0;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture t[] -> MutBorrow\n+  --> $DIR/deep-multilevel-tuple.rs:20:9\n+   |\n+LL |         t.1.1.1 = 9;\n+   |         ^^^^^^^ t[] captured as MutBorrow here\n+...\n+LL |         println!(\"{:?}\", t);\n+   |                          ^ t[] used here\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "a6b5e12d2ed78e4d6f562d00794764af78f67f10", "filename": "src/test/ui/closures/2229_closure_analysis/simple-struct-min-capture.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fsimple-struct-min-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fsimple-struct-min-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fsimple-struct-min-capture.rs?ref=2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4", "patch": "@@ -32,9 +32,11 @@ fn main() {\n     //~| ERROR: Min Capture analysis includes:\n         p.x += 10;\n         //~^ NOTE: Capturing p[(0, 0)] -> MutBorrow\n-        //~| NOTE: Min Capture p[] -> MutBorrow\n+        //~| NOTE: p[] captured as MutBorrow here\n         println!(\"{:?}\", p);\n         //~^ NOTE: Capturing p[] -> ImmBorrow\n+        //~| NOTE: Min Capture p[] -> MutBorrow\n+        //~| NOTE: p[] used here\n     };\n \n     c();"}, {"sha": "cbbc8792199153639bdd13bb1074e16e5b299074", "filename": "src/test/ui/closures/2229_closure_analysis/simple-struct-min-capture.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fsimple-struct-min-capture.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fsimple-struct-min-capture.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fsimple-struct-min-capture.stderr?ref=2624b3e443b6a09c8338c92c09bc8d8b41fa5cb4", "patch": "@@ -55,7 +55,10 @@ note: Min Capture p[] -> MutBorrow\n   --> $DIR/simple-struct-min-capture.rs:33:9\n    |\n LL |         p.x += 10;\n-   |         ^^^\n+   |         ^^^ p[] captured as MutBorrow here\n+...\n+LL |         println!(\"{:?}\", p);\n+   |                          ^ p[] used here\n \n error: aborting due to 3 previous errors; 1 warning emitted\n "}]}