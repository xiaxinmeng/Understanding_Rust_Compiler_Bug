{"sha": "452817b854868d934643cc9e0a8848404ea4ee10", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1MjgxN2I4NTQ4NjhkOTM0NjQzY2M5ZTBhODg0ODQwNGVhNGVlMTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-07T19:42:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-07T19:42:41Z"}, "message": "auto merge of #6292 : thestinger/rust/cleanup, r=brson", "tree": {"sha": "bb0d143c12128794e5e2dad90bb0aeb359fa6db8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb0d143c12128794e5e2dad90bb0aeb359fa6db8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/452817b854868d934643cc9e0a8848404ea4ee10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/452817b854868d934643cc9e0a8848404ea4ee10", "html_url": "https://github.com/rust-lang/rust/commit/452817b854868d934643cc9e0a8848404ea4ee10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/452817b854868d934643cc9e0a8848404ea4ee10/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "506392830052ec5da8ad0cdb0afc3439ec69f938", "url": "https://api.github.com/repos/rust-lang/rust/commits/506392830052ec5da8ad0cdb0afc3439ec69f938", "html_url": "https://github.com/rust-lang/rust/commit/506392830052ec5da8ad0cdb0afc3439ec69f938"}, {"sha": "d800147abba010328c00e7518073085ed6ceb133", "url": "https://api.github.com/repos/rust-lang/rust/commits/d800147abba010328c00e7518073085ed6ceb133", "html_url": "https://github.com/rust-lang/rust/commit/d800147abba010328c00e7518073085ed6ceb133"}], "stats": {"total": 105, "additions": 93, "deletions": 12}, "files": [{"sha": "47fcb224a73487251dd69bf1e722ac4db75ad68d", "filename": "mk/install.mk", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/452817b854868d934643cc9e0a8848404ea4ee10/mk%2Finstall.mk", "raw_url": "https://github.com/rust-lang/rust/raw/452817b854868d934643cc9e0a8848404ea4ee10/mk%2Finstall.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Finstall.mk?ref=452817b854868d934643cc9e0a8848404ea4ee10", "patch": "@@ -192,9 +192,9 @@ ifeq ($(CFG_ADB_DEVICE_STATUS),true)\n ifdef VERBOSE\n  ADB = adb $(1)\n  ADB_PUSH = adb push $(1) $(2)\n- ADB_SHELL = adb shell $(1) $(2) \n+ ADB_SHELL = adb shell $(1) $(2)\n else\n- ADB = $(Q)$(call E, adb $(1)) && adb $(1) 1>/dev/null \n+ ADB = $(Q)$(call E, adb $(1)) && adb $(1) 1>/dev/null\n  ADB_PUSH = $(Q)$(call E, adb push $(1)) && adb push $(1) $(2) 1>/dev/null\n  ADB_SHELL = $(Q)$(call E, adb shell $(1) $(2)) && adb shell $(1) $(2) 1>/dev/null\n endif\n@@ -222,8 +222,8 @@ install-runtime-target: \\\n \tinstall-runtime-target-arm-linux-androideabi-cleanup \\\n \tinstall-runtime-target-arm-linux-androideabi-host-$(CFG_BUILD_TRIPLE)\n else\n-install-runtime-target: \n+install-runtime-target:\n \t@echo \"No device to install runtime library\"\n-\t@echo \n+\t@echo\n endif\n endif"}, {"sha": "8ac2ad68e3ab8965c730a3c872a66968e5b25943", "filename": "mk/tests.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/452817b854868d934643cc9e0a8848404ea4ee10/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/452817b854868d934643cc9e0a8848404ea4ee10/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=452817b854868d934643cc9e0a8848404ea4ee10", "patch": "@@ -92,7 +92,7 @@ endef\n $(foreach target,$(CFG_TARGET_TRIPLES), \\\n   $(eval $(call DEF_TARGET_COMMANDS,$(target))))\n \n-# Target platform specific variables \n+# Target platform specific variables\n # for arm-linux-androidabi\n define DEF_ADB_DEVICE_STATUS\n CFG_ADB_DEVICE_STATUS=$(1)\n@@ -402,7 +402,7 @@ $(foreach host,$(CFG_HOST_TRIPLES), \\\n        $(eval $(call DEF_TEST_CRATE_RULES_null,$(stage),$(target),$(host),$(crate))) \\\n       ), \\\n       $(eval $(call DEF_TEST_CRATE_RULES,$(stage),$(target),$(host),$(crate))) \\\n-     )))))) \n+     ))))))\n \n \n ######################################################################"}, {"sha": "b764fccf64cff0ec65c2cdd487cdaa509543c0ea", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 75, "deletions": 3, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/452817b854868d934643cc9e0a8848404ea4ee10/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/452817b854868d934643cc9e0a8848404ea4ee10/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=452817b854868d934643cc9e0a8848404ea4ee10", "patch": "@@ -352,16 +352,27 @@ impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n     }\n \n     /// Return a mutable reference to the value corresponding to the key\n+    #[cfg(stage0)]\n     fn find_mut<'a>(&'a mut self, k: &K) -> Option<&'a mut V> {\n         let idx = match self.bucket_for_key(k) {\n             FoundEntry(idx) => idx,\n             TableFull | FoundHole(_) => return None\n         };\n-        unsafe {  // FIXME(#4903)---requires flow-sensitive borrow checker\n+        unsafe {\n             Some(::cast::transmute_mut_region(self.mut_value_for_bucket(idx)))\n         }\n     }\n \n+    /// Return a mutable reference to the value corresponding to the key\n+    #[cfg(not(stage0))]\n+    fn find_mut<'a>(&'a mut self, k: &K) -> Option<&'a mut V> {\n+        let idx = match self.bucket_for_key(k) {\n+            FoundEntry(idx) => idx,\n+            TableFull | FoundHole(_) => return None\n+        };\n+        Some(self.mut_value_for_bucket(idx))\n+    }\n+\n     /// Insert a key-value pair into the map. An existing value for a\n     /// key is replaced by the new value. Return true if the key did\n     /// not already exist in the map.\n@@ -424,6 +435,7 @@ pub impl<K: Hash + Eq, V> HashMap<K, V> {\n \n     /// Return the value corresponding to the key in the map, or insert\n     /// and return the value if it doesn't exist.\n+    #[cfg(stage0)]\n     fn find_or_insert<'a>(&'a mut self, k: K, v: V) -> &'a V {\n         if self.size >= self.resize_at {\n             // n.b.: We could also do this after searching, so\n@@ -447,13 +459,43 @@ pub impl<K: Hash + Eq, V> HashMap<K, V> {\n             },\n         };\n \n-        unsafe { // FIXME(#4903)---requires flow-sensitive borrow checker\n+        unsafe {\n             ::cast::transmute_region(self.value_for_bucket(idx))\n         }\n     }\n \n+    /// Return the value corresponding to the key in the map, or insert\n+    /// and return the value if it doesn't exist.\n+    #[cfg(not(stage0))]\n+    fn find_or_insert<'a>(&'a mut self, k: K, v: V) -> &'a V {\n+        if self.size >= self.resize_at {\n+            // n.b.: We could also do this after searching, so\n+            // that we do not resize if this call to insert is\n+            // simply going to update a key in place.  My sense\n+            // though is that it's worse to have to search through\n+            // buckets to find the right spot twice than to just\n+            // resize in this corner case.\n+            self.expand();\n+        }\n+\n+        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n+        let idx = match self.bucket_for_key_with_hash(hash, &k) {\n+            TableFull => fail!(~\"Internal logic error\"),\n+            FoundEntry(idx) => idx,\n+            FoundHole(idx) => {\n+                self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n+                                     value: v});\n+                self.size += 1;\n+                idx\n+            },\n+        };\n+\n+        self.value_for_bucket(idx)\n+    }\n+\n     /// Return the value corresponding to the key in the map, or create,\n     /// insert, and return a new value if it doesn't exist.\n+    #[cfg(stage0)]\n     fn find_or_insert_with<'a>(&'a mut self, k: K, f: &fn(&K) -> V) -> &'a V {\n         if self.size >= self.resize_at {\n             // n.b.: We could also do this after searching, so\n@@ -478,11 +520,41 @@ pub impl<K: Hash + Eq, V> HashMap<K, V> {\n             },\n         };\n \n-        unsafe { // FIXME(#4903)---requires flow-sensitive borrow checker\n+        unsafe {\n             ::cast::transmute_region(self.value_for_bucket(idx))\n         }\n     }\n \n+    /// Return the value corresponding to the key in the map, or create,\n+    /// insert, and return a new value if it doesn't exist.\n+    #[cfg(not(stage0))]\n+    fn find_or_insert_with<'a>(&'a mut self, k: K, f: &fn(&K) -> V) -> &'a V {\n+        if self.size >= self.resize_at {\n+            // n.b.: We could also do this after searching, so\n+            // that we do not resize if this call to insert is\n+            // simply going to update a key in place.  My sense\n+            // though is that it's worse to have to search through\n+            // buckets to find the right spot twice than to just\n+            // resize in this corner case.\n+            self.expand();\n+        }\n+\n+        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n+        let idx = match self.bucket_for_key_with_hash(hash, &k) {\n+            TableFull => fail!(~\"Internal logic error\"),\n+            FoundEntry(idx) => idx,\n+            FoundHole(idx) => {\n+                let v = f(&k);\n+                self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n+                                     value: v});\n+                self.size += 1;\n+                idx\n+            },\n+        };\n+\n+        self.value_for_bucket(idx)\n+    }\n+\n     fn consume(&mut self, f: &fn(K, V)) {\n         let mut buckets = ~[];\n         self.buckets <-> buckets;"}, {"sha": "af1c1aa83c3d16df25c9fe600c480056e46efed7", "filename": "src/libcore/trie.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/452817b854868d934643cc9e0a8848404ea4ee10/src%2Flibcore%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/452817b854868d934643cc9e0a8848404ea4ee10/src%2Flibcore%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftrie.rs?ref=452817b854868d934643cc9e0a8848404ea4ee10", "patch": "@@ -289,9 +289,9 @@ fn chunk(n: uint, idx: uint) -> uint {\n     (n >> sh) & MASK\n }\n \n-fn find_mut<'r, T>(child: &'r mut Child<T>, key: uint, idx: uint)\n-                -> Option<&'r mut T> {\n-    unsafe { // FIXME(#4903)---requires flow-sensitive borrow checker\n+#[cfg(stage0)]\n+fn find_mut<'r, T>(child: &'r mut Child<T>, key: uint, idx: uint) -> Option<&'r mut T> {\n+    unsafe {\n         (match *child {\n             External(_, ref value) => Some(cast::transmute_mut(value)),\n             Internal(ref x) => find_mut(cast::transmute_mut(&x.children[chunk(key, idx)]),\n@@ -301,6 +301,15 @@ fn find_mut<'r, T>(child: &'r mut Child<T>, key: uint, idx: uint)\n     }\n }\n \n+#[cfg(not(stage0))]\n+fn find_mut<'r, T>(child: &'r mut Child<T>, key: uint, idx: uint) -> Option<&'r mut T> {\n+    match *child {\n+        External(_, ref mut value) => Some(value),\n+        Internal(ref mut x) => find_mut(&mut x.children[chunk(key, idx)], key, idx + 1),\n+        Nothing => None\n+    }\n+}\n+\n fn insert<T>(count: &mut uint, child: &mut Child<T>, key: uint, value: T,\n              idx: uint) -> Option<T> {\n     let mut tmp = Nothing;"}]}