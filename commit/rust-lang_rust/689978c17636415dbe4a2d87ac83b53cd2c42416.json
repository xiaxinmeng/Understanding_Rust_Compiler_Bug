{"sha": "689978c17636415dbe4a2d87ac83b53cd2c42416", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4OTk3OGMxNzYzNjQxNWRiZTRhMmQ4N2FjODNiNTNjZDJjNDI0MTY=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-04-08T18:29:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-08T18:29:54Z"}, "message": "Rollup merge of #80733 - steffahn:prettify_pin_links, r=jyn514\n\nImprove links in inline code in `core::pin`.\n\n## Context\n\nSo I recently opened #80720. That PR uses HTML-based `<code>foo</code>` syntax in place of `` `foo` `` for some inline code. It looks like usage of `<code>` tags in doc comments is without precedent in the standard library, but the HTML-based syntax has an important advantage:\n\nYou can write something like\n```\n<code>[Box]<[Option]\\<T>></code>\n```\nwhich becomes: <code>[Box]<[Option]\\<T>></code>, whereas with ordinary backtick syntax, you cannot create links for a substring of an inline code block.\n\n## Problem\nI recalled (from my own experience) that a way to partially work around this limitation is to do something like\n```\n[`Box`]`<`[`Option`]`<T>>`\n```\nwhich looks like this: [`Box`]`<`[`Option`]`<T>>` _(admitted, it looks even worse on GitHub than in `rustdoc`\u2019s CSS)_.\n\n[Box]: https://doc.rust-lang.org/std/boxed/struct.Box.html \"Box\"\n[`Box`]: https://doc.rust-lang.org/std/boxed/struct.Box.html \"Box\"\n[Option]: https://doc.rust-lang.org/std/option/enum.Option.html \"Option\"\n[`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html \"Option\"\n[Pin]: https://doc.rust-lang.org/std/pin/struct.Pin.html \"Pin\"\n[&mut]: https://doc.rust-lang.org/std/primitive.reference.html \"mutable reference\"\n\nSo I searched the standard library and found that e.g. the [std::pin](https://doc.rust-lang.org/std/pin/index.html) module documentation uses this hack/workaround quite a bit, with types like <code>[Pin]<[Box]\\<T>></code> or <code>[Pin]<[&mut] T>></code>. Although the way they look like in this sentence is what I would like them to look like, not what they currently look.\n\n### Status Quo\n\nHere\u2019s a screenshot of what it currently looks like:\n![Screenshot_20210105_202751](https://user-images.githubusercontent.com/3986214/103692608-4a978780-4f98-11eb-9451-e13622b2e3c0.png)\n\nWith a few HTML-style code blocks, we can fix all the spacing issues in the above screenshot that are due usage of this hack/workaround of putting multiple code blocks right next to each other being used.\n\n### after d3915c555ee016b11ce288e107e46dbab9f78c4f:\n![Screenshot_20210105_202932](https://user-images.githubusercontent.com/3986214/103692688-6f8bfa80-4f98-11eb-9be5-9b370eaef644.png)\n\nThere\u2019s still a problem of inconsistency. Especially in a sentence such as\n> A [`Pin<P>`][Pin] where `P: Deref` should be considered as a \"`P`-style pointer\" to _[...]_\n\nlooks weird with the variable `P` having different colors (and `Deref` has a different color from before where it was a link, too). Or compare the difference of <code>[Pin]<[Box]\\<T>></code> vs [`Box<T>`][Box] where one time the variable is part of the link and the other time it isn\u2019t.\n\n_Note: Color differences show even **more strongly** when the ayu theme is used, while they are a bit less prominent in the light theme than they are in the dark theme, which is the one used for these screenshots._\n\nThis is why I\u2019ve added the next commit\n### after ceaeb249a3813a78bd81fa3890e27e8843a58262\n![Screenshot_20210105_203113](https://user-images.githubusercontent.com/3986214/103693496-ab738f80-4f99-11eb-942d-29dace459734.png)\npulling all the type parameters out of their links, and also the last commit with clearly visible changes\n### after 87ac118ba3d0c8268e043fadbd63b51e06904795\n![Screenshot_20210105_203252](https://user-images.githubusercontent.com/3986214/103693625-e5dd2c80-4f99-11eb-91b7-470c37934e7e.png)\nwhere more links are added, removing e.g. the inconsistency with `Deref`\u2019s color in e.g. `P: Deref` that I already mentioned above.\n\n## Discussion\n\nI am aware that this PR may very well be overkill. If for now only the first commit (plus the fix for the `Drop` link in e65385fbfa72995b27ec64aa54f330cf503dfc03, the link titles 684edf7a70d2e90466ae74e7a321670259bf3fd9 as far as they apply, and a few of the line-break changes) are wanted, I can reduce this PR to just those changes. I personally find the rendered result with all these changes very nice though. On the other hand, all these `<code>` tags are not very nice in the source code, I\u2019ll admit.\n\nPerhaps alternative solutions could be preferred, such as `rustdoc` support for merging subsequent inline code blocks so that all the cases that currently use workarounds rendered as [`Box`]`<`[`Option`]`<T>>` automatically become <code>[Box]<[Option]\\<T>></code> without any need for further changes. Even in this case, having a properly formatted, better looking example in the standard library docs could help motivate such a change to `rustdoc` by prodiving an example of the expected results and also the already existing alternative (i.e. using `<code>`). On the other hand, `` [`Box`]`<`[`Option`]`<T>>` `` isn\u2019t particularly nice-looking source code either. I\u2019m not even sure if I wouldn\u2019t actually find the version `<code>[Box]<[Option]\\<T>></code>` cleaner to read.\n\n`@rustbot` modify labels: T-doc, T-rustdoc", "tree": {"sha": "01f1c7d3451a70fa7ce9947d3dd4bd052236972c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01f1c7d3451a70fa7ce9947d3dd4bd052236972c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/689978c17636415dbe4a2d87ac83b53cd2c42416", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgb0ujCRBK7hj4Ov3rIwAAdHIIAEcns+MBgtuE6BaqKj0pLPwV\niIEj7t4BIRMdGzIucyWUELR+Pqwv17bA9+zDcmXzIxn/ov+PaaCvfimPAOpyVchY\n7wasUdBrl+C6sHCdCPwSAdJ5AMBUbwzDZrDXDM5BaY5OSCpDc5Tt2wSWQ40P/+HR\nbVVk2ig+eQ0W1d25KYmLTo/nymBwjY2DLXCy4R2G9zLjg8ln6EqTFJTKSQ52YaPw\n7phV1vt/H84Ut4W5WCxPSG7I8On1QAwkk73lkX0EZclpLhJu5IT/aMzd3mdUV5H8\niIjZryDEkJjSqyDhYIgPT85ELbywujzu5bHwuP27I/Y3uF5MMazXlaxaj8psMjs=\n=WlS3\n-----END PGP SIGNATURE-----\n", "payload": "tree 01f1c7d3451a70fa7ce9947d3dd4bd052236972c\nparent 010c2368fa33ef08df3080228498db8d2ba5a93b\nparent 3e0cef7d6937e17b67dec25477ed56ef2386a3e0\nauthor Dylan DPC <dylan.dpc@gmail.com> 1617906594 +0200\ncommitter GitHub <noreply@github.com> 1617906594 +0200\n\nRollup merge of #80733 - steffahn:prettify_pin_links, r=jyn514\n\nImprove links in inline code in `core::pin`.\n\n## Context\n\nSo I recently opened #80720. That PR uses HTML-based `<code>foo</code>` syntax in place of `` `foo` `` for some inline code. It looks like usage of `<code>` tags in doc comments is without precedent in the standard library, but the HTML-based syntax has an important advantage:\n\nYou can write something like\n```\n<code>[Box]<[Option]\\<T>></code>\n```\nwhich becomes: <code>[Box]<[Option]\\<T>></code>, whereas with ordinary backtick syntax, you cannot create links for a substring of an inline code block.\n\n## Problem\nI recalled (from my own experience) that a way to partially work around this limitation is to do something like\n```\n[`Box`]`<`[`Option`]`<T>>`\n```\nwhich looks like this: [`Box`]`<`[`Option`]`<T>>` _(admitted, it looks even worse on GitHub than in `rustdoc`\u2019s CSS)_.\n\n[Box]: https://doc.rust-lang.org/std/boxed/struct.Box.html \"Box\"\n[`Box`]: https://doc.rust-lang.org/std/boxed/struct.Box.html \"Box\"\n[Option]: https://doc.rust-lang.org/std/option/enum.Option.html \"Option\"\n[`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html \"Option\"\n[Pin]: https://doc.rust-lang.org/std/pin/struct.Pin.html \"Pin\"\n[&mut]: https://doc.rust-lang.org/std/primitive.reference.html \"mutable reference\"\n\nSo I searched the standard library and found that e.g. the [std::pin](https://doc.rust-lang.org/std/pin/index.html) module documentation uses this hack/workaround quite a bit, with types like <code>[Pin]<[Box]\\<T>></code> or <code>[Pin]<[&mut] T>></code>. Although the way they look like in this sentence is what I would like them to look like, not what they currently look.\n\n### Status Quo\n\nHere\u2019s a screenshot of what it currently looks like:\n![Screenshot_20210105_202751](https://user-images.githubusercontent.com/3986214/103692608-4a978780-4f98-11eb-9451-e13622b2e3c0.png)\n\nWith a few HTML-style code blocks, we can fix all the spacing issues in the above screenshot that are due usage of this hack/workaround of putting multiple code blocks right next to each other being used.\n\n### after d3915c555ee016b11ce288e107e46dbab9f78c4f:\n![Screenshot_20210105_202932](https://user-images.githubusercontent.com/3986214/103692688-6f8bfa80-4f98-11eb-9be5-9b370eaef644.png)\n\nThere\u2019s still a problem of inconsistency. Especially in a sentence such as\n> A [`Pin<P>`][Pin] where `P: Deref` should be considered as a \"`P`-style pointer\" to _[...]_\n\nlooks weird with the variable `P` having different colors (and `Deref` has a different color from before where it was a link, too). Or compare the difference of <code>[Pin]<[Box]\\<T>></code> vs [`Box<T>`][Box] where one time the variable is part of the link and the other time it isn\u2019t.\n\n_Note: Color differences show even **more strongly** when the ayu theme is used, while they are a bit less prominent in the light theme than they are in the dark theme, which is the one used for these screenshots._\n\nThis is why I\u2019ve added the next commit\n### after ceaeb249a3813a78bd81fa3890e27e8843a58262\n![Screenshot_20210105_203113](https://user-images.githubusercontent.com/3986214/103693496-ab738f80-4f99-11eb-942d-29dace459734.png)\npulling all the type parameters out of their links, and also the last commit with clearly visible changes\n### after 87ac118ba3d0c8268e043fadbd63b51e06904795\n![Screenshot_20210105_203252](https://user-images.githubusercontent.com/3986214/103693625-e5dd2c80-4f99-11eb-91b7-470c37934e7e.png)\nwhere more links are added, removing e.g. the inconsistency with `Deref`\u2019s color in e.g. `P: Deref` that I already mentioned above.\n\n## Discussion\n\nI am aware that this PR may very well be overkill. If for now only the first commit (plus the fix for the `Drop` link in e65385fbfa72995b27ec64aa54f330cf503dfc03, the link titles 684edf7a70d2e90466ae74e7a321670259bf3fd9 as far as they apply, and a few of the line-break changes) are wanted, I can reduce this PR to just those changes. I personally find the rendered result with all these changes very nice though. On the other hand, all these `<code>` tags are not very nice in the source code, I\u2019ll admit.\n\nPerhaps alternative solutions could be preferred, such as `rustdoc` support for merging subsequent inline code blocks so that all the cases that currently use workarounds rendered as [`Box`]`<`[`Option`]`<T>>` automatically become <code>[Box]<[Option]\\<T>></code> without any need for further changes. Even in this case, having a properly formatted, better looking example in the standard library docs could help motivate such a change to `rustdoc` by prodiving an example of the expected results and also the already existing alternative (i.e. using `<code>`). On the other hand, `` [`Box`]`<`[`Option`]`<T>>` `` isn\u2019t particularly nice-looking source code either. I\u2019m not even sure if I wouldn\u2019t actually find the version `<code>[Box]<[Option]\\<T>></code>` cleaner to read.\n\n`@rustbot` modify labels: T-doc, T-rustdoc\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/689978c17636415dbe4a2d87ac83b53cd2c42416", "html_url": "https://github.com/rust-lang/rust/commit/689978c17636415dbe4a2d87ac83b53cd2c42416", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/689978c17636415dbe4a2d87ac83b53cd2c42416/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "010c2368fa33ef08df3080228498db8d2ba5a93b", "url": "https://api.github.com/repos/rust-lang/rust/commits/010c2368fa33ef08df3080228498db8d2ba5a93b", "html_url": "https://github.com/rust-lang/rust/commit/010c2368fa33ef08df3080228498db8d2ba5a93b"}, {"sha": "3e0cef7d6937e17b67dec25477ed56ef2386a3e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e0cef7d6937e17b67dec25477ed56ef2386a3e0", "html_url": "https://github.com/rust-lang/rust/commit/3e0cef7d6937e17b67dec25477ed56ef2386a3e0"}], "stats": {"total": 217, "additions": 113, "deletions": 104}, "files": [{"sha": "3d888299485b5249b08afd63bd5bbe1f9990853c", "filename": "library/core/src/pin.rs", "status": "modified", "additions": 113, "deletions": 104, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/689978c17636415dbe4a2d87ac83b53cd2c42416/library%2Fcore%2Fsrc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/689978c17636415dbe4a2d87ac83b53cd2c42416/library%2Fcore%2Fsrc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpin.rs?ref=689978c17636415dbe4a2d87ac83b53cd2c42416", "patch": "@@ -6,21 +6,23 @@\n //! as moving an object with pointers to itself will invalidate them, which could cause undefined\n //! behavior.\n //!\n-//! At a high level, a [`Pin<P>`] ensures that the pointee of any pointer type\n+//! At a high level, a <code>[Pin]\\<P></code> ensures that the pointee of any pointer type\n //! `P` has a stable location in memory, meaning it cannot be moved elsewhere\n //! and its memory cannot be deallocated until it gets dropped. We say that the\n //! pointee is \"pinned\". Things get more subtle when discussing types that\n //! combine pinned with non-pinned data; [see below](#projections-and-structural-pinning)\n //! for more details.\n //!\n //! By default, all types in Rust are movable. Rust allows passing all types by-value,\n-//! and common smart-pointer types such as [`Box<T>`] and `&mut T` allow replacing and\n-//! moving the values they contain: you can move out of a [`Box<T>`], or you can use [`mem::swap`].\n-//! [`Pin<P>`] wraps a pointer type `P`, so [`Pin`]`<`[`Box`]`<T>>` functions much like a regular\n-//! [`Box<T>`]: when a [`Pin`]`<`[`Box`]`<T>>` gets dropped, so do its contents, and the memory gets\n-//! deallocated. Similarly, [`Pin`]`<&mut T>` is a lot like `&mut T`. However, [`Pin<P>`] does\n-//! not let clients actually obtain a [`Box<T>`] or `&mut T` to pinned data, which implies that you\n-//! cannot use operations such as [`mem::swap`]:\n+//! and common smart-pointer types such as <code>[Box]\\<T></code> and <code>[&mut] T</code> allow\n+//! replacing and moving the values they contain: you can move out of a <code>[Box]\\<T></code>,\n+//! or you can use [`mem::swap`]. <code>[Pin]\\<P></code> wraps a pointer type `P`, so\n+//! <code>[Pin]<[Box]\\<T>></code> functions much like a regular <code>[Box]\\<T></code>:\n+//! when a <code>[Pin]<[Box]\\<T>></code> gets dropped, so do its contents, and the memory gets\n+//! deallocated. Similarly, <code>[Pin]<[&mut] T></code> is a lot like <code>[&mut] T</code>.\n+//! However, <code>[Pin]\\<P></code> does not let clients actually obtain a <code>[Box]\\<T></code>\n+//! or <code>[&mut] T</code> to pinned data, which implies that you cannot use operations such\n+//! as [`mem::swap`]:\n //!\n //! ```\n //! use std::pin::Pin;\n@@ -32,18 +34,18 @@\n //! }\n //! ```\n //!\n-//! It is worth reiterating that [`Pin<P>`] does *not* change the fact that a Rust compiler\n-//! considers all types movable. [`mem::swap`] remains callable for any `T`. Instead, [`Pin<P>`]\n-//! prevents certain *values* (pointed to by pointers wrapped in [`Pin<P>`]) from being\n-//! moved by making it impossible to call methods that require `&mut T` on them\n-//! (like [`mem::swap`]).\n-//!\n-//! [`Pin<P>`] can be used to wrap any pointer type `P`, and as such it interacts with\n-//! [`Deref`] and [`DerefMut`]. A [`Pin<P>`] where `P: Deref` should be considered\n-//! as a \"`P`-style pointer\" to a pinned `P::Target` -- so, a [`Pin`]`<`[`Box`]`<T>>` is\n-//! an owned pointer to a pinned `T`, and a [`Pin`]`<`[`Rc`]`<T>>` is a reference-counted\n-//! pointer to a pinned `T`.\n-//! For correctness, [`Pin<P>`] relies on the implementations of [`Deref`] and\n+//! It is worth reiterating that <code>[Pin]\\<P></code> does *not* change the fact that a Rust\n+//! compiler considers all types movable. [`mem::swap`] remains callable for any `T`. Instead,\n+//! <code>[Pin]\\<P></code> prevents certain *values* (pointed to by pointers wrapped in\n+//! <code>[Pin]\\<P></code>) from being moved by making it impossible to call methods that require\n+//! <code>[&mut] T</code> on them (like [`mem::swap`]).\n+//!\n+//! <code>[Pin]\\<P></code> can be used to wrap any pointer type `P`, and as such it interacts with\n+//! [`Deref`] and [`DerefMut`]. A <code>[Pin]\\<P></code> where <code>P: [Deref]</code> should be\n+//! considered as a \"`P`-style pointer\" to a pinned <code>P::[Target]</code> \u2013 so, a\n+//! <code>[Pin]<[Box]\\<T>></code> is an owned pointer to a pinned `T`, and a\n+//! <code>[Pin]<[Rc]\\<T>></code> is a reference-counted pointer to a pinned `T`.\n+//! For correctness, <code>[Pin]\\<P></code> relies on the implementations of [`Deref`] and\n //! [`DerefMut`] not to move out of their `self` parameter, and only ever to\n //! return a pointer to pinned data when they are called on a pinned pointer.\n //!\n@@ -53,19 +55,19 @@\n //! rely on having a stable address. This includes all the basic types (like\n //! [`bool`], [`i32`], and references) as well as types consisting solely of these\n //! types. Types that do not care about pinning implement the [`Unpin`]\n-//! auto-trait, which cancels the effect of [`Pin<P>`]. For `T: Unpin`,\n-//! [`Pin`]`<`[`Box`]`<T>>` and [`Box<T>`] function identically, as do [`Pin`]`<&mut T>` and\n-//! `&mut T`.\n+//! auto-trait, which cancels the effect of <code>[Pin]\\<P></code>. For <code>T: [Unpin]</code>,\n+//! <code>[Pin]<[Box]\\<T>></code> and <code>[Box]\\<T></code> function identically, as do\n+//! <code>[Pin]<[&mut] T></code> and <code>[&mut] T</code>.\n //!\n-//! Note that pinning and [`Unpin`] only affect the pointed-to type `P::Target`, not the pointer\n-//! type `P` itself that got wrapped in [`Pin<P>`]. For example, whether or not [`Box<T>`] is\n-//! [`Unpin`] has no effect on the behavior of [`Pin`]`<`[`Box`]`<T>>` (here, `T` is the\n-//! pointed-to type).\n+//! Note that pinning and [`Unpin`] only affect the pointed-to type <code>P::[Target]</code>,\n+//! not the pointer type `P` itself that got wrapped in <code>[Pin]\\<P></code>. For example,\n+//! whether or not <code>[Box]\\<T></code> is [`Unpin`] has no effect on the behavior of\n+//! <code>[Pin]<[Box]\\<T>></code> (here, `T` is the pointed-to type).\n //!\n //! # Example: self-referential struct\n //!\n //! Before we go into more details to explain the guarantees and choices\n-//! associated with `Pin<T>`, we discuss some examples for how it might be used.\n+//! associated with <code>[Pin]\\<P></code>, we discuss some examples for how it might be used.\n //! Feel free to [skip to where the theoretical discussion continues](#drop-guarantee).\n //!\n //! ```rust\n@@ -129,7 +131,7 @@\n //!\n //! To make this work, every element has pointers to its predecessor and successor in\n //! the list. Elements can only be added when they are pinned, because moving the elements\n-//! around would invalidate the pointers. Moreover, the [`Drop`] implementation of a linked\n+//! around would invalidate the pointers. Moreover, the [`Drop`][Drop] implementation of a linked\n //! list element will patch the pointers of its predecessor and successor to remove itself\n //! from the list.\n //!\n@@ -149,34 +151,34 @@\n //! when [`drop`] is called*.  Only once [`drop`] returns or panics, the memory may be reused.\n //!\n //! Memory can be \"invalidated\" by deallocation, but also by\n-//! replacing a [`Some(v)`] by [`None`], or calling [`Vec::set_len`] to \"kill\" some elements\n-//! off of a vector. It can be repurposed by using [`ptr::write`] to overwrite it without\n+//! replacing a <code>[Some]\\(v)</code> by [`None`], or calling [`Vec::set_len`] to \"kill\" some\n+//! elements off of a vector. It can be repurposed by using [`ptr::write`] to overwrite it without\n //! calling the destructor first. None of this is allowed for pinned data without calling [`drop`].\n //!\n //! This is exactly the kind of guarantee that the intrusive linked list from the previous\n //! section needs to function correctly.\n //!\n //! Notice that this guarantee does *not* mean that memory does not leak! It is still\n //! completely okay not ever to call [`drop`] on a pinned element (e.g., you can still\n-//! call [`mem::forget`] on a [`Pin`]`<`[`Box`]`<T>>`). In the example of the doubly-linked\n+//! call [`mem::forget`] on a <code>[Pin]<[Box]\\<T>></code>). In the example of the doubly-linked\n //! list, that element would just stay in the list. However you may not free or reuse the storage\n //! *without calling [`drop`]*.\n //!\n //! # `Drop` implementation\n //!\n //! If your type uses pinning (such as the two examples above), you have to be careful\n-//! when implementing [`Drop`]. The [`drop`] function takes `&mut self`, but this\n+//! when implementing [`Drop`][Drop]. The [`drop`] function takes <code>[&mut] self</code>, but this\n //! is called *even if your type was previously pinned*! It is as if the\n //! compiler automatically called [`Pin::get_unchecked_mut`].\n //!\n //! This can never cause a problem in safe code because implementing a type that\n //! relies on pinning requires unsafe code, but be aware that deciding to make\n //! use of pinning in your type (for example by implementing some operation on\n-//! [`Pin`]`<&Self>` or [`Pin`]`<&mut Self>`) has consequences for your [`Drop`]\n-//! implementation as well: if an element of your type could have been pinned,\n-//! you must treat [`Drop`] as implicitly taking [`Pin`]`<&mut Self>`.\n+//! <code>[Pin]<[&]Self></code> or <code>[Pin]<[&mut] Self></code>) has consequences for your\n+//! [`Drop`][Drop]implementation as well: if an element of your type could have been pinned,\n+//! you must treat [`Drop`][Drop] as implicitly taking <code>[Pin]<[&mut] Self></code>.\n //!\n-//! For example, you could implement `Drop` as follows:\n+//! For example, you could implement [`Drop`][Drop] as follows:\n //!\n //! ```rust,no_run\n //! # use std::pin::Pin;\n@@ -204,18 +206,18 @@\n //! # Projections and Structural Pinning\n //!\n //! When working with pinned structs, the question arises how one can access the\n-//! fields of that struct in a method that takes just [`Pin`]`<&mut Struct>`.\n+//! fields of that struct in a method that takes just <code>[Pin]<[&mut] Struct></code>.\n //! The usual approach is to write helper methods (so called *projections*)\n-//! that turn [`Pin`]`<&mut Struct>` into a reference to the field, but what\n-//! type should that reference have? Is it [`Pin`]`<&mut Field>` or `&mut Field`?\n+//! that turn <code>[Pin]<[&mut] Struct></code> into a reference to the field, but what type should\n+//! that reference have? Is it <code>[Pin]<[&mut] Field></code> or <code>[&mut] Field</code>?\n //! The same question arises with the fields of an `enum`, and also when considering\n-//! container/wrapper types such as [`Vec<T>`], [`Box<T>`], or [`RefCell<T>`].\n-//! (This question applies to both mutable and shared references, we just\n-//! use the more common case of mutable references here for illustration.)\n+//! container/wrapper types such as <code>[Vec]\\<T></code>, <code>[Box]\\<T></code>,\n+//! or <code>[RefCell]\\<T></code>. (This question applies to both mutable and shared references,\n+//! we just use the more common case of mutable references here for illustration.)\n //!\n-//! It turns out that it is actually up to the author of the data structure\n-//! to decide whether the pinned projection for a particular field turns\n-//! [`Pin`]`<&mut Struct>` into [`Pin`]`<&mut Field>` or `&mut Field`. There are some\n+//! It turns out that it is actually up to the author of the data structure to decide whether\n+//! the pinned projection for a particular field turns <code>[Pin]<[&mut] Struct></code>\n+//! into <code>[Pin]<[&mut] Field></code> or <code>[&mut] Field</code>. There are some\n //! constraints though, and the most important constraint is *consistency*:\n //! every field can be *either* projected to a pinned reference, *or* have\n //! pinning removed as part of the projection. If both are done for the same field,\n@@ -230,12 +232,12 @@\n //! ## Pinning *is not* structural for `field`\n //!\n //! It may seem counter-intuitive that the field of a pinned struct might not be pinned,\n-//! but that is actually the easiest choice: if a [`Pin`]`<&mut Field>` is never created,\n+//! but that is actually the easiest choice: if a <code>[Pin]<[&mut] Field></code> is never created,\n //! nothing can go wrong! So, if you decide that some field does not have structural pinning,\n //! all you have to ensure is that you never create a pinned reference to that field.\n //!\n //! Fields without structural pinning may have a projection method that turns\n-//! [`Pin`]`<&mut Struct>` into `&mut Field`:\n+//! <code>[Pin]<[&mut] Struct></code> into <code>[&mut] Field</code>:\n //!\n //! ```rust,no_run\n //! # use std::pin::Pin;\n@@ -249,16 +251,16 @@\n //! }\n //! ```\n //!\n-//! You may also `impl Unpin for Struct` *even if* the type of `field`\n+//! You may also <code>impl [Unpin] for Struct</code> *even if* the type of `field`\n //! is not [`Unpin`]. What that type thinks about pinning is not relevant\n-//! when no [`Pin`]`<&mut Field>` is ever created.\n+//! when no <code>[Pin]<[&mut] Field></code> is ever created.\n //!\n //! ## Pinning *is* structural for `field`\n //!\n //! The other option is to decide that pinning is \"structural\" for `field`,\n //! meaning that if the struct is pinned then so is the field.\n //!\n-//! This allows writing a projection that creates a [`Pin`]`<&mut Field>`, thus\n+//! This allows writing a projection that creates a <code>[Pin]<[&mut] Field></code>, thus\n //! witnessing that the field is pinned:\n //!\n //! ```rust,no_run\n@@ -278,34 +280,36 @@\n //! 1.  The struct must only be [`Unpin`] if all the structural fields are\n //!     [`Unpin`]. This is the default, but [`Unpin`] is a safe trait, so as the author of\n //!     the struct it is your responsibility *not* to add something like\n-//!     `impl<T> Unpin for Struct<T>`. (Notice that adding a projection operation\n+//!     <code>impl\\<T> [Unpin] for Struct\\<T></code>. (Notice that adding a projection operation\n //!     requires unsafe code, so the fact that [`Unpin`] is a safe trait does not break\n-//!     the principle that you only have to worry about any of this if you use `unsafe`.)\n+//!     the principle that you only have to worry about any of this if you use [`unsafe`].)\n //! 2.  The destructor of the struct must not move structural fields out of its argument. This\n-//!     is the exact point that was raised in the [previous section][drop-impl]: `drop` takes\n-//!     `&mut self`, but the struct (and hence its fields) might have been pinned before.\n-//!     You have to guarantee that you do not move a field inside your [`Drop`] implementation.\n-//!     In particular, as explained previously, this means that your struct must *not*\n-//!     be `#[repr(packed)]`.\n+//!     is the exact point that was raised in the [previous section][drop-impl]: [`drop`] takes\n+//!     <code>[&mut] self</code>, but the struct (and hence its fields) might have been pinned\n+//!     before. You have to guarantee that you do not move a field inside your [`Drop`][Drop]\n+//!     implementation. In particular, as explained previously, this means that your struct\n+//!     must *not* be `#[repr(packed)]`.\n //!     See that section for how to write [`drop`] in a way that the compiler can help you\n //!     not accidentally break pinning.\n //! 3.  You must make sure that you uphold the [`Drop` guarantee][drop-guarantee]:\n //!     once your struct is pinned, the memory that contains the\n //!     content is not overwritten or deallocated without calling the content's destructors.\n-//!     This can be tricky, as witnessed by [`VecDeque<T>`]: the destructor of [`VecDeque<T>`]\n-//!     can fail to call [`drop`] on all elements if one of the destructors panics. This violates\n-//!     the [`Drop`] guarantee, because it can lead to elements being deallocated without\n-//!     their destructor being called. ([`VecDeque<T>`] has no pinning projections, so this\n+//!     This can be tricky, as witnessed by <code>[VecDeque]\\<T></code>: the destructor of\n+//!     <code>[VecDeque]\\<T></code> can fail to call [`drop`] on all elements if one of the\n+//!     destructors panics. This violates the [`Drop`][Drop] guarantee, because it can lead to\n+//!     elements being deallocated without their destructor being called.\n+//!     (<code>[VecDeque]\\<T></code> has no pinning projections, so this\n //!     does not cause unsoundness.)\n //! 4.  You must not offer any other operations that could lead to data being moved out of\n //!     the structural fields when your type is pinned. For example, if the struct contains an\n-//!     [`Option<T>`] and there is a `take`-like operation with type\n-//!     `fn(Pin<&mut Struct<T>>) -> Option<T>`,\n-//!     that operation can be used to move a `T` out of a pinned `Struct<T>` -- which means\n+//!     <code>[Option]\\<T></code> and there is a [`take`][Option::take]-like operation with type\n+//!     <code>fn([Pin]<[&mut] Struct\\<T>>) -> [Option]\\<T></code>,\n+//!     that operation can be used to move a `T` out of a pinned `Struct<T>` \u2013 which means\n //!     pinning cannot be structural for the field holding this data.\n //!\n-//!     For a more complex example of moving data out of a pinned type, imagine if [`RefCell<T>`]\n-//!     had a method `fn get_pin_mut(self: Pin<&mut Self>) -> Pin<&mut T>`.\n+//!     For a more complex example of moving data out of a pinned type,\n+//!     imagine if <code>[RefCell]\\<T></code> had a method\n+//!     <code>fn get_pin_mut(self: [Pin]<[&mut] Self>) -> [Pin]<[&mut] T></code>.\n //!     Then we could do the following:\n //!     ```compile_fail\n //!     fn exploit_ref_cell<T>(rc: Pin<&mut RefCell<T>>) {\n@@ -315,60 +319,65 @@\n //!         let content = &mut *b; // And here we have `&mut T` to the same data.\n //!     }\n //!     ```\n-//!     This is catastrophic, it means we can first pin the content of the [`RefCell<T>`]\n-//!     (using `RefCell::get_pin_mut`) and then move that content using the mutable\n-//!     reference we got later.\n+//!     This is catastrophic, it means we can first pin the content of the\n+//!     <code>[RefCell]\\<T></code> (using <code>[RefCell]::get_pin_mut</code>) and then move that\n+//!     content using the mutable reference we got later.\n //!\n //! ## Examples\n //!\n-//! For a type like [`Vec<T>`], both possibilities (structural pinning or not) make sense.\n-//! A [`Vec<T>`] with structural pinning could have `get_pin`/`get_pin_mut` methods to get\n-//! pinned references to elements. However, it could *not* allow calling\n-//! [`pop`][Vec::pop] on a pinned [`Vec<T>`] because that would move the (structurally pinned)\n-//! contents! Nor could it allow [`push`][Vec::push], which might reallocate and thus also move the\n-//! contents.\n+//! For a type like <code>[Vec]\\<T></code>, both possibilities (structural pinning or not) make\n+//! sense. A <code>[Vec]\\<T></code> with structural pinning could have `get_pin`/`get_pin_mut`\n+//! methods to get pinned references to elements. However, it could *not* allow calling\n+//! [`pop`][Vec::pop] on a pinned <code>[Vec]\\<T></code> because that would move the (structurally\n+//! pinned) contents! Nor could it allow [`push`][Vec::push], which might reallocate and thus also\n+//! move the contents.\n //!\n-//! A [`Vec<T>`] without structural pinning could `impl<T> Unpin for Vec<T>`, because the contents\n-//! are never pinned and the [`Vec<T>`] itself is fine with being moved as well.\n+//! A <code>[Vec]\\<T></code> without structural pinning could\n+//! <code>impl\\<T> [Unpin] for [Vec]\\<T></code>, because the contents are never pinned\n+//! and the <code>[Vec]\\<T></code> itself is fine with being moved as well.\n //! At that point pinning just has no effect on the vector at all.\n //!\n //! In the standard library, pointer types generally do not have structural pinning,\n-//! and thus they do not offer pinning projections. This is why `Box<T>: Unpin` holds for all `T`.\n-//! It makes sense to do this for pointer types, because moving the `Box<T>`\n-//! does not actually move the `T`: the [`Box<T>`] can be freely movable (aka `Unpin`) even if\n-//! the `T` is not. In fact, even [`Pin`]`<`[`Box`]`<T>>` and [`Pin`]`<&mut T>` are always\n-//! [`Unpin`] themselves, for the same reason: their contents (the `T`) are pinned, but the\n-//! pointers themselves can be moved without moving the pinned data. For both [`Box<T>`] and\n-//! [`Pin`]`<`[`Box`]`<T>>`, whether the content is pinned is entirely independent of whether the\n+//! and thus they do not offer pinning projections. This is why <code>[Box]\\<T>: [Unpin]</code>\n+//! holds for all `T`. It makes sense to do this for pointer types, because moving the\n+//! <code>[Box]\\<T></code> does not actually move the `T`: the <code>[Box]\\<T></code> can be freely\n+//! movable (aka [`Unpin`]) even if the `T` is not. In fact, even <code>[Pin]<[Box]\\<T>></code> and\n+//! <code>[Pin]<[&mut] T></code> are always [`Unpin`] themselves, for the same reason:\n+//! their contents (the `T`) are pinned, but the pointers themselves can be moved without moving\n+//! the pinned data. For both <code>[Box]\\<T></code> and <code>[Pin]<[Box]\\<T>></code>,\n+//! whether the content is pinned is entirely independent of whether the\n //! pointer is pinned, meaning pinning is *not* structural.\n //!\n //! When implementing a [`Future`] combinator, you will usually need structural pinning\n //! for the nested futures, as you need to get pinned references to them to call [`poll`].\n //! But if your combinator contains any other data that does not need to be pinned,\n //! you can make those fields not structural and hence freely access them with a\n-//! mutable reference even when you just have [`Pin`]`<&mut Self>` (such as in your own\n+//! mutable reference even when you just have <code>[Pin]<[&mut] Self></code> (such as in your own\n //! [`poll`] implementation).\n //!\n-//! [`Deref`]: crate::ops::Deref\n-//! [`DerefMut`]: crate::ops::DerefMut\n-//! [`mem::swap`]: crate::mem::swap\n-//! [`mem::forget`]: crate::mem::forget\n-//! [`Box<T>`]: ../../std/boxed/struct.Box.html\n-//! [`Vec<T>`]: ../../std/vec/struct.Vec.html\n-//! [`Vec::set_len`]: ../../std/vec/struct.Vec.html#method.set_len\n-//! [`Box`]: ../../std/boxed/struct.Box.html\n-//! [Vec::pop]: ../../std/vec/struct.Vec.html#method.pop\n-//! [Vec::push]: ../../std/vec/struct.Vec.html#method.push\n-//! [`Rc`]: ../../std/rc/struct.Rc.html\n-//! [`RefCell<T>`]: crate::cell::RefCell\n-//! [`drop`]: Drop::drop\n-//! [`VecDeque<T>`]: ../../std/collections/struct.VecDeque.html\n-//! [`Some(v)`]: Some\n-//! [`ptr::write`]: crate::ptr::write\n-//! [`Future`]: crate::future::Future\n+//! [Deref]: crate::ops::Deref \"ops::Deref\"\n+//! [`Deref`]: crate::ops::Deref \"ops::Deref\"\n+//! [Target]: crate::ops::Deref::Target \"ops::Deref::Target\"\n+//! [`DerefMut`]: crate::ops::DerefMut \"ops::DerefMut\"\n+//! [`mem::swap`]: crate::mem::swap \"mem::swap\"\n+//! [`mem::forget`]: crate::mem::forget \"mem::forget\"\n+//! [Vec]: ../../std/vec/struct.Vec.html \"Vec\"\n+//! [`Vec::set_len`]: ../../std/vec/struct.Vec.html#method.set_len \"Vec::set_len\"\n+//! [Box]: ../../std/boxed/struct.Box.html \"Box\"\n+//! [Vec::pop]: ../../std/vec/struct.Vec.html#method.pop \"Vec::pop\"\n+//! [Vec::push]: ../../std/vec/struct.Vec.html#method.push \"Vec::push\"\n+//! [Rc]: ../../std/rc/struct.Rc.html \"rc::Rc\"\n+//! [RefCell]: crate::cell::RefCell \"cell::RefCell\"\n+//! [`drop`]: Drop::drop \"Drop::drop\"\n+//! [VecDeque]: ../../std/collections/struct.VecDeque.html \"collections::VecDeque\"\n+//! [`ptr::write`]: crate::ptr::write \"ptr::write\"\n+//! [`Future`]: crate::future::Future \"future::Future\"\n //! [drop-impl]: #drop-implementation\n //! [drop-guarantee]: #drop-guarantee\n-//! [`poll`]: crate::future::Future::poll\n+//! [`poll`]: crate::future::Future::poll \"future::Future::poll\"\n+//! [&]: ../../std/primitive.reference.html \"shared reference\"\n+//! [&mut]: ../../std/primitive.reference.html \"mutable reference\"\n+//! [`unsafe`]: ../../std/keyword.unsafe.html \"keyword unsafe\"\n \n #![stable(feature = \"pin\", since = \"1.33.0\")]\n "}]}