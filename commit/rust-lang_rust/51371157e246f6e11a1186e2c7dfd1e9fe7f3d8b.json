{"sha": "51371157e246f6e11a1186e2c7dfd1e9fe7f3d8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxMzcxMTU3ZTI0NmY2ZTExYTExODZlMmM3ZGZkMWU5ZmU3ZjNkOGI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-03-27T20:24:17Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-03-27T22:56:23Z"}, "message": "Rollup merge of #40751 - nrc:save-callback, r=eddyb\n\nsave-analysis: allow clients to get data directly without writing to a file.", "tree": {"sha": "bec20a544eabfcc9005d19b7b4801c7867d100de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bec20a544eabfcc9005d19b7b4801c7867d100de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51371157e246f6e11a1186e2c7dfd1e9fe7f3d8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51371157e246f6e11a1186e2c7dfd1e9fe7f3d8b", "html_url": "https://github.com/rust-lang/rust/commit/51371157e246f6e11a1186e2c7dfd1e9fe7f3d8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51371157e246f6e11a1186e2c7dfd1e9fe7f3d8b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12f6c5019a045eead09b46251173ec3ae558891a", "url": "https://api.github.com/repos/rust-lang/rust/commits/12f6c5019a045eead09b46251173ec3ae558891a", "html_url": "https://github.com/rust-lang/rust/commit/12f6c5019a045eead09b46251173ec3ae558891a"}, {"sha": "3ec61ea921a0090e97d3ec6a306561c8c6bacc91", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ec61ea921a0090e97d3ec6a306561c8c6bacc91", "html_url": "https://github.com/rust-lang/rust/commit/3ec61ea921a0090e97d3ec6a306561c8c6bacc91"}], "stats": {"total": 236, "additions": 164, "deletions": 72}, "files": [{"sha": "4873b21c548740f98480346794ea5abc76309c64", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/51371157e246f6e11a1186e2c7dfd1e9fe7f3d8b/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51371157e246f6e11a1186e2c7dfd1e9fe7f3d8b/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=51371157e246f6e11a1186e2c7dfd1e9fe7f3d8b", "patch": "@@ -258,10 +258,7 @@ fn keep_hygiene_data(sess: &Session) -> bool {\n }\n \n fn keep_ast(sess: &Session) -> bool {\n-    sess.opts.debugging_opts.keep_ast ||\n-    sess.opts.debugging_opts.save_analysis ||\n-    sess.opts.debugging_opts.save_analysis_csv ||\n-    sess.opts.debugging_opts.save_analysis_api\n+    sess.opts.debugging_opts.keep_ast || ::save_analysis(sess)\n }\n \n /// The name used for source code that doesn't originate in a file"}, {"sha": "c90dde3a5f6e0232694ae37dec7e11e70c91b446", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51371157e246f6e11a1186e2c7dfd1e9fe7f3d8b/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51371157e246f6e11a1186e2c7dfd1e9fe7f3d8b/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=51371157e246f6e11a1186e2c7dfd1e9fe7f3d8b", "patch": "@@ -67,6 +67,7 @@ use pretty::{PpMode, UserIdentifiedItem};\n \n use rustc_resolve as resolve;\n use rustc_save_analysis as save;\n+use rustc_save_analysis::DumpHandler;\n use rustc_trans::back::link;\n use rustc_trans::back::write::{create_target_machine, RELOC_MODEL_ARGS, CODE_GEN_MODEL_ARGS};\n use rustc::dep_graph::DepGraph;\n@@ -507,8 +508,9 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                                         state.expanded_crate.unwrap(),\n                                         state.analysis.unwrap(),\n                                         state.crate_name.unwrap(),\n-                                        state.out_dir,\n-                                        save_analysis_format(state.session))\n+                                        DumpHandler::new(save_analysis_format(state.session),\n+                                                         state.out_dir,\n+                                                         state.crate_name.unwrap()))\n                 });\n             };\n             control.after_analysis.run_callback_on_error = true;"}, {"sha": "2d1e12bf0a10dfd379e4d90488a6f915a9059d9e", "filename": "src/librustc_save_analysis/json_dumper.rs", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/51371157e246f6e11a1186e2c7dfd1e9fe7f3d8b/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51371157e246f6e11a1186e2c7dfd1e9fe7f3d8b/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_dumper.rs?ref=51371157e246f6e11a1186e2c7dfd1e9fe7f3d8b", "patch": "@@ -22,25 +22,55 @@ use external_data::*;\n use data::{self, VariableKind};\n use dump::Dump;\n \n-pub struct JsonDumper<'b, W: Write + 'b> {\n-    output: &'b mut W,\n+pub struct JsonDumper<O: DumpOutput> {\n     result: Analysis,\n+    output: O,\n }\n \n-impl<'b, W: Write> JsonDumper<'b, W> {\n-    pub fn new(writer: &'b mut W) -> JsonDumper<'b, W> {\n-        JsonDumper { output: writer, result: Analysis::new() }\n-    }\n+pub trait DumpOutput {\n+    fn dump(&mut self, result: &Analysis);\n }\n \n-impl<'b, W: Write> Drop for JsonDumper<'b, W> {\n-    fn drop(&mut self) {\n-        if let Err(_) = write!(self.output, \"{}\", as_json(&self.result)) {\n+pub struct WriteOutput<'b, W: Write + 'b> {\n+    output: &'b mut W,\n+}\n+\n+impl<'b, W: Write> DumpOutput for WriteOutput<'b, W> {\n+    fn dump(&mut self, result: &Analysis) {\n+        if let Err(_) = write!(self.output, \"{}\", as_json(&result)) {\n             error!(\"Error writing output\");\n         }\n     }\n }\n \n+pub struct CallbackOutput<'b> {\n+    callback: &'b mut FnMut(&Analysis),\n+}\n+\n+impl<'b> DumpOutput for CallbackOutput<'b> {\n+    fn dump(&mut self, result: &Analysis) {\n+        (self.callback)(result)\n+    }\n+}\n+\n+impl<'b, W: Write> JsonDumper<WriteOutput<'b, W>> {\n+    pub fn new(writer: &'b mut W) -> JsonDumper<WriteOutput<'b, W>> {\n+        JsonDumper { output: WriteOutput { output: writer }, result: Analysis::new() }\n+    }\n+}\n+\n+impl<'b> JsonDumper<CallbackOutput<'b>> {\n+    pub fn with_callback(callback: &'b mut FnMut(&Analysis)) -> JsonDumper<CallbackOutput<'b>> {\n+        JsonDumper { output: CallbackOutput { callback: callback }, result: Analysis::new() }\n+    }\n+}\n+\n+impl<O: DumpOutput> Drop for JsonDumper<O> {\n+    fn drop(&mut self) {\n+        self.output.dump(&self.result);\n+    }\n+}\n+\n macro_rules! impl_fn {\n     ($fn_name: ident, $data_type: ident, $bucket: ident) => {\n         fn $fn_name(&mut self, data: $data_type) {\n@@ -49,7 +79,7 @@ macro_rules! impl_fn {\n     }\n }\n \n-impl<'b, W: Write + 'b> Dump for JsonDumper<'b, W> {\n+impl<'b, O: DumpOutput + 'b> Dump for JsonDumper<O> {\n     fn crate_prelude(&mut self, data: CratePreludeData) {\n         self.result.prelude = Some(data)\n     }"}, {"sha": "e5c04f6b61ec297643bb9cd1726fb33bcff8b115", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 119, "deletions": 56, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/51371157e246f6e11a1186e2c7dfd1e9fe7f3d8b/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51371157e246f6e11a1186e2c7dfd1e9fe7f3d8b/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=51371157e246f6e11a1186e2c7dfd1e9fe7f3d8b", "patch": "@@ -48,6 +48,7 @@ use rustc::hir::def::Def;\n use rustc::hir::map::Node;\n use rustc::hir::def_id::DefId;\n use rustc::session::config::CrateType::CrateTypeExecutable;\n+use rustc::session::Session;\n use rustc::ty::{self, TyCtxt};\n \n use std::env;\n@@ -866,55 +867,131 @@ impl Format {\n     }\n }\n \n-pub fn process_crate<'l, 'tcx>(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n-                               krate: &ast::Crate,\n-                               analysis: &'l ty::CrateAnalysis,\n-                               cratename: &str,\n-                               odir: Option<&Path>,\n-                               format: Format) {\n-    let _ignore = tcx.dep_graph.in_ignore();\n+/// Defines what to do with the results of saving the analysis.\n+pub trait SaveHandler {\n+    fn save<'l, 'tcx>(&mut self,\n+                      save_ctxt: SaveContext<'l, 'tcx>,\n+                      krate: &ast::Crate,\n+                      cratename: &str);\n+}\n \n-    assert!(analysis.glob_map.is_some());\n+/// Dump the save-analysis results to a file.\n+pub struct DumpHandler<'a> {\n+    format: Format,\n+    odir: Option<&'a Path>,\n+    cratename: String\n+}\n \n-    info!(\"Dumping crate {}\", cratename);\n+impl<'a> DumpHandler<'a> {\n+    pub fn new(format: Format, odir: Option<&'a Path>, cratename: &str) -> DumpHandler<'a> {\n+        DumpHandler {\n+            format: format,\n+            odir: odir,\n+            cratename: cratename.to_owned()\n+        }\n+    }\n \n-    // find a path to dump our data to\n-    let mut root_path = match env::var_os(\"RUST_SAVE_ANALYSIS_FOLDER\") {\n-        Some(val) => PathBuf::from(val),\n-        None => match odir {\n-            Some(val) => val.join(\"save-analysis\"),\n-            None => PathBuf::from(\"save-analysis-temp\"),\n-        },\n-    };\n+    fn output_file(&self, sess: &Session) -> File {\n+        let mut root_path = match env::var_os(\"RUST_SAVE_ANALYSIS_FOLDER\") {\n+            Some(val) => PathBuf::from(val),\n+            None => match self.odir {\n+                Some(val) => val.join(\"save-analysis\"),\n+                None => PathBuf::from(\"save-analysis-temp\"),\n+            },\n+        };\n \n-    if let Err(e) = std::fs::create_dir_all(&root_path) {\n-        tcx.sess.err(&format!(\"Could not create directory {}: {}\",\n-                              root_path.display(),\n-                              e));\n+        if let Err(e) = std::fs::create_dir_all(&root_path) {\n+            error!(\"Could not create directory {}: {}\", root_path.display(), e);\n+        }\n+\n+        {\n+            let disp = root_path.display();\n+            info!(\"Writing output to {}\", disp);\n+        }\n+\n+        let executable = sess.crate_types.borrow().iter().any(|ct| *ct == CrateTypeExecutable);\n+        let mut out_name = if executable {\n+            \"\".to_owned()\n+        } else {\n+            \"lib\".to_owned()\n+        };\n+        out_name.push_str(&self.cratename);\n+        out_name.push_str(&sess.opts.cg.extra_filename);\n+        out_name.push_str(self.format.extension());\n+        root_path.push(&out_name);\n+        let output_file = File::create(&root_path).unwrap_or_else(|e| {\n+            let disp = root_path.display();\n+            sess.fatal(&format!(\"Could not open {}: {}\", disp, e));\n+        });\n+        root_path.pop();\n+        output_file\n     }\n+}\n+\n+impl<'a> SaveHandler for DumpHandler<'a> {\n+    fn save<'l, 'tcx>(&mut self,\n+                      save_ctxt: SaveContext<'l, 'tcx>,\n+                      krate: &ast::Crate,\n+                      cratename: &str) {\n+        macro_rules! dump {\n+            ($new_dumper: expr) => {{\n+                let mut dumper = $new_dumper;\n+                let mut visitor = DumpVisitor::new(save_ctxt, &mut dumper);\n+\n+                visitor.dump_crate_info(cratename, krate);\n+                visit::walk_crate(&mut visitor, krate);\n+            }}\n+        }\n+\n+        let output = &mut self.output_file(&save_ctxt.tcx.sess);\n \n-    {\n-        let disp = root_path.display();\n-        info!(\"Writing output to {}\", disp);\n+        match self.format {\n+            Format::Csv => dump!(CsvDumper::new(output)),\n+            Format::Json => dump!(JsonDumper::new(output)),\n+            Format::JsonApi => dump!(JsonApiDumper::new(output)),\n+        }\n     }\n+}\n \n-    // Create output file.\n-    let executable = tcx.sess.crate_types.borrow().iter().any(|ct| *ct == CrateTypeExecutable);\n-    let mut out_name = if executable {\n-        \"\".to_owned()\n-    } else {\n-        \"lib\".to_owned()\n-    };\n-    out_name.push_str(&cratename);\n-    out_name.push_str(&tcx.sess.opts.cg.extra_filename);\n-    out_name.push_str(format.extension());\n-    root_path.push(&out_name);\n-    let mut output_file = File::create(&root_path).unwrap_or_else(|e| {\n-        let disp = root_path.display();\n-        tcx.sess.fatal(&format!(\"Could not open {}: {}\", disp, e));\n-    });\n-    root_path.pop();\n-    let output = &mut output_file;\n+/// Call a callback with the results of save-analysis.\n+pub struct CallbackHandler<'b> {\n+    pub callback: &'b mut FnMut(&rls_data::Analysis),\n+}\n+\n+impl<'b> SaveHandler for CallbackHandler<'b> {\n+    fn save<'l, 'tcx>(&mut self,\n+                      save_ctxt: SaveContext<'l, 'tcx>,\n+                      krate: &ast::Crate,\n+                      cratename: &str) {\n+        macro_rules! dump {\n+            ($new_dumper: expr) => {{\n+                let mut dumper = $new_dumper;\n+                let mut visitor = DumpVisitor::new(save_ctxt, &mut dumper);\n+\n+                visitor.dump_crate_info(cratename, krate);\n+                visit::walk_crate(&mut visitor, krate);\n+            }}\n+        }\n+\n+        // We're using the JsonDumper here because it has the format of the\n+        // save-analysis results that we will pass to the callback. IOW, we are\n+        // using the JsonDumper to collect the save-analysis results, but not\n+        // actually to dump them to a file. This is all a bit convoluted and\n+        // there is certainly a simpler design here trying to get out (FIXME).\n+        dump!(JsonDumper::with_callback(self.callback))\n+    }\n+}\n+\n+pub fn process_crate<'l, 'tcx, H: SaveHandler>(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n+                                               krate: &ast::Crate,\n+                                               analysis: &'l ty::CrateAnalysis,\n+                                               cratename: &str,\n+                                               mut handler: H) {\n+    let _ignore = tcx.dep_graph.in_ignore();\n+\n+    assert!(analysis.glob_map.is_some());\n+\n+    info!(\"Dumping crate {}\", cratename);\n \n     let save_ctxt = SaveContext {\n         tcx: tcx,\n@@ -923,21 +1000,7 @@ pub fn process_crate<'l, 'tcx>(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n         span_utils: SpanUtils::new(&tcx.sess),\n     };\n \n-    macro_rules! dump {\n-        ($new_dumper: expr) => {{\n-            let mut dumper = $new_dumper;\n-            let mut visitor = DumpVisitor::new(save_ctxt, &mut dumper);\n-\n-            visitor.dump_crate_info(cratename, krate);\n-            visit::walk_crate(&mut visitor, krate);\n-        }}\n-    }\n-\n-    match format {\n-        Format::Csv => dump!(CsvDumper::new(output)),\n-        Format::Json => dump!(JsonDumper::new(output)),\n-        Format::JsonApi => dump!(JsonApiDumper::new(output)),\n-    }\n+    handler.save(save_ctxt, krate, cratename)\n }\n \n // Utility functions for the module."}]}