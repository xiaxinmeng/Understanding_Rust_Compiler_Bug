{"sha": "7c1283a0686893ee7d906168c40d905db909d3a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjMTI4M2EwNjg2ODkzZWU3ZDkwNjE2OGM0MGQ5MDVkYjkwOWQzYTM=", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2021-07-28T21:11:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-28T21:11:42Z"}, "message": "Rollup merge of #81363 - jonhoo:no-unpin-in-pin-future-impl, r=m-ou-se\n\nRemove P: Unpin bound on impl Future for Pin\n\nWe can safely produce a `Pin<&mut P::Target>` without moving out of the `Pin` by using `Pin::as_mut` directly.\n\nThe `Unpin` bound was originally added in #56939 following the recommendation of ``@withoutboats`` in https://github.com/rust-lang/rust/issues/55766#issue-378417538\n\nThat comment does not give explicit justification for why the bound should be added. The relevant context was:\n\n> [ ] Remove `impl<P> Unpin for Pin<P>`\n>\n> This impl is not justified by our standard justification for unpin impls: there is no pointer direction between `Pin<P>` and `P`. Its usefulness is covered by the impls for pointers themselves.\n>\n> This futures impl (link to the impl changed in this PR) will need to change to add a `P: Unpin` bound.\n\nThe decision to remove the unconditional impl of `Unpin for Pin` is sound (these days there is just an auto-impl for when `P: Unpin`). But, I think the decision to also add the `Unpin` bound for `impl Future` may have been unnecessary. Or if that's not the case, I'd be very interested to have the argument for why written down somewhere. The bound _appears_ to not be needed, as demonstrated by the change requiring no unsafe code and by the existence of `Pin::as_mut`.", "tree": {"sha": "ef202aef969c3b6f12f91275fa3294d16216ea94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef202aef969c3b6f12f91275fa3294d16216ea94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c1283a0686893ee7d906168c40d905db909d3a3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhAcgOCRBK7hj4Ov3rIwAAHJYIAElVSkTfhGeSnXbvyQtqwtqp\n5WHDktMLufFR8QV+A3u1ruBoEfRr3BMNMM28j8/D9U4dPIE/vQmkoLG1YC/xBV06\nsJTxqUkWhoQbtk+YQv2tbGwUcLBZ+DHo8f+ETcgXqaGbehUmx7X1zpZkGhrbq3ie\nYM/d1plKiAfmYf263BPdIHx5vhoTTXm3AgZqJmezac3deOtMWFD2amZu4iKpJljo\nRMigbS/mYQkvYYiDYYZ5KeVK6t8DWKKOF/gjbPCVaFw+TRchZkZ/uYzXaCxXrhBn\n0hph/txdHY1D4KjyQAYqLg2sYb6qc5346uH7CUSqNXXEIBwVxLMVytA3IyGEynY=\n=vRA1\n-----END PGP SIGNATURE-----\n", "payload": "tree ef202aef969c3b6f12f91275fa3294d16216ea94\nparent fef1725c0f60616e62b75342ce96412748544725\nparent cf402921222bd6b3152c6ed55c7039887d12a4c0\nauthor Yuki Okushi <jtitor@2k36.org> 1627506702 +0900\ncommitter GitHub <noreply@github.com> 1627506702 +0900\n\nRollup merge of #81363 - jonhoo:no-unpin-in-pin-future-impl, r=m-ou-se\n\nRemove P: Unpin bound on impl Future for Pin\n\nWe can safely produce a `Pin<&mut P::Target>` without moving out of the `Pin` by using `Pin::as_mut` directly.\n\nThe `Unpin` bound was originally added in #56939 following the recommendation of ``@withoutboats`` in https://github.com/rust-lang/rust/issues/55766#issue-378417538\n\nThat comment does not give explicit justification for why the bound should be added. The relevant context was:\n\n> [ ] Remove `impl<P> Unpin for Pin<P>`\n>\n> This impl is not justified by our standard justification for unpin impls: there is no pointer direction between `Pin<P>` and `P`. Its usefulness is covered by the impls for pointers themselves.\n>\n> This futures impl (link to the impl changed in this PR) will need to change to add a `P: Unpin` bound.\n\nThe decision to remove the unconditional impl of `Unpin for Pin` is sound (these days there is just an auto-impl for when `P: Unpin`). But, I think the decision to also add the `Unpin` bound for `impl Future` may have been unnecessary. Or if that's not the case, I'd be very interested to have the argument for why written down somewhere. The bound _appears_ to not be needed, as demonstrated by the change requiring no unsafe code and by the existence of `Pin::as_mut`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c1283a0686893ee7d906168c40d905db909d3a3", "html_url": "https://github.com/rust-lang/rust/commit/7c1283a0686893ee7d906168c40d905db909d3a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c1283a0686893ee7d906168c40d905db909d3a3/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fef1725c0f60616e62b75342ce96412748544725", "url": "https://api.github.com/repos/rust-lang/rust/commits/fef1725c0f60616e62b75342ce96412748544725", "html_url": "https://github.com/rust-lang/rust/commit/fef1725c0f60616e62b75342ce96412748544725"}, {"sha": "cf402921222bd6b3152c6ed55c7039887d12a4c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf402921222bd6b3152c6ed55c7039887d12a4c0", "html_url": "https://github.com/rust-lang/rust/commit/cf402921222bd6b3152c6ed55c7039887d12a4c0"}], "stats": {"total": 43, "additions": 41, "deletions": 2}, "files": [{"sha": "7cd0ce9d2efe0fab67dfeedc8a405effffd04ba4", "filename": "library/core/src/future/future.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c1283a0686893ee7d906168c40d905db909d3a3/library%2Fcore%2Fsrc%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c1283a0686893ee7d906168c40d905db909d3a3/library%2Fcore%2Fsrc%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Ffuture.rs?ref=7c1283a0686893ee7d906168c40d905db909d3a3", "patch": "@@ -111,11 +111,11 @@ impl<F: ?Sized + Future + Unpin> Future for &mut F {\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n impl<P> Future for Pin<P>\n where\n-    P: Unpin + ops::DerefMut<Target: Future>,\n+    P: ops::DerefMut<Target: Future>,\n {\n     type Output = <<P as ops::Deref>::Target as Future>::Output;\n \n     fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n-        Pin::get_mut(self).as_mut().poll(cx)\n+        <P::Target as Future>::poll(self.as_deref_mut(), cx)\n     }\n }"}, {"sha": "f7d48a91396fff38c181ad5aab9c13cef299d371", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c1283a0686893ee7d906168c40d905db909d3a3/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c1283a0686893ee7d906168c40d905db909d3a3/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=7c1283a0686893ee7d906168c40d905db909d3a3", "patch": "@@ -128,6 +128,7 @@\n #![feature(exhaustive_patterns)]\n #![feature(no_core)]\n #![feature(auto_traits)]\n+#![feature(pin_deref_mut)]\n #![feature(prelude_import)]\n #![feature(ptr_metadata)]\n #![feature(repr_simd, platform_intrinsics)]"}, {"sha": "6b1a12ed18c0fa6351adbd70a1106dfb8420fde0", "filename": "library/core/src/pin.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7c1283a0686893ee7d906168c40d905db909d3a3/library%2Fcore%2Fsrc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c1283a0686893ee7d906168c40d905db909d3a3/library%2Fcore%2Fsrc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpin.rs?ref=7c1283a0686893ee7d906168c40d905db909d3a3", "patch": "@@ -802,6 +802,44 @@ impl<T: ?Sized> Pin<&'static T> {\n     }\n }\n \n+impl<'a, P: DerefMut> Pin<&'a mut Pin<P>> {\n+    /// Gets a pinned mutable reference from this nested pinned pointer.\n+    ///\n+    /// This is a generic method to go from `Pin<&mut Pin<Pointer<T>>>` to `Pin<&mut T>`. It is\n+    /// safe because the existence of a `Pin<Pointer<T>>` ensures that the pointee, `T`, cannot\n+    /// move in the future, and this method does not enable the pointee to move. \"Malicious\"\n+    /// implementations of `P::DerefMut` are likewise ruled out by the contract of\n+    /// `Pin::new_unchecked`.\n+    #[unstable(feature = \"pin_deref_mut\", issue = \"86918\")]\n+    #[inline(always)]\n+    pub fn as_deref_mut(self) -> Pin<&'a mut P::Target> {\n+        // SAFETY: What we're asserting here is that going from\n+        //\n+        //     Pin<&mut Pin<P>>\n+        //\n+        // to\n+        //\n+        //     Pin<&mut P::Target>\n+        //\n+        // is safe.\n+        //\n+        // We need to ensure that two things hold for that to be the case:\n+        //\n+        // 1) Once we give out a `Pin<&mut P::Target>`, an `&mut P::Target` will not be given out.\n+        // 2) By giving out a `Pin<&mut P::Target>`, we do not risk of violating `Pin<&mut Pin<P>>`\n+        //\n+        // The existence of `Pin<P>` is sufficient to guarantee #1: since we already have a\n+        // `Pin<P>`, it must already uphold the pinning guarantees, which must mean that\n+        // `Pin<&mut P::Target>` does as well, since `Pin::as_mut` is safe. We do not have to rely\n+        // on the fact that P is _also_ pinned.\n+        //\n+        // For #2, we need to ensure that code given a `Pin<&mut P::Target>` cannot cause the\n+        // `Pin<P>` to move? That is not possible, since `Pin<&mut P::Target>` no longer retains\n+        // any access to the `P` itself, much less the `Pin<P>`.\n+        unsafe { self.get_unchecked_mut() }.as_mut()\n+    }\n+}\n+\n impl<T: ?Sized> Pin<&'static mut T> {\n     /// Get a pinned mutable reference from a static mutable reference.\n     ///"}]}