{"sha": "cce5c2d93ad4b33967c8f06f26c67e204c46c87b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjZTVjMmQ5M2FkNGIzMzk2N2M4ZjA2ZjI2YzY3ZTIwNGM0NmM4N2I=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-04-06T18:55:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-04-06T18:55:02Z"}, "message": "Rollup merge of #40878 - michaelwoerister:dmh, r=nikomatsakis\n\nIntroduce HashStable trait and base ICH implementations on it.\n\nThis PR introduces the `HashStable` trait which marks that a type can be hashed in a way that is stable across multiple compilation sessions. The PR also moves HIR incr. comp. hashing over to implementations of this trait instead of doing this via a HIR visitor. It also provides many `HashStable` implementations that are not used yet (e.g. for MIR types) but soon will be used when we directly hash crate metadata for incr. comp.\n\nI've only done superficial performance measurements but it looks like the new implementation is a bit faster than the current one (due, I suppose, to some bugs I fixed and some unnecessary inefficiencies I removed). Here is the time in seconds for the `compute_incremental_hashes_map` pass for various crates:\n\n|                 |  OLD  |  NEW  |\n|:---------------:|:-----:|:-----:|\n| libcore         | 0.507 | 0.409 |\n| libsyntax       | 0.320 | 0.260 |\n| librustc        | 0.730 | 0.611 |\n| librustc_driver | 0.024 | 0.015 |\n\nSome notes regarding the implementation:\n* Most `HashStable` implementations are provided via the `impl_hash_stable_for!` macro (as suggested by @nikomatsakis). This works out quite well. A custom_derive would have been better but Macros 1.1 are not available in the compiler.\n* The trait implementation take care to exhaustively destructure everything they hash so that fields added in the future don't fall through the cracks. This is a bit verbose but I think it's well worth the trouble since we've had quite a few issues with missing fields or visitor callbacks in this area in the past. Most of it is behind the macro anyway.\n\ncc @rust-lang/compiler\nr? @nikomatsakis", "tree": {"sha": "58ab45820cdc33bc3cccab9c933753f806a5666f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58ab45820cdc33bc3cccab9c933753f806a5666f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cce5c2d93ad4b33967c8f06f26c67e204c46c87b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cce5c2d93ad4b33967c8f06f26c67e204c46c87b", "html_url": "https://github.com/rust-lang/rust/commit/cce5c2d93ad4b33967c8f06f26c67e204c46c87b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44855a4cef3e83c76c386fdcf034447a8ee128e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/44855a4cef3e83c76c386fdcf034447a8ee128e4", "html_url": "https://github.com/rust-lang/rust/commit/44855a4cef3e83c76c386fdcf034447a8ee128e4"}, {"sha": "c47cdc0d93726429ee18b418b1f85fae67b82d41", "url": "https://api.github.com/repos/rust-lang/rust/commits/c47cdc0d93726429ee18b418b1f85fae67b82d41", "html_url": "https://github.com/rust-lang/rust/commit/c47cdc0d93726429ee18b418b1f85fae67b82d41"}], "stats": {"total": 4303, "additions": 3080, "deletions": 1223}, "files": [{"sha": "dca9ebb3397a62b547b831f931ae172231df6f5b", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=cce5c2d93ad4b33967c8f06f26c67e204c46c87b", "patch": "@@ -394,6 +394,10 @@ impl Definitions {\n         }\n     }\n \n+    pub fn node_to_hir_id(&self, node_id: ast::NodeId) -> hir::HirId {\n+        self.node_to_hir_id[node_id]\n+    }\n+\n     /// Add a definition with a parent definition.\n     pub fn create_def_with_parent(&mut self,\n                                   parent: Option<DefIndex>,"}, {"sha": "73d81212cd77eaf5ffd15c5d4e7d241582521048", "filename": "src/librustc/ich/hcx.rs", "status": "added", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=cce5c2d93ad4b33967c8f06f26c67e204c46c87b", "patch": "@@ -0,0 +1,300 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hir;\n+use hir::def_id::DefId;\n+use ich::{self, CachingCodemapView, DefPathHashes};\n+use session::config::DebugInfoLevel::NoDebugInfo;\n+use ty;\n+\n+use std::hash as std_hash;\n+\n+use syntax::ast;\n+use syntax::attr;\n+use syntax::ext::hygiene::SyntaxContext;\n+use syntax::symbol::Symbol;\n+use syntax_pos::Span;\n+\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n+use rustc_data_structures::accumulate_vec::AccumulateVec;\n+\n+/// This is the context state available during incr. comp. hashing. It contains\n+/// enough information to transform DefIds and HirIds into stable DefPaths (i.e.\n+/// a reference to the TyCtxt) and it holds a few caches for speeding up various\n+/// things (e.g. each DefId/DefPath is only hashed once).\n+pub struct StableHashingContext<'a, 'tcx: 'a> {\n+    tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+    def_path_hashes: DefPathHashes<'a, 'tcx>,\n+    codemap: CachingCodemapView<'tcx>,\n+    hash_spans: bool,\n+    hash_bodies: bool,\n+    overflow_checks_enabled: bool,\n+    node_id_hashing_mode: NodeIdHashingMode,\n+    // A sorted array of symbol keys for fast lookup.\n+    ignored_attr_names: Vec<Symbol>,\n+}\n+\n+#[derive(PartialEq, Eq, Clone, Copy)]\n+pub enum NodeIdHashingMode {\n+    Ignore,\n+    HashDefPath,\n+    HashTraitsInScope,\n+}\n+\n+impl<'a, 'tcx: 'a> StableHashingContext<'a, 'tcx> {\n+\n+    pub fn new(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+        let hash_spans_initial = tcx.sess.opts.debuginfo != NoDebugInfo;\n+        let check_overflow_initial = tcx.sess.overflow_checks();\n+\n+        let mut ignored_attr_names: Vec<_> = ich::IGNORED_ATTRIBUTES\n+            .iter()\n+            .map(|&s| Symbol::intern(s))\n+            .collect();\n+\n+        ignored_attr_names.sort();\n+\n+        StableHashingContext {\n+            tcx: tcx,\n+            def_path_hashes: DefPathHashes::new(tcx),\n+            codemap: CachingCodemapView::new(tcx),\n+            hash_spans: hash_spans_initial,\n+            hash_bodies: true,\n+            overflow_checks_enabled: check_overflow_initial,\n+            node_id_hashing_mode: NodeIdHashingMode::HashDefPath,\n+            ignored_attr_names: ignored_attr_names,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn while_hashing_hir_bodies<F: FnOnce(&mut Self)>(&mut self,\n+                                                          hash_bodies: bool,\n+                                                          f: F) {\n+        let prev_hash_bodies = self.hash_bodies;\n+        self.hash_bodies = hash_bodies;\n+        f(self);\n+        self.hash_bodies = prev_hash_bodies;\n+    }\n+\n+    #[inline]\n+    pub fn while_hashing_spans<F: FnOnce(&mut Self)>(&mut self,\n+                                                     hash_spans: bool,\n+                                                     f: F) {\n+        let prev_hash_spans = self.hash_spans;\n+        self.hash_spans = hash_spans;\n+        f(self);\n+        self.hash_spans = prev_hash_spans;\n+    }\n+\n+    #[inline]\n+    pub fn with_node_id_hashing_mode<F: FnOnce(&mut Self)>(&mut self,\n+                                                           mode: NodeIdHashingMode,\n+                                                           f: F) {\n+        let prev = self.node_id_hashing_mode;\n+        self.node_id_hashing_mode = mode;\n+        f(self);\n+        self.node_id_hashing_mode = prev;\n+    }\n+\n+    #[inline]\n+    pub fn tcx(&self) -> ty::TyCtxt<'a, 'tcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    #[inline]\n+    pub fn def_path_hash(&mut self, def_id: DefId) -> u64 {\n+        self.def_path_hashes.hash(def_id)\n+    }\n+\n+    #[inline]\n+    pub fn hash_spans(&self) -> bool {\n+        self.hash_spans\n+    }\n+\n+    #[inline]\n+    pub fn hash_bodies(&self) -> bool {\n+        self.hash_bodies\n+    }\n+\n+    #[inline]\n+    pub fn codemap(&mut self) -> &mut CachingCodemapView<'tcx> {\n+        &mut self.codemap\n+    }\n+\n+    #[inline]\n+    pub fn is_ignored_attr(&self, name: Symbol) -> bool {\n+        self.ignored_attr_names.binary_search(&name).is_ok()\n+    }\n+\n+    pub fn hash_hir_item_like<F: FnOnce(&mut Self)>(&mut self,\n+                                                    item_attrs: &[ast::Attribute],\n+                                                    f: F) {\n+        let prev_overflow_checks = self.overflow_checks_enabled;\n+        if attr::contains_name(item_attrs, \"rustc_inherit_overflow_checks\") {\n+            self.overflow_checks_enabled = true;\n+        }\n+        let prev_hash_node_ids = self.node_id_hashing_mode;\n+        self.node_id_hashing_mode = NodeIdHashingMode::Ignore;\n+\n+        f(self);\n+\n+        self.node_id_hashing_mode = prev_hash_node_ids;\n+        self.overflow_checks_enabled = prev_overflow_checks;\n+    }\n+\n+    #[inline]\n+    pub fn binop_can_panic_at_runtime(&self, binop: hir::BinOp_) -> bool\n+    {\n+        match binop {\n+            hir::BiAdd |\n+            hir::BiSub |\n+            hir::BiMul => self.overflow_checks_enabled,\n+\n+            hir::BiDiv |\n+            hir::BiRem => true,\n+\n+            hir::BiAnd |\n+            hir::BiOr |\n+            hir::BiBitXor |\n+            hir::BiBitAnd |\n+            hir::BiBitOr |\n+            hir::BiShl |\n+            hir::BiShr |\n+            hir::BiEq |\n+            hir::BiLt |\n+            hir::BiLe |\n+            hir::BiNe |\n+            hir::BiGe |\n+            hir::BiGt => false\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn unop_can_panic_at_runtime(&self, unop: hir::UnOp) -> bool\n+    {\n+        match unop {\n+            hir::UnDeref |\n+            hir::UnNot => false,\n+            hir::UnNeg => self.overflow_checks_enabled,\n+        }\n+    }\n+}\n+\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::NodeId {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        match hcx.node_id_hashing_mode {\n+            NodeIdHashingMode::Ignore => {\n+                // Most NodeIds in the HIR can be ignored, but if there is a\n+                // corresponding entry in the `trait_map` we need to hash that.\n+                // Make sure we don't ignore too much by checking that there is\n+                // no entry in a debug_assert!().\n+                debug_assert!(hcx.tcx.trait_map.get(self).is_none());\n+            }\n+            NodeIdHashingMode::HashDefPath => {\n+                hcx.tcx.hir.definitions().node_to_hir_id(*self).hash_stable(hcx, hasher);\n+            }\n+            NodeIdHashingMode::HashTraitsInScope => {\n+                if let Some(traits) = hcx.tcx.trait_map.get(self) {\n+                    // The ordering of the candidates is not fixed. So we hash\n+                    // the def-ids and then sort them and hash the collection.\n+                    let mut candidates: AccumulateVec<[_; 8]> =\n+                        traits.iter()\n+                              .map(|&hir::TraitCandidate { def_id, import_id: _ }| {\n+                                  hcx.def_path_hash(def_id)\n+                              })\n+                              .collect();\n+                    if traits.len() > 1 {\n+                        candidates.sort();\n+                    }\n+                    candidates.hash_stable(hcx, hasher);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for Span {\n+\n+    // Hash a span in a stable way. We can't directly hash the span's BytePos\n+    // fields (that would be similar to hashing pointers, since those are just\n+    // offsets into the CodeMap). Instead, we hash the (file name, line, column)\n+    // triple, which stays the same even if the containing FileMap has moved\n+    // within the CodeMap.\n+    // Also note that we are hashing byte offsets for the column, not unicode\n+    // codepoint offsets. For the purpose of the hash that's sufficient.\n+    // Also, hashing filenames is expensive so we avoid doing it twice when the\n+    // span starts and ends in the same file, which is almost always the case.\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use syntax_pos::Pos;\n+\n+        if !hcx.hash_spans {\n+            return\n+        }\n+\n+        // If this is not an empty or invalid span, we want to hash the last\n+        // position that belongs to it, as opposed to hashing the first\n+        // position past it.\n+        let span_hi = if self.hi > self.lo {\n+            // We might end up in the middle of a multibyte character here,\n+            // but that's OK, since we are not trying to decode anything at\n+            // this position.\n+            self.hi - ::syntax_pos::BytePos(1)\n+        } else {\n+            self.hi\n+        };\n+\n+        {\n+            let loc1 = hcx.codemap().byte_pos_to_line_and_col(self.lo);\n+            let loc1 = loc1.as_ref()\n+                           .map(|&(ref fm, line, col)| (&fm.name[..], line, col.to_usize()))\n+                           .unwrap_or((\"???\", 0, 0));\n+\n+            let loc2 = hcx.codemap().byte_pos_to_line_and_col(span_hi);\n+            let loc2 = loc2.as_ref()\n+                           .map(|&(ref fm, line, col)| (&fm.name[..], line, col.to_usize()))\n+                           .unwrap_or((\"???\", 0, 0));\n+\n+            if loc1.0 == loc2.0 {\n+                std_hash::Hash::hash(&0u8, hasher);\n+\n+                std_hash::Hash::hash(loc1.0, hasher);\n+                std_hash::Hash::hash(&loc1.1, hasher);\n+                std_hash::Hash::hash(&loc1.2, hasher);\n+\n+                // Do not hash the file name twice\n+                std_hash::Hash::hash(&loc2.1, hasher);\n+                std_hash::Hash::hash(&loc2.2, hasher);\n+            } else {\n+                std_hash::Hash::hash(&1u8, hasher);\n+\n+                std_hash::Hash::hash(loc1.0, hasher);\n+                std_hash::Hash::hash(&loc1.1, hasher);\n+                std_hash::Hash::hash(&loc1.2, hasher);\n+\n+                std_hash::Hash::hash(loc2.0, hasher);\n+                std_hash::Hash::hash(&loc2.1, hasher);\n+                std_hash::Hash::hash(&loc2.2, hasher);\n+            }\n+        }\n+\n+        if self.ctxt == SyntaxContext::empty() {\n+            0u8.hash_stable(hcx, hasher);\n+        } else {\n+            1u8.hash_stable(hcx, hasher);\n+            self.source_callsite().hash_stable(hcx, hasher);\n+        }\n+    }\n+}"}, {"sha": "6d11f2a87a413485ceb97bbaf6cdb2ebc4b8caf4", "filename": "src/librustc/ich/impls_const_math.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc%2Fich%2Fimpls_const_math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc%2Fich%2Fimpls_const_math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_const_math.rs?ref=cce5c2d93ad4b33967c8f06f26c67e204c46c87b", "patch": "@@ -0,0 +1,71 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains `HashStable` implementations for various data types\n+//! from `rustc_const_math` in no particular order.\n+\n+impl_stable_hash_for!(enum ::rustc_const_math::ConstFloat {\n+    F32(val),\n+    F64(val)\n+});\n+\n+impl_stable_hash_for!(enum ::rustc_const_math::ConstInt {\n+    I8(val),\n+    I16(val),\n+    I32(val),\n+    I64(val),\n+    I128(val),\n+    Isize(val),\n+    U8(val),\n+    U16(val),\n+    U32(val),\n+    U64(val),\n+    U128(val),\n+    Usize(val)\n+});\n+\n+impl_stable_hash_for!(enum ::rustc_const_math::ConstIsize {\n+    Is16(i16),\n+    Is32(i32),\n+    Is64(i64)\n+});\n+\n+impl_stable_hash_for!(enum ::rustc_const_math::ConstUsize {\n+    Us16(i16),\n+    Us32(i32),\n+    Us64(i64)\n+});\n+\n+impl_stable_hash_for!(enum ::rustc_const_math::ConstMathErr {\n+    NotInRange,\n+    CmpBetweenUnequalTypes,\n+    UnequalTypes(op),\n+    Overflow(op),\n+    ShiftNegative,\n+    DivisionByZero,\n+    RemainderByZero,\n+    UnsignedNegation,\n+    ULitOutOfRange(int_ty),\n+    LitOutOfRange(int_ty)\n+});\n+\n+impl_stable_hash_for!(enum ::rustc_const_math::Op {\n+    Add,\n+    Sub,\n+    Mul,\n+    Div,\n+    Rem,\n+    Shr,\n+    Shl,\n+    Neg,\n+    BitAnd,\n+    BitOr,\n+    BitXor\n+});"}, {"sha": "fb18f50027e29602d2a9ea630f6619e3767a1da8", "filename": "src/librustc/ich/impls_hir.rs", "status": "added", "additions": 1104, "deletions": 0, "changes": 1104, "blob_url": "https://github.com/rust-lang/rust/blob/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=cce5c2d93ad4b33967c8f06f26c67e204c46c87b", "patch": "@@ -0,0 +1,1104 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains `HashStable` implementations for various HIR data\n+//! types in no particular order.\n+\n+use hir;\n+use hir::def_id::DefId;\n+use ich::{StableHashingContext, NodeIdHashingMode};\n+use std::mem;\n+\n+use syntax::ast;\n+\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for DefId {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        hcx.def_path_hash(*self).hash_stable(hcx, hasher);\n+    }\n+}\n+\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::HirId {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::HirId {\n+            owner,\n+            local_id,\n+        } = *self;\n+\n+        hcx.def_path_hash(DefId::local(owner)).hash_stable(hcx, hasher);\n+        local_id.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(tuple_struct hir::ItemLocalId { index });\n+\n+// The following implementations of HashStable for ItemId, TraitItemId, and\n+// ImplItemId deserve special attention. Normally we do not hash NodeIds within\n+// the HIR, since they just signify a HIR nodes own path. But ItemId et al\n+// are used when another item in the HIR is *referenced* and we certainly\n+// want to pick up on a reference changing its target, so we hash the NodeIds\n+// in \"DefPath Mode\".\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::ItemId {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::ItemId {\n+            id\n+        } = *self;\n+\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            id.hash_stable(hcx, hasher);\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::TraitItemId {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::TraitItemId {\n+            node_id\n+        } = * self;\n+\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            node_id.hash_stable(hcx, hasher);\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::ImplItemId {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::ImplItemId {\n+            node_id\n+        } = * self;\n+\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            node_id.hash_stable(hcx, hasher);\n+        })\n+    }\n+}\n+\n+impl_stable_hash_for!(struct hir::Lifetime {\n+    id,\n+    span,\n+    name\n+});\n+\n+impl_stable_hash_for!(struct hir::LifetimeDef {\n+    lifetime,\n+    bounds,\n+    pure_wrt_drop\n+});\n+\n+impl_stable_hash_for!(struct hir::Path {\n+    span,\n+    def,\n+    segments\n+});\n+\n+impl_stable_hash_for!(struct hir::PathSegment {\n+    name,\n+    parameters\n+});\n+\n+impl_stable_hash_for!(enum hir::PathParameters {\n+    AngleBracketedParameters(data),\n+    ParenthesizedParameters(data)\n+});\n+\n+impl_stable_hash_for!(struct hir::AngleBracketedParameterData {\n+    lifetimes,\n+    types,\n+    infer_types,\n+    bindings\n+});\n+\n+impl_stable_hash_for!(struct hir::ParenthesizedParameterData {\n+    span,\n+    inputs,\n+    output\n+});\n+\n+impl_stable_hash_for!(enum hir::TyParamBound {\n+    TraitTyParamBound(poly_trait_ref, trait_bound_modifier),\n+    RegionTyParamBound(lifetime)\n+});\n+\n+impl_stable_hash_for!(enum hir::TraitBoundModifier {\n+    None,\n+    Maybe\n+});\n+\n+impl_stable_hash_for!(struct hir::TyParam {\n+    name,\n+    id,\n+    bounds,\n+    default,\n+    span,\n+    pure_wrt_drop\n+});\n+\n+impl_stable_hash_for!(struct hir::Generics {\n+    lifetimes,\n+    ty_params,\n+    where_clause,\n+    span\n+});\n+\n+impl_stable_hash_for!(struct hir::WhereClause {\n+    id,\n+    predicates\n+});\n+\n+impl_stable_hash_for!(enum hir::WherePredicate {\n+    BoundPredicate(pred),\n+    RegionPredicate(pred),\n+    EqPredicate(pred)\n+});\n+\n+impl_stable_hash_for!(struct hir::WhereBoundPredicate {\n+    span,\n+    bound_lifetimes,\n+    bounded_ty,\n+    bounds\n+});\n+\n+impl_stable_hash_for!(struct hir::WhereRegionPredicate {\n+    span,\n+    lifetime,\n+    bounds\n+});\n+\n+impl_stable_hash_for!(struct hir::WhereEqPredicate {\n+    id,\n+    span,\n+    lhs_ty,\n+    rhs_ty\n+});\n+\n+impl_stable_hash_for!(struct hir::MutTy {\n+    ty,\n+    mutbl\n+});\n+\n+impl_stable_hash_for!(struct hir::MethodSig {\n+    unsafety,\n+    constness,\n+    abi,\n+    decl,\n+    generics\n+});\n+\n+impl_stable_hash_for!(struct hir::TypeBinding {\n+    id,\n+    name,\n+    ty,\n+    span\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Ty {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let node_id_hashing_mode = match self.node {\n+            hir::TySlice(..)       |\n+            hir::TyArray(..)       |\n+            hir::TyPtr(..)         |\n+            hir::TyRptr(..)        |\n+            hir::TyBareFn(..)      |\n+            hir::TyNever           |\n+            hir::TyTup(..)         |\n+            hir::TyTraitObject(..) |\n+            hir::TyImplTrait(..)   |\n+            hir::TyTypeof(..)      |\n+            hir::TyInfer           => {\n+                NodeIdHashingMode::Ignore\n+            }\n+            hir::TyPath(..) => {\n+                NodeIdHashingMode::HashTraitsInScope\n+            }\n+        };\n+\n+        hcx.while_hashing_hir_bodies(true, |hcx| {\n+            let hir::Ty {\n+                id,\n+                ref node,\n+                ref span,\n+            } = *self;\n+\n+            hcx.with_node_id_hashing_mode(node_id_hashing_mode, |hcx| {\n+                id.hash_stable(hcx, hasher);\n+            });\n+            node.hash_stable(hcx, hasher);\n+            span.hash_stable(hcx, hasher);\n+        })\n+    }\n+}\n+\n+impl_stable_hash_for!(enum hir::PrimTy {\n+    TyInt(int_ty),\n+    TyUint(uint_ty),\n+    TyFloat(float_ty),\n+    TyStr,\n+    TyBool,\n+    TyChar\n+});\n+\n+impl_stable_hash_for!(struct hir::BareFnTy {\n+    unsafety,\n+    abi,\n+    lifetimes,\n+    decl\n+});\n+\n+impl_stable_hash_for!(enum hir::Ty_ {\n+    TySlice(t),\n+    TyArray(t, body_id),\n+    TyPtr(t),\n+    TyRptr(lifetime, t),\n+    TyBareFn(t),\n+    TyNever,\n+    TyTup(ts),\n+    TyPath(qpath),\n+    TyTraitObject(trait_refs, lifetime),\n+    TyImplTrait(bounds),\n+    TyTypeof(body_id),\n+    TyInfer\n+});\n+\n+impl_stable_hash_for!(struct hir::FnDecl {\n+    inputs,\n+    output,\n+    variadic,\n+    has_implicit_self\n+});\n+\n+impl_stable_hash_for!(enum hir::FunctionRetTy {\n+    DefaultReturn(span),\n+    Return(t)\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::TraitRef {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::TraitRef {\n+            ref path,\n+            ref_id,\n+        } = *self;\n+\n+        path.hash_stable(hcx, hasher);\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashTraitsInScope, |hcx| {\n+            ref_id.hash_stable(hcx, hasher);\n+        });\n+    }\n+}\n+\n+\n+impl_stable_hash_for!(struct hir::PolyTraitRef {\n+    bound_lifetimes,\n+    trait_ref,\n+    span\n+});\n+\n+impl_stable_hash_for!(enum hir::QPath {\n+    Resolved(t, path),\n+    TypeRelative(t, path_segment)\n+});\n+\n+impl_stable_hash_for!(struct hir::MacroDef {\n+    name,\n+    attrs,\n+    id,\n+    span,\n+    body\n+});\n+\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Block {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::Block {\n+            ref stmts,\n+            ref expr,\n+            id,\n+            rules,\n+            span,\n+            targeted_by_break,\n+        } = *self;\n+\n+        let non_item_stmts = || stmts.iter().filter(|stmt| {\n+            match stmt.node {\n+                hir::StmtDecl(ref decl, _) => {\n+                    match decl.node {\n+                        // If this is a declaration of a nested item, we don't\n+                        // want to leave any trace of it in the hash value, not\n+                        // even that it exists. Otherwise changing the position\n+                        // of nested items would invalidate the containing item\n+                        // even though that does not constitute a semantic\n+                        // change.\n+                        hir::DeclItem(_) => false,\n+                        hir::DeclLocal(_) => true\n+                    }\n+                }\n+                hir::StmtExpr(..) |\n+                hir::StmtSemi(..) => true\n+            }\n+        });\n+\n+        let count = non_item_stmts().count();\n+\n+        count.hash_stable(hcx, hasher);\n+\n+        for stmt in non_item_stmts() {\n+            stmt.hash_stable(hcx, hasher);\n+        }\n+\n+        expr.hash_stable(hcx, hasher);\n+        id.hash_stable(hcx, hasher);\n+        rules.hash_stable(hcx, hasher);\n+        span.hash_stable(hcx, hasher);\n+        targeted_by_break.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Pat {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let node_id_hashing_mode = match self.node {\n+            hir::PatKind::Wild        |\n+            hir::PatKind::Binding(..) |\n+            hir::PatKind::Tuple(..)   |\n+            hir::PatKind::Box(..)     |\n+            hir::PatKind::Ref(..)     |\n+            hir::PatKind::Lit(..)     |\n+            hir::PatKind::Range(..)   |\n+            hir::PatKind::Slice(..)   => {\n+                NodeIdHashingMode::Ignore\n+            }\n+            hir::PatKind::Path(..)        |\n+            hir::PatKind::Struct(..)      |\n+            hir::PatKind::TupleStruct(..) => {\n+                NodeIdHashingMode::HashTraitsInScope\n+            }\n+        };\n+\n+        let hir::Pat {\n+            id,\n+            ref node,\n+            ref span\n+        } = *self;\n+\n+        hcx.with_node_id_hashing_mode(node_id_hashing_mode, |hcx| {\n+            id.hash_stable(hcx, hasher);\n+        });\n+        node.hash_stable(hcx, hasher);\n+        span.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for_spanned!(hir::FieldPat);\n+impl_stable_hash_for!(struct hir::FieldPat {\n+    name,\n+    pat,\n+    is_shorthand\n+});\n+\n+impl_stable_hash_for!(enum hir::BindingMode {\n+    BindByRef(mutability),\n+    BindByValue(mutability)\n+});\n+\n+impl_stable_hash_for!(enum hir::RangeEnd {\n+    Included,\n+    Excluded\n+});\n+\n+impl_stable_hash_for!(enum hir::PatKind {\n+    Wild,\n+    Binding(binding_mode, var, name, sub),\n+    Struct(path, field_pats, dotdot),\n+    TupleStruct(path, field_pats, dotdot),\n+    Path(path),\n+    Tuple(field_pats, dotdot),\n+    Box(sub),\n+    Ref(sub, mutability),\n+    Lit(expr),\n+    Range(start, end, end_kind),\n+    Slice(one, two, three)\n+});\n+\n+impl_stable_hash_for!(enum hir::BinOp_ {\n+    BiAdd,\n+    BiSub,\n+    BiMul,\n+    BiDiv,\n+    BiRem,\n+    BiAnd,\n+    BiOr,\n+    BiBitXor,\n+    BiBitAnd,\n+    BiBitOr,\n+    BiShl,\n+    BiShr,\n+    BiEq,\n+    BiLt,\n+    BiLe,\n+    BiNe,\n+    BiGe,\n+    BiGt\n+});\n+\n+impl_stable_hash_for_spanned!(hir::BinOp_);\n+\n+impl_stable_hash_for!(enum hir::UnOp {\n+    UnDeref,\n+    UnNot,\n+    UnNeg\n+});\n+\n+impl_stable_hash_for_spanned!(hir::Stmt_);\n+\n+impl_stable_hash_for!(struct hir::Local {\n+    pat,\n+    ty,\n+    init,\n+    id,\n+    span,\n+    attrs\n+});\n+\n+impl_stable_hash_for_spanned!(hir::Decl_);\n+impl_stable_hash_for!(enum hir::Decl_ {\n+    DeclLocal(local),\n+    DeclItem(item_id)\n+});\n+\n+impl_stable_hash_for!(struct hir::Arm {\n+    attrs,\n+    pats,\n+    guard,\n+    body\n+});\n+\n+impl_stable_hash_for!(struct hir::Field {\n+    name,\n+    expr,\n+    span,\n+    is_shorthand\n+});\n+\n+impl_stable_hash_for_spanned!(ast::Name);\n+\n+\n+impl_stable_hash_for!(enum hir::BlockCheckMode {\n+    DefaultBlock,\n+    UnsafeBlock(src),\n+    PushUnsafeBlock(src),\n+    PopUnsafeBlock(src)\n+});\n+\n+impl_stable_hash_for!(enum hir::UnsafeSource {\n+    CompilerGenerated,\n+    UserProvided\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Expr {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        hcx.while_hashing_hir_bodies(true, |hcx| {\n+            let hir::Expr {\n+                id,\n+                ref span,\n+                ref node,\n+                ref attrs\n+            } = *self;\n+\n+            let (spans_always_on, node_id_hashing_mode) = match *node {\n+                hir::ExprBox(..)        |\n+                hir::ExprArray(..)      |\n+                hir::ExprCall(..)       |\n+                hir::ExprLit(..)        |\n+                hir::ExprCast(..)       |\n+                hir::ExprType(..)       |\n+                hir::ExprIf(..)         |\n+                hir::ExprWhile(..)      |\n+                hir::ExprLoop(..)       |\n+                hir::ExprMatch(..)      |\n+                hir::ExprClosure(..)    |\n+                hir::ExprBlock(..)      |\n+                hir::ExprAssign(..)     |\n+                hir::ExprTupField(..)   |\n+                hir::ExprAddrOf(..)     |\n+                hir::ExprBreak(..)      |\n+                hir::ExprAgain(..)      |\n+                hir::ExprRet(..)        |\n+                hir::ExprInlineAsm(..)  |\n+                hir::ExprRepeat(..)     |\n+                hir::ExprTup(..)        => {\n+                    // For these we only hash the span when debuginfo is on.\n+                    (false, NodeIdHashingMode::Ignore)\n+                }\n+                // For the following, spans might be significant because of\n+                // panic messages indicating the source location.\n+                hir::ExprBinary(op, ..) => {\n+                    (hcx.binop_can_panic_at_runtime(op.node), NodeIdHashingMode::Ignore)\n+                }\n+                hir::ExprUnary(op, _) => {\n+                    (hcx.unop_can_panic_at_runtime(op), NodeIdHashingMode::Ignore)\n+                }\n+                hir::ExprAssignOp(op, ..) => {\n+                    (hcx.binop_can_panic_at_runtime(op.node), NodeIdHashingMode::Ignore)\n+                }\n+                hir::ExprIndex(..) => {\n+                    (true, NodeIdHashingMode::Ignore)\n+                }\n+                // For these we don't care about the span, but want to hash the\n+                // trait in scope\n+                hir::ExprMethodCall(..) |\n+                hir::ExprPath(..)       |\n+                hir::ExprStruct(..)     |\n+                hir::ExprField(..)      => {\n+                    (false, NodeIdHashingMode::HashTraitsInScope)\n+                }\n+            };\n+\n+            hcx.with_node_id_hashing_mode(node_id_hashing_mode, |hcx| {\n+                id.hash_stable(hcx, hasher);\n+            });\n+\n+            if spans_always_on {\n+                hcx.while_hashing_spans(true, |hcx| {\n+                    span.hash_stable(hcx, hasher);\n+                    node.hash_stable(hcx, hasher);\n+                    attrs.hash_stable(hcx, hasher);\n+                });\n+            } else {\n+                span.hash_stable(hcx, hasher);\n+                node.hash_stable(hcx, hasher);\n+                attrs.hash_stable(hcx, hasher);\n+            }\n+        })\n+    }\n+}\n+\n+impl_stable_hash_for!(enum hir::Expr_ {\n+    ExprBox(sub),\n+    ExprArray(subs),\n+    ExprCall(callee, args),\n+    ExprMethodCall(name, ts, args),\n+    ExprTup(fields),\n+    ExprBinary(op, lhs, rhs),\n+    ExprUnary(op, operand),\n+    ExprLit(value),\n+    ExprCast(expr, t),\n+    ExprType(expr, t),\n+    ExprIf(cond, then, els),\n+    ExprWhile(cond, body, label),\n+    ExprLoop(body, label, loop_src),\n+    ExprMatch(matchee, arms, match_src),\n+    ExprClosure(capture_clause, decl, body_id, span),\n+    ExprBlock(blk),\n+    ExprAssign(lhs, rhs),\n+    ExprAssignOp(op, lhs, rhs),\n+    ExprField(owner, field_name),\n+    ExprTupField(owner, idx),\n+    ExprIndex(lhs, rhs),\n+    ExprPath(path),\n+    ExprAddrOf(mutability, sub),\n+    ExprBreak(destination, sub),\n+    ExprAgain(destination),\n+    ExprRet(val),\n+    ExprInlineAsm(asm, inputs, outputs),\n+    ExprStruct(path, fields, base),\n+    ExprRepeat(val, times)\n+});\n+\n+impl_stable_hash_for!(enum hir::LoopSource {\n+    Loop,\n+    WhileLet,\n+    ForLoop\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::MatchSource {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use hir::MatchSource;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            MatchSource::Normal |\n+            MatchSource::WhileLetDesugar |\n+            MatchSource::ForLoopDesugar |\n+            MatchSource::TryDesugar => {\n+                // No fields to hash.\n+            }\n+            MatchSource::IfLetDesugar { contains_else_clause } => {\n+                contains_else_clause.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum hir::CaptureClause {\n+    CaptureByValue,\n+    CaptureByRef\n+});\n+\n+impl_stable_hash_for_spanned!(usize);\n+\n+impl_stable_hash_for!(struct hir::Destination {\n+    ident,\n+    target_id\n+});\n+\n+impl_stable_hash_for_spanned!(ast::Ident);\n+\n+impl_stable_hash_for!(enum hir::LoopIdResult {\n+    Ok(node_id),\n+    Err(loop_id_error)\n+});\n+\n+impl_stable_hash_for!(enum hir::LoopIdError {\n+    OutsideLoopScope,\n+    UnlabeledCfInWhileCondition,\n+    UnresolvedLabel\n+});\n+\n+impl_stable_hash_for!(enum hir::ScopeTarget {\n+    Block(node_id),\n+    Loop(loop_id_result)\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::Ident {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ast::Ident {\n+            ref name,\n+            ctxt: _ // Ignore this\n+        } = *self;\n+\n+        name.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::TraitItem {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::TraitItem {\n+            id,\n+            name,\n+            ref attrs,\n+            ref node,\n+            span\n+        } = *self;\n+\n+        hcx.hash_hir_item_like(attrs, |hcx| {\n+            id.hash_stable(hcx, hasher);\n+            name.hash_stable(hcx, hasher);\n+            attrs.hash_stable(hcx, hasher);\n+            node.hash_stable(hcx, hasher);\n+            span.hash_stable(hcx, hasher);\n+        });\n+    }\n+}\n+\n+impl_stable_hash_for!(enum hir::TraitMethod {\n+    Required(name),\n+    Provided(body)\n+});\n+\n+impl_stable_hash_for!(enum hir::TraitItemKind {\n+    Const(t, body),\n+    Method(sig, method),\n+    Type(bounds, rhs)\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::ImplItem {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::ImplItem {\n+            id,\n+            name,\n+            ref vis,\n+            defaultness,\n+            ref attrs,\n+            ref node,\n+            span\n+        } = *self;\n+\n+        hcx.hash_hir_item_like(attrs, |hcx| {\n+            id.hash_stable(hcx, hasher);\n+            name.hash_stable(hcx, hasher);\n+            vis.hash_stable(hcx, hasher);\n+            defaultness.hash_stable(hcx, hasher);\n+            attrs.hash_stable(hcx, hasher);\n+            node.hash_stable(hcx, hasher);\n+            span.hash_stable(hcx, hasher);\n+        });\n+    }\n+}\n+\n+impl_stable_hash_for!(enum hir::ImplItemKind {\n+    Const(t, body),\n+    Method(sig, body),\n+    Type(t)\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Visibility {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            hir::Visibility::Public |\n+            hir::Visibility::Crate |\n+            hir::Visibility::Inherited => {\n+                // No fields to hash.\n+            }\n+            hir::Visibility::Restricted { ref path, id } => {\n+                hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashTraitsInScope, |hcx| {\n+                    id.hash_stable(hcx, hasher);\n+                });\n+                path.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Defaultness {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            hir::Defaultness::Final => {\n+                // No fields to hash.\n+            }\n+            hir::Defaultness::Default { has_value } => {\n+                has_value.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum hir::ImplPolarity {\n+    Positive,\n+    Negative\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Mod {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::Mod {\n+            inner,\n+            // We are not hashing the IDs of the items contained in the module.\n+            // This is harmless and matches the current behavior but it's not\n+            // actually correct. See issue #40876.\n+            item_ids: _,\n+        } = *self;\n+\n+        inner.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(struct hir::ForeignMod {\n+    abi,\n+    items\n+});\n+\n+impl_stable_hash_for!(struct hir::EnumDef {\n+    variants\n+});\n+\n+impl_stable_hash_for!(struct hir::Variant_ {\n+    name,\n+    attrs,\n+    data,\n+    disr_expr\n+});\n+\n+impl_stable_hash_for_spanned!(hir::Variant_);\n+\n+impl_stable_hash_for!(enum hir::UseKind {\n+    Single,\n+    Glob,\n+    ListStem\n+});\n+\n+impl_stable_hash_for!(struct hir::StructField {\n+    span,\n+    name,\n+    vis,\n+    id,\n+    ty,\n+    attrs\n+});\n+\n+impl_stable_hash_for!(enum hir::VariantData {\n+    Struct(fields, id),\n+    Tuple(fields, id),\n+    Unit(id)\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Item {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let node_id_hashing_mode = match self.node {\n+            hir::ItemExternCrate(..) |\n+            hir::ItemStatic(..)      |\n+            hir::ItemConst(..)       |\n+            hir::ItemFn(..)          |\n+            hir::ItemMod(..)         |\n+            hir::ItemForeignMod(..)  |\n+            hir::ItemTy(..)          |\n+            hir::ItemEnum(..)        |\n+            hir::ItemStruct(..)      |\n+            hir::ItemUnion(..)       |\n+            hir::ItemTrait(..)       |\n+            hir::ItemDefaultImpl(..) |\n+            hir::ItemImpl(..)        => {\n+                NodeIdHashingMode::Ignore\n+            }\n+            hir::ItemUse(..) => {\n+                NodeIdHashingMode::HashTraitsInScope\n+            }\n+        };\n+\n+        let hir::Item {\n+            name,\n+            ref attrs,\n+            id,\n+            ref node,\n+            ref vis,\n+            span\n+        } = *self;\n+\n+        hcx.hash_hir_item_like(attrs, |hcx| {\n+            hcx.with_node_id_hashing_mode(node_id_hashing_mode, |hcx| {\n+                id.hash_stable(hcx, hasher);\n+            });\n+            name.hash_stable(hcx, hasher);\n+            attrs.hash_stable(hcx, hasher);\n+            node.hash_stable(hcx, hasher);\n+            vis.hash_stable(hcx, hasher);\n+            span.hash_stable(hcx, hasher);\n+        });\n+    }\n+}\n+\n+impl_stable_hash_for!(enum hir::Item_ {\n+    ItemExternCrate(name),\n+    ItemUse(path, use_kind),\n+    ItemStatic(ty, mutability, body_id),\n+    ItemConst(ty, body_id),\n+    ItemFn(fn_decl, unsafety, constness, abi, generics, body_id),\n+    ItemMod(module),\n+    ItemForeignMod(foreign_mod),\n+    ItemTy(ty, generics),\n+    ItemEnum(enum_def, generics),\n+    ItemStruct(variant_data, generics),\n+    ItemUnion(variant_data, generics),\n+    ItemTrait(unsafety, generics, bounds, item_refs),\n+    ItemDefaultImpl(unsafety, trait_ref),\n+    ItemImpl(unsafety, impl_polarity, generics, trait_ref, ty, impl_item_refs)\n+});\n+\n+impl_stable_hash_for!(struct hir::TraitItemRef {\n+    id,\n+    name,\n+    kind,\n+    span,\n+    defaultness\n+});\n+\n+impl_stable_hash_for!(struct hir::ImplItemRef {\n+    id,\n+    name,\n+    kind,\n+    span,\n+    vis,\n+    defaultness\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::AssociatedItemKind {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            hir::AssociatedItemKind::Const |\n+            hir::AssociatedItemKind::Type => {\n+                // No fields to hash.\n+            }\n+            hir::AssociatedItemKind::Method { has_self } => {\n+                has_self.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct hir::ForeignItem {\n+    name,\n+    attrs,\n+    node,\n+    id,\n+    span,\n+    vis\n+});\n+\n+impl_stable_hash_for!(enum hir::ForeignItem_ {\n+    ForeignItemFn(fn_decl, arg_names, generics),\n+    ForeignItemStatic(ty, is_mutbl)\n+});\n+\n+impl_stable_hash_for!(enum hir::Stmt_ {\n+    StmtDecl(decl, id),\n+    StmtExpr(expr, id),\n+    StmtSemi(expr, id)\n+});\n+\n+impl_stable_hash_for!(struct hir::Arg {\n+    pat,\n+    id\n+});\n+\n+impl_stable_hash_for!(struct hir::Body {\n+    arguments,\n+    value\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::BodyId {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        if hcx.hash_bodies() {\n+            hcx.tcx().hir.body(*self).hash_stable(hcx, hasher);\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct hir::InlineAsmOutput {\n+    constraint,\n+    is_rw,\n+    is_indirect\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::InlineAsm {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::InlineAsm {\n+            asm,\n+            asm_str_style,\n+            ref outputs,\n+            ref inputs,\n+            ref clobbers,\n+            volatile,\n+            alignstack,\n+            dialect,\n+            ctxt: _, // This is used for error reporting\n+        } = *self;\n+\n+        asm.hash_stable(hcx, hasher);\n+        asm_str_style.hash_stable(hcx, hasher);\n+        outputs.hash_stable(hcx, hasher);\n+        inputs.hash_stable(hcx, hasher);\n+        clobbers.hash_stable(hcx, hasher);\n+        volatile.hash_stable(hcx, hasher);\n+        alignstack.hash_stable(hcx, hasher);\n+        dialect.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(enum hir::def::CtorKind {\n+    Fn,\n+    Const,\n+    Fictive\n+});\n+\n+impl_stable_hash_for!(enum hir::def::Def {\n+    Mod(def_id),\n+    Struct(def_id),\n+    Union(def_id),\n+    Enum(def_id),\n+    Variant(def_id),\n+    Trait(def_id),\n+    TyAlias(def_id),\n+    AssociatedTy(def_id),\n+    PrimTy(prim_ty),\n+    TyParam(def_id),\n+    SelfTy(trait_def_id, impl_def_id),\n+    Fn(def_id),\n+    Const(def_id),\n+    Static(def_id, is_mutbl),\n+    StructCtor(def_id, ctor_kind),\n+    VariantCtor(def_id, ctor_kind),\n+    Method(def_id),\n+    AssociatedConst(def_id),\n+    Local(def_id),\n+    Upvar(def_id, index, expr_id),\n+    Label(node_id),\n+    Macro(def_id, macro_kind),\n+    Err\n+});\n+\n+impl_stable_hash_for!(enum hir::Mutability {\n+    MutMutable,\n+    MutImmutable\n+});\n+\n+\n+impl_stable_hash_for!(enum hir::Unsafety {\n+    Unsafe,\n+    Normal\n+});\n+\n+\n+impl_stable_hash_for!(enum hir::Constness {\n+    Const,\n+    NotConst\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::def_id::DefIndex {\n+\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        DefId::local(*self).hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(struct hir::def::Export {\n+    name,\n+    def,\n+    span\n+});"}, {"sha": "401f7e1921ab49a3561cedb8ac808a87ef53395a", "filename": "src/librustc/ich/impls_mir.rs", "status": "added", "additions": 407, "deletions": 0, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=cce5c2d93ad4b33967c8f06f26c67e204c46c87b", "patch": "@@ -0,0 +1,407 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains `HashStable` implementations for various MIR data\n+//! types in no particular order.\n+\n+use ich::StableHashingContext;\n+use mir;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n+use std::mem;\n+\n+\n+impl_stable_hash_for!(struct mir::SourceInfo { span, scope });\n+impl_stable_hash_for!(enum mir::Mutability { Mut, Not });\n+impl_stable_hash_for!(enum mir::BorrowKind { Shared, Unique, Mut });\n+impl_stable_hash_for!(enum mir::LocalKind { Var, Temp, Arg, ReturnPointer });\n+impl_stable_hash_for!(struct mir::LocalDecl<'tcx> { mutability, ty, name, source_info });\n+impl_stable_hash_for!(struct mir::UpvarDecl { debug_name, by_ref });\n+impl_stable_hash_for!(struct mir::BasicBlockData<'tcx> { statements, terminator, is_cleanup });\n+impl_stable_hash_for!(struct mir::Terminator<'tcx> { source_info, kind });\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Local {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use rustc_data_structures::indexed_vec::Idx;\n+        self.index().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::BasicBlock {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use rustc_data_structures::indexed_vec::Idx;\n+        self.index().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Field {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use rustc_data_structures::indexed_vec::Idx;\n+        self.index().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::VisibilityScope {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use rustc_data_structures::indexed_vec::Idx;\n+        self.index().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Promoted {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use rustc_data_structures::indexed_vec::Idx;\n+        self.index().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::TerminatorKind<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            mir::TerminatorKind::Goto { ref target } => {\n+                target.hash_stable(hcx, hasher);\n+            }\n+            mir::TerminatorKind::SwitchInt { ref discr,\n+                                             switch_ty,\n+                                             ref values,\n+                                             ref targets } => {\n+                discr.hash_stable(hcx, hasher);\n+                switch_ty.hash_stable(hcx, hasher);\n+                values.hash_stable(hcx, hasher);\n+                targets.hash_stable(hcx, hasher);\n+            }\n+            mir::TerminatorKind::Resume |\n+            mir::TerminatorKind::Return |\n+            mir::TerminatorKind::Unreachable => {}\n+            mir::TerminatorKind::Drop { ref location, target, unwind } => {\n+                location.hash_stable(hcx, hasher);\n+                target.hash_stable(hcx, hasher);\n+                unwind.hash_stable(hcx, hasher);\n+            }\n+            mir::TerminatorKind::DropAndReplace { ref location,\n+                                                  ref value,\n+                                                  target,\n+                                                  unwind, } => {\n+                location.hash_stable(hcx, hasher);\n+                value.hash_stable(hcx, hasher);\n+                target.hash_stable(hcx, hasher);\n+                unwind.hash_stable(hcx, hasher);\n+            }\n+            mir::TerminatorKind::Call { ref func,\n+                                        ref args,\n+                                        ref destination,\n+                                        cleanup } => {\n+                func.hash_stable(hcx, hasher);\n+                args.hash_stable(hcx, hasher);\n+                destination.hash_stable(hcx, hasher);\n+                cleanup.hash_stable(hcx, hasher);\n+            }\n+            mir::TerminatorKind::Assert { ref cond,\n+                                          expected,\n+                                          ref msg,\n+                                          target,\n+                                          cleanup } => {\n+                cond.hash_stable(hcx, hasher);\n+                expected.hash_stable(hcx, hasher);\n+                msg.hash_stable(hcx, hasher);\n+                target.hash_stable(hcx, hasher);\n+                cleanup.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::AssertMessage<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            mir::AssertMessage::BoundsCheck { ref len, ref index } => {\n+                len.hash_stable(hcx, hasher);\n+                index.hash_stable(hcx, hasher);\n+            }\n+            mir::AssertMessage::Math(ref const_math_err) => {\n+                const_math_err.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct mir::Statement<'tcx> { source_info, kind });\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::StatementKind<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n+                lvalue.hash_stable(hcx, hasher);\n+                rvalue.hash_stable(hcx, hasher);\n+            }\n+            mir::StatementKind::SetDiscriminant { ref lvalue, variant_index } => {\n+                lvalue.hash_stable(hcx, hasher);\n+                variant_index.hash_stable(hcx, hasher);\n+            }\n+            mir::StatementKind::StorageLive(ref lvalue) |\n+            mir::StatementKind::StorageDead(ref lvalue) => {\n+                lvalue.hash_stable(hcx, hasher);\n+            }\n+            mir::StatementKind::Nop => {}\n+            mir::StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {\n+                asm.hash_stable(hcx, hasher);\n+                outputs.hash_stable(hcx, hasher);\n+                inputs.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Lvalue<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            mir::Lvalue::Local(ref local) => {\n+                local.hash_stable(hcx, hasher);\n+            }\n+            mir::Lvalue::Static(ref statik) => {\n+                statik.hash_stable(hcx, hasher);\n+            }\n+            mir::Lvalue::Projection(ref lvalue_projection) => {\n+                lvalue_projection.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx, B, V> HashStable<StableHashingContext<'a, 'tcx>> for mir::Projection<'tcx, B, V>\n+    where B: HashStable<StableHashingContext<'a, 'tcx>>,\n+          V: HashStable<StableHashingContext<'a, 'tcx>>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let mir::Projection {\n+            ref base,\n+            ref elem,\n+        } = *self;\n+\n+        base.hash_stable(hcx, hasher);\n+        elem.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx, V> HashStable<StableHashingContext<'a, 'tcx>> for mir::ProjectionElem<'tcx, V>\n+    where V: HashStable<StableHashingContext<'a, 'tcx>>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            mir::ProjectionElem::Deref => {}\n+            mir::ProjectionElem::Field(field, ty) => {\n+                field.hash_stable(hcx, hasher);\n+                ty.hash_stable(hcx, hasher);\n+            }\n+            mir::ProjectionElem::Index(ref value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            mir::ProjectionElem::ConstantIndex { offset, min_length, from_end } => {\n+                offset.hash_stable(hcx, hasher);\n+                min_length.hash_stable(hcx, hasher);\n+                from_end.hash_stable(hcx, hasher);\n+            }\n+            mir::ProjectionElem::Subslice { from, to } => {\n+                from.hash_stable(hcx, hasher);\n+                to.hash_stable(hcx, hasher);\n+            }\n+            mir::ProjectionElem::Downcast(adt_def, variant) => {\n+                adt_def.hash_stable(hcx, hasher);\n+                variant.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct mir::VisibilityScopeData { span, parent_scope });\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Operand<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            mir::Operand::Consume(ref lvalue) => {\n+                lvalue.hash_stable(hcx, hasher);\n+            }\n+            mir::Operand::Constant(ref constant) => {\n+                constant.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Rvalue<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            mir::Rvalue::Use(ref operand) => {\n+                operand.hash_stable(hcx, hasher);\n+            }\n+            mir::Rvalue::Repeat(ref operand, ref val) => {\n+                operand.hash_stable(hcx, hasher);\n+                val.hash_stable(hcx, hasher);\n+            }\n+            mir::Rvalue::Ref(region, borrow_kind, ref lvalue) => {\n+                region.hash_stable(hcx, hasher);\n+                borrow_kind.hash_stable(hcx, hasher);\n+                lvalue.hash_stable(hcx, hasher);\n+            }\n+            mir::Rvalue::Len(ref lvalue) => {\n+                lvalue.hash_stable(hcx, hasher);\n+            }\n+            mir::Rvalue::Cast(cast_kind, ref operand, ty) => {\n+                cast_kind.hash_stable(hcx, hasher);\n+                operand.hash_stable(hcx, hasher);\n+                ty.hash_stable(hcx, hasher);\n+            }\n+            mir::Rvalue::BinaryOp(op, ref operand1, ref operand2) |\n+            mir::Rvalue::CheckedBinaryOp(op, ref operand1, ref operand2) => {\n+                op.hash_stable(hcx, hasher);\n+                operand1.hash_stable(hcx, hasher);\n+                operand2.hash_stable(hcx, hasher);\n+            }\n+            mir::Rvalue::UnaryOp(op, ref operand) => {\n+                op.hash_stable(hcx, hasher);\n+                operand.hash_stable(hcx, hasher);\n+            }\n+            mir::Rvalue::Discriminant(ref lvalue) => {\n+                lvalue.hash_stable(hcx, hasher);\n+            }\n+            mir::Rvalue::Box(ty) => {\n+                ty.hash_stable(hcx, hasher);\n+            }\n+            mir::Rvalue::Aggregate(ref kind, ref operands) => {\n+                kind.hash_stable(hcx, hasher);\n+                operands.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum mir::CastKind {\n+    Misc,\n+    ReifyFnPointer,\n+    ClosureFnPointer,\n+    UnsafeFnPointer,\n+    Unsize\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::AggregateKind<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            mir::AggregateKind::Tuple => {}\n+            mir::AggregateKind::Array(t) => {\n+                t.hash_stable(hcx, hasher);\n+            }\n+            mir::AggregateKind::Adt(adt_def, idx, substs, active_field) => {\n+                adt_def.hash_stable(hcx, hasher);\n+                idx.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+                active_field.hash_stable(hcx, hasher);\n+            }\n+            mir::AggregateKind::Closure(def_id, ref substs) => {\n+                def_id.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum mir::BinOp {\n+    Add,\n+    Sub,\n+    Mul,\n+    Div,\n+    Rem,\n+    BitXor,\n+    BitAnd,\n+    BitOr,\n+    Shl,\n+    Shr,\n+    Eq,\n+    Lt,\n+    Le,\n+    Ne,\n+    Ge,\n+    Gt\n+});\n+\n+impl_stable_hash_for!(enum mir::UnOp {\n+    Not,\n+    Neg\n+});\n+\n+\n+impl_stable_hash_for!(struct mir::Constant<'tcx> { span, ty, literal });\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Literal<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            mir::Literal::Item { def_id, substs } => {\n+                def_id.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+            }\n+            mir::Literal::Value { ref value } => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            mir::Literal::Promoted { index } => {\n+                index.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct mir::Location { block, statement_index });"}, {"sha": "26734500001f6d772327d64f712d074ab21d7c02", "filename": "src/librustc/ich/impls_syntax.rs", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=cce5c2d93ad4b33967c8f06f26c67e204c46c87b", "patch": "@@ -0,0 +1,301 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains `HashStable` implementations for various data types\n+//! from libsyntax in no particular order.\n+\n+use ich::StableHashingContext;\n+\n+use std::hash as std_hash;\n+use std::mem;\n+\n+use syntax::ast;\n+use syntax::parse::token;\n+use syntax::tokenstream;\n+use syntax_pos::Span;\n+\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n+use rustc_data_structures::accumulate_vec::AccumulateVec;\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::syntax::symbol::InternedString {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let s: &str = &**self;\n+        s.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::Name {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.as_str().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(enum ::syntax::ast::AsmDialect {\n+    Att,\n+    Intel\n+});\n+\n+impl_stable_hash_for!(enum ::syntax::ext::base::MacroKind {\n+    Bang,\n+    Attr,\n+    Derive\n+});\n+\n+\n+impl_stable_hash_for!(enum ::syntax::abi::Abi {\n+    Cdecl,\n+    Stdcall,\n+    Fastcall,\n+    Vectorcall,\n+    Aapcs,\n+    Win64,\n+    SysV64,\n+    PtxKernel,\n+    Msp430Interrupt,\n+    X86Interrupt,\n+    Rust,\n+    C,\n+    System,\n+    RustIntrinsic,\n+    RustCall,\n+    PlatformIntrinsic,\n+    Unadjusted\n+});\n+\n+impl_stable_hash_for!(struct ::syntax::attr::Deprecation { since, note });\n+impl_stable_hash_for!(struct ::syntax::attr::Stability { level, feature, rustc_depr });\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::syntax::attr::StabilityLevel {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            ::syntax::attr::StabilityLevel::Unstable { ref reason, ref issue } => {\n+                reason.hash_stable(hcx, hasher);\n+                issue.hash_stable(hcx, hasher);\n+            }\n+            ::syntax::attr::StabilityLevel::Stable { ref since } => {\n+                since.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ::syntax::attr::RustcDeprecation { since, reason });\n+\n+\n+impl_stable_hash_for!(enum ::syntax::attr::IntType {\n+    SignedInt(int_ty),\n+    UnsignedInt(uint_ty)\n+});\n+\n+impl_stable_hash_for!(enum ::syntax::ast::LitIntType {\n+    Signed(int_ty),\n+    Unsigned(int_ty),\n+    Unsuffixed\n+});\n+\n+impl_stable_hash_for_spanned!(::syntax::ast::LitKind);\n+impl_stable_hash_for!(enum ::syntax::ast::LitKind {\n+    Str(value, style),\n+    ByteStr(value),\n+    Byte(value),\n+    Char(value),\n+    Int(value, lit_int_type),\n+    Float(value, float_ty),\n+    FloatUnsuffixed(value),\n+    Bool(value)\n+});\n+\n+impl_stable_hash_for!(enum ::syntax::ast::IntTy { Is, I8, I16, I32, I64, I128 });\n+impl_stable_hash_for!(enum ::syntax::ast::UintTy { Us, U8, U16, U32, U64, U128 });\n+impl_stable_hash_for!(enum ::syntax::ast::FloatTy { F32, F64 });\n+impl_stable_hash_for!(enum ::syntax::ast::Unsafety { Unsafe, Normal });\n+impl_stable_hash_for!(enum ::syntax::ast::Constness { Const, NotConst });\n+impl_stable_hash_for!(enum ::syntax::ast::Defaultness { Default, Final });\n+impl_stable_hash_for!(struct ::syntax::ast::Lifetime { id, span, name });\n+impl_stable_hash_for!(enum ::syntax::ast::StrStyle { Cooked, Raw(pounds) });\n+impl_stable_hash_for!(enum ::syntax::ast::AttrStyle { Outer, Inner });\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for [ast::Attribute] {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        // Some attributes are always ignored during hashing.\n+        let filtered: AccumulateVec<[&ast::Attribute; 8]> = self\n+            .iter()\n+            .filter(|attr| {\n+                !attr.is_sugared_doc &&\n+                attr.name().map(|name| !hcx.is_ignored_attr(name)).unwrap_or(true)\n+            })\n+            .collect();\n+\n+        filtered.len().hash_stable(hcx, hasher);\n+        for attr in filtered {\n+            attr.hash_stable(hcx, hasher);\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::Attribute {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        // Make sure that these have been filtered out.\n+        debug_assert!(self.name().map(|name| !hcx.is_ignored_attr(name)).unwrap_or(true));\n+        debug_assert!(!self.is_sugared_doc);\n+\n+        let ast::Attribute {\n+            id: _,\n+            style,\n+            ref path,\n+            ref tokens,\n+            is_sugared_doc: _,\n+            span,\n+        } = *self;\n+\n+        style.hash_stable(hcx, hasher);\n+        path.segments.len().hash_stable(hcx, hasher);\n+        for segment in &path.segments {\n+            segment.identifier.name.hash_stable(hcx, hasher);\n+        }\n+        for tt in tokens.trees() {\n+            tt.hash_stable(hcx, hasher);\n+        }\n+        span.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for tokenstream::TokenTree {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            tokenstream::TokenTree::Token(span, ref token) => {\n+                span.hash_stable(hcx, hasher);\n+                hash_token(token, hcx, hasher, span);\n+            }\n+            tokenstream::TokenTree::Delimited(span, ref delimited) => {\n+                span.hash_stable(hcx, hasher);\n+                std_hash::Hash::hash(&delimited.delim, hasher);\n+                for sub_tt in delimited.stream().trees() {\n+                    sub_tt.hash_stable(hcx, hasher);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for tokenstream::TokenStream {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        for sub_tt in self.trees() {\n+            sub_tt.hash_stable(hcx, hasher);\n+        }\n+    }\n+}\n+\n+fn hash_token<'a, 'tcx, W: StableHasherResult>(token: &token::Token,\n+                                               hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                               hasher: &mut StableHasher<W>,\n+                                               error_reporting_span: Span) {\n+    mem::discriminant(token).hash_stable(hcx, hasher);\n+    match *token {\n+        token::Token::Eq |\n+        token::Token::Lt |\n+        token::Token::Le |\n+        token::Token::EqEq |\n+        token::Token::Ne |\n+        token::Token::Ge |\n+        token::Token::Gt |\n+        token::Token::AndAnd |\n+        token::Token::OrOr |\n+        token::Token::Not |\n+        token::Token::Tilde |\n+        token::Token::At |\n+        token::Token::Dot |\n+        token::Token::DotDot |\n+        token::Token::DotDotDot |\n+        token::Token::Comma |\n+        token::Token::Semi |\n+        token::Token::Colon |\n+        token::Token::ModSep |\n+        token::Token::RArrow |\n+        token::Token::LArrow |\n+        token::Token::FatArrow |\n+        token::Token::Pound |\n+        token::Token::Dollar |\n+        token::Token::Question |\n+        token::Token::Underscore |\n+        token::Token::Whitespace |\n+        token::Token::Comment |\n+        token::Token::Eof => {}\n+\n+        token::Token::BinOp(bin_op_token) |\n+        token::Token::BinOpEq(bin_op_token) => {\n+            std_hash::Hash::hash(&bin_op_token, hasher);\n+        }\n+\n+        token::Token::OpenDelim(delim_token) |\n+        token::Token::CloseDelim(delim_token) => {\n+            std_hash::Hash::hash(&delim_token, hasher);\n+        }\n+        token::Token::Literal(ref lit, ref opt_name) => {\n+            mem::discriminant(lit).hash_stable(hcx, hasher);\n+            match *lit {\n+                token::Lit::Byte(val) |\n+                token::Lit::Char(val) |\n+                token::Lit::Integer(val) |\n+                token::Lit::Float(val) |\n+                token::Lit::Str_(val) |\n+                token::Lit::ByteStr(val) => val.hash_stable(hcx, hasher),\n+                token::Lit::StrRaw(val, n) |\n+                token::Lit::ByteStrRaw(val, n) => {\n+                    val.hash_stable(hcx, hasher);\n+                    n.hash_stable(hcx, hasher);\n+                }\n+            };\n+            opt_name.hash_stable(hcx, hasher);\n+        }\n+\n+        token::Token::Ident(ident) |\n+        token::Token::Lifetime(ident) |\n+        token::Token::SubstNt(ident) => ident.name.hash_stable(hcx, hasher),\n+\n+        token::Token::Interpolated(ref non_terminal) => {\n+            // FIXME(mw): This could be implemented properly. It's just a\n+            //            lot of work, since we would need to hash the AST\n+            //            in a stable way, in addition to the HIR.\n+            //            Since this is hardly used anywhere, just emit a\n+            //            warning for now.\n+            if hcx.tcx().sess.opts.debugging_opts.incremental.is_some() {\n+                let msg = format!(\"Quasi-quoting might make incremental \\\n+                                   compilation very inefficient: {:?}\",\n+                                  non_terminal);\n+                hcx.tcx().sess.span_warn(error_reporting_span, &msg[..]);\n+            }\n+\n+            std_hash::Hash::hash(non_terminal, hasher);\n+        }\n+\n+        token::Token::DocComment(val) |\n+        token::Token::Shebang(val) => val.hash_stable(hcx, hasher),\n+    }\n+}"}, {"sha": "7b6f3af2a11ec88582d572128185e17c029b4a43", "filename": "src/librustc/ich/impls_ty.rs", "status": "added", "additions": 415, "deletions": 0, "changes": 415, "blob_url": "https://github.com/rust-lang/rust/blob/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=cce5c2d93ad4b33967c8f06f26c67e204c46c87b", "patch": "@@ -0,0 +1,415 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains `HashStable` implementations for various data types\n+//! from rustc::ty in no particular order.\n+\n+use ich::StableHashingContext;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n+use std::hash as std_hash;\n+use std::mem;\n+use ty;\n+\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Ty<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let type_hash = hcx.tcx().type_id_hash(*self);\n+        type_hash.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::ItemSubsts<'tcx> { substs });\n+\n+impl<'a, 'tcx, T> HashStable<StableHashingContext<'a, 'tcx>> for ty::Slice<T>\n+    where T: HashStable<StableHashingContext<'a, 'tcx>> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        (&**self).hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::subst::Kind<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.as_type().hash_stable(hcx, hasher);\n+        self.as_region().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Region {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            ty::ReErased |\n+            ty::ReStatic |\n+            ty::ReEmpty => {\n+                // No variant fields to hash for these ...\n+            }\n+            ty::ReLateBound(db, ty::BrAnon(i)) => {\n+                db.depth.hash_stable(hcx, hasher);\n+                i.hash_stable(hcx, hasher);\n+            }\n+            ty::ReEarlyBound(ty::EarlyBoundRegion { index, name }) => {\n+                index.hash_stable(hcx, hasher);\n+                name.hash_stable(hcx, hasher);\n+            }\n+            ty::ReLateBound(..) |\n+            ty::ReFree(..) |\n+            ty::ReScope(..) |\n+            ty::ReVar(..) |\n+            ty::ReSkolemized(..) => {\n+                bug!(\"TypeIdHasher: unexpected region {:?}\", *self)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::adjustment::AutoBorrow<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            ty::adjustment::AutoBorrow::Ref(ref region, mutability) => {\n+                region.hash_stable(hcx, hasher);\n+                mutability.hash_stable(hcx, hasher);\n+            }\n+            ty::adjustment::AutoBorrow::RawPtr(mutability) => {\n+                mutability.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::adjustment::Adjust<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            ty::adjustment::Adjust::NeverToAny |\n+            ty::adjustment::Adjust::ReifyFnPointer |\n+            ty::adjustment::Adjust::UnsafeFnPointer |\n+            ty::adjustment::Adjust::ClosureFnPointer |\n+            ty::adjustment::Adjust::MutToConstPointer => {}\n+            ty::adjustment::Adjust::DerefRef { autoderefs, ref autoref, unsize } => {\n+                autoderefs.hash_stable(hcx, hasher);\n+                autoref.hash_stable(hcx, hasher);\n+                unsize.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::adjustment::Adjustment<'tcx> { kind, target });\n+impl_stable_hash_for!(struct ty::MethodCall { expr_id, autoderef });\n+impl_stable_hash_for!(struct ty::MethodCallee<'tcx> { def_id, ty, substs });\n+impl_stable_hash_for!(struct ty::UpvarId { var_id, closure_expr_id });\n+impl_stable_hash_for!(struct ty::UpvarBorrow<'tcx> { kind, region });\n+\n+impl_stable_hash_for!(enum ty::BorrowKind {\n+    ImmBorrow,\n+    UniqueImmBorrow,\n+    MutBorrow\n+});\n+\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::UpvarCapture<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            ty::UpvarCapture::ByValue => {}\n+            ty::UpvarCapture::ByRef(ref up_var_borrow) => {\n+                up_var_borrow.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::FnSig<'tcx> {\n+    inputs_and_output,\n+    variadic,\n+    unsafety,\n+    abi\n+});\n+\n+impl<'a, 'tcx, T> HashStable<StableHashingContext<'a, 'tcx>> for ty::Binder<T>\n+    where T: HashStable<StableHashingContext<'a, 'tcx>> + ty::fold::TypeFoldable<'tcx>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        hcx.tcx().anonymize_late_bound_regions(self).0.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(enum ty::ClosureKind { Fn, FnMut, FnOnce });\n+\n+impl_stable_hash_for!(enum ty::Visibility {\n+    Public,\n+    Restricted(def_id),\n+    Invisible\n+});\n+\n+impl_stable_hash_for!(struct ty::TraitRef<'tcx> { def_id, substs });\n+impl_stable_hash_for!(struct ty::TraitPredicate<'tcx> { trait_ref });\n+impl_stable_hash_for!(tuple_struct ty::EquatePredicate<'tcx> { t1, t2 });\n+\n+impl<'a, 'tcx, A, B> HashStable<StableHashingContext<'a, 'tcx>> for ty::OutlivesPredicate<A, B>\n+    where A: HashStable<StableHashingContext<'a, 'tcx>>,\n+          B: HashStable<StableHashingContext<'a, 'tcx>>,\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ty::OutlivesPredicate(ref a, ref b) = *self;\n+        a.hash_stable(hcx, hasher);\n+        b.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::ProjectionPredicate<'tcx> { projection_ty, ty });\n+impl_stable_hash_for!(struct ty::ProjectionTy<'tcx> { trait_ref, item_name });\n+\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Predicate<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            ty::Predicate::Trait(ref pred) => {\n+                pred.hash_stable(hcx, hasher);\n+            }\n+            ty::Predicate::Equate(ref pred) => {\n+                pred.hash_stable(hcx, hasher);\n+            }\n+            ty::Predicate::RegionOutlives(ref pred) => {\n+                pred.hash_stable(hcx, hasher);\n+            }\n+            ty::Predicate::TypeOutlives(ref pred) => {\n+                pred.hash_stable(hcx, hasher);\n+            }\n+            ty::Predicate::Projection(ref pred) => {\n+                pred.hash_stable(hcx, hasher);\n+            }\n+            ty::Predicate::WellFormed(ty) => {\n+                ty.hash_stable(hcx, hasher);\n+            }\n+            ty::Predicate::ObjectSafe(def_id) => {\n+                def_id.hash_stable(hcx, hasher);\n+            }\n+            ty::Predicate::ClosureKind(def_id, closure_kind) => {\n+                def_id.hash_stable(hcx, hasher);\n+                closure_kind.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::AdtFlags {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          _: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        std_hash::Hash::hash(self, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::VariantDef {\n+    did,\n+    name,\n+    discr,\n+    fields,\n+    ctor_kind\n+});\n+\n+impl_stable_hash_for!(enum ty::VariantDiscr {\n+    Explicit(def_id),\n+    Relative(distance)\n+});\n+\n+impl_stable_hash_for!(struct ty::FieldDef {\n+    did,\n+    name,\n+    vis\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>>\n+for ::middle::const_val::ConstVal<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use middle::const_val::ConstVal;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            ConstVal::Float(ref value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::Integral(ref value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::Str(ref value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::ByteStr(ref value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::Bool(value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::Function(def_id, substs) => {\n+                def_id.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::Struct(ref _name_value_map) => {\n+                // BTreeMap<ast::Name, ConstVal<'tcx>>),\n+                panic!(\"Ordering still unstable\")\n+            }\n+            ConstVal::Tuple(ref value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::Array(ref value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::Repeat(ref value, times) => {\n+                value.hash_stable(hcx, hasher);\n+                times.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::Char(value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::ClosureSubsts<'tcx> { substs });\n+\n+\n+impl_stable_hash_for!(struct ty::GenericPredicates<'tcx> {\n+    parent,\n+    predicates\n+});\n+\n+impl_stable_hash_for!(enum ty::Variance {\n+    Covariant,\n+    Invariant,\n+    Contravariant,\n+    Bivariant\n+});\n+\n+impl_stable_hash_for!(enum ty::adjustment::CustomCoerceUnsized {\n+    Struct(index)\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Generics {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ty::Generics {\n+            parent,\n+            parent_regions,\n+            parent_types,\n+            ref regions,\n+            ref types,\n+\n+            // Reverse map to each `TypeParameterDef`'s `index` field, from\n+            // `def_id.index` (`def_id.krate` is the same as the item's).\n+            type_param_to_index: _, // Don't hash this\n+            has_self,\n+        } = *self;\n+\n+        parent.hash_stable(hcx, hasher);\n+        parent_regions.hash_stable(hcx, hasher);\n+        parent_types.hash_stable(hcx, hasher);\n+        regions.hash_stable(hcx, hasher);\n+        types.hash_stable(hcx, hasher);\n+        has_self.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::RegionParameterDef {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ty::RegionParameterDef {\n+            name,\n+            def_id,\n+            index,\n+            issue_32330: _,\n+            pure_wrt_drop\n+        } = *self;\n+\n+        name.hash_stable(hcx, hasher);\n+        def_id.hash_stable(hcx, hasher);\n+        index.hash_stable(hcx, hasher);\n+        pure_wrt_drop.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::TypeParameterDef {\n+    name,\n+    def_id,\n+    index,\n+    has_default,\n+    object_lifetime_default,\n+    pure_wrt_drop\n+});\n+\n+\n+impl<'a, 'tcx, T> HashStable<StableHashingContext<'a, 'tcx>>\n+for ::middle::resolve_lifetime::Set1<T>\n+    where T: HashStable<StableHashingContext<'a, 'tcx>>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use middle::resolve_lifetime::Set1;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            Set1::Empty |\n+            Set1::Many => {\n+                // Nothing to do.\n+            }\n+            Set1::One(ref value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum ::middle::resolve_lifetime::Region {\n+    Static,\n+    EarlyBound(index, decl),\n+    LateBound(db_index, decl),\n+    LateBoundAnon(db_index, anon_index),\n+    Free(call_site_scope_data, decl)\n+});\n+\n+impl_stable_hash_for!(struct ::middle::region::CallSiteScopeData {\n+    fn_id,\n+    body_id\n+});\n+\n+impl_stable_hash_for!(struct ty::DebruijnIndex {\n+    depth\n+});"}, {"sha": "f0601a0efabf89e87390c67498c3e6c436d6a48d", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=cce5c2d93ad4b33967c8f06f26c67e204c46c87b", "patch": "@@ -8,20 +8,44 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! ICH - Incremental Compilation Hash\n+\n pub use self::fingerprint::Fingerprint;\n pub use self::def_path_hash::DefPathHashes;\n pub use self::caching_codemap_view::CachingCodemapView;\n+pub use self::hcx::{StableHashingContext, NodeIdHashingMode};\n \n mod fingerprint;\n mod def_path_hash;\n mod caching_codemap_view;\n+mod hcx;\n+\n+mod impls_const_math;\n+mod impls_hir;\n+mod impls_mir;\n+mod impls_ty;\n+mod impls_syntax;\n \n pub const ATTR_DIRTY: &'static str = \"rustc_dirty\";\n pub const ATTR_CLEAN: &'static str = \"rustc_clean\";\n pub const ATTR_DIRTY_METADATA: &'static str = \"rustc_metadata_dirty\";\n pub const ATTR_CLEAN_METADATA: &'static str = \"rustc_metadata_clean\";\n pub const ATTR_IF_THIS_CHANGED: &'static str = \"rustc_if_this_changed\";\n pub const ATTR_THEN_THIS_WOULD_NEED: &'static str = \"rustc_then_this_would_need\";\n+pub const ATTR_PARTITION_REUSED: &'static str = \"rustc_partition_reused\";\n+pub const ATTR_PARTITION_TRANSLATED: &'static str = \"rustc_partition_translated\";\n+\n+\n+pub const DEP_GRAPH_ASSERT_ATTRS: &'static [&'static str] = &[\n+    ATTR_IF_THIS_CHANGED,\n+    ATTR_THEN_THIS_WOULD_NEED,\n+    ATTR_DIRTY,\n+    ATTR_CLEAN,\n+    ATTR_DIRTY_METADATA,\n+    ATTR_CLEAN_METADATA,\n+    ATTR_PARTITION_REUSED,\n+    ATTR_PARTITION_TRANSLATED,\n+];\n \n pub const IGNORED_ATTRIBUTES: &'static [&'static str] = &[\n     \"cfg\",\n@@ -30,5 +54,7 @@ pub const IGNORED_ATTRIBUTES: &'static [&'static str] = &[\n     ATTR_DIRTY,\n     ATTR_CLEAN,\n     ATTR_DIRTY_METADATA,\n-    ATTR_CLEAN_METADATA\n+    ATTR_CLEAN_METADATA,\n+    ATTR_PARTITION_REUSED,\n+    ATTR_PARTITION_TRANSLATED,\n ];"}, {"sha": "3b002fd4dfc1a210e8445eb9e2cd8469beac0c68", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=cce5c2d93ad4b33967c8f06f26c67e204c46c87b", "patch": "@@ -41,6 +41,7 @@\n #![feature(specialization)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n+#![feature(discriminant_value)]\n \n extern crate arena;\n extern crate core;"}, {"sha": "c18e585f79553bd1791ca22614efb51701389829", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=cce5c2d93ad4b33967c8f06f26c67e204c46c87b", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-tidy-linelength\n+\n macro_rules! enum_from_u32 {\n     ($(#[$attr:meta])* pub enum $name:ident {\n         $($variant:ident = $e:expr,)*\n@@ -59,3 +61,80 @@ macro_rules! span_bug {\n         $crate::session::span_bug_fmt(file!(), line!(), $span, format_args!($($message)*))\n     })\n }\n+\n+#[macro_export]\n+macro_rules! __impl_stable_hash_field {\n+    (DECL IGNORED) => (_);\n+    (DECL $name:ident) => (ref $name);\n+    (USE IGNORED $ctx:expr, $hasher:expr) => ({});\n+    (USE $name:ident, $ctx:expr, $hasher:expr) => ($name.hash_stable($ctx, $hasher));\n+}\n+\n+#[macro_export]\n+macro_rules! impl_stable_hash_for {\n+    (enum $enum_name:path { $( $variant:ident $( ( $($arg:ident),* ) )* ),* }) => {\n+        impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a, 'tcx>> for $enum_name {\n+            #[inline]\n+            fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'a, 'tcx>,\n+                                                  __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n+                use $enum_name::*;\n+                ::std::mem::discriminant(self).hash_stable(__ctx, __hasher);\n+\n+                match *self {\n+                    $(\n+                        $variant $( ( $( __impl_stable_hash_field!(DECL $arg) ),* ) )* => {\n+                            $($( __impl_stable_hash_field!(USE $arg, __ctx, __hasher) );*)*\n+                        }\n+                    )*\n+                }\n+            }\n+        }\n+    };\n+    (struct $struct_name:path { $($field:ident),* }) => {\n+        impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a, 'tcx>> for $struct_name {\n+            #[inline]\n+            fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'a, 'tcx>,\n+                                                  __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n+                let $struct_name {\n+                    $(ref $field),*\n+                } = *self;\n+\n+                $( $field.hash_stable(__ctx, __hasher));*\n+            }\n+        }\n+    };\n+    (tuple_struct $struct_name:path { $($field:ident),* }) => {\n+        impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a, 'tcx>> for $struct_name {\n+            #[inline]\n+            fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'a, 'tcx>,\n+                                                  __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n+                let $struct_name (\n+                    $(ref $field),*\n+                ) = *self;\n+\n+                $( $field.hash_stable(__ctx, __hasher));*\n+            }\n+        }\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! impl_stable_hash_for_spanned {\n+    ($T:path) => (\n+\n+        impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::syntax::codemap::Spanned<$T>\n+        {\n+            #[inline]\n+            fn hash_stable<W: StableHasherResult>(&self,\n+                                                  hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                                  hasher: &mut StableHasher<W>) {\n+                self.node.hash_stable(hcx, hasher);\n+                self.span.hash_stable(hcx, hasher);\n+            }\n+        }\n+    );\n+}\n+"}, {"sha": "799686ceca4a0ec97021d7ed5343d0d24c417b7f", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=cce5c2d93ad4b33967c8f06f26c67e204c46c87b", "patch": "@@ -10,7 +10,9 @@\n \n use std::cell::{Ref, RefCell};\n use rustc_data_structures::indexed_vec::IndexVec;\n-\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n+use ich::StableHashingContext;\n use mir::{Mir, BasicBlock};\n \n use rustc_serialize as serialize;\n@@ -33,6 +35,13 @@ impl serialize::Decodable for Cache {\n     }\n }\n \n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for Cache {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          _: &mut StableHashingContext<'a, 'tcx>,\n+                                          _: &mut StableHasher<W>) {\n+        // do nothing\n+    }\n+}\n \n impl Cache {\n     pub fn new() -> Self {"}, {"sha": "aea4684e526ce3a04c454a23bb93075c0b8ebf9d", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=cce5c2d93ad4b33967c8f06f26c67e204c46c87b", "patch": "@@ -243,6 +243,19 @@ impl<'tcx> Mir<'tcx> {\n     }\n }\n \n+impl_stable_hash_for!(struct Mir<'tcx> {\n+    basic_blocks,\n+    visibility_scopes,\n+    promoted,\n+    return_ty,\n+    local_decls,\n+    arg_count,\n+    upvar_decls,\n+    spread_arg,\n+    span,\n+    cache\n+});\n+\n impl<'tcx> Index<BasicBlock> for Mir<'tcx> {\n     type Output = BasicBlockData<'tcx>;\n \n@@ -830,6 +843,11 @@ pub struct Static<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n+impl_stable_hash_for!(struct Static<'tcx> {\n+    def_id,\n+    ty\n+});\n+\n /// The `Projection` data structure defines things of the form `B.x`\n /// or `*B` or `B[index]`. Note that it is parameterized because it is\n /// shared between `Constant` and `Lvalue`. See the aliases"}, {"sha": "3c529a69820427052525d8fc999fc79ba552b3df", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=cce5c2d93ad4b33967c8f06f26c67e204c46c87b", "patch": "@@ -19,6 +19,7 @@ use dep_graph::{self, DepNode};\n use hir::{map as hir_map, FreevarMap, TraitMap};\n use hir::def::{Def, CtorKind, ExportMap};\n use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use ich::StableHashingContext;\n use middle::const_val::ConstVal;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::privacy::AccessLevels;\n@@ -50,6 +51,8 @@ use syntax_pos::{DUMMY_SP, Span};\n use rustc_const_math::ConstInt;\n \n use rustc_data_structures::accumulate_vec::IntoIter as AccIntoIter;\n+use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n+                                           HashStable};\n \n use hir;\n use hir::itemlikevisit::ItemLikeVisitor;\n@@ -1379,6 +1382,25 @@ impl<'tcx> serialize::UseSpecializedEncodable for &'tcx AdtDef {\n \n impl<'tcx> serialize::UseSpecializedDecodable for &'tcx AdtDef {}\n \n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for AdtDef {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ty::AdtDef {\n+            did,\n+            ref variants,\n+            ref flags,\n+            ref repr,\n+        } = *self;\n+\n+        did.hash_stable(hcx, hasher);\n+        variants.hash_stable(hcx, hasher);\n+        flags.hash_stable(hcx, hasher);\n+        repr.hash_stable(hcx, hasher);\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum AdtKind { Struct, Union, Enum }\n \n@@ -1391,6 +1413,13 @@ pub struct ReprOptions {\n     pub int: Option<attr::IntType>,\n }\n \n+impl_stable_hash_for!(struct ReprOptions {\n+    c,\n+    packed,\n+    simd,\n+    int\n+});\n+\n impl ReprOptions {\n     pub fn new(tcx: TyCtxt, did: DefId) -> ReprOptions {\n         let mut ret = ReprOptions::default();"}, {"sha": "c1735b4a4ec9a588156757293152deb775fa1129", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=cce5c2d93ad4b33967c8f06f26c67e204c46c87b", "patch": "@@ -37,6 +37,8 @@\n #![feature(unsize)]\n #![feature(i128_type)]\n #![feature(conservative_impl_trait)]\n+#![feature(discriminant_value)]\n+#![feature(specialization)]\n \n #![cfg_attr(unix, feature(libc))]\n #![cfg_attr(test, feature(test))]"}, {"sha": "dc412a0763ef70f196eed9134bfa930f21a40570", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 191, "deletions": 1, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=cce5c2d93ad4b33967c8f06f26c67e204c46c87b", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::hash::Hasher;\n+use std::hash::{Hash, Hasher};\n use std::marker::PhantomData;\n use std::mem;\n use blake2b::Blake2bHasher;\n@@ -174,3 +174,193 @@ impl<W> Hasher for StableHasher<W> {\n         self.write_ileb128(i as i64);\n     }\n }\n+\n+\n+/// Something that implements `HashStable<CTX>` can be hashed in a way that is\n+/// stable across multiple compiliation sessions.\n+pub trait HashStable<CTX> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>);\n+}\n+\n+// Implement HashStable by just calling `Hash::hash()`. This works fine for\n+// self-contained values that don't depend on the hashing context `CTX`.\n+macro_rules! impl_stable_hash_via_hash {\n+    ($t:ty) => (\n+        impl<CTX> HashStable<CTX> for $t {\n+            #[inline]\n+            fn hash_stable<W: StableHasherResult>(&self,\n+                                                  _: &mut CTX,\n+                                                  hasher: &mut StableHasher<W>) {\n+                ::std::hash::Hash::hash(self, hasher);\n+            }\n+        }\n+    );\n+}\n+\n+impl_stable_hash_via_hash!(i8);\n+impl_stable_hash_via_hash!(i16);\n+impl_stable_hash_via_hash!(i32);\n+impl_stable_hash_via_hash!(i64);\n+impl_stable_hash_via_hash!(isize);\n+\n+impl_stable_hash_via_hash!(u8);\n+impl_stable_hash_via_hash!(u16);\n+impl_stable_hash_via_hash!(u32);\n+impl_stable_hash_via_hash!(u64);\n+impl_stable_hash_via_hash!(usize);\n+\n+impl_stable_hash_via_hash!(u128);\n+impl_stable_hash_via_hash!(i128);\n+\n+impl_stable_hash_via_hash!(char);\n+impl_stable_hash_via_hash!(());\n+\n+impl<CTX> HashStable<CTX> for f32 {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        let val: u32 = unsafe {\n+            ::std::mem::transmute(*self)\n+        };\n+        val.hash_stable(ctx, hasher);\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for f64 {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        let val: u64 = unsafe {\n+            ::std::mem::transmute(*self)\n+        };\n+        val.hash_stable(ctx, hasher);\n+    }\n+}\n+\n+impl<T1: HashStable<CTX>, T2: HashStable<CTX>, CTX> HashStable<CTX> for (T1, T2) {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.0.hash_stable(ctx, hasher);\n+        self.1.hash_stable(ctx, hasher);\n+    }\n+}\n+\n+impl<T: HashStable<CTX>, CTX> HashStable<CTX> for [T] {\n+    default fn hash_stable<W: StableHasherResult>(&self,\n+                                                  ctx: &mut CTX,\n+                                                  hasher: &mut StableHasher<W>) {\n+        self.len().hash_stable(ctx, hasher);\n+        for item in self {\n+            item.hash_stable(ctx, hasher);\n+        }\n+    }\n+}\n+\n+impl<T: HashStable<CTX>, CTX> HashStable<CTX> for Vec<T> {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        (&self[..]).hash_stable(ctx, hasher);\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for str {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          _: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.len().hash(hasher);\n+        self.as_bytes().hash(hasher);\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for bool {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        (if *self { 1u8 } else { 0u8 }).hash_stable(ctx, hasher);\n+    }\n+}\n+\n+\n+impl<T, CTX> HashStable<CTX> for Option<T>\n+    where T: HashStable<CTX>\n+{\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        if let Some(ref value) = *self {\n+            1u8.hash_stable(ctx, hasher);\n+            value.hash_stable(ctx, hasher);\n+        } else {\n+            0u8.hash_stable(ctx, hasher);\n+        }\n+    }\n+}\n+\n+impl<'a, T, CTX> HashStable<CTX> for &'a T\n+    where T: HashStable<CTX>\n+{\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        (**self).hash_stable(ctx, hasher);\n+    }\n+}\n+\n+impl<T, CTX> HashStable<CTX> for ::std::mem::Discriminant<T> {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          _: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        ::std::hash::Hash::hash(self, hasher);\n+    }\n+}\n+\n+impl<K, V, CTX> HashStable<CTX> for ::std::collections::BTreeMap<K, V>\n+    where K: Ord + HashStable<CTX>,\n+          V: HashStable<CTX>,\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.len().hash_stable(ctx, hasher);\n+        for (k, v) in self {\n+            k.hash_stable(ctx, hasher);\n+            v.hash_stable(ctx, hasher);\n+        }\n+    }\n+}\n+\n+impl<T, CTX> HashStable<CTX> for ::std::collections::BTreeSet<T>\n+    where T: Ord + HashStable<CTX>,\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.len().hash_stable(ctx, hasher);\n+        for v in self {\n+            v.hash_stable(ctx, hasher);\n+        }\n+    }\n+}\n+\n+impl<I: ::indexed_vec::Idx, T, CTX> HashStable<CTX> for ::indexed_vec::IndexVec<I, T>\n+    where T: HashStable<CTX>,\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.len().hash_stable(ctx, hasher);\n+        for v in &self.raw {\n+            v.hash_stable(ctx, hasher);\n+        }\n+    }\n+}"}, {"sha": "c80a5a1627797bfbae1448530bd649f99ca9b55d", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 93, "deletions": 104, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=cce5c2d93ad4b33967c8f06f26c67e204c46c87b", "patch": "@@ -27,24 +27,17 @@\n //! at the end of compilation would be different from those computed\n //! at the beginning.\n \n-use syntax::ast;\n use std::cell::RefCell;\n use std::hash::Hash;\n use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n-use rustc::hir::intravisit as visit;\n-use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n-use rustc::ich::{Fingerprint, DefPathHashes, CachingCodemapView};\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::ich::{Fingerprint, StableHashingContext};\n use rustc::ty::TyCtxt;\n-use rustc_data_structures::stable_hasher::StableHasher;\n+use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use rustc_data_structures::fx::FxHashMap;\n use rustc::util::common::record_time;\n-use rustc::session::config::DebugInfoLevel::NoDebugInfo;\n-\n-use self::svh_visitor::StrictVersionHashVisitor;\n-\n-mod svh_visitor;\n \n pub type IchHasher = StableHasher<Fingerprint>;\n \n@@ -94,107 +87,58 @@ impl<'a> ::std::ops::Index<&'a DepNode<DefId>> for IncrementalHashesMap {\n     }\n }\n \n-\n-pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                                    -> IncrementalHashesMap {\n-    let _ignore = tcx.dep_graph.in_ignore();\n-    let krate = tcx.hir.krate();\n-    let hash_spans = tcx.sess.opts.debuginfo != NoDebugInfo;\n-    let mut visitor = HashItemsVisitor {\n-        tcx: tcx,\n-        hashes: IncrementalHashesMap::new(),\n-        def_path_hashes: DefPathHashes::new(tcx),\n-        codemap: CachingCodemapView::new(tcx),\n-        hash_spans: hash_spans,\n-    };\n-    record_time(&tcx.sess.perf_stats.incr_comp_hashes_time, || {\n-        visitor.calculate_def_id(DefId::local(CRATE_DEF_INDEX), |v| {\n-            v.hash_crate_root_module(krate);\n-        });\n-        krate.visit_all_item_likes(&mut visitor.as_deep_visitor());\n-\n-        for macro_def in krate.exported_macros.iter() {\n-            visitor.calculate_node_id(macro_def.id,\n-                                      |v| v.visit_macro_def(macro_def));\n-        }\n-    });\n-\n-    tcx.sess.perf_stats.incr_comp_hashes_count.set(visitor.hashes.len() as u64);\n-\n-    record_time(&tcx.sess.perf_stats.svh_time, || visitor.compute_crate_hash());\n-    visitor.hashes\n-}\n-\n-struct HashItemsVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    def_path_hashes: DefPathHashes<'a, 'tcx>,\n-    codemap: CachingCodemapView<'tcx>,\n+struct ComputeItemHashesVisitor<'a, 'tcx: 'a> {\n+    hcx: StableHashingContext<'a, 'tcx>,\n     hashes: IncrementalHashesMap,\n-    hash_spans: bool,\n }\n \n-impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n-    fn calculate_node_id<W>(&mut self, id: ast::NodeId, walk_op: W)\n-        where W: for<'v> FnMut(&mut StrictVersionHashVisitor<'v, 'a, 'tcx>)\n-    {\n-        let def_id = self.tcx.hir.local_def_id(id);\n-        self.calculate_def_id(def_id, walk_op)\n-    }\n-\n-    fn calculate_def_id<W>(&mut self, def_id: DefId, mut walk_op: W)\n-        where W: for<'v> FnMut(&mut StrictVersionHashVisitor<'v, 'a, 'tcx>)\n+impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n+    fn compute_and_store_ich_for_item_like<T>(&mut self,\n+                                              dep_node: DepNode<DefId>,\n+                                              hash_bodies: bool,\n+                                              item_like: T)\n+        where T: HashStable<StableHashingContext<'a, 'tcx>>\n     {\n-        assert!(def_id.is_local());\n-        debug!(\"HashItemsVisitor::calculate(def_id={:?})\", def_id);\n-        self.calculate_def_hash(DepNode::Hir(def_id), false, &mut walk_op);\n-        self.calculate_def_hash(DepNode::HirBody(def_id), true, &mut walk_op);\n-    }\n+        let mut hasher = IchHasher::new();\n+        self.hcx.while_hashing_hir_bodies(hash_bodies, |hcx| {\n+            item_like.hash_stable(hcx, &mut hasher);\n+        });\n \n-    fn calculate_def_hash<W>(&mut self,\n-                             dep_node: DepNode<DefId>,\n-                             hash_bodies: bool,\n-                             walk_op: &mut W)\n-        where W: for<'v> FnMut(&mut StrictVersionHashVisitor<'v, 'a, 'tcx>)\n-    {\n-        let mut state = IchHasher::new();\n-        walk_op(&mut StrictVersionHashVisitor::new(&mut state,\n-                                                   self.tcx,\n-                                                   &mut self.def_path_hashes,\n-                                                   &mut self.codemap,\n-                                                   self.hash_spans,\n-                                                   hash_bodies));\n-        let bytes_hashed = state.bytes_hashed();\n-        let item_hash = state.finish();\n+        let bytes_hashed = hasher.bytes_hashed();\n+        let item_hash = hasher.finish();\n         debug!(\"calculate_def_hash: dep_node={:?} hash={:?}\", dep_node, item_hash);\n         self.hashes.insert(dep_node, item_hash);\n \n-        let bytes_hashed = self.tcx.sess.perf_stats.incr_comp_bytes_hashed.get() +\n+        let tcx = self.hcx.tcx();\n+        let bytes_hashed =\n+            tcx.sess.perf_stats.incr_comp_bytes_hashed.get() +\n             bytes_hashed;\n-        self.tcx.sess.perf_stats.incr_comp_bytes_hashed.set(bytes_hashed);\n+        tcx.sess.perf_stats.incr_comp_bytes_hashed.set(bytes_hashed);\n     }\n \n     fn compute_crate_hash(&mut self) {\n-        let krate = self.tcx.hir.krate();\n+        let tcx = self.hcx.tcx();\n+        let krate = tcx.hir.krate();\n \n         let mut crate_state = IchHasher::new();\n \n-        let crate_disambiguator = self.tcx.sess.local_crate_disambiguator();\n+        let crate_disambiguator = tcx.sess.local_crate_disambiguator();\n         \"crate_disambiguator\".hash(&mut crate_state);\n         crate_disambiguator.as_str().len().hash(&mut crate_state);\n         crate_disambiguator.as_str().hash(&mut crate_state);\n \n         // add each item (in some deterministic order) to the overall\n         // crate hash.\n         {\n-            let def_path_hashes = &mut self.def_path_hashes;\n+            let hcx = &mut self.hcx;\n             let mut item_hashes: Vec<_> =\n                 self.hashes.iter()\n                            .map(|(item_dep_node, &item_hash)| {\n                                // convert from a DepNode<DefId> tp a\n                                // DepNode<u64> where the u64 is the\n                                // hash of the def-id's def-path:\n                                let item_dep_node =\n-                                   item_dep_node.map_def(|&did| Some(def_path_hashes.hash(did)))\n+                                   item_dep_node.map_def(|&did| Some(hcx.def_path_hash(did)))\n                                                 .unwrap();\n                                (item_dep_node, item_hash)\n                            })\n@@ -203,40 +147,85 @@ impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n             item_hashes.hash(&mut crate_state);\n         }\n \n-        {\n-            let mut visitor = StrictVersionHashVisitor::new(&mut crate_state,\n-                                                            self.tcx,\n-                                                            &mut self.def_path_hashes,\n-                                                            &mut self.codemap,\n-                                                            self.hash_spans,\n-                                                            false);\n-            visitor.hash_attributes(&krate.attrs);\n-        }\n+        krate.attrs.hash_stable(&mut self.hcx, &mut crate_state);\n \n         let crate_hash = crate_state.finish();\n         self.hashes.insert(DepNode::Krate, crate_hash);\n         debug!(\"calculate_crate_hash: crate_hash={:?}\", crate_hash);\n     }\n-}\n \n-\n-impl<'a, 'tcx> Visitor<'tcx> for HashItemsVisitor<'a, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n+    fn hash_crate_root_module(&mut self, krate: &'tcx hir::Crate) {\n+        let hir::Crate {\n+            ref module,\n+            // Crate attributes are not copied over to the root `Mod`, so hash\n+            // them explicitly here.\n+            ref attrs,\n+            span,\n+\n+            // These fields are handled separately:\n+            exported_macros: _,\n+            items: _,\n+            trait_items: _,\n+            impl_items: _,\n+            bodies: _,\n+            trait_impls: _,\n+            trait_default_impl: _,\n+            body_ids: _,\n+        } = *krate;\n+\n+        let def_id = DefId::local(CRATE_DEF_INDEX);\n+        self.compute_and_store_ich_for_item_like(DepNode::Hir(def_id),\n+                                                 false,\n+                                                 (module, (span, attrs)));\n+        self.compute_and_store_ich_for_item_like(DepNode::HirBody(def_id),\n+                                                 true,\n+                                                 (module, (span, attrs)));\n     }\n+}\n \n+impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for ComputeItemHashesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        self.calculate_node_id(item.id, |v| v.visit_item(item));\n-        visit::walk_item(self, item);\n+        let def_id = self.hcx.tcx().hir.local_def_id(item.id);\n+        self.compute_and_store_ich_for_item_like(DepNode::Hir(def_id), false, item);\n+        self.compute_and_store_ich_for_item_like(DepNode::HirBody(def_id), true, item);\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n-        self.calculate_node_id(trait_item.id, |v| v.visit_trait_item(trait_item));\n-        visit::walk_trait_item(self, trait_item);\n+    fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n+        let def_id = self.hcx.tcx().hir.local_def_id(item.id);\n+        self.compute_and_store_ich_for_item_like(DepNode::Hir(def_id), false, item);\n+        self.compute_and_store_ich_for_item_like(DepNode::HirBody(def_id), true, item);\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n-        self.calculate_node_id(impl_item.id, |v| v.visit_impl_item(impl_item));\n-        visit::walk_impl_item(self, impl_item);\n+    fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n+        let def_id = self.hcx.tcx().hir.local_def_id(item.id);\n+        self.compute_and_store_ich_for_item_like(DepNode::Hir(def_id), false, item);\n+        self.compute_and_store_ich_for_item_like(DepNode::HirBody(def_id), true, item);\n     }\n }\n+\n+pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                                                    -> IncrementalHashesMap {\n+    let _ignore = tcx.dep_graph.in_ignore();\n+    let krate = tcx.hir.krate();\n+\n+    let mut visitor = ComputeItemHashesVisitor {\n+        hcx: StableHashingContext::new(tcx),\n+        hashes: IncrementalHashesMap::new(),\n+    };\n+\n+    record_time(&tcx.sess.perf_stats.incr_comp_hashes_time, || {\n+        visitor.hash_crate_root_module(krate);\n+        krate.visit_all_item_likes(&mut visitor);\n+\n+        for macro_def in krate.exported_macros.iter() {\n+            let def_id = tcx.hir.local_def_id(macro_def.id);\n+            visitor.compute_and_store_ich_for_item_like(DepNode::Hir(def_id), false, macro_def);\n+            visitor.compute_and_store_ich_for_item_like(DepNode::HirBody(def_id), true, macro_def);\n+        }\n+    });\n+\n+    tcx.sess.perf_stats.incr_comp_hashes_count.set(visitor.hashes.len() as u64);\n+\n+    record_time(&tcx.sess.perf_stats.svh_time, || visitor.compute_crate_hash());\n+    visitor.hashes\n+}"}, {"sha": "5401b371888e939c58b6b3145b5f3faf67aa5315", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "removed", "additions": 0, "deletions": 1111, "changes": 1111, "blob_url": "https://github.com/rust-lang/rust/blob/44855a4cef3e83c76c386fdcf034447a8ee128e4/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44855a4cef3e83c76c386fdcf034447a8ee128e4/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=44855a4cef3e83c76c386fdcf034447a8ee128e4", "patch": "@@ -1,1111 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use self::SawExprComponent::*;\n-use self::SawAbiComponent::*;\n-use self::SawItemComponent::*;\n-use self::SawPatComponent::*;\n-use self::SawTyComponent::*;\n-use self::SawTraitOrImplItemComponent::*;\n-use syntax::abi::Abi;\n-use syntax::ast::{self, Name, NodeId};\n-use syntax::attr;\n-use syntax::ext::hygiene::SyntaxContext;\n-use syntax::parse::token;\n-use syntax::symbol::InternedString;\n-use syntax_pos::{Span, BytePos};\n-use syntax::tokenstream;\n-use rustc::hir;\n-use rustc::hir::*;\n-use rustc::hir::def::Def;\n-use rustc::hir::def_id::DefId;\n-use rustc::hir::intravisit::{self as visit, Visitor};\n-use rustc::ich::{DefPathHashes, CachingCodemapView, IGNORED_ATTRIBUTES};\n-use rustc::ty::TyCtxt;\n-use std::hash::{Hash, Hasher};\n-\n-use super::IchHasher;\n-\n-pub struct StrictVersionHashVisitor<'a, 'hash: 'a, 'tcx: 'hash> {\n-    pub tcx: TyCtxt<'hash, 'tcx, 'tcx>,\n-    pub st: &'a mut IchHasher,\n-    // collect a deterministic hash of def-ids that we have seen\n-    def_path_hashes: &'a mut DefPathHashes<'hash, 'tcx>,\n-    hash_spans: bool,\n-    codemap: &'a mut CachingCodemapView<'tcx>,\n-    overflow_checks_enabled: bool,\n-    hash_bodies: bool,\n-}\n-\n-impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n-    pub fn new(st: &'a mut IchHasher,\n-               tcx: TyCtxt<'hash, 'tcx, 'tcx>,\n-               def_path_hashes: &'a mut DefPathHashes<'hash, 'tcx>,\n-               codemap: &'a mut CachingCodemapView<'tcx>,\n-               hash_spans: bool,\n-               hash_bodies: bool)\n-               -> Self {\n-        let check_overflow = tcx.sess.overflow_checks();\n-\n-        StrictVersionHashVisitor {\n-            st: st,\n-            tcx: tcx,\n-            def_path_hashes: def_path_hashes,\n-            hash_spans: hash_spans,\n-            codemap: codemap,\n-            overflow_checks_enabled: check_overflow,\n-            hash_bodies: hash_bodies,\n-        }\n-    }\n-\n-    fn compute_def_id_hash(&mut self, def_id: DefId) -> u64 {\n-        self.def_path_hashes.hash(def_id)\n-    }\n-\n-    // Hash a span in a stable way. We can't directly hash the span's BytePos\n-    // fields (that would be similar to hashing pointers, since those are just\n-    // offsets into the CodeMap). Instead, we hash the (file name, line, column)\n-    // triple, which stays the same even if the containing FileMap has moved\n-    // within the CodeMap.\n-    // Also note that we are hashing byte offsets for the column, not unicode\n-    // codepoint offsets. For the purpose of the hash that's sufficient.\n-    // Also, hashing filenames is expensive so we avoid doing it twice when the\n-    // span starts and ends in the same file, which is almost always the case.\n-    fn hash_span(&mut self, span: Span) {\n-        debug!(\"hash_span: st={:?}\", self.st);\n-\n-        // If this is not an empty or invalid span, we want to hash the last\n-        // position that belongs to it, as opposed to hashing the first\n-        // position past it.\n-        let span_hi = if span.hi > span.lo {\n-            // We might end up in the middle of a multibyte character here,\n-            // but that's OK, since we are not trying to decode anything at\n-            // this position.\n-            span.hi - BytePos(1)\n-        } else {\n-            span.hi\n-        };\n-\n-        let expn_kind = if span.ctxt == SyntaxContext::empty() {\n-            SawSpanExpnKind::NoExpansion\n-        } else {\n-            SawSpanExpnKind::SomeExpansion\n-        };\n-\n-        let loc1 = self.codemap.byte_pos_to_line_and_col(span.lo);\n-        let loc1 = loc1.as_ref()\n-                       .map(|&(ref fm, line, col)| (&fm.name[..], line, col))\n-                       .unwrap_or((\"???\", 0, BytePos(0)));\n-\n-        let loc2 = self.codemap.byte_pos_to_line_and_col(span_hi);\n-        let loc2 = loc2.as_ref()\n-                       .map(|&(ref fm, line, col)| (&fm.name[..], line, col))\n-                       .unwrap_or((\"???\", 0, BytePos(0)));\n-\n-        let saw = if loc1.0 == loc2.0 {\n-            SawSpan(loc1.0,\n-                    loc1.1, loc1.2,\n-                    loc2.1, loc2.2,\n-                    expn_kind)\n-        } else {\n-            SawSpanTwoFiles(loc1.0, loc1.1, loc1.2,\n-                            loc2.0, loc2.1, loc2.2,\n-                            expn_kind)\n-        };\n-        saw.hash(self.st);\n-\n-        if expn_kind == SawSpanExpnKind::SomeExpansion {\n-            self.hash_span(span.source_callsite());\n-        }\n-    }\n-\n-    fn hash_discriminant<T>(&mut self, v: &T) {\n-        unsafe {\n-            let disr = ::std::intrinsics::discriminant_value(v);\n-            debug!(\"hash_discriminant: disr={}, st={:?}\", disr, self.st);\n-            disr.hash(self.st);\n-        }\n-    }\n-}\n-\n-// To off-load the bulk of the hash-computation on #[derive(Hash)],\n-// we define a set of enums corresponding to the content that our\n-// crate visitor will encounter as it traverses the ast.\n-//\n-// The important invariant is that all of the Saw*Component enums\n-// do not carry any Spans, Names, or Idents.\n-//\n-// Not carrying any Names/Idents is the important fix for problem\n-// noted on PR #13948: using the ident.name as the basis for a\n-// hash leads to unstable SVH, because ident.name is just an index\n-// into intern table (i.e. essentially a random address), not\n-// computed from the name content.\n-//\n-// With the below enums, the SVH computation is not sensitive to\n-// artifacts of how rustc was invoked nor of how the source code\n-// was laid out.  (Or at least it is *less* sensitive.)\n-\n-// This enum represents the different potential bits of code the\n-// visitor could encounter that could affect the ABI for the crate,\n-// and assigns each a distinct tag to feed into the hash computation.\n-#[derive(Hash)]\n-enum SawAbiComponent<'a> {\n-\n-    // FIXME (#14132): should we include (some function of)\n-    // ident.ctxt as well?\n-    SawIdent(InternedString),\n-    SawStructDef(InternedString),\n-\n-    SawLifetime,\n-    SawLifetimeDef(usize),\n-\n-    SawMod,\n-    SawForeignItem(SawForeignItemComponent),\n-    SawItem(SawItemComponent),\n-    SawTy(SawTyComponent),\n-    SawFnDecl(bool),\n-    SawGenerics,\n-    SawTraitItem(SawTraitOrImplItemComponent),\n-    SawImplItem(SawTraitOrImplItemComponent),\n-    SawStructField,\n-    SawVariant(bool),\n-    SawQPath,\n-    SawPathSegment,\n-    SawPathParameters,\n-    SawBlock,\n-    SawPat(SawPatComponent),\n-    SawLocal,\n-    SawArm,\n-    SawExpr(SawExprComponent<'a>),\n-    SawStmt,\n-    SawVis,\n-    SawAssociatedItemKind(hir::AssociatedItemKind),\n-    SawDefaultness(hir::Defaultness),\n-    SawWherePredicate,\n-    SawTyParamBound,\n-    SawPolyTraitRef,\n-    SawAssocTypeBinding,\n-    SawAttribute(ast::AttrStyle),\n-    SawMacroDef,\n-    SawSpan(&'a str,\n-            usize, BytePos,\n-            usize, BytePos,\n-            SawSpanExpnKind),\n-    SawSpanTwoFiles(&'a str, usize, BytePos,\n-                    &'a str, usize, BytePos,\n-                    SawSpanExpnKind),\n-}\n-\n-/// SawExprComponent carries all of the information that we want\n-/// to include in the hash that *won't* be covered by the\n-/// subsequent recursive traversal of the expression's\n-/// substructure by the visitor.\n-///\n-/// We know every Expr_ variant is covered by a variant because\n-/// `fn saw_expr` maps each to some case below.  Ensuring that\n-/// each variant carries an appropriate payload has to be verified\n-/// by hand.\n-///\n-/// (However, getting that *exactly* right is not so important\n-/// because the SVH is just a developer convenience; there is no\n-/// guarantee of collision-freedom, hash collisions are just\n-/// (hopefully) unlikely.)\n-///\n-/// The xxxComponent enums and saw_xxx functions for Item, Pat,\n-/// Ty, TraitItem and ImplItem follow the same methodology.\n-#[derive(Hash)]\n-enum SawExprComponent<'a> {\n-\n-    SawExprLoop(Option<InternedString>),\n-    SawExprField(InternedString),\n-    SawExprTupField(usize),\n-    SawExprBreak(Option<InternedString>),\n-    SawExprAgain(Option<InternedString>),\n-\n-    SawExprBox,\n-    SawExprArray,\n-    SawExprCall,\n-    SawExprMethodCall,\n-    SawExprTup,\n-    SawExprBinary(hir::BinOp_),\n-    SawExprUnary(hir::UnOp),\n-    SawExprLit(ast::LitKind),\n-    SawExprLitStr(InternedString, ast::StrStyle),\n-    SawExprLitFloat(InternedString, Option<ast::FloatTy>),\n-    SawExprCast,\n-    SawExprType,\n-    SawExprIf,\n-    SawExprWhile,\n-    SawExprMatch,\n-    SawExprClosure(CaptureClause),\n-    SawExprBlock,\n-    SawExprAssign,\n-    SawExprAssignOp(hir::BinOp_),\n-    SawExprIndex,\n-    SawExprPath,\n-    SawExprAddrOf(hir::Mutability),\n-    SawExprRet,\n-    SawExprInlineAsm(StableInlineAsm<'a>),\n-    SawExprStruct,\n-    SawExprRepeat,\n-}\n-\n-// The boolean returned indicates whether the span of this expression is always\n-// significant, regardless of debuginfo.\n-fn saw_expr<'a>(node: &'a Expr_,\n-                overflow_checks_enabled: bool)\n-                -> (SawExprComponent<'a>, bool) {\n-    let binop_can_panic_at_runtime = |binop| {\n-        match binop {\n-            BiAdd |\n-            BiSub |\n-            BiMul => overflow_checks_enabled,\n-\n-            BiDiv |\n-            BiRem => true,\n-\n-            BiAnd |\n-            BiOr |\n-            BiBitXor |\n-            BiBitAnd |\n-            BiBitOr |\n-            BiShl |\n-            BiShr |\n-            BiEq |\n-            BiLt |\n-            BiLe |\n-            BiNe |\n-            BiGe |\n-            BiGt => false\n-        }\n-    };\n-\n-    let unop_can_panic_at_runtime = |unop| {\n-        match unop {\n-            UnDeref |\n-            UnNot => false,\n-            UnNeg => overflow_checks_enabled,\n-        }\n-    };\n-\n-    match *node {\n-        ExprBox(..)              => (SawExprBox, false),\n-        ExprArray(..)            => (SawExprArray, false),\n-        ExprCall(..)             => (SawExprCall, false),\n-        ExprMethodCall(..)       => (SawExprMethodCall, false),\n-        ExprTup(..)              => (SawExprTup, false),\n-        ExprBinary(op, ..)       => {\n-            (SawExprBinary(op.node), binop_can_panic_at_runtime(op.node))\n-        }\n-        ExprUnary(op, _)         => {\n-            (SawExprUnary(op), unop_can_panic_at_runtime(op))\n-        }\n-        ExprLit(ref lit)         => (saw_lit(lit), false),\n-        ExprCast(..)             => (SawExprCast, false),\n-        ExprType(..)             => (SawExprType, false),\n-        ExprIf(..)               => (SawExprIf, false),\n-        ExprWhile(..)            => (SawExprWhile, false),\n-        ExprLoop(_, id, _)       => (SawExprLoop(id.map(|id| id.node.as_str())), false),\n-        ExprMatch(..)            => (SawExprMatch, false),\n-        ExprClosure(cc, _, _, _) => (SawExprClosure(cc), false),\n-        ExprBlock(..)            => (SawExprBlock, false),\n-        ExprAssign(..)           => (SawExprAssign, false),\n-        ExprAssignOp(op, ..)     => {\n-            (SawExprAssignOp(op.node), binop_can_panic_at_runtime(op.node))\n-        }\n-        ExprField(_, name)       => (SawExprField(name.node.as_str()), false),\n-        ExprTupField(_, id)      => (SawExprTupField(id.node), false),\n-        ExprIndex(..)            => (SawExprIndex, true),\n-        ExprPath(_)              => (SawExprPath, false),\n-        ExprAddrOf(m, _)         => (SawExprAddrOf(m), false),\n-        ExprBreak(label, _)      => (SawExprBreak(label.ident.map(|i|\n-                                                    i.node.name.as_str())), false),\n-        ExprAgain(label)         => (SawExprAgain(label.ident.map(|i|\n-                                                    i.node.name.as_str())), false),\n-        ExprRet(..)              => (SawExprRet, false),\n-        ExprInlineAsm(ref a,..)  => (SawExprInlineAsm(StableInlineAsm(a)), false),\n-        ExprStruct(..)           => (SawExprStruct, false),\n-        ExprRepeat(..)           => (SawExprRepeat, false),\n-    }\n-}\n-\n-fn saw_lit(lit: &ast::Lit) -> SawExprComponent<'static> {\n-    match lit.node {\n-        ast::LitKind::Str(s, style) => SawExprLitStr(s.as_str(), style),\n-        ast::LitKind::Float(s, ty) => SawExprLitFloat(s.as_str(), Some(ty)),\n-        ast::LitKind::FloatUnsuffixed(s) => SawExprLitFloat(s.as_str(), None),\n-        ref node @ _ => SawExprLit(node.clone()),\n-    }\n-}\n-\n-#[derive(Hash)]\n-enum SawItemComponent {\n-    SawItemExternCrate,\n-    SawItemUse(UseKind),\n-    SawItemStatic(Mutability),\n-    SawItemConst,\n-    SawItemFn(Unsafety, Constness, Abi),\n-    SawItemMod,\n-    SawItemForeignMod(Abi),\n-    SawItemTy,\n-    SawItemEnum,\n-    SawItemStruct,\n-    SawItemUnion,\n-    SawItemTrait(Unsafety),\n-    SawItemDefaultImpl(Unsafety),\n-    SawItemImpl(Unsafety, ImplPolarity)\n-}\n-\n-fn saw_item(node: &Item_) -> SawItemComponent {\n-    match *node {\n-        ItemExternCrate(..) => SawItemExternCrate,\n-        ItemUse(_, kind) => SawItemUse(kind),\n-        ItemStatic(_, mutability, _) => SawItemStatic(mutability),\n-        ItemConst(..) =>SawItemConst,\n-        ItemFn(_, unsafety, constness, abi, _, _) => SawItemFn(unsafety, constness, abi),\n-        ItemMod(..) => SawItemMod,\n-        ItemForeignMod(ref fm) => SawItemForeignMod(fm.abi),\n-        ItemTy(..) => SawItemTy,\n-        ItemEnum(..) => SawItemEnum,\n-        ItemStruct(..) => SawItemStruct,\n-        ItemUnion(..) => SawItemUnion,\n-        ItemTrait(unsafety, ..) => SawItemTrait(unsafety),\n-        ItemDefaultImpl(unsafety, _) => SawItemDefaultImpl(unsafety),\n-        ItemImpl(unsafety, implpolarity, ..) => SawItemImpl(unsafety, implpolarity)\n-    }\n-}\n-\n-#[derive(Hash)]\n-enum SawForeignItemComponent {\n-    Static { mutable: bool },\n-    Fn,\n-}\n-\n-#[derive(Hash)]\n-enum SawPatComponent {\n-    SawPatWild,\n-    SawPatBinding(BindingMode),\n-    SawPatStruct,\n-    SawPatTupleStruct,\n-    SawPatPath,\n-    SawPatTuple,\n-    SawPatBox,\n-    SawPatRef(Mutability),\n-    SawPatLit,\n-    SawPatRange,\n-    SawPatSlice\n-}\n-\n-fn saw_pat(node: &PatKind) -> SawPatComponent {\n-    match *node {\n-        PatKind::Wild => SawPatWild,\n-        PatKind::Binding(bindingmode, ..) => SawPatBinding(bindingmode),\n-        PatKind::Struct(..) => SawPatStruct,\n-        PatKind::TupleStruct(..) => SawPatTupleStruct,\n-        PatKind::Path(_) => SawPatPath,\n-        PatKind::Tuple(..) => SawPatTuple,\n-        PatKind::Box(..) => SawPatBox,\n-        PatKind::Ref(_, mutability) => SawPatRef(mutability),\n-        PatKind::Lit(..) => SawPatLit,\n-        PatKind::Range(..) => SawPatRange,\n-        PatKind::Slice(..) => SawPatSlice\n-    }\n-}\n-\n-#[derive(Hash)]\n-enum SawTyComponent {\n-    SawTySlice,\n-    SawTyArray,\n-    SawTyPtr(Mutability),\n-    SawTyRptr(Mutability),\n-    SawTyBareFn(Unsafety, Abi),\n-    SawTyNever,\n-    SawTyTup,\n-    SawTyPath,\n-    SawTyObjectSum,\n-    SawTyImplTrait,\n-    SawTyTypeof,\n-    SawTyInfer\n-}\n-\n-fn saw_ty(node: &Ty_) -> SawTyComponent {\n-    match *node {\n-      TySlice(..) => SawTySlice,\n-      TyArray(..) => SawTyArray,\n-      TyPtr(ref mty) => SawTyPtr(mty.mutbl),\n-      TyRptr(_, ref mty) => SawTyRptr(mty.mutbl),\n-      TyBareFn(ref barefnty) => SawTyBareFn(barefnty.unsafety, barefnty.abi),\n-      TyNever => SawTyNever,\n-      TyTup(..) => SawTyTup,\n-      TyPath(_) => SawTyPath,\n-      TyTraitObject(..) => SawTyObjectSum,\n-      TyImplTrait(..) => SawTyImplTrait,\n-      TyTypeof(..) => SawTyTypeof,\n-      TyInfer => SawTyInfer\n-    }\n-}\n-\n-#[derive(Hash)]\n-enum SawTraitOrImplItemComponent {\n-    SawTraitOrImplItemConst,\n-    // The boolean signifies whether a body is present\n-    SawTraitOrImplItemMethod(Unsafety, Constness, Abi, bool),\n-    SawTraitOrImplItemType\n-}\n-\n-fn saw_trait_item(ti: &TraitItemKind) -> SawTraitOrImplItemComponent {\n-    match *ti {\n-        TraitItemKind::Const(..) => SawTraitOrImplItemConst,\n-        TraitItemKind::Method(ref sig, TraitMethod::Required(_)) =>\n-            SawTraitOrImplItemMethod(sig.unsafety, sig.constness, sig.abi, false),\n-        TraitItemKind::Method(ref sig, TraitMethod::Provided(_)) =>\n-            SawTraitOrImplItemMethod(sig.unsafety, sig.constness, sig.abi, true),\n-        TraitItemKind::Type(..) => SawTraitOrImplItemType\n-    }\n-}\n-\n-fn saw_impl_item(ii: &ImplItemKind) -> SawTraitOrImplItemComponent {\n-    match *ii {\n-        ImplItemKind::Const(..) => SawTraitOrImplItemConst,\n-        ImplItemKind::Method(ref sig, _) =>\n-            SawTraitOrImplItemMethod(sig.unsafety, sig.constness, sig.abi, true),\n-        ImplItemKind::Type(..) => SawTraitOrImplItemType\n-    }\n-}\n-\n-#[derive(Clone, Copy, Hash, Eq, PartialEq)]\n-enum SawSpanExpnKind {\n-    NoExpansion,\n-    SomeExpansion,\n-}\n-\n-/// A wrapper that provides a stable Hash implementation.\n-struct StableInlineAsm<'a>(&'a InlineAsm);\n-\n-impl<'a> Hash for StableInlineAsm<'a> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        let InlineAsm {\n-            asm,\n-            asm_str_style,\n-            ref outputs,\n-            ref inputs,\n-            ref clobbers,\n-            volatile,\n-            alignstack,\n-            dialect,\n-            ctxt: _, // This is used for error reporting\n-        } = *self.0;\n-\n-        asm.as_str().hash(state);\n-        asm_str_style.hash(state);\n-        outputs.len().hash(state);\n-        for output in outputs {\n-            let InlineAsmOutput { constraint, is_rw, is_indirect } = *output;\n-            constraint.as_str().hash(state);\n-            is_rw.hash(state);\n-            is_indirect.hash(state);\n-        }\n-        inputs.len().hash(state);\n-        for input in inputs {\n-            input.as_str().hash(state);\n-        }\n-        clobbers.len().hash(state);\n-        for clobber in clobbers {\n-            clobber.as_str().hash(state);\n-        }\n-        volatile.hash(state);\n-        alignstack.hash(state);\n-        dialect.hash(state);\n-    }\n-}\n-\n-macro_rules! hash_attrs {\n-    ($visitor:expr, $attrs:expr) => ({\n-        let attrs = $attrs;\n-        if attrs.len() > 0 {\n-            $visitor.hash_attributes(attrs);\n-        }\n-    })\n-}\n-\n-macro_rules! hash_span {\n-    ($visitor:expr, $span:expr) => ({\n-        hash_span!($visitor, $span, false)\n-    });\n-    ($visitor:expr, $span:expr, $force:expr) => ({\n-        if $force || $visitor.hash_spans {\n-            $visitor.hash_span($span);\n-        }\n-    });\n-}\n-\n-impl<'a, 'hash, 'tcx> Visitor<'tcx> for StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> visit::NestedVisitorMap<'this, 'tcx> {\n-        if self.hash_bodies {\n-            visit::NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n-        } else {\n-            visit::NestedVisitorMap::None\n-        }\n-    }\n-\n-    fn visit_variant_data(&mut self,\n-                          s: &'tcx VariantData,\n-                          name: Name,\n-                          _: &'tcx Generics,\n-                          _: NodeId,\n-                          span: Span) {\n-        debug!(\"visit_variant_data: st={:?}\", self.st);\n-        SawStructDef(name.as_str()).hash(self.st);\n-        hash_span!(self, span);\n-        visit::walk_struct_def(self, s);\n-    }\n-\n-    fn visit_variant(&mut self,\n-                     v: &'tcx Variant,\n-                     g: &'tcx Generics,\n-                     item_id: NodeId) {\n-        debug!(\"visit_variant: st={:?}\", self.st);\n-        SawVariant(v.node.disr_expr.is_some()).hash(self.st);\n-        hash_attrs!(self, &v.node.attrs);\n-        visit::walk_variant(self, v, g, item_id)\n-    }\n-\n-    fn visit_name(&mut self, span: Span, name: Name) {\n-        debug!(\"visit_name: st={:?}\", self.st);\n-        SawIdent(name.as_str()).hash(self.st);\n-        hash_span!(self, span);\n-    }\n-\n-    fn visit_lifetime(&mut self, l: &'tcx Lifetime) {\n-        debug!(\"visit_lifetime: st={:?}\", self.st);\n-        SawLifetime.hash(self.st);\n-        visit::walk_lifetime(self, l);\n-    }\n-\n-    fn visit_lifetime_def(&mut self, l: &'tcx LifetimeDef) {\n-        debug!(\"visit_lifetime_def: st={:?}\", self.st);\n-        SawLifetimeDef(l.bounds.len()).hash(self.st);\n-        visit::walk_lifetime_def(self, l);\n-    }\n-\n-    fn visit_expr(&mut self, ex: &'tcx Expr) {\n-        debug!(\"visit_expr: st={:?}\", self.st);\n-        let (saw_expr, force_span) = saw_expr(&ex.node,\n-                                              self.overflow_checks_enabled);\n-        SawExpr(saw_expr).hash(self.st);\n-        // No need to explicitly hash the discriminant here, since we are\n-        // implicitly hashing the discriminant of SawExprComponent.\n-        hash_span!(self, ex.span, force_span);\n-        hash_attrs!(self, &ex.attrs);\n-\n-        // Always hash nested constant bodies (e.g. n in `[x; n]`).\n-        let hash_bodies = self.hash_bodies;\n-        self.hash_bodies = true;\n-        visit::walk_expr(self, ex);\n-        self.hash_bodies = hash_bodies;\n-    }\n-\n-    fn visit_stmt(&mut self, s: &'tcx Stmt) {\n-        debug!(\"visit_stmt: st={:?}\", self.st);\n-\n-        // We don't want to modify the hash for decls, because\n-        // they might be item decls (if they are local decls,\n-        // we'll hash that fact in visit_local); but we do want to\n-        // remember if this was a StmtExpr or StmtSemi (the later\n-        // had an explicit semi-colon; this affects the typing\n-        // rules).\n-        match s.node {\n-            StmtDecl(..) => (),\n-            StmtExpr(..) => {\n-                SawStmt.hash(self.st);\n-                self.hash_discriminant(&s.node);\n-                hash_span!(self, s.span);\n-            }\n-            StmtSemi(..) => {\n-                SawStmt.hash(self.st);\n-                self.hash_discriminant(&s.node);\n-                hash_span!(self, s.span);\n-            }\n-        }\n-\n-        visit::walk_stmt(self, s)\n-    }\n-\n-    fn visit_foreign_item(&mut self, i: &'tcx ForeignItem) {\n-        debug!(\"visit_foreign_item: st={:?}\", self.st);\n-\n-        match i.node {\n-            ForeignItemFn(..) => {\n-                SawForeignItem(SawForeignItemComponent::Fn)\n-            }\n-            ForeignItemStatic(_, mutable) => {\n-                SawForeignItem(SawForeignItemComponent::Static {\n-                    mutable: mutable\n-                })\n-            }\n-        }.hash(self.st);\n-\n-        hash_span!(self, i.span);\n-        hash_attrs!(self, &i.attrs);\n-        visit::walk_foreign_item(self, i)\n-    }\n-\n-    fn visit_item(&mut self, i: &'tcx Item) {\n-        debug!(\"visit_item: {:?} st={:?}\", i, self.st);\n-\n-        self.maybe_enable_overflow_checks(&i.attrs);\n-\n-        SawItem(saw_item(&i.node)).hash(self.st);\n-        hash_span!(self, i.span);\n-        hash_attrs!(self, &i.attrs);\n-        visit::walk_item(self, i)\n-    }\n-\n-    fn visit_mod(&mut self, m: &'tcx Mod, span: Span, n: NodeId) {\n-        debug!(\"visit_mod: st={:?}\", self.st);\n-        SawMod.hash(self.st);\n-        hash_span!(self, span);\n-        visit::walk_mod(self, m, n)\n-    }\n-\n-    fn visit_ty(&mut self, t: &'tcx Ty) {\n-        debug!(\"visit_ty: st={:?}\", self.st);\n-        SawTy(saw_ty(&t.node)).hash(self.st);\n-        hash_span!(self, t.span);\n-\n-        // Always hash nested constant bodies (e.g. N in `[T; N]`).\n-        let hash_bodies = self.hash_bodies;\n-        self.hash_bodies = true;\n-        visit::walk_ty(self, t);\n-        self.hash_bodies = hash_bodies;\n-    }\n-\n-    fn visit_generics(&mut self, g: &'tcx Generics) {\n-        debug!(\"visit_generics: st={:?}\", self.st);\n-        SawGenerics.hash(self.st);\n-        visit::walk_generics(self, g)\n-    }\n-\n-    fn visit_fn_decl(&mut self, fd: &'tcx FnDecl) {\n-        debug!(\"visit_fn_decl: st={:?}\", self.st);\n-        SawFnDecl(fd.variadic).hash(self.st);\n-        visit::walk_fn_decl(self, fd)\n-    }\n-\n-    fn visit_trait_item(&mut self, ti: &'tcx TraitItem) {\n-        debug!(\"visit_trait_item: st={:?}\", self.st);\n-\n-        self.maybe_enable_overflow_checks(&ti.attrs);\n-\n-        SawTraitItem(saw_trait_item(&ti.node)).hash(self.st);\n-        hash_span!(self, ti.span);\n-        hash_attrs!(self, &ti.attrs);\n-        visit::walk_trait_item(self, ti)\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'tcx ImplItem) {\n-        debug!(\"visit_impl_item: st={:?}\", self.st);\n-\n-        self.maybe_enable_overflow_checks(&ii.attrs);\n-\n-        SawImplItem(saw_impl_item(&ii.node)).hash(self.st);\n-        hash_span!(self, ii.span);\n-        hash_attrs!(self, &ii.attrs);\n-        visit::walk_impl_item(self, ii)\n-    }\n-\n-    fn visit_struct_field(&mut self, s: &'tcx StructField) {\n-        debug!(\"visit_struct_field: st={:?}\", self.st);\n-        SawStructField.hash(self.st);\n-        hash_span!(self, s.span);\n-        hash_attrs!(self, &s.attrs);\n-        visit::walk_struct_field(self, s)\n-    }\n-\n-    fn visit_qpath(&mut self, qpath: &'tcx QPath, id: NodeId, span: Span) {\n-        debug!(\"visit_qpath: st={:?}\", self.st);\n-        SawQPath.hash(self.st);\n-        self.hash_discriminant(qpath);\n-        visit::walk_qpath(self, qpath, id, span)\n-    }\n-\n-    fn visit_path(&mut self, path: &'tcx Path, _: ast::NodeId) {\n-        debug!(\"visit_path: st={:?}\", self.st);\n-        hash_span!(self, path.span);\n-        visit::walk_path(self, path)\n-    }\n-\n-    fn visit_def_mention(&mut self, def: Def) {\n-        self.hash_def(def);\n-    }\n-\n-    fn visit_block(&mut self, b: &'tcx Block) {\n-        debug!(\"visit_block: st={:?}\", self.st);\n-        SawBlock.hash(self.st);\n-        hash_span!(self, b.span);\n-        visit::walk_block(self, b)\n-    }\n-\n-    fn visit_pat(&mut self, p: &'tcx Pat) {\n-        debug!(\"visit_pat: st={:?}\", self.st);\n-        SawPat(saw_pat(&p.node)).hash(self.st);\n-        hash_span!(self, p.span);\n-        visit::walk_pat(self, p)\n-    }\n-\n-    fn visit_local(&mut self, l: &'tcx Local) {\n-        debug!(\"visit_local: st={:?}\", self.st);\n-        SawLocal.hash(self.st);\n-        hash_attrs!(self, &l.attrs);\n-        visit::walk_local(self, l)\n-        // No need to hash span, we are hashing all component spans\n-    }\n-\n-    fn visit_arm(&mut self, a: &'tcx Arm) {\n-        debug!(\"visit_arm: st={:?}\", self.st);\n-        SawArm.hash(self.st);\n-        hash_attrs!(self, &a.attrs);\n-        visit::walk_arm(self, a)\n-    }\n-\n-    fn visit_id(&mut self, id: NodeId) {\n-        debug!(\"visit_id: id={} st={:?}\", id, self.st);\n-        self.hash_resolve(id)\n-    }\n-\n-    fn visit_vis(&mut self, v: &'tcx Visibility) {\n-        debug!(\"visit_vis: st={:?}\", self.st);\n-        SawVis.hash(self.st);\n-        self.hash_discriminant(v);\n-        visit::walk_vis(self, v)\n-    }\n-\n-    fn visit_associated_item_kind(&mut self, kind: &'tcx AssociatedItemKind) {\n-        debug!(\"visit_associated_item_kind: st={:?}\", self.st);\n-        SawAssociatedItemKind(*kind).hash(self.st);\n-        visit::walk_associated_item_kind(self, kind);\n-    }\n-\n-    fn visit_defaultness(&mut self, defaultness: &'tcx Defaultness) {\n-        debug!(\"visit_associated_item_kind: st={:?}\", self.st);\n-        SawDefaultness(*defaultness).hash(self.st);\n-        visit::walk_defaultness(self, defaultness);\n-    }\n-\n-    fn visit_where_predicate(&mut self, predicate: &'tcx WherePredicate) {\n-        debug!(\"visit_where_predicate: st={:?}\", self.st);\n-        SawWherePredicate.hash(self.st);\n-        self.hash_discriminant(predicate);\n-        // Ignoring span. Any important nested components should be visited.\n-        visit::walk_where_predicate(self, predicate)\n-    }\n-\n-    fn visit_ty_param_bound(&mut self, bounds: &'tcx TyParamBound) {\n-        debug!(\"visit_ty_param_bound: st={:?}\", self.st);\n-        SawTyParamBound.hash(self.st);\n-        self.hash_discriminant(bounds);\n-        // The TraitBoundModifier in TraitTyParamBound will be hash in\n-        // visit_poly_trait_ref()\n-        visit::walk_ty_param_bound(self, bounds)\n-    }\n-\n-    fn visit_poly_trait_ref(&mut self, t: &'tcx PolyTraitRef, m: TraitBoundModifier) {\n-        debug!(\"visit_poly_trait_ref: st={:?}\", self.st);\n-        SawPolyTraitRef.hash(self.st);\n-        m.hash(self.st);\n-        visit::walk_poly_trait_ref(self, t, m)\n-    }\n-\n-    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'tcx PathSegment) {\n-        debug!(\"visit_path_segment: st={:?}\", self.st);\n-        SawPathSegment.hash(self.st);\n-        visit::walk_path_segment(self, path_span, path_segment)\n-    }\n-\n-    fn visit_path_parameters(&mut self, path_span: Span, path_parameters: &'tcx PathParameters) {\n-        debug!(\"visit_path_parameters: st={:?}\", self.st);\n-        SawPathParameters.hash(self.st);\n-        self.hash_discriminant(path_parameters);\n-        visit::walk_path_parameters(self, path_span, path_parameters)\n-    }\n-\n-    fn visit_assoc_type_binding(&mut self, type_binding: &'tcx TypeBinding) {\n-        debug!(\"visit_assoc_type_binding: st={:?}\", self.st);\n-        SawAssocTypeBinding.hash(self.st);\n-        hash_span!(self, type_binding.span);\n-        visit::walk_assoc_type_binding(self, type_binding)\n-    }\n-\n-    fn visit_attribute(&mut self, _: &ast::Attribute) {\n-        // We explicitly do not use this method, since doing that would\n-        // implicitly impose an order on the attributes being hashed, while we\n-        // explicitly don't want their order to matter\n-    }\n-\n-    fn visit_macro_def(&mut self, macro_def: &'tcx MacroDef) {\n-        debug!(\"visit_macro_def: st={:?}\", self.st);\n-        SawMacroDef.hash(self.st);\n-        hash_attrs!(self, &macro_def.attrs);\n-        for tt in macro_def.body.trees() {\n-            self.hash_token_tree(&tt);\n-        }\n-        visit::walk_macro_def(self, macro_def)\n-    }\n-}\n-\n-#[derive(Hash)]\n-pub enum DefHash {\n-    SawDefId,\n-    SawLabel,\n-    SawPrimTy,\n-    SawSelfTy,\n-    SawErr,\n-}\n-\n-impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n-    fn hash_resolve(&mut self, id: ast::NodeId) {\n-        // Because whether or not a given id has an entry is dependent\n-        // solely on expr variant etc, we don't need to hash whether\n-        // or not an entry was present (we are already hashing what\n-        // variant it is above when we visit the HIR).\n-\n-        if let Some(traits) = self.tcx.trait_map.get(&id) {\n-            debug!(\"hash_resolve: id={:?} traits={:?} st={:?}\", id, traits, self.st);\n-            traits.len().hash(self.st);\n-\n-            // The ordering of the candidates is not fixed. So we hash\n-            // the def-ids and then sort them and hash the collection.\n-            let mut candidates: Vec<_> =\n-                traits.iter()\n-                      .map(|&TraitCandidate { def_id, import_id: _ }| {\n-                          self.compute_def_id_hash(def_id)\n-                      })\n-                      .collect();\n-            candidates.sort();\n-            candidates.hash(self.st);\n-        }\n-    }\n-\n-    fn hash_def_id(&mut self, def_id: DefId) {\n-        self.compute_def_id_hash(def_id).hash(self.st);\n-    }\n-\n-    fn hash_def(&mut self, def: Def) {\n-        match def {\n-            // Crucial point: for all of these variants, the variant +\n-            // add'l data that is added is always the same if the\n-            // def-id is the same, so it suffices to hash the def-id\n-            Def::Fn(..) |\n-            Def::Mod(..) |\n-            Def::Static(..) |\n-            Def::Variant(..) |\n-            Def::VariantCtor(..) |\n-            Def::Enum(..) |\n-            Def::TyAlias(..) |\n-            Def::AssociatedTy(..) |\n-            Def::TyParam(..) |\n-            Def::Struct(..) |\n-            Def::StructCtor(..) |\n-            Def::Union(..) |\n-            Def::Trait(..) |\n-            Def::Method(..) |\n-            Def::Const(..) |\n-            Def::AssociatedConst(..) |\n-            Def::Local(..) |\n-            Def::Upvar(..) |\n-            Def::Macro(..) => {\n-                DefHash::SawDefId.hash(self.st);\n-                self.hash_def_id(def.def_id());\n-            }\n-\n-            Def::Label(..) => {\n-                DefHash::SawLabel.hash(self.st);\n-                // we don't encode the `id` because it always refers to something\n-                // within this item, so if it changed, there would have to be other\n-                // changes too\n-            }\n-            Def::PrimTy(ref prim_ty) => {\n-                DefHash::SawPrimTy.hash(self.st);\n-                prim_ty.hash(self.st);\n-            }\n-            Def::SelfTy(..) => {\n-                DefHash::SawSelfTy.hash(self.st);\n-                // the meaning of Self is always the same within a\n-                // given context, so we don't need to hash the other\n-                // fields\n-            }\n-            Def::Err => {\n-                DefHash::SawErr.hash(self.st);\n-            }\n-        }\n-    }\n-\n-    pub fn hash_attributes(&mut self, attributes: &[ast::Attribute]) {\n-        debug!(\"hash_attributes: st={:?}\", self.st);\n-        let indices = self.indices_sorted_by(attributes, |attr| attr.name());\n-\n-        for i in indices {\n-            let attr = &attributes[i];\n-            match attr.name() {\n-                Some(name) if IGNORED_ATTRIBUTES.contains(&&*name.as_str()) => continue,\n-                _ => {}\n-            };\n-            if !attr.is_sugared_doc {\n-                SawAttribute(attr.style).hash(self.st);\n-                for segment in &attr.path.segments {\n-                    SawIdent(segment.identifier.name.as_str()).hash(self.st);\n-                }\n-                for tt in attr.tokens.trees() {\n-                    self.hash_token_tree(&tt);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn indices_sorted_by<T, K, F>(&mut self, items: &[T], get_key: F) -> Vec<usize>\n-        where K: Ord,\n-              F: Fn(&T) -> K\n-    {\n-        let mut indices = Vec::with_capacity(items.len());\n-        indices.extend(0 .. items.len());\n-        indices.sort_by_key(|index| get_key(&items[*index]));\n-        indices\n-    }\n-\n-    fn maybe_enable_overflow_checks(&mut self, item_attrs: &[ast::Attribute]) {\n-        if attr::contains_name(item_attrs, \"rustc_inherit_overflow_checks\") {\n-            self.overflow_checks_enabled = true;\n-        }\n-    }\n-\n-    fn hash_token_tree(&mut self, tt: &tokenstream::TokenTree) {\n-        self.hash_discriminant(tt);\n-        match *tt {\n-            tokenstream::TokenTree::Token(span, ref token) => {\n-                hash_span!(self, span);\n-                self.hash_token(token, span);\n-            }\n-            tokenstream::TokenTree::Delimited(span, ref delimited) => {\n-                hash_span!(self, span);\n-                delimited.delim.hash(self.st);\n-                for sub_tt in delimited.stream().trees() {\n-                    self.hash_token_tree(&sub_tt);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn hash_token(&mut self,\n-                  token: &token::Token,\n-                  error_reporting_span: Span) {\n-        self.hash_discriminant(token);\n-        match *token {\n-            token::Token::Eq |\n-            token::Token::Lt |\n-            token::Token::Le |\n-            token::Token::EqEq |\n-            token::Token::Ne |\n-            token::Token::Ge |\n-            token::Token::Gt |\n-            token::Token::AndAnd |\n-            token::Token::OrOr |\n-            token::Token::Not |\n-            token::Token::Tilde |\n-            token::Token::At |\n-            token::Token::Dot |\n-            token::Token::DotDot |\n-            token::Token::DotDotDot |\n-            token::Token::Comma |\n-            token::Token::Semi |\n-            token::Token::Colon |\n-            token::Token::ModSep |\n-            token::Token::RArrow |\n-            token::Token::LArrow |\n-            token::Token::FatArrow |\n-            token::Token::Pound |\n-            token::Token::Dollar |\n-            token::Token::Question |\n-            token::Token::Underscore |\n-            token::Token::Whitespace |\n-            token::Token::Comment |\n-            token::Token::Eof => {}\n-\n-            token::Token::BinOp(bin_op_token) |\n-            token::Token::BinOpEq(bin_op_token) => bin_op_token.hash(self.st),\n-\n-            token::Token::OpenDelim(delim_token) |\n-            token::Token::CloseDelim(delim_token) => delim_token.hash(self.st),\n-\n-            token::Token::Literal(ref lit, ref opt_name) => {\n-                self.hash_discriminant(lit);\n-                match *lit {\n-                    token::Lit::Byte(val) |\n-                    token::Lit::Char(val) |\n-                    token::Lit::Integer(val) |\n-                    token::Lit::Float(val) |\n-                    token::Lit::Str_(val) |\n-                    token::Lit::ByteStr(val) => val.as_str().hash(self.st),\n-                    token::Lit::StrRaw(val, n) |\n-                    token::Lit::ByteStrRaw(val, n) => {\n-                        val.as_str().hash(self.st);\n-                        n.hash(self.st);\n-                    }\n-                };\n-                opt_name.map(ast::Name::as_str).hash(self.st);\n-            }\n-\n-            token::Token::Ident(ident) |\n-            token::Token::Lifetime(ident) |\n-            token::Token::SubstNt(ident) => ident.name.as_str().hash(self.st),\n-\n-            token::Token::Interpolated(ref non_terminal) => {\n-                // FIXME(mw): This could be implemented properly. It's just a\n-                //            lot of work, since we would need to hash the AST\n-                //            in a stable way, in addition to the HIR.\n-                //            Since this is hardly used anywhere, just emit a\n-                //            warning for now.\n-                if self.tcx.sess.opts.debugging_opts.incremental.is_some() {\n-                    let msg = format!(\"Quasi-quoting might make incremental \\\n-                                       compilation very inefficient: {:?}\",\n-                                      non_terminal);\n-                    self.tcx.sess.span_warn(error_reporting_span, &msg[..]);\n-                }\n-\n-                non_terminal.hash(self.st);\n-            }\n-\n-            token::Token::DocComment(val) |\n-            token::Token::Shebang(val) => val.as_str().hash(self.st),\n-        }\n-    }\n-\n-    pub fn hash_crate_root_module(&mut self, krate: &'tcx Crate) {\n-        let hir::Crate {\n-            ref module,\n-            ref attrs,\n-            span,\n-\n-            // These fields are handled separately:\n-            exported_macros: _,\n-            items: _,\n-            trait_items: _,\n-            impl_items: _,\n-            bodies: _,\n-            trait_impls: _,\n-            trait_default_impl: _,\n-            body_ids: _,\n-        } = *krate;\n-\n-        visit::Visitor::visit_mod(self, module, span, ast::CRATE_NODE_ID);\n-        // Crate attributes are not copied over to the root `Mod`, so hash them\n-        // explicitly here.\n-        hash_attrs!(self, attrs);\n-    }\n-}"}, {"sha": "d10df17f85837bc251a7055f04f512704eb5d792", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=cce5c2d93ad4b33967c8f06f26c67e204c46c87b", "patch": "@@ -22,7 +22,6 @@\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(rand)]\n-#![feature(core_intrinsics)]\n #![feature(conservative_impl_trait)]\n #![cfg_attr(stage0, feature(pub_restricted))]\n "}, {"sha": "63cfe591ce366b6fefdd6367de221f214f12610d", "filename": "src/librustc_trans/assert_module_sources.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc_trans%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibrustc_trans%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fassert_module_sources.rs?ref=cce5c2d93ad4b33967c8f06f26c67e204c46c87b", "patch": "@@ -32,8 +32,7 @@ use syntax::ast;\n \n use {ModuleSource, ModuleTranslation};\n \n-const PARTITION_REUSED: &'static str = \"rustc_partition_reused\";\n-const PARTITION_TRANSLATED: &'static str = \"rustc_partition_translated\";\n+use rustc::ich::{ATTR_PARTITION_REUSED, ATTR_PARTITION_TRANSLATED};\n \n const MODULE: &'static str = \"module\";\n const CFG: &'static str = \"cfg\";\n@@ -62,9 +61,9 @@ struct AssertModuleSource<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n     fn check_attr(&self, attr: &ast::Attribute) {\n-        let disposition = if attr.check_name(PARTITION_REUSED) {\n+        let disposition = if attr.check_name(ATTR_PARTITION_REUSED) {\n             Disposition::Reused\n-        } else if attr.check_name(PARTITION_TRANSLATED) {\n+        } else if attr.check_name(ATTR_PARTITION_TRANSLATED) {\n             Disposition::Translated\n         } else {\n             return;"}, {"sha": "15111bbba0a92d6d04cdb03b0f0f5f09fcd09587", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=cce5c2d93ad4b33967c8f06f26c67e204c46c87b", "patch": "@@ -43,6 +43,8 @@ use std::{mem, ptr, slice, vec};\n \n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n+use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n+                                           HashStable};\n /// An owned smart pointer.\n #[derive(Hash, PartialEq, Eq, PartialOrd, Ord)]\n pub struct P<T: ?Sized> {\n@@ -215,3 +217,13 @@ impl<T: Decodable> Decodable for P<[T]> {\n         }))\n     }\n }\n+\n+impl<CTX, T> HashStable<CTX> for P<T>\n+    where T: ?Sized + HashStable<CTX>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        (**self).hash_stable(hcx, hasher);\n+    }\n+}"}, {"sha": "2d9fd7aa87553dc81ad73bb36f77fc3198ce781a", "filename": "src/libsyntax/util/rc_slice.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibsyntax%2Futil%2Frc_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce5c2d93ad4b33967c8f06f26c67e204c46c87b/src%2Flibsyntax%2Futil%2Frc_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Frc_slice.rs?ref=cce5c2d93ad4b33967c8f06f26c67e204c46c87b", "patch": "@@ -12,6 +12,9 @@ use std::fmt;\n use std::ops::Deref;\n use std::rc::Rc;\n \n+use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n+                                           HashStable};\n+\n #[derive(Clone)]\n pub struct RcSlice<T> {\n     data: Rc<Box<[T]>>,\n@@ -41,3 +44,13 @@ impl<T: fmt::Debug> fmt::Debug for RcSlice<T> {\n         fmt::Debug::fmt(self.deref(), f)\n     }\n }\n+\n+impl<CTX, T> HashStable<CTX> for RcSlice<T>\n+    where T: HashStable<CTX>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        (**self).hash_stable(hcx, hasher);\n+    }\n+}"}]}