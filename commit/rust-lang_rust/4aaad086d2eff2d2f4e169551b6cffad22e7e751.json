{"sha": "4aaad086d2eff2d2f4e169551b6cffad22e7e751", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhYWFkMDg2ZDJlZmYyZDJmNGUxNjk1NTFiNmNmZmFkMjJlN2U3NTE=", "commit": {"author": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-03-05T10:10:15Z"}, "committer": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-03-05T12:36:55Z"}, "message": "Fix dogfood errors in clippy_dev", "tree": {"sha": "c01a05e2070bbf88017eca5ae29e8222e63c71e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c01a05e2070bbf88017eca5ae29e8222e63c71e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4aaad086d2eff2d2f4e169551b6cffad22e7e751", "comment_count": 0, "verification": {"verified": false, "reason": "bad_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmBCJecACgkQHKDfKvWd\naKUxGw//Vkqzn2jw6zxEwnvaBJEYizIj5L3flqgY0qtMxwLxuvvZBQACu2pL3bk6\nUV4OfCXmO6APWQmMxwi1HG/Ogpbfc5nfAFHGHSJum2PDUDHcXoWXIrmYDHfEpqOh\ne6Fu4Ps5664XqAROPDJFy+drcyFZs09S27k21sS3Tkr9EzYlDVx7ESYN58uvd8oi\nQsE/tZoWgz5lYQiIkc/FlPWowil0heyDXUi9woxkDDItPa9ZdLs1hsVsJLMVtwZO\nbhbcpz4JzAZ+jHQeCJ5MkszxTVfo9fF78aXXP0w8h6THW7C8zSTrwzLUpsdznu6C\nlNgN/hTAMxWSJ/tIdCHuDyGRpnh1+nitLpaNNDRgIqi4Ge8NNGrx4N3VEIZQYyWZ\n4w4cSqhHYURjGtAf/SU23C+7FuyvZ7J3PU/tQUUPDd9YdJAU3N5CUHvgHjWEBDY9\n1liZAYSqkp8z7hhoNLIh+843CyksdrNguZjI3BBo3s8Vbz9SWpoe74GtZyYPxGtp\nzmbb6WRxDN+GBcpeNuWFKWKD13CF00i05gerNk1ighUfMDOMUNQaigV3kVWPpUPM\nmxwOUTn3+4xtEvnpG6SSfjUWHBnJ0xJ1o2IlUIur/KXchy+4HoJ30R3Mw2CuXRSN\nRTrTtVKIvPzQrvGW3MZXWyE3Zqlwdn3Qh8F49zRQ2zAJU92WzV0=\n=xvCB\n-----END PGP SIGNATURE-----", "payload": "tree c01a05e2070bbf88017eca5ae29e8222e63c71e0\nparent 1d71d9a106e12bd90f0f3be86e43736f89acc975\nauthor flip1995 <philipp.krones@embecosm.com> 1614939015 +0100\ncommitter flip1995 <philipp.krones@embecosm.com> 1614947815 +0100\n\nFix dogfood errors in clippy_dev\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4aaad086d2eff2d2f4e169551b6cffad22e7e751", "html_url": "https://github.com/rust-lang/rust/commit/4aaad086d2eff2d2f4e169551b6cffad22e7e751", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4aaad086d2eff2d2f4e169551b6cffad22e7e751/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d71d9a106e12bd90f0f3be86e43736f89acc975", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d71d9a106e12bd90f0f3be86e43736f89acc975", "html_url": "https://github.com/rust-lang/rust/commit/1d71d9a106e12bd90f0f3be86e43736f89acc975"}], "stats": {"total": 70, "additions": 41, "deletions": 29}, "files": [{"sha": "0244ff2b6c27bd262d2e12178233dfdf65497814", "filename": "clippy_dev/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4aaad086d2eff2d2f4e169551b6cffad22e7e751/clippy_dev%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aaad086d2eff2d2f4e169551b6cffad22e7e751/clippy_dev%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Flib.rs?ref=4aaad086d2eff2d2f4e169551b6cffad22e7e751", "patch": "@@ -530,7 +530,7 @@ fn test_gen_deprecated() {\n #[should_panic]\n fn test_gen_deprecated_fail() {\n     let lints = vec![Lint::new(\"should_assert_eq2\", \"group2\", \"abc\", None, \"module_name\")];\n-    let _ = gen_deprecated(lints.iter());\n+    let _deprecated_lints = gen_deprecated(lints.iter());\n }\n \n #[test]"}, {"sha": "81b86481f5709cf4ddc54318040e3633f0617700", "filename": "clippy_dev/src/lintcheck.rs", "status": "modified", "additions": 40, "deletions": 28, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/4aaad086d2eff2d2f4e169551b6cffad22e7e751/clippy_dev%2Fsrc%2Flintcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aaad086d2eff2d2f4e169551b6cffad22e7e751/clippy_dev%2Fsrc%2Flintcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Flintcheck.rs?ref=4aaad086d2eff2d2f4e169551b6cffad22e7e751", "patch": "@@ -6,13 +6,12 @@\n \n #![cfg(feature = \"lintcheck\")]\n #![allow(clippy::filter_map, clippy::collapsible_else_if)]\n-#![allow(clippy::blocks_in_if_conditions)] // FP on `if x.iter().any(|x| ...)`\n \n use crate::clippy_project_root;\n \n-use std::collections::HashMap;\n use std::process::Command;\n use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::{collections::HashMap, io::ErrorKind};\n use std::{\n     env, fmt,\n     fs::write,\n@@ -116,9 +115,21 @@ impl CrateSource {\n                 // url to download the crate from crates.io\n                 let url = format!(\"https://crates.io/api/v1/crates/{}/{}/download\", name, version);\n                 println!(\"Downloading and extracting {} {} from {}\", name, version, url);\n-                let _ = std::fs::create_dir(\"target/lintcheck/\");\n-                let _ = std::fs::create_dir(&krate_download_dir);\n-                let _ = std::fs::create_dir(&extract_dir);\n+                std::fs::create_dir(\"target/lintcheck/\").unwrap_or_else(|err| {\n+                    if err.kind() != ErrorKind::AlreadyExists {\n+                        panic!(\"cannot create lintcheck target dir\");\n+                    }\n+                });\n+                std::fs::create_dir(&krate_download_dir).unwrap_or_else(|err| {\n+                    if err.kind() != ErrorKind::AlreadyExists {\n+                        panic!(\"cannot create crate download dir\");\n+                    }\n+                });\n+                std::fs::create_dir(&extract_dir).unwrap_or_else(|err| {\n+                    if err.kind() != ErrorKind::AlreadyExists {\n+                        panic!(\"cannot create crate extraction dir\");\n+                    }\n+                });\n \n                 let krate_file_path = krate_download_dir.join(format!(\"{}-{}.crate.tar.gz\", name, version));\n                 // don't download/extract if we already have done so\n@@ -198,18 +209,18 @@ impl CrateSource {\n                 // the source path of the crate we copied,  ${copy_dest}/crate_name\n                 let crate_root = copy_dest.join(name); // .../crates/local_crate\n \n-                if !crate_root.exists() {\n-                    println!(\"Copying {} to {}\", path.display(), copy_dest.display());\n-\n-                    dir::copy(path, &copy_dest, &dir::CopyOptions::new()).unwrap_or_else(|_| {\n-                        panic!(\"Failed to copy from {}, to  {}\", path.display(), crate_root.display())\n-                    });\n-                } else {\n+                if crate_root.exists() {\n                     println!(\n                         \"Not copying {} to {}, destination already exists\",\n                         path.display(),\n                         crate_root.display()\n                     );\n+                } else {\n+                    println!(\"Copying {} to {}\", path.display(), copy_dest.display());\n+\n+                    dir::copy(path, &copy_dest, &dir::CopyOptions::new()).unwrap_or_else(|_| {\n+                        panic!(\"Failed to copy from {}, to  {}\", path.display(), crate_root.display())\n+                    });\n                 }\n \n                 Crate {\n@@ -236,8 +247,8 @@ impl Crate {\n         // advance the atomic index by one\n         let index = target_dir_index.fetch_add(1, Ordering::SeqCst);\n         // \"loop\" the index within 0..thread_limit\n-        let target_dir_index = index % thread_limit;\n-        let perc = ((index * 100) as f32 / total_crates_to_lint as f32) as u8;\n+        let thread_index = index % thread_limit;\n+        let perc = (index * 100) / total_crates_to_lint;\n \n         if thread_limit == 1 {\n             println!(\n@@ -247,7 +258,7 @@ impl Crate {\n         } else {\n             println!(\n                 \"{}/{} {}% Linting {} {} in target dir {:?}\",\n-                index, total_crates_to_lint, perc, &self.name, &self.version, target_dir_index\n+                index, total_crates_to_lint, perc, &self.name, &self.version, thread_index\n             );\n         }\n \n@@ -269,7 +280,7 @@ impl Crate {\n             // use the looping index to create individual target dirs\n             .env(\n                 \"CARGO_TARGET_DIR\",\n-                shared_target_dir.join(format!(\"_{:?}\", target_dir_index)),\n+                shared_target_dir.join(format!(\"_{:?}\", thread_index)),\n             )\n             // lint warnings will look like this:\n             // src/cargo/ops/cargo_compile.rs:127:35: warning: usage of `FromIterator::from_iter`\n@@ -529,6 +540,10 @@ fn lintcheck_needs_rerun(lintcheck_logs_path: &Path) -> bool {\n }\n \n /// lintchecks `main()` function\n+///\n+/// # Panics\n+///\n+/// This function panics if the clippy binaries don't exist.\n pub fn run(clap_config: &ArgMatches) {\n     let config = LintcheckConfig::from_clap(clap_config);\n \n@@ -579,9 +594,9 @@ pub fn run(clap_config: &ArgMatches) {\n         // if we don't have the specified crate in the .toml, throw an error\n         if !crates.iter().any(|krate| {\n             let name = match krate {\n-                CrateSource::CratesIo { name, .. } => name,\n-                CrateSource::Git { name, .. } => name,\n-                CrateSource::Path { name, .. } => name,\n+                CrateSource::CratesIo { name, .. } | CrateSource::Git { name, .. } | CrateSource::Path { name, .. } => {\n+                    name\n+                },\n             };\n             name == only_one_crate\n         }) {\n@@ -597,8 +612,7 @@ pub fn run(clap_config: &ArgMatches) {\n             .into_iter()\n             .map(|krate| krate.download_and_extract())\n             .filter(|krate| krate.name == only_one_crate)\n-            .map(|krate| krate.run_clippy_lints(&cargo_clippy_path, &AtomicUsize::new(0), 1, 1))\n-            .flatten()\n+            .flat_map(|krate| krate.run_clippy_lints(&cargo_clippy_path, &AtomicUsize::new(0), 1, 1))\n             .collect()\n     } else {\n         if config.max_jobs > 1 {\n@@ -621,17 +635,15 @@ pub fn run(clap_config: &ArgMatches) {\n             crates\n                 .into_par_iter()\n                 .map(|krate| krate.download_and_extract())\n-                .map(|krate| krate.run_clippy_lints(&cargo_clippy_path, &counter, num_cpus, num_crates))\n-                .flatten()\n+                .flat_map(|krate| krate.run_clippy_lints(&cargo_clippy_path, &counter, num_cpus, num_crates))\n                 .collect()\n         } else {\n             // run sequential\n             let num_crates = crates.len();\n             crates\n                 .into_iter()\n                 .map(|krate| krate.download_and_extract())\n-                .map(|krate| krate.run_clippy_lints(&cargo_clippy_path, &counter, 1, num_crates))\n-                .flatten()\n+                .flat_map(|krate| krate.run_clippy_lints(&cargo_clippy_path, &counter, 1, num_crates))\n                 .collect()\n         }\n     };\n@@ -646,7 +658,7 @@ pub fn run(clap_config: &ArgMatches) {\n         .map(|w| (&w.crate_name, &w.message))\n         .collect();\n \n-    let mut all_msgs: Vec<String> = clippy_warnings.iter().map(|warning| warning.to_string()).collect();\n+    let mut all_msgs: Vec<String> = clippy_warnings.iter().map(ToString::to_string).collect();\n     all_msgs.sort();\n     all_msgs.push(\"\\n\\n\\n\\nStats:\\n\".into());\n     all_msgs.push(stats_formatted);\n@@ -673,13 +685,13 @@ fn read_stats_from_file(file_path: &Path) -> HashMap<String, usize> {\n         },\n     };\n \n-    let lines: Vec<String> = file_content.lines().map(|l| l.to_string()).collect();\n+    let lines: Vec<String> = file_content.lines().map(ToString::to_string).collect();\n \n     // search for the beginning \"Stats:\" and the end \"ICEs:\" of the section we want\n     let start = lines.iter().position(|line| line == \"Stats:\").unwrap();\n     let end = lines.iter().position(|line| line == \"ICEs:\").unwrap();\n \n-    let stats_lines = &lines[start + 1..=end - 1];\n+    let stats_lines = &lines[start + 1..end];\n \n     stats_lines\n         .iter()"}]}