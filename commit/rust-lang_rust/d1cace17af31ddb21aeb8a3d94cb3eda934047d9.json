{"sha": "d1cace17af31ddb21aeb8a3d94cb3eda934047d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxY2FjZTE3YWYzMWRkYjIxYWViOGEzZDk0Y2IzZWRhOTM0MDQ3ZDk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-10-23T05:07:19Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-01-30T00:25:20Z"}, "message": "trans: Upgrade LLVM\n\nThis brings some routine upgrades to the bundled LLVM that we're using, the most\nnotable of which is a bug fix to the way we handle range asserts when loading\nthe discriminant of an enum. This fix ended up being very similar to f9d4149c\nwhere we basically can't have a range assert when loading a discriminant due to\nfilling drop, and appropriate flags were added to communicate this to\n`trans::adt`.", "tree": {"sha": "90a8ea64593d7d5330cc1466ba13db135e0b593d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90a8ea64593d7d5330cc1466ba13db135e0b593d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1cace17af31ddb21aeb8a3d94cb3eda934047d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1cace17af31ddb21aeb8a3d94cb3eda934047d9", "html_url": "https://github.com/rust-lang/rust/commit/d1cace17af31ddb21aeb8a3d94cb3eda934047d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "142214d1f2232a4e88ff7bd99951b01f36052c61", "url": "https://api.github.com/repos/rust-lang/rust/commits/142214d1f2232a4e88ff7bd99951b01f36052c61", "html_url": "https://github.com/rust-lang/rust/commit/142214d1f2232a4e88ff7bd99951b01f36052c61"}], "stats": {"total": 168, "additions": 124, "deletions": 44}, "files": [{"sha": "be7f0ed6a0298dd8b46e80a683684f9f7f7e2998", "filename": "src/librustc_llvm/archive_ro.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Flibrustc_llvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Flibrustc_llvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Farchive_ro.rs?ref=d1cace17af31ddb21aeb8a3d94cb3eda934047d9", "patch": "@@ -79,14 +79,14 @@ impl Drop for ArchiveRO {\n }\n \n impl<'a> Iterator for Iter<'a> {\n-    type Item = Child<'a>;\n+    type Item = Result<Child<'a>, String>;\n \n-    fn next(&mut self) -> Option<Child<'a>> {\n+    fn next(&mut self) -> Option<Result<Child<'a>, String>> {\n         let ptr = unsafe { ::LLVMRustArchiveIteratorNext(self.ptr) };\n         if ptr.is_null() {\n-            None\n+            ::last_error().map(Err)\n         } else {\n-            Some(Child { ptr: ptr, _data: marker::PhantomData })\n+            Some(Ok(Child { ptr: ptr, _data: marker::PhantomData }))\n         }\n     }\n }"}, {"sha": "32009b0f29da3f3df09b7ddf2257be97725c58f9", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=d1cace17af31ddb21aeb8a3d94cb3eda934047d9", "patch": "@@ -56,7 +56,7 @@ pub use self::DiagnosticSeverity::*;\n pub use self::Linkage::*;\n pub use self::DLLStorageClassTypes::*;\n \n-use std::ffi::CString;\n+use std::ffi::{CString, CStr};\n use std::cell::RefCell;\n use std::slice;\n use libc::{c_uint, c_ushort, uint64_t, c_int, size_t, c_char};\n@@ -2404,6 +2404,20 @@ pub fn initialize_available_targets() {\n     init_pnacl();\n }\n \n+pub fn last_error() -> Option<String> {\n+    unsafe {\n+        let cstr = LLVMRustGetLastError();\n+        if cstr.is_null() {\n+            None\n+        } else {\n+            let err = CStr::from_ptr(cstr).to_bytes();\n+            let err = String::from_utf8_lossy(err).to_string();\n+            libc::free(cstr as *mut _);\n+            Some(err)\n+        }\n+    }\n+}\n+\n // The module containing the native LLVM dependencies, generated by the build system\n // Note that this must come after the rustllvm extern declaration so that\n // parts of LLVM that rustllvm depends on aren't thrown away by the linker."}, {"sha": "07a736d9959c853144e32c1abb97c3075a92338d", "filename": "src/librustc_metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Flibrustc_metadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Flibrustc_metadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Floader.rs?ref=d1cace17af31ddb21aeb8a3d94cb3eda934047d9", "patch": "@@ -729,7 +729,7 @@ pub fn note_crate_name(err: &mut DiagnosticBuilder, name: &str) {\n impl ArchiveMetadata {\n     fn new(ar: ArchiveRO) -> Option<ArchiveMetadata> {\n         let data = {\n-            let section = ar.iter().find(|sect| {\n+            let section = ar.iter().filter_map(|s| s.ok()).find(|sect| {\n                 sect.name() == Some(METADATA_FILENAME)\n             });\n             match section {"}, {"sha": "df902fbaff4d6b97789f27e65c61d2a92106f830", "filename": "src/librustc_trans/back/archive.rs", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=d1cace17af31ddb21aeb8a3d94cb3eda934047d9", "patch": "@@ -124,6 +124,7 @@ impl<'a> ArchiveBuilder<'a> {\n         }\n         let archive = self.src_archive.as_ref().unwrap().as_ref().unwrap();\n         let ret = archive.iter()\n+                         .filter_map(|child| child.ok())\n                          .filter(is_relevant_child)\n                          .filter_map(|child| child.name())\n                          .filter(|name| !self.removals.iter().any(|x| x == name))\n@@ -332,9 +333,15 @@ impl<'a> ArchiveBuilder<'a> {\n         // We skip any files explicitly desired for skipping, and we also skip\n         // all SYMDEF files as these are just magical placeholders which get\n         // re-created when we make a new archive anyway.\n-        for file in archive.iter().filter(is_relevant_child) {\n+        for file in archive.iter() {\n+            let file = try!(file.map_err(string2io));\n+            if !is_relevant_child(&file) {\n+                continue\n+            }\n             let filename = file.name().unwrap();\n-            if skip(filename) { continue }\n+            if skip(filename) {\n+                continue\n+            }\n             let filename = Path::new(filename).file_name().unwrap()\n                                               .to_str().unwrap();\n \n@@ -448,6 +455,7 @@ impl<'a> ArchiveBuilder<'a> {\n         unsafe {\n             if let Some(archive) = self.src_archive() {\n                 for child in archive.iter() {\n+                    let child = try!(child.map_err(string2io));\n                     let child_name = match child.name() {\n                         Some(s) => s,\n                         None => continue,\n@@ -475,10 +483,25 @@ impl<'a> ArchiveBuilder<'a> {\n                         strings.push(name);\n                     }\n                     Addition::Archive { archive, archive_name: _, mut skip } => {\n-                        for child in archive.iter().filter(is_relevant_child) {\n+                        for child in archive.iter() {\n+                            let child = try!(child.map_err(string2io));\n+                            if !is_relevant_child(&child) {\n+                                continue\n+                            }\n                             let child_name = child.name().unwrap();\n-                            if skip(child_name) { continue }\n-\n+                            if skip(child_name) {\n+                                continue\n+                            }\n+\n+                            // It appears that LLVM's archive writer is a little\n+                            // buggy if the name we pass down isn't just the\n+                            // filename component, so chop that off here and\n+                            // pass it in.\n+                            //\n+                            // See LLVM bug 25877 for more info.\n+                            let child_name = Path::new(child_name)\n+                                                  .file_name().unwrap()\n+                                                  .to_str().unwrap();\n                             let name = try!(CString::new(child_name));\n                             let m = llvm::LLVMRustArchiveMemberNew(ptr::null(),\n                                                                    name.as_ptr(),\n@@ -517,3 +540,7 @@ impl<'a> ArchiveBuilder<'a> {\n         }\n     }\n }\n+\n+fn string2io(s: String) -> io::Error {\n+    io::Error::new(io::ErrorKind::Other, format!(\"bad archive: {}\", s))\n+}"}, {"sha": "649d37e802d149edfcb00715883b52a14eb3b6ab", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=d1cace17af31ddb21aeb8a3d94cb3eda934047d9", "patch": "@@ -52,7 +52,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n     link::each_linked_rlib(sess, &mut |_, path| {\n         let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n         let bytecodes = archive.iter().filter_map(|child| {\n-            child.name().map(|name| (name, child))\n+            child.ok().and_then(|c| c.name().map(|name| (name, c)))\n         }).filter(|&(name, _)| name.ends_with(\"bytecode.deflate\"));\n         for (name, data) in bytecodes {\n             let bc_encoded = data.data();"}, {"sha": "1bbc0a5b04d3630ba7846b15222d0b9cd9116f6b", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=d1cace17af31ddb21aeb8a3d94cb3eda934047d9", "patch": "@@ -27,24 +27,16 @@ use std::collections::HashMap;\n use std::ffi::{CStr, CString};\n use std::fs;\n use std::path::{Path, PathBuf};\n-use std::ptr;\n use std::str;\n use std::sync::{Arc, Mutex};\n use std::sync::mpsc::channel;\n use std::thread;\n-use libc::{self, c_uint, c_int, c_void};\n+use libc::{c_uint, c_int, c_void};\n \n pub fn llvm_err(handler: &errors::Handler, msg: String) -> ! {\n-    unsafe {\n-        let cstr = llvm::LLVMRustGetLastError();\n-        if cstr == ptr::null() {\n-            panic!(handler.fatal(&msg[..]));\n-        } else {\n-            let err = CStr::from_ptr(cstr).to_bytes();\n-            let err = String::from_utf8_lossy(err).to_string();\n-            libc::free(cstr as *mut _);\n-            panic!(handler.fatal(&format!(\"{}: {}\", &msg[..], &err[..])));\n-        }\n+    match llvm::last_error() {\n+        Some(err) => panic!(handler.fatal(&format!(\"{}: {}\", msg, err))),\n+        None => panic!(handler.fatal(&msg)),\n     }\n }\n "}, {"sha": "851ff33cf9327fce00f9057dc9578eaa1b1bd187", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=d1cace17af31ddb21aeb8a3d94cb3eda934047d9", "patch": "@@ -1271,7 +1271,8 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 };\n             }\n             Variant(_, ref repr, _, _) => {\n-                let (the_kind, val_opt) = adt::trans_switch(bcx, &**repr, val.val);\n+                let (the_kind, val_opt) = adt::trans_switch(bcx, &repr,\n+                                                            val.val, true);\n                 kind = the_kind;\n                 if let Some(tval) = val_opt { test_val = tval; }\n             }"}, {"sha": "ae42134813ec85910fca00706b9e27863184f4f0", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=d1cace17af31ddb21aeb8a3d94cb3eda934047d9", "patch": "@@ -890,12 +890,15 @@ fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, st: &Struct<'tcx>,\n ///\n /// This should ideally be less tightly tied to `_match`.\n pub fn trans_switch<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                r: &Repr<'tcx>, scrutinee: ValueRef)\n+                                r: &Repr<'tcx>,\n+                                scrutinee: ValueRef,\n+                                range_assert: bool)\n                                 -> (_match::BranchKind, Option<ValueRef>) {\n     match *r {\n         CEnum(..) | General(..) |\n         RawNullablePointer { .. } | StructWrappedNullablePointer { .. } => {\n-            (_match::Switch, Some(trans_get_discr(bcx, r, scrutinee, None)))\n+            (_match::Switch, Some(trans_get_discr(bcx, r, scrutinee, None,\n+                                                  range_assert)))\n         }\n         Univariant(..) => {\n             // N.B.: Univariant means <= 1 enum variants (*not* == 1 variants).\n@@ -916,14 +919,18 @@ pub fn is_discr_signed<'tcx>(r: &Repr<'tcx>) -> bool {\n \n /// Obtain the actual discriminant of a value.\n pub fn trans_get_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n-                                   scrutinee: ValueRef, cast_to: Option<Type>)\n+                                   scrutinee: ValueRef, cast_to: Option<Type>,\n+                                   range_assert: bool)\n     -> ValueRef {\n     debug!(\"trans_get_discr r: {:?}\", r);\n     let val = match *r {\n-        CEnum(ity, min, max) => load_discr(bcx, ity, scrutinee, min, max),\n+        CEnum(ity, min, max) => {\n+            load_discr(bcx, ity, scrutinee, min, max, range_assert)\n+        }\n         General(ity, ref cases, _) => {\n             let ptr = StructGEP(bcx, scrutinee, 0);\n-            load_discr(bcx, ity, ptr, Disr(0), Disr(cases.len() as u64 - 1))\n+            load_discr(bcx, ity, ptr, Disr(0), Disr(cases.len() as u64 - 1),\n+                       range_assert)\n         }\n         Univariant(..) => C_u8(bcx.ccx(), 0),\n         RawNullablePointer { nndiscr, nnty, .. } =>  {\n@@ -950,7 +957,8 @@ fn struct_wrapped_nullable_bitdiscr(bcx: Block, nndiscr: Disr, discrfield: &Disc\n }\n \n /// Helper for cases where the discriminant is simply loaded.\n-fn load_discr(bcx: Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr)\n+fn load_discr(bcx: Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr,\n+              range_assert: bool)\n     -> ValueRef {\n     let llty = ll_inttype(bcx.ccx(), ity);\n     assert_eq!(val_ty(ptr), llty.ptr_to());\n@@ -960,7 +968,7 @@ fn load_discr(bcx: Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr)\n     let mask = Disr(!0u64 >> (64 - bits));\n     // For a (max) discr of -1, max will be `-1 as usize`, which overflows.\n     // However, that is fine here (it would still represent the full range),\n-    if max.wrapping_add(Disr(1)) & mask == min & mask {\n+    if max.wrapping_add(Disr(1)) & mask == min & mask || !range_assert {\n         // i.e., if the range is everything.  The lo==hi case would be\n         // rejected by the LLVM verifier (it would mean either an\n         // empty set, which is impossible, or the entire range of the\n@@ -1239,10 +1247,14 @@ pub fn fold_variants<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             // runtime, so the basic block isn't actually unreachable, so we\n             // need to make it do something with defined behavior. In this case\n             // we just return early from the function.\n+            //\n+            // Note that this is also why the `trans_get_discr` below has\n+            // `false` to indicate that loading the discriminant should\n+            // not have a range assert.\n             let ret_void_cx = fcx.new_temp_block(\"enum-variant-iter-ret-void\");\n             RetVoid(ret_void_cx, DebugLoc::None);\n \n-            let discr_val = trans_get_discr(bcx, r, value, None);\n+            let discr_val = trans_get_discr(bcx, r, value, None, false);\n             let llswitch = Switch(bcx, discr_val, ret_void_cx.llbb, cases.len());\n             let bcx_next = fcx.new_temp_block(\"enum-variant-iter-next\");\n "}, {"sha": "9c25284eb60cf113adb6974f105da58b54e3b5df", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=d1cace17af31ddb21aeb8a3d94cb3eda934047d9", "patch": "@@ -556,7 +556,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n             // NB: we must hit the discriminant first so that structural\n             // comparison know not to proceed when the discriminants differ.\n \n-            match adt::trans_switch(cx, &*repr, av) {\n+            match adt::trans_switch(cx, &*repr, av, false) {\n                 (_match::Single, None) => {\n                     if n_variants != 0 {\n                         assert!(n_variants == 1);"}, {"sha": "30cbe6eeee4f4902fd98d7f57ada5e467e10bbea", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=d1cace17af31ddb21aeb8a3d94cb3eda934047d9", "patch": "@@ -2116,7 +2116,8 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let datum = unpack_datum!(\n             bcx, datum.to_lvalue_datum(bcx, \"trans_imm_cast\", expr.id));\n         let llexpr_ptr = datum.to_llref();\n-        let discr = adt::trans_get_discr(bcx, &*repr, llexpr_ptr, Some(Type::i64(ccx)));\n+        let discr = adt::trans_get_discr(bcx, &*repr, llexpr_ptr,\n+                                         Some(Type::i64(ccx)), true);\n         ll_t_in = val_ty(discr);\n         (discr, adt::is_discr_signed(&*repr))\n     } else {"}, {"sha": "629ea6f1c2f55d5bb24da274f3fbc2a26e5dee1c", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=d1cace17af31ddb21aeb8a3d94cb3eda934047d9", "patch": "@@ -655,7 +655,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             match val_ty.sty {\n                 ty::TyEnum(..) => {\n                     let repr = adt::represent_type(ccx, *val_ty);\n-                    adt::trans_get_discr(bcx, &*repr, llargs[0], Some(llret_ty))\n+                    adt::trans_get_discr(bcx, &*repr, llargs[0],\n+                                         Some(llret_ty), true)\n                 }\n                 _ => C_null(llret_ty)\n             }"}, {"sha": "0dadcf54bf3eefc27aaee93f5b24f5b30c6ab3fb", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=d1cace17af31ddb21aeb8a3d94cb3eda934047d9", "patch": "@@ -55,7 +55,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let discr_lvalue = self.trans_lvalue(bcx, discr);\n                 let ty = discr_lvalue.ty.to_ty(bcx.tcx());\n                 let repr = adt::represent_type(bcx.ccx(), ty);\n-                let discr = adt::trans_get_discr(bcx, &repr, discr_lvalue.llval, None);\n+                let discr = adt::trans_get_discr(bcx, &repr, discr_lvalue.llval,\n+                                                 None, true);\n \n                 // The else branch of the Switch can't be hit, so branch to an unreachable\n                 // instruction so LLVM knows that"}, {"sha": "de5c31045dc0f6da1f65d02ee640ccf99ba90e7c", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=d1cace17af31ddb21aeb8a3d94cb3eda934047d9", "patch": "@@ -1 +1 @@\n-Subproject commit 3564439515985dc1cc0d77057ed00901635a80ad\n+Subproject commit de5c31045dc0f6da1f65d02ee640ccf99ba90e7c"}, {"sha": "d3f2907bfc31cbb1e7c076f649794d5859663ff3", "filename": "src/rustllvm/ArchiveWrapper.cpp", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Frustllvm%2FArchiveWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Frustllvm%2FArchiveWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FArchiveWrapper.cpp?ref=d1cace17af31ddb21aeb8a3d94cb3eda934047d9", "patch": "@@ -24,7 +24,13 @@ struct LLVMRustArchiveMember {\n   const char *name;\n   Archive::Child child;\n \n-  LLVMRustArchiveMember(): filename(NULL), name(NULL), child(NULL, NULL) {}\n+  LLVMRustArchiveMember(): filename(NULL), name(NULL),\n+#if LLVM_VERSION_MINOR >= 8\n+    child(NULL, NULL, NULL)\n+#else\n+    child(NULL, NULL)\n+#endif\n+  {}\n   ~LLVMRustArchiveMember() {}\n };\n \n@@ -92,8 +98,18 @@ extern \"C\" const Archive::Child*\n LLVMRustArchiveIteratorNext(RustArchiveIterator *rai) {\n     if (rai->cur == rai->end)\n         return NULL;\n-    const Archive::Child *cur = rai->cur.operator->();\n-    Archive::Child *ret = new Archive::Child(*cur);\n+#if LLVM_VERSION_MINOR >= 8\n+    const ErrorOr<Archive::Child>* cur = rai->cur.operator->();\n+    if (!*cur) {\n+        LLVMRustSetLastError(cur->getError().message().c_str());\n+        return NULL;\n+    }\n+    const Archive::Child &child = cur->get();\n+#else\n+    const Archive::Child &child = *rai->cur.operator->();\n+#endif\n+    Archive::Child *ret = new Archive::Child(child);\n+\n     ++rai->cur;\n     return ret;\n }"}, {"sha": "a625a75933dc91900b7bacb2c8aaee2f791b9fce", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=d1cace17af31ddb21aeb8a3d94cb3eda934047d9", "patch": "@@ -348,6 +348,19 @@ extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateFunction(\n     LLVMValueRef Fn,\n     LLVMMetadataRef TParam,\n     LLVMMetadataRef Decl) {\n+#if LLVM_VERSION_MINOR >= 8\n+    DITemplateParameterArray TParams =\n+        DITemplateParameterArray(unwrap<MDTuple>(TParam));\n+    DISubprogram *Sub = Builder->createFunction(\n+        unwrapDI<DIScope>(Scope), Name, LinkageName,\n+        unwrapDI<DIFile>(File), LineNo,\n+        unwrapDI<DISubroutineType>(Ty), isLocalToUnit, isDefinition, ScopeLine,\n+        Flags, isOptimized,\n+        TParams,\n+        unwrapDIptr<DISubprogram>(Decl));\n+    unwrap<Function>(Fn)->setSubprogram(Sub);\n+    return wrap(Sub);\n+#else\n     return wrap(Builder->createFunction(\n         unwrapDI<DIScope>(Scope), Name, LinkageName,\n         unwrapDI<DIFile>(File), LineNo,\n@@ -356,6 +369,7 @@ extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateFunction(\n         unwrap<Function>(Fn),\n         unwrapDIptr<MDNode>(TParam),\n         unwrapDIptr<MDNode>(Decl)));\n+#endif\n }\n \n extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateBasicType(\n@@ -830,7 +844,9 @@ LLVMRustLinkInExternalBitcode(LLVMModuleRef dst, char *bc, size_t len) {\n #if LLVM_VERSION_MINOR >= 6\n     raw_string_ostream Stream(Err);\n     DiagnosticPrinterRawOStream DP(Stream);\n-#if LLVM_VERSION_MINOR >= 7\n+#if LLVM_VERSION_MINOR >= 8\n+    if (Linker::linkModules(*Dst, std::move(Src.get()))) {\n+#elif LLVM_VERSION_MINOR >= 7\n     if (Linker::LinkModules(Dst, Src->get(), [&](const DiagnosticInfo &DI) { DI.print(DP); })) {\n #else\n     if (Linker::LinkModules(Dst, *Src, [&](const DiagnosticInfo &DI) { DI.print(DP); })) {"}, {"sha": "7df7df505cd2000cd88d3a5599eaf8823cc58bc1", "filename": "src/rustllvm/llvm-auto-clean-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Frustllvm%2Fllvm-auto-clean-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Frustllvm%2Fllvm-auto-clean-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-auto-clean-trigger?ref=d1cace17af31ddb21aeb8a3d94cb3eda934047d9", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be forcibly cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2015-12-02\n+2015-01-25"}, {"sha": "e3080d29ec33077ce320a4b0a8f2758d74ff7483", "filename": "src/test/run-make/target-specs/my-awesome-platform.json", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Ftest%2Frun-make%2Ftarget-specs%2Fmy-awesome-platform.json", "raw_url": "https://github.com/rust-lang/rust/raw/d1cace17af31ddb21aeb8a3d94cb3eda934047d9/src%2Ftest%2Frun-make%2Ftarget-specs%2Fmy-awesome-platform.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftarget-specs%2Fmy-awesome-platform.json?ref=d1cace17af31ddb21aeb8a3d94cb3eda934047d9", "patch": "@@ -1,5 +1,4 @@\n {\n-    \"data-layout\": \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\",\n     \"llvm-target\": \"i686-unknown-linux-gnu\",\n     \"target-endian\": \"little\",\n     \"target-pointer-width\": \"32\","}]}