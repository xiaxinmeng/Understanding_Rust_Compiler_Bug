{"sha": "7d82d95af9c54c3947f6c6e21a6d632d9ee468de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkODJkOTVhZjljNTRjMzk0N2Y2YzZlMjFhNmQ2MzJkOWVlNDY4ZGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-14T08:48:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-14T08:48:28Z"}, "message": "Auto merge of #38927 - petrochenkov:leven, r=jseyfried\n\nresolve: Levenshtein-based suggestions for non-import paths\n\nThis patch addresses both items from https://github.com/rust-lang/rust/issues/30197#issuecomment-264846000 and therefore implements the largest part of https://github.com/rust-lang/rust/issues/30197.\n\nr? @jseyfried", "tree": {"sha": "9217e02db142130dce495c264de39c7d16272fbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9217e02db142130dce495c264de39c7d16272fbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d82d95af9c54c3947f6c6e21a6d632d9ee468de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d82d95af9c54c3947f6c6e21a6d632d9ee468de", "html_url": "https://github.com/rust-lang/rust/commit/7d82d95af9c54c3947f6c6e21a6d632d9ee468de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d82d95af9c54c3947f6c6e21a6d632d9ee468de/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fe23719feb20c25a8b2693d1f196e72d8da9af5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fe23719feb20c25a8b2693d1f196e72d8da9af5", "html_url": "https://github.com/rust-lang/rust/commit/6fe23719feb20c25a8b2693d1f196e72d8da9af5"}, {"sha": "589bd649d2c56f5c526f6fde3bfac85efb5f3a4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/589bd649d2c56f5c526f6fde3bfac85efb5f3a4d", "html_url": "https://github.com/rust-lang/rust/commit/589bd649d2c56f5c526f6fde3bfac85efb5f3a4d"}], "stats": {"total": 176, "additions": 157, "deletions": 19}, "files": [{"sha": "56e8c75b859a12802bfe0f44d19fd2a98b2d6857", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 65, "deletions": 16, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/7d82d95af9c54c3947f6c6e21a6d632d9ee468de/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d82d95af9c54c3947f6c6e21a6d632d9ee468de/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7d82d95af9c54c3947f6c6e21a6d632d9ee468de", "patch": "@@ -2191,11 +2191,9 @@ impl<'a> Resolver<'a> {\n             }\n \n             // Try Levenshtein if nothing else worked.\n-            if path.len() == 1 {\n-                if let Some(candidate) = this.lookup_typo_candidate(name, ns, is_expected) {\n-                    err.span_label(span, &format!(\"did you mean `{}`?\", candidate));\n-                    return err;\n-                }\n+            if let Some(candidate) = this.lookup_typo_candidate(path, ns, is_expected) {\n+                err.span_label(span, &format!(\"did you mean `{}`?\", candidate));\n+                return err;\n             }\n \n             // Fallback label.\n@@ -2649,21 +2647,72 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn lookup_typo_candidate<FilterFn>(&mut self,\n-                                       name: Name,\n+                                       path: &[Ident],\n                                        ns: Namespace,\n                                        filter_fn: FilterFn)\n-                                       -> Option<Name>\n+                                       -> Option<String>\n         where FilterFn: Fn(Def) -> bool\n     {\n-        // FIXME: bindings in ribs provide quite modest set of candidates,\n-        // extend it with other names in scope.\n-        let names = self.ribs[ns].iter().rev().flat_map(|rib| {\n-            rib.bindings.iter().filter_map(|(ident, def)| {\n-                if filter_fn(*def) { Some(&ident.name) } else { None }\n-            })\n-        });\n-        match find_best_match_for_name(names, &name.as_str(), None) {\n-            Some(found) if found != name => Some(found),\n+        let add_module_candidates = |module: Module, names: &mut Vec<Name>| {\n+            for (&(ident, _), resolution) in module.resolutions.borrow().iter() {\n+                if let Some(binding) = resolution.borrow().binding {\n+                    if filter_fn(binding.def()) {\n+                        names.push(ident.name);\n+                    }\n+                }\n+            }\n+        };\n+\n+        let mut names = Vec::new();\n+        let prefix_str = if path.len() == 1 {\n+            // Search in lexical scope.\n+            // Walk backwards up the ribs in scope and collect candidates.\n+            for rib in self.ribs[ns].iter().rev() {\n+                // Locals and type parameters\n+                for (ident, def) in &rib.bindings {\n+                    if filter_fn(*def) {\n+                        names.push(ident.name);\n+                    }\n+                }\n+                // Items in scope\n+                if let ModuleRibKind(module) = rib.kind {\n+                    // Items from this module\n+                    add_module_candidates(module, &mut names);\n+\n+                    if let ModuleKind::Block(..) = module.kind {\n+                        // We can see through blocks\n+                    } else {\n+                        // Items from the prelude\n+                        if let Some(prelude) = self.prelude {\n+                            if !module.no_implicit_prelude {\n+                                add_module_candidates(prelude, &mut names);\n+                            }\n+                        }\n+                        break;\n+                    }\n+                }\n+            }\n+            // Add primitive types to the mix\n+            if filter_fn(Def::PrimTy(TyBool)) {\n+                for (name, _) in &self.primitive_type_table.primitive_types {\n+                    names.push(*name);\n+                }\n+            }\n+            String::new()\n+        } else {\n+            // Search in module.\n+            let mod_path = &path[..path.len() - 1];\n+            if let PathResult::Module(module) = self.resolve_path(mod_path, Some(TypeNS), None) {\n+                add_module_candidates(module, &mut names);\n+            }\n+            names_to_string(mod_path) + \"::\"\n+        };\n+\n+        let name = path[path.len() - 1].name;\n+        // Make sure error reporting is deterministic.\n+        names.sort_by_key(|name| name.as_str());\n+        match find_best_match_for_name(names.iter(), &name.as_str(), None) {\n+            Some(found) if found != name => Some(format!(\"{}{}\", prefix_str, found)),\n             _ => None,\n         }\n     }"}, {"sha": "53b6372d8eb40774ab3e22a72b9a3831e3ae74ae", "filename": "src/test/ui/resolve/levenshtein.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7d82d95af9c54c3947f6c6e21a6d632d9ee468de/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d82d95af9c54c3947f6c6e21a6d632d9ee468de/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.rs?ref=7d82d95af9c54c3947f6c6e21a6d632d9ee468de", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const MAX_ITEM: usize = 10;\n+\n+fn foo_bar() {}\n+\n+fn foo(c: esize) {} // Misspelled primitive type name.\n+\n+enum Bar { }\n+\n+type A = Baz; // Misspelled type name.\n+type B = Opiton<u8>; // Misspelled type name from the prelude.\n+\n+mod m {\n+    type A = Baz; // No suggestion here, Bar is not visible\n+\n+    pub struct First;\n+    pub struct Second;\n+}\n+\n+fn main() {\n+    let v = [0u32; MAXITEM]; // Misspelled constant name.\n+    foobar(); // Misspelled function name.\n+    let b: m::first = m::second; // Misspelled item in module.\n+}"}, {"sha": "d01ffcb2839b4f6fdd13162ef140962ca2bab576", "filename": "src/test/ui/resolve/levenshtein.stderr", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7d82d95af9c54c3947f6c6e21a6d632d9ee468de/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d82d95af9c54c3947f6c6e21a6d632d9ee468de/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr?ref=7d82d95af9c54c3947f6c6e21a6d632d9ee468de", "patch": "@@ -0,0 +1,56 @@\n+error[E0412]: cannot find type `esize` in this scope\n+  --> $DIR/levenshtein.rs:15:11\n+   |\n+15 | fn foo(c: esize) {} // Misspelled primitive type name.\n+   |           ^^^^^ did you mean `isize`?\n+\n+error[E0412]: cannot find type `Baz` in this scope\n+  --> $DIR/levenshtein.rs:19:10\n+   |\n+19 | type A = Baz; // Misspelled type name.\n+   |          ^^^ did you mean `Bar`?\n+\n+error[E0412]: cannot find type `Opiton` in this scope\n+  --> $DIR/levenshtein.rs:20:10\n+   |\n+20 | type B = Opiton<u8>; // Misspelled type name from the prelude.\n+   |          ^^^^^^^^^^ did you mean `Option`?\n+\n+error[E0412]: cannot find type `Baz` in this scope\n+  --> $DIR/levenshtein.rs:23:14\n+   |\n+23 |     type A = Baz; // No suggestion here, Bar is not visible\n+   |              ^^^ not found in this scope\n+\n+error[E0425]: cannot find value `MAXITEM` in this scope\n+  --> $DIR/levenshtein.rs:30:20\n+   |\n+30 |     let v = [0u32; MAXITEM]; // Misspelled constant name.\n+   |                    ^^^^^^^ did you mean `MAX_ITEM`?\n+\n+error[E0425]: cannot find function `foobar` in this scope\n+  --> $DIR/levenshtein.rs:31:5\n+   |\n+31 |     foobar(); // Misspelled function name.\n+   |     ^^^^^^ did you mean `foo_bar`?\n+\n+error[E0412]: cannot find type `first` in module `m`\n+  --> $DIR/levenshtein.rs:32:12\n+   |\n+32 |     let b: m::first = m::second; // Misspelled item in module.\n+   |            ^^^^^^^^ did you mean `m::First`?\n+\n+error[E0425]: cannot find value `second` in module `m`\n+  --> $DIR/levenshtein.rs:32:23\n+   |\n+32 |     let b: m::first = m::second; // Misspelled item in module.\n+   |                       ^^^^^^^^^ did you mean `m::Second`?\n+\n+error[E0080]: constant evaluation error\n+  --> $DIR/levenshtein.rs:30:20\n+   |\n+30 |     let v = [0u32; MAXITEM]; // Misspelled constant name.\n+   |                    ^^^^^^^ unresolved path in constant expression\n+\n+error: aborting due to previous error\n+"}, {"sha": "57c0ecc813505d39b31a9ffc956a1a970ef44274", "filename": "src/test/ui/resolve/suggest-path-instead-of-mod-dot-item.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d82d95af9c54c3947f6c6e21a6d632d9ee468de/src%2Ftest%2Fui%2Fresolve%2Fsuggest-path-instead-of-mod-dot-item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d82d95af9c54c3947f6c6e21a6d632d9ee468de/src%2Ftest%2Fui%2Fresolve%2Fsuggest-path-instead-of-mod-dot-item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fsuggest-path-instead-of-mod-dot-item.stderr?ref=7d82d95af9c54c3947f6c6e21a6d632d9ee468de", "patch": "@@ -32,7 +32,7 @@ error[E0423]: expected value, found module `a::b`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:55:12\n    |\n 55 |     v.push(a::b);\n-   |            ^^^^ not a value\n+   |            ^^^^ did you mean `a::I`?\n \n error[E0423]: expected value, found module `a::b`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:61:5\n@@ -44,13 +44,13 @@ error[E0423]: expected value, found module `a::b`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:67:5\n    |\n 67 |     a::b\n-   |     ^^^^ not a value\n+   |     ^^^^ did you mean `a::I`?\n \n error[E0423]: expected function, found module `a::b`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:73:5\n    |\n 73 |     a::b()\n-   |     ^^^^ not a function\n+   |     ^^^^ did you mean `a::I`?\n \n error: main function not found\n "}]}