{"sha": "538147bf94b4c52a945c975b67e8d557998f9052", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzODE0N2JmOTRiNGM1MmE5NDVjOTc1YjY3ZThkNTU3OTk4ZjkwNTI=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2018-12-29T22:20:12Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-01-04T18:13:50Z"}, "message": "Resolve the Self type", "tree": {"sha": "667dc8e07cc92335de0ae1ca6e5ddcba7db1fa11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/667dc8e07cc92335de0ae1ca6e5ddcba7db1fa11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/538147bf94b4c52a945c975b67e8d557998f9052", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/538147bf94b4c52a945c975b67e8d557998f9052", "html_url": "https://github.com/rust-lang/rust/commit/538147bf94b4c52a945c975b67e8d557998f9052", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/538147bf94b4c52a945c975b67e8d557998f9052/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4db61b9a151a2a46c4067e61b0a4b1a9e3c73ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4db61b9a151a2a46c4067e61b0a4b1a9e3c73ec", "html_url": "https://github.com/rust-lang/rust/commit/d4db61b9a151a2a46c4067e61b0a4b1a9e3c73ec"}], "stats": {"total": 95, "additions": 71, "deletions": 24}, "files": [{"sha": "017caf442e29c56b082c6e6280741bd79689ec7d", "filename": "crates/ra_hir/src/name.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/538147bf94b4c52a945c975b67e8d557998f9052/crates%2Fra_hir%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/538147bf94b4c52a945c975b67e8d557998f9052/crates%2Fra_hir%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fname.rs?ref=538147bf94b4c52a945c975b67e8d557998f9052", "patch": "@@ -51,6 +51,7 @@ impl Name {\n             \"u128\" => KnownName::U128,\n             \"f32\" => KnownName::F32,\n             \"f64\" => KnownName::F64,\n+            \"Self\" => KnownName::Self_,\n             _ => return None,\n         };\n         Some(name)\n@@ -84,7 +85,7 @@ impl AsName for ra_db::Dependency {\n // const ISIZE: Name = Name::new(\"isize\")\n // ```\n // but const-fn is not that powerful yet.\n-#[derive(Debug)]\n+#[derive(Debug, PartialEq, Eq)]\n pub(crate) enum KnownName {\n     Isize,\n     I8,\n@@ -102,4 +103,6 @@ pub(crate) enum KnownName {\n \n     F32,\n     F64,\n+\n+    Self_,\n }"}, {"sha": "d11f80cffb844401a7830d90a93a620f2fbb71a8", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 65, "deletions": 21, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/538147bf94b4c52a945c975b67e8d557998f9052/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/538147bf94b4c52a945c975b67e8d557998f9052/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=538147bf94b4c52a945c975b67e8d557998f9052", "patch": "@@ -31,9 +31,10 @@ use ra_syntax::{\n };\n \n use crate::{\n-    Def, DefId, FnScopes, Module, Function, Struct, Enum, Path, Name, AsName,\n+    Def, DefId, FnScopes, Module, Function, Struct, Enum, Path, Name, AsName, ImplBlock,\n     db::HirDatabase,\n     type_ref::{TypeRef, Mutability},\n+    name::KnownName,\n };\n \n /// The ID of a type variable.\n@@ -235,36 +236,37 @@ impl Ty {\n     pub(crate) fn from_hir(\n         db: &impl HirDatabase,\n         module: &Module,\n+        impl_block: Option<&ImplBlock>,\n         type_ref: &TypeRef,\n     ) -> Cancelable<Self> {\n         Ok(match type_ref {\n             TypeRef::Never => Ty::Never,\n             TypeRef::Tuple(inner) => {\n                 let inner_tys = inner\n                     .iter()\n-                    .map(|tr| Ty::from_hir(db, module, tr))\n+                    .map(|tr| Ty::from_hir(db, module, impl_block, tr))\n                     .collect::<Cancelable<Vec<_>>>()?;\n                 Ty::Tuple(inner_tys.into())\n             }\n-            TypeRef::Path(path) => Ty::from_hir_path(db, module, path)?,\n+            TypeRef::Path(path) => Ty::from_hir_path(db, module, impl_block, path)?,\n             TypeRef::RawPtr(inner, mutability) => {\n-                let inner_ty = Ty::from_hir(db, module, inner)?;\n+                let inner_ty = Ty::from_hir(db, module, impl_block, inner)?;\n                 Ty::RawPtr(Arc::new(inner_ty), *mutability)\n             }\n             TypeRef::Array(_inner) => Ty::Unknown, // TODO\n             TypeRef::Slice(inner) => {\n-                let inner_ty = Ty::from_hir(db, module, inner)?;\n+                let inner_ty = Ty::from_hir(db, module, impl_block, inner)?;\n                 Ty::Slice(Arc::new(inner_ty))\n             }\n             TypeRef::Reference(inner, mutability) => {\n-                let inner_ty = Ty::from_hir(db, module, inner)?;\n+                let inner_ty = Ty::from_hir(db, module, impl_block, inner)?;\n                 Ty::Ref(Arc::new(inner_ty), *mutability)\n             }\n             TypeRef::Placeholder => Ty::Unknown,\n             TypeRef::Fn(params) => {\n                 let mut inner_tys = params\n                     .iter()\n-                    .map(|tr| Ty::from_hir(db, module, tr))\n+                    .map(|tr| Ty::from_hir(db, module, impl_block, tr))\n                     .collect::<Cancelable<Vec<_>>>()?;\n                 let return_ty = inner_tys\n                     .pop()\n@@ -279,9 +281,21 @@ impl Ty {\n         })\n     }\n \n+    pub(crate) fn from_hir_opt(\n+        db: &impl HirDatabase,\n+        module: &Module,\n+        impl_block: Option<&ImplBlock>,\n+        type_ref: Option<&TypeRef>,\n+    ) -> Cancelable<Self> {\n+        type_ref\n+            .map(|t| Ty::from_hir(db, module, impl_block, t))\n+            .unwrap_or(Ok(Ty::Unknown))\n+    }\n+\n     pub(crate) fn from_hir_path(\n         db: &impl HirDatabase,\n         module: &Module,\n+        impl_block: Option<&ImplBlock>,\n         path: &Path,\n     ) -> Cancelable<Self> {\n         if let Some(name) = path.as_ident() {\n@@ -291,6 +305,8 @@ impl Ty {\n                 return Ok(Ty::Uint(uint_ty));\n             } else if let Some(float_ty) = primitive::FloatTy::from_name(name) {\n                 return Ok(Ty::Float(float_ty));\n+            } else if name.as_known_name() == Some(KnownName::Self_) {\n+                return Ty::from_hir_opt(db, module, None, impl_block.map(|i| i.target()));\n             }\n         }\n \n@@ -308,18 +324,20 @@ impl Ty {\n     pub(crate) fn from_ast_opt(\n         db: &impl HirDatabase,\n         module: &Module,\n+        impl_block: Option<&ImplBlock>,\n         node: Option<ast::TypeRef>,\n     ) -> Cancelable<Self> {\n-        node.map(|n| Ty::from_ast(db, module, n))\n+        node.map(|n| Ty::from_ast(db, module, impl_block, n))\n             .unwrap_or(Ok(Ty::Unknown))\n     }\n \n     pub(crate) fn from_ast(\n         db: &impl HirDatabase,\n         module: &Module,\n+        impl_block: Option<&ImplBlock>,\n         node: ast::TypeRef,\n     ) -> Cancelable<Self> {\n-        Ty::from_hir(db, module, &TypeRef::from_ast(node))\n+        Ty::from_hir(db, module, impl_block, &TypeRef::from_ast(node))\n     }\n \n     pub fn unit() -> Self {\n@@ -402,18 +420,19 @@ impl fmt::Display for Ty {\n fn type_for_fn(db: &impl HirDatabase, f: Function) -> Cancelable<Ty> {\n     let syntax = f.syntax(db);\n     let module = f.module(db)?;\n+    let impl_block = f.impl_block(db)?;\n     let node = syntax.borrowed();\n     // TODO we ignore type parameters for now\n     let input = node\n         .param_list()\n         .map(|pl| {\n             pl.params()\n-                .map(|p| Ty::from_ast_opt(db, &module, p.type_ref()))\n+                .map(|p| Ty::from_ast_opt(db, &module, impl_block.as_ref(), p.type_ref()))\n                 .collect()\n         })\n         .unwrap_or_else(|| Ok(Vec::new()))?;\n     let output = if let Some(type_ref) = node.ret_type().and_then(|rt| rt.type_ref()) {\n-        Ty::from_ast(db, &module, type_ref)?\n+        Ty::from_ast(db, &module, impl_block.as_ref(), type_ref)?\n     } else {\n         Ty::unit()\n     };\n@@ -467,12 +486,13 @@ pub(super) fn type_for_field(db: &impl HirDatabase, def_id: DefId, field: Name)\n         ),\n     };\n     let module = def_id.module(db)?;\n+    let impl_block = def_id.impl_block(db)?;\n     let type_ref = if let Some(tr) = variant_data.get_field_type_ref(&field) {\n         tr\n     } else {\n         return Ok(Ty::Unknown);\n     };\n-    Ty::from_hir(db, &module, &type_ref)\n+    Ty::from_hir(db, &module, impl_block.as_ref(), &type_ref)\n }\n \n /// The result of type inference: A mapping from expressions and patterns to types.\n@@ -499,19 +519,26 @@ struct InferenceContext<'a, D: HirDatabase> {\n     /// The self param for the current method, if it exists.\n     self_param: Option<LocalSyntaxPtr>,\n     module: Module,\n+    impl_block: Option<ImplBlock>,\n     var_unification_table: InPlaceUnificationTable<TypeVarId>,\n     type_of: FxHashMap<LocalSyntaxPtr, Ty>,\n }\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n-    fn new(db: &'a D, scopes: Arc<FnScopes>, module: Module) -> Self {\n+    fn new(\n+        db: &'a D,\n+        scopes: Arc<FnScopes>,\n+        module: Module,\n+        impl_block: Option<ImplBlock>,\n+    ) -> Self {\n         InferenceContext {\n             type_of: FxHashMap::default(),\n             var_unification_table: InPlaceUnificationTable::new(),\n             self_param: None, // set during parameter typing\n             db,\n             scopes,\n             module,\n+            impl_block,\n         }\n     }\n \n@@ -835,7 +862,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             ast::Expr::CastExpr(e) => {\n                 let _inner_ty = self.infer_expr_opt(e.expr(), &Expectation::none())?;\n-                let cast_ty = Ty::from_ast_opt(self.db, &self.module, e.type_ref())?;\n+                let cast_ty = Ty::from_ast_opt(\n+                    self.db,\n+                    &self.module,\n+                    self.impl_block.as_ref(),\n+                    e.type_ref(),\n+                )?;\n                 let cast_ty = self.insert_type_vars(cast_ty);\n                 // TODO do the coercion...\n                 cast_ty\n@@ -889,7 +921,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         for stmt in node.statements() {\n             match stmt {\n                 ast::Stmt::LetStmt(stmt) => {\n-                    let decl_ty = Ty::from_ast_opt(self.db, &self.module, stmt.type_ref())?;\n+                    let decl_ty = Ty::from_ast_opt(\n+                        self.db,\n+                        &self.module,\n+                        self.impl_block.as_ref(),\n+                        stmt.type_ref(),\n+                    )?;\n                     let decl_ty = self.insert_type_vars(decl_ty);\n                     let ty = if let Some(expr) = stmt.initializer() {\n                         let expr_ty = self.infer_expr(expr, &Expectation::has_type(decl_ty))?;\n@@ -921,19 +958,26 @@ pub fn infer(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<InferenceRe\n     let function = Function::new(def_id); // TODO: consts also need inference\n     let scopes = function.scopes(db);\n     let module = function.module(db)?;\n-    let mut ctx = InferenceContext::new(db, scopes, module);\n+    let impl_block = function.impl_block(db)?;\n+    let mut ctx = InferenceContext::new(db, scopes, module, impl_block);\n \n     let syntax = function.syntax(db);\n     let node = syntax.borrowed();\n \n     if let Some(param_list) = node.param_list() {\n         if let Some(self_param) = param_list.self_param() {\n-            let self_type = if let Some(impl_block) = function.impl_block(db)? {\n+            let self_type = if let Some(impl_block) = &ctx.impl_block {\n                 if let Some(type_ref) = self_param.type_ref() {\n-                    let ty = Ty::from_ast(db, &ctx.module, type_ref)?;\n+                    let ty = Ty::from_ast(db, &ctx.module, ctx.impl_block.as_ref(), type_ref)?;\n                     ctx.insert_type_vars(ty)\n                 } else {\n-                    let ty = Ty::from_hir(db, &ctx.module, impl_block.target())?;\n+                    // TODO this should be handled by desugaring during HIR conversion\n+                    let ty = Ty::from_hir(\n+                        db,\n+                        &ctx.module,\n+                        ctx.impl_block.as_ref(),\n+                        impl_block.target(),\n+                    )?;\n                     let ty = match self_param.flavor() {\n                         ast::SelfParamFlavor::Owned => ty,\n                         ast::SelfParamFlavor::Ref => Ty::Ref(Arc::new(ty), Mutability::Shared),\n@@ -961,7 +1005,7 @@ pub fn infer(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<InferenceRe\n                 continue;\n             };\n             let ty = if let Some(type_ref) = param.type_ref() {\n-                let ty = Ty::from_ast(db, &ctx.module, type_ref)?;\n+                let ty = Ty::from_ast(db, &ctx.module, ctx.impl_block.as_ref(), type_ref)?;\n                 ctx.insert_type_vars(ty)\n             } else {\n                 // missing type annotation\n@@ -972,7 +1016,7 @@ pub fn infer(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<InferenceRe\n     }\n \n     let ret_ty = if let Some(type_ref) = node.ret_type().and_then(|n| n.type_ref()) {\n-        let ty = Ty::from_ast(db, &ctx.module, type_ref)?;\n+        let ty = Ty::from_ast(db, &ctx.module, ctx.impl_block.as_ref(), type_ref)?;\n         ctx.insert_type_vars(ty)\n     } else {\n         Ty::unit()"}, {"sha": "db4ba17d07915d25e96b8a521c4f4d89914eba13", "filename": "crates/ra_hir/src/ty/tests/data/0007_self.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/538147bf94b4c52a945c975b67e8d557998f9052/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0007_self.txt", "raw_url": "https://github.com/rust-lang/rust/raw/538147bf94b4c52a945c975b67e8d557998f9052/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0007_self.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0007_self.txt?ref=538147bf94b4c52a945c975b67e8d557998f9052", "patch": "@@ -2,5 +2,5 @@\n [34; 38) 'self': &S\n [40; 61) '{     ...     }': ()\n [88; 109) '{     ...     }': ()\n-[98; 102) 'self': &[unknown]\n-[75; 79) 'self': &[unknown]\n+[98; 102) 'self': &S\n+[75; 79) 'self': &S"}]}