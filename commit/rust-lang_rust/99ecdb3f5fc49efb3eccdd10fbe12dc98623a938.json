{"sha": "99ecdb3f5fc49efb3eccdd10fbe12dc98623a938", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5ZWNkYjNmNWZjNDllZmIzZWNjZGQxMGZiZTEyZGM5ODYyM2E5Mzg=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-06-24T16:54:23Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-06-29T22:53:32Z"}, "message": "hygiene: Implement transparent marks", "tree": {"sha": "7c82e4221bf6f94e44ca58399c873b2b9eb29a25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c82e4221bf6f94e44ca58399c873b2b9eb29a25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938", "html_url": "https://github.com/rust-lang/rust/commit/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09856c85b73feff1db93990cd3d80f2c585b40c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/09856c85b73feff1db93990cd3d80f2c585b40c4", "html_url": "https://github.com/rust-lang/rust/commit/09856c85b73feff1db93990cd3d80f2c585b40c4"}], "stats": {"total": 280, "additions": 253, "deletions": 27}, "files": [{"sha": "640e650207e8db03740d3ce757ff0632ae088e77", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=99ecdb3f5fc49efb3eccdd10fbe12dc98623a938", "patch": "@@ -1850,6 +1850,8 @@ impl<'a> Resolver<'a> {\n             } else {\n                 ident.span.modern()\n             }\n+        } else {\n+            ident = ident.modern_and_legacy();\n         }\n \n         // Walk backwards up the ribs in scope.\n@@ -1987,7 +1989,7 @@ impl<'a> Resolver<'a> {\n             // When resolving `$crate` from a `macro_rules!` invoked in a `macro`,\n             // we don't want to pretend that the `macro_rules!` definition is in the `macro`\n             // as described in `SyntaxContext::apply_mark`, so we ignore prepended modern marks.\n-            ctxt.marks().into_iter().find(|&mark| mark.transparency() != Transparency::Opaque)\n+            ctxt.marks().into_iter().rev().find(|m| m.transparency() != Transparency::Transparent)\n         } else {\n             ctxt = ctxt.modern();\n             ctxt.adjust(Mark::root())\n@@ -2628,6 +2630,7 @@ impl<'a> Resolver<'a> {\n         // must not add it if it's in the bindings map\n         // because that breaks the assumptions later\n         // passes make about or-patterns.)\n+        let ident = ident.modern_and_legacy();\n         let mut def = Def::Local(pat_id);\n         match bindings.get(&ident).cloned() {\n             Some(id) if id == outer_pat_id => {\n@@ -3782,7 +3785,8 @@ impl<'a> Resolver<'a> {\n             self.unused_labels.insert(id, label.ident.span);\n             let def = Def::Label(id);\n             self.with_label_rib(|this| {\n-                this.label_ribs.last_mut().unwrap().bindings.insert(label.ident, def);\n+                let ident = label.ident.modern_and_legacy();\n+                this.label_ribs.last_mut().unwrap().bindings.insert(ident, def);\n                 f(this);\n             });\n         } else {\n@@ -3813,7 +3817,10 @@ impl<'a> Resolver<'a> {\n             }\n \n             ExprKind::Break(Some(label), _) | ExprKind::Continue(Some(label)) => {\n-                match self.search_label(label.ident, |rib, id| rib.bindings.get(&id).cloned()) {\n+                let def = self.search_label(label.ident, |rib, ident| {\n+                    rib.bindings.get(&ident.modern_and_legacy()).cloned()\n+                });\n+                match def {\n                     None => {\n                         // Search again for close matches...\n                         // Picks the first label that is \"close enough\", which is not necessarily"}, {"sha": "0523765ea189750cb879d61588967d3511855fa1", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=99ecdb3f5fc49efb3eccdd10fbe12dc98623a938", "patch": "@@ -332,7 +332,9 @@ impl<'a> base::Resolver for Resolver<'a> {\n         self.unused_macros.remove(&def_id);\n         let ext = self.get_macro(def);\n         if ext.is_modern() {\n-            invoc.expansion_data.mark.set_transparency(Transparency::Opaque);\n+            let transparency =\n+                if ext.is_transparent() { Transparency::Transparent } else { Transparency::Opaque };\n+            invoc.expansion_data.mark.set_transparency(transparency);\n         } else if def_id.krate == BUILTIN_MACROS_CRATE {\n             invoc.expansion_data.mark.set_is_builtin(true);\n         }"}, {"sha": "e2424de4d1449a25a81d4bcac7618cb5e8bf4fa9", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=99ecdb3f5fc49efb3eccdd10fbe12dc98623a938", "patch": "@@ -649,6 +649,7 @@ pub enum SyntaxExtension {\n     DeclMacro {\n         expander: Box<TTMacroExpander + sync::Sync + sync::Send>,\n         def_info: Option<(ast::NodeId, Span)>,\n+        is_transparent: bool,\n         edition: Edition,\n     }\n }\n@@ -682,6 +683,13 @@ impl SyntaxExtension {\n         }\n     }\n \n+    pub fn is_transparent(&self) -> bool {\n+        match *self {\n+            SyntaxExtension::DeclMacro { is_transparent, .. } => is_transparent,\n+            _ => false,\n+        }\n+    }\n+\n     pub fn edition(&self) -> Edition {\n         match *self {\n             SyntaxExtension::NormalTT { edition, .. } |"}, {"sha": "e364e145593dee842edfb7fef23f8b8007b210ce", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=99ecdb3f5fc49efb3eccdd10fbe12dc98623a938", "patch": "@@ -738,7 +738,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         };\n \n         let opt_expanded = match *ext {\n-            DeclMacro { ref expander, def_info, edition } => {\n+            DeclMacro { ref expander, def_info, edition, .. } => {\n                 if let Err(dummy_span) = validate_and_set_expn_info(self, def_info.map(|(_, s)| s),\n                                                                     false, false, false, None,\n                                                                     edition) {"}, {"sha": "70fc9dada428ea7f8c60f17720fec27a010cb49f", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=99ecdb3f5fc49efb3eccdd10fbe12dc98623a938", "patch": "@@ -312,9 +312,12 @@ pub fn compile(sess: &ParseSess, features: &Features, def: &ast::Item, edition:\n             edition,\n         }\n     } else {\n+        let is_transparent = attr::contains_name(&def.attrs, \"rustc_transparent_macro\");\n+\n         SyntaxExtension::DeclMacro {\n             expander,\n             def_info: Some((def.id, def.span)),\n+            is_transparent,\n             edition,\n         }\n     }"}, {"sha": "e7f1f31084a64e7bdd27aa5d382d1fe0d9b9bab0", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 75, "deletions": 22, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=99ecdb3f5fc49efb3eccdd10fbe12dc98623a938", "patch": "@@ -33,14 +33,17 @@ pub struct SyntaxContext(pub(super) u32);\n pub struct SyntaxContextData {\n     pub outer_mark: Mark,\n     pub prev_ctxt: SyntaxContext,\n-    pub modern: SyntaxContext,\n+    // This context, but with all transparent and semi-transparent marks filtered away.\n+    pub opaque: SyntaxContext,\n+    // This context, but with all transparent marks filtered away.\n+    pub opaque_and_semitransparent: SyntaxContext,\n }\n \n /// A mark is a unique id associated with a macro expansion.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct Mark(u32);\n \n-#[derive(Debug)]\n+#[derive(Clone, Debug)]\n struct MarkData {\n     parent: Mark,\n     transparency: Transparency,\n@@ -50,7 +53,7 @@ struct MarkData {\n \n /// A property of a macro expansion that determines how identifiers\n /// produced by that expansion are resolved.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Debug)]\n pub enum Transparency {\n     /// Identifier produced by a transparent expansion is always resolved at call-site.\n     /// Call-site spans in procedural macros, hygiene opt-out in `macro` should use this.\n@@ -69,16 +72,26 @@ pub enum Transparency {\n }\n \n impl Mark {\n+    fn fresh_with_data(mark_data: MarkData, data: &mut HygieneData) -> Self {\n+        data.marks.push(mark_data);\n+        Mark(data.marks.len() as u32 - 1)\n+    }\n+\n     pub fn fresh(parent: Mark) -> Self {\n         HygieneData::with(|data| {\n-            data.marks.push(MarkData {\n+            Mark::fresh_with_data(MarkData {\n                 parent,\n                 // By default expansions behave like `macro_rules`.\n                 transparency: Transparency::SemiTransparent,\n                 is_builtin: false,\n                 expn_info: None,\n-            });\n-            Mark(data.marks.len() as u32 - 1)\n+            }, data)\n+        })\n+    }\n+\n+    pub fn fresh_cloned(clone_from: Mark) -> Self {\n+        HygieneData::with(|data| {\n+            Mark::fresh_with_data(data.marks[clone_from.0 as usize].clone(), data)\n         })\n     }\n \n@@ -207,7 +220,8 @@ impl HygieneData {\n             syntax_contexts: vec![SyntaxContextData {\n                 outer_mark: Mark::root(),\n                 prev_ctxt: SyntaxContext(0),\n-                modern: SyntaxContext(0),\n+                opaque: SyntaxContext(0),\n+                opaque_and_semitransparent: SyntaxContext(0),\n             }],\n             markings: HashMap::new(),\n             default_edition: Edition::Edition2015,\n@@ -239,7 +253,7 @@ impl SyntaxContext {\n     // Allocate a new SyntaxContext with the given ExpnInfo. This is used when\n     // deserializing Spans from the incr. comp. cache.\n     // FIXME(mw): This method does not restore MarkData::parent or\n-    // SyntaxContextData::prev_ctxt or SyntaxContextData::modern. These things\n+    // SyntaxContextData::prev_ctxt or SyntaxContextData::opaque. These things\n     // don't seem to be used after HIR lowering, so everything should be fine\n     // as long as incremental compilation does not kick in before that.\n     pub fn allocate_directly(expansion_info: ExpnInfo) -> Self {\n@@ -256,7 +270,8 @@ impl SyntaxContext {\n             data.syntax_contexts.push(SyntaxContextData {\n                 outer_mark: mark,\n                 prev_ctxt: SyntaxContext::empty(),\n-                modern: SyntaxContext::empty(),\n+                opaque: SyntaxContext::empty(),\n+                opaque_and_semitransparent: SyntaxContext::empty(),\n             });\n             SyntaxContext(data.syntax_contexts.len() as u32 - 1)\n         })\n@@ -269,7 +284,13 @@ impl SyntaxContext {\n         }\n \n         let call_site_ctxt =\n-            mark.expn_info().map_or(SyntaxContext::empty(), |info| info.call_site.ctxt()).modern();\n+            mark.expn_info().map_or(SyntaxContext::empty(), |info| info.call_site.ctxt());\n+        let call_site_ctxt = if mark.transparency() == Transparency::SemiTransparent {\n+            call_site_ctxt.modern()\n+        } else {\n+            call_site_ctxt.modern_and_legacy()\n+        };\n+\n         if call_site_ctxt == SyntaxContext::empty() {\n             return self.apply_mark_internal(mark);\n         }\n@@ -293,26 +314,53 @@ impl SyntaxContext {\n     fn apply_mark_internal(self, mark: Mark) -> SyntaxContext {\n         HygieneData::with(|data| {\n             let syntax_contexts = &mut data.syntax_contexts;\n-            let mut modern = syntax_contexts[self.0 as usize].modern;\n-            if data.marks[mark.0 as usize].transparency == Transparency::Opaque {\n-                modern = *data.markings.entry((modern, mark)).or_insert_with(|| {\n-                    let len = syntax_contexts.len() as u32;\n+            let transparency = data.marks[mark.0 as usize].transparency;\n+\n+            let mut opaque = syntax_contexts[self.0 as usize].opaque;\n+            let mut opaque_and_semitransparent =\n+                syntax_contexts[self.0 as usize].opaque_and_semitransparent;\n+\n+            if transparency >= Transparency::Opaque {\n+                let prev_ctxt = opaque;\n+                opaque = *data.markings.entry((prev_ctxt, mark)).or_insert_with(|| {\n+                    let new_opaque = SyntaxContext(syntax_contexts.len() as u32);\n+                    syntax_contexts.push(SyntaxContextData {\n+                        outer_mark: mark,\n+                        prev_ctxt,\n+                        opaque: new_opaque,\n+                        opaque_and_semitransparent: new_opaque,\n+                    });\n+                    new_opaque\n+                });\n+            }\n+\n+            if transparency >= Transparency::SemiTransparent {\n+                let prev_ctxt = opaque_and_semitransparent;\n+                opaque_and_semitransparent =\n+                        *data.markings.entry((prev_ctxt, mark)).or_insert_with(|| {\n+                    let new_opaque_and_semitransparent =\n+                        SyntaxContext(syntax_contexts.len() as u32);\n                     syntax_contexts.push(SyntaxContextData {\n                         outer_mark: mark,\n-                        prev_ctxt: modern,\n-                        modern: SyntaxContext(len),\n+                        prev_ctxt,\n+                        opaque,\n+                        opaque_and_semitransparent: new_opaque_and_semitransparent,\n                     });\n-                    SyntaxContext(len)\n+                    new_opaque_and_semitransparent\n                 });\n             }\n \n-            *data.markings.entry((self, mark)).or_insert_with(|| {\n+            let prev_ctxt = self;\n+            *data.markings.entry((prev_ctxt, mark)).or_insert_with(|| {\n+                let new_opaque_and_semitransparent_and_transparent =\n+                    SyntaxContext(syntax_contexts.len() as u32);\n                 syntax_contexts.push(SyntaxContextData {\n                     outer_mark: mark,\n-                    prev_ctxt: self,\n-                    modern,\n+                    prev_ctxt,\n+                    opaque,\n+                    opaque_and_semitransparent,\n                 });\n-                SyntaxContext(syntax_contexts.len() as u32 - 1)\n+                new_opaque_and_semitransparent_and_transparent\n             })\n         })\n     }\n@@ -452,7 +500,12 @@ impl SyntaxContext {\n \n     #[inline]\n     pub fn modern(self) -> SyntaxContext {\n-        HygieneData::with(|data| data.syntax_contexts[self.0 as usize].modern)\n+        HygieneData::with(|data| data.syntax_contexts[self.0 as usize].opaque)\n+    }\n+\n+    #[inline]\n+    pub fn modern_and_legacy(self) -> SyntaxContext {\n+        HygieneData::with(|data| data.syntax_contexts[self.0 as usize].opaque_and_semitransparent)\n     }\n \n     #[inline]"}, {"sha": "308fb118f07960a32a0bae19c80c29771ffde13d", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=99ecdb3f5fc49efb3eccdd10fbe12dc98623a938", "patch": "@@ -491,6 +491,12 @@ impl Span {\n         let span = self.data();\n         span.with_ctxt(span.ctxt.modern())\n     }\n+\n+    #[inline]\n+    pub fn modern_and_legacy(self) -> Span {\n+        let span = self.data();\n+        span.with_ctxt(span.ctxt.modern_and_legacy())\n+    }\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "fe0b479d16103941167f208e6646a4475a221300", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=99ecdb3f5fc49efb3eccdd10fbe12dc98623a938", "patch": "@@ -68,6 +68,15 @@ impl Ident {\n         Ident::new(self.name, self.span.modern())\n     }\n \n+    // \"Normalize\" ident for use in comparisons using \"local variable hygiene\".\n+    // Identifiers with same string value become same if they came from the same non-transparent\n+    // macro (e.g. `macro` or `macro_rules!` items) and stay different if they came from different\n+    // non-transparent macros.\n+    // Technically, this operation strips all transparent marks from ident's syntactic context.\n+    pub fn modern_and_legacy(self) -> Ident {\n+        Ident::new(self.name, self.span.modern_and_legacy())\n+    }\n+\n     pub fn gensym(self) -> Ident {\n         Ident::new(self.name.gensymed(), self.span)\n     }"}, {"sha": "244a9903e31df4d5df02079588e5ded5cdda78ae", "filename": "src/test/ui/hygiene/auxiliary/intercrate.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fintercrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fintercrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fintercrate.rs?ref=99ecdb3f5fc49efb3eccdd10fbe12dc98623a938", "patch": "@@ -19,3 +19,9 @@ pub mod foo {\n         }\n     }\n }\n+\n+pub struct SomeType;\n+\n+pub macro uses_dollar_crate() {\n+    type Alias = $crate::SomeType;\n+}"}, {"sha": "ba65c5f4da80c4eeac98852f8a2899616b42b32d", "filename": "src/test/ui/hygiene/auxiliary/transparent-basic.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Ftransparent-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Ftransparent-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Ftransparent-basic.rs?ref=99ecdb3f5fc49efb3eccdd10fbe12dc98623a938", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(decl_macro, rustc_attrs)]\n+\n+#[rustc_transparent_macro]\n+pub macro dollar_crate() {\n+    let s = $crate::S;\n+}"}, {"sha": "f4b24d0c5b4ee0a5df3738c29d937cfde6d51f9c", "filename": "src/test/ui/hygiene/dollar-crate-modern.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/src%2Ftest%2Fui%2Fhygiene%2Fdollar-crate-modern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/src%2Ftest%2Fui%2Fhygiene%2Fdollar-crate-modern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fdollar-crate-modern.rs?ref=99ecdb3f5fc49efb3eccdd10fbe12dc98623a938", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Make sure `$crate` works in `macro` macros.\n+\n+// compile-pass\n+// aux-build:intercrate.rs\n+\n+#![feature(use_extern_macros)]\n+\n+extern crate intercrate;\n+\n+intercrate::uses_dollar_crate!();\n+\n+fn main() {}"}, {"sha": "90409857deadcff726cf6d448c785344db44355e", "filename": "src/test/ui/hygiene/generate-mod.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.rs?ref=99ecdb3f5fc49efb3eccdd10fbe12dc98623a938", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This is an equivalent of issue #50504, but for declarative macros.\n+\n+#![feature(decl_macro, rustc_attrs)]\n+\n+#[rustc_transparent_macro]\n+macro genmod() {\n+    mod m {\n+        type A = S; //~ ERROR cannot find type `S` in this scope\n+    }\n+}\n+\n+struct S;\n+\n+genmod!();"}, {"sha": "e79f8528c2cd7a42de0ca5064ab731190832cb70", "filename": "src/test/ui/hygiene/generate-mod.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.stderr?ref=99ecdb3f5fc49efb3eccdd10fbe12dc98623a938", "patch": "@@ -0,0 +1,17 @@\n+error[E0412]: cannot find type `S` in this scope\n+  --> $DIR/generate-mod.rs:18:18\n+   |\n+LL |         type A = S; //~ ERROR cannot find type `S` in this scope\n+   |                  ^ did you mean `A`?\n+...\n+LL | genmod!();\n+   | ---------- in this macro invocation\n+\n+error[E0601]: `main` function not found in crate `generate_mod`\n+   |\n+   = note: consider adding a `main` function to `$DIR/generate-mod.rs`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors occurred: E0412, E0601.\n+For more information about an error, try `rustc --explain E0412`."}, {"sha": "81ece1f11bc6aa90e5a832276ccbea3f4d36dd5c", "filename": "src/test/ui/hygiene/transparent-basic.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/src%2Ftest%2Fui%2Fhygiene%2Ftransparent-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938/src%2Ftest%2Fui%2Fhygiene%2Ftransparent-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Ftransparent-basic.rs?ref=99ecdb3f5fc49efb3eccdd10fbe12dc98623a938", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+// aux-build:transparent-basic.rs\n+\n+#![feature(decl_macro, rustc_attrs)]\n+\n+extern crate transparent_basic;\n+\n+#[rustc_transparent_macro]\n+macro binding() {\n+    let x = 10;\n+}\n+\n+#[rustc_transparent_macro]\n+macro label() {\n+    break 'label\n+}\n+\n+macro_rules! legacy {\n+    () => {\n+        binding!();\n+        let y = x;\n+    }\n+}\n+\n+fn legacy_interaction1() {\n+    legacy!();\n+}\n+\n+struct S;\n+\n+fn check_dollar_crate() {\n+    // `$crate::S` inside the macro resolves to `S` from this crate.\n+    transparent_basic::dollar_crate!();\n+}\n+\n+fn main() {\n+    binding!();\n+    let y = x;\n+\n+    'label: loop {\n+        label!();\n+    }\n+}"}]}