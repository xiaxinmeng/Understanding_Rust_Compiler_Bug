{"sha": "84745b483f322671f894b9e8d0a462c46275a9d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0NzQ1YjQ4M2YzMjI2NzFmODk0YjllOGQwYTQ2MmM0NjI3NWE5ZDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-14T08:55:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-14T08:55:42Z"}, "message": "auto merge of #6463 : bjz/rust/numeric-traits, r=thestinger\n\nThis is part of the numeric trait reform tracked on issue #4819", "tree": {"sha": "bdfac0f4e826f44588e95847d16a1caa398d112b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdfac0f4e826f44588e95847d16a1caa398d112b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84745b483f322671f894b9e8d0a462c46275a9d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84745b483f322671f894b9e8d0a462c46275a9d3", "html_url": "https://github.com/rust-lang/rust/commit/84745b483f322671f894b9e8d0a462c46275a9d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84745b483f322671f894b9e8d0a462c46275a9d3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a2f65fb5035627b8fb0b1ce0e927a492d55e3a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a2f65fb5035627b8fb0b1ce0e927a492d55e3a4", "html_url": "https://github.com/rust-lang/rust/commit/5a2f65fb5035627b8fb0b1ce0e927a492d55e3a4"}, {"sha": "3515b4996ae5c151459222601306d538eebdc3b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/3515b4996ae5c151459222601306d538eebdc3b3", "html_url": "https://github.com/rust-lang/rust/commit/3515b4996ae5c151459222601306d538eebdc3b3"}], "stats": {"total": 446, "additions": 445, "deletions": 1}, "files": [{"sha": "21e55af39ebba1378bac74f89016003fe36c60ec", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/84745b483f322671f894b9e8d0a462c46275a9d3/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84745b483f322671f894b9e8d0a462c46275a9d3/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=84745b483f322671f894b9e8d0a462c46275a9d3", "patch": "@@ -10,6 +10,7 @@\n \n //! Operations and constants for `f32`\n \n+use libc::c_int;\n use num::{Zero, One, strconv};\n use num::{FPCategory, FPNaN, FPInfinite , FPZero, FPSubnormal, FPNormal};\n use prelude::*;\n@@ -450,6 +451,57 @@ impl Hyperbolic for f32 {\n \n     #[inline(always)]\n     fn tanh(&self) -> f32 { tanh(*self) }\n+\n+    ///\n+    /// Inverse hyperbolic sine\n+    ///\n+    /// # Returns\n+    ///\n+    /// - on success, the inverse hyperbolic sine of `self` will be returned\n+    /// - `self` if `self` is `0.0`, `-0.0`, `infinity`, or `neg_infinity`\n+    /// - `NaN` if `self` is `NaN`\n+    ///\n+    #[inline(always)]\n+    fn asinh(&self) -> f32 {\n+        match *self {\n+            neg_infinity => neg_infinity,\n+            x => (x + ((x * x) + 1.0).sqrt()).ln(),\n+        }\n+    }\n+\n+    ///\n+    /// Inverse hyperbolic cosine\n+    ///\n+    /// # Returns\n+    ///\n+    /// - on success, the inverse hyperbolic cosine of `self` will be returned\n+    /// - `infinity` if `self` is `infinity`\n+    /// - `NaN` if `self` is `NaN` or `self < 1.0` (including `neg_infinity`)\n+    ///\n+    #[inline(always)]\n+    fn acosh(&self) -> f32 {\n+        match *self {\n+            x if x < 1.0 => Float::NaN(),\n+            x => (x + ((x * x) - 1.0).sqrt()).ln(),\n+        }\n+    }\n+\n+    ///\n+    /// Inverse hyperbolic tangent\n+    ///\n+    /// # Returns\n+    ///\n+    /// - on success, the inverse hyperbolic tangent of `self` will be returned\n+    /// - `self` if `self` is `0.0` or `-0.0`\n+    /// - `infinity` if `self` is `1.0`\n+    /// - `neg_infinity` if `self` is `-1.0`\n+    /// - `NaN` if the `self` is `NaN` or outside the domain of `-1.0 <= self <= 1.0`\n+    ///   (including `infinity` and `neg_infinity`)\n+    ///\n+    #[inline(always)]\n+    fn atanh(&self) -> f32 {\n+        0.5 * ((2.0 * *self) / (1.0 - *self)).ln_1p()\n+    }\n }\n \n impl Real for f32 {\n@@ -620,6 +672,25 @@ impl Float for f32 {\n     #[inline(always)]\n     fn max_10_exp() -> int { 38 }\n \n+    /// Constructs a floating point number by multiplying `x` by 2 raised to the power of `exp`\n+    #[inline(always)]\n+    fn ldexp(x: f32, exp: int) -> f32 {\n+        ldexp(x, exp as c_int)\n+    }\n+\n+    ///\n+    /// Breaks the number into a normalized fraction and a base-2 exponent, satisfying:\n+    ///\n+    /// - `self = x * pow(2, exp)`\n+    /// - `0.5 <= abs(x) < 1.0`\n+    ///\n+    #[inline(always)]\n+    fn frexp(&self) -> (f32, int) {\n+        let mut exp = 0;\n+        let x = frexp(*self, &mut exp);\n+        (x, exp as int)\n+    }\n+\n     ///\n     /// Returns the exponential of the number, minus `1`, in a way that is accurate\n     /// even if the number is close to zero\n@@ -972,6 +1043,43 @@ mod tests {\n         assert_approx_eq!((-1.7f32).fract(), -0.7f32);\n     }\n \n+    #[test]\n+    fn test_asinh() {\n+        assert_eq!(0.0f32.asinh(), 0.0f32);\n+        assert_eq!((-0.0f32).asinh(), -0.0f32);\n+        assert_eq!(Float::infinity::<f32>().asinh(), Float::infinity::<f32>());\n+        assert_eq!(Float::neg_infinity::<f32>().asinh(), Float::neg_infinity::<f32>());\n+        assert!(Float::NaN::<f32>().asinh().is_NaN());\n+        assert_approx_eq!(2.0f32.asinh(), 1.443635475178810342493276740273105f32);\n+        assert_approx_eq!((-2.0f32).asinh(), -1.443635475178810342493276740273105f32);\n+    }\n+\n+    #[test]\n+    fn test_acosh() {\n+        assert_eq!(1.0f32.acosh(), 0.0f32);\n+        assert!(0.999f32.acosh().is_NaN());\n+        assert_eq!(Float::infinity::<f32>().acosh(), Float::infinity::<f32>());\n+        assert!(Float::neg_infinity::<f32>().acosh().is_NaN());\n+        assert!(Float::NaN::<f32>().acosh().is_NaN());\n+        assert_approx_eq!(2.0f32.acosh(), 1.31695789692481670862504634730796844f32);\n+        assert_approx_eq!(3.0f32.acosh(), 1.76274717403908605046521864995958461f32);\n+    }\n+\n+    #[test]\n+    fn test_atanh() {\n+        assert_eq!(0.0f32.atanh(), 0.0f32);\n+        assert_eq!((-0.0f32).atanh(), -0.0f32);\n+        assert_eq!(1.0f32.atanh(), Float::infinity::<f32>());\n+        assert_eq!((-1.0f32).atanh(), Float::neg_infinity::<f32>());\n+        assert!(2f64.atanh().atanh().is_NaN());\n+        assert!((-2f64).atanh().atanh().is_NaN());\n+        assert!(Float::infinity::<f64>().atanh().is_NaN());\n+        assert!(Float::neg_infinity::<f64>().atanh().is_NaN());\n+        assert!(Float::NaN::<f32>().atanh().is_NaN());\n+        assert_approx_eq!(0.5f32.atanh(), 0.54930614433405484569762261846126285f32);\n+        assert_approx_eq!((-0.5f32).atanh(), -0.54930614433405484569762261846126285f32);\n+    }\n+\n     #[test]\n     fn test_real_consts() {\n         assert_approx_eq!(Real::two_pi::<f32>(), 2f32 * Real::pi::<f32>());\n@@ -1091,4 +1199,44 @@ mod tests {\n         assert_eq!(1e-37f32.classify(), FPNormal);\n         assert_eq!(1e-38f32.classify(), FPSubnormal);\n     }\n+\n+    #[test]\n+    fn test_ldexp() {\n+        // We have to use from_str until base-2 exponents\n+        // are supported in floating-point literals\n+        let f1: f32 = from_str_hex(\"1p-123\").unwrap();\n+        let f2: f32 = from_str_hex(\"1p-111\").unwrap();\n+        assert_eq!(Float::ldexp(1f32, -123), f1);\n+        assert_eq!(Float::ldexp(1f32, -111), f2);\n+\n+        assert_eq!(Float::ldexp(0f32, -123), 0f32);\n+        assert_eq!(Float::ldexp(-0f32, -123), -0f32);\n+        assert_eq!(Float::ldexp(Float::infinity::<f32>(), -123),\n+                   Float::infinity::<f32>());\n+        assert_eq!(Float::ldexp(Float::neg_infinity::<f32>(), -123),\n+                   Float::neg_infinity::<f32>());\n+        assert!(Float::ldexp(Float::NaN::<f32>(), -123).is_NaN());\n+    }\n+\n+    #[test]\n+    fn test_frexp() {\n+        // We have to use from_str until base-2 exponents\n+        // are supported in floating-point literals\n+        let f1: f32 = from_str_hex(\"1p-123\").unwrap();\n+        let f2: f32 = from_str_hex(\"1p-111\").unwrap();\n+        let (x1, exp1) = f1.frexp();\n+        let (x2, exp2) = f2.frexp();\n+        assert_eq!((x1, exp1), (0.5f32, -122));\n+        assert_eq!((x2, exp2), (0.5f32, -110));\n+        assert_eq!(Float::ldexp(x1, exp1), f1);\n+        assert_eq!(Float::ldexp(x2, exp2), f2);\n+\n+        assert_eq!(0f32.frexp(), (0f32, 0));\n+        assert_eq!((-0f32).frexp(), (-0f32, 0));\n+        assert_eq!(match Float::infinity::<f32>().frexp() { (x, _) => x },\n+                   Float::infinity::<f32>())\n+        assert_eq!(match Float::neg_infinity::<f32>().frexp() { (x, _) => x },\n+                   Float::neg_infinity::<f32>())\n+        assert!(match Float::NaN::<f32>().frexp() { (x, _) => x.is_NaN() })\n+    }\n }"}, {"sha": "3c9df4040d8eaafd0abd41b40dba7415650fc1e3", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/84745b483f322671f894b9e8d0a462c46275a9d3/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84745b483f322671f894b9e8d0a462c46275a9d3/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=84745b483f322671f894b9e8d0a462c46275a9d3", "patch": "@@ -463,6 +463,57 @@ impl Hyperbolic for f64 {\n \n     #[inline(always)]\n     fn tanh(&self) -> f64 { tanh(*self) }\n+\n+    ///\n+    /// Inverse hyperbolic sine\n+    ///\n+    /// # Returns\n+    ///\n+    /// - on success, the inverse hyperbolic sine of `self` will be returned\n+    /// - `self` if `self` is `0.0`, `-0.0`, `infinity`, or `neg_infinity`\n+    /// - `NaN` if `self` is `NaN`\n+    ///\n+    #[inline(always)]\n+    fn asinh(&self) -> f64 {\n+        match *self {\n+            neg_infinity => neg_infinity,\n+            x => (x + ((x * x) + 1.0).sqrt()).ln(),\n+        }\n+    }\n+\n+    ///\n+    /// Inverse hyperbolic cosine\n+    ///\n+    /// # Returns\n+    ///\n+    /// - on success, the inverse hyperbolic cosine of `self` will be returned\n+    /// - `infinity` if `self` is `infinity`\n+    /// - `NaN` if `self` is `NaN` or `self < 1.0` (including `neg_infinity`)\n+    ///\n+    #[inline(always)]\n+    fn acosh(&self) -> f64 {\n+        match *self {\n+            x if x < 1.0 => Float::NaN(),\n+            x => (x + ((x * x) - 1.0).sqrt()).ln(),\n+        }\n+    }\n+\n+    ///\n+    /// Inverse hyperbolic tangent\n+    ///\n+    /// # Returns\n+    ///\n+    /// - on success, the inverse hyperbolic tangent of `self` will be returned\n+    /// - `self` if `self` is `0.0` or `-0.0`\n+    /// - `infinity` if `self` is `1.0`\n+    /// - `neg_infinity` if `self` is `-1.0`\n+    /// - `NaN` if the `self` is `NaN` or outside the domain of `-1.0 <= self <= 1.0`\n+    ///   (including `infinity` and `neg_infinity`)\n+    ///\n+    #[inline(always)]\n+    fn atanh(&self) -> f64 {\n+        0.5 * ((2.0 * *self) / (1.0 - *self)).ln_1p()\n+    }\n }\n \n impl Real for f64 {\n@@ -663,6 +714,25 @@ impl Float for f64 {\n     #[inline(always)]\n     fn max_10_exp() -> int { 308 }\n \n+    /// Constructs a floating point number by multiplying `x` by 2 raised to the power of `exp`\n+    #[inline(always)]\n+    fn ldexp(x: f64, exp: int) -> f64 {\n+        ldexp(x, exp as c_int)\n+    }\n+\n+    ///\n+    /// Breaks the number into a normalized fraction and a base-2 exponent, satisfying:\n+    ///\n+    /// - `self = x * pow(2, exp)`\n+    /// - `0.5 <= abs(x) < 1.0`\n+    ///\n+    #[inline(always)]\n+    fn frexp(&self) -> (f64, int) {\n+        let mut exp = 0;\n+        let x = frexp(*self, &mut exp);\n+        (x, exp as int)\n+    }\n+\n     ///\n     /// Returns the exponential of the number, minus `1`, in a way that is accurate\n     /// even if the number is close to zero\n@@ -1019,6 +1089,43 @@ mod tests {\n         assert_approx_eq!((-1.7f64).fract(), -0.7f64);\n     }\n \n+    #[test]\n+    fn test_asinh() {\n+        assert_eq!(0.0f64.asinh(), 0.0f64);\n+        assert_eq!((-0.0f64).asinh(), -0.0f64);\n+        assert_eq!(Float::infinity::<f64>().asinh(), Float::infinity::<f64>());\n+        assert_eq!(Float::neg_infinity::<f64>().asinh(), Float::neg_infinity::<f64>());\n+        assert!(Float::NaN::<f64>().asinh().is_NaN());\n+        assert_approx_eq!(2.0f64.asinh(), 1.443635475178810342493276740273105f64);\n+        assert_approx_eq!((-2.0f64).asinh(), -1.443635475178810342493276740273105f64);\n+    }\n+\n+    #[test]\n+    fn test_acosh() {\n+        assert_eq!(1.0f64.acosh(), 0.0f64);\n+        assert!(0.999f64.acosh().is_NaN());\n+        assert_eq!(Float::infinity::<f64>().acosh(), Float::infinity::<f64>());\n+        assert!(Float::neg_infinity::<f64>().acosh().is_NaN());\n+        assert!(Float::NaN::<f64>().acosh().is_NaN());\n+        assert_approx_eq!(2.0f64.acosh(), 1.31695789692481670862504634730796844f64);\n+        assert_approx_eq!(3.0f64.acosh(), 1.76274717403908605046521864995958461f64);\n+    }\n+\n+    #[test]\n+    fn test_atanh() {\n+        assert_eq!(0.0f64.atanh(), 0.0f64);\n+        assert_eq!((-0.0f64).atanh(), -0.0f64);\n+        assert_eq!(1.0f64.atanh(), Float::infinity::<f64>());\n+        assert_eq!((-1.0f64).atanh(), Float::neg_infinity::<f64>());\n+        assert!(2f64.atanh().atanh().is_NaN());\n+        assert!((-2f64).atanh().atanh().is_NaN());\n+        assert!(Float::infinity::<f64>().atanh().is_NaN());\n+        assert!(Float::neg_infinity::<f64>().atanh().is_NaN());\n+        assert!(Float::NaN::<f64>().atanh().is_NaN());\n+        assert_approx_eq!(0.5f64.atanh(), 0.54930614433405484569762261846126285f64);\n+        assert_approx_eq!((-0.5f64).atanh(), -0.54930614433405484569762261846126285f64);\n+    }\n+\n     #[test]\n     fn test_real_consts() {\n         assert_approx_eq!(Real::two_pi::<f64>(), 2.0 * Real::pi::<f64>());\n@@ -1137,4 +1244,44 @@ mod tests {\n         assert_eq!(1e-307f64.classify(), FPNormal);\n         assert_eq!(1e-308f64.classify(), FPSubnormal);\n     }\n+\n+    #[test]\n+    fn test_ldexp() {\n+        // We have to use from_str until base-2 exponents\n+        // are supported in floating-point literals\n+        let f1: f64 = from_str_hex(\"1p-123\").unwrap();\n+        let f2: f64 = from_str_hex(\"1p-111\").unwrap();\n+        assert_eq!(Float::ldexp(1f64, -123), f1);\n+        assert_eq!(Float::ldexp(1f64, -111), f2);\n+\n+        assert_eq!(Float::ldexp(0f64, -123), 0f64);\n+        assert_eq!(Float::ldexp(-0f64, -123), -0f64);\n+        assert_eq!(Float::ldexp(Float::infinity::<f64>(), -123),\n+                   Float::infinity::<f64>());\n+        assert_eq!(Float::ldexp(Float::neg_infinity::<f64>(), -123),\n+                   Float::neg_infinity::<f64>());\n+        assert!(Float::ldexp(Float::NaN::<f64>(), -123).is_NaN());\n+    }\n+\n+    #[test]\n+    fn test_frexp() {\n+        // We have to use from_str until base-2 exponents\n+        // are supported in floating-point literals\n+        let f1: f64 = from_str_hex(\"1p-123\").unwrap();\n+        let f2: f64 = from_str_hex(\"1p-111\").unwrap();\n+        let (x1, exp1) = f1.frexp();\n+        let (x2, exp2) = f2.frexp();\n+        assert_eq!((x1, exp1), (0.5f64, -122));\n+        assert_eq!((x2, exp2), (0.5f64, -110));\n+        assert_eq!(Float::ldexp(x1, exp1), f1);\n+        assert_eq!(Float::ldexp(x2, exp2), f2);\n+\n+        assert_eq!(0f64.frexp(), (0f64, 0));\n+        assert_eq!((-0f64).frexp(), (-0f64, 0));\n+        assert_eq!(match Float::infinity::<f64>().frexp() { (x, _) => x },\n+                   Float::infinity::<f64>())\n+        assert_eq!(match Float::neg_infinity::<f64>().frexp() { (x, _) => x },\n+                   Float::neg_infinity::<f64>())\n+        assert!(match Float::NaN::<f64>().frexp() { (x, _) => x.is_NaN() })\n+    }\n }"}, {"sha": "22abc76c3d328197918ad23fd8c7ed5275e680ce", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 144, "deletions": 1, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/84745b483f322671f894b9e8d0a462c46275a9d3/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84745b483f322671f894b9e8d0a462c46275a9d3/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=84745b483f322671f894b9e8d0a462c46275a9d3", "patch": "@@ -585,6 +585,51 @@ impl Hyperbolic for float {\n     fn tanh(&self) -> float {\n         (*self as f64).tanh() as float\n     }\n+\n+    ///\n+    /// Inverse hyperbolic sine\n+    ///\n+    /// # Returns\n+    ///\n+    /// - on success, the inverse hyperbolic sine of `self` will be returned\n+    /// - `self` if `self` is `0.0`, `-0.0`, `infinity`, or `neg_infinity`\n+    /// - `NaN` if `self` is `NaN`\n+    ///\n+    #[inline(always)]\n+    fn asinh(&self) -> float {\n+        (*self as f64).asinh() as float\n+    }\n+\n+    ///\n+    /// Inverse hyperbolic cosine\n+    ///\n+    /// # Returns\n+    ///\n+    /// - on success, the inverse hyperbolic cosine of `self` will be returned\n+    /// - `infinity` if `self` is `infinity`\n+    /// - `NaN` if `self` is `NaN` or `self < 1.0` (including `neg_infinity`)\n+    ///\n+    #[inline(always)]\n+    fn acosh(&self) -> float {\n+        (*self as f64).acosh() as float\n+    }\n+\n+    ///\n+    /// Inverse hyperbolic tangent\n+    ///\n+    /// # Returns\n+    ///\n+    /// - on success, the inverse hyperbolic tangent of `self` will be returned\n+    /// - `self` if `self` is `0.0` or `-0.0`\n+    /// - `infinity` if `self` is `1.0`\n+    /// - `neg_infinity` if `self` is `-1.0`\n+    /// - `NaN` if the `self` is `NaN` or outside the domain of `-1.0 <= self <= 1.0`\n+    ///   (including `infinity` and `neg_infinity`)\n+    ///\n+    #[inline(always)]\n+    fn atanh(&self) -> float {\n+        (*self as f64).atanh() as float\n+    }\n }\n \n impl Real for float {\n@@ -836,6 +881,25 @@ impl Float for float {\n     #[inline(always)]\n     fn max_10_exp() -> int { Float::max_10_exp::<f64>() }\n \n+    /// Constructs a floating point number by multiplying `x` by 2 raised to the power of `exp`\n+    #[inline(always)]\n+    fn ldexp(x: float, exp: int) -> float {\n+        Float::ldexp(x as f64, exp) as float\n+    }\n+\n+    ///\n+    /// Breaks the number into a normalized fraction and a base-2 exponent, satisfying:\n+    ///\n+    /// - `self = x * pow(2, exp)`\n+    /// - `0.5 <= abs(x) < 1.0`\n+    ///\n+    #[inline(always)]\n+    fn frexp(&self) -> (float, int) {\n+        match (*self as f64).frexp() {\n+            (x, exp) => (x as float, exp)\n+        }\n+    }\n+\n     ///\n     /// Returns the exponential of the number, minus `1`, in a way that is accurate\n     /// even if the number is close to zero\n@@ -850,7 +914,9 @@ impl Float for float {\n     /// than if the operations were performed separately\n     ///\n     #[inline(always)]\n-    fn ln_1p(&self) -> float { (*self as f64).ln_1p() as float }\n+    fn ln_1p(&self) -> float {\n+        (*self as f64).ln_1p() as float\n+    }\n \n     ///\n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n@@ -972,6 +1038,43 @@ mod tests {\n         assert_approx_eq!((-1.7f).fract(), -0.7f);\n     }\n \n+    #[test]\n+    fn test_asinh() {\n+        assert_eq!(0.0f.asinh(), 0.0f);\n+        assert_eq!((-0.0f).asinh(), -0.0f);\n+        assert_eq!(Float::infinity::<float>().asinh(), Float::infinity::<float>());\n+        assert_eq!(Float::neg_infinity::<float>().asinh(), Float::neg_infinity::<float>());\n+        assert!(Float::NaN::<float>().asinh().is_NaN());\n+        assert_approx_eq!(2.0f.asinh(), 1.443635475178810342493276740273105f);\n+        assert_approx_eq!((-2.0f).asinh(), -1.443635475178810342493276740273105f);\n+    }\n+\n+    #[test]\n+    fn test_acosh() {\n+        assert_eq!(1.0f.acosh(), 0.0f);\n+        assert!(0.999f.acosh().is_NaN());\n+        assert_eq!(Float::infinity::<float>().acosh(), Float::infinity::<float>());\n+        assert!(Float::neg_infinity::<float>().acosh().is_NaN());\n+        assert!(Float::NaN::<float>().acosh().is_NaN());\n+        assert_approx_eq!(2.0f.acosh(), 1.31695789692481670862504634730796844f);\n+        assert_approx_eq!(3.0f.acosh(), 1.76274717403908605046521864995958461f);\n+    }\n+\n+    #[test]\n+    fn test_atanh() {\n+        assert_eq!(0.0f.atanh(), 0.0f);\n+        assert_eq!((-0.0f).atanh(), -0.0f);\n+        assert_eq!(1.0f.atanh(), Float::infinity::<float>());\n+        assert_eq!((-1.0f).atanh(), Float::neg_infinity::<float>());\n+        assert!(2f64.atanh().atanh().is_NaN());\n+        assert!((-2f64).atanh().atanh().is_NaN());\n+        assert!(Float::infinity::<f64>().atanh().is_NaN());\n+        assert!(Float::neg_infinity::<f64>().atanh().is_NaN());\n+        assert!(Float::NaN::<float>().atanh().is_NaN());\n+        assert_approx_eq!(0.5f.atanh(), 0.54930614433405484569762261846126285f);\n+        assert_approx_eq!((-0.5f).atanh(), -0.54930614433405484569762261846126285f);\n+    }\n+\n     #[test]\n     fn test_real_consts() {\n         assert_approx_eq!(Real::two_pi::<float>(), 2f * Real::pi::<float>());\n@@ -1092,6 +1195,46 @@ mod tests {\n         assert_eq!(1e-308f.classify(), FPSubnormal);\n     }\n \n+    #[test]\n+    fn test_ldexp() {\n+        // We have to use from_str until base-2 exponents\n+        // are supported in floating-point literals\n+        let f1: float = from_str_hex(\"1p-123\").unwrap();\n+        let f2: float = from_str_hex(\"1p-111\").unwrap();\n+        assert_eq!(Float::ldexp(1f, -123), f1);\n+        assert_eq!(Float::ldexp(1f, -111), f2);\n+\n+        assert_eq!(Float::ldexp(0f, -123), 0f);\n+        assert_eq!(Float::ldexp(-0f, -123), -0f);\n+        assert_eq!(Float::ldexp(Float::infinity::<float>(), -123),\n+                   Float::infinity::<float>());\n+        assert_eq!(Float::ldexp(Float::neg_infinity::<float>(), -123),\n+                   Float::neg_infinity::<float>());\n+        assert!(Float::ldexp(Float::NaN::<float>(), -123).is_NaN());\n+    }\n+\n+    #[test]\n+    fn test_frexp() {\n+        // We have to use from_str until base-2 exponents\n+        // are supported in floating-point literals\n+        let f1: float = from_str_hex(\"1p-123\").unwrap();\n+        let f2: float = from_str_hex(\"1p-111\").unwrap();\n+        let (x1, exp1) = f1.frexp();\n+        let (x2, exp2) = f2.frexp();\n+        assert_eq!((x1, exp1), (0.5f, -122));\n+        assert_eq!((x2, exp2), (0.5f, -110));\n+        assert_eq!(Float::ldexp(x1, exp1), f1);\n+        assert_eq!(Float::ldexp(x2, exp2), f2);\n+\n+        assert_eq!(0f.frexp(), (0f, 0));\n+        assert_eq!((-0f).frexp(), (-0f, 0));\n+        assert_eq!(match Float::infinity::<float>().frexp() { (x, _) => x },\n+                   Float::infinity::<float>())\n+        assert_eq!(match Float::neg_infinity::<float>().frexp() { (x, _) => x },\n+                   Float::neg_infinity::<float>())\n+        assert!(match Float::NaN::<float>().frexp() { (x, _) => x.is_NaN() })\n+    }\n+\n     #[test]\n     pub fn test_to_str_exact_do_decimal() {\n         let s = to_str_exact(5.0, 4u);"}, {"sha": "a15a8f1a2153eb3b924f49d84f6b8bebf6d335e9", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/84745b483f322671f894b9e8d0a462c46275a9d3/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84745b483f322671f894b9e8d0a462c46275a9d3/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=84745b483f322671f894b9e8d0a462c46275a9d3", "patch": "@@ -133,6 +133,9 @@ pub trait Hyperbolic: Exponential {\n     fn sinh(&self) -> Self;\n     fn cosh(&self) -> Self;\n     fn tanh(&self) -> Self;\n+    fn asinh(&self) -> Self;\n+    fn acosh(&self) -> Self;\n+    fn atanh(&self) -> Self;\n }\n \n ///\n@@ -281,6 +284,9 @@ pub trait Float: Real\n     fn min_10_exp() -> int;\n     fn max_10_exp() -> int;\n \n+    fn ldexp(x: Self, exp: int) -> Self;\n+    fn frexp(&self) -> (Self, int);\n+\n     fn exp_m1(&self) -> Self;\n     fn ln_1p(&self) -> Self;\n     fn mul_add(&self, a: Self, b: Self) -> Self;"}]}