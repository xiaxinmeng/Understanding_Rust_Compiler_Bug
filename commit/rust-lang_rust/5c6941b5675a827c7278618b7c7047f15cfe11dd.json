{"sha": "5c6941b5675a827c7278618b7c7047f15cfe11dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjNjk0MWI1Njc1YTgyN2M3Mjc4NjE4YjdjNzA0N2YxNWNmZTExZGQ=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-12-09T22:33:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-09T22:33:02Z"}, "message": "Rollup merge of #67106 - petrochenkov:docerr, r=matthewjasper\n\nresolve: Resolve visibilities on fields with non-builtin attributes\n\nFollow-up to https://github.com/rust-lang/rust/pull/66669.\n\nThe first commit is primary (and also a backport candidate), the other ones are further cleanups.\nIn this case it's not strictly necessary to avoid reporting errors during speculative resolution because 1) all visibilities are resolved non-speculatively sooner or later and 2) error reporting infrastructure merges identical errors with identical spans anyway.\n\nFixes https://github.com/rust-lang/rust/issues/67006\nr? @matthewjasper", "tree": {"sha": "49fa960897739dda8a37d246cc77c0af965d8271", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49fa960897739dda8a37d246cc77c0af965d8271"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c6941b5675a827c7278618b7c7047f15cfe11dd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd7sueCRBK7hj4Ov3rIwAAdHIIAKf9pQf8w66pxBIO4g6rPI/s\nM3pBwlp+/ngqsXUsNIpglnzsbaX+EODTfa9IgBqBhd90kMk9nJgbvoaipbhz/0Gn\nlreke5kFO9ruGGvck/vIMrdPSeowu8/62HT+xhiaqioZTptZ/rLEdoVJR/JjHgmw\nij/ZFRDUV4dE/J/I8q67nZTYDXeeSKUPyl+nt7Y4CUxoaqgzRSCxSqEpU3SfRjp6\n7L56jqkNfJzFPdP/CBbkORLw4NLHS11aeVI42o+6U12/p3DwKO/4DvzOulehTEoW\neFNoB4dXXHbiDACCPqQRawesiG8KBzBaonQuocESGgXDZ8rpX4lFXAuDhI1TzU0=\n=/JYi\n-----END PGP SIGNATURE-----\n", "payload": "tree 49fa960897739dda8a37d246cc77c0af965d8271\nparent 4166ce8674f2dcc136b50f55094c7cc580c933a3\nparent 5f6267c8b34bdb6e75012b817e64d15cf6e3b45a\nauthor Tyler Mandry <tmandry@gmail.com> 1575930782 -0800\ncommitter GitHub <noreply@github.com> 1575930782 -0800\n\nRollup merge of #67106 - petrochenkov:docerr, r=matthewjasper\n\nresolve: Resolve visibilities on fields with non-builtin attributes\n\nFollow-up to https://github.com/rust-lang/rust/pull/66669.\n\nThe first commit is primary (and also a backport candidate), the other ones are further cleanups.\nIn this case it's not strictly necessary to avoid reporting errors during speculative resolution because 1) all visibilities are resolved non-speculatively sooner or later and 2) error reporting infrastructure merges identical errors with identical spans anyway.\n\nFixes https://github.com/rust-lang/rust/issues/67006\nr? @matthewjasper\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c6941b5675a827c7278618b7c7047f15cfe11dd", "html_url": "https://github.com/rust-lang/rust/commit/5c6941b5675a827c7278618b7c7047f15cfe11dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c6941b5675a827c7278618b7c7047f15cfe11dd/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4166ce8674f2dcc136b50f55094c7cc580c933a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/4166ce8674f2dcc136b50f55094c7cc580c933a3", "html_url": "https://github.com/rust-lang/rust/commit/4166ce8674f2dcc136b50f55094c7cc580c933a3"}, {"sha": "5f6267c8b34bdb6e75012b817e64d15cf6e3b45a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f6267c8b34bdb6e75012b817e64d15cf6e3b45a", "html_url": "https://github.com/rust-lang/rust/commit/5f6267c8b34bdb6e75012b817e64d15cf6e3b45a"}], "stats": {"total": 250, "additions": 162, "deletions": 88}, "files": [{"sha": "566ba129074370b0cba3dd10f151724577225fa2", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 73, "deletions": 88, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/5c6941b5675a827c7278618b7c7047f15cfe11dd/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6941b5675a827c7278618b7c7047f15cfe11dd/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=5c6941b5675a827c7278618b7c7047f15cfe11dd", "patch": "@@ -12,7 +12,7 @@ use crate::resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleIm\n use crate::{Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, Segment, ToNameBinding};\n use crate::{ModuleOrUniformRoot, ParentScope, PerNS, Resolver, ResolverArenas, ExternPreludeEntry};\n use crate::Namespace::{self, TypeNS, ValueNS, MacroNS};\n-use crate::{ResolutionError, Determinacy, PathResult, CrateLint};\n+use crate::{ResolutionError, VisResolutionError, Determinacy, PathResult, CrateLint};\n \n use rustc::bug;\n use rustc::hir::def::{self, *};\n@@ -32,8 +32,7 @@ use syntax::attr;\n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind, NodeId};\n use syntax::ast::{MetaItemKind, StmtKind, TraitItem, TraitItemKind};\n use syntax::token::{self, Token};\n-use syntax::print::pprust;\n-use syntax::{span_err, struct_span_err};\n+use syntax::span_err;\n use syntax::source_map::{respan, Spanned};\n use syntax::symbol::{kw, sym};\n use syntax::visit::{self, Visitor};\n@@ -192,14 +191,25 @@ impl<'a> AsMut<Resolver<'a>> for BuildReducedGraphVisitor<'a, '_> {\n \n impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn resolve_visibility(&mut self, vis: &ast::Visibility) -> ty::Visibility {\n+        self.resolve_visibility_speculative(vis, false).unwrap_or_else(|err| {\n+            self.r.report_vis_error(err);\n+            ty::Visibility::Public\n+        })\n+    }\n+\n+    fn resolve_visibility_speculative<'ast>(\n+        &mut self,\n+        vis: &'ast ast::Visibility,\n+        speculative: bool,\n+    ) -> Result<ty::Visibility, VisResolutionError<'ast>> {\n         let parent_scope = &self.parent_scope;\n         match vis.node {\n-            ast::VisibilityKind::Public => ty::Visibility::Public,\n+            ast::VisibilityKind::Public => Ok(ty::Visibility::Public),\n             ast::VisibilityKind::Crate(..) => {\n-                ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))\n+                Ok(ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX)))\n             }\n             ast::VisibilityKind::Inherited => {\n-                ty::Visibility::Restricted(parent_scope.module.normal_ancestor_id)\n+                Ok(ty::Visibility::Restricted(parent_scope.module.normal_ancestor_id))\n             }\n             ast::VisibilityKind::Restricted { ref path, id, .. } => {\n                 // For visibilities we are not ready to provide correct implementation of \"uniform\n@@ -209,86 +219,67 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 let ident = path.segments.get(0).expect(\"empty path in visibility\").ident;\n                 let crate_root = if ident.is_path_segment_keyword() {\n                     None\n-                } else if ident.span.rust_2018() {\n-                    let msg = \"relative paths are not supported in visibilities on 2018 edition\";\n-                    self.r.session.struct_span_err(ident.span, msg)\n-                        .span_suggestion(\n-                            path.span,\n-                            \"try\",\n-                            format!(\"crate::{}\", pprust::path_to_string(&path)),\n-                            Applicability::MaybeIncorrect,\n-                        )\n-                        .emit();\n-                    return ty::Visibility::Public;\n-                } else {\n-                    let ctxt = ident.span.ctxt();\n+                } else if ident.span.rust_2015() {\n                     Some(Segment::from_ident(Ident::new(\n-                        kw::PathRoot, path.span.shrink_to_lo().with_ctxt(ctxt)\n+                        kw::PathRoot, path.span.shrink_to_lo().with_ctxt(ident.span.ctxt())\n                     )))\n+                } else {\n+                    return Err(VisResolutionError::Relative2018(ident.span, path));\n                 };\n \n                 let segments = crate_root.into_iter()\n                     .chain(path.segments.iter().map(|seg| seg.into())).collect::<Vec<_>>();\n-                let expected_found_error = |this: &Self, res: Res| {\n-                    let path_str = Segment::names_to_string(&segments);\n-                    struct_span_err!(this.r.session, path.span, E0577,\n-                                     \"expected module, found {} `{}`\", res.descr(), path_str)\n-                        .span_label(path.span, \"not a module\").emit();\n-                };\n+                let expected_found_error = |res| Err(VisResolutionError::ExpectedFound(\n+                    path.span, Segment::names_to_string(&segments), res\n+                ));\n                 match self.r.resolve_path(\n                     &segments,\n                     Some(TypeNS),\n                     parent_scope,\n-                    true,\n+                    !speculative,\n                     path.span,\n                     CrateLint::SimplePath(id),\n                 ) {\n                     PathResult::Module(ModuleOrUniformRoot::Module(module)) => {\n                         let res = module.res().expect(\"visibility resolved to unnamed block\");\n-                        self.r.record_partial_res(id, PartialRes::new(res));\n+                        if !speculative {\n+                            self.r.record_partial_res(id, PartialRes::new(res));\n+                        }\n                         if module.is_normal() {\n                             if res == Res::Err {\n-                                ty::Visibility::Public\n+                                Ok(ty::Visibility::Public)\n                             } else {\n                                 let vis = ty::Visibility::Restricted(res.def_id());\n                                 if self.r.is_accessible_from(vis, parent_scope.module) {\n-                                    vis\n+                                    Ok(vis)\n                                 } else {\n-                                    struct_span_err!(self.r.session, path.span, E0742,\n-                                        \"visibilities can only be restricted to ancestor modules\")\n-                                        .emit();\n-                                    ty::Visibility::Public\n+                                    Err(VisResolutionError::AncestorOnly(path.span))\n                                 }\n                             }\n                         } else {\n-                            expected_found_error(self, res);\n-                            ty::Visibility::Public\n+                            expected_found_error(res)\n                         }\n                     }\n-                    PathResult::Module(..) => {\n-                        self.r.session.span_err(path.span, \"visibility must resolve to a module\");\n-                        ty::Visibility::Public\n-                    }\n-                    PathResult::NonModule(partial_res) => {\n-                        expected_found_error(self, partial_res.base_res());\n-                        ty::Visibility::Public\n-                    }\n-                    PathResult::Failed { span, label, suggestion, .. } => {\n-                        self.r.report_error(\n-                            span, ResolutionError::FailedToResolve { label, suggestion }\n-                        );\n-                        ty::Visibility::Public\n-                    }\n-                    PathResult::Indeterminate => {\n-                        span_err!(self.r.session, path.span, E0578,\n-                                  \"cannot determine resolution for the visibility\");\n-                        ty::Visibility::Public\n-                    }\n+                    PathResult::Module(..) =>\n+                        Err(VisResolutionError::ModuleOnly(path.span)),\n+                    PathResult::NonModule(partial_res) =>\n+                        expected_found_error(partial_res.base_res()),\n+                    PathResult::Failed { span, label, suggestion, .. } =>\n+                        Err(VisResolutionError::FailedToResolve(span, label, suggestion)),\n+                    PathResult::Indeterminate =>\n+                        Err(VisResolutionError::Indeterminate(path.span)),\n                 }\n             }\n         }\n     }\n \n+    fn insert_field_names_local(&mut self, def_id: DefId, vdata: &ast::VariantData) {\n+        let field_names = vdata.fields().iter().map(|field| {\n+            respan(field.span, field.ident.map_or(kw::Invalid, |ident| ident.name))\n+        }).collect();\n+        self.insert_field_names(def_id, field_names);\n+    }\n+\n     fn insert_field_names(&mut self, def_id: DefId, field_names: Vec<Spanned<Name>>) {\n         if !field_names.is_empty() {\n             self.r.field_names.insert(def_id, field_names);\n@@ -726,59 +717,52 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             }\n \n             // These items live in both the type and value namespaces.\n-            ItemKind::Struct(ref struct_def, _) => {\n+            ItemKind::Struct(ref vdata, _) => {\n                 // Define a name in the type namespace.\n                 let def_id = self.r.definitions.local_def_id(item.id);\n                 let res = Res::Def(DefKind::Struct, def_id);\n                 self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n \n-                let mut ctor_vis = vis;\n-\n-                let has_non_exhaustive = attr::contains_name(&item.attrs, sym::non_exhaustive);\n-\n-                // If the structure is marked as non_exhaustive then lower the visibility\n-                // to within the crate.\n-                if has_non_exhaustive && vis == ty::Visibility::Public {\n-                    ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n-                }\n-\n                 // Record field names for error reporting.\n-                let field_names = struct_def.fields().iter().map(|field| {\n-                    // NOTE: The field may be an expansion placeholder, but expansion sets correct\n-                    // visibilities for unnamed field placeholders specifically, so the constructor\n-                    // visibility should still be determined correctly.\n-                    let field_vis = self.resolve_visibility(&field.vis);\n-                    if ctor_vis.is_at_least(field_vis, &*self.r) {\n-                        ctor_vis = field_vis;\n-                    }\n-                    respan(field.span, field.ident.map_or(kw::Invalid, |ident| ident.name))\n-                }).collect();\n-                let item_def_id = self.r.definitions.local_def_id(item.id);\n-                self.insert_field_names(item_def_id, field_names);\n+                self.insert_field_names_local(def_id, vdata);\n \n                 // If this is a tuple or unit struct, define a name\n                 // in the value namespace as well.\n-                if let Some(ctor_node_id) = struct_def.ctor_id() {\n+                if let Some(ctor_node_id) = vdata.ctor_id() {\n+                    let mut ctor_vis = vis;\n+                    // If the structure is marked as non_exhaustive then lower the visibility\n+                    // to within the crate.\n+                    if vis == ty::Visibility::Public &&\n+                       attr::contains_name(&item.attrs, sym::non_exhaustive) {\n+                        ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n+                    }\n+                    for field in vdata.fields() {\n+                        // NOTE: The field may be an expansion placeholder, but expansion sets\n+                        // correct visibilities for unnamed field placeholders specifically, so the\n+                        // constructor visibility should still be determined correctly.\n+                        if let Ok(field_vis) =\n+                                self.resolve_visibility_speculative(&field.vis, true) {\n+                            if ctor_vis.is_at_least(field_vis, &*self.r) {\n+                                ctor_vis = field_vis;\n+                            }\n+                        }\n+                    }\n                     let ctor_res = Res::Def(\n-                        DefKind::Ctor(CtorOf::Struct, CtorKind::from_ast(struct_def)),\n+                        DefKind::Ctor(CtorOf::Struct, CtorKind::from_ast(vdata)),\n                         self.r.definitions.local_def_id(ctor_node_id),\n                     );\n                     self.r.define(parent, ident, ValueNS, (ctor_res, ctor_vis, sp, expansion));\n-                    self.r.struct_constructors.insert(res.def_id(), (ctor_res, ctor_vis));\n+                    self.r.struct_constructors.insert(def_id, (ctor_res, ctor_vis));\n                 }\n             }\n \n             ItemKind::Union(ref vdata, _) => {\n-                let res = Res::Def(DefKind::Union, self.r.definitions.local_def_id(item.id));\n+                let def_id = self.r.definitions.local_def_id(item.id);\n+                let res = Res::Def(DefKind::Union, def_id);\n                 self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n \n                 // Record field names for error reporting.\n-                let field_names = vdata.fields().iter().map(|field| {\n-                    self.resolve_visibility(&field.vis);\n-                    respan(field.span, field.ident.map_or(kw::Invalid, |ident| ident.name))\n-                }).collect();\n-                let item_def_id = self.r.definitions.local_def_id(item.id);\n-                self.insert_field_names(item_def_id, field_names);\n+                self.insert_field_names_local(def_id, vdata);\n             }\n \n             ItemKind::Impl(.., ref impl_items) => {\n@@ -1281,6 +1265,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n         if sf.is_placeholder {\n             self.visit_invoc(sf.id);\n         } else {\n+            self.resolve_visibility(&sf.vis);\n             visit::walk_struct_field(self, sf);\n         }\n     }"}, {"sha": "f92415fc0521a2fd802754cb43ab876fd1f46199", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5c6941b5675a827c7278618b7c7047f15cfe11dd/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6941b5675a827c7278618b7c7047f15cfe11dd/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=5c6941b5675a827c7278618b7c7047f15cfe11dd", "patch": "@@ -11,6 +11,7 @@ use rustc::ty::{self, DefIdTree};\n use rustc::util::nodemap::FxHashSet;\n use rustc_feature::BUILTIN_ATTRIBUTES;\n use syntax::ast::{self, Ident, Path};\n+use syntax::print::pprust;\n use syntax::source_map::SourceMap;\n use syntax::struct_span_err;\n use syntax::symbol::{Symbol, kw};\n@@ -22,6 +23,7 @@ use crate::resolve_imports::{ImportDirective, ImportDirectiveSubclass, ImportRes\n use crate::path_names_to_string;\n use crate::{BindingError, CrateLint, HasGenericParams, LegacyScope, Module, ModuleOrUniformRoot};\n use crate::{PathResult, ParentScope, ResolutionError, Resolver, Scope, ScopeSet, Segment};\n+use crate::VisResolutionError;\n \n use rustc_error_codes::*;\n \n@@ -357,6 +359,44 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    crate fn report_vis_error(&self, vis_resolution_error: VisResolutionError<'_>) {\n+        match vis_resolution_error {\n+            VisResolutionError::Relative2018(span, path) => {\n+                let mut err = self.session.struct_span_err(span,\n+                    \"relative paths are not supported in visibilities on 2018 edition\");\n+                err.span_suggestion(\n+                    path.span,\n+                    \"try\",\n+                    format!(\"crate::{}\", pprust::path_to_string(&path)),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                err\n+            }\n+            VisResolutionError::AncestorOnly(span) => {\n+                struct_span_err!(self.session, span, E0742,\n+                    \"visibilities can only be restricted to ancestor modules\")\n+            }\n+            VisResolutionError::FailedToResolve(span, label, suggestion) => {\n+                self.into_struct_error(\n+                    span, ResolutionError::FailedToResolve { label, suggestion }\n+                )\n+            }\n+            VisResolutionError::ExpectedFound(span, path_str, res) => {\n+                let mut err = struct_span_err!(self.session, span, E0577,\n+                    \"expected module, found {} `{}`\", res.descr(), path_str);\n+                err.span_label(span, \"not a module\");\n+                err\n+            }\n+            VisResolutionError::Indeterminate(span) => {\n+                struct_span_err!(self.session, span, E0578,\n+                    \"cannot determine resolution for the visibility\")\n+            }\n+            VisResolutionError::ModuleOnly(span) => {\n+                self.session.struct_span_err(span, \"visibility must resolve to a module\")\n+            }\n+        }.emit()\n+    }\n+\n     /// Lookup typo candidate in scope for a macro or import.\n     fn early_lookup_typo_candidate(\n         &mut self,"}, {"sha": "9db89c8273d9c16b956d9a5a122efb95b1a3aa7f", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5c6941b5675a827c7278618b7c7047f15cfe11dd/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6941b5675a827c7278618b7c7047f15cfe11dd/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=5c6941b5675a827c7278618b7c7047f15cfe11dd", "patch": "@@ -218,6 +218,15 @@ enum ResolutionError<'a> {\n     SelfInTyParamDefault,\n }\n \n+enum VisResolutionError<'a> {\n+    Relative2018(Span, &'a ast::Path),\n+    AncestorOnly(Span),\n+    FailedToResolve(Span, String, Option<Suggestion>),\n+    ExpectedFound(Span, String, Res),\n+    Indeterminate(Span),\n+    ModuleOnly(Span),\n+}\n+\n // A minimal representation of a path segment. We use this in resolve because\n // we synthesize 'path segments' which don't have the rest of an AST or HIR\n // `PathSegment`."}, {"sha": "d1bd2a1e7272416d95ad11145bb4151fdbf1f2c5", "filename": "src/test/ui/attributes/field-attributes-vis-unresolved.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5c6941b5675a827c7278618b7c7047f15cfe11dd/src%2Ftest%2Fui%2Fattributes%2Ffield-attributes-vis-unresolved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6941b5675a827c7278618b7c7047f15cfe11dd/src%2Ftest%2Fui%2Fattributes%2Ffield-attributes-vis-unresolved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Ffield-attributes-vis-unresolved.rs?ref=5c6941b5675a827c7278618b7c7047f15cfe11dd", "patch": "@@ -0,0 +1,25 @@\n+// Non-builtin attributes do not mess with field visibility resolution (issue #67006).\n+\n+mod internal {\n+    struct S {\n+        #[rustfmt::skip]\n+        pub(in crate::internal) field: u8 // OK\n+    }\n+\n+    struct Z(\n+        #[rustfmt::skip]\n+        pub(in crate::internal) u8 // OK\n+    );\n+}\n+\n+struct S {\n+    #[rustfmt::skip]\n+    pub(in nonexistent) field: u8 //~ ERROR failed to resolve\n+}\n+\n+struct Z(\n+    #[rustfmt::skip]\n+    pub(in nonexistent) u8 //~ ERROR failed to resolve\n+);\n+\n+fn main() {}"}, {"sha": "41c3cea3021354d56ba96a3a97adcd726fee0e50", "filename": "src/test/ui/attributes/field-attributes-vis-unresolved.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5c6941b5675a827c7278618b7c7047f15cfe11dd/src%2Ftest%2Fui%2Fattributes%2Ffield-attributes-vis-unresolved.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c6941b5675a827c7278618b7c7047f15cfe11dd/src%2Ftest%2Fui%2Fattributes%2Ffield-attributes-vis-unresolved.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Ffield-attributes-vis-unresolved.stderr?ref=5c6941b5675a827c7278618b7c7047f15cfe11dd", "patch": "@@ -0,0 +1,15 @@\n+error[E0433]: failed to resolve: maybe a missing crate `nonexistent`?\n+  --> $DIR/field-attributes-vis-unresolved.rs:17:12\n+   |\n+LL |     pub(in nonexistent) field: u8\n+   |            ^^^^^^^^^^^ maybe a missing crate `nonexistent`?\n+\n+error[E0433]: failed to resolve: maybe a missing crate `nonexistent`?\n+  --> $DIR/field-attributes-vis-unresolved.rs:22:12\n+   |\n+LL |     pub(in nonexistent) u8\n+   |            ^^^^^^^^^^^ maybe a missing crate `nonexistent`?\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0433`."}]}