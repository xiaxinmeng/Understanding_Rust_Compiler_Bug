{"sha": "a43da5a09701469e013c623c7cfc1e2f7ec83e47", "node_id": "C_kwDOAAsO6NoAKGE0M2RhNWEwOTcwMTQ2OWUwMTNjNjIzYzdjZmMxZTJmN2VjODNlNDc", "commit": {"author": {"name": "Ibraheem Ahmed", "email": "ibraheem@ibraheem.ca", "date": "2022-10-17T23:09:54Z"}, "committer": {"name": "Ibraheem Ahmed", "email": "ibraheem@ibraheem.ca", "date": "2022-11-10T04:18:06Z"}, "message": "initial port of crossbeam-channel", "tree": {"sha": "98571ae0b14396eb66f93c80bbaee632643449eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98571ae0b14396eb66f93c80bbaee632643449eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a43da5a09701469e013c623c7cfc1e2f7ec83e47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a43da5a09701469e013c623c7cfc1e2f7ec83e47", "html_url": "https://github.com/rust-lang/rust/commit/a43da5a09701469e013c623c7cfc1e2f7ec83e47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a43da5a09701469e013c623c7cfc1e2f7ec83e47/comments", "author": {"login": "ibraheemdev", "id": 34988408, "node_id": "MDQ6VXNlcjM0OTg4NDA4", "avatar_url": "https://avatars.githubusercontent.com/u/34988408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibraheemdev", "html_url": "https://github.com/ibraheemdev", "followers_url": "https://api.github.com/users/ibraheemdev/followers", "following_url": "https://api.github.com/users/ibraheemdev/following{/other_user}", "gists_url": "https://api.github.com/users/ibraheemdev/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibraheemdev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibraheemdev/subscriptions", "organizations_url": "https://api.github.com/users/ibraheemdev/orgs", "repos_url": "https://api.github.com/users/ibraheemdev/repos", "events_url": "https://api.github.com/users/ibraheemdev/events{/privacy}", "received_events_url": "https://api.github.com/users/ibraheemdev/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibraheemdev", "id": 34988408, "node_id": "MDQ6VXNlcjM0OTg4NDA4", "avatar_url": "https://avatars.githubusercontent.com/u/34988408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibraheemdev", "html_url": "https://github.com/ibraheemdev", "followers_url": "https://api.github.com/users/ibraheemdev/followers", "following_url": "https://api.github.com/users/ibraheemdev/following{/other_user}", "gists_url": "https://api.github.com/users/ibraheemdev/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibraheemdev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibraheemdev/subscriptions", "organizations_url": "https://api.github.com/users/ibraheemdev/orgs", "repos_url": "https://api.github.com/users/ibraheemdev/repos", "events_url": "https://api.github.com/users/ibraheemdev/events{/privacy}", "received_events_url": "https://api.github.com/users/ibraheemdev/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34115d040b43d9a0dcc313c6282520a86d1e6f61", "url": "https://api.github.com/repos/rust-lang/rust/commits/34115d040b43d9a0dcc313c6282520a86d1e6f61", "html_url": "https://github.com/rust-lang/rust/commit/34115d040b43d9a0dcc313c6282520a86d1e6f61"}], "stats": {"total": 2694, "additions": 2694, "deletions": 0}, "files": [{"sha": "4fee8d3e92fc84b58ee1747d095f0bbbcf128d6e", "filename": "library/std/src/sync/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a43da5a09701469e013c623c7cfc1e2f7ec83e47/library%2Fstd%2Fsrc%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a43da5a09701469e013c623c7cfc1e2f7ec83e47/library%2Fstd%2Fsrc%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmod.rs?ref=a43da5a09701469e013c623c7cfc1e2f7ec83e47", "patch": "@@ -182,6 +182,7 @@ pub mod mpsc;\n mod barrier;\n mod condvar;\n mod lazy_lock;\n+mod mpmc;\n mod mutex;\n mod once;\n mod once_lock;"}, {"sha": "74bc53d549d2cd4bca7453ce5b5ddb680395746d", "filename": "library/std/src/sync/mpmc/array.rs", "status": "added", "additions": 523, "deletions": 0, "changes": 523, "blob_url": "https://github.com/rust-lang/rust/blob/a43da5a09701469e013c623c7cfc1e2f7ec83e47/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a43da5a09701469e013c623c7cfc1e2f7ec83e47/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs?ref=a43da5a09701469e013c623c7cfc1e2f7ec83e47", "patch": "@@ -0,0 +1,523 @@\n+//! Bounded channel based on a preallocated array.\n+//!\n+//! This flavor has a fixed, positive capacity.\n+//!\n+//! The implementation is based on Dmitry Vyukov's bounded MPMC queue.\n+//!\n+//! Source:\n+//!   - <http://www.1024cores.net/home/lock-free-algorithms/queues/bounded-mpmc-queue>\n+//!   - <https://docs.google.com/document/d/1yIAYmbvL3JxOKOjuCyon7JhW4cSv1wy5hC0ApeGMV9s/pub>\n+\n+use super::context::Context;\n+use super::error::*;\n+use super::select::{Operation, Selected, Token};\n+use super::utils::{Backoff, CachePadded};\n+use super::waker::SyncWaker;\n+\n+use crate::cell::UnsafeCell;\n+use crate::mem::MaybeUninit;\n+use crate::ptr;\n+use crate::sync::atomic::{self, AtomicUsize, Ordering};\n+use crate::time::Instant;\n+\n+/// A slot in a channel.\n+struct Slot<T> {\n+    /// The current stamp.\n+    stamp: AtomicUsize,\n+\n+    /// The message in this slot.\n+    msg: UnsafeCell<MaybeUninit<T>>,\n+}\n+\n+/// The token type for the array flavor.\n+#[derive(Debug)]\n+pub(crate) struct ArrayToken {\n+    /// Slot to read from or write to.\n+    slot: *const u8,\n+\n+    /// Stamp to store into the slot after reading or writing.\n+    stamp: usize,\n+}\n+\n+impl Default for ArrayToken {\n+    #[inline]\n+    fn default() -> Self {\n+        ArrayToken { slot: ptr::null(), stamp: 0 }\n+    }\n+}\n+\n+/// Bounded channel based on a preallocated array.\n+pub(crate) struct Channel<T> {\n+    /// The head of the channel.\n+    ///\n+    /// This value is a \"stamp\" consisting of an index into the buffer, a mark bit, and a lap, but\n+    /// packed into a single `usize`. The lower bits represent the index, while the upper bits\n+    /// represent the lap. The mark bit in the head is always zero.\n+    ///\n+    /// Messages are popped from the head of the channel.\n+    head: CachePadded<AtomicUsize>,\n+\n+    /// The tail of the channel.\n+    ///\n+    /// This value is a \"stamp\" consisting of an index into the buffer, a mark bit, and a lap, but\n+    /// packed into a single `usize`. The lower bits represent the index, while the upper bits\n+    /// represent the lap. The mark bit indicates that the channel is disconnected.\n+    ///\n+    /// Messages are pushed into the tail of the channel.\n+    tail: CachePadded<AtomicUsize>,\n+\n+    /// The buffer holding slots.\n+    buffer: Box<[Slot<T>]>,\n+\n+    /// The channel capacity.\n+    cap: usize,\n+\n+    /// A stamp with the value of `{ lap: 1, mark: 0, index: 0 }`.\n+    one_lap: usize,\n+\n+    /// If this bit is set in the tail, that means the channel is disconnected.\n+    mark_bit: usize,\n+\n+    /// Senders waiting while the channel is full.\n+    senders: SyncWaker,\n+\n+    /// Receivers waiting while the channel is empty and not disconnected.\n+    receivers: SyncWaker,\n+}\n+\n+impl<T> Channel<T> {\n+    /// Creates a bounded channel of capacity `cap`.\n+    pub(crate) fn with_capacity(cap: usize) -> Self {\n+        assert!(cap > 0, \"capacity must be positive\");\n+\n+        // Compute constants `mark_bit` and `one_lap`.\n+        let mark_bit = (cap + 1).next_power_of_two();\n+        let one_lap = mark_bit * 2;\n+\n+        // Head is initialized to `{ lap: 0, mark: 0, index: 0 }`.\n+        let head = 0;\n+        // Tail is initialized to `{ lap: 0, mark: 0, index: 0 }`.\n+        let tail = 0;\n+\n+        // Allocate a buffer of `cap` slots initialized\n+        // with stamps.\n+        let buffer: Box<[Slot<T>]> = (0..cap)\n+            .map(|i| {\n+                // Set the stamp to `{ lap: 0, mark: 0, index: i }`.\n+                Slot { stamp: AtomicUsize::new(i), msg: UnsafeCell::new(MaybeUninit::uninit()) }\n+            })\n+            .collect();\n+\n+        Channel {\n+            buffer,\n+            cap,\n+            one_lap,\n+            mark_bit,\n+            head: CachePadded::new(AtomicUsize::new(head)),\n+            tail: CachePadded::new(AtomicUsize::new(tail)),\n+            senders: SyncWaker::new(),\n+            receivers: SyncWaker::new(),\n+        }\n+    }\n+\n+    /// Attempts to reserve a slot for sending a message.\n+    fn start_send(&self, token: &mut Token) -> bool {\n+        let backoff = Backoff::new();\n+        let mut tail = self.tail.load(Ordering::Relaxed);\n+\n+        loop {\n+            // Check if the channel is disconnected.\n+            if tail & self.mark_bit != 0 {\n+                token.array.slot = ptr::null();\n+                token.array.stamp = 0;\n+                return true;\n+            }\n+\n+            // Deconstruct the tail.\n+            let index = tail & (self.mark_bit - 1);\n+            let lap = tail & !(self.one_lap - 1);\n+\n+            // Inspect the corresponding slot.\n+            debug_assert!(index < self.buffer.len());\n+            let slot = unsafe { self.buffer.get_unchecked(index) };\n+            let stamp = slot.stamp.load(Ordering::Acquire);\n+\n+            // If the tail and the stamp match, we may attempt to push.\n+            if tail == stamp {\n+                let new_tail = if index + 1 < self.cap {\n+                    // Same lap, incremented index.\n+                    // Set to `{ lap: lap, mark: 0, index: index + 1 }`.\n+                    tail + 1\n+                } else {\n+                    // One lap forward, index wraps around to zero.\n+                    // Set to `{ lap: lap.wrapping_add(1), mark: 0, index: 0 }`.\n+                    lap.wrapping_add(self.one_lap)\n+                };\n+\n+                // Try moving the tail.\n+                match self.tail.compare_exchange_weak(\n+                    tail,\n+                    new_tail,\n+                    Ordering::SeqCst,\n+                    Ordering::Relaxed,\n+                ) {\n+                    Ok(_) => {\n+                        // Prepare the token for the follow-up call to `write`.\n+                        token.array.slot = slot as *const Slot<T> as *const u8;\n+                        token.array.stamp = tail + 1;\n+                        return true;\n+                    }\n+                    Err(t) => {\n+                        tail = t;\n+                        backoff.spin();\n+                    }\n+                }\n+            } else if stamp.wrapping_add(self.one_lap) == tail + 1 {\n+                atomic::fence(Ordering::SeqCst);\n+                let head = self.head.load(Ordering::Relaxed);\n+\n+                // If the head lags one lap behind the tail as well...\n+                if head.wrapping_add(self.one_lap) == tail {\n+                    // ...then the channel is full.\n+                    return false;\n+                }\n+\n+                backoff.spin();\n+                tail = self.tail.load(Ordering::Relaxed);\n+            } else {\n+                // Snooze because we need to wait for the stamp to get updated.\n+                backoff.snooze();\n+                tail = self.tail.load(Ordering::Relaxed);\n+            }\n+        }\n+    }\n+\n+    /// Writes a message into the channel.\n+    pub(crate) unsafe fn write(&self, token: &mut Token, msg: T) -> Result<(), T> {\n+        // If there is no slot, the channel is disconnected.\n+        if token.array.slot.is_null() {\n+            return Err(msg);\n+        }\n+\n+        let slot: &Slot<T> = &*(token.array.slot as *const Slot<T>);\n+\n+        // Write the message into the slot and update the stamp.\n+        slot.msg.get().write(MaybeUninit::new(msg));\n+        slot.stamp.store(token.array.stamp, Ordering::Release);\n+\n+        // Wake a sleeping receiver.\n+        self.receivers.notify();\n+        Ok(())\n+    }\n+\n+    /// Attempts to reserve a slot for receiving a message.\n+    fn start_recv(&self, token: &mut Token) -> bool {\n+        let backoff = Backoff::new();\n+        let mut head = self.head.load(Ordering::Relaxed);\n+\n+        loop {\n+            // Deconstruct the head.\n+            let index = head & (self.mark_bit - 1);\n+            let lap = head & !(self.one_lap - 1);\n+\n+            // Inspect the corresponding slot.\n+            debug_assert!(index < self.buffer.len());\n+            let slot = unsafe { self.buffer.get_unchecked(index) };\n+            let stamp = slot.stamp.load(Ordering::Acquire);\n+\n+            // If the the stamp is ahead of the head by 1, we may attempt to pop.\n+            if head + 1 == stamp {\n+                let new = if index + 1 < self.cap {\n+                    // Same lap, incremented index.\n+                    // Set to `{ lap: lap, mark: 0, index: index + 1 }`.\n+                    head + 1\n+                } else {\n+                    // One lap forward, index wraps around to zero.\n+                    // Set to `{ lap: lap.wrapping_add(1), mark: 0, index: 0 }`.\n+                    lap.wrapping_add(self.one_lap)\n+                };\n+\n+                // Try moving the head.\n+                match self.head.compare_exchange_weak(\n+                    head,\n+                    new,\n+                    Ordering::SeqCst,\n+                    Ordering::Relaxed,\n+                ) {\n+                    Ok(_) => {\n+                        // Prepare the token for the follow-up call to `read`.\n+                        token.array.slot = slot as *const Slot<T> as *const u8;\n+                        token.array.stamp = head.wrapping_add(self.one_lap);\n+                        return true;\n+                    }\n+                    Err(h) => {\n+                        head = h;\n+                        backoff.spin();\n+                    }\n+                }\n+            } else if stamp == head {\n+                atomic::fence(Ordering::SeqCst);\n+                let tail = self.tail.load(Ordering::Relaxed);\n+\n+                // If the tail equals the head, that means the channel is empty.\n+                if (tail & !self.mark_bit) == head {\n+                    // If the channel is disconnected...\n+                    if tail & self.mark_bit != 0 {\n+                        // ...then receive an error.\n+                        token.array.slot = ptr::null();\n+                        token.array.stamp = 0;\n+                        return true;\n+                    } else {\n+                        // Otherwise, the receive operation is not ready.\n+                        return false;\n+                    }\n+                }\n+\n+                backoff.spin();\n+                head = self.head.load(Ordering::Relaxed);\n+            } else {\n+                // Snooze because we need to wait for the stamp to get updated.\n+                backoff.snooze();\n+                head = self.head.load(Ordering::Relaxed);\n+            }\n+        }\n+    }\n+\n+    /// Reads a message from the channel.\n+    pub(crate) unsafe fn read(&self, token: &mut Token) -> Result<T, ()> {\n+        if token.array.slot.is_null() {\n+            // The channel is disconnected.\n+            return Err(());\n+        }\n+\n+        let slot: &Slot<T> = &*(token.array.slot as *const Slot<T>);\n+\n+        // Read the message from the slot and update the stamp.\n+        let msg = slot.msg.get().read().assume_init();\n+        slot.stamp.store(token.array.stamp, Ordering::Release);\n+\n+        // Wake a sleeping sender.\n+        self.senders.notify();\n+        Ok(msg)\n+    }\n+\n+    /// Attempts to send a message into the channel.\n+    pub(crate) fn try_send(&self, msg: T) -> Result<(), TrySendError<T>> {\n+        let token = &mut Token::default();\n+        if self.start_send(token) {\n+            unsafe { self.write(token, msg).map_err(TrySendError::Disconnected) }\n+        } else {\n+            Err(TrySendError::Full(msg))\n+        }\n+    }\n+\n+    /// Sends a message into the channel.\n+    pub(crate) fn send(\n+        &self,\n+        msg: T,\n+        deadline: Option<Instant>,\n+    ) -> Result<(), SendTimeoutError<T>> {\n+        let token = &mut Token::default();\n+        loop {\n+            // Try sending a message several times.\n+            let backoff = Backoff::new();\n+            loop {\n+                if self.start_send(token) {\n+                    let res = unsafe { self.write(token, msg) };\n+                    return res.map_err(SendTimeoutError::Disconnected);\n+                }\n+\n+                if backoff.is_completed() {\n+                    break;\n+                } else {\n+                    backoff.snooze();\n+                }\n+            }\n+\n+            if let Some(d) = deadline {\n+                if Instant::now() >= d {\n+                    return Err(SendTimeoutError::Timeout(msg));\n+                }\n+            }\n+\n+            Context::with(|cx| {\n+                // Prepare for blocking until a receiver wakes us up.\n+                let oper = Operation::hook(token);\n+                self.senders.register(oper, cx);\n+\n+                // Has the channel become ready just now?\n+                if !self.is_full() || self.is_disconnected() {\n+                    let _ = cx.try_select(Selected::Aborted);\n+                }\n+\n+                // Block the current thread.\n+                let sel = cx.wait_until(deadline);\n+\n+                match sel {\n+                    Selected::Waiting => unreachable!(),\n+                    Selected::Aborted | Selected::Disconnected => {\n+                        self.senders.unregister(oper).unwrap();\n+                    }\n+                    Selected::Operation(_) => {}\n+                }\n+            });\n+        }\n+    }\n+\n+    /// Attempts to receive a message without blocking.\n+    pub(crate) fn try_recv(&self) -> Result<T, TryRecvError> {\n+        let token = &mut Token::default();\n+\n+        if self.start_recv(token) {\n+            unsafe { self.read(token).map_err(|_| TryRecvError::Disconnected) }\n+        } else {\n+            Err(TryRecvError::Empty)\n+        }\n+    }\n+\n+    /// Receives a message from the channel.\n+    pub(crate) fn recv(&self, deadline: Option<Instant>) -> Result<T, RecvTimeoutError> {\n+        let token = &mut Token::default();\n+        loop {\n+            // Try receiving a message several times.\n+            let backoff = Backoff::new();\n+            loop {\n+                if self.start_recv(token) {\n+                    let res = unsafe { self.read(token) };\n+                    return res.map_err(|_| RecvTimeoutError::Disconnected);\n+                }\n+\n+                if backoff.is_completed() {\n+                    break;\n+                } else {\n+                    backoff.snooze();\n+                }\n+            }\n+\n+            if let Some(d) = deadline {\n+                if Instant::now() >= d {\n+                    return Err(RecvTimeoutError::Timeout);\n+                }\n+            }\n+\n+            Context::with(|cx| {\n+                // Prepare for blocking until a sender wakes us up.\n+                let oper = Operation::hook(token);\n+                self.receivers.register(oper, cx);\n+\n+                // Has the channel become ready just now?\n+                if !self.is_empty() || self.is_disconnected() {\n+                    let _ = cx.try_select(Selected::Aborted);\n+                }\n+\n+                // Block the current thread.\n+                let sel = cx.wait_until(deadline);\n+\n+                match sel {\n+                    Selected::Waiting => unreachable!(),\n+                    Selected::Aborted | Selected::Disconnected => {\n+                        self.receivers.unregister(oper).unwrap();\n+                        // If the channel was disconnected, we still have to check for remaining\n+                        // messages.\n+                    }\n+                    Selected::Operation(_) => {}\n+                }\n+            });\n+        }\n+    }\n+\n+    /// Returns the current number of messages inside the channel.\n+    pub(crate) fn len(&self) -> usize {\n+        loop {\n+            // Load the tail, then load the head.\n+            let tail = self.tail.load(Ordering::SeqCst);\n+            let head = self.head.load(Ordering::SeqCst);\n+\n+            // If the tail didn't change, we've got consistent values to work with.\n+            if self.tail.load(Ordering::SeqCst) == tail {\n+                let hix = head & (self.mark_bit - 1);\n+                let tix = tail & (self.mark_bit - 1);\n+\n+                return if hix < tix {\n+                    tix - hix\n+                } else if hix > tix {\n+                    self.cap - hix + tix\n+                } else if (tail & !self.mark_bit) == head {\n+                    0\n+                } else {\n+                    self.cap\n+                };\n+            }\n+        }\n+    }\n+\n+    /// Returns the capacity of the channel.\n+    #[allow(clippy::unnecessary_wraps)] // This is intentional.\n+    pub(crate) fn capacity(&self) -> Option<usize> {\n+        Some(self.cap)\n+    }\n+\n+    /// Disconnects the channel and wakes up all blocked senders and receivers.\n+    ///\n+    /// Returns `true` if this call disconnected the channel.\n+    pub(crate) fn disconnect(&self) -> bool {\n+        let tail = self.tail.fetch_or(self.mark_bit, Ordering::SeqCst);\n+\n+        if tail & self.mark_bit == 0 {\n+            self.senders.disconnect();\n+            self.receivers.disconnect();\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Returns `true` if the channel is disconnected.\n+    pub(crate) fn is_disconnected(&self) -> bool {\n+        self.tail.load(Ordering::SeqCst) & self.mark_bit != 0\n+    }\n+\n+    /// Returns `true` if the channel is empty.\n+    pub(crate) fn is_empty(&self) -> bool {\n+        let head = self.head.load(Ordering::SeqCst);\n+        let tail = self.tail.load(Ordering::SeqCst);\n+\n+        // Is the tail equal to the head?\n+        //\n+        // Note: If the head changes just before we load the tail, that means there was a moment\n+        // when the channel was not empty, so it is safe to just return `false`.\n+        (tail & !self.mark_bit) == head\n+    }\n+\n+    /// Returns `true` if the channel is full.\n+    pub(crate) fn is_full(&self) -> bool {\n+        let tail = self.tail.load(Ordering::SeqCst);\n+        let head = self.head.load(Ordering::SeqCst);\n+\n+        // Is the head lagging one lap behind tail?\n+        //\n+        // Note: If the tail changes just before we load the head, that means there was a moment\n+        // when the channel was not full, so it is safe to just return `false`.\n+        head.wrapping_add(self.one_lap) == tail & !self.mark_bit\n+    }\n+}\n+\n+impl<T> Drop for Channel<T> {\n+    fn drop(&mut self) {\n+        // Get the index of the head.\n+        let hix = self.head.load(Ordering::Relaxed) & (self.mark_bit - 1);\n+\n+        // Loop over all slots that hold a message and drop them.\n+        for i in 0..self.len() {\n+            // Compute the index of the next slot holding a message.\n+            let index = if hix + i < self.cap { hix + i } else { hix + i - self.cap };\n+\n+            unsafe {\n+                debug_assert!(index < self.buffer.len());\n+                let slot = self.buffer.get_unchecked_mut(index);\n+                let msg = &mut *slot.msg.get();\n+                msg.as_mut_ptr().drop_in_place();\n+            }\n+        }\n+    }\n+}"}, {"sha": "83197ae3de8417c18eb769f4a3bcd15cd4b2de7a", "filename": "library/std/src/sync/mpmc/context.rs", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/a43da5a09701469e013c623c7cfc1e2f7ec83e47/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a43da5a09701469e013c623c7cfc1e2f7ec83e47/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fcontext.rs?ref=a43da5a09701469e013c623c7cfc1e2f7ec83e47", "patch": "@@ -0,0 +1,170 @@\n+//! Thread-local channel context.\n+\n+use super::select::Selected;\n+use super::utils::Backoff;\n+\n+use crate::cell::Cell;\n+use crate::ptr;\n+use crate::sync::atomic::{AtomicPtr, AtomicUsize, Ordering};\n+use crate::sync::Arc;\n+use crate::thread::{self, Thread, ThreadId};\n+use crate::time::Instant;\n+\n+/// Thread-local context.\n+#[derive(Debug, Clone)]\n+pub struct Context {\n+    inner: Arc<Inner>,\n+}\n+\n+/// Inner representation of `Context`.\n+#[derive(Debug)]\n+struct Inner {\n+    /// Selected operation.\n+    select: AtomicUsize,\n+\n+    /// A slot into which another thread may store a pointer to its `Packet`.\n+    packet: AtomicPtr<()>,\n+\n+    /// Thread handle.\n+    thread: Thread,\n+\n+    /// Thread id.\n+    thread_id: ThreadId,\n+}\n+\n+impl Context {\n+    /// Creates a new context for the duration of the closure.\n+    #[inline]\n+    pub fn with<F, R>(f: F) -> R\n+    where\n+        F: FnOnce(&Context) -> R,\n+    {\n+        thread_local! {\n+            /// Cached thread-local context.\n+            static CONTEXT: Cell<Option<Context>> = Cell::new(Some(Context::new()));\n+        }\n+\n+        let mut f = Some(f);\n+        let mut f = |cx: &Context| -> R {\n+            let f = f.take().unwrap();\n+            f(cx)\n+        };\n+\n+        CONTEXT\n+            .try_with(|cell| match cell.take() {\n+                None => f(&Context::new()),\n+                Some(cx) => {\n+                    cx.reset();\n+                    let res = f(&cx);\n+                    cell.set(Some(cx));\n+                    res\n+                }\n+            })\n+            .unwrap_or_else(|_| f(&Context::new()))\n+    }\n+\n+    /// Creates a new `Context`.\n+    #[cold]\n+    fn new() -> Context {\n+        Context {\n+            inner: Arc::new(Inner {\n+                select: AtomicUsize::new(Selected::Waiting.into()),\n+                packet: AtomicPtr::new(ptr::null_mut()),\n+                thread: thread::current(),\n+                thread_id: thread::current().id(),\n+            }),\n+        }\n+    }\n+\n+    /// Resets `select` and `packet`.\n+    #[inline]\n+    fn reset(&self) {\n+        self.inner.select.store(Selected::Waiting.into(), Ordering::Release);\n+        self.inner.packet.store(ptr::null_mut(), Ordering::Release);\n+    }\n+\n+    /// Attempts to select an operation.\n+    ///\n+    /// On failure, the previously selected operation is returned.\n+    #[inline]\n+    pub fn try_select(&self, select: Selected) -> Result<(), Selected> {\n+        self.inner\n+            .select\n+            .compare_exchange(\n+                Selected::Waiting.into(),\n+                select.into(),\n+                Ordering::AcqRel,\n+                Ordering::Acquire,\n+            )\n+            .map(|_| ())\n+            .map_err(|e| e.into())\n+    }\n+\n+    /// Stores a packet.\n+    ///\n+    /// This method must be called after `try_select` succeeds and there is a packet to provide.\n+    #[inline]\n+    pub fn store_packet(&self, packet: *mut ()) {\n+        if !packet.is_null() {\n+            self.inner.packet.store(packet, Ordering::Release);\n+        }\n+    }\n+\n+    /// Waits until an operation is selected and returns it.\n+    ///\n+    /// If the deadline is reached, `Selected::Aborted` will be selected.\n+    #[inline]\n+    pub fn wait_until(&self, deadline: Option<Instant>) -> Selected {\n+        // Spin for a short time, waiting until an operation is selected.\n+        let backoff = Backoff::new();\n+        loop {\n+            let sel = Selected::from(self.inner.select.load(Ordering::Acquire));\n+            if sel != Selected::Waiting {\n+                return sel;\n+            }\n+\n+            if backoff.is_completed() {\n+                break;\n+            } else {\n+                backoff.snooze();\n+            }\n+        }\n+\n+        loop {\n+            // Check whether an operation has been selected.\n+            let sel = Selected::from(self.inner.select.load(Ordering::Acquire));\n+            if sel != Selected::Waiting {\n+                return sel;\n+            }\n+\n+            // If there's a deadline, park the current thread until the deadline is reached.\n+            if let Some(end) = deadline {\n+                let now = Instant::now();\n+\n+                if now < end {\n+                    thread::park_timeout(end - now);\n+                } else {\n+                    // The deadline has been reached. Try aborting select.\n+                    return match self.try_select(Selected::Aborted) {\n+                        Ok(()) => Selected::Aborted,\n+                        Err(s) => s,\n+                    };\n+                }\n+            } else {\n+                thread::park();\n+            }\n+        }\n+    }\n+\n+    /// Unparks the thread this context belongs to.\n+    #[inline]\n+    pub fn unpark(&self) {\n+        self.inner.thread.unpark();\n+    }\n+\n+    /// Returns the id of the thread this context belongs to.\n+    #[inline]\n+    pub fn thread_id(&self) -> ThreadId {\n+        self.inner.thread_id\n+    }\n+}"}, {"sha": "a5a6bdc67f13fd0f97fa150bd6582f59827e15f0", "filename": "library/std/src/sync/mpmc/counter.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/a43da5a09701469e013c623c7cfc1e2f7ec83e47/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fcounter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a43da5a09701469e013c623c7cfc1e2f7ec83e47/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fcounter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fcounter.rs?ref=a43da5a09701469e013c623c7cfc1e2f7ec83e47", "patch": "@@ -0,0 +1,137 @@\n+use crate::ops;\n+use crate::process;\n+use crate::sync::atomic::{AtomicBool, AtomicUsize, Ordering};\n+\n+/// Reference counter internals.\n+struct Counter<C> {\n+    /// The number of senders associated with the channel.\n+    senders: AtomicUsize,\n+\n+    /// The number of receivers associated with the channel.\n+    receivers: AtomicUsize,\n+\n+    /// Set to `true` if the last sender or the last receiver reference deallocates the channel.\n+    destroy: AtomicBool,\n+\n+    /// The internal channel.\n+    chan: C,\n+}\n+\n+/// Wraps a channel into the reference counter.\n+pub(crate) fn new<C>(chan: C) -> (Sender<C>, Receiver<C>) {\n+    let counter = Box::into_raw(Box::new(Counter {\n+        senders: AtomicUsize::new(1),\n+        receivers: AtomicUsize::new(1),\n+        destroy: AtomicBool::new(false),\n+        chan,\n+    }));\n+    let s = Sender { counter };\n+    let r = Receiver { counter };\n+    (s, r)\n+}\n+\n+/// The sending side.\n+pub(crate) struct Sender<C> {\n+    counter: *mut Counter<C>,\n+}\n+\n+impl<C> Sender<C> {\n+    /// Returns the internal `Counter`.\n+    fn counter(&self) -> &Counter<C> {\n+        unsafe { &*self.counter }\n+    }\n+\n+    /// Acquires another sender reference.\n+    pub(crate) fn acquire(&self) -> Sender<C> {\n+        let count = self.counter().senders.fetch_add(1, Ordering::Relaxed);\n+\n+        // Cloning senders and calling `mem::forget` on the clones could potentially overflow the\n+        // counter. It's very difficult to recover sensibly from such degenerate scenarios so we\n+        // just abort when the count becomes very large.\n+        if count > isize::MAX as usize {\n+            process::abort();\n+        }\n+\n+        Sender { counter: self.counter }\n+    }\n+\n+    /// Releases the sender reference.\n+    ///\n+    /// Function `disconnect` will be called if this is the last sender reference.\n+    pub(crate) unsafe fn release<F: FnOnce(&C) -> bool>(&self, disconnect: F) {\n+        if self.counter().senders.fetch_sub(1, Ordering::AcqRel) == 1 {\n+            disconnect(&self.counter().chan);\n+\n+            if self.counter().destroy.swap(true, Ordering::AcqRel) {\n+                drop(Box::from_raw(self.counter));\n+            }\n+        }\n+    }\n+}\n+\n+impl<C> ops::Deref for Sender<C> {\n+    type Target = C;\n+\n+    fn deref(&self) -> &C {\n+        &self.counter().chan\n+    }\n+}\n+\n+impl<C> PartialEq for Sender<C> {\n+    fn eq(&self, other: &Sender<C>) -> bool {\n+        self.counter == other.counter\n+    }\n+}\n+\n+/// The receiving side.\n+pub(crate) struct Receiver<C> {\n+    counter: *mut Counter<C>,\n+}\n+\n+impl<C> Receiver<C> {\n+    /// Returns the internal `Counter`.\n+    fn counter(&self) -> &Counter<C> {\n+        unsafe { &*self.counter }\n+    }\n+\n+    /// Acquires another receiver reference.\n+    pub(crate) fn acquire(&self) -> Receiver<C> {\n+        let count = self.counter().receivers.fetch_add(1, Ordering::Relaxed);\n+\n+        // Cloning receivers and calling `mem::forget` on the clones could potentially overflow the\n+        // counter. It's very difficult to recover sensibly from such degenerate scenarios so we\n+        // just abort when the count becomes very large.\n+        if count > isize::MAX as usize {\n+            process::abort();\n+        }\n+\n+        Receiver { counter: self.counter }\n+    }\n+\n+    /// Releases the receiver reference.\n+    ///\n+    /// Function `disconnect` will be called if this is the last receiver reference.\n+    pub(crate) unsafe fn release<F: FnOnce(&C) -> bool>(&self, disconnect: F) {\n+        if self.counter().receivers.fetch_sub(1, Ordering::AcqRel) == 1 {\n+            disconnect(&self.counter().chan);\n+\n+            if self.counter().destroy.swap(true, Ordering::AcqRel) {\n+                drop(Box::from_raw(self.counter));\n+            }\n+        }\n+    }\n+}\n+\n+impl<C> ops::Deref for Receiver<C> {\n+    type Target = C;\n+\n+    fn deref(&self) -> &C {\n+        &self.counter().chan\n+    }\n+}\n+\n+impl<C> PartialEq for Receiver<C> {\n+    fn eq(&self, other: &Receiver<C>) -> bool {\n+        self.counter == other.counter\n+    }\n+}"}, {"sha": "1b8a1f387974d9152173315ad77e2b4262903a8c", "filename": "library/std/src/sync/mpmc/error.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a43da5a09701469e013c623c7cfc1e2f7ec83e47/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a43da5a09701469e013c623c7cfc1e2f7ec83e47/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Ferror.rs?ref=a43da5a09701469e013c623c7cfc1e2f7ec83e47", "patch": "@@ -0,0 +1,46 @@\n+use crate::error;\n+use crate::fmt;\n+\n+pub use crate::sync::mpsc::{RecvError, RecvTimeoutError, SendError, TryRecvError, TrySendError};\n+\n+/// An error returned from the [`send_timeout`] method.\n+///\n+/// The error contains the message being sent so it can be recovered.\n+///\n+/// [`send_timeout`]: super::Sender::send_timeout\n+#[derive(PartialEq, Eq, Clone, Copy)]\n+pub enum SendTimeoutError<T> {\n+    /// The message could not be sent because the channel is full and the operation timed out.\n+    ///\n+    /// If this is a zero-capacity channel, then the error indicates that there was no receiver\n+    /// available to receive the message and the operation timed out.\n+    Timeout(T),\n+\n+    /// The message could not be sent because the channel is disconnected.\n+    Disconnected(T),\n+}\n+\n+impl<T> fmt::Debug for SendTimeoutError<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        \"SendTimeoutError(..)\".fmt(f)\n+    }\n+}\n+\n+impl<T> fmt::Display for SendTimeoutError<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            SendTimeoutError::Timeout(..) => \"timed out waiting on send operation\".fmt(f),\n+            SendTimeoutError::Disconnected(..) => \"sending on a disconnected channel\".fmt(f),\n+        }\n+    }\n+}\n+\n+impl<T: Send> error::Error for SendTimeoutError<T> {}\n+\n+impl<T> From<SendError<T>> for SendTimeoutError<T> {\n+    fn from(err: SendError<T>) -> SendTimeoutError<T> {\n+        match err {\n+            SendError(e) => SendTimeoutError::Disconnected(e),\n+        }\n+    }\n+}"}, {"sha": "5bc196995b14e74c3e27d7ac13e7ae93e33669bf", "filename": "library/std/src/sync/mpmc/list.rs", "status": "added", "additions": 648, "deletions": 0, "changes": 648, "blob_url": "https://github.com/rust-lang/rust/blob/a43da5a09701469e013c623c7cfc1e2f7ec83e47/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a43da5a09701469e013c623c7cfc1e2f7ec83e47/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Flist.rs?ref=a43da5a09701469e013c623c7cfc1e2f7ec83e47", "patch": "@@ -0,0 +1,648 @@\n+//! Unbounded channel implemented as a linked list.\n+\n+use super::context::Context;\n+use super::error::*;\n+use super::select::{Operation, Selected, Token};\n+use super::utils::{Backoff, CachePadded};\n+use super::waker::SyncWaker;\n+\n+use crate::cell::UnsafeCell;\n+use crate::marker::PhantomData;\n+use crate::mem::MaybeUninit;\n+use crate::ptr;\n+use crate::sync::atomic::{self, AtomicPtr, AtomicUsize, Ordering};\n+use crate::time::Instant;\n+\n+// Bits indicating the state of a slot:\n+// * If a message has been written into the slot, `WRITE` is set.\n+// * If a message has been read from the slot, `READ` is set.\n+// * If the block is being destroyed, `DESTROY` is set.\n+const WRITE: usize = 1;\n+const READ: usize = 2;\n+const DESTROY: usize = 4;\n+\n+// Each block covers one \"lap\" of indices.\n+const LAP: usize = 32;\n+// The maximum number of messages a block can hold.\n+const BLOCK_CAP: usize = LAP - 1;\n+// How many lower bits are reserved for metadata.\n+const SHIFT: usize = 1;\n+// Has two different purposes:\n+// * If set in head, indicates that the block is not the last one.\n+// * If set in tail, indicates that the channel is disconnected.\n+const MARK_BIT: usize = 1;\n+\n+/// A slot in a block.\n+struct Slot<T> {\n+    /// The message.\n+    msg: UnsafeCell<MaybeUninit<T>>,\n+\n+    /// The state of the slot.\n+    state: AtomicUsize,\n+}\n+\n+impl<T> Slot<T> {\n+    /// Waits until a message is written into the slot.\n+    fn wait_write(&self) {\n+        let backoff = Backoff::new();\n+        while self.state.load(Ordering::Acquire) & WRITE == 0 {\n+            backoff.snooze();\n+        }\n+    }\n+}\n+\n+/// A block in a linked list.\n+///\n+/// Each block in the list can hold up to `BLOCK_CAP` messages.\n+struct Block<T> {\n+    /// The next block in the linked list.\n+    next: AtomicPtr<Block<T>>,\n+\n+    /// Slots for messages.\n+    slots: [Slot<T>; BLOCK_CAP],\n+}\n+\n+impl<T> Block<T> {\n+    /// Creates an empty block.\n+    fn new() -> Block<T> {\n+        // SAFETY: This is safe because:\n+        //  [1] `Block::next` (AtomicPtr) may be safely zero initialized.\n+        //  [2] `Block::slots` (Array) may be safely zero initialized because of [3, 4].\n+        //  [3] `Slot::msg` (UnsafeCell) may be safely zero initialized because it\n+        //       holds a MaybeUninit.\n+        //  [4] `Slot::state` (AtomicUsize) may be safely zero initialized.\n+        unsafe { MaybeUninit::zeroed().assume_init() }\n+    }\n+\n+    /// Waits until the next pointer is set.\n+    fn wait_next(&self) -> *mut Block<T> {\n+        let backoff = Backoff::new();\n+        loop {\n+            let next = self.next.load(Ordering::Acquire);\n+            if !next.is_null() {\n+                return next;\n+            }\n+            backoff.snooze();\n+        }\n+    }\n+\n+    /// Sets the `DESTROY` bit in slots starting from `start` and destroys the block.\n+    unsafe fn destroy(this: *mut Block<T>, start: usize) {\n+        // It is not necessary to set the `DESTROY` bit in the last slot because that slot has\n+        // begun destruction of the block.\n+        for i in start..BLOCK_CAP - 1 {\n+            let slot = (*this).slots.get_unchecked(i);\n+\n+            // Mark the `DESTROY` bit if a thread is still using the slot.\n+            if slot.state.load(Ordering::Acquire) & READ == 0\n+                && slot.state.fetch_or(DESTROY, Ordering::AcqRel) & READ == 0\n+            {\n+                // If a thread is still using the slot, it will continue destruction of the block.\n+                return;\n+            }\n+        }\n+\n+        // No thread is using the block, now it is safe to destroy it.\n+        drop(Box::from_raw(this));\n+    }\n+}\n+\n+/// A position in a channel.\n+#[derive(Debug)]\n+struct Position<T> {\n+    /// The index in the channel.\n+    index: AtomicUsize,\n+\n+    /// The block in the linked list.\n+    block: AtomicPtr<Block<T>>,\n+}\n+\n+/// The token type for the list flavor.\n+#[derive(Debug)]\n+pub(crate) struct ListToken {\n+    /// The block of slots.\n+    block: *const u8,\n+\n+    /// The offset into the block.\n+    offset: usize,\n+}\n+\n+impl Default for ListToken {\n+    #[inline]\n+    fn default() -> Self {\n+        ListToken { block: ptr::null(), offset: 0 }\n+    }\n+}\n+\n+/// Unbounded channel implemented as a linked list.\n+///\n+/// Each message sent into the channel is assigned a sequence number, i.e. an index. Indices are\n+/// represented as numbers of type `usize` and wrap on overflow.\n+///\n+/// Consecutive messages are grouped into blocks in order to put less pressure on the allocator and\n+/// improve cache efficiency.\n+pub(crate) struct Channel<T> {\n+    /// The head of the channel.\n+    head: CachePadded<Position<T>>,\n+\n+    /// The tail of the channel.\n+    tail: CachePadded<Position<T>>,\n+\n+    /// Receivers waiting while the channel is empty and not disconnected.\n+    receivers: SyncWaker,\n+\n+    /// Indicates that dropping a `Channel<T>` may drop messages of type `T`.\n+    _marker: PhantomData<T>,\n+}\n+\n+impl<T> Channel<T> {\n+    /// Creates a new unbounded channel.\n+    pub(crate) fn new() -> Self {\n+        Channel {\n+            head: CachePadded::new(Position {\n+                block: AtomicPtr::new(ptr::null_mut()),\n+                index: AtomicUsize::new(0),\n+            }),\n+            tail: CachePadded::new(Position {\n+                block: AtomicPtr::new(ptr::null_mut()),\n+                index: AtomicUsize::new(0),\n+            }),\n+            receivers: SyncWaker::new(),\n+            _marker: PhantomData,\n+        }\n+    }\n+\n+    /// Attempts to reserve a slot for sending a message.\n+    fn start_send(&self, token: &mut Token) -> bool {\n+        let backoff = Backoff::new();\n+        let mut tail = self.tail.index.load(Ordering::Acquire);\n+        let mut block = self.tail.block.load(Ordering::Acquire);\n+        let mut next_block = None;\n+\n+        loop {\n+            // Check if the channel is disconnected.\n+            if tail & MARK_BIT != 0 {\n+                token.list.block = ptr::null();\n+                return true;\n+            }\n+\n+            // Calculate the offset of the index into the block.\n+            let offset = (tail >> SHIFT) % LAP;\n+\n+            // If we reached the end of the block, wait until the next one is installed.\n+            if offset == BLOCK_CAP {\n+                backoff.snooze();\n+                tail = self.tail.index.load(Ordering::Acquire);\n+                block = self.tail.block.load(Ordering::Acquire);\n+                continue;\n+            }\n+\n+            // If we're going to have to install the next block, allocate it in advance in order to\n+            // make the wait for other threads as short as possible.\n+            if offset + 1 == BLOCK_CAP && next_block.is_none() {\n+                next_block = Some(Box::new(Block::<T>::new()));\n+            }\n+\n+            // If this is the first message to be sent into the channel, we need to allocate the\n+            // first block and install it.\n+            if block.is_null() {\n+                let new = Box::into_raw(Box::new(Block::<T>::new()));\n+\n+                if self\n+                    .tail\n+                    .block\n+                    .compare_exchange(block, new, Ordering::Release, Ordering::Relaxed)\n+                    .is_ok()\n+                {\n+                    self.head.block.store(new, Ordering::Release);\n+                    block = new;\n+                } else {\n+                    next_block = unsafe { Some(Box::from_raw(new)) };\n+                    tail = self.tail.index.load(Ordering::Acquire);\n+                    block = self.tail.block.load(Ordering::Acquire);\n+                    continue;\n+                }\n+            }\n+\n+            let new_tail = tail + (1 << SHIFT);\n+\n+            // Try advancing the tail forward.\n+            match self.tail.index.compare_exchange_weak(\n+                tail,\n+                new_tail,\n+                Ordering::SeqCst,\n+                Ordering::Acquire,\n+            ) {\n+                Ok(_) => unsafe {\n+                    // If we've reached the end of the block, install the next one.\n+                    if offset + 1 == BLOCK_CAP {\n+                        let next_block = Box::into_raw(next_block.unwrap());\n+                        self.tail.block.store(next_block, Ordering::Release);\n+                        self.tail.index.fetch_add(1 << SHIFT, Ordering::Release);\n+                        (*block).next.store(next_block, Ordering::Release);\n+                    }\n+\n+                    token.list.block = block as *const u8;\n+                    token.list.offset = offset;\n+                    return true;\n+                },\n+                Err(t) => {\n+                    tail = t;\n+                    block = self.tail.block.load(Ordering::Acquire);\n+                    backoff.spin();\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Writes a message into the channel.\n+    pub(crate) unsafe fn write(&self, token: &mut Token, msg: T) -> Result<(), T> {\n+        // If there is no slot, the channel is disconnected.\n+        if token.list.block.is_null() {\n+            return Err(msg);\n+        }\n+\n+        // Write the message into the slot.\n+        let block = token.list.block as *mut Block<T>;\n+        let offset = token.list.offset;\n+        let slot = (*block).slots.get_unchecked(offset);\n+        slot.msg.get().write(MaybeUninit::new(msg));\n+        slot.state.fetch_or(WRITE, Ordering::Release);\n+\n+        // Wake a sleeping receiver.\n+        self.receivers.notify();\n+        Ok(())\n+    }\n+\n+    /// Attempts to reserve a slot for receiving a message.\n+    fn start_recv(&self, token: &mut Token) -> bool {\n+        let backoff = Backoff::new();\n+        let mut head = self.head.index.load(Ordering::Acquire);\n+        let mut block = self.head.block.load(Ordering::Acquire);\n+\n+        loop {\n+            // Calculate the offset of the index into the block.\n+            let offset = (head >> SHIFT) % LAP;\n+\n+            // If we reached the end of the block, wait until the next one is installed.\n+            if offset == BLOCK_CAP {\n+                backoff.snooze();\n+                head = self.head.index.load(Ordering::Acquire);\n+                block = self.head.block.load(Ordering::Acquire);\n+                continue;\n+            }\n+\n+            let mut new_head = head + (1 << SHIFT);\n+\n+            if new_head & MARK_BIT == 0 {\n+                atomic::fence(Ordering::SeqCst);\n+                let tail = self.tail.index.load(Ordering::Relaxed);\n+\n+                // If the tail equals the head, that means the channel is empty.\n+                if head >> SHIFT == tail >> SHIFT {\n+                    // If the channel is disconnected...\n+                    if tail & MARK_BIT != 0 {\n+                        // ...then receive an error.\n+                        token.list.block = ptr::null();\n+                        return true;\n+                    } else {\n+                        // Otherwise, the receive operation is not ready.\n+                        return false;\n+                    }\n+                }\n+\n+                // If head and tail are not in the same block, set `MARK_BIT` in head.\n+                if (head >> SHIFT) / LAP != (tail >> SHIFT) / LAP {\n+                    new_head |= MARK_BIT;\n+                }\n+            }\n+\n+            // The block can be null here only if the first message is being sent into the channel.\n+            // In that case, just wait until it gets initialized.\n+            if block.is_null() {\n+                backoff.snooze();\n+                head = self.head.index.load(Ordering::Acquire);\n+                block = self.head.block.load(Ordering::Acquire);\n+                continue;\n+            }\n+\n+            // Try moving the head index forward.\n+            match self.head.index.compare_exchange_weak(\n+                head,\n+                new_head,\n+                Ordering::SeqCst,\n+                Ordering::Acquire,\n+            ) {\n+                Ok(_) => unsafe {\n+                    // If we've reached the end of the block, move to the next one.\n+                    if offset + 1 == BLOCK_CAP {\n+                        let next = (*block).wait_next();\n+                        let mut next_index = (new_head & !MARK_BIT).wrapping_add(1 << SHIFT);\n+                        if !(*next).next.load(Ordering::Relaxed).is_null() {\n+                            next_index |= MARK_BIT;\n+                        }\n+\n+                        self.head.block.store(next, Ordering::Release);\n+                        self.head.index.store(next_index, Ordering::Release);\n+                    }\n+\n+                    token.list.block = block as *const u8;\n+                    token.list.offset = offset;\n+                    return true;\n+                },\n+                Err(h) => {\n+                    head = h;\n+                    block = self.head.block.load(Ordering::Acquire);\n+                    backoff.spin();\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Reads a message from the channel.\n+    pub(crate) unsafe fn read(&self, token: &mut Token) -> Result<T, ()> {\n+        if token.list.block.is_null() {\n+            // The channel is disconnected.\n+            return Err(());\n+        }\n+\n+        // Read the message.\n+        let block = token.list.block as *mut Block<T>;\n+        let offset = token.list.offset;\n+        let slot = (*block).slots.get_unchecked(offset);\n+        slot.wait_write();\n+        let msg = slot.msg.get().read().assume_init();\n+\n+        // Destroy the block if we've reached the end, or if another thread wanted to destroy but\n+        // couldn't because we were busy reading from the slot.\n+        if offset + 1 == BLOCK_CAP {\n+            Block::destroy(block, 0);\n+        } else if slot.state.fetch_or(READ, Ordering::AcqRel) & DESTROY != 0 {\n+            Block::destroy(block, offset + 1);\n+        }\n+\n+        Ok(msg)\n+    }\n+\n+    /// Attempts to send a message into the channel.\n+    pub(crate) fn try_send(&self, msg: T) -> Result<(), TrySendError<T>> {\n+        self.send(msg, None).map_err(|err| match err {\n+            SendTimeoutError::Disconnected(msg) => TrySendError::Disconnected(msg),\n+            SendTimeoutError::Timeout(_) => unreachable!(),\n+        })\n+    }\n+\n+    /// Sends a message into the channel.\n+    pub(crate) fn send(\n+        &self,\n+        msg: T,\n+        _deadline: Option<Instant>,\n+    ) -> Result<(), SendTimeoutError<T>> {\n+        let token = &mut Token::default();\n+        assert!(self.start_send(token));\n+        unsafe { self.write(token, msg).map_err(SendTimeoutError::Disconnected) }\n+    }\n+\n+    /// Attempts to receive a message without blocking.\n+    pub(crate) fn try_recv(&self) -> Result<T, TryRecvError> {\n+        let token = &mut Token::default();\n+\n+        if self.start_recv(token) {\n+            unsafe { self.read(token).map_err(|_| TryRecvError::Disconnected) }\n+        } else {\n+            Err(TryRecvError::Empty)\n+        }\n+    }\n+\n+    /// Receives a message from the channel.\n+    pub(crate) fn recv(&self, deadline: Option<Instant>) -> Result<T, RecvTimeoutError> {\n+        let token = &mut Token::default();\n+        loop {\n+            // Try receiving a message several times.\n+            let backoff = Backoff::new();\n+            loop {\n+                if self.start_recv(token) {\n+                    unsafe {\n+                        return self.read(token).map_err(|_| RecvTimeoutError::Disconnected);\n+                    }\n+                }\n+\n+                if backoff.is_completed() {\n+                    break;\n+                } else {\n+                    backoff.snooze();\n+                }\n+            }\n+\n+            if let Some(d) = deadline {\n+                if Instant::now() >= d {\n+                    return Err(RecvTimeoutError::Timeout);\n+                }\n+            }\n+\n+            // Prepare for blocking until a sender wakes us up.\n+            Context::with(|cx| {\n+                let oper = Operation::hook(token);\n+                self.receivers.register(oper, cx);\n+\n+                // Has the channel become ready just now?\n+                if !self.is_empty() || self.is_disconnected() {\n+                    let _ = cx.try_select(Selected::Aborted);\n+                }\n+\n+                // Block the current thread.\n+                let sel = cx.wait_until(deadline);\n+\n+                match sel {\n+                    Selected::Waiting => unreachable!(),\n+                    Selected::Aborted | Selected::Disconnected => {\n+                        self.receivers.unregister(oper).unwrap();\n+                        // If the channel was disconnected, we still have to check for remaining\n+                        // messages.\n+                    }\n+                    Selected::Operation(_) => {}\n+                }\n+            });\n+        }\n+    }\n+\n+    /// Returns the current number of messages inside the channel.\n+    pub(crate) fn len(&self) -> usize {\n+        loop {\n+            // Load the tail index, then load the head index.\n+            let mut tail = self.tail.index.load(Ordering::SeqCst);\n+            let mut head = self.head.index.load(Ordering::SeqCst);\n+\n+            // If the tail index didn't change, we've got consistent indices to work with.\n+            if self.tail.index.load(Ordering::SeqCst) == tail {\n+                // Erase the lower bits.\n+                tail &= !((1 << SHIFT) - 1);\n+                head &= !((1 << SHIFT) - 1);\n+\n+                // Fix up indices if they fall onto block ends.\n+                if (tail >> SHIFT) & (LAP - 1) == LAP - 1 {\n+                    tail = tail.wrapping_add(1 << SHIFT);\n+                }\n+                if (head >> SHIFT) & (LAP - 1) == LAP - 1 {\n+                    head = head.wrapping_add(1 << SHIFT);\n+                }\n+\n+                // Rotate indices so that head falls into the first block.\n+                let lap = (head >> SHIFT) / LAP;\n+                tail = tail.wrapping_sub((lap * LAP) << SHIFT);\n+                head = head.wrapping_sub((lap * LAP) << SHIFT);\n+\n+                // Remove the lower bits.\n+                tail >>= SHIFT;\n+                head >>= SHIFT;\n+\n+                // Return the difference minus the number of blocks between tail and head.\n+                return tail - head - tail / LAP;\n+            }\n+        }\n+    }\n+\n+    /// Returns the capacity of the channel.\n+    pub(crate) fn capacity(&self) -> Option<usize> {\n+        None\n+    }\n+\n+    /// Disconnects senders and wakes up all blocked receivers.\n+    ///\n+    /// Returns `true` if this call disconnected the channel.\n+    pub(crate) fn disconnect_senders(&self) -> bool {\n+        let tail = self.tail.index.fetch_or(MARK_BIT, Ordering::SeqCst);\n+\n+        if tail & MARK_BIT == 0 {\n+            self.receivers.disconnect();\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Disconnects receivers.\n+    ///\n+    /// Returns `true` if this call disconnected the channel.\n+    pub(crate) fn disconnect_receivers(&self) -> bool {\n+        let tail = self.tail.index.fetch_or(MARK_BIT, Ordering::SeqCst);\n+\n+        if tail & MARK_BIT == 0 {\n+            // If receivers are dropped first, discard all messages to free\n+            // memory eagerly.\n+            self.discard_all_messages();\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Discards all messages.\n+    ///\n+    /// This method should only be called when all receivers are dropped.\n+    fn discard_all_messages(&self) {\n+        let backoff = Backoff::new();\n+        let mut tail = self.tail.index.load(Ordering::Acquire);\n+        loop {\n+            let offset = (tail >> SHIFT) % LAP;\n+            if offset != BLOCK_CAP {\n+                break;\n+            }\n+\n+            // New updates to tail will be rejected by MARK_BIT and aborted unless it's\n+            // at boundary. We need to wait for the updates take affect otherwise there\n+            // can be memory leaks.\n+            backoff.snooze();\n+            tail = self.tail.index.load(Ordering::Acquire);\n+        }\n+\n+        let mut head = self.head.index.load(Ordering::Acquire);\n+        let mut block = self.head.block.load(Ordering::Acquire);\n+\n+        unsafe {\n+            // Drop all messages between head and tail and deallocate the heap-allocated blocks.\n+            while head >> SHIFT != tail >> SHIFT {\n+                let offset = (head >> SHIFT) % LAP;\n+\n+                if offset < BLOCK_CAP {\n+                    // Drop the message in the slot.\n+                    let slot = (*block).slots.get_unchecked(offset);\n+                    slot.wait_write();\n+                    let p = &mut *slot.msg.get();\n+                    p.as_mut_ptr().drop_in_place();\n+                } else {\n+                    (*block).wait_next();\n+                    // Deallocate the block and move to the next one.\n+                    let next = (*block).next.load(Ordering::Acquire);\n+                    drop(Box::from_raw(block));\n+                    block = next;\n+                }\n+\n+                head = head.wrapping_add(1 << SHIFT);\n+            }\n+\n+            // Deallocate the last remaining block.\n+            if !block.is_null() {\n+                drop(Box::from_raw(block));\n+            }\n+        }\n+        head &= !MARK_BIT;\n+        self.head.block.store(ptr::null_mut(), Ordering::Release);\n+        self.head.index.store(head, Ordering::Release);\n+    }\n+\n+    /// Returns `true` if the channel is disconnected.\n+    pub(crate) fn is_disconnected(&self) -> bool {\n+        self.tail.index.load(Ordering::SeqCst) & MARK_BIT != 0\n+    }\n+\n+    /// Returns `true` if the channel is empty.\n+    pub(crate) fn is_empty(&self) -> bool {\n+        let head = self.head.index.load(Ordering::SeqCst);\n+        let tail = self.tail.index.load(Ordering::SeqCst);\n+        head >> SHIFT == tail >> SHIFT\n+    }\n+\n+    /// Returns `true` if the channel is full.\n+    pub(crate) fn is_full(&self) -> bool {\n+        false\n+    }\n+}\n+\n+impl<T> Drop for Channel<T> {\n+    fn drop(&mut self) {\n+        let mut head = self.head.index.load(Ordering::Relaxed);\n+        let mut tail = self.tail.index.load(Ordering::Relaxed);\n+        let mut block = self.head.block.load(Ordering::Relaxed);\n+\n+        // Erase the lower bits.\n+        head &= !((1 << SHIFT) - 1);\n+        tail &= !((1 << SHIFT) - 1);\n+\n+        unsafe {\n+            // Drop all messages between head and tail and deallocate the heap-allocated blocks.\n+            while head != tail {\n+                let offset = (head >> SHIFT) % LAP;\n+\n+                if offset < BLOCK_CAP {\n+                    // Drop the message in the slot.\n+                    let slot = (*block).slots.get_unchecked(offset);\n+                    let p = &mut *slot.msg.get();\n+                    p.as_mut_ptr().drop_in_place();\n+                } else {\n+                    // Deallocate the block and move to the next one.\n+                    let next = (*block).next.load(Ordering::Relaxed);\n+                    drop(Box::from_raw(block));\n+                    block = next;\n+                }\n+\n+                head = head.wrapping_add(1 << SHIFT);\n+            }\n+\n+            // Deallocate the last remaining block.\n+            if !block.is_null() {\n+                drop(Box::from_raw(block));\n+            }\n+        }\n+    }\n+}"}, {"sha": "cef99c58843009bda1d5ddbe5b02fd64c93f32e2", "filename": "library/std/src/sync/mpmc/mod.rs", "status": "added", "additions": 430, "deletions": 0, "changes": 430, "blob_url": "https://github.com/rust-lang/rust/blob/a43da5a09701469e013c623c7cfc1e2f7ec83e47/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a43da5a09701469e013c623c7cfc1e2f7ec83e47/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs?ref=a43da5a09701469e013c623c7cfc1e2f7ec83e47", "patch": "@@ -0,0 +1,430 @@\n+//! Multi-producer multi-consumer channels.\n+\n+// This module is not currently exposed publicly, but is used\n+// as the implementation for the channels in `sync::mpsc`. The\n+// implementation comes from the crossbeam-channel crate:\n+//\n+// Copyright (c) 2019 The Crossbeam Project Developers\n+//\n+// Permission is hereby granted, free of charge, to any\n+// person obtaining a copy of this software and associated\n+// documentation files (the \"Software\"), to deal in the\n+// Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge,\n+// publish, distribute, sublicense, and/or sell copies of\n+// the Software, and to permit persons to whom the Software\n+// is furnished to do so, subject to the following\n+// conditions:\n+//\n+// The above copyright notice and this permission notice\n+// shall be included in all copies or substantial portions\n+// of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n+// ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n+// TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n+// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT\n+// SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\n+// IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+// DEALINGS IN THE SOFTWARE.\n+\n+mod array;\n+mod context;\n+mod counter;\n+mod error;\n+mod list;\n+mod select;\n+mod utils;\n+mod waker;\n+mod zero;\n+\n+use crate::fmt;\n+use crate::panic::{RefUnwindSafe, UnwindSafe};\n+use crate::time::{Duration, Instant};\n+use error::*;\n+\n+/// Creates a channel of unbounded capacity.\n+///\n+/// This channel has a growable buffer that can hold any number of messages at a time.\n+pub fn channel<T>() -> (Sender<T>, Receiver<T>) {\n+    let (s, r) = counter::new(list::Channel::new());\n+    let s = Sender { flavor: SenderFlavor::List(s) };\n+    let r = Receiver { flavor: ReceiverFlavor::List(r) };\n+    (s, r)\n+}\n+\n+/// Creates a channel of bounded capacity.\n+///\n+/// This channel has a buffer that can hold at most `cap` messages at a time.\n+///\n+/// A special case is zero-capacity channel, which cannot hold any messages. Instead, send and\n+/// receive operations must appear at the same time in order to pair up and pass the message over.\n+pub fn sync_channel<T>(cap: usize) -> (Sender<T>, Receiver<T>) {\n+    if cap == 0 {\n+        let (s, r) = counter::new(zero::Channel::new());\n+        let s = Sender { flavor: SenderFlavor::Zero(s) };\n+        let r = Receiver { flavor: ReceiverFlavor::Zero(r) };\n+        (s, r)\n+    } else {\n+        let (s, r) = counter::new(array::Channel::with_capacity(cap));\n+        let s = Sender { flavor: SenderFlavor::Array(s) };\n+        let r = Receiver { flavor: ReceiverFlavor::Array(r) };\n+        (s, r)\n+    }\n+}\n+\n+/// The sending side of a channel.\n+pub struct Sender<T> {\n+    flavor: SenderFlavor<T>,\n+}\n+\n+/// Sender flavors.\n+enum SenderFlavor<T> {\n+    /// Bounded channel based on a preallocated array.\n+    Array(counter::Sender<array::Channel<T>>),\n+\n+    /// Unbounded channel implemented as a linked list.\n+    List(counter::Sender<list::Channel<T>>),\n+\n+    /// Zero-capacity channel.\n+    Zero(counter::Sender<zero::Channel<T>>),\n+}\n+\n+unsafe impl<T: Send> Send for Sender<T> {}\n+unsafe impl<T: Send> Sync for Sender<T> {}\n+\n+impl<T> UnwindSafe for Sender<T> {}\n+impl<T> RefUnwindSafe for Sender<T> {}\n+\n+impl<T> Sender<T> {\n+    /// Attempts to send a message into the channel without blocking.\n+    ///\n+    /// This method will either send a message into the channel immediately or return an error if\n+    /// the channel is full or disconnected. The returned error contains the original message.\n+    ///\n+    /// If called on a zero-capacity channel, this method will send the message only if there\n+    /// happens to be a receive operation on the other side of the channel at the same time.\n+    pub fn try_send(&self, msg: T) -> Result<(), TrySendError<T>> {\n+        match &self.flavor {\n+            SenderFlavor::Array(chan) => chan.try_send(msg),\n+            SenderFlavor::List(chan) => chan.try_send(msg),\n+            SenderFlavor::Zero(chan) => chan.try_send(msg),\n+        }\n+    }\n+\n+    /// Blocks the current thread until a message is sent or the channel is disconnected.\n+    ///\n+    /// If the channel is full and not disconnected, this call will block until the send operation\n+    /// can proceed. If the channel becomes disconnected, this call will wake up and return an\n+    /// error. The returned error contains the original message.\n+    ///\n+    /// If called on a zero-capacity channel, this method will wait for a receive operation to\n+    /// appear on the other side of the channel.\n+    pub fn send(&self, msg: T) -> Result<(), SendError<T>> {\n+        match &self.flavor {\n+            SenderFlavor::Array(chan) => chan.send(msg, None),\n+            SenderFlavor::List(chan) => chan.send(msg, None),\n+            SenderFlavor::Zero(chan) => chan.send(msg, None),\n+        }\n+        .map_err(|err| match err {\n+            SendTimeoutError::Disconnected(msg) => SendError(msg),\n+            SendTimeoutError::Timeout(_) => unreachable!(),\n+        })\n+    }\n+}\n+\n+// The methods below are not used by `sync::mpsc`, but\n+// are useful and we'll likely want to expose them\n+// eventually\n+#[allow(unused)]\n+impl<T> Sender<T> {\n+    /// Waits for a message to be sent into the channel, but only for a limited time.\n+    ///\n+    /// If the channel is full and not disconnected, this call will block until the send operation\n+    /// can proceed or the operation times out. If the channel becomes disconnected, this call will\n+    /// wake up and return an error. The returned error contains the original message.\n+    ///\n+    /// If called on a zero-capacity channel, this method will wait for a receive operation to\n+    /// appear on the other side of the channel.\n+    pub fn send_timeout(&self, msg: T, timeout: Duration) -> Result<(), SendTimeoutError<T>> {\n+        match Instant::now().checked_add(timeout) {\n+            Some(deadline) => self.send_deadline(msg, deadline),\n+            // So far in the future that it's practically the same as waiting indefinitely.\n+            None => self.send(msg).map_err(SendTimeoutError::from),\n+        }\n+    }\n+\n+    /// Waits for a message to be sent into the channel, but only until a given deadline.\n+    ///\n+    /// If the channel is full and not disconnected, this call will block until the send operation\n+    /// can proceed or the operation times out. If the channel becomes disconnected, this call will\n+    /// wake up and return an error. The returned error contains the original message.\n+    ///\n+    /// If called on a zero-capacity channel, this method will wait for a receive operation to\n+    /// appear on the other side of the channel.\n+    pub fn send_deadline(&self, msg: T, deadline: Instant) -> Result<(), SendTimeoutError<T>> {\n+        match &self.flavor {\n+            SenderFlavor::Array(chan) => chan.send(msg, Some(deadline)),\n+            SenderFlavor::List(chan) => chan.send(msg, Some(deadline)),\n+            SenderFlavor::Zero(chan) => chan.send(msg, Some(deadline)),\n+        }\n+    }\n+\n+    /// Returns `true` if the channel is empty.\n+    ///\n+    /// Note: Zero-capacity channels are always empty.\n+    pub fn is_empty(&self) -> bool {\n+        match &self.flavor {\n+            SenderFlavor::Array(chan) => chan.is_empty(),\n+            SenderFlavor::List(chan) => chan.is_empty(),\n+            SenderFlavor::Zero(chan) => chan.is_empty(),\n+        }\n+    }\n+\n+    /// Returns `true` if the channel is full.\n+    ///\n+    /// Note: Zero-capacity channels are always full.\n+    pub fn is_full(&self) -> bool {\n+        match &self.flavor {\n+            SenderFlavor::Array(chan) => chan.is_full(),\n+            SenderFlavor::List(chan) => chan.is_full(),\n+            SenderFlavor::Zero(chan) => chan.is_full(),\n+        }\n+    }\n+\n+    /// Returns the number of messages in the channel.\n+    pub fn len(&self) -> usize {\n+        match &self.flavor {\n+            SenderFlavor::Array(chan) => chan.len(),\n+            SenderFlavor::List(chan) => chan.len(),\n+            SenderFlavor::Zero(chan) => chan.len(),\n+        }\n+    }\n+\n+    /// If the channel is bounded, returns its capacity.\n+    pub fn capacity(&self) -> Option<usize> {\n+        match &self.flavor {\n+            SenderFlavor::Array(chan) => chan.capacity(),\n+            SenderFlavor::List(chan) => chan.capacity(),\n+            SenderFlavor::Zero(chan) => chan.capacity(),\n+        }\n+    }\n+\n+    /// Returns `true` if senders belong to the same channel.\n+    pub fn same_channel(&self, other: &Sender<T>) -> bool {\n+        match (&self.flavor, &other.flavor) {\n+            (SenderFlavor::Array(ref a), SenderFlavor::Array(ref b)) => a == b,\n+            (SenderFlavor::List(ref a), SenderFlavor::List(ref b)) => a == b,\n+            (SenderFlavor::Zero(ref a), SenderFlavor::Zero(ref b)) => a == b,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl<T> Drop for Sender<T> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            match &self.flavor {\n+                SenderFlavor::Array(chan) => chan.release(|c| c.disconnect()),\n+                SenderFlavor::List(chan) => chan.release(|c| c.disconnect_senders()),\n+                SenderFlavor::Zero(chan) => chan.release(|c| c.disconnect()),\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> Clone for Sender<T> {\n+    fn clone(&self) -> Self {\n+        let flavor = match &self.flavor {\n+            SenderFlavor::Array(chan) => SenderFlavor::Array(chan.acquire()),\n+            SenderFlavor::List(chan) => SenderFlavor::List(chan.acquire()),\n+            SenderFlavor::Zero(chan) => SenderFlavor::Zero(chan.acquire()),\n+        };\n+\n+        Sender { flavor }\n+    }\n+}\n+\n+impl<T> fmt::Debug for Sender<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.pad(\"Sender { .. }\")\n+    }\n+}\n+\n+/// The receiving side of a channel.\n+pub struct Receiver<T> {\n+    flavor: ReceiverFlavor<T>,\n+}\n+\n+/// Receiver flavors.\n+enum ReceiverFlavor<T> {\n+    /// Bounded channel based on a preallocated array.\n+    Array(counter::Receiver<array::Channel<T>>),\n+\n+    /// Unbounded channel implemented as a linked list.\n+    List(counter::Receiver<list::Channel<T>>),\n+\n+    /// Zero-capacity channel.\n+    Zero(counter::Receiver<zero::Channel<T>>),\n+}\n+\n+unsafe impl<T: Send> Send for Receiver<T> {}\n+unsafe impl<T: Send> Sync for Receiver<T> {}\n+\n+impl<T> UnwindSafe for Receiver<T> {}\n+impl<T> RefUnwindSafe for Receiver<T> {}\n+\n+impl<T> Receiver<T> {\n+    /// Attempts to receive a message from the channel without blocking.\n+    ///\n+    /// This method will either receive a message from the channel immediately or return an error\n+    /// if the channel is empty.\n+    ///\n+    /// If called on a zero-capacity channel, this method will receive a message only if there\n+    /// happens to be a send operation on the other side of the channel at the same time.\n+    pub fn try_recv(&self) -> Result<T, TryRecvError> {\n+        match &self.flavor {\n+            ReceiverFlavor::Array(chan) => chan.try_recv(),\n+            ReceiverFlavor::List(chan) => chan.try_recv(),\n+            ReceiverFlavor::Zero(chan) => chan.try_recv(),\n+        }\n+    }\n+\n+    /// Blocks the current thread until a message is received or the channel is empty and\n+    /// disconnected.\n+    ///\n+    /// If the channel is empty and not disconnected, this call will block until the receive\n+    /// operation can proceed. If the channel is empty and becomes disconnected, this call will\n+    /// wake up and return an error.\n+    ///\n+    /// If called on a zero-capacity channel, this method will wait for a send operation to appear\n+    /// on the other side of the channel.\n+    pub fn recv(&self) -> Result<T, RecvError> {\n+        match &self.flavor {\n+            ReceiverFlavor::Array(chan) => chan.recv(None),\n+            ReceiverFlavor::List(chan) => chan.recv(None),\n+            ReceiverFlavor::Zero(chan) => chan.recv(None),\n+        }\n+        .map_err(|_| RecvError)\n+    }\n+\n+    /// Waits for a message to be received from the channel, but only for a limited time.\n+    ///\n+    /// If the channel is empty and not disconnected, this call will block until the receive\n+    /// operation can proceed or the operation times out. If the channel is empty and becomes\n+    /// disconnected, this call will wake up and return an error.\n+    ///\n+    /// If called on a zero-capacity channel, this method will wait for a send operation to appear\n+    /// on the other side of the channel.\n+    pub fn recv_timeout(&self, timeout: Duration) -> Result<T, RecvTimeoutError> {\n+        match Instant::now().checked_add(timeout) {\n+            Some(deadline) => self.recv_deadline(deadline),\n+            // So far in the future that it's practically the same as waiting indefinitely.\n+            None => self.recv().map_err(RecvTimeoutError::from),\n+        }\n+    }\n+\n+    /// Waits for a message to be received from the channel, but only for a limited time.\n+    ///\n+    /// If the channel is empty and not disconnected, this call will block until the receive\n+    /// operation can proceed or the operation times out. If the channel is empty and becomes\n+    /// disconnected, this call will wake up and return an error.\n+    ///\n+    /// If called on a zero-capacity channel, this method will wait for a send operation to appear\n+    /// on the other side of the channel.\n+    pub fn recv_deadline(&self, deadline: Instant) -> Result<T, RecvTimeoutError> {\n+        match &self.flavor {\n+            ReceiverFlavor::Array(chan) => chan.recv(Some(deadline)),\n+            ReceiverFlavor::List(chan) => chan.recv(Some(deadline)),\n+            ReceiverFlavor::Zero(chan) => chan.recv(Some(deadline)),\n+        }\n+    }\n+}\n+\n+// The methods below are not used by `sync::mpsc`, but\n+// are useful and we'll likely want to expose them\n+// eventually\n+#[allow(unused)]\n+impl<T> Receiver<T> {\n+    /// Returns `true` if the channel is empty.\n+    ///\n+    /// Note: Zero-capacity channels are always empty.\n+    pub fn is_empty(&self) -> bool {\n+        match &self.flavor {\n+            ReceiverFlavor::Array(chan) => chan.is_empty(),\n+            ReceiverFlavor::List(chan) => chan.is_empty(),\n+            ReceiverFlavor::Zero(chan) => chan.is_empty(),\n+        }\n+    }\n+\n+    /// Returns `true` if the channel is full.\n+    ///\n+    /// Note: Zero-capacity channels are always full.\n+    pub fn is_full(&self) -> bool {\n+        match &self.flavor {\n+            ReceiverFlavor::Array(chan) => chan.is_full(),\n+            ReceiverFlavor::List(chan) => chan.is_full(),\n+            ReceiverFlavor::Zero(chan) => chan.is_full(),\n+        }\n+    }\n+\n+    /// Returns the number of messages in the channel.\n+    pub fn len(&self) -> usize {\n+        match &self.flavor {\n+            ReceiverFlavor::Array(chan) => chan.len(),\n+            ReceiverFlavor::List(chan) => chan.len(),\n+            ReceiverFlavor::Zero(chan) => chan.len(),\n+        }\n+    }\n+\n+    /// If the channel is bounded, returns its capacity.\n+    pub fn capacity(&self) -> Option<usize> {\n+        match &self.flavor {\n+            ReceiverFlavor::Array(chan) => chan.capacity(),\n+            ReceiverFlavor::List(chan) => chan.capacity(),\n+            ReceiverFlavor::Zero(chan) => chan.capacity(),\n+        }\n+    }\n+\n+    /// Returns `true` if receivers belong to the same channel.\n+    pub fn same_channel(&self, other: &Receiver<T>) -> bool {\n+        match (&self.flavor, &other.flavor) {\n+            (ReceiverFlavor::Array(a), ReceiverFlavor::Array(b)) => a == b,\n+            (ReceiverFlavor::List(a), ReceiverFlavor::List(b)) => a == b,\n+            (ReceiverFlavor::Zero(a), ReceiverFlavor::Zero(b)) => a == b,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl<T> Drop for Receiver<T> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            match &self.flavor {\n+                ReceiverFlavor::Array(chan) => chan.release(|c| c.disconnect()),\n+                ReceiverFlavor::List(chan) => chan.release(|c| c.disconnect_receivers()),\n+                ReceiverFlavor::Zero(chan) => chan.release(|c| c.disconnect()),\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> Clone for Receiver<T> {\n+    fn clone(&self) -> Self {\n+        let flavor = match &self.flavor {\n+            ReceiverFlavor::Array(chan) => ReceiverFlavor::Array(chan.acquire()),\n+            ReceiverFlavor::List(chan) => ReceiverFlavor::List(chan.acquire()),\n+            ReceiverFlavor::Zero(chan) => ReceiverFlavor::Zero(chan.acquire()),\n+        };\n+\n+        Receiver { flavor }\n+    }\n+}\n+\n+impl<T> fmt::Debug for Receiver<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.pad(\"Receiver { .. }\")\n+    }\n+}"}, {"sha": "56a83fee2e119c3396c394b67ca99d8599f117a2", "filename": "library/std/src/sync/mpmc/select.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/a43da5a09701469e013c623c7cfc1e2f7ec83e47/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a43da5a09701469e013c623c7cfc1e2f7ec83e47/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fselect.rs?ref=a43da5a09701469e013c623c7cfc1e2f7ec83e47", "patch": "@@ -0,0 +1,71 @@\n+/// Temporary data that gets initialized during a blocking operation, and is consumed by\n+/// `read` or `write`.\n+///\n+/// Each field contains data associated with a specific channel flavor.\n+#[derive(Debug, Default)]\n+pub struct Token {\n+    pub(crate) array: super::array::ArrayToken,\n+    pub(crate) list: super::list::ListToken,\n+    #[allow(dead_code)]\n+    pub(crate) zero: super::zero::ZeroToken,\n+}\n+\n+/// Identifier associated with an operation by a specific thread on a specific channel.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub struct Operation(usize);\n+\n+impl Operation {\n+    /// Creates an operation identifier from a mutable reference.\n+    ///\n+    /// This function essentially just turns the address of the reference into a number. The\n+    /// reference should point to a variable that is specific to the thread and the operation,\n+    /// and is alive for the entire duration of a blocking operation.\n+    #[inline]\n+    pub fn hook<T>(r: &mut T) -> Operation {\n+        let val = r as *mut T as usize;\n+        // Make sure that the pointer address doesn't equal the numerical representation of\n+        // `Selected::{Waiting, Aborted, Disconnected}`.\n+        assert!(val > 2);\n+        Operation(val)\n+    }\n+}\n+\n+/// Current state of a blocking operation.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum Selected {\n+    /// Still waiting for an operation.\n+    Waiting,\n+\n+    /// The attempt to block the current thread has been aborted.\n+    Aborted,\n+\n+    /// An operation became ready because a channel is disconnected.\n+    Disconnected,\n+\n+    /// An operation became ready because a message can be sent or received.\n+    Operation(Operation),\n+}\n+\n+impl From<usize> for Selected {\n+    #[inline]\n+    fn from(val: usize) -> Selected {\n+        match val {\n+            0 => Selected::Waiting,\n+            1 => Selected::Aborted,\n+            2 => Selected::Disconnected,\n+            oper => Selected::Operation(Operation(oper)),\n+        }\n+    }\n+}\n+\n+impl Into<usize> for Selected {\n+    #[inline]\n+    fn into(self) -> usize {\n+        match self {\n+            Selected::Waiting => 0,\n+            Selected::Aborted => 1,\n+            Selected::Disconnected => 2,\n+            Selected::Operation(Operation(val)) => val,\n+        }\n+    }\n+}"}, {"sha": "3f0cb848cc5ce3d63a45d14b1bf517e44c3b6f31", "filename": "library/std/src/sync/mpmc/utils.rs", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/a43da5a09701469e013c623c7cfc1e2f7ec83e47/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a43da5a09701469e013c623c7cfc1e2f7ec83e47/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Futils.rs?ref=a43da5a09701469e013c623c7cfc1e2f7ec83e47", "patch": "@@ -0,0 +1,143 @@\n+use crate::cell::Cell;\n+use crate::ops::{Deref, DerefMut};\n+\n+/// Pads and aligns a value to the length of a cache line.\n+#[derive(Clone, Copy, Default, Hash, PartialEq, Eq)]\n+// Starting from Intel's Sandy Bridge, spatial prefetcher is now pulling pairs of 64-byte cache\n+// lines at a time, so we have to align to 128 bytes rather than 64.\n+//\n+// Sources:\n+// - https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf\n+// - https://github.com/facebook/folly/blob/1b5288e6eea6df074758f877c849b6e73bbb9fbb/folly/lang/Align.h#L107\n+//\n+// ARM's big.LITTLE architecture has asymmetric cores and \"big\" cores have 128-byte cache line size.\n+//\n+// Sources:\n+// - https://www.mono-project.com/news/2016/09/12/arm64-icache/\n+//\n+// powerpc64 has 128-byte cache line size.\n+//\n+// Sources:\n+// - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_ppc64x.go#L9\n+#[cfg_attr(\n+    any(target_arch = \"x86_64\", target_arch = \"aarch64\", target_arch = \"powerpc64\",),\n+    repr(align(128))\n+)]\n+// arm, mips, mips64, and riscv64 have 32-byte cache line size.\n+//\n+// Sources:\n+// - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_arm.go#L7\n+// - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_mips.go#L7\n+// - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_mipsle.go#L7\n+// - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_mips64x.go#L9\n+// - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_riscv64.go#L7\n+#[cfg_attr(\n+    any(\n+        target_arch = \"arm\",\n+        target_arch = \"mips\",\n+        target_arch = \"mips64\",\n+        target_arch = \"riscv64\",\n+    ),\n+    repr(align(32))\n+)]\n+// s390x has 256-byte cache line size.\n+//\n+// Sources:\n+// - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_s390x.go#L7\n+#[cfg_attr(target_arch = \"s390x\", repr(align(256)))]\n+// x86 and wasm have 64-byte cache line size.\n+//\n+// Sources:\n+// - https://github.com/golang/go/blob/dda2991c2ea0c5914714469c4defc2562a907230/src/internal/cpu/cpu_x86.go#L9\n+// - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_wasm.go#L7\n+//\n+// All others are assumed to have 64-byte cache line size.\n+#[cfg_attr(\n+    not(any(\n+        target_arch = \"x86_64\",\n+        target_arch = \"aarch64\",\n+        target_arch = \"powerpc64\",\n+        target_arch = \"arm\",\n+        target_arch = \"mips\",\n+        target_arch = \"mips64\",\n+        target_arch = \"riscv64\",\n+        target_arch = \"s390x\",\n+    )),\n+    repr(align(64))\n+)]\n+pub struct CachePadded<T> {\n+    value: T,\n+}\n+\n+impl<T> CachePadded<T> {\n+    /// Pads and aligns a value to the length of a cache line.\n+    pub fn new(value: T) -> CachePadded<T> {\n+        CachePadded::<T> { value }\n+    }\n+}\n+\n+impl<T> Deref for CachePadded<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        &self.value\n+    }\n+}\n+\n+impl<T> DerefMut for CachePadded<T> {\n+    fn deref_mut(&mut self) -> &mut T {\n+        &mut self.value\n+    }\n+}\n+\n+const SPIN_LIMIT: u32 = 6;\n+const YIELD_LIMIT: u32 = 10;\n+\n+/// Performs exponential backoff in spin loops.\n+pub struct Backoff {\n+    step: Cell<u32>,\n+}\n+\n+impl Backoff {\n+    /// Creates a new `Backoff`.\n+    pub fn new() -> Self {\n+        Backoff { step: Cell::new(0) }\n+    }\n+\n+    /// Backs off in a lock-free loop.\n+    ///\n+    /// This method should be used when we need to retry an operation because another thread made\n+    /// progress.\n+    #[inline]\n+    pub fn spin(&self) {\n+        for _ in 0..1 << self.step.get().min(SPIN_LIMIT) {\n+            crate::hint::spin_loop();\n+        }\n+\n+        if self.step.get() <= SPIN_LIMIT {\n+            self.step.set(self.step.get() + 1);\n+        }\n+    }\n+\n+    /// Backs off in a blocking loop.\n+    #[inline]\n+    pub fn snooze(&self) {\n+        if self.step.get() <= SPIN_LIMIT {\n+            for _ in 0..1 << self.step.get() {\n+                crate::hint::spin_loop()\n+            }\n+        } else {\n+            crate::thread::yield_now();\n+        }\n+\n+        if self.step.get() <= YIELD_LIMIT {\n+            self.step.set(self.step.get() + 1);\n+        }\n+    }\n+\n+    /// Returns `true` if exponential backoff has completed and blocking the thread is advised.\n+    #[inline]\n+    pub fn is_completed(&self) -> bool {\n+        self.step.get() > YIELD_LIMIT\n+    }\n+}"}, {"sha": "572ac01d3f7056cf3e4a93c29fb82bb71e896e51", "filename": "library/std/src/sync/mpmc/waker.rs", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/a43da5a09701469e013c623c7cfc1e2f7ec83e47/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fwaker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a43da5a09701469e013c623c7cfc1e2f7ec83e47/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fwaker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fwaker.rs?ref=a43da5a09701469e013c623c7cfc1e2f7ec83e47", "patch": "@@ -0,0 +1,207 @@\n+//! Waking mechanism for threads blocked on channel operations.\n+\n+use super::context::Context;\n+use super::select::{Operation, Selected};\n+\n+use crate::ptr;\n+use crate::sync::atomic::{AtomicBool, Ordering};\n+use crate::sync::Mutex;\n+use crate::thread::{self, ThreadId};\n+\n+/// Represents a thread blocked on a specific channel operation.\n+pub(crate) struct Entry {\n+    /// The operation.\n+    pub(crate) oper: Operation,\n+\n+    /// Optional packet.\n+    pub(crate) packet: *mut (),\n+\n+    /// Context associated with the thread owning this operation.\n+    pub(crate) cx: Context,\n+}\n+\n+/// A queue of threads blocked on channel operations.\n+///\n+/// This data structure is used by threads to register blocking operations and get woken up once\n+/// an operation becomes ready.\n+pub(crate) struct Waker {\n+    /// A list of select operations.\n+    selectors: Vec<Entry>,\n+\n+    /// A list of operations waiting to be ready.\n+    observers: Vec<Entry>,\n+}\n+\n+impl Waker {\n+    /// Creates a new `Waker`.\n+    #[inline]\n+    pub(crate) fn new() -> Self {\n+        Waker { selectors: Vec::new(), observers: Vec::new() }\n+    }\n+\n+    /// Registers a select operation.\n+    #[inline]\n+    pub(crate) fn register(&mut self, oper: Operation, cx: &Context) {\n+        self.register_with_packet(oper, ptr::null_mut(), cx);\n+    }\n+\n+    /// Registers a select operation and a packet.\n+    #[inline]\n+    pub(crate) fn register_with_packet(&mut self, oper: Operation, packet: *mut (), cx: &Context) {\n+        self.selectors.push(Entry { oper, packet, cx: cx.clone() });\n+    }\n+\n+    /// Unregisters a select operation.\n+    #[inline]\n+    pub(crate) fn unregister(&mut self, oper: Operation) -> Option<Entry> {\n+        if let Some((i, _)) =\n+            self.selectors.iter().enumerate().find(|&(_, entry)| entry.oper == oper)\n+        {\n+            let entry = self.selectors.remove(i);\n+            Some(entry)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Attempts to find another thread's entry, select the operation, and wake it up.\n+    #[inline]\n+    pub(crate) fn try_select(&mut self) -> Option<Entry> {\n+        self.selectors\n+            .iter()\n+            .position(|selector| {\n+                // Does the entry belong to a different thread?\n+                selector.cx.thread_id() != current_thread_id()\n+                    && selector // Try selecting this operation.\n+                        .cx\n+                        .try_select(Selected::Operation(selector.oper))\n+                        .is_ok()\n+                    && {\n+                        // Provide the packet.\n+                        selector.cx.store_packet(selector.packet);\n+                        // Wake the thread up.\n+                        selector.cx.unpark();\n+                        true\n+                    }\n+            })\n+            // Remove the entry from the queue to keep it clean and improve\n+            // performance.\n+            .map(|pos| self.selectors.remove(pos))\n+    }\n+\n+    /// Notifies all operations waiting to be ready.\n+    #[inline]\n+    pub(crate) fn notify(&mut self) {\n+        for entry in self.observers.drain(..) {\n+            if entry.cx.try_select(Selected::Operation(entry.oper)).is_ok() {\n+                entry.cx.unpark();\n+            }\n+        }\n+    }\n+\n+    /// Notifies all registered operations that the channel is disconnected.\n+    #[inline]\n+    pub(crate) fn disconnect(&mut self) {\n+        for entry in self.selectors.iter() {\n+            if entry.cx.try_select(Selected::Disconnected).is_ok() {\n+                // Wake the thread up.\n+                //\n+                // Here we don't remove the entry from the queue. Registered threads must\n+                // unregister from the waker by themselves. They might also want to recover the\n+                // packet value and destroy it, if necessary.\n+                entry.cx.unpark();\n+            }\n+        }\n+\n+        self.notify();\n+    }\n+}\n+\n+impl Drop for Waker {\n+    #[inline]\n+    fn drop(&mut self) {\n+        debug_assert_eq!(self.selectors.len(), 0);\n+        debug_assert_eq!(self.observers.len(), 0);\n+    }\n+}\n+\n+/// A waker that can be shared among threads without locking.\n+///\n+/// This is a simple wrapper around `Waker` that internally uses a mutex for synchronization.\n+pub(crate) struct SyncWaker {\n+    /// The inner `Waker`.\n+    inner: Mutex<Waker>,\n+\n+    /// `true` if the waker is empty.\n+    is_empty: AtomicBool,\n+}\n+\n+impl SyncWaker {\n+    /// Creates a new `SyncWaker`.\n+    #[inline]\n+    pub(crate) fn new() -> Self {\n+        SyncWaker { inner: Mutex::new(Waker::new()), is_empty: AtomicBool::new(true) }\n+    }\n+\n+    /// Registers the current thread with an operation.\n+    #[inline]\n+    pub(crate) fn register(&self, oper: Operation, cx: &Context) {\n+        let mut inner = self.inner.lock().unwrap();\n+        inner.register(oper, cx);\n+        self.is_empty\n+            .store(inner.selectors.is_empty() && inner.observers.is_empty(), Ordering::SeqCst);\n+    }\n+\n+    /// Unregisters an operation previously registered by the current thread.\n+    #[inline]\n+    pub(crate) fn unregister(&self, oper: Operation) -> Option<Entry> {\n+        let mut inner = self.inner.lock().unwrap();\n+        let entry = inner.unregister(oper);\n+        self.is_empty\n+            .store(inner.selectors.is_empty() && inner.observers.is_empty(), Ordering::SeqCst);\n+        entry\n+    }\n+\n+    /// Attempts to find one thread (not the current one), select its operation, and wake it up.\n+    #[inline]\n+    pub(crate) fn notify(&self) {\n+        if !self.is_empty.load(Ordering::SeqCst) {\n+            let mut inner = self.inner.lock().unwrap();\n+            if !self.is_empty.load(Ordering::SeqCst) {\n+                inner.try_select();\n+                inner.notify();\n+                self.is_empty.store(\n+                    inner.selectors.is_empty() && inner.observers.is_empty(),\n+                    Ordering::SeqCst,\n+                );\n+            }\n+        }\n+    }\n+\n+    /// Notifies all threads that the channel is disconnected.\n+    #[inline]\n+    pub(crate) fn disconnect(&self) {\n+        let mut inner = self.inner.lock().unwrap();\n+        inner.disconnect();\n+        self.is_empty\n+            .store(inner.selectors.is_empty() && inner.observers.is_empty(), Ordering::SeqCst);\n+    }\n+}\n+\n+impl Drop for SyncWaker {\n+    #[inline]\n+    fn drop(&mut self) {\n+        debug_assert!(self.is_empty.load(Ordering::SeqCst));\n+    }\n+}\n+\n+/// Returns the id of the current thread.\n+#[inline]\n+fn current_thread_id() -> ThreadId {\n+    thread_local! {\n+        /// Cached thread-local id.\n+        static THREAD_ID: ThreadId = thread::current().id();\n+    }\n+\n+    THREAD_ID.try_with(|id| *id).unwrap_or_else(|_| thread::current().id())\n+}"}, {"sha": "fccd6c29a7e462f5993bb30c72526d3fe44c0913", "filename": "library/std/src/sync/mpmc/zero.rs", "status": "added", "additions": 318, "deletions": 0, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/a43da5a09701469e013c623c7cfc1e2f7ec83e47/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a43da5a09701469e013c623c7cfc1e2f7ec83e47/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fzero.rs?ref=a43da5a09701469e013c623c7cfc1e2f7ec83e47", "patch": "@@ -0,0 +1,318 @@\n+//! Zero-capacity channel.\n+//!\n+//! This kind of channel is also known as *rendezvous* channel.\n+\n+use super::context::Context;\n+use super::error::*;\n+use super::select::{Operation, Selected, Token};\n+use super::utils::Backoff;\n+use super::waker::Waker;\n+\n+use crate::cell::UnsafeCell;\n+use crate::marker::PhantomData;\n+use crate::sync::atomic::{AtomicBool, Ordering};\n+use crate::sync::Mutex;\n+use crate::time::Instant;\n+use crate::{fmt, ptr};\n+\n+/// A pointer to a packet.\n+pub(crate) struct ZeroToken(*mut ());\n+\n+impl Default for ZeroToken {\n+    fn default() -> Self {\n+        Self(ptr::null_mut())\n+    }\n+}\n+\n+impl fmt::Debug for ZeroToken {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Debug::fmt(&(self.0 as usize), f)\n+    }\n+}\n+\n+/// A slot for passing one message from a sender to a receiver.\n+struct Packet<T> {\n+    /// Equals `true` if the packet is allocated on the stack.\n+    on_stack: bool,\n+\n+    /// Equals `true` once the packet is ready for reading or writing.\n+    ready: AtomicBool,\n+\n+    /// The message.\n+    msg: UnsafeCell<Option<T>>,\n+}\n+\n+impl<T> Packet<T> {\n+    /// Creates an empty packet on the stack.\n+    fn empty_on_stack() -> Packet<T> {\n+        Packet { on_stack: true, ready: AtomicBool::new(false), msg: UnsafeCell::new(None) }\n+    }\n+\n+    /// Creates a packet on the stack, containing a message.\n+    fn message_on_stack(msg: T) -> Packet<T> {\n+        Packet { on_stack: true, ready: AtomicBool::new(false), msg: UnsafeCell::new(Some(msg)) }\n+    }\n+\n+    /// Waits until the packet becomes ready for reading or writing.\n+    fn wait_ready(&self) {\n+        let backoff = Backoff::new();\n+        while !self.ready.load(Ordering::Acquire) {\n+            backoff.snooze();\n+        }\n+    }\n+}\n+\n+/// Inner representation of a zero-capacity channel.\n+struct Inner {\n+    /// Senders waiting to pair up with a receive operation.\n+    senders: Waker,\n+\n+    /// Receivers waiting to pair up with a send operation.\n+    receivers: Waker,\n+\n+    /// Equals `true` when the channel is disconnected.\n+    is_disconnected: bool,\n+}\n+\n+/// Zero-capacity channel.\n+pub(crate) struct Channel<T> {\n+    /// Inner representation of the channel.\n+    inner: Mutex<Inner>,\n+\n+    /// Indicates that dropping a `Channel<T>` may drop values of type `T`.\n+    _marker: PhantomData<T>,\n+}\n+\n+impl<T> Channel<T> {\n+    /// Constructs a new zero-capacity channel.\n+    pub(crate) fn new() -> Self {\n+        Channel {\n+            inner: Mutex::new(Inner {\n+                senders: Waker::new(),\n+                receivers: Waker::new(),\n+                is_disconnected: false,\n+            }),\n+            _marker: PhantomData,\n+        }\n+    }\n+\n+    /// Writes a message into the packet.\n+    pub(crate) unsafe fn write(&self, token: &mut Token, msg: T) -> Result<(), T> {\n+        // If there is no packet, the channel is disconnected.\n+        if token.zero.0.is_null() {\n+            return Err(msg);\n+        }\n+\n+        let packet = &*(token.zero.0 as *const Packet<T>);\n+        packet.msg.get().write(Some(msg));\n+        packet.ready.store(true, Ordering::Release);\n+        Ok(())\n+    }\n+\n+    /// Reads a message from the packet.\n+    pub(crate) unsafe fn read(&self, token: &mut Token) -> Result<T, ()> {\n+        // If there is no packet, the channel is disconnected.\n+        if token.zero.0.is_null() {\n+            return Err(());\n+        }\n+\n+        let packet = &*(token.zero.0 as *const Packet<T>);\n+\n+        if packet.on_stack {\n+            // The message has been in the packet from the beginning, so there is no need to wait\n+            // for it. However, after reading the message, we need to set `ready` to `true` in\n+            // order to signal that the packet can be destroyed.\n+            let msg = packet.msg.get().replace(None).unwrap();\n+            packet.ready.store(true, Ordering::Release);\n+            Ok(msg)\n+        } else {\n+            // Wait until the message becomes available, then read it and destroy the\n+            // heap-allocated packet.\n+            packet.wait_ready();\n+            let msg = packet.msg.get().replace(None).unwrap();\n+            drop(Box::from_raw(token.zero.0 as *mut Packet<T>));\n+            Ok(msg)\n+        }\n+    }\n+\n+    /// Attempts to send a message into the channel.\n+    pub(crate) fn try_send(&self, msg: T) -> Result<(), TrySendError<T>> {\n+        let token = &mut Token::default();\n+        let mut inner = self.inner.lock().unwrap();\n+\n+        // If there's a waiting receiver, pair up with it.\n+        if let Some(operation) = inner.receivers.try_select() {\n+            token.zero.0 = operation.packet;\n+            drop(inner);\n+            unsafe {\n+                self.write(token, msg).ok().unwrap();\n+            }\n+            Ok(())\n+        } else if inner.is_disconnected {\n+            Err(TrySendError::Disconnected(msg))\n+        } else {\n+            Err(TrySendError::Full(msg))\n+        }\n+    }\n+\n+    /// Sends a message into the channel.\n+    pub(crate) fn send(\n+        &self,\n+        msg: T,\n+        deadline: Option<Instant>,\n+    ) -> Result<(), SendTimeoutError<T>> {\n+        let token = &mut Token::default();\n+        let mut inner = self.inner.lock().unwrap();\n+\n+        // If there's a waiting receiver, pair up with it.\n+        if let Some(operation) = inner.receivers.try_select() {\n+            token.zero.0 = operation.packet;\n+            drop(inner);\n+            unsafe {\n+                self.write(token, msg).ok().unwrap();\n+            }\n+            return Ok(());\n+        }\n+\n+        if inner.is_disconnected {\n+            return Err(SendTimeoutError::Disconnected(msg));\n+        }\n+\n+        Context::with(|cx| {\n+            // Prepare for blocking until a receiver wakes us up.\n+            let oper = Operation::hook(token);\n+            let mut packet = Packet::<T>::message_on_stack(msg);\n+            inner.senders.register_with_packet(oper, &mut packet as *mut Packet<T> as *mut (), cx);\n+            inner.receivers.notify();\n+            drop(inner);\n+\n+            // Block the current thread.\n+            let sel = cx.wait_until(deadline);\n+\n+            match sel {\n+                Selected::Waiting => unreachable!(),\n+                Selected::Aborted => {\n+                    self.inner.lock().unwrap().senders.unregister(oper).unwrap();\n+                    let msg = unsafe { packet.msg.get().replace(None).unwrap() };\n+                    Err(SendTimeoutError::Timeout(msg))\n+                }\n+                Selected::Disconnected => {\n+                    self.inner.lock().unwrap().senders.unregister(oper).unwrap();\n+                    let msg = unsafe { packet.msg.get().replace(None).unwrap() };\n+                    Err(SendTimeoutError::Disconnected(msg))\n+                }\n+                Selected::Operation(_) => {\n+                    // Wait until the message is read, then drop the packet.\n+                    packet.wait_ready();\n+                    Ok(())\n+                }\n+            }\n+        })\n+    }\n+\n+    /// Attempts to receive a message without blocking.\n+    pub(crate) fn try_recv(&self) -> Result<T, TryRecvError> {\n+        let token = &mut Token::default();\n+        let mut inner = self.inner.lock().unwrap();\n+\n+        // If there's a waiting sender, pair up with it.\n+        if let Some(operation) = inner.senders.try_select() {\n+            token.zero.0 = operation.packet;\n+            drop(inner);\n+            unsafe { self.read(token).map_err(|_| TryRecvError::Disconnected) }\n+        } else if inner.is_disconnected {\n+            Err(TryRecvError::Disconnected)\n+        } else {\n+            Err(TryRecvError::Empty)\n+        }\n+    }\n+\n+    /// Receives a message from the channel.\n+    pub(crate) fn recv(&self, deadline: Option<Instant>) -> Result<T, RecvTimeoutError> {\n+        let token = &mut Token::default();\n+        let mut inner = self.inner.lock().unwrap();\n+\n+        // If there's a waiting sender, pair up with it.\n+        if let Some(operation) = inner.senders.try_select() {\n+            token.zero.0 = operation.packet;\n+            drop(inner);\n+            unsafe {\n+                return self.read(token).map_err(|_| RecvTimeoutError::Disconnected);\n+            }\n+        }\n+\n+        if inner.is_disconnected {\n+            return Err(RecvTimeoutError::Disconnected);\n+        }\n+\n+        Context::with(|cx| {\n+            // Prepare for blocking until a sender wakes us up.\n+            let oper = Operation::hook(token);\n+            let mut packet = Packet::<T>::empty_on_stack();\n+            inner.receivers.register_with_packet(\n+                oper,\n+                &mut packet as *mut Packet<T> as *mut (),\n+                cx,\n+            );\n+            inner.senders.notify();\n+            drop(inner);\n+\n+            // Block the current thread.\n+            let sel = cx.wait_until(deadline);\n+\n+            match sel {\n+                Selected::Waiting => unreachable!(),\n+                Selected::Aborted => {\n+                    self.inner.lock().unwrap().receivers.unregister(oper).unwrap();\n+                    Err(RecvTimeoutError::Timeout)\n+                }\n+                Selected::Disconnected => {\n+                    self.inner.lock().unwrap().receivers.unregister(oper).unwrap();\n+                    Err(RecvTimeoutError::Disconnected)\n+                }\n+                Selected::Operation(_) => {\n+                    // Wait until the message is provided, then read it.\n+                    packet.wait_ready();\n+                    unsafe { Ok(packet.msg.get().replace(None).unwrap()) }\n+                }\n+            }\n+        })\n+    }\n+\n+    /// Disconnects the channel and wakes up all blocked senders and receivers.\n+    ///\n+    /// Returns `true` if this call disconnected the channel.\n+    pub(crate) fn disconnect(&self) -> bool {\n+        let mut inner = self.inner.lock().unwrap();\n+\n+        if !inner.is_disconnected {\n+            inner.is_disconnected = true;\n+            inner.senders.disconnect();\n+            inner.receivers.disconnect();\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Returns the current number of messages inside the channel.\n+    pub(crate) fn len(&self) -> usize {\n+        0\n+    }\n+\n+    /// Returns the capacity of the channel.\n+    #[allow(clippy::unnecessary_wraps)] // This is intentional.\n+    pub(crate) fn capacity(&self) -> Option<usize> {\n+        Some(0)\n+    }\n+\n+    /// Returns `true` if the channel is empty.\n+    pub(crate) fn is_empty(&self) -> bool {\n+        true\n+    }\n+\n+    /// Returns `true` if the channel is full.\n+    pub(crate) fn is_full(&self) -> bool {\n+        true\n+    }\n+}"}]}