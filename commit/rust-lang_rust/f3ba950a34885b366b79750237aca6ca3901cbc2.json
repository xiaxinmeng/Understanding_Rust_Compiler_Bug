{"sha": "f3ba950a34885b366b79750237aca6ca3901cbc2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzYmE5NTBhMzQ4ODViMzY2Yjc5NzUwMjM3YWNhNmNhMzkwMWNiYzI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-07-03T00:50:18Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-07-03T05:29:24Z"}, "message": "Refactor how the parser looks for sub-modules\n\nThis makes the functionality usable from outside the parser", "tree": {"sha": "c28a7cee50f3d8cce94e53870d94154bcd2c5fc4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c28a7cee50f3d8cce94e53870d94154bcd2c5fc4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3ba950a34885b366b79750237aca6ca3901cbc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3ba950a34885b366b79750237aca6ca3901cbc2", "html_url": "https://github.com/rust-lang/rust/commit/f3ba950a34885b366b79750237aca6ca3901cbc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3ba950a34885b366b79750237aca6ca3901cbc2/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68094818969b295a043963ad59c502928f66239f", "url": "https://api.github.com/repos/rust-lang/rust/commits/68094818969b295a043963ad59c502928f66239f", "html_url": "https://github.com/rust-lang/rust/commit/68094818969b295a043963ad59c502928f66239f"}], "stats": {"total": 176, "additions": 108, "deletions": 68}, "files": [{"sha": "d19364f5f44a24629e6bbf42c83fac1c1765f4c8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 108, "deletions": 68, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/f3ba950a34885b366b79750237aca6ca3901cbc2/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ba950a34885b366b79750237aca6ca3901cbc2/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f3ba950a34885b366b79750237aca6ca3901cbc2", "patch": "@@ -60,7 +60,7 @@ use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause};\n use ast;\n use ast_util::{self, AS_PREC, ident_to_path, operator_prec};\n-use codemap::{self, Span, BytePos, Spanned, spanned, mk_sp};\n+use codemap::{self, Span, BytePos, Spanned, spanned, mk_sp, CodeMap};\n use diagnostic;\n use ext::tt::macro_parser;\n use parse;\n@@ -297,6 +297,24 @@ fn is_plain_ident_or_underscore(t: &token::Token) -> bool {\n     t.is_plain_ident() || *t == token::Underscore\n }\n \n+/// Information about the path to a module.\n+pub struct ModulePath {\n+    pub name: String,\n+    pub path_exists: bool,\n+    pub result: Result<ModulePathSuccess, ModulePathError>,\n+}\n+\n+pub struct ModulePathSuccess {\n+    pub path: ::std::path::PathBuf,\n+    pub owns_directory: bool,\n+}\n+\n+pub struct ModulePathError {\n+    pub err_msg: String,\n+    pub help_msg: String,\n+}\n+\n+\n impl<'a> Parser<'a> {\n     pub fn new(sess: &'a ParseSess,\n                cfg: ast::CrateConfig,\n@@ -4861,82 +4879,104 @@ impl<'a> Parser<'a> {\n         self.mod_path_stack.pop().unwrap();\n     }\n \n-    /// Read a module from a source file.\n-    fn eval_src_mod(&mut self,\n-                    id: ast::Ident,\n-                    outer_attrs: &[ast::Attribute],\n-                    id_sp: Span)\n-                    -> PResult<(ast::Item_, Vec<ast::Attribute> )> {\n+    pub fn submod_path_from_attr(attrs: &[ast::Attribute], dir_path: &Path) -> Option<PathBuf> {\n+        ::attr::first_attr_value_str_by_name(attrs, \"path\").map(|d| dir_path.join(&*d))\n+    }\n+\n+    /// Returns either a path to a module, or .\n+    pub fn default_submod_path(id: ast::Ident, dir_path: &Path, codemap: &CodeMap) -> ModulePath\n+    {\n+        let mod_string = token::get_ident(id);\n+        let mod_name = mod_string.to_string();\n+        let default_path_str = format!(\"{}.rs\", mod_name);\n+        let secondary_path_str = format!(\"{}/mod.rs\", mod_name);\n+        let default_path = dir_path.join(&default_path_str);\n+        let secondary_path = dir_path.join(&secondary_path_str);\n+        let default_exists = codemap.file_exists(&default_path);\n+        let secondary_exists = codemap.file_exists(&secondary_path);\n+\n+        let result = match (default_exists, secondary_exists) {\n+            (true, false) => Ok(ModulePathSuccess { path: default_path, owns_directory: false }),\n+            (false, true) => Ok(ModulePathSuccess { path: secondary_path, owns_directory: true }),\n+            (false, false) => Err(ModulePathError {\n+                err_msg: format!(\"file not found for module `{}`\", mod_name),\n+                help_msg: format!(\"name the file either {} or {} inside the directory {:?}\",\n+                                  default_path_str,\n+                                  secondary_path_str,\n+                                  dir_path.display()),\n+            }),\n+            (true, true) => Err(ModulePathError {\n+                err_msg: format!(\"file for module `{}` found at both {} and {}\",\n+                                 mod_name,\n+                                 default_path_str,\n+                                 secondary_path_str),\n+                help_msg: \"delete or rename one of them to remove the ambiguity\".to_owned(),\n+            }),\n+        };\n+\n+        ModulePath {\n+            name: mod_name,\n+            path_exists: default_exists || secondary_exists,\n+            result: result,\n+        }\n+    }\n+\n+    fn submod_path(&mut self,\n+                   id: ast::Ident,\n+                   outer_attrs: &[ast::Attribute],\n+                   id_sp: Span) -> PResult<ModulePathSuccess> {\n         let mut prefix = PathBuf::from(&self.sess.codemap().span_to_filename(self.span));\n         prefix.pop();\n         let mut dir_path = prefix;\n         for part in &self.mod_path_stack {\n             dir_path.push(&**part);\n         }\n-        let mod_string = token::get_ident(id);\n-        let (file_path, owns_directory) = match ::attr::first_attr_value_str_by_name(\n-                outer_attrs, \"path\") {\n-            Some(d) => (dir_path.join(&*d), true),\n-            None => {\n-                let mod_name = mod_string.to_string();\n-                let default_path_str = format!(\"{}.rs\", mod_name);\n-                let secondary_path_str = format!(\"{}/mod.rs\", mod_name);\n-                let default_path = dir_path.join(&default_path_str[..]);\n-                let secondary_path = dir_path.join(&secondary_path_str[..]);\n-                let default_exists = self.sess.codemap().file_exists(&default_path);\n-                let secondary_exists = self.sess.codemap().file_exists(&secondary_path);\n-\n-                if !self.owns_directory {\n-                    self.span_err(id_sp,\n-                                  \"cannot declare a new module at this location\");\n-                    let this_module = match self.mod_path_stack.last() {\n-                        Some(name) => name.to_string(),\n-                        None => self.root_module_name.as_ref().unwrap().clone(),\n-                    };\n-                    self.span_note(id_sp,\n-                                   &format!(\"maybe move this module `{0}` \\\n-                                            to its own directory via \\\n-                                            `{0}/mod.rs`\",\n-                                           this_module));\n-                    if default_exists || secondary_exists {\n-                        self.span_note(id_sp,\n-                                       &format!(\"... or maybe `use` the module \\\n-                                                `{}` instead of possibly \\\n-                                                redeclaring it\",\n-                                               mod_name));\n-                    }\n-                    self.abort_if_errors();\n-                }\n \n-                match (default_exists, secondary_exists) {\n-                    (true, false) => (default_path, false),\n-                    (false, true) => (secondary_path, true),\n-                    (false, false) => {\n-                        return Err(self.span_fatal_help(id_sp,\n-                                             &format!(\"file not found for module `{}`\",\n-                                                     mod_name),\n-                                             &format!(\"name the file either {} or {} inside \\\n-                                                     the directory {:?}\",\n-                                                     default_path_str,\n-                                                     secondary_path_str,\n-                                                     dir_path.display())));\n-                    }\n-                    (true, true) => {\n-                        return Err(self.span_fatal_help(\n-                            id_sp,\n-                            &format!(\"file for module `{}` found at both {} \\\n-                                     and {}\",\n-                                    mod_name,\n-                                    default_path_str,\n-                                    secondary_path_str),\n-                            \"delete or rename one of them to remove the ambiguity\"));\n-                    }\n-                }\n+        if let Some(p) = Parser::submod_path_from_attr(outer_attrs, &dir_path) {\n+            return Ok(ModulePathSuccess { path: p, owns_directory: true });\n+        }\n+\n+        let paths = Parser::default_submod_path(id, &dir_path, self.sess.codemap());\n+\n+        if !self.owns_directory {\n+            self.span_err(id_sp, \"cannot declare a new module at this location\");\n+            let this_module = match self.mod_path_stack.last() {\n+                Some(name) => name.to_string(),\n+                None => self.root_module_name.as_ref().unwrap().clone(),\n+            };\n+            self.span_note(id_sp,\n+                           &format!(\"maybe move this module `{0}` to its own directory \\\n+                                     via `{0}/mod.rs`\",\n+                                    this_module));\n+            if paths.path_exists {\n+                self.span_note(id_sp,\n+                               &format!(\"... or maybe `use` the module `{}` instead \\\n+                                         of possibly redeclaring it\",\n+                                        paths.name));\n             }\n-        };\n+            self.abort_if_errors();\n+        }\n+\n+        match paths.result {\n+            Ok(succ) => Ok(succ),\n+            Err(err) => Err(self.span_fatal_help(id_sp, &err.err_msg, &err.help_msg)),\n+        }\n+    }\n \n-        self.eval_src_mod_from_path(file_path, owns_directory,\n-                                    mod_string.to_string(), id_sp)\n+    /// Read a module from a source file.\n+    fn eval_src_mod(&mut self,\n+                    id: ast::Ident,\n+                    outer_attrs: &[ast::Attribute],\n+                    id_sp: Span)\n+                    -> PResult<(ast::Item_, Vec<ast::Attribute> )> {\n+        let ModulePathSuccess { path, owns_directory } = try!(self.submod_path(id,\n+                                                                               outer_attrs,\n+                                                                               id_sp));\n+\n+        self.eval_src_mod_from_path(path,\n+                                    owns_directory,\n+                                    token::get_ident(id).to_string(),\n+                                    id_sp)\n     }\n \n     fn eval_src_mod_from_path(&mut self,"}]}