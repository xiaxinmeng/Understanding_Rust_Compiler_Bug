{"sha": "660c28391c79bd12e116724a8877a2148630dee5", "node_id": "C_kwDOAAsO6NoAKDY2MGMyODM5MWM3OWJkMTJlMTE2NzI0YTg4NzdhMjE0ODYzMGRlZTU", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-01-17T10:47:47Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-01-18T07:11:15Z"}, "message": "remove assembly context and impl a bit more", "tree": {"sha": "e183d837135297d2db8490b46fc6963007142689", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e183d837135297d2db8490b46fc6963007142689"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/660c28391c79bd12e116724a8877a2148630dee5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/660c28391c79bd12e116724a8877a2148630dee5", "html_url": "https://github.com/rust-lang/rust/commit/660c28391c79bd12e116724a8877a2148630dee5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/660c28391c79bd12e116724a8877a2148630dee5/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf7dbff9210497ca3db0b19b5ca0c6daed47e64e", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf7dbff9210497ca3db0b19b5ca0c6daed47e64e", "html_url": "https://github.com/rust-lang/rust/commit/bf7dbff9210497ca3db0b19b5ca0c6daed47e64e"}], "stats": {"total": 480, "additions": 317, "deletions": 163}, "files": [{"sha": "43583b5723e698f763e7c03f5a35b19b41e25108", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/660c28391c79bd12e116724a8877a2148630dee5/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c28391c79bd12e116724a8877a2148630dee5/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=660c28391c79bd12e116724a8877a2148630dee5", "patch": "@@ -339,6 +339,12 @@ TrivialTypeTraversalAndLiftImpls! {\n }\n \n impl<'tcx> CanonicalVarValues<'tcx> {\n+    /// Creates dummy var values which should not be used in a\n+    /// canonical response.\n+    pub fn dummy() -> CanonicalVarValues<'tcx> {\n+        CanonicalVarValues { var_values: Default::default() }\n+    }\n+\n     #[inline]\n     pub fn len(&self) -> usize {\n         self.var_values.len()"}, {"sha": "cd6e4d2bccd5cfdae00dae9e2fdb09514c1431a2", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 206, "deletions": 48, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/660c28391c79bd12e116724a8877a2148630dee5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c28391c79bd12e116724a8877a2148630dee5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=660c28391c79bd12e116724a8877a2148630dee5", "patch": "@@ -12,112 +12,270 @@ use std::fmt::Debug;\n ///\n /// It consists of both the `source`, which describes how that goal would be proven,\n /// and the `result` when using the given `source`.\n-///\n-/// For the list of possible candidates, please look at the documentation of\n-/// [super::trait_goals::CandidateSource] and [super::project_goals::CandidateSource].\n #[derive(Debug, Clone)]\n-pub(super) struct Candidate<'tcx, G: GoalKind<'tcx>> {\n-    pub(super) source: G::CandidateSource,\n+pub(super) struct Candidate<'tcx> {\n+    pub(super) source: CandidateSource,\n     pub(super) result: CanonicalResponse<'tcx>,\n }\n \n-pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy {\n-    type CandidateSource: Debug + Copy;\n+/// Possible ways the given goal can be proven.\n+#[derive(Debug, Clone, Copy)]\n+pub(super) enum CandidateSource {\n+    /// A user written impl.\n+    ///\n+    /// ## Examples\n+    ///\n+    /// ```rust\n+    /// fn main() {\n+    ///     let x: Vec<u32> = Vec::new();\n+    ///     // This uses the impl from the standard library to prove `Vec<T>: Clone`.\n+    ///     let y = x.clone();\n+    /// }\n+    /// ```\n+    Impl(DefId),\n+    /// A builtin impl generated by the compiler. When adding a new special\n+    /// trait, try to use actual impls whenever possible. Builtin impls should\n+    /// only be used in cases where the impl cannot be manually be written.\n+    ///\n+    /// Notable examples are auto traits, `Sized`, and `DiscriminantKind`.\n+    /// For a list of all traits with builtin impls, check out the\n+    /// [`EvalCtxt::assemble_builtin_impl_candidates`] method. Not\n+    BuiltinImpl,\n+    /// An assumption from the environment.\n+    ///\n+    /// More precicely we've used the `n-th` assumption in the `param_env`.\n+    ///\n+    /// ## Examples\n+    ///\n+    /// ```rust\n+    /// fn is_clone<T: Clone>(x: T) -> (T, T) {\n+    ///     // This uses the assumption `T: Clone` from the `where`-bounds\n+    ///     // to prove `T: Clone`.\n+    ///     (x.clone(), x)\n+    /// }\n+    /// ```\n+    ParamEnv(usize),\n+    /// If the self type is an alias type, e.g. an opaque type or a projection,\n+    /// we know the bounds on that alias to hold even without knowing its concrete\n+    /// underlying type.\n+    ///\n+    /// More precisely this candidate is using the `n-th` bound in the `item_bounds` of\n+    /// the self type.\n+    ///\n+    /// ## Examples\n+    ///\n+    /// ```rust\n+    /// trait Trait {\n+    ///     type Assoc: Clone;\n+    /// }\n+    ///\n+    /// fn foo<T: Trait>(x: <T as Trait>::Assoc) {\n+    ///     // We prove `<T as Trait>::Assoc` by looking at the bounds on `Assoc` in\n+    ///     // in the trait definition.\n+    ///     let _y = x.clone();\n+    /// }\n+    /// ```\n+    AliasBound(usize),\n+}\n \n+pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy {\n     fn self_ty(self) -> Ty<'tcx>;\n \n     fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self;\n \n     fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId;\n \n     fn consider_impl_candidate(\n-        acx: &mut AssemblyCtxt<'_, '_, 'tcx, Self>,\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n         impl_def_id: DefId,\n-    );\n-}\n+    ) -> Result<Certainty, NoSolution>;\n \n-/// An abstraction which correctly deals with the canonical results for candidates.\n-///\n-/// It also deduplicates the behavior between trait and projection predicates.\n-pub(super) struct AssemblyCtxt<'a, 'b, 'tcx, G: GoalKind<'tcx>> {\n-    pub(super) cx: &'a mut EvalCtxt<'b, 'tcx>,\n-    candidates: Vec<Candidate<'tcx, G>>,\n-}\n+    fn consider_builtin_sized_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> Result<Certainty, NoSolution>;\n \n-impl<'a, 'b, 'tcx, G: GoalKind<'tcx>> AssemblyCtxt<'a, 'b, 'tcx, G> {\n-    pub(super) fn assemble_and_evaluate_candidates(\n-        cx: &'a mut EvalCtxt<'b, 'tcx>,\n+    fn consider_assumption(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+    ) -> Result<Certainty, NoSolution>;\n+}\n+impl<'tcx> EvalCtxt<'_, 'tcx> {\n+    pub(super) fn assemble_and_evaluate_candidates<G: GoalKind<'tcx>>(\n+        &mut self,\n         goal: Goal<'tcx, G>,\n-    ) -> Vec<Candidate<'tcx, G>> {\n-        let mut acx = AssemblyCtxt { cx, candidates: Vec::new() };\n+    ) -> Vec<Candidate<'tcx>> {\n+        let mut candidates = Vec::new();\n \n-        acx.assemble_candidates_after_normalizing_self_ty(goal);\n+        self.assemble_candidates_after_normalizing_self_ty(goal, &mut candidates);\n \n-        acx.assemble_impl_candidates(goal);\n+        self.assemble_impl_candidates(goal, &mut candidates);\n \n-        acx.candidates\n-    }\n+        self.assemble_builtin_impl_candidates(goal, &mut candidates);\n \n-    pub(super) fn try_insert_candidate(\n-        &mut self,\n-        source: G::CandidateSource,\n-        certainty: Certainty,\n-    ) {\n-        match self.cx.make_canonical_response(certainty) {\n-            Ok(result) => self.candidates.push(Candidate { source, result }),\n-            Err(NoSolution) => debug!(?source, ?certainty, \"failed leakcheck\"),\n-        }\n+        self.assemble_param_env_candidates(goal, &mut candidates);\n+\n+        self.assemble_alias_bound_candidates(goal, &mut candidates);\n+\n+        candidates\n     }\n \n     /// If the self type of a goal is a projection, computing the relevant candidates is difficult.\n     ///\n     /// To deal with this, we first try to normalize the self type and add the candidates for the normalized\n     /// self type to the list of candidates in case that succeeds. Note that we can't just eagerly return in\n     /// this case as projections as self types add `\n-    fn assemble_candidates_after_normalizing_self_ty(&mut self, goal: Goal<'tcx, G>) {\n-        let tcx = self.cx.tcx();\n-        let infcx = self.cx.infcx;\n+    fn assemble_candidates_after_normalizing_self_ty<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+        candidates: &mut Vec<Candidate<'tcx>>,\n+    ) {\n+        let tcx = self.tcx();\n         // FIXME: We also have to normalize opaque types, not sure where to best fit that in.\n         let &ty::Alias(ty::Projection, projection_ty) = goal.predicate.self_ty().kind() else {\n             return\n         };\n-        infcx.probe(|_| {\n-            let normalized_ty = infcx.next_ty_infer();\n+        self.infcx.probe(|_| {\n+            let normalized_ty = self.infcx.next_ty_infer();\n             let normalizes_to_goal = goal.with(\n                 tcx,\n                 ty::Binder::dummy(ty::ProjectionPredicate {\n                     projection_ty,\n                     term: normalized_ty.into(),\n                 }),\n             );\n-            let normalization_certainty = match self.cx.evaluate_goal(normalizes_to_goal) {\n+            let normalization_certainty = match self.evaluate_goal(normalizes_to_goal) {\n                 Ok((_, certainty)) => certainty,\n                 Err(NoSolution) => return,\n             };\n \n             // NOTE: Alternatively we could call `evaluate_goal` here and only have a `Normalized` candidate.\n-            // This doesn't work as long as we use `CandidateSource` in both winnowing and to resolve associated items.\n+            // This doesn't work as long as we use `CandidateSource` in winnowing.\n             let goal = goal.with(tcx, goal.predicate.with_self_ty(tcx, normalized_ty));\n-            let normalized_candidates =\n-                AssemblyCtxt::assemble_and_evaluate_candidates(self.cx, goal);\n+            // FIXME: This is broken if we care about the `usize` of `AliasBound` because the self type\n+            // could be normalized to yet another projection with different item bounds.\n+            let normalized_candidates = self.assemble_and_evaluate_candidates(goal);\n             for mut normalized_candidate in normalized_candidates {\n                 normalized_candidate.result =\n                     normalized_candidate.result.unchecked_map(|mut response| {\n+                        // FIXME: This currently hides overflow in the normalization step of the self type\n+                        // which is probably wrong. Maybe `unify_and` should actually keep overflow as\n+                        // we treat it as non-fatal anyways.\n                         response.certainty = response.certainty.unify_and(normalization_certainty);\n                         response\n                     });\n-                self.candidates.push(normalized_candidate);\n+                candidates.push(normalized_candidate);\n             }\n         })\n     }\n \n-    fn assemble_impl_candidates(&mut self, goal: Goal<'tcx, G>) {\n-        let tcx = self.cx.tcx();\n+    fn assemble_impl_candidates<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+        candidates: &mut Vec<Candidate<'tcx>>,\n+    ) {\n+        let tcx = self.tcx();\n         tcx.for_each_relevant_impl(\n             goal.predicate.trait_def_id(tcx),\n             goal.predicate.self_ty(),\n-            |impl_def_id| G::consider_impl_candidate(self, goal, impl_def_id),\n+            |impl_def_id| match G::consider_impl_candidate(self, goal, impl_def_id)\n+                .and_then(|certainty| self.make_canonical_response(certainty))\n+            {\n+                Ok(result) => candidates\n+                    .push(Candidate { source: CandidateSource::Impl(impl_def_id), result }),\n+                Err(NoSolution) => (),\n+            },\n         );\n     }\n+\n+    fn assemble_builtin_impl_candidates<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+        candidates: &mut Vec<Candidate<'tcx>>,\n+    ) {\n+        let lang_items = self.tcx().lang_items();\n+        let trait_def_id = goal.predicate.trait_def_id(self.tcx());\n+        let result = if lang_items.sized_trait() == Some(trait_def_id) {\n+            G::consider_builtin_sized_candidate(self, goal)\n+        } else {\n+            Err(NoSolution)\n+        };\n+\n+        match result.and_then(|certainty| self.make_canonical_response(certainty)) {\n+            Ok(result) => {\n+                candidates.push(Candidate { source: CandidateSource::BuiltinImpl, result })\n+            }\n+            Err(NoSolution) => (),\n+        }\n+    }\n+\n+    fn assemble_param_env_candidates<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+        candidates: &mut Vec<Candidate<'tcx>>,\n+    ) {\n+        for (i, assumption) in goal.param_env.caller_bounds().iter().enumerate() {\n+            match G::consider_assumption(self, goal, assumption)\n+                .and_then(|certainty| self.make_canonical_response(certainty))\n+            {\n+                Ok(result) => {\n+                    candidates.push(Candidate { source: CandidateSource::ParamEnv(i), result })\n+                }\n+                Err(NoSolution) => (),\n+            }\n+        }\n+    }\n+\n+    fn assemble_alias_bound_candidates<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+        candidates: &mut Vec<Candidate<'tcx>>,\n+    ) {\n+        let alias_ty = match goal.predicate.self_ty().kind() {\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Adt(_, _)\n+            | ty::Foreign(_)\n+            | ty::Str\n+            | ty::Array(_, _)\n+            | ty::Slice(_)\n+            | ty::RawPtr(_)\n+            | ty::Ref(_, _, _)\n+            | ty::FnDef(_, _)\n+            | ty::FnPtr(_)\n+            | ty::Dynamic(..)\n+            | ty::Closure(..)\n+            | ty::Generator(..)\n+            | ty::GeneratorWitness(_)\n+            | ty::Never\n+            | ty::Tuple(_)\n+            | ty::Param(_)\n+            | ty::Placeholder(..)\n+            | ty::Infer(_)\n+            | ty::Error(_) => return,\n+            ty::Bound(..) => bug!(\"unexpected bound type: {goal:?}\"),\n+            ty::Alias(_, alias_ty) => alias_ty,\n+        };\n+\n+        for (i, (assumption, _)) in self\n+            .tcx()\n+            .bound_explicit_item_bounds(alias_ty.def_id)\n+            .subst_iter_copied(self.tcx(), alias_ty.substs)\n+            .enumerate()\n+        {\n+            match G::consider_assumption(self, goal, assumption)\n+                .and_then(|certainty| self.make_canonical_response(certainty))\n+            {\n+                Ok(result) => {\n+                    candidates.push(Candidate { source: CandidateSource::AliasBound(i), result })\n+                }\n+                Err(NoSolution) => (),\n+            }\n+        }\n+    }\n }"}, {"sha": "b086c0684d28d48315afaf67c14da1c53628e8eb", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/660c28391c79bd12e116724a8877a2148630dee5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c28391c79bd12e116724a8877a2148630dee5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=660c28391c79bd12e116724a8877a2148630dee5", "patch": "@@ -2,15 +2,15 @@ use std::mem;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_infer::{\n-    infer::{canonical::OriginalQueryValues, InferCtxt},\n+    infer::InferCtxt,\n     traits::{\n         query::NoSolution, FulfillmentError, FulfillmentErrorCode, PredicateObligation,\n         SelectionError, TraitEngine,\n     },\n };\n use rustc_middle::ty;\n \n-use super::{Certainty, EvalCtxt};\n+use super::{search_graph, Certainty, EvalCtxt};\n \n /// A trait engine using the new trait solver.\n ///\n@@ -68,25 +68,10 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n             let mut has_changed = false;\n             for obligation in mem::take(&mut self.obligations) {\n                 let goal = obligation.clone().into();\n-\n-                // FIXME: Add a better API for that '^^\n-                let mut orig_values = OriginalQueryValues::default();\n-                let canonical_goal = infcx.canonicalize_query(goal, &mut orig_values);\n-                let (changed, certainty) = match EvalCtxt::evaluate_canonical_goal(\n-                    infcx.tcx,\n-                    &mut super::search_graph::SearchGraph::new(infcx.tcx),\n-                    canonical_goal,\n-                ) {\n-                    Ok(canonical_response) => {\n-                        (\n-                            true, // FIXME: check whether `var_values` are an identity substitution.\n-                            super::instantiate_canonical_query_response(\n-                                infcx,\n-                                &orig_values,\n-                                canonical_response,\n-                            ),\n-                        )\n-                    }\n+                let search_graph = &mut search_graph::SearchGraph::new(infcx.tcx);\n+                let mut ecx = EvalCtxt::new_outside_solver(infcx, search_graph);\n+                let (changed, certainty) = match ecx.evaluate_goal(goal) {\n+                    Ok(result) => result,\n                     Err(NoSolution) => {\n                         errors.push(FulfillmentError {\n                             obligation: obligation.clone(),"}, {"sha": "579cd6a2d59cde4d0469ee928b6ea68fb918e782", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/660c28391c79bd12e116724a8877a2148630dee5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c28391c79bd12e116724a8877a2148630dee5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=660c28391c79bd12e116724a8877a2148630dee5", "patch": "@@ -155,6 +155,23 @@ struct EvalCtxt<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    /// Creates a new evaluation context outside of the trait solver.\n+    ///\n+    /// With this solver making a canonical response doesn't make much sense.\n+    /// The `search_graph` for this solver has to be completely empty.\n+    fn new_outside_solver(\n+        infcx: &'a InferCtxt<'tcx>,\n+        search_graph: &'a mut search_graph::SearchGraph<'tcx>,\n+    ) -> EvalCtxt<'a, 'tcx> {\n+        assert!(search_graph.is_empty());\n+        EvalCtxt { infcx, var_values: CanonicalVarValues::dummy(), search_graph }\n+    }\n+\n+    #[instrument(level = \"debug\", skip(tcx, search_graph), ret)]\n     fn evaluate_canonical_goal(\n         tcx: TyCtxt<'tcx>,\n         search_graph: &'a mut search_graph::SearchGraph<'tcx>,\n@@ -183,10 +200,6 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.infcx.tcx\n-    }\n-\n     fn make_canonical_response(&self, certainty: Certainty) -> QueryResult<'tcx> {\n         let external_constraints = take_external_constraints(self.infcx)?;\n "}, {"sha": "92c5d4e53f5302be1408bad440e1b3745b9979d7", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 40, "deletions": 34, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/660c28391c79bd12e116724a8877a2148630dee5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c28391c79bd12e116724a8877a2148630dee5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=660c28391c79bd12e116724a8877a2148630dee5", "patch": "@@ -1,7 +1,7 @@\n use crate::traits::{specialization_graph, translate_substs};\n \n-use super::assembly::{self, AssemblyCtxt};\n-use super::{EvalCtxt, Goal, QueryResult};\n+use super::assembly::{self, Candidate, CandidateSource};\n+use super::{Certainty, EvalCtxt, Goal, QueryResult};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n@@ -16,22 +16,12 @@ use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::DUMMY_SP;\n use std::iter;\n \n-#[allow(dead_code)] // FIXME: implement and use all variants.\n-#[derive(Debug, Clone, Copy)]\n-pub(super) enum CandidateSource {\n-    Impl(DefId),\n-    ParamEnv(usize),\n-    Builtin,\n-}\n-\n-type Candidate<'tcx> = assembly::Candidate<'tcx, ProjectionPredicate<'tcx>>;\n-\n impl<'tcx> EvalCtxt<'_, 'tcx> {\n     pub(super) fn compute_projection_goal(\n         &mut self,\n         goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        let candidates = AssemblyCtxt::assemble_and_evaluate_candidates(self, goal);\n+        let candidates = self.assemble_and_evaluate_candidates(goal);\n         self.merge_project_candidates(candidates)\n     }\n \n@@ -83,14 +73,13 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         match (candidate.source, other.source) {\n             (CandidateSource::Impl(_), _)\n             | (CandidateSource::ParamEnv(_), _)\n-            | (CandidateSource::Builtin, _) => unimplemented!(),\n+            | (CandidateSource::BuiltinImpl, _)\n+            | (CandidateSource::AliasBound(_), _) => unimplemented!(),\n         }\n     }\n }\n \n impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n-    type CandidateSource = CandidateSource;\n-\n     fn self_ty(self) -> Ty<'tcx> {\n         self.self_ty()\n     }\n@@ -104,33 +93,32 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n     }\n \n     fn consider_impl_candidate(\n-        acx: &mut AssemblyCtxt<'_, '_, 'tcx, ProjectionPredicate<'tcx>>,\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n         impl_def_id: DefId,\n-    ) {\n-        let tcx = acx.cx.tcx();\n-        let infcx = acx.cx.infcx;\n+    ) -> Result<Certainty, NoSolution> {\n+        let tcx = ecx.tcx();\n \n         let goal_trait_ref = goal.predicate.projection_ty.trait_ref(tcx);\n         let impl_trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n         if iter::zip(goal_trait_ref.substs, impl_trait_ref.skip_binder().substs)\n             .any(|(goal, imp)| !drcx.generic_args_may_unify(goal, imp))\n         {\n-            return;\n+            return Err(NoSolution);\n         }\n \n-        infcx.probe(|_| {\n-            let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+        ecx.infcx.probe(|_| {\n+            let impl_substs = ecx.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n             let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n \n-            let Ok(InferOk { obligations, .. }) = infcx\n+            let Ok(InferOk { obligations, .. }) = ecx.infcx\n                 .at(&ObligationCause::dummy(), goal.param_env)\n                 .define_opaque_types(false)\n                 .eq(goal_trait_ref, impl_trait_ref)\n                 .map_err(|e| debug!(\"failed to equate trait refs: {e:?}\"))\n             else {\n-                return\n+                return Err(NoSolution)\n             };\n             let where_clause_bounds = tcx\n                 .predicates_of(impl_def_id)\n@@ -141,16 +129,16 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n \n             let nested_goals =\n                 obligations.into_iter().map(|o| o.into()).chain(where_clause_bounds).collect();\n-            let Ok(trait_ref_certainty) = acx.cx.evaluate_all(nested_goals) else { return };\n+            let trait_ref_certainty = ecx.evaluate_all(nested_goals)?;\n \n             let Some(assoc_def) = fetch_eligible_assoc_item_def(\n-                infcx,\n+                ecx.infcx,\n                 goal.param_env,\n                 goal_trait_ref,\n                 goal.predicate.def_id(),\n                 impl_def_id\n             ) else {\n-                return\n+                return Err(NoSolution);\n             };\n \n             if !assoc_def.item.defaultness(tcx).has_value() {\n@@ -176,7 +164,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 impl_substs,\n             );\n             let substs = translate_substs(\n-                infcx,\n+                ecx.infcx,\n                 goal.param_env,\n                 impl_def_id,\n                 impl_substs_with_gat,\n@@ -197,22 +185,40 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 ty.map_bound(|ty| ty.into())\n             };\n \n-            let Ok(InferOk { obligations, .. }) = infcx\n+            let Ok(InferOk { obligations, .. }) = ecx.infcx\n                 .at(&ObligationCause::dummy(), goal.param_env)\n                 .define_opaque_types(false)\n                 .eq(goal.predicate.term,  term.subst(tcx, substs))\n                 .map_err(|e| debug!(\"failed to equate trait refs: {e:?}\"))\n             else {\n-                return\n+                return Err(NoSolution);\n             };\n \n             let nested_goals = obligations.into_iter().map(|o| o.into()).collect();\n-            let Ok(rhs_certainty) = acx.cx.evaluate_all(nested_goals) else { return };\n+            let rhs_certainty = ecx.evaluate_all(nested_goals)?;\n \n-            let certainty = trait_ref_certainty.unify_and(rhs_certainty);\n-            acx.try_insert_candidate(CandidateSource::Impl(impl_def_id), certainty);\n+            Ok(trait_ref_certainty.unify_and(rhs_certainty))\n         })\n     }\n+\n+    fn consider_builtin_sized_candidate(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> Result<Certainty, NoSolution> {\n+        bug!(\"`Sized` does not have an associated type: {:?}\", goal);\n+    }\n+\n+    fn consider_assumption(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        _goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+    ) -> Result<Certainty, NoSolution> {\n+        if let Some(_poly_projection_pred) = assumption.to_opt_poly_projection_pred() {\n+            unimplemented!()\n+        } else {\n+            Err(NoSolution)\n+        }\n+    }\n }\n \n /// This behavior is also implemented in `rustc_ty_utils` and in the old `project` code."}, {"sha": "cb00fe6bf14af167bce9abbf2f90ca5b4de12af1", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/cache.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/660c28391c79bd12e116724a8877a2148630dee5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c28391c79bd12e116724a8877a2148630dee5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs?ref=660c28391c79bd12e116724a8877a2148630dee5", "patch": "@@ -52,6 +52,10 @@ impl<'tcx> ProvisionalCache<'tcx> {\n         ProvisionalCache { entries: Default::default(), lookup_table: Default::default() }\n     }\n \n+    pub(super) fn is_empty(&self) -> bool {\n+        self.entries.is_empty() && self.lookup_table.is_empty()\n+    }\n+\n     /// Adds a dependency from the current leaf to `target` in the cache\n     /// to prevent us from moving any goals which depend on the current leaf\n     /// to the global cache while we're still computing `target`."}, {"sha": "4f48389410bfac28654b97a0e0ee5250f152b9ee", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/660c28391c79bd12e116724a8877a2148630dee5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c28391c79bd12e116724a8877a2148630dee5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs?ref=660c28391c79bd12e116724a8877a2148630dee5", "patch": "@@ -36,6 +36,12 @@ impl<'tcx> SearchGraph<'tcx> {\n         }\n     }\n \n+    pub(super) fn is_empty(&self) -> bool {\n+        self.stack.is_empty()\n+            && self.provisional_cache.is_empty()\n+            && !self.overflow_data.did_overflow()\n+    }\n+\n     /// Tries putting the new goal on the stack, returning an error if it is already cached.\n     ///\n     /// This correctly updates the provisional cache if there is a cycle."}, {"sha": "3c8314aa565ee12616eac0a00ff070847394bfe7", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 32, "deletions": 56, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/660c28391c79bd12e116724a8877a2148630dee5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c28391c79bd12e116724a8877a2148630dee5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=660c28391c79bd12e116724a8877a2148630dee5", "patch": "@@ -2,8 +2,8 @@\n \n use std::iter;\n \n-use super::assembly::{self, AssemblyCtxt};\n-use super::{EvalCtxt, Goal, QueryResult};\n+use super::assembly::{self, Candidate, CandidateSource};\n+use super::{Certainty, EvalCtxt, Goal, QueryResult};\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::InferOk;\n use rustc_infer::traits::query::NoSolution;\n@@ -13,47 +13,7 @@ use rustc_middle::ty::TraitPredicate;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::DUMMY_SP;\n \n-#[allow(dead_code)] // FIXME: implement and use all variants.\n-#[derive(Debug, Clone, Copy)]\n-pub(super) enum CandidateSource {\n-    /// Some user-defined impl with the given `DefId`.\n-    Impl(DefId),\n-    /// The n-th caller bound in the `param_env` of our goal.\n-    ///\n-    /// This is pretty much always a bound from the `where`-clauses of the\n-    /// currently checked item.\n-    ParamEnv(usize),\n-    /// A bound on the `self_ty` in case it is a projection or an opaque type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore (for syntax highlighting)\n-    /// trait Trait {\n-    ///     type Assoc: OtherTrait;\n-    /// }\n-    /// ```\n-    ///\n-    /// We know that `<Whatever as Trait>::Assoc: OtherTrait` holds by looking at\n-    /// the bounds on `Trait::Assoc`.\n-    AliasBound(usize),\n-    /// A builtin implementation for some specific traits, used in cases\n-    /// where we cannot rely an ordinary library implementations.\n-    ///\n-    /// The most notable examples are `Sized`, `Copy` and `Clone`. This is also\n-    /// used for the `DiscriminantKind` and `Pointee` trait, both of which have\n-    /// an associated type.\n-    Builtin,\n-    /// An automatic impl for an auto trait, e.g. `Send`. These impls recursively look\n-    /// at the constituent types of the `self_ty` to check whether the auto trait\n-    /// is implemented for those.\n-    AutoImpl,\n-}\n-\n-type Candidate<'tcx> = assembly::Candidate<'tcx, TraitPredicate<'tcx>>;\n-\n impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n-    type CandidateSource = CandidateSource;\n-\n     fn self_ty(self) -> Ty<'tcx> {\n         self.self_ty()\n     }\n@@ -67,32 +27,31 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n     }\n \n     fn consider_impl_candidate(\n-        acx: &mut AssemblyCtxt<'_, '_, 'tcx, Self>,\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, TraitPredicate<'tcx>>,\n         impl_def_id: DefId,\n-    ) {\n-        let tcx = acx.cx.tcx();\n-        let infcx = acx.cx.infcx;\n+    ) -> Result<Certainty, NoSolution> {\n+        let tcx = ecx.tcx();\n \n         let impl_trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n         if iter::zip(goal.predicate.trait_ref.substs, impl_trait_ref.skip_binder().substs)\n             .any(|(goal, imp)| !drcx.generic_args_may_unify(goal, imp))\n         {\n-            return;\n+            return Err(NoSolution);\n         }\n \n-        infcx.probe(|_| {\n-            let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+        ecx.infcx.probe(|_| {\n+            let impl_substs = ecx.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n             let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n \n-            let Ok(InferOk { obligations, .. }) = infcx\n+            let Ok(InferOk { obligations, .. }) = ecx.infcx\n                 .at(&ObligationCause::dummy(), goal.param_env)\n                 .define_opaque_types(false)\n                 .eq(goal.predicate.trait_ref, impl_trait_ref)\n                 .map_err(|e| debug!(\"failed to equate trait refs: {e:?}\"))\n             else {\n-                return\n+                return Err(NoSolution);\n             };\n             let where_clause_bounds = tcx\n                 .predicates_of(impl_def_id)\n@@ -104,18 +63,36 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             let nested_goals =\n                 obligations.into_iter().map(|o| o.into()).chain(where_clause_bounds).collect();\n \n-            let Ok(certainty) = acx.cx.evaluate_all(nested_goals) else { return };\n-            acx.try_insert_candidate(CandidateSource::Impl(impl_def_id), certainty);\n+            ecx.evaluate_all(nested_goals)\n         })\n     }\n+\n+    fn consider_builtin_sized_candidate(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        _goal: Goal<'tcx, Self>,\n+    ) -> Result<Certainty, NoSolution> {\n+        unimplemented!();\n+    }\n+\n+    fn consider_assumption(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        _goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+    ) -> Result<Certainty, NoSolution> {\n+        if let Some(_poly_trait_pred) = assumption.to_opt_poly_trait_pred() {\n+            unimplemented!()\n+        } else {\n+            Err(NoSolution)\n+        }\n+    }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n     pub(super) fn compute_trait_goal(\n         &mut self,\n         goal: Goal<'tcx, TraitPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        let candidates = AssemblyCtxt::assemble_and_evaluate_candidates(self, goal);\n+        let candidates = self.assemble_and_evaluate_candidates(goal);\n         self.merge_trait_candidates_discard_reservation_impls(candidates)\n     }\n \n@@ -169,8 +146,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             (CandidateSource::Impl(_), _)\n             | (CandidateSource::ParamEnv(_), _)\n             | (CandidateSource::AliasBound(_), _)\n-            | (CandidateSource::Builtin, _)\n-            | (CandidateSource::AutoImpl, _) => unimplemented!(),\n+            | (CandidateSource::BuiltinImpl, _) => unimplemented!(),\n         }\n     }\n "}]}