{"sha": "798b9ff9d5b74a2f78e81cb3a2528a477f425d9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5OGI5ZmY5ZDViNzRhMmY3OGU4MWNiM2EyNTI4YTQ3N2Y0MjVkOWU=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-19T22:10:18Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-19T22:10:18Z"}, "message": "Tweak comments", "tree": {"sha": "2e82cf18fa250cb230b4f49d621cf01a78c883f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e82cf18fa250cb230b4f49d621cf01a78c883f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/798b9ff9d5b74a2f78e81cb3a2528a477f425d9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/798b9ff9d5b74a2f78e81cb3a2528a477f425d9e", "html_url": "https://github.com/rust-lang/rust/commit/798b9ff9d5b74a2f78e81cb3a2528a477f425d9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/798b9ff9d5b74a2f78e81cb3a2528a477f425d9e/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0383539deddb37c87c3d7babe8c44a19669bbfba", "url": "https://api.github.com/repos/rust-lang/rust/commits/0383539deddb37c87c3d7babe8c44a19669bbfba", "html_url": "https://github.com/rust-lang/rust/commit/0383539deddb37c87c3d7babe8c44a19669bbfba"}], "stats": {"total": 87, "additions": 49, "deletions": 38}, "files": [{"sha": "87ae9648af65b3a0354fe890e9822d667c800674", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 49, "deletions": 38, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/798b9ff9d5b74a2f78e81cb3a2528a477f425d9e/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/798b9ff9d5b74a2f78e81cb3a2528a477f425d9e/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=798b9ff9d5b74a2f78e81cb3a2528a477f425d9e", "patch": "@@ -62,7 +62,7 @@\n ///        The specialisation of a row vector is computed by `specialize`.\n ///\n ///        It is computed as follows. For each row `p_i` of P, we have four cases:\n-///             1.1. `p_(i,1)= c(r_1, .., r_a)`. Then `S(c, P)` has a corresponding row:\n+///             1.1. `p_(i,1) = c(r_1, .., r_a)`. Then `S(c, P)` has a corresponding row:\n ///                     r_1, .., r_a, p_(i,2), .., p_(i,n)\n ///             1.2. `p_(i,1) = c'(r_1, .., r_a')` where `c \u2260 c'`. Then `S(c, P)` has no\n ///                  corresponding row.\n@@ -85,6 +85,9 @@\n ///                     D((r_1, p_(i,2), .., p_(i,n)))\n ///                     D((r_2, p_(i,2), .., p_(i,n)))\n ///\n+///     Note that the OR-patterns are not always used directly in Rust, but are used to derive\n+///     the exhaustive integer matching rules, so they're written here for posterity.\n+///\n /// The algorithm for computing `U`\n /// -------------------------------\n /// The algorithm is inductive (on the number of columns: i.e. components of tuple patterns).\n@@ -97,7 +100,8 @@\n ///       then `U(P, p_{m + 1})` is false.\n ///     - Otherwise, `P` must be empty, so `U(P, p_{m + 1})` is true.\n ///\n-/// Inductive step. (`n > 0`, i.e. 1 or more tuple pattern components)\n+/// Inductive step. (`n > 0`, i.e. whether there's at least one column\n+///                  [which may then be expanded into further columns later])\n ///     We're going to match on the new pattern, `p_{m + 1}`.\n ///         - If `p_{m + 1} == c(r_1, .., r_a)`, then we have a constructor pattern.\n ///           Thus, the usefulness of `p_{m + 1}` can be reduced to whether it is useful when\n@@ -926,6 +930,46 @@ impl<'tcx> IntRange<'tcx> {\n     }\n }\n \n+// Find those constructors that are not matched by any non-wildcard patterns in the current column.\n+fn compute_missing_ctors<'a, 'tcx: 'a>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    all_ctors: &Vec<Constructor<'tcx>>,\n+    used_ctors: &Vec<Constructor<'tcx>>,\n+) -> Vec<Constructor<'tcx>> {\n+    let mut missing_ctors = vec![];\n+\n+    for req_ctor in all_ctors {\n+        let mut refined_ctors = vec![req_ctor.clone()];\n+        for used_ctor in used_ctors {\n+            if used_ctor == req_ctor {\n+                // If a constructor appears in a `match` arm, we can\n+                // eliminate it straight away.\n+                refined_ctors = vec![]\n+            } else if tcx.features().exhaustive_integer_patterns {\n+                if let Some(interval) = IntRange::from_ctor(tcx, used_ctor) {\n+                    // Refine the required constructors for the type by subtracting\n+                    // the range defined by the current constructor pattern.\n+                    refined_ctors = interval.subtract_from(tcx, refined_ctors);\n+                }\n+            }\n+\n+            // If the constructor patterns that have been considered so far\n+            // already cover the entire range of values, then we the\n+            // constructor is not missing, and we can move on to the next one.\n+            if refined_ctors.is_empty() {\n+                break;\n+            }\n+        }\n+        // If a constructor has not been matched, then it is missing.\n+        // We add `refined_ctors` instead of `req_ctor`, because then we can\n+        // provide more detailed error information about precisely which\n+        // ranges have been omitted.\n+        missing_ctors.extend(refined_ctors);\n+    }\n+\n+    missing_ctors\n+}\n+\n /// Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html\n /// The algorithm from the paper has been modified to correctly handle empty\n /// types. The changes are:\n@@ -1017,38 +1061,6 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         let all_ctors = all_constructors(cx, pcx);\n         debug!(\"all_ctors = {:#?}\", all_ctors);\n \n-        // `missing_ctors` are those that should have appeared\n-        // as patterns in the `match` expression, but did not.\n-        let mut missing_ctors = vec![];\n-        for req_ctor in &all_ctors {\n-            let mut refined_ctors = vec![req_ctor.clone()];\n-            for used_ctor in &used_ctors {\n-                if used_ctor == req_ctor {\n-                    // If a constructor appears in a `match` arm, we can\n-                    // eliminate it straight away.\n-                    refined_ctors = vec![]\n-                } else if cx.tcx.features().exhaustive_integer_patterns {\n-                    if let Some(interval) = IntRange::from_ctor(cx.tcx, used_ctor) {\n-                        // Refine the required constructors for the type by subtracting\n-                        // the range defined by the current constructor pattern.\n-                        refined_ctors = interval.subtract_from(cx.tcx, refined_ctors);\n-                    }\n-                }\n-\n-                // If the constructor patterns that have been considered so far\n-                // already cover the entire range of values, then we the\n-                // constructor is not missing, and we can move on to the next one.\n-                if refined_ctors.is_empty() {\n-                    break;\n-                }\n-            }\n-            // If a constructor has not been matched, then it is missing.\n-            // We add `refined_ctors` instead of `req_ctor`, because then we can\n-            // provide more detailed error information about precisely which\n-            // ranges have been omitted.\n-            missing_ctors.extend(refined_ctors);\n-        }\n-\n         // `missing_ctors` is the set of constructors from the same type as the\n         // first column of `matrix` that are matched only by wildcard patterns\n         // from the first column.\n@@ -1067,11 +1079,10 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         // be a privately-empty enum is when the exhaustive_patterns\n         // feature flag is not present, so this is only\n         // needed for that case.\n+        let missing_ctors = compute_missing_ctors(cx.tcx, &all_ctors, &used_ctors);\n \n-        let is_privately_empty =\n-            all_ctors.is_empty() && !cx.is_uninhabited(pcx.ty);\n-        let is_declared_nonexhaustive =\n-            cx.is_non_exhaustive_enum(pcx.ty) && !cx.is_local(pcx.ty);\n+        let is_privately_empty = all_ctors.is_empty() && !cx.is_uninhabited(pcx.ty);\n+        let is_declared_nonexhaustive = cx.is_non_exhaustive_enum(pcx.ty) && !cx.is_local(pcx.ty);\n         debug!(\"missing_ctors={:#?} is_privately_empty={:#?} is_declared_nonexhaustive={:#?}\",\n                missing_ctors, is_privately_empty, is_declared_nonexhaustive);\n "}]}