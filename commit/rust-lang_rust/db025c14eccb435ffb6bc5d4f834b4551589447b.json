{"sha": "db025c14eccb435ffb6bc5d4f834b4551589447b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiMDI1YzE0ZWNjYjQzNWZmYjZiYzVkNGY4MzRiNDU1MTU4OTQ0N2I=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2018-06-22T00:31:09Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2018-07-04T21:36:07Z"}, "message": "Refactor EvalContext stack and heap into inner struct\n\nChange surrounding code to use accessor methods to refer to these fields.\nSimilar changes have not yet been made in tools/miri", "tree": {"sha": "1dbd33e4a01c30d9b8b50aa1805a65c418a51817", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1dbd33e4a01c30d9b8b50aa1805a65c418a51817"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db025c14eccb435ffb6bc5d4f834b4551589447b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db025c14eccb435ffb6bc5d4f834b4551589447b", "html_url": "https://github.com/rust-lang/rust/commit/db025c14eccb435ffb6bc5d4f834b4551589447b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db025c14eccb435ffb6bc5d4f834b4551589447b/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ad8f9e5b1950e4ac09950def4231c8d5875de57", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ad8f9e5b1950e4ac09950def4231c8d5875de57", "html_url": "https://github.com/rust-lang/rust/commit/0ad8f9e5b1950e4ac09950def4231c8d5875de57"}], "stats": {"total": 208, "additions": 110, "deletions": 98}, "files": [{"sha": "4bf40091153534fb78505f147dd40e7987518a31", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db025c14eccb435ffb6bc5d4f834b4551589447b/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db025c14eccb435ffb6bc5d4f834b4551589447b/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=db025c14eccb435ffb6bc5d4f834b4551589447b", "patch": "@@ -76,8 +76,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             // No alignment check needed for raw pointers.  But we have to truncate to target ptr size.\n             TyRawPtr(_) => {\n                 Ok(Scalar::Bits {\n-                    bits: self.memory.truncate_to_ptr(v).0 as u128,\n-                    defined: self.memory.pointer_size().bits() as u8,\n+                    bits: self.memory().truncate_to_ptr(v).0 as u128,\n+                    defined: self.memory().pointer_size().bits() as u8,\n                 })\n             },\n \n@@ -92,7 +92,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         match dest_ty.sty {\n             // float -> uint\n             TyUint(t) => {\n-                let width = t.bit_width().unwrap_or(self.memory.pointer_size().bits() as usize);\n+                let width = t.bit_width().unwrap_or(self.memory().pointer_size().bits() as usize);\n                 match fty {\n                     FloatTy::F32 => Ok(Scalar::Bits {\n                         bits: Single::from_bits(bits).to_u128(width).value,\n@@ -106,7 +106,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             },\n             // float -> int\n             TyInt(t) => {\n-                let width = t.bit_width().unwrap_or(self.memory.pointer_size().bits() as usize);\n+                let width = t.bit_width().unwrap_or(self.memory().pointer_size().bits() as usize);\n                 match fty {\n                     FloatTy::F32 => Ok(Scalar::Bits {\n                         bits: Single::from_bits(bits).to_i128(width).value as u128,"}, {"sha": "fe2c46aa48fd86daff59735697f1d7c87c78097f", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/db025c14eccb435ffb6bc5d4f834b4551589447b/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db025c14eccb435ffb6bc5d4f834b4551589447b/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=db025c14eccb435ffb6bc5d4f834b4551589447b", "patch": "@@ -88,7 +88,7 @@ pub fn value_to_const_value<'tcx>(\n             Value::ScalarPair(a, b) => Ok(ConstValue::ScalarPair(a, b)),\n             Value::ByRef(ptr, align) => {\n                 let ptr = ptr.to_ptr().unwrap();\n-                let alloc = ecx.memory.get(ptr.alloc_id)?;\n+                let alloc = ecx.memory().get(ptr.alloc_id)?;\n                 assert!(alloc.align.abi() >= align.abi());\n                 assert!(alloc.bytes.len() as u64 - ptr.offset.bytes() >= layout.size.bytes());\n                 let mut alloc = alloc.clone();\n@@ -149,7 +149,7 @@ fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n     }\n     let layout = ecx.layout_of(mir.return_ty().subst(tcx, cid.instance.substs))?;\n     assert!(!layout.is_unsized());\n-    let ptr = ecx.memory.allocate(\n+    let ptr = ecx.memory_mut().allocate(\n         layout.size,\n         layout.align,\n         MemoryKind::Stack,\n@@ -486,7 +486,7 @@ pub fn const_variant_index<'a, 'tcx>(\n     let (ptr, align) = match value {\n         Value::ScalarPair(..) | Value::Scalar(_) => {\n             let layout = ecx.layout_of(val.ty)?;\n-            let ptr = ecx.memory.allocate(layout.size, layout.align, MemoryKind::Stack)?.into();\n+            let ptr = ecx.memory_mut().allocate(layout.size, layout.align, MemoryKind::Stack)?.into();\n             ecx.write_value_to_ptr(value, ptr, layout.align, val.ty)?;\n             (ptr, layout.align)\n         },\n@@ -515,9 +515,9 @@ pub fn const_value_to_allocation_provider<'a, 'tcx>(\n             ());\n         let value = ecx.const_to_value(val.val)?;\n         let layout = ecx.layout_of(val.ty)?;\n-        let ptr = ecx.memory.allocate(layout.size, layout.align, MemoryKind::Stack)?;\n+        let ptr = ecx.memory_mut().allocate(layout.size, layout.align, MemoryKind::Stack)?;\n         ecx.write_value_to_ptr(value, ptr.into(), layout.align, val.ty)?;\n-        let alloc = ecx.memory.get(ptr.alloc_id)?;\n+        let alloc = ecx.memory().get(ptr.alloc_id)?;\n         Ok(tcx.intern_const_alloc(alloc.clone()))\n     };\n     result().expect(\"unable to convert ConstValue to Allocation\")"}, {"sha": "fe95b9319f3203d0bb05c39009d41a59b9ce7817", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 75, "deletions": 63, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/db025c14eccb435ffb6bc5d4f834b4551589447b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db025c14eccb435ffb6bc5d4f834b4551589447b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=db025c14eccb435ffb6bc5d4f834b4551589447b", "patch": "@@ -32,11 +32,8 @@ pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// Bounds in scope for polymorphic evaluations.\n     pub param_env: ty::ParamEnv<'tcx>,\n \n-    /// The virtual memory system.\n-    pub memory: Memory<'a, 'mir, 'tcx, M>,\n-\n-    /// The virtual call stack.\n-    pub(crate) stack: Vec<Frame<'mir, 'tcx>>,\n+    /// Virtual memory and call stack.\n+    state: EvalState<'a, 'mir, 'tcx, M>,\n \n     /// The maximum number of stack frames allowed\n     pub(crate) stack_limit: usize,\n@@ -47,6 +44,14 @@ pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     pub(crate) terminators_remaining: usize,\n }\n \n+struct EvalState<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n+    /// The virtual memory system.\n+    memory: Memory<'a, 'mir, 'tcx, M>,\n+\n+    /// The virtual call stack.\n+    stack: Vec<Frame<'mir, 'tcx>>,\n+}\n+\n /// A stack frame.\n pub struct Frame<'mir, 'tcx: 'mir> {\n     ////////////////////////////////////////////////////////////////////////////////\n@@ -186,18 +191,20 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             machine,\n             tcx,\n             param_env,\n-            memory: Memory::new(tcx, memory_data),\n-            stack: Vec::new(),\n+            state: EvalState {\n+                memory: Memory::new(tcx, memory_data),\n+                stack: Vec::new(),\n+            },\n             stack_limit: tcx.sess.const_eval_stack_frame_limit,\n             terminators_remaining: MAX_TERMINATORS,\n         }\n     }\n \n     pub(crate) fn with_fresh_body<F: FnOnce(&mut Self) -> R, R>(&mut self, f: F) -> R {\n-        let stack = mem::replace(&mut self.stack, Vec::new());\n+        let stack = mem::replace(self.stack_mut(), Vec::new());\n         let terminators_remaining = mem::replace(&mut self.terminators_remaining, MAX_TERMINATORS);\n         let r = f(self);\n-        self.stack = stack;\n+        *self.stack_mut() = stack;\n         self.terminators_remaining = terminators_remaining;\n         r\n     }\n@@ -206,29 +213,34 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         let layout = self.layout_of(ty)?;\n         assert!(!layout.is_unsized(), \"cannot alloc memory for unsized type\");\n \n-        self.memory.allocate(layout.size, layout.align, MemoryKind::Stack)\n+        self.memory_mut().allocate(layout.size, layout.align, MemoryKind::Stack)\n     }\n \n     pub fn memory(&self) -> &Memory<'a, 'mir, 'tcx, M> {\n-        &self.memory\n+        &self.state.memory\n     }\n \n     pub fn memory_mut(&mut self) -> &mut Memory<'a, 'mir, 'tcx, M> {\n-        &mut self.memory\n+        &mut self.state.memory\n     }\n \n+    #[inline]\n     pub fn stack(&self) -> &[Frame<'mir, 'tcx>] {\n-        &self.stack\n+        &self.state.stack\n+    }\n+\n+    pub fn stack_mut(&mut self) -> &mut Vec<Frame<'mir, 'tcx>> {\n+        &mut self.state.stack\n     }\n \n     #[inline]\n     pub fn cur_frame(&self) -> usize {\n-        assert!(self.stack.len() > 0);\n-        self.stack.len() - 1\n+        assert!(self.stack().len() > 0);\n+        self.stack().len() - 1\n     }\n \n     pub fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value> {\n-        let ptr = self.memory.allocate_bytes(s.as_bytes());\n+        let ptr = self.memory_mut().allocate_bytes(s.as_bytes());\n         Ok(Scalar::Ptr(ptr).to_value_with_len(s.len() as u64, self.tcx.tcx))\n     }\n \n@@ -246,7 +258,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             }\n             ConstValue::ByRef(alloc, offset) => {\n                 // FIXME: Allocate new AllocId for all constants inside\n-                let id = self.memory.allocate_value(alloc.clone(), MemoryKind::Stack)?;\n+                let id = self.memory_mut().allocate_value(alloc.clone(), MemoryKind::Stack)?;\n                 Ok(Value::ByRef(Pointer::new(id, offset).into(), alloc.align))\n             },\n             ConstValue::ScalarPair(a, b) => Ok(Value::ScalarPair(a, b)),\n@@ -417,7 +429,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             IndexVec::new()\n         };\n \n-        self.stack.push(Frame {\n+        self.stack_mut().push(Frame {\n             mir,\n             block: mir::START_BLOCK,\n             return_to_block,\n@@ -428,9 +440,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             stmt: 0,\n         });\n \n-        self.memory.cur_frame = self.cur_frame();\n+        self.memory_mut().cur_frame = self.cur_frame();\n \n-        if self.stack.len() > self.stack_limit {\n+        if self.stack().len() > self.stack_limit {\n             err!(StackFrameLimitReached)\n         } else {\n             Ok(())\n@@ -440,18 +452,18 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     pub(super) fn pop_stack_frame(&mut self) -> EvalResult<'tcx> {\n         ::log_settings::settings().indentation -= 1;\n         M::end_region(self, None)?;\n-        let frame = self.stack.pop().expect(\n+        let frame = self.stack_mut().pop().expect(\n             \"tried to pop a stack frame, but there were none\",\n         );\n-        if !self.stack.is_empty() {\n+        if !self.stack().is_empty() {\n             // TODO: Is this the correct time to start considering these accesses as originating from the returned-to stack frame?\n-            self.memory.cur_frame = self.cur_frame();\n+            self.memory_mut().cur_frame = self.cur_frame();\n         }\n         match frame.return_to_block {\n             StackPopCleanup::MarkStatic(mutable) => {\n                 if let Place::Ptr { ptr, .. } = frame.return_place {\n                     // FIXME: to_ptr()? might be too extreme here, static zsts might reach this under certain conditions\n-                    self.memory.mark_static_initialized(\n+                    self.memory_mut().mark_static_initialized(\n                         ptr.to_ptr()?.alloc_id,\n                         mutable,\n                     )?\n@@ -474,8 +486,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         if let Some(Value::ByRef(ptr, _align)) = local {\n             trace!(\"deallocating local\");\n             let ptr = ptr.to_ptr()?;\n-            self.memory.dump_alloc(ptr.alloc_id);\n-            self.memory.deallocate_local(ptr)?;\n+            self.memory().dump_alloc(ptr.alloc_id);\n+            self.memory_mut().deallocate_local(ptr)?;\n         };\n         Ok(())\n     }\n@@ -595,7 +607,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let src = self.eval_place(place)?;\n                 let ty = self.place_ty(place);\n                 let (_, len) = src.elem_ty_and_len(ty, self.tcx.tcx);\n-                let defined = self.memory.pointer_size().bits() as u8;\n+                let defined = self.memory().pointer_size().bits() as u8;\n                 self.write_scalar(\n                     dest,\n                     Scalar::Bits {\n@@ -637,7 +649,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let layout = self.layout_of(ty)?;\n                 assert!(!layout.is_unsized(),\n                         \"SizeOf nullary MIR operator called for unsized type\");\n-                let defined = self.memory.pointer_size().bits() as u8;\n+                let defined = self.memory().pointer_size().bits() as u8;\n                 self.write_scalar(\n                     dest,\n                     Scalar::Bits {\n@@ -732,7 +744,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                                     def_id,\n                                     substs,\n                                 ).ok_or_else(|| EvalErrorKind::TooGeneric.into());\n-                                let fn_ptr = self.memory.create_fn_alloc(instance?);\n+                                let fn_ptr = self.memory_mut().create_fn_alloc(instance?);\n                                 let valty = ValTy {\n                                     value: Value::Scalar(fn_ptr.into()),\n                                     ty: dest_ty,\n@@ -768,7 +780,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                                     substs,\n                                     ty::ClosureKind::FnOnce,\n                                 );\n-                                let fn_ptr = self.memory.create_fn_alloc(instance);\n+                                let fn_ptr = self.memory_mut().create_fn_alloc(instance);\n                                 let valty = ValTy {\n                                     value: Value::Scalar(fn_ptr.into()),\n                                     ty: dest_ty,\n@@ -1045,7 +1057,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     pub fn force_allocation(&mut self, place: Place) -> EvalResult<'tcx, Place> {\n         let new_place = match place {\n             Place::Local { frame, local } => {\n-                match self.stack[frame].locals[local] {\n+                match self.stack()[frame].locals[local] {\n                     None => return err!(DeadLocal),\n                     Some(Value::ByRef(ptr, align)) => {\n                         Place::Ptr {\n@@ -1055,11 +1067,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                         }\n                     }\n                     Some(val) => {\n-                        let ty = self.stack[frame].mir.local_decls[local].ty;\n-                        let ty = self.monomorphize(ty, self.stack[frame].instance.substs);\n+                        let ty = self.stack()[frame].mir.local_decls[local].ty;\n+                        let ty = self.monomorphize(ty, self.stack()[frame].instance.substs);\n                         let layout = self.layout_of(ty)?;\n                         let ptr = self.alloc_ptr(ty)?;\n-                        self.stack[frame].locals[local] =\n+                        self.stack_mut()[frame].locals[local] =\n                             Some(Value::ByRef(ptr.into(), layout.align)); // it stays live\n                         let place = Place::from_ptr(ptr, layout.align);\n                         self.write_value(ValTy { value: val, ty }, place)?;\n@@ -1141,10 +1153,10 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             }\n \n             Place::Local { frame, local } => {\n-                let dest = self.stack[frame].get_local(local)?;\n+                let dest = self.stack()[frame].get_local(local)?;\n                 self.write_value_possibly_by_val(\n                     src_val,\n-                    |this, val| this.stack[frame].set_local(local, val),\n+                    |this, val| this.stack_mut()[frame].set_local(local, val),\n                     dest,\n                     dest_ty,\n                 )\n@@ -1186,7 +1198,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             } else {\n                 let dest_ptr = self.alloc_ptr(dest_ty)?.into();\n                 let layout = self.layout_of(dest_ty)?;\n-                self.memory.copy(src_ptr, align.min(layout.align), dest_ptr, layout.align, layout.size, false)?;\n+                self.memory_mut().copy(src_ptr, align.min(layout.align), dest_ptr, layout.align, layout.size, false)?;\n                 write_dest(self, Value::ByRef(dest_ptr, layout.align))?;\n             }\n         } else {\n@@ -1208,7 +1220,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         trace!(\"write_value_to_ptr: {:#?}, {}, {:#?}\", value, dest_ty, layout);\n         match value {\n             Value::ByRef(ptr, align) => {\n-                self.memory.copy(ptr, align.min(layout.align), dest, dest_align.min(layout.align), layout.size, false)\n+                self.memory_mut().copy(ptr, align.min(layout.align), dest, dest_align.min(layout.align), layout.size, false)\n             }\n             Value::Scalar(scalar) => {\n                 let signed = match layout.abi {\n@@ -1221,7 +1233,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                         _ => bug!(\"write_value_to_ptr: invalid ByVal layout: {:#?}\", layout),\n                     }\n                 };\n-                self.memory.write_scalar(dest, dest_align, scalar, layout.size, signed)\n+                self.memory_mut().write_scalar(dest, dest_align, scalar, layout.size, signed)\n             }\n             Value::ScalarPair(a_val, b_val) => {\n                 trace!(\"write_value_to_ptr valpair: {:#?}\", layout);\n@@ -1234,8 +1246,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let b_offset = a_size.abi_align(b.align(&self));\n                 let b_ptr = dest.ptr_offset(b_offset, &self)?.into();\n                 // TODO: What about signedess?\n-                self.memory.write_scalar(a_ptr, dest_align, a_val, a_size, false)?;\n-                self.memory.write_scalar(b_ptr, dest_align, b_val, b_size, false)\n+                self.memory_mut().write_scalar(a_ptr, dest_align, a_val, a_size, false)?;\n+                self.memory_mut().write_scalar(b_ptr, dest_align, b_val, b_size, false)\n             }\n         }\n     }\n@@ -1266,20 +1278,20 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         ptr_align: Align,\n         pointee_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, Value> {\n-        let ptr_size = self.memory.pointer_size();\n-        let p: Scalar = self.memory.read_ptr_sized(ptr, ptr_align)?.into();\n+        let ptr_size = self.memory().pointer_size();\n+        let p: Scalar = self.memory().read_ptr_sized(ptr, ptr_align)?.into();\n         if self.type_is_sized(pointee_ty) {\n             Ok(p.to_value())\n         } else {\n             trace!(\"reading fat pointer extra of type {}\", pointee_ty);\n             let extra = ptr.offset(ptr_size, self)?;\n             match self.tcx.struct_tail(pointee_ty).sty {\n                 ty::TyDynamic(..) => Ok(p.to_value_with_vtable(\n-                    self.memory.read_ptr_sized(extra, ptr_align)?.to_ptr()?,\n+                    self.memory().read_ptr_sized(extra, ptr_align)?.to_ptr()?,\n                 )),\n                 ty::TySlice(..) | ty::TyStr => {\n                     let len = self\n-                        .memory\n+                        .memory()\n                         .read_ptr_sized(extra, ptr_align)?\n                         .to_bits(ptr_size)?;\n                     Ok(p.to_value_with_len(len as u64, self.tcx.tcx))\n@@ -1297,18 +1309,18 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     ) -> EvalResult<'tcx> {\n         match ty.sty {\n             ty::TyBool => {\n-                self.memory.read_scalar(ptr, ptr_align, Size::from_bytes(1))?.to_bool()?;\n+                self.memory().read_scalar(ptr, ptr_align, Size::from_bytes(1))?.to_bool()?;\n             }\n             ty::TyChar => {\n-                let c = self.memory.read_scalar(ptr, ptr_align, Size::from_bytes(4))?.to_bits(Size::from_bytes(4))? as u32;\n+                let c = self.memory().read_scalar(ptr, ptr_align, Size::from_bytes(4))?.to_bits(Size::from_bytes(4))? as u32;\n                 match ::std::char::from_u32(c) {\n                     Some(..) => (),\n                     None => return err!(InvalidChar(c as u128)),\n                 }\n             }\n \n             ty::TyFnPtr(_) => {\n-                self.memory.read_ptr_sized(ptr, ptr_align)?;\n+                self.memory().read_ptr_sized(ptr, ptr_align)?;\n             },\n             ty::TyRef(_, rty, _) |\n             ty::TyRawPtr(ty::TypeAndMut { ty: rty, .. }) => {\n@@ -1323,7 +1335,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n                 if let layout::Abi::Scalar(ref scalar) = self.layout_of(ty)?.abi {\n                     let size = scalar.value.size(self);\n-                    self.memory.read_scalar(ptr, ptr_align, size)?;\n+                    self.memory().read_scalar(ptr, ptr_align, size)?;\n                 }\n             }\n \n@@ -1344,7 +1356,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n     pub fn try_read_value(&self, ptr: Scalar, ptr_align: Align, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n         let layout = self.layout_of(ty)?;\n-        self.memory.check_align(ptr, ptr_align)?;\n+        self.memory().check_align(ptr, ptr_align)?;\n \n         if layout.size.bytes() == 0 {\n             return Ok(Some(Value::Scalar(Scalar::undef())));\n@@ -1357,7 +1369,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n         match layout.abi {\n             layout::Abi::Scalar(..) => {\n-                let scalar = self.memory.read_scalar(ptr, ptr_align, layout.size)?;\n+                let scalar = self.memory().read_scalar(ptr, ptr_align, layout.size)?;\n                 Ok(Some(Value::Scalar(scalar)))\n             }\n             layout::Abi::ScalarPair(ref a, ref b) => {\n@@ -1366,28 +1378,28 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let a_ptr = ptr;\n                 let b_offset = a_size.abi_align(b.align(self));\n                 let b_ptr = ptr.offset(b_offset, self)?.into();\n-                let a_val = self.memory.read_scalar(a_ptr, ptr_align, a_size)?;\n-                let b_val = self.memory.read_scalar(b_ptr, ptr_align, b_size)?;\n+                let a_val = self.memory().read_scalar(a_ptr, ptr_align, a_size)?;\n+                let b_val = self.memory().read_scalar(b_ptr, ptr_align, b_size)?;\n                 Ok(Some(Value::ScalarPair(a_val, b_val)))\n             }\n             _ => Ok(None),\n         }\n     }\n \n     pub fn frame(&self) -> &Frame<'mir, 'tcx> {\n-        self.stack.last().expect(\"no call frames exist\")\n+        self.stack().last().expect(\"no call frames exist\")\n     }\n \n     pub fn frame_mut(&mut self) -> &mut Frame<'mir, 'tcx> {\n-        self.stack.last_mut().expect(\"no call frames exist\")\n+        self.stack_mut().last_mut().expect(\"no call frames exist\")\n     }\n \n     pub(super) fn mir(&self) -> &'mir mir::Mir<'tcx> {\n         self.frame().mir\n     }\n \n     pub fn substs(&self) -> &'tcx Substs<'tcx> {\n-        if let Some(frame) = self.stack.last() {\n+        if let Some(frame) = self.stack().last() {\n             frame.instance.substs\n         } else {\n             Substs::empty()\n@@ -1533,7 +1545,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 }\n                 write!(msg, \":\").unwrap();\n \n-                match self.stack[frame].get_local(local) {\n+                match self.stack()[frame].get_local(local) {\n                     Err(err) => {\n                         if let EvalErrorKind::DeadLocal = err.kind {\n                             write!(msg, \" is dead\").unwrap();\n@@ -1568,13 +1580,13 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 }\n \n                 trace!(\"{}\", msg);\n-                self.memory.dump_allocs(allocs);\n+                self.memory().dump_allocs(allocs);\n             }\n             Place::Ptr { ptr, align, .. } => {\n                 match ptr {\n                     Scalar::Ptr(ptr) => {\n                         trace!(\"by align({}) ref:\", align.abi());\n-                        self.memory.dump_alloc(ptr.alloc_id);\n+                        self.memory().dump_alloc(ptr.alloc_id);\n                     }\n                     ptr => trace!(\" integral by ref: {:?}\", ptr),\n                 }\n@@ -1587,12 +1599,12 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     where\n         F: FnOnce(&mut Self, Value) -> EvalResult<'tcx, Value>,\n     {\n-        let val = self.stack[frame].get_local(local)?;\n+        let val = self.stack()[frame].get_local(local)?;\n         let new_val = f(self, val)?;\n-        self.stack[frame].set_local(local, new_val)?;\n+        self.stack_mut()[frame].set_local(local, new_val)?;\n         // FIXME(solson): Run this when setting to Undef? (See previous version of this code.)\n-        // if let Value::ByRef(ptr) = self.stack[frame].get_local(local) {\n-        //     self.memory.deallocate(ptr)?;\n+        // if let Value::ByRef(ptr) = self.stack()[frame].get_local(local) {\n+        //     self.memory().deallocate(ptr)?;\n         // }\n         Ok(())\n     }"}, {"sha": "4d1188b0f152b843fcfb8c92af73e8a76dd40a71", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db025c14eccb435ffb6bc5d4f834b4551589447b/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db025c14eccb435ffb6bc5d4f834b4551589447b/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=db025c14eccb435ffb6bc5d4f834b4551589447b", "patch": "@@ -991,12 +991,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasMemory<'a, 'mir, 'tcx, M> for Me\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasMemory<'a, 'mir, 'tcx, M> for EvalContext<'a, 'mir, 'tcx, M> {\n     #[inline]\n     fn memory_mut(&mut self) -> &mut Memory<'a, 'mir, 'tcx, M> {\n-        &mut self.memory\n+        self.memory_mut()\n     }\n \n     #[inline]\n     fn memory(&self) -> &Memory<'a, 'mir, 'tcx, M> {\n-        &self.memory\n+        self.memory()\n     }\n }\n "}, {"sha": "95391bc8963e9f2e90f7698608ccd9213508f998", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db025c14eccb435ffb6bc5d4f834b4551589447b/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db025c14eccb435ffb6bc5d4f834b4551589447b/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=db025c14eccb435ffb6bc5d4f834b4551589447b", "patch": "@@ -201,7 +201,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 assert_eq!(extra, PlaceExtra::None);\n                 Ok(Value::ByRef(ptr, align))\n             }\n-            Place::Local { frame, local } => self.stack[frame].get_local(local),\n+            Place::Local { frame, local } => self.stack()[frame].get_local(local),\n         }\n     }\n \n@@ -261,7 +261,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let (base_ptr, base_align, base_extra) = match base {\n             Place::Ptr { ptr, align, extra } => (ptr, align, extra),\n             Place::Local { frame, local } => {\n-                match (&self.stack[frame].get_local(local)?, &base_layout.abi) {\n+                match (&self.stack()[frame].get_local(local)?, &base_layout.abi) {\n                     // in case the field covers the entire type, just return the value\n                     (&Value::Scalar(_), &layout::Abi::Scalar(_)) |\n                     (&Value::ScalarPair(..), &layout::Abi::ScalarPair(..))"}, {"sha": "86eb02312bd19d63c0d9f26aadf1fad738bff07d", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/db025c14eccb435ffb6bc5d4f834b4551589447b/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db025c14eccb435ffb6bc5d4f834b4551589447b/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=db025c14eccb435ffb6bc5d4f834b4551589447b", "patch": "@@ -19,7 +19,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n     /// Returns true as long as there are more things to do.\n     pub fn step(&mut self) -> EvalResult<'tcx, bool> {\n-        if self.stack.is_empty() {\n+        if self.stack().is_empty() {\n             return Ok(false);\n         }\n \n@@ -53,7 +53,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         // *before* executing the statement.\n         let frame_idx = self.cur_frame();\n         self.tcx.span = stmt.source_info.span;\n-        self.memory.tcx.span = stmt.source_info.span;\n+        self.memory_mut().tcx.span = stmt.source_info.span;\n \n         match stmt.kind {\n             Assign(ref place, ref rvalue) => self.eval_rvalue_into_place(rvalue, place)?,\n@@ -102,16 +102,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             InlineAsm { .. } => return err!(InlineAsm),\n         }\n \n-        self.stack[frame_idx].stmt += 1;\n+        self.stack_mut()[frame_idx].stmt += 1;\n         Ok(())\n     }\n \n     fn terminator(&mut self, terminator: &mir::Terminator<'tcx>) -> EvalResult<'tcx> {\n         trace!(\"{:?}\", terminator.kind);\n         self.tcx.span = terminator.source_info.span;\n-        self.memory.tcx.span = terminator.source_info.span;\n+        self.memory_mut().tcx.span = terminator.source_info.span;\n         self.eval_terminator(terminator)?;\n-        if !self.stack.is_empty() {\n+        if !self.stack().is_empty() {\n             trace!(\"// {:?}\", self.frame().block);\n         }\n         Ok(())"}, {"sha": "61670769d01ad40562a548e4ce078fe548079d62", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db025c14eccb435ffb6bc5d4f834b4551589447b/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db025c14eccb435ffb6bc5d4f834b4551589447b/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=db025c14eccb435ffb6bc5d4f834b4551589447b", "patch": "@@ -71,7 +71,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let (fn_def, sig) = match func.ty.sty {\n                     ty::TyFnPtr(sig) => {\n                         let fn_ptr = self.value_to_scalar(func)?.to_ptr()?;\n-                        let instance = self.memory.get_fn(fn_ptr)?;\n+                        let instance = self.memory().get_fn(fn_ptr)?;\n                         let instance_ty = instance.ty(*self.tcx);\n                         match instance_ty.sty {\n                             ty::TyFnDef(..) => {\n@@ -377,14 +377,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             }\n             // cannot use the shim here, because that will only result in infinite recursion\n             ty::InstanceDef::Virtual(_, idx) => {\n-                let ptr_size = self.memory.pointer_size();\n+                let ptr_size = self.memory().pointer_size();\n                 let ptr_align = self.tcx.data_layout.pointer_align;\n                 let (ptr, vtable) = self.into_ptr_vtable_pair(args[0].value)?;\n-                let fn_ptr = self.memory.read_ptr_sized(\n+                let fn_ptr = self.memory().read_ptr_sized(\n                     vtable.offset(ptr_size * (idx as u64 + 3), &self)?,\n                     ptr_align\n                 )?.to_ptr()?;\n-                let instance = self.memory.get_fn(fn_ptr)?;\n+                let instance = self.memory().get_fn(fn_ptr)?;\n                 let mut args = args.to_vec();\n                 let ty = self.layout_of(args[0].ty)?.field(&self, 0)?.ty;\n                 args[0].ty = ty;"}, {"sha": "2a9129498ad52caa6b23338614bcb6eb2abc92c7", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/db025c14eccb435ffb6bc5d4f834b4551589447b/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db025c14eccb435ffb6bc5d4f834b4551589447b/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=db025c14eccb435ffb6bc5d4f834b4551589447b", "patch": "@@ -25,40 +25,40 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let size = layout.size.bytes();\n         let align = layout.align.abi();\n \n-        let ptr_size = self.memory.pointer_size();\n+        let ptr_size = self.memory().pointer_size();\n         let ptr_align = self.tcx.data_layout.pointer_align;\n         let methods = self.tcx.vtable_methods(trait_ref);\n-        let vtable = self.memory.allocate(\n+        let vtable = self.memory_mut().allocate(\n             ptr_size * (3 + methods.len() as u64),\n             ptr_align,\n             MemoryKind::Stack,\n         )?;\n \n         let drop = ::monomorphize::resolve_drop_in_place(*self.tcx, ty);\n-        let drop = self.memory.create_fn_alloc(drop);\n-        self.memory.write_ptr_sized_unsigned(vtable, ptr_align, drop.into())?;\n+        let drop = self.memory_mut().create_fn_alloc(drop);\n+        self.memory_mut().write_ptr_sized_unsigned(vtable, ptr_align, drop.into())?;\n \n         let size_ptr = vtable.offset(ptr_size, &self)?;\n-        self.memory.write_ptr_sized_unsigned(size_ptr, ptr_align, Scalar::Bits {\n+        self.memory_mut().write_ptr_sized_unsigned(size_ptr, ptr_align, Scalar::Bits {\n             bits: size as u128,\n             defined: ptr_size.bits() as u8,\n         })?;\n         let align_ptr = vtable.offset(ptr_size * 2, &self)?;\n-        self.memory.write_ptr_sized_unsigned(align_ptr, ptr_align, Scalar::Bits {\n+        self.memory_mut().write_ptr_sized_unsigned(align_ptr, ptr_align, Scalar::Bits {\n             bits: align as u128,\n             defined: ptr_size.bits() as u8,\n         })?;\n \n         for (i, method) in methods.iter().enumerate() {\n             if let Some((def_id, substs)) = *method {\n                 let instance = self.resolve(def_id, substs)?;\n-                let fn_ptr = self.memory.create_fn_alloc(instance);\n+                let fn_ptr = self.memory_mut().create_fn_alloc(instance);\n                 let method_ptr = vtable.offset(ptr_size * (3 + i as u64), &self)?;\n-                self.memory.write_ptr_sized_unsigned(method_ptr, ptr_align, fn_ptr.into())?;\n+                self.memory_mut().write_ptr_sized_unsigned(method_ptr, ptr_align, fn_ptr.into())?;\n             }\n         }\n \n-        self.memory.mark_static_initialized(\n+        self.memory_mut().mark_static_initialized(\n             vtable.alloc_id,\n             Mutability::Immutable,\n         )?;\n@@ -76,7 +76,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         match self.read_ptr(vtable, pointer_align, self.tcx.mk_nil_ptr())? {\n             // some values don't need to call a drop impl, so the value is null\n             Value::Scalar(Scalar::Bits { bits: 0, defined} ) if defined == pointer_size => Ok(None),\n-            Value::Scalar(Scalar::Ptr(drop_fn)) => self.memory.get_fn(drop_fn).map(Some),\n+            Value::Scalar(Scalar::Ptr(drop_fn)) => self.memory().get_fn(drop_fn).map(Some),\n             _ => err!(ReadBytesAsPointer),\n         }\n     }\n@@ -85,10 +85,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         &self,\n         vtable: Pointer,\n     ) -> EvalResult<'tcx, (Size, Align)> {\n-        let pointer_size = self.memory.pointer_size();\n+        let pointer_size = self.memory().pointer_size();\n         let pointer_align = self.tcx.data_layout.pointer_align;\n-        let size = self.memory.read_ptr_sized(vtable.offset(pointer_size, self)?, pointer_align)?.to_bits(pointer_size)? as u64;\n-        let align = self.memory.read_ptr_sized(\n+        let size = self.memory().read_ptr_sized(vtable.offset(pointer_size, self)?, pointer_align)?.to_bits(pointer_size)? as u64;\n+        let align = self.memory().read_ptr_sized(\n             vtable.offset(pointer_size * 2, self)?,\n             pointer_align\n         )?.to_bits(pointer_size)? as u64;"}]}