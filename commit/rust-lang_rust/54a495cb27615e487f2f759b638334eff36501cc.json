{"sha": "54a495cb27615e487f2f759b638334eff36501cc", "node_id": "C_kwDOAAsO6NoAKDU0YTQ5NWNiMjc2MTVlNDg3ZjJmNzU5YjYzODMzNGVmZjM2NTAxY2M", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-25T20:01:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-25T20:01:49Z"}, "message": "Auto merge of #2267 - RalfJung:rustup, r=RalfJung\n\nrustup\n\nI cannot reproduce https://github.com/rust-lang/rust/issues/98493 so let's see what CI says.", "tree": {"sha": "715ffa3d4c8c749009ccab221abbe95b8203a6df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/715ffa3d4c8c749009ccab221abbe95b8203a6df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54a495cb27615e487f2f759b638334eff36501cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54a495cb27615e487f2f759b638334eff36501cc", "html_url": "https://github.com/rust-lang/rust/commit/54a495cb27615e487f2f759b638334eff36501cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54a495cb27615e487f2f759b638334eff36501cc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3d42e696306bd578eb1409326049ed2a4f25b4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3d42e696306bd578eb1409326049ed2a4f25b4d", "html_url": "https://github.com/rust-lang/rust/commit/e3d42e696306bd578eb1409326049ed2a4f25b4d"}, {"sha": "7c025a8f0eac5297c1d8cc3daf31dc27cad0694d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c025a8f0eac5297c1d8cc3daf31dc27cad0694d", "html_url": "https://github.com/rust-lang/rust/commit/7c025a8f0eac5297c1d8cc3daf31dc27cad0694d"}], "stats": {"total": 111, "additions": 61, "deletions": 50}, "files": [{"sha": "dafb049cc5a85ce1fc9e01c4ff61fa105b2343d3", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54a495cb27615e487f2f759b638334eff36501cc/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/54a495cb27615e487f2f759b638334eff36501cc/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=54a495cb27615e487f2f759b638334eff36501cc", "patch": "@@ -1 +1 @@\n-a09c668c965f735f4cd59e7158662b9daa0b71ba\n+8aab472d52ba7314dc193c73abcd384e2586123c"}, {"sha": "7fbc6dd30166bdbca3bacb43f4b17d79b4a06251", "filename": "tests/pass/concurrency/mutex_leak.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/54a495cb27615e487f2f759b638334eff36501cc/tests%2Fpass%2Fconcurrency%2Fmutex_leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54a495cb27615e487f2f759b638334eff36501cc/tests%2Fpass%2Fconcurrency%2Fmutex_leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fmutex_leak.rs?ref=54a495cb27615e487f2f759b638334eff36501cc", "patch": "@@ -0,0 +1,9 @@\n+// compile-flags: -Zmiri-ignore-leaks\n+use std::mem;\n+use std::sync::Mutex;\n+\n+fn main() {\n+    // Test for https://github.com/rust-lang/rust/issues/85434\n+    let m = Mutex::new(5i32);\n+    mem::forget(m.lock());\n+}"}, {"sha": "396c1a97e07e8db80c9a8f36bce33900c15f3a2d", "filename": "tests/pass/concurrency/sync.rs", "status": "modified", "additions": 3, "deletions": 48, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/54a495cb27615e487f2f759b638334eff36501cc/tests%2Fpass%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54a495cb27615e487f2f759b638334eff36501cc/tests%2Fpass%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fsync.rs?ref=54a495cb27615e487f2f759b638334eff36501cc", "patch": "@@ -35,7 +35,7 @@ fn check_conditional_variables_notify_one() {\n     let pair2 = pair.clone();\n \n     // Spawn a new thread.\n-    thread::spawn(move || {\n+    let t = thread::spawn(move || {\n         thread::yield_now();\n         let (lock, cvar) = &*pair2;\n         let mut started = lock.lock().unwrap();\n@@ -50,6 +50,8 @@ fn check_conditional_variables_notify_one() {\n     while !*started {\n         started = cvar.wait(started).unwrap();\n     }\n+\n+    t.join().unwrap();\n }\n \n /// Test that waiting on a conditional variable with a timeout does not\n@@ -191,51 +193,6 @@ fn check_once() {\n     }\n }\n \n-fn check_rwlock_unlock_bug1() {\n-    // There was a bug where when un-read-locking an rwlock that still has other\n-    // readers waiting, we'd accidentally also let a writer in.\n-    // That caused an ICE.\n-    let l = Arc::new(RwLock::new(0));\n-\n-    let r1 = l.read().unwrap();\n-    let r2 = l.read().unwrap();\n-\n-    // Make a waiting writer.\n-    let l2 = l.clone();\n-    thread::spawn(move || {\n-        let mut w = l2.write().unwrap();\n-        *w += 1;\n-    });\n-    thread::yield_now();\n-\n-    drop(r1);\n-    assert_eq!(*r2, 0);\n-    thread::yield_now();\n-    thread::yield_now();\n-    thread::yield_now();\n-    assert_eq!(*r2, 0);\n-    drop(r2);\n-}\n-\n-fn check_rwlock_unlock_bug2() {\n-    // There was a bug where when un-read-locking an rwlock by letting the last reader leaver,\n-    // we'd forget to wake up a writer.\n-    // That meant the writer thread could never run again.\n-    let l = Arc::new(RwLock::new(0));\n-\n-    let r = l.read().unwrap();\n-\n-    // Make a waiting writer.\n-    let l2 = l.clone();\n-    let h = thread::spawn(move || {\n-        let _w = l2.write().unwrap();\n-    });\n-    thread::yield_now();\n-\n-    drop(r);\n-    h.join().unwrap();\n-}\n-\n fn park_timeout() {\n     let start = Instant::now();\n \n@@ -277,8 +234,6 @@ fn main() {\n     check_rwlock_write();\n     check_rwlock_read_no_deadlock();\n     check_once();\n-    check_rwlock_unlock_bug1();\n-    check_rwlock_unlock_bug2();\n     park_timeout();\n     park_unpark();\n     check_condvar();"}, {"sha": "391f65ae5a9cb0013267d14b06b9c768e821a174", "filename": "tests/pass/concurrency/sync_nopreempt.rs", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/54a495cb27615e487f2f759b638334eff36501cc/tests%2Fpass%2Fconcurrency%2Fsync_nopreempt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54a495cb27615e487f2f759b638334eff36501cc/tests%2Fpass%2Fconcurrency%2Fsync_nopreempt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fsync_nopreempt.rs?ref=54a495cb27615e487f2f759b638334eff36501cc", "patch": "@@ -2,7 +2,7 @@\n // We are making scheduler assumptions here.\n // compile-flags: -Zmiri-strict-provenance -Zmiri-preemption-rate=0\n \n-use std::sync::{Arc, Condvar, Mutex};\n+use std::sync::{Arc, Condvar, Mutex, RwLock};\n use std::thread;\n \n fn check_conditional_variables_notify_all() {\n@@ -35,6 +35,53 @@ fn check_conditional_variables_notify_all() {\n     }\n }\n \n+fn check_rwlock_unlock_bug1() {\n+    // There was a bug where when un-read-locking an rwlock that still has other\n+    // readers waiting, we'd accidentally also let a writer in.\n+    // That caused an ICE.\n+    let l = Arc::new(RwLock::new(0));\n+\n+    let r1 = l.read().unwrap();\n+    let r2 = l.read().unwrap();\n+\n+    // Make a waiting writer.\n+    let l2 = l.clone();\n+    thread::spawn(move || {\n+        let mut w = l2.write().unwrap();\n+        *w += 1;\n+    });\n+    thread::yield_now();\n+\n+    drop(r1);\n+    assert_eq!(*r2, 0);\n+    thread::yield_now();\n+    thread::yield_now();\n+    thread::yield_now();\n+    assert_eq!(*r2, 0);\n+    drop(r2);\n+}\n+\n+fn check_rwlock_unlock_bug2() {\n+    // There was a bug where when un-read-locking an rwlock by letting the last reader leaver,\n+    // we'd forget to wake up a writer.\n+    // That meant the writer thread could never run again.\n+    let l = Arc::new(RwLock::new(0));\n+\n+    let r = l.read().unwrap();\n+\n+    // Make a waiting writer.\n+    let l2 = l.clone();\n+    let h = thread::spawn(move || {\n+        let _w = l2.write().unwrap();\n+    });\n+    thread::yield_now();\n+\n+    drop(r);\n+    h.join().unwrap();\n+}\n+\n fn main() {\n     check_conditional_variables_notify_all();\n+    check_rwlock_unlock_bug1();\n+    check_rwlock_unlock_bug2();\n }"}]}