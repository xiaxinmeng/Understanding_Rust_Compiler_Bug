{"sha": "5f90947c2c27d5d4ae30ccc0e83ffc95a8597128", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmOTA5NDdjMmMyN2Q1ZDRhZTMwY2NjMGU4M2ZmYzk1YTg1OTcxMjg=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-01-09T14:52:08Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-01-09T15:06:58Z"}, "message": "trans: Treat generics like regular functions, not like #[inline] functions during CGU partitioning.", "tree": {"sha": "47930b67ff2082f94f8fad7573124617409dcd0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47930b67ff2082f94f8fad7573124617409dcd0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f90947c2c27d5d4ae30ccc0e83ffc95a8597128", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f90947c2c27d5d4ae30ccc0e83ffc95a8597128", "html_url": "https://github.com/rust-lang/rust/commit/5f90947c2c27d5d4ae30ccc0e83ffc95a8597128", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f90947c2c27d5d4ae30ccc0e83ffc95a8597128/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02c7b117dadcfea4416f53b4bd99828bf750871f", "url": "https://api.github.com/repos/rust-lang/rust/commits/02c7b117dadcfea4416f53b4bd99828bf750871f", "html_url": "https://github.com/rust-lang/rust/commit/02c7b117dadcfea4416f53b4bd99828bf750871f"}], "stats": {"total": 269, "additions": 145, "deletions": 124}, "files": [{"sha": "ac182ae5606bc25d72f59125492c49aaa7ac2f72", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 53, "deletions": 27, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/5f90947c2c27d5d4ae30ccc0e83ffc95a8597128/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f90947c2c27d5d4ae30ccc0e83ffc95a8597128/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=5f90947c2c27d5d4ae30ccc0e83ffc95a8597128", "patch": "@@ -212,7 +212,7 @@ use glue::{self, DropGlueKind};\n use monomorphize::{self, Instance};\n use util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n \n-use trans_item::{TransItem, DefPathBasedNames};\n+use trans_item::{TransItem, DefPathBasedNames, InstantiationMode};\n \n use std::iter;\n \n@@ -337,6 +337,10 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n         }\n         TransItem::Static(node_id) => {\n             let def_id = scx.tcx().map.local_def_id(node_id);\n+\n+            // Sanity check whether this ended up being collected accidentally\n+            debug_assert!(should_trans_locally(scx.tcx(), def_id));\n+\n             let ty = scx.tcx().item_type(def_id);\n             let ty = glue::get_drop_glue_type(scx, ty);\n             neighbors.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n@@ -346,6 +350,9 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n             collect_neighbours(scx, Instance::mono(scx, def_id), &mut neighbors);\n         }\n         TransItem::Fn(instance) => {\n+            // Sanity check whether this ended up being collected accidentally\n+            debug_assert!(should_trans_locally(scx.tcx(), instance.def));\n+\n             // Keep track of the monomorphization recursion depth\n             recursion_depth_reset = Some(check_recursion_limit(scx.tcx(),\n                                                                instance,\n@@ -374,7 +381,7 @@ fn record_inlining_canditates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         callees: &[TransItem<'tcx>],\n                                         inlining_map: &mut InliningMap<'tcx>) {\n     let is_inlining_candidate = |trans_item: &TransItem<'tcx>| {\n-        trans_item.needs_local_copy(tcx)\n+        trans_item.instantiation_mode(tcx) == InstantiationMode::LocalCopy\n     };\n \n     let inlining_candidates = callees.into_iter()\n@@ -490,15 +497,16 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                         .require(ExchangeMallocFnLangItem)\n                         .unwrap_or_else(|e| self.scx.sess().fatal(&e));\n \n-                assert!(can_have_local_instance(self.scx.tcx(), exchange_malloc_fn_def_id));\n-                let empty_substs = self.scx.empty_substs_for_def_id(exchange_malloc_fn_def_id);\n-                let exchange_malloc_fn_trans_item =\n-                    create_fn_trans_item(self.scx,\n-                                         exchange_malloc_fn_def_id,\n-                                         empty_substs,\n-                                         self.param_substs);\n+                if should_trans_locally(self.scx.tcx(), exchange_malloc_fn_def_id) {\n+                    let empty_substs = self.scx.empty_substs_for_def_id(exchange_malloc_fn_def_id);\n+                    let exchange_malloc_fn_trans_item =\n+                        create_fn_trans_item(self.scx,\n+                                             exchange_malloc_fn_def_id,\n+                                             empty_substs,\n+                                             self.param_substs);\n \n-                self.output.push(exchange_malloc_fn_trans_item);\n+                    self.output.push(exchange_malloc_fn_trans_item);\n+                }\n             }\n             _ => { /* not interesting */ }\n         }\n@@ -609,7 +617,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             match tcx.item_type(def_id).sty {\n                 ty::TyFnDef(def_id, _, f) => {\n                     // Some constructors also have type TyFnDef but they are\n-                    // always instantiated inline and don't result in\n+                    // always instantiated inline and don't result in a\n                     // translation item. Same for FFI functions.\n                     if let Some(hir_map::NodeForeignItem(_)) = tcx.map.get_if_local(def_id) {\n                         return false;\n@@ -625,7 +633,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 _ => return false\n             }\n \n-            can_have_local_instance(tcx, def_id)\n+            should_trans_locally(tcx, def_id)\n         }\n     }\n \n@@ -675,10 +683,27 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n     }\n }\n \n-fn can_have_local_instance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     def_id: DefId)\n-                                     -> bool {\n-    tcx.sess.cstore.can_have_local_instance(tcx, def_id)\n+// Returns true if we should translate an instance in the local crate.\n+// Returns false if we can just link to the upstream crate and therefore don't\n+// need a translation item.\n+fn should_trans_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                  def_id: DefId)\n+                                  -> bool {\n+    if def_id.is_local() {\n+        true\n+    } else {\n+        if tcx.sess.cstore.is_exported_symbol(def_id) ||\n+           tcx.sess.cstore.is_foreign_item(def_id) {\n+            // We can link to the item in question, no instance needed in this\n+            // crate\n+            false\n+        } else {\n+            if !tcx.sess.cstore.can_have_local_instance(tcx, def_id) {\n+                bug!(\"Cannot create local trans-item for {:?}\", def_id)\n+            }\n+            true\n+        }\n+    }\n }\n \n fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n@@ -698,14 +723,15 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     // Make sure the BoxFreeFn lang-item gets translated if there is a boxed value.\n     if let ty::TyBox(content_type) = ty.sty {\n         let def_id = scx.tcx().require_lang_item(BoxFreeFnLangItem);\n-        assert!(can_have_local_instance(scx.tcx(), def_id));\n-        let box_free_fn_trans_item =\n-            create_fn_trans_item(scx,\n-                                 def_id,\n-                                 scx.tcx().mk_substs(iter::once(Kind::from(content_type))),\n-                                 scx.tcx().intern_substs(&[]));\n-\n-        output.push(box_free_fn_trans_item);\n+\n+        if should_trans_locally(scx.tcx(), def_id) {\n+            let box_free_fn_trans_item =\n+                create_fn_trans_item(scx,\n+                                     def_id,\n+                                     scx.tcx().mk_substs(iter::once(Kind::from(content_type))),\n+                                     scx.tcx().intern_substs(&[]));\n+            output.push(box_free_fn_trans_item);\n+        }\n     }\n \n     // If the type implements Drop, also add a translation item for the\n@@ -735,7 +761,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             _ => bug!()\n         };\n \n-        if can_have_local_instance(scx.tcx(), destructor_did) {\n+        if should_trans_locally(scx.tcx(), destructor_did) {\n             let trans_item = create_fn_trans_item(scx,\n                                                   destructor_did,\n                                                   substs,\n@@ -1080,7 +1106,7 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a,\n                         None\n                     }\n                 })\n-                .filter(|&(def_id, _)| can_have_local_instance(scx.tcx(), def_id))\n+                .filter(|&(def_id, _)| should_trans_locally(scx.tcx(), def_id))\n                 .map(|(def_id, substs)| create_fn_trans_item(scx, def_id, substs, param_substs));\n             output.extend(methods);\n         }\n@@ -1255,7 +1281,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n                         continue;\n                     }\n \n-                    if can_have_local_instance(tcx, method.def_id) {\n+                    if should_trans_locally(tcx, method.def_id) {\n                         let item = create_fn_trans_item(scx,\n                                                         method.def_id,\n                                                         callee_substs,"}, {"sha": "c91b25ef360cdd2bf24be7991c28e6101885622c", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 13, "deletions": 42, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5f90947c2c27d5d4ae30ccc0e83ffc95a8597128/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f90947c2c27d5d4ae30ccc0e83ffc95a8597128/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=5f90947c2c27d5d4ae30ccc0e83ffc95a8597128", "patch": "@@ -133,7 +133,7 @@ use std::sync::Arc;\n use symbol_map::SymbolMap;\n use syntax::ast::NodeId;\n use syntax::symbol::{Symbol, InternedString};\n-use trans_item::TransItem;\n+use trans_item::{TransItem, InstantiationMode};\n use util::nodemap::{FxHashMap, FxHashSet};\n \n pub enum PartitioningStrategy {\n@@ -326,13 +326,15 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     let tcx = scx.tcx();\n     let mut roots = FxHashSet();\n     let mut codegen_units = FxHashMap();\n+    let is_incremental_build = tcx.sess.opts.incremental.is_some();\n \n     for trans_item in trans_items {\n-        let is_root = !trans_item.is_instantiated_only_on_demand(tcx);\n+        let is_root = trans_item.instantiation_mode(tcx) == InstantiationMode::GloballyShared;\n \n         if is_root {\n             let characteristic_def_id = characteristic_def_id_of_trans_item(scx, trans_item);\n-            let is_volatile = trans_item.is_generic_fn();\n+            let is_volatile = is_incremental_build &&\n+                              trans_item.is_generic_fn();\n \n             let codegen_unit_name = match characteristic_def_id {\n                 Some(def_id) => compute_codegen_unit_name(tcx, def_id, is_volatile),\n@@ -350,25 +352,9 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n                 Some(explicit_linkage) => explicit_linkage,\n                 None => {\n                     match trans_item {\n+                        TransItem::Fn(..) |\n                         TransItem::Static(..) => llvm::ExternalLinkage,\n                         TransItem::DropGlue(..) => unreachable!(),\n-                        // Is there any benefit to using ExternalLinkage?:\n-                        TransItem::Fn(ref instance) => {\n-                            if instance.substs.types().next().is_none() {\n-                                // This is a non-generic functions, we always\n-                                // make it visible externally on the chance that\n-                                // it might be used in another codegen unit.\n-                                // Later on base::internalize_symbols() will\n-                                // assign \"internal\" linkage to those symbols\n-                                // that are not referenced from other codegen\n-                                // units (and are not publicly visible).\n-                                llvm::ExternalLinkage\n-                            } else {\n-                                // In the current setup, generic functions cannot\n-                                // be roots.\n-                                unreachable!()\n-                            }\n-                        }\n                     }\n                 }\n             };\n@@ -448,29 +434,14 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n             if let Some(linkage) = codegen_unit.items.get(&trans_item) {\n                 // This is a root, just copy it over\n                 new_codegen_unit.items.insert(trans_item, *linkage);\n-            } else if initial_partitioning.roots.contains(&trans_item) {\n-                // This item will be instantiated in some other codegen unit,\n-                // so we just add it here with AvailableExternallyLinkage\n-                // FIXME(mw): I have not seen it happening yet but having\n-                //            available_externally here could potentially lead\n-                //            to the same problem with exception handling tables\n-                //            as in the case below.\n-                new_codegen_unit.items.insert(trans_item,\n-                                              llvm::AvailableExternallyLinkage);\n-            } else if trans_item.is_from_extern_crate() && !trans_item.is_generic_fn() {\n-                // FIXME(mw): It would be nice if we could mark these as\n-                // `AvailableExternallyLinkage`, since they should have\n-                // been instantiated in the extern crate. But this\n-                // sometimes leads to crashes on Windows because LLVM\n-                // does not handle exception handling table instantiation\n-                // reliably in that case.\n-                new_codegen_unit.items.insert(trans_item, llvm::InternalLinkage);\n             } else {\n-                // We can't be sure if this will also be instantiated\n-                // somewhere else, so we add an instance here with\n-                // InternalLinkage so we don't get any conflicts.\n-                new_codegen_unit.items.insert(trans_item,\n-                                              llvm::InternalLinkage);\n+                if initial_partitioning.roots.contains(&trans_item) {\n+                    bug!(\"GloballyShared trans-item inlined into other CGU: \\\n+                          {:?}\", trans_item);\n+                }\n+\n+                // This is a cgu-private copy\n+                new_codegen_unit.items.insert(trans_item, llvm::InternalLinkage);\n             }\n         }\n "}, {"sha": "816c34425437166e985b823fe2e75f7d05754d50", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5f90947c2c27d5d4ae30ccc0e83ffc95a8597128/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f90947c2c27d5d4ae30ccc0e83ffc95a8597128/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=5f90947c2c27d5d4ae30ccc0e83ffc95a8597128", "patch": "@@ -45,6 +45,18 @@ pub enum TransItem<'tcx> {\n     Static(NodeId)\n }\n \n+/// Describes how a translation item will be instantiated in object files.\n+#[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n+pub enum InstantiationMode {\n+    /// There will be exactly one instance of the given TransItem. It will have\n+    /// external linkage so that it can be linked to from other codegen units.\n+    GloballyShared,\n+\n+    /// Each codegen unit containing a reference to the given TransItem will\n+    /// have its own private copy of the function (with internal linkage).\n+    LocalCopy,\n+}\n+\n impl<'a, 'tcx> TransItem<'tcx> {\n \n     pub fn define(&self, ccx: &CrateContext<'a, 'tcx>) {\n@@ -231,22 +243,21 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         }\n     }\n \n-    /// True if the translation item should only be translated to LLVM IR if\n-    /// it is referenced somewhere (like inline functions, for example).\n-    pub fn is_instantiated_only_on_demand(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n-        if self.explicit_linkage(tcx).is_some() {\n-            return false;\n-        }\n-\n+    pub fn instantiation_mode(&self,\n+                              tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                              -> InstantiationMode {\n         match *self {\n             TransItem::Fn(ref instance) => {\n-                !instance.def.is_local() ||\n-                instance.substs.types().next().is_some() ||\n-                common::is_closure(tcx, instance.def) ||\n-                attr::requests_inline(&tcx.get_attrs(instance.def)[..])\n+                if self.explicit_linkage(tcx).is_none() &&\n+                   (common::is_closure(tcx, instance.def) ||\n+                    attr::requests_inline(&tcx.get_attrs(instance.def)[..])) {\n+                    InstantiationMode::LocalCopy\n+                } else {\n+                    InstantiationMode::GloballyShared\n+                }\n             }\n-            TransItem::DropGlue(..) => true,\n-            TransItem::Static(..)   => false,\n+            TransItem::DropGlue(..) => InstantiationMode::LocalCopy,\n+            TransItem::Static(..) => InstantiationMode::GloballyShared,\n         }\n     }\n \n@@ -260,18 +271,6 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         }\n     }\n \n-    /// Returns true if there has to be a local copy of this TransItem in every\n-    /// codegen unit that references it (as with inlined functions, for example)\n-    pub fn needs_local_copy(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n-        // Currently everything that is instantiated only on demand is done so\n-        // with \"internal\" linkage, so we need a copy to be present in every\n-        // codegen unit.\n-        // This is coincidental: We could also instantiate something only if it\n-        // is referenced (e.g. a regular, private function) but place it in its\n-        // own codegen unit with \"external\" linkage.\n-        self.is_instantiated_only_on_demand(tcx)\n-    }\n-\n     pub fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<llvm::Linkage> {\n         let def_id = match *self {\n             TransItem::Fn(ref instance) => instance.def,"}, {"sha": "db36b50702a43efd090be185914bddd167dd9527", "filename": "src/test/codegen-units/partitioning/extern-generic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f90947c2c27d5d4ae30ccc0e83ffc95a8597128/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f90947c2c27d5d4ae30ccc0e83ffc95a8597128/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs?ref=5f90947c2c27d5d4ae30ccc0e83ffc95a8597128", "patch": "@@ -57,8 +57,8 @@ mod mod3 {\n }\n \n // Make sure the two generic functions from the extern crate get instantiated\n-// privately in every module they are use in.\n-//~ TRANS_ITEM fn cgu_generic_function::foo[0]<&str> @@ extern_generic[Internal] extern_generic-mod1[Internal] extern_generic-mod2[Internal] extern_generic-mod1-mod1[Internal]\n-//~ TRANS_ITEM fn cgu_generic_function::bar[0]<&str> @@ extern_generic[Internal] extern_generic-mod1[Internal] extern_generic-mod2[Internal] extern_generic-mod1-mod1[Internal]\n+// once for the current crate\n+//~ TRANS_ITEM fn cgu_generic_function::foo[0]<&str> @@ cgu_generic_function.volatile[External]\n+//~ TRANS_ITEM fn cgu_generic_function::bar[0]<&str> @@ cgu_generic_function.volatile[External]\n \n //~ TRANS_ITEM drop-glue i8"}, {"sha": "70fc75c6970b7a23218fd245ab5cef7897b264bb", "filename": "src/test/codegen-units/partitioning/local-generic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f90947c2c27d5d4ae30ccc0e83ffc95a8597128/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f90947c2c27d5d4ae30ccc0e83ffc95a8597128/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs?ref=5f90947c2c27d5d4ae30ccc0e83ffc95a8597128", "patch": "@@ -16,10 +16,10 @@\n #![allow(dead_code)]\n #![crate_type=\"lib\"]\n \n-//~ TRANS_ITEM fn local_generic::generic[0]<u32> @@ local_generic[Internal]\n-//~ TRANS_ITEM fn local_generic::generic[0]<u64> @@ local_generic-mod1[Internal]\n-//~ TRANS_ITEM fn local_generic::generic[0]<char> @@ local_generic-mod1-mod1[Internal]\n-//~ TRANS_ITEM fn local_generic::generic[0]<&str> @@ local_generic-mod2[Internal]\n+//~ TRANS_ITEM fn local_generic::generic[0]<u32> @@ local_generic.volatile[External]\n+//~ TRANS_ITEM fn local_generic::generic[0]<u64> @@ local_generic.volatile[External]\n+//~ TRANS_ITEM fn local_generic::generic[0]<char> @@ local_generic.volatile[External]\n+//~ TRANS_ITEM fn local_generic::generic[0]<&str> @@ local_generic.volatile[External]\n pub fn generic<T>(x: T) -> T { x }\n \n //~ TRANS_ITEM fn local_generic::user[0] @@ local_generic[External]"}, {"sha": "7a0217072f32c597cd44011f191f4bbaf7dff69d", "filename": "src/test/codegen-units/partitioning/vtable-through-const.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f90947c2c27d5d4ae30ccc0e83ffc95a8597128/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fvtable-through-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f90947c2c27d5d4ae30ccc0e83ffc95a8597128/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fvtable-through-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fvtable-through-const.rs?ref=5f90947c2c27d5d4ae30ccc0e83ffc95a8597128", "patch": "@@ -74,19 +74,19 @@ fn main() {\n     // Since Trait1::do_something() is instantiated via its default implementation,\n     // it is considered a generic and is instantiated here only because it is\n     // referenced in this module.\n-    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::Trait1[0]::do_something_else[0]<u32> @@ vtable_through_const[Internal]\n+    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::Trait1[0]::do_something_else[0]<u32> @@ vtable_through_const-mod1.volatile[External]\n \n     // Although it is never used, Trait1::do_something_else() has to be\n     // instantiated locally here too, otherwise the <&u32 as &Trait1> vtable\n     // could not be fully constructed.\n-    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::Trait1[0]::do_something[0]<u32> @@ vtable_through_const[Internal]\n+    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::Trait1[0]::do_something[0]<u32> @@ vtable_through_const-mod1.volatile[External]\n     mod1::TRAIT1_REF.do_something();\n \n     // Same as above\n-    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::{{impl}}[1]::do_something[0]<u8> @@ vtable_through_const[Internal]\n-    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::{{impl}}[1]::do_something_else[0]<u8> @@ vtable_through_const[Internal]\n+    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::{{impl}}[1]::do_something[0]<u8> @@ vtable_through_const-mod1.volatile[External]\n+    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::{{impl}}[1]::do_something_else[0]<u8> @@ vtable_through_const-mod1.volatile[External]\n     mod1::TRAIT1_GEN_REF.do_something(0u8);\n \n-    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::id[0]<char> @@ vtable_through_const[Internal]\n+    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::id[0]<char> @@ vtable_through_const-mod1.volatile[External]\n     mod1::ID_CHAR('x');\n }"}, {"sha": "3cbc5593ac0a2241926a577341285a84aa9b0732", "filename": "src/test/run-make/stable-symbol-names/Makefile", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5f90947c2c27d5d4ae30ccc0e83ffc95a8597128/src%2Ftest%2Frun-make%2Fstable-symbol-names%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/5f90947c2c27d5d4ae30ccc0e83ffc95a8597128/src%2Ftest%2Frun-make%2Fstable-symbol-names%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fstable-symbol-names%2FMakefile?ref=5f90947c2c27d5d4ae30ccc0e83ffc95a8597128", "patch": "@@ -9,14 +9,32 @@\n #  5. write the result into a file\n \n dump-symbols = nm \"$(TMPDIR)/lib$(1).rlib\" \\\n-             | grep -E \"some_test_function|Bar|bar\" \\\n+             | grep -E \"$(2)\" \\\n              | sed \"s/.*\\(_ZN.*E\\).*/\\1/\" \\\n              | sort \\\n-             > \"$(TMPDIR)/$(1).nm\"\n+             > \"$(TMPDIR)/$(1)$(3).nm\"\n+\n+# This test\n+# - compiles each of the two crates 2 times and makes sure each time we get\n+#   exactly the same symbol names\n+# - makes sure that both crates agree on the same symbol names for monomorphic\n+#   functions\n \n all:\n \t$(RUSTC) stable-symbol-names1.rs\n+\t$(call dump-symbols,stable_symbol_names1,generic_|mono_,_v1)\n+\trm $(TMPDIR)/libstable_symbol_names1.rlib\n+\t$(RUSTC) stable-symbol-names1.rs\n+\t$(call dump-symbols,stable_symbol_names1,generic_|mono_,_v2)\n+\tcmp \"$(TMPDIR)/stable_symbol_names1_v1.nm\" \"$(TMPDIR)/stable_symbol_names1_v2.nm\"\n+\n \t$(RUSTC) stable-symbol-names2.rs\n-\t$(call dump-symbols,stable_symbol_names1)\n-\t$(call dump-symbols,stable_symbol_names2)\n-\tcmp \"$(TMPDIR)/stable_symbol_names1.nm\" \"$(TMPDIR)/stable_symbol_names2.nm\"\n+\t$(call dump-symbols,stable_symbol_names2,generic_|mono_,_v1)\n+\trm $(TMPDIR)/libstable_symbol_names2.rlib\n+\t$(RUSTC) stable-symbol-names2.rs\n+\t$(call dump-symbols,stable_symbol_names2,generic_|mono_,_v2)\n+\tcmp \"$(TMPDIR)/stable_symbol_names2_v1.nm\" \"$(TMPDIR)/stable_symbol_names2_v2.nm\"\n+\n+\t$(call dump-symbols,stable_symbol_names1,mono_,_cross)\n+\t$(call dump-symbols,stable_symbol_names2,mono_,_cross)\n+\tcmp \"$(TMPDIR)/stable_symbol_names1_cross.nm\" \"$(TMPDIR)/stable_symbol_names2_cross.nm\""}, {"sha": "7344bdf49f6f2e2cde77bd4e363addebfd9199a7", "filename": "src/test/run-make/stable-symbol-names/stable-symbol-names1.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5f90947c2c27d5d4ae30ccc0e83ffc95a8597128/src%2Ftest%2Frun-make%2Fstable-symbol-names%2Fstable-symbol-names1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f90947c2c27d5d4ae30ccc0e83ffc95a8597128/src%2Ftest%2Frun-make%2Fstable-symbol-names%2Fstable-symbol-names1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fstable-symbol-names%2Fstable-symbol-names1.rs?ref=5f90947c2c27d5d4ae30ccc0e83ffc95a8597128", "patch": "@@ -11,26 +11,31 @@\n #![crate_type=\"rlib\"]\n \n pub trait Foo {\n-  fn foo<T>();\n+  fn generic_method<T>();\n }\n \n pub struct Bar;\n \n impl Foo for Bar {\n-  fn foo<T>() {}\n+  fn generic_method<T>() {}\n }\n \n-pub fn bar() {\n-  Bar::foo::<Bar>();\n+pub fn mono_function() {\n+  Bar::generic_method::<Bar>();\n }\n \n-pub fn some_test_function<T>(t: T) -> T {\n+pub fn mono_function_lifetime<'a>(x: &'a u64) -> u64 {\n+  *x\n+}\n+\n+pub fn generic_function<T>(t: T) -> T {\n   t\n }\n \n pub fn user() {\n-  some_test_function(0u32);\n-  some_test_function(\"abc\");\n+  generic_function(0u32);\n+  generic_function(\"abc\");\n   let x = 2u64;\n-  some_test_function(&x);\n+  generic_function(&x);\n+  let _ = mono_function_lifetime(&x);\n }"}, {"sha": "eacba4ddb25c0c5e5a41a59480fd15da24f953b9", "filename": "src/test/run-make/stable-symbol-names/stable-symbol-names2.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5f90947c2c27d5d4ae30ccc0e83ffc95a8597128/src%2Ftest%2Frun-make%2Fstable-symbol-names%2Fstable-symbol-names2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f90947c2c27d5d4ae30ccc0e83ffc95a8597128/src%2Ftest%2Frun-make%2Fstable-symbol-names%2Fstable-symbol-names2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fstable-symbol-names%2Fstable-symbol-names2.rs?ref=5f90947c2c27d5d4ae30ccc0e83ffc95a8597128", "patch": "@@ -13,14 +13,16 @@\n extern crate stable_symbol_names1;\n \n pub fn user() {\n-  stable_symbol_names1::some_test_function(1u32);\n-  stable_symbol_names1::some_test_function(\"def\");\n+  stable_symbol_names1::generic_function(1u32);\n+  stable_symbol_names1::generic_function(\"def\");\n   let x = 2u64;\n-  stable_symbol_names1::some_test_function(&x);\n+  stable_symbol_names1::generic_function(&x);\n+  stable_symbol_names1::mono_function();\n+  stable_symbol_names1::mono_function_lifetime(&0);\n }\n \n pub fn trait_impl_test_function() {\n   use stable_symbol_names1::*;\n-  Bar::foo::<Bar>();\n-  bar();\n+  Bar::generic_method::<Bar>();\n }\n+"}]}