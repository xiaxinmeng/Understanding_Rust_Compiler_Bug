{"sha": "47cbaeba6f21e59ee8735bfe8bcbf06300767b57", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3Y2JhZWJhNmYyMWU1OWVlODczNWJmZThiY2JmMDYzMDA3NjdiNTc=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-03T18:03:37Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-03T18:03:37Z"}, "message": "Index deps", "tree": {"sha": "779f75f740a1717ab225a52f26f53562c28ace4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/779f75f740a1717ab225a52f26f53562c28ace4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47cbaeba6f21e59ee8735bfe8bcbf06300767b57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47cbaeba6f21e59ee8735bfe8bcbf06300767b57", "html_url": "https://github.com/rust-lang/rust/commit/47cbaeba6f21e59ee8735bfe8bcbf06300767b57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47cbaeba6f21e59ee8735bfe8bcbf06300767b57/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b04c14d4ad51433b0055e2e5799f98da20d15d58", "url": "https://api.github.com/repos/rust-lang/rust/commits/b04c14d4ad51433b0055e2e5799f98da20d15d58", "html_url": "https://github.com/rust-lang/rust/commit/b04c14d4ad51433b0055e2e5799f98da20d15d58"}], "stats": {"total": 200, "additions": 122, "deletions": 78}, "files": [{"sha": "3ea27947e0ec077e81e1f80f54eb50a693e1fec5", "filename": "crates/libanalysis/src/imp.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/47cbaeba6f21e59ee8735bfe8bcbf06300767b57/crates%2Flibanalysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cbaeba6f21e59ee8735bfe8bcbf06300767b57/crates%2Flibanalysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fimp.rs?ref=47cbaeba6f21e59ee8735bfe8bcbf06300767b57", "patch": "@@ -57,9 +57,9 @@ impl AnalysisHostImpl {\n         }\n         self.data_mut().crate_graph = graph;\n     }\n-    pub fn set_libraries(&mut self, libs: impl Iterator<Item=impl Iterator<Item=(FileId, String)>>) {\n-        let libs = libs.map(ReadonlySourceRoot::new).collect::<Vec<_>>();\n-        self.data_mut().libs = Arc::new(libs);\n+    pub fn add_library(&mut self, files: impl Iterator<Item=(FileId, String)>) {\n+        let libs = ReadonlySourceRoot::new(files);\n+        self.data_mut().libs.push(Arc::new(libs));\n     }\n     fn data_mut(&mut self) -> &mut WorldData {\n         Arc::make_mut(&mut self.data)\n@@ -93,7 +93,7 @@ impl AnalysisImpl {\n         if self.data.root.contains(file_id) {\n             return &self.data.root;\n         }\n-        self.data.libs.iter().find(|it| it.contains(file_id)).unwrap()\n+        &**self.data.libs.iter().find(|it| it.contains(file_id)).unwrap()\n     }\n     pub fn file_syntax(&self, file_id: FileId) -> &File {\n         self.root(file_id).syntax(file_id)\n@@ -308,7 +308,7 @@ impl AnalysisImpl {\n struct WorldData {\n     crate_graph: CrateGraph,\n     root: WritableSourceRoot,\n-    libs: Arc<Vec<ReadonlySourceRoot>>,\n+    libs: Vec<Arc<ReadonlySourceRoot>>,\n }\n \n impl SourceChange {"}, {"sha": "e9e0c51d542f9d0cb3b15d4f43d79f4100619245", "filename": "crates/libanalysis/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47cbaeba6f21e59ee8735bfe8bcbf06300767b57/crates%2Flibanalysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cbaeba6f21e59ee8735bfe8bcbf06300767b57/crates%2Flibanalysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Flib.rs?ref=47cbaeba6f21e59ee8735bfe8bcbf06300767b57", "patch": "@@ -68,8 +68,8 @@ impl AnalysisHost {\n     pub fn set_crate_graph(&mut self, graph: CrateGraph) {\n         self.imp.set_crate_graph(graph)\n     }\n-    pub fn set_libraries(&mut self, libs: impl Iterator<Item=impl Iterator<Item=(FileId, String)>>) {\n-        self.imp.set_libraries(libs)\n+    pub fn add_library(&mut self, files: impl Iterator<Item=(FileId, String)>) {\n+        self.imp.add_library(files)\n     }\n }\n "}, {"sha": "323d4e95ea435a646eca8fced0e485e277ed27b8", "filename": "crates/server/src/main_loop/handlers.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/47cbaeba6f21e59ee8735bfe8bcbf06300767b57/crates%2Fserver%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cbaeba6f21e59ee8735bfe8bcbf06300767b57/crates%2Fserver%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=47cbaeba6f21e59ee8735bfe8bcbf06300767b57", "patch": "@@ -141,14 +141,18 @@ pub fn handle_workspace_symbol(\n     token: JobToken,\n ) -> Result<Option<Vec<SymbolInformation>>> {\n     let all_symbols = params.query.contains(\"#\");\n+    let libs = params.query.contains(\"*\");\n     let query = {\n         let query: String = params.query.chars()\n-            .filter(|&c| c != '#')\n+            .filter(|&c| c != '#' && c != '*')\n             .collect();\n         let mut q = Query::new(query);\n         if !all_symbols {\n             q.only_types();\n         }\n+        if libs {\n+            q.libs();\n+        }\n         q.limit(128);\n         q\n     };"}, {"sha": "ce61265a29df1caccc04822d4c178f0e4d4e891f", "filename": "crates/server/src/main_loop/mod.rs", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/47cbaeba6f21e59ee8735bfe8bcbf06300767b57/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cbaeba6f21e59ee8735bfe8bcbf06300767b57/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs?ref=47cbaeba6f21e59ee8735bfe8bcbf06300767b57", "patch": "@@ -38,23 +38,24 @@ pub fn main_loop(\n ) -> Result<()> {\n     let pool = ThreadPool::new(4);\n     let (task_sender, task_receiver) = bounded::<Task>(16);\n-    let (fs_events_receiver, watcher) = vfs::watch(vec![root.clone()]);\n-    let (ws_root_sender, ws_receiver, ws_watcher) = workspace_loader();\n-    ws_root_sender.send(root);\n+    let (fs_sender, fs_receiver, fs_watcher) = vfs::roots_loader();\n+    let (ws_sender, ws_receiver, ws_watcher) = workspace_loader();\n \n     info!(\"server initialized, serving requests\");\n     let mut state = ServerWorldState::new();\n \n     let mut pending_requests = HashMap::new();\n     let mut subs = Subscriptions::new();\n     let main_res = main_loop_inner(\n+        root,\n         &pool,\n-        msg_receriver,\n         msg_sender,\n-        task_receiver.clone(),\n+        msg_receriver,\n         task_sender,\n-        fs_events_receiver,\n-        ws_root_sender,\n+        task_receiver.clone(),\n+        fs_sender,\n+        fs_receiver,\n+        ws_sender,\n         ws_receiver,\n         &mut state,\n         &mut pending_requests,\n@@ -68,38 +69,40 @@ pub fn main_loop(\n     pool.join();\n     info!(\"...threadpool has finished\");\n \n-    let vfs_res = watcher.stop();\n+    let fs_res = fs_watcher.stop();\n     let ws_res = ws_watcher.stop();\n \n     main_res?;\n-    vfs_res?;\n+    fs_res?;\n     ws_res?;\n \n     Ok(())\n }\n \n fn main_loop_inner(\n+    ws_root: PathBuf,\n     pool: &ThreadPool,\n-    msg_receiver: &mut Receiver<RawMessage>,\n     msg_sender: &mut Sender<RawMessage>,\n-    task_receiver: Receiver<Task>,\n+    msg_receiver: &mut Receiver<RawMessage>,\n     task_sender: Sender<Task>,\n-    fs_receiver: Receiver<Vec<FileEvent>>,\n-    _ws_roots_sender: Sender<PathBuf>,\n+    task_receiver: Receiver<Task>,\n+    fs_sender: Sender<PathBuf>,\n+    fs_receiver: Receiver<(PathBuf, Vec<FileEvent>)>,\n+    ws_sender: Sender<PathBuf>,\n     ws_receiver: Receiver<Result<CargoWorkspace>>,\n     state: &mut ServerWorldState,\n     pending_requests: &mut HashMap<u64, JobHandle>,\n     subs: &mut Subscriptions,\n ) -> Result<()> {\n-    let mut fs_receiver = Some(fs_receiver);\n+    ws_sender.send(ws_root.clone());\n+    fs_sender.send(ws_root.clone());\n     loop {\n         #[derive(Debug)]\n         enum Event {\n             Msg(RawMessage),\n             Task(Task),\n-            Fs(Vec<FileEvent>),\n+            Fs(PathBuf, Vec<FileEvent>),\n             Ws(Result<CargoWorkspace>),\n-            FsWatcherDead,\n         }\n         trace!(\"selecting\");\n         let event = select! {\n@@ -109,8 +112,8 @@ fn main_loop_inner(\n             },\n             recv(task_receiver, task) => Event::Task(task.unwrap()),\n             recv(fs_receiver, events) => match events {\n-                Some(events) => Event::Fs(events),\n-                None => Event::FsWatcherDead,\n+                None => bail!(\"roots watcher died\"),\n+                Some((pb, events)) => Event::Fs(pb, events),\n             }\n             recv(ws_receiver, ws) => match ws {\n                 None => bail!(\"workspace watcher died\"),\n@@ -120,19 +123,30 @@ fn main_loop_inner(\n         trace!(\"selected {:?}\", event);\n         let mut state_changed = false;\n         match event {\n-            Event::FsWatcherDead => fs_receiver = None,\n             Event::Task(task) => on_task(task, msg_sender, pending_requests),\n-            Event::Fs(events) => {\n-                trace!(\"fs change, {} events\", events.len());\n-                state.apply_fs_changes(events);\n+            Event::Fs(root, events) => {\n+                info!(\"fs change, {}, {} events\", root.display(), events.len());\n+                if root == ws_root {\n+                    state.apply_fs_changes(events);\n+                } else {\n+                    state.add_library(events);\n+                }\n                 state_changed = true;\n             }\n             Event::Ws(ws) => {\n                 match ws {\n                     Ok(ws) => {\n-                        let not = RawNotification::new::<req::DidReloadWorkspace>(&vec![ws.clone()]);\n+                        let workspaces = vec![ws];\n+                        let not = RawNotification::new::<req::DidReloadWorkspace>(&workspaces);\n                         msg_sender.send(RawMessage::Notification(not));\n-                        state.set_workspaces(vec![ws]);\n+                        for ws in workspaces.iter() {\n+                            for pkg in ws.packages().filter(|pkg| !pkg.is_member(ws)) {\n+                                debug!(\"sending root, {}\", pkg.root(ws).to_path_buf().display());\n+                                // deadlocky :-(\n+                                fs_sender.send(pkg.root(ws).to_path_buf());\n+                            }\n+                        }\n+                        state.set_workspaces(workspaces);\n                         state_changed = true;\n                     }\n                     Err(e) => warn!(\"loading workspace failed: {}\", e),"}, {"sha": "517836e624a62ca3e5c704bd0091ecb418e15f37", "filename": "crates/server/src/project_model.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/47cbaeba6f21e59ee8735bfe8bcbf06300767b57/crates%2Fserver%2Fsrc%2Fproject_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cbaeba6f21e59ee8735bfe8bcbf06300767b57/crates%2Fserver%2Fsrc%2Fproject_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fproject_model.rs?ref=47cbaeba6f21e59ee8735bfe8bcbf06300767b57", "patch": "@@ -1,5 +1,5 @@\n use std::{\n-    collections::HashMap,\n+    collections::{HashMap, HashSet},\n     path::{Path, PathBuf},\n };\n use cargo_metadata::{metadata_run, CargoOpt};\n@@ -13,7 +13,6 @@ use {\n \n #[derive(Debug, Serialize, Clone)]\n pub struct CargoWorkspace {\n-    ws_members: Vec<Package>,\n     packages: Vec<PackageData>,\n     targets: Vec<TargetData>,\n }\n@@ -27,7 +26,8 @@ pub struct Target(usize);\n struct PackageData {\n     name: SmolStr,\n     manifest: PathBuf,\n-    targets: Vec<Target>\n+    targets: Vec<Target>,\n+    is_member: bool,\n }\n \n #[derive(Debug, Serialize, Clone)]\n@@ -50,9 +50,15 @@ impl Package {\n     pub fn manifest(self, ws: &CargoWorkspace) -> &Path {\n         ws.pkg(self).manifest.as_path()\n     }\n+    pub fn root(self, ws: &CargoWorkspace) -> &Path {\n+        ws.pkg(self).manifest.parent().unwrap()\n+    }\n     pub fn targets<'a>(self, ws: &'a CargoWorkspace) -> impl Iterator<Item=Target> + 'a {\n         ws.pkg(self).targets.iter().cloned()\n     }\n+    pub fn is_member(self, ws: &CargoWorkspace) -> bool {\n+        ws.pkg(self).is_member\n+    }\n }\n \n impl Target {\n@@ -81,13 +87,21 @@ impl CargoWorkspace {\n         let mut pkg_by_id = HashMap::new();\n         let mut packages = Vec::new();\n         let mut targets = Vec::new();\n+\n+        let ws_members: HashSet<String> = meta.workspace_members\n+            .into_iter()\n+            .map(|it| it.raw)\n+            .collect();\n+\n         for meta_pkg in meta.packages {\n             let pkg = Package(packages.len());\n+            let is_member = ws_members.contains(&meta_pkg.id);\n             pkg_by_id.insert(meta_pkg.id.clone(), pkg);\n             let mut pkg_data = PackageData {\n                 name: meta_pkg.name.into(),\n                 manifest: PathBuf::from(meta_pkg.manifest_path),\n                 targets: Vec::new(),\n+                is_member,\n             };\n             for meta_tgt in meta_pkg.targets {\n                 let tgt = Target(targets.len());\n@@ -101,19 +115,12 @@ impl CargoWorkspace {\n             }\n             packages.push(pkg_data)\n         }\n-        let ws_members = meta.workspace_members\n-            .iter()\n-            .map(|it| pkg_by_id[&it.raw])\n-            .collect();\n \n-        Ok(CargoWorkspace { packages, targets, ws_members })\n+        Ok(CargoWorkspace { packages, targets })\n     }\n     pub fn packages<'a>(&'a self) -> impl Iterator<Item=Package> + 'a {\n         (0..self.packages.len()).map(Package)\n     }\n-    pub fn ws_members<'a>(&'a self) -> impl Iterator<Item=Package> + 'a {\n-        self.ws_members.iter().cloned()\n-    }\n     pub fn target_by_root(&self, root: &Path) -> Option<Target> {\n         self.packages()\n             .filter_map(|pkg| pkg.targets(self).find(|it| it.root(self) == root))"}, {"sha": "95c109e102f80e947a7053153f7d00d6bd74ed1f", "filename": "crates/server/src/server_world.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/47cbaeba6f21e59ee8735bfe8bcbf06300767b57/crates%2Fserver%2Fsrc%2Fserver_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cbaeba6f21e59ee8735bfe8bcbf06300767b57/crates%2Fserver%2Fsrc%2Fserver_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fserver_world.rs?ref=47cbaeba6f21e59ee8735bfe8bcbf06300767b57", "patch": "@@ -47,7 +47,6 @@ impl ServerWorldState {\n             .map(|event| {\n                 let text = match event.kind {\n                     FileEventKind::Add(text) => Some(text),\n-                    FileEventKind::Remove => None,\n                 };\n                 (event.path, text)\n             })\n@@ -65,6 +64,18 @@ impl ServerWorldState {\n \n         self.analysis_host.change_files(changes);\n     }\n+    pub fn add_library(&mut self, events: Vec<FileEvent>) {\n+        let pm = &mut self.path_map;\n+        let files = events.into_iter()\n+            .map(|event| {\n+                let text = match event.kind {\n+                    FileEventKind::Add(text) => text,\n+                };\n+                (event.path, text)\n+            })\n+            .map(|(path, text)| (pm.get_or_insert(path), text));\n+        self.analysis_host.add_library(files);\n+    }\n \n     pub fn add_mem_file(&mut self, path: PathBuf, text: String) -> FileId {\n         let file_id = self.path_map.get_or_insert(path);"}, {"sha": "69a7654af21e01a1f70d857fcbf3339849ada7c9", "filename": "crates/server/src/vfs.rs", "status": "modified", "additions": 42, "deletions": 34, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/47cbaeba6f21e59ee8735bfe8bcbf06300767b57/crates%2Fserver%2Fsrc%2Fvfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cbaeba6f21e59ee8735bfe8bcbf06300767b57/crates%2Fserver%2Fsrc%2Fvfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fvfs.rs?ref=47cbaeba6f21e59ee8735bfe8bcbf06300767b57", "patch": "@@ -1,5 +1,5 @@\n use std::{\n-    path::PathBuf,\n+    path::{PathBuf, Path},\n     fs,\n };\n \n@@ -20,46 +20,54 @@ pub struct FileEvent {\n #[derive(Debug)]\n pub enum FileEventKind {\n     Add(String),\n-    #[allow(unused)]\n-    Remove,\n }\n \n-pub fn watch(roots: Vec<PathBuf>) -> (Receiver<Vec<FileEvent>>, ThreadWatcher) {\n-    let (sender, receiver) = bounded(16);\n-    let watcher = ThreadWatcher::spawn(\"vfs\", move || run(roots, sender));\n-    (receiver, watcher)\n+pub fn roots_loader() -> (Sender<PathBuf>, Receiver<(PathBuf, Vec<FileEvent>)>, ThreadWatcher) {\n+    let (path_sender, path_receiver) = bounded::<PathBuf>(2048);\n+    let (event_sender, event_receiver) = bounded::<(PathBuf, Vec<FileEvent>)>(1);\n+    let thread = ThreadWatcher::spawn(\"roots loader\", move || {\n+        path_receiver\n+            .into_iter()\n+            .map(|path| {\n+                debug!(\"loading {} ...\", path.as_path().display());\n+                let events = load_root(path.as_path());\n+                debug!(\"... loaded {}\", path.as_path().display());\n+                (path, events)\n+            })\n+            .for_each(|it| event_sender.send(it))\n+    });\n+\n+    (path_sender, event_receiver, thread)\n }\n \n-fn run(roots: Vec<PathBuf>, sender: Sender<Vec<FileEvent>>) {\n-    for root in roots {\n-        let mut events = Vec::new();\n-        for entry in WalkDir::new(root.as_path()) {\n-            let entry = match entry {\n-                Ok(entry) => entry,\n-                Err(e) => {\n-                    warn!(\"watcher error: {}\", e);\n-                    continue;\n-                }\n-            };\n-            if !entry.file_type().is_file() {\n+fn load_root(path: &Path) -> Vec<FileEvent> {\n+    let mut res = Vec::new();\n+    for entry in WalkDir::new(path) {\n+        let entry = match entry {\n+            Ok(entry) => entry,\n+            Err(e) => {\n+                warn!(\"watcher error: {}\", e);\n                 continue;\n             }\n-            let path = entry.path();\n-            if path.extension().and_then(|os| os.to_str()) != Some(\"rs\") {\n+        };\n+        if !entry.file_type().is_file() {\n+            continue;\n+        }\n+        let path = entry.path();\n+        if path.extension().and_then(|os| os.to_str()) != Some(\"rs\") {\n+            continue;\n+        }\n+        let text = match fs::read_to_string(path) {\n+            Ok(text) => text,\n+            Err(e) => {\n+                warn!(\"watcher error: {}\", e);\n                 continue;\n             }\n-            let text = match fs::read_to_string(path) {\n-                Ok(text) => text,\n-                Err(e) => {\n-                    warn!(\"watcher error: {}\", e);\n-                    continue;\n-                }\n-            };\n-            events.push(FileEvent {\n-                path: path.to_owned(),\n-                kind: FileEventKind::Add(text),\n-            })\n-        }\n-        sender.send(events)\n+        };\n+        res.push(FileEvent {\n+            path: path.to_owned(),\n+            kind: FileEventKind::Add(text),\n+        })\n     }\n+    res\n }"}]}