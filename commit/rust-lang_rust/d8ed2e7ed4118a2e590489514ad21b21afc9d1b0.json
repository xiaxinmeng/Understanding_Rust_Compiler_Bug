{"sha": "d8ed2e7ed4118a2e590489514ad21b21afc9d1b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4ZWQyZTdlZDQxMThhMmU1OTA0ODk1MTRhZDIxYjIxYWZjOWQxYjA=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-06-29T01:41:53Z"}, "committer": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-06-29T01:42:06Z"}, "message": "Use RequiresStorage to determine which locals can overlap", "tree": {"sha": "109dd57dfb448c1eadcb6271e1c617983c715e45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/109dd57dfb448c1eadcb6271e1c617983c715e45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8ed2e7ed4118a2e590489514ad21b21afc9d1b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8ed2e7ed4118a2e590489514ad21b21afc9d1b0", "html_url": "https://github.com/rust-lang/rust/commit/d8ed2e7ed4118a2e590489514ad21b21afc9d1b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8ed2e7ed4118a2e590489514ad21b21afc9d1b0/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aee13574f2a31f5e8b6293a06de2622e554c7172", "url": "https://api.github.com/repos/rust-lang/rust/commits/aee13574f2a31f5e8b6293a06de2622e554c7172", "html_url": "https://github.com/rust-lang/rust/commit/aee13574f2a31f5e8b6293a06de2622e554c7172"}], "stats": {"total": 53, "additions": 33, "deletions": 20}, "files": [{"sha": "ad8b3f5fdbec160259cfc416bb576fd24af0eafd", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8ed2e7ed4118a2e590489514ad21b21afc9d1b0/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8ed2e7ed4118a2e590489514ad21b21afc9d1b0/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=d8ed2e7ed4118a2e590489514ad21b21afc9d1b0", "patch": "@@ -72,10 +72,6 @@ impl<'a, 'tcx> BottomValue for MaybeStorageLive<'a, 'tcx> {\n \n /// Dataflow analysis that determines whether each local requires storage at a\n /// given location; i.e. whether its storage can go away without being observed.\n-///\n-/// In the case of a movable generator, borrowed_locals can be `None` and we\n-/// will not consider borrows in this pass. This relies on the fact that we only\n-/// use this pass at yield points for these generators.\n pub struct RequiresStorage<'mir, 'tcx, 'b> {\n     body: &'mir Body<'tcx>,\n     borrowed_locals:"}, {"sha": "e16477cf2fd0b953ef56397463002ae2ac77e13e", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d8ed2e7ed4118a2e590489514ad21b21afc9d1b0/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8ed2e7ed4118a2e590489514ad21b21afc9d1b0/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=d8ed2e7ed4118a2e590489514ad21b21afc9d1b0", "patch": "@@ -62,6 +62,7 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::bit_set::{BitSet, BitMatrix};\n use std::borrow::Cow;\n use std::iter;\n+use std::marker::PhantomData;\n use std::mem;\n use crate::transform::{MirPass, MirSource};\n use crate::transform::simplify;\n@@ -539,8 +540,8 @@ fn locals_live_across_suspend_points(\n         body,\n         &live_locals,\n         &ignored,\n-        storage_live,\n-        storage_live_analysis);\n+        requires_storage,\n+        requires_storage_analysis);\n \n     LivenessInfo {\n         live_locals,\n@@ -577,8 +578,8 @@ fn compute_storage_conflicts(\n     body: &'mir Body<'tcx>,\n     stored_locals: &liveness::LiveVarSet,\n     ignored: &StorageIgnored,\n-    storage_live: DataflowResults<'tcx, MaybeStorageLive<'mir, 'tcx>>,\n-    _storage_live_analysis: MaybeStorageLive<'mir, 'tcx>,\n+    requires_storage: DataflowResults<'tcx, RequiresStorage<'mir, 'tcx, '_>>,\n+    _requires_storage_analysis: RequiresStorage<'mir, 'tcx, '_>,\n ) -> BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal> {\n     assert_eq!(body.local_decls.len(), ignored.0.domain_size());\n     assert_eq!(body.local_decls.len(), stored_locals.domain_size());\n@@ -594,9 +595,10 @@ fn compute_storage_conflicts(\n     let mut visitor = StorageConflictVisitor {\n         body,\n         stored_locals: &stored_locals,\n-        local_conflicts: BitMatrix::from_row_n(&ineligible_locals, body.local_decls.len())\n+        local_conflicts: BitMatrix::from_row_n(&ineligible_locals, body.local_decls.len()),\n+        _phantom: PhantomData::default(),\n     };\n-    let mut state = FlowAtLocation::new(storage_live);\n+    let mut state = FlowAtLocation::new(requires_storage);\n     visitor.analyze_results(&mut state);\n     let local_conflicts = visitor.local_conflicts;\n \n@@ -626,18 +628,19 @@ fn compute_storage_conflicts(\n     storage_conflicts\n }\n \n-struct StorageConflictVisitor<'body, 'tcx, 's> {\n+struct StorageConflictVisitor<'body: 'b, 'tcx, 's, 'b> {\n     body: &'body Body<'tcx>,\n     stored_locals: &'s liveness::LiveVarSet,\n     // FIXME(tmandry): Consider using sparse bitsets here once we have good\n     // benchmarks for generators.\n     local_conflicts: BitMatrix<Local, Local>,\n+    _phantom: PhantomData<&'b ()>,\n }\n \n-impl<'body, 'tcx, 's> DataflowResultsConsumer<'body, 'tcx>\n-    for StorageConflictVisitor<'body, 'tcx, 's>\n+impl<'body, 'tcx, 's, 'b> DataflowResultsConsumer<'body, 'tcx>\n+    for StorageConflictVisitor<'body, 'tcx, 's, 'b>\n {\n-    type FlowState = FlowAtLocation<'tcx, MaybeStorageLive<'body, 'tcx>>;\n+    type FlowState = FlowAtLocation<'tcx, RequiresStorage<'body, 'tcx, 'b>>;\n \n     fn body(&self) -> &'body Body<'tcx> {\n         self.body\n@@ -665,9 +668,9 @@ impl<'body, 'tcx, 's> DataflowResultsConsumer<'body, 'tcx>\n     }\n }\n \n-impl<'body, 'tcx, 's> StorageConflictVisitor<'body, 'tcx, 's> {\n+impl<'body, 'tcx, 's, 'b> StorageConflictVisitor<'body, 'tcx, 's, 'b> {\n     fn apply_state(&mut self,\n-                   flow_state: &FlowAtLocation<'tcx, MaybeStorageLive<'body, 'tcx>>,\n+                   flow_state: &FlowAtLocation<'tcx, RequiresStorage<'body, 'tcx, 'b>>,\n                    loc: Location) {\n         // Ignore unreachable blocks.\n         match self.body.basic_blocks()[loc.block].terminator().kind {"}, {"sha": "37e2e0cfdcccf2de257fc22527810a6ff11ffc6e", "filename": "src/test/run-pass/generator/size-moved-locals.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d8ed2e7ed4118a2e590489514ad21b21afc9d1b0/src%2Ftest%2Frun-pass%2Fgenerator%2Fsize-moved-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8ed2e7ed4118a2e590489514ad21b21afc9d1b0/src%2Ftest%2Frun-pass%2Fgenerator%2Fsize-moved-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fsize-moved-locals.rs?ref=d8ed2e7ed4118a2e590489514ad21b21afc9d1b0", "patch": "@@ -21,7 +21,7 @@ impl Drop for Foo {\n     fn drop(&mut self) {}\n }\n \n-fn simple() -> impl Generator<Yield = (), Return = ()> {\n+fn move_before_yield() -> impl Generator<Yield = (), Return = ()> {\n     static || {\n         let first = Foo([0; FOO_SIZE]);\n         let _second = first;\n@@ -32,7 +32,7 @@ fn simple() -> impl Generator<Yield = (), Return = ()> {\n \n fn noop() {}\n \n-fn complex() -> impl Generator<Yield = (), Return = ()> {\n+fn move_before_yield_with_noop() -> impl Generator<Yield = (), Return = ()> {\n     static || {\n         let first = Foo([0; FOO_SIZE]);\n         noop();\n@@ -42,7 +42,21 @@ fn complex() -> impl Generator<Yield = (), Return = ()> {\n     }\n }\n \n+// Today we don't have NRVO (we allocate space for both `first` and `second`,)\n+// but we can overlap `first` with `_third`.\n+fn overlap_move_points() -> impl Generator<Yield = (), Return = ()> {\n+    static || {\n+        let first = Foo([0; FOO_SIZE]);\n+        yield;\n+        let second = first;\n+        yield;\n+        let _third = second;\n+        yield;\n+    }\n+}\n+\n fn main() {\n-    assert_eq!(1028, std::mem::size_of_val(&simple()));\n-    assert_eq!(1032, std::mem::size_of_val(&complex()));\n+    assert_eq!(1028, std::mem::size_of_val(&move_before_yield()));\n+    assert_eq!(1032, std::mem::size_of_val(&move_before_yield_with_noop()));\n+    assert_eq!(2056, std::mem::size_of_val(&overlap_move_points()));\n }"}]}