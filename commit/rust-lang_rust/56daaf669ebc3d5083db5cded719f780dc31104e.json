{"sha": "56daaf669ebc3d5083db5cded719f780dc31104e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2ZGFhZjY2OWViYzNkNTA4M2RiNWNkZWQ3MTlmNzgwZGMzMTEwNGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-03T16:06:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-03T16:06:30Z"}, "message": "Auto merge of #72948 - Dylan-DPC:rollup-fazhw00, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #72586 (split select into submodules)\n - #72900 (Don't count pathless --extern for unused-crate-dependencies warnings)\n - #72924 (Stabilize `std::io::Buf{Reader, Writer}::capacity`)\n - #72942 (clean up E0641 explanation)\n - #72945 (Updated documentation for Control Flow Guard)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "1c21c92c86d7d575f56c3b887e83a7ca47876321", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c21c92c86d7d575f56c3b887e83a7ca47876321"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56daaf669ebc3d5083db5cded719f780dc31104e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56daaf669ebc3d5083db5cded719f780dc31104e", "html_url": "https://github.com/rust-lang/rust/commit/56daaf669ebc3d5083db5cded719f780dc31104e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56daaf669ebc3d5083db5cded719f780dc31104e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f4888845674837fd4b55adb66d9322e1973d7db", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f4888845674837fd4b55adb66d9322e1973d7db", "html_url": "https://github.com/rust-lang/rust/commit/6f4888845674837fd4b55adb66d9322e1973d7db"}, {"sha": "b61f3bb66b0b3a6646ef5435af12c6de3965b90c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b61f3bb66b0b3a6646ef5435af12c6de3965b90c", "html_url": "https://github.com/rust-lang/rust/commit/b61f3bb66b0b3a6646ef5435af12c6de3965b90c"}], "stats": {"total": 2929, "additions": 1497, "deletions": 1432}, "files": [{"sha": "48dea213e8cee040f5d8427ac08273dfe9b5862f", "filename": "src/doc/unstable-book/src/compiler-flags/control-flow-guard.md", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/56daaf669ebc3d5083db5cded719f780dc31104e/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcontrol-flow-guard.md", "raw_url": "https://github.com/rust-lang/rust/raw/56daaf669ebc3d5083db5cded719f780dc31104e/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcontrol-flow-guard.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcontrol-flow-guard.md?ref=56daaf669ebc3d5083db5cded719f780dc31104e", "patch": "@@ -4,30 +4,54 @@ The tracking issue for this feature is: [#68793](https://github.com/rust-lang/ru\n \n ------------------------\n \n-The `-Zcontrol_flow_guard=checks` compiler flag enables the Windows [Control Flow Guard][cfguard-docs] platform security feature. When enabled, the compiler outputs a list of valid indirect call targets, and inserts runtime checks on all indirect jump instructions to ensure that the destination is in the list of valid call targets.\n+The rustc flag `-Z control_flow_guard=checks` enables the Windows [Control Flow Guard](https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard) (CFG) platform security feature.\n \n-[cfguard-docs]: https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard\n+CFG is an exploit mitigation designed to enforce control-flow integrity for software running on supported Windows platforms (Windows 8.1 onwards). Specifically, CFG uses runtime checks to validate the target address of every indirect call/jump before allowing the call to complete. \n \n-For testing purposes, the `-Zcontrol_flow_guard=nochecks` compiler flag can be used to emit only the list of valid call targets, but not the runtime checks.\n+During compilation, the compiler identifies all indirect calls/jumps and adds CFG checks. It also emits metadata containing the relative addresses of all address-taken functions. At runtime, if the binary is run on a CFG-aware operating system, the loader uses the CFG metadata to generate a bitmap of the address space and marks those addresses that contain valid targets. On each indirect call, the inserted check determines whether the target address is marked in this bitmap. If the target is not valid, the process is terminated.\n \n-It is strongly recommended to also enable Control Flow Guard checks in all linked libraries, including the standard library. \n+In terms of interoperability:\n+- Code compiled with CFG enabled can be linked with libraries and object files that are not compiled with CFG. In this case, a CFG-aware linker can identify address-taken functions in the non-CFG libraries.\n+- Libraries compiled with CFG can linked into non-CFG programs. In this case, the CFG runtime checks in the libraries are not used (i.e. the mitigation is completely disabled).\n \n-To enable Control Flow Guard in the standard library, you can use the [cargo `-Zbuild-std` functionality][build-std] to recompile the standard library with the same configuration options as the main program. \n+CFG functionality is completely implemented in the LLVM backend and is supported for X86 (32-bit and 64-bit), ARM, and Aarch64 targets. The rustc flag adds the relevant LLVM module flags to enable the feature. This flag will be ignored for all non-Windows targets.\n+\n+\n+## When to use Control Flow Guard\n+\n+The primary motivation for enabling CFG in Rust is to enhance security when linking against non-Rust code, especially C/C++ code. To achieve full CFG protection, all indirect calls (including any from Rust code) must have the appropriate CFG checks, as added by this flag. CFG can also improve security for Rust code that uses the `unsafe` keyword\n+\n+\n+## Overhead of Control Flow Guard\n+\n+The CFG checks and metadata can potentially increase binary size and runtime overhead. The magnitude of any increase depends on the number and frequency of indirect calls. For example, enabling CFG for the Rust standard library increases binary size by approximately 0.14%. Enabling CFG in the SPEC CPU 2017 Integer Speed benchmark suite (compiled with Clang/LLVM) incurs approximate runtime overheads of between 0% and 8%, with a geometric mean of 2.9%.\n+\n+\n+## Testing Control Flow Guard\n+\n+The rustc flag `-Z control_flow_guard=nochecks` instructs LLVM to emit the list of valid call targets without inserting runtime checks. This flag should only be used for testing purposes as it does not provide security enforcement.\n+\n+\n+## Control Flow Guard in libraries\n+\n+It is strongly recommended to also enable CFG checks for all linked libraries, including the standard library. \n+\n+To enable CFG in the standard library, use the [cargo `-Z build-std` functionality][build-std] to recompile the standard library with the same configuration options as the main program.\n \n [build-std]: https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-std\n \n For example:\n ```cmd\n rustup toolchain install --force nightly\n rustup component add rust-src\n-SET RUSTFLAGS=-Zcontrol_flow_guard=checks\n+SET RUSTFLAGS=-Z control_flow_guard=checks\n cargo +nightly build -Z build-std --target x86_64-pc-windows-msvc\n ```\n \n ```PowerShell\n rustup toolchain install --force nightly\n rustup component add rust-src\n-$Env:RUSTFLAGS = \"-Zcontrol_flow_guard=checks\"\n+$Env:RUSTFLAGS = \"-Z control_flow_guard=checks\"\n cargo +nightly build -Z build-std --target x86_64-pc-windows-msvc\n ```\n "}, {"sha": "5848e9b5c05ca60700d71fca68cc4a00acfe3f30", "filename": "src/librustc_error_codes/error_codes/E0641.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/56daaf669ebc3d5083db5cded719f780dc31104e/src%2Flibrustc_error_codes%2Ferror_codes%2FE0641.md", "raw_url": "https://github.com/rust-lang/rust/raw/56daaf669ebc3d5083db5cded719f780dc31104e/src%2Flibrustc_error_codes%2Ferror_codes%2FE0641.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0641.md?ref=56daaf669ebc3d5083db5cded719f780dc31104e", "patch": "@@ -1,19 +1,19 @@\n Attempted to cast to/from a pointer with an unknown kind.\n \n-Erroneous code examples:\n+Erroneous code example:\n \n ```compile_fail,E0641\n let b = 0 as *const _; // error\n ```\n \n-Must give information for type of pointer that is being cast from/to if the\n-type cannot be inferred.\n+Type information must be provided if a pointer type being cast from/into another\n+type which cannot be inferred:\n \n ```\n // Creating a pointer from reference: type can be inferred\n-let a = &(String::from(\"Hello world!\")) as *const _; // Ok\n+let a = &(String::from(\"Hello world!\")) as *const _; // ok!\n \n-let b = 0 as *const i32; // Ok\n+let b = 0 as *const i32; // ok!\n \n-let c: *const i32 = 0 as *const _; // Ok\n+let c: *const i32 = 0 as *const _; // ok!\n ```"}, {"sha": "7e902f0ade2eff6109c27a0f29d0d73f32ca464e", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/56daaf669ebc3d5083db5cded719f780dc31104e/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56daaf669ebc3d5083db5cded719f780dc31104e/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=56daaf669ebc3d5083db5cded719f780dc31104e", "patch": "@@ -18,7 +18,7 @@ use rustc_middle::middle::cstore::{\n     CrateSource, ExternCrate, ExternCrateSource, MetadataLoaderDyn,\n };\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config::{self, CrateType};\n+use rustc_session::config::{self, CrateType, ExternLocation};\n use rustc_session::lint;\n use rustc_session::output::validate_crate_name;\n use rustc_session::search_paths::PathKind;\n@@ -850,7 +850,11 @@ impl<'a> CrateLoader<'a> {\n         // Make a point span rather than covering the whole file\n         let span = krate.span.shrink_to_lo();\n         // Complain about anything left over\n-        for (name, _) in self.sess.opts.externs.iter() {\n+        for (name, entry) in self.sess.opts.externs.iter() {\n+            if let ExternLocation::FoundInLibrarySearchDirectories = entry.location {\n+                // Don't worry about pathless `--extern foo` sysroot references\n+                continue;\n+            }\n             if !self.used_extern_options.contains(&Symbol::intern(name)) {\n                 self.sess.parse_sess.buffer_lint(\n                     lint::builtin::UNUSED_CRATE_DEPENDENCIES,"}, {"sha": "d42c31a5474b2a365f9043929e9543f55feef725", "filename": "src/librustc_trait_selection/traits/select/candidate_assembly.rs", "status": "added", "additions": 611, "deletions": 0, "changes": 611, "blob_url": "https://github.com/rust-lang/rust/blob/56daaf669ebc3d5083db5cded719f780dc31104e/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56daaf669ebc3d5083db5cded719f780dc31104e/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=56daaf669ebc3d5083db5cded719f780dc31104e", "patch": "@@ -0,0 +1,611 @@\n+//! Candidate assembly.\n+//!\n+//! The selection process begins by examining all in-scope impls,\n+//! caller obligations, and so forth and assembling a list of\n+//! candidates. See the [rustc dev guide] for more details.\n+//!\n+//! [rustc dev guide]:https://rustc-dev-guide.rust-lang.org/traits/resolution.html#candidate-assembly\n+use rustc_hir as hir;\n+use rustc_infer::traits::{Obligation, SelectionError, TraitObligation};\n+use rustc_middle::ty::{self, TypeFoldable};\n+use rustc_target::spec::abi::Abi;\n+\n+use crate::traits::{util, SelectionResult};\n+\n+use super::BuiltinImplConditions;\n+use super::SelectionCandidate::{self, *};\n+use super::{SelectionCandidateSet, SelectionContext, TraitObligationStack};\n+\n+impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n+    pub(super) fn candidate_from_obligation<'o>(\n+        &mut self,\n+        stack: &TraitObligationStack<'o, 'tcx>,\n+    ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n+        // Watch out for overflow. This intentionally bypasses (and does\n+        // not update) the cache.\n+        self.check_recursion_limit(&stack.obligation, &stack.obligation)?;\n+\n+        // Check the cache. Note that we freshen the trait-ref\n+        // separately rather than using `stack.fresh_trait_ref` --\n+        // this is because we want the unbound variables to be\n+        // replaced with fresh types starting from index 0.\n+        let cache_fresh_trait_pred = self.infcx.freshen(stack.obligation.predicate);\n+        debug!(\n+            \"candidate_from_obligation(cache_fresh_trait_pred={:?}, obligation={:?})\",\n+            cache_fresh_trait_pred, stack\n+        );\n+        debug_assert!(!stack.obligation.predicate.has_escaping_bound_vars());\n+\n+        if let Some(c) =\n+            self.check_candidate_cache(stack.obligation.param_env, cache_fresh_trait_pred)\n+        {\n+            debug!(\"CACHE HIT: SELECT({:?})={:?}\", cache_fresh_trait_pred, c);\n+            return c;\n+        }\n+\n+        // If no match, compute result and insert into cache.\n+        //\n+        // FIXME(nikomatsakis) -- this cache is not taking into\n+        // account cycles that may have occurred in forming the\n+        // candidate. I don't know of any specific problems that\n+        // result but it seems awfully suspicious.\n+        let (candidate, dep_node) =\n+            self.in_task(|this| this.candidate_from_obligation_no_cache(stack));\n+\n+        debug!(\"CACHE MISS: SELECT({:?})={:?}\", cache_fresh_trait_pred, candidate);\n+        self.insert_candidate_cache(\n+            stack.obligation.param_env,\n+            cache_fresh_trait_pred,\n+            dep_node,\n+            candidate.clone(),\n+        );\n+        candidate\n+    }\n+\n+    pub(super) fn assemble_candidates<'o>(\n+        &mut self,\n+        stack: &TraitObligationStack<'o, 'tcx>,\n+    ) -> Result<SelectionCandidateSet<'tcx>, SelectionError<'tcx>> {\n+        let TraitObligationStack { obligation, .. } = *stack;\n+        let obligation = &Obligation {\n+            param_env: obligation.param_env,\n+            cause: obligation.cause.clone(),\n+            recursion_depth: obligation.recursion_depth,\n+            predicate: self.infcx().resolve_vars_if_possible(&obligation.predicate),\n+        };\n+\n+        if obligation.predicate.skip_binder().self_ty().is_ty_var() {\n+            // Self is a type variable (e.g., `_: AsRef<str>`).\n+            //\n+            // This is somewhat problematic, as the current scheme can't really\n+            // handle it turning to be a projection. This does end up as truly\n+            // ambiguous in most cases anyway.\n+            //\n+            // Take the fast path out - this also improves\n+            // performance by preventing assemble_candidates_from_impls from\n+            // matching every impl for this trait.\n+            return Ok(SelectionCandidateSet { vec: vec![], ambiguous: true });\n+        }\n+\n+        let mut candidates = SelectionCandidateSet { vec: Vec::new(), ambiguous: false };\n+\n+        self.assemble_candidates_for_trait_alias(obligation, &mut candidates)?;\n+\n+        // Other bounds. Consider both in-scope bounds from fn decl\n+        // and applicable impls. There is a certain set of precedence rules here.\n+        let def_id = obligation.predicate.def_id();\n+        let lang_items = self.tcx().lang_items();\n+\n+        if lang_items.copy_trait() == Some(def_id) {\n+            debug!(\"obligation self ty is {:?}\", obligation.predicate.skip_binder().self_ty());\n+\n+            // User-defined copy impls are permitted, but only for\n+            // structs and enums.\n+            self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n+\n+            // For other types, we'll use the builtin rules.\n+            let copy_conditions = self.copy_clone_conditions(obligation);\n+            self.assemble_builtin_bound_candidates(copy_conditions, &mut candidates)?;\n+        } else if lang_items.discriminant_kind_trait() == Some(def_id) {\n+            // `DiscriminantKind` is automatically implemented for every type.\n+            candidates.vec.push(DiscriminantKindCandidate);\n+        } else if lang_items.sized_trait() == Some(def_id) {\n+            // Sized is never implementable by end-users, it is\n+            // always automatically computed.\n+            let sized_conditions = self.sized_conditions(obligation);\n+            self.assemble_builtin_bound_candidates(sized_conditions, &mut candidates)?;\n+        } else if lang_items.unsize_trait() == Some(def_id) {\n+            self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n+        } else {\n+            if lang_items.clone_trait() == Some(def_id) {\n+                // Same builtin conditions as `Copy`, i.e., every type which has builtin support\n+                // for `Copy` also has builtin support for `Clone`, and tuples/arrays of `Clone`\n+                // types have builtin support for `Clone`.\n+                let clone_conditions = self.copy_clone_conditions(obligation);\n+                self.assemble_builtin_bound_candidates(clone_conditions, &mut candidates)?;\n+            }\n+\n+            self.assemble_generator_candidates(obligation, &mut candidates)?;\n+            self.assemble_closure_candidates(obligation, &mut candidates)?;\n+            self.assemble_fn_pointer_candidates(obligation, &mut candidates)?;\n+            self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n+            self.assemble_candidates_from_object_ty(obligation, &mut candidates);\n+        }\n+\n+        self.assemble_candidates_from_projected_tys(obligation, &mut candidates);\n+        self.assemble_candidates_from_caller_bounds(stack, &mut candidates)?;\n+        // Auto implementations have lower priority, so we only\n+        // consider triggering a default if there is no other impl that can apply.\n+        if candidates.vec.is_empty() {\n+            self.assemble_candidates_from_auto_impls(obligation, &mut candidates)?;\n+        }\n+        debug!(\"candidate list size: {}\", candidates.vec.len());\n+        Ok(candidates)\n+    }\n+\n+    fn assemble_candidates_from_projected_tys(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        candidates: &mut SelectionCandidateSet<'tcx>,\n+    ) {\n+        debug!(\"assemble_candidates_for_projected_tys({:?})\", obligation);\n+\n+        // Before we go into the whole placeholder thing, just\n+        // quickly check if the self-type is a projection at all.\n+        match obligation.predicate.skip_binder().trait_ref.self_ty().kind {\n+            ty::Projection(_) | ty::Opaque(..) => {}\n+            ty::Infer(ty::TyVar(_)) => {\n+                span_bug!(\n+                    obligation.cause.span,\n+                    \"Self=_ should have been handled by assemble_candidates\"\n+                );\n+            }\n+            _ => return,\n+        }\n+\n+        let result = self.infcx.probe(|snapshot| {\n+            self.match_projection_obligation_against_definition_bounds(obligation, snapshot)\n+        });\n+\n+        if result {\n+            candidates.vec.push(ProjectionCandidate);\n+        }\n+    }\n+\n+    /// Given an obligation like `<SomeTrait for T>`, searches the obligations that the caller\n+    /// supplied to find out whether it is listed among them.\n+    ///\n+    /// Never affects the inference environment.\n+    fn assemble_candidates_from_caller_bounds<'o>(\n+        &mut self,\n+        stack: &TraitObligationStack<'o, 'tcx>,\n+        candidates: &mut SelectionCandidateSet<'tcx>,\n+    ) -> Result<(), SelectionError<'tcx>> {\n+        debug!(\"assemble_candidates_from_caller_bounds({:?})\", stack.obligation);\n+\n+        let all_bounds = stack\n+            .obligation\n+            .param_env\n+            .caller_bounds\n+            .iter()\n+            .filter_map(|o| o.to_opt_poly_trait_ref());\n+\n+        // Micro-optimization: filter out predicates relating to different traits.\n+        let matching_bounds =\n+            all_bounds.filter(|p| p.def_id() == stack.obligation.predicate.def_id());\n+\n+        // Keep only those bounds which may apply, and propagate overflow if it occurs.\n+        let mut param_candidates = vec![];\n+        for bound in matching_bounds {\n+            let wc = self.evaluate_where_clause(stack, bound)?;\n+            if wc.may_apply() {\n+                param_candidates.push(ParamCandidate(bound));\n+            }\n+        }\n+\n+        candidates.vec.extend(param_candidates);\n+\n+        Ok(())\n+    }\n+\n+    fn assemble_generator_candidates(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        candidates: &mut SelectionCandidateSet<'tcx>,\n+    ) -> Result<(), SelectionError<'tcx>> {\n+        if self.tcx().lang_items().gen_trait() != Some(obligation.predicate.def_id()) {\n+            return Ok(());\n+        }\n+\n+        // Okay to skip binder because the substs on generator types never\n+        // touch bound regions, they just capture the in-scope\n+        // type/region parameters.\n+        let self_ty = *obligation.self_ty().skip_binder();\n+        match self_ty.kind {\n+            ty::Generator(..) => {\n+                debug!(\n+                    \"assemble_generator_candidates: self_ty={:?} obligation={:?}\",\n+                    self_ty, obligation\n+                );\n+\n+                candidates.vec.push(GeneratorCandidate);\n+            }\n+            ty::Infer(ty::TyVar(_)) => {\n+                debug!(\"assemble_generator_candidates: ambiguous self-type\");\n+                candidates.ambiguous = true;\n+            }\n+            _ => {}\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Checks for the artificial impl that the compiler will create for an obligation like `X :\n+    /// FnMut<..>` where `X` is a closure type.\n+    ///\n+    /// Note: the type parameters on a closure candidate are modeled as *output* type\n+    /// parameters and hence do not affect whether this trait is a match or not. They will be\n+    /// unified during the confirmation step.\n+    fn assemble_closure_candidates(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        candidates: &mut SelectionCandidateSet<'tcx>,\n+    ) -> Result<(), SelectionError<'tcx>> {\n+        let kind = match self.tcx().fn_trait_kind_from_lang_item(obligation.predicate.def_id()) {\n+            Some(k) => k,\n+            None => {\n+                return Ok(());\n+            }\n+        };\n+\n+        // Okay to skip binder because the substs on closure types never\n+        // touch bound regions, they just capture the in-scope\n+        // type/region parameters\n+        match obligation.self_ty().skip_binder().kind {\n+            ty::Closure(_, closure_substs) => {\n+                debug!(\"assemble_unboxed_candidates: kind={:?} obligation={:?}\", kind, obligation);\n+                match self.infcx.closure_kind(closure_substs) {\n+                    Some(closure_kind) => {\n+                        debug!(\"assemble_unboxed_candidates: closure_kind = {:?}\", closure_kind);\n+                        if closure_kind.extends(kind) {\n+                            candidates.vec.push(ClosureCandidate);\n+                        }\n+                    }\n+                    None => {\n+                        debug!(\"assemble_unboxed_candidates: closure_kind not yet known\");\n+                        candidates.vec.push(ClosureCandidate);\n+                    }\n+                }\n+            }\n+            ty::Infer(ty::TyVar(_)) => {\n+                debug!(\"assemble_unboxed_closure_candidates: ambiguous self-type\");\n+                candidates.ambiguous = true;\n+            }\n+            _ => {}\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Implements one of the `Fn()` family for a fn pointer.\n+    fn assemble_fn_pointer_candidates(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        candidates: &mut SelectionCandidateSet<'tcx>,\n+    ) -> Result<(), SelectionError<'tcx>> {\n+        // We provide impl of all fn traits for fn pointers.\n+        if self.tcx().fn_trait_kind_from_lang_item(obligation.predicate.def_id()).is_none() {\n+            return Ok(());\n+        }\n+\n+        // Okay to skip binder because what we are inspecting doesn't involve bound regions.\n+        let self_ty = *obligation.self_ty().skip_binder();\n+        match self_ty.kind {\n+            ty::Infer(ty::TyVar(_)) => {\n+                debug!(\"assemble_fn_pointer_candidates: ambiguous self-type\");\n+                candidates.ambiguous = true; // Could wind up being a fn() type.\n+            }\n+            // Provide an impl, but only for suitable `fn` pointers.\n+            ty::FnDef(..) | ty::FnPtr(_) => {\n+                if let ty::FnSig {\n+                    unsafety: hir::Unsafety::Normal,\n+                    abi: Abi::Rust,\n+                    c_variadic: false,\n+                    ..\n+                } = self_ty.fn_sig(self.tcx()).skip_binder()\n+                {\n+                    candidates.vec.push(FnPointerCandidate);\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Searches for impls that might apply to `obligation`.\n+    fn assemble_candidates_from_impls(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        candidates: &mut SelectionCandidateSet<'tcx>,\n+    ) -> Result<(), SelectionError<'tcx>> {\n+        debug!(\"assemble_candidates_from_impls(obligation={:?})\", obligation);\n+\n+        self.tcx().for_each_relevant_impl(\n+            obligation.predicate.def_id(),\n+            obligation.predicate.skip_binder().trait_ref.self_ty(),\n+            |impl_def_id| {\n+                self.infcx.probe(|snapshot| {\n+                    if let Ok(_substs) = self.match_impl(impl_def_id, obligation, snapshot) {\n+                        candidates.vec.push(ImplCandidate(impl_def_id));\n+                    }\n+                });\n+            },\n+        );\n+\n+        Ok(())\n+    }\n+\n+    fn assemble_candidates_from_auto_impls(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        candidates: &mut SelectionCandidateSet<'tcx>,\n+    ) -> Result<(), SelectionError<'tcx>> {\n+        // Okay to skip binder here because the tests we do below do not involve bound regions.\n+        let self_ty = *obligation.self_ty().skip_binder();\n+        debug!(\"assemble_candidates_from_auto_impls(self_ty={:?})\", self_ty);\n+\n+        let def_id = obligation.predicate.def_id();\n+\n+        if self.tcx().trait_is_auto(def_id) {\n+            match self_ty.kind {\n+                ty::Dynamic(..) => {\n+                    // For object types, we don't know what the closed\n+                    // over types are. This means we conservatively\n+                    // say nothing; a candidate may be added by\n+                    // `assemble_candidates_from_object_ty`.\n+                }\n+                ty::Foreign(..) => {\n+                    // Since the contents of foreign types is unknown,\n+                    // we don't add any `..` impl. Default traits could\n+                    // still be provided by a manual implementation for\n+                    // this trait and type.\n+                }\n+                ty::Param(..) | ty::Projection(..) => {\n+                    // In these cases, we don't know what the actual\n+                    // type is.  Therefore, we cannot break it down\n+                    // into its constituent types. So we don't\n+                    // consider the `..` impl but instead just add no\n+                    // candidates: this means that typeck will only\n+                    // succeed if there is another reason to believe\n+                    // that this obligation holds. That could be a\n+                    // where-clause or, in the case of an object type,\n+                    // it could be that the object type lists the\n+                    // trait (e.g., `Foo+Send : Send`). See\n+                    // `compile-fail/typeck-default-trait-impl-send-param.rs`\n+                    // for an example of a test case that exercises\n+                    // this path.\n+                }\n+                ty::Infer(ty::TyVar(_)) => {\n+                    // The auto impl might apply; we don't know.\n+                    candidates.ambiguous = true;\n+                }\n+                ty::Generator(_, _, movability)\n+                    if self.tcx().lang_items().unpin_trait() == Some(def_id) =>\n+                {\n+                    match movability {\n+                        hir::Movability::Static => {\n+                            // Immovable generators are never `Unpin`, so\n+                            // suppress the normal auto-impl candidate for it.\n+                        }\n+                        hir::Movability::Movable => {\n+                            // Movable generators are always `Unpin`, so add an\n+                            // unconditional builtin candidate.\n+                            candidates.vec.push(BuiltinCandidate { has_nested: false });\n+                        }\n+                    }\n+                }\n+\n+                _ => candidates.vec.push(AutoImplCandidate(def_id)),\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Searches for impls that might apply to `obligation`.\n+    fn assemble_candidates_from_object_ty(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        candidates: &mut SelectionCandidateSet<'tcx>,\n+    ) {\n+        debug!(\n+            \"assemble_candidates_from_object_ty(self_ty={:?})\",\n+            obligation.self_ty().skip_binder()\n+        );\n+\n+        self.infcx.probe(|_snapshot| {\n+            // The code below doesn't care about regions, and the\n+            // self-ty here doesn't escape this probe, so just erase\n+            // any LBR.\n+            let self_ty = self.tcx().erase_late_bound_regions(&obligation.self_ty());\n+            let poly_trait_ref = match self_ty.kind {\n+                ty::Dynamic(ref data, ..) => {\n+                    if data.auto_traits().any(|did| did == obligation.predicate.def_id()) {\n+                        debug!(\n+                            \"assemble_candidates_from_object_ty: matched builtin bound, \\\n+                             pushing candidate\"\n+                        );\n+                        candidates.vec.push(BuiltinObjectCandidate);\n+                        return;\n+                    }\n+\n+                    if let Some(principal) = data.principal() {\n+                        if !self.infcx.tcx.features().object_safe_for_dispatch {\n+                            principal.with_self_ty(self.tcx(), self_ty)\n+                        } else if self.tcx().is_object_safe(principal.def_id()) {\n+                            principal.with_self_ty(self.tcx(), self_ty)\n+                        } else {\n+                            return;\n+                        }\n+                    } else {\n+                        // Only auto trait bounds exist.\n+                        return;\n+                    }\n+                }\n+                ty::Infer(ty::TyVar(_)) => {\n+                    debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n+                    candidates.ambiguous = true; // could wind up being an object type\n+                    return;\n+                }\n+                _ => return,\n+            };\n+\n+            debug!(\"assemble_candidates_from_object_ty: poly_trait_ref={:?}\", poly_trait_ref);\n+\n+            // Count only those upcast versions that match the trait-ref\n+            // we are looking for. Specifically, do not only check for the\n+            // correct trait, but also the correct type parameters.\n+            // For example, we may be trying to upcast `Foo` to `Bar<i32>`,\n+            // but `Foo` is declared as `trait Foo: Bar<u32>`.\n+            let upcast_trait_refs = util::supertraits(self.tcx(), poly_trait_ref)\n+                .filter(|upcast_trait_ref| {\n+                    self.infcx\n+                        .probe(|_| self.match_poly_trait_ref(obligation, *upcast_trait_ref).is_ok())\n+                })\n+                .count();\n+\n+            if upcast_trait_refs > 1 {\n+                // Can be upcast in many ways; need more type information.\n+                candidates.ambiguous = true;\n+            } else if upcast_trait_refs == 1 {\n+                candidates.vec.push(ObjectCandidate);\n+            }\n+        })\n+    }\n+\n+    /// Searches for unsizing that might apply to `obligation`.\n+    fn assemble_candidates_for_unsizing(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        candidates: &mut SelectionCandidateSet<'tcx>,\n+    ) {\n+        // We currently never consider higher-ranked obligations e.g.\n+        // `for<'a> &'a T: Unsize<Trait+'a>` to be implemented. This is not\n+        // because they are a priori invalid, and we could potentially add support\n+        // for them later, it's just that there isn't really a strong need for it.\n+        // A `T: Unsize<U>` obligation is always used as part of a `T: CoerceUnsize<U>`\n+        // impl, and those are generally applied to concrete types.\n+        //\n+        // That said, one might try to write a fn with a where clause like\n+        //     for<'a> Foo<'a, T>: Unsize<Foo<'a, Trait>>\n+        // where the `'a` is kind of orthogonal to the relevant part of the `Unsize`.\n+        // Still, you'd be more likely to write that where clause as\n+        //     T: Trait\n+        // so it seems ok if we (conservatively) fail to accept that `Unsize`\n+        // obligation above. Should be possible to extend this in the future.\n+        let source = match obligation.self_ty().no_bound_vars() {\n+            Some(t) => t,\n+            None => {\n+                // Don't add any candidates if there are bound regions.\n+                return;\n+            }\n+        };\n+        let target = obligation.predicate.skip_binder().trait_ref.substs.type_at(1);\n+\n+        debug!(\"assemble_candidates_for_unsizing(source={:?}, target={:?})\", source, target);\n+\n+        let may_apply = match (&source.kind, &target.kind) {\n+            // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n+            (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n+                // Upcasts permit two things:\n+                //\n+                // 1. Dropping auto traits, e.g., `Foo + Send` to `Foo`\n+                // 2. Tightening the region bound, e.g., `Foo + 'a` to `Foo + 'b` if `'a: 'b`\n+                //\n+                // Note that neither of these changes requires any\n+                // change at runtime. Eventually this will be\n+                // generalized.\n+                //\n+                // We always upcast when we can because of reason\n+                // #2 (region bounds).\n+                data_a.principal_def_id() == data_b.principal_def_id()\n+                    && data_b\n+                        .auto_traits()\n+                        // All of a's auto traits need to be in b's auto traits.\n+                        .all(|b| data_a.auto_traits().any(|a| a == b))\n+            }\n+\n+            // `T` -> `Trait`\n+            (_, &ty::Dynamic(..)) => true,\n+\n+            // Ambiguous handling is below `T` -> `Trait`, because inference\n+            // variables can still implement `Unsize<Trait>` and nested\n+            // obligations will have the final say (likely deferred).\n+            (&ty::Infer(ty::TyVar(_)), _) | (_, &ty::Infer(ty::TyVar(_))) => {\n+                debug!(\"assemble_candidates_for_unsizing: ambiguous\");\n+                candidates.ambiguous = true;\n+                false\n+            }\n+\n+            // `[T; n]` -> `[T]`\n+            (&ty::Array(..), &ty::Slice(_)) => true,\n+\n+            // `Struct<T>` -> `Struct<U>`\n+            (&ty::Adt(def_id_a, _), &ty::Adt(def_id_b, _)) if def_id_a.is_struct() => {\n+                def_id_a == def_id_b\n+            }\n+\n+            // `(.., T)` -> `(.., U)`\n+            (&ty::Tuple(tys_a), &ty::Tuple(tys_b)) => tys_a.len() == tys_b.len(),\n+\n+            _ => false,\n+        };\n+\n+        if may_apply {\n+            candidates.vec.push(BuiltinUnsizeCandidate);\n+        }\n+    }\n+\n+    fn assemble_candidates_for_trait_alias(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        candidates: &mut SelectionCandidateSet<'tcx>,\n+    ) -> Result<(), SelectionError<'tcx>> {\n+        // Okay to skip binder here because the tests we do below do not involve bound regions.\n+        let self_ty = *obligation.self_ty().skip_binder();\n+        debug!(\"assemble_candidates_for_trait_alias(self_ty={:?})\", self_ty);\n+\n+        let def_id = obligation.predicate.def_id();\n+\n+        if self.tcx().is_trait_alias(def_id) {\n+            candidates.vec.push(TraitAliasCandidate(def_id));\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Assembles the trait which are built-in to the language itself:\n+    /// `Copy`, `Clone` and `Sized`.\n+    fn assemble_builtin_bound_candidates(\n+        &mut self,\n+        conditions: BuiltinImplConditions<'tcx>,\n+        candidates: &mut SelectionCandidateSet<'tcx>,\n+    ) -> Result<(), SelectionError<'tcx>> {\n+        match conditions {\n+            BuiltinImplConditions::Where(nested) => {\n+                debug!(\"builtin_bound: nested={:?}\", nested);\n+                candidates\n+                    .vec\n+                    .push(BuiltinCandidate { has_nested: !nested.skip_binder().is_empty() });\n+            }\n+            BuiltinImplConditions::None => {}\n+            BuiltinImplConditions::Ambiguous => {\n+                debug!(\"assemble_builtin_bound_candidates: ambiguous builtin\");\n+                candidates.ambiguous = true;\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "65bb9b7cda93748338c5c9732b2f7a20d4302135", "filename": "src/librustc_trait_selection/traits/select/confirmation.rs", "status": "added", "additions": 820, "deletions": 0, "changes": 820, "blob_url": "https://github.com/rust-lang/rust/blob/56daaf669ebc3d5083db5cded719f780dc31104e/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56daaf669ebc3d5083db5cded719f780dc31104e/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fconfirmation.rs?ref=56daaf669ebc3d5083db5cded719f780dc31104e", "patch": "@@ -0,0 +1,820 @@\n+//! Confirmation.\n+//!\n+//! Confirmation unifies the output type parameters of the trait\n+//! with the values found in the obligation, possibly yielding a\n+//! type error.  See the [rustc dev guide] for more details.\n+//!\n+//! [rustc dev guide]:\n+//! https://rustc-dev-guide.rust-lang.org/traits/resolution.html#confirmation\n+use rustc_data_structures::stack::ensure_sufficient_stack;\n+use rustc_hir::lang_items;\n+use rustc_index::bit_set::GrowableBitSet;\n+use rustc_infer::infer::InferOk;\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst, SubstsRef};\n+use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{ToPolyTraitRef, ToPredicate, WithConstness};\n+use rustc_span::def_id::DefId;\n+\n+use crate::traits::project::{self, normalize_with_depth};\n+use crate::traits::select::TraitObligationExt;\n+use crate::traits::util;\n+use crate::traits::util::{closure_trait_ref_and_return_type, predicate_for_trait_def};\n+use crate::traits::Normalized;\n+use crate::traits::OutputTypeParameterMismatch;\n+use crate::traits::Selection;\n+use crate::traits::TraitNotObjectSafe;\n+use crate::traits::{BuiltinDerivedObligation, ImplDerivedObligation};\n+use crate::traits::{ObjectCastObligation, PredicateObligation, TraitObligation};\n+use crate::traits::{Obligation, ObligationCause};\n+use crate::traits::{SelectionError, Unimplemented};\n+use crate::traits::{\n+    VtableAutoImpl, VtableBuiltin, VtableClosure, VtableDiscriminantKind, VtableFnPointer,\n+    VtableGenerator, VtableImpl, VtableObject, VtableParam, VtableTraitAlias,\n+};\n+use crate::traits::{\n+    VtableAutoImplData, VtableBuiltinData, VtableClosureData, VtableDiscriminantKindData,\n+    VtableFnPointerData, VtableGeneratorData, VtableImplData, VtableObjectData,\n+    VtableTraitAliasData,\n+};\n+\n+use super::BuiltinImplConditions;\n+use super::SelectionCandidate::{self, *};\n+use super::SelectionContext;\n+\n+use std::iter;\n+\n+impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n+    pub(super) fn confirm_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        candidate: SelectionCandidate<'tcx>,\n+    ) -> Result<Selection<'tcx>, SelectionError<'tcx>> {\n+        debug!(\"confirm_candidate({:?}, {:?})\", obligation, candidate);\n+\n+        match candidate {\n+            BuiltinCandidate { has_nested } => {\n+                let data = self.confirm_builtin_candidate(obligation, has_nested);\n+                Ok(VtableBuiltin(data))\n+            }\n+\n+            ParamCandidate(param) => {\n+                let obligations = self.confirm_param_candidate(obligation, param);\n+                Ok(VtableParam(obligations))\n+            }\n+\n+            ImplCandidate(impl_def_id) => {\n+                Ok(VtableImpl(self.confirm_impl_candidate(obligation, impl_def_id)))\n+            }\n+\n+            AutoImplCandidate(trait_def_id) => {\n+                let data = self.confirm_auto_impl_candidate(obligation, trait_def_id);\n+                Ok(VtableAutoImpl(data))\n+            }\n+\n+            ProjectionCandidate => {\n+                self.confirm_projection_candidate(obligation);\n+                Ok(VtableParam(Vec::new()))\n+            }\n+\n+            ClosureCandidate => {\n+                let vtable_closure = self.confirm_closure_candidate(obligation)?;\n+                Ok(VtableClosure(vtable_closure))\n+            }\n+\n+            GeneratorCandidate => {\n+                let vtable_generator = self.confirm_generator_candidate(obligation)?;\n+                Ok(VtableGenerator(vtable_generator))\n+            }\n+\n+            FnPointerCandidate => {\n+                let data = self.confirm_fn_pointer_candidate(obligation)?;\n+                Ok(VtableFnPointer(data))\n+            }\n+\n+            DiscriminantKindCandidate => Ok(VtableDiscriminantKind(VtableDiscriminantKindData)),\n+\n+            TraitAliasCandidate(alias_def_id) => {\n+                let data = self.confirm_trait_alias_candidate(obligation, alias_def_id);\n+                Ok(VtableTraitAlias(data))\n+            }\n+\n+            ObjectCandidate => {\n+                let data = self.confirm_object_candidate(obligation);\n+                Ok(VtableObject(data))\n+            }\n+\n+            BuiltinObjectCandidate => {\n+                // This indicates something like `Trait + Send: Send`. In this case, we know that\n+                // this holds because that's what the object type is telling us, and there's really\n+                // no additional obligations to prove and no types in particular to unify, etc.\n+                Ok(VtableParam(Vec::new()))\n+            }\n+\n+            BuiltinUnsizeCandidate => {\n+                let data = self.confirm_builtin_unsize_candidate(obligation)?;\n+                Ok(VtableBuiltin(data))\n+            }\n+        }\n+    }\n+\n+    fn confirm_projection_candidate(&mut self, obligation: &TraitObligation<'tcx>) {\n+        self.infcx.commit_unconditionally(|snapshot| {\n+            let result =\n+                self.match_projection_obligation_against_definition_bounds(obligation, snapshot);\n+            assert!(result);\n+        })\n+    }\n+\n+    fn confirm_param_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        param: ty::PolyTraitRef<'tcx>,\n+    ) -> Vec<PredicateObligation<'tcx>> {\n+        debug!(\"confirm_param_candidate({:?},{:?})\", obligation, param);\n+\n+        // During evaluation, we already checked that this\n+        // where-clause trait-ref could be unified with the obligation\n+        // trait-ref. Repeat that unification now without any\n+        // transactional boundary; it should not fail.\n+        match self.match_where_clause_trait_ref(obligation, param) {\n+            Ok(obligations) => obligations,\n+            Err(()) => {\n+                bug!(\n+                    \"Where clause `{:?}` was applicable to `{:?}` but now is not\",\n+                    param,\n+                    obligation\n+                );\n+            }\n+        }\n+    }\n+\n+    fn confirm_builtin_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        has_nested: bool,\n+    ) -> VtableBuiltinData<PredicateObligation<'tcx>> {\n+        debug!(\"confirm_builtin_candidate({:?}, {:?})\", obligation, has_nested);\n+\n+        let lang_items = self.tcx().lang_items();\n+        let obligations = if has_nested {\n+            let trait_def = obligation.predicate.def_id();\n+            let conditions = if Some(trait_def) == lang_items.sized_trait() {\n+                self.sized_conditions(obligation)\n+            } else if Some(trait_def) == lang_items.copy_trait() {\n+                self.copy_clone_conditions(obligation)\n+            } else if Some(trait_def) == lang_items.clone_trait() {\n+                self.copy_clone_conditions(obligation)\n+            } else {\n+                bug!(\"unexpected builtin trait {:?}\", trait_def)\n+            };\n+            let nested = match conditions {\n+                BuiltinImplConditions::Where(nested) => nested,\n+                _ => bug!(\"obligation {:?} had matched a builtin impl but now doesn't\", obligation),\n+            };\n+\n+            let cause = obligation.derived_cause(BuiltinDerivedObligation);\n+            ensure_sufficient_stack(|| {\n+                self.collect_predicates_for_types(\n+                    obligation.param_env,\n+                    cause,\n+                    obligation.recursion_depth + 1,\n+                    trait_def,\n+                    nested,\n+                )\n+            })\n+        } else {\n+            vec![]\n+        };\n+\n+        debug!(\"confirm_builtin_candidate: obligations={:?}\", obligations);\n+\n+        VtableBuiltinData { nested: obligations }\n+    }\n+\n+    /// This handles the case where a `auto trait Foo` impl is being used.\n+    /// The idea is that the impl applies to `X : Foo` if the following conditions are met:\n+    ///\n+    /// 1. For each constituent type `Y` in `X`, `Y : Foo` holds\n+    /// 2. For each where-clause `C` declared on `Foo`, `[Self => X] C` holds.\n+    fn confirm_auto_impl_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        trait_def_id: DefId,\n+    ) -> VtableAutoImplData<PredicateObligation<'tcx>> {\n+        debug!(\"confirm_auto_impl_candidate({:?}, {:?})\", obligation, trait_def_id);\n+\n+        let types = obligation.predicate.map_bound(|inner| {\n+            let self_ty = self.infcx.shallow_resolve(inner.self_ty());\n+            self.constituent_types_for_ty(self_ty)\n+        });\n+        self.vtable_auto_impl(obligation, trait_def_id, types)\n+    }\n+\n+    /// See `confirm_auto_impl_candidate`.\n+    fn vtable_auto_impl(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        trait_def_id: DefId,\n+        nested: ty::Binder<Vec<Ty<'tcx>>>,\n+    ) -> VtableAutoImplData<PredicateObligation<'tcx>> {\n+        debug!(\"vtable_auto_impl: nested={:?}\", nested);\n+        ensure_sufficient_stack(|| {\n+            let cause = obligation.derived_cause(BuiltinDerivedObligation);\n+            let mut obligations = self.collect_predicates_for_types(\n+                obligation.param_env,\n+                cause,\n+                obligation.recursion_depth + 1,\n+                trait_def_id,\n+                nested,\n+            );\n+\n+            let trait_obligations: Vec<PredicateObligation<'_>> =\n+                self.infcx.commit_unconditionally(|_| {\n+                    let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n+                    let (trait_ref, _) =\n+                        self.infcx.replace_bound_vars_with_placeholders(&poly_trait_ref);\n+                    let cause = obligation.derived_cause(ImplDerivedObligation);\n+                    self.impl_or_trait_obligations(\n+                        cause,\n+                        obligation.recursion_depth + 1,\n+                        obligation.param_env,\n+                        trait_def_id,\n+                        &trait_ref.substs,\n+                    )\n+                });\n+\n+            // Adds the predicates from the trait.  Note that this contains a `Self: Trait`\n+            // predicate as usual.  It won't have any effect since auto traits are coinductive.\n+            obligations.extend(trait_obligations);\n+\n+            debug!(\"vtable_auto_impl: obligations={:?}\", obligations);\n+\n+            VtableAutoImplData { trait_def_id, nested: obligations }\n+        })\n+    }\n+\n+    fn confirm_impl_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        impl_def_id: DefId,\n+    ) -> VtableImplData<'tcx, PredicateObligation<'tcx>> {\n+        debug!(\"confirm_impl_candidate({:?},{:?})\", obligation, impl_def_id);\n+\n+        // First, create the substitutions by matching the impl again,\n+        // this time not in a probe.\n+        self.infcx.commit_unconditionally(|snapshot| {\n+            let substs = self.rematch_impl(impl_def_id, obligation, snapshot);\n+            debug!(\"confirm_impl_candidate: substs={:?}\", substs);\n+            let cause = obligation.derived_cause(ImplDerivedObligation);\n+            ensure_sufficient_stack(|| {\n+                self.vtable_impl(\n+                    impl_def_id,\n+                    substs,\n+                    cause,\n+                    obligation.recursion_depth + 1,\n+                    obligation.param_env,\n+                )\n+            })\n+        })\n+    }\n+\n+    fn vtable_impl(\n+        &mut self,\n+        impl_def_id: DefId,\n+        mut substs: Normalized<'tcx, SubstsRef<'tcx>>,\n+        cause: ObligationCause<'tcx>,\n+        recursion_depth: usize,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> VtableImplData<'tcx, PredicateObligation<'tcx>> {\n+        debug!(\n+            \"vtable_impl(impl_def_id={:?}, substs={:?}, recursion_depth={})\",\n+            impl_def_id, substs, recursion_depth,\n+        );\n+\n+        let mut impl_obligations = self.impl_or_trait_obligations(\n+            cause,\n+            recursion_depth,\n+            param_env,\n+            impl_def_id,\n+            &substs.value,\n+        );\n+\n+        debug!(\n+            \"vtable_impl: impl_def_id={:?} impl_obligations={:?}\",\n+            impl_def_id, impl_obligations\n+        );\n+\n+        // Because of RFC447, the impl-trait-ref and obligations\n+        // are sufficient to determine the impl substs, without\n+        // relying on projections in the impl-trait-ref.\n+        //\n+        // e.g., `impl<U: Tr, V: Iterator<Item=U>> Foo<<U as Tr>::T> for V`\n+        impl_obligations.append(&mut substs.obligations);\n+\n+        VtableImplData { impl_def_id, substs: substs.value, nested: impl_obligations }\n+    }\n+\n+    fn confirm_object_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+    ) -> VtableObjectData<'tcx, PredicateObligation<'tcx>> {\n+        debug!(\"confirm_object_candidate({:?})\", obligation);\n+\n+        // FIXME(nmatsakis) skipping binder here seems wrong -- we should\n+        // probably flatten the binder from the obligation and the binder\n+        // from the object. Have to try to make a broken test case that\n+        // results.\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n+        let poly_trait_ref = match self_ty.kind {\n+            ty::Dynamic(ref data, ..) => data\n+                .principal()\n+                .unwrap_or_else(|| {\n+                    span_bug!(obligation.cause.span, \"object candidate with no principal\")\n+                })\n+                .with_self_ty(self.tcx(), self_ty),\n+            _ => span_bug!(obligation.cause.span, \"object candidate with non-object\"),\n+        };\n+\n+        let mut upcast_trait_ref = None;\n+        let mut nested = vec![];\n+        let vtable_base;\n+\n+        {\n+            let tcx = self.tcx();\n+\n+            // We want to find the first supertrait in the list of\n+            // supertraits that we can unify with, and do that\n+            // unification. We know that there is exactly one in the list\n+            // where we can unify, because otherwise select would have\n+            // reported an ambiguity. (When we do find a match, also\n+            // record it for later.)\n+            let nonmatching = util::supertraits(tcx, poly_trait_ref).take_while(|&t| {\n+                match self.infcx.commit_if_ok(|_| self.match_poly_trait_ref(obligation, t)) {\n+                    Ok(obligations) => {\n+                        upcast_trait_ref = Some(t);\n+                        nested.extend(obligations);\n+                        false\n+                    }\n+                    Err(_) => true,\n+                }\n+            });\n+\n+            // Additionally, for each of the non-matching predicates that\n+            // we pass over, we sum up the set of number of vtable\n+            // entries, so that we can compute the offset for the selected\n+            // trait.\n+            vtable_base = nonmatching.map(|t| super::util::count_own_vtable_entries(tcx, t)).sum();\n+        }\n+\n+        VtableObjectData { upcast_trait_ref: upcast_trait_ref.unwrap(), vtable_base, nested }\n+    }\n+\n+    fn confirm_fn_pointer_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+    ) -> Result<VtableFnPointerData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+        debug!(\"confirm_fn_pointer_candidate({:?})\", obligation);\n+\n+        // Okay to skip binder; it is reintroduced below.\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n+        let sig = self_ty.fn_sig(self.tcx());\n+        let trait_ref = closure_trait_ref_and_return_type(\n+            self.tcx(),\n+            obligation.predicate.def_id(),\n+            self_ty,\n+            sig,\n+            util::TupleArgumentsFlag::Yes,\n+        )\n+        .map_bound(|(trait_ref, _)| trait_ref);\n+\n+        let Normalized { value: trait_ref, obligations } = ensure_sufficient_stack(|| {\n+            project::normalize_with_depth(\n+                self,\n+                obligation.param_env,\n+                obligation.cause.clone(),\n+                obligation.recursion_depth + 1,\n+                &trait_ref,\n+            )\n+        });\n+\n+        self.confirm_poly_trait_refs(\n+            obligation.cause.clone(),\n+            obligation.param_env,\n+            obligation.predicate.to_poly_trait_ref(),\n+            trait_ref,\n+        )?;\n+        Ok(VtableFnPointerData { fn_ty: self_ty, nested: obligations })\n+    }\n+\n+    fn confirm_trait_alias_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        alias_def_id: DefId,\n+    ) -> VtableTraitAliasData<'tcx, PredicateObligation<'tcx>> {\n+        debug!(\"confirm_trait_alias_candidate({:?}, {:?})\", obligation, alias_def_id);\n+\n+        self.infcx.commit_unconditionally(|_| {\n+            let (predicate, _) =\n+                self.infcx().replace_bound_vars_with_placeholders(&obligation.predicate);\n+            let trait_ref = predicate.trait_ref;\n+            let trait_def_id = trait_ref.def_id;\n+            let substs = trait_ref.substs;\n+\n+            let trait_obligations = self.impl_or_trait_obligations(\n+                obligation.cause.clone(),\n+                obligation.recursion_depth,\n+                obligation.param_env,\n+                trait_def_id,\n+                &substs,\n+            );\n+\n+            debug!(\n+                \"confirm_trait_alias_candidate: trait_def_id={:?} trait_obligations={:?}\",\n+                trait_def_id, trait_obligations\n+            );\n+\n+            VtableTraitAliasData { alias_def_id, substs, nested: trait_obligations }\n+        })\n+    }\n+\n+    fn confirm_generator_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+    ) -> Result<VtableGeneratorData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+        // Okay to skip binder because the substs on generator types never\n+        // touch bound regions, they just capture the in-scope\n+        // type/region parameters.\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n+        let (generator_def_id, substs) = match self_ty.kind {\n+            ty::Generator(id, substs, _) => (id, substs),\n+            _ => bug!(\"closure candidate for non-closure {:?}\", obligation),\n+        };\n+\n+        debug!(\"confirm_generator_candidate({:?},{:?},{:?})\", obligation, generator_def_id, substs);\n+\n+        let trait_ref = self.generator_trait_ref_unnormalized(obligation, substs);\n+        let Normalized { value: trait_ref, mut obligations } = ensure_sufficient_stack(|| {\n+            normalize_with_depth(\n+                self,\n+                obligation.param_env,\n+                obligation.cause.clone(),\n+                obligation.recursion_depth + 1,\n+                &trait_ref,\n+            )\n+        });\n+\n+        debug!(\n+            \"confirm_generator_candidate(generator_def_id={:?}, \\\n+             trait_ref={:?}, obligations={:?})\",\n+            generator_def_id, trait_ref, obligations\n+        );\n+\n+        obligations.extend(self.confirm_poly_trait_refs(\n+            obligation.cause.clone(),\n+            obligation.param_env,\n+            obligation.predicate.to_poly_trait_ref(),\n+            trait_ref,\n+        )?);\n+\n+        Ok(VtableGeneratorData { generator_def_id, substs, nested: obligations })\n+    }\n+\n+    fn confirm_closure_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+    ) -> Result<VtableClosureData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+        debug!(\"confirm_closure_candidate({:?})\", obligation);\n+\n+        let kind = self\n+            .tcx()\n+            .fn_trait_kind_from_lang_item(obligation.predicate.def_id())\n+            .unwrap_or_else(|| bug!(\"closure candidate for non-fn trait {:?}\", obligation));\n+\n+        // Okay to skip binder because the substs on closure types never\n+        // touch bound regions, they just capture the in-scope\n+        // type/region parameters.\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n+        let (closure_def_id, substs) = match self_ty.kind {\n+            ty::Closure(id, substs) => (id, substs),\n+            _ => bug!(\"closure candidate for non-closure {:?}\", obligation),\n+        };\n+\n+        let trait_ref = self.closure_trait_ref_unnormalized(obligation, substs);\n+        let Normalized { value: trait_ref, mut obligations } = ensure_sufficient_stack(|| {\n+            normalize_with_depth(\n+                self,\n+                obligation.param_env,\n+                obligation.cause.clone(),\n+                obligation.recursion_depth + 1,\n+                &trait_ref,\n+            )\n+        });\n+\n+        debug!(\n+            \"confirm_closure_candidate(closure_def_id={:?}, trait_ref={:?}, obligations={:?})\",\n+            closure_def_id, trait_ref, obligations\n+        );\n+\n+        obligations.extend(self.confirm_poly_trait_refs(\n+            obligation.cause.clone(),\n+            obligation.param_env,\n+            obligation.predicate.to_poly_trait_ref(),\n+            trait_ref,\n+        )?);\n+\n+        // FIXME: Chalk\n+\n+        if !self.tcx().sess.opts.debugging_opts.chalk {\n+            obligations.push(Obligation::new(\n+                obligation.cause.clone(),\n+                obligation.param_env,\n+                ty::PredicateKind::ClosureKind(closure_def_id, substs, kind)\n+                    .to_predicate(self.tcx()),\n+            ));\n+        }\n+\n+        Ok(VtableClosureData { closure_def_id, substs, nested: obligations })\n+    }\n+\n+    /// In the case of closure types and fn pointers,\n+    /// we currently treat the input type parameters on the trait as\n+    /// outputs. This means that when we have a match we have only\n+    /// considered the self type, so we have to go back and make sure\n+    /// to relate the argument types too. This is kind of wrong, but\n+    /// since we control the full set of impls, also not that wrong,\n+    /// and it DOES yield better error messages (since we don't report\n+    /// errors as if there is no applicable impl, but rather report\n+    /// errors are about mismatched argument types.\n+    ///\n+    /// Here is an example. Imagine we have a closure expression\n+    /// and we desugared it so that the type of the expression is\n+    /// `Closure`, and `Closure` expects an int as argument. Then it\n+    /// is \"as if\" the compiler generated this impl:\n+    ///\n+    ///     impl Fn(int) for Closure { ... }\n+    ///\n+    /// Now imagine our obligation is `Fn(usize) for Closure`. So far\n+    /// we have matched the self type `Closure`. At this point we'll\n+    /// compare the `int` to `usize` and generate an error.\n+    ///\n+    /// Note that this checking occurs *after* the impl has selected,\n+    /// because these output type parameters should not affect the\n+    /// selection of the impl. Therefore, if there is a mismatch, we\n+    /// report an error to the user.\n+    fn confirm_poly_trait_refs(\n+        &mut self,\n+        obligation_cause: ObligationCause<'tcx>,\n+        obligation_param_env: ty::ParamEnv<'tcx>,\n+        obligation_trait_ref: ty::PolyTraitRef<'tcx>,\n+        expected_trait_ref: ty::PolyTraitRef<'tcx>,\n+    ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+        self.infcx\n+            .at(&obligation_cause, obligation_param_env)\n+            .sup(obligation_trait_ref, expected_trait_ref)\n+            .map(|InferOk { obligations, .. }| obligations)\n+            .map_err(|e| OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n+    }\n+\n+    fn confirm_builtin_unsize_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+    ) -> Result<VtableBuiltinData<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+        let tcx = self.tcx();\n+\n+        // `assemble_candidates_for_unsizing` should ensure there are no late-bound\n+        // regions here. See the comment there for more details.\n+        let source = self.infcx.shallow_resolve(obligation.self_ty().no_bound_vars().unwrap());\n+        let target = obligation.predicate.skip_binder().trait_ref.substs.type_at(1);\n+        let target = self.infcx.shallow_resolve(target);\n+\n+        debug!(\"confirm_builtin_unsize_candidate(source={:?}, target={:?})\", source, target);\n+\n+        let mut nested = vec![];\n+        match (&source.kind, &target.kind) {\n+            // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n+            (&ty::Dynamic(ref data_a, r_a), &ty::Dynamic(ref data_b, r_b)) => {\n+                // See `assemble_candidates_for_unsizing` for more info.\n+                let existential_predicates = data_a.map_bound(|data_a| {\n+                    let iter = data_a\n+                        .principal()\n+                        .map(ty::ExistentialPredicate::Trait)\n+                        .into_iter()\n+                        .chain(data_a.projection_bounds().map(ty::ExistentialPredicate::Projection))\n+                        .chain(data_b.auto_traits().map(ty::ExistentialPredicate::AutoTrait));\n+                    tcx.mk_existential_predicates(iter)\n+                });\n+                let source_trait = tcx.mk_dynamic(existential_predicates, r_b);\n+\n+                // Require that the traits involved in this upcast are **equal**;\n+                // only the **lifetime bound** is changed.\n+                //\n+                // FIXME: This condition is arguably too strong -- it would\n+                // suffice for the source trait to be a *subtype* of the target\n+                // trait. In particular, changing from something like\n+                // `for<'a, 'b> Foo<'a, 'b>` to `for<'a> Foo<'a, 'a>` should be\n+                // permitted. And, indeed, in the in commit\n+                // 904a0bde93f0348f69914ee90b1f8b6e4e0d7cbc, this\n+                // condition was loosened. However, when the leak check was\n+                // added back, using subtype here actually guides the coercion\n+                // code in such a way that it accepts `old-lub-glb-object.rs`.\n+                // This is probably a good thing, but I've modified this to `.eq`\n+                // because I want to continue rejecting that test (as we have\n+                // done for quite some time) before we are firmly comfortable\n+                // with what our behavior should be there. -nikomatsakis\n+                let InferOk { obligations, .. } = self\n+                    .infcx\n+                    .at(&obligation.cause, obligation.param_env)\n+                    .eq(target, source_trait) // FIXME -- see below\n+                    .map_err(|_| Unimplemented)?;\n+                nested.extend(obligations);\n+\n+                // Register one obligation for 'a: 'b.\n+                let cause = ObligationCause::new(\n+                    obligation.cause.span,\n+                    obligation.cause.body_id,\n+                    ObjectCastObligation(target),\n+                );\n+                let outlives = ty::OutlivesPredicate(r_a, r_b);\n+                nested.push(Obligation::with_depth(\n+                    cause,\n+                    obligation.recursion_depth + 1,\n+                    obligation.param_env,\n+                    ty::Binder::bind(outlives).to_predicate(tcx),\n+                ));\n+            }\n+\n+            // `T` -> `Trait`\n+            (_, &ty::Dynamic(ref data, r)) => {\n+                let mut object_dids = data.auto_traits().chain(data.principal_def_id());\n+                if let Some(did) = object_dids.find(|did| !tcx.is_object_safe(*did)) {\n+                    return Err(TraitNotObjectSafe(did));\n+                }\n+\n+                let cause = ObligationCause::new(\n+                    obligation.cause.span,\n+                    obligation.cause.body_id,\n+                    ObjectCastObligation(target),\n+                );\n+\n+                let predicate_to_obligation = |predicate| {\n+                    Obligation::with_depth(\n+                        cause.clone(),\n+                        obligation.recursion_depth + 1,\n+                        obligation.param_env,\n+                        predicate,\n+                    )\n+                };\n+\n+                // Create obligations:\n+                //  - Casting `T` to `Trait`\n+                //  - For all the various builtin bounds attached to the object cast. (In other\n+                //  words, if the object type is `Foo + Send`, this would create an obligation for\n+                //  the `Send` check.)\n+                //  - Projection predicates\n+                nested.extend(\n+                    data.iter().map(|predicate| {\n+                        predicate_to_obligation(predicate.with_self_ty(tcx, source))\n+                    }),\n+                );\n+\n+                // We can only make objects from sized types.\n+                let tr = ty::TraitRef::new(\n+                    tcx.require_lang_item(lang_items::SizedTraitLangItem, None),\n+                    tcx.mk_substs_trait(source, &[]),\n+                );\n+                nested.push(predicate_to_obligation(tr.without_const().to_predicate(tcx)));\n+\n+                // If the type is `Foo + 'a`, ensure that the type\n+                // being cast to `Foo + 'a` outlives `'a`:\n+                let outlives = ty::OutlivesPredicate(source, r);\n+                nested.push(predicate_to_obligation(ty::Binder::dummy(outlives).to_predicate(tcx)));\n+            }\n+\n+            // `[T; n]` -> `[T]`\n+            (&ty::Array(a, _), &ty::Slice(b)) => {\n+                let InferOk { obligations, .. } = self\n+                    .infcx\n+                    .at(&obligation.cause, obligation.param_env)\n+                    .eq(b, a)\n+                    .map_err(|_| Unimplemented)?;\n+                nested.extend(obligations);\n+            }\n+\n+            // `Struct<T>` -> `Struct<U>`\n+            (&ty::Adt(def, substs_a), &ty::Adt(_, substs_b)) => {\n+                let maybe_unsizing_param_idx = |arg: GenericArg<'tcx>| match arg.unpack() {\n+                    GenericArgKind::Type(ty) => match ty.kind {\n+                        ty::Param(p) => Some(p.index),\n+                        _ => None,\n+                    },\n+\n+                    // Lifetimes aren't allowed to change during unsizing.\n+                    GenericArgKind::Lifetime(_) => None,\n+\n+                    GenericArgKind::Const(ct) => match ct.val {\n+                        ty::ConstKind::Param(p) => Some(p.index),\n+                        _ => None,\n+                    },\n+                };\n+\n+                // The last field of the structure has to exist and contain type/const parameters.\n+                let (tail_field, prefix_fields) =\n+                    def.non_enum_variant().fields.split_last().ok_or(Unimplemented)?;\n+                let tail_field_ty = tcx.type_of(tail_field.did);\n+\n+                let mut unsizing_params = GrowableBitSet::new_empty();\n+                let mut found = false;\n+                for arg in tail_field_ty.walk() {\n+                    if let Some(i) = maybe_unsizing_param_idx(arg) {\n+                        unsizing_params.insert(i);\n+                        found = true;\n+                    }\n+                }\n+                if !found {\n+                    return Err(Unimplemented);\n+                }\n+\n+                // Ensure none of the other fields mention the parameters used\n+                // in unsizing.\n+                // FIXME(eddyb) cache this (including computing `unsizing_params`)\n+                // by putting it in a query; it would only need the `DefId` as it\n+                // looks at declared field types, not anything substituted.\n+                for field in prefix_fields {\n+                    for arg in tcx.type_of(field.did).walk() {\n+                        if let Some(i) = maybe_unsizing_param_idx(arg) {\n+                            if unsizing_params.contains(i) {\n+                                return Err(Unimplemented);\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // Extract `TailField<T>` and `TailField<U>` from `Struct<T>` and `Struct<U>`.\n+                let source_tail = tail_field_ty.subst(tcx, substs_a);\n+                let target_tail = tail_field_ty.subst(tcx, substs_b);\n+\n+                // Check that the source struct with the target's\n+                // unsizing parameters is equal to the target.\n+                let substs = tcx.mk_substs(substs_a.iter().enumerate().map(|(i, k)| {\n+                    if unsizing_params.contains(i as u32) { substs_b[i] } else { k }\n+                }));\n+                let new_struct = tcx.mk_adt(def, substs);\n+                let InferOk { obligations, .. } = self\n+                    .infcx\n+                    .at(&obligation.cause, obligation.param_env)\n+                    .eq(target, new_struct)\n+                    .map_err(|_| Unimplemented)?;\n+                nested.extend(obligations);\n+\n+                // Construct the nested `TailField<T>: Unsize<TailField<U>>` predicate.\n+                nested.push(predicate_for_trait_def(\n+                    tcx,\n+                    obligation.param_env,\n+                    obligation.cause.clone(),\n+                    obligation.predicate.def_id(),\n+                    obligation.recursion_depth + 1,\n+                    source_tail,\n+                    &[target_tail.into()],\n+                ));\n+            }\n+\n+            // `(.., T)` -> `(.., U)`\n+            (&ty::Tuple(tys_a), &ty::Tuple(tys_b)) => {\n+                assert_eq!(tys_a.len(), tys_b.len());\n+\n+                // The last field of the tuple has to exist.\n+                let (&a_last, a_mid) = tys_a.split_last().ok_or(Unimplemented)?;\n+                let &b_last = tys_b.last().unwrap();\n+\n+                // Check that the source tuple with the target's\n+                // last element is equal to the target.\n+                let new_tuple = tcx.mk_tup(\n+                    a_mid.iter().map(|k| k.expect_ty()).chain(iter::once(b_last.expect_ty())),\n+                );\n+                let InferOk { obligations, .. } = self\n+                    .infcx\n+                    .at(&obligation.cause, obligation.param_env)\n+                    .eq(target, new_tuple)\n+                    .map_err(|_| Unimplemented)?;\n+                nested.extend(obligations);\n+\n+                // Construct the nested `T: Unsize<U>` predicate.\n+                nested.push(ensure_sufficient_stack(|| {\n+                    predicate_for_trait_def(\n+                        tcx,\n+                        obligation.param_env,\n+                        obligation.cause.clone(),\n+                        obligation.predicate.def_id(),\n+                        obligation.recursion_depth + 1,\n+                        a_last.expect_ty(),\n+                        &[b_last],\n+                    )\n+                }));\n+            }\n+\n+            _ => bug!(),\n+        };\n+\n+        Ok(VtableBuiltinData { nested })\n+    }\n+}"}, {"sha": "def99a7b5b5285cefa9426703bb190564529b31d", "filename": "src/librustc_trait_selection/traits/select/mod.rs", "status": "renamed", "additions": 9, "deletions": 1413, "changes": 1422, "blob_url": "https://github.com/rust-lang/rust/blob/56daaf669ebc3d5083db5cded719f780dc31104e/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56daaf669ebc3d5083db5cded719f780dc31104e/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs?ref=56daaf669ebc3d5083db5cded719f780dc31104e", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-filelength\n-\n //! Candidate selection. See the [rustc dev guide] for more information on how this works.\n //!\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/traits/resolution.html#selection\n@@ -9,29 +7,19 @@ use self::SelectionCandidate::*;\n \n use super::coherence::{self, Conflict};\n use super::project;\n-use super::project::{normalize_with_depth, normalize_with_depth_to};\n+use super::project::normalize_with_depth_to;\n use super::util;\n use super::util::{closure_trait_ref_and_return_type, predicate_for_trait_def};\n use super::wf;\n use super::DerivedObligationCause;\n+use super::Obligation;\n+use super::ObligationCauseCode;\n use super::Selection;\n use super::SelectionResult;\n-use super::TraitNotObjectSafe;\n use super::TraitQueryMode;\n-use super::{BuiltinDerivedObligation, ImplDerivedObligation, ObligationCauseCode};\n use super::{Normalized, ProjectionCacheKey};\n-use super::{ObjectCastObligation, Obligation};\n use super::{ObligationCause, PredicateObligation, TraitObligation};\n-use super::{OutputTypeParameterMismatch, Overflow, SelectionError, Unimplemented};\n-use super::{\n-    VtableAutoImpl, VtableBuiltin, VtableClosure, VtableDiscriminantKind, VtableFnPointer,\n-    VtableGenerator, VtableImpl, VtableObject, VtableParam, VtableTraitAlias,\n-};\n-use super::{\n-    VtableAutoImplData, VtableBuiltinData, VtableClosureData, VtableDiscriminantKindData,\n-    VtableFnPointerData, VtableGeneratorData, VtableImplData, VtableObjectData,\n-    VtableTraitAliasData,\n-};\n+use super::{Overflow, SelectionError, Unimplemented};\n \n use crate::infer::{CombinedSnapshot, InferCtxt, InferOk, PlaceholderMap, TypeFreshener};\n use crate::traits::error_reporting::InferCtxtExt;\n@@ -42,18 +30,13 @@ use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::lang_items;\n-use rustc_index::bit_set::GrowableBitSet;\n use rustc_middle::dep_graph::{DepKind, DepNodeIndex};\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::fast_reject;\n use rustc_middle::ty::relate::TypeRelation;\n-use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst, SubstsRef};\n-use rustc_middle::ty::{\n-    self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n-};\n+use rustc_middle::ty::subst::{GenericArgKind, Subst, SubstsRef};\n+use rustc_middle::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use rustc_span::symbol::sym;\n-use rustc_target::spec::abi::Abi;\n \n use std::cell::{Cell, RefCell};\n use std::cmp;\n@@ -63,6 +46,9 @@ use std::rc::Rc;\n \n pub use rustc_middle::traits::select::*;\n \n+mod candidate_assembly;\n+mod confirmation;\n+\n pub struct SelectionContext<'cx, 'tcx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n \n@@ -932,61 +918,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         Ok(())\n     }\n \n-    ///////////////////////////////////////////////////////////////////////////\n-    // CANDIDATE ASSEMBLY\n-    //\n-    // The selection process begins by examining all in-scope impls,\n-    // caller obligations, and so forth and assembling a list of\n-    // candidates. See the [rustc dev guide] for more details.\n-    //\n-    // [rustc dev guide]:\n-    // https://rustc-dev-guide.rust-lang.org/traits/resolution.html#candidate-assembly\n-\n-    fn candidate_from_obligation<'o>(\n-        &mut self,\n-        stack: &TraitObligationStack<'o, 'tcx>,\n-    ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n-        // Watch out for overflow. This intentionally bypasses (and does\n-        // not update) the cache.\n-        self.check_recursion_limit(&stack.obligation, &stack.obligation)?;\n-\n-        // Check the cache. Note that we freshen the trait-ref\n-        // separately rather than using `stack.fresh_trait_ref` --\n-        // this is because we want the unbound variables to be\n-        // replaced with fresh types starting from index 0.\n-        let cache_fresh_trait_pred = self.infcx.freshen(stack.obligation.predicate);\n-        debug!(\n-            \"candidate_from_obligation(cache_fresh_trait_pred={:?}, obligation={:?})\",\n-            cache_fresh_trait_pred, stack\n-        );\n-        debug_assert!(!stack.obligation.predicate.has_escaping_bound_vars());\n-\n-        if let Some(c) =\n-            self.check_candidate_cache(stack.obligation.param_env, cache_fresh_trait_pred)\n-        {\n-            debug!(\"CACHE HIT: SELECT({:?})={:?}\", cache_fresh_trait_pred, c);\n-            return c;\n-        }\n-\n-        // If no match, compute result and insert into cache.\n-        //\n-        // FIXME(nikomatsakis) -- this cache is not taking into\n-        // account cycles that may have occurred in forming the\n-        // candidate. I don't know of any specific problems that\n-        // result but it seems awfully suspicious.\n-        let (candidate, dep_node) =\n-            self.in_task(|this| this.candidate_from_obligation_no_cache(stack));\n-\n-        debug!(\"CACHE MISS: SELECT({:?})={:?}\", cache_fresh_trait_pred, candidate);\n-        self.insert_candidate_cache(\n-            stack.obligation.param_env,\n-            cache_fresh_trait_pred,\n-            dep_node,\n-            candidate.clone(),\n-        );\n-        candidate\n-    }\n-\n     fn in_task<OP, R>(&mut self, op: OP) -> (R, DepNodeIndex)\n     where\n         OP: FnOnce(&mut Self) -> R,\n@@ -1320,116 +1251,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .insert(param_env.and(trait_ref), WithDepNode::new(dep_node, candidate));\n     }\n \n-    fn assemble_candidates<'o>(\n-        &mut self,\n-        stack: &TraitObligationStack<'o, 'tcx>,\n-    ) -> Result<SelectionCandidateSet<'tcx>, SelectionError<'tcx>> {\n-        let TraitObligationStack { obligation, .. } = *stack;\n-        let obligation = &Obligation {\n-            param_env: obligation.param_env,\n-            cause: obligation.cause.clone(),\n-            recursion_depth: obligation.recursion_depth,\n-            predicate: self.infcx().resolve_vars_if_possible(&obligation.predicate),\n-        };\n-\n-        if obligation.predicate.skip_binder().self_ty().is_ty_var() {\n-            // Self is a type variable (e.g., `_: AsRef<str>`).\n-            //\n-            // This is somewhat problematic, as the current scheme can't really\n-            // handle it turning to be a projection. This does end up as truly\n-            // ambiguous in most cases anyway.\n-            //\n-            // Take the fast path out - this also improves\n-            // performance by preventing assemble_candidates_from_impls from\n-            // matching every impl for this trait.\n-            return Ok(SelectionCandidateSet { vec: vec![], ambiguous: true });\n-        }\n-\n-        let mut candidates = SelectionCandidateSet { vec: Vec::new(), ambiguous: false };\n-\n-        self.assemble_candidates_for_trait_alias(obligation, &mut candidates)?;\n-\n-        // Other bounds. Consider both in-scope bounds from fn decl\n-        // and applicable impls. There is a certain set of precedence rules here.\n-        let def_id = obligation.predicate.def_id();\n-        let lang_items = self.tcx().lang_items();\n-\n-        if lang_items.copy_trait() == Some(def_id) {\n-            debug!(\"obligation self ty is {:?}\", obligation.predicate.skip_binder().self_ty());\n-\n-            // User-defined copy impls are permitted, but only for\n-            // structs and enums.\n-            self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n-\n-            // For other types, we'll use the builtin rules.\n-            let copy_conditions = self.copy_clone_conditions(obligation);\n-            self.assemble_builtin_bound_candidates(copy_conditions, &mut candidates)?;\n-        } else if lang_items.discriminant_kind_trait() == Some(def_id) {\n-            // `DiscriminantKind` is automatically implemented for every type.\n-            candidates.vec.push(DiscriminantKindCandidate);\n-        } else if lang_items.sized_trait() == Some(def_id) {\n-            // Sized is never implementable by end-users, it is\n-            // always automatically computed.\n-            let sized_conditions = self.sized_conditions(obligation);\n-            self.assemble_builtin_bound_candidates(sized_conditions, &mut candidates)?;\n-        } else if lang_items.unsize_trait() == Some(def_id) {\n-            self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n-        } else {\n-            if lang_items.clone_trait() == Some(def_id) {\n-                // Same builtin conditions as `Copy`, i.e., every type which has builtin support\n-                // for `Copy` also has builtin support for `Clone`, and tuples/arrays of `Clone`\n-                // types have builtin support for `Clone`.\n-                let clone_conditions = self.copy_clone_conditions(obligation);\n-                self.assemble_builtin_bound_candidates(clone_conditions, &mut candidates)?;\n-            }\n-\n-            self.assemble_generator_candidates(obligation, &mut candidates)?;\n-            self.assemble_closure_candidates(obligation, &mut candidates)?;\n-            self.assemble_fn_pointer_candidates(obligation, &mut candidates)?;\n-            self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n-            self.assemble_candidates_from_object_ty(obligation, &mut candidates);\n-        }\n-\n-        self.assemble_candidates_from_projected_tys(obligation, &mut candidates);\n-        self.assemble_candidates_from_caller_bounds(stack, &mut candidates)?;\n-        // Auto implementations have lower priority, so we only\n-        // consider triggering a default if there is no other impl that can apply.\n-        if candidates.vec.is_empty() {\n-            self.assemble_candidates_from_auto_impls(obligation, &mut candidates)?;\n-        }\n-        debug!(\"candidate list size: {}\", candidates.vec.len());\n-        Ok(candidates)\n-    }\n-\n-    fn assemble_candidates_from_projected_tys(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) {\n-        debug!(\"assemble_candidates_for_projected_tys({:?})\", obligation);\n-\n-        // Before we go into the whole placeholder thing, just\n-        // quickly check if the self-type is a projection at all.\n-        match obligation.predicate.skip_binder().trait_ref.self_ty().kind {\n-            ty::Projection(_) | ty::Opaque(..) => {}\n-            ty::Infer(ty::TyVar(_)) => {\n-                span_bug!(\n-                    obligation.cause.span,\n-                    \"Self=_ should have been handled by assemble_candidates\"\n-                );\n-            }\n-            _ => return,\n-        }\n-\n-        let result = self.infcx.probe(|snapshot| {\n-            self.match_projection_obligation_against_definition_bounds(obligation, snapshot)\n-        });\n-\n-        if result {\n-            candidates.vec.push(ProjectionCandidate);\n-        }\n-    }\n-\n     fn match_projection_obligation_against_definition_bounds(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n@@ -1523,42 +1344,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             && self.infcx.leak_check(false, placeholder_map, snapshot).is_ok()\n     }\n \n-    /// Given an obligation like `<SomeTrait for T>`, searches the obligations that the caller\n-    /// supplied to find out whether it is listed among them.\n-    ///\n-    /// Never affects the inference environment.\n-    fn assemble_candidates_from_caller_bounds<'o>(\n-        &mut self,\n-        stack: &TraitObligationStack<'o, 'tcx>,\n-        candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) -> Result<(), SelectionError<'tcx>> {\n-        debug!(\"assemble_candidates_from_caller_bounds({:?})\", stack.obligation);\n-\n-        let all_bounds = stack\n-            .obligation\n-            .param_env\n-            .caller_bounds\n-            .iter()\n-            .filter_map(|o| o.to_opt_poly_trait_ref());\n-\n-        // Micro-optimization: filter out predicates relating to different traits.\n-        let matching_bounds =\n-            all_bounds.filter(|p| p.def_id() == stack.obligation.predicate.def_id());\n-\n-        // Keep only those bounds which may apply, and propagate overflow if it occurs.\n-        let mut param_candidates = vec![];\n-        for bound in matching_bounds {\n-            let wc = self.evaluate_where_clause(stack, bound)?;\n-            if wc.may_apply() {\n-                param_candidates.push(ParamCandidate(bound));\n-            }\n-        }\n-\n-        candidates.vec.extend(param_candidates);\n-\n-        Ok(())\n-    }\n-\n     fn evaluate_where_clause<'o>(\n         &mut self,\n         stack: &TraitObligationStack<'o, 'tcx>,\n@@ -1574,383 +1359,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         })\n     }\n \n-    fn assemble_generator_candidates(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) -> Result<(), SelectionError<'tcx>> {\n-        if self.tcx().lang_items().gen_trait() != Some(obligation.predicate.def_id()) {\n-            return Ok(());\n-        }\n-\n-        // Okay to skip binder because the substs on generator types never\n-        // touch bound regions, they just capture the in-scope\n-        // type/region parameters.\n-        let self_ty = *obligation.self_ty().skip_binder();\n-        match self_ty.kind {\n-            ty::Generator(..) => {\n-                debug!(\n-                    \"assemble_generator_candidates: self_ty={:?} obligation={:?}\",\n-                    self_ty, obligation\n-                );\n-\n-                candidates.vec.push(GeneratorCandidate);\n-            }\n-            ty::Infer(ty::TyVar(_)) => {\n-                debug!(\"assemble_generator_candidates: ambiguous self-type\");\n-                candidates.ambiguous = true;\n-            }\n-            _ => {}\n-        }\n-\n-        Ok(())\n-    }\n-\n-    /// Checks for the artificial impl that the compiler will create for an obligation like `X :\n-    /// FnMut<..>` where `X` is a closure type.\n-    ///\n-    /// Note: the type parameters on a closure candidate are modeled as *output* type\n-    /// parameters and hence do not affect whether this trait is a match or not. They will be\n-    /// unified during the confirmation step.\n-    fn assemble_closure_candidates(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) -> Result<(), SelectionError<'tcx>> {\n-        let kind = match self.tcx().fn_trait_kind_from_lang_item(obligation.predicate.def_id()) {\n-            Some(k) => k,\n-            None => {\n-                return Ok(());\n-            }\n-        };\n-\n-        // Okay to skip binder because the substs on closure types never\n-        // touch bound regions, they just capture the in-scope\n-        // type/region parameters\n-        match obligation.self_ty().skip_binder().kind {\n-            ty::Closure(_, closure_substs) => {\n-                debug!(\"assemble_unboxed_candidates: kind={:?} obligation={:?}\", kind, obligation);\n-                match self.infcx.closure_kind(closure_substs) {\n-                    Some(closure_kind) => {\n-                        debug!(\"assemble_unboxed_candidates: closure_kind = {:?}\", closure_kind);\n-                        if closure_kind.extends(kind) {\n-                            candidates.vec.push(ClosureCandidate);\n-                        }\n-                    }\n-                    None => {\n-                        debug!(\"assemble_unboxed_candidates: closure_kind not yet known\");\n-                        candidates.vec.push(ClosureCandidate);\n-                    }\n-                }\n-            }\n-            ty::Infer(ty::TyVar(_)) => {\n-                debug!(\"assemble_unboxed_closure_candidates: ambiguous self-type\");\n-                candidates.ambiguous = true;\n-            }\n-            _ => {}\n-        }\n-\n-        Ok(())\n-    }\n-\n-    /// Implements one of the `Fn()` family for a fn pointer.\n-    fn assemble_fn_pointer_candidates(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) -> Result<(), SelectionError<'tcx>> {\n-        // We provide impl of all fn traits for fn pointers.\n-        if self.tcx().fn_trait_kind_from_lang_item(obligation.predicate.def_id()).is_none() {\n-            return Ok(());\n-        }\n-\n-        // Okay to skip binder because what we are inspecting doesn't involve bound regions.\n-        let self_ty = *obligation.self_ty().skip_binder();\n-        match self_ty.kind {\n-            ty::Infer(ty::TyVar(_)) => {\n-                debug!(\"assemble_fn_pointer_candidates: ambiguous self-type\");\n-                candidates.ambiguous = true; // Could wind up being a fn() type.\n-            }\n-            // Provide an impl, but only for suitable `fn` pointers.\n-            ty::FnDef(..) | ty::FnPtr(_) => {\n-                if let ty::FnSig {\n-                    unsafety: hir::Unsafety::Normal,\n-                    abi: Abi::Rust,\n-                    c_variadic: false,\n-                    ..\n-                } = self_ty.fn_sig(self.tcx()).skip_binder()\n-                {\n-                    candidates.vec.push(FnPointerCandidate);\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        Ok(())\n-    }\n-\n-    /// Searches for impls that might apply to `obligation`.\n-    fn assemble_candidates_from_impls(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) -> Result<(), SelectionError<'tcx>> {\n-        debug!(\"assemble_candidates_from_impls(obligation={:?})\", obligation);\n-\n-        self.tcx().for_each_relevant_impl(\n-            obligation.predicate.def_id(),\n-            obligation.predicate.skip_binder().trait_ref.self_ty(),\n-            |impl_def_id| {\n-                self.infcx.probe(|snapshot| {\n-                    if let Ok(_substs) = self.match_impl(impl_def_id, obligation, snapshot) {\n-                        candidates.vec.push(ImplCandidate(impl_def_id));\n-                    }\n-                });\n-            },\n-        );\n-\n-        Ok(())\n-    }\n-\n-    fn assemble_candidates_from_auto_impls(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) -> Result<(), SelectionError<'tcx>> {\n-        // Okay to skip binder here because the tests we do below do not involve bound regions.\n-        let self_ty = *obligation.self_ty().skip_binder();\n-        debug!(\"assemble_candidates_from_auto_impls(self_ty={:?})\", self_ty);\n-\n-        let def_id = obligation.predicate.def_id();\n-\n-        if self.tcx().trait_is_auto(def_id) {\n-            match self_ty.kind {\n-                ty::Dynamic(..) => {\n-                    // For object types, we don't know what the closed\n-                    // over types are. This means we conservatively\n-                    // say nothing; a candidate may be added by\n-                    // `assemble_candidates_from_object_ty`.\n-                }\n-                ty::Foreign(..) => {\n-                    // Since the contents of foreign types is unknown,\n-                    // we don't add any `..` impl. Default traits could\n-                    // still be provided by a manual implementation for\n-                    // this trait and type.\n-                }\n-                ty::Param(..) | ty::Projection(..) => {\n-                    // In these cases, we don't know what the actual\n-                    // type is.  Therefore, we cannot break it down\n-                    // into its constituent types. So we don't\n-                    // consider the `..` impl but instead just add no\n-                    // candidates: this means that typeck will only\n-                    // succeed if there is another reason to believe\n-                    // that this obligation holds. That could be a\n-                    // where-clause or, in the case of an object type,\n-                    // it could be that the object type lists the\n-                    // trait (e.g., `Foo+Send : Send`). See\n-                    // `compile-fail/typeck-default-trait-impl-send-param.rs`\n-                    // for an example of a test case that exercises\n-                    // this path.\n-                }\n-                ty::Infer(ty::TyVar(_)) => {\n-                    // The auto impl might apply; we don't know.\n-                    candidates.ambiguous = true;\n-                }\n-                ty::Generator(_, _, movability)\n-                    if self.tcx().lang_items().unpin_trait() == Some(def_id) =>\n-                {\n-                    match movability {\n-                        hir::Movability::Static => {\n-                            // Immovable generators are never `Unpin`, so\n-                            // suppress the normal auto-impl candidate for it.\n-                        }\n-                        hir::Movability::Movable => {\n-                            // Movable generators are always `Unpin`, so add an\n-                            // unconditional builtin candidate.\n-                            candidates.vec.push(BuiltinCandidate { has_nested: false });\n-                        }\n-                    }\n-                }\n-\n-                _ => candidates.vec.push(AutoImplCandidate(def_id)),\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-\n-    /// Searches for impls that might apply to `obligation`.\n-    fn assemble_candidates_from_object_ty(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) {\n-        debug!(\n-            \"assemble_candidates_from_object_ty(self_ty={:?})\",\n-            obligation.self_ty().skip_binder()\n-        );\n-\n-        self.infcx.probe(|_snapshot| {\n-            // The code below doesn't care about regions, and the\n-            // self-ty here doesn't escape this probe, so just erase\n-            // any LBR.\n-            let self_ty = self.tcx().erase_late_bound_regions(&obligation.self_ty());\n-            let poly_trait_ref = match self_ty.kind {\n-                ty::Dynamic(ref data, ..) => {\n-                    if data.auto_traits().any(|did| did == obligation.predicate.def_id()) {\n-                        debug!(\n-                            \"assemble_candidates_from_object_ty: matched builtin bound, \\\n-                             pushing candidate\"\n-                        );\n-                        candidates.vec.push(BuiltinObjectCandidate);\n-                        return;\n-                    }\n-\n-                    if let Some(principal) = data.principal() {\n-                        if !self.infcx.tcx.features().object_safe_for_dispatch {\n-                            principal.with_self_ty(self.tcx(), self_ty)\n-                        } else if self.tcx().is_object_safe(principal.def_id()) {\n-                            principal.with_self_ty(self.tcx(), self_ty)\n-                        } else {\n-                            return;\n-                        }\n-                    } else {\n-                        // Only auto trait bounds exist.\n-                        return;\n-                    }\n-                }\n-                ty::Infer(ty::TyVar(_)) => {\n-                    debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n-                    candidates.ambiguous = true; // could wind up being an object type\n-                    return;\n-                }\n-                _ => return,\n-            };\n-\n-            debug!(\"assemble_candidates_from_object_ty: poly_trait_ref={:?}\", poly_trait_ref);\n-\n-            // Count only those upcast versions that match the trait-ref\n-            // we are looking for. Specifically, do not only check for the\n-            // correct trait, but also the correct type parameters.\n-            // For example, we may be trying to upcast `Foo` to `Bar<i32>`,\n-            // but `Foo` is declared as `trait Foo: Bar<u32>`.\n-            let upcast_trait_refs = util::supertraits(self.tcx(), poly_trait_ref)\n-                .filter(|upcast_trait_ref| {\n-                    self.infcx\n-                        .probe(|_| self.match_poly_trait_ref(obligation, *upcast_trait_ref).is_ok())\n-                })\n-                .count();\n-\n-            if upcast_trait_refs > 1 {\n-                // Can be upcast in many ways; need more type information.\n-                candidates.ambiguous = true;\n-            } else if upcast_trait_refs == 1 {\n-                candidates.vec.push(ObjectCandidate);\n-            }\n-        })\n-    }\n-\n-    /// Searches for unsizing that might apply to `obligation`.\n-    fn assemble_candidates_for_unsizing(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) {\n-        // We currently never consider higher-ranked obligations e.g.\n-        // `for<'a> &'a T: Unsize<Trait+'a>` to be implemented. This is not\n-        // because they are a priori invalid, and we could potentially add support\n-        // for them later, it's just that there isn't really a strong need for it.\n-        // A `T: Unsize<U>` obligation is always used as part of a `T: CoerceUnsize<U>`\n-        // impl, and those are generally applied to concrete types.\n-        //\n-        // That said, one might try to write a fn with a where clause like\n-        //     for<'a> Foo<'a, T>: Unsize<Foo<'a, Trait>>\n-        // where the `'a` is kind of orthogonal to the relevant part of the `Unsize`.\n-        // Still, you'd be more likely to write that where clause as\n-        //     T: Trait\n-        // so it seems ok if we (conservatively) fail to accept that `Unsize`\n-        // obligation above. Should be possible to extend this in the future.\n-        let source = match obligation.self_ty().no_bound_vars() {\n-            Some(t) => t,\n-            None => {\n-                // Don't add any candidates if there are bound regions.\n-                return;\n-            }\n-        };\n-        let target = obligation.predicate.skip_binder().trait_ref.substs.type_at(1);\n-\n-        debug!(\"assemble_candidates_for_unsizing(source={:?}, target={:?})\", source, target);\n-\n-        let may_apply = match (&source.kind, &target.kind) {\n-            // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n-            (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n-                // Upcasts permit two things:\n-                //\n-                // 1. Dropping auto traits, e.g., `Foo + Send` to `Foo`\n-                // 2. Tightening the region bound, e.g., `Foo + 'a` to `Foo + 'b` if `'a: 'b`\n-                //\n-                // Note that neither of these changes requires any\n-                // change at runtime. Eventually this will be\n-                // generalized.\n-                //\n-                // We always upcast when we can because of reason\n-                // #2 (region bounds).\n-                data_a.principal_def_id() == data_b.principal_def_id()\n-                    && data_b\n-                        .auto_traits()\n-                        // All of a's auto traits need to be in b's auto traits.\n-                        .all(|b| data_a.auto_traits().any(|a| a == b))\n-            }\n-\n-            // `T` -> `Trait`\n-            (_, &ty::Dynamic(..)) => true,\n-\n-            // Ambiguous handling is below `T` -> `Trait`, because inference\n-            // variables can still implement `Unsize<Trait>` and nested\n-            // obligations will have the final say (likely deferred).\n-            (&ty::Infer(ty::TyVar(_)), _) | (_, &ty::Infer(ty::TyVar(_))) => {\n-                debug!(\"assemble_candidates_for_unsizing: ambiguous\");\n-                candidates.ambiguous = true;\n-                false\n-            }\n-\n-            // `[T; n]` -> `[T]`\n-            (&ty::Array(..), &ty::Slice(_)) => true,\n-\n-            // `Struct<T>` -> `Struct<U>`\n-            (&ty::Adt(def_id_a, _), &ty::Adt(def_id_b, _)) if def_id_a.is_struct() => {\n-                def_id_a == def_id_b\n-            }\n-\n-            // `(.., T)` -> `(.., U)`\n-            (&ty::Tuple(tys_a), &ty::Tuple(tys_b)) => tys_a.len() == tys_b.len(),\n-\n-            _ => false,\n-        };\n-\n-        if may_apply {\n-            candidates.vec.push(BuiltinUnsizeCandidate);\n-        }\n-    }\n-\n-    fn assemble_candidates_for_trait_alias(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) -> Result<(), SelectionError<'tcx>> {\n-        // Okay to skip binder here because the tests we do below do not involve bound regions.\n-        let self_ty = *obligation.self_ty().skip_binder();\n-        debug!(\"assemble_candidates_for_trait_alias(self_ty={:?})\", self_ty);\n-\n-        let def_id = obligation.predicate.def_id();\n-\n-        if self.tcx().is_trait_alias(def_id) {\n-            candidates.vec.push(TraitAliasCandidate(def_id));\n-        }\n-\n-        Ok(())\n-    }\n-\n     ///////////////////////////////////////////////////////////////////////////\n     // WINNOW\n     //\n@@ -2128,34 +1536,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n-    ///////////////////////////////////////////////////////////////////////////\n-    // BUILTIN BOUNDS\n-    //\n-    // These cover the traits that are built-in to the language\n-    // itself: `Copy`, `Clone` and `Sized`.\n-\n-    fn assemble_builtin_bound_candidates(\n-        &mut self,\n-        conditions: BuiltinImplConditions<'tcx>,\n-        candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) -> Result<(), SelectionError<'tcx>> {\n-        match conditions {\n-            BuiltinImplConditions::Where(nested) => {\n-                debug!(\"builtin_bound: nested={:?}\", nested);\n-                candidates\n-                    .vec\n-                    .push(BuiltinCandidate { has_nested: !nested.skip_binder().is_empty() });\n-            }\n-            BuiltinImplConditions::None => {}\n-            BuiltinImplConditions::Ambiguous => {\n-                debug!(\"assemble_builtin_bound_candidates: ambiguous builtin\");\n-                candidates.ambiguous = true;\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-\n     fn sized_conditions(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n@@ -2413,790 +1793,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .collect()\n     }\n \n-    ///////////////////////////////////////////////////////////////////////////\n-    // CONFIRMATION\n-    //\n-    // Confirmation unifies the output type parameters of the trait\n-    // with the values found in the obligation, possibly yielding a\n-    // type error.  See the [rustc dev guide] for more details.\n-    //\n-    // [rustc dev guide]:\n-    // https://rustc-dev-guide.rust-lang.org/traits/resolution.html#confirmation\n-\n-    fn confirm_candidate(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        candidate: SelectionCandidate<'tcx>,\n-    ) -> Result<Selection<'tcx>, SelectionError<'tcx>> {\n-        debug!(\"confirm_candidate({:?}, {:?})\", obligation, candidate);\n-\n-        match candidate {\n-            BuiltinCandidate { has_nested } => {\n-                let data = self.confirm_builtin_candidate(obligation, has_nested);\n-                Ok(VtableBuiltin(data))\n-            }\n-\n-            ParamCandidate(param) => {\n-                let obligations = self.confirm_param_candidate(obligation, param);\n-                Ok(VtableParam(obligations))\n-            }\n-\n-            ImplCandidate(impl_def_id) => {\n-                Ok(VtableImpl(self.confirm_impl_candidate(obligation, impl_def_id)))\n-            }\n-\n-            AutoImplCandidate(trait_def_id) => {\n-                let data = self.confirm_auto_impl_candidate(obligation, trait_def_id);\n-                Ok(VtableAutoImpl(data))\n-            }\n-\n-            ProjectionCandidate => {\n-                self.confirm_projection_candidate(obligation);\n-                Ok(VtableParam(Vec::new()))\n-            }\n-\n-            ClosureCandidate => {\n-                let vtable_closure = self.confirm_closure_candidate(obligation)?;\n-                Ok(VtableClosure(vtable_closure))\n-            }\n-\n-            GeneratorCandidate => {\n-                let vtable_generator = self.confirm_generator_candidate(obligation)?;\n-                Ok(VtableGenerator(vtable_generator))\n-            }\n-\n-            FnPointerCandidate => {\n-                let data = self.confirm_fn_pointer_candidate(obligation)?;\n-                Ok(VtableFnPointer(data))\n-            }\n-\n-            DiscriminantKindCandidate => Ok(VtableDiscriminantKind(VtableDiscriminantKindData)),\n-\n-            TraitAliasCandidate(alias_def_id) => {\n-                let data = self.confirm_trait_alias_candidate(obligation, alias_def_id);\n-                Ok(VtableTraitAlias(data))\n-            }\n-\n-            ObjectCandidate => {\n-                let data = self.confirm_object_candidate(obligation);\n-                Ok(VtableObject(data))\n-            }\n-\n-            BuiltinObjectCandidate => {\n-                // This indicates something like `Trait + Send: Send`. In this case, we know that\n-                // this holds because that's what the object type is telling us, and there's really\n-                // no additional obligations to prove and no types in particular to unify, etc.\n-                Ok(VtableParam(Vec::new()))\n-            }\n-\n-            BuiltinUnsizeCandidate => {\n-                let data = self.confirm_builtin_unsize_candidate(obligation)?;\n-                Ok(VtableBuiltin(data))\n-            }\n-        }\n-    }\n-\n-    fn confirm_projection_candidate(&mut self, obligation: &TraitObligation<'tcx>) {\n-        self.infcx.commit_unconditionally(|snapshot| {\n-            let result =\n-                self.match_projection_obligation_against_definition_bounds(obligation, snapshot);\n-            assert!(result);\n-        })\n-    }\n-\n-    fn confirm_param_candidate(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        param: ty::PolyTraitRef<'tcx>,\n-    ) -> Vec<PredicateObligation<'tcx>> {\n-        debug!(\"confirm_param_candidate({:?},{:?})\", obligation, param);\n-\n-        // During evaluation, we already checked that this\n-        // where-clause trait-ref could be unified with the obligation\n-        // trait-ref. Repeat that unification now without any\n-        // transactional boundary; it should not fail.\n-        match self.match_where_clause_trait_ref(obligation, param) {\n-            Ok(obligations) => obligations,\n-            Err(()) => {\n-                bug!(\n-                    \"Where clause `{:?}` was applicable to `{:?}` but now is not\",\n-                    param,\n-                    obligation\n-                );\n-            }\n-        }\n-    }\n-\n-    fn confirm_builtin_candidate(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        has_nested: bool,\n-    ) -> VtableBuiltinData<PredicateObligation<'tcx>> {\n-        debug!(\"confirm_builtin_candidate({:?}, {:?})\", obligation, has_nested);\n-\n-        let lang_items = self.tcx().lang_items();\n-        let obligations = if has_nested {\n-            let trait_def = obligation.predicate.def_id();\n-            let conditions = if Some(trait_def) == lang_items.sized_trait() {\n-                self.sized_conditions(obligation)\n-            } else if Some(trait_def) == lang_items.copy_trait() {\n-                self.copy_clone_conditions(obligation)\n-            } else if Some(trait_def) == lang_items.clone_trait() {\n-                self.copy_clone_conditions(obligation)\n-            } else {\n-                bug!(\"unexpected builtin trait {:?}\", trait_def)\n-            };\n-            let nested = match conditions {\n-                BuiltinImplConditions::Where(nested) => nested,\n-                _ => bug!(\"obligation {:?} had matched a builtin impl but now doesn't\", obligation),\n-            };\n-\n-            let cause = obligation.derived_cause(BuiltinDerivedObligation);\n-            ensure_sufficient_stack(|| {\n-                self.collect_predicates_for_types(\n-                    obligation.param_env,\n-                    cause,\n-                    obligation.recursion_depth + 1,\n-                    trait_def,\n-                    nested,\n-                )\n-            })\n-        } else {\n-            vec![]\n-        };\n-\n-        debug!(\"confirm_builtin_candidate: obligations={:?}\", obligations);\n-\n-        VtableBuiltinData { nested: obligations }\n-    }\n-\n-    /// This handles the case where a `auto trait Foo` impl is being used.\n-    /// The idea is that the impl applies to `X : Foo` if the following conditions are met:\n-    ///\n-    /// 1. For each constituent type `Y` in `X`, `Y : Foo` holds\n-    /// 2. For each where-clause `C` declared on `Foo`, `[Self => X] C` holds.\n-    fn confirm_auto_impl_candidate(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        trait_def_id: DefId,\n-    ) -> VtableAutoImplData<PredicateObligation<'tcx>> {\n-        debug!(\"confirm_auto_impl_candidate({:?}, {:?})\", obligation, trait_def_id);\n-\n-        let types = obligation.predicate.map_bound(|inner| {\n-            let self_ty = self.infcx.shallow_resolve(inner.self_ty());\n-            self.constituent_types_for_ty(self_ty)\n-        });\n-        self.vtable_auto_impl(obligation, trait_def_id, types)\n-    }\n-\n-    /// See `confirm_auto_impl_candidate`.\n-    fn vtable_auto_impl(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        trait_def_id: DefId,\n-        nested: ty::Binder<Vec<Ty<'tcx>>>,\n-    ) -> VtableAutoImplData<PredicateObligation<'tcx>> {\n-        debug!(\"vtable_auto_impl: nested={:?}\", nested);\n-        ensure_sufficient_stack(|| {\n-            let cause = obligation.derived_cause(BuiltinDerivedObligation);\n-            let mut obligations = self.collect_predicates_for_types(\n-                obligation.param_env,\n-                cause,\n-                obligation.recursion_depth + 1,\n-                trait_def_id,\n-                nested,\n-            );\n-\n-            let trait_obligations: Vec<PredicateObligation<'_>> =\n-                self.infcx.commit_unconditionally(|_| {\n-                    let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n-                    let (trait_ref, _) =\n-                        self.infcx.replace_bound_vars_with_placeholders(&poly_trait_ref);\n-                    let cause = obligation.derived_cause(ImplDerivedObligation);\n-                    self.impl_or_trait_obligations(\n-                        cause,\n-                        obligation.recursion_depth + 1,\n-                        obligation.param_env,\n-                        trait_def_id,\n-                        &trait_ref.substs,\n-                    )\n-                });\n-\n-            // Adds the predicates from the trait.  Note that this contains a `Self: Trait`\n-            // predicate as usual.  It won't have any effect since auto traits are coinductive.\n-            obligations.extend(trait_obligations);\n-\n-            debug!(\"vtable_auto_impl: obligations={:?}\", obligations);\n-\n-            VtableAutoImplData { trait_def_id, nested: obligations }\n-        })\n-    }\n-\n-    fn confirm_impl_candidate(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        impl_def_id: DefId,\n-    ) -> VtableImplData<'tcx, PredicateObligation<'tcx>> {\n-        debug!(\"confirm_impl_candidate({:?},{:?})\", obligation, impl_def_id);\n-\n-        // First, create the substitutions by matching the impl again,\n-        // this time not in a probe.\n-        self.infcx.commit_unconditionally(|snapshot| {\n-            let substs = self.rematch_impl(impl_def_id, obligation, snapshot);\n-            debug!(\"confirm_impl_candidate: substs={:?}\", substs);\n-            let cause = obligation.derived_cause(ImplDerivedObligation);\n-            ensure_sufficient_stack(|| {\n-                self.vtable_impl(\n-                    impl_def_id,\n-                    substs,\n-                    cause,\n-                    obligation.recursion_depth + 1,\n-                    obligation.param_env,\n-                )\n-            })\n-        })\n-    }\n-\n-    fn vtable_impl(\n-        &mut self,\n-        impl_def_id: DefId,\n-        mut substs: Normalized<'tcx, SubstsRef<'tcx>>,\n-        cause: ObligationCause<'tcx>,\n-        recursion_depth: usize,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> VtableImplData<'tcx, PredicateObligation<'tcx>> {\n-        debug!(\n-            \"vtable_impl(impl_def_id={:?}, substs={:?}, recursion_depth={})\",\n-            impl_def_id, substs, recursion_depth,\n-        );\n-\n-        let mut impl_obligations = self.impl_or_trait_obligations(\n-            cause,\n-            recursion_depth,\n-            param_env,\n-            impl_def_id,\n-            &substs.value,\n-        );\n-\n-        debug!(\n-            \"vtable_impl: impl_def_id={:?} impl_obligations={:?}\",\n-            impl_def_id, impl_obligations\n-        );\n-\n-        // Because of RFC447, the impl-trait-ref and obligations\n-        // are sufficient to determine the impl substs, without\n-        // relying on projections in the impl-trait-ref.\n-        //\n-        // e.g., `impl<U: Tr, V: Iterator<Item=U>> Foo<<U as Tr>::T> for V`\n-        impl_obligations.append(&mut substs.obligations);\n-\n-        VtableImplData { impl_def_id, substs: substs.value, nested: impl_obligations }\n-    }\n-\n-    fn confirm_object_candidate(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-    ) -> VtableObjectData<'tcx, PredicateObligation<'tcx>> {\n-        debug!(\"confirm_object_candidate({:?})\", obligation);\n-\n-        // FIXME(nmatsakis) skipping binder here seems wrong -- we should\n-        // probably flatten the binder from the obligation and the binder\n-        // from the object. Have to try to make a broken test case that\n-        // results.\n-        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n-        let poly_trait_ref = match self_ty.kind {\n-            ty::Dynamic(ref data, ..) => data\n-                .principal()\n-                .unwrap_or_else(|| {\n-                    span_bug!(obligation.cause.span, \"object candidate with no principal\")\n-                })\n-                .with_self_ty(self.tcx(), self_ty),\n-            _ => span_bug!(obligation.cause.span, \"object candidate with non-object\"),\n-        };\n-\n-        let mut upcast_trait_ref = None;\n-        let mut nested = vec![];\n-        let vtable_base;\n-\n-        {\n-            let tcx = self.tcx();\n-\n-            // We want to find the first supertrait in the list of\n-            // supertraits that we can unify with, and do that\n-            // unification. We know that there is exactly one in the list\n-            // where we can unify, because otherwise select would have\n-            // reported an ambiguity. (When we do find a match, also\n-            // record it for later.)\n-            let nonmatching = util::supertraits(tcx, poly_trait_ref).take_while(|&t| {\n-                match self.infcx.commit_if_ok(|_| self.match_poly_trait_ref(obligation, t)) {\n-                    Ok(obligations) => {\n-                        upcast_trait_ref = Some(t);\n-                        nested.extend(obligations);\n-                        false\n-                    }\n-                    Err(_) => true,\n-                }\n-            });\n-\n-            // Additionally, for each of the non-matching predicates that\n-            // we pass over, we sum up the set of number of vtable\n-            // entries, so that we can compute the offset for the selected\n-            // trait.\n-            vtable_base = nonmatching.map(|t| super::util::count_own_vtable_entries(tcx, t)).sum();\n-        }\n-\n-        VtableObjectData { upcast_trait_ref: upcast_trait_ref.unwrap(), vtable_base, nested }\n-    }\n-\n-    fn confirm_fn_pointer_candidate(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-    ) -> Result<VtableFnPointerData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n-        debug!(\"confirm_fn_pointer_candidate({:?})\", obligation);\n-\n-        // Okay to skip binder; it is reintroduced below.\n-        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n-        let sig = self_ty.fn_sig(self.tcx());\n-        let trait_ref = closure_trait_ref_and_return_type(\n-            self.tcx(),\n-            obligation.predicate.def_id(),\n-            self_ty,\n-            sig,\n-            util::TupleArgumentsFlag::Yes,\n-        )\n-        .map_bound(|(trait_ref, _)| trait_ref);\n-\n-        let Normalized { value: trait_ref, obligations } = ensure_sufficient_stack(|| {\n-            project::normalize_with_depth(\n-                self,\n-                obligation.param_env,\n-                obligation.cause.clone(),\n-                obligation.recursion_depth + 1,\n-                &trait_ref,\n-            )\n-        });\n-\n-        self.confirm_poly_trait_refs(\n-            obligation.cause.clone(),\n-            obligation.param_env,\n-            obligation.predicate.to_poly_trait_ref(),\n-            trait_ref,\n-        )?;\n-        Ok(VtableFnPointerData { fn_ty: self_ty, nested: obligations })\n-    }\n-\n-    fn confirm_trait_alias_candidate(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        alias_def_id: DefId,\n-    ) -> VtableTraitAliasData<'tcx, PredicateObligation<'tcx>> {\n-        debug!(\"confirm_trait_alias_candidate({:?}, {:?})\", obligation, alias_def_id);\n-\n-        self.infcx.commit_unconditionally(|_| {\n-            let (predicate, _) =\n-                self.infcx().replace_bound_vars_with_placeholders(&obligation.predicate);\n-            let trait_ref = predicate.trait_ref;\n-            let trait_def_id = trait_ref.def_id;\n-            let substs = trait_ref.substs;\n-\n-            let trait_obligations = self.impl_or_trait_obligations(\n-                obligation.cause.clone(),\n-                obligation.recursion_depth,\n-                obligation.param_env,\n-                trait_def_id,\n-                &substs,\n-            );\n-\n-            debug!(\n-                \"confirm_trait_alias_candidate: trait_def_id={:?} trait_obligations={:?}\",\n-                trait_def_id, trait_obligations\n-            );\n-\n-            VtableTraitAliasData { alias_def_id, substs, nested: trait_obligations }\n-        })\n-    }\n-\n-    fn confirm_generator_candidate(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-    ) -> Result<VtableGeneratorData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n-        // Okay to skip binder because the substs on generator types never\n-        // touch bound regions, they just capture the in-scope\n-        // type/region parameters.\n-        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n-        let (generator_def_id, substs) = match self_ty.kind {\n-            ty::Generator(id, substs, _) => (id, substs),\n-            _ => bug!(\"closure candidate for non-closure {:?}\", obligation),\n-        };\n-\n-        debug!(\"confirm_generator_candidate({:?},{:?},{:?})\", obligation, generator_def_id, substs);\n-\n-        let trait_ref = self.generator_trait_ref_unnormalized(obligation, substs);\n-        let Normalized { value: trait_ref, mut obligations } = ensure_sufficient_stack(|| {\n-            normalize_with_depth(\n-                self,\n-                obligation.param_env,\n-                obligation.cause.clone(),\n-                obligation.recursion_depth + 1,\n-                &trait_ref,\n-            )\n-        });\n-\n-        debug!(\n-            \"confirm_generator_candidate(generator_def_id={:?}, \\\n-             trait_ref={:?}, obligations={:?})\",\n-            generator_def_id, trait_ref, obligations\n-        );\n-\n-        obligations.extend(self.confirm_poly_trait_refs(\n-            obligation.cause.clone(),\n-            obligation.param_env,\n-            obligation.predicate.to_poly_trait_ref(),\n-            trait_ref,\n-        )?);\n-\n-        Ok(VtableGeneratorData { generator_def_id, substs, nested: obligations })\n-    }\n-\n-    fn confirm_closure_candidate(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-    ) -> Result<VtableClosureData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n-        debug!(\"confirm_closure_candidate({:?})\", obligation);\n-\n-        let kind = self\n-            .tcx()\n-            .fn_trait_kind_from_lang_item(obligation.predicate.def_id())\n-            .unwrap_or_else(|| bug!(\"closure candidate for non-fn trait {:?}\", obligation));\n-\n-        // Okay to skip binder because the substs on closure types never\n-        // touch bound regions, they just capture the in-scope\n-        // type/region parameters.\n-        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n-        let (closure_def_id, substs) = match self_ty.kind {\n-            ty::Closure(id, substs) => (id, substs),\n-            _ => bug!(\"closure candidate for non-closure {:?}\", obligation),\n-        };\n-\n-        let trait_ref = self.closure_trait_ref_unnormalized(obligation, substs);\n-        let Normalized { value: trait_ref, mut obligations } = ensure_sufficient_stack(|| {\n-            normalize_with_depth(\n-                self,\n-                obligation.param_env,\n-                obligation.cause.clone(),\n-                obligation.recursion_depth + 1,\n-                &trait_ref,\n-            )\n-        });\n-\n-        debug!(\n-            \"confirm_closure_candidate(closure_def_id={:?}, trait_ref={:?}, obligations={:?})\",\n-            closure_def_id, trait_ref, obligations\n-        );\n-\n-        obligations.extend(self.confirm_poly_trait_refs(\n-            obligation.cause.clone(),\n-            obligation.param_env,\n-            obligation.predicate.to_poly_trait_ref(),\n-            trait_ref,\n-        )?);\n-\n-        // FIXME: Chalk\n-\n-        if !self.tcx().sess.opts.debugging_opts.chalk {\n-            obligations.push(Obligation::new(\n-                obligation.cause.clone(),\n-                obligation.param_env,\n-                ty::PredicateKind::ClosureKind(closure_def_id, substs, kind)\n-                    .to_predicate(self.tcx()),\n-            ));\n-        }\n-\n-        Ok(VtableClosureData { closure_def_id, substs, nested: obligations })\n-    }\n-\n-    /// In the case of closure types and fn pointers,\n-    /// we currently treat the input type parameters on the trait as\n-    /// outputs. This means that when we have a match we have only\n-    /// considered the self type, so we have to go back and make sure\n-    /// to relate the argument types too. This is kind of wrong, but\n-    /// since we control the full set of impls, also not that wrong,\n-    /// and it DOES yield better error messages (since we don't report\n-    /// errors as if there is no applicable impl, but rather report\n-    /// errors are about mismatched argument types.\n-    ///\n-    /// Here is an example. Imagine we have a closure expression\n-    /// and we desugared it so that the type of the expression is\n-    /// `Closure`, and `Closure` expects an int as argument. Then it\n-    /// is \"as if\" the compiler generated this impl:\n-    ///\n-    ///     impl Fn(int) for Closure { ... }\n-    ///\n-    /// Now imagine our obligation is `Fn(usize) for Closure`. So far\n-    /// we have matched the self type `Closure`. At this point we'll\n-    /// compare the `int` to `usize` and generate an error.\n-    ///\n-    /// Note that this checking occurs *after* the impl has selected,\n-    /// because these output type parameters should not affect the\n-    /// selection of the impl. Therefore, if there is a mismatch, we\n-    /// report an error to the user.\n-    fn confirm_poly_trait_refs(\n-        &mut self,\n-        obligation_cause: ObligationCause<'tcx>,\n-        obligation_param_env: ty::ParamEnv<'tcx>,\n-        obligation_trait_ref: ty::PolyTraitRef<'tcx>,\n-        expected_trait_ref: ty::PolyTraitRef<'tcx>,\n-    ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n-        self.infcx\n-            .at(&obligation_cause, obligation_param_env)\n-            .sup(obligation_trait_ref, expected_trait_ref)\n-            .map(|InferOk { obligations, .. }| obligations)\n-            .map_err(|e| OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n-    }\n-\n-    fn confirm_builtin_unsize_candidate(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-    ) -> Result<VtableBuiltinData<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n-        let tcx = self.tcx();\n-\n-        // `assemble_candidates_for_unsizing` should ensure there are no late-bound\n-        // regions here. See the comment there for more details.\n-        let source = self.infcx.shallow_resolve(obligation.self_ty().no_bound_vars().unwrap());\n-        let target = obligation.predicate.skip_binder().trait_ref.substs.type_at(1);\n-        let target = self.infcx.shallow_resolve(target);\n-\n-        debug!(\"confirm_builtin_unsize_candidate(source={:?}, target={:?})\", source, target);\n-\n-        let mut nested = vec![];\n-        match (&source.kind, &target.kind) {\n-            // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n-            (&ty::Dynamic(ref data_a, r_a), &ty::Dynamic(ref data_b, r_b)) => {\n-                // See `assemble_candidates_for_unsizing` for more info.\n-                let existential_predicates = data_a.map_bound(|data_a| {\n-                    let iter = data_a\n-                        .principal()\n-                        .map(ty::ExistentialPredicate::Trait)\n-                        .into_iter()\n-                        .chain(data_a.projection_bounds().map(ty::ExistentialPredicate::Projection))\n-                        .chain(data_b.auto_traits().map(ty::ExistentialPredicate::AutoTrait));\n-                    tcx.mk_existential_predicates(iter)\n-                });\n-                let source_trait = tcx.mk_dynamic(existential_predicates, r_b);\n-\n-                // Require that the traits involved in this upcast are **equal**;\n-                // only the **lifetime bound** is changed.\n-                //\n-                // FIXME: This condition is arguably too strong -- it would\n-                // suffice for the source trait to be a *subtype* of the target\n-                // trait. In particular, changing from something like\n-                // `for<'a, 'b> Foo<'a, 'b>` to `for<'a> Foo<'a, 'a>` should be\n-                // permitted. And, indeed, in the in commit\n-                // 904a0bde93f0348f69914ee90b1f8b6e4e0d7cbc, this\n-                // condition was loosened. However, when the leak check was\n-                // added back, using subtype here actually guides the coercion\n-                // code in such a way that it accepts `old-lub-glb-object.rs`.\n-                // This is probably a good thing, but I've modified this to `.eq`\n-                // because I want to continue rejecting that test (as we have\n-                // done for quite some time) before we are firmly comfortable\n-                // with what our behavior should be there. -nikomatsakis\n-                let InferOk { obligations, .. } = self\n-                    .infcx\n-                    .at(&obligation.cause, obligation.param_env)\n-                    .eq(target, source_trait) // FIXME -- see below\n-                    .map_err(|_| Unimplemented)?;\n-                nested.extend(obligations);\n-\n-                // Register one obligation for 'a: 'b.\n-                let cause = ObligationCause::new(\n-                    obligation.cause.span,\n-                    obligation.cause.body_id,\n-                    ObjectCastObligation(target),\n-                );\n-                let outlives = ty::OutlivesPredicate(r_a, r_b);\n-                nested.push(Obligation::with_depth(\n-                    cause,\n-                    obligation.recursion_depth + 1,\n-                    obligation.param_env,\n-                    ty::Binder::bind(outlives).to_predicate(tcx),\n-                ));\n-            }\n-\n-            // `T` -> `Trait`\n-            (_, &ty::Dynamic(ref data, r)) => {\n-                let mut object_dids = data.auto_traits().chain(data.principal_def_id());\n-                if let Some(did) = object_dids.find(|did| !tcx.is_object_safe(*did)) {\n-                    return Err(TraitNotObjectSafe(did));\n-                }\n-\n-                let cause = ObligationCause::new(\n-                    obligation.cause.span,\n-                    obligation.cause.body_id,\n-                    ObjectCastObligation(target),\n-                );\n-\n-                let predicate_to_obligation = |predicate| {\n-                    Obligation::with_depth(\n-                        cause.clone(),\n-                        obligation.recursion_depth + 1,\n-                        obligation.param_env,\n-                        predicate,\n-                    )\n-                };\n-\n-                // Create obligations:\n-                //  - Casting `T` to `Trait`\n-                //  - For all the various builtin bounds attached to the object cast. (In other\n-                //  words, if the object type is `Foo + Send`, this would create an obligation for\n-                //  the `Send` check.)\n-                //  - Projection predicates\n-                nested.extend(\n-                    data.iter().map(|predicate| {\n-                        predicate_to_obligation(predicate.with_self_ty(tcx, source))\n-                    }),\n-                );\n-\n-                // We can only make objects from sized types.\n-                let tr = ty::TraitRef::new(\n-                    tcx.require_lang_item(lang_items::SizedTraitLangItem, None),\n-                    tcx.mk_substs_trait(source, &[]),\n-                );\n-                nested.push(predicate_to_obligation(tr.without_const().to_predicate(tcx)));\n-\n-                // If the type is `Foo + 'a`, ensure that the type\n-                // being cast to `Foo + 'a` outlives `'a`:\n-                let outlives = ty::OutlivesPredicate(source, r);\n-                nested.push(predicate_to_obligation(ty::Binder::dummy(outlives).to_predicate(tcx)));\n-            }\n-\n-            // `[T; n]` -> `[T]`\n-            (&ty::Array(a, _), &ty::Slice(b)) => {\n-                let InferOk { obligations, .. } = self\n-                    .infcx\n-                    .at(&obligation.cause, obligation.param_env)\n-                    .eq(b, a)\n-                    .map_err(|_| Unimplemented)?;\n-                nested.extend(obligations);\n-            }\n-\n-            // `Struct<T>` -> `Struct<U>`\n-            (&ty::Adt(def, substs_a), &ty::Adt(_, substs_b)) => {\n-                let maybe_unsizing_param_idx = |arg: GenericArg<'tcx>| match arg.unpack() {\n-                    GenericArgKind::Type(ty) => match ty.kind {\n-                        ty::Param(p) => Some(p.index),\n-                        _ => None,\n-                    },\n-\n-                    // Lifetimes aren't allowed to change during unsizing.\n-                    GenericArgKind::Lifetime(_) => None,\n-\n-                    GenericArgKind::Const(ct) => match ct.val {\n-                        ty::ConstKind::Param(p) => Some(p.index),\n-                        _ => None,\n-                    },\n-                };\n-\n-                // The last field of the structure has to exist and contain type/const parameters.\n-                let (tail_field, prefix_fields) =\n-                    def.non_enum_variant().fields.split_last().ok_or(Unimplemented)?;\n-                let tail_field_ty = tcx.type_of(tail_field.did);\n-\n-                let mut unsizing_params = GrowableBitSet::new_empty();\n-                let mut found = false;\n-                for arg in tail_field_ty.walk() {\n-                    if let Some(i) = maybe_unsizing_param_idx(arg) {\n-                        unsizing_params.insert(i);\n-                        found = true;\n-                    }\n-                }\n-                if !found {\n-                    return Err(Unimplemented);\n-                }\n-\n-                // Ensure none of the other fields mention the parameters used\n-                // in unsizing.\n-                // FIXME(eddyb) cache this (including computing `unsizing_params`)\n-                // by putting it in a query; it would only need the `DefId` as it\n-                // looks at declared field types, not anything substituted.\n-                for field in prefix_fields {\n-                    for arg in tcx.type_of(field.did).walk() {\n-                        if let Some(i) = maybe_unsizing_param_idx(arg) {\n-                            if unsizing_params.contains(i) {\n-                                return Err(Unimplemented);\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                // Extract `TailField<T>` and `TailField<U>` from `Struct<T>` and `Struct<U>`.\n-                let source_tail = tail_field_ty.subst(tcx, substs_a);\n-                let target_tail = tail_field_ty.subst(tcx, substs_b);\n-\n-                // Check that the source struct with the target's\n-                // unsizing parameters is equal to the target.\n-                let substs = tcx.mk_substs(substs_a.iter().enumerate().map(|(i, k)| {\n-                    if unsizing_params.contains(i as u32) { substs_b[i] } else { k }\n-                }));\n-                let new_struct = tcx.mk_adt(def, substs);\n-                let InferOk { obligations, .. } = self\n-                    .infcx\n-                    .at(&obligation.cause, obligation.param_env)\n-                    .eq(target, new_struct)\n-                    .map_err(|_| Unimplemented)?;\n-                nested.extend(obligations);\n-\n-                // Construct the nested `TailField<T>: Unsize<TailField<U>>` predicate.\n-                nested.push(predicate_for_trait_def(\n-                    tcx,\n-                    obligation.param_env,\n-                    obligation.cause.clone(),\n-                    obligation.predicate.def_id(),\n-                    obligation.recursion_depth + 1,\n-                    source_tail,\n-                    &[target_tail.into()],\n-                ));\n-            }\n-\n-            // `(.., T)` -> `(.., U)`\n-            (&ty::Tuple(tys_a), &ty::Tuple(tys_b)) => {\n-                assert_eq!(tys_a.len(), tys_b.len());\n-\n-                // The last field of the tuple has to exist.\n-                let (&a_last, a_mid) = tys_a.split_last().ok_or(Unimplemented)?;\n-                let &b_last = tys_b.last().unwrap();\n-\n-                // Check that the source tuple with the target's\n-                // last element is equal to the target.\n-                let new_tuple = tcx.mk_tup(\n-                    a_mid.iter().map(|k| k.expect_ty()).chain(iter::once(b_last.expect_ty())),\n-                );\n-                let InferOk { obligations, .. } = self\n-                    .infcx\n-                    .at(&obligation.cause, obligation.param_env)\n-                    .eq(target, new_tuple)\n-                    .map_err(|_| Unimplemented)?;\n-                nested.extend(obligations);\n-\n-                // Construct the nested `T: Unsize<U>` predicate.\n-                nested.push(ensure_sufficient_stack(|| {\n-                    predicate_for_trait_def(\n-                        tcx,\n-                        obligation.param_env,\n-                        obligation.cause.clone(),\n-                        obligation.predicate.def_id(),\n-                        obligation.recursion_depth + 1,\n-                        a_last.expect_ty(),\n-                        &[b_last],\n-                    )\n-                }));\n-            }\n-\n-            _ => bug!(),\n-        };\n-\n-        Ok(VtableBuiltinData { nested })\n-    }\n-\n     ///////////////////////////////////////////////////////////////////////////\n     // Matching\n     //", "previous_filename": "src/librustc_trait_selection/traits/select.rs"}, {"sha": "e986a39eb03e07dd5541be2da99d16101a1ab49e", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56daaf669ebc3d5083db5cded719f780dc31104e/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56daaf669ebc3d5083db5cded719f780dc31104e/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=56daaf669ebc3d5083db5cded719f780dc31104e", "patch": "@@ -184,7 +184,6 @@ impl<R> BufReader<R> {\n     /// # Examples\n     ///\n     /// ```no_run\n-    /// #![feature(buffered_io_capacity)]\n     /// use std::io::{BufReader, BufRead};\n     /// use std::fs::File;\n     ///\n@@ -198,7 +197,7 @@ impl<R> BufReader<R> {\n     ///     Ok(())\n     /// }\n     /// ```\n-    #[unstable(feature = \"buffered_io_capacity\", issue = \"68833\")]\n+    #[stable(feature = \"buffered_io_capacity\", since = \"1.46.0\")]\n     pub fn capacity(&self) -> usize {\n         self.buf.len()\n     }\n@@ -609,7 +608,6 @@ impl<W: Write> BufWriter<W> {\n     /// # Examples\n     ///\n     /// ```no_run\n-    /// #![feature(buffered_io_capacity)]\n     /// use std::io::BufWriter;\n     /// use std::net::TcpStream;\n     ///\n@@ -620,7 +618,7 @@ impl<W: Write> BufWriter<W> {\n     /// // Calculate how many bytes can be written without flushing\n     /// let without_flush = capacity - buf_writer.buffer().len();\n     /// ```\n-    #[unstable(feature = \"buffered_io_capacity\", issue = \"68833\")]\n+    #[stable(feature = \"buffered_io_capacity\", since = \"1.46.0\")]\n     pub fn capacity(&self) -> usize {\n         self.buf.capacity()\n     }"}, {"sha": "8c273cb534d744b67561c0dfb9d6e00f26854f50", "filename": "src/test/ui/unused-crate-deps/ignore-pathless-extern.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/56daaf669ebc3d5083db5cded719f780dc31104e/src%2Ftest%2Fui%2Funused-crate-deps%2Fignore-pathless-extern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56daaf669ebc3d5083db5cded719f780dc31104e/src%2Ftest%2Fui%2Funused-crate-deps%2Fignore-pathless-extern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funused-crate-deps%2Fignore-pathless-extern.rs?ref=56daaf669ebc3d5083db5cded719f780dc31104e", "patch": "@@ -0,0 +1,12 @@\n+// Pathless --extern references don't count\n+\n+// edition:2018\n+// check-pass\n+// aux-crate:bar=bar.rs\n+// compile-flags:--extern proc_macro\n+\n+#![warn(unused_crate_dependencies)]\n+\n+use bar as _;\n+\n+fn main() {}"}]}