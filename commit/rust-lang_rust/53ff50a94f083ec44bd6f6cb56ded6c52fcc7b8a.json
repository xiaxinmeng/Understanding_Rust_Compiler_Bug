{"sha": "53ff50a94f083ec44bd6f6cb56ded6c52fcc7b8a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzZmY1MGE5NGYwODNlYzQ0YmQ2ZjZjYjU2ZGVkNmM1MmZjYzdiOGE=", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2016-12-08T18:02:22Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2016-12-30T14:17:28Z"}, "message": "Port to wrapping_* and unchecked_* operations\n\nOtherwise, we codegen panic calls which create problems with debug assertions turned on.", "tree": {"sha": "cd2e2402ca74207072d4454188391b22ba2433a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd2e2402ca74207072d4454188391b22ba2433a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53ff50a94f083ec44bd6f6cb56ded6c52fcc7b8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53ff50a94f083ec44bd6f6cb56ded6c52fcc7b8a", "html_url": "https://github.com/rust-lang/rust/commit/53ff50a94f083ec44bd6f6cb56ded6c52fcc7b8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53ff50a94f083ec44bd6f6cb56ded6c52fcc7b8a/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3be141f1b46be54607277444956a211ee56a359c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3be141f1b46be54607277444956a211ee56a359c", "html_url": "https://github.com/rust-lang/rust/commit/3be141f1b46be54607277444956a211ee56a359c"}], "stats": {"total": 196, "additions": 118, "deletions": 78}, "files": [{"sha": "8d124b7e0aab881c1e4b0d5bcfacacb34e0bdb2e", "filename": "src/libcompiler_builtins/lib.rs", "status": "modified", "additions": 118, "deletions": 78, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/53ff50a94f083ec44bd6f6cb56ded6c52fcc7b8a/src%2Flibcompiler_builtins%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ff50a94f083ec44bd6f6cb56ded6c52fcc7b8a/src%2Flibcompiler_builtins%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2Flib.rs?ref=53ff50a94f083ec44bd6f6cb56ded6c52fcc7b8a", "patch": "@@ -50,13 +50,17 @@ pub mod reimpls {\n         ($a:expr, $b:expr, $ty:ty) => {{\n             let (a, b) = ($a, $b);\n             let bits = (::core::mem::size_of::<$ty>() * 8) as $ty;\n-            let half_bits = bits / 2;\n+            let half_bits = bits >> 1;\n             if b & half_bits != 0 {\n-                <$ty>::from_parts(0, a.low() << (b - half_bits))\n+                <$ty>::from_parts(0, a.low().wrapping_shl(\n+                                        b.wrapping_sub(half_bits) as u32))\n             } else if b == 0 {\n                 a\n             } else {\n-                <$ty>::from_parts(a.low() << b, (a.high() << b) | (a.low() >> (half_bits - b)))\n+                <$ty>::from_parts(a.low().wrapping_shl(b as u32),\n+                                  a.high().wrapping_shl(b as u32)\n+                                  | a.low()\n+                                     .wrapping_shr(half_bits.wrapping_sub(b) as u32))\n             }\n         }}\n     }\n@@ -72,14 +76,16 @@ pub mod reimpls {\n             let bits = (::core::mem::size_of::<$ty>() * 8) as $ty;\n             let half_bits = bits >> 1;\n             if b & half_bits != 0 {\n-                <$ty>::from_parts((a.high() >> (b - half_bits)) as <$ty as LargeInt>::LowHalf,\n-                                  a.high() >> (half_bits - 1))\n+                <$ty>::from_parts(a.high().wrapping_shr(b.wrapping_sub(half_bits) as u32)\n+                                  as <$ty as LargeInt>::LowHalf,\n+                                  a.high().wrapping_shr(half_bits.wrapping_sub(1) as u32))\n             } else if b == 0 {\n                 a\n             } else {\n                 let high_unsigned = a.high() as <$ty as LargeInt>::LowHalf;\n-                <$ty>::from_parts((high_unsigned << (half_bits - b)) | (a.low() >> b),\n-                                  a.high() >> b)\n+                <$ty>::from_parts(high_unsigned.wrapping_shl(half_bits.wrapping_sub(b) as u32)\n+                                  | a.low().wrapping_shr(b as u32),\n+                                  a.high().wrapping_shr(b as u32))\n             }\n         }}\n     }\n@@ -95,11 +101,13 @@ pub mod reimpls {\n             let bits = (::core::mem::size_of::<$ty>() * 8) as $ty;\n             let half_bits = bits >> 1;\n             if b & half_bits != 0 {\n-                <$ty>::from_parts(a.high() >> (b - half_bits), 0)\n+                <$ty>::from_parts(a.high().wrapping_shr(b.wrapping_sub(half_bits) as u32), 0)\n             } else if b == 0 {\n                 a\n             } else {\n-                <$ty>::from_parts((a.high() << (half_bits - b)) | (a.low() >> b), a.high() >> b)\n+                <$ty>::from_parts(a.high().wrapping_shl(half_bits.wrapping_sub(b) as u32)\n+                                  | a.low().wrapping_shr(b as u32),\n+                                  a.high().wrapping_shr(b as u32))\n             }\n         }}\n     }\n@@ -178,9 +186,10 @@ pub mod reimpls {\n \n             if d.high().is_power_of_two() {\n                 if !rem.is_null() {\n-                    *rem = u128::from_parts(n.low(), n.high() & (d.high() - 1));\n+                    *rem = u128::from_parts(n.low(),\n+                                            n.high() & (d.high().wrapping_sub(1)));\n                 }\n-                return u128::from(n.high() >> d.high().trailing_zeros());\n+                return u128::from(n.high().wrapping_shr(d.high().trailing_zeros()));\n             }\n \n             // K K\n@@ -196,34 +205,36 @@ pub mod reimpls {\n                 return 0;\n             }\n \n-            sr += 1;\n+            sr = sr.wrapping_add(1);\n \n             // 1 <= sr <= u64::bits() - 1\n-            q = n << (64 - sr);\n-            r = n >> sr;\n+            q = n.wrapping_shl(64u32.wrapping_sub(sr));\n+            r = n.wrapping_shr(sr);\n         } else {\n             if d.high() == 0 {\n                 // K X\n                 // ---\n                 // 0 K\n                 if d.low().is_power_of_two() {\n                     if !rem.is_null() {\n-                        *rem = u128::from(n.low() & (d.low() - 1));\n+                        *rem = u128::from(n.low() & (d.low().wrapping_sub(1)));\n                     }\n \n                     if d.low() == 1 {\n                         return n;\n                     } else {\n                         let sr = d.low().trailing_zeros();\n-                        return n >> sr;\n+                        return n.wrapping_shr(sr);\n                     };\n                 }\n \n-                sr = 1 + 64 + d.low().leading_zeros() - n.high().leading_zeros();\n+                sr = (1 + 64u32)\n+                    .wrapping_add(d.low().leading_zeros())\n+                    .wrapping_sub(n.high().leading_zeros());\n \n                 // 2 <= sr <= u64::bits() - 1\n-                q = n << (128 - sr);\n-                r = n >> sr;\n+                q = n.wrapping_shl(128u32.wrapping_sub(sr));\n+                r = n.wrapping_shr(sr);\n                 // FIXME the C compiler-rt implementation has something here\n                 // that looks like a speed optimisation.\n                 // It would be worth a try to port it to Rust too and\n@@ -242,11 +253,11 @@ pub mod reimpls {\n                     return 0;\n                 }\n \n-                sr += 1;\n+                sr = sr.wrapping_add(1);\n \n                 // 1 <= sr <= u32::bits()\n-                q = n << (128 - sr);\n-                r = n >> sr;\n+                q = n.wrapping_shl(128u32.wrapping_sub(sr));\n+                r = n.wrapping_shr(sr);\n             }\n         }\n \n@@ -264,24 +275,24 @@ pub mod reimpls {\n         // compilation steps)\n         while sr > 0 {\n             // r:q = ((r:q) << 1) | carry\n-            r = (r << 1) | (q >> (128 - 1));\n-            q = (q << 1) | carry as u128;\n+            r = r.wrapping_shl(1) | q.wrapping_shr(128 - 1);\n+            q = q.wrapping_shl(1) | carry as u128;\n \n             // carry = 0\n             // if r >= d {\n             //     r -= d;\n             //     carry = 1;\n             // }\n-            let s = (d.wrapping_sub(r).wrapping_sub(1)) as i128 >> (128 - 1);\n+            let s = ((d.wrapping_sub(r).wrapping_sub(1)) as i128).wrapping_shr(128 - 1);\n             carry = (s & 1) as u64;\n-            r -= d & s as u128;\n-            sr -= 1;\n+            r = r.wrapping_sub(d & s as u128);\n+            sr = sr.wrapping_sub(1);\n         }\n \n         if !rem.is_null() {\n             *rem = r;\n         }\n-        (q << 1) | carry as u128\n+        (q.wrapping_shl(1)) | carry as u128\n         }\n     }\n \n@@ -302,7 +313,7 @@ pub mod reimpls {\n         unsafe {\n             let mut r = ::core::mem::zeroed();\n             u128_div_mod(a, b, &mut r);\n-            if sa == -1 { -(r as i128_) } else { r as i128_ }\n+            if sa == -1 { (r as i128_).unchecked_neg() } else { r as i128_ }\n         }\n     }\n \n@@ -312,9 +323,9 @@ pub mod reimpls {\n         let sb = b.signum();\n         let a = a.uabs();\n         let b = b.uabs();\n-        let sr = sa * sb; // sign of quotient\n+        let sr = sa.wrapping_mul(sb); // sign of quotient\n         if sr == -1 {\n-            -(u128_div_mod(a, b, ptr::null_mut()) as i128_)\n+            (u128_div_mod(a, b, ptr::null_mut()) as i128_).unchecked_neg()\n         } else {\n             u128_div_mod(a, b, ptr::null_mut()) as i128_\n         }\n@@ -356,7 +367,7 @@ pub mod reimpls {\n                     *overflow = 1;\n                 }\n             } else {\n-                if abs_a > unchecked_div(<$ty>::min_value(), -abs_b) {\n+                if abs_a > unchecked_div(<$ty>::min_value(), abs_b.unchecked_neg()) {\n                     *overflow = 1;\n                 }\n             }\n@@ -387,10 +398,10 @@ pub mod reimpls {\n             self as u32\n         }\n         fn high(self) -> u32 {\n-            (self >> 32) as u32\n+            (self.wrapping_shr(32)) as u32\n         }\n         fn from_parts(low: u32, high: u32) -> u64 {\n-            low as u64 | ((high as u64) << 32)\n+            low as u64 | (high as u64).wrapping_shl(32)\n         }\n     }\n     impl LargeInt for i64 {\n@@ -401,10 +412,10 @@ pub mod reimpls {\n             self as u32\n         }\n         fn high(self) -> i32 {\n-            (self >> 32) as i32\n+            self.wrapping_shr(32) as i32\n         }\n         fn from_parts(low: u32, high: i32) -> i64 {\n-            low as i64 | ((high as i64) << 32)\n+            low as i64 | (high as i64).wrapping_shl(32)\n         }\n     }\n     #[cfg(not(stage0))]\n@@ -442,20 +453,23 @@ pub mod reimpls {\n     macro_rules! mul {\n         ($a:expr, $b:expr, $ty: ty, $tyh: ty) => {{\n             let (a, b) = ($a, $b);\n-            let half_bits = (::core::mem::size_of::<$tyh>() * 8) / 2;\n-            let lower_mask = !0 >> half_bits;\n-            let mut low = (a.low() & lower_mask) * (b.low() & lower_mask);\n-            let mut t = low >> half_bits;\n+            let half_bits = ((::core::mem::size_of::<$tyh>() * 8) / 2) as u32;\n+            let lower_mask = (!0u64).wrapping_shr(half_bits);\n+            let mut low = (a.low() & lower_mask).wrapping_mul(b.low() & lower_mask);\n+            let mut t = low.wrapping_shr(half_bits);\n             low &= lower_mask;\n-            t += (a.low() >> half_bits) * (b.low() & lower_mask);\n-            low += (t & lower_mask) << half_bits;\n-            let mut high = (t >> half_bits) as $tyh;\n-            t = low >> half_bits;\n+            t = t.wrapping_add(a.low().wrapping_shr(half_bits)\n+                                      .wrapping_mul(b.low() & lower_mask));\n+            low = low.wrapping_add((t & lower_mask).wrapping_shl(half_bits));\n+            let mut high = t.wrapping_shr(half_bits) as $tyh;\n+            t = low.wrapping_shr(half_bits);\n             low &= lower_mask;\n-            t += (b.low() >> half_bits) * (a.low() & lower_mask);\n-            low += (t & lower_mask) << half_bits;\n-            high += (t >> half_bits) as $tyh;\n-            high += ((a.low() >> half_bits) * (b.low() >> half_bits)) as $tyh;\n+            t = t.wrapping_add(b.low().wrapping_shr(half_bits)\n+                                      .wrapping_mul(a.low() & lower_mask));\n+            low = low.wrapping_add((t & lower_mask).wrapping_shl(half_bits));\n+            high = high.wrapping_add(t.wrapping_shr(half_bits) as $tyh);\n+            high = high.wrapping_add(a.low().wrapping_shr(half_bits)\n+                           .wrapping_mul(b.low().wrapping_shr(half_bits)) as $tyh);\n             high = high\n                 .wrapping_add(a.high()\n                 .wrapping_mul(b.low() as $tyh))\n@@ -468,7 +482,7 @@ pub mod reimpls {\n     #[cfg(stage0)]\n     #[export_name=\"__multi3\"]\n     pub extern \"C\" fn u128_mul(a: i128_, b: i128_) -> i128_ {\n-        (a as i64 * b as i64) as i128_\n+        (a as i64).wrapping_mul(b as i64) as i128_\n     }\n \n     #[cfg(not(stage0))]\n@@ -491,6 +505,16 @@ pub mod reimpls {\n         }\n     }\n \n+    trait NegExt: Sized {\n+        fn unchecked_neg(self) -> i128_;\n+    }\n+\n+    impl NegExt for i128_ {\n+        fn unchecked_neg(self) -> i128_ {\n+            (!self).wrapping_add(1)\n+        }\n+    }\n+\n     trait FloatStuff: Sized {\n         type ToBytes;\n \n@@ -514,7 +538,8 @@ pub mod reimpls {\n \n         fn to_bytes(self) -> u32 { unsafe { ::core::mem::transmute(self) } }\n         fn get_exponent(self) -> i32 {\n-            (((self.to_bytes() & Self::EXP_MASK) >> Self::MANTISSA_BITS) as i32) - Self::MAX_EXP\n+            ((self.to_bytes() & Self::EXP_MASK).wrapping_shr(Self::MANTISSA_BITS) as i32)\n+            .wrapping_sub(Self::MAX_EXP)\n         }\n     }\n \n@@ -528,7 +553,8 @@ pub mod reimpls {\n \n         fn to_bytes(self) -> u64 { unsafe { ::core::mem::transmute(self) } }\n         fn get_exponent(self) -> i32 {\n-            (((self.to_bytes() & Self::EXP_MASK) >> Self::MANTISSA_BITS) as i32) - Self::MAX_EXP\n+            ((self.to_bytes() & Self::EXP_MASK).wrapping_shr(Self::MANTISSA_BITS) as i32)\n+            .wrapping_sub(Self::MAX_EXP)\n         }\n     }\n \n@@ -545,9 +571,11 @@ pub mod reimpls {\n                 return !0;\n             }\n             if exponent < (<$fromty as FloatStuff>::MANTISSA_BITS) as i32 {\n-                mantissa as $outty >> (<$fromty as FloatStuff>::MANTISSA_BITS as i32 - exponent)\n+                (mantissa as $outty)\n+                    .wrapping_shr((<$fromty as FloatStuff>::MANTISSA_BITS as i32).wrapping_sub(exponent) as u32)\n             } else {\n-                mantissa as $outty << (exponent - <$fromty as FloatStuff>::MANTISSA_BITS as i32)\n+                (mantissa as $outty)\n+                    .wrapping_shl(exponent.wrapping_sub(<$fromty as FloatStuff>::MANTISSA_BITS as i32) as u32)\n             }\n         } }\n     }\n@@ -576,11 +604,13 @@ pub mod reimpls {\n                 return if sign > 0.0 { <$outty>::max_value() } else { <$outty>::min_value() };\n             }\n             let r = if exponent < (<$fromty as FloatStuff>::MANTISSA_BITS) as i32 {\n-                mantissa as $outty >> (<$fromty as FloatStuff>::MANTISSA_BITS as i32 - exponent)\n+                (mantissa as $outty)\n+                    .wrapping_shr((<$fromty as FloatStuff>::MANTISSA_BITS as i32).wrapping_sub(exponent) as u32)\n             } else {\n-                mantissa as $outty << (exponent - <$fromty as FloatStuff>::MANTISSA_BITS as i32)\n+                (mantissa as $outty)\n+                    .wrapping_shl(exponent.wrapping_sub(<$fromty as FloatStuff>::MANTISSA_BITS as i32) as u32)\n             };\n-            if sign >= 0.0 { r } else { -r }\n+            if sign >= 0.0 { r } else { r.unchecked_neg() }\n         }}\n     }\n \n@@ -616,61 +646,71 @@ pub mod reimpls {\n     pub extern \"C\" fn u128_as_f64(mut a: u128_) -> f64 {\n         use ::core::f64::MANTISSA_DIGITS;\n         if a == 0 { return 0.0; }\n-        let sd = 128 - a.leading_zeros();\n-        let mut e = sd - 1;\n+        let sd = 128u32.wrapping_sub(a.leading_zeros());\n+        let mut e = sd.wrapping_sub(1);\n         const MD1 : u32 = MANTISSA_DIGITS + 1;\n         const MD2 : u32 = MANTISSA_DIGITS + 2;\n \n+        // SNAP: replace this with !0u128\n+        let negn :u128_ = !0;\n+\n         if sd > MANTISSA_DIGITS {\n             a = match sd {\n-                MD1 => a << 1,\n+                MD1 => a.wrapping_shl(1),\n                 MD2 => a,\n-                _ => (a >> (sd - (MANTISSA_DIGITS + 2))) |\n-                     (if (a & (!0 >> (128 + MANTISSA_DIGITS + 2) - sd)) == 0 { 0 } else { 1 })\n+                _ => a.wrapping_shr(sd.wrapping_sub(MANTISSA_DIGITS + 2)) |\n+                     (if (a & (negn.wrapping_shr(128 + MANTISSA_DIGITS + 2)\n+                                   .wrapping_sub(sd as u128_))) == 0 { 0 } else { 1 })\n             };\n             a |= if (a & 4) == 0 { 0 } else { 1 };\n-            a += 1;\n-            a >>= 2;\n+            a = a.wrapping_add(1);\n+            a = a.wrapping_shr(2);\n             if a & (1 << MANTISSA_DIGITS) != 0 {\n-                a >>= 1;\n-                e += 1;\n+                a = a.wrapping_shr(1);\n+                e = e.wrapping_add(1);\n             }\n         } else {\n-            a <<= MANTISSA_DIGITS - sd;\n+            a = a.wrapping_shl(MANTISSA_DIGITS.wrapping_sub(sd));\n         }\n         unsafe {\n-            ::core::mem::transmute(((e as u64 + 1023) << 52) | (a as u64 & 0x000f_ffff_ffff_ffff))\n+            ::core::mem::transmute((e as u64).wrapping_add(1023).wrapping_shl(52)\n+                                   | (a as u64 & 0x000f_ffff_ffff_ffff))\n         }\n     }\n \n     #[export_name=\"__floatuntisf\"]\n     pub extern \"C\" fn u128_as_f32(mut a: u128_) -> f32 {\n         use ::core::f32::MANTISSA_DIGITS;\n         if a == 0 { return 0.0; }\n-        let sd = 128 - a.leading_zeros();\n-        let mut e = sd - 1;\n+        let sd = 128u32.wrapping_sub(a.leading_zeros());\n+        let mut e = sd.wrapping_sub(1);\n         const MD1 : u32 = MANTISSA_DIGITS + 1;\n         const MD2 : u32 = MANTISSA_DIGITS + 2;\n \n+        // SNAP: replace this with !0u128\n+        let negn :u128_ = !0;\n+\n         if sd > MANTISSA_DIGITS {\n             a = match sd {\n-                MD1 => a << 1,\n+                MD1 => a.wrapping_shl(1),\n                 MD2 => a,\n-                _ => (a >> (sd - (MANTISSA_DIGITS + 2))) |\n-                     (if (a & (!0 >> (128 + MANTISSA_DIGITS + 2) - sd)) == 0 { 0 } else { 1 })\n+                _ => a.wrapping_shr(sd.wrapping_sub(MANTISSA_DIGITS + 2)) |\n+                     (if (a & (negn.wrapping_shr(128 + MANTISSA_DIGITS + 2)\n+                                   .wrapping_sub(sd as u128_))) == 0 { 0 } else { 1 })\n             };\n             a |= if (a & 4) == 0 { 0 } else { 1 };\n-            a += 1;\n-            a >>= 2;\n+            a = a.wrapping_add(1);\n+            a = a.wrapping_shr(2);\n             if a & (1 << MANTISSA_DIGITS) != 0 {\n-                a >>= 1;\n-                e += 1;\n+                a = a.wrapping_shr(1);\n+                e = e.wrapping_add(1);\n             }\n         } else {\n-            a <<= MANTISSA_DIGITS - sd;\n+            a = a.wrapping_shl(MANTISSA_DIGITS.wrapping_sub(sd));\n         }\n         unsafe {\n-            ::core::mem::transmute(((e + 127) << 23) | (a as u32 & 0x007f_ffff))\n+            ::core::mem::transmute((e as u32).wrapping_add(127).wrapping_shl(23)\n+                                   | (a as u32 & 0x007f_ffff))\n         }\n     }\n }"}]}