{"sha": "1df512fcaeaf17639c5d28a3045814d6f7a7db97", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkZjUxMmZjYWVhZjE3NjM5YzVkMjhhMzA0NTgxNGQ2ZjdhN2RiOTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-02T11:24:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-02T11:24:13Z"}, "message": "Auto merge of #63214 - Centril:rollup-hdb7dnx, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #62663 (More questionmarks in doctests)\n - #62969 (Changing the structure of `mir::interpret::InterpError`)\n - #63153 (Remove redundant method with const variable resolution)\n - #63189 (Doc improvements)\n - #63198 (Allow trailing comma in macro 2.0 declarations.)\n - #63202 (Fix ICE in #63135)\n - #63203 (Make is_mutable use PlaceRef instead of it's fields)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "9b6c5c48d0e809e70979f5dcf9995282afbc5fde", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b6c5c48d0e809e70979f5dcf9995282afbc5fde"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1df512fcaeaf17639c5d28a3045814d6f7a7db97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1df512fcaeaf17639c5d28a3045814d6f7a7db97", "html_url": "https://github.com/rust-lang/rust/commit/1df512fcaeaf17639c5d28a3045814d6f7a7db97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1df512fcaeaf17639c5d28a3045814d6f7a7db97/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc3ef9698fa80aa2f4da6208b8295bc8fa48eec5", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc3ef9698fa80aa2f4da6208b8295bc8fa48eec5", "html_url": "https://github.com/rust-lang/rust/commit/fc3ef9698fa80aa2f4da6208b8295bc8fa48eec5"}, {"sha": "97098f466ad7a72e6690cf45e6ff2d60885396a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/97098f466ad7a72e6690cf45e6ff2d60885396a9", "html_url": "https://github.com/rust-lang/rust/commit/97098f466ad7a72e6690cf45e6ff2d60885396a9"}], "stats": {"total": 1134, "additions": 632, "deletions": 502}, "files": [{"sha": "b5614010e5c2f2b1730d93092b1fd6c38b7105ab", "filename": "src/libcore/array.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -24,9 +24,12 @@ use crate::slice::{Iter, IterMut};\n /// layout in memory of a fixed size array (for example, for unsafe\n /// initialization).\n ///\n-/// Note that the traits AsRef and AsMut provide similar methods for types that\n+/// Note that the traits [`AsRef`] and [`AsMut`] provide similar methods for types that\n /// may not be fixed-size arrays. Implementors should prefer those traits\n /// instead.\n+///\n+/// [`AsRef`]: ../convert/trait.AsRef.html\n+/// [`AsMut`]: ../convert/trait.AsMut.html\n #[unstable(feature = \"fixed_size_array\", issue = \"27778\")]\n pub unsafe trait FixedSizeArray<T> {\n     /// Converts the array to immutable slice"}, {"sha": "624b13d96472cfe1dad9ded9f9a134576666fba6", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -427,7 +427,7 @@ pub trait TryInto<T>: Sized {\n /// - [`try_from`] is reflexive, which means that `TryFrom<T> for T`\n /// is implemented and cannot fail -- the associated `Error` type for\n /// calling `T::try_from()` on a value of type `T` is [`Infallible`].\n-/// When the [`!`] type is stablized [`Infallible`] and [`!`] will be\n+/// When the [`!`] type is stabilized [`Infallible`] and [`!`] will be\n /// equivalent.\n ///\n /// `TryFrom<T>` can be implemented as follows:"}, {"sha": "593c01060ca49ae981ce21ceab6423055e85cf30", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -17,11 +17,13 @@ use crate::task::{Context, Poll};\n /// final value. This method does not block if the value is not ready. Instead,\n /// the current task is scheduled to be woken up when it's possible to make\n /// further progress by `poll`ing again. The `context` passed to the `poll`\n-/// method can provide a `Waker`, which is a handle for waking up the current\n+/// method can provide a [`Waker`], which is a handle for waking up the current\n /// task.\n ///\n /// When using a future, you generally won't call `poll` directly, but instead\n /// `.await` the value.\n+///\n+/// [`Waker`]: ../task/struct.Waker.html\n #[doc(spotlight)]\n #[must_use = \"futures do nothing unless you `.await` or poll them\"]\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]"}, {"sha": "37cc71bff62b4e9fa42d4793f3229f7bab0aa718", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -353,11 +353,15 @@ macro_rules! r#try {\n /// use std::fmt::Write as FmtWrite;\n /// use std::io::Write as IoWrite;\n ///\n-/// let mut s = String::new();\n-/// let mut v = Vec::new();\n-/// write!(&mut s, \"{} {}\", \"abc\", 123).unwrap(); // uses fmt::Write::write_fmt\n-/// write!(&mut v, \"s = {:?}\", s).unwrap(); // uses io::Write::write_fmt\n-/// assert_eq!(v, b\"s = \\\"abc 123\\\"\");\n+/// fn main() -> Result<(), Box<dyn std::error::Error>> {\n+///     let mut s = String::new();\n+///     let mut v = Vec::new();\n+///\n+///     write!(&mut s, \"{} {}\", \"abc\", 123)?; // uses fmt::Write::write_fmt\n+///     write!(&mut v, \"s = {:?}\", s)?; // uses io::Write::write_fmt\n+///     assert_eq!(v, b\"s = \\\"abc 123\\\"\");\n+///     Ok(())\n+/// }\n /// ```\n ///\n /// Note: This macro can be used in `no_std` setups as well.\n@@ -399,14 +403,17 @@ macro_rules! write {\n /// # Examples\n ///\n /// ```\n-/// use std::io::Write;\n+/// use std::io::{Write, Result};\n ///\n-/// let mut w = Vec::new();\n-/// writeln!(&mut w).unwrap();\n-/// writeln!(&mut w, \"test\").unwrap();\n-/// writeln!(&mut w, \"formatted {}\", \"arguments\").unwrap();\n+/// fn main() -> Result<()> {\n+///     let mut w = Vec::new();\n+///     writeln!(&mut w)?;\n+///     writeln!(&mut w, \"test\")?;\n+///     writeln!(&mut w, \"formatted {}\", \"arguments\")?;\n ///\n-/// assert_eq!(&w[..], \"\\ntest\\nformatted arguments\\n\".as_bytes());\n+///     assert_eq!(&w[..], \"\\ntest\\nformatted arguments\\n\".as_bytes());\n+///     Ok(())\n+/// }\n /// ```\n ///\n /// A module can import both `std::fmt::Write` and `std::io::Write` and call `write!` on objects\n@@ -417,11 +424,15 @@ macro_rules! write {\n /// use std::fmt::Write as FmtWrite;\n /// use std::io::Write as IoWrite;\n ///\n-/// let mut s = String::new();\n-/// let mut v = Vec::new();\n-/// writeln!(&mut s, \"{} {}\", \"abc\", 123).unwrap(); // uses fmt::Write::write_fmt\n-/// writeln!(&mut v, \"s = {:?}\", s).unwrap(); // uses io::Write::write_fmt\n-/// assert_eq!(v, b\"s = \\\"abc 123\\\\n\\\"\\n\");\n+/// fn main() -> Result<(), Box<dyn std::error::Error>> {\n+///     let mut s = String::new();\n+///     let mut v = Vec::new();\n+///\n+///     writeln!(&mut s, \"{} {}\", \"abc\", 123)?; // uses fmt::Write::write_fmt\n+///     writeln!(&mut v, \"s = {:?}\", s)?; // uses io::Write::write_fmt\n+///     assert_eq!(v, b\"s = \\\"abc 123\\\\n\\\"\\n\");\n+///     Ok(())\n+/// }\n /// ```\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "64fdf504369f2a555335c87a837377e253b2e1ac", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -434,7 +434,7 @@ impl<T> MaybeUninit<T> {\n     /// Reads the value from the `MaybeUninit<T>` container. The resulting `T` is subject\n     /// to the usual drop handling.\n     ///\n-    /// Whenever possible, it is preferrable to use [`assume_init`] instead, which\n+    /// Whenever possible, it is preferable to use [`assume_init`] instead, which\n     /// prevents duplicating the content of the `MaybeUninit<T>`.\n     ///\n     /// # Safety"}, {"sha": "0ec4dd47b1ff017f8b0aaba6640caa9aceb2c95b", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -1611,7 +1611,7 @@ impl<T: ?Sized> *const T {\n     /// The offset is expressed in number of `T` elements, and not bytes. The value returned can be\n     /// used with the `add` method.\n     ///\n-    /// There are no guarantees whatsover that offsetting the pointer will not overflow or go\n+    /// There are no guarantees whatsoever that offsetting the pointer will not overflow or go\n     /// beyond the allocation that the pointer points into. It is up to the caller to ensure that\n     /// the returned offset is correct in all terms other than alignment.\n     ///\n@@ -2412,7 +2412,7 @@ impl<T: ?Sized> *mut T {\n     /// The offset is expressed in number of `T` elements, and not bytes. The value returned can be\n     /// used with the `add` method.\n     ///\n-    /// There are no guarantees whatsover that offsetting the pointer will not overflow or go\n+    /// There are no guarantees whatsoever that offsetting the pointer will not overflow or go\n     /// beyond the allocation that the pointer points into. It is up to the caller to ensure that\n     /// the returned offset is correct in all terms other than alignment.\n     ///"}, {"sha": "db724875b8aa390b16aaf4b3fe7ef722a1818054", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -693,7 +693,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         const_var: &'tcx ty::Const<'tcx>\n     ) -> &'tcx ty::Const<'tcx> {\n         let infcx = self.infcx.expect(\"encountered const-var without infcx\");\n-        let bound_to = infcx.resolve_const_var(const_var);\n+        let bound_to = infcx.shallow_resolve(const_var);\n         if bound_to != const_var {\n             self.fold_const(bound_to)\n         } else {"}, {"sha": "e1d77a97c116068fd0c26828d486c03e40b47dc9", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 23, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -1351,23 +1351,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn resolve_const_var(\n-        &self,\n-        ct: &'tcx ty::Const<'tcx>\n-    ) -> &'tcx ty::Const<'tcx> {\n-        if let ty::Const { val: ConstValue::Infer(InferConst::Var(v)), .. } = ct {\n-            self.const_unification_table\n-                .borrow_mut()\n-                .probe_value(*v)\n-                .val\n-                .known()\n-                .map(|c| self.resolve_const_var(c))\n-                .unwrap_or(ct)\n-        } else {\n-            ct\n-        }\n-    }\n-\n     pub fn fully_resolve<T: TypeFoldable<'tcx>>(&self, value: &T) -> FixupResult<'tcx, T> {\n         /*!\n          * Attempts to resolve all type/region/const variables in\n@@ -1586,7 +1569,7 @@ impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n                 // it can be resolved to an int/float variable, which\n                 // can then be recursively resolved, hence the\n                 // recursion. Note though that we prevent type\n-                // variables from unifyxing to other type variables\n+                // variables from unifying to other type variables\n                 // directly (though they may be embedded\n                 // structurally), and we prevent cycles in any case,\n                 // so this recursion should always be of very limited\n@@ -1626,17 +1609,15 @@ impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n     }\n \n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        match ct {\n-            ty::Const { val: ConstValue::Infer(InferConst::Var(vid)), .. } => {\n+        if let ty::Const { val: ConstValue::Infer(InferConst::Var(vid)), .. } = ct {\n                 self.infcx.const_unification_table\n                     .borrow_mut()\n                     .probe_value(*vid)\n                     .val\n                     .known()\n-                    .map(|c| self.fold_const(c))\n                     .unwrap_or(ct)\n-            }\n-            _ => ct,\n+        } else {\n+            ct\n         }\n     }\n }"}, {"sha": "ce04cca96e0f93b144c16f1aeb04503b5bbdd339", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -235,17 +235,17 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     {\n         assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n         let offset = ptr.offset.bytes() as usize;\n-        match self.bytes[offset..].iter().position(|&c| c == 0) {\n+        Ok(match self.bytes[offset..].iter().position(|&c| c == 0) {\n             Some(size) => {\n                 let size_with_null = Size::from_bytes((size + 1) as u64);\n                 // Go through `get_bytes` for checks and AllocationExtra hooks.\n                 // We read the null, so we include it in the request, but we want it removed\n                 // from the result, so we do subslicing.\n-                Ok(&self.get_bytes(cx, ptr, size_with_null)?[..size])\n+                &self.get_bytes(cx, ptr, size_with_null)?[..size]\n             }\n             // This includes the case where `offset` is out-of-bounds to begin with.\n-            None => err!(UnterminatedCString(ptr.erase_tag())),\n-        }\n+            None => throw_unsup!(UnterminatedCString(ptr.erase_tag())),\n+        })\n     }\n \n     /// Validates that `ptr.offset` and `ptr.offset + size` do not point to the middle of a\n@@ -446,7 +446,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         if self.relocations(cx, ptr, size).is_empty() {\n             Ok(())\n         } else {\n-            err!(ReadPointerAsBytes)\n+            throw_unsup!(ReadPointerAsBytes)\n         }\n     }\n \n@@ -516,7 +516,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n         self.undef_mask.is_range_defined(\n             ptr.offset,\n             ptr.offset + size,\n-        ).or_else(|idx| err!(ReadUndefBytes(idx)))\n+        ).or_else(|idx| throw_unsup!(ReadUndefBytes(idx)))\n     }\n \n     pub fn mark_definedness("}, {"sha": "8d41b019c221a4719d578556a47fa74c9398dfcf", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 144, "deletions": 66, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -138,10 +138,12 @@ impl<'tcx> ConstEvalErr<'tcx> {\n         lint_root: Option<hir::HirId>,\n     ) -> Result<DiagnosticBuilder<'tcx>, ErrorHandled> {\n         match self.error {\n-            InterpError::Layout(LayoutError::Unknown(_)) |\n-            InterpError::TooGeneric => return Err(ErrorHandled::TooGeneric),\n-            InterpError::Layout(LayoutError::SizeOverflow(_)) |\n-            InterpError::TypeckError => return Err(ErrorHandled::Reported),\n+            err_inval!(Layout(LayoutError::Unknown(_))) |\n+            err_inval!(TooGeneric) =>\n+                return Err(ErrorHandled::TooGeneric),\n+            err_inval!(Layout(LayoutError::SizeOverflow(_))) |\n+            err_inval!(TypeckError) =>\n+                return Err(ErrorHandled::Reported),\n             _ => {},\n         }\n         trace!(\"reporting const eval failure at {:?}\", self.span);\n@@ -181,8 +183,8 @@ pub fn struct_error<'tcx>(tcx: TyCtxtAt<'tcx>, msg: &str) -> DiagnosticBuilder<'\n /// Packages the kind of error we got from the const code interpreter\n /// up with a Rust-level backtrace of where the error occured.\n /// Thsese should always be constructed by calling `.into()` on\n-/// a `InterpError`. In `librustc_mir::interpret`, we have the `err!`\n-/// macro for this.\n+/// a `InterpError`. In `librustc_mir::interpret`, we have `throw_err_*`\n+/// macros for this.\n #[derive(Debug, Clone)]\n pub struct InterpErrorInfo<'tcx> {\n     pub kind: InterpError<'tcx>,\n@@ -234,7 +236,7 @@ impl<'tcx> From<InterpError<'tcx>> for InterpErrorInfo<'tcx> {\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n-pub enum PanicMessage<O> {\n+pub enum PanicInfo<O> {\n     Panic {\n         msg: Symbol,\n         line: u32,\n@@ -254,14 +256,14 @@ pub enum PanicMessage<O> {\n }\n \n /// Type for MIR `Assert` terminator error messages.\n-pub type AssertMessage<'tcx> = PanicMessage<mir::Operand<'tcx>>;\n+pub type AssertMessage<'tcx> = PanicInfo<mir::Operand<'tcx>>;\n \n-impl<O> PanicMessage<O> {\n+impl<O> PanicInfo<O> {\n     /// Getting a description does not require `O` to be printable, and does not\n     /// require allocation.\n     /// The caller is expected to handle `Panic` and `BoundsCheck` separately.\n     pub fn description(&self) -> &'static str {\n-        use PanicMessage::*;\n+        use PanicInfo::*;\n         match self {\n             Overflow(mir::BinOp::Add) =>\n                 \"attempt to add with overflow\",\n@@ -290,14 +292,14 @@ impl<O> PanicMessage<O> {\n             GeneratorResumedAfterPanic =>\n                 \"generator resumed after panicking\",\n             Panic { .. } | BoundsCheck { .. } =>\n-                bug!(\"Unexpected PanicMessage\"),\n+                bug!(\"Unexpected PanicInfo\"),\n         }\n     }\n }\n \n-impl<O: fmt::Debug> fmt::Debug for PanicMessage<O> {\n+impl<O: fmt::Debug> fmt::Debug for PanicInfo<O> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use PanicMessage::*;\n+        use PanicInfo::*;\n         match self {\n             Panic { ref msg, line, col, ref file } =>\n                 write!(f, \"the evaluated program panicked at '{}', {}:{}:{}\", msg, file, line, col),\n@@ -310,20 +312,64 @@ impl<O: fmt::Debug> fmt::Debug for PanicMessage<O> {\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n-pub enum InterpError<'tcx> {\n-    /// This variant is used by machines to signal their own errors that do not\n-    /// match an existing variant.\n-    MachineError(String),\n+pub enum InvalidProgramInfo<'tcx> {\n+    /// Resolution can fail if we are in a too generic context.\n+    TooGeneric,\n+    /// Cannot compute this constant because it depends on another one\n+    /// which already produced an error.\n+    ReferencedConstant,\n+    /// Abort in case type errors are reached.\n+    TypeckError,\n+    /// An error occurred during layout computation.\n+    Layout(layout::LayoutError<'tcx>),\n+}\n \n-    /// Not actually an interpreter error -- used to signal that execution has exited\n-    /// with the given status code.  Used by Miri, but not by CTFE.\n-    Exit(i32),\n+impl fmt::Debug for InvalidProgramInfo<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use InvalidProgramInfo::*;\n+        match self {\n+            TooGeneric =>\n+                write!(f, \"encountered overly generic constant\"),\n+            ReferencedConstant =>\n+                write!(f, \"referenced constant has errors\"),\n+            TypeckError =>\n+                write!(f, \"encountered constants with type errors, stopping evaluation\"),\n+            Layout(ref err) =>\n+                write!(f, \"rustc layout computation failed: {:?}\", err),\n+        }\n+    }\n+}\n \n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+pub enum UndefinedBehaviourInfo {\n+    /// Handle cases which for which we do not have a fixed variant.\n+    Ub(String),\n+    /// Unreachable code was executed.\n+    Unreachable,\n+}\n+\n+impl fmt::Debug for UndefinedBehaviourInfo {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use UndefinedBehaviourInfo::*;\n+        match self {\n+            Ub(ref msg) =>\n+                write!(f, \"{}\", msg),\n+            Unreachable =>\n+                write!(f, \"entered unreachable code\"),\n+        }\n+    }\n+}\n+\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+pub enum UnsupportedOpInfo<'tcx> {\n+    /// Handle cases which for which we do not have a fixed variant.\n+    Unimplemented(String),\n+\n+    // -- Everything below is not classified yet --\n     FunctionAbiMismatch(Abi, Abi),\n     FunctionArgMismatch(Ty<'tcx>, Ty<'tcx>),\n     FunctionRetMismatch(Ty<'tcx>, Ty<'tcx>),\n     FunctionArgCountMismatch,\n-    NoMirFor(String),\n     UnterminatedCString(Pointer),\n     DanglingPointerDeref,\n     DoubleFree,\n@@ -344,12 +390,17 @@ pub enum InterpError<'tcx> {\n     ReadUndefBytes(Size),\n     DeadLocal,\n     InvalidBoolOp(mir::BinOp),\n-    Unimplemented(String),\n+    InlineAsm,\n+    UnimplementedTraitSelection,\n+    CalledClosureAsFunction,\n+    NoMirFor(String),\n+    /// This variant is used by machines to signal their own errors that do not\n+    /// match an existing variant.\n+    MachineError(String),\n     DerefFunctionPointer,\n     ExecuteMemory,\n     Intrinsic(String),\n     InvalidChar(u128),\n-    StackFrameLimitReached,\n     OutOfTls,\n     TlsOutOfBounds,\n     AbiViolation(String),\n@@ -358,49 +409,26 @@ pub enum InterpError<'tcx> {\n         has: Align,\n     },\n     ValidationFailure(String),\n-    CalledClosureAsFunction,\n     VtableForArgumentlessMethod,\n     ModifiedConstantMemory,\n     ModifiedStatic,\n     AssumptionNotHeld,\n-    InlineAsm,\n     TypeNotPrimitive(Ty<'tcx>),\n     ReallocatedWrongMemoryKind(String, String),\n     DeallocatedWrongMemoryKind(String, String),\n     ReallocateNonBasePtr,\n     DeallocateNonBasePtr,\n     IncorrectAllocationInformation(Size, Size, Align, Align),\n-    Layout(layout::LayoutError<'tcx>),\n     HeapAllocZeroBytes,\n     HeapAllocNonPowerOfTwoAlignment(u64),\n-    Unreachable,\n-    Panic(PanicMessage<u64>),\n     ReadFromReturnPointer,\n     PathNotFound(Vec<String>),\n-    UnimplementedTraitSelection,\n-    /// Abort in case type errors are reached\n-    TypeckError,\n-    /// Resolution can fail if we are in a too generic context\n-    TooGeneric,\n-    /// Cannot compute this constant because it depends on another one\n-    /// which already produced an error\n-    ReferencedConstant,\n-    InfiniteLoop,\n-}\n-\n-pub type InterpResult<'tcx, T = ()> = Result<T, InterpErrorInfo<'tcx>>;\n-\n-impl fmt::Display for InterpError<'_> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // Forward `Display` to `Debug`\n-        write!(f, \"{:?}\", self)\n-    }\n }\n \n-impl fmt::Debug for InterpError<'_> {\n+impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use InterpError::*;\n-        match *self {\n+        use UnsupportedOpInfo::*;\n+        match self {\n             PointerOutOfBounds { ptr, msg, allocation_size } => {\n                 write!(f, \"{} failed: pointer must be in-bounds at offset {}, \\\n                           but is outside bounds of allocation {} which has size {}\",\n@@ -434,8 +462,6 @@ impl fmt::Debug for InterpError<'_> {\n                       has.bytes(), required.bytes()),\n             TypeNotPrimitive(ty) =>\n                 write!(f, \"expected primitive type, got {}\", ty),\n-            Layout(ref err) =>\n-                write!(f, \"rustc layout computation failed: {:?}\", err),\n             PathNotFound(ref path) =>\n                 write!(f, \"Cannot find path {:?}\", path),\n             IncorrectAllocationInformation(size, size2, align, align2) =>\n@@ -444,8 +470,6 @@ impl fmt::Debug for InterpError<'_> {\n                     size.bytes(), align.bytes(), size2.bytes(), align2.bytes()),\n             InvalidDiscriminant(val) =>\n                 write!(f, \"encountered invalid enum discriminant {}\", val),\n-            Exit(code) =>\n-                write!(f, \"exited with status code {}\", code),\n             InvalidMemoryAccess =>\n                 write!(f, \"tried to access memory through an invalid pointer\"),\n             DanglingPointerDeref =>\n@@ -474,8 +498,6 @@ impl fmt::Debug for InterpError<'_> {\n                 write!(f, \"tried to dereference a function pointer\"),\n             ExecuteMemory =>\n                 write!(f, \"tried to treat a memory pointer as a function pointer\"),\n-            StackFrameLimitReached =>\n-                write!(f, \"reached the configured maximum number of stack frames\"),\n             OutOfTls =>\n                 write!(f, \"reached the maximum number of representable TLS keys\"),\n             TlsOutOfBounds =>\n@@ -501,21 +523,10 @@ impl fmt::Debug for InterpError<'_> {\n                     existing object\"),\n             HeapAllocZeroBytes =>\n                 write!(f, \"tried to re-, de- or allocate zero bytes on the heap\"),\n-            Unreachable =>\n-                write!(f, \"entered unreachable code\"),\n             ReadFromReturnPointer =>\n                 write!(f, \"tried to read from the return pointer\"),\n             UnimplementedTraitSelection =>\n                 write!(f, \"there were unresolved type arguments during trait selection\"),\n-            TypeckError =>\n-                write!(f, \"encountered constants with type errors, stopping evaluation\"),\n-            TooGeneric =>\n-                write!(f, \"encountered overly generic constant\"),\n-            ReferencedConstant =>\n-                write!(f, \"referenced constant has errors\"),\n-            InfiniteLoop =>\n-                write!(f, \"duplicate interpreter state observed here, const evaluation will never \\\n-                    terminate\"),\n             InvalidBoolOp(_) =>\n                 write!(f, \"invalid boolean operation\"),\n             UnterminatedCString(_) =>\n@@ -531,8 +542,75 @@ impl fmt::Debug for InterpError<'_> {\n             AbiViolation(ref msg) |\n             Intrinsic(ref msg) =>\n                 write!(f, \"{}\", msg),\n+        }\n+    }\n+}\n+\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+pub enum ResourceExhaustionInfo {\n+    /// The stack grew too big.\n+    StackFrameLimitReached,\n+    /// The program ran into an infinite loop.\n+    InfiniteLoop,\n+}\n+\n+impl fmt::Debug for ResourceExhaustionInfo {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use ResourceExhaustionInfo::*;\n+        match self {\n+            StackFrameLimitReached =>\n+                write!(f, \"reached the configured maximum number of stack frames\"),\n+            InfiniteLoop =>\n+                write!(f, \"duplicate interpreter state observed here, const evaluation will never \\\n+                    terminate\"),\n+        }\n+    }\n+}\n+\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+pub enum InterpError<'tcx> {\n+    /// The program panicked.\n+    Panic(PanicInfo<u64>),\n+    /// The program caused undefined behavior.\n+    UndefinedBehaviour(UndefinedBehaviourInfo),\n+    /// The program did something the interpreter does not support (some of these *might* be UB\n+    /// but the interpreter is not sure).\n+    Unsupported(UnsupportedOpInfo<'tcx>),\n+    /// The program was invalid (ill-typed, not sufficiently monomorphized, ...).\n+    InvalidProgram(InvalidProgramInfo<'tcx>),\n+    /// The program exhausted the interpreter's resources (stack/heap too big,\n+    /// execution takes too long, ..).\n+    ResourceExhaustion(ResourceExhaustionInfo),\n+    /// Not actually an interpreter error -- used to signal that execution has exited\n+    /// with the given status code.  Used by Miri, but not by CTFE.\n+    Exit(i32),\n+}\n+\n+pub type InterpResult<'tcx, T = ()> = Result<T, InterpErrorInfo<'tcx>>;\n+\n+impl fmt::Display for InterpError<'_> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // Forward `Display` to `Debug`\n+        write!(f, \"{:?}\", self)\n+    }\n+}\n+\n+impl fmt::Debug for InterpError<'_> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use InterpError::*;\n+        match *self {\n+            Unsupported(ref msg) =>\n+                write!(f, \"{:?}\", msg),\n+            InvalidProgram(ref msg) =>\n+                write!(f, \"{:?}\", msg),\n+            UndefinedBehaviour(ref msg) =>\n+                write!(f, \"{:?}\", msg),\n+            ResourceExhaustion(ref msg) =>\n+                write!(f, \"{:?}\", msg),\n             Panic(ref msg) =>\n                 write!(f, \"{:?}\", msg),\n+            Exit(code) =>\n+                write!(f, \"exited with status code {}\", code),\n         }\n     }\n }"}, {"sha": "723a30792fddc0f7a7d0c3ac00ffdd8e5d324b47", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 69, "deletions": 3, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -1,8 +1,73 @@\n //! An interpreter for MIR used in CTFE and by miri\n \n #[macro_export]\n-macro_rules! err {\n-    ($($tt:tt)*) => { Err($crate::mir::interpret::InterpError::$($tt)*.into()) };\n+macro_rules! err_unsup {\n+    ($($tt:tt)*) => {\n+        $crate::mir::interpret::InterpError::Unsupported(\n+            $crate::mir::interpret::UnsupportedOpInfo::$($tt)*\n+        )\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! err_inval {\n+    ($($tt:tt)*) => {\n+        $crate::mir::interpret::InterpError::InvalidProgram(\n+            $crate::mir::interpret::InvalidProgramInfo::$($tt)*\n+        )\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! err_ub {\n+    ($($tt:tt)*) => {\n+        $crate::mir::interpret::InterpError::UndefinedBehaviour(\n+            $crate::mir::interpret::UndefinedBehaviourInfo::$($tt)*\n+        )\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! err_panic {\n+    ($($tt:tt)*) => {\n+        $crate::mir::interpret::InterpError::Panic(\n+            $crate::mir::interpret::PanicInfo::$($tt)*\n+        )\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! err_exhaust {\n+    ($($tt:tt)*) => {\n+        $crate::mir::interpret::InterpError::ResourceExhaustion(\n+            $crate::mir::interpret::ResourceExhaustionInfo::$($tt)*\n+        )\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! throw_unsup {\n+    ($($tt:tt)*) => { return Err(err_unsup!($($tt)*).into()) };\n+}\n+\n+#[macro_export]\n+macro_rules! throw_inval {\n+    ($($tt:tt)*) => { return Err(err_inval!($($tt)*).into()) };\n+}\n+\n+#[macro_export]\n+macro_rules! throw_ub {\n+    ($($tt:tt)*) => { return Err(err_ub!($($tt)*).into()) };\n+}\n+\n+#[macro_export]\n+macro_rules! throw_panic {\n+    ($($tt:tt)*) => { return Err(err_panic!($($tt)*).into()) };\n+}\n+\n+#[macro_export]\n+macro_rules! throw_exhaust {\n+    ($($tt:tt)*) => { return Err(err_exhaust!($($tt)*).into()) };\n }\n \n mod error;\n@@ -12,7 +77,8 @@ mod pointer;\n \n pub use self::error::{\n     InterpErrorInfo, InterpResult, InterpError, AssertMessage, ConstEvalErr, struct_error,\n-    FrameInfo, ConstEvalRawResult, ConstEvalResult, ErrorHandled, PanicMessage\n+    FrameInfo, ConstEvalRawResult, ConstEvalResult, ErrorHandled, PanicInfo, UnsupportedOpInfo,\n+    InvalidProgramInfo, ResourceExhaustionInfo, UndefinedBehaviourInfo,\n };\n \n pub use self::value::{Scalar, ScalarMaybeUndef, RawConst, ConstValue};"}, {"sha": "0a9985133799498cbe6c5734e2bff8d8fa68d8dd", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -4,9 +4,7 @@ use crate::mir;\n use crate::ty::layout::{self, HasDataLayout, Size};\n use rustc_macros::HashStable;\n \n-use super::{\n-    AllocId, InterpResult, PanicMessage\n-};\n+use super::{AllocId, InterpResult};\n \n /// Used by `check_in_alloc` to indicate context of check\n #[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n@@ -76,13 +74,13 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n     #[inline]\n     fn offset<'tcx>(&self, val: u64, i: u64) -> InterpResult<'tcx, u64> {\n         let (res, over) = self.overflowing_offset(val, i);\n-        if over { err!(Panic(PanicMessage::Overflow(mir::BinOp::Add))) } else { Ok(res) }\n+        if over { throw_panic!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n     }\n \n     #[inline]\n     fn signed_offset<'tcx>(&self, val: u64, i: i64) -> InterpResult<'tcx, u64> {\n         let (res, over) = self.overflowing_signed_offset(val, i128::from(i));\n-        if over { err!(Panic(PanicMessage::Overflow(mir::BinOp::Add))) } else { Ok(res) }\n+        if over { throw_panic!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n     }\n }\n \n@@ -198,11 +196,7 @@ impl<'tcx, Tag> Pointer<Tag> {\n         msg: CheckInAllocMsg,\n     ) -> InterpResult<'tcx, ()> {\n         if self.offset > allocation_size {\n-            err!(PointerOutOfBounds {\n-                ptr: self.erase_tag(),\n-                msg,\n-                allocation_size,\n-            })\n+            throw_unsup!(PointerOutOfBounds { ptr: self.erase_tag(), msg, allocation_size })\n         } else {\n             Ok(())\n         }"}, {"sha": "607bcea7fe80109a224c57dd1b235d4e60f3b4f8", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -360,7 +360,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n                 Scalar::check_data(data, size);\n                 Ok(data)\n             }\n-            Scalar::Ptr(_) => err!(ReadPointerAsBytes),\n+            Scalar::Ptr(_) => throw_unsup!(ReadPointerAsBytes),\n         }\n     }\n \n@@ -373,8 +373,8 @@ impl<'tcx, Tag> Scalar<Tag> {\n     #[inline]\n     pub fn to_ptr(self) -> InterpResult<'tcx, Pointer<Tag>> {\n         match self {\n-            Scalar::Raw { data: 0, .. } => err!(InvalidNullPointerUsage),\n-            Scalar::Raw { .. } => err!(ReadBytesAsPointer),\n+            Scalar::Raw { data: 0, .. } => throw_unsup!(InvalidNullPointerUsage),\n+            Scalar::Raw { .. } => throw_unsup!(ReadBytesAsPointer),\n             Scalar::Ptr(p) => Ok(p),\n         }\n     }\n@@ -406,15 +406,15 @@ impl<'tcx, Tag> Scalar<Tag> {\n         match self {\n             Scalar::Raw { data: 0, size: 1 } => Ok(false),\n             Scalar::Raw { data: 1, size: 1 } => Ok(true),\n-            _ => err!(InvalidBool),\n+            _ => throw_unsup!(InvalidBool),\n         }\n     }\n \n     pub fn to_char(self) -> InterpResult<'tcx, char> {\n         let val = self.to_u32()?;\n         match ::std::char::from_u32(val) {\n             Some(c) => Ok(c),\n-            None => err!(InvalidChar(val as u128)),\n+            None => throw_unsup!(InvalidChar(val as u128)),\n         }\n     }\n \n@@ -537,7 +537,7 @@ impl<'tcx, Tag> ScalarMaybeUndef<Tag> {\n     pub fn not_undef(self) -> InterpResult<'static, Scalar<Tag>> {\n         match self {\n             ScalarMaybeUndef::Scalar(scalar) => Ok(scalar),\n-            ScalarMaybeUndef::Undef => err!(ReadUndefBytes(Size::from_bytes(0))),\n+            ScalarMaybeUndef::Undef => throw_unsup!(ReadUndefBytes(Size::from_bytes(0))),\n         }\n     }\n "}, {"sha": "1e2ec08301cf91f544aa4515dd818de05ce13ede", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -7,7 +7,7 @@\n use crate::hir::def::{CtorKind, Namespace};\n use crate::hir::def_id::DefId;\n use crate::hir::{self, InlineAsm as HirInlineAsm};\n-use crate::mir::interpret::{ConstValue, PanicMessage, Scalar};\n+use crate::mir::interpret::{ConstValue, PanicInfo, Scalar};\n use crate::mir::visit::MirVisitable;\n use crate::ty::adjustment::PointerCast;\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n@@ -3152,7 +3152,7 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                 }\n             }\n             Assert { ref cond, expected, ref msg, target, cleanup } => {\n-                use PanicMessage::*;\n+                use PanicInfo::*;\n                 let msg = match msg {\n                     BoundsCheck { ref len, ref index } =>\n                         BoundsCheck {\n@@ -3200,7 +3200,7 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n             }\n             Assert { ref cond, ref msg, .. } => {\n                 if cond.visit_with(visitor) {\n-                    use PanicMessage::*;\n+                    use PanicInfo::*;\n                     match msg {\n                         BoundsCheck { ref len, ref index } =>\n                             len.visit_with(visitor) || index.visit_with(visitor),"}, {"sha": "ee4ecb6762c96a674267956c295876663027d92b", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -514,7 +514,7 @@ macro_rules! make_mir_visitor {\n             fn super_assert_message(&mut self,\n                                     msg: & $($mutability)? AssertMessage<'tcx>,\n                                     location: Location) {\n-                use crate::mir::interpret::PanicMessage::*;\n+                use crate::mir::interpret::PanicInfo::*;\n                 match msg {\n                     BoundsCheck { len, index } => {\n                         self.visit_operand(len, location);"}, {"sha": "2486f29ab0f222606d5814d299ecff8df1468a48", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -167,7 +167,7 @@ struct TraitObligationStack<'prev, 'tcx> {\n     /// ok on the premise that if `A: AutoTrait` held, but we indeed\n     /// encountered a problem (later on) with `A: AutoTrait. So we\n     /// currently set a flag on the stack node for `B: AutoTrait` (as\n-    /// well as the second instance of `A: AutoTrait`) to supress\n+    /// well as the second instance of `A: AutoTrait`) to suppress\n     /// caching.\n     ///\n     /// This is a simple, targeted fix. A more-performant fix requires\n@@ -1105,7 +1105,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ///\n     /// - is a defaulted trait,\n     /// - it also appears in the backtrace at some position `X`,\n-    /// - all the predicates at positions `X..` between `X` an the top are\n+    /// - all the predicates at positions `X..` between `X` and the top are\n     ///   also defaulted traits.\n     pub fn coinductive_match<I>(&mut self, cycle: I) -> bool\n     where"}, {"sha": "ca54f63b83afe0c2acc30e6f38162a9cbf7dedb8", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -594,13 +594,11 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n                 ty: a.ty,\n             }))\n         }\n-        (ConstValue::ByRef { .. }, _) => {\n-            bug!(\n-                \"non-Scalar ConstValue encountered in super_relate_consts {:?} {:?}\",\n-                a,\n-                b,\n-            );\n-        }\n+\n+        // FIXME(const_generics): we should either handle `Scalar::Ptr` or add a comment\n+        // saying that we're not handling it intentionally.\n+\n+        // FIXME(const_generics): handle `ConstValue::ByRef` and `ConstValue::Slice`.\n \n         // FIXME(const_generics): this is wrong, as it is a projection\n         (ConstValue::Unevaluated(a_def_id, a_substs),"}, {"sha": "006ebcbdec6727797112984932f2ebc0e8430d52", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -2,7 +2,7 @@ use rustc::middle::lang_items;\n use rustc::ty::{self, Ty, TypeFoldable, Instance};\n use rustc::ty::layout::{self, LayoutOf, HasTyCtxt, FnTypeExt};\n use rustc::mir::{self, Place, PlaceBase, Static, StaticKind};\n-use rustc::mir::interpret::PanicMessage;\n+use rustc::mir::interpret::PanicInfo;\n use rustc_target::abi::call::{ArgType, FnType, PassMode, IgnoreMode};\n use rustc_target::spec::abi::Abi;\n use crate::base;\n@@ -368,7 +368,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // checked operation, just a comparison with the minimum\n         // value, so we have to check for the assert message.\n         if !bx.check_overflow() {\n-            if let PanicMessage::OverflowNeg = *msg {\n+            if let PanicInfo::OverflowNeg = *msg {\n                 const_cond = Some(expected);\n             }\n         }\n@@ -403,7 +403,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // Put together the arguments to the panic entry point.\n         let (lang_item, args) = match msg {\n-            PanicMessage::BoundsCheck { ref len, ref index } => {\n+            PanicInfo::BoundsCheck { ref len, ref index } => {\n                 let len = self.codegen_operand(&mut bx, len).immediate();\n                 let index = self.codegen_operand(&mut bx, index).immediate();\n "}, {"sha": "9f22d7c51df6e6210fddc759e2db580ba4e6ee57", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 73, "deletions": 64, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -733,8 +733,8 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n                 cleanup: _,\n             } => {\n                 self.consume_operand(loc, (cond, span), flow_state);\n-                use rustc::mir::interpret::PanicMessage;\n-                if let PanicMessage::BoundsCheck { ref len, ref index } = *msg {\n+                use rustc::mir::interpret::PanicInfo;\n+                if let PanicInfo::BoundsCheck { ref len, ref index } = *msg {\n                     self.consume_operand(loc, (len, span), flow_state);\n                     self.consume_operand(loc, (index, span), flow_state);\n                 }\n@@ -1942,7 +1942,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     BorrowKind::Mut { .. } => is_local_mutation_allowed,\n                     BorrowKind::Shared | BorrowKind::Shallow => unreachable!(),\n                 };\n-                match self.is_mutable(&place.base, &place.projection, is_local_mutation_allowed) {\n+                match self.is_mutable(place.as_ref(), is_local_mutation_allowed) {\n                     Ok(root_place) => {\n                         self.add_used_mut(root_place, flow_state);\n                         return false;\n@@ -1954,7 +1954,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n             }\n             Reservation(WriteKind::Mutate) | Write(WriteKind::Mutate) => {\n-                match self.is_mutable(&place.base, &place.projection, is_local_mutation_allowed) {\n+                match self.is_mutable(place.as_ref(), is_local_mutation_allowed) {\n                     Ok(root_place) => {\n                         self.add_used_mut(root_place, flow_state);\n                         return false;\n@@ -1974,8 +1974,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             | Write(wk @ WriteKind::StorageDeadOrDrop)\n             | Write(wk @ WriteKind::MutableBorrow(BorrowKind::Shared))\n             | Write(wk @ WriteKind::MutableBorrow(BorrowKind::Shallow)) => {\n-                if let (Err(_place_err), true) = (\n-                    self.is_mutable(&place.base, &place.projection, is_local_mutation_allowed),\n+                if let (Err(place_err), true) = (\n+                    self.is_mutable(place.as_ref(), is_local_mutation_allowed),\n                     self.errors_buffer.is_empty()\n                 ) {\n                     if self.infcx.tcx.migrate_borrowck() {\n@@ -1996,10 +1996,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         self.report_mutability_error(\n                             place,\n                             span,\n-                            PlaceRef {\n-                                base: _place_err.0,\n-                                projection: _place_err.1,\n-                            },\n+                            place_err,\n                             error_access,\n                             location,\n                         );\n@@ -2033,10 +2030,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             self.report_mutability_error(\n                 place,\n                 span,\n-                PlaceRef {\n-                    base: the_place_err.0,\n-                    projection: the_place_err.1,\n-                },\n+                the_place_err,\n                 error_access,\n                 location,\n             );\n@@ -2107,78 +2101,86 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Returns the root place if the place passed in is a projection.\n     fn is_mutable<'d>(\n         &self,\n-        place_base: &'d PlaceBase<'tcx>,\n-        place_projection: &'d Option<Box<Projection<'tcx>>>,\n+        place: PlaceRef<'d, 'tcx>,\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n-    ) -> Result<RootPlace<'d, 'tcx>, (&'d PlaceBase<'tcx>, &'d Option<Box<Projection<'tcx>>>)> {\n-        match (place_base, place_projection) {\n-            (PlaceBase::Local(local), None) => {\n+    ) -> Result<RootPlace<'d, 'tcx>, PlaceRef<'d, 'tcx>> {\n+        match place {\n+            PlaceRef {\n+                base: PlaceBase::Local(local),\n+                projection: None,\n+            } => {\n                 let local = &self.body.local_decls[*local];\n                 match local.mutability {\n                     Mutability::Not => match is_local_mutation_allowed {\n                         LocalMutationIsAllowed::Yes => Ok(RootPlace {\n-                            place_base,\n-                            place_projection,\n+                            place_base: place.base,\n+                            place_projection: place.projection,\n                             is_local_mutation_allowed: LocalMutationIsAllowed::Yes,\n                         }),\n                         LocalMutationIsAllowed::ExceptUpvars => Ok(RootPlace {\n-                            place_base,\n-                            place_projection,\n+                            place_base: place.base,\n+                            place_projection: place.projection,\n                             is_local_mutation_allowed: LocalMutationIsAllowed::ExceptUpvars,\n                         }),\n-                        LocalMutationIsAllowed::No => Err((place_base, place_projection)),\n+                        LocalMutationIsAllowed::No => Err(place),\n                     },\n                     Mutability::Mut => Ok(RootPlace {\n-                        place_base,\n-                        place_projection,\n+                        place_base: place.base,\n+                        place_projection: place.projection,\n                         is_local_mutation_allowed,\n                     }),\n                 }\n             }\n             // The rules for promotion are made by `qualify_consts`, there wouldn't even be a\n             // `Place::Promoted` if the promotion weren't 100% legal. So we just forward this\n-            (PlaceBase::Static(box Static {\n-                kind: StaticKind::Promoted(_),\n-                ..\n-            }), None) =>\n+            PlaceRef {\n+                base: PlaceBase::Static(box Static {\n+                    kind: StaticKind::Promoted(_),\n+                    ..\n+                }),\n+                projection: None,\n+            } =>\n                 Ok(RootPlace {\n-                    place_base,\n-                    place_projection,\n+                    place_base: place.base,\n+                    place_projection: place.projection,\n                     is_local_mutation_allowed,\n                 }),\n-            (PlaceBase::Static(box Static {\n-                kind: StaticKind::Static(def_id),\n-                ..\n-            }), None) => {\n+            PlaceRef {\n+                base: PlaceBase::Static(box Static {\n+                    kind: StaticKind::Static(def_id),\n+                    ..\n+                }),\n+                projection: None,\n+            } => {\n                 if !self.infcx.tcx.is_mutable_static(*def_id) {\n-                    Err((place_base, place_projection))\n+                    Err(place)\n                 } else {\n                     Ok(RootPlace {\n-                        place_base,\n-                        place_projection,\n+                        place_base: place.base,\n+                        place_projection: place.projection,\n                         is_local_mutation_allowed,\n                     })\n                 }\n             }\n-            (_, Some(ref proj)) => {\n+            PlaceRef {\n+                base: _,\n+                projection: Some(proj),\n+            } => {\n                 match proj.elem {\n                     ProjectionElem::Deref => {\n                         let base_ty =\n-                            Place::ty_from(place_base, &proj.base, self.body, self.infcx.tcx).ty;\n+                            Place::ty_from(place.base, &proj.base, self.body, self.infcx.tcx).ty;\n \n                         // Check the kind of deref to decide\n                         match base_ty.sty {\n                             ty::Ref(_, _, mutbl) => {\n                                 match mutbl {\n                                     // Shared borrowed data is never mutable\n-                                    hir::MutImmutable => Err((place_base, place_projection)),\n+                                    hir::MutImmutable => Err(place),\n                                     // Mutably borrowed data is mutable, but only if we have a\n                                     // unique path to the `&mut`\n                                     hir::MutMutable => {\n-                                        let mode = match self.is_upvar_field_projection(PlaceRef {\n-                                            base: &place_base,\n-                                            projection: &place_projection,\n-                                        }) {\n+                                        let mode = match self.is_upvar_field_projection(place) {\n                                             Some(field)\n                                                 if self.upvars[field.index()].by_ref =>\n                                             {\n@@ -2187,28 +2189,34 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                             _ => LocalMutationIsAllowed::Yes,\n                                         };\n \n-                                        self.is_mutable(place_base, &proj.base, mode)\n+                                        self.is_mutable(PlaceRef {\n+                                            base: place.base,\n+                                            projection: &proj.base,\n+                                        }, mode)\n                                     }\n                                 }\n                             }\n                             ty::RawPtr(tnm) => {\n                                 match tnm.mutbl {\n                                     // `*const` raw pointers are not mutable\n-                                    hir::MutImmutable => Err((place_base, place_projection)),\n+                                    hir::MutImmutable => Err(place),\n                                     // `*mut` raw pointers are always mutable, regardless of\n                                     // context. The users have to check by themselves.\n                                     hir::MutMutable => {\n                                         Ok(RootPlace {\n-                                            place_base,\n-                                            place_projection,\n+                                            place_base: place.base,\n+                                            place_projection: place.projection,\n                                             is_local_mutation_allowed,\n                                         })\n                                     }\n                                 }\n                             }\n                             // `Box<T>` owns its content, so mutable if its location is mutable\n                             _ if base_ty.is_box() => {\n-                                self.is_mutable(place_base, &proj.base, is_local_mutation_allowed)\n+                                self.is_mutable(PlaceRef {\n+                                    base: place.base,\n+                                    projection: &proj.base,\n+                                }, is_local_mutation_allowed)\n                             }\n                             // Deref should only be for reference, pointers or boxes\n                             _ => bug!(\"Deref of unexpected type: {:?}\", base_ty),\n@@ -2221,21 +2229,18 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     | ProjectionElem::ConstantIndex { .. }\n                     | ProjectionElem::Subslice { .. }\n                     | ProjectionElem::Downcast(..) => {\n-                        let upvar_field_projection = self.is_upvar_field_projection(PlaceRef {\n-                            base: &place_base,\n-                            projection: &place_projection,\n-                        });\n+                        let upvar_field_projection = self.is_upvar_field_projection(place);\n                         if let Some(field) = upvar_field_projection {\n                             let upvar = &self.upvars[field.index()];\n                             debug!(\n                                 \"upvar.mutability={:?} local_mutation_is_allowed={:?} \\\n-                                place={:?} {:?}\",\n-                                upvar, is_local_mutation_allowed, place_base, place_projection\n+                                place={:?}\",\n+                                upvar, is_local_mutation_allowed, place\n                             );\n                             match (upvar.mutability, is_local_mutation_allowed) {\n                                 (Mutability::Not, LocalMutationIsAllowed::No)\n                                 | (Mutability::Not, LocalMutationIsAllowed::ExceptUpvars) => {\n-                                    Err((place_base, place_projection))\n+                                    Err(place)\n                                 }\n                                 (Mutability::Not, LocalMutationIsAllowed::Yes)\n                                 | (Mutability::Mut, _) => {\n@@ -2265,18 +2270,22 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     //     });\n                                     // }\n                                     // ```\n-                                    let _ = self.is_mutable(place_base,\n-                                                            &proj.base,\n-                                                            is_local_mutation_allowed)?;\n+                                    let _ = self.is_mutable(PlaceRef {\n+                                        base: place.base,\n+                                        projection: &proj.base,\n+                                    }, is_local_mutation_allowed)?;\n                                     Ok(RootPlace {\n-                                        place_base,\n-                                        place_projection,\n+                                        place_base: place.base,\n+                                        place_projection: place.projection,\n                                         is_local_mutation_allowed,\n                                     })\n                                 }\n                             }\n                         } else {\n-                            self.is_mutable(place_base, &proj.base, is_local_mutation_allowed)\n+                            self.is_mutable(PlaceRef {\n+                                base: place.base,\n+                                projection: &proj.base,\n+                            }, is_local_mutation_allowed)\n                         }\n                     }\n                 }"}, {"sha": "631a81421131c334290d06af2ef8ddcb157f5b2e", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -207,8 +207,8 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                 cleanup: _,\n             } => {\n                 self.consume_operand(location, cond);\n-                use rustc::mir::interpret::PanicMessage;\n-                if let PanicMessage::BoundsCheck { ref len, ref index } = *msg {\n+                use rustc::mir::interpret::PanicInfo;\n+                if let PanicInfo::BoundsCheck { ref len, ref index } = *msg {\n                     self.consume_operand(location, len);\n                     self.consume_operand(location, index);\n                 }"}, {"sha": "f10d505fe89830ca6e46e74371268c6f3eca1d2e", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -26,7 +26,7 @@ use rustc::infer::canonical::QueryRegionConstraints;\n use rustc::infer::outlives::env::RegionBoundPairs;\n use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime, NLLRegionVariableOrigin};\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc::mir::interpret::{ConstValue, PanicMessage};\n+use rustc::mir::interpret::{ConstValue, PanicInfo};\n use rustc::mir::tcx::PlaceTy;\n use rustc::mir::visit::{PlaceContext, Visitor, NonMutatingUseContext};\n use rustc::mir::*;\n@@ -1632,7 +1632,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     span_mirbug!(self, term, \"bad Assert ({:?}, not bool\", cond_ty);\n                 }\n \n-                if let PanicMessage::BoundsCheck { ref len, ref index } = *msg {\n+                if let PanicInfo::BoundsCheck { ref len, ref index } = *msg {\n                     if len.ty(body, tcx) != tcx.types.usize {\n                         span_mirbug!(self, len, \"bounds-check length non-usize {:?}\", len)\n                     }"}, {"sha": "7005f274e0e7def29f39b88d373595e4b1751c67", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -4,7 +4,7 @@ use crate::build::expr::category::Category;\n use crate::build::ForGuard::{OutsideGuard, RefWithinGuard};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::hair::*;\n-use rustc::mir::interpret::{PanicMessage::BoundsCheck};\n+use rustc::mir::interpret::{PanicInfo::BoundsCheck};\n use rustc::mir::*;\n use rustc::ty::{CanonicalUserTypeAnnotation, Variance};\n "}, {"sha": "ec061e74535778d7865c0f2b18700f9ed73e0982", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -7,7 +7,7 @@ use crate::build::expr::category::{Category, RvalueFunc};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::hair::*;\n use rustc::middle::region;\n-use rustc::mir::interpret::PanicMessage;\n+use rustc::mir::interpret::PanicInfo;\n use rustc::mir::*;\n use rustc::ty::{self, CanonicalUserTypeAnnotation, Ty, UpvarSubsts};\n use syntax_pos::Span;\n@@ -101,7 +101,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         block,\n                         Operand::Move(is_min),\n                         false,\n-                        PanicMessage::OverflowNeg,\n+                        PanicInfo::OverflowNeg,\n                         expr_span,\n                     );\n                 }\n@@ -401,7 +401,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let val = result_value.clone().field(val_fld, ty);\n             let of = result_value.field(of_fld, bool_ty);\n \n-            let err = PanicMessage::Overflow(op);\n+            let err = PanicInfo::Overflow(op);\n \n             block = self.assert(block, Operand::Move(of), false, err, span);\n \n@@ -412,11 +412,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // and 2. there are two possible failure cases, divide-by-zero and overflow.\n \n                 let zero_err = if op == BinOp::Div {\n-                    PanicMessage::DivisionByZero\n+                    PanicInfo::DivisionByZero\n                 } else {\n-                    PanicMessage::RemainderByZero\n+                    PanicInfo::RemainderByZero\n                 };\n-                let overflow_err = PanicMessage::Overflow(op);\n+                let overflow_err = PanicInfo::Overflow(op);\n \n                 // Check for / 0\n                 let is_zero = self.temp(bool_ty, span);"}, {"sha": "1b92e4992ffb1b90d316afcc99852a25a677de0f", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -22,7 +22,7 @@ use syntax::source_map::{Span, DUMMY_SP};\n use crate::interpret::{self,\n     PlaceTy, MPlaceTy, OpTy, ImmTy, Immediate, Scalar,\n     RawConst, ConstValue,\n-    InterpResult, InterpErrorInfo, InterpError, GlobalId, InterpCx, StackPopCleanup,\n+    InterpResult, InterpErrorInfo, GlobalId, InterpCx, StackPopCleanup,\n     Allocation, AllocId, MemoryKind,\n     snapshot, RefTracking, intern_const_alloc_recursive,\n };\n@@ -183,7 +183,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n \n impl<'tcx> Into<InterpErrorInfo<'tcx>> for ConstEvalError {\n     fn into(self) -> InterpErrorInfo<'tcx> {\n-        InterpError::MachineError(self.to_string()).into()\n+        err_unsup!(MachineError(self.to_string())).into()\n     }\n }\n \n@@ -352,15 +352,15 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                     ecx.goto_block(ret)?; // fully evaluated and done\n                     Ok(None)\n                 } else {\n-                    err!(MachineError(format!(\"calling non-const function `{}`\", instance)))\n+                    throw_unsup!(MachineError(format!(\"calling non-const function `{}`\", instance)))\n                 };\n             }\n         }\n         // This is a const fn. Call it.\n         Ok(Some(match ecx.load_mir(instance.def) {\n             Ok(body) => body,\n             Err(err) => {\n-                if let InterpError::NoMirFor(ref path) = err.kind {\n+                if let err_unsup!(NoMirFor(ref path)) = err.kind {\n                     return Err(\n                         ConstEvalError::NeedsRfc(format!(\"calling extern function `{}`\", path))\n                             .into(),\n@@ -412,7 +412,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         _tcx: TyCtxt<'tcx>,\n         _def_id: DefId,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>> {\n-        err!(ReadForeignStatic)\n+        throw_unsup!(ReadForeignStatic)\n     }\n \n     #[inline(always)]\n@@ -698,7 +698,7 @@ pub fn const_eval_raw_provider<'tcx>(\n                 // any other kind of error will be reported to the user as a deny-by-default lint\n                 _ => if let Some(p) = cid.promoted {\n                     let span = tcx.promoted_mir(def_id)[p].span;\n-                    if let InterpError::ReferencedConstant = err.error {\n+                    if let err_inval!(ReferencedConstant) = err.error {\n                         err.report_as_error(\n                             tcx.at(span),\n                             \"evaluation of constant expression failed\","}, {"sha": "a481a3b37b7177e4b4876ca05f2106be9cdd5716", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -7,7 +7,7 @@ use syntax::symbol::sym;\n use rustc_apfloat::ieee::{Single, Double};\n use rustc_apfloat::{Float, FloatConvert};\n use rustc::mir::interpret::{\n-    Scalar, InterpResult, Pointer, PointerArithmetic, InterpError,\n+    Scalar, InterpResult, Pointer, PointerArithmetic,\n };\n use rustc::mir::CastKind;\n \n@@ -80,13 +80,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         if self.tcx.has_attr(def_id, sym::rustc_args_required_const) {\n                             bug!(\"reifying a fn ptr that requires const arguments\");\n                         }\n-                        let instance: InterpResult<'tcx, _> = ty::Instance::resolve(\n+                        let instance = ty::Instance::resolve(\n                             *self.tcx,\n                             self.param_env,\n                             def_id,\n                             substs,\n-                        ).ok_or_else(|| InterpError::TooGeneric.into());\n-                        let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance?));\n+                        ).ok_or_else(|| err_inval!(TooGeneric))?;\n+                        let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n                         self.write_scalar(Scalar::Ptr(fn_ptr.into()), dest)?;\n                     }\n                     _ => bug!(\"reify fn pointer on {:?}\", src.layout.ty),\n@@ -199,7 +199,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             },\n \n             // Casts to bool are not permitted by rustc, no need to handle them here.\n-            _ => err!(Unimplemented(format!(\"int to {:?} cast\", dest_layout.ty))),\n+            _ => throw_unsup!(Unimplemented(format!(\"int to {:?} cast\", dest_layout.ty))),\n         }\n     }\n "}, {"sha": "f10d7fb96511601cddbb4f79e60ec9fc0cbe3c26", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -16,8 +16,7 @@ use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::mir::interpret::{\n     ErrorHandled,\n     GlobalId, Scalar, Pointer, FrameInfo, AllocId,\n-    InterpResult, InterpError,\n-    truncate, sign_extend,\n+    InterpResult, truncate, sign_extend,\n };\n use rustc_data_structures::fx::FxHashMap;\n \n@@ -135,7 +134,7 @@ pub enum LocalValue<Tag=(), Id=AllocId> {\n impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n     pub fn access(&self) -> InterpResult<'tcx, Operand<Tag>> {\n         match self.value {\n-            LocalValue::Dead => err!(DeadLocal),\n+            LocalValue::Dead => throw_unsup!(DeadLocal),\n             LocalValue::Uninitialized =>\n                 bug!(\"The type checker should prevent reading from a never-written local\"),\n             LocalValue::Live(val) => Ok(val),\n@@ -148,7 +147,7 @@ impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n         &mut self,\n     ) -> InterpResult<'tcx, Result<&mut LocalValue<Tag>, MemPlace<Tag>>> {\n         match self.value {\n-            LocalValue::Dead => err!(DeadLocal),\n+            LocalValue::Dead => throw_unsup!(DeadLocal),\n             LocalValue::Live(Operand::Indirect(mplace)) => Ok(Err(mplace)),\n             ref mut local @ LocalValue::Live(Operand::Immediate(_)) |\n             ref mut local @ LocalValue::Uninitialized => {\n@@ -190,8 +189,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf for InterpCx<'mir, 'tcx, M> {\n \n     #[inline]\n     fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n-        self.tcx.layout_of(self.param_env.and(ty))\n-            .map_err(|layout| InterpError::Layout(layout).into())\n+        self.tcx\n+            .layout_of(self.param_env.and(ty))\n+            .map_err(|layout| err_inval!(Layout(layout)).into())\n     }\n }\n \n@@ -302,7 +302,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 &substs,\n             )),\n             None => if substs.needs_subst() {\n-                err!(TooGeneric).into()\n+                throw_inval!(TooGeneric)\n             } else {\n                 Ok(substs)\n             },\n@@ -323,7 +323,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             self.param_env,\n             def_id,\n             substs,\n-        ).ok_or_else(|| InterpError::TooGeneric.into())\n+        ).ok_or_else(|| err_inval!(TooGeneric).into())\n     }\n \n     pub fn load_mir(\n@@ -336,14 +336,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             && self.tcx.has_typeck_tables(did)\n             && self.tcx.typeck_tables_of(did).tainted_by_errors\n         {\n-            return err!(TypeckError);\n+            throw_inval!(TypeckError)\n         }\n         trace!(\"load mir {:?}\", instance);\n         match instance {\n             ty::InstanceDef::Item(def_id) => if self.tcx.is_mir_available(did) {\n                 Ok(self.tcx.optimized_mir(did))\n             } else {\n-                err!(NoMirFor(self.tcx.def_path_str(def_id)))\n+                throw_unsup!(NoMirFor(self.tcx.def_path_str(def_id)))\n             },\n             _ => Ok(self.tcx.instance_mir(instance)),\n         }\n@@ -356,7 +356,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match self.stack.last() {\n             Some(frame) => Ok(self.monomorphize_with_substs(t, frame.instance.substs)?),\n             None => if t.needs_subst() {\n-                err!(TooGeneric).into()\n+                throw_inval!(TooGeneric)\n             } else {\n                 Ok(t)\n             },\n@@ -373,7 +373,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let substituted = t.subst(*self.tcx, substs);\n \n         if substituted.needs_subst() {\n-            return err!(TooGeneric);\n+            throw_inval!(TooGeneric)\n         }\n \n         Ok(self.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), substituted))\n@@ -572,7 +572,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         info!(\"ENTERING({}) {}\", self.cur_frame(), self.frame().instance);\n \n         if self.stack.len() > self.tcx.sess.const_eval_stack_frame_limit {\n-            err!(StackFrameLimitReached)\n+            throw_exhaust!(StackFrameLimitReached)\n         } else {\n             Ok(())\n         }\n@@ -620,7 +620,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         } else {\n             // Uh, that shouldn't happen... the function did not intend to return\n-            return err!(Unreachable);\n+            throw_ub!(Unreachable)\n         }\n         // Jump to new block -- *after* validation so that the spans make more sense.\n         match frame.return_to_block {\n@@ -694,8 +694,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // `Memory::get_static_alloc` which has to use `const_eval_raw` to avoid cycles.\n         let val = self.tcx.const_eval_raw(param_env.and(gid)).map_err(|err| {\n             match err {\n-                ErrorHandled::Reported => InterpError::ReferencedConstant,\n-                ErrorHandled::TooGeneric => InterpError::TooGeneric,\n+                ErrorHandled::Reported =>\n+                    err_inval!(ReferencedConstant),\n+                ErrorHandled::TooGeneric =>\n+                    err_inval!(TooGeneric),\n             }\n         })?;\n         self.raw_const_to_mplace(val)"}, {"sha": "e9bba7889119a2f6a532f1d5bb0476640f8e7988", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -4,9 +4,7 @@\n //! memory, we need to extract all memory allocations to the global memory pool so they stay around.\n \n use rustc::ty::{Ty, TyCtxt, ParamEnv, self};\n-use rustc::mir::interpret::{\n-    InterpResult, ErrorHandled,\n-};\n+use rustc::mir::interpret::{InterpResult, ErrorHandled};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use super::validity::RefTracking;\n@@ -16,7 +14,7 @@ use syntax::ast::Mutability;\n use syntax_pos::Span;\n \n use super::{\n-    ValueVisitor, MemoryKind, Pointer, AllocId, MPlaceTy, InterpError, Scalar,\n+    ValueVisitor, MemoryKind, Pointer, AllocId, MPlaceTy, Scalar,\n };\n use crate::const_eval::{CompileTimeInterpreter, CompileTimeEvalContext};\n \n@@ -293,7 +291,7 @@ pub fn intern_const_alloc_recursive(\n         if let Err(error) = interned {\n             // This can happen when e.g. the tag of an enum is not a valid discriminant. We do have\n             // to read enum discriminants in order to find references in enum variant fields.\n-            if let InterpError::ValidationFailure(_) = error.kind {\n+            if let err_unsup!(ValidationFailure(_)) = error.kind {\n                 let err = crate::const_eval::error_to_const_error(&ecx, error);\n                 match err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\") {\n                     Ok(mut diag) => {\n@@ -328,9 +326,7 @@ pub fn intern_const_alloc_recursive(\n             }\n         } else if ecx.memory().dead_alloc_map.contains_key(&alloc_id) {\n             // dangling pointer\n-            return err!(ValidationFailure(\n-                \"encountered dangling pointer in final constant\".into(),\n-            ))\n+            throw_unsup!(ValidationFailure(\"encountered dangling pointer in final constant\".into()))\n         }\n     }\n     Ok(())"}, {"sha": "97866adcfa333ed75e35d8103aed46d6a6ac0d71", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -6,9 +6,7 @@ use syntax::symbol::Symbol;\n use rustc::ty;\n use rustc::ty::layout::{LayoutOf, Primitive, Size};\n use rustc::mir::BinOp;\n-use rustc::mir::interpret::{\n-    InterpResult, InterpError, Scalar, PanicMessage,\n-};\n+use rustc::mir::interpret::{InterpResult, Scalar};\n \n use super::{\n     Machine, PlaceTy, OpTy, InterpCx, Immediate,\n@@ -100,11 +98,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let bits = self.read_scalar(args[0])?.to_bits(layout_of.size)?;\n                 let kind = match layout_of.abi {\n                     ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n-                    _ => Err(::rustc::mir::interpret::InterpError::TypeNotPrimitive(ty))?,\n+                    _ => Err(err_unsup!(TypeNotPrimitive(ty)))?,\n                 };\n                 let out_val = if intrinsic_name.ends_with(\"_nonzero\") {\n                     if bits == 0 {\n-                        return err!(Intrinsic(format!(\"{} called on 0\", intrinsic_name)));\n+                        throw_unsup!(Intrinsic(format!(\"{} called on 0\", intrinsic_name)))\n                     }\n                     numeric_intrinsic(intrinsic_name.trim_end_matches(\"_nonzero\"), bits, kind)?\n                 } else {\n@@ -190,9 +188,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 if overflowed {\n                     let layout = self.layout_of(substs.type_at(0))?;\n                     let r_val =  r.to_scalar()?.to_bits(layout.size)?;\n-                    return err!(Intrinsic(\n-                        format!(\"Overflowing shift by {} in {}\", r_val, intrinsic_name),\n-                    ));\n+                    throw_unsup!(\n+                        Intrinsic(format!(\"Overflowing shift by {} in {}\", r_val, intrinsic_name))\n+                    )\n                 }\n                 self.write_scalar(val, dest)?;\n             }\n@@ -250,7 +248,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             let file = Symbol::intern(self.read_str(file_place)?);\n             let line = self.read_scalar(line.into())?.to_u32()?;\n             let col = self.read_scalar(col.into())?.to_u32()?;\n-            return Err(InterpError::Panic(PanicMessage::Panic { msg, file, line, col }).into());\n+            throw_panic!(Panic { msg, file, line, col })\n         } else if Some(def_id) == self.tcx.lang_items().begin_panic_fn() {\n             assert!(args.len() == 2);\n             // &'static str, &(&'static str, u32, u32)\n@@ -268,7 +266,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             let file = Symbol::intern(self.read_str(file_place)?);\n             let line = self.read_scalar(line.into())?.to_u32()?;\n             let col = self.read_scalar(col.into())?.to_u32()?;\n-            return Err(InterpError::Panic(PanicMessage::Panic { msg, file, line, col }).into());\n+            throw_panic!(Panic { msg, file, line, col })\n         } else {\n             return Ok(false);\n         }"}, {"sha": "78902b101663416b4af8de19ec5629c4ab83af18", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -10,7 +10,7 @@ use rustc::mir;\n use rustc::ty::{self, TyCtxt};\n \n use super::{\n-    Allocation, AllocId, InterpResult, InterpError, Scalar, AllocationExtra,\n+    Allocation, AllocId, InterpResult, Scalar, AllocationExtra,\n     InterpCx, PlaceTy, OpTy, ImmTy, MemoryKind, Pointer, Memory,\n };\n \n@@ -240,9 +240,9 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         int: u64,\n     ) -> InterpResult<'tcx, Pointer<Self::PointerTag>> {\n         Err((if int == 0 {\n-            InterpError::InvalidNullPointerUsage\n+            err_unsup!(InvalidNullPointerUsage)\n         } else {\n-            InterpError::ReadBytesAsPointer\n+            err_unsup!(ReadBytesAsPointer)\n         }).into())\n     }\n \n@@ -251,6 +251,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         _mem: &Memory<'mir, 'tcx, Self>,\n         _ptr: Pointer<Self::PointerTag>,\n     ) -> InterpResult<'tcx, u64> {\n-        err!(ReadPointerAsBytes)\n+        throw_unsup!(ReadPointerAsBytes)\n     }\n }"}, {"sha": "a1574cd5935e9f475f9c866fe46c3360f22d2c27", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 35, "deletions": 38, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -18,7 +18,7 @@ use syntax::ast::Mutability;\n \n use super::{\n     Pointer, AllocId, Allocation, GlobalId, AllocationExtra,\n-    InterpResult, Scalar, InterpError, GlobalAlloc, PointerArithmetic,\n+    InterpResult, Scalar, GlobalAlloc, PointerArithmetic,\n     Machine, AllocMap, MayLeak, ErrorHandled, CheckInAllocMsg,\n };\n \n@@ -66,10 +66,9 @@ impl<'tcx, Other> FnVal<'tcx, Other> {\n         match self {\n             FnVal::Instance(instance) =>\n                 Ok(instance),\n-            FnVal::Other(_) =>\n-                err!(MachineError(\n-                    format!(\"Expected instance function pointer, got 'other' pointer\")\n-                )),\n+            FnVal::Other(_) => throw_unsup!(MachineError(format!(\n+                \"Expected instance function pointer, got 'other' pointer\"\n+            ))),\n         }\n     }\n }\n@@ -203,7 +202,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n         if ptr.offset.bytes() != 0 {\n-            return err!(ReallocateNonBasePtr);\n+            throw_unsup!(ReallocateNonBasePtr)\n         }\n \n         // For simplicities' sake, we implement reallocate as \"alloc, copy, dealloc\".\n@@ -244,41 +243,37 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         trace!(\"deallocating: {}\", ptr.alloc_id);\n \n         if ptr.offset.bytes() != 0 {\n-            return err!(DeallocateNonBasePtr);\n+            throw_unsup!(DeallocateNonBasePtr)\n         }\n \n         let (alloc_kind, mut alloc) = match self.alloc_map.remove(&ptr.alloc_id) {\n             Some(alloc) => alloc,\n             None => {\n                 // Deallocating static memory -- always an error\n-                return match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n-                    Some(GlobalAlloc::Function(..)) => err!(DeallocatedWrongMemoryKind(\n+                return Err(match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n+                    Some(GlobalAlloc::Function(..)) => err_unsup!(DeallocatedWrongMemoryKind(\n                         \"function\".to_string(),\n                         format!(\"{:?}\", kind),\n                     )),\n-                    Some(GlobalAlloc::Static(..)) |\n-                    Some(GlobalAlloc::Memory(..)) => err!(DeallocatedWrongMemoryKind(\n-                        \"static\".to_string(),\n-                        format!(\"{:?}\", kind),\n-                    )),\n-                    None => err!(DoubleFree)\n+                    Some(GlobalAlloc::Static(..)) | Some(GlobalAlloc::Memory(..)) => err_unsup!(\n+                        DeallocatedWrongMemoryKind(\"static\".to_string(), format!(\"{:?}\", kind))\n+                    ),\n+                    None => err_unsup!(DoubleFree),\n                 }\n+                .into());\n             }\n         };\n \n         if alloc_kind != kind {\n-            return err!(DeallocatedWrongMemoryKind(\n+            throw_unsup!(DeallocatedWrongMemoryKind(\n                 format!(\"{:?}\", alloc_kind),\n                 format!(\"{:?}\", kind),\n-            ));\n+            ))\n         }\n         if let Some((size, align)) = old_size_and_align {\n             if size.bytes() != alloc.bytes.len() as u64 || align != alloc.align {\n                 let bytes = Size::from_bytes(alloc.bytes.len() as u64);\n-                return err!(IncorrectAllocationInformation(size,\n-                                                           bytes,\n-                                                           align,\n-                                                           alloc.align));\n+                throw_unsup!(IncorrectAllocationInformation(size, bytes, align, alloc.align))\n             }\n         }\n \n@@ -323,7 +318,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             } else {\n                 // The biggest power of two through which `offset` is divisible.\n                 let offset_pow2 = 1 << offset.trailing_zeros();\n-                err!(AlignmentCheckFailed {\n+                throw_unsup!(AlignmentCheckFailed {\n                     has: Align::from_bytes(offset_pow2).unwrap(),\n                     required: align,\n                 })\n@@ -345,7 +340,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 assert!(size.bytes() == 0);\n                 // Must be non-NULL and aligned.\n                 if bits == 0 {\n-                    return err!(InvalidNullPointerUsage);\n+                    throw_unsup!(InvalidNullPointerUsage)\n                 }\n                 check_offset_align(bits, align)?;\n                 None\n@@ -366,10 +361,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     // got picked we might be aligned even if this check fails.\n                     // We instead have to fall back to converting to an integer and checking\n                     // the \"real\" alignment.\n-                    return err!(AlignmentCheckFailed {\n+                    throw_unsup!(AlignmentCheckFailed {\n                         has: alloc_align,\n                         required: align,\n-                    });\n+                    })\n                 }\n                 check_offset_align(ptr.offset.bytes(), align)?;\n \n@@ -417,9 +412,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Some(GlobalAlloc::Memory(mem)) =>\n                 Cow::Borrowed(mem),\n             Some(GlobalAlloc::Function(..)) =>\n-                return err!(DerefFunctionPointer),\n+                throw_unsup!(DerefFunctionPointer),\n             None =>\n-                return err!(DanglingPointerDeref),\n+                throw_unsup!(DanglingPointerDeref),\n             Some(GlobalAlloc::Static(def_id)) => {\n                 // We got a \"lazy\" static that has not been computed yet.\n                 if tcx.is_foreign_item(def_id) {\n@@ -440,8 +435,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                             // for statics\n                             assert!(tcx.is_static(def_id));\n                             match err {\n-                                ErrorHandled::Reported => InterpError::ReferencedConstant,\n-                                ErrorHandled::TooGeneric => InterpError::TooGeneric,\n+                                ErrorHandled::Reported =>\n+                                    err_inval!(ReferencedConstant),\n+                                ErrorHandled::TooGeneric =>\n+                                    err_inval!(TooGeneric),\n                             }\n                         })?;\n                     // Make sure we use the ID of the resolved memory, not the lazy one!\n@@ -505,11 +502,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             // to give us a cheap reference.\n             let alloc = Self::get_static_alloc(memory_extra, tcx, id)?;\n             if alloc.mutability == Mutability::Immutable {\n-                return err!(ModifiedConstantMemory);\n+                throw_unsup!(ModifiedConstantMemory)\n             }\n             match M::STATIC_KIND {\n                 Some(kind) => Ok((MemoryKind::Machine(kind), alloc.into_owned())),\n-                None => err!(ModifiedStatic),\n+                None => throw_unsup!(ModifiedStatic),\n             }\n         });\n         // Unpack the error type manually because type inference doesn't\n@@ -519,7 +516,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Ok(a) => {\n                 let a = &mut a.1;\n                 if a.mutability == Mutability::Immutable {\n-                    return err!(ModifiedConstantMemory);\n+                    throw_unsup!(ModifiedConstantMemory)\n                 }\n                 Ok(a)\n             }\n@@ -548,7 +545,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         if let Ok(_) = self.get_fn_alloc(id) {\n             return if let AllocCheck::Dereferencable = liveness {\n                 // The caller requested no function pointers.\n-                err!(DerefFunctionPointer)\n+                throw_unsup!(DerefFunctionPointer)\n             } else {\n                 Ok((Size::ZERO, Align::from_bytes(1).unwrap()))\n             };\n@@ -579,7 +576,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     .expect(\"deallocated pointers should all be recorded in \\\n                             `dead_alloc_map`\"))\n             } else {\n-                err!(DanglingPointerDeref)\n+                throw_unsup!(DanglingPointerDeref)\n             },\n         }\n     }\n@@ -591,7 +588,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         } else {\n             match self.tcx.alloc_map.lock().get(id) {\n                 Some(GlobalAlloc::Function(instance)) => Ok(FnVal::Instance(instance)),\n-                _ => Err(InterpError::ExecuteMemory.into()),\n+                _ => throw_unsup!(ExecuteMemory),\n             }\n         }\n     }\n@@ -602,7 +599,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n         let ptr = self.force_ptr(ptr)?; // We definitely need a pointer value.\n         if ptr.offset.bytes() != 0 {\n-            return err!(InvalidFunctionPointer);\n+            throw_unsup!(InvalidFunctionPointer)\n         }\n         self.get_fn_alloc(ptr.alloc_id)\n     }\n@@ -837,9 +834,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     if (src.offset <= dest.offset && src.offset + size > dest.offset) ||\n                         (dest.offset <= src.offset && dest.offset + size > src.offset)\n                     {\n-                        return err!(Intrinsic(\n+                        throw_unsup!(Intrinsic(\n                             \"copy_nonoverlapping called on overlapping ranges\".to_string(),\n-                        ));\n+                        ))\n                     }\n                 }\n "}, {"sha": "e64a474b4ca7171c2a907ffe59b6c5455ec964cd", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -11,8 +11,7 @@ use rustc::ty::layout::{\n use rustc::mir::interpret::{\n     GlobalId, AllocId,\n     ConstValue, Pointer, Scalar,\n-    InterpResult, InterpError,\n-    sign_extend, truncate,\n+    InterpResult, sign_extend, truncate,\n };\n use super::{\n     InterpCx, Machine,\n@@ -331,8 +330,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, &str> {\n         let len = mplace.len(self)?;\n         let bytes = self.memory.read_bytes(mplace.ptr, Size::from_bytes(len as u64))?;\n-        let str = ::std::str::from_utf8(bytes)\n-            .map_err(|err| InterpError::ValidationFailure(err.to_string()))?;\n+        let str = ::std::str::from_utf8(bytes).map_err(|err| {\n+            err_unsup!(ValidationFailure(err.to_string()))\n+        })?;\n         Ok(str)\n     }\n \n@@ -459,7 +459,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         mir_place.iterate(|place_base, place_projection| {\n             let mut op = match place_base {\n-                PlaceBase::Local(mir::RETURN_PLACE) => return err!(ReadFromReturnPointer),\n+                PlaceBase::Local(mir::RETURN_PLACE) =>\n+                    throw_unsup!(ReadFromReturnPointer),\n                 PlaceBase::Local(local) => {\n                     // Do not use the layout passed in as argument if the base we are looking at\n                     // here is not the entire place.\n@@ -530,7 +531,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         };\n         // Early-return cases.\n         match val.val {\n-            ConstValue::Param(_) => return err!(TooGeneric), // FIXME(oli-obk): try to monomorphize\n+            ConstValue::Param(_) =>\n+                // FIXME(oli-obk): try to monomorphize\n+                throw_inval!(TooGeneric),\n             ConstValue::Unevaluated(def_id, substs) => {\n                 let instance = self.resolve(def_id, substs)?;\n                 return Ok(OpTy::from(self.const_eval_raw(GlobalId {\n@@ -604,7 +607,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             layout::DiscriminantKind::Tag => {\n                 let bits_discr = match raw_discr.to_bits(discr_val.layout.size) {\n                     Ok(raw_discr) => raw_discr,\n-                    Err(_) => return err!(InvalidDiscriminant(raw_discr.erase_tag())),\n+                    Err(_) =>\n+                        throw_unsup!(InvalidDiscriminant(raw_discr.erase_tag())),\n                 };\n                 let real_discr = if discr_val.layout.ty.is_signed() {\n                     // going from layout tag type to typeck discriminant type\n@@ -630,7 +634,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         .discriminants(*def_id, self.tcx.tcx)\n                         .find(|(_, var)| var.val == real_discr),\n                     _ => bug!(\"tagged layout for non-adt non-generator\"),\n-                }.ok_or_else(|| InterpError::InvalidDiscriminant(raw_discr.erase_tag()))?;\n+                }.ok_or_else(\n+                    || err_unsup!(InvalidDiscriminant(raw_discr.erase_tag()))\n+                )?;\n                 (real_discr, index.0)\n             },\n             layout::DiscriminantKind::Niche {\n@@ -640,15 +646,16 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             } => {\n                 let variants_start = niche_variants.start().as_u32() as u128;\n                 let variants_end = niche_variants.end().as_u32() as u128;\n-                let raw_discr = raw_discr.not_undef()\n-                    .map_err(|_| InterpError::InvalidDiscriminant(ScalarMaybeUndef::Undef))?;\n+                let raw_discr = raw_discr.not_undef().map_err(|_| {\n+                    err_unsup!(InvalidDiscriminant(ScalarMaybeUndef::Undef))\n+                })?;\n                 match raw_discr.to_bits_or_ptr(discr_val.layout.size, self) {\n                     Err(ptr) => {\n                         // The niche must be just 0 (which an inbounds pointer value never is)\n                         let ptr_valid = niche_start == 0 && variants_start == variants_end &&\n                             !self.memory.ptr_may_be_null(ptr);\n                         if !ptr_valid {\n-                            return err!(InvalidDiscriminant(raw_discr.erase_tag().into()));\n+                            throw_unsup!(InvalidDiscriminant(raw_discr.erase_tag().into()))\n                         }\n                         (dataful_variant.as_u32() as u128, dataful_variant)\n                     },"}, {"sha": "a942da5771b00b3606d25a518c4c67aaa4289882", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -2,7 +2,7 @@ use rustc::mir;\n use rustc::ty::{self, layout::TyLayout};\n use syntax::ast::FloatTy;\n use rustc_apfloat::Float;\n-use rustc::mir::interpret::{InterpResult, PanicMessage, Scalar};\n+use rustc::mir::interpret::{InterpResult, Scalar};\n \n use super::{InterpCx, PlaceTy, Immediate, Machine, ImmTy};\n \n@@ -155,7 +155,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 r,\n                 right_layout.ty\n             );\n-            return err!(Unimplemented(msg));\n+            throw_unsup!(Unimplemented(msg))\n         }\n \n         // Operations that need special treatment for signed integers\n@@ -173,8 +173,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 return Ok((Scalar::from_bool(op(&l, &r)), false));\n             }\n             let op: Option<fn(i128, i128) -> (i128, bool)> = match bin_op {\n-                Div if r == 0 => return err!(Panic(PanicMessage::DivisionByZero)),\n-                Rem if r == 0 => return err!(Panic(PanicMessage::RemainderByZero)),\n+                Div if r == 0 => throw_panic!(DivisionByZero),\n+                Rem if r == 0 => throw_panic!(RemainderByZero),\n                 Div => Some(i128::overflowing_div),\n                 Rem => Some(i128::overflowing_rem),\n                 Add => Some(i128::overflowing_add),\n@@ -231,8 +231,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Add => u128::overflowing_add,\n                     Sub => u128::overflowing_sub,\n                     Mul => u128::overflowing_mul,\n-                    Div if r == 0 => return err!(Panic(PanicMessage::DivisionByZero)),\n-                    Rem if r == 0 => return err!(Panic(PanicMessage::RemainderByZero)),\n+                    Div if r == 0 => throw_panic!(DivisionByZero),\n+                    Rem if r == 0 => throw_panic!(RemainderByZero),\n                     Div => u128::overflowing_div,\n                     Rem => u128::overflowing_rem,\n                     _ => bug!(),\n@@ -250,7 +250,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     r,\n                     right_layout.ty,\n                 );\n-                return err!(Unimplemented(msg));\n+                throw_unsup!(Unimplemented(msg))\n             }\n         };\n "}, {"sha": "f66c4adf763976a33ad969e3681b219efa6b1f01", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -13,8 +13,8 @@ use rustc::ty::TypeFoldable;\n \n use super::{\n     GlobalId, AllocId, Allocation, Scalar, InterpResult, Pointer, PointerArithmetic,\n-    InterpCx, Machine, AllocMap, AllocationExtra, PanicMessage,\n-    RawConst, Immediate, ImmTy, ScalarMaybeUndef, Operand, OpTy, MemoryKind, LocalValue\n+    InterpCx, Machine, AllocMap, AllocationExtra,\n+    RawConst, Immediate, ImmTy, ScalarMaybeUndef, Operand, OpTy, MemoryKind, LocalValue,\n };\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n@@ -356,7 +356,7 @@ where\n                     // This can be violated because this runs during promotion on code where the\n                     // type system has not yet ensured that such things don't happen.\n                     debug!(\"tried to access element {} of array/slice with length {}\", field, len);\n-                    return err!(Panic(PanicMessage::BoundsCheck { len, index: field }));\n+                    throw_panic!(BoundsCheck { len, index: field });\n                 }\n                 stride * field\n             }\n@@ -622,7 +622,7 @@ where\n                                 .layout_of(self.monomorphize(self.frame().body.return_ty())?)?,\n                         }\n                     }\n-                    None => return err!(InvalidNullPointerUsage),\n+                    None => throw_unsup!(InvalidNullPointerUsage),\n                 },\n                 PlaceBase::Local(local) => PlaceTy {\n                     // This works even for dead/uninitialized locals; we check further when writing"}, {"sha": "70a297c866280af83e6b16354bbcaffd3235740f", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -11,8 +11,7 @@ use rustc::ich::StableHashingContextProvider;\n use rustc::mir;\n use rustc::mir::interpret::{\n     AllocId, Pointer, Scalar,\n-    Relocations, Allocation, UndefMask,\n-    InterpResult, InterpError,\n+    Relocations, Allocation, UndefMask, InterpResult,\n };\n \n use rustc::ty::{self, TyCtxt};\n@@ -77,7 +76,7 @@ impl<'mir, 'tcx> InfiniteLoopDetector<'mir, 'tcx> {\n         }\n \n         // Second cycle\n-        Err(InterpError::InfiniteLoop.into())\n+        throw_exhaust!(InfiniteLoop)\n     }\n }\n "}, {"sha": "95824d0ebc16608641930c2fc5af39f4292a4301", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -121,7 +121,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // size of MIR constantly.\n             Nop => {}\n \n-            InlineAsm { .. } => return err!(InlineAsm),\n+            InlineAsm { .. } => throw_unsup!(InlineAsm),\n         }\n \n         self.stack[frame_idx].stmt += 1;"}, {"sha": "d4bc8f460e894d98fa17cc90c34768640358540c", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -7,7 +7,7 @@ use syntax::source_map::Span;\n use rustc_target::spec::abi::Abi;\n \n use super::{\n-    InterpResult, PointerArithmetic, InterpError, Scalar,\n+    InterpResult, PointerArithmetic, Scalar,\n     InterpCx, Machine, Immediate, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup, FnVal,\n };\n \n@@ -19,7 +19,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             self.frame_mut().stmt = 0;\n             Ok(())\n         } else {\n-            err!(Unreachable)\n+            throw_ub!(Unreachable)\n         }\n     }\n \n@@ -89,7 +89,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     },\n                     _ => {\n                         let msg = format!(\"can't handle callee of type {:?}\", func.layout.ty);\n-                        return err!(Unimplemented(msg));\n+                        throw_unsup!(Unimplemented(msg))\n                     }\n                 };\n                 let args = self.eval_operands(args)?;\n@@ -135,32 +135,30 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     self.goto_block(Some(target))?;\n                 } else {\n                     // Compute error message\n-                    use rustc::mir::interpret::PanicMessage::*;\n-                    return match msg {\n+                    use rustc::mir::interpret::PanicInfo::*;\n+                    return Err(match msg {\n                         BoundsCheck { ref len, ref index } => {\n-                            let len = self.read_immediate(self.eval_operand(len, None)?)\n-                                .expect(\"can't eval len\").to_scalar()?\n+                            let len = self\n+                                .read_immediate(self.eval_operand(len, None)?)\n+                                .expect(\"can't eval len\")\n+                                .to_scalar()?\n                                 .to_bits(self.memory().pointer_size())? as u64;\n-                            let index = self.read_immediate(self.eval_operand(index, None)?)\n-                                .expect(\"can't eval index\").to_scalar()?\n+                            let index = self\n+                                .read_immediate(self.eval_operand(index, None)?)\n+                                .expect(\"can't eval index\")\n+                                .to_scalar()?\n                                 .to_bits(self.memory().pointer_size())? as u64;\n-                            err!(Panic(BoundsCheck { len, index }))\n+                            err_panic!(BoundsCheck { len, index })\n                         }\n-                        Overflow(op) =>\n-                            err!(Panic(Overflow(*op))),\n-                        OverflowNeg =>\n-                            err!(Panic(OverflowNeg)),\n-                        DivisionByZero =>\n-                            err!(Panic(DivisionByZero)),\n-                        RemainderByZero =>\n-                            err!(Panic(RemainderByZero)),\n-                        GeneratorResumedAfterReturn =>\n-                            err!(Panic(GeneratorResumedAfterReturn)),\n-                        GeneratorResumedAfterPanic =>\n-                            err!(Panic(GeneratorResumedAfterPanic)),\n-                        Panic { .. } =>\n-                            bug!(\"`Panic` variant cannot occur in MIR\"),\n-                    };\n+                        Overflow(op) => err_panic!(Overflow(*op)),\n+                        OverflowNeg => err_panic!(OverflowNeg),\n+                        DivisionByZero => err_panic!(DivisionByZero),\n+                        RemainderByZero => err_panic!(RemainderByZero),\n+                        GeneratorResumedAfterReturn => err_panic!(GeneratorResumedAfterReturn),\n+                        GeneratorResumedAfterPanic => err_panic!(GeneratorResumedAfterPanic),\n+                        Panic { .. } => bug!(\"`Panic` variant cannot occur in MIR\"),\n+                    }\n+                    .into());\n                 }\n             }\n \n@@ -173,7 +171,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                                       `simplify_branches` mir pass\"),\n             FalseUnwind { .. } => bug!(\"should have been eliminated by\\\n                                        `simplify_branches` mir pass\"),\n-            Unreachable => return err!(Unreachable),\n+            Unreachable => throw_ub!(Unreachable),\n         }\n \n         Ok(())\n@@ -220,13 +218,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(());\n         }\n         let caller_arg = caller_arg.next()\n-            .ok_or_else(|| InterpError::FunctionArgCountMismatch)?;\n+            .ok_or_else(|| err_unsup!(FunctionArgCountMismatch)) ?;\n         if rust_abi {\n             debug_assert!(!caller_arg.layout.is_zst(), \"ZSTs must have been already filtered out\");\n         }\n         // Now, check\n         if !Self::check_argument_compat(rust_abi, caller_arg.layout, callee_arg.layout) {\n-            return err!(FunctionArgMismatch(caller_arg.layout.ty, callee_arg.layout.ty));\n+            throw_unsup!(FunctionArgMismatch(caller_arg.layout.ty, callee_arg.layout.ty))\n         }\n         // We allow some transmutes here\n         self.copy_op_transmute(caller_arg, callee_arg)\n@@ -254,13 +252,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match instance.def {\n             ty::InstanceDef::Intrinsic(..) => {\n                 if caller_abi != Abi::RustIntrinsic {\n-                    return err!(FunctionAbiMismatch(caller_abi, Abi::RustIntrinsic));\n+                    throw_unsup!(FunctionAbiMismatch(caller_abi, Abi::RustIntrinsic))\n                 }\n                 // The intrinsic itself cannot diverge, so if we got here without a return\n                 // place... (can happen e.g., for transmute returning `!`)\n                 let dest = match dest {\n                     Some(dest) => dest,\n-                    None => return err!(Unreachable)\n+                    None => throw_ub!(Unreachable)\n                 };\n                 M::call_intrinsic(self, instance, args, dest)?;\n                 // No stack frame gets pushed, the main loop will just act as if the\n@@ -295,7 +293,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             abi,\n                     };\n                     if normalize_abi(caller_abi) != normalize_abi(callee_abi) {\n-                        return err!(FunctionAbiMismatch(caller_abi, callee_abi));\n+                        throw_unsup!(FunctionAbiMismatch(caller_abi, callee_abi))\n                     }\n                 }\n \n@@ -390,7 +388,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // Now we should have no more caller args\n                     if caller_iter.next().is_some() {\n                         trace!(\"Caller has passed too many args\");\n-                        return err!(FunctionArgCountMismatch);\n+                        throw_unsup!(FunctionArgCountMismatch)\n                     }\n                     // Don't forget to check the return type!\n                     if let Some(caller_ret) = dest {\n@@ -402,15 +400,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             caller_ret.layout,\n                             callee_ret.layout,\n                         ) {\n-                            return err!(FunctionRetMismatch(\n-                                caller_ret.layout.ty, callee_ret.layout.ty\n-                            ));\n+                            throw_unsup!(\n+                                FunctionRetMismatch(caller_ret.layout.ty, callee_ret.layout.ty)\n+                            )\n                         }\n                     } else {\n                         let local = mir::RETURN_PLACE;\n                         let ty = self.frame().body.local_decls[local].ty;\n                         if !self.tcx.is_ty_uninhabited_from_any_module(ty) {\n-                            return err!(FunctionRetMismatch(self.tcx.types.never, ty));\n+                            throw_unsup!(FunctionRetMismatch(self.tcx.types.never, ty))\n                         }\n                     }\n                     Ok(())"}, {"sha": "e55b0d0fb1f2a56e6f572a3b78b6fd2a5070415c", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -1,8 +1,8 @@\n use rustc::ty::{self, Ty, Instance};\n use rustc::ty::layout::{Size, Align, LayoutOf};\n-use rustc::mir::interpret::{Scalar, Pointer, InterpResult, PointerArithmetic};\n+use rustc::mir::interpret::{Scalar, Pointer, InterpResult, PointerArithmetic,};\n \n-use super::{InterpCx, InterpError, Machine, MemoryKind, FnVal};\n+use super::{InterpCx, Machine, MemoryKind, FnVal};\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n@@ -83,7 +83,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     self.param_env,\n                     def_id,\n                     substs,\n-                ).ok_or_else(|| InterpError::TooGeneric)?;\n+                ).ok_or_else(|| err_inval!(TooGeneric))?;\n                 let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n                 let method_ptr = vtable.offset(ptr_size * (3 + i as u64), self)?;\n                 self.memory"}, {"sha": "072c9afc50ae024745fa1c2535d0e009379b0e82", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -10,19 +10,19 @@ use rustc_data_structures::fx::FxHashSet;\n use std::hash::Hash;\n \n use super::{\n-    GlobalAlloc, InterpResult, InterpError,\n+    GlobalAlloc, InterpResult,\n     OpTy, Machine, InterpCx, ValueVisitor, MPlaceTy,\n };\n \n-macro_rules! validation_failure {\n+macro_rules! throw_validation_failure {\n     ($what:expr, $where:expr, $details:expr) => {{\n         let where_ = path_format(&$where);\n         let where_ = if where_.is_empty() {\n             String::new()\n         } else {\n             format!(\" at {}\", where_)\n         };\n-        err!(ValidationFailure(format!(\n+        throw_unsup!(ValidationFailure(format!(\n             \"encountered {}{}, but expected {}\",\n             $what, where_, $details,\n         )))\n@@ -34,7 +34,7 @@ macro_rules! validation_failure {\n         } else {\n             format!(\" at {}\", where_)\n         };\n-        err!(ValidationFailure(format!(\n+        throw_unsup!(ValidationFailure(format!(\n             \"encountered {}{}\",\n             $what, where_,\n         )))\n@@ -45,14 +45,14 @@ macro_rules! try_validation {\n     ($e:expr, $what:expr, $where:expr, $details:expr) => {{\n         match $e {\n             Ok(x) => x,\n-            Err(_) => return validation_failure!($what, $where, $details),\n+            Err(_) => throw_validation_failure!($what, $where, $details),\n         }\n     }};\n \n     ($e:expr, $what:expr, $where:expr) => {{\n         match $e {\n             Ok(x) => x,\n-            Err(_) => return validation_failure!($what, $where),\n+            Err(_) => throw_validation_failure!($what, $where),\n         }\n     }}\n }\n@@ -297,12 +297,12 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         match self.walk_value(op) {\n             Ok(()) => Ok(()),\n             Err(err) => match err.kind {\n-                InterpError::InvalidDiscriminant(val) =>\n-                    validation_failure!(\n+                err_unsup!(InvalidDiscriminant(val)) =>\n+                    throw_validation_failure!(\n                         val, self.path, \"a valid enum discriminant\"\n                     ),\n-                InterpError::ReadPointerAsBytes =>\n-                    validation_failure!(\n+                err_unsup!(ReadPointerAsBytes) =>\n+                    throw_validation_failure!(\n                         \"a pointer\", self.path, \"plain (non-pointer) bytes\"\n                     ),\n                 _ => Err(err),\n@@ -406,19 +406,19 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                             ptr, size, align\n                         );\n                         match err.kind {\n-                            InterpError::InvalidNullPointerUsage =>\n-                                return validation_failure!(\"NULL reference\", self.path),\n-                            InterpError::AlignmentCheckFailed { required, has } =>\n-                                return validation_failure!(format!(\"unaligned reference \\\n+                            err_unsup!(InvalidNullPointerUsage) =>\n+                                throw_validation_failure!(\"NULL reference\", self.path),\n+                            err_unsup!(AlignmentCheckFailed { required, has }) =>\n+                                throw_validation_failure!(format!(\"unaligned reference \\\n                                     (required {} byte alignment but found {})\",\n                                     required.bytes(), has.bytes()), self.path),\n-                            InterpError::ReadBytesAsPointer =>\n-                                return validation_failure!(\n+                            err_unsup!(ReadBytesAsPointer) =>\n+                                throw_validation_failure!(\n                                     \"dangling reference (created from integer)\",\n                                     self.path\n                                 ),\n                             _ =>\n-                                return validation_failure!(\n+                                throw_validation_failure!(\n                                     \"dangling reference (not entirely in bounds)\",\n                                     self.path\n                                 ),\n@@ -478,7 +478,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n \n     fn visit_uninhabited(&mut self) -> InterpResult<'tcx>\n     {\n-        validation_failure!(\"a value of an uninhabited type\", self.path)\n+        throw_validation_failure!(\"a value of an uninhabited type\", self.path)\n     }\n \n     fn visit_scalar(\n@@ -511,27 +511,27 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 if lo == 1 && hi == max_hi {\n                     // Only NULL is the niche.  So make sure the ptr is NOT NULL.\n                     if self.ecx.memory.ptr_may_be_null(ptr) {\n-                        return validation_failure!(\n+                        throw_validation_failure!(\n                             \"a potentially NULL pointer\",\n                             self.path,\n                             format!(\n                                 \"something that cannot possibly fail to be {}\",\n                                 wrapping_range_format(&layout.valid_range, max_hi)\n                             )\n-                        );\n+                        )\n                     }\n                     return Ok(());\n                 } else {\n                     // Conservatively, we reject, because the pointer *could* have a bad\n                     // value.\n-                    return validation_failure!(\n+                    throw_validation_failure!(\n                         \"a pointer\",\n                         self.path,\n                         format!(\n                             \"something that cannot possibly fail to be {}\",\n                             wrapping_range_format(&layout.valid_range, max_hi)\n                         )\n-                    );\n+                    )\n                 }\n             }\n             Ok(data) =>\n@@ -541,7 +541,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         if wrapping_range_contains(&layout.valid_range, bits) {\n             Ok(())\n         } else {\n-            validation_failure!(\n+            throw_validation_failure!(\n                 bits,\n                 self.path,\n                 format!(\"something {}\", wrapping_range_format(&layout.valid_range, max_hi))\n@@ -608,16 +608,14 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     Err(err) => {\n                         // For some errors we might be able to provide extra information\n                         match err.kind {\n-                            InterpError::ReadUndefBytes(offset) => {\n+                            err_unsup!(ReadUndefBytes(offset)) => {\n                                 // Some byte was undefined, determine which\n                                 // element that byte belongs to so we can\n                                 // provide an index.\n                                 let i = (offset.bytes() / ty_size.bytes()) as usize;\n                                 self.path.push(PathElem::ArrayElem(i));\n \n-                                return validation_failure!(\n-                                    \"undefined bytes\", self.path\n-                                )\n+                                throw_validation_failure!(\"undefined bytes\", self.path)\n                             },\n                             // Other errors shouldn't be possible\n                             _ => return Err(err),"}, {"sha": "a450ec32e1a478410a432d9c971c7d9b32f6dbab", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 16, "deletions": 89, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -13,7 +13,7 @@ use rustc::mir::{\n use rustc::mir::visit::{\n     Visitor, PlaceContext, MutatingUseContext, MutVisitor, NonMutatingUseContext,\n };\n-use rustc::mir::interpret::{Scalar, GlobalId, InterpResult, InterpError, PanicMessage};\n+use rustc::mir::interpret::{Scalar, GlobalId, InterpResult, PanicInfo};\n use rustc::ty::{self, Instance, ParamEnv, Ty, TyCtxt};\n use syntax_pos::{Span, DUMMY_SP};\n use rustc::ty::subst::InternalSubsts;\n@@ -258,87 +258,14 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 let diagnostic = error_to_const_error(&self.ecx, error);\n                 use rustc::mir::interpret::InterpError::*;\n                 match diagnostic.error {\n-                    // don't report these, they make no sense in a const prop context\n-                    | MachineError(_)\n-                    | Exit(_)\n-                    // at runtime these transformations might make sense\n-                    // FIXME: figure out the rules and start linting\n-                    | FunctionAbiMismatch(..)\n-                    | FunctionArgMismatch(..)\n-                    | FunctionRetMismatch(..)\n-                    | FunctionArgCountMismatch\n-                    // fine at runtime, might be a register address or sth\n-                    | ReadBytesAsPointer\n-                    // fine at runtime\n-                    | ReadForeignStatic\n-                    | Unimplemented(_)\n-                    // don't report const evaluator limits\n-                    | StackFrameLimitReached\n-                    | NoMirFor(..)\n-                    | InlineAsm\n-                    => {},\n-\n-                    | InvalidMemoryAccess\n-                    | DanglingPointerDeref\n-                    | DoubleFree\n-                    | InvalidFunctionPointer\n-                    | InvalidBool\n-                    | InvalidDiscriminant(..)\n-                    | PointerOutOfBounds { .. }\n-                    | InvalidNullPointerUsage\n-                    | ValidationFailure(..)\n-                    | InvalidPointerMath\n-                    | ReadUndefBytes(_)\n-                    | DeadLocal\n-                    | InvalidBoolOp(_)\n-                    | DerefFunctionPointer\n-                    | ExecuteMemory\n-                    | Intrinsic(..)\n-                    | InvalidChar(..)\n-                    | AbiViolation(_)\n-                    | AlignmentCheckFailed{..}\n-                    | CalledClosureAsFunction\n-                    | VtableForArgumentlessMethod\n-                    | ModifiedConstantMemory\n-                    | ModifiedStatic\n-                    | AssumptionNotHeld\n-                    // FIXME: should probably be removed and turned into a bug! call\n-                    | TypeNotPrimitive(_)\n-                    | ReallocatedWrongMemoryKind(_, _)\n-                    | DeallocatedWrongMemoryKind(_, _)\n-                    | ReallocateNonBasePtr\n-                    | DeallocateNonBasePtr\n-                    | IncorrectAllocationInformation(..)\n-                    | UnterminatedCString(_)\n-                    | HeapAllocZeroBytes\n-                    | HeapAllocNonPowerOfTwoAlignment(_)\n-                    | Unreachable\n-                    | ReadFromReturnPointer\n-                    | ReferencedConstant\n-                    | InfiniteLoop\n-                    => {\n-                        // FIXME: report UB here\n-                    },\n-\n-                    | OutOfTls\n-                    | TlsOutOfBounds\n-                    | PathNotFound(_)\n-                    => bug!(\"these should not be in rustc, but in miri's machine errors\"),\n-\n-                    | Layout(_)\n-                    | UnimplementedTraitSelection\n-                    | TypeckError\n-                    | TooGeneric\n-                    // these are just noise\n-                    => {},\n-\n-                    // non deterministic\n-                    | ReadPointerAsBytes\n-                    // FIXME: implement\n-                    => {},\n-\n-                    | Panic(_)\n-                    => {\n+                    Exit(_) => bug!(\"the CTFE program cannot exit\"),\n+                    Unsupported(_)\n+                    | UndefinedBehaviour(_)\n+                    | InvalidProgram(_)\n+                    | ResourceExhaustion(_) => {\n+                        // Ignore these errors.\n+                    }\n+                    Panic(_) => {\n                         diagnostic.report_as_lint(\n                             self.ecx.tcx,\n                             \"this expression will panic at runtime\",\n@@ -515,7 +442,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                             // Need to do overflow check here: For actual CTFE, MIR\n                             // generation emits code that does this before calling the op.\n                             if prim.to_bits()? == (1 << (prim.layout.size.bits() - 1)) {\n-                                return err!(Panic(PanicMessage::OverflowNeg));\n+                                throw_panic!(OverflowNeg)\n                             }\n                         }\n                         UnOp::Not => {\n@@ -593,7 +520,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     )\n                 } else {\n                     if overflow {\n-                        let err = InterpError::Panic(PanicMessage::Overflow(op)).into();\n+                        let err = err_panic!(Overflow(op)).into();\n                         let _: Option<()> = self.use_ecx(source_info, |_| Err(err));\n                         return None;\n                     }\n@@ -830,12 +757,12 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                             .as_local_hir_id(self.source.def_id())\n                             .expect(\"some part of a failing const eval must be local\");\n                         let msg = match msg {\n-                            PanicMessage::Overflow(_) |\n-                            PanicMessage::OverflowNeg |\n-                            PanicMessage::DivisionByZero |\n-                            PanicMessage::RemainderByZero =>\n+                            PanicInfo::Overflow(_) |\n+                            PanicInfo::OverflowNeg |\n+                            PanicInfo::DivisionByZero |\n+                            PanicInfo::RemainderByZero =>\n                                 msg.description().to_owned(),\n-                            PanicMessage::BoundsCheck { ref len, ref index } => {\n+                            PanicInfo::BoundsCheck { ref len, ref index } => {\n                                 let len = self\n                                     .eval_operand(len, source_info)\n                                     .expect(\"len must be const\");"}, {"sha": "94bb70e10aa53bda6d01b87dd69ef95704592f46", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -1016,7 +1016,7 @@ fn create_generator_resume_function<'tcx>(\n \n     let mut cases = create_cases(body, &transform, |point| Some(point.resume));\n \n-    use rustc::mir::interpret::PanicMessage::{\n+    use rustc::mir::interpret::PanicInfo::{\n         GeneratorResumedAfterPanic,\n         GeneratorResumedAfterReturn,\n     };"}, {"sha": "6e111f2423659ccbbcc359cb3da7869ad3f44b3c", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -1055,7 +1055,7 @@ impl CStr {\n     ///\n     /// ```no_run\n     /// # #![allow(unused_must_use)]\n-    /// use std::ffi::{CString};\n+    /// use std::ffi::CString;\n     ///\n     /// let ptr = CString::new(\"Hello\").expect(\"CString::new failed\").as_ptr();\n     /// unsafe {\n@@ -1071,7 +1071,7 @@ impl CStr {\n     ///\n     /// ```no_run\n     /// # #![allow(unused_must_use)]\n-    /// use std::ffi::{CString};\n+    /// use std::ffi::CString;\n     ///\n     /// let hello = CString::new(\"Hello\").expect(\"CString::new failed\");\n     /// let ptr = hello.as_ptr();"}, {"sha": "81c5ef135b245c76e87b8a8c00afd2a4c4661e63", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -282,7 +282,10 @@ pub fn compile(\n         quoted::TokenTree::Sequence(\n             DelimSpan::dummy(),\n             Lrc::new(quoted::SequenceRepetition {\n-                tts: vec![quoted::TokenTree::token(token::Semi, def.span)],\n+                tts: vec![quoted::TokenTree::token(\n+                    if body.legacy { token::Semi } else { token::Comma },\n+                    def.span,\n+                )],\n                 separator: None,\n                 kleene: quoted::KleeneToken::new(quoted::KleeneOp::ZeroOrMore, def.span),\n                 num_captures: 0,"}, {"sha": "002aa2f891e4b599d6e23a76ac28c888e5e61a14", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -368,7 +368,7 @@ pub fn stream_to_parser_with_base_dir<'a>(\n \n /// A sequence separator.\n pub struct SeqSep {\n-    /// The seperator token.\n+    /// The separator token.\n     pub sep: Option<TokenKind>,\n     /// `true` if a trailing separator is allowed.\n     pub trailing_sep_allowed: bool,"}, {"sha": "8ca962a4419bdfc6385a20bd1e8023dd37301e20", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -3592,7 +3592,15 @@ impl<'a> Parser<'a> {\n         let mut etc_span = None;\n \n         while self.token != token::CloseDelim(token::Brace) {\n-            let attrs = self.parse_outer_attributes()?;\n+            let attrs = match self.parse_outer_attributes() {\n+                Ok(attrs) => attrs,\n+                Err(err) => {\n+                    if let Some(mut delayed) = delayed_err {\n+                        delayed.emit();\n+                    }\n+                    return Err(err);\n+                },\n+            };\n             let lo = self.token.span;\n \n             // check that a comma comes after every field"}, {"sha": "6af5b1868064035d89b2a42ada4bbfddef7ee491", "filename": "src/test/ui/macros/issue-63102.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Ftest%2Fui%2Fmacros%2Fissue-63102.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Ftest%2Fui%2Fmacros%2Fissue-63102.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-63102.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -0,0 +1,8 @@\n+// check-pass\n+\n+#![feature(decl_macro)]\n+macro foo {\n+    () => {},\n+}\n+\n+fn main() {}"}, {"sha": "d5f5f1469f35a830acb1ba6b91f034f31e02b656", "filename": "src/test/ui/parser/issue-63135.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Ftest%2Fui%2Fparser%2Fissue-63135.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Ftest%2Fui%2Fparser%2Fissue-63135.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-63135.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -0,0 +1,3 @@\n+// error-pattern: aborting due to 6 previous errors\n+\n+fn i(n{...,f #"}, {"sha": "c0286d90af74473a8a4ed370a7825e5f454cf2a9", "filename": "src/test/ui/parser/issue-63135.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Ftest%2Fui%2Fparser%2Fissue-63135.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Ftest%2Fui%2Fparser%2Fissue-63135.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-63135.stderr?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -0,0 +1,44 @@\n+error: this file contains an un-closed delimiter\n+  --> $DIR/issue-63135.rs:3:16\n+   |\n+LL | fn i(n{...,f #\n+   |     - -        ^\n+   |     | |\n+   |     | un-closed delimiter\n+   |     un-closed delimiter\n+\n+error: expected field pattern, found `...`\n+  --> $DIR/issue-63135.rs:3:8\n+   |\n+LL | fn i(n{...,f #\n+   |        ^^^ help: to omit remaining fields, use one fewer `.`: `..`\n+\n+error: expected `}`, found `,`\n+  --> $DIR/issue-63135.rs:3:11\n+   |\n+LL | fn i(n{...,f #\n+   |        ---^\n+   |        |  |\n+   |        |  expected `}`\n+   |        `..` must be at the end and cannot have a trailing comma\n+\n+error: expected `[`, found `}`\n+  --> $DIR/issue-63135.rs:3:15\n+   |\n+LL | fn i(n{...,f #\n+   |               ^ expected `[`\n+\n+error: expected `:`, found `)`\n+  --> $DIR/issue-63135.rs:3:15\n+   |\n+LL | fn i(n{...,f #\n+   |               ^ expected `:`\n+\n+error: expected one of `->`, `where`, or `{`, found `<eof>`\n+  --> $DIR/issue-63135.rs:3:15\n+   |\n+LL | fn i(n{...,f #\n+   |               ^ expected one of `->`, `where`, or `{` here\n+\n+error: aborting due to 6 previous errors\n+"}]}