{"sha": "90c3e9a2c226a89b5e4b6de3cd4a53a655784295", "node_id": "C_kwDOAAsO6NoAKDkwYzNlOWEyYzIyNmE4OWI1ZTRiNmRlM2NkNGE1M2E2NTU3ODQyOTU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-12-09T04:02:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-09T04:02:22Z"}, "message": "Rollup merge of #91645 - ibraheemdev:future-join, r=joshtriplett\n\nImplement `core::future::join!`\n\n`join!` polls multiple futures concurrently and returns their outputs.\n\n```rust\nasync fn run() {\n    let (a, b) = join!(async { 0 }, async { 1 });\n}\n```\n\ncc `@rust-lang/wg-async-foundations`", "tree": {"sha": "9fd185d2a5d809d1001febeb4f49d123db2d4113", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fd185d2a5d809d1001febeb4f49d123db2d4113"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90c3e9a2c226a89b5e4b6de3cd4a53a655784295", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhsX/PCRBK7hj4Ov3rIwAAJh8IAA37580AugvhuLHTykWagaPZ\nBACwVwkhaGc5h3XcQmOdEJUG5MgphNpWVIM7tR/AVpDatDjmFq0grjadClTEqWBp\nh94IOUcVidjtDnVe/25uNbJMcw43pQ7fGVVqL44q9SnBZcl2RyI2y53PHPfPFSM+\nQ67FibLb8/Gpxchhb31dH0DEQcFuKlf/kUeU/2BGM92n+E0/5gF4k66csvdWZpNE\nQm3txeUf8ITUMHmYCg84td2MeJaJi8754PuBaa+/IO4A8zPfH0fGdN15qmRlrynJ\n9IY1HcBCGLQ9ymMEYDnC7y8KTrF9H3RdSTm57o3VLdZ0c5JwA1UYD0axzrEYKb0=\n=xXE3\n-----END PGP SIGNATURE-----\n", "payload": "tree 9fd185d2a5d809d1001febeb4f49d123db2d4113\nparent f82049618d67ebd11b4d4596b214007411e2b0b8\nparent 5478f439e13b55c7b9b858f76986786371b97c8f\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1639022542 +0100\ncommitter GitHub <noreply@github.com> 1639022542 +0100\n\nRollup merge of #91645 - ibraheemdev:future-join, r=joshtriplett\n\nImplement `core::future::join!`\n\n`join!` polls multiple futures concurrently and returns their outputs.\n\n```rust\nasync fn run() {\n    let (a, b) = join!(async { 0 }, async { 1 });\n}\n```\n\ncc `@rust-lang/wg-async-foundations`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90c3e9a2c226a89b5e4b6de3cd4a53a655784295", "html_url": "https://github.com/rust-lang/rust/commit/90c3e9a2c226a89b5e4b6de3cd4a53a655784295", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90c3e9a2c226a89b5e4b6de3cd4a53a655784295/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f82049618d67ebd11b4d4596b214007411e2b0b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f82049618d67ebd11b4d4596b214007411e2b0b8", "html_url": "https://github.com/rust-lang/rust/commit/f82049618d67ebd11b4d4596b214007411e2b0b8"}, {"sha": "5478f439e13b55c7b9b858f76986786371b97c8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5478f439e13b55c7b9b858f76986786371b97c8f", "html_url": "https://github.com/rust-lang/rust/commit/5478f439e13b55c7b9b858f76986786371b97c8f"}], "stats": {"total": 239, "additions": 239, "deletions": 0}, "files": [{"sha": "aadff103ebab44ef04973612948e6113ddaba30f", "filename": "library/core/src/future/join.rs", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/90c3e9a2c226a89b5e4b6de3cd4a53a655784295/library%2Fcore%2Fsrc%2Ffuture%2Fjoin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c3e9a2c226a89b5e4b6de3cd4a53a655784295/library%2Fcore%2Fsrc%2Ffuture%2Fjoin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Fjoin.rs?ref=90c3e9a2c226a89b5e4b6de3cd4a53a655784295", "patch": "@@ -0,0 +1,147 @@\n+#![allow(unused_imports)] // items are used by the macro\n+\n+use crate::cell::UnsafeCell;\n+use crate::future::{poll_fn, Future};\n+use crate::mem;\n+use crate::pin::Pin;\n+use crate::task::{Context, Poll};\n+\n+/// Polls multiple futures simultaneously, returning a tuple\n+/// of all results once complete.\n+///\n+/// While `join!(a, b)` is similar to `(a.await, b.await)`,\n+/// `join!` polls both futures concurrently and is therefore more efficient.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(future_join, future_poll_fn)]\n+///\n+/// use std::future::join;\n+///\n+/// async fn one() -> usize { 1 }\n+/// async fn two() -> usize { 2 }\n+///\n+/// # let _ =  async {\n+/// let x = join!(one(), two()).await;\n+/// assert_eq!(x, (1, 2));\n+/// # };\n+/// ```\n+///\n+/// `join!` is variadic, so you can pass any number of futures:\n+///\n+/// ```\n+/// #![feature(future_join, future_poll_fn)]\n+///\n+/// use std::future::join;\n+///\n+/// async fn one() -> usize { 1 }\n+/// async fn two() -> usize { 2 }\n+/// async fn three() -> usize { 3 }\n+///\n+/// # let _ = async {\n+/// let x = join!(one(), two(), three()).await;\n+/// assert_eq!(x, (1, 2, 3));\n+/// # };\n+/// ```\n+#[unstable(feature = \"future_join\", issue = \"91642\")]\n+pub macro join {\n+    ( $($fut:expr),* $(,)?) => {\n+        join! { @count: (), @futures: {}, @rest: ($($fut,)*) }\n+    },\n+    // Recurse until we have the position of each future in the tuple\n+    (\n+        // A token for each future that has been expanded: \"_ _ _\"\n+        @count: ($($count:tt)*),\n+        // Futures and their positions in the tuple: \"{ a => (_), b => (_ _)) }\"\n+        @futures: { $($fut:tt)* },\n+        // Take a future from @rest to expand\n+        @rest: ($current:expr, $($rest:tt)*)\n+    ) => {\n+        join! {\n+            @count: ($($count)* _),\n+            @futures: { $($fut)* $current => ($($count)*), },\n+            @rest: ($($rest)*)\n+        }\n+    },\n+    // Now generate the output future\n+    (\n+        @count: ($($count:tt)*),\n+        @futures: {\n+            $( $(@$f:tt)? $fut:expr => ( $($pos:tt)* ), )*\n+        },\n+        @rest: ()\n+    ) => {\n+        async move {\n+            let mut futures = ( $( MaybeDone::Future($fut), )* );\n+\n+            poll_fn(move |cx| {\n+                let mut done = true;\n+\n+                $(\n+                    let ( $($pos,)* fut, .. ) = &mut futures;\n+\n+                    // SAFETY: The futures are never moved\n+                    done &= unsafe { Pin::new_unchecked(fut).poll(cx).is_ready() };\n+                )*\n+\n+                if done {\n+                    // Extract all the outputs\n+                    Poll::Ready(($({\n+                        let ( $($pos,)* fut, .. ) = &mut futures;\n+\n+                        fut.take_output().unwrap()\n+                    }),*))\n+                } else {\n+                    Poll::Pending\n+                }\n+            }).await\n+        }\n+    }\n+}\n+\n+/// Future used by `join!` that stores it's output to\n+/// be later taken and doesn't panic when polled after ready.\n+///\n+/// This type is public in a private module for use by the macro.\n+#[allow(missing_debug_implementations)]\n+#[unstable(feature = \"future_join\", issue = \"91642\")]\n+pub enum MaybeDone<F: Future> {\n+    Future(F),\n+    Done(F::Output),\n+    Took,\n+}\n+\n+#[unstable(feature = \"future_join\", issue = \"91642\")]\n+impl<F: Future> MaybeDone<F> {\n+    pub fn take_output(&mut self) -> Option<F::Output> {\n+        match &*self {\n+            MaybeDone::Done(_) => match mem::replace(self, Self::Took) {\n+                MaybeDone::Done(val) => Some(val),\n+                _ => unreachable!(),\n+            },\n+            _ => None,\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"future_join\", issue = \"91642\")]\n+impl<F: Future> Future for MaybeDone<F> {\n+    type Output = ();\n+\n+    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n+        // SAFETY: pinning in structural for `f`\n+        unsafe {\n+            match self.as_mut().get_unchecked_mut() {\n+                MaybeDone::Future(f) => match Pin::new_unchecked(f).poll(cx) {\n+                    Poll::Ready(val) => self.set(Self::Done(val)),\n+                    Poll::Pending => return Poll::Pending,\n+                },\n+                MaybeDone::Done(_) => {}\n+                MaybeDone::Took => unreachable!(),\n+            }\n+        }\n+\n+        Poll::Ready(())\n+    }\n+}"}, {"sha": "88db584aefd08df0a75ccaca7efab0d29fa8edeb", "filename": "library/core/src/future/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90c3e9a2c226a89b5e4b6de3cd4a53a655784295/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c3e9a2c226a89b5e4b6de3cd4a53a655784295/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs?ref=90c3e9a2c226a89b5e4b6de3cd4a53a655784295", "patch": "@@ -11,13 +11,17 @@ use crate::{\n \n mod future;\n mod into_future;\n+mod join;\n mod pending;\n mod poll_fn;\n mod ready;\n \n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub use self::future::Future;\n \n+#[unstable(feature = \"future_join\", issue = \"91642\")]\n+pub use self::join::join;\n+\n #[unstable(feature = \"into_future\", issue = \"67644\")]\n pub use into_future::IntoFuture;\n "}, {"sha": "73249b1b8a4355d899df06664e84a40e11751aa5", "filename": "library/core/tests/future.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/90c3e9a2c226a89b5e4b6de3cd4a53a655784295/library%2Fcore%2Ftests%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c3e9a2c226a89b5e4b6de3cd4a53a655784295/library%2Fcore%2Ftests%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Ffuture.rs?ref=90c3e9a2c226a89b5e4b6de3cd4a53a655784295", "patch": "@@ -0,0 +1,85 @@\n+use std::future::{join, Future};\n+use std::pin::Pin;\n+use std::sync::Arc;\n+use std::task::{Context, Poll, Wake};\n+use std::thread;\n+\n+struct PollN {\n+    val: usize,\n+    polled: usize,\n+    num: usize,\n+}\n+\n+impl Future for PollN {\n+    type Output = usize;\n+\n+    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n+        self.polled += 1;\n+\n+        if self.polled == self.num {\n+            return Poll::Ready(self.val);\n+        }\n+\n+        cx.waker().wake_by_ref();\n+        Poll::Pending\n+    }\n+}\n+\n+fn poll_n(val: usize, num: usize) -> PollN {\n+    PollN { val, num, polled: 0 }\n+}\n+\n+#[test]\n+fn test_join() {\n+    block_on(async move {\n+        let x = join!(async { 0 }).await;\n+        assert_eq!(x, 0);\n+\n+        let x = join!(async { 0 }, async { 1 }).await;\n+        assert_eq!(x, (0, 1));\n+\n+        let x = join!(async { 0 }, async { 1 }, async { 2 }).await;\n+        assert_eq!(x, (0, 1, 2));\n+\n+        let x = join!(\n+            poll_n(0, 1),\n+            poll_n(1, 5),\n+            poll_n(2, 2),\n+            poll_n(3, 1),\n+            poll_n(4, 2),\n+            poll_n(5, 3),\n+            poll_n(6, 4),\n+            poll_n(7, 1)\n+        )\n+        .await;\n+        assert_eq!(x, (0, 1, 2, 3, 4, 5, 6, 7));\n+\n+        let y = String::new();\n+        let x = join!(async {\n+            println!(\"{}\", &y);\n+            1\n+        })\n+        .await;\n+        assert_eq!(x, 1);\n+    });\n+}\n+\n+fn block_on(fut: impl Future) {\n+    struct Waker;\n+    impl Wake for Waker {\n+        fn wake(self: Arc<Self>) {\n+            thread::current().unpark()\n+        }\n+    }\n+\n+    let waker = Arc::new(Waker).into();\n+    let mut cx = Context::from_waker(&waker);\n+    let mut fut = Box::pin(fut);\n+\n+    loop {\n+        match fut.as_mut().poll(&mut cx) {\n+            Poll::Ready(_) => break,\n+            Poll::Pending => thread::park(),\n+        }\n+    }\n+}"}, {"sha": "73a3a1fc3e0af8df8b5fe6803515e43582972014", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/90c3e9a2c226a89b5e4b6de3cd4a53a655784295/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c3e9a2c226a89b5e4b6de3cd4a53a655784295/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=90c3e9a2c226a89b5e4b6de3cd4a53a655784295", "patch": "@@ -29,6 +29,8 @@\n #![feature(flt2dec)]\n #![feature(fmt_internals)]\n #![feature(float_minimum_maximum)]\n+#![feature(future_join)]\n+#![feature(future_poll_fn)]\n #![feature(array_from_fn)]\n #![feature(hashmap_internals)]\n #![feature(try_find)]\n@@ -94,6 +96,7 @@ mod clone;\n mod cmp;\n mod const_ptr;\n mod fmt;\n+mod future;\n mod hash;\n mod intrinsics;\n mod iter;"}]}