{"sha": "fbc8bd3fdbbeed199901d6f387ab57d82aac6e04", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiYzhiZDNmZGJiZWVkMTk5OTAxZDZmMzg3YWI1N2Q4MmFhYzZlMDQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-05-06T16:04:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-06T16:04:47Z"}, "message": "Merge #4043\n\n4043: add Ok wrapping assist #3907 r=matklad a=bnjjj\n\nAbout issue #3907 \r\nclose #3907 \n\nCo-authored-by: Benjamin Coenen <5719034+bnjjj@users.noreply.github.com>", "tree": {"sha": "1817e29c0da2455f898d611e38914ff14cace26c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1817e29c0da2455f898d611e38914ff14cace26c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbc8bd3fdbbeed199901d6f387ab57d82aac6e04", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJesuAfCRBK7hj4Ov3rIwAAdHIIAEl081LbBUrQwSpuVaWq64nC\n666x+bqSW8haVJlvdVcG6q2gpVF8w3aL0EUghXxbTRCLjfwjecgkVnVG+/6fIdIf\nj0gJSc5S/h9sqi7FW92RchIUoP0nAurIzje5bIT5qlWTJJPP/y2vIzzLISm+a8tM\nnzBxNvV/GKrgOZwmfzoZ8dX4faXtZ6HnxMUDZ3tqqCfBvdOP7gAlhVz77oToEE93\nfgpXamO7cUbhRqQEG7DwfsND892txcSYHiNJTYIU06ThIQtqqfFedSLUAJIAFauT\n1GYdYeUBzvHS0BTfspVnL24B3wz6v3RzJ0jNBodWvZfK/sDCV0HCS/q2HaqdIxk=\n=ONBu\n-----END PGP SIGNATURE-----\n", "payload": "tree 1817e29c0da2455f898d611e38914ff14cace26c\nparent e99447ffbf77b17674dc047e5a9f5aff9480ed1c\nparent 51c02ab84f6b88ba39e2d0a3ed22bea51114b05a\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1588781087 +0000\ncommitter GitHub <noreply@github.com> 1588781087 +0000\n\nMerge #4043\n\n4043: add Ok wrapping assist #3907 r=matklad a=bnjjj\n\nAbout issue #3907 \r\nclose #3907 \n\nCo-authored-by: Benjamin Coenen <5719034+bnjjj@users.noreply.github.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbc8bd3fdbbeed199901d6f387ab57d82aac6e04", "html_url": "https://github.com/rust-lang/rust/commit/fbc8bd3fdbbeed199901d6f387ab57d82aac6e04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbc8bd3fdbbeed199901d6f387ab57d82aac6e04/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e99447ffbf77b17674dc047e5a9f5aff9480ed1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e99447ffbf77b17674dc047e5a9f5aff9480ed1c", "html_url": "https://github.com/rust-lang/rust/commit/e99447ffbf77b17674dc047e5a9f5aff9480ed1c"}, {"sha": "51c02ab84f6b88ba39e2d0a3ed22bea51114b05a", "url": "https://api.github.com/repos/rust-lang/rust/commits/51c02ab84f6b88ba39e2d0a3ed22bea51114b05a", "html_url": "https://github.com/rust-lang/rust/commit/51c02ab84f6b88ba39e2d0a3ed22bea51114b05a"}], "stats": {"total": 998, "additions": 998, "deletions": 0}, "files": [{"sha": "1e8d986cdbc4f73f66c9035da48a61bc5123239a", "filename": "crates/ra_assists/src/handlers/change_return_type_to_result.rs", "status": "added", "additions": 971, "deletions": 0, "changes": 971, "blob_url": "https://github.com/rust-lang/rust/blob/fbc8bd3fdbbeed199901d6f387ab57d82aac6e04/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc8bd3fdbbeed199901d6f387ab57d82aac6e04/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs?ref=fbc8bd3fdbbeed199901d6f387ab57d82aac6e04", "patch": "@@ -0,0 +1,971 @@\n+use ra_syntax::{\n+    ast, AstNode,\n+    SyntaxKind::{COMMENT, WHITESPACE},\n+    SyntaxNode, TextSize,\n+};\n+\n+use crate::{Assist, AssistCtx, AssistId};\n+use ast::{BlockExpr, Expr, LoopBodyOwner};\n+\n+// Assist: change_return_type_to_result\n+//\n+// Change the function's return type to Result.\n+//\n+// ```\n+// fn foo() -> i32<|> { 42i32 }\n+// ```\n+// ->\n+// ```\n+// fn foo() -> Result<i32, > { Ok(42i32) }\n+// ```\n+pub(crate) fn change_return_type_to_result(ctx: AssistCtx) -> Option<Assist> {\n+    let fn_def = ctx.find_node_at_offset::<ast::FnDef>();\n+    let fn_def = &mut fn_def?;\n+    let ret_type = &fn_def.ret_type()?.type_ref()?;\n+    if ret_type.syntax().text().to_string().starts_with(\"Result<\") {\n+        return None;\n+    }\n+\n+    let block_expr = &fn_def.body()?;\n+    let cursor_in_ret_type =\n+        fn_def.ret_type()?.syntax().text_range().contains_range(ctx.frange.range);\n+    if !cursor_in_ret_type {\n+        return None;\n+    }\n+\n+    ctx.add_assist(\n+        AssistId(\"change_return_type_to_result\"),\n+        \"Change return type to Result\",\n+        ret_type.syntax().text_range(),\n+        |edit| {\n+            let mut tail_return_expr_collector = TailReturnCollector::new();\n+            tail_return_expr_collector.collect_jump_exprs(block_expr, false);\n+            tail_return_expr_collector.collect_tail_exprs(block_expr);\n+\n+            for ret_expr_arg in tail_return_expr_collector.exprs_to_wrap {\n+                edit.replace_node_and_indent(&ret_expr_arg, format!(\"Ok({})\", ret_expr_arg));\n+            }\n+            edit.replace_node_and_indent(ret_type.syntax(), format!(\"Result<{}, >\", ret_type));\n+\n+            if let Some(node_start) = result_insertion_offset(&ret_type) {\n+                edit.set_cursor(node_start + TextSize::of(&format!(\"Result<{}, \", ret_type)));\n+            }\n+        },\n+    )\n+}\n+\n+struct TailReturnCollector {\n+    exprs_to_wrap: Vec<SyntaxNode>,\n+}\n+\n+impl TailReturnCollector {\n+    fn new() -> Self {\n+        Self { exprs_to_wrap: vec![] }\n+    }\n+    /// Collect all`return` expression\n+    fn collect_jump_exprs(&mut self, block_expr: &BlockExpr, collect_break: bool) {\n+        let statements = block_expr.statements();\n+        for stmt in statements {\n+            let expr = match &stmt {\n+                ast::Stmt::ExprStmt(stmt) => stmt.expr(),\n+                ast::Stmt::LetStmt(stmt) => stmt.initializer(),\n+            };\n+            if let Some(expr) = &expr {\n+                self.handle_exprs(expr, collect_break);\n+            }\n+        }\n+\n+        // Browse tail expressions for each block\n+        if let Some(expr) = block_expr.expr() {\n+            if let Some(last_exprs) = get_tail_expr_from_block(&expr) {\n+                for last_expr in last_exprs {\n+                    let last_expr = match last_expr {\n+                        NodeType::Node(expr) | NodeType::Leaf(expr) => expr,\n+                    };\n+\n+                    if let Some(last_expr) = Expr::cast(last_expr.clone()) {\n+                        self.handle_exprs(&last_expr, collect_break);\n+                    } else if let Some(expr_stmt) = ast::Stmt::cast(last_expr) {\n+                        let expr_stmt = match &expr_stmt {\n+                            ast::Stmt::ExprStmt(stmt) => stmt.expr(),\n+                            ast::Stmt::LetStmt(stmt) => stmt.initializer(),\n+                        };\n+                        if let Some(expr) = &expr_stmt {\n+                            self.handle_exprs(expr, collect_break);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn handle_exprs(&mut self, expr: &Expr, collect_break: bool) {\n+        match expr {\n+            Expr::BlockExpr(block_expr) => {\n+                self.collect_jump_exprs(&block_expr, collect_break);\n+            }\n+            Expr::ReturnExpr(ret_expr) => {\n+                if let Some(ret_expr_arg) = &ret_expr.expr() {\n+                    self.exprs_to_wrap.push(ret_expr_arg.syntax().clone());\n+                }\n+            }\n+            Expr::BreakExpr(break_expr) if collect_break => {\n+                if let Some(break_expr_arg) = &break_expr.expr() {\n+                    self.exprs_to_wrap.push(break_expr_arg.syntax().clone());\n+                }\n+            }\n+            Expr::IfExpr(if_expr) => {\n+                for block in if_expr.blocks() {\n+                    self.collect_jump_exprs(&block, collect_break);\n+                }\n+            }\n+            Expr::LoopExpr(loop_expr) => {\n+                if let Some(block_expr) = loop_expr.loop_body() {\n+                    self.collect_jump_exprs(&block_expr, collect_break);\n+                }\n+            }\n+            Expr::ForExpr(for_expr) => {\n+                if let Some(block_expr) = for_expr.loop_body() {\n+                    self.collect_jump_exprs(&block_expr, collect_break);\n+                }\n+            }\n+            Expr::WhileExpr(while_expr) => {\n+                if let Some(block_expr) = while_expr.loop_body() {\n+                    self.collect_jump_exprs(&block_expr, collect_break);\n+                }\n+            }\n+            Expr::MatchExpr(match_expr) => {\n+                if let Some(arm_list) = match_expr.match_arm_list() {\n+                    arm_list.arms().filter_map(|match_arm| match_arm.expr()).for_each(|expr| {\n+                        self.handle_exprs(&expr, collect_break);\n+                    });\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn collect_tail_exprs(&mut self, block: &BlockExpr) {\n+        if let Some(expr) = block.expr() {\n+            self.handle_exprs(&expr, true);\n+            self.fetch_tail_exprs(&expr);\n+        }\n+    }\n+\n+    fn fetch_tail_exprs(&mut self, expr: &Expr) {\n+        if let Some(exprs) = get_tail_expr_from_block(expr) {\n+            for node_type in &exprs {\n+                match node_type {\n+                    NodeType::Leaf(expr) => {\n+                        self.exprs_to_wrap.push(expr.clone());\n+                    }\n+                    NodeType::Node(expr) => match &Expr::cast(expr.clone()) {\n+                        Some(last_expr) => {\n+                            self.fetch_tail_exprs(last_expr);\n+                        }\n+                        None => {\n+                            self.exprs_to_wrap.push(expr.clone());\n+                        }\n+                    },\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+enum NodeType {\n+    Leaf(SyntaxNode),\n+    Node(SyntaxNode),\n+}\n+\n+/// Get a tail expression inside a block\n+fn get_tail_expr_from_block(expr: &Expr) -> Option<Vec<NodeType>> {\n+    match expr {\n+        Expr::IfExpr(if_expr) => {\n+            let mut nodes = vec![];\n+            for block in if_expr.blocks() {\n+                if let Some(block_expr) = block.expr() {\n+                    if let Some(tail_exprs) = get_tail_expr_from_block(&block_expr) {\n+                        nodes.extend(tail_exprs);\n+                    }\n+                } else if let Some(last_expr) = block.syntax().last_child() {\n+                    nodes.push(NodeType::Node(last_expr));\n+                } else {\n+                    nodes.push(NodeType::Node(block.syntax().clone()));\n+                }\n+            }\n+            Some(nodes)\n+        }\n+        Expr::LoopExpr(loop_expr) => {\n+            loop_expr.syntax().last_child().map(|lc| vec![NodeType::Node(lc)])\n+        }\n+        Expr::ForExpr(for_expr) => {\n+            for_expr.syntax().last_child().map(|lc| vec![NodeType::Node(lc)])\n+        }\n+        Expr::WhileExpr(while_expr) => {\n+            while_expr.syntax().last_child().map(|lc| vec![NodeType::Node(lc)])\n+        }\n+        Expr::BlockExpr(block_expr) => {\n+            block_expr.expr().map(|lc| vec![NodeType::Node(lc.syntax().clone())])\n+        }\n+        Expr::MatchExpr(match_expr) => {\n+            let arm_list = match_expr.match_arm_list()?;\n+            let arms: Vec<NodeType> = arm_list\n+                .arms()\n+                .filter_map(|match_arm| match_arm.expr())\n+                .map(|expr| match expr {\n+                    Expr::ReturnExpr(ret_expr) => NodeType::Node(ret_expr.syntax().clone()),\n+                    Expr::BreakExpr(break_expr) => NodeType::Node(break_expr.syntax().clone()),\n+                    _ => match expr.syntax().last_child() {\n+                        Some(last_expr) => NodeType::Node(last_expr),\n+                        None => NodeType::Node(expr.syntax().clone()),\n+                    },\n+                })\n+                .collect();\n+\n+            Some(arms)\n+        }\n+        Expr::BreakExpr(expr) => expr.expr().map(|e| vec![NodeType::Leaf(e.syntax().clone())]),\n+        Expr::ReturnExpr(ret_expr) => Some(vec![NodeType::Node(ret_expr.syntax().clone())]),\n+        Expr::CallExpr(call_expr) => Some(vec![NodeType::Leaf(call_expr.syntax().clone())]),\n+        Expr::Literal(lit_expr) => Some(vec![NodeType::Leaf(lit_expr.syntax().clone())]),\n+        Expr::TupleExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::ArrayExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::ParenExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::PathExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::Label(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::RecordLit(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::IndexExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::MethodCallExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::AwaitExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::CastExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::RefExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::PrefixExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::RangeExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::BinExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::MacroCall(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::BoxExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        _ => None,\n+    }\n+}\n+\n+fn result_insertion_offset(ret_type: &ast::TypeRef) -> Option<TextSize> {\n+    let non_ws_child = ret_type\n+        .syntax()\n+        .children_with_tokens()\n+        .find(|it| it.kind() != COMMENT && it.kind() != WHITESPACE)?;\n+    Some(non_ws_child.text_range().start())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn change_return_type_to_result_simple() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i3<|>2 {\n+                let test = \"test\";\n+                return 42i32;\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                let test = \"test\";\n+                return Ok(42i32);\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_return_type() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                let test = \"test\";\n+                return 42i32;\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                let test = \"test\";\n+                return Ok(42i32);\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_return_type_bad_cursor() {\n+        check_assist_not_applicable(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32 {\n+                let test = \"test\";<|>\n+                return 42i32;\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_cursor() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> <|>i32 {\n+                let test = \"test\";\n+                return 42i32;\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                let test = \"test\";\n+                return Ok(42i32);\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_tail() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -><|> i32 {\n+                let test = \"test\";\n+                42i32\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                let test = \"test\";\n+                Ok(42i32)\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_tail_only() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                42i32\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                Ok(42i32)\n+            }\"#,\n+        );\n+    }\n+    #[test]\n+    fn change_return_type_to_result_simple_with_tail_block_like() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                if true {\n+                    42i32\n+                } else {\n+                    24i32\n+                }\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                if true {\n+                    Ok(42i32)\n+                } else {\n+                    Ok(24i32)\n+                }\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_nested_if() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                if true {\n+                    if false {\n+                        1\n+                    } else {\n+                        2\n+                    }\n+                } else {\n+                    24i32\n+                }\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                if true {\n+                    if false {\n+                        Ok(1)\n+                    } else {\n+                        Ok(2)\n+                    }\n+                } else {\n+                    Ok(24i32)\n+                }\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_await() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"async fn foo() -> i<|>32 {\n+                if true {\n+                    if false {\n+                        1.await\n+                    } else {\n+                        2.await\n+                    }\n+                } else {\n+                    24i32.await\n+                }\n+            }\"#,\n+            r#\"async fn foo() -> Result<i32, <|>> {\n+                if true {\n+                    if false {\n+                        Ok(1.await)\n+                    } else {\n+                        Ok(2.await)\n+                    }\n+                } else {\n+                    Ok(24i32.await)\n+                }\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_array() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> [i32;<|> 3] {\n+                [1, 2, 3]\n+            }\"#,\n+            r#\"fn foo() -> Result<[i32; 3], <|>> {\n+                Ok([1, 2, 3])\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_cast() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -<|>> i32 {\n+                if true {\n+                    if false {\n+                        1 as i32\n+                    } else {\n+                        2 as i32\n+                    }\n+                } else {\n+                    24 as i32\n+                }\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                if true {\n+                    if false {\n+                        Ok(1 as i32)\n+                    } else {\n+                        Ok(2 as i32)\n+                    }\n+                } else {\n+                    Ok(24 as i32)\n+                }\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_tail_block_like_match() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                let my_var = 5;\n+                match my_var {\n+                    5 => 42i32,\n+                    _ => 24i32,\n+                }\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                let my_var = 5;\n+                match my_var {\n+                    5 => Ok(42i32),\n+                    _ => Ok(24i32),\n+                }\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_loop_with_tail() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                let my_var = 5;\n+                loop {\n+                    println!(\"test\");\n+                    5\n+                }\n+\n+                my_var\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                let my_var = 5;\n+                loop {\n+                    println!(\"test\");\n+                    5\n+                }\n+\n+                Ok(my_var)\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_loop_in_let_stmt() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                let my_var = let x = loop {\n+                    break 1;\n+                };\n+\n+                my_var\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                let my_var = let x = loop {\n+                    break 1;\n+                };\n+\n+                Ok(my_var)\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_tail_block_like_match_return_expr() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                let my_var = 5;\n+                let res = match my_var {\n+                    5 => 42i32,\n+                    _ => return 24i32,\n+                };\n+\n+                res\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                let my_var = 5;\n+                let res = match my_var {\n+                    5 => 42i32,\n+                    _ => return Ok(24i32),\n+                };\n+\n+                Ok(res)\n+            }\"#,\n+        );\n+\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                let my_var = 5;\n+                let res = if my_var == 5 {\n+                    42i32\n+                } else {\n+                    return 24i32;\n+                };\n+\n+                res\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                let my_var = 5;\n+                let res = if my_var == 5 {\n+                    42i32\n+                } else {\n+                    return Ok(24i32);\n+                };\n+\n+                Ok(res)\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_tail_block_like_match_deeper() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                let my_var = 5;\n+                match my_var {\n+                    5 => {\n+                        if true {\n+                            42i32\n+                        } else {\n+                            25i32\n+                        }\n+                    },\n+                    _ => {\n+                        let test = \"test\";\n+                        if test == \"test\" {\n+                            return bar();\n+                        }\n+                        53i32\n+                    },\n+                }\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                let my_var = 5;\n+                match my_var {\n+                    5 => {\n+                        if true {\n+                            Ok(42i32)\n+                        } else {\n+                            Ok(25i32)\n+                        }\n+                    },\n+                    _ => {\n+                        let test = \"test\";\n+                        if test == \"test\" {\n+                            return Ok(bar());\n+                        }\n+                        Ok(53i32)\n+                    },\n+                }\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_tail_block_like_early_return() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i<|>32 {\n+                let test = \"test\";\n+                if test == \"test\" {\n+                    return 24i32;\n+                }\n+                53i32\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                let test = \"test\";\n+                if test == \"test\" {\n+                    return Ok(24i32);\n+                }\n+                Ok(53i32)\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_closure() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo(the_field: u32) -><|> u32 {\n+                let true_closure = || {\n+                    return true;\n+                };\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+\n+                    if true_closure() {\n+                        return 99;\n+                    } else {\n+                        return 0;\n+                    }\n+                }\n+\n+                the_field\n+            }\"#,\n+            r#\"fn foo(the_field: u32) -> Result<u32, <|>> {\n+                let true_closure = || {\n+                    return true;\n+                };\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+\n+                    if true_closure() {\n+                        return Ok(99);\n+                    } else {\n+                        return Ok(0);\n+                    }\n+                }\n+\n+                Ok(the_field)\n+            }\"#,\n+        );\n+\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo(the_field: u32) -> u32<|> {\n+                let true_closure = || {\n+                    return true;\n+                };\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+\n+                    if true_closure() {\n+                        return 99;\n+                    } else {\n+                        return 0;\n+                    }\n+                }\n+                let t = None;\n+\n+                t.unwrap_or_else(|| the_field)\n+            }\"#,\n+            r#\"fn foo(the_field: u32) -> Result<u32, <|>> {\n+                let true_closure = || {\n+                    return true;\n+                };\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+\n+                    if true_closure() {\n+                        return Ok(99);\n+                    } else {\n+                        return Ok(0);\n+                    }\n+                }\n+                let t = None;\n+\n+                Ok(t.unwrap_or_else(|| the_field))\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_weird_forms() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                let test = \"test\";\n+                if test == \"test\" {\n+                    return 24i32;\n+                }\n+                let mut i = 0;\n+                loop {\n+                    if i == 1 {\n+                        break 55;\n+                    }\n+                    i += 1;\n+                }\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                let test = \"test\";\n+                if test == \"test\" {\n+                    return Ok(24i32);\n+                }\n+                let mut i = 0;\n+                loop {\n+                    if i == 1 {\n+                        break Ok(55);\n+                    }\n+                    i += 1;\n+                }\n+            }\"#,\n+        );\n+\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                let test = \"test\";\n+                if test == \"test\" {\n+                    return 24i32;\n+                }\n+                let mut i = 0;\n+                loop {\n+                    loop {\n+                        if i == 1 {\n+                            break 55;\n+                        }\n+                        i += 1;\n+                    }\n+                }\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                let test = \"test\";\n+                if test == \"test\" {\n+                    return Ok(24i32);\n+                }\n+                let mut i = 0;\n+                loop {\n+                    loop {\n+                        if i == 1 {\n+                            break Ok(55);\n+                        }\n+                        i += 1;\n+                    }\n+                }\n+            }\"#,\n+        );\n+\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i3<|>2 {\n+                let test = \"test\";\n+                let other = 5;\n+                if test == \"test\" {\n+                    let res = match other {\n+                        5 => 43,\n+                        _ => return 56,\n+                    };\n+                }\n+                let mut i = 0;\n+                loop {\n+                    loop {\n+                        if i == 1 {\n+                            break 55;\n+                        }\n+                        i += 1;\n+                    }\n+                }\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, <|>> {\n+                let test = \"test\";\n+                let other = 5;\n+                if test == \"test\" {\n+                    let res = match other {\n+                        5 => 43,\n+                        _ => return Ok(56),\n+                    };\n+                }\n+                let mut i = 0;\n+                loop {\n+                    loop {\n+                        if i == 1 {\n+                            break Ok(55);\n+                        }\n+                        i += 1;\n+                    }\n+                }\n+            }\"#,\n+        );\n+\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo(the_field: u32) -> u32<|> {\n+                if the_field < 5 {\n+                    let mut i = 0;\n+                    loop {\n+                        if i > 5 {\n+                            return 55u32;\n+                        }\n+                        i += 3;\n+                    }\n+\n+                    match i {\n+                        5 => return 99,\n+                        _ => return 0,\n+                    };\n+                }\n+\n+                the_field\n+            }\"#,\n+            r#\"fn foo(the_field: u32) -> Result<u32, <|>> {\n+                if the_field < 5 {\n+                    let mut i = 0;\n+                    loop {\n+                        if i > 5 {\n+                            return Ok(55u32);\n+                        }\n+                        i += 3;\n+                    }\n+\n+                    match i {\n+                        5 => return Ok(99),\n+                        _ => return Ok(0),\n+                    };\n+                }\n+\n+                Ok(the_field)\n+            }\"#,\n+        );\n+\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo(the_field: u32) -> u3<|>2 {\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+                    match i {\n+                        5 => return 99,\n+                        _ => return 0,\n+                    }\n+                }\n+\n+                the_field\n+            }\"#,\n+            r#\"fn foo(the_field: u32) -> Result<u32, <|>> {\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+                    match i {\n+                        5 => return Ok(99),\n+                        _ => return Ok(0),\n+                    }\n+                }\n+\n+                Ok(the_field)\n+            }\"#,\n+        );\n+\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo(the_field: u32) -> u32<|> {\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+                    if i == 5 {\n+                        return 99\n+                    } else {\n+                        return 0\n+                    }\n+                }\n+\n+                the_field\n+            }\"#,\n+            r#\"fn foo(the_field: u32) -> Result<u32, <|>> {\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+                    if i == 5 {\n+                        return Ok(99)\n+                    } else {\n+                        return Ok(0)\n+                    }\n+                }\n+\n+                Ok(the_field)\n+            }\"#,\n+        );\n+\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo(the_field: u32) -> <|>u32 {\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+                    if i == 5 {\n+                        return 99;\n+                    } else {\n+                        return 0;\n+                    }\n+                }\n+\n+                the_field\n+            }\"#,\n+            r#\"fn foo(the_field: u32) -> Result<u32, <|>> {\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+                    if i == 5 {\n+                        return Ok(99);\n+                    } else {\n+                        return Ok(0);\n+                    }\n+                }\n+\n+                Ok(the_field)\n+            }\"#,\n+        );\n+    }\n+}"}, {"sha": "0473fd8c200a2b4f3b212bac69d79f30302ec543", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbc8bd3fdbbeed199901d6f387ab57d82aac6e04/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc8bd3fdbbeed199901d6f387ab57d82aac6e04/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=fbc8bd3fdbbeed199901d6f387ab57d82aac6e04", "patch": "@@ -129,6 +129,7 @@ mod handlers {\n     mod replace_qualified_name_with_use;\n     mod replace_unwrap_with_match;\n     mod split_import;\n+    mod change_return_type_to_result;\n     mod add_from_impl_for_enum;\n     mod reorder_fields;\n     mod unwrap_block;\n@@ -145,6 +146,7 @@ mod handlers {\n             add_new::add_new,\n             apply_demorgan::apply_demorgan,\n             auto_import::auto_import,\n+            change_return_type_to_result::change_return_type_to_result,\n             change_visibility::change_visibility,\n             early_return::convert_to_guarded_return,\n             fill_match_arms::fill_match_arms,"}, {"sha": "972dbd251d6a8ebb05071f26b38799cb28ca028a", "filename": "crates/ra_assists/src/tests/generated.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fbc8bd3fdbbeed199901d6f387ab57d82aac6e04/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc8bd3fdbbeed199901d6f387ab57d82aac6e04/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=fbc8bd3fdbbeed199901d6f387ab57d82aac6e04", "patch": "@@ -249,6 +249,19 @@ pub mod std { pub mod collections { pub struct HashMap { } } }\n     )\n }\n \n+#[test]\n+fn doctest_change_return_type_to_result() {\n+    check_doc_test(\n+        \"change_return_type_to_result\",\n+        r#####\"\n+fn foo() -> i32<|> { 42i32 }\n+\"#####,\n+        r#####\"\n+fn foo() -> Result<i32, > { Ok(42i32) }\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_change_visibility() {\n     check_doc_test("}, {"sha": "692fd4f52bacfabe4917646214565a8952053af4", "filename": "docs/user/assists.md", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fbc8bd3fdbbeed199901d6f387ab57d82aac6e04/docs%2Fuser%2Fassists.md", "raw_url": "https://github.com/rust-lang/rust/raw/fbc8bd3fdbbeed199901d6f387ab57d82aac6e04/docs%2Fuser%2Fassists.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fassists.md?ref=fbc8bd3fdbbeed199901d6f387ab57d82aac6e04", "patch": "@@ -241,6 +241,18 @@ fn main() {\n }\n ```\n \n+## `change_return_type_to_result`\n+\n+Change the function's return type to Result.\n+\n+```rust\n+// BEFORE\n+fn foo() -> i32\u2503 { 42i32 }\n+\n+// AFTER\n+fn foo() -> Result<i32, > { Ok(42i32) }\n+```\n+\n ## `change_visibility`\n \n Adds or changes existing visibility specifier."}]}