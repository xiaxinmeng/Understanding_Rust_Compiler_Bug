{"sha": "57c7645cb83e609ff97872bb159633c7f89c485a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3Yzc2NDVjYjgzZTYwOWZmOTc4NzJiYjE1OTYzM2M3Zjg5YzQ4NWE=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-14T09:47:39Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-14T12:43:36Z"}, "message": "Allow static method calls to be bound\n\nThis allows you to take the value of, for example, `[1].len`, or bind\nit with `bind x.map(_)` syntax.\n\nI'm holding off on implementing this for dynamic methods (those on\nbounded type parameters or iface types) until it's clearer what we\nwill do with monomorphization.\n\nIssue #435", "tree": {"sha": "ca51e6fa4c49697ba8244ce45874bae1200d45a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca51e6fa4c49697ba8244ce45874bae1200d45a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57c7645cb83e609ff97872bb159633c7f89c485a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57c7645cb83e609ff97872bb159633c7f89c485a", "html_url": "https://github.com/rust-lang/rust/commit/57c7645cb83e609ff97872bb159633c7f89c485a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57c7645cb83e609ff97872bb159633c7f89c485a/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2e880b75069415d8ebd6ee04508e0b85a8191d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2e880b75069415d8ebd6ee04508e0b85a8191d7", "html_url": "https://github.com/rust-lang/rust/commit/f2e880b75069415d8ebd6ee04508e0b85a8191d7"}], "stats": {"total": 176, "additions": 107, "deletions": 69}, "files": [{"sha": "08e3e04cb913ad82c02555013e576a763e28c9e0", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/57c7645cb83e609ff97872bb159633c7f89c485a/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57c7645cb83e609ff97872bb159633c7f89c485a/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=57c7645cb83e609ff97872bb159633c7f89c485a", "patch": "@@ -2188,7 +2188,7 @@ type lval_result = {bcx: @block_ctxt, val: ValueRef, kind: lval_kind};\n enum callee_env {\n     null_env,\n     is_closure,\n-    self_env(ValueRef),\n+    self_env(ValueRef, ty::t),\n     dict_env(ValueRef, ValueRef),\n }\n type lval_maybe_callee = {bcx: @block_ctxt,\n@@ -2597,36 +2597,28 @@ fn trans_lval(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n     }\n }\n \n-fn maybe_add_env(bcx: @block_ctxt, c: lval_maybe_callee)\n-    -> (lval_kind, ValueRef) {\n-    alt c.env {\n-      is_closure { (c.kind, c.val) }\n-      self_env(_) | dict_env(_, _) {\n-        fail \"Taking the value of a method does not work yet (issue #435)\";\n-      }\n-      null_env {\n-        let llfnty = llvm::LLVMGetElementType(val_ty(c.val));\n-        (temporary, create_real_fn_pair(bcx, llfnty, c.val,\n-                                        null_env_ptr(bcx)))\n-      }\n-    }\n-}\n-\n fn lval_maybe_callee_to_lval(c: lval_maybe_callee, ty: ty::t) -> lval_result {\n-    alt c.generic {\n-      generic_full(gi) {\n+    let must_bind = alt c.generic { generic_full(_) { true } _ { false } } ||\n+        alt c.env { self_env(_, _) | dict_env(_, _) { true } _ { false } };\n+    if must_bind {\n         let n_args = ty::ty_fn_args(ty).len();\n-        let args = vec::init_elt(n_args, none::<@ast::expr>);\n+        let args = vec::init_elt(n_args, none);\n         let space = alloc_ty(c.bcx, ty);\n         let bcx = closure::trans_bind_1(space.bcx, ty, c, args, ty,\n                                               save_in(space.val));\n         add_clean_temp(bcx, space.val, ty);\n-        ret {bcx: bcx, val: space.val, kind: temporary};\n-      }\n-      _ {\n-        let (kind, val) = maybe_add_env(c.bcx, c);\n-        ret {bcx: c.bcx, val: val, kind: kind};\n-      }\n+        {bcx: bcx, val: space.val, kind: temporary}\n+    } else {\n+        alt c.env {\n+          is_closure { {bcx: c.bcx, val: c.val, kind: c.kind} }\n+          null_env {\n+            let llfnty = llvm::LLVMGetElementType(val_ty(c.val));\n+            let llfn = create_real_fn_pair(c.bcx, llfnty, c.val,\n+                                           null_env_ptr(c.bcx));\n+            {bcx: c.bcx, val: llfn, kind: temporary}\n+          }\n+          _ { fail; }\n+        }\n     }\n }\n \n@@ -2762,7 +2754,7 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty: TypeRef,\n         if arg_mode == ast::by_val && (lv.kind == owned || !imm) {\n             val = Load(bcx, val);\n         }\n-        } else if arg_mode == ast::by_copy {\n+    } else if arg_mode == ast::by_copy {\n         let {bcx: cx, val: alloc} = alloc_ty(bcx, e_ty);\n         let last_use = ccx.last_uses.contains_key(e.id);\n         bcx = cx;\n@@ -2926,16 +2918,21 @@ fn trans_call_inner(in_cx: @block_ctxt, fn_expr_ty: ty::t,\n     let cx = new_scope_block_ctxt(in_cx, \"call\");\n     Br(in_cx, cx.llbb);\n     let f_res = get_callee(cx);\n-    let bcx = f_res.bcx;\n+    let bcx = f_res.bcx, ccx = bcx_ccx(cx);\n \n     let faddr = f_res.val;\n     let llenv, dict_param = none;\n     alt f_res.env {\n       null_env {\n-        llenv = llvm::LLVMGetUndef(T_opaque_box_ptr(bcx_ccx(cx)));\n+        llenv = llvm::LLVMGetUndef(T_opaque_box_ptr(ccx));\n+      }\n+      self_env(e, _) {\n+        llenv = PointerCast(bcx, e, T_opaque_box_ptr(ccx));\n+      }\n+      dict_env(dict, e) {\n+        llenv = PointerCast(bcx, e, T_opaque_box_ptr(ccx));\n+        dict_param = some(dict);\n       }\n-      self_env(e) { llenv = e; }\n-      dict_env(dict, e) { llenv = e; dict_param = some(dict); }\n       is_closure {\n         // It's a closure. Have to fetch the elements\n         if f_res.kind == owned {\n@@ -3306,7 +3303,9 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         ret trans_call(bcx, f, args, e.id, dest);\n       }\n       ast::expr_field(_, _, _) {\n-        fail \"Taking the value of a method does not work yet (issue #435)\";\n+        let callee = trans_callee(bcx, e), ty = expr_ty(bcx, e);\n+        let lv = lval_maybe_callee_to_lval(callee, ty);\n+        ret memmove_ty(lv.bcx, get_dest_addr(dest), lv.val, ty);\n       }\n       ast::expr_index(base, idx) {\n         // If it is here, it's not an lval, so this is a user-defined index op"}, {"sha": "45e4bfadcbea38853ffe1ec06fd57ac08e5cc99a", "filename": "src/comp/middle/trans/closure.rs", "status": "modified", "additions": 33, "deletions": 22, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/57c7645cb83e609ff97872bb159633c7f89c485a/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57c7645cb83e609ff97872bb159633c7f89c485a/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs?ref=57c7645cb83e609ff97872bb159633c7f89c485a", "patch": "@@ -494,6 +494,7 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n                 f_res: lval_maybe_callee,\n                 args: [option<@ast::expr>], pair_ty: ty::t,\n                 dest: dest) -> @block_ctxt {\n+    let ccx = bcx_ccx(cx);\n     let bound: [@ast::expr] = [];\n     for argopt: option<@ast::expr> in args {\n         alt argopt { none { } some(e) { bound += [e]; } }\n@@ -523,39 +524,37 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n                 }\n             }\n         }\n-        lazily_emit_all_generic_info_tydesc_glues(bcx_ccx(cx), ginfo);\n+        lazily_emit_all_generic_info_tydesc_glues(ccx, ginfo);\n         (ginfo.item_type, tds, ginfo.param_bounds)\n       }\n       _ { (outgoing_fty, [], @[]) }\n     };\n \n-    if bound.len() == 0u && lltydescs.len() == 0u {\n+    if bound.len() == 0u && lltydescs.len() == 0u &&\n+       (f_res.env == null_env || f_res.env == is_closure) {\n         // Trivial 'binding': just return the closure\n         let lv = lval_maybe_callee_to_lval(f_res, pair_ty);\n-        bcx = lv.bcx;\n-        ret memmove_ty(bcx, get_dest_addr(dest), lv.val, pair_ty);\n+        ret memmove_ty(lv.bcx, get_dest_addr(dest), lv.val, pair_ty);\n     }\n-    let closure = alt f_res.env {\n-      null_env { none }\n-      _ { let (_, cl) = maybe_add_env(cx, f_res); some(cl) }\n-    };\n-\n-    // FIXME: should follow from a precondition on trans_bind_1\n-    let ccx = bcx_ccx(cx);\n-    check (type_has_static_size(ccx, outgoing_fty));\n \n     // Arrange for the bound function to live in the first binding spot\n     // if the function is not statically known.\n-    let (env_vals, target_res) = alt closure {\n-      some(cl) {\n+    let (env_vals, target_info) = alt f_res.env {\n+      null_env { ([], target_static(f_res.val)) }\n+      is_closure {\n         // Cast the function we are binding to be the type that the\n         // closure will expect it to have. The type the closure knows\n         // about has the type parameters substituted with the real types.\n         let llclosurety = T_ptr(type_of(ccx, outgoing_fty));\n-        let src_loc = PointerCast(bcx, cl, llclosurety);\n-        ([env_copy(src_loc, pair_ty, owned)], none)\n+        let src_loc = PointerCast(bcx, f_res.val, llclosurety);\n+        ([env_copy(src_loc, pair_ty, owned)], target_closure)\n+      }\n+      self_env(slf, slf_t) {\n+        ([env_copy(slf, slf_t, owned)], target_self(f_res.val))\n+      }\n+      dict_env(_, _) {\n+        ccx.sess.unimpl(\"binding of dynamic method calls\");\n       }\n-      none { ([], some(f_res.val)) }\n     };\n \n     // Actually construct the closure\n@@ -567,7 +566,7 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n     // Make thunk\n     let llthunk = trans_bind_thunk(\n         cx.fcx.ccx, cx.fcx.path, pair_ty, outgoing_fty_real, args,\n-        cdata_ty, *param_bounds, target_res);\n+        cdata_ty, *param_bounds, target_info);\n \n     // Fill the function pair\n     fill_fn_pair(bcx, get_dest_addr(dest), llthunk.val, llbox);\n@@ -722,6 +721,12 @@ fn make_opaque_cbox_free_glue(\n     }\n }\n \n+enum target_info {\n+    target_closure,\n+    target_static(ValueRef),\n+    target_self(ValueRef),\n+}\n+\n // pth is cx.path\n fn trans_bind_thunk(ccx: @crate_ctxt,\n                     path: path,\n@@ -730,7 +735,7 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n                     args: [option<@ast::expr>],\n                     cdata_ty: ty::t,\n                     param_bounds: [ty::param_bounds],\n-                    target_fn: option<ValueRef>)\n+                    target_info: target_info)\n     -> {val: ValueRef, ty: TypeRef} {\n \n     // If we supported constraints on record fields, we could make the\n@@ -800,11 +805,11 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n     // creating.  (In our running example, target is the function f.)  Pick\n     // out the pointer to the target function from the environment. The\n     // target function lives in the first binding spot.\n-    let (lltargetfn, lltargetenv, starting_idx) = alt target_fn {\n-      some(fptr) {\n+    let (lltargetfn, lltargetenv, starting_idx) = alt target_info {\n+      target_static(fptr) {\n         (fptr, llvm::LLVMGetUndef(T_opaque_cbox_ptr(ccx)), 0)\n       }\n-      none {\n+      target_closure {\n         let {bcx: cx, val: pair} =\n             GEP_tup_like(bcx, cdata_ty, llcdata,\n                          [0, abi::closure_body_bindings, 0]);\n@@ -815,6 +820,12 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n         bcx = cx;\n         (lltargetfn, lltargetenv, 1)\n       }\n+      target_self(fptr) {\n+        let rs = GEP_tup_like(bcx, cdata_ty, llcdata,\n+                              [0, abi::closure_body_bindings, 0]);\n+        bcx = rs.bcx;\n+        (fptr, PointerCast(bcx, rs.val, T_opaque_cbox_ptr(ccx)), 1)\n+      }\n     };\n \n     // And then, pick out the target function's own environment.  That's what"}, {"sha": "3da3f0b236053d171d647585500c74a90545f42a", "filename": "src/comp/middle/trans/impl.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/57c7645cb83e609ff97872bb159633c7f89c485a/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57c7645cb83e609ff97872bb159633c7f89c485a/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs?ref=57c7645cb83e609ff97872bb159633c7f89c485a", "patch": "@@ -63,11 +63,9 @@ fn trans_self_arg(bcx: @block_ctxt, base: @ast::expr) -> result {\n     let tz = [], tr = [];\n     let basety = expr_ty(bcx, base);\n     let m_by_ref = ast::expl(ast::by_ref);\n-    let {bcx, val} =\n-        trans_arg_expr(bcx, {mode: m_by_ref, ty: basety},\n-                       T_ptr(type_of_or_i8(bcx_ccx(bcx), basety)), tz,\n-                       tr, base);\n-    rslt(bcx, PointerCast(bcx, val, T_opaque_cbox_ptr(bcx_ccx(bcx))))\n+    trans_arg_expr(bcx, {mode: m_by_ref, ty: basety},\n+                   T_ptr(type_of_or_i8(bcx_ccx(bcx), basety)), tz,\n+                   tr, base)\n }\n \n fn trans_method_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n@@ -100,7 +98,8 @@ fn trans_static_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n                        substs: option<([ty::t], typeck::dict_res)>)\n     -> lval_maybe_callee {\n     let {bcx, val} = trans_self_arg(bcx, base);\n-    {env: self_env(val) with lval_static_fn(bcx, did, callee_id, substs)}\n+    {env: self_env(val, node_id_type(bcx, base.id))\n+     with lval_static_fn(bcx, did, callee_id, substs)}\n }\n \n fn wrapper_fn_ty(ccx: @crate_ctxt, dict_ty: TypeRef, fty: ty::t,\n@@ -110,7 +109,7 @@ fn wrapper_fn_ty(ccx: @crate_ctxt, dict_ty: TypeRef, fty: ty::t,\n     {ty: fty, llty: T_fn([dict_ty] + inputs, output)}\n }\n \n-fn trans_vtable_callee(bcx: @block_ctxt, self: ValueRef, dict: ValueRef,\n+fn trans_vtable_callee(bcx: @block_ctxt, env: callee_env, dict: ValueRef,\n                        callee_id: ast::node_id, iface_id: ast::def_id,\n                        n_method: uint) -> lval_maybe_callee {\n     let bcx = bcx, ccx = bcx_ccx(bcx), tcx = ccx.tcx;\n@@ -139,7 +138,7 @@ fn trans_vtable_callee(bcx: @block_ctxt, self: ValueRef, dict: ValueRef,\n                                 origins: ccx.dict_map.find(callee_id)});\n     }\n     {bcx: bcx, val: mptr, kind: owned,\n-     env: dict_env(dict, self),\n+     env: env,\n      generic: generic}\n }\n \n@@ -181,7 +180,8 @@ fn trans_param_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n                       n_param: uint, n_bound: uint) -> lval_maybe_callee {\n     let {bcx, val} = trans_self_arg(bcx, base);\n     let dict = option::get(bcx.fcx.lltyparams[n_param].dicts)[n_bound];\n-    trans_vtable_callee(bcx, val, dict, callee_id, iface_id, n_method)\n+    trans_vtable_callee(bcx, dict_env(dict, val), dict,\n+                        callee_id, iface_id, n_method)\n }\n \n // Method callee where the dict comes from a boxed iface\n@@ -193,9 +193,9 @@ fn trans_iface_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n                                      T_ptr(T_ptr(T_dict()))));\n     let box = Load(bcx, GEPi(bcx, val, [0, 1]));\n     // FIXME[impl] I doubt this is alignment-safe\n-    let self = PointerCast(bcx, GEPi(bcx, box, [0, abi::box_field_body]),\n-                           T_opaque_cbox_ptr(bcx_ccx(bcx)));\n-    trans_vtable_callee(bcx, self, dict, callee_id, iface_id, n_method)\n+    let self = GEPi(bcx, box, [0, abi::box_field_body]);\n+    trans_vtable_callee(bcx, dict_env(dict, self), dict,\n+                        callee_id, iface_id, n_method)\n }\n \n fn llfn_arg_tys(ft: TypeRef) -> {inputs: [TypeRef], output: TypeRef} {"}, {"sha": "caa4079a9d46abdc5385ed234204fbf2c454bb2b", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/57c7645cb83e609ff97872bb159633c7f89c485a/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57c7645cb83e609ff97872bb159633c7f89c485a/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=57c7645cb83e609ff97872bb159633c7f89c485a", "patch": "@@ -1674,7 +1674,8 @@ fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n                 alt vec::position(*ifce_methods, {|m| m.ident == name}) {\n                   some(pos) {\n                     let m = ifce_methods[pos];\n-                    ret some({method_ty: ty::mk_fn(tcx, m.fty),\n+                    ret some({method_ty: ty::mk_fn(tcx, {proto: ast::proto_box\n+                                                         with m.fty}),\n                               n_tps: vec::len(*m.tps),\n                               substs: tps,\n                               origin: method_param(iid, pos, n, bound_n),\n@@ -1694,7 +1695,7 @@ fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n         let i = 0u;\n         for m in *ty::iface_methods(tcx, did) {\n             if m.ident == name {\n-                let fty = ty::mk_fn(tcx, m.fty);\n+                let fty = ty::mk_fn(tcx, {proto: ast::proto_box with m.fty});\n                 if ty::type_has_vars(fty) {\n                     tcx.sess.span_fatal(\n                         expr.span, \"can not call a method that contains a \\\n@@ -1717,13 +1718,20 @@ fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n             alt tcx.items.get(did.node) {\n               ast_map::node_method(m, _, _) {\n                 let mt = ty_of_method(tcx, m_check, m);\n-                ty::mk_fn(tcx, mt.fty)\n+                ty::mk_fn(tcx, {proto: ast::proto_box with mt.fty})\n               }\n               _ {\n                   tcx.sess.bug(\"Undocumented invariant in ty_from_did\");\n               }\n             }\n-        } else { csearch::get_type(tcx, did).ty }\n+        } else {\n+            alt ty::get(csearch::get_type(tcx, did).ty).struct {\n+              ty::ty_fn(fty) {\n+                ty::mk_fn(tcx, {proto: ast::proto_box with fty})\n+              }\n+              _ { fail; }\n+            }\n+        }\n     }\n \n     let result = none, complained = false;"}, {"sha": "2eb20ed0e9d2c8c9c883ad212d1d2a0d9dbbec1d", "filename": "src/test/run-pass/bind-methods.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/57c7645cb83e609ff97872bb159633c7f89c485a/src%2Ftest%2Frun-pass%2Fbind-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57c7645cb83e609ff97872bb159633c7f89c485a/src%2Ftest%2Frun-pass%2Fbind-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-methods.rs?ref=57c7645cb83e609ff97872bb159633c7f89c485a", "patch": "@@ -0,0 +1,20 @@\n+iface foo {\n+    fn foo() -> int;\n+    fn bar(p: int) -> int;\n+}\n+impl of foo for int {\n+    fn foo() -> int { self }\n+    fn bar(p: int) -> int { p * self.foo() }\n+}\n+impl <T: foo> of foo for [T] {\n+    fn foo() -> int { vec::foldl(0, self, {|a, b| a + b.foo()}) }\n+    fn bar(p: int) -> int { p + self.len() as int }\n+}\n+\n+fn main() {\n+    let x = [1, 2, 3];\n+    let y = x.foo, z = [4, 5, 6].foo;\n+    assert y() + z() == 21;\n+    let a = x.bar, b = bind [4, 5, 6].bar(_);\n+    assert a(1) + b(2) + z() == 24;\n+}"}]}