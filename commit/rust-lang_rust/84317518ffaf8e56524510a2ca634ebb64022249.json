{"sha": "84317518ffaf8e56524510a2ca634ebb64022249", "node_id": "C_kwDOAAsO6NoAKDg0MzE3NTE4ZmZhZjhlNTY1MjQ1MTBhMmNhNjM0ZWJiNjQwMjIyNDk", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-10-30T11:55:58Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-10-31T17:25:00Z"}, "message": "resolve: Turn the binding from `#[macro_export]` into a proper `Import`", "tree": {"sha": "137159a0bf27706ba1efe0b3e4e83c69d22f3fe1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/137159a0bf27706ba1efe0b3e4e83c69d22f3fe1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84317518ffaf8e56524510a2ca634ebb64022249", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84317518ffaf8e56524510a2ca634ebb64022249", "html_url": "https://github.com/rust-lang/rust/commit/84317518ffaf8e56524510a2ca634ebb64022249", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84317518ffaf8e56524510a2ca634ebb64022249/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "637bfe68a1dc23108e8103034cb1e0590d1a9f6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/637bfe68a1dc23108e8103034cb1e0590d1a9f6c", "html_url": "https://github.com/rust-lang/rust/commit/637bfe68a1dc23108e8103034cb1e0590d1a9f6c"}], "stats": {"total": 157, "additions": 96, "deletions": 61}, "files": [{"sha": "423c57275333a2c355020942ecfb383816b8f24b", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/84317518ffaf8e56524510a2ca634ebb64022249/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84317518ffaf8e56524510a2ca634ebb64022249/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=84317518ffaf8e56524510a2ca634ebb64022249", "patch": "@@ -56,21 +56,7 @@ impl<'a, Id: Into<DefId>> ToNameBinding<'a>\n impl<'a, Id: Into<DefId>> ToNameBinding<'a> for (Res, ty::Visibility<Id>, Span, LocalExpnId) {\n     fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n         arenas.alloc_name_binding(NameBinding {\n-            kind: NameBindingKind::Res(self.0, false),\n-            ambiguity: None,\n-            vis: self.1.to_def_id(),\n-            span: self.2,\n-            expansion: self.3,\n-        })\n-    }\n-}\n-\n-struct IsMacroExport;\n-\n-impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, LocalExpnId, IsMacroExport) {\n-    fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n-        arenas.alloc_name_binding(NameBinding {\n-            kind: NameBindingKind::Res(self.0, true),\n+            kind: NameBindingKind::Res(self.0),\n             ambiguity: None,\n             vis: self.1.to_def_id(),\n             span: self.2,\n@@ -1267,8 +1253,22 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             let binding = (res, vis, span, expansion).to_name_binding(self.r.arenas);\n             self.r.set_binding_parent_module(binding, parent_scope.module);\n             if is_macro_export {\n-                let module = self.r.graph_root;\n-                self.r.define(module, ident, MacroNS, (res, vis, span, expansion, IsMacroExport));\n+                let import = self.r.arenas.alloc_import(Import {\n+                    kind: ImportKind::MacroExport,\n+                    root_id: item.id,\n+                    parent_scope: self.parent_scope,\n+                    imported_module: Cell::new(None),\n+                    has_attributes: false,\n+                    use_span_with_attributes: span,\n+                    use_span: span,\n+                    root_span: span,\n+                    span: span,\n+                    module_path: Vec::new(),\n+                    vis: Cell::new(Some(vis)),\n+                    used: Cell::new(true),\n+                });\n+                let import_binding = self.r.import(binding, import);\n+                self.r.define(self.r.graph_root, ident, MacroNS, import_binding);\n             } else {\n                 self.r.check_reserved_macro_name(ident, res);\n                 self.insert_unused_macro(ident, def_id, item.id, &rule_spans);"}, {"sha": "d14e01a25c89cffec69387b9be9ab2307ae9de58", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/84317518ffaf8e56524510a2ca634ebb64022249/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84317518ffaf8e56524510a2ca634ebb64022249/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=84317518ffaf8e56524510a2ca634ebb64022249", "patch": "@@ -190,12 +190,12 @@ impl<'a> Resolver<'a> {\n             ModuleKind::Block => \"block\",\n         };\n \n-        let old_noun = match old_binding.is_import() {\n+        let old_noun = match old_binding.is_import_user_facing() {\n             true => \"import\",\n             false => \"definition\",\n         };\n \n-        let new_participle = match new_binding.is_import() {\n+        let new_participle = match new_binding.is_import_user_facing() {\n             true => \"imported\",\n             false => \"defined\",\n         };\n@@ -226,7 +226,7 @@ impl<'a> Resolver<'a> {\n                 true => struct_span_err!(self.session, span, E0254, \"{}\", msg),\n                 false => struct_span_err!(self.session, span, E0260, \"{}\", msg),\n             },\n-            _ => match (old_binding.is_import(), new_binding.is_import()) {\n+            _ => match (old_binding.is_import_user_facing(), new_binding.is_import_user_facing()) {\n                 (false, false) => struct_span_err!(self.session, span, E0428, \"{}\", msg),\n                 (true, true) => struct_span_err!(self.session, span, E0252, \"{}\", msg),\n                 _ => struct_span_err!(self.session, span, E0255, \"{}\", msg),\n@@ -248,14 +248,18 @@ impl<'a> Resolver<'a> {\n \n         // See https://github.com/rust-lang/rust/issues/32354\n         use NameBindingKind::Import;\n+        let can_suggest = |binding: &NameBinding<'_>, import: &self::Import<'_>| {\n+            !binding.span.is_dummy()\n+                && !matches!(import.kind, ImportKind::MacroUse | ImportKind::MacroExport)\n+        };\n         let import = match (&new_binding.kind, &old_binding.kind) {\n             // If there are two imports where one or both have attributes then prefer removing the\n             // import without attributes.\n             (Import { import: new, .. }, Import { import: old, .. })\n                 if {\n-                    !new_binding.span.is_dummy()\n-                        && !old_binding.span.is_dummy()\n-                        && (new.has_attributes || old.has_attributes)\n+                    (new.has_attributes || old.has_attributes)\n+                        && can_suggest(old_binding, old)\n+                        && can_suggest(new_binding, new)\n                 } =>\n             {\n                 if old.has_attributes {\n@@ -265,10 +269,10 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n             // Otherwise prioritize the new binding.\n-            (Import { import, .. }, other) if !new_binding.span.is_dummy() => {\n+            (Import { import, .. }, other) if can_suggest(new_binding, import) => {\n                 Some((import, new_binding.span, other.is_import()))\n             }\n-            (other, Import { import, .. }) if !old_binding.span.is_dummy() => {\n+            (other, Import { import, .. }) if can_suggest(old_binding, import) => {\n                 Some((import, old_binding.span, other.is_import()))\n             }\n             _ => None,\n@@ -1683,7 +1687,7 @@ impl<'a> Resolver<'a> {\n             let a = if built_in.is_empty() { res.article() } else { \"a\" };\n             format!(\"{a}{built_in} {thing}{from}\", thing = res.descr())\n         } else {\n-            let introduced = if b.is_import() { \"imported\" } else { \"defined\" };\n+            let introduced = if b.is_import_user_facing() { \"imported\" } else { \"defined\" };\n             format!(\"the {thing} {introduced} here\", thing = res.descr())\n         }\n     }\n@@ -1742,10 +1746,10 @@ impl<'a> Resolver<'a> {\n     /// If the binding refers to a tuple struct constructor with fields,\n     /// returns the span of its fields.\n     fn ctor_fields_span(&self, binding: &NameBinding<'_>) -> Option<Span> {\n-        if let NameBindingKind::Res(\n-            Res::Def(DefKind::Ctor(CtorOf::Struct, CtorKind::Fn), ctor_def_id),\n-            _,\n-        ) = binding.kind\n+        if let NameBindingKind::Res(Res::Def(\n+            DefKind::Ctor(CtorOf::Struct, CtorKind::Fn),\n+            ctor_def_id,\n+        )) = binding.kind\n         {\n             let def_id = self.parent(ctor_def_id);\n             let fields = self.field_names.get(&def_id)?;\n@@ -1789,7 +1793,9 @@ impl<'a> Resolver<'a> {\n                         next_ident = source;\n                         Some(binding)\n                     }\n-                    ImportKind::Glob { .. } | ImportKind::MacroUse => Some(binding),\n+                    ImportKind::Glob { .. } | ImportKind::MacroUse | ImportKind::MacroExport => {\n+                        Some(binding)\n+                    }\n                     ImportKind::ExternCrate { .. } => None,\n                 },\n                 _ => None,"}, {"sha": "17ce854cb4388fa88a41aa87a9b8027730a98eee", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/84317518ffaf8e56524510a2ca634ebb64022249/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84317518ffaf8e56524510a2ca634ebb64022249/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=84317518ffaf8e56524510a2ca634ebb64022249", "patch": "@@ -88,6 +88,11 @@ impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n                                 // here, but `macro_use` imports always refer to external items,\n                                 // so it doesn't matter and we can just do nothing.\n                             }\n+                            ImportKind::MacroExport => {\n+                                // In theory we should reset the parent id to something public\n+                                // here, but it has the same effect as leaving the previous parent,\n+                                // so we can just do nothing.\n+                            }\n                         }\n \n                         level = Level::Reexported;\n@@ -152,13 +157,6 @@ impl<'r, 'ast> Visitor<'ast> for EffectiveVisibilitiesVisitor<'ast, 'r> {\n                 self.update(def_id, Visibility::Public, parent_id, Level::Direct);\n             }\n \n-            // Only exported `macro_rules!` items are public, but they always are\n-            ast::ItemKind::MacroDef(ref macro_def) if macro_def.macro_rules => {\n-                let parent_id = self.r.local_parent(def_id);\n-                let vis = self.r.visibilities[&def_id];\n-                self.update(def_id, vis, parent_id, Level::Direct);\n-            }\n-\n             ast::ItemKind::Mod(..) => {\n                 self.set_bindings_effective_visibilities(def_id);\n                 visit::walk_item(self, item);"}, {"sha": "7598188567458158e654ecbba9560cbaf5aaeae1", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/84317518ffaf8e56524510a2ca634ebb64022249/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84317518ffaf8e56524510a2ca634ebb64022249/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=84317518ffaf8e56524510a2ca634ebb64022249", "patch": "@@ -19,7 +19,7 @@ use crate::late::{\n };\n use crate::macros::{sub_namespace_match, MacroRulesScope};\n use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, Determinacy, Finalize};\n-use crate::{ImportKind, LexicalScopeBinding, Module, ModuleKind, ModuleOrUniformRoot};\n+use crate::{Import, ImportKind, LexicalScopeBinding, Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{NameBinding, NameBindingKind, ParentScope, PathResult, PrivacyError, Res};\n use crate::{ResolutionError, Resolver, Scope, ScopeSet, Segment, ToNameBinding, Weak};\n \n@@ -915,7 +915,11 @@ impl<'a> Resolver<'a> {\n             }\n \n             if !restricted_shadowing && binding.expansion != LocalExpnId::ROOT {\n-                if let NameBindingKind::Res(_, true) = binding.kind {\n+                if let NameBindingKind::Import {\n+                    import: Import { kind: ImportKind::MacroExport, .. },\n+                    ..\n+                } = binding.kind\n+                {\n                     self.macro_expanded_macro_export_errors.insert((path_span, binding.span));\n                 }\n             }"}, {"sha": "bdb852548b84e43e652ba5764297173c20d181e8", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/84317518ffaf8e56524510a2ca634ebb64022249/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84317518ffaf8e56524510a2ca634ebb64022249/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=84317518ffaf8e56524510a2ca634ebb64022249", "patch": "@@ -73,6 +73,7 @@ pub enum ImportKind<'a> {\n         id: NodeId,\n     },\n     MacroUse,\n+    MacroExport,\n }\n \n /// Manually implement `Debug` for `ImportKind` because the `source/target_bindings`\n@@ -113,6 +114,7 @@ impl<'a> std::fmt::Debug for ImportKind<'a> {\n                 .field(\"id\", id)\n                 .finish(),\n             MacroUse => f.debug_struct(\"MacroUse\").finish(),\n+            MacroExport => f.debug_struct(\"MacroExport\").finish(),\n         }\n     }\n }\n@@ -177,7 +179,7 @@ impl<'a> Import<'a> {\n             ImportKind::Single { id, .. }\n             | ImportKind::Glob { id, .. }\n             | ImportKind::ExternCrate { id, .. } => Some(id),\n-            ImportKind::MacroUse => None,\n+            ImportKind::MacroUse | ImportKind::MacroExport => None,\n         }\n     }\n }\n@@ -883,7 +885,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                                         match binding.kind {\n                                             // Never suggest the name that has binding error\n                                             // i.e., the name that cannot be previously resolved\n-                                            NameBindingKind::Res(Res::Err, _) => None,\n+                                            NameBindingKind::Res(Res::Err) => None,\n                                             _ => Some(i.name),\n                                         }\n                                     }\n@@ -1014,7 +1016,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     let mut err =\n                         struct_span_err!(self.r.session, import.span, E0364, \"{error_msg}\");\n                     match binding.kind {\n-                        NameBindingKind::Res(Res::Def(DefKind::Macro(_), def_id), _)\n+                        NameBindingKind::Res(Res::Def(DefKind::Macro(_), def_id))\n                             // exclude decl_macro\n                             if self.r.get_macro_by_def_id(def_id).macro_rules =>\n                         {\n@@ -1235,5 +1237,6 @@ fn import_kind_to_string(import_kind: &ImportKind<'_>) -> String {\n         ImportKind::Glob { .. } => \"*\".to_string(),\n         ImportKind::ExternCrate { .. } => \"<extern crate>\".to_string(),\n         ImportKind::MacroUse => \"#[macro_use]\".to_string(),\n+        ImportKind::MacroExport => \"#[macro_export]\".to_string(),\n     }\n }"}, {"sha": "201ccdf120ba95684eb74a355e629992f8261d6d", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/84317518ffaf8e56524510a2ca634ebb64022249/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84317518ffaf8e56524510a2ca634ebb64022249/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=84317518ffaf8e56524510a2ca634ebb64022249", "patch": "@@ -646,7 +646,7 @@ impl<'a> ToNameBinding<'a> for &'a NameBinding<'a> {\n \n #[derive(Clone, Debug)]\n enum NameBindingKind<'a> {\n-    Res(Res, /* is_macro_export */ bool),\n+    Res(Res),\n     Module(Module<'a>),\n     Import { binding: &'a NameBinding<'a>, import: &'a Import<'a>, used: Cell<bool> },\n }\n@@ -745,7 +745,7 @@ impl<'a> NameBinding<'a> {\n \n     fn res(&self) -> Res {\n         match self.kind {\n-            NameBindingKind::Res(res, _) => res,\n+            NameBindingKind::Res(res) => res,\n             NameBindingKind::Module(module) => module.res().unwrap(),\n             NameBindingKind::Import { binding, .. } => binding.res(),\n         }\n@@ -762,10 +762,10 @@ impl<'a> NameBinding<'a> {\n     fn is_possibly_imported_variant(&self) -> bool {\n         match self.kind {\n             NameBindingKind::Import { binding, .. } => binding.is_possibly_imported_variant(),\n-            NameBindingKind::Res(\n-                Res::Def(DefKind::Variant | DefKind::Ctor(CtorOf::Variant, ..), _),\n+            NameBindingKind::Res(Res::Def(\n+                DefKind::Variant | DefKind::Ctor(CtorOf::Variant, ..),\n                 _,\n-            ) => true,\n+            )) => true,\n             NameBindingKind::Res(..) | NameBindingKind::Module(..) => false,\n         }\n     }\n@@ -788,6 +788,13 @@ impl<'a> NameBinding<'a> {\n         matches!(self.kind, NameBindingKind::Import { .. })\n     }\n \n+    /// The binding introduced by `#[macro_export] macro_rules` is a public import, but it might\n+    /// not be perceived as such by users, so treat it as a non-import in some diagnostics.\n+    fn is_import_user_facing(&self) -> bool {\n+        matches!(self.kind, NameBindingKind::Import { import, .. }\n+            if !matches!(import.kind, ImportKind::MacroExport))\n+    }\n+\n     fn is_glob_import(&self) -> bool {\n         match self.kind {\n             NameBindingKind::Import { import, .. } => import.is_glob(),\n@@ -1283,7 +1290,7 @@ impl<'a> Resolver<'a> {\n \n             arenas,\n             dummy_binding: arenas.alloc_name_binding(NameBinding {\n-                kind: NameBindingKind::Res(Res::Err, false),\n+                kind: NameBindingKind::Res(Res::Err),\n                 ambiguity: None,\n                 expansion: LocalExpnId::ROOT,\n                 span: DUMMY_SP,\n@@ -1998,11 +2005,7 @@ impl<'a> Resolver<'a> {\n \n     // Items that go to reexport table encoded to metadata and visible through it to other crates.\n     fn is_reexport(&self, binding: &NameBinding<'a>) -> Option<def::Res<!>> {\n-        // FIXME: Consider changing the binding inserted by `#[macro_export] macro_rules`\n-        // into the crate root to actual `NameBindingKind::Import`.\n-        if binding.is_import()\n-            || matches!(binding.kind, NameBindingKind::Res(_, _is_macro_export @ true))\n-        {\n+        if binding.is_import() {\n             let res = binding.res().expect_non_local();\n             // Ambiguous imports are treated as errors at this point and are\n             // not exposed to other crates (see #36837 for more details)."}, {"sha": "85ed97663e8a0db7ff00411033bf8a9faff680d2", "filename": "src/test/ui/macros/issue-38715.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/84317518ffaf8e56524510a2ca634ebb64022249/src%2Ftest%2Fui%2Fmacros%2Fissue-38715.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84317518ffaf8e56524510a2ca634ebb64022249/src%2Ftest%2Fui%2Fmacros%2Fissue-38715.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-38715.rs?ref=84317518ffaf8e56524510a2ca634ebb64022249", "patch": "@@ -1,7 +1,17 @@\n #[macro_export]\n-macro_rules! foo { ($i:ident) => {} }\n+macro_rules! foo { () => {} }\n \n #[macro_export]\n macro_rules! foo { () => {} } //~ ERROR the name `foo` is defined multiple times\n \n+mod inner1 {\n+    #[macro_export]\n+    macro_rules! bar { () => {} }\n+}\n+\n+mod inner2 {\n+    #[macro_export]\n+    macro_rules! bar { () => {} } //~ ERROR the name `bar` is defined multiple times\n+}\n+\n fn main() {}"}, {"sha": "828a7f459301fce6e8f21b190107e42fc931a6b9", "filename": "src/test/ui/macros/issue-38715.stderr", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/84317518ffaf8e56524510a2ca634ebb64022249/src%2Ftest%2Fui%2Fmacros%2Fissue-38715.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84317518ffaf8e56524510a2ca634ebb64022249/src%2Ftest%2Fui%2Fmacros%2Fissue-38715.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-38715.stderr?ref=84317518ffaf8e56524510a2ca634ebb64022249", "patch": "@@ -1,14 +1,25 @@\n error[E0428]: the name `foo` is defined multiple times\n   --> $DIR/issue-38715.rs:5:1\n    |\n-LL | macro_rules! foo { ($i:ident) => {} }\n+LL | macro_rules! foo { () => {} }\n    | ---------------- previous definition of the macro `foo` here\n ...\n LL | macro_rules! foo { () => {} }\n    | ^^^^^^^^^^^^^^^^ `foo` redefined here\n    |\n    = note: `foo` must be defined only once in the macro namespace of this module\n \n-error: aborting due to previous error\n+error[E0428]: the name `bar` is defined multiple times\n+  --> $DIR/issue-38715.rs:14:5\n+   |\n+LL |     macro_rules! bar { () => {} }\n+   |     ---------------- previous definition of the macro `bar` here\n+...\n+LL |     macro_rules! bar { () => {} }\n+   |     ^^^^^^^^^^^^^^^^ `bar` redefined here\n+   |\n+   = note: `bar` must be defined only once in the macro namespace of this module\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0428`."}, {"sha": "c1f9ee8dfdf73e1081e3841e9a8e8d26b4c41676", "filename": "src/test/ui/privacy/effective_visibilities.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84317518ffaf8e56524510a2ca634ebb64022249/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84317518ffaf8e56524510a2ca634ebb64022249/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.rs?ref=84317518ffaf8e56524510a2ca634ebb64022249", "patch": "@@ -38,13 +38,13 @@ mod outer { //~ ERROR Direct: pub(crate), Reexported: pub(crate), Reachable: pub\n     }\n \n     #[rustc_effective_visibility]\n-    macro_rules! none_macro { //~ Direct: pub(crate), Reexported: pub(crate), Reachable: pub(crate), ReachableThroughImplTrait: pub(crate)\n+    macro_rules! none_macro { //~ ERROR not in the table\n         () => {};\n     }\n \n     #[macro_export]\n     #[rustc_effective_visibility]\n-    macro_rules! public_macro { //~ Direct: pub, Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+    macro_rules! public_macro { //~ ERROR Direct: pub(self), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n         () => {};\n     }\n "}, {"sha": "5a8f7db38fc8a4db83fd53df3a1bf958b507ae7a", "filename": "src/test/ui/privacy/effective_visibilities.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84317518ffaf8e56524510a2ca634ebb64022249/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84317518ffaf8e56524510a2ca634ebb64022249/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.stderr?ref=84317518ffaf8e56524510a2ca634ebb64022249", "patch": "@@ -64,13 +64,13 @@ error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImpl\n LL |                 PubUnion,\n    |                 ^^^^^^^^\n \n-error: Direct: pub(crate), Reexported: pub(crate), Reachable: pub(crate), ReachableThroughImplTrait: pub(crate)\n+error: not in the table\n   --> $DIR/effective_visibilities.rs:41:5\n    |\n LL |     macro_rules! none_macro {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: Direct: pub, Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+error: Direct: pub(self), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n   --> $DIR/effective_visibilities.rs:47:5\n    |\n LL |     macro_rules! public_macro {"}]}