{"sha": "2ef910f71ab83761b1f5f9144621f246622e92d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlZjkxMGY3MWFiODM3NjFiMWY1ZjkxNDQ2MjFmMjQ2NjIyZTkyZDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-16T06:32:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-16T06:32:03Z"}, "message": "auto merge of #14715 : vhbit/rust/ios-pr2, r=alexcrichton", "tree": {"sha": "260c5393432cab41234c55eb88f24575afa2ad16", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/260c5393432cab41234c55eb88f24575afa2ad16"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ef910f71ab83761b1f5f9144621f246622e92d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ef910f71ab83761b1f5f9144621f246622e92d8", "html_url": "https://github.com/rust-lang/rust/commit/2ef910f71ab83761b1f5f9144621f246622e92d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ef910f71ab83761b1f5f9144621f246622e92d8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d8342f5e9f7093694548e761ee7df4f55243f3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d8342f5e9f7093694548e761ee7df4f55243f3f", "html_url": "https://github.com/rust-lang/rust/commit/6d8342f5e9f7093694548e761ee7df4f55243f3f"}, {"sha": "2ec323e4c30c265f35314c0a77f5df5a655cec2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ec323e4c30c265f35314c0a77f5df5a655cec2f", "html_url": "https://github.com/rust-lang/rust/commit/2ec323e4c30c265f35314c0a77f5df5a655cec2f"}], "stats": {"total": 1032, "additions": 803, "deletions": 229}, "files": [{"sha": "1efa1cc5b6d85751a3c25b22e729508be80e48ed", "filename": "mk/platform.mk", "status": "modified", "additions": 68, "deletions": 28, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -155,36 +155,76 @@ CFG_LDPATH_i686-unknown-linux-gnu :=\n CFG_RUN_i686-unknown-linux-gnu=$(2)\n CFG_RUN_TARG_i686-unknown-linux-gnu=$(call CFG_RUN_i686-unknown-linux-gnu,,$(2))\n \n-# arm-apple-darwin configuration\n-ifeq ($(CFG_OSTYPE),apple-darwin)\n+# arm-apple-ios configuration\n+CFG_SDK_NAME_arm-apple-ios = iphoneos\n+CFG_SDK_ARCHS_arm-apple-ios = armv7\n+ifneq ($(findstring darwin,$(CFG_OSTYPE)),)\n CFG_IOS_SDK = $(shell xcrun --show-sdk-path -sdk iphoneos 2>/dev/null)\n-CFG_IOS_FLAGS = -target arm-apple-darwin -isysroot $(CFG_IOS_SDK) -I$(CFG_IOS_SDK)/usr/include -I$(CFG_IOS_SDK)/usr/include/c++/4.2.1\n-CC_arm-apple-darwin = $(shell xcrun -find -sdk iphoneos clang)\n-CXX_arm-apple-darwin = $(shell xcrun -find -sdk iphoneos clang++)\n-CPP_arm-apple-darwin = $(shell xcrun -find -sdk iphoneos clang++)\n-AR_arm-apple-darwin = $(shell xcrun -find -sdk iphoneos ar)\n-CFG_LIB_NAME_arm-apple-darwin = lib$(1).dylib\n-CFG_LIB_GLOB_arm-apple-darwin = lib$(1)-*.dylib\n-CFG_LIB_DSYM_GLOB_arm-apple-darwin = lib$(1)-*.dylib.dSYM\n-CFG_CFLAGS_arm-apple-darwin := $(CFG_IOS_FLAGS) $(CFLAGS)\n-CFG_GCCISH_CFLAGS_arm-apple-darwin := -Wall -Werror -g -fPIC $(CFG_IOS_FLAGS) $(CFLAGS)\n-CFG_GCCISH_CXXFLAGS_arm-apple-darwin := -fno-rtti $(CFG_IOS_FLAGS) $(CXXFLAGS)\n-CFG_GCCISH_LINK_FLAGS_arm-apple-darwin := -dynamiclib -lpthread -framework CoreServices -Wl,-no_compact_unwind\n-CFG_GCCISH_DEF_FLAG_arm-apple-darwin := -Wl,-exported_symbols_list,\n-CFG_GCCISH_PRE_LIB_FLAGS_arm-apple-darwin :=\n-CFG_GCCISH_POST_LIB_FLAGS_arm-apple-darwin :=\n-CFG_DEF_SUFFIX_arm-apple-darwin := .darwin.def\n-CFG_LLC_FLAGS_arm-apple-darwin :=\n-CFG_INSTALL_NAME_arm-apple-darwin = -Wl,-install_name,@rpath/$(1)\n-CFG_LIBUV_LINK_FLAGS_arm-apple-darwin =\n-CFG_EXE_SUFFIX_arm-apple-darwin :=\n-CFG_WINDOWSY_arm-apple-darwin :=\n-CFG_UNIXY_arm-apple-darwin := 1\n-CFG_PATH_MUNGE_arm-apple-darwin := true\n-CFG_LDPATH_arm-apple-darwin :=\n-CFG_RUN_arm-apple-darwin = $(2)\n-CFG_RUN_TARG_arm-apple-darwin = $(call CFG_RUN_arm-apple-darwin,,$(2))\n+CFG_IOS_FLAGS = -target armv7-apple-darwin -isysroot $(CFG_IOS_SDK) -mios-version-min=7.0\n+CC_arm-apple-ios = $(shell xcrun -find -sdk iphoneos clang)\n+CXX_arm-apple-ios = $(shell xcrun -find -sdk iphoneos clang++)\n+CPP_arm-apple-ios = $(shell xcrun -find -sdk iphoneos clang++)\n+AR_arm-apple-ios = $(shell xcrun -find -sdk iphoneos ar)\n endif\n+CFG_LIB_NAME_arm-apple-ios = lib$(1).a\n+CFG_LIB_GLOB_arm-apple-ios = lib$(1)-*.a\n+CFG_STATIC_LIB_NAME_arm-apple-ios=lib$(1).a\n+CFG_LIB_DSYM_GLOB_arm-apple-ios = lib$(1)-*.a.dSYM\n+CFG_CFLAGS_arm-apple-ios := -arch armv7 -mfpu=vfp3 $(CFG_IOS_FLAGS)\n+CFG_GCCISH_CFLAGS_arm-apple-ios := -Wall -Werror -g -fPIC $(CFG_IOS_FLAGS) -mfpu=vfp3 -arch armv7\n+CFG_GCCISH_CXXFLAGS_arm-apple-ios := -fno-rtti $(CFG_IOS_FLAGS) -I$(CFG_IOS_SDK)/usr/include/c++/4.2.1\n+CFG_GCCISH_LINK_FLAGS_arm-apple-ios := -lpthread -syslibroot $(CFG_IOS_SDK) -Wl,-no_compact_unwind\n+CFG_GCCISH_DEF_FLAG_arm-apple-ios := -Wl,-exported_symbols_list,\n+CFG_GCCISH_PRE_LIB_FLAGS_arm-apple-ios :=\n+CFG_GCCISH_POST_LIB_FLAGS_arm-apple-ios :=\n+CFG_DEF_SUFFIX_arm-apple-ios := .darwin.def\n+CFG_LLC_FLAGS_arm-apple-ios := -mattr=+vfp3,+v7,+thumb2,+neon -march=arm\n+CFG_INSTALL_NAME_arm-apple-ios = -Wl,-install_name,@rpath/$(1)\n+CFG_LIBUV_LINK_FLAGS_arm-apple-ios =\n+CFG_EXE_SUFFIX_arm-apple-ios :=\n+CFG_WINDOWSY_arm-apple-ios :=\n+CFG_UNIXY_arm-apple-ios := 1\n+CFG_PATH_MUNGE_arm-apple-ios := true\n+CFG_LDPATH_arm-apple-ios :=\n+CFG_RUN_arm-apple-ios = $(2)\n+CFG_RUN_TARG_arm-apple-ios = $(call CFG_RUN_arm-apple-ios,,$(2))\n+RUSTC_FLAGS_arm-apple-ios := -C relocation_model=pic\n+RUSTC_CROSS_FLAGS_arm-apple-ios :=-C relocation_model=pic\n+\n+# i386-apple-ios configuration\n+CFG_SDK_NAME_i386-apple-ios = iphonesimulator\n+CFG_SDK_ARCHS_i386-apple-ios = i386\n+ifneq ($(findstring darwin,$(CFG_OSTYPE)),)\n+CFG_IOSSIM_SDK = $(shell xcrun --show-sdk-path -sdk iphonesimulator 2>/dev/null)\n+CFG_IOSSIM_FLAGS = -target i386-apple-ios -isysroot $(CFG_IOSSIM_SDK) -mios-simulator-version-min=7.0\n+CC_i386-apple-ios = $(shell xcrun -find -sdk iphonesimulator clang)\n+CXX_i386-apple-ios = $(shell xcrun -find -sdk iphonesimulator clang++)\n+CPP_i386-apple-ios = $(shell xcrun -find -sdk iphonesimulator clang++)\n+AR_i386-apple-ios = $(shell xcrun -find -sdk iphonesimulator ar)\n+endif\n+CFG_LIB_NAME_i386-apple-ios = lib$(1).a\n+CFG_LIB_GLOB_i386-apple-ios = lib$(1)-*.dylib\n+CFG_STATIC_LIB_NAME_i386-apple-ios=lib$(1).a\n+CFG_LIB_DSYM_GLOB_i386-apple-ios = lib$(1)-*.dylib.dSYM\n+CFG_CFLAGS_i386-apple-ios = $(CFG_IOSSIM_FLAGS)\n+CFG_GCCISH_CFLAGS_i386-apple-ios = -Wall -Werror -g -fPIC -m32 $(CFG_IOSSIM_FLAGS)\n+CFG_GCCISH_CXXFLAGS_i386-apple-ios = -fno-rtti $(CFG_IOSSIM_FLAGS) -I$(CFG_IOSSIM_SDK)/usr/include/c++/4.2.1\n+CFG_GCCISH_LINK_FLAGS_i386-apple-ios = -lpthread -Wl,-no_compact_unwind -m32 -Wl,-syslibroot $(CFG_IOSSIM_SDK)\n+CFG_GCCISH_DEF_FLAG_i386-apple-ios = -Wl,-exported_symbols_list,\n+CFG_GCCISH_PRE_LIB_FLAGS_i386-apple-ios =\n+CFG_GCCISH_POST_LIB_FLAGS_i386-apple-ios =\n+CFG_DEF_SUFFIX_i386-apple-ios = .darwin.def\n+CFG_LLC_FLAGS_i386-apple-ios =\n+CFG_INSTALL_NAME_i386-apple-ios = -Wl,-install_name,@rpath/$(1)\n+CFG_LIBUV_LINK_FLAGS_i386-apple-ios =\n+CFG_EXE_SUFFIX_i386-apple-ios =\n+CFG_WINDOWSY_i386-apple-ios =\n+CFG_UNIXY_i386-apple-ios = 1\n+CFG_PATH_MUNGE_i386-apple-ios = true\n+CFG_LDPATH_i386-apple-ios =\n+CFG_RUN_i386-apple-ios = $(2)\n+CFG_RUN_TARG_i386-apple-ios = $(call CFG_RUN_i386-apple-ios,,$(2))\n+CFG_JEMALLOC_CFLAGS_i386-apple-ios = -target i386-apple-ios -Wl,-syslibroot $(CFG_IOSSIM_SDK) -Wl,-no_compact_unwind\n \n # x86_64-apple-darwin configuration\n CC_x86_64-apple-darwin=$(CC)"}, {"sha": "7fc82ef6269d80587a8b5dacf338597b44697399", "filename": "mk/rt.mk", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -166,6 +166,9 @@ ifeq ($$(CFG_WINDOWSY_$(1)), 1)\n   JEMALLOC_ARGS_$(1) := --enable-lazy-lock\n else ifeq ($(OSTYPE_$(1)), apple-darwin)\n   LIBUV_OSTYPE_$(1) := mac\n+else ifeq ($(OSTYPE_$(1)), apple-ios)\n+  LIBUV_OSTYPE_$(1) := ios\n+  JEMALLOC_ARGS_$(1) := --disable-tls\n else ifeq ($(OSTYPE_$(1)), unknown-freebsd)\n   LIBUV_OSTYPE_$(1) := freebsd\n else ifeq ($(OSTYPE_$(1)), linux-androideabi)\n@@ -181,6 +184,8 @@ LIBUV_DIR_$(1) := $$(RT_OUTPUT_DIR_$(1))/libuv\n LIBUV_LIB_$(1) := $$(RT_OUTPUT_DIR_$(1))/$$(LIBUV_NAME_$(1))\n \n LIBUV_MAKEFILE_$(1) := $$(CFG_BUILD_DIR)$$(RT_OUTPUT_DIR_$(1))/libuv/Makefile\n+LIBUV_BUILD_DIR_$(1) := $$(CFG_BUILD_DIR)$$(RT_OUTPUT_DIR_$(1))/libuv\n+LIBUV_XCODEPROJ_$(1) := $$(LIBUV_BUILD_DIR_$(1))/uv.xcodeproj\n \n LIBUV_STAMP_$(1) = $$(LIBUV_DIR_$(1))/libuv-auto-clean-stamp\n \n@@ -212,6 +217,30 @@ $$(LIBUV_LOCAL_$(1)): $$(LIBUV_DEPS) $$(MKFILE_DEPS)\n \t\tCXX=\"$$(CXX_$(1))\" \\\n \t\tAR=\"$$(AR_$(1))\" \\\n \t\tV=$$(VERBOSE)\n+else ifeq ($(OSTYPE_$(1)), apple-ios) # iOS\n+$$(LIBUV_XCODEPROJ_$(1)): $$(LIBUV_DEPS) $$(MKFILE_DEPS) $$(LIBUV_STAMP_$(1))\n+\tcp -rf $(S)src/libuv/ $$(LIBUV_BUILD_DIR_$(1))\n+\t(cd $$(LIBUV_BUILD_DIR_$(1)) && \\\n+\t $$(CFG_PYTHON) ./gyp_uv.py -f xcode \\\n+\t   -D ninja \\\n+\t   -R libuv)\n+\ttouch $$@\n+\n+LIBUV_XCODE_OUT_LIB_$(1) := $$(LIBUV_BUILD_DIR_$(1))/build/Release-$$(CFG_SDK_NAME_$(1))/libuv.a\n+\n+$$(LIBUV_LIB_$(1)): $$(LIBUV_XCODE_OUT_LIB_$(1)) $$(MKFILE_DEPS)\n+\t$$(Q)cp $$< $$@\n+$$(LIBUV_XCODE_OUT_LIB_$(1)): $$(LIBUV_DEPS) $$(LIBUV_XCODEPROJ_$(1)) \\\n+\t\t\t\t    $$(MKFILE_DEPS)\n+\t$$(Q)xcodebuild -project $$(LIBUV_BUILD_DIR_$(1))/uv.xcodeproj \\\n+\t\tCFLAGS=\"$$(LIBUV_CFLAGS_$(1)) $$(SNAP_DEFINES)\" \\\n+\t\tLDFLAGS=\"$$(CFG_GCCISH_LINK_FLAGS_$(1))\" \\\n+\t\t$$(LIBUV_ARGS_$(1)) \\\n+\t\tV=$$(VERBOSE) \\\n+\t\t-configuration Release \\\n+\t\t-sdk \"$$(CFG_SDK_NAME_$(1))\" \\\n+\t\tARCHS=\"$$(CFG_SDK_ARCHS_$(1))\"\n+\t$$(Q)touch $$@\n else\n LIBUV_LOCAL_$(1) := $$(LIBUV_DIR_$(1))/Release/libuv.a\n $$(LIBUV_LOCAL_$(1)): $$(LIBUV_DEPS) $$(LIBUV_MAKEFILE_$(1)) $$(MKFILE_DEPS)\n@@ -226,7 +255,6 @@ $$(LIBUV_LOCAL_$(1)): $$(LIBUV_DEPS) $$(LIBUV_MAKEFILE_$(1)) $$(MKFILE_DEPS)\n \t\tNO_LOAD=\"$$(LIBUV_NO_LOAD)\" \\\n \t\tV=$$(VERBOSE)\n \t$$(Q)touch $$@\n-\n endif\n \n ifeq ($(1),$$(CFG_BUILD))\n@@ -269,13 +297,13 @@ JEMALLOC_LOCAL_$(1) := $$(JEMALLOC_BUILD_DIR_$(1))/lib/$$(JEMALLOC_REAL_NAME_$(1\n $$(JEMALLOC_LOCAL_$(1)): $$(JEMALLOC_DEPS) $$(MKFILE_DEPS)\n \t@$$(call E, make: jemalloc)\n \tcd \"$$(JEMALLOC_BUILD_DIR_$(1))\"; \"$(S)src/jemalloc/configure\" \\\n-\t\t$$(JEMALLOC_ARGS_$(1)) --enable-cc-silence --with-jemalloc-prefix=je_ \\\n-\t\t--disable-experimental --build=$(CFG_BUILD) --host=$(1) \\\n+\t\t$$(JEMALLOC_ARGS_$(1)) --with-jemalloc-prefix=je_ \\\n+\t\t--build=$(CFG_BUILD) --host=$(1) \\\n \t\tCC=\"$$(CC_$(1))\" \\\n \t\tAR=\"$$(AR_$(1))\" \\\n \t\tRANLIB=\"$$(AR_$(1)) s\" \\\n \t\tCPPFLAGS=\"-I $(S)src/rt/\" \\\n-\t\tEXTRA_CFLAGS=\"$$(CFG_CFLAGS_$(1)) -g1\"\n+\t\tEXTRA_CFLAGS=\"$$(CFG_CFLAGS_$(1)) $$(CFG_JEMALLOC_CFLAGS_$(1)) -g1\"\n \t$$(Q)$$(MAKE) -C \"$$(JEMALLOC_BUILD_DIR_$(1))\" build_lib_static\n \n ifeq ($(1),$$(CFG_BUILD))\n@@ -335,15 +363,22 @@ BACKTRACE_NAME_$(1) := $$(call CFG_STATIC_LIB_NAME_$(1),backtrace)\n BACKTRACE_LIB_$(1) := $$(RT_OUTPUT_DIR_$(1))/$$(BACKTRACE_NAME_$(1))\n BACKTRACE_BUILD_DIR_$(1) := $$(RT_OUTPUT_DIR_$(1))/libbacktrace\n \n-ifeq ($$(findstring darwin,$$(OSTYPE_$(1))),darwin)\n-\n # We don't use this on platforms that aren't linux-based, so just make the file\n # available, the compilation of libstd won't actually build it.\n+ifeq ($$(findstring darwin,$$(OSTYPE_$(1))),darwin)\n+# See comment above\n $$(BACKTRACE_LIB_$(1)):\n \ttouch $$@\n \n else\n+ifeq ($$(findstring ios,$$(OSTYPE_$(1))),ios)\n+# See comment above\n+$$(BACKTRACE_LIB_$(1)):\n+\ttouch $$@\n+else\n+\n ifeq ($$(CFG_WINDOWSY_$(1)),1)\n+# See comment above\n $$(BACKTRACE_LIB_$(1)):\n \ttouch $$@\n else\n@@ -388,6 +423,7 @@ $$(BACKTRACE_LIB_$(1)): $$(BACKTRACE_BUILD_DIR_$(1))/Makefile $$(MKFILE_DEPS)\n \t$$(Q)cp $$(BACKTRACE_BUILD_DIR_$(1))/.libs/libbacktrace.a $$@\n \n endif # endif for windowsy\n+endif # endif for ios\n endif # endif for darwin\n \n endef"}, {"sha": "7b97b8468f0614072cf3299fa8c51e85f609316f", "filename": "src/compiler-rt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiler-rt?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -1 +1 @@\n-Subproject commit ed112ca1e4275e1c5707a898f2bf6164707ba378\n+Subproject commit 7b97b8468f0614072cf3299fa8c51e85f609316f"}, {"sha": "024c67ad651e1a3ca228936c4cfb13a37329baf2", "filename": "src/jemalloc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fjemalloc?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -1 +1 @@\n-Subproject commit 6a96910f2eaea6d2c705bb12379b23576b30d7d5\n+Subproject commit 024c67ad651e1a3ca228936c4cfb13a37329baf2"}, {"sha": "9ed0d50a03e8aae811dc9384a4d8ed9d906353a8", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -278,10 +278,13 @@ pub use consts::os::extra::{MAP_STACK};\n pub use consts::os::bsd44::{TCP_KEEPIDLE};\n \n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"ios\")]\n pub use consts::os::bsd44::{TCP_KEEPALIVE};\n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"ios\")]\n pub use consts::os::extra::{F_FULLFSYNC};\n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"ios\")]\n pub use types::os::arch::extra::{mach_timebase_info};\n \n \n@@ -1286,6 +1289,7 @@ pub mod types {\n     }\n \n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     pub mod os {\n         pub mod common {\n             pub mod posix01 {\n@@ -3106,6 +3110,7 @@ pub mod consts {\n     }\n \n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     pub mod os {\n         pub mod c95 {\n             use types::os::arch::c95::{c_int, c_uint};\n@@ -3769,6 +3774,7 @@ pub mod funcs {\n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"android\")]\n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     #[cfg(target_os = \"freebsd\")]\n     pub mod posix88 {\n         pub mod stat_ {\n@@ -3783,6 +3789,7 @@ pub mod funcs {\n                 #[cfg(target_os = \"linux\")]\n                 #[cfg(target_os = \"freebsd\")]\n                 #[cfg(target_os = \"android\")]\n+                #[cfg(target_os = \"ios\")]\n                 pub fn fstat(fildes: c_int, buf: *mut stat) -> c_int;\n \n                 #[cfg(target_os = \"macos\")]\n@@ -3795,6 +3802,7 @@ pub mod funcs {\n                 #[cfg(target_os = \"linux\")]\n                 #[cfg(target_os = \"freebsd\")]\n                 #[cfg(target_os = \"android\")]\n+                #[cfg(target_os = \"ios\")]\n                 pub fn stat(path: *c_char, buf: *mut stat) -> c_int;\n \n                 #[cfg(target_os = \"macos\")]\n@@ -3967,6 +3975,7 @@ pub mod funcs {\n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"android\")]\n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     #[cfg(target_os = \"freebsd\")]\n     pub mod posix01 {\n         pub mod stat_ {\n@@ -3977,6 +3986,7 @@ pub mod funcs {\n                 #[cfg(target_os = \"linux\")]\n                 #[cfg(target_os = \"freebsd\")]\n                 #[cfg(target_os = \"android\")]\n+                #[cfg(target_os = \"ios\")]\n                 pub fn lstat(path: *c_char, buf: *mut stat) -> c_int;\n \n                 #[cfg(target_os = \"macos\")]\n@@ -4076,6 +4086,7 @@ pub mod funcs {\n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"android\")]\n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     #[cfg(target_os = \"freebsd\")]\n     pub mod posix08 {\n         pub mod unistd {\n@@ -4156,6 +4167,7 @@ pub mod funcs {\n     }\n \n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     #[cfg(target_os = \"freebsd\")]\n     pub mod bsd44 {\n         use types::common::c95::{c_void};\n@@ -4209,6 +4221,7 @@ pub mod funcs {\n     }\n \n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     pub mod extra {\n         use types::os::arch::c95::{c_char, c_int};\n "}, {"sha": "70fd6310070da0e7cbaa19bd6ad4f3852a96b04f", "filename": "src/libnative/io/c_unix.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibnative%2Fio%2Fc_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibnative%2Fio%2Fc_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_unix.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -20,6 +20,7 @@ pub use self::signal::{SA_NODEFER, SA_NOCLDWAIT, SA_SIGINFO, SIGCHLD};\n use libc;\n \n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"ios\")]\n #[cfg(target_os = \"freebsd\")]\n pub static FIONBIO: libc::c_ulong = 0x8004667e;\n #[cfg(target_os = \"linux\", not(target_arch = \"mips\"))]\n@@ -29,6 +30,7 @@ pub static FIONBIO: libc::c_ulong = 0x5421;\n pub static FIONBIO: libc::c_ulong = 0x667e;\n \n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"ios\")]\n #[cfg(target_os = \"freebsd\")]\n pub static FIOCLEX: libc::c_ulong = 0x20006601;\n #[cfg(target_os = \"linux\", not(target_arch = \"mips\"))]\n@@ -38,6 +40,7 @@ pub static FIOCLEX: libc::c_ulong = 0x5451;\n pub static FIOCLEX: libc::c_ulong = 0x6601;\n \n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"ios\")]\n #[cfg(target_os = \"freebsd\")]\n pub static MSG_DONTWAIT: libc::c_int = 0x80;\n #[cfg(target_os = \"linux\")]\n@@ -75,6 +78,7 @@ extern {\n }\n \n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"ios\")]\n mod select {\n     pub static FD_SETSIZE: uint = 1024;\n \n@@ -187,6 +191,7 @@ mod signal {\n }\n \n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"ios\")]\n #[cfg(target_os = \"freebsd\")]\n mod signal {\n     use libc;\n@@ -201,6 +206,7 @@ mod signal {\n     pub static SIGCHLD: libc::c_int = 20;\n \n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     pub type sigset_t = u32;\n     #[cfg(target_os = \"freebsd\")]\n     pub struct sigset_t {\n@@ -219,6 +225,7 @@ mod signal {\n     }\n \n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     pub struct sigaction {\n         pub sa_handler: extern fn(libc::c_int),\n         sa_tramp: *mut libc::c_void,"}, {"sha": "f521934c0f9654056bba2036940f3e7758a82b44", "filename": "src/libnative/io/file_unix.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -133,14 +133,15 @@ impl rtio::RtioFileStream for FileDesc {\n         return super::mkerr_libc(os_datasync(self.fd()));\n \n         #[cfg(target_os = \"macos\")]\n+        #[cfg(target_os = \"ios\")]\n         fn os_datasync(fd: c_int) -> c_int {\n             unsafe { libc::fcntl(fd, libc::F_FULLFSYNC) }\n         }\n         #[cfg(target_os = \"linux\")]\n         fn os_datasync(fd: c_int) -> c_int {\n             retry(|| unsafe { libc::fdatasync(fd) })\n         }\n-        #[cfg(not(target_os = \"macos\"), not(target_os = \"linux\"))]\n+        #[cfg(not(target_os = \"macos\"), not(target_os = \"ios\"), not(target_os = \"linux\"))]\n         fn os_datasync(fd: c_int) -> c_int {\n             retry(|| unsafe { libc::fsync(fd) })\n         }"}, {"sha": "6dc2482ab0c7df9b1e1ff58d0cf3a7eea72778fd", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -50,6 +50,7 @@ pub mod file;\n pub mod file;\n \n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"ios\")]\n #[cfg(target_os = \"freebsd\")]\n #[cfg(target_os = \"android\")]\n #[cfg(target_os = \"linux\")]"}, {"sha": "2694c932b959c83e187c086dfa876189b5a37c19", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -320,6 +320,7 @@ impl TcpStream {\n     }\n \n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     fn set_tcp_keepalive(&mut self, seconds: uint) -> IoResult<()> {\n         setsockopt(self.fd(), libc::IPPROTO_TCP, libc::TCP_KEEPALIVE,\n                    seconds as libc::c_int)\n@@ -329,7 +330,7 @@ impl TcpStream {\n         setsockopt(self.fd(), libc::IPPROTO_TCP, libc::TCP_KEEPIDLE,\n                    seconds as libc::c_int)\n     }\n-    #[cfg(not(target_os = \"macos\"), not(target_os = \"freebsd\"))]\n+    #[cfg(not(target_os = \"macos\"), not(target_os = \"ios\"), not(target_os = \"freebsd\"))]\n     fn set_tcp_keepalive(&mut self, _seconds: uint) -> IoResult<()> {\n         Ok(())\n     }"}, {"sha": "f26d87ba1b52ff9f8853c7e54ef62b622768f5bc", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -769,6 +769,7 @@ fn translate_status(status: c_int) -> rtio::ProcessExit {\n     }\n \n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     #[cfg(target_os = \"freebsd\")]\n     mod imp {\n         pub fn WIFEXITED(status: i32) -> bool { (status & 0x7f) == 0 }"}, {"sha": "ca0a810890c277cbf29aee3ad61bea693f30e8bb", "filename": "src/libnative/io/timer_unix.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibnative%2Fio%2Ftimer_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibnative%2Fio%2Ftimer_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_unix.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -93,7 +93,20 @@ pub fn now() -> u64 {\n     }\n }\n \n-fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n+\n+// Note: although the last parameter isn't used there is no way now to\n+// convert it to unit type, because LLVM dies in SjLj preparation\n+// step (unfortunately iOS uses SjLJ exceptions)\n+//\n+// It's definitely a temporary workaround just to get it working.\n+// So far it looks like an LLVM issue and it was reported:\n+// http://llvm.org/bugs/show_bug.cgi?id=19855\n+// Actually this issue is pretty common while compiling for armv7 iOS\n+// and in most cases it is simply solved by using --opt-level=2 (or -O)\n+//\n+// For this specific case unfortunately turning optimizations wasn't\n+// enough.\n+fn helper(input: libc::c_int, messages: Receiver<Req>, _: int) {\n     let mut set: c::fd_set = unsafe { mem::zeroed() };\n \n     let mut fd = FileDesc::new(input, true);\n@@ -202,7 +215,9 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n \n impl Timer {\n     pub fn new() -> IoResult<Timer> {\n-        unsafe { HELPER.boot(|| {}, helper); }\n+        // See notes above regarding using int return value\n+        // instead of ()\n+        unsafe { HELPER.boot(|| {0}, helper); }\n \n         static mut ID: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n         let id = unsafe { ID.fetch_add(1, atomics::Relaxed) };"}, {"sha": "7a7d248a4cbf55db065ee1f1e0aa7ec331af5365", "filename": "src/librustc/back/arm.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fback%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fback%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farm.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -9,8 +9,6 @@\n // except according to those terms.\n \n use back::target_strs;\n-use driver::config::cfg_os_to_meta_os;\n-use metadata::loader::meta_section_name;\n use syntax::abi;\n \n pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs::t {\n@@ -22,9 +20,6 @@ pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs\n     return target_strs::t {\n         module_asm: \"\".to_string(),\n \n-        meta_sect_name:\n-            meta_section_name(cfg_os_to_meta_os(target_os)).to_string(),\n-\n         data_layout: match target_os {\n           abi::OsMacos => {\n             \"e-p:32:32:32\\\n@@ -34,6 +29,14 @@ pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs\n                 -a0:0:64-n32\".to_string()\n           }\n \n+          abi::OsiOS => {\n+            \"e-p:32:32:32\\\n+                -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n+                -f32:32:32-f64:64:64\\\n+                -v64:64:64-v128:64:128\\\n+                -a0:0:64-n32\".to_string()\n+          }\n+\n           abi::OsWin32 => {\n             \"e-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\"}, {"sha": "d644a0cc353304f9d407c2c38dc221a306dd0ae5", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 57, "deletions": 13, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -114,6 +114,13 @@ pub mod write {\n     // which are *far* more efficient. This is obviously undesirable in some\n     // cases, so if any sort of target feature is specified we don't append v7\n     // to the feature list.\n+    //\n+    // On iOS only armv7 and newer are supported. So it is useful to\n+    // get all hardware potential via VFP3 (hardware floating point)\n+    // and NEON (SIMD) instructions supported by LLVM.\n+    // Note that without those flags various linking errors might\n+    // arise as some of intrinsicts are converted into function calls\n+    // and nobody provides implementations those functions\n     fn target_feature<'a>(sess: &'a Session) -> &'a str {\n         match sess.targ_cfg.os {\n             abi::OsAndroid => {\n@@ -122,7 +129,10 @@ pub mod write {\n                 } else {\n                     sess.opts.cg.target_feature.as_slice()\n                 }\n-            }\n+            },\n+            abi::OsiOS if sess.targ_cfg.arch == abi::Arm => {\n+                \"+v7,+thumb2,+vfp3,+neon\"\n+            },\n             _ => sess.opts.cg.target_feature.as_slice()\n         }\n     }\n@@ -796,6 +806,10 @@ pub fn link_binary(sess: &Session,\n                    id: &CrateId) -> Vec<Path> {\n     let mut out_filenames = Vec::new();\n     for &crate_type in sess.crate_types.borrow().iter() {\n+        if invalid_output_for_target(sess, crate_type) {\n+            sess.bug(format!(\"invalid output type `{}` for target os `{}`\",\n+                             crate_type, sess.targ_cfg.os).as_slice());\n+        }\n         let out_file = link_binary_output(sess, trans, crate_type, outputs, id);\n         out_filenames.push(out_file);\n     }\n@@ -812,6 +826,32 @@ pub fn link_binary(sess: &Session,\n     out_filenames\n }\n \n+\n+/// Returns default crate type for target\n+///\n+/// Default crate type is used when crate type isn't provided neither\n+/// through cmd line arguments nor through crate attributes\n+///\n+/// It is CrateTypeExecutable for all platforms but iOS as there is no\n+/// way to run iOS binaries anyway without jailbreaking and\n+/// interaction with Rust code through static library is the only\n+/// option for now\n+pub fn default_output_for_target(sess: &Session) -> config::CrateType {\n+    match sess.targ_cfg.os {\n+        abi::OsiOS => config::CrateTypeStaticlib,\n+        _ => config::CrateTypeExecutable\n+    }\n+}\n+\n+/// Checks if target supports crate_type as output\n+pub fn invalid_output_for_target(sess: &Session,\n+                                 crate_type: config::CrateType) -> bool {\n+    match (sess.targ_cfg.os, crate_type) {\n+        (abi::OsiOS, config::CrateTypeDylib) => true,\n+        _ => false\n+    }\n+}\n+\n fn is_writeable(p: &Path) -> bool {\n     match p.stat() {\n         Err(..) => true,\n@@ -833,8 +873,11 @@ pub fn filename_for_input(sess: &Session, crate_type: config::CrateType,\n                 abi::OsLinux => (loader::LINUX_DLL_PREFIX, loader::LINUX_DLL_SUFFIX),\n                 abi::OsAndroid => (loader::ANDROID_DLL_PREFIX, loader::ANDROID_DLL_SUFFIX),\n                 abi::OsFreebsd => (loader::FREEBSD_DLL_PREFIX, loader::FREEBSD_DLL_SUFFIX),\n+                abi::OsiOS => unreachable!(),\n             };\n-            out_filename.with_filename(format!(\"{}{}{}\", prefix, libname,\n+            out_filename.with_filename(format!(\"{}{}{}\",\n+                                               prefix,\n+                                               libname,\n                                                suffix))\n         }\n         config::CrateTypeStaticlib => {\n@@ -991,7 +1034,7 @@ fn link_rlib<'a>(sess: &'a Session,\n             // symbol table of the archive. This currently dies on OSX (see\n             // #11162), and isn't necessary there anyway\n             match sess.targ_cfg.os {\n-                abi::OsMacos => {}\n+                abi::OsMacos | abi::OsiOS => {}\n                 _ => { a.update_symbols(); }\n             }\n         }\n@@ -1104,15 +1147,16 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n \n     // On OSX, debuggers need this utility to get run to do some munging of\n     // the symbols\n-    if sess.targ_cfg.os == abi::OsMacos && (sess.opts.debuginfo != NoDebugInfo) {\n-        match Command::new(\"dsymutil\").arg(out_filename).status() {\n-            Ok(..) => {}\n-            Err(e) => {\n-                sess.err(format!(\"failed to run dsymutil: {}\", e).as_slice());\n-                sess.abort_if_errors();\n+    if (sess.targ_cfg.os == abi::OsMacos || sess.targ_cfg.os == abi::OsiOS)\n+        && (sess.opts.debuginfo != NoDebugInfo) {\n+            match Command::new(\"dsymutil\").arg(out_filename).status() {\n+                Ok(..) => {}\n+                Err(e) => {\n+                    sess.err(format!(\"failed to run dsymutil: {}\", e).as_slice());\n+                    sess.abort_if_errors();\n+                }\n             }\n         }\n-    }\n }\n \n fn link_args(cmd: &mut Command,\n@@ -1169,7 +1213,7 @@ fn link_args(cmd: &mut Command,\n     // already done the best it can do, and we also don't want to eliminate the\n     // metadata. If we're building an executable, however, --gc-sections drops\n     // the size of hello world from 1.8MB to 597K, a 67% reduction.\n-    if !dylib && sess.targ_cfg.os != abi::OsMacos {\n+    if !dylib && sess.targ_cfg.os != abi::OsMacos && sess.targ_cfg.os != abi::OsiOS {\n         cmd.arg(\"-Wl,--gc-sections\");\n     }\n \n@@ -1185,7 +1229,7 @@ fn link_args(cmd: &mut Command,\n            sess.opts.optimize == config::Aggressive {\n             cmd.arg(\"-Wl,-O1\");\n         }\n-    } else if sess.targ_cfg.os == abi::OsMacos {\n+    } else if sess.targ_cfg.os == abi::OsMacos || sess.targ_cfg.os == abi::OsiOS {\n         // The dead_strip option to the linker specifies that functions and data\n         // unreachable by the entry point will be removed. This is quite useful\n         // with Rust's compilation model of compiling libraries at a time into\n@@ -1348,7 +1392,7 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n     // For those that support this, we ensure we pass the option if the library\n     // was flagged \"static\" (most defaults are dynamic) to ensure that if\n     // libfoo.a and libfoo.so both exist that the right one is chosen.\n-    let takes_hints = sess.targ_cfg.os != abi::OsMacos;\n+    let takes_hints = sess.targ_cfg.os != abi::OsMacos && sess.targ_cfg.os != abi::OsiOS;\n \n     for &(ref l, kind) in sess.cstore.get_used_libraries().borrow().iter() {\n         match kind {"}, {"sha": "8f3da03e825eaa9235d519dd2d5c22f21faedf9d", "filename": "src/librustc/back/mips.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fback%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fback%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fmips.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -9,17 +9,12 @@\n // except according to those terms.\n \n use back::target_strs;\n-use driver::config::cfg_os_to_meta_os;\n-use metadata::loader::meta_section_name;\n use syntax::abi;\n \n pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs::t {\n     return target_strs::t {\n         module_asm: \"\".to_string(),\n \n-        meta_sect_name:\n-            meta_section_name(cfg_os_to_meta_os(target_os)).to_string(),\n-\n         data_layout: match target_os {\n           abi::OsMacos => {\n             \"E-p:32:32:32\\\n@@ -29,6 +24,14 @@ pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs\n                 -a0:0:64-n32\".to_string()\n           }\n \n+          abi::OsiOS => {\n+            \"E-p:32:32:32\\\n+                -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n+                -f32:32:32-f64:64:64\\\n+                -v64:64:64-v128:64:128\\\n+                -a0:0:64-n32\".to_string()\n+          }\n+\n           abi::OsWin32 => {\n             \"E-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\"}, {"sha": "a458cf22a5bdc3c545b2be4ab43899333c92e3e3", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -122,7 +122,7 @@ pub fn get_rpath_relative_to_output(os: abi::Os,\n         abi::OsAndroid | abi::OsLinux | abi::OsFreebsd\n                           => \"$ORIGIN\",\n         abi::OsMacos => \"@loader_path\",\n-        abi::OsWin32 => unreachable!()\n+        abi::OsWin32 | abi::OsiOS => unreachable!()\n     };\n \n     let mut lib = fs::realpath(&os::make_absolute(lib)).unwrap();"}, {"sha": "7928f3d8db098167d7571824ea1b7d5666835a21", "filename": "src/librustc/back/target_strs.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fback%2Ftarget_strs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fback%2Ftarget_strs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Ftarget_strs.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -12,7 +12,6 @@\n \n pub struct t {\n     pub module_asm: String,\n-    pub meta_sect_name: String,\n     pub data_layout: String,\n     pub target_triple: String,\n     pub cc_args: Vec<String> ,"}, {"sha": "d2dac03267d5fc7e4b18cee9a779b7d64ac2afdf", "filename": "src/librustc/back/x86.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fx86.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -10,18 +10,13 @@\n \n \n use back::target_strs;\n-use driver::config::cfg_os_to_meta_os;\n-use metadata::loader::meta_section_name;\n use syntax::abi;\n \n pub fn get_target_strs(target_triple: String, target_os: abi::Os)\n                        -> target_strs::t {\n     return target_strs::t {\n         module_asm: \"\".to_string(),\n \n-        meta_sect_name:\n-            meta_section_name(cfg_os_to_meta_os(target_os)).to_string(),\n-\n         data_layout: match target_os {\n           abi::OsMacos => {\n             \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16\\\n@@ -31,6 +26,14 @@ pub fn get_target_strs(target_triple: String, target_os: abi::Os)\n                 -n8:16:32\".to_string()\n           }\n \n+          abi::OsiOS => {\n+            \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16\\\n+                -i32:32:32-i64:32:64\\\n+                -f32:32:32-f64:32:64-v64:64:64\\\n+                -v128:128:128-a0:0:64-f80:128:128\\\n+                -n8:16:32\".to_string()\n+          }\n+\n           abi::OsWin32 => {\n             \"e-p:32:32-f64:64:64-i64:64:64-f80:32:32-n8:16:32\".to_string()\n           }"}, {"sha": "c2eae18737bfad2e37feba7335c20639bfbb08cc", "filename": "src/librustc/back/x86_64.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fback%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fback%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fx86_64.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -10,24 +10,25 @@\n \n \n use back::target_strs;\n-use driver::config::cfg_os_to_meta_os;\n-use metadata::loader::meta_section_name;\n use syntax::abi;\n \n pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs::t {\n     return target_strs::t {\n         module_asm: \"\".to_string(),\n \n-        meta_sect_name:\n-            meta_section_name(cfg_os_to_meta_os(target_os)).to_string(),\n-\n         data_layout: match target_os {\n           abi::OsMacos => {\n             \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n                 f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n                 s0:64:64-f80:128:128-n8:16:32:64\".to_string()\n           }\n \n+          abi::OsiOS => {\n+            \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n+                f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n+                s0:64:64-f80:128:128-n8:16:32:64\".to_string()\n+          }\n+\n           abi::OsWin32 => {\n             // FIXME: Test this. Copied from linux (#2398)\n             \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\"}, {"sha": "db96330d656fe78b712cc65fafcd4b37eafb0d3f", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -19,7 +19,6 @@ use back;\n use back::link;\n use back::target_strs;\n use back::{arm, x86, x86_64, mips};\n-use metadata;\n use middle::lint;\n \n use syntax::abi;\n@@ -36,6 +35,7 @@ use getopts::{optopt, optmulti, optflag, optflagopt};\n use getopts;\n use lib::llvm::llvm;\n use std::cell::{RefCell};\n+use std::fmt;\n \n \n pub struct Config {\n@@ -357,25 +357,14 @@ pub fn default_lib_output() -> CrateType {\n     CrateTypeRlib\n }\n \n-pub fn cfg_os_to_meta_os(os: abi::Os) -> metadata::loader::Os {\n-    use metadata::loader;\n-\n-    match os {\n-        abi::OsWin32 => loader::OsWin32,\n-        abi::OsLinux => loader::OsLinux,\n-        abi::OsAndroid => loader::OsAndroid,\n-        abi::OsMacos => loader::OsMacos,\n-        abi::OsFreebsd => loader::OsFreebsd\n-    }\n-}\n-\n pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     let tos = match sess.targ_cfg.os {\n         abi::OsWin32 =>   InternedString::new(\"win32\"),\n         abi::OsMacos =>   InternedString::new(\"macos\"),\n         abi::OsLinux =>   InternedString::new(\"linux\"),\n         abi::OsAndroid => InternedString::new(\"android\"),\n         abi::OsFreebsd => InternedString::new(\"freebsd\"),\n+        abi::OsiOS =>     InternedString::new(\"ios\"),\n     };\n \n     // ARM is bi-endian, however using NDK seems to default\n@@ -441,7 +430,8 @@ static os_names : &'static [(&'static str, abi::Os)] = &'static [\n     (\"darwin\",  abi::OsMacos),\n     (\"android\", abi::OsAndroid),\n     (\"linux\",   abi::OsLinux),\n-    (\"freebsd\", abi::OsFreebsd)];\n+    (\"freebsd\", abi::OsFreebsd),\n+    (\"ios\",     abi::OsiOS)];\n \n pub fn get_arch(triple: &str) -> Option<abi::Architecture> {\n     for &(arch, abi) in architecture_abis.iter() {\n@@ -775,6 +765,16 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     }\n }\n \n+impl fmt::Show for CrateType {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            CrateTypeExecutable => \"bin\".fmt(f),\n+            CrateTypeDylib => \"dylib\".fmt(f),\n+            CrateTypeRlib => \"rlib\".fmt(f),\n+            CrateTypeStaticlib => \"staticlib\".fmt(f)\n+        }\n+    }\n+}\n \n #[cfg(test)]\n mod test {"}, {"sha": "e767a7c84f686fb8c489ce55a5c268aa573457bf", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -794,17 +794,26 @@ pub fn collect_crate_types(session: &Session,\n     // command line, then reuse the empty `base` Vec to hold the types that\n     // will be found in crate attributes.\n     let mut base = session.opts.crate_types.clone();\n-    if base.len() > 0 {\n-        return base\n-    } else {\n+    if base.len() == 0 {\n         base.extend(attr_types.move_iter());\n         if base.len() == 0 {\n-            base.push(config::CrateTypeExecutable);\n+            base.push(link::default_output_for_target(session));\n         }\n         base.as_mut_slice().sort();\n         base.dedup();\n-        return base;\n     }\n+\n+    base.move_iter().filter(|crate_type| {\n+        let res = !link::invalid_output_for_target(session, *crate_type);\n+\n+        if !res {\n+            session.warn(format!(\"dropping unsupported crate type `{}` \\\n+                                   for target os `{}`\",\n+                                 *crate_type, session.targ_cfg.os).as_slice());\n+        }\n+\n+        res\n+    }).collect()\n }\n \n pub struct OutputFilenames {"}, {"sha": "ada65394e1923721d8d685306a55c9f09c2593f7", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -349,8 +349,7 @@ pub fn early_error(msg: &str) -> ! {\n \n pub fn list_metadata(sess: &Session, path: &Path,\n                      out: &mut io::Writer) -> io::IoResult<()> {\n-    metadata::loader::list_file_metadata(\n-        config::cfg_os_to_meta_os(sess.targ_cfg.os), path, out)\n+    metadata::loader::list_file_metadata(sess.targ_cfg.os, path, out)\n }\n \n /// Run a procedure which will detect failures in the compiler and print nicer"}, {"sha": "f98831714f27aa2562f9b207ae99ba4658bf7b61", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -250,4 +250,3 @@ pub fn expect<T:Clone>(sess: &Session, opt: Option<T>, msg: || -> String)\n               -> T {\n     diagnostic::expect(sess.diagnostic(), opt, msg)\n }\n-"}, {"sha": "efe28614b8f4da26e586f817de751145d48f4ce2", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -215,7 +215,8 @@ fn visit_item(e: &Env, i: &ast::Item) {\n                             Some(k) => {\n                                 if k.equiv(&(\"static\")) {\n                                     cstore::NativeStatic\n-                                } else if e.sess.targ_cfg.os == abi::OsMacos &&\n+                                } else if (e.sess.targ_cfg.os == abi::OsMacos ||\n+                                           e.sess.targ_cfg.os == abi::OsiOS) &&\n                                           k.equiv(&(\"framework\")) {\n                                     cstore::NativeFramework\n                                 } else if k.equiv(&(\"framework\")) {\n@@ -345,7 +346,7 @@ fn resolve_crate<'a>(e: &mut Env,\n                 id_hash: id_hash.as_slice(),\n                 hash: hash.map(|a| &*a),\n                 filesearch: e.sess.target_filesearch(),\n-                os: config::cfg_os_to_meta_os(e.sess.targ_cfg.os),\n+                os: e.sess.targ_cfg.os,\n                 triple: e.sess.targ_cfg.target_strs.target_triple.as_slice(),\n                 root: root,\n                 rejected_via_hash: vec!(),\n@@ -409,7 +410,7 @@ impl<'a> PluginMetadataReader<'a> {\n             hash: None,\n             filesearch: self.env.sess.host_filesearch(),\n             triple: driver::host_triple(),\n-            os: config::cfg_os_to_meta_os(os),\n+            os: os,\n             root: &None,\n             rejected_via_hash: vec!(),\n             rejected_via_triple: vec!(),\n@@ -420,7 +421,7 @@ impl<'a> PluginMetadataReader<'a> {\n                 // try loading from target crates (only valid if there are\n                 // no syntax extensions)\n                 load_ctxt.triple = target_triple;\n-                load_ctxt.os = config::cfg_os_to_meta_os(self.env.sess.targ_cfg.os);\n+                load_ctxt.os = self.env.sess.targ_cfg.os;\n                 load_ctxt.filesearch = self.env.sess.target_filesearch();\n                 let lib = load_ctxt.load_library_crate();\n                 if decoder::get_plugin_registrar_fn(lib.metadata.as_slice()).is_some() {"}, {"sha": "f379302e929db957dcc7afc25f812e812fd9b75c", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -18,6 +18,7 @@ use metadata::cstore::{MetadataBlob, MetadataVec, MetadataArchive};\n use metadata::decoder;\n use metadata::encoder;\n use metadata::filesearch::{FileSearch, FileMatches, FileDoesntMatch};\n+use syntax::abi;\n use syntax::codemap::Span;\n use syntax::diagnostic::SpanHandler;\n use syntax::crateid::CrateId;\n@@ -51,14 +52,6 @@ pub static FREEBSD_DLL_SUFFIX: &'static str = \".so\";\n pub static ANDROID_DLL_PREFIX: &'static str = \"lib\";\n pub static ANDROID_DLL_SUFFIX: &'static str = \".so\";\n \n-pub enum Os {\n-    OsMacos,\n-    OsWin32,\n-    OsLinux,\n-    OsAndroid,\n-    OsFreebsd\n-}\n-\n pub struct CrateMismatch {\n     path: Path,\n     got: String,\n@@ -72,7 +65,7 @@ pub struct Context<'a> {\n     pub id_hash: &'a str,\n     pub hash: Option<&'a Svh>,\n     pub triple: &'a str,\n-    pub os: Os,\n+    pub os: abi::Os,\n     pub filesearch: FileSearch<'a>,\n     pub root: &'a Option<CratePaths>,\n     pub rejected_via_hash: Vec<CrateMismatch>,\n@@ -183,10 +176,12 @@ impl<'a> Context<'a> {\n     }\n \n     fn find_library_crate(&mut self) -> Option<Library> {\n-        let (dyprefix, dysuffix) = self.dylibname();\n+        let dypair = self.dylibname();\n \n         // want: crate_name.dir_part() + prefix + crate_name.file_part + \"-\"\n-        let dylib_prefix = format!(\"{}{}-\", dyprefix, self.crate_id.name);\n+        let dylib_prefix = dypair.map(|(prefix, _)| {\n+            format!(\"{}{}-\", prefix, self.crate_id.name)\n+        });\n         let rlib_prefix = format!(\"lib{}-\", self.crate_id.name);\n \n         let mut candidates = HashMap::new();\n@@ -227,12 +222,14 @@ impl<'a> Context<'a> {\n                         FileDoesntMatch\n                     }\n                 }\n-            } else if file.starts_with(dylib_prefix.as_slice()) &&\n-                    file.ends_with(dysuffix){\n+            } else if dypair.map_or(false, |(_, suffix)| {\n+                file.starts_with(dylib_prefix.get_ref().as_slice()) &&\n+                file.ends_with(suffix)\n+            }) {\n+                let (_, suffix) = dypair.unwrap();\n+                let dylib_prefix = dylib_prefix.get_ref().as_slice();\n                 info!(\"dylib candidate: {}\", path.display());\n-                match self.try_match(file,\n-                                     dylib_prefix.as_slice(),\n-                                     dysuffix) {\n+                match self.try_match(file, dylib_prefix, suffix) {\n                     Some(hash) => {\n                         info!(\"dylib accepted, hash: {}\", hash);\n                         let slot = candidates.find_or_insert_with(hash, |_| {\n@@ -457,13 +454,14 @@ impl<'a> Context<'a> {\n \n     // Returns the corresponding (prefix, suffix) that files need to have for\n     // dynamic libraries\n-    fn dylibname(&self) -> (&'static str, &'static str) {\n+    fn dylibname(&self) -> Option<(&'static str, &'static str)> {\n         match self.os {\n-            OsWin32 => (WIN32_DLL_PREFIX, WIN32_DLL_SUFFIX),\n-            OsMacos => (MACOS_DLL_PREFIX, MACOS_DLL_SUFFIX),\n-            OsLinux => (LINUX_DLL_PREFIX, LINUX_DLL_SUFFIX),\n-            OsAndroid => (ANDROID_DLL_PREFIX, ANDROID_DLL_SUFFIX),\n-            OsFreebsd => (FREEBSD_DLL_PREFIX, FREEBSD_DLL_SUFFIX),\n+            abi::OsWin32 => Some((WIN32_DLL_PREFIX, WIN32_DLL_SUFFIX)),\n+            abi::OsMacos => Some((MACOS_DLL_PREFIX, MACOS_DLL_SUFFIX)),\n+            abi::OsLinux => Some((LINUX_DLL_PREFIX, LINUX_DLL_SUFFIX)),\n+            abi::OsAndroid => Some((ANDROID_DLL_PREFIX, ANDROID_DLL_SUFFIX)),\n+            abi::OsFreebsd => Some((FREEBSD_DLL_PREFIX, FREEBSD_DLL_SUFFIX)),\n+            abi::OsiOS => None,\n         }\n     }\n \n@@ -505,15 +503,15 @@ impl ArchiveMetadata {\n }\n \n // Just a small wrapper to time how long reading metadata takes.\n-fn get_metadata_section(os: Os, filename: &Path) -> Result<MetadataBlob, String> {\n+fn get_metadata_section(os: abi::Os, filename: &Path) -> Result<MetadataBlob, String> {\n     let start = time::precise_time_ns();\n     let ret = get_metadata_section_imp(os, filename);\n     info!(\"reading {} => {}ms\", filename.filename_display(),\n            (time::precise_time_ns() - start) / 1000000);\n     return ret;\n }\n \n-fn get_metadata_section_imp(os: Os, filename: &Path) -> Result<MetadataBlob, String> {\n+fn get_metadata_section_imp(os: abi::Os, filename: &Path) -> Result<MetadataBlob, String> {\n     if !filename.exists() {\n         return Err(format!(\"no such file: '{}'\", filename.display()));\n     }\n@@ -599,28 +597,30 @@ fn get_metadata_section_imp(os: Os, filename: &Path) -> Result<MetadataBlob, Str\n     }\n }\n \n-pub fn meta_section_name(os: Os) -> &'static str {\n+pub fn meta_section_name(os: abi::Os) -> Option<&'static str> {\n     match os {\n-        OsMacos => \"__DATA,__note.rustc\",\n-        OsWin32 => \".note.rustc\",\n-        OsLinux => \".note.rustc\",\n-        OsAndroid => \".note.rustc\",\n-        OsFreebsd => \".note.rustc\"\n+        abi::OsMacos => Some(\"__DATA,__note.rustc\"),\n+        abi::OsiOS => Some(\"__DATA,__note.rustc\"),\n+        abi::OsWin32 => Some(\".note.rustc\"),\n+        abi::OsLinux => Some(\".note.rustc\"),\n+        abi::OsAndroid => Some(\".note.rustc\"),\n+        abi::OsFreebsd => Some(\".note.rustc\")\n     }\n }\n \n-pub fn read_meta_section_name(os: Os) -> &'static str {\n+pub fn read_meta_section_name(os: abi::Os) -> &'static str {\n     match os {\n-        OsMacos => \"__note.rustc\",\n-        OsWin32 => \".note.rustc\",\n-        OsLinux => \".note.rustc\",\n-        OsAndroid => \".note.rustc\",\n-        OsFreebsd => \".note.rustc\"\n+        abi::OsMacos => \"__note.rustc\",\n+        abi::OsiOS => unreachable!(),\n+        abi::OsWin32 => \".note.rustc\",\n+        abi::OsLinux => \".note.rustc\",\n+        abi::OsAndroid => \".note.rustc\",\n+        abi::OsFreebsd => \".note.rustc\"\n     }\n }\n \n // A diagnostic function for dumping crate metadata to an output stream\n-pub fn list_file_metadata(os: Os, path: &Path,\n+pub fn list_file_metadata(os: abi::Os, path: &Path,\n                           out: &mut io::Writer) -> io::IoResult<()> {\n     match get_metadata_section(os, path) {\n         Ok(bytes) => decoder::list_crate_metadata(bytes.as_slice(), out),"}, {"sha": "4657c8cd13654b90a224e4f994f2933c26441859", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -35,7 +35,7 @@ use driver::driver::{CrateAnalysis, CrateTranslation};\n use lib::llvm::{ModuleRef, ValueRef, BasicBlockRef};\n use lib::llvm::{llvm, Vector};\n use lib;\n-use metadata::{csearch, encoder};\n+use metadata::{csearch, encoder, loader};\n use middle::lint;\n use middle::astencode;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n@@ -173,12 +173,12 @@ impl<'a> Drop for StatRecorder<'a> {\n }\n \n // only use this for foreign function ABIs and glue, use `decl_rust_fn` for Rust functions\n-fn decl_fn(llmod: ModuleRef, name: &str, cc: lib::llvm::CallConv,\n+fn decl_fn(ccx: &CrateContext, name: &str, cc: lib::llvm::CallConv,\n            ty: Type, output: ty::t) -> ValueRef {\n \n     let llfn: ValueRef = name.with_c_str(|buf| {\n         unsafe {\n-            llvm::LLVMGetOrInsertFunction(llmod, buf, ty.to_ref())\n+            llvm::LLVMGetOrInsertFunction(ccx.llmod, buf, ty.to_ref())\n         }\n     });\n \n@@ -197,17 +197,20 @@ fn decl_fn(llmod: ModuleRef, name: &str, cc: lib::llvm::CallConv,\n     lib::llvm::SetFunctionCallConv(llfn, cc);\n     // Function addresses in Rust are never significant, allowing functions to be merged.\n     lib::llvm::SetUnnamedAddr(llfn, true);\n-    set_split_stack(llfn);\n+\n+    if ccx.is_split_stack_supported() {\n+        set_split_stack(llfn);\n+    }\n \n     llfn\n }\n \n // only use this for foreign function ABIs and glue, use `decl_rust_fn` for Rust functions\n-pub fn decl_cdecl_fn(llmod: ModuleRef,\n+pub fn decl_cdecl_fn(ccx: &CrateContext,\n                      name: &str,\n                      ty: Type,\n                      output: ty::t) -> ValueRef {\n-    decl_fn(llmod, name, lib::llvm::CCallConv, ty, output)\n+    decl_fn(ccx, name, lib::llvm::CCallConv, ty, output)\n }\n \n // only use this for foreign function ABIs and glue, use `get_extern_rust_fn` for Rust functions\n@@ -222,7 +225,7 @@ pub fn get_extern_fn(ccx: &CrateContext,\n         Some(n) => return *n,\n         None => {}\n     }\n-    let f = decl_fn(ccx.llmod, name, cc, ty, output);\n+    let f = decl_fn(ccx, name, cc, ty, output);\n     externs.insert(name.to_string(), f);\n     f\n }\n@@ -251,7 +254,7 @@ pub fn decl_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> ValueRef {\n     };\n \n     let llfty = type_of_rust_fn(ccx, has_env, inputs.as_slice(), output);\n-    let llfn = decl_fn(ccx.llmod, name, lib::llvm::CCallConv, llfty, output);\n+    let llfn = decl_fn(ccx, name, lib::llvm::CCallConv, llfty, output);\n     let attrs = get_fn_llvm_attributes(ccx, fn_ty);\n     for &(idx, attr) in attrs.iter() {\n         unsafe {\n@@ -1878,7 +1881,7 @@ pub fn register_fn_llvmty(ccx: &CrateContext,\n                           llfty: Type) -> ValueRef {\n     debug!(\"register_fn_llvmty id={} sym={}\", node_id, sym);\n \n-    let llfn = decl_fn(ccx.llmod, sym.as_slice(), cc, llfty, ty::mk_nil());\n+    let llfn = decl_fn(ccx, sym.as_slice(), cc, llfty, ty::mk_nil());\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n     llfn\n }\n@@ -1910,7 +1913,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n         let llfty = Type::func([ccx.int_type, Type::i8p(ccx).ptr_to()],\n                                &ccx.int_type);\n \n-        let llfn = decl_cdecl_fn(ccx.llmod, \"main\", llfty, ty::mk_nil());\n+        let llfn = decl_cdecl_fn(ccx, \"main\", llfty, ty::mk_nil());\n         let llbb = \"top\".with_c_str(|buf| {\n             unsafe {\n                 llvm::LLVMAppendBasicBlockInContext(ccx.llcx, llfn, buf)\n@@ -2279,12 +2282,8 @@ pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> Vec<u8> {\n     });\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n-        cx.sess()\n-          .targ_cfg\n-          .target_strs\n-          .meta_sect_name\n-          .as_slice()\n-          .with_c_str(|buf| {\n+        let name = loader::meta_section_name(cx.sess().targ_cfg.os);\n+        name.unwrap_or(\"rust_metadata\").with_c_str(|buf| {\n             llvm::LLVMSetSection(llglobal, buf)\n         });\n     }"}, {"sha": "d10f6b72820d29c68b77c9e21e29edb009062728", "filename": "src/librustc/middle/trans/cabi_x86.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-use syntax::abi::{OsWin32, OsMacos};\n+use syntax::abi::{OsWin32, OsMacos, OsiOS};\n use lib::llvm::*;\n use super::cabi::*;\n use super::common::*;\n@@ -36,7 +36,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n \n         enum Strategy { RetValue(Type), RetPointer }\n         let strategy = match ccx.sess().targ_cfg.os {\n-            OsWin32 | OsMacos => {\n+            OsWin32 | OsMacos | OsiOS => {\n                 match llsize_of_alloc(ccx, rty) {\n                     1 => RetValue(Type::i8(ccx)),\n                     2 => RetValue(Type::i16(ccx)),"}, {"sha": "24f30bae75a91fb762330adda0cea01b9bb50bc4", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -680,7 +680,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n                     Some(llpersonality) => llpersonality,\n                     None => {\n                         let fty = Type::variadic_func(&[], &Type::i32(self.ccx));\n-                        let f = base::decl_cdecl_fn(self.ccx.llmod,\n+                        let f = base::decl_cdecl_fn(self.ccx,\n                                                     \"rust_eh_personality\",\n                                                     fty,\n                                                     ty::mk_i32());"}, {"sha": "68c6f1752bdfea033d22f74012feacba9458cc1a", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use driver::config::NoDebugInfo;\n use driver::session::Session;\n use lib::llvm::{ContextRef, ModuleRef, ValueRef};\n@@ -32,6 +31,7 @@ use std::c_str::ToCStr;\n use std::ptr;\n use std::rc::Rc;\n use std::collections::{HashMap, HashSet};\n+use syntax::abi;\n use syntax::ast;\n use syntax::parse::token::InternedString;\n \n@@ -273,20 +273,32 @@ impl CrateContext {\n             None => fail!()\n         }\n     }\n+\n+    // Although there is an experimental implementation of LLVM which\n+    // supports SS on armv7 it wasn't approved by Apple, see:\n+    // http://lists.cs.uiuc.edu/pipermail/llvm-commits/Week-of-Mon-20140505/216350.html\n+    // It looks like it might be never accepted to upstream LLVM.\n+    //\n+    // So far the decision was to disable them in default builds\n+    // but it could be enabled (with patched LLVM)\n+    pub fn is_split_stack_supported(&self) -> bool {\n+        let ref cfg = self.sess().targ_cfg;\n+        cfg.os != abi::OsiOS || cfg.arch != abi::Arm\n+    }\n }\n \n fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef> {\n     macro_rules! ifn (\n         ($name:expr fn() -> $ret:expr) => (\n             if *key == $name {\n-                let f = base::decl_cdecl_fn(ccx.llmod, $name, Type::func([], &$ret), ty::mk_nil());\n+                let f = base::decl_cdecl_fn(ccx, $name, Type::func([], &$ret), ty::mk_nil());\n                 ccx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr fn($($arg:expr),*) -> $ret:expr) => (\n             if *key == $name {\n-                let f = base::decl_cdecl_fn(ccx.llmod, $name,\n+                let f = base::decl_cdecl_fn(ccx, $name,\n                                   Type::func([$($arg),*], &$ret), ty::mk_nil());\n                 ccx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n@@ -418,7 +430,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n                 // The `if key == $name` is already in ifn!\n                 ifn!($name fn($($arg),*) -> $ret);\n             } else if *key == $name {\n-                let f = base::decl_cdecl_fn(ccx.llmod, stringify!($cname),\n+                let f = base::decl_cdecl_fn(ccx, stringify!($cname),\n                                       Type::func([$($arg),*], &$ret),\n                                       ty::mk_nil());\n                 ccx.intrinsics.borrow_mut().insert($name, f.clone());"}, {"sha": "d4efe9b8a09b42c3ee13757bd6804e7a6c45a925", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -660,7 +660,8 @@ pub fn finalize(cx: &CrateContext) {\n         // instruct LLVM to emit an older version of dwarf, however,\n         // for OS X to understand. For more info see #11352\n         // This can be overridden using --llvm-opts -dwarf-version,N.\n-        if cx.sess().targ_cfg.os == abi::OsMacos {\n+        if cx.sess().targ_cfg.os == abi::OsMacos ||\n+            cx.sess().targ_cfg.os == abi::OsiOS {\n             \"Dwarf Version\".with_c_str(\n                 |s| llvm::LLVMRustAddModuleFlag(cx.llmod, s, 2));\n         } else {"}, {"sha": "ef9bf4eebe24b0d11239d0a0d35b4be218dad747", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -462,7 +462,7 @@ fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n         t,\n         format!(\"glue_{}\", name).as_slice());\n     debug!(\"{} is for type {}\", fn_nm, ppaux::ty_to_str(ccx.tcx(), t));\n-    let llfn = decl_cdecl_fn(ccx.llmod, fn_nm.as_slice(), llfnty, ty::mk_nil());\n+    let llfn = decl_cdecl_fn(ccx, fn_nm.as_slice(), llfnty, ty::mk_nil());\n     note_unique_llvm_symbol(ccx, fn_nm);\n     return llfn;\n }"}, {"sha": "800e7f065f1e604ef7422dd273629c89e93ae321", "filename": "src/librustdoc/flock.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustdoc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustdoc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fflock.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -64,6 +64,7 @@ mod imp {\n     }\n \n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     mod os {\n         use libc;\n "}, {"sha": "d6d4b18051bf3e54ffaad90c02f75cf67810ab99", "filename": "src/librustrt/args.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustrt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustrt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fargs.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -145,6 +145,7 @@ mod imp {\n }\n \n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"ios\")]\n #[cfg(target_os = \"win32\")]\n mod imp {\n     use core::prelude::*;"}, {"sha": "c461dccceff025b7c2a090570cf162ec6f960344", "filename": "src/librustrt/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -156,7 +156,7 @@ pub unsafe fn cleanup() {\n pub mod shouldnt_be_public {\n     #[cfg(not(test))]\n     pub use super::local_ptr::native::maybe_tls_key;\n-    #[cfg(not(windows), not(target_os = \"android\"))]\n+    #[cfg(not(windows), not(target_os = \"android\"), not(target_os = \"ios\"))]\n     pub use super::local_ptr::compiled::RT_TLS_PTR;\n }\n "}, {"sha": "2d58c1bee15bd9aa0c480342945a77dff7a56653", "filename": "src/librustrt/libunwind.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustrt%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustrt%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flibunwind.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -17,6 +17,7 @@\n use libc;\n \n #[cfg(not(target_arch = \"arm\"))]\n+#[cfg(target_os = \"ios\")]\n #[repr(C)]\n pub enum _Unwind_Action {\n     _UA_SEARCH_PHASE = 1,\n@@ -61,9 +62,12 @@ pub static unwinder_private_data_size: int = 5;\n #[cfg(target_arch = \"x86_64\")]\n pub static unwinder_private_data_size: int = 2;\n \n-#[cfg(target_arch = \"arm\")]\n+#[cfg(target_arch = \"arm\", not(target_os = \"ios\"))]\n pub static unwinder_private_data_size: int = 20;\n \n+#[cfg(target_arch = \"arm\", target_os = \"ios\")]\n+pub static unwinder_private_data_size: int = 5;\n+\n #[cfg(target_arch = \"mips\")]\n pub static unwinder_private_data_size: int = 2;\n \n@@ -89,8 +93,27 @@ extern {}\n #[link(name = \"gcc\")]\n extern {}\n \n+\n extern \"C\" {\n+    // iOS on armv7 uses SjLj exceptions and requires to link\n+    // agains corresponding routine (..._SjLj_...)\n+    #[cfg(not(target_os = \"ios\", target_arch = \"arm\"))]\n     pub fn _Unwind_RaiseException(exception: *_Unwind_Exception)\n-                -> _Unwind_Reason_Code;\n+                                  -> _Unwind_Reason_Code;\n+\n+    #[cfg(target_os = \"ios\", target_arch = \"arm\")]\n+    fn _Unwind_SjLj_RaiseException(e: *_Unwind_Exception)\n+                                   -> _Unwind_Reason_Code;\n+\n     pub fn _Unwind_DeleteException(exception: *_Unwind_Exception);\n }\n+\n+// ... and now we just providing access to SjLj counterspart\n+// through a standard name to hide those details from others\n+// (see also comment above regarding _Unwind_RaiseException)\n+#[cfg(target_os = \"ios\", target_arch = \"arm\")]\n+#[inline(always)]\n+pub unsafe fn _Unwind_RaiseException(exc: *_Unwind_Exception)\n+                                     -> _Unwind_Reason_Code {\n+    _Unwind_SjLj_RaiseException(exc)\n+}"}, {"sha": "b6858be32b7ceb70fc0ee9f4da000dc9d8e18f09", "filename": "src/librustrt/local_ptr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustrt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustrt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_ptr.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -24,10 +24,11 @@ use alloc::owned::Box;\n \n #[cfg(windows)]               // mingw-w32 doesn't like thread_local things\n #[cfg(target_os = \"android\")] // see #10686\n+#[cfg(target_os = \"ios\")]\n pub use self::native::{init, cleanup, put, take, try_take, unsafe_take, exists,\n                        unsafe_borrow, try_unsafe_borrow};\n \n-#[cfg(not(windows), not(target_os = \"android\"))]\n+#[cfg(not(windows), not(target_os = \"android\"), not(target_os = \"ios\"))]\n pub use self::compiled::{init, cleanup, put, take, try_take, unsafe_take, exists,\n                          unsafe_borrow, try_unsafe_borrow};\n \n@@ -81,7 +82,7 @@ pub unsafe fn borrow<T>() -> Borrowed<T> {\n /// implemented using LLVM's thread_local attribute which isn't necessarily\n /// working on all platforms. This implementation is faster, however, so we use\n /// it wherever possible.\n-#[cfg(not(windows), not(target_os = \"android\"))]\n+#[cfg(not(windows), not(target_os = \"android\"), not(target_os = \"ios\"))]\n pub mod compiled {\n     use core::prelude::*;\n "}, {"sha": "ee696f2cf7c086d736c148fa0c48ac3f69fee346", "filename": "src/librustrt/mutex.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustrt%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustrt%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fmutex.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -361,6 +361,7 @@ mod imp {\n     }\n \n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     mod os {\n         use libc;\n \n@@ -372,6 +373,10 @@ mod imp {\n         static __PTHREAD_MUTEX_SIZE__: uint = 40;\n         #[cfg(target_arch = \"x86\")]\n         static __PTHREAD_COND_SIZE__: uint = 24;\n+        #[cfg(target_arch = \"arm\")]\n+        static __PTHREAD_MUTEX_SIZE__: uint = 40;\n+        #[cfg(target_arch = \"arm\")]\n+        static __PTHREAD_COND_SIZE__: uint = 24;\n \n         static _PTHREAD_MUTEX_SIG_init: libc::c_long = 0x32AAABA7;\n         static _PTHREAD_COND_SIG_init: libc::c_long = 0x3CB0B1BB;"}, {"sha": "e6fa845bedc895aee2710029db29254dda429a88", "filename": "src/librustrt/stack.rs", "status": "modified", "additions": 45, "deletions": 6, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustrt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustrt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fstack.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -24,6 +24,28 @@\n //! detection is not guaranteed to continue in the future. Usage of this module\n //! is discouraged unless absolutely necessary.\n \n+// iOS related notes\n+//\n+// It is possible to implement it using idea from\n+// http://www.opensource.apple.com/source/Libc/Libc-825.40.1/pthreads/pthread_machdep.h\n+//\n+// In short: _pthread_{get,set}_specific_direct allows extremely fast\n+// access, exactly what is required for segmented stack\n+// There is a pool of reserved slots for Apple internal use (0..119)\n+// First dynamic allocated pthread key starts with 257 (on iOS7)\n+// So using slot 149 should be pretty safe ASSUMING space is reserved\n+// for every key < first dynamic key\n+//\n+// There is also an opportunity to steal keys reserved for Garbage Collection\n+// ranges 80..89 and 110..119, especially considering the fact Garbage Collection\n+// never supposed to work on iOS. But as everybody knows it - there is a chance\n+// that those slots will be re-used, like it happened with key 95 (moved from\n+// JavaScriptCore to CoreText)\n+//\n+// Unfortunately Apple rejected patch to LLVM which generated\n+// corresponding prolog, decision was taken to disable segmented\n+// stack support on iOS.\n+\n pub static RED_ZONE: uint = 20 * 1024;\n \n /// This function is invoked from rust's current __morestack function. Segmented\n@@ -151,7 +173,8 @@ pub unsafe fn record_sp_limit(limit: uint) {\n     return target_record_sp_limit(limit);\n \n     // x86-64\n-    #[cfg(target_arch = \"x86_64\", target_os = \"macos\")] #[inline(always)]\n+    #[cfg(target_arch = \"x86_64\", target_os = \"macos\")]\n+    #[cfg(target_arch = \"x86_64\", target_os = \"ios\")] #[inline(always)]\n     unsafe fn target_record_sp_limit(limit: uint) {\n         asm!(\"movq $$0x60+90*8, %rsi\n               movq $0, %gs:(%rsi)\" :: \"r\"(limit) : \"rsi\" : \"volatile\")\n@@ -173,7 +196,8 @@ pub unsafe fn record_sp_limit(limit: uint) {\n     }\n \n     // x86\n-    #[cfg(target_arch = \"x86\", target_os = \"macos\")] #[inline(always)]\n+    #[cfg(target_arch = \"x86\", target_os = \"macos\")]\n+    #[cfg(target_arch = \"x86\", target_os = \"ios\")] #[inline(always)]\n     unsafe fn target_record_sp_limit(limit: uint) {\n         asm!(\"movl $$0x48+90*4, %eax\n               movl $0, %gs:(%eax)\" :: \"r\"(limit) : \"eax\" : \"volatile\")\n@@ -193,14 +217,19 @@ pub unsafe fn record_sp_limit(limit: uint) {\n     // mips, arm - Some brave soul can port these to inline asm, but it's over\n     //             my head personally\n     #[cfg(target_arch = \"mips\")]\n-    #[cfg(target_arch = \"arm\")] #[inline(always)]\n+    #[cfg(target_arch = \"arm\", not(target_os = \"ios\"))] #[inline(always)]\n     unsafe fn target_record_sp_limit(limit: uint) {\n         use libc::c_void;\n         return record_sp_limit(limit as *c_void);\n         extern {\n             fn record_sp_limit(limit: *c_void);\n         }\n     }\n+\n+    // iOS segmented stack is disabled for now, see related notes\n+    #[cfg(target_arch = \"arm\", target_os = \"ios\")] #[inline(always)]\n+    unsafe fn target_record_sp_limit(_: uint) {\n+    }\n }\n \n /// The counterpart of the function above, this function will fetch the current\n@@ -216,7 +245,8 @@ pub unsafe fn get_sp_limit() -> uint {\n     return target_get_sp_limit();\n \n     // x86-64\n-    #[cfg(target_arch = \"x86_64\", target_os = \"macos\")] #[inline(always)]\n+    #[cfg(target_arch = \"x86_64\", target_os = \"macos\")]\n+    #[cfg(target_arch = \"x86_64\", target_os = \"ios\")] #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n         let limit;\n         asm!(\"movq $$0x60+90*8, %rsi\n@@ -243,7 +273,8 @@ pub unsafe fn get_sp_limit() -> uint {\n     }\n \n     // x86\n-    #[cfg(target_arch = \"x86\", target_os = \"macos\")] #[inline(always)]\n+    #[cfg(target_arch = \"x86\", target_os = \"macos\")]\n+    #[cfg(target_arch = \"x86\", target_os = \"ios\")] #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n         let limit;\n         asm!(\"movl $$0x48+90*4, %eax\n@@ -267,12 +298,20 @@ pub unsafe fn get_sp_limit() -> uint {\n     // mips, arm - Some brave soul can port these to inline asm, but it's over\n     //             my head personally\n     #[cfg(target_arch = \"mips\")]\n-    #[cfg(target_arch = \"arm\")] #[inline(always)]\n+    #[cfg(target_arch = \"arm\", not(target_os = \"ios\"))] #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n         use libc::c_void;\n         return get_sp_limit() as uint;\n         extern {\n             fn get_sp_limit() -> *c_void;\n         }\n     }\n+\n+    // iOS doesn't support segmented stacks yet. This function might\n+    // be called by runtime though so it is unsafe to mark it as\n+    // unreachable, let's return a fixed constant.\n+    #[cfg(target_arch = \"arm\", target_os = \"ios\")] #[inline(always)]\n+    unsafe fn target_get_sp_limit() -> uint {\n+        1024\n+    }\n }"}, {"sha": "3dcd1c4a6f0d3bde6b7a16392d34a2fd773c1319", "filename": "src/librustrt/thread.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustrt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustrt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fthread.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -276,7 +276,6 @@ mod imp {\n     }\n \n     pub unsafe fn yield_now() { assert_eq!(sched_yield(), 0); }\n-\n     // glibc >= 2.15 has a __pthread_get_minstack() function that returns\n     // PTHREAD_STACK_MIN plus however many bytes are needed for thread-local\n     // storage.  We need that information to avoid blowing up when a small stack\n@@ -345,4 +344,3 @@ mod tests {\n         assert_eq!(42, Thread::start_stack(1, proc () 42).join());\n     }\n }\n-"}, {"sha": "4a7be39e6b87a0b7e15891acb87cd58bdc604fbe", "filename": "src/librustrt/thread_local_storage.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustrt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustrt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fthread_local_storage.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -37,13 +37,14 @@ pub unsafe fn destroy(key: Key) {\n     assert!(pthread_key_delete(key) == 0);\n }\n \n-#[cfg(target_os=\"macos\")]\n+#[cfg(target_os = \"macos\")]\n #[allow(non_camel_case_types)] // foreign type\n type pthread_key_t = ::libc::c_ulong;\n \n #[cfg(target_os=\"linux\")]\n #[cfg(target_os=\"freebsd\")]\n #[cfg(target_os=\"android\")]\n+#[cfg(target_os = \"ios\")]\n #[allow(non_camel_case_types)] // foreign type\n type pthread_key_t = ::libc::c_uint;\n "}, {"sha": "80429bb667de54d57a2293da800feaf0bb0dbe16", "filename": "src/librustrt/unwind.rs", "status": "modified", "additions": 60, "deletions": 3, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustrt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibrustrt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Funwind.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -283,16 +283,73 @@ pub mod eabi {\n         }\n         else { // cleanup phase\n             unsafe {\n-                 __gcc_personality_v0(version, actions, exception_class, ue_header,\n+                __gcc_personality_v0(version, actions, exception_class, ue_header,\n+                                     context)\n+            }\n+        }\n+    }\n+}\n+\n+// iOS on armv7 is using SjLj exceptions and therefore requires to use\n+// a specialized personality routine: __gcc_personality_sj0\n+\n+#[cfg(target_os = \"ios\", target_arch = \"arm\", not(test))]\n+#[doc(hidden)]\n+#[allow(visible_private_types)]\n+pub mod eabi {\n+    use uw = libunwind;\n+    use libc::c_int;\n+\n+    extern \"C\" {\n+        fn __gcc_personality_sj0(version: c_int,\n+                                actions: uw::_Unwind_Action,\n+                                exception_class: uw::_Unwind_Exception_Class,\n+                                ue_header: *uw::_Unwind_Exception,\n+                                context: *uw::_Unwind_Context)\n+            -> uw::_Unwind_Reason_Code;\n+    }\n+\n+    #[lang=\"eh_personality\"]\n+    #[no_mangle] // so we can reference it by name from middle/trans/base.rs\n+    pub extern \"C\" fn rust_eh_personality(\n+        version: c_int,\n+        actions: uw::_Unwind_Action,\n+        exception_class: uw::_Unwind_Exception_Class,\n+        ue_header: *uw::_Unwind_Exception,\n+        context: *uw::_Unwind_Context\n+    ) -> uw::_Unwind_Reason_Code\n+    {\n+        unsafe {\n+            __gcc_personality_sj0(version, actions, exception_class, ue_header,\n+                                  context)\n+        }\n+    }\n+\n+    #[no_mangle] // referenced from rust_try.ll\n+    pub extern \"C\" fn rust_eh_personality_catch(\n+        version: c_int,\n+        actions: uw::_Unwind_Action,\n+        exception_class: uw::_Unwind_Exception_Class,\n+        ue_header: *uw::_Unwind_Exception,\n+        context: *uw::_Unwind_Context\n+    ) -> uw::_Unwind_Reason_Code\n+    {\n+        if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 { // search phase\n+            uw::_URC_HANDLER_FOUND // catch!\n+        }\n+        else { // cleanup phase\n+            unsafe {\n+                __gcc_personality_sj0(version, actions, exception_class, ue_header,\n                                       context)\n             }\n         }\n     }\n }\n \n+\n // ARM EHABI uses a slightly different personality routine signature,\n // but otherwise works the same.\n-#[cfg(target_arch = \"arm\", not(test))]\n+#[cfg(target_arch = \"arm\", not(test), not(target_os = \"ios\"))]\n #[allow(visible_private_types)]\n pub mod eabi {\n     use uw = libunwind;\n@@ -330,7 +387,7 @@ pub mod eabi {\n         }\n         else { // cleanup phase\n             unsafe {\n-                 __gcc_personality_v0(state, ue_header, context)\n+                __gcc_personality_v0(state, ue_header, context)\n             }\n         }\n     }"}, {"sha": "79e01c8b96653ed89a5ab866858e01b01c9d41e9", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -153,7 +153,7 @@ impl DynamicLibrary {\n     }\n }\n \n-#[cfg(test)]\n+#[cfg(test, not(target_os = \"ios\"))]\n mod test {\n     use super::*;\n     use prelude::*;\n@@ -206,6 +206,7 @@ mod test {\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"android\")]\n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"ios\")]\n #[cfg(target_os = \"freebsd\")]\n pub mod dl {\n     use prelude::*;"}, {"sha": "f6b1c04dd34c604b5beec2a99e601f5caadf62c3", "filename": "src/libstd/os.rs", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -552,6 +552,7 @@ pub fn pipe() -> Pipe {\n \n /// Returns the proper dll filename for the given basename of a file\n /// as a String.\n+#[cfg(not(target_os=\"ios\"))]\n pub fn dll_filename(base: &str) -> String {\n     format!(\"{}{}{}\", consts::DLL_PREFIX, base, consts::DLL_SUFFIX)\n }\n@@ -608,6 +609,7 @@ pub fn self_exe_name() -> Option<Path> {\n     }\n \n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     fn load_self() -> Option<Vec<u8>> {\n         unsafe {\n             use libc::funcs::extra::_NSGetExecutablePath;\n@@ -802,6 +804,7 @@ pub fn change_dir(p: &Path) -> bool {\n /// Returns the platform-specific value of errno\n pub fn errno() -> int {\n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     #[cfg(target_os = \"freebsd\")]\n     fn errno_location() -> *c_int {\n         extern {\n@@ -850,6 +853,7 @@ pub fn error_string(errnum: uint) -> String {\n     #[cfg(unix)]\n     fn strerror(errnum: uint) -> String {\n         #[cfg(target_os = \"macos\")]\n+        #[cfg(target_os = \"ios\")]\n         #[cfg(target_os = \"android\")]\n         #[cfg(target_os = \"freebsd\")]\n         fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: libc::size_t)\n@@ -995,6 +999,64 @@ fn real_args_as_bytes() -> Vec<Vec<u8>> {\n     }\n }\n \n+// As _NSGetArgc and _NSGetArgv aren't mentioned in iOS docs\n+// and use underscores in their names - they're most probably\n+// are considered private and therefore should be avoided\n+// Here is another way to get arguments using Objective C\n+// runtime\n+//\n+// In general it looks like:\n+// res = Vec::new()\n+// let args = [[NSProcessInfo processInfo] arguments]\n+// for i in range(0, [args count])\n+//      res.push([args objectAtIndex:i])\n+// res\n+#[cfg(target_os = \"ios\")]\n+fn real_args_as_bytes() -> Vec<Vec<u8>> {\n+    use c_str::CString;\n+    use iter::range;\n+    use mem;\n+\n+    #[link(name = \"objc\")]\n+    extern {\n+        fn sel_registerName(name: *libc::c_uchar) -> Sel;\n+        fn objc_msgSend(obj: NsId, sel: Sel, ...) -> NsId;\n+        fn objc_getClass(class_name: *libc::c_uchar) -> NsId;\n+    }\n+\n+    #[link(name = \"Foundation\", kind = \"framework\")]\n+    extern {}\n+\n+    type Sel = *libc::c_void;\n+    type NsId = *libc::c_void;\n+\n+    let mut res = Vec::new();\n+\n+    unsafe {\n+        let processInfoSel = sel_registerName(\"processInfo\\0\".as_ptr());\n+        let argumentsSel = sel_registerName(\"arguments\\0\".as_ptr());\n+        let utf8Sel = sel_registerName(\"UTF8String\\0\".as_ptr());\n+        let countSel = sel_registerName(\"count\\0\".as_ptr());\n+        let objectAtSel = sel_registerName(\"objectAtIndex:\\0\".as_ptr());\n+\n+        let klass = objc_getClass(\"NSProcessInfo\\0\".as_ptr());\n+        let info = objc_msgSend(klass, processInfoSel);\n+        let args = objc_msgSend(info, argumentsSel);\n+\n+        let cnt: int = mem::transmute(objc_msgSend(args, countSel));\n+        for i in range(0, cnt) {\n+            let tmp = objc_msgSend(args, objectAtSel, i);\n+            let utf_c_str: *libc::c_char = mem::transmute(objc_msgSend(tmp, utf8Sel));\n+            let s = CString::new(utf_c_str, false);\n+            if s.is_not_null() {\n+                res.push(Vec::from_slice(s.as_bytes_no_nul()))\n+            }\n+        }\n+    }\n+\n+    res\n+}\n+\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"android\")]\n #[cfg(target_os = \"freebsd\")]\n@@ -1532,6 +1594,25 @@ pub mod consts {\n     pub static EXE_EXTENSION: &'static str = \"\";\n }\n \n+#[cfg(target_os = \"ios\")]\n+pub mod consts {\n+    pub use os::arch_consts::ARCH;\n+\n+    pub static FAMILY: &'static str = \"unix\";\n+\n+    /// A string describing the specific operating system in use: in this\n+    /// case, `ios`.\n+    pub static SYSNAME: &'static str = \"ios\";\n+\n+    /// Specifies the filename suffix used for executable binaries on this\n+    /// platform: in this case, the empty string.\n+    pub static EXE_SUFFIX: &'static str = \"\";\n+\n+    /// Specifies the file extension, if any, used for executable binaries\n+    /// on this platform: in this case, the empty string.\n+    pub static EXE_EXTENSION: &'static str = \"\";\n+}\n+\n #[cfg(target_os = \"freebsd\")]\n pub mod consts {\n     pub use os::arch_consts::ARCH;"}, {"sha": "f507011c2b955166e5863b85aee4aa306e8b7444", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 67, "deletions": 2, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -13,7 +13,7 @@\n \n pub use self::imp::OsRng;\n \n-#[cfg(unix)]\n+#[cfg(unix, not(target_os = \"ios\"))]\n mod imp {\n     use io::{IoResult, File};\n     use path::Path;\n@@ -28,7 +28,7 @@ mod imp {\n     ///   `/dev/urandom`.\n     /// - Windows: calls `CryptGenRandom`, using the default cryptographic\n     ///   service provider with the `PROV_RSA_FULL` type.\n-    ///\n+    /// - iOS: calls SecRandomCopyBytes as /dev/(u)random is sandboxed\n     /// This does not block.\n     #[cfg(unix)]\n     pub struct OsRng {\n@@ -58,6 +58,71 @@ mod imp {\n     }\n }\n \n+#[cfg(target_os = \"ios\")]\n+mod imp {\n+    extern crate libc;\n+\n+    use collections::Collection;\n+    use io::{IoResult};\n+    use kinds::marker;\n+    use mem;\n+    use os;\n+    use rand::Rng;\n+    use result::{Ok};\n+    use self::libc::{c_int, size_t};\n+    use slice::MutableVector;\n+\n+    /// A random number generator that retrieves randomness straight from\n+    /// the operating system. Platform sources:\n+    ///\n+    /// - Unix-like systems (Linux, Android, Mac OSX): read directly from\n+    ///   `/dev/urandom`.\n+    /// - Windows: calls `CryptGenRandom`, using the default cryptographic\n+    ///   service provider with the `PROV_RSA_FULL` type.\n+    /// - iOS: calls SecRandomCopyBytes as /dev/(u)random is sandboxed\n+    /// This does not block.\n+    pub struct OsRng {\n+        marker: marker::NoCopy\n+    }\n+\n+    struct SecRandom;\n+\n+    static kSecRandomDefault: *SecRandom = 0 as *SecRandom;\n+\n+    #[link(name = \"Security\", kind = \"framework\")]\n+    extern \"C\" {\n+        fn SecRandomCopyBytes(rnd: *SecRandom, count: size_t, bytes: *mut u8) -> c_int;\n+    }\n+\n+    impl OsRng {\n+        /// Create a new `OsRng`.\n+        pub fn new() -> IoResult<OsRng> {\n+            Ok(OsRng {marker: marker::NoCopy} )\n+        }\n+    }\n+\n+    impl Rng for OsRng {\n+        fn next_u32(&mut self) -> u32 {\n+            let mut v = [0u8, .. 4];\n+            self.fill_bytes(v);\n+            unsafe { mem::transmute(v) }\n+        }\n+        fn next_u64(&mut self) -> u64 {\n+            let mut v = [0u8, .. 8];\n+            self.fill_bytes(v);\n+            unsafe { mem::transmute(v) }\n+        }\n+        fn fill_bytes(&mut self, v: &mut [u8]) {\n+            let ret = unsafe {\n+                SecRandomCopyBytes(kSecRandomDefault, v.len() as size_t, v.as_mut_ptr())\n+            };\n+            if ret == -1 {\n+                fail!(\"couldn't generate random bytes: {}\", os::last_os_error());\n+            }\n+        }\n+    }\n+}\n+\n #[cfg(windows)]\n mod imp {\n     extern crate libc;"}, {"sha": "b98fe8f0aaeda9b00b097c08bbdd2f514d4160f9", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 57, "deletions": 8, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -237,22 +237,63 @@ fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n #[cfg(unix)]\n mod imp {\n     use c_str::CString;\n-    use io::{IoResult, IoError, Writer};\n+    use io::{IoResult, Writer};\n     use libc;\n     use mem;\n     use option::{Some, None, Option};\n     use result::{Ok, Err};\n     use rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n \n-    struct Context<'a> {\n-        idx: int,\n-        writer: &'a mut Writer,\n-        last_error: Option<IoError>,\n+    /// As always - iOS on arm uses SjLj exceptions and\n+    /// _Unwind_Backtrace is even not available there. Still,\n+    /// backtraces could be extracted using a backtrace function,\n+    /// which thanks god is public\n+    ///\n+    /// As mentioned in a huge comment block above, backtrace doesn't\n+    /// play well with green threads, so while it is extremely nice\n+    /// and simple to use it should be used only on iOS devices as the\n+    /// only viable option.\n+    #[cfg(target_os = \"ios\", target_arch = \"arm\")]\n+    #[inline(never)]\n+    pub fn write(w: &mut Writer) -> IoResult<()> {\n+        use iter::{Iterator, range};\n+        use result;\n+        use slice::{MutableVector};\n+\n+        extern {\n+            fn backtrace(buf: *mut *libc::c_void, sz: libc::c_int) -> libc::c_int;\n+        }\n+\n+        // while it doesn't requires lock for work as everything is\n+        // local, it still displays much nicier backtraces when a\n+        // couple of tasks fail simultaneously\n+        static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+        let _g = unsafe { LOCK.lock() };\n+\n+        try!(writeln!(w, \"stack backtrace:\"));\n+        // 100 lines should be enough\n+        static SIZE: libc::c_int = 100;\n+        let mut buf: [*libc::c_void, ..SIZE] = unsafe {mem::zeroed()};\n+        let cnt = unsafe { backtrace(buf.as_mut_ptr(), SIZE) as uint};\n+\n+        // skipping the first one as it is write itself\n+        result::fold_(range(1, cnt).map(|i| {\n+            print(w, i as int, buf[i])\n+        }))\n     }\n \n+    #[cfg(not(target_os = \"ios\", target_arch = \"arm\"))]\n     #[inline(never)] // if we know this is a function call, we can skip it when\n                      // tracing\n     pub fn write(w: &mut Writer) -> IoResult<()> {\n+        use io::IoError;\n+\n+        struct Context<'a> {\n+            idx: int,\n+            writer: &'a mut Writer,\n+            last_error: Option<IoError>,\n+        }\n+\n         // When using libbacktrace, we use some necessary global state, so we\n         // need to prevent more than one thread from entering this block. This\n         // is semi-reasonable in terms of printing anyway, and we know that all\n@@ -291,7 +332,7 @@ mod imp {\n             // instructions after it. This means that the return instruction\n             // pointer points *outside* of the calling function, and by\n             // unwinding it we go back to the original function.\n-            let ip = if cfg!(target_os = \"macos\") {\n+            let ip = if cfg!(target_os = \"macos\") || cfg!(target_os = \"ios\") {\n                 ip\n             } else {\n                 unsafe { uw::_Unwind_FindEnclosingFunction(ip) }\n@@ -323,6 +364,7 @@ mod imp {\n     }\n \n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     fn print(w: &mut Writer, idx: int, addr: *libc::c_void) -> IoResult<()> {\n         use intrinsics;\n         #[repr(C)]\n@@ -347,7 +389,7 @@ mod imp {\n         }\n     }\n \n-    #[cfg(not(target_os = \"macos\"))]\n+    #[cfg(not(target_os = \"macos\"), not(target_os = \"ios\"))]\n     fn print(w: &mut Writer, idx: int, addr: *libc::c_void) -> IoResult<()> {\n         use collections::Collection;\n         use iter::Iterator;\n@@ -487,9 +529,14 @@ mod imp {\n \n     /// Unwind library interface used for backtraces\n     ///\n-    /// Note that the native libraries come from librustrt, not this module.\n+    /// Note that the native libraries come from librustrt, not this\n+    /// module.\n+    /// Note that dead code is allowed as here are just bindings\n+    /// iOS doesn't use all of them it but adding more\n+    /// platform-specific configs pollutes the code too much\n     #[allow(non_camel_case_types)]\n     #[allow(non_snake_case_functions)]\n+    #[allow(dead_code)]\n     mod uw {\n         use libc;\n \n@@ -514,6 +561,8 @@ mod imp {\n                           arg: *libc::c_void) -> _Unwind_Reason_Code;\n \n         extern {\n+            // No native _Unwind_Backtrace on iOS\n+            #[cfg(not(target_os = \"ios\", target_arch = \"arm\"))]\n             pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,\n                                      trace_argument: *libc::c_void)\n                         -> _Unwind_Reason_Code;"}, {"sha": "f8bfde52261632f1887ccffe786d263f9b4d45e3", "filename": "src/libstd/rtdeps.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibstd%2Frtdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibstd%2Frtdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frtdeps.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -39,3 +39,7 @@ extern {}\n #[cfg(target_os = \"macos\")]\n #[link(name = \"System\")]\n extern {}\n+\n+#[cfg(target_os = \"ios\")]\n+#[link(name = \"System\")]\n+extern {}"}, {"sha": "7ff020d6818e19a18faef99041bc6761ffea3aa7", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -11,7 +11,7 @@\n use std::fmt;\n \n #[deriving(PartialEq)]\n-pub enum Os { OsWin32, OsMacos, OsLinux, OsAndroid, OsFreebsd, }\n+pub enum Os { OsWin32, OsMacos, OsLinux, OsAndroid, OsFreebsd, OsiOS, }\n \n #[deriving(PartialEq, Eq, Hash, Encodable, Decodable, Clone)]\n pub enum Abi {\n@@ -159,6 +159,19 @@ impl fmt::Show for Abi {\n     }\n }\n \n+impl fmt::Show for Os {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            OsLinux => \"linux\".fmt(f),\n+            OsWin32 => \"win32\".fmt(f),\n+            OsMacos => \"macos\".fmt(f),\n+            OsiOS => \"ios\".fmt(f),\n+            OsAndroid => \"android\".fmt(f),\n+            OsFreebsd => \"freebsd\".fmt(f)\n+        }\n+    }\n+}\n+\n #[allow(non_snake_case_functions)]\n #[test]\n fn lookup_Rust() {"}, {"sha": "79f8cd3379a9d4e1c6743eb4e3474523039ac213", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -46,7 +46,7 @@ mod rustrt {\n     }\n }\n \n-#[cfg(unix, not(target_os = \"macos\"))]\n+#[cfg(unix, not(target_os = \"macos\"), not(target_os = \"ios\"))]\n mod imp {\n     use libc::{c_int, timespec};\n \n@@ -61,6 +61,7 @@ mod imp {\n \n }\n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"ios\")]\n mod imp {\n     use libc::{timeval, timezone, c_int, mach_timebase_info};\n \n@@ -121,14 +122,15 @@ pub fn get_time() -> Timespec {\n     }\n \n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     unsafe fn os_get_time() -> (i64, i32) {\n         use std::ptr;\n         let mut tv = libc::timeval { tv_sec: 0, tv_usec: 0 };\n         imp::gettimeofday(&mut tv, ptr::mut_null());\n         (tv.tv_sec as i64, tv.tv_usec * 1000)\n     }\n \n-    #[cfg(not(target_os = \"macos\"), not(windows))]\n+    #[cfg(not(target_os = \"macos\"), not(target_os = \"ios\"), not(windows))]\n     unsafe fn os_get_time() -> (i64, i32) {\n         let mut tv = libc::timespec { tv_sec: 0, tv_nsec: 0 };\n         imp::clock_gettime(libc::CLOCK_REALTIME, &mut tv);\n@@ -160,6 +162,7 @@ pub fn precise_time_ns() -> u64 {\n     }\n \n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     fn os_precise_time_ns() -> u64 {\n         static mut TIMEBASE: libc::mach_timebase_info = libc::mach_timebase_info { numer: 0,\n                                                                                    denom: 0 };\n@@ -173,7 +176,7 @@ pub fn precise_time_ns() -> u64 {\n         }\n     }\n \n-    #[cfg(not(windows), not(target_os = \"macos\"))]\n+    #[cfg(not(windows), not(target_os = \"macos\"), not(target_os = \"ios\"))]\n     fn os_precise_time_ns() -> u64 {\n         let mut ts = libc::timespec { tv_sec: 0, tv_nsec: 0 };\n         unsafe {"}, {"sha": "38fc4827f5861e811ded6db100301a08f6af6b09", "filename": "src/rt/arch/arm/_context.S", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Frt%2Farch%2Farm%2F_context.S", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Frt%2Farch%2Farm%2F_context.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Farm%2F_context.S?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -12,8 +12,16 @@\n .align\n #endif\n \n-.globl rust_swap_registers\n-rust_swap_registers:\n+#if defined(__APPLE__)\n+  #define SWAP_REGISTERS  _rust_swap_registers\n+  #define BOOTSTRAP_TASK  _rust_bootstrap_green_task\n+#else\n+  #define SWAP_REGISTERS  rust_swap_registers\n+  #define BOOTSTRAP_TASK  rust_bootstrap_green_task\n+#endif\n+        \n+.globl SWAP_REGISTERS\n+SWAP_REGISTERS:\n \tstr r0, [r0, #0]\n \tstr r3, [r0, #12]\n \tstr r4, [r0, #16]\n@@ -53,9 +61,9 @@ rust_swap_registers:\n \tmov pc, lr\n \n // For reasons of this existence, see the comments in x86_64/_context.S\n-.globl rust_bootstrap_green_task\n-rust_bootstrap_green_task:\n-        mov r0, r0\n-        mov r1, r3\n-        mov r2, r4\n-        mov pc, r5\n+.globl BOOTSTRAP_TASK\n+BOOTSTRAP_TASK:\n+    mov r0, r0\n+    mov r1, r3\n+    mov r2, r4\n+    mov pc, r5"}, {"sha": "0b9012cc2a80a27a48cc7fd4b6d0531aae349196", "filename": "src/rt/arch/arm/morestack.S", "status": "modified", "additions": 46, "deletions": 16, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Frt%2Farch%2Farm%2Fmorestack.S", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Frt%2Farch%2Farm%2Fmorestack.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Farm%2Fmorestack.S?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -8,33 +8,63 @@\n .text\n .code 32\n .arm\n+#if defined(__APPLE__)\n+.align 2\n+#else\n .align\n+#endif\n+\n+#if defined(__APPLE__)\n+#define MORESTACK ___morestack\n+#define STACK_EXHAUSTED _rust_stack_exhausted\n+#else\n+#define MORESTACK __morestack\n+#define STACK_EXHAUSTED rust_stack_exhausted\n+#endif\n+\n+.global STACK_EXHAUSTED\n+.global MORESTACK\n+\n+// Unfortunately LLVM yet doesn't support emitting correct debug\n+// DWARF information for non-ELF targets so to make it compile\n+// on iOS all that directives are simply commented out\n+#if defined(__APPLE__)\n+#define UNWIND @\n+#else\n+#define UNWIND\n+#endif\n \n-.global rust_stack_exhausted\n-.global __morestack\n-.hidden __morestack\n+#if defined(__APPLE__)\n+.private_extern MORESTACK\n+#else\n+.hidden MORESTACK\n+#endif\n+\n+#if !defined(__APPLE__)\n+   .type MORESTACK,%function\n+#endif\n \n // r4 and r5 are scratch registers for __morestack due to llvm\n // ARMFrameLowering::adjustForSegmentedStacks() implementation.\n- .type __morestack,%function\n-__morestack:\n-\t.fnstart\n-\t// Save frame pointer and return address\n-\t.save {r4, r5}\n-\t.save {lr}\n-\t.save {r6, fp, lr}\n+MORESTACK:\n+    UNWIND .fnstart\n+\n+    // Save frame pointer and return address\n+    UNWIND .save {r4, r5}\n+    UNWIND .save {lr}\n+    UNWIND .save {r6, fp, lr}\n     push {r6, fp, lr}\n \n-\t.movsp r6\n-\tmov r6, sp\n-\t.setfp fp, sp, #4\n-\tadd fp, sp, #4\n+    UNWIND .movsp r6\n+    mov r6, sp\n+    UNWIND .setfp fp, sp, #4\n+    add fp, sp, #4\n \n     // Save argument registers of the original function\n     push {r0, r1, r2, r3, lr}\n \n     // Create new stack\n-    bl rust_stack_exhausted@plt\n+    bl STACK_EXHAUSTED@plt\n \n     // the above function ensures that it never returns\n-    .fnend\n+    UNWIND  .fnend"}, {"sha": "d0e9b81b95a9bfbe03a1268100afcfafd7afc2fb", "filename": "src/rt/arch/arm/record_sp.S", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Frt%2Farch%2Farm%2Frecord_sp.S", "raw_url": "https://github.com/rust-lang/rust/raw/2ef910f71ab83761b1f5f9144621f246622e92d8/src%2Frt%2Farch%2Farm%2Frecord_sp.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Farm%2Frecord_sp.S?ref=2ef910f71ab83761b1f5f9144621f246622e92d8", "patch": "@@ -1,3 +1,9 @@\n+// Do not compile anything here for iOS because split stacks\n+// are disabled at all and do not need any runtime support.\n+//\n+// See also comments in librustrt/stack.rs about why it was\n+// disabled and how it could be implemented in case of need.\n+#if !defined(__APPLE__)\n // Mark stack as non-executable\n #if defined(__linux__) && defined(__ELF__)\n .section\t.note.GNU-stack, \"\", %progbits\n@@ -6,16 +12,15 @@\n .text\n .code 32\n .arm\n-#if defined(__APPLE__)\n-.align 2\n-#else\n .align\n-#endif\n \n-.globl record_sp_limit\n-.globl get_sp_limit\n+#define RECORD_SP_LIMIT record_sp_limit\n+#define GET_SP_LIMIT    get_sp_limit\n+\n+.globl \tRECORD_SP_LIMIT\n+.globl\tGET_SP_LIMIT\n \n-record_sp_limit:\n+RECORD_SP_LIMIT:\n \t// First, try to read TLS address from coprocessor\n \tmrc p15, #0, r3, c13, c0, #3\n \tcmp r3, #0\n@@ -27,12 +32,12 @@ record_sp_limit:\n \tadd r3, r3, #252\n #elif __linux__\n \tadd r3, r3, #4\n-#endif\n+#endif // ANDROID\n \n \tstr r0, [r3]\n \tmov pc, lr\n \n-get_sp_limit:\n+GET_SP_LIMIT:\n \t// First, try to read TLS address from coprocessor\n \tmrc p15, #0, r3, c13, c0, #3\n \tcmp r3, #0\n@@ -44,7 +49,8 @@ get_sp_limit:\n \tadd r3, r3, #252\n #elif __linux__\n \tadd r3, r3, #4\n-#endif\n+#endif  // __ANDROID__\n \n \tldr r0, [r3]\n \tmov pc, lr\n+#endif"}]}