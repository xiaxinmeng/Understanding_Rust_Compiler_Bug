{"sha": "cc5e6db5f2d25fb1c0371455574db7aecbe0ba0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjNWU2ZGI1ZjJkMjVmYjFjMDM3MTQ1NTU3NGRiN2FlY2JlMGJhMGM=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-12-15T08:38:15Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2021-02-01T23:38:41Z"}, "message": "Migrations first pass", "tree": {"sha": "85b5dccedfb10ec083cb09425ca019bcf5632df2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85b5dccedfb10ec083cb09425ca019bcf5632df2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc5e6db5f2d25fb1c0371455574db7aecbe0ba0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc5e6db5f2d25fb1c0371455574db7aecbe0ba0c", "html_url": "https://github.com/rust-lang/rust/commit/cc5e6db5f2d25fb1c0371455574db7aecbe0ba0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc5e6db5f2d25fb1c0371455574db7aecbe0ba0c/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3e85014a712e2b41ac44d71ddee3d55711a8d44", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3e85014a712e2b41ac44d71ddee3d55711a8d44", "html_url": "https://github.com/rust-lang/rust/commit/d3e85014a712e2b41ac44d71ddee3d55711a8d44"}], "stats": {"total": 138, "additions": 134, "deletions": 4}, "files": [{"sha": "16aaa48ce17fe36174c6a272222b648756064441", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 131, "deletions": 1, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/cc5e6db5f2d25fb1c0371455574db7aecbe0ba0c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc5e6db5f2d25fb1c0371455574db7aecbe0ba0c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=cc5e6db5f2d25fb1c0371455574db7aecbe0ba0c", "patch": "@@ -30,6 +30,7 @@\n //! then mean that all later passes would have to check for these figments\n //! and report an error, and it just seems like more mess in the end.)\n \n+use super::writeback::Resolver;\n use super::FnCtxt;\n \n use crate::expr_use_visitor as euv;\n@@ -40,7 +41,9 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_infer::infer::UpvarRegion;\n use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId, ProjectionKind};\n+use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeckResults, UpvarSubsts};\n+use rustc_session::lint;\n use rustc_span::sym;\n use rustc_span::{MultiSpan, Span, Symbol};\n \n@@ -97,7 +100,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         closure_hir_id: hir::HirId,\n         span: Span,\n-        body: &hir::Body<'_>,\n+        body: &'tcx hir::Body<'tcx>,\n         capture_clause: hir::CaptureBy,\n     ) {\n         debug!(\"analyze_closure(id={:?}, body.id={:?})\", closure_hir_id, body.id());\n@@ -157,6 +160,38 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         self.compute_min_captures(closure_def_id, delegate.capture_information);\n \n+        let closure_hir_id = self.tcx.hir().local_def_id_to_hir_id(local_def_id);\n+        if should_do_migration_analysis(self.tcx, closure_hir_id) {\n+            let need_migrations = self.compute_2229_migrations_first_pass(\n+                closure_def_id,\n+                span,\n+                capture_clause,\n+                body,\n+                self.typeck_results.borrow().closure_min_captures.get(&closure_def_id),\n+            );\n+\n+            if !need_migrations.is_empty() {\n+                let need_migrations_hir_id =\n+                    need_migrations.iter().map(|m| m.0).collect::<Vec<_>>();\n+\n+                let migrations_text =\n+                    migration_suggestion_for_2229(self.tcx, &need_migrations_hir_id);\n+\n+                self.tcx.struct_span_lint_hir(\n+                    lint::builtin::DISJOINT_CAPTURE_DROP_REORDER,\n+                    closure_hir_id,\n+                    span,\n+                    |lint| {\n+                        let mut diagnostics_builder = lint.build(\n+                            \"drop order affected for closure because of `capture_disjoint_fields`\",\n+                        );\n+                        diagnostics_builder.note(&migrations_text);\n+                        diagnostics_builder.emit();\n+                    },\n+                );\n+            }\n+        }\n+\n         // We now fake capture information for all variables that are mentioned within the closure\n         // We do this after handling migrations so that min_captures computes before\n         if !self.tcx.features().capture_disjoint_fields {\n@@ -520,6 +555,86 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         typeck_results.closure_min_captures.insert(closure_def_id, root_var_min_capture_list);\n     }\n \n+    /// Figures out the list of root variables (and their types) that aren't completely\n+    /// captured by the closure when `capture_disjoint_fields` is enabled and drop order of\n+    /// some path starting at that root variable **might** be affected.\n+    ///\n+    /// The output list would include a root variable if:\n+    /// - It would have been moved into the closure when `capture_disjoint_fields` wasn't\n+    ///   enabled, **and**\n+    /// - It wasn't completely captured by the closure, **and**\n+    /// - The type of the root variable needs Drop.\n+    fn compute_2229_migrations_first_pass(\n+        &self,\n+        closure_def_id: DefId,\n+        closure_span: Span,\n+        closure_clause: hir::CaptureBy,\n+        body: &'tcx hir::Body<'tcx>,\n+        min_captures: Option<&ty::RootVariableMinCaptureList<'tcx>>,\n+    ) -> Vec<(hir::HirId, Ty<'tcx>)> {\n+        fn resolve_ty<T: TypeFoldable<'tcx>>(\n+            fcx: &FnCtxt<'_, 'tcx>,\n+            span: Span,\n+            body: &'tcx hir::Body<'tcx>,\n+            ty: T,\n+        ) -> T {\n+            let mut resolver = Resolver::new(fcx, &span, body);\n+            ty.fold_with(&mut resolver)\n+        }\n+\n+        let upvars = if let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) {\n+            upvars\n+        } else {\n+            return vec![];\n+        };\n+\n+        let mut need_migrations = Vec::new();\n+\n+        for (&var_hir_id, _) in upvars.iter() {\n+            let ty = resolve_ty(self, closure_span, body, self.node_ty(var_hir_id));\n+\n+            if !ty.needs_drop(self.tcx, self.tcx.param_env(closure_def_id.expect_local())) {\n+                continue;\n+            }\n+\n+            let root_var_min_capture_list = if let Some(root_var_min_capture_list) =\n+                min_captures.and_then(|m| m.get(&var_hir_id))\n+            {\n+                root_var_min_capture_list\n+            } else {\n+                // The upvar is mentioned within the closure but no path starting from it is\n+                // used.\n+\n+                match closure_clause {\n+                    // Only migrate if closure is a move closure\n+                    hir::CaptureBy::Value => need_migrations.push((var_hir_id, ty)),\n+\n+                    hir::CaptureBy::Ref => {}\n+                }\n+\n+                continue;\n+            };\n+\n+            let is_moved = root_var_min_capture_list\n+                .iter()\n+                .find(|capture| matches!(capture.info.capture_kind, ty::UpvarCapture::ByValue(_)))\n+                .is_some();\n+\n+            // 1. If we capture more than one path starting at the root variabe then the root variable\n+            //    isn't being captured in its entirety\n+            // 2. If we only capture one path starting at the root variable, it's still possible\n+            //    that it isn't the root variable completely.\n+            if is_moved\n+                && ((root_var_min_capture_list.len() > 1)\n+                    || (root_var_min_capture_list[0].place.projections.len() > 0))\n+            {\n+                need_migrations.push((var_hir_id, ty));\n+            }\n+        }\n+\n+        need_migrations\n+    }\n+\n     fn init_capture_kind(\n         &self,\n         capture_clause: hir::CaptureBy,\n@@ -1136,6 +1251,21 @@ fn var_name(tcx: TyCtxt<'_>, var_hir_id: hir::HirId) -> Symbol {\n     tcx.hir().name(var_hir_id)\n }\n \n+fn should_do_migration_analysis(tcx: TyCtxt<'_>, closure_id: hir::HirId) -> bool {\n+    let (level, _) =\n+        tcx.lint_level_at_node(lint::builtin::DISJOINT_CAPTURE_DROP_REORDER, closure_id);\n+\n+    !matches!(level, lint::Level::Allow)\n+}\n+\n+fn migration_suggestion_for_2229(tcx: TyCtxt<'_>, need_migrations: &Vec<hir::HirId>) -> String {\n+    let need_migrations_strings =\n+        need_migrations.iter().map(|v| format!(\"{}\", var_name(tcx, *v))).collect::<Vec<_>>();\n+    let migrations_list_concat = need_migrations_strings.join(\", \");\n+\n+    format!(\"let ({}) = ({});\", migrations_list_concat, migrations_list_concat)\n+}\n+\n /// Helper function to determine if we need to escalate CaptureKind from\n /// CaptureInfo A to B and returns the escalated CaptureInfo.\n /// (Note: CaptureInfo contains CaptureKind and an expression that led to capture it in that way)"}, {"sha": "4d18b2cb3fc49656d2f558761ffea967ce8fdd19", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc5e6db5f2d25fb1c0371455574db7aecbe0ba0c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc5e6db5f2d25fb1c0371455574db7aecbe0ba0c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=cc5e6db5f2d25fb1c0371455574db7aecbe0ba0c", "patch": "@@ -650,7 +650,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     }\n }\n \n-trait Locatable {\n+crate trait Locatable {\n     fn to_span(&self, tcx: TyCtxt<'_>) -> Span;\n }\n \n@@ -668,7 +668,7 @@ impl Locatable for hir::HirId {\n \n /// The Resolver. This is the type folding engine that detects\n /// unresolved types and so forth.\n-struct Resolver<'cx, 'tcx> {\n+crate struct Resolver<'cx, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n     span: &'cx dyn Locatable,\n@@ -679,7 +679,7 @@ struct Resolver<'cx, 'tcx> {\n }\n \n impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n-    fn new(\n+    crate fn new(\n         fcx: &'cx FnCtxt<'cx, 'tcx>,\n         span: &'cx dyn Locatable,\n         body: &'tcx hir::Body<'tcx>,"}]}