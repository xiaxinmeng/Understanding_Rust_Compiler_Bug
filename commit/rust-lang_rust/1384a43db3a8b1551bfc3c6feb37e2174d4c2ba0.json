{"sha": "1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzODRhNDNkYjNhOGIxNTUxYmZjM2M2ZmViMzdlMjE3NGQ0YzJiYTA=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-10-24T17:25:50Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-10-31T12:25:34Z"}, "message": "DSTify Hash\n\n- The signature of the `*_equiv` methods of `HashMap` and similar structures\nhave changed, and now require one less level of indirection. Change your code\nfrom:\n\n```\nhashmap.find_equiv(&\"Hello\");\nhashmap.find_equiv(&&[0u8, 1, 2]);\n```\n\nto:\n\n```\nhashmap.find_equiv(\"Hello\");\nhashmap.find_equiv(&[0u8, 1, 2]);\n```\n\n- The generic parameter `T` of the `Hasher::hash<T>` method have become\n`Sized?`. Downstream code must add `Sized?` to that method in their\nimplementations. For example:\n\n```\nimpl Hasher<FnvState> for FnvHasher {\n    fn hash<T: Hash<FnvState>>(&self, t: &T) -> u64 { /* .. */ }\n}\n```\n\nmust be changed to:\n\n```\nimpl Hasher<FnvState> for FnvHasher {\n    fn hash<Sized? T: Hash<FnvState>>(&self, t: &T) -> u64 { /* .. */ }\n    //      ^^^^^^\n}\n```\n\n[breaking-change]", "tree": {"sha": "e45a0343003c22ed5b1ccbaa008189db578c3658", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e45a0343003c22ed5b1ccbaa008189db578c3658"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "html_url": "https://github.com/rust-lang/rust/commit/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/comments", "author": null, "committer": null, "parents": [{"sha": "065caf34f5ff29e04605f95d9c5d511af219439a", "url": "https://api.github.com/repos/rust-lang/rust/commits/065caf34f5ff29e04605f95d9c5d511af219439a", "html_url": "https://github.com/rust-lang/rust/commit/065caf34f5ff29e04605f95d9c5d511af219439a"}], "stats": {"total": 157, "additions": 83, "deletions": 74}, "files": [{"sha": "6c1a4019bd83ffc5d9c75f81c7ad7c32bd3f199c", "filename": "src/libcollections/hash/mod.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fmod.rs?ref=1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "patch": "@@ -80,7 +80,7 @@ pub mod sip;\n /// A hashable type. The `S` type parameter is an abstract hash state that is\n /// used by the `Hash` to compute the hash. It defaults to\n /// `std::hash::sip::SipState`.\n-pub trait Hash<S = sip::SipState> {\n+pub trait Hash<S = sip::SipState> for Sized? {\n     /// Computes the hash of a value.\n     fn hash(&self, state: &mut S);\n }\n@@ -89,7 +89,7 @@ pub trait Hash<S = sip::SipState> {\n /// containers like `HashMap`, which need a generic way hash multiple types.\n pub trait Hasher<S> {\n     /// Compute the hash of a value.\n-    fn hash<T: Hash<S>>(&self, value: &T) -> u64;\n+    fn hash<Sized? T: Hash<S>>(&self, value: &T) -> u64;\n }\n \n pub trait Writer {\n@@ -137,7 +137,7 @@ impl<S: Writer> Hash<S> for char {\n     }\n }\n \n-impl<'a, S: Writer> Hash<S> for &'a str {\n+impl<S: Writer> Hash<S> for str {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         state.write(self.as_bytes());\n@@ -186,7 +186,7 @@ impl_hash_tuple!(A B C D E F G H I J)\n impl_hash_tuple!(A B C D E F G H I J K)\n impl_hash_tuple!(A B C D E F G H I J K L)\n \n-impl<'a, S: Writer, T: Hash<S>> Hash<S> for &'a [T] {\n+impl<S: Writer, T: Hash<S>> Hash<S> for [T] {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);\n@@ -197,41 +197,35 @@ impl<'a, S: Writer, T: Hash<S>> Hash<S> for &'a [T] {\n }\n \n \n-impl<'a, S: Writer, T: Hash<S>> Hash<S> for &'a mut [T] {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        self.as_slice().hash(state);\n-    }\n-}\n-\n impl<S: Writer, T: Hash<S>> Hash<S> for Vec<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         self.as_slice().hash(state);\n     }\n }\n \n-impl<'a, S: Writer, T: Hash<S>> Hash<S> for &'a T {\n+impl<'a, S: Writer, Sized? T: Hash<S>> Hash<S> for &'a T {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         (**self).hash(state);\n     }\n }\n \n-impl<'a, S: Writer, T: Hash<S>> Hash<S> for &'a mut T {\n+impl<'a, S: Writer, Sized? T: Hash<S>> Hash<S> for &'a mut T {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         (**self).hash(state);\n     }\n }\n \n-impl<S: Writer, T: Hash<S>> Hash<S> for Box<T> {\n+impl<S: Writer, Sized? T: Hash<S>> Hash<S> for Box<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         (**self).hash(state);\n     }\n }\n \n+// FIXME (#18248) Make `T` `Sized?`\n impl<S: Writer, T: Hash<S>> Hash<S> for Rc<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n@@ -293,6 +287,7 @@ impl<S: Writer, T: Hash<S>, U: Hash<S>> Hash<S> for Result<T, U> {\n \n #[cfg(test)]\n mod tests {\n+    use core::kinds::Sized;\n     use std::mem;\n \n     use slice::ImmutableSlice;\n@@ -301,7 +296,7 @@ mod tests {\n     struct MyWriterHasher;\n \n     impl Hasher<MyWriter> for MyWriterHasher {\n-        fn hash<T: Hash<MyWriter>>(&self, value: &T) -> u64 {\n+        fn hash<Sized? T: Hash<MyWriter>>(&self, value: &T) -> u64 {\n             let mut state = MyWriter { hash: 0 };\n             value.hash(&mut state);\n             state.hash\n@@ -323,6 +318,8 @@ mod tests {\n \n     #[test]\n     fn test_writer_hasher() {\n+        use alloc::boxed::Box;\n+\n         let hasher = MyWriterHasher;\n \n         assert_eq!(hasher.hash(&()), 0);\n@@ -344,9 +341,17 @@ mod tests {\n \n         assert_eq!(hasher.hash(&'a'), 97);\n \n-        assert_eq!(hasher.hash(&(\"a\")), 97 + 0xFF);\n+        let s: &str = \"a\";\n+        assert_eq!(hasher.hash(& s), 97 + 0xFF);\n+        // FIXME (#18283) Enable test\n+        //let s: Box<str> = box \"a\";\n+        //assert_eq!(hasher.hash(& s), 97 + 0xFF);\n         let cs: &[u8] = &[1u8, 2u8, 3u8];\n         assert_eq!(hasher.hash(& cs), 9);\n+        let cs: Box<[u8]> = box [1u8, 2u8, 3u8];\n+        assert_eq!(hasher.hash(& cs), 9);\n+\n+        // FIXME (#18248) Add tests for hashing Rc<str> and Rc<[T]>\n \n         unsafe {\n             let ptr: *const int = mem::transmute(5i);"}, {"sha": "1f12065750ba35df1321ce9e102e62c2f567f103", "filename": "src/libcollections/hash/sip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibcollections%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibcollections%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fsip.rs?ref=1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "patch": "@@ -235,7 +235,7 @@ impl SipHasher {\n \n impl Hasher<SipState> for SipHasher {\n     #[inline]\n-    fn hash<T: Hash<SipState>>(&self, value: &T) -> u64 {\n+    fn hash<Sized? T: Hash<SipState>>(&self, value: &T) -> u64 {\n         let mut state = SipState::new_with_keys(self.k0, self.k1);\n         value.hash(&mut state);\n         state.result()"}, {"sha": "d7c2b52b8dea424ec1e1606e8e1af9fc725f4298", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "patch": "@@ -39,6 +39,7 @@\n \n #![stable]\n \n+use kinds::Sized;\n use option::{Option, Some, None};\n \n /// Trait for values that can be compared for equality and inequality.\n@@ -236,7 +237,7 @@ pub trait PartialOrd: PartialEq {\n /// container types; e.g. it is often desirable to be able to use `&str`\n /// values to look up entries in a container with `String` keys.\n #[experimental = \"Better solutions may be discovered.\"]\n-pub trait Equiv<T> {\n+pub trait Equiv<T> for Sized? {\n     /// Implement this function to decide equivalent values.\n     fn equiv(&self, other: &T) -> bool;\n }"}, {"sha": "dd51534d3198148937ce81cd21f3561d090fe538", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "patch": "@@ -1565,7 +1565,7 @@ impl<'a,T:PartialEq> PartialEq for &'a [T] {\n impl<'a,T:Eq> Eq for &'a [T] {}\n \n #[unstable = \"waiting for DST\"]\n-impl<'a,T:PartialEq, V: AsSlice<T>> Equiv<V> for &'a [T] {\n+impl<T: PartialEq, V: AsSlice<T>> Equiv<V> for [T] {\n     #[inline]\n     fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n }"}, {"sha": "86bbef861c4cede39efd9bdf174fe735a2ab35e8", "filename": "src/libcore/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "patch": "@@ -1160,9 +1160,9 @@ pub mod traits {\n         }\n     }\n \n-    impl<'a, S: Str> Equiv<S> for &'a str {\n+    impl<S: Str> Equiv<S> for str {\n         #[inline]\n-        fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n+        fn equiv(&self, other: &S) -> bool { eq_slice(self, other.as_slice()) }\n     }\n \n     impl ops::Slice<uint, str> for str {"}, {"sha": "08d73d3434fca4b4761bf965bfdcb042cb278e9c", "filename": "src/libregex/re.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "patch": "@@ -724,7 +724,7 @@ impl<'t> Captures<'t> {\n         match self.named {\n             None => \"\",\n             Some(ref h) => {\n-                match h.find_equiv(&name) {\n+                match h.find_equiv(name) {\n                     None => \"\",\n                     Some(i) => self.at(*i),\n                 }"}, {"sha": "a18d91196e04de57dc8aaa5c39ec69eb9cba61e7", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "patch": "@@ -164,7 +164,7 @@ impl LintStore {\n     }\n \n     fn register_renamed(&mut self, old_name: &str, new_name: &str) {\n-        let target = match self.by_name.find_equiv(&new_name) {\n+        let target = match self.by_name.find_equiv(new_name) {\n             Some(&Id(lint_id)) => lint_id.clone(),\n             _ => panic!(\"invalid lint renaming of {} to {}\", old_name, new_name)\n         };\n@@ -258,7 +258,7 @@ impl LintStore {\n     fn find_lint(&self, lint_name: &str, sess: &Session, span: Option<Span>)\n                  -> Option<LintId>\n     {\n-        match self.by_name.find_equiv(&lint_name) {\n+        match self.by_name.find_equiv(lint_name) {\n             Some(&Id(lint_id)) => Some(lint_id),\n             Some(&Renamed(ref new_name, lint_id)) => {\n                 let warning = format!(\"lint {} has been renamed to {}\",\n@@ -280,7 +280,7 @@ impl LintStore {\n                 None => {\n                     match self.lint_groups.iter().map(|(&x, pair)| (x, pair.ref0().clone()))\n                                                  .collect::<HashMap<&'static str, Vec<LintId>>>()\n-                                                 .find_equiv(&lint_name.as_slice()) {\n+                                                 .find_equiv(lint_name.as_slice()) {\n                         Some(v) => {\n                             v.iter()\n                              .map(|lint_id: &LintId|\n@@ -487,7 +487,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                     match self.lints.find_lint(lint_name.get(), &self.tcx.sess, Some(span)) {\n                         Some(lint_id) => vec![(lint_id, level, span)],\n                         None => {\n-                            match self.lints.lint_groups.find_equiv(&lint_name.get()) {\n+                            match self.lints.lint_groups.find_equiv(lint_name.get()) {\n                                 Some(&(ref v, _)) => v.iter()\n                                                       .map(|lint_id: &LintId|\n                                                            (*lint_id, level, span))"}, {"sha": "92b2382ae64f493d8b7f7e0bf858625d2cc61911", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "patch": "@@ -303,7 +303,7 @@ fn existing_match(e: &Env, name: &str,\n         // `source` stores paths which are normalized which may be different\n         // from the strings on the command line.\n         let source = e.sess.cstore.get_used_crate_source(cnum).unwrap();\n-        match e.sess.opts.externs.find_equiv(&name) {\n+        match e.sess.opts.externs.find_equiv(name) {\n             Some(locs) => {\n                 let found = locs.iter().any(|l| {\n                     let l = fs::realpath(&Path::new(l.as_slice())).ok();"}, {"sha": "22ebaa40eb20b9ae7ef962a7911a6c8c710628a0", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "patch": "@@ -295,7 +295,7 @@ fn item_path(item_doc: rbml::Doc) -> Vec<ast_map::PathElem> {\n fn item_name(intr: &IdentInterner, item: rbml::Doc) -> ast::Name {\n     let name = reader::get_doc(item, tag_paths_data_name);\n     let string = name.as_str_slice();\n-    match intr.find_equiv(&string) {\n+    match intr.find_equiv(string) {\n         None => token::intern(string),\n         Some(val) => val,\n     }"}, {"sha": "6d938b563036b28896fb5e01e92753831b8f6519", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "patch": "@@ -52,7 +52,7 @@ impl<'a> FileSearch<'a> {\n         debug!(\"filesearch: searching lib path\");\n         let tlib_path = make_target_lib_path(self.sysroot,\n                                     self.triple);\n-        if !visited_dirs.contains_equiv(&tlib_path.as_vec()) {\n+        if !visited_dirs.contains_equiv(tlib_path.as_vec()) {\n             match f(&tlib_path) {\n                 FileMatches => found = true,\n                 FileDoesntMatch => ()\n@@ -69,7 +69,7 @@ impl<'a> FileSearch<'a> {\n                 debug!(\"is {} in visited_dirs? {}\", tlib_path.display(),\n                         visited_dirs.contains_equiv(&tlib_path.as_vec().to_vec()));\n \n-                if !visited_dirs.contains_equiv(&tlib_path.as_vec()) {\n+                if !visited_dirs.contains_equiv(tlib_path.as_vec()) {\n                     visited_dirs.insert(tlib_path.as_vec().to_vec());\n                     // Don't keep searching the RUST_PATH if one match turns up --\n                     // if we did, we'd get a \"multiple matching crates\" error"}, {"sha": "623a763bd7468bd6d2840ac4b18fcc0d12a7dea6", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "patch": "@@ -631,7 +631,7 @@ impl<'a> Context<'a> {\n     }\n \n     fn find_commandline_library(&mut self) -> Option<Library> {\n-        let locs = match self.sess.opts.externs.find_equiv(&self.crate_name) {\n+        let locs = match self.sess.opts.externs.find_equiv(self.crate_name) {\n             Some(s) => s,\n             None => return None,\n         };"}, {"sha": "e6a54c74cd2928f17776000a242cf9289108bda3", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "patch": "@@ -224,7 +224,7 @@ pub fn get_extern_fn(ccx: &CrateContext,\n                      ty: Type,\n                      output: ty::t)\n                      -> ValueRef {\n-    match externs.find_equiv(&name) {\n+    match externs.find_equiv(name) {\n         Some(n) => return *n,\n         None => {}\n     }\n@@ -234,7 +234,7 @@ pub fn get_extern_fn(ccx: &CrateContext,\n }\n \n fn get_extern_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str, did: ast::DefId) -> ValueRef {\n-    match ccx.externs().borrow().find_equiv(&name) {\n+    match ccx.externs().borrow().find_equiv(name) {\n         Some(n) => return *n,\n         None => ()\n     }\n@@ -2999,7 +2999,7 @@ fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<String>) {\n \n                 let name = CString::new(llvm::LLVMGetValueName(val), false);\n                 if !declared.contains(&name) &&\n-                   !reachable.contains_equiv(&name.as_str().unwrap()) {\n+                   !reachable.contains_equiv(name.as_str().unwrap()) {\n                     llvm::SetLinkage(val, llvm::InternalLinkage);\n                 }\n             }"}, {"sha": "3d76d1f5d4da0f112b297f8121e9ed963f675919", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "patch": "@@ -1670,7 +1670,7 @@ fn declare_local(bcx: Block,\n }\n \n fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n-    match debug_context(cx).created_files.borrow().find_equiv(&full_path) {\n+    match debug_context(cx).created_files.borrow().find_equiv(full_path) {\n         Some(file_metadata) => return *file_metadata,\n         None => ()\n     }"}, {"sha": "d8424c9f316b5c0cc7c51d0c00e85d91feeff77c", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "patch": "@@ -333,7 +333,7 @@ impl TypeNames {\n     }\n \n     pub fn find_type(&self, s: &str) -> Option<Type> {\n-        self.named_types.borrow().find_equiv(&s).map(|x| Type::from_ref(*x))\n+        self.named_types.borrow().find_equiv(s).map(|x| Type::from_ref(*x))\n     }\n \n     pub fn type_to_string(&self, ty: Type) -> String {"}, {"sha": "75406eb29a9d68b55d05cfc0fecb3c96176e6c1e", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "patch": "@@ -74,7 +74,7 @@ pub struct FnvHasher;\n pub struct FnvState(u64);\n \n impl Hasher<FnvState> for FnvHasher {\n-    fn hash<T: Hash<FnvState>>(&self, t: &T) -> u64 {\n+    fn hash<Sized? T: Hash<FnvState>>(&self, t: &T) -> u64 {\n         let mut state = FnvState(0xcbf29ce484222325);\n         t.hash(&mut state);\n         let FnvState(ret) = state;"}, {"sha": "d1d9702a134f6fda562e9485918fedd01d28fb6a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "patch": "@@ -2123,7 +2123,7 @@ impl<'a> fmt::Show for Sidebar<'a> {\n \n         fn block(w: &mut fmt::Formatter, short: &str, longty: &str,\n                  cur: &clean::Item, cx: &Context) -> fmt::Result {\n-            let items = match cx.sidebar.find_equiv(&short) {\n+            let items = match cx.sidebar.find_equiv(short) {\n                 Some(items) => items.as_slice(),\n                 None => return Ok(())\n             };"}, {"sha": "881ffd21d710b7c50542fd58052a35ec1244b6a5", "filename": "src/libstd/collections/hashmap/map.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs?ref=1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "patch": "@@ -17,6 +17,7 @@ use default::Default;\n use fmt::{mod, Show};\n use hash::{Hash, Hasher, RandomSipHasher};\n use iter::{mod, Iterator, FromIterator, Extendable};\n+use kinds::Sized;\n use mem::{mod, replace};\n use num;\n use ops::{Deref, Index, IndexMut};\n@@ -419,17 +420,17 @@ impl<K, V, M> SearchResult<K, V, M> {\n }\n \n impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n-    fn make_hash<X: Hash<S>>(&self, x: &X) -> SafeHash {\n+    fn make_hash<Sized? X: Hash<S>>(&self, x: &X) -> SafeHash {\n         table::make_hash(&self.hasher, x)\n     }\n \n-    fn search_equiv<'a, Q: Hash<S> + Equiv<K>>(&'a self, q: &Q)\n+    fn search_equiv<'a, Sized? Q: Hash<S> + Equiv<K>>(&'a self, q: &Q)\n                     -> Option<FullBucketImm<'a, K, V>> {\n         let hash = self.make_hash(q);\n         search_hashed_generic(&self.table, &hash, |k| q.equiv(k)).into_option()\n     }\n \n-    fn search_equiv_mut<'a, Q: Hash<S> + Equiv<K>>(&'a mut self, q: &Q)\n+    fn search_equiv_mut<'a, Sized? Q: Hash<S> + Equiv<K>>(&'a mut self, q: &Q)\n                     -> Option<FullBucketMut<'a, K, V>> {\n         let hash = self.make_hash(q);\n         search_hashed_generic(&mut self.table, &hash, |k| q.equiv(k)).into_option()\n@@ -857,15 +858,15 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// using equivalence.\n     ///\n     /// See [pop_equiv](#method.pop_equiv) for an extended example.\n-    pub fn contains_key_equiv<Q: Hash<S> + Equiv<K>>(&self, key: &Q) -> bool {\n+    pub fn contains_key_equiv<Sized? Q: Hash<S> + Equiv<K>>(&self, key: &Q) -> bool {\n         self.search_equiv(key).is_some()\n     }\n \n     /// Return the value corresponding to the key in the map, using\n     /// equivalence.\n     ///\n     /// See [pop_equiv](#method.pop_equiv) for an extended example.\n-    pub fn find_equiv<'a, Q: Hash<S> + Equiv<K>>(&'a self, k: &Q) -> Option<&'a V> {\n+    pub fn find_equiv<'a, Sized? Q: Hash<S> + Equiv<K>>(&'a self, k: &Q) -> Option<&'a V> {\n         match self.search_equiv(k) {\n             None      => None,\n             Some(bucket) => {\n@@ -921,7 +922,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///\n     /// ```\n     #[experimental]\n-    pub fn pop_equiv<Q:Hash<S> + Equiv<K>>(&mut self, k: &Q) -> Option<V> {\n+    pub fn pop_equiv<Sized? Q:Hash<S> + Equiv<K>>(&mut self, k: &Q) -> Option<V> {\n         if self.table.size() == 0 {\n             return None\n         }\n@@ -1879,11 +1880,11 @@ mod test_map {\n         m.insert(\"baz\".to_string(), baz);\n \n \n-        assert_eq!(m.find_equiv(&(\"foo\")), Some(&foo));\n-        assert_eq!(m.find_equiv(&(\"bar\")), Some(&bar));\n-        assert_eq!(m.find_equiv(&(\"baz\")), Some(&baz));\n+        assert_eq!(m.find_equiv(\"foo\"), Some(&foo));\n+        assert_eq!(m.find_equiv(\"bar\"), Some(&bar));\n+        assert_eq!(m.find_equiv(\"baz\"), Some(&baz));\n \n-        assert_eq!(m.find_equiv(&(\"qux\")), None);\n+        assert_eq!(m.find_equiv(\"qux\"), None);\n     }\n \n     #[test]"}, {"sha": "e4016c703206666bb56007f3f716c73d8289f0d7", "filename": "src/libstd/collections/hashmap/set.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibstd%2Fcollections%2Fhashmap%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibstd%2Fcollections%2Fhashmap%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Fset.rs?ref=1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "patch": "@@ -13,6 +13,7 @@\n use clone::Clone;\n use cmp::{Eq, Equiv, PartialEq};\n use collections::{Collection, Mutable, Set, MutableSet, Map, MutableMap};\n+use core::kinds::Sized;\n use default::Default;\n use fmt::Show;\n use fmt;\n@@ -221,7 +222,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert!(!set.contains_equiv(&EvenOrOdd { num: 2u }));\n     ///\n     /// ```\n-    pub fn contains_equiv<Q: Hash<S> + Equiv<T>>(&self, value: &Q) -> bool {\n+    pub fn contains_equiv<Sized? Q: Hash<S> + Equiv<T>>(&self, value: &Q) -> bool {\n       self.map.contains_key_equiv(value)\n     }\n "}, {"sha": "faff68c75fffb68faeddf3c26bb43e5c29e80879", "filename": "src/libstd/collections/hashmap/table.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibstd%2Fcollections%2Fhashmap%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibstd%2Fcollections%2Fhashmap%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Ftable.rs?ref=1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "patch": "@@ -14,7 +14,7 @@ use clone::Clone;\n use cmp;\n use hash::{Hash, Hasher};\n use iter::{Iterator, count};\n-use kinds::marker;\n+use kinds::{Sized, marker};\n use mem::{min_align_of, size_of};\n use mem;\n use num::{CheckedAdd, CheckedMul, is_power_of_two};\n@@ -131,7 +131,7 @@ impl SafeHash {\n /// We need to remove hashes of 0. That's reserved for empty buckets.\n /// This function wraps up `hash_keyed` to be the only way outside this\n /// module to generate a SafeHash.\n-pub fn make_hash<T: Hash<S>, S, H: Hasher<S>>(hasher: &H, t: &T) -> SafeHash {\n+pub fn make_hash<Sized? T: Hash<S>, S, H: Hasher<S>>(hasher: &H, t: &T) -> SafeHash {\n     match hasher.hash(t) {\n         // This constant is exceedingly likely to hash to the same\n         // bucket, but it won't be counted as empty! Just so we can maintain"}, {"sha": "e4017ea5a47fa8338299f99a5d628d8cf92cd944", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "patch": "@@ -65,6 +65,7 @@\n \n pub use core_collections::hash::{Hash, Hasher, Writer, hash, sip};\n \n+use core::kinds::Sized;\n use default::Default;\n use rand::Rng;\n use rand;\n@@ -91,7 +92,7 @@ impl RandomSipHasher {\n \n impl Hasher<sip::SipState> for RandomSipHasher {\n     #[inline]\n-    fn hash<T: Hash<sip::SipState>>(&self, value: &T) -> u64 {\n+    fn hash<Sized? T: Hash<sip::SipState>>(&self, value: &T) -> u64 {\n         self.hasher.hash(value)\n     }\n }"}, {"sha": "71d82a41f38683e7ae4d7bfb5c19ed0fdf487f11", "filename": "src/libsyntax/diagnostics/registry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibsyntax%2Fdiagnostics%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibsyntax%2Fdiagnostics%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fregistry.rs?ref=1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "patch": "@@ -20,6 +20,6 @@ impl Registry {\n     }\n \n     pub fn find_description(&self, code: &str) -> Option<&'static str> {\n-        self.descriptions.find_equiv(&code).map(|desc| *desc)\n+        self.descriptions.find_equiv(code).map(|desc| *desc)\n     }\n }"}, {"sha": "53d091db095be38c4b409daaf59fa05c12230710", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "patch": "@@ -140,7 +140,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, allow_method: bool,\n             let name = interned_name.get();\n             p.expect(&token::Eq);\n             let e = p.parse_expr();\n-            match names.find_equiv(&name) {\n+            match names.find_equiv(name) {\n                 None => {}\n                 Some(prev) => {\n                     ecx.span_err(e.span,\n@@ -362,7 +362,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 self.ecx.expr_path(path)\n             }\n             parse::CountIsName(n) => {\n-                let i = match self.name_positions.find_equiv(&n) {\n+                let i = match self.name_positions.find_equiv(n) {\n                     Some(&i) => i,\n                     None => 0, // error already emitted elsewhere\n                 };\n@@ -406,7 +406,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     // Named arguments are converted to positional arguments at\n                     // the end of the list of arguments\n                     parse::ArgumentNamed(n) => {\n-                        let i = match self.name_positions.find_equiv(&n) {\n+                        let i = match self.name_positions.find_equiv(n) {\n                             Some(&i) => i,\n                             None => 0, // error already emitted elsewhere\n                         };"}, {"sha": "105118ff76a9dfaf80ccca4135e729b2a18f6cec", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "patch": "@@ -75,7 +75,7 @@ impl<T: Eq + Hash + Clone + 'static> Interner<T> {\n         (*vect).len()\n     }\n \n-    pub fn find_equiv<Q:Hash + Equiv<T>>(&self, val: &Q) -> Option<Name> {\n+    pub fn find_equiv<Sized? Q: Hash + Equiv<T>>(&self, val: &Q) -> Option<Name> {\n         let map = self.map.borrow();\n         match (*map).find_equiv(val) {\n             Some(v) => Some(*v),\n@@ -149,7 +149,7 @@ impl StrInterner {\n \n     pub fn intern(&self, val: &str) -> Name {\n         let mut map = self.map.borrow_mut();\n-        match map.find_equiv(&val) {\n+        match map.find_equiv(val) {\n             Some(&idx) => return idx,\n             None => (),\n         }\n@@ -195,7 +195,7 @@ impl StrInterner {\n         self.vect.borrow().len()\n     }\n \n-    pub fn find_equiv<Q:Hash + Equiv<RcStr>>(&self, val: &Q) -> Option<Name> {\n+    pub fn find_equiv<Sized? Q:Hash + Equiv<RcStr>>(&self, val: &Q) -> Option<Name> {\n         match (*self.map.borrow()).find_equiv(val) {\n             Some(v) => Some(*v),\n             None => None,"}, {"sha": "416be0e70508a1014f440c96738f1662e9096b60", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "patch": "@@ -78,7 +78,7 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n         if self.num_colors > color {\n             let s = expand(self.ti\n                                .strings\n-                               .find_equiv(&(\"setaf\"))\n+                               .find_equiv(\"setaf\")\n                                .unwrap()\n                                .as_slice(),\n                            [Number(color as int)], &mut Variables::new());\n@@ -95,7 +95,7 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n         if self.num_colors > color {\n             let s = expand(self.ti\n                                .strings\n-                               .find_equiv(&(\"setab\"))\n+                               .find_equiv(\"setab\")\n                                .unwrap()\n                                .as_slice(),\n                            [Number(color as int)], &mut Variables::new());\n@@ -113,7 +113,7 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n             attr::BackgroundColor(c) => self.bg(c),\n             _ => {\n                 let cap = cap_for_attr(attr);\n-                let parm = self.ti.strings.find_equiv(&cap);\n+                let parm = self.ti.strings.find_equiv(cap);\n                 if parm.is_some() {\n                     let s = expand(parm.unwrap().as_slice(),\n                                    [],\n@@ -135,19 +135,19 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n             }\n             _ => {\n                 let cap = cap_for_attr(attr);\n-                self.ti.strings.find_equiv(&cap).is_some()\n+                self.ti.strings.find_equiv(cap).is_some()\n             }\n         }\n     }\n \n     fn reset(&mut self) -> IoResult<()> {\n-        let mut cap = self.ti.strings.find_equiv(&(\"sgr0\"));\n+        let mut cap = self.ti.strings.find_equiv(\"sgr0\");\n         if cap.is_none() {\n             // are there any terminals that have color/attrs and not sgr0?\n             // Try falling back to sgr, then op\n-            cap = self.ti.strings.find_equiv(&(\"sgr\"));\n+            cap = self.ti.strings.find_equiv(\"sgr\");\n             if cap.is_none() {\n-                cap = self.ti.strings.find_equiv(&(\"op\"));\n+                cap = self.ti.strings.find_equiv(\"op\");\n             }\n         }\n         let s = cap.map_or(Err(\"can't find terminfo capability `sgr0`\".to_string()), |op| {\n@@ -202,9 +202,9 @@ impl<T: Writer+Send> TerminfoTerminal<T> {\n         }\n \n         let inf = ti.unwrap();\n-        let nc = if inf.strings.find_equiv(&(\"setaf\")).is_some()\n-                 && inf.strings.find_equiv(&(\"setab\")).is_some() {\n-                     inf.numbers.find_equiv(&(\"colors\")).map_or(0, |&n| n)\n+        let nc = if inf.strings.find_equiv(\"setaf\").is_some()\n+                 && inf.strings.find_equiv(\"setab\").is_some() {\n+                     inf.numbers.find_equiv(\"colors\").map_or(0, |&n| n)\n                  } else { 0 };\n \n         return Some(box TerminfoTerminal {out: out,"}, {"sha": "b1cc52791ab8882d787a5bc6b88664e436b7974e", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "patch": "@@ -75,7 +75,7 @@ fn sort_and_fmt(mm: &HashMap<Vec<u8> , uint>, total: uint) -> String {\n // given a map, search for the frequency of a pattern\n fn find(mm: &HashMap<Vec<u8> , uint>, key: String) -> uint {\n    let key = key.into_ascii().as_slice().to_lowercase().into_string();\n-   match mm.find_equiv(&key.as_bytes()) {\n+   match mm.find_equiv(key.as_bytes()) {\n       option::None      => { return 0u; }\n       option::Some(&num) => { return num; }\n    }"}, {"sha": "163cf194a3cc56c66970ce857285af0011757eb8", "filename": "src/test/run-pass/send_str_hashmap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs?ref=1384a43db3a8b1551bfc3c6feb37e2174d4c2ba0", "patch": "@@ -49,10 +49,10 @@ pub fn main() {\n     assert!(!map.insert(Owned(\"cde\".to_string()), c));\n     assert!(!map.insert(Slice(\"def\"), d));\n \n-    assert_eq!(map.find_equiv(&(\"abc\")), Some(&a));\n-    assert_eq!(map.find_equiv(&(\"bcd\")), Some(&b));\n-    assert_eq!(map.find_equiv(&(\"cde\")), Some(&c));\n-    assert_eq!(map.find_equiv(&(\"def\")), Some(&d));\n+    assert_eq!(map.find_equiv(\"abc\"), Some(&a));\n+    assert_eq!(map.find_equiv(\"bcd\"), Some(&b));\n+    assert_eq!(map.find_equiv(\"cde\"), Some(&c));\n+    assert_eq!(map.find_equiv(\"def\"), Some(&d));\n \n     assert_eq!(map.find_equiv(&Slice(\"abc\")), Some(&a));\n     assert_eq!(map.find_equiv(&Slice(\"bcd\")), Some(&b));"}]}