{"sha": "fad04ff60e36e5638b23f5fb5ce3c4598603119f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhZDA0ZmY2MGUzNmU1NjM4YjIzZjVmYjVjZTNjNDU5ODYwMzExOWY=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-05-18T12:08:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-18T12:08:55Z"}, "message": "Rollup merge of #85369 - FabianWolff:issue-84973, r=jackh726\n\nSuggest borrowing if a trait implementation is found for &/&mut <type>\n\nThis pull request fixes #84973 by suggesting to borrow if a trait is not implemented for some type `T`, but it is for `&T` or `&mut T`. For instance:\n```rust\ntrait Ti {}\nimpl<T> Ti for &T {}\nfn foo<T: Ti>(_: T) {}\n\ntrait Tm {}\nimpl<T> Tm for &mut T {}\nfn bar<T: Tm>(_: T) {}\n\nfn main() {\n    let a: i32 = 5;\n    foo(a);\n\n    let b: Box<i32> = Box::new(42);\n    bar(b);\n}\n```\ngives, on current nightly:\n```\nerror[E0277]: the trait bound `i32: Ti` is not satisfied\n  --> t2.rs:11:9\n   |\n3  | fn foo<T: Ti>(_: T) {}\n   |           -- required by this bound in `foo`\n...\n11 |     foo(a);\n   |         ^ the trait `Ti` is not implemented for `i32`\n\nerror[E0277]: the trait bound `Box<i32>: Tm` is not satisfied\n  --> t2.rs:14:9\n   |\n7  | fn bar<T: Tm>(_: T) {}\n   |           -- required by this bound in `bar`\n...\n14 |     bar(b);\n   |         ^ the trait `Tm` is not implemented for `Box<i32>`\n\nerror: aborting due to 2 previous errors\n```\nwhereas with my changes, I get:\n```\nerror[E0277]: the trait bound `i32: Ti` is not satisfied\n  --> t2.rs:11:9\n   |\n3  | fn foo<T: Ti>(_: T) {}\n   |           -- required by this bound in `foo`\n...\n11 |     foo(a);\n   |         ^\n   |         |\n   |         expected an implementor of trait `Ti`\n   |         help: consider borrowing here: `&a`\n\nerror[E0277]: the trait bound `Box<i32>: Tm` is not satisfied\n  --> t2.rs:14:9\n   |\n7  | fn bar<T: Tm>(_: T) {}\n   |           -- required by this bound in `bar`\n...\n14 |     bar(b);\n   |         ^\n   |         |\n   |         expected an implementor of trait `Tm`\n   |         help: consider borrowing mutably here: `&mut b`\n\nerror: aborting due to 2 previous errors\n```\nIn my implementation, I have added a \"blacklist\" to make these suggestions flexible. In particular, suggesting to borrow can interfere with other suggestions, such as to add another trait bound to a generic argument. I have tried to configure this blacklist to cause the least amount of test case failures, i.e. to model the current behavior as closely as possible (I only had to change one existing test case, and this change was quite clearly an improvement).", "tree": {"sha": "8936be1f10edbaaae07a1b3202b0cd90ae78859c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8936be1f10edbaaae07a1b3202b0cd90ae78859c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fad04ff60e36e5638b23f5fb5ce3c4598603119f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgo65YCRBK7hj4Ov3rIwAA0GkIAF/d854aV1BJQUvCGOBNt/fb\nR8m3tLkv2Ke7btNhtubojoPlLI/HyLHs3SvFxsCsWHe8RA8es8TQexupIrTicB9G\nZL9LgCXFk8nGvRYkrSLbOZvrl7uEQcOPtiLTFHm/y+qpw/QxgrMxU27NsQoWT9B6\n6WtLrtP8RcZWm7OdbZF+EgPNofpfcspNuLVQr94Rph7LBJW/F0ytJqlctG6DeNCu\neE42ePSx312yndt6fND0gMqnD/VgsXBgCxAA4Fo0msbpkeOQ6fB7qtgFojSL//KP\nHjbLwY2L2CcK5ecSQRf2BzWvhKwl+g78L0OFp/zH9m+cXFycFB9QIDOdJCq9Dtc=\n=2/iD\n-----END PGP SIGNATURE-----\n", "payload": "tree 8936be1f10edbaaae07a1b3202b0cd90ae78859c\nparent 1bfd987f6911ec463c8d1cc10f80dd77a883d92c\nparent 572bb13ae537b198e7909911bf114d3cbb9f3d8e\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1621339735 +0200\ncommitter GitHub <noreply@github.com> 1621339735 +0200\n\nRollup merge of #85369 - FabianWolff:issue-84973, r=jackh726\n\nSuggest borrowing if a trait implementation is found for &/&mut <type>\n\nThis pull request fixes #84973 by suggesting to borrow if a trait is not implemented for some type `T`, but it is for `&T` or `&mut T`. For instance:\n```rust\ntrait Ti {}\nimpl<T> Ti for &T {}\nfn foo<T: Ti>(_: T) {}\n\ntrait Tm {}\nimpl<T> Tm for &mut T {}\nfn bar<T: Tm>(_: T) {}\n\nfn main() {\n    let a: i32 = 5;\n    foo(a);\n\n    let b: Box<i32> = Box::new(42);\n    bar(b);\n}\n```\ngives, on current nightly:\n```\nerror[E0277]: the trait bound `i32: Ti` is not satisfied\n  --> t2.rs:11:9\n   |\n3  | fn foo<T: Ti>(_: T) {}\n   |           -- required by this bound in `foo`\n...\n11 |     foo(a);\n   |         ^ the trait `Ti` is not implemented for `i32`\n\nerror[E0277]: the trait bound `Box<i32>: Tm` is not satisfied\n  --> t2.rs:14:9\n   |\n7  | fn bar<T: Tm>(_: T) {}\n   |           -- required by this bound in `bar`\n...\n14 |     bar(b);\n   |         ^ the trait `Tm` is not implemented for `Box<i32>`\n\nerror: aborting due to 2 previous errors\n```\nwhereas with my changes, I get:\n```\nerror[E0277]: the trait bound `i32: Ti` is not satisfied\n  --> t2.rs:11:9\n   |\n3  | fn foo<T: Ti>(_: T) {}\n   |           -- required by this bound in `foo`\n...\n11 |     foo(a);\n   |         ^\n   |         |\n   |         expected an implementor of trait `Ti`\n   |         help: consider borrowing here: `&a`\n\nerror[E0277]: the trait bound `Box<i32>: Tm` is not satisfied\n  --> t2.rs:14:9\n   |\n7  | fn bar<T: Tm>(_: T) {}\n   |           -- required by this bound in `bar`\n...\n14 |     bar(b);\n   |         ^\n   |         |\n   |         expected an implementor of trait `Tm`\n   |         help: consider borrowing mutably here: `&mut b`\n\nerror: aborting due to 2 previous errors\n```\nIn my implementation, I have added a \"blacklist\" to make these suggestions flexible. In particular, suggesting to borrow can interfere with other suggestions, such as to add another trait bound to a generic argument. I have tried to configure this blacklist to cause the least amount of test case failures, i.e. to model the current behavior as closely as possible (I only had to change one existing test case, and this change was quite clearly an improvement).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fad04ff60e36e5638b23f5fb5ce3c4598603119f", "html_url": "https://github.com/rust-lang/rust/commit/fad04ff60e36e5638b23f5fb5ce3c4598603119f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fad04ff60e36e5638b23f5fb5ce3c4598603119f/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bfd987f6911ec463c8d1cc10f80dd77a883d92c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bfd987f6911ec463c8d1cc10f80dd77a883d92c", "html_url": "https://github.com/rust-lang/rust/commit/1bfd987f6911ec463c8d1cc10f80dd77a883d92c"}, {"sha": "572bb13ae537b198e7909911bf114d3cbb9f3d8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/572bb13ae537b198e7909911bf114d3cbb9f3d8e", "html_url": "https://github.com/rust-lang/rust/commit/572bb13ae537b198e7909911bf114d3cbb9f3d8e"}], "stats": {"total": 294, "additions": 277, "deletions": 17}, "files": [{"sha": "8bbd2da5375130f432ce85e73d8e0f6d8f09adf9", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 68, "deletions": 13, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/fad04ff60e36e5638b23f5fb5ce3c4598603119f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad04ff60e36e5638b23f5fb5ce3c4598603119f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=fad04ff60e36e5638b23f5fb5ce3c4598603119f", "patch": "@@ -686,17 +686,36 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             return false;\n         }\n \n+        // Blacklist traits for which it would be nonsensical to suggest borrowing.\n+        // For instance, immutable references are always Copy, so suggesting to\n+        // borrow would always succeed, but it's probably not what the user wanted.\n+        let blacklist: Vec<_> =\n+            [LangItem::Copy, LangItem::Clone, LangItem::Unpin, LangItem::Sized, LangItem::Send]\n+                .iter()\n+                .filter_map(|lang_item| self.tcx.lang_items().require(*lang_item).ok())\n+                .collect();\n+\n         let span = obligation.cause.span;\n         let param_env = obligation.param_env;\n         let trait_ref = trait_ref.skip_binder();\n \n-        if let ObligationCauseCode::ImplDerivedObligation(obligation) = &obligation.cause.code {\n-            // Try to apply the original trait binding obligation by borrowing.\n-            let self_ty = trait_ref.self_ty();\n-            let found = self_ty.to_string();\n-            let new_self_ty = self.tcx.mk_imm_ref(self.tcx.lifetimes.re_static, self_ty);\n-            let substs = self.tcx.mk_substs_trait(new_self_ty, &[]);\n-            let new_trait_ref = ty::TraitRef::new(obligation.parent_trait_ref.def_id(), substs);\n+        let found_ty = trait_ref.self_ty();\n+        let found_ty_str = found_ty.to_string();\n+        let imm_borrowed_found_ty = self.tcx.mk_imm_ref(self.tcx.lifetimes.re_static, found_ty);\n+        let imm_substs = self.tcx.mk_substs_trait(imm_borrowed_found_ty, &[]);\n+        let mut_borrowed_found_ty = self.tcx.mk_mut_ref(self.tcx.lifetimes.re_static, found_ty);\n+        let mut_substs = self.tcx.mk_substs_trait(mut_borrowed_found_ty, &[]);\n+\n+        // Try to apply the original trait binding obligation by borrowing.\n+        let mut try_borrowing = |new_trait_ref: ty::TraitRef<'tcx>,\n+                                 expected_trait_ref: ty::TraitRef<'tcx>,\n+                                 mtbl: bool,\n+                                 blacklist: &[DefId]|\n+         -> bool {\n+            if blacklist.contains(&expected_trait_ref.def_id) {\n+                return false;\n+            }\n+\n             let new_obligation = Obligation::new(\n                 ObligationCause::dummy(),\n                 param_env,\n@@ -713,8 +732,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n                     let msg = format!(\n                         \"the trait bound `{}: {}` is not satisfied\",\n-                        found,\n-                        obligation.parent_trait_ref.skip_binder().print_only_trait_path(),\n+                        found_ty_str,\n+                        expected_trait_ref.print_only_trait_path(),\n                     );\n                     if has_custom_message {\n                         err.note(&msg);\n@@ -730,7 +749,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         span,\n                         &format!(\n                             \"expected an implementor of trait `{}`\",\n-                            obligation.parent_trait_ref.skip_binder().print_only_trait_path(),\n+                            expected_trait_ref.print_only_trait_path(),\n                         ),\n                     );\n \n@@ -745,16 +764,52 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n                         err.span_suggestion(\n                             span,\n-                            \"consider borrowing here\",\n-                            format!(\"&{}\", snippet),\n+                            &format!(\n+                                \"consider{} borrowing here\",\n+                                if mtbl { \" mutably\" } else { \"\" }\n+                            ),\n+                            format!(\"&{}{}\", if mtbl { \"mut \" } else { \"\" }, snippet),\n                             Applicability::MaybeIncorrect,\n                         );\n                     }\n                     return true;\n                 }\n             }\n+            return false;\n+        };\n+\n+        if let ObligationCauseCode::ImplDerivedObligation(obligation) = &obligation.cause.code {\n+            let expected_trait_ref = obligation.parent_trait_ref.skip_binder();\n+            let new_imm_trait_ref =\n+                ty::TraitRef::new(obligation.parent_trait_ref.def_id(), imm_substs);\n+            let new_mut_trait_ref =\n+                ty::TraitRef::new(obligation.parent_trait_ref.def_id(), mut_substs);\n+            if try_borrowing(new_imm_trait_ref, expected_trait_ref, false, &[]) {\n+                return true;\n+            } else {\n+                return try_borrowing(new_mut_trait_ref, expected_trait_ref, true, &[]);\n+            }\n+        } else if let ObligationCauseCode::BindingObligation(_, _)\n+        | ObligationCauseCode::ItemObligation(_) = &obligation.cause.code\n+        {\n+            if try_borrowing(\n+                ty::TraitRef::new(trait_ref.def_id, imm_substs),\n+                trait_ref,\n+                false,\n+                &blacklist[..],\n+            ) {\n+                return true;\n+            } else {\n+                return try_borrowing(\n+                    ty::TraitRef::new(trait_ref.def_id, mut_substs),\n+                    trait_ref,\n+                    true,\n+                    &blacklist[..],\n+                );\n+            }\n+        } else {\n+            false\n         }\n-        false\n     }\n \n     /// Whenever references are used by mistake, like `for (i, e) in &vec.iter().enumerate()`,"}, {"sha": "bd060c92cd4699f3c8872bd3d7350a62d74180f6", "filename": "src/test/ui/suggestions/imm-ref-trait-object-literal.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fad04ff60e36e5638b23f5fb5ce3c4598603119f/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fad04ff60e36e5638b23f5fb5ce3c4598603119f/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal.stderr?ref=fad04ff60e36e5638b23f5fb5ce3c4598603119f", "patch": "@@ -21,10 +21,10 @@ LL | fn foo<X: Trait>(_: X) {}\n    |           ----- required by this bound in `foo`\n ...\n LL |   foo(s);\n-   |       ^ the trait `Trait` is not implemented for `S`\n-   |\n-   = help: the following implementations were found:\n-             <&'a mut S as Trait>\n+   |       ^\n+   |       |\n+   |       expected an implementor of trait `Trait`\n+   |       help: consider mutably borrowing here: `&mut s`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "050cf8c64b361eaa2438e11c34b003abeae65667", "filename": "src/test/ui/suggestions/issue-84973-2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fad04ff60e36e5638b23f5fb5ce3c4598603119f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad04ff60e36e5638b23f5fb5ce3c4598603119f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-2.rs?ref=fad04ff60e36e5638b23f5fb5ce3c4598603119f", "patch": "@@ -0,0 +1,13 @@\n+// A slight variation of issue-84973.rs. Here, a mutable borrow is\n+// required (and the obligation kind is different).\n+\n+trait Tr {}\n+impl Tr for &mut i32 {}\n+\n+fn foo<T: Tr>(i: T) {}\n+\n+fn main() {\n+    let a: i32 = 32;\n+    foo(a);\n+    //~^ ERROR: the trait bound `i32: Tr` is not satisfied [E0277]\n+}"}, {"sha": "b6ed437b5eefd7f71493222d1f65d8b9b5fe7fd8", "filename": "src/test/ui/suggestions/issue-84973-2.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fad04ff60e36e5638b23f5fb5ce3c4598603119f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fad04ff60e36e5638b23f5fb5ce3c4598603119f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-2.stderr?ref=fad04ff60e36e5638b23f5fb5ce3c4598603119f", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `i32: Tr` is not satisfied\n+  --> $DIR/issue-84973-2.rs:11:9\n+   |\n+LL | fn foo<T: Tr>(i: T) {}\n+   |           -- required by this bound in `foo`\n+...\n+LL |     foo(a);\n+   |         ^\n+   |         |\n+   |         expected an implementor of trait `Tr`\n+   |         help: consider mutably borrowing here: `&mut a`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "db954530b1bebe34acb5cb34ac2de3a2146e5880", "filename": "src/test/ui/suggestions/issue-84973-blacklist.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fad04ff60e36e5638b23f5fb5ce3c4598603119f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-blacklist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad04ff60e36e5638b23f5fb5ce3c4598603119f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-blacklist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-blacklist.rs?ref=fad04ff60e36e5638b23f5fb5ce3c4598603119f", "patch": "@@ -0,0 +1,29 @@\n+// Checks that certain traits for which we don't want to suggest borrowing\n+// are blacklisted and don't cause the suggestion to be issued.\n+\n+#![feature(generators)]\n+\n+fn f_copy<T: Copy>(t: T) {}\n+fn f_clone<T: Clone>(t: T) {}\n+fn f_unpin<T: Unpin>(t: T) {}\n+fn f_sized<T: Sized>(t: T) {}\n+fn f_send<T: Send>(t: T) {}\n+\n+struct S;\n+\n+fn main() {\n+    f_copy(\"\".to_string()); //~ ERROR: the trait bound `String: Copy` is not satisfied [E0277]\n+    f_clone(S); //~ ERROR: the trait bound `S: Clone` is not satisfied [E0277]\n+    f_unpin(static || { yield; });\n+    //~^ ERROR: cannot be unpinned [E0277]\n+\n+    let cl = || ();\n+    let ref_cl: &dyn Fn() -> () = &cl;\n+    f_sized(*ref_cl);\n+    //~^ ERROR: the size for values of type `dyn Fn()` cannot be known at compilation time [E0277]\n+    //~| ERROR: the size for values of type `dyn Fn()` cannot be known at compilation time [E0277]\n+\n+    use std::rc::Rc;\n+    let rc = Rc::new(0);\n+    f_send(rc); //~ ERROR: `Rc<{integer}>` cannot be sent between threads safely [E0277]\n+}"}, {"sha": "f1e6ef883ae904e964a384de5cac221d467d30d0", "filename": "src/test/ui/suggestions/issue-84973-blacklist.stderr", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/fad04ff60e36e5638b23f5fb5ce3c4598603119f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-blacklist.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fad04ff60e36e5638b23f5fb5ce3c4598603119f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-blacklist.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-blacklist.stderr?ref=fad04ff60e36e5638b23f5fb5ce3c4598603119f", "patch": "@@ -0,0 +1,64 @@\n+error[E0277]: the trait bound `String: Copy` is not satisfied\n+  --> $DIR/issue-84973-blacklist.rs:15:12\n+   |\n+LL | fn f_copy<T: Copy>(t: T) {}\n+   |              ---- required by this bound in `f_copy`\n+...\n+LL |     f_copy(\"\".to_string());\n+   |            ^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `String`\n+\n+error[E0277]: the trait bound `S: Clone` is not satisfied\n+  --> $DIR/issue-84973-blacklist.rs:16:13\n+   |\n+LL | fn f_clone<T: Clone>(t: T) {}\n+   |               ----- required by this bound in `f_clone`\n+...\n+LL |     f_clone(S);\n+   |             ^ the trait `Clone` is not implemented for `S`\n+\n+error[E0277]: `[static generator@$DIR/issue-84973-blacklist.rs:17:13: 17:33]` cannot be unpinned\n+  --> $DIR/issue-84973-blacklist.rs:17:5\n+   |\n+LL | fn f_unpin<T: Unpin>(t: T) {}\n+   |               ----- required by this bound in `f_unpin`\n+...\n+LL |     f_unpin(static || { yield; });\n+   |     ^^^^^^^ the trait `Unpin` is not implemented for `[static generator@$DIR/issue-84973-blacklist.rs:17:13: 17:33]`\n+   |\n+   = note: consider using `Box::pin`\n+\n+error[E0277]: the size for values of type `dyn Fn()` cannot be known at compilation time\n+  --> $DIR/issue-84973-blacklist.rs:22:13\n+   |\n+LL | fn f_sized<T: Sized>(t: T) {}\n+   |            - required by this bound in `f_sized`\n+...\n+LL |     f_sized(*ref_cl);\n+   |             ^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `Sized` is not implemented for `dyn Fn()`\n+\n+error[E0277]: `Rc<{integer}>` cannot be sent between threads safely\n+  --> $DIR/issue-84973-blacklist.rs:28:12\n+   |\n+LL | fn f_send<T: Send>(t: T) {}\n+   |              ---- required by this bound in `f_send`\n+...\n+LL |     f_send(rc);\n+   |            ^^ `Rc<{integer}>` cannot be sent between threads safely\n+   |\n+   = help: the trait `Send` is not implemented for `Rc<{integer}>`\n+\n+error[E0277]: the size for values of type `dyn Fn()` cannot be known at compilation time\n+  --> $DIR/issue-84973-blacklist.rs:22:5\n+   |\n+LL |     f_sized(*ref_cl);\n+   |     ^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `Sized` is not implemented for `dyn Fn()`\n+   = note: all function arguments must have a statically known size\n+   = help: unsized fn params are gated as an unstable feature\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "f339251e57dabd49ab830695553153409f4719a8", "filename": "src/test/ui/suggestions/issue-84973-negative.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fad04ff60e36e5638b23f5fb5ce3c4598603119f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-negative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad04ff60e36e5638b23f5fb5ce3c4598603119f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-negative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-negative.rs?ref=fad04ff60e36e5638b23f5fb5ce3c4598603119f", "patch": "@@ -0,0 +1,12 @@\n+// Checks that we only suggest borrowing if &T actually implements the trait.\n+\n+trait Tr {}\n+impl Tr for &f32 {}\n+fn bar<T: Tr>(t: T) {}\n+\n+fn main() {\n+    let a = 0i32;\n+    let b = 0.0f32;\n+    bar(a); //~ ERROR: the trait bound `i32: Tr` is not satisfied [E0277]\n+    bar(b); //~ ERROR: the trait bound `f32: Tr` is not satisfied [E0277]\n+}"}, {"sha": "94513eca0bf0994077ee5530cb8650f308e2f264", "filename": "src/test/ui/suggestions/issue-84973-negative.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fad04ff60e36e5638b23f5fb5ce3c4598603119f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-negative.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fad04ff60e36e5638b23f5fb5ce3c4598603119f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-negative.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-negative.stderr?ref=fad04ff60e36e5638b23f5fb5ce3c4598603119f", "patch": "@@ -0,0 +1,24 @@\n+error[E0277]: the trait bound `i32: Tr` is not satisfied\n+  --> $DIR/issue-84973-negative.rs:10:9\n+   |\n+LL | fn bar<T: Tr>(t: T) {}\n+   |           -- required by this bound in `bar`\n+...\n+LL |     bar(a);\n+   |         ^ the trait `Tr` is not implemented for `i32`\n+\n+error[E0277]: the trait bound `f32: Tr` is not satisfied\n+  --> $DIR/issue-84973-negative.rs:11:9\n+   |\n+LL | fn bar<T: Tr>(t: T) {}\n+   |           -- required by this bound in `bar`\n+...\n+LL |     bar(b);\n+   |         ^\n+   |         |\n+   |         expected an implementor of trait `Tr`\n+   |         help: consider borrowing here: `&b`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "42468478ed9a24214ccbad6f3986a054b14dae79", "filename": "src/test/ui/suggestions/issue-84973.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fad04ff60e36e5638b23f5fb5ce3c4598603119f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad04ff60e36e5638b23f5fb5ce3c4598603119f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973.rs?ref=fad04ff60e36e5638b23f5fb5ce3c4598603119f", "patch": "@@ -0,0 +1,33 @@\n+// Checks whether borrowing is suggested when a trait bound is not satisfied\n+// for found type `T`, but is for `&/&mut T`.\n+\n+fn main() {\n+    let f = Fancy{};\n+    let o = Other::new(f);\n+    //~^ ERROR: the trait bound `Fancy: SomeTrait` is not satisfied [E0277]\n+}\n+\n+struct Fancy {}\n+\n+impl <'a> SomeTrait for &'a Fancy {\n+}\n+\n+trait SomeTrait {}\n+\n+struct Other<'a, G> {\n+    a: &'a str,\n+    g: G,\n+}\n+\n+// Broadly copied from https://docs.rs/petgraph/0.5.1/src/petgraph/dot.rs.html#70\n+impl<'a, G> Other<'a, G>\n+where\n+    G: SomeTrait,\n+{\n+    pub fn new(g: G) -> Self {\n+        Other {\n+            a: \"hi\",\n+            g: g,\n+        }\n+    }\n+}"}, {"sha": "49fa94da8592304a44ae8fbc25a62c1220b94067", "filename": "src/test/ui/suggestions/issue-84973.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fad04ff60e36e5638b23f5fb5ce3c4598603119f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fad04ff60e36e5638b23f5fb5ce3c4598603119f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973.stderr?ref=fad04ff60e36e5638b23f5fb5ce3c4598603119f", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `Fancy: SomeTrait` is not satisfied\n+  --> $DIR/issue-84973.rs:6:24\n+   |\n+LL |     let o = Other::new(f);\n+   |                        ^\n+   |                        |\n+   |                        expected an implementor of trait `SomeTrait`\n+   |                        help: consider borrowing here: `&f`\n+...\n+LL |     pub fn new(g: G) -> Self {\n+   |     ------------------------ required by `Other::<'a, G>::new`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}