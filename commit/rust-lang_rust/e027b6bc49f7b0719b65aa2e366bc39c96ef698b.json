{"sha": "e027b6bc49f7b0719b65aa2e366bc39c96ef698b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwMjdiNmJjNDlmN2IwNzE5YjY1YWEyZTM2NmJjMzljOTZlZjY5OGI=", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-05-04T15:35:54Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-05-24T14:30:52Z"}, "message": "Minor SpanlessHash improvements", "tree": {"sha": "08b55bcfe231241bf4d2737444777acc56b3cdcc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08b55bcfe231241bf4d2737444777acc56b3cdcc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e027b6bc49f7b0719b65aa2e366bc39c96ef698b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e027b6bc49f7b0719b65aa2e366bc39c96ef698b", "html_url": "https://github.com/rust-lang/rust/commit/e027b6bc49f7b0719b65aa2e366bc39c96ef698b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e027b6bc49f7b0719b65aa2e366bc39c96ef698b/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c25f4b4434fd269a5a903dea6cc14035551b7274", "url": "https://api.github.com/repos/rust-lang/rust/commits/c25f4b4434fd269a5a903dea6cc14035551b7274", "html_url": "https://github.com/rust-lang/rust/commit/c25f4b4434fd269a5a903dea6cc14035551b7274"}], "stats": {"total": 59, "additions": 12, "deletions": 47}, "files": [{"sha": "84dceb9a16581479414ee5b6d7549d4e9bb1fedc", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 12, "deletions": 47, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/e027b6bc49f7b0719b65aa2e366bc39c96ef698b/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e027b6bc49f7b0719b65aa2e366bc39c96ef698b/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=e027b6bc49f7b0719b65aa2e366bc39c96ef698b", "patch": "@@ -6,9 +6,9 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def::Res;\n use rustc_hir::HirIdMap;\n use rustc_hir::{\n-    BinOpKind, Block, BlockCheckMode, BodyId, BorrowKind, CaptureBy, Expr, ExprField, ExprKind, FnRetTy, GenericArg,\n-    GenericArgs, Guard, HirId, InlineAsmOperand, Lifetime, LifetimeName, ParamName, Pat, PatField, PatKind, Path,\n-    PathSegment, QPath, Stmt, StmtKind, Ty, TyKind, TypeBinding,\n+    BinOpKind, Block, BodyId, Expr, ExprField, ExprKind, FnRetTy, GenericArg, GenericArgs, Guard, HirId,\n+    InlineAsmOperand, Lifetime, LifetimeName, ParamName, Pat, PatField, PatKind, Path, PathSegment, QPath, Stmt,\n+    StmtKind, Ty, TyKind, TypeBinding,\n };\n use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::LateContext;\n@@ -537,13 +537,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n             self.hash_expr(e);\n         }\n \n-        match b.rules {\n-            BlockCheckMode::DefaultBlock => 0,\n-            BlockCheckMode::UnsafeBlock(_) => 1,\n-            BlockCheckMode::PushUnsafeBlock(_) => 2,\n-            BlockCheckMode::PopUnsafeBlock(_) => 3,\n-        }\n-        .hash(&mut self.s);\n+        std::mem::discriminant(&b.rules).hash(&mut self.s);\n     }\n \n     #[allow(clippy::many_single_char_names, clippy::too_many_lines)]\n@@ -554,21 +548,16 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n \n         // const hashing may result in the same hash as some unrelated node, so add a sort of\n         // discriminant depending on which path we're choosing next\n-        simple_const.is_some().hash(&mut self.s);\n-\n-        if let Some(e) = simple_const {\n-            return e.hash(&mut self.s);\n+        simple_const.hash(&mut self.s);\n+        if simple_const.is_some() {\n+            return;\n         }\n \n         std::mem::discriminant(&e.kind).hash(&mut self.s);\n \n         match e.kind {\n             ExprKind::AddrOf(kind, m, e) => {\n-                match kind {\n-                    BorrowKind::Ref => 0,\n-                    BorrowKind::Raw => 1,\n-                }\n-                .hash(&mut self.s);\n+                std::mem::discriminant(&kind).hash(&mut self.s);\n                 m.hash(&mut self.s);\n                 self.hash_expr(e);\n             },\n@@ -616,11 +605,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 self.hash_ty(ty);\n             },\n             ExprKind::Closure(cap, _, eid, _, _) => {\n-                match cap {\n-                    CaptureBy::Value => 0,\n-                    CaptureBy::Ref => 1,\n-                }\n-                .hash(&mut self.s);\n+                std::mem::discriminant(&cap).hash(&mut self.s);\n                 // closures inherit TypeckResults\n                 self.hash_expr(&self.cx.tcx.hir().body(eid).value);\n             },\n@@ -694,8 +679,6 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 }\n             },\n             ExprKind::If(cond, then, ref else_opt) => {\n-                let c: fn(_, _, _) -> _ = ExprKind::If;\n-                c.hash(&mut self.s);\n                 self.hash_expr(cond);\n                 self.hash_expr(then);\n                 if let Some(e) = *else_opt {\n@@ -928,10 +911,9 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 for arg in bfn.decl.inputs {\n                     self.hash_ty(arg);\n                 }\n+                std::mem::discriminant(&bfn.decl.output).hash(&mut self.s);\n                 match bfn.decl.output {\n-                    FnRetTy::DefaultReturn(_) => {\n-                        ().hash(&mut self.s);\n-                    },\n+                    FnRetTy::DefaultReturn(_) => {},\n                     FnRetTy::Return(ty) => {\n                         self.hash_ty(ty);\n                     },\n@@ -943,24 +925,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                     self.hash_ty(ty);\n                 }\n             },\n-            TyKind::Path(ref qpath) => match qpath {\n-                QPath::Resolved(ref maybe_ty, path) => {\n-                    if let Some(ty) = maybe_ty {\n-                        self.hash_ty(ty);\n-                    }\n-                    for segment in path.segments {\n-                        segment.ident.name.hash(&mut self.s);\n-                        self.hash_generic_args(segment.args().args);\n-                    }\n-                },\n-                QPath::TypeRelative(ty, segment) => {\n-                    self.hash_ty(ty);\n-                    segment.ident.name.hash(&mut self.s);\n-                },\n-                QPath::LangItem(lang_item, ..) => {\n-                    lang_item.hash(&mut self.s);\n-                },\n-            },\n+            TyKind::Path(ref qpath) => self.hash_qpath(qpath),\n             TyKind::OpaqueDef(_, arg_list) => {\n                 self.hash_generic_args(arg_list);\n             },"}]}