{"sha": "dd66e7549b72575d5d7e06c0173e702e28cdfba7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkNjZlNzU0OWI3MjU3NWQ1ZDdlMDZjMDE3M2U3MDJlMjhjZGZiYTc=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-18T19:20:18Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-22T16:20:37Z"}, "message": "Preliminary support for labeled break/continue for `loop`s\n\nThis patch adds preliminary middle-end support (liveness and trans)\nfor breaks and `loop`s to `loop` constructs that have labels.\n\nwhile and for loops can't have labels yet.\n\nProgress on #2216", "tree": {"sha": "b3ce10fb564b8b5fb4dc4af73bd380e6b39d32dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3ce10fb564b8b5fb4dc4af73bd380e6b39d32dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd66e7549b72575d5d7e06c0173e702e28cdfba7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd66e7549b72575d5d7e06c0173e702e28cdfba7", "html_url": "https://github.com/rust-lang/rust/commit/dd66e7549b72575d5d7e06c0173e702e28cdfba7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd66e7549b72575d5d7e06c0173e702e28cdfba7/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46d4bbbae4e52b79c23136b926c1e3b1f187ce4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/46d4bbbae4e52b79c23136b926c1e3b1f187ce4b", "html_url": "https://github.com/rust-lang/rust/commit/46d4bbbae4e52b79c23136b926c1e3b1f187ce4b"}], "stats": {"total": 330, "additions": 232, "deletions": 98}, "files": [{"sha": "33915c8c0c93139aaecdabcc2bf19a1b506c44ce", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dd66e7549b72575d5d7e06c0173e702e28cdfba7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd66e7549b72575d5d7e06c0173e702e28cdfba7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=dd66e7549b72575d5d7e06c0173e702e28cdfba7", "patch": "@@ -1180,7 +1180,10 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n       ast::expr_loop(blk, opt_ident) => {\n         head(s, ~\"loop\");\n         space(s.s);\n-        opt_ident.iter(|ident| {print_ident(s, *ident); space(s.s)});\n+        opt_ident.iter(|ident| {\n+            print_ident(s, *ident);\n+            word_space(s, ~\":\");\n+        });\n         print_block(s, blk);\n       }\n       ast::expr_match(expr, arms) => {"}, {"sha": "184d694a50c5c507e7a0515a58ee19db3420a853", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 136, "deletions": 56, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/dd66e7549b72575d5d7e06c0173e702e28cdfba7/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd66e7549b72575d5d7e06c0173e702e28cdfba7/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=dd66e7549b72575d5d7e06c0173e702e28cdfba7", "patch": "@@ -95,9 +95,9 @@\n use dvec::DVec;\n use std::map::HashMap;\n use syntax::{visit, ast_util};\n-use syntax::print::pprust::{expr_to_str};\n+use syntax::print::pprust::{expr_to_str, block_to_str};\n use visit::vt;\n-use syntax::codemap::span;\n+use syntax::codemap::{span, span_to_str};\n use syntax::ast::*;\n use io::WriterUtil;\n use capture::{cap_move, cap_drop, cap_copy, cap_ref};\n@@ -167,6 +167,16 @@ impl LiveNodeKind : cmp::Eq {\n     pure fn ne(other: &LiveNodeKind) -> bool { !self.eq(other) }\n }\n \n+fn live_node_kind_to_str(lnk: LiveNodeKind, cx: ty::ctxt) -> ~str {\n+    let cm = cx.sess.codemap;\n+    match lnk {\n+        FreeVarNode(s) => fmt!(\"Free var node [%s]\", span_to_str(s, cm)),\n+        ExprNode(s)    => fmt!(\"Expr node [%s]\", span_to_str(s, cm)),\n+        VarDefNode(s)  => fmt!(\"Var def node [%s]\", span_to_str(s, cm)),\n+        ExitNode       => ~\"Exit node\"\n+    }\n+}\n+\n fn check_crate(tcx: ty::ctxt,\n                method_map: typeck::method_map,\n                crate: @crate) -> last_use_map {\n@@ -277,8 +287,8 @@ fn IrMaps(tcx: ty::ctxt, method_map: typeck::method_map,\n         tcx: tcx,\n         method_map: method_map,\n         last_use_map: last_use_map,\n-        num_live_nodes: 0u,\n-        num_vars: 0u,\n+        num_live_nodes: 0,\n+        num_vars: 0,\n         live_node_map: HashMap(),\n         variable_map: HashMap(),\n         capture_map: HashMap(),\n@@ -291,9 +301,10 @@ impl IrMaps {\n     fn add_live_node(lnk: LiveNodeKind) -> LiveNode {\n         let ln = LiveNode(self.num_live_nodes);\n         self.lnks.push(lnk);\n-        self.num_live_nodes += 1u;\n+        self.num_live_nodes += 1;\n \n-        debug!(\"%s is of kind %?\", ln.to_str(), lnk);\n+        debug!(\"%s is of kind %s\", ln.to_str(),\n+               live_node_kind_to_str(lnk, self.tcx));\n \n         ln\n     }\n@@ -308,7 +319,7 @@ impl IrMaps {\n     fn add_variable(vk: VarKind) -> Variable {\n         let v = Variable(self.num_vars);\n         self.var_kinds.push(vk);\n-        self.num_vars += 1u;\n+        self.num_vars += 1;\n \n         match vk {\n             Local(LocalInfo {id:node_id, _}) |\n@@ -491,6 +502,10 @@ fn visit_expr(expr: @expr, &&self: @IrMaps, vt: vt<@IrMaps>) {\n       }\n       expr_fn(_, _, _, cap_clause) |\n       expr_fn_block(_, _, cap_clause) => {\n+          // Interesting control flow (for loops can contain labeled\n+          // breaks or continues)\n+          self.add_live_node_for_node(expr.id, ExprNode(expr.span));\n+\n         // Make a live_node for each captured variable, with the span\n         // being the location that the variable is used.  This results\n         // in better error messages than just pointing at the closure\n@@ -571,14 +586,22 @@ const ACC_READ: uint = 1u;\n const ACC_WRITE: uint = 2u;\n const ACC_USE: uint = 4u;\n \n+type LiveNodeMap = HashMap<node_id, LiveNode>;\n+\n struct Liveness {\n     tcx: ty::ctxt,\n     ir: @IrMaps,\n     s: Specials,\n     successors: ~[mut LiveNode],\n     users: ~[mut users],\n-    mut break_ln: LiveNode,\n-    mut cont_ln: LiveNode,\n+    // The list of node IDs for the nested loop scopes\n+    // we're in.\n+    mut loop_scope: @DVec<node_id>,\n+    // mappings from loop node ID to LiveNode\n+    // (\"break\" label should map to loop node ID,\n+    // it probably doesn't now)\n+    break_ln: LiveNodeMap,\n+    cont_ln: LiveNodeMap\n }\n \n fn Liveness(ir: @IrMaps, specials: Specials) -> Liveness {\n@@ -594,8 +617,9 @@ fn Liveness(ir: @IrMaps, specials: Specials) -> Liveness {\n             vec::to_mut(\n                 vec::from_elem(ir.num_live_nodes * ir.num_vars,\n                                invalid_users())),\n-        break_ln: invalid_node(),\n-        cont_ln: invalid_node()\n+        loop_scope: @DVec(),\n+        break_ln: HashMap(),\n+        cont_ln: HashMap()\n     }\n }\n \n@@ -691,6 +715,9 @@ impl Liveness {\n         if reader.is_valid() {Some((*self.ir).lnk(reader))} else {None}\n     }\n \n+    /*\n+    Is this variable live on entry to any of its successor nodes?\n+    */\n     fn live_on_exit(ln: LiveNode, var: Variable)\n         -> Option<LiveNodeKind> {\n \n@@ -717,8 +744,8 @@ impl Liveness {\n     }\n \n     fn indices(ln: LiveNode, op: fn(uint)) {\n-        let node_base_idx = self.idx(ln, Variable(0u));\n-        for uint::range(0u, self.ir.num_vars) |var_idx| {\n+        let node_base_idx = self.idx(ln, Variable(0));\n+        for uint::range(0, self.ir.num_vars) |var_idx| {\n             op(node_base_idx + var_idx)\n         }\n     }\n@@ -735,8 +762,8 @@ impl Liveness {\n     fn write_vars(wr: io::Writer,\n                   ln: LiveNode,\n                   test: fn(uint) -> LiveNode) {\n-        let node_base_idx = self.idx(ln, Variable(0u));\n-        for uint::range(0u, self.ir.num_vars) |var_idx| {\n+        let node_base_idx = self.idx(ln, Variable(0));\n+        for uint::range(0, self.ir.num_vars) |var_idx| {\n             let idx = node_base_idx + var_idx;\n             if test(idx).is_valid() {\n                 wr.write_str(~\" \");\n@@ -745,6 +772,28 @@ impl Liveness {\n         }\n     }\n \n+    fn find_loop_scope(opt_label: Option<ident>, id: node_id, sp: span)\n+        -> node_id {\n+        match opt_label {\n+            Some(_) => // Refers to a labeled loop. Use the results of resolve\n+                      // to find with one\n+                match self.tcx.def_map.find(id) {\n+                  Some(def_label(loop_id)) => loop_id,\n+                  _ => self.tcx.sess.span_bug(sp, ~\"Label on break/loop \\\n+                                                 doesn't refer to a loop\")\n+            },\n+            None =>\n+                // Vanilla 'break' or 'loop', so use the enclosing\n+                // loop scope\n+                if self.loop_scope.len() == 0 {\n+                    self.tcx.sess.span_bug(sp, ~\"break outside loop\");\n+                }\n+                else {\n+                    self.loop_scope.last()\n+                }\n+        }\n+    }\n+\n     fn ln_str(ln: LiveNode) -> ~str {\n         do io::with_str_writer |wr| {\n             wr.write_str(~\"[ln(\");\n@@ -833,18 +882,18 @@ impl Liveness {\n         let idx = self.idx(ln, var);\n         let user = &mut self.users[idx];\n \n-        if (acc & ACC_WRITE) != 0u {\n+        if (acc & ACC_WRITE) != 0 {\n             user.reader = invalid_node();\n             user.writer = ln;\n         }\n \n         // Important: if we both read/write, must do read second\n         // or else the write will override.\n-        if (acc & ACC_READ) != 0u {\n+        if (acc & ACC_READ) != 0 {\n             user.reader = ln;\n         }\n \n-        if (acc & ACC_USE) != 0u {\n+        if (acc & ACC_USE) != 0 {\n             self.users[idx].used = true;\n         }\n \n@@ -858,10 +907,13 @@ impl Liveness {\n         // if there is a `break` or `again` at the top level, then it's\n         // effectively a return---this only occurs in `for` loops,\n         // where the body is really a closure.\n+\n+        debug!(\"compute: using id for block, %s\", block_to_str(body,\n+                      self.tcx.sess.intr()));\n+\n         let entry_ln: LiveNode =\n-            self.with_loop_nodes(self.s.exit_ln, self.s.exit_ln, || {\n-                self.propagate_through_fn_block(decl, body)\n-            });\n+            self.with_loop_nodes(body.node.id, self.s.exit_ln, self.s.exit_ln,\n+              || { self.propagate_through_fn_block(decl, body) });\n \n         // hack to skip the loop unless debug! is enabled:\n         debug!(\"^^ liveness computation results for body %d (entry=%s)\",\n@@ -972,6 +1024,9 @@ impl Liveness {\n     }\n \n     fn propagate_through_expr(expr: @expr, succ: LiveNode) -> LiveNode {\n+      debug!(\"propagate_through_expr: %s\",\n+             expr_to_str(expr, self.tcx.sess.intr()));\n+\n         match expr.node {\n           // Interesting cases with control flow or which gen/kill\n \n@@ -983,16 +1038,27 @@ impl Liveness {\n               self.propagate_through_expr(e, succ)\n           }\n \n-          expr_fn(*) | expr_fn_block(*) => {\n-            // the construction of a closure itself is not important,\n-            // but we have to consider the closed over variables.\n-            let caps = (*self.ir).captures(expr);\n-            do (*caps).foldr(succ) |cap, succ| {\n-                self.init_from_succ(cap.ln, succ);\n-                let var = self.variable(cap.var_nid, expr.span);\n-                self.acc(cap.ln, var, ACC_READ | ACC_USE);\n-                cap.ln\n-            }\n+          expr_fn(_, _, blk, _) | expr_fn_block(_, blk, _) => {\n+            debug!(\"%s is an expr_fn or expr_fn_block\",\n+                   expr_to_str(expr, self.tcx.sess.intr()));\n+\n+              /*\n+              The next-node for a break is the successor of the entire\n+              loop. The next-node for a continue is the top of this loop.\n+              */\n+              self.with_loop_nodes(blk.node.id, succ,\n+                  self.live_node(expr.id, expr.span), || {\n+\n+                 // the construction of a closure itself is not important,\n+                 // but we have to consider the closed over variables.\n+                 let caps = (*self.ir).captures(expr);\n+                 do (*caps).foldr(succ) |cap, succ| {\n+                     self.init_from_succ(cap.ln, succ);\n+                     let var = self.variable(cap.var_nid, expr.span);\n+                     self.acc(cap.ln, var, ACC_READ | ACC_USE);\n+                     cap.ln\n+                 }\n+              })\n           }\n \n           expr_if(cond, then, els) => {\n@@ -1021,6 +1087,8 @@ impl Liveness {\n             self.propagate_through_loop(expr, Some(cond), blk, succ)\n           }\n \n+          // Note that labels have been resolved, so we don't need to look\n+          // at the label ident\n           expr_loop(blk, _) => {\n             self.propagate_through_loop(expr, None, blk, succ)\n           }\n@@ -1062,29 +1130,31 @@ impl Liveness {\n           }\n \n           expr_break(opt_label) => {\n-            if !self.break_ln.is_valid() {\n-                self.tcx.sess.span_bug(\n-                    expr.span, ~\"break with invalid break_ln\");\n-            }\n+              // Find which label this break jumps to\n+              let sc = self.find_loop_scope(opt_label, expr.id, expr.span);\n \n-            if opt_label.is_some() {\n-                self.tcx.sess.span_unimpl(expr.span, ~\"labeled break\");\n-            }\n+              // Now that we know the label we're going to,\n+              // look it up in the break loop nodes table\n \n-            self.break_ln\n+              match self.break_ln.find(sc) {\n+                  Some(b) => b,\n+                  None => self.tcx.sess.span_bug(expr.span,\n+                                ~\"Break to unknown label\")\n+              }\n           }\n \n           expr_again(opt_label) => {\n-            if !self.cont_ln.is_valid() {\n-                self.tcx.sess.span_bug(\n-                    expr.span, ~\"cont with invalid cont_ln\");\n-            }\n+              // Find which label this expr continues to to\n+              let sc = self.find_loop_scope(opt_label, expr.id, expr.span);\n \n-            if opt_label.is_some() {\n-                self.tcx.sess.span_unimpl(expr.span, ~\"labeled again\");\n-            }\n+              // Now that we know the label we're going to,\n+              // look it up in the continue loop nodes table\n \n-            self.cont_ln\n+              match self.cont_ln.find(sc) {\n+                  Some(b) => b,\n+                  None => self.tcx.sess.span_bug(expr.span,\n+                                ~\"Loop to unknown label\")\n+              }\n           }\n \n           expr_move(l, r) | expr_assign(l, r) => {\n@@ -1314,6 +1384,7 @@ impl Liveness {\n \n         */\n \n+\n         // first iteration:\n         let mut first_merge = true;\n         let ln = self.live_node(expr.id, expr.span);\n@@ -1325,32 +1396,37 @@ impl Liveness {\n             self.merge_from_succ(ln, succ, first_merge);\n             first_merge = false;\n         }\n+        debug!(\"propagate_through_loop: using id for loop body %d %s\",\n+               expr.id, block_to_str(body, self.tcx.sess.intr()));\n+\n         let cond_ln = self.propagate_through_opt_expr(cond, ln);\n-        let body_ln = self.with_loop_nodes(succ, ln, || {\n+        let body_ln = self.with_loop_nodes(expr.id, succ, ln, || {\n             self.propagate_through_block(body, cond_ln)\n         });\n \n         // repeat until fixed point is reached:\n         while self.merge_from_succ(ln, body_ln, first_merge) {\n             first_merge = false;\n             assert cond_ln == self.propagate_through_opt_expr(cond, ln);\n-            assert body_ln == self.with_loop_nodes(succ, ln, || {\n+            assert body_ln == self.with_loop_nodes(expr.id, succ, ln,\n+            || {\n                 self.propagate_through_block(body, cond_ln)\n             });\n         }\n \n         cond_ln\n     }\n \n-    fn with_loop_nodes<R>(break_ln: LiveNode,\n+    fn with_loop_nodes<R>(loop_node_id: node_id,\n+                          break_ln: LiveNode,\n                           cont_ln: LiveNode,\n                           f: fn() -> R) -> R {\n-        let bl = self.break_ln, cl = self.cont_ln;\n-        self.break_ln = break_ln;\n-        self.cont_ln = cont_ln;\n-        let r <- f();\n-        self.break_ln = bl;\n-        self.cont_ln = cl;\n+      debug!(\"with_loop_nodes: %d %u\", loop_node_id, *break_ln);\n+        self.loop_scope.push(loop_node_id);\n+        self.break_ln.insert(loop_node_id, break_ln);\n+        self.cont_ln.insert(loop_node_id, cont_ln);\n+        let r = f();\n+        self.loop_scope.pop();\n         move r\n     }\n }\n@@ -1526,6 +1602,10 @@ impl @Liveness {\n         }\n     }\n \n+    /*\n+    Checks whether <var> is live on entry to any of the successors of <ln>.\n+    If it is, report an error.\n+    */\n     fn check_move_from_var(span: span, ln: LiveNode, var: Variable) {\n         debug!(\"check_move_from_var(%s, %s)\",\n                ln.to_str(), var.to_str());"}, {"sha": "d2cde0420fb640acb1e73372ac35fe9bbe70425e", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dd66e7549b72575d5d7e06c0173e702e28cdfba7/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd66e7549b72575d5d7e06c0173e702e28cdfba7/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=dd66e7549b72575d5d7e06c0173e702e28cdfba7", "patch": "@@ -1050,7 +1050,7 @@ fn new_block(cx: fn_ctxt, parent: Option<block>, +kind: block_kind,\n }\n \n fn simple_block_scope() -> block_kind {\n-    block_scope({loop_break: None, mut cleanups: ~[],\n+    block_scope({loop_break: None, loop_label: None, mut cleanups: ~[],\n                  mut cleanup_paths: ~[], mut landing_pad: None})\n }\n \n@@ -1067,10 +1067,11 @@ fn scope_block(bcx: block,\n                   n, opt_node_info);\n }\n \n-fn loop_scope_block(bcx: block, loop_break: block, n: ~str,\n-                    opt_node_info: Option<node_info>) -> block {\n+fn loop_scope_block(bcx: block, loop_break: block, loop_label: Option<ident>,\n+                    n: ~str, opt_node_info: Option<node_info>) -> block {\n     return new_block(bcx.fcx, Some(bcx), block_scope({\n         loop_break: Some(loop_break),\n+        loop_label: loop_label,\n         mut cleanups: ~[],\n         mut cleanup_paths: ~[],\n         mut landing_pad: None"}, {"sha": "7f234349d711fdbc80179d6131fcf19e6e4fdacd", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd66e7549b72575d5d7e06c0173e702e28cdfba7/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd66e7549b72575d5d7e06c0173e702e28cdfba7/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=dd66e7549b72575d5d7e06c0173e702e28cdfba7", "patch": "@@ -445,6 +445,7 @@ enum block_kind {\n \n type scope_info = {\n     loop_break: Option<block>,\n+    loop_label: Option<ident>,\n     // A list of functions that must be run at when leaving this\n     // block, cleaning up any variables that were introduced in the\n     // block."}, {"sha": "b1ca93f8f8a00e225b5b4029cb5909b84554d4ca", "filename": "src/rustc/middle/trans/controlflow.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dd66e7549b72575d5d7e06c0173e702e28cdfba7/src%2Frustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd66e7549b72575d5d7e06c0173e702e28cdfba7/src%2Frustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=dd66e7549b72575d5d7e06c0173e702e28cdfba7", "patch": "@@ -113,7 +113,9 @@ fn trans_while(bcx: block, cond: @ast::expr, body: ast::blk)\n     //    |           body_bcx_out --+\n     // next_bcx\n \n-    let loop_bcx = loop_scope_block(bcx, next_bcx, ~\"`while`\", body.info());\n+    // tjc: while should have labels...\n+    let loop_bcx = loop_scope_block(bcx, next_bcx, None, ~\"`while`\",\n+                                    body.info());\n     let cond_bcx_in = scope_block(loop_bcx, cond.info(), ~\"while loop cond\");\n     let body_bcx_in = scope_block(loop_bcx, body.info(), ~\"while loop body\");\n     Br(bcx, loop_bcx.llbb);\n@@ -133,10 +135,11 @@ fn trans_while(bcx: block, cond: @ast::expr, body: ast::blk)\n     return next_bcx;\n }\n \n-fn trans_loop(bcx:block, body: ast::blk) -> block {\n+fn trans_loop(bcx:block, body: ast::blk, opt_label: Option<ident>) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_loop\");\n     let next_bcx = sub_block(bcx, ~\"next\");\n-    let body_bcx_in = loop_scope_block(bcx, next_bcx, ~\"`loop`\", body.info());\n+    let body_bcx_in = loop_scope_block(bcx, next_bcx, opt_label, ~\"`loop`\",\n+                                       body.info());\n     Br(bcx, body_bcx_in.llbb);\n     let body_bcx_out = trans_block(body_bcx_in, body, expr::Ignore);\n     cleanup_and_Br(body_bcx_out, body_bcx_in, body_bcx_in.llbb);\n@@ -201,21 +204,30 @@ fn trans_log(log_ex: @ast::expr,\n     }\n }\n \n-fn trans_break_cont(bcx: block, to_end: bool)\n+fn trans_break_cont(bcx: block, opt_label: Option<ident>, to_end: bool)\n     -> block {\n     let _icx = bcx.insn_ctxt(\"trans_break_cont\");\n     // Locate closest loop block, outputting cleanup as we go.\n     let mut unwind = bcx;\n     let mut target;\n     loop {\n         match unwind.kind {\n-          block_scope({loop_break: Some(brk), _}) => {\n+          block_scope({loop_break: Some(brk), loop_label: l, _}) => {\n+              // If we're looking for a labeled loop, check the label...\n             target = if to_end {\n                 brk\n             } else {\n                 unwind\n             };\n-            break;\n+              match opt_label {\n+                  Some(desired) => match l {\n+                      Some(actual) if actual == desired => break,\n+                      // If it doesn't match the one we want,\n+                      // don't break\n+                      _ => ()\n+                  },\n+                  None => break\n+              }\n           }\n           _ => ()\n         }\n@@ -235,12 +247,12 @@ fn trans_break_cont(bcx: block, to_end: bool)\n     return bcx;\n }\n \n-fn trans_break(bcx: block) -> block {\n-    return trans_break_cont(bcx, true);\n+fn trans_break(bcx: block, label_opt: Option<ident>) -> block {\n+    return trans_break_cont(bcx, label_opt, true);\n }\n \n-fn trans_cont(bcx: block) -> block {\n-    return trans_break_cont(bcx, false);\n+fn trans_cont(bcx: block, label_opt: Option<ident>) -> block {\n+    return trans_break_cont(bcx, label_opt, false);\n }\n \n fn trans_ret(bcx: block, e: Option<@ast::expr>) -> block {"}, {"sha": "b0702c80b39bf451d53fec79f86795428fe32d35", "filename": "src/rustc/middle/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dd66e7549b72575d5d7e06c0173e702e28cdfba7/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd66e7549b72575d5d7e06c0173e702e28cdfba7/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=dd66e7549b72575d5d7e06c0173e702e28cdfba7", "patch": "@@ -410,16 +410,10 @@ fn trans_rvalue_stmt_unadjusted(bcx: block, expr: @ast::expr) -> block {\n \n     match expr.node {\n         ast::expr_break(label_opt) => {\n-            if label_opt.is_some() {\n-                bcx.tcx().sess.span_unimpl(expr.span, ~\"labeled break\");\n-            }\n-            return controlflow::trans_break(bcx);\n+            return controlflow::trans_break(bcx, label_opt);\n         }\n         ast::expr_again(label_opt) => {\n-            if label_opt.is_some() {\n-                bcx.tcx().sess.span_unimpl(expr.span, ~\"labeled again\");\n-            }\n-            return controlflow::trans_cont(bcx);\n+            return controlflow::trans_cont(bcx, label_opt);\n         }\n         ast::expr_ret(ex) => {\n             return controlflow::trans_ret(bcx, ex);\n@@ -436,8 +430,8 @@ fn trans_rvalue_stmt_unadjusted(bcx: block, expr: @ast::expr) -> block {\n         ast::expr_while(cond, body) => {\n             return controlflow::trans_while(bcx, cond, body);\n         }\n-        ast::expr_loop(body, _) => {\n-            return controlflow::trans_loop(bcx, body);\n+        ast::expr_loop(body, opt_label) => {\n+            return controlflow::trans_loop(bcx, body, opt_label);\n         }\n         ast::expr_assign(dst, src) => {\n             let src_datum = unpack_datum!(bcx, trans_to_datum(bcx, src));"}, {"sha": "90aacb4b7ce6145ebc5c6ba5605dac8d76c4bdd4", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd66e7549b72575d5d7e06c0173e702e28cdfba7/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd66e7549b72575d5d7e06c0173e702e28cdfba7/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=dd66e7549b72575d5d7e06c0173e702e28cdfba7", "patch": "@@ -46,7 +46,7 @@ use syntax::ast_map::node_id_to_str;\n use syntax::ast_util::{local_def, respan, split_trait_methods};\n use syntax::visit;\n use metadata::csearch;\n-use util::common::may_break;\n+use util::common::{block_query, loop_query};\n use syntax::codemap::span;\n use pat_util::{pat_is_variant, pat_id_map, PatIdMap};\n use middle::ty;"}, {"sha": "e37c90d98b410b15b9cacf398d81aa7caafe7392", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dd66e7549b72575d5d7e06c0173e702e28cdfba7/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd66e7549b72575d5d7e06c0173e702e28cdfba7/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=dd66e7549b72575d5d7e06c0173e702e28cdfba7", "patch": "@@ -1665,7 +1665,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       ast::expr_loop(body, _) => {\n         check_block_no_value(fcx, body);\n         fcx.write_ty(id, ty::mk_nil(tcx));\n-        bot = !may_break(body);\n+        bot = !may_break(tcx, expr.id, body);\n       }\n       ast::expr_match(discrim, arms) => {\n         bot = alt::check_alt(fcx, expr, discrim, arms);\n@@ -2544,6 +2544,30 @@ fn ast_expr_vstore_to_vstore(fcx: @fn_ctxt, e: @ast::expr, n: uint,\n     }\n }\n \n+// Returns true if b contains a break that can exit from b\n+fn may_break(cx: ty::ctxt, id: ast::node_id, b: ast::blk) -> bool {\n+    // First: is there an unlabeled break immediately\n+    // inside the loop?\n+    (loop_query(b, |e| {\n+        match e {\n+          ast::expr_break(_) => true,\n+          _ => false\n+        }\n+    })) ||\n+   // Second: is there a labeled break with label\n+   // <id> nested anywhere inside the loop?\n+   (block_query(b, |e| {\n+       match e.node {\n+           ast::expr_break(Some(_)) =>\n+               match cx.def_map.find(e.id) {\n+                 Some(ast::def_label(loop_id)) if id == loop_id => true,\n+                 _ => false,\n+              },\n+           _ => false\n+       }\n+   }))\n+}\n+\n fn check_bounds_are_used(ccx: @crate_ctxt,\n                          span: span,\n                          tps: ~[ast::ty_param],"}, {"sha": "0448b022602a6a1f2eb52f1bce89efab3c082d4f", "filename": "src/rustc/util/common.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/dd66e7549b72575d5d7e06c0173e702e28cdfba7/src%2Frustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd66e7549b72575d5d7e06c0173e702e28cdfba7/src%2Frustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fcommon.rs?ref=dd66e7549b72575d5d7e06c0173e702e28cdfba7", "patch": "@@ -58,22 +58,19 @@ fn loop_query(b: ast::blk, p: fn@(ast::expr_) -> bool) -> bool {\n     return *rs;\n }\n \n-fn has_nonlocal_exits(b: ast::blk) -> bool {\n-    do loop_query(b) |e| {\n-        match e {\n-          ast::expr_break(_) | ast::expr_again(_) => true,\n-          _ => false\n-        }\n-    }\n-}\n-\n-fn may_break(b: ast::blk) -> bool {\n-    do loop_query(b) |e| {\n-        match e {\n-          ast::expr_break(_) => true,\n-          _ => false\n-        }\n-    }\n+// Takes a predicate p, returns true iff p is true for any subexpressions\n+// of b -- skipping any inner loops (loop, while, loop_body)\n+fn block_query(b: ast::blk, p: fn@(@ast::expr) -> bool) -> bool {\n+    let rs = @mut false;\n+    let visit_expr =\n+        |e: @ast::expr, &&flag: @mut bool, v: visit::vt<@mut bool>| {\n+        *flag |= p(e);\n+        visit::visit_expr(e, flag, v)\n+    };\n+    let v = visit::mk_vt(@{visit_expr: visit_expr\n+                           ,.. *visit::default_visitor()});\n+    visit::visit_block(b, rs, v);\n+    return *rs;\n }\n \n fn local_rhs_span(l: @ast::local, def: span) -> span {"}, {"sha": "11815db176327154016eed669b368b68399ead2b", "filename": "src/test/run-pass/issue-2216.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dd66e7549b72575d5d7e06c0173e702e28cdfba7/src%2Ftest%2Frun-pass%2Fissue-2216.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd66e7549b72575d5d7e06c0173e702e28cdfba7/src%2Ftest%2Frun-pass%2Fissue-2216.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2216.rs?ref=dd66e7549b72575d5d7e06c0173e702e28cdfba7", "patch": "@@ -0,0 +1,22 @@\n+fn main() {\n+    let mut x = 0;\n+    \n+    loop foo: {\n+        loop bar: {\n+            loop quux: {\n+                if 1 == 2 {\n+                    break foo;\n+                }\n+                else {\n+                    break bar;\n+                }\n+            }\n+            loop foo;\n+        }\n+        x = 42;\n+        break;\n+    }\n+\n+    error!(\"%?\", x);\n+    assert(x == 42);\n+}\n\\ No newline at end of file"}]}