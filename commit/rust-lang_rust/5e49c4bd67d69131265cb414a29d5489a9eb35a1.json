{"sha": "5e49c4bd67d69131265cb414a29d5489a9eb35a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlNDljNGJkNjdkNjkxMzEyNjVjYjQxNGEyOWQ1NDg5YTllYjM1YTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-30T14:55:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-30T14:55:56Z"}, "message": "Auto merge of #6951 - Jarcho:implicit_return_fp, r=flip1995\n\n`implicit_return` improvements\n\nfixes: #6940\n\nchangelog: Fix `implicit_return` suggestion for async functions\nchangelog: Improve `implicit_return` suggestions when returning the result of a macro\nchangelog: Check for `break` expressions inside a loop which are then implicitly returned\nchangelog: Allow all diverging functions in `implicit_return`, not just panic functions", "tree": {"sha": "a3ccd81733505ed4ad512d14fa89c5040633761d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3ccd81733505ed4ad512d14fa89c5040633761d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e49c4bd67d69131265cb414a29d5489a9eb35a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e49c4bd67d69131265cb414a29d5489a9eb35a1", "html_url": "https://github.com/rust-lang/rust/commit/5e49c4bd67d69131265cb414a29d5489a9eb35a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e49c4bd67d69131265cb414a29d5489a9eb35a1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14f155107591ebbd0a6c3fa71b2eaa3e03fe9419", "url": "https://api.github.com/repos/rust-lang/rust/commits/14f155107591ebbd0a6c3fa71b2eaa3e03fe9419", "html_url": "https://github.com/rust-lang/rust/commit/14f155107591ebbd0a6c3fa71b2eaa3e03fe9419"}, {"sha": "3d793f3111845c8d5836310387b65622ea86b01f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d793f3111845c8d5836310387b65622ea86b01f", "html_url": "https://github.com/rust-lang/rust/commit/3d793f3111845c8d5836310387b65622ea86b01f"}], "stats": {"total": 590, "additions": 450, "deletions": 140}, "files": [{"sha": "30174fa2100dbbd2f259bbb7e8de3e9ac2ebed87", "filename": "clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 169, "deletions": 82, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/5e49c4bd67d69131265cb414a29d5489a9eb35a1/clippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e49c4bd67d69131265cb414a29d5489a9eb35a1/clippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_return.rs?ref=5e49c4bd67d69131265cb414a29d5489a9eb35a1", "patch": "@@ -1,13 +1,16 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::match_panic_def_id;\n-use clippy_utils::source::snippet_opt;\n-use if_chain::if_chain;\n+use clippy_utils::{\n+    diagnostics::span_lint_and_sugg,\n+    get_async_fn_body, is_async_fn,\n+    source::{snippet_with_applicability, snippet_with_context, walk_span_to_context},\n+    visitors::visit_break_exprs,\n+};\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n-use rustc_hir::{Body, Expr, ExprKind, FnDecl, HirId, MatchSource, StmtKind};\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_hir::{Block, Body, Expr, ExprKind, FnDecl, FnRetTy, HirId};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Span;\n+use rustc_span::{Span, SyntaxContext};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for missing return statements at the end of a block.\n@@ -39,109 +42,193 @@ declare_clippy_lint! {\n \n declare_lint_pass!(ImplicitReturn => [IMPLICIT_RETURN]);\n \n-static LINT_BREAK: &str = \"change `break` to `return` as shown\";\n-static LINT_RETURN: &str = \"add `return` as shown\";\n-\n-fn lint(cx: &LateContext<'_>, outer_span: Span, inner_span: Span, msg: &str) {\n-    let outer_span = outer_span.source_callsite();\n-    let inner_span = inner_span.source_callsite();\n-\n-    span_lint_and_then(cx, IMPLICIT_RETURN, outer_span, \"missing `return` statement\", |diag| {\n-        if let Some(snippet) = snippet_opt(cx, inner_span) {\n-            diag.span_suggestion(\n-                outer_span,\n-                msg,\n-                format!(\"return {}\", snippet),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-    });\n+fn lint_return(cx: &LateContext<'_>, span: Span) {\n+    let mut app = Applicability::MachineApplicable;\n+    let snip = snippet_with_applicability(cx, span, \"..\", &mut app);\n+    span_lint_and_sugg(\n+        cx,\n+        IMPLICIT_RETURN,\n+        span,\n+        \"missing `return` statement\",\n+        \"add `return` as shown\",\n+        format!(\"return {}\", snip),\n+        app,\n+    );\n+}\n+\n+fn lint_break(cx: &LateContext<'_>, break_span: Span, expr_span: Span) {\n+    let mut app = Applicability::MachineApplicable;\n+    let snip = snippet_with_context(cx, expr_span, break_span.ctxt(), \"..\", &mut app).0;\n+    span_lint_and_sugg(\n+        cx,\n+        IMPLICIT_RETURN,\n+        break_span,\n+        \"missing `return` statement\",\n+        \"change `break` to `return` as shown\",\n+        format!(\"return {}\", snip),\n+        app,\n+    )\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq)]\n+enum LintLocation {\n+    /// The lint was applied to a parent expression.\n+    Parent,\n+    /// The lint was applied to this expression, a child, or not applied.\n+    Inner,\n+}\n+impl LintLocation {\n+    fn still_parent(self, b: bool) -> Self {\n+        if b { self } else { Self::Inner }\n+    }\n+\n+    fn is_parent(self) -> bool {\n+        self == Self::Parent\n+    }\n+}\n+\n+// Gets the call site if the span is in a child context. Otherwise returns `None`.\n+fn get_call_site(span: Span, ctxt: SyntaxContext) -> Option<Span> {\n+    (span.ctxt() != ctxt).then(|| walk_span_to_context(span, ctxt).unwrap_or(span))\n }\n \n-fn expr_match(cx: &LateContext<'_>, expr: &Expr<'_>) {\n+fn lint_implicit_returns(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    // The context of the function body.\n+    ctxt: SyntaxContext,\n+    // Whether the expression is from a macro expansion.\n+    call_site_span: Option<Span>,\n+) -> LintLocation {\n     match expr.kind {\n-        // loops could be using `break` instead of `return`\n-        ExprKind::Block(block, ..) | ExprKind::Loop(block, ..) => {\n-            if let Some(expr) = &block.expr {\n-                expr_match(cx, expr);\n-            }\n-            // only needed in the case of `break` with `;` at the end\n-            else if let Some(stmt) = block.stmts.last() {\n-                if_chain! {\n-                    if let StmtKind::Semi(expr, ..) = &stmt.kind;\n-                    // make sure it's a break, otherwise we want to skip\n-                    if let ExprKind::Break(.., Some(break_expr)) = &expr.kind;\n-                    then {\n-                            lint(cx, expr.span, break_expr.span, LINT_BREAK);\n-                    }\n-                }\n-            }\n-        },\n-        // use `return` instead of `break`\n-        ExprKind::Break(.., break_expr) => {\n-            if let Some(break_expr) = break_expr {\n-                lint(cx, expr.span, break_expr.span, LINT_BREAK);\n+        ExprKind::Block(\n+            Block {\n+                expr: Some(block_expr), ..\n+            },\n+            _,\n+        ) => lint_implicit_returns(\n+            cx,\n+            block_expr,\n+            ctxt,\n+            call_site_span.or_else(|| get_call_site(block_expr.span, ctxt)),\n+        )\n+        .still_parent(call_site_span.is_some()),\n+\n+        ExprKind::If(_, then_expr, Some(else_expr)) => {\n+            // Both `then_expr` or `else_expr` are required to be blocks in the same context as the `if`. Don't\n+            // bother checking.\n+            let res = lint_implicit_returns(cx, then_expr, ctxt, call_site_span).still_parent(call_site_span.is_some());\n+            if res.is_parent() {\n+                // The return was added as a parent of this if expression.\n+                return res;\n             }\n+            lint_implicit_returns(cx, else_expr, ctxt, call_site_span).still_parent(call_site_span.is_some())\n         },\n-        ExprKind::If(.., if_expr, else_expr) => {\n-            expr_match(cx, if_expr);\n \n-            if let Some(else_expr) = else_expr {\n-                expr_match(cx, else_expr);\n+        ExprKind::Match(_, arms, _) => {\n+            for arm in arms {\n+                let res = lint_implicit_returns(\n+                    cx,\n+                    arm.body,\n+                    ctxt,\n+                    call_site_span.or_else(|| get_call_site(arm.body.span, ctxt)),\n+                )\n+                .still_parent(call_site_span.is_some());\n+                if res.is_parent() {\n+                    // The return was added as a parent of this match expression.\n+                    return res;\n+                }\n             }\n+            LintLocation::Inner\n         },\n-        ExprKind::Match(.., arms, source) => {\n-            let check_all_arms = match source {\n-                MatchSource::IfLetDesugar {\n-                    contains_else_clause: has_else,\n-                } => has_else,\n-                _ => true,\n-            };\n-\n-            if check_all_arms {\n-                for arm in arms {\n-                    expr_match(cx, arm.body);\n+\n+        ExprKind::Loop(block, ..) => {\n+            let mut add_return = false;\n+            visit_break_exprs(block, |break_expr, dest, sub_expr| {\n+                if dest.target_id.ok() == Some(expr.hir_id) {\n+                    if call_site_span.is_none() && break_expr.span.ctxt() == ctxt {\n+                        lint_break(cx, break_expr.span, sub_expr.unwrap().span);\n+                    } else {\n+                        // the break expression is from a macro call, add a return to the loop\n+                        add_return = true;\n+                    }\n+                }\n+            });\n+            if add_return {\n+                #[allow(clippy::option_if_let_else)]\n+                if let Some(span) = call_site_span {\n+                    lint_return(cx, span);\n+                    LintLocation::Parent\n+                } else {\n+                    lint_return(cx, expr.span);\n+                    LintLocation::Inner\n                 }\n             } else {\n-                expr_match(cx, arms.first().expect(\"`if let` doesn't have a single arm\").body);\n+                LintLocation::Inner\n             }\n         },\n-        // skip if it already has a return statement\n-        ExprKind::Ret(..) => (),\n-        // make sure it's not a call that panics\n-        ExprKind::Call(expr, ..) => {\n-            if_chain! {\n-                if let ExprKind::Path(qpath) = &expr.kind;\n-                if let Some(path_def_id) = cx.qpath_res(qpath, expr.hir_id).opt_def_id();\n-                if match_panic_def_id(cx, path_def_id);\n-                then { }\n-                else {\n-                    lint(cx, expr.span, expr.span, LINT_RETURN)\n-                }\n+\n+        // If expressions without an else clause, and blocks without a final expression can only be the final expression\n+        // if they are divergent, or return the unit type.\n+        ExprKind::If(_, _, None) | ExprKind::Block(Block { expr: None, .. }, _) | ExprKind::Ret(_) => {\n+            LintLocation::Inner\n+        },\n+\n+        // Any divergent expression doesn't need a return statement.\n+        ExprKind::MethodCall(..)\n+        | ExprKind::Call(..)\n+        | ExprKind::Binary(..)\n+        | ExprKind::Unary(..)\n+        | ExprKind::Index(..)\n+            if cx.typeck_results().expr_ty(expr).is_never() =>\n+        {\n+            LintLocation::Inner\n+        },\n+\n+        _ =>\n+        {\n+            #[allow(clippy::option_if_let_else)]\n+            if let Some(span) = call_site_span {\n+                lint_return(cx, span);\n+                LintLocation::Parent\n+            } else {\n+                lint_return(cx, expr.span);\n+                LintLocation::Inner\n             }\n         },\n-        // everything else is missing `return`\n-        _ => lint(cx, expr.span, expr.span, LINT_RETURN),\n     }\n }\n \n impl<'tcx> LateLintPass<'tcx> for ImplicitReturn {\n     fn check_fn(\n         &mut self,\n         cx: &LateContext<'tcx>,\n-        _: FnKind<'tcx>,\n-        _: &'tcx FnDecl<'_>,\n+        kind: FnKind<'tcx>,\n+        decl: &'tcx FnDecl<'_>,\n         body: &'tcx Body<'_>,\n         span: Span,\n         _: HirId,\n     ) {\n-        if span.from_expansion() {\n+        if (!matches!(kind, FnKind::Closure) && matches!(decl.output, FnRetTy::DefaultReturn(_)))\n+            || span.ctxt() != body.value.span.ctxt()\n+            || in_external_macro(cx.sess(), span)\n+        {\n             return;\n         }\n-        let body = cx.tcx.hir().body(body.id());\n-        if cx.typeck_results().expr_ty(&body.value).is_unit() {\n+\n+        let res_ty = cx.typeck_results().expr_ty(&body.value);\n+        if res_ty.is_unit() || res_ty.is_never() {\n             return;\n         }\n-        expr_match(cx, &body.value);\n+\n+        let expr = if is_async_fn(kind) {\n+            match get_async_fn_body(cx.tcx, body) {\n+                Some(e) => e,\n+                None => return,\n+            }\n+        } else {\n+            &body.value\n+        };\n+        lint_implicit_returns(cx, expr, expr.span.ctxt(), None);\n     }\n }"}, {"sha": "94eade0c9324319edbb7b1e403931d3a737c04ca", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5e49c4bd67d69131265cb414a29d5489a9eb35a1/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e49c4bd67d69131265cb414a29d5489a9eb35a1/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=5e49c4bd67d69131265cb414a29d5489a9eb35a1", "patch": "@@ -61,12 +61,12 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_hir::intravisit::{self, walk_expr, ErasedMap, NestedVisitorMap, Visitor};\n+use rustc_hir::intravisit::{self, walk_expr, ErasedMap, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::LangItem::{ResultErr, ResultOk};\n use rustc_hir::{\n     def, Arm, BindingAnnotation, Block, Body, Constness, Destination, Expr, ExprKind, FnDecl, GenericArgs, HirId, Impl,\n-    ImplItem, ImplItemKind, Item, ItemKind, LangItem, Local, MatchSource, Node, Param, Pat, PatKind, Path, PathSegment,\n-    QPath, Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind,\n+    ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local, MatchSource, Node, Param, Pat, PatKind, Path,\n+    PathSegment, QPath, Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind,\n };\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::exports::Export;\n@@ -1301,6 +1301,40 @@ pub fn if_sequence<'tcx>(mut expr: &'tcx Expr<'tcx>) -> (Vec<&'tcx Expr<'tcx>>,\n     (conds, blocks)\n }\n \n+/// Checks if the given function kind is an async function.\n+pub fn is_async_fn(kind: FnKind) -> bool {\n+    matches!(kind, FnKind::ItemFn(_, _, header, _) if header.asyncness == IsAsync::Async)\n+}\n+\n+/// Peels away all the compiler generated code surrounding the body of an async function,\n+pub fn get_async_fn_body(tcx: TyCtxt<'tcx>, body: &Body<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    if let ExprKind::Call(\n+        _,\n+        &[Expr {\n+            kind: ExprKind::Closure(_, _, body, _, _),\n+            ..\n+        }],\n+    ) = body.value.kind\n+    {\n+        if let ExprKind::Block(\n+            Block {\n+                stmts: [],\n+                expr:\n+                    Some(Expr {\n+                        kind: ExprKind::DropTemps(expr),\n+                        ..\n+                    }),\n+                ..\n+            },\n+            _,\n+        ) = tcx.hir().body(body).value.kind\n+        {\n+            return Some(expr);\n+        }\n+    };\n+    None\n+}\n+\n // Finds the `#[must_use]` attribute, if any\n pub fn must_use_attr(attrs: &[Attribute]) -> Option<&Attribute> {\n     attrs.iter().find(|a| a.has_name(sym::must_use))"}, {"sha": "4d49b43bde9ecd9751bc825b55afad614e5f1fd7", "filename": "clippy_utils/src/source.rs", "status": "modified", "additions": 42, "deletions": 11, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/5e49c4bd67d69131265cb414a29d5489a9eb35a1/clippy_utils%2Fsrc%2Fsource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e49c4bd67d69131265cb414a29d5489a9eb35a1/clippy_utils%2Fsrc%2Fsource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsource.rs?ref=5e49c4bd67d69131265cb414a29d5489a9eb35a1", "patch": "@@ -280,24 +280,55 @@ pub fn snippet_with_context(\n     default: &'a str,\n     applicability: &mut Applicability,\n ) -> (Cow<'a, str>, bool) {\n-    let outer_span = hygiene::walk_chain(span, outer);\n-    let (span, is_macro_call) = if outer_span.ctxt() == outer {\n-        (outer_span, span.ctxt() != outer)\n-    } else {\n-        // The span is from a macro argument, and the outer context is the macro using the argument\n-        if *applicability != Applicability::Unspecified {\n-            *applicability = Applicability::MaybeIncorrect;\n-        }\n-        // TODO: get the argument span.\n-        (span, false)\n-    };\n+    let (span, is_macro_call) = walk_span_to_context(span, outer).map_or_else(\n+        || {\n+            // The span is from a macro argument, and the outer context is the macro using the argument\n+            if *applicability != Applicability::Unspecified {\n+                *applicability = Applicability::MaybeIncorrect;\n+            }\n+            // TODO: get the argument span.\n+            (span, false)\n+        },\n+        |outer_span| (outer_span, span.ctxt() != outer),\n+    );\n \n     (\n         snippet_with_applicability(cx, span, default, applicability),\n         is_macro_call,\n     )\n }\n \n+/// Walks the span up to the target context, thereby returning the macro call site if the span is\n+/// inside a macro expansion, or the original span if it is not. Note this will return `None` in the\n+/// case of the span being in a macro expansion, but the target context is from expanding a macro\n+/// argument.\n+///\n+/// Given the following\n+///\n+/// ```rust,ignore\n+/// macro_rules! m { ($e:expr) => { f($e) }; }\n+/// g(m!(0))\n+/// ```\n+///\n+/// If called with a span of the call to `f` and a context of the call to `g` this will return a\n+/// span containing `m!(0)`. However, if called with a span of the literal `0` this will give a span\n+/// containing `0` as the context is the same as the outer context.\n+///\n+/// This will traverse through multiple macro calls. Given the following:\n+///\n+/// ```rust,ignore\n+/// macro_rules! m { ($e:expr) => { n!($e, 0) }; }\n+/// macro_rules! n { ($e:expr, $f:expr) => { f($e, $f) }; }\n+/// g(m!(0))\n+/// ```\n+///\n+/// If called with a span of the call to `f` and a context of the call to `g` this will return a\n+/// span containing `m!(0)`.\n+pub fn walk_span_to_context(span: Span, outer: SyntaxContext) -> Option<Span> {\n+    let outer_span = hygiene::walk_chain(span, outer);\n+    (outer_span.ctxt() == outer).then(|| outer_span)\n+}\n+\n /// Removes block comments from the given `Vec` of lines.\n ///\n /// # Examples"}, {"sha": "d431bdf34eeeea2c62f0662f8ca562df16e35ac2", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5e49c4bd67d69131265cb414a29d5489a9eb35a1/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e49c4bd67d69131265cb414a29d5489a9eb35a1/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=5e49c4bd67d69131265cb414a29d5489a9eb35a1", "patch": "@@ -1,7 +1,7 @@\n use crate::path_to_local_id;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{self, walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{Arm, Body, Expr, HirId, Stmt};\n+use rustc_hir::intravisit::{self, walk_expr, ErasedMap, NestedVisitorMap, Visitor};\n+use rustc_hir::{Arm, Block, Body, Destination, Expr, ExprKind, HirId, Stmt};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n \n@@ -188,3 +188,54 @@ impl<'v> Visitor<'v> for LocalUsedVisitor<'v> {\n         NestedVisitorMap::OnlyBodies(self.hir)\n     }\n }\n+\n+pub trait Visitable<'tcx> {\n+    fn visit<V: Visitor<'tcx>>(self, v: &mut V);\n+}\n+impl Visitable<'tcx> for &'tcx Expr<'tcx> {\n+    fn visit<V: Visitor<'tcx>>(self, v: &mut V) {\n+        v.visit_expr(self)\n+    }\n+}\n+impl Visitable<'tcx> for &'tcx Block<'tcx> {\n+    fn visit<V: Visitor<'tcx>>(self, v: &mut V) {\n+        v.visit_block(self)\n+    }\n+}\n+impl<'tcx> Visitable<'tcx> for &'tcx Stmt<'tcx> {\n+    fn visit<V: Visitor<'tcx>>(self, v: &mut V) {\n+        v.visit_stmt(self)\n+    }\n+}\n+impl<'tcx> Visitable<'tcx> for &'tcx Body<'tcx> {\n+    fn visit<V: Visitor<'tcx>>(self, v: &mut V) {\n+        v.visit_body(self)\n+    }\n+}\n+impl<'tcx> Visitable<'tcx> for &'tcx Arm<'tcx> {\n+    fn visit<V: Visitor<'tcx>>(self, v: &mut V) {\n+        v.visit_arm(self)\n+    }\n+}\n+\n+pub fn visit_break_exprs<'tcx>(\n+    node: impl Visitable<'tcx>,\n+    f: impl FnMut(&'tcx Expr<'tcx>, Destination, Option<&'tcx Expr<'tcx>>),\n+) {\n+    struct V<F>(F);\n+    impl<'tcx, F: FnMut(&'tcx Expr<'tcx>, Destination, Option<&'tcx Expr<'tcx>>)> Visitor<'tcx> for V<F> {\n+        type Map = ErasedMap<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::None\n+        }\n+\n+        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+            if let ExprKind::Break(dest, sub_expr) = e.kind {\n+                self.0(e, dest, sub_expr)\n+            }\n+            walk_expr(self, e);\n+        }\n+    }\n+\n+    node.visit(&mut V(f));\n+}"}, {"sha": "7698b88a88c8aa80a143ac27ab11e145a880ef51", "filename": "tests/ui/implicit_return.fixed", "status": "modified", "additions": 51, "deletions": 17, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/5e49c4bd67d69131265cb414a29d5489a9eb35a1/tests%2Fui%2Fimplicit_return.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5e49c4bd67d69131265cb414a29d5489a9eb35a1/tests%2Fui%2Fimplicit_return.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_return.fixed?ref=5e49c4bd67d69131265cb414a29d5489a9eb35a1", "patch": "@@ -1,7 +1,8 @@\n+// edition:2018\n // run-rustfix\n \n #![warn(clippy::implicit_return)]\n-#![allow(clippy::needless_return, unused)]\n+#![allow(clippy::needless_return, clippy::needless_bool, unused, clippy::never_loop)]\n \n fn test_end_of_fn() -> bool {\n     if true {\n@@ -12,7 +13,6 @@ fn test_end_of_fn() -> bool {\n     return true\n }\n \n-#[allow(clippy::needless_bool)]\n fn test_if_block() -> bool {\n     if true { return true } else { return false }\n }\n@@ -25,22 +25,19 @@ fn test_match(x: bool) -> bool {\n     }\n }\n \n-#[allow(clippy::needless_return)]\n fn test_match_with_unreachable(x: bool) -> bool {\n     match x {\n         true => return false,\n         false => unreachable!(),\n     }\n }\n \n-#[allow(clippy::never_loop)]\n fn test_loop() -> bool {\n     loop {\n         return true;\n     }\n }\n \n-#[allow(clippy::never_loop)]\n fn test_loop_with_block() -> bool {\n     loop {\n         {\n@@ -49,7 +46,6 @@ fn test_loop_with_block() -> bool {\n     }\n }\n \n-#[allow(clippy::never_loop)]\n fn test_loop_with_nests() -> bool {\n     loop {\n         if true {\n@@ -83,15 +79,53 @@ fn test_return_macro() -> String {\n     return format!(\"test {}\", \"test\")\n }\n \n-fn main() {\n-    let _ = test_end_of_fn();\n-    let _ = test_if_block();\n-    let _ = test_match(true);\n-    let _ = test_match_with_unreachable(true);\n-    let _ = test_loop();\n-    let _ = test_loop_with_block();\n-    let _ = test_loop_with_nests();\n-    let _ = test_loop_with_if_let();\n-    test_closure();\n-    let _ = test_return_macro();\n+fn macro_branch_test() -> bool {\n+    macro_rules! m {\n+        ($t:expr, $f:expr) => {\n+            if true { $t } else { $f }\n+        };\n+    }\n+    return m!(true, false)\n+}\n+\n+fn loop_test() -> bool {\n+    'outer: loop {\n+        if true {\n+            return true;\n+        }\n+\n+        let _ = loop {\n+            if false {\n+                return false;\n+            }\n+            if true {\n+                break true;\n+            }\n+        };\n+    }\n }\n+\n+fn loop_macro_test() -> bool {\n+    macro_rules! m {\n+        ($e:expr) => {\n+            break $e\n+        };\n+    }\n+    return loop {\n+        m!(true);\n+    }\n+}\n+\n+fn divergent_test() -> bool {\n+    fn diverge() -> ! {\n+        panic!()\n+    }\n+    diverge()\n+}\n+\n+// issue #6940\n+async fn foo() -> bool {\n+    return true\n+}\n+\n+fn main() {}"}, {"sha": "45bbc2ec670e05463d1a0f8d6f8d5fc557561cfe", "filename": "tests/ui/implicit_return.rs", "status": "modified", "additions": 51, "deletions": 17, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/5e49c4bd67d69131265cb414a29d5489a9eb35a1/tests%2Fui%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e49c4bd67d69131265cb414a29d5489a9eb35a1/tests%2Fui%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_return.rs?ref=5e49c4bd67d69131265cb414a29d5489a9eb35a1", "patch": "@@ -1,7 +1,8 @@\n+// edition:2018\n // run-rustfix\n \n #![warn(clippy::implicit_return)]\n-#![allow(clippy::needless_return, unused)]\n+#![allow(clippy::needless_return, clippy::needless_bool, unused, clippy::never_loop)]\n \n fn test_end_of_fn() -> bool {\n     if true {\n@@ -12,7 +13,6 @@ fn test_end_of_fn() -> bool {\n     true\n }\n \n-#[allow(clippy::needless_bool)]\n fn test_if_block() -> bool {\n     if true { true } else { false }\n }\n@@ -25,22 +25,19 @@ fn test_match(x: bool) -> bool {\n     }\n }\n \n-#[allow(clippy::needless_return)]\n fn test_match_with_unreachable(x: bool) -> bool {\n     match x {\n         true => return false,\n         false => unreachable!(),\n     }\n }\n \n-#[allow(clippy::never_loop)]\n fn test_loop() -> bool {\n     loop {\n         break true;\n     }\n }\n \n-#[allow(clippy::never_loop)]\n fn test_loop_with_block() -> bool {\n     loop {\n         {\n@@ -49,7 +46,6 @@ fn test_loop_with_block() -> bool {\n     }\n }\n \n-#[allow(clippy::never_loop)]\n fn test_loop_with_nests() -> bool {\n     loop {\n         if true {\n@@ -83,15 +79,53 @@ fn test_return_macro() -> String {\n     format!(\"test {}\", \"test\")\n }\n \n-fn main() {\n-    let _ = test_end_of_fn();\n-    let _ = test_if_block();\n-    let _ = test_match(true);\n-    let _ = test_match_with_unreachable(true);\n-    let _ = test_loop();\n-    let _ = test_loop_with_block();\n-    let _ = test_loop_with_nests();\n-    let _ = test_loop_with_if_let();\n-    test_closure();\n-    let _ = test_return_macro();\n+fn macro_branch_test() -> bool {\n+    macro_rules! m {\n+        ($t:expr, $f:expr) => {\n+            if true { $t } else { $f }\n+        };\n+    }\n+    m!(true, false)\n+}\n+\n+fn loop_test() -> bool {\n+    'outer: loop {\n+        if true {\n+            break true;\n+        }\n+\n+        let _ = loop {\n+            if false {\n+                break 'outer false;\n+            }\n+            if true {\n+                break true;\n+            }\n+        };\n+    }\n+}\n+\n+fn loop_macro_test() -> bool {\n+    macro_rules! m {\n+        ($e:expr) => {\n+            break $e\n+        };\n+    }\n+    loop {\n+        m!(true);\n+    }\n+}\n+\n+fn divergent_test() -> bool {\n+    fn diverge() -> ! {\n+        panic!()\n+    }\n+    diverge()\n }\n+\n+// issue #6940\n+async fn foo() -> bool {\n+    true\n+}\n+\n+fn main() {}"}, {"sha": "16fe9ed444ff696d20c0c3411cb56913a631a6d2", "filename": "tests/ui/implicit_return.stderr", "status": "modified", "additions": 47, "deletions": 8, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5e49c4bd67d69131265cb414a29d5489a9eb35a1/tests%2Fui%2Fimplicit_return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e49c4bd67d69131265cb414a29d5489a9eb35a1/tests%2Fui%2Fimplicit_return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_return.stderr?ref=5e49c4bd67d69131265cb414a29d5489a9eb35a1", "patch": "@@ -1,5 +1,5 @@\n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:12:5\n+  --> $DIR/implicit_return.rs:13:5\n    |\n LL |     true\n    |     ^^^^ help: add `return` as shown: `return true`\n@@ -31,40 +31,79 @@ LL |         false => { true },\n    |                    ^^^^ help: add `return` as shown: `return true`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:39:9\n+  --> $DIR/implicit_return.rs:37:9\n    |\n LL |         break true;\n    |         ^^^^^^^^^^ help: change `break` to `return` as shown: `return true`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:47:13\n+  --> $DIR/implicit_return.rs:44:13\n    |\n LL |             break true;\n    |             ^^^^^^^^^^ help: change `break` to `return` as shown: `return true`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:56:13\n+  --> $DIR/implicit_return.rs:52:13\n    |\n LL |             break true;\n    |             ^^^^^^^^^^ help: change `break` to `return` as shown: `return true`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:74:18\n+  --> $DIR/implicit_return.rs:70:18\n    |\n LL |     let _ = || { true };\n    |                  ^^^^ help: add `return` as shown: `return true`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:75:16\n+  --> $DIR/implicit_return.rs:71:16\n    |\n LL |     let _ = || true;\n    |                ^^^^ help: add `return` as shown: `return true`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:83:5\n+  --> $DIR/implicit_return.rs:79:5\n    |\n LL |     format!(\"test {}\", \"test\")\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: add `return` as shown: `return format!(\"test {}\", \"test\")`\n \n-error: aborting due to 11 previous errors\n+error: missing `return` statement\n+  --> $DIR/implicit_return.rs:88:5\n+   |\n+LL |     m!(true, false)\n+   |     ^^^^^^^^^^^^^^^ help: add `return` as shown: `return m!(true, false)`\n+\n+error: missing `return` statement\n+  --> $DIR/implicit_return.rs:94:13\n+   |\n+LL |             break true;\n+   |             ^^^^^^^^^^ help: change `break` to `return` as shown: `return true`\n+\n+error: missing `return` statement\n+  --> $DIR/implicit_return.rs:99:17\n+   |\n+LL |                 break 'outer false;\n+   |                 ^^^^^^^^^^^^^^^^^^ help: change `break` to `return` as shown: `return false`\n+\n+error: missing `return` statement\n+  --> $DIR/implicit_return.rs:114:5\n+   |\n+LL | /     loop {\n+LL | |         m!(true);\n+LL | |     }\n+   | |_____^\n+   |\n+help: add `return` as shown\n+   |\n+LL |     return loop {\n+LL |         m!(true);\n+LL |     }\n+   |\n+\n+error: missing `return` statement\n+  --> $DIR/implicit_return.rs:128:5\n+   |\n+LL |     true\n+   |     ^^^^ help: add `return` as shown: `return true`\n+\n+error: aborting due to 16 previous errors\n "}]}