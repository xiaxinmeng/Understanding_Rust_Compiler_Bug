{"sha": "b5b7266b786cb953581ba588d400bddcdae4a852", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1YjcyNjZiNzg2Y2I5NTM1ODFiYTU4OGQ0MDBiZGRjZGFlNGE4NTI=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-07-26T12:15:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-07-26T12:15:01Z"}, "message": "Rollup merge of #42959 - SimonSapin:nonzero-checked, r=sfackler\n\nMake the \"main\" constructors of NonZero/Shared/Unique return Option\n\nPer discussion in https://github.com/rust-lang/rust/issues/27730#issuecomment-303939441.\n\nThis is a breaking change to unstable APIs.\n\nThe old behavior is still available under the name `new_unchecked`. Note that only that one can be `const fn`, since `if` is currently not allowed in constant contexts.\n\nIn the case of `NonZero` this requires adding a new `is_zero` method to the `Zeroable` trait. I mildly dislike this, but it\u2019s not much worse than having a `Zeroable` trait in the first place. `Zeroable` and `NonZero` are both unstable, this can be reworked later.", "tree": {"sha": "c957402d4bf9f3f60cc718e86bf45ebba616bf4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c957402d4bf9f3f60cc718e86bf45ebba616bf4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5b7266b786cb953581ba588d400bddcdae4a852", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5b7266b786cb953581ba588d400bddcdae4a852", "html_url": "https://github.com/rust-lang/rust/commit/b5b7266b786cb953581ba588d400bddcdae4a852", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5b7266b786cb953581ba588d400bddcdae4a852/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bad58f27916e7e233cc2916dcc9167708077e792", "url": "https://api.github.com/repos/rust-lang/rust/commits/bad58f27916e7e233cc2916dcc9167708077e792", "html_url": "https://github.com/rust-lang/rust/commit/bad58f27916e7e233cc2916dcc9167708077e792"}, {"sha": "0d1864b8cf9585e6133aa3da2b06b29cbfb791bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d1864b8cf9585e6133aa3da2b06b29cbfb791bd", "html_url": "https://github.com/rust-lang/rust/commit/0d1864b8cf9585e6133aa3da2b06b29cbfb791bd"}], "stats": {"total": 306, "additions": 219, "deletions": 87}, "files": [{"sha": "f8fd6710399a1a557155cb5be4922fe6a6f694c0", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=b5b7266b786cb953581ba588d400bddcdae4a852", "patch": "@@ -1 +1 @@\n-Subproject commit 81134a4dff811403b3b2f349b0c59a819f0fe0c1\n+Subproject commit f8fd6710399a1a557155cb5be4922fe6a6f694c0"}, {"sha": "efc59d2cbc86f9a586ccadcf8e78038b3c50fdca", "filename": "src/liballoc/allocator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Fliballoc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Fliballoc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fallocator.rs?ref=b5b7266b786cb953581ba588d400bddcdae4a852", "patch": "@@ -892,7 +892,7 @@ pub unsafe trait Alloc {\n     {\n         let k = Layout::new::<T>();\n         if k.size() > 0 {\n-            unsafe { self.alloc(k).map(|p| Unique::new(p as *mut T)) }\n+            unsafe { self.alloc(k).map(|p| Unique::new_unchecked(p as *mut T)) }\n         } else {\n             Err(AllocErr::invalid_input(\"zero-sized type invalid for alloc_one\"))\n         }\n@@ -963,7 +963,7 @@ pub unsafe trait Alloc {\n                 unsafe {\n                     self.alloc(layout.clone())\n                         .map(|p| {\n-                            Unique::new(p as *mut T)\n+                            Unique::new_unchecked(p as *mut T)\n                         })\n                 }\n             }\n@@ -1012,7 +1012,7 @@ pub unsafe trait Alloc {\n         match (Layout::array::<T>(n_old), Layout::array::<T>(n_new), ptr.as_ptr()) {\n             (Some(ref k_old), Some(ref k_new), ptr) if k_old.size() > 0 && k_new.size() > 0 => {\n                 self.realloc(ptr as *mut u8, k_old.clone(), k_new.clone())\n-                    .map(|p|Unique::new(p as *mut T))\n+                    .map(|p|Unique::new_unchecked(p as *mut T))\n             }\n             _ => {\n                 Err(AllocErr::invalid_input(\"invalid layout for realloc_array\"))"}, {"sha": "9e3142519341777cca7803f8e663bdca417ef00c", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=b5b7266b786cb953581ba588d400bddcdae4a852", "patch": "@@ -280,7 +280,7 @@ impl<T> Arc<T> {\n             weak: atomic::AtomicUsize::new(1),\n             data: data,\n         };\n-        Arc { ptr: unsafe { Shared::new(Box::into_raw(x)) } }\n+        Arc { ptr: Shared::from(Box::into_unique(x)) }\n     }\n \n     /// Returns the contained value, if the `Arc` has exactly one strong reference.\n@@ -382,7 +382,7 @@ impl<T> Arc<T> {\n         // `data` field from the pointer.\n         let ptr = (ptr as *const u8).offset(-offset_of!(ArcInner<T>, data));\n         Arc {\n-            ptr: Shared::new(ptr as *mut u8 as *mut _),\n+            ptr: Shared::new_unchecked(ptr as *mut u8 as *mut _),\n         }\n     }\n }\n@@ -842,7 +842,7 @@ impl<T> Weak<T> {\n     pub fn new() -> Weak<T> {\n         unsafe {\n             Weak {\n-                ptr: Shared::new(Box::into_raw(box ArcInner {\n+                ptr: Shared::from(Box::into_unique(box ArcInner {\n                     strong: atomic::AtomicUsize::new(0),\n                     weak: atomic::AtomicUsize::new(1),\n                     data: uninitialized(),"}, {"sha": "6318d22059f96c09339337a9f32dd23453b1a96c", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=b5b7266b786cb953581ba588d400bddcdae4a852", "patch": "@@ -297,6 +297,37 @@ impl<T: ?Sized> Box<T> {\n     pub fn into_raw(b: Box<T>) -> *mut T {\n         unsafe { mem::transmute(b) }\n     }\n+\n+    /// Consumes the `Box`, returning the wrapped pointer as `Unique<T>`.\n+    ///\n+    /// After calling this function, the caller is responsible for the\n+    /// memory previously managed by the `Box`. In particular, the\n+    /// caller should properly destroy `T` and release the memory. The\n+    /// proper way to do so is to convert the raw pointer back into a\n+    /// `Box` with the [`Box::from_raw`] function.\n+    ///\n+    /// Note: this is an associated function, which means that you have\n+    /// to call it as `Box::into_unique(b)` instead of `b.into_unique()`. This\n+    /// is so that there is no conflict with a method on the inner type.\n+    ///\n+    /// [`Box::from_raw`]: struct.Box.html#method.from_raw\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(unique)]\n+    ///\n+    /// fn main() {\n+    ///     let x = Box::new(5);\n+    ///     let ptr = Box::into_unique(x);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unique\", reason = \"needs an RFC to flesh out design\",\n+               issue = \"27730\")]\n+    #[inline]\n+    pub fn into_unique(b: Box<T>) -> Unique<T> {\n+        unsafe { mem::transmute(b) }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "06d3a113b947471989ad7a803cb77e490f9f5038", "filename": "src/liballoc/btree/node.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Fliballoc%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Fliballoc%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fnode.rs?ref=b5b7266b786cb953581ba588d400bddcdae4a852", "patch": "@@ -140,24 +140,22 @@ struct BoxedNode<K, V> {\n \n impl<K, V> BoxedNode<K, V> {\n     fn from_leaf(node: Box<LeafNode<K, V>>) -> Self {\n-        unsafe {\n-            BoxedNode { ptr: Unique::new(Box::into_raw(node)) }\n-        }\n+        BoxedNode { ptr: Box::into_unique(node) }\n     }\n \n     fn from_internal(node: Box<InternalNode<K, V>>) -> Self {\n         unsafe {\n-            BoxedNode { ptr: Unique::new(Box::into_raw(node) as *mut LeafNode<K, V>) }\n+            BoxedNode { ptr: Unique::new_unchecked(Box::into_raw(node) as *mut LeafNode<K, V>) }\n         }\n     }\n \n     unsafe fn from_ptr(ptr: NonZero<*const LeafNode<K, V>>) -> Self {\n-        BoxedNode { ptr: Unique::new(ptr.get() as *mut LeafNode<K, V>) }\n+        BoxedNode { ptr: Unique::new_unchecked(ptr.get() as *mut LeafNode<K, V>) }\n     }\n \n     fn as_ptr(&self) -> NonZero<*const LeafNode<K, V>> {\n         unsafe {\n-            NonZero::new(self.ptr.as_ptr())\n+            NonZero::from(self.ptr.as_ref())\n         }\n     }\n }\n@@ -384,21 +382,19 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         >,\n         Self\n     > {\n-        if self.as_leaf().parent.is_null() {\n-            Err(self)\n-        } else {\n+        if let Some(non_zero) = NonZero::new(self.as_leaf().parent as *const LeafNode<K, V>) {\n             Ok(Handle {\n                 node: NodeRef {\n                     height: self.height + 1,\n-                    node: unsafe {\n-                        NonZero::new(self.as_leaf().parent as *mut LeafNode<K, V>)\n-                    },\n+                    node: non_zero,\n                     root: self.root,\n                     _marker: PhantomData\n                 },\n                 idx: self.as_leaf().parent_idx as usize,\n                 _marker: PhantomData\n             })\n+        } else {\n+            Err(self)\n         }\n     }\n "}, {"sha": "850dd6adcf0af08e3d8c033f500b1b577e53a397", "filename": "src/liballoc/linked_list.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Fliballoc%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Fliballoc%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flinked_list.rs?ref=b5b7266b786cb953581ba588d400bddcdae4a852", "patch": "@@ -157,7 +157,7 @@ impl<T> LinkedList<T> {\n         unsafe {\n             node.next = self.head;\n             node.prev = None;\n-            let node = Some(Shared::new(Box::into_raw(node)));\n+            let node = Some(Shared::from(Box::into_unique(node)));\n \n             match self.head {\n                 None => self.tail = node,\n@@ -192,7 +192,7 @@ impl<T> LinkedList<T> {\n         unsafe {\n             node.next = None;\n             node.prev = self.tail;\n-            let node = Some(Shared::new(Box::into_raw(node)));\n+            let node = Some(Shared::from(Box::into_unique(node)));\n \n             match self.tail {\n                 None => self.head = node,\n@@ -921,7 +921,7 @@ impl<'a, T> IterMut<'a, T> {\n                     Some(prev) => prev,\n                 };\n \n-                let node = Some(Shared::new(Box::into_raw(box Node {\n+                let node = Some(Shared::from(Box::into_unique(box Node {\n                     next: Some(head),\n                     prev: Some(prev),\n                     element: element,"}, {"sha": "ca55831220da6ba72530d9ffa7499b409a4c6c7f", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=b5b7266b786cb953581ba588d400bddcdae4a852", "patch": "@@ -104,7 +104,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             };\n \n             RawVec {\n-                ptr: Unique::new(ptr as *mut _),\n+                ptr: Unique::new_unchecked(ptr as *mut _),\n                 cap: cap,\n                 a: a,\n             }\n@@ -159,7 +159,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// If the ptr and capacity come from a RawVec created via `a`, then this is guaranteed.\n     pub unsafe fn from_raw_parts_in(ptr: *mut T, cap: usize, a: A) -> Self {\n         RawVec {\n-            ptr: Unique::new(ptr),\n+            ptr: Unique::new_unchecked(ptr),\n             cap: cap,\n             a: a,\n         }\n@@ -176,7 +176,7 @@ impl<T> RawVec<T, Heap> {\n     /// If the ptr and capacity come from a RawVec, then this is guaranteed.\n     pub unsafe fn from_raw_parts(ptr: *mut T, cap: usize) -> Self {\n         RawVec {\n-            ptr: Unique::new(ptr),\n+            ptr: Unique::new_unchecked(ptr),\n             cap: cap,\n             a: Heap,\n         }"}, {"sha": "a2184054b377ebddde035eeea2cf5c1f4eb7769b", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=b5b7266b786cb953581ba588d400bddcdae4a852", "patch": "@@ -303,18 +303,16 @@ impl<T> Rc<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(value: T) -> Rc<T> {\n-        unsafe {\n-            Rc {\n-                // there is an implicit weak pointer owned by all the strong\n-                // pointers, which ensures that the weak destructor never frees\n-                // the allocation while the strong destructor is running, even\n-                // if the weak pointer is stored inside the strong one.\n-                ptr: Shared::new(Box::into_raw(box RcBox {\n-                    strong: Cell::new(1),\n-                    weak: Cell::new(1),\n-                    value: value,\n-                })),\n-            }\n+        Rc {\n+            // there is an implicit weak pointer owned by all the strong\n+            // pointers, which ensures that the weak destructor never frees\n+            // the allocation while the strong destructor is running, even\n+            // if the weak pointer is stored inside the strong one.\n+            ptr: Shared::from(Box::into_unique(box RcBox {\n+                strong: Cell::new(1),\n+                weak: Cell::new(1),\n+                value: value,\n+            })),\n         }\n     }\n \n@@ -418,7 +416,7 @@ impl<T> Rc<T> {\n \n         let ptr = (ptr as *const u8).offset(-offset_of!(RcBox<T>, value));\n         Rc {\n-            ptr: Shared::new(ptr as *mut u8 as *mut _)\n+            ptr: Shared::new_unchecked(ptr as *mut u8 as *mut _)\n         }\n     }\n }\n@@ -443,7 +441,7 @@ impl Rc<str> {\n             // Combine the allocation address and the string length into a fat pointer to `RcBox`.\n             let rcbox_ptr: *mut RcBox<str> = mem::transmute([ptr as usize, value.len()]);\n             assert!(aligned_len * size_of::<usize>() == size_of_val(&*rcbox_ptr));\n-            Rc { ptr: Shared::new(rcbox_ptr) }\n+            Rc { ptr: Shared::new_unchecked(rcbox_ptr) }\n         }\n     }\n }\n@@ -476,7 +474,7 @@ impl<T> Rc<[T]> {\n             // Free the original allocation without freeing its (moved) contents.\n             box_free(Box::into_raw(value));\n \n-            Rc { ptr: Shared::new(ptr as *mut _) }\n+            Rc { ptr: Shared::new_unchecked(ptr as *mut _) }\n         }\n     }\n }\n@@ -1016,7 +1014,7 @@ impl<T> Weak<T> {\n     pub fn new() -> Weak<T> {\n         unsafe {\n             Weak {\n-                ptr: Shared::new(Box::into_raw(box RcBox {\n+                ptr: Shared::from(Box::into_unique(box RcBox {\n                     strong: Cell::new(0),\n                     weak: Cell::new(1),\n                     value: uninitialized(),"}, {"sha": "8a1d14b48a1a340132d68d6737796f62d811f534", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=b5b7266b786cb953581ba588d400bddcdae4a852", "patch": "@@ -1126,7 +1126,7 @@ impl<T> Vec<T> {\n                 tail_start: end,\n                 tail_len: len - end,\n                 iter: range_slice.iter(),\n-                vec: Shared::new(self as *mut _),\n+                vec: Shared::from(self),\n             }\n         }\n     }\n@@ -1727,7 +1727,7 @@ impl<T> IntoIterator for Vec<T> {\n             let cap = self.buf.cap();\n             mem::forget(self);\n             IntoIter {\n-                buf: Shared::new(begin),\n+                buf: Shared::new_unchecked(begin),\n                 cap: cap,\n                 ptr: begin,\n                 end: end,"}, {"sha": "fdd6c79ef2e9d74d8971033c588b7d0236cf76aa", "filename": "src/liballoc/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Fliballoc%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Fliballoc%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec_deque.rs?ref=b5b7266b786cb953581ba588d400bddcdae4a852", "patch": "@@ -893,7 +893,7 @@ impl<T> VecDeque<T> {\n         self.head = drain_tail;\n \n         Drain {\n-            deque: unsafe { Shared::new(self as *mut _) },\n+            deque: Shared::from(&mut *self),\n             after_tail: drain_head,\n             after_head: head,\n             iter: Iter {"}, {"sha": "3ff1068b93763581de7f71133b75bd8194eb1ea6", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 72, "deletions": 17, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=b5b7266b786cb953581ba588d400bddcdae4a852", "patch": "@@ -16,22 +16,48 @@\n use ops::CoerceUnsized;\n \n /// Unsafe trait to indicate what types are usable with the NonZero struct\n-pub unsafe trait Zeroable {}\n-\n-unsafe impl<T:?Sized> Zeroable for *const T {}\n-unsafe impl<T:?Sized> Zeroable for *mut T {}\n-unsafe impl Zeroable for isize {}\n-unsafe impl Zeroable for usize {}\n-unsafe impl Zeroable for i8 {}\n-unsafe impl Zeroable for u8 {}\n-unsafe impl Zeroable for i16 {}\n-unsafe impl Zeroable for u16 {}\n-unsafe impl Zeroable for i32 {}\n-unsafe impl Zeroable for u32 {}\n-unsafe impl Zeroable for i64 {}\n-unsafe impl Zeroable for u64 {}\n-unsafe impl Zeroable for i128 {}\n-unsafe impl Zeroable for u128 {}\n+pub unsafe trait Zeroable {\n+    /// Whether this value is zero\n+    fn is_zero(&self) -> bool;\n+}\n+\n+macro_rules! impl_zeroable_for_pointer_types {\n+    ( $( $Ptr: ty )+ ) => {\n+        $(\n+            /// For fat pointers to be considered \"zero\", only the \"data\" part needs to be null.\n+            unsafe impl<T: ?Sized> Zeroable for $Ptr {\n+                #[inline]\n+                fn is_zero(&self) -> bool {\n+                    // Cast because `is_null` is only available on thin pointers\n+                    (*self as *mut u8).is_null()\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+macro_rules! impl_zeroable_for_integer_types {\n+    ( $( $Int: ty )+ ) => {\n+        $(\n+            unsafe impl Zeroable for $Int {\n+                #[inline]\n+                fn is_zero(&self) -> bool {\n+                    *self == 0\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+impl_zeroable_for_pointer_types! {\n+    *const T\n+    *mut T\n+}\n+\n+impl_zeroable_for_integer_types! {\n+    usize u8 u16 u32 u64 u128\n+    isize i8 i16 i32 i64 i128\n+}\n \n /// A wrapper type for raw pointers and integers that will never be\n /// NULL or 0 that might allow certain optimizations.\n@@ -43,14 +69,43 @@ impl<T: Zeroable> NonZero<T> {\n     /// Creates an instance of NonZero with the provided value.\n     /// You must indeed ensure that the value is actually \"non-zero\".\n     #[inline]\n-    pub const unsafe fn new(inner: T) -> NonZero<T> {\n+    pub const unsafe fn new_unchecked(inner: T) -> Self {\n         NonZero(inner)\n     }\n \n+    /// Creates an instance of NonZero with the provided value.\n+    #[inline]\n+    pub fn new(inner: T) -> Option<Self> {\n+        if inner.is_zero() {\n+            None\n+        } else {\n+            Some(NonZero(inner))\n+        }\n+    }\n+\n     /// Gets the inner value.\n     pub fn get(self) -> T {\n         self.0\n     }\n }\n \n impl<T: Zeroable+CoerceUnsized<U>, U: Zeroable> CoerceUnsized<NonZero<U>> for NonZero<T> {}\n+\n+impl<'a, T: ?Sized> From<&'a mut T> for NonZero<*mut T> {\n+    fn from(reference: &'a mut T) -> Self {\n+        NonZero(reference)\n+    }\n+}\n+\n+impl<'a, T: ?Sized> From<&'a mut T> for NonZero<*const T> {\n+    fn from(reference: &'a mut T) -> Self {\n+        let ptr: *mut T = reference;\n+        NonZero(ptr)\n+    }\n+}\n+\n+impl<'a, T: ?Sized> From<&'a T> for NonZero<*const T> {\n+    fn from(reference: &'a T) -> Self {\n+        NonZero(reference)\n+    }\n+}"}, {"sha": "60cf1a2053068862dacfe63bb2d434034fecb621", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 54, "deletions": 8, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=b5b7266b786cb953581ba588d400bddcdae4a852", "patch": "@@ -16,6 +16,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use convert::From;\n use intrinsics;\n use ops::CoerceUnsized;\n use fmt;\n@@ -1098,7 +1099,7 @@ impl<T: Sized> Unique<T> {\n     pub fn empty() -> Self {\n         unsafe {\n             let ptr = mem::align_of::<T>() as *mut T;\n-            Unique::new(ptr)\n+            Unique::new_unchecked(ptr)\n         }\n     }\n }\n@@ -1110,8 +1111,13 @@ impl<T: ?Sized> Unique<T> {\n     /// # Safety\n     ///\n     /// `ptr` must be non-null.\n-    pub const unsafe fn new(ptr: *mut T) -> Unique<T> {\n-        Unique { pointer: NonZero::new(ptr), _marker: PhantomData }\n+    pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n+        Unique { pointer: NonZero::new_unchecked(ptr), _marker: PhantomData }\n+    }\n+\n+    /// Creates a new `Unique` if `ptr` is non-null.\n+    pub fn new(ptr: *mut T) -> Option<Self> {\n+        NonZero::new(ptr as *const T).map(|nz| Unique { pointer: nz, _marker: PhantomData })\n     }\n \n     /// Acquires the underlying `*mut` pointer.\n@@ -1138,14 +1144,14 @@ impl<T: ?Sized> Unique<T> {\n     }\n }\n \n-#[unstable(feature = \"shared\", issue = \"27730\")]\n+#[unstable(feature = \"unique\", issue = \"27730\")]\n impl<T: ?Sized> Clone for Unique<T> {\n     fn clone(&self) -> Self {\n         *self\n     }\n }\n \n-#[unstable(feature = \"shared\", issue = \"27730\")]\n+#[unstable(feature = \"unique\", issue = \"27730\")]\n impl<T: ?Sized> Copy for Unique<T> { }\n \n #[unstable(feature = \"unique\", issue = \"27730\")]\n@@ -1158,6 +1164,20 @@ impl<T: ?Sized> fmt::Pointer for Unique<T> {\n     }\n }\n \n+#[unstable(feature = \"unique\", issue = \"27730\")]\n+impl<'a, T: ?Sized> From<&'a mut T> for Unique<T> {\n+    fn from(reference: &'a mut T) -> Self {\n+        Unique { pointer: NonZero::from(reference), _marker: PhantomData }\n+    }\n+}\n+\n+#[unstable(feature = \"unique\", issue = \"27730\")]\n+impl<'a, T: ?Sized> From<&'a T> for Unique<T> {\n+    fn from(reference: &'a T) -> Self {\n+        Unique { pointer: NonZero::from(reference), _marker: PhantomData }\n+    }\n+}\n+\n /// A wrapper around a raw `*mut T` that indicates that the possessor\n /// of this wrapper has shared ownership of the referent. Useful for\n /// building abstractions like `Rc<T>`, `Arc<T>`, or doubly-linked lists, which\n@@ -1212,7 +1232,7 @@ impl<T: Sized> Shared<T> {\n     pub fn empty() -> Self {\n         unsafe {\n             let ptr = mem::align_of::<T>() as *mut T;\n-            Shared::new(ptr)\n+            Shared::new_unchecked(ptr)\n         }\n     }\n }\n@@ -1224,8 +1244,13 @@ impl<T: ?Sized> Shared<T> {\n     /// # Safety\n     ///\n     /// `ptr` must be non-null.\n-    pub unsafe fn new(ptr: *mut T) -> Self {\n-        Shared { pointer: NonZero::new(ptr), _marker: PhantomData }\n+    pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n+        Shared { pointer: NonZero::new_unchecked(ptr), _marker: PhantomData }\n+    }\n+\n+    /// Creates a new `Shared` if `ptr` is non-null.\n+    pub fn new(ptr: *mut T) -> Option<Self> {\n+        NonZero::new(ptr as *const T).map(|nz| Shared { pointer: nz, _marker: PhantomData })\n     }\n \n     /// Acquires the underlying `*mut` pointer.\n@@ -1278,3 +1303,24 @@ impl<T: ?Sized> fmt::Pointer for Shared<T> {\n         fmt::Pointer::fmt(&self.as_ptr(), f)\n     }\n }\n+\n+#[unstable(feature = \"shared\", issue = \"27730\")]\n+impl<T: ?Sized> From<Unique<T>> for Shared<T> {\n+    fn from(unique: Unique<T>) -> Self {\n+        Shared { pointer: unique.pointer, _marker: PhantomData }\n+    }\n+}\n+\n+#[unstable(feature = \"shared\", issue = \"27730\")]\n+impl<'a, T: ?Sized> From<&'a mut T> for Shared<T> {\n+    fn from(reference: &'a mut T) -> Self {\n+        Shared { pointer: NonZero::from(reference), _marker: PhantomData }\n+    }\n+}\n+\n+#[unstable(feature = \"shared\", issue = \"27730\")]\n+impl<'a, T: ?Sized> From<&'a T> for Shared<T> {\n+    fn from(reference: &'a T) -> Self {\n+        Shared { pointer: NonZero::from(reference), _marker: PhantomData }\n+    }\n+}"}, {"sha": "a795dd575043dd883d2f1e00576eca63cecbc570", "filename": "src/libcore/tests/nonzero.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Flibcore%2Ftests%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Flibcore%2Ftests%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnonzero.rs?ref=b5b7266b786cb953581ba588d400bddcdae4a852", "patch": "@@ -16,7 +16,7 @@ use std::mem::size_of;\n #[test]\n fn test_create_nonzero_instance() {\n     let _a = unsafe {\n-        NonZero::new(21)\n+        NonZero::new_unchecked(21)\n     };\n }\n \n@@ -28,14 +28,14 @@ fn test_size_nonzero_in_option() {\n #[test]\n fn test_match_on_nonzero_option() {\n     let a = Some(unsafe {\n-        NonZero::new(42)\n+        NonZero::new_unchecked(42)\n     });\n     match a {\n         Some(val) => assert_eq!(val.get(), 42),\n         None => panic!(\"unexpected None while matching on Some(NonZero(_))\")\n     }\n \n-    match unsafe { Some(NonZero::new(43)) } {\n+    match unsafe { Some(NonZero::new_unchecked(43)) } {\n         Some(val) => assert_eq!(val.get(), 43),\n         None => panic!(\"unexpected None while matching on Some(NonZero(_))\")\n     }"}, {"sha": "c2d53840f8f570e572c6fc48ba5114bb4fb577b8", "filename": "src/libcore/tests/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Flibcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Flibcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fptr.rs?ref=b5b7266b786cb953581ba588d400bddcdae4a852", "patch": "@@ -167,7 +167,7 @@ fn test_set_memory() {\n #[test]\n fn test_unsized_unique() {\n     let xs: &[i32] = &[1, 2, 3];\n-    let ptr = unsafe { Unique::new(xs as *const [i32] as *mut [i32]) };\n+    let ptr = unsafe { Unique::new_unchecked(xs as *const [i32] as *mut [i32]) };\n     let ys = unsafe { ptr.as_ref() };\n     let zs: &[i32] = &[1, 2, 3];\n     assert!(ys == zs);"}, {"sha": "e2881ac9b798e81ccf56db8b9aac588cc2608eb9", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=b5b7266b786cb953581ba588d400bddcdae4a852", "patch": "@@ -47,7 +47,7 @@ impl<'tcx> From<Ty<'tcx>> for Kind<'tcx> {\n         let ptr = ty as *const _ as usize;\n         Kind {\n             ptr: unsafe {\n-                NonZero::new(ptr | TYPE_TAG)\n+                NonZero::new_unchecked(ptr | TYPE_TAG)\n             },\n             marker: PhantomData\n         }\n@@ -62,7 +62,7 @@ impl<'tcx> From<ty::Region<'tcx>> for Kind<'tcx> {\n         let ptr = r as *const _ as usize;\n         Kind {\n             ptr: unsafe {\n-                NonZero::new(ptr | REGION_TAG)\n+                NonZero::new_unchecked(ptr | REGION_TAG)\n             },\n             marker: PhantomData\n         }"}, {"sha": "ced73e9e4262767cd4f740200b8116b7ae876ccd", "filename": "src/librustc_data_structures/array_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=b5b7266b786cb953581ba588d400bddcdae4a852", "patch": "@@ -146,7 +146,7 @@ impl<A: Array> ArrayVec<A> {\n                 tail_start: end,\n                 tail_len: len - end,\n                 iter: range_slice.iter(),\n-                array_vec: Shared::new(self as *mut _),\n+                array_vec: Shared::from(self),\n             }\n         }\n     }"}, {"sha": "a72cc6b57eade5fa6c0ed07ff28d02581fd91860", "filename": "src/librustc_data_structures/obligation_forest/node_index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs?ref=b5b7266b786cb953581ba588d400bddcdae4a852", "patch": "@@ -19,7 +19,7 @@ pub struct NodeIndex {\n impl NodeIndex {\n     pub fn new(value: usize) -> NodeIndex {\n         assert!(value < (u32::MAX as usize));\n-        unsafe { NodeIndex { index: NonZero::new((value as u32) + 1) } }\n+        NodeIndex { index: NonZero::new((value as u32) + 1).unwrap() }\n     }\n \n     pub fn get(self) -> usize {"}, {"sha": "fbf977b98f901b2f47bcb0c5418318efd65e2662", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=b5b7266b786cb953581ba588d400bddcdae4a852", "patch": "@@ -42,7 +42,7 @@ pub(crate) mod indexes {\n \n             impl Idx for $Index {\n                 fn new(idx: usize) -> Self {\n-                    unsafe { $Index(NonZero::new(idx + 1)) }\n+                    $Index(NonZero::new(idx + 1).unwrap())\n                 }\n                 fn index(self) -> usize {\n                     self.0.get() - 1"}, {"sha": "3844690860b5a7aa9e6e15658ab2352f308231eb", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=b5b7266b786cb953581ba588d400bddcdae4a852", "patch": "@@ -44,7 +44,7 @@ impl TaggedHashUintPtr {\n     #[inline]\n     unsafe fn new(ptr: *mut HashUint) -> Self {\n         debug_assert!(ptr as usize & 1 == 0 || ptr as usize == EMPTY as usize);\n-        TaggedHashUintPtr(Unique::new(ptr))\n+        TaggedHashUintPtr(Unique::new_unchecked(ptr))\n     }\n \n     #[inline]\n@@ -56,7 +56,7 @@ impl TaggedHashUintPtr {\n             } else {\n                 usize_ptr &= !1;\n             }\n-            self.0 = Unique::new(usize_ptr as *mut HashUint)\n+            self.0 = Unique::new_unchecked(usize_ptr as *mut HashUint)\n         }\n     }\n \n@@ -877,7 +877,7 @@ impl<K, V> RawTable<K, V> {\n                 elems_left: elems_left,\n                 marker: marker::PhantomData,\n             },\n-            table: unsafe { Shared::new(self) },\n+            table: Shared::from(self),\n             marker: marker::PhantomData,\n         }\n     }"}, {"sha": "aa13d6fad47c9f188bf4e855438559467caa99ec", "filename": "src/test/run-pass/issue-23433.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Ftest%2Frun-pass%2Fissue-23433.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Ftest%2Frun-pass%2Fissue-23433.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23433.rs?ref=b5b7266b786cb953581ba588d400bddcdae4a852", "patch": "@@ -16,7 +16,7 @@ use std::ptr::Unique;\n \n fn main() {\n     let mut a = [0u8; 5];\n-    let b: Option<Unique<[u8]>> = unsafe { Some(Unique::new(&mut a)) };\n+    let b: Option<Unique<[u8]>> = Some(Unique::from(&mut a));\n     match b {\n         Some(_) => println!(\"Got `Some`\"),\n         None => panic!(\"Unexpected `None`\"),"}, {"sha": "5052c59a39dcfcfa2989e48f0b11fff0279bad88", "filename": "src/test/ui/print_type_sizes/nullable.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Ftest%2Fui%2Fprint_type_sizes%2Fnullable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b7266b786cb953581ba588d400bddcdae4a852/src%2Ftest%2Fui%2Fprint_type_sizes%2Fnullable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fnullable.rs?ref=b5b7266b786cb953581ba588d400bddcdae4a852", "patch": "@@ -42,7 +42,7 @@ impl Default for EmbeddedDiscr {\n }\n \n #[derive(Default)]\n-pub struct IndirectNonZero<T: Zeroable> {\n+pub struct IndirectNonZero<T: Zeroable + One> {\n     pre: u8,\n     nested: NestedNonZero<T>,\n     post: u16,\n@@ -54,14 +54,20 @@ pub struct NestedNonZero<T: Zeroable> {\n     post: u16,\n }\n \n-impl<T: Zeroable+Default> Default for NestedNonZero<T> {\n+impl<T: Zeroable+One> Default for NestedNonZero<T> {\n     fn default() -> Self {\n-        unsafe {\n-            NestedNonZero { pre: 0, val: NonZero::new(Default::default()), post: 0 }\n-        }\n+        NestedNonZero { pre: 0, val: NonZero::new(T::one()).unwrap(), post: 0 }\n     }\n }\n \n+pub trait One {\n+    fn one() -> Self;\n+}\n+\n+impl One for u32 {\n+    fn one() -> Self { 1 }\n+}\n+\n pub fn main() {\n     let _x: MyOption<NonZero<u32>> = Default::default();\n     let _y: EmbeddedDiscr = Default::default();"}]}