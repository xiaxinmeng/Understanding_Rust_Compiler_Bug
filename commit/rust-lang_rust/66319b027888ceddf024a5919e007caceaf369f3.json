{"sha": "66319b027888ceddf024a5919e007caceaf369f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2MzE5YjAyNzg4OGNlZGRmMDI0YTU5MTllMDA3Y2FjZWFmMzY5ZjM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-20T02:46:54Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-20T06:34:32Z"}, "message": "Register snapshots", "tree": {"sha": "d210e635c950974972a086f7caa4268be6f33c93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d210e635c950974972a086f7caa4268be6f33c93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66319b027888ceddf024a5919e007caceaf369f3", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66319b027888ceddf024a5919e007caceaf369f3", "html_url": "https://github.com/rust-lang/rust/commit/66319b027888ceddf024a5919e007caceaf369f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66319b027888ceddf024a5919e007caceaf369f3/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a481c0f88025318eba7c48907a5c1d966e01d27", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a481c0f88025318eba7c48907a5c1d966e01d27", "html_url": "https://github.com/rust-lang/rust/commit/3a481c0f88025318eba7c48907a5c1d966e01d27"}], "stats": {"total": 9868, "additions": 24, "deletions": 9844}, "files": [{"sha": "4e71b62f10cd724e0722aff42dd8be50df125360", "filename": "src/libcore/cast.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcast.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -24,20 +24,6 @@ pub mod rusti {\n }\n \n /// Casts the value at `src` to U. The two types must have the same length.\n-#[cfg(not(stage0))]\n-pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n-    let mut dest: U = unstable::intrinsics::uninit();\n-    {\n-        let dest_ptr: *mut u8 = rusti::transmute(&mut dest);\n-        let src_ptr: *u8 = rusti::transmute(src);\n-        unstable::intrinsics::memmove64(dest_ptr,\n-                                        src_ptr,\n-                                        sys::size_of::<U>() as u64);\n-    }\n-    dest\n-}\n-\n-#[cfg(stage0)]\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n     let mut dest: U = unstable::intrinsics::init();\n     {"}, {"sha": "bd70f59212d2175c9bbb2ada861ac725fb8da7dc", "filename": "src/libcore/char.rs", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -12,9 +12,6 @@\n \n use option::{None, Option, Some};\n use str;\n-#[cfg(stage0)]\n-use str::StrSlice;\n-#[cfg(not(stage0))]\n use str::{StrSlice, OwnedStr};\n use u32;\n use uint;\n@@ -191,21 +188,6 @@ pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n     }\n }\n \n-#[cfg(stage0)]\n-pub fn escape_unicode(c: char) -> ~str {\n-    let s = u32::to_str_radix(c as u32, 16u);\n-    let (c, pad) = (if c <= '\\xff' { ('x', 2u) }\n-                    else if c <= '\\uffff' { ('u', 4u) }\n-                    else { ('U', 8u) });\n-    assert!(str::len(s) <= pad);\n-    let mut out = ~\"\\\\\";\n-    str::push_str(&mut out, str::from_char(c));\n-    for uint::range(str::len(s), pad) |_i|\n-        { str::push_str(&mut out, ~\"0\"); }\n-    str::push_str(&mut out, s);\n-    out\n-}\n-\n ///\n /// Return the hexadecimal unicode escape of a char.\n ///\n@@ -215,7 +197,6 @@ pub fn escape_unicode(c: char) -> ~str {\n /// - chars in [0x100,0xffff] get 4-digit escapes: `\\\\uNNNN`\n /// - chars above 0x10000 get 8-digit escapes: `\\\\UNNNNNNNN`\n ///\n-#[cfg(not(stage0))]\n pub fn escape_unicode(c: char) -> ~str {\n     let s = u32::to_str_radix(c as u32, 16u);\n     let (c, pad) = cond!(\n@@ -258,23 +239,7 @@ pub fn escape_default(c: char) -> ~str {\n     }\n }\n \n-#[cfg(stage0)]\n-pub fn len_utf8_bytes(c: char) -> uint {\n-    static max_one_b: uint = 128u;\n-    static max_two_b: uint = 2048u;\n-    static max_three_b: uint = 65536u;\n-    static max_four_b: uint = 2097152u;\n-\n-    let code = c as uint;\n-    if code < max_one_b { 1u }\n-    else if code < max_two_b { 2u }\n-    else if code < max_three_b { 3u }\n-    else if code < max_four_b { 4u }\n-    else { fail!(\"invalid character!\") }\n-}\n-\n /// Returns the amount of bytes this character would need if encoded in utf8\n-#[cfg(not(stage0))]\n pub fn len_utf8_bytes(c: char) -> uint {\n     static MAX_ONE_B:   uint = 128u;\n     static MAX_TWO_B:   uint = 2048u;"}, {"sha": "5796be7b1e4ce9308f3a1630049a6f7277331c3e", "filename": "src/libcore/cleanup.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcleanup.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -127,33 +127,6 @@ struct AnnihilateStats {\n     n_bytes_freed: uint\n }\n \n-#[cfg(stage0)]\n-unsafe fn each_live_alloc(read_next_before: bool,\n-                          f: &fn(box: *mut BoxRepr, uniq: bool) -> bool) {\n-    //! Walks the internal list of allocations\n-\n-    use managed;\n-\n-    let task: *Task = transmute(rustrt::rust_get_task());\n-    let box = (*task).boxed_region.live_allocs;\n-    let mut box: *mut BoxRepr = transmute(copy box);\n-    while box != mut_null() {\n-        let next_before = transmute(copy (*box).header.next);\n-        let uniq =\n-            (*box).header.ref_count == managed::raw::RC_MANAGED_UNIQUE;\n-\n-        if !f(box, uniq) {\n-            return;\n-        }\n-\n-        if read_next_before {\n-            box = next_before;\n-        } else {\n-            box = transmute(copy (*box).header.next);\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n unsafe fn each_live_alloc(read_next_before: bool,\n                           f: &fn(box: *mut BoxRepr, uniq: bool) -> bool) -> bool {\n     //! Walks the internal list of allocations"}, {"sha": "505aa5881c5c22f325082ec5c889e9b998434dc9", "filename": "src/libcore/container.rs", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcontainer.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -30,31 +30,15 @@ pub trait Map<K, V>: Mutable {\n     fn contains_key(&self, key: &K) -> bool;\n \n     // Visits all keys and values\n-    #[cfg(stage0)]\n-    fn each<'a>(&'a self, f: &fn(&K, &'a V) -> bool);\n-    // Visits all keys and values\n-    #[cfg(not(stage0))]\n     fn each<'a>(&'a self, f: &fn(&K, &'a V) -> bool) -> bool;\n \n     /// Visit all keys\n-    #[cfg(stage0)]\n-    fn each_key(&self, f: &fn(&K) -> bool);\n-    /// Visit all keys\n-    #[cfg(not(stage0))]\n     fn each_key(&self, f: &fn(&K) -> bool) -> bool;\n \n     /// Visit all values\n-    #[cfg(stage0)]\n-    fn each_value<'a>(&'a self, f: &fn(&'a V) -> bool);\n-    /// Visit all values\n-    #[cfg(not(stage0))]\n     fn each_value<'a>(&'a self, f: &fn(&'a V) -> bool) -> bool;\n \n     /// Iterate over the map and mutate the contained values\n-    #[cfg(stage0)]\n-    fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool);\n-    /// Iterate over the map and mutate the contained values\n-    #[cfg(not(stage0))]\n     fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool) -> bool;\n \n     /// Return a reference to the value corresponding to the key\n@@ -81,43 +65,6 @@ pub trait Map<K, V>: Mutable {\n     fn pop(&mut self, k: &K) -> Option<V>;\n }\n \n-#[cfg(stage0)]\n-pub trait Set<T>: Mutable {\n-    /// Return true if the set contains a value\n-    fn contains(&self, value: &T) -> bool;\n-\n-    /// Add a value to the set. Return true if the value was not already\n-    /// present in the set.\n-    fn insert(&mut self, value: T) -> bool;\n-\n-    /// Remove a value from the set. Return true if the value was\n-    /// present in the set.\n-    fn remove(&mut self, value: &T) -> bool;\n-\n-    /// Return true if the set has no elements in common with `other`.\n-    /// This is equivalent to checking for an empty intersection.\n-    fn is_disjoint(&self, other: &Self) -> bool;\n-\n-    /// Return true if the set is a subset of another\n-    fn is_subset(&self, other: &Self) -> bool;\n-\n-    /// Return true if the set is a superset of another\n-    fn is_superset(&self, other: &Self) -> bool;\n-\n-    /// Visit the values representing the difference\n-    fn difference(&self, other: &Self, f: &fn(&T) -> bool);\n-\n-    /// Visit the values representing the symmetric difference\n-    fn symmetric_difference(&self, other: &Self, f: &fn(&T) -> bool);\n-\n-    /// Visit the values representing the intersection\n-    fn intersection(&self, other: &Self, f: &fn(&T) -> bool);\n-\n-    /// Visit the values representing the union\n-    fn union(&self, other: &Self, f: &fn(&T) -> bool);\n-}\n-\n-#[cfg(not(stage0))]\n pub trait Set<T>: Mutable {\n     /// Return true if the set contains a value\n     fn contains(&self, value: &T) -> bool;"}, {"sha": "611b95a7745e4e2a305e533d5b1b5ea17dddfefb", "filename": "src/libcore/gc.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -171,11 +171,6 @@ unsafe fn _walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) -> bool {\n     return true;\n }\n \n-#[cfg(stage0)]\n-unsafe fn walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) {\n-    _walk_safe_point(fp, sp, visitor);\n-}\n-#[cfg(not(stage0))]\n unsafe fn walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) -> bool {\n     _walk_safe_point(fp, sp, visitor)\n }\n@@ -303,11 +298,6 @@ unsafe fn _walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) -> boo\n     return true;\n }\n \n-#[cfg(stage0)]\n-unsafe fn walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) {\n-    _walk_gc_roots(mem, sentinel, visitor);\n-}\n-#[cfg(not(stage0))]\n unsafe fn walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) -> bool {\n     _walk_gc_roots(mem, sentinel, visitor)\n }"}, {"sha": "d116c966c5cb336cb04fe1beb3e90b9d8dcad1e5", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -19,8 +19,6 @@\n  * CPRNG like rand::rng.\n  */\n \n-#[cfg(stage0)]\n-use cast;\n use container::Container;\n use old_iter::BaseIter;\n use rt::io::Writer;\n@@ -78,14 +76,6 @@ pub trait Streaming {\n     fn reset(&mut self);\n }\n \n-// XXX: Ugly workaround for bootstrapping.\n-#[cfg(stage0)]\n-fn transmute_for_stage0<'a>(bytes: &'a [const u8]) -> &'a [u8] {\n-    unsafe {\n-        cast::transmute(bytes)\n-    }\n-}\n-#[cfg(not(stage0))]\n fn transmute_for_stage0<'a>(bytes: &'a [u8]) -> &'a [u8] {\n     bytes\n }"}, {"sha": "4770d38895192b93d907273b360f7a9088ec92e0", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 0, "deletions": 185, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -87,22 +87,6 @@ priv impl<K:Hash + Eq,V> HashMap<K, V> {\n     }\n \n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn bucket_sequence(&self, hash: uint,\n-                       op: &fn(uint) -> bool) {\n-        let start_idx = self.to_bucket(hash);\n-        let len_buckets = self.buckets.len();\n-        let mut idx = start_idx;\n-        loop {\n-            if !op(idx) { return; }\n-            idx = self.next_bucket(idx, len_buckets);\n-            if idx == start_idx {\n-                return;\n-            }\n-        }\n-    }\n-    #[inline(always)]\n-    #[cfg(not(stage0))]\n     fn bucket_sequence(&self, hash: uint,\n                        op: &fn(uint) -> bool) -> bool {\n         let start_idx = self.to_bucket(hash);\n@@ -318,19 +302,6 @@ impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n     }\n \n     /// Visit all key-value pairs\n-    #[cfg(stage0)]\n-    fn each<'a>(&'a self, blk: &fn(&K, &'a V) -> bool) {\n-        for uint::range(0, self.buckets.len()) |i| {\n-            for self.buckets[i].each |bucket| {\n-                if !blk(&bucket.key, &bucket.value) {\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Visit all key-value pairs\n-    #[cfg(not(stage0))]\n     fn each<'a>(&'a self, blk: &fn(&K, &'a V) -> bool) -> bool {\n         for uint::range(0, self.buckets.len()) |i| {\n             for self.buckets[i].each |bucket| {\n@@ -343,44 +314,16 @@ impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n     }\n \n     /// Visit all keys\n-    #[cfg(stage0)]\n-    fn each_key(&self, blk: &fn(k: &K) -> bool) {\n-        self.each(|k, _| blk(k))\n-    }\n-\n-    /// Visit all keys\n-    #[cfg(not(stage0))]\n     fn each_key(&self, blk: &fn(k: &K) -> bool) -> bool {\n         self.each(|k, _| blk(k))\n     }\n \n     /// Visit all values\n-    #[cfg(stage0)]\n-    fn each_value<'a>(&'a self, blk: &fn(v: &'a V) -> bool) {\n-        self.each(|_, v| blk(v))\n-    }\n-\n-    /// Visit all values\n-    #[cfg(not(stage0))]\n     fn each_value<'a>(&'a self, blk: &fn(v: &'a V) -> bool) -> bool {\n         self.each(|_, v| blk(v))\n     }\n \n     /// Iterate over the map and mutate the contained values\n-    #[cfg(stage0)]\n-    fn mutate_values(&mut self, blk: &fn(&K, &mut V) -> bool) {\n-        for uint::range(0, self.buckets.len()) |i| {\n-            match self.buckets[i] {\n-              Some(Bucket{key: ref key, value: ref mut value, _}) => {\n-                if !blk(key, value) { return }\n-              }\n-              None => ()\n-            }\n-        }\n-    }\n-\n-    /// Iterate over the map and mutate the contained values\n-    #[cfg(not(stage0))]\n     fn mutate_values(&mut self, blk: &fn(&K, &mut V) -> bool) -> bool {\n         for uint::range(0, self.buckets.len()) |i| {\n             match self.buckets[i] {\n@@ -402,19 +345,6 @@ impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n     }\n \n     /// Return a mutable reference to the value corresponding to the key\n-    #[cfg(stage0)]\n-    fn find_mut<'a>(&'a mut self, k: &K) -> Option<&'a mut V> {\n-        let idx = match self.bucket_for_key(k) {\n-            FoundEntry(idx) => idx,\n-            TableFull | FoundHole(_) => return None\n-        };\n-        unsafe {\n-            Some(::cast::transmute_mut_region(self.mut_value_for_bucket(idx)))\n-        }\n-    }\n-\n-    /// Return a mutable reference to the value corresponding to the key\n-    #[cfg(not(stage0))]\n     fn find_mut<'a>(&'a mut self, k: &K) -> Option<&'a mut V> {\n         let idx = match self.bucket_for_key(k) {\n             FoundEntry(idx) => idx,\n@@ -485,38 +415,6 @@ pub impl<K: Hash + Eq, V> HashMap<K, V> {\n \n     /// Return the value corresponding to the key in the map, or insert\n     /// and return the value if it doesn't exist.\n-    #[cfg(stage0)]\n-    fn find_or_insert<'a>(&'a mut self, k: K, v: V) -> &'a V {\n-        if self.size >= self.resize_at {\n-            // n.b.: We could also do this after searching, so\n-            // that we do not resize if this call to insert is\n-            // simply going to update a key in place.  My sense\n-            // though is that it's worse to have to search through\n-            // buckets to find the right spot twice than to just\n-            // resize in this corner case.\n-            self.expand();\n-        }\n-\n-        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n-        let idx = match self.bucket_for_key_with_hash(hash, &k) {\n-            TableFull => fail!(\"Internal logic error\"),\n-            FoundEntry(idx) => idx,\n-            FoundHole(idx) => {\n-                self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n-                                     value: v});\n-                self.size += 1;\n-                idx\n-            },\n-        };\n-\n-        unsafe {\n-            ::cast::transmute_region(self.value_for_bucket(idx))\n-        }\n-    }\n-\n-    /// Return the value corresponding to the key in the map, or insert\n-    /// and return the value if it doesn't exist.\n-    #[cfg(not(stage0))]\n     fn find_or_insert<'a>(&'a mut self, k: K, v: V) -> &'a V {\n         if self.size >= self.resize_at {\n             // n.b.: We could also do this after searching, so\n@@ -545,39 +443,6 @@ pub impl<K: Hash + Eq, V> HashMap<K, V> {\n \n     /// Return the value corresponding to the key in the map, or create,\n     /// insert, and return a new value if it doesn't exist.\n-    #[cfg(stage0)]\n-    fn find_or_insert_with<'a>(&'a mut self, k: K, f: &fn(&K) -> V) -> &'a V {\n-        if self.size >= self.resize_at {\n-            // n.b.: We could also do this after searching, so\n-            // that we do not resize if this call to insert is\n-            // simply going to update a key in place.  My sense\n-            // though is that it's worse to have to search through\n-            // buckets to find the right spot twice than to just\n-            // resize in this corner case.\n-            self.expand();\n-        }\n-\n-        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n-        let idx = match self.bucket_for_key_with_hash(hash, &k) {\n-            TableFull => fail!(\"Internal logic error\"),\n-            FoundEntry(idx) => idx,\n-            FoundHole(idx) => {\n-                let v = f(&k);\n-                self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n-                                     value: v});\n-                self.size += 1;\n-                idx\n-            },\n-        };\n-\n-        unsafe {\n-            ::cast::transmute_region(self.value_for_bucket(idx))\n-        }\n-    }\n-\n-    /// Return the value corresponding to the key in the map, or create,\n-    /// insert, and return a new value if it doesn't exist.\n-    #[cfg(not(stage0))]\n     fn find_or_insert_with<'a>(&'a mut self, k: K, f: &fn(&K) -> V) -> &'a V {\n         if self.size >= self.resize_at {\n             // n.b.: We could also do this after searching, so\n@@ -680,9 +545,6 @@ pub struct HashSet<T> {\n \n impl<T:Hash + Eq> BaseIter<T> for HashSet<T> {\n     /// Visit all values in order\n-    #[cfg(stage0)]\n-    fn each(&self, f: &fn(&T) -> bool) { self.map.each_key(f) }\n-    #[cfg(not(stage0))]\n     fn each(&self, f: &fn(&T) -> bool) -> bool { self.map.each_key(f) }\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n@@ -734,70 +596,23 @@ impl<T:Hash + Eq> Set<T> for HashSet<T> {\n     }\n \n     /// Visit the values representing the difference\n-    #[cfg(stage0)]\n-    fn difference(&self, other: &HashSet<T>, f: &fn(&T) -> bool) {\n-        for self.each |v| {\n-            if !other.contains(v) {\n-                if !f(v) { return }\n-            }\n-        }\n-    }\n-\n-    /// Visit the values representing the difference\n-    #[cfg(not(stage0))]\n     fn difference(&self, other: &HashSet<T>, f: &fn(&T) -> bool) -> bool {\n         self.each(|v| other.contains(v) || f(v))\n     }\n \n     /// Visit the values representing the symmetric difference\n-    #[cfg(stage0)]\n-    fn symmetric_difference(&self,\n-                            other: &HashSet<T>,\n-                            f: &fn(&T) -> bool) {\n-        self.difference(other, f);\n-        other.difference(self, f);\n-    }\n-\n-    /// Visit the values representing the symmetric difference\n-    #[cfg(not(stage0))]\n     fn symmetric_difference(&self,\n                             other: &HashSet<T>,\n                             f: &fn(&T) -> bool) -> bool {\n         self.difference(other, f) && other.difference(self, f)\n     }\n \n     /// Visit the values representing the intersection\n-    #[cfg(stage0)]\n-    fn intersection(&self, other: &HashSet<T>, f: &fn(&T) -> bool) {\n-        for self.each |v| {\n-            if other.contains(v) {\n-                if !f(v) { return }\n-            }\n-        }\n-    }\n-\n-    /// Visit the values representing the intersection\n-    #[cfg(not(stage0))]\n     fn intersection(&self, other: &HashSet<T>, f: &fn(&T) -> bool) -> bool {\n         self.each(|v| !other.contains(v) || f(v))\n     }\n \n     /// Visit the values representing the union\n-    #[cfg(stage0)]\n-    fn union(&self, other: &HashSet<T>, f: &fn(&T) -> bool) {\n-        for self.each |v| {\n-            if !f(v) { return }\n-        }\n-\n-        for other.each |v| {\n-            if !self.contains(v) {\n-                if !f(v) { return }\n-            }\n-        }\n-    }\n-\n-    /// Visit the values representing the union\n-    #[cfg(not(stage0))]\n     fn union(&self, other: &HashSet<T>, f: &fn(&T) -> bool) -> bool {\n         self.each(f) && other.each(|v| self.contains(v) || f(v))\n     }"}, {"sha": "2ffd362519f155d1e9ed4ad692bd1bb0b0ebdce8", "filename": "src/libcore/io.rs", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -282,9 +282,6 @@ pub trait ReaderUtil {\n     *\n     * None right now.\n     */\n-    #[cfg(stage0)]\n-    fn each_byte(&self, it: &fn(int) -> bool);\n-    #[cfg(not(stage0))]\n     fn each_byte(&self, it: &fn(int) -> bool) -> bool;\n \n     /**\n@@ -294,9 +291,6 @@ pub trait ReaderUtil {\n     *\n     * None right now.\n     */\n-    #[cfg(stage0)]\n-    fn each_char(&self, it: &fn(char) -> bool);\n-    #[cfg(not(stage0))]\n     fn each_char(&self, it: &fn(char) -> bool) -> bool;\n \n     /**\n@@ -306,9 +300,6 @@ pub trait ReaderUtil {\n     *\n     * None right now.\n     */\n-    #[cfg(stage0)]\n-    fn each_line(&self, it: &fn(&str) -> bool);\n-    #[cfg(not(stage0))]\n     fn each_line(&self, it: &fn(&str) -> bool) -> bool;\n \n     /**\n@@ -720,55 +711,20 @@ impl<T:Reader> ReaderUtil for T {\n         bytes\n     }\n \n-    #[cfg(stage0)]\n-    fn each_byte(&self, it: &fn(int) -> bool) {\n-        while !self.eof() {\n-            if !it(self.read_byte()) { break; }\n-        }\n-    }\n-    #[cfg(not(stage0))]\n     fn each_byte(&self, it: &fn(int) -> bool) -> bool {\n         while !self.eof() {\n             if !it(self.read_byte()) { return false; }\n         }\n         return true;\n     }\n \n-    #[cfg(stage0)]\n-    fn each_char(&self, it: &fn(char) -> bool) {\n-        while !self.eof() {\n-            if !it(self.read_char()) { break; }\n-        }\n-    }\n-    #[cfg(not(stage0))]\n     fn each_char(&self, it: &fn(char) -> bool) -> bool {\n         while !self.eof() {\n             if !it(self.read_char()) { return false; }\n         }\n         return true;\n     }\n \n-    #[cfg(stage0)]\n-    fn each_line(&self, it: &fn(s: &str) -> bool) {\n-        while !self.eof() {\n-            // include the \\n, so that we can distinguish an entirely empty\n-            // line read after \"...\\n\", and the trailing empty line in\n-            // \"...\\n\\n\".\n-            let mut line = self.read_until('\\n' as u8, true);\n-\n-            // blank line at the end of the reader is ignored\n-            if self.eof() && line.is_empty() { break; }\n-\n-            // trim the \\n, so that each_line is consistent with read_line\n-            let n = str::len(line);\n-            if line[n-1] == '\\n' as u8 {\n-                unsafe { str::raw::set_len(&mut line, n-1); }\n-            }\n-\n-            if !it(line) { break; }\n-        }\n-    }\n-    #[cfg(not(stage0))]\n     fn each_line(&self, it: &fn(s: &str) -> bool) -> bool {\n         while !self.eof() {\n             // include the \\n, so that we can distinguish an entirely empty"}, {"sha": "57a076bb0829b9af0fc948d5f5e2bedf5529decc", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 5, "deletions": 42, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -40,17 +40,12 @@ much easier to implement.\n \n */\n \n-#[cfg(not(stage0))] use cmp::Ord;\n-#[cfg(not(stage0))] use option::{Option, Some, None};\n-#[cfg(not(stage0))] use vec::OwnedVector;\n-#[cfg(not(stage0))] use num::{One, Zero};\n-#[cfg(not(stage0))] use ops::{Add, Mul};\n+use cmp::Ord;\n+use option::{Option, Some, None};\n+use vec::OwnedVector;\n+use num::{One, Zero};\n+use ops::{Add, Mul};\n \n-#[cfg(stage0)]\n-pub trait Times {\n-    fn times(&self, it: &fn() -> bool);\n-}\n-#[cfg(not(stage0))]\n pub trait Times {\n     fn times(&self, it: &fn() -> bool) -> bool;\n }\n@@ -67,7 +62,6 @@ pub trait Times {\n  * ~~~\n  */\n #[inline(always)]\n-#[cfg(not(stage0))]\n pub fn to_vec<T>(iter: &fn(f: &fn(T) -> bool) -> bool) -> ~[T] {\n     let mut v = ~[];\n     for iter |x| { v.push(x) }\n@@ -86,7 +80,6 @@ pub fn to_vec<T>(iter: &fn(f: &fn(T) -> bool) -> bool) -> ~[T] {\n  * ~~~~\n  */\n #[inline(always)]\n-#[cfg(not(stage0))]\n pub fn any<T>(predicate: &fn(T) -> bool,\n               iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n     for iter |x| {\n@@ -108,29 +101,6 @@ pub fn any<T>(predicate: &fn(T) -> bool,\n  * ~~~~\n  */\n #[inline(always)]\n-#[cfg(stage0)]\n-pub fn all<T>(predicate: &fn(T) -> bool,\n-              iter: &fn(f: &fn(T) -> bool)) -> bool {\n-    for iter |x| {\n-        if !predicate(x) {\n-            return false;\n-        }\n-    }\n-    return true;\n-}\n-\n-/**\n- * Return true if `predicate` is true for all values yielded by an internal iterator.\n- *\n- * # Example:\n- *\n- * ~~~~\n- * assert!(all(|&x: &uint| x < 6, |f| uint::range(1, 6, f)));\n- * assert!(!all(|&x: &uint| x < 5, |f| uint::range(1, 6, f)));\n- * ~~~~\n- */\n-#[inline(always)]\n-#[cfg(not(stage0))]\n pub fn all<T>(predicate: &fn(T) -> bool,\n               iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n     // If we ever break, iter will return false, so this will only return true\n@@ -149,7 +119,6 @@ pub fn all<T>(predicate: &fn(T) -> bool,\n  * ~~~~\n  */\n #[inline(always)]\n-#[cfg(not(stage0))]\n pub fn find<T>(predicate: &fn(&T) -> bool,\n                iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n     for iter |x| {\n@@ -171,7 +140,6 @@ pub fn find<T>(predicate: &fn(&T) -> bool,\n  * ~~~~\n  */\n #[inline]\n-#[cfg(not(stage0))]\n pub fn max<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n     let mut result = None;\n     for iter |x| {\n@@ -198,7 +166,6 @@ pub fn max<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n  * ~~~~\n  */\n #[inline]\n-#[cfg(not(stage0))]\n pub fn min<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n     let mut result = None;\n     for iter |x| {\n@@ -223,7 +190,6 @@ pub fn min<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n  * assert_eq!(fold(0i, |f| int::range(1, 5, f), |a, x| *a += x), 10);\n  * ~~~~\n  */\n-#[cfg(not(stage0))]\n #[inline]\n pub fn fold<T, U>(start: T, iter: &fn(f: &fn(U) -> bool) -> bool, f: &fn(&mut T, U)) -> T {\n     let mut result = start;\n@@ -247,7 +213,6 @@ pub fn fold<T, U>(start: T, iter: &fn(f: &fn(U) -> bool) -> bool, f: &fn(&mut T,\n  * }\n  * ~~~~\n  */\n-#[cfg(not(stage0))]\n #[inline]\n pub fn fold_ref<T, U>(start: T, iter: &fn(f: &fn(&U) -> bool) -> bool, f: &fn(&mut T, &U)) -> T {\n     let mut result = start;\n@@ -267,7 +232,6 @@ pub fn fold_ref<T, U>(start: T, iter: &fn(f: &fn(&U) -> bool) -> bool, f: &fn(&m\n  * assert_eq!(do sum |f| { xs.each(f) }, 10);\n  * ~~~~\n  */\n-#[cfg(not(stage0))]\n #[inline(always)]\n pub fn sum<T: Zero + Add<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n     fold_ref(Zero::zero::<T>(), iter, |a, x| *a = a.add(x))\n@@ -283,7 +247,6 @@ pub fn sum<T: Zero + Add<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n  * assert_eq!(do product |f| { xs.each(f) }, 24);\n  * ~~~~\n  */\n-#[cfg(not(stage0))]\n #[inline(always)]\n pub fn product<T: One + Mul<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n     fold_ref(One::one::<T>(), iter, |a, x| *a = a.mul(x))"}, {"sha": "a5679e6dbff204d3d76b470f30c1fd2294d0aed5", "filename": "src/libcore/iterator.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiterator.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -43,11 +43,7 @@ pub trait IteratorUtil<A> {\n     fn take(self, n: uint) -> TakeIterator<Self>;\n     fn scan<'r, St, B>(self, initial_state: St, f: &'r fn(&mut St, A) -> Option<B>)\n         -> ScanIterator<'r, A, B, Self, St>;\n-    #[cfg(stage0)]\n-    fn advance(&mut self, f: &fn(A) -> bool);\n-    #[cfg(not(stage0))]\n     fn advance(&mut self, f: &fn(A) -> bool) -> bool;\n-    #[cfg(not(stage0))]\n     fn to_vec(&mut self) -> ~[A];\n     fn nth(&mut self, n: uint) -> Option<A>;\n     fn last(&mut self) -> Option<A>;\n@@ -121,21 +117,6 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n \n     /// A shim implementing the `for` loop iteration protocol for iterator objects\n     #[inline]\n-    #[cfg(stage0)]\n-    fn advance(&mut self, f: &fn(A) -> bool) {\n-        loop {\n-            match self.next() {\n-                Some(x) => {\n-                    if !f(x) { return; }\n-                }\n-                None => { return; }\n-            }\n-        }\n-    }\n-\n-    /// A shim implementing the `for` loop iteration protocol for iterator objects\n-    #[inline]\n-    #[cfg(not(stage0))]\n     fn advance(&mut self, f: &fn(A) -> bool) -> bool {\n         loop {\n             match self.next() {\n@@ -147,7 +128,6 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n         }\n     }\n \n-    #[cfg(not(stage0))]\n     #[inline(always)]\n     fn to_vec(&mut self) -> ~[A] {\n         iter::to_vec::<A>(|f| self.advance(f))"}, {"sha": "d9b3e35b6b9d76623c8b897023ae95d96671b360", "filename": "src/libcore/kinds.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fkinds.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -51,9 +51,3 @@ pub trait Owned {\n pub trait Const {\n     // Empty.\n }\n-\n-#[lang=\"durable\"]\n-#[cfg(stage0)]\n-pub trait Durable {\n-    // Empty.\n-}"}, {"sha": "d5dc0dd4730e179b39467575f90d3aa0d3a5e693", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -248,18 +248,8 @@ impl Orderable for f32 {\n         if self.is_NaN() || other.is_NaN() { Float::NaN() } else { fmax(*self, *other) }\n     }\n \n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn clamp(&self, mn: &f32, mx: &f32) -> f32 {\n-        if self.is_NaN() { *self }\n-        else if !(*self <= *mx) { *mx }\n-        else if !(*self >= *mn) { *mn }\n-        else { *self }\n-    }\n-\n     /// Returns the number constrained within the range `mn <= self <= mx`.\n     /// If any of the numbers are `NaN` then `NaN` is returned.\n-    #[cfg(not(stage0))]\n     #[inline(always)]\n     fn clamp(&self, mn: &f32, mx: &f32) -> f32 {\n         cond!("}, {"sha": "6e2496e2e4561dff2116e37f508bdee0cd687079", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -270,18 +270,8 @@ impl Orderable for f64 {\n         if self.is_NaN() || other.is_NaN() { Float::NaN() } else { fmax(*self, *other) }\n     }\n \n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn clamp(&self, mn: &f64, mx: &f64) -> f64 {\n-        if self.is_NaN() { *self }\n-        else if !(*self <= *mx) { *mx }\n-        else if !(*self >= *mn) { *mn }\n-        else { *self }\n-    }\n-\n     /// Returns the number constrained within the range `mn <= self <= mx`.\n     /// If any of the numbers are `NaN` then `NaN` is returned.\n-    #[cfg(not(stage0))]\n     #[inline(always)]\n     fn clamp(&self, mn: &f64, mx: &f64) -> f64 {\n         cond!("}, {"sha": "3c31a7d574518c9436539ca023272e2f5f6801bc", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -108,37 +108,17 @@ pub fn _range_step(start: T, stop: T, step: T, it: &fn(T) -> bool) -> bool {\n     return true;\n }\n \n-#[cfg(stage0)]\n-pub fn range_step(start: T, stop: T, step: T, it: &fn(T) -> bool) {\n-    _range_step(start, stop, step, it);\n-}\n-#[cfg(not(stage0))]\n pub fn range_step(start: T, stop: T, step: T, it: &fn(T) -> bool) -> bool {\n     _range_step(start, stop, step, it)\n }\n \n #[inline(always)]\n-#[cfg(stage0)]\n-/// Iterate over the range [`lo`..`hi`)\n-pub fn range(lo: T, hi: T, it: &fn(T) -> bool) {\n-    range_step(lo, hi, 1 as T, it);\n-}\n-\n-#[inline(always)]\n-#[cfg(not(stage0))]\n /// Iterate over the range [`lo`..`hi`)\n pub fn range(lo: T, hi: T, it: &fn(T) -> bool) -> bool {\n     range_step(lo, hi, 1 as T, it)\n }\n \n #[inline(always)]\n-#[cfg(stage0)]\n-/// Iterate over the range [`hi`..`lo`)\n-pub fn range_rev(hi: T, lo: T, it: &fn(T) -> bool) {\n-    range_step(hi, lo, -1 as T, it);\n-}\n-#[inline(always)]\n-#[cfg(not(stage0))]\n /// Iterate over the range [`hi`..`lo`)\n pub fn range_rev(hi: T, lo: T, it: &fn(T) -> bool) -> bool {\n     range_step(hi, lo, -1 as T, it)\n@@ -187,15 +167,7 @@ impl Orderable for T {\n         if *self > *other { *self } else { *other }\n     }\n \n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn clamp(&self, mn: &T, mx: &T) -> T {\n-        if *self > *mx { *mx } else\n-        if *self < *mn { *mn } else { *self }\n-    }\n-\n     /// Returns the number constrained within the range `mn <= self <= mx`.\n-    #[cfg(not(stage0))]\n     #[inline(always)]\n     fn clamp(&self, mn: &T, mx: &T) -> T {\n         cond!("}, {"sha": "66ff16cbeb1ef03d9ee6a166f9e28df2e694c08e", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -77,38 +77,17 @@ pub fn _range_step(start: T,\n     return true;\n }\n \n-#[cfg(stage0)]\n-pub fn range_step(start: T, stop: T, step: T_SIGNED, it: &fn(T) -> bool) {\n-    _range_step(start, stop, step, it);\n-}\n-#[cfg(not(stage0))]\n pub fn range_step(start: T, stop: T, step: T_SIGNED, it: &fn(T) -> bool) -> bool {\n     _range_step(start, stop, step, it)\n }\n \n #[inline(always)]\n-#[cfg(stage0)]\n-/// Iterate over the range [`lo`..`hi`)\n-pub fn range(lo: T, hi: T, it: &fn(T) -> bool) {\n-    range_step(lo, hi, 1 as T_SIGNED, it);\n-}\n-\n-#[inline(always)]\n-#[cfg(not(stage0))]\n /// Iterate over the range [`lo`..`hi`)\n pub fn range(lo: T, hi: T, it: &fn(T) -> bool) -> bool {\n     range_step(lo, hi, 1 as T_SIGNED, it)\n }\n \n #[inline(always)]\n-#[cfg(stage0)]\n-/// Iterate over the range [`hi`..`lo`)\n-pub fn range_rev(hi: T, lo: T, it: &fn(T) -> bool) {\n-    range_step(hi, lo, -1 as T_SIGNED, it);\n-}\n-\n-#[inline(always)]\n-#[cfg(not(stage0))]\n /// Iterate over the range [`hi`..`lo`)\n pub fn range_rev(hi: T, lo: T, it: &fn(T) -> bool) -> bool {\n     range_step(hi, lo, -1 as T_SIGNED, it)\n@@ -153,15 +132,7 @@ impl Orderable for T {\n         if *self > *other { *self } else { *other }\n     }\n \n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn clamp(&self, mn: &T, mx: &T) -> T {\n-        if *self > *mx { *mx } else\n-        if *self < *mn { *mn } else { *self }\n-    }\n-\n     /// Returns the number constrained within the range `mn <= self <= mx`.\n-    #[cfg(not(stage0))]\n     #[inline(always)]\n     fn clamp(&self, mn: &T, mx: &T) -> T {\n         cond!("}, {"sha": "763c305f2214941b462d960ed2e8abf072d3c34a", "filename": "src/libcore/num/uint-template/uint.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -154,29 +154,6 @@ pub mod inst {\n         return true;\n     }\n \n-    #[cfg(stage0)]\n-    impl iter::Times for uint {\n-        #[inline(always)]\n-        ///\n-        /// A convenience form for basic iteration. Given a uint `x`,\n-        /// `for x.times { ... }` executes the given block x times.\n-        ///\n-        /// Equivalent to `for uint::range(0, x) |_| { ... }`.\n-        ///\n-        /// Not defined on all integer types to permit unambiguous\n-        /// use with integer literals of inferred integer-type as\n-        /// the self-value (eg. `for 100.times { ... }`).\n-        ///\n-        fn times(&self, it: &fn() -> bool) {\n-            let mut i = *self;\n-            while i > 0 {\n-                if !it() { break }\n-                i -= 1;\n-            }\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     impl iter::Times for uint {\n         #[inline(always)]\n         ///"}, {"sha": "389b643572cb6b2089968f6aff850e324fa76124", "filename": "src/libcore/old_iter.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fold_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fold_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fold_iter.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -22,39 +22,20 @@ use vec;\n /// A function used to initialize the elements of a sequence\n pub type InitOp<'self,T> = &'self fn(uint) -> T;\n \n-#[cfg(stage0)]\n-pub trait BaseIter<A> {\n-    fn each(&self, blk: &fn(v: &A) -> bool);\n-    fn size_hint(&self) -> Option<uint>;\n-}\n-#[cfg(not(stage0))]\n pub trait BaseIter<A> {\n     fn each(&self, blk: &fn(v: &A) -> bool) -> bool;\n     fn size_hint(&self) -> Option<uint>;\n }\n \n-#[cfg(stage0)]\n-pub trait ReverseIter<A>: BaseIter<A> {\n-    fn each_reverse(&self, blk: &fn(&A) -> bool);\n-}\n-#[cfg(not(stage0))]\n pub trait ReverseIter<A>: BaseIter<A> {\n     fn each_reverse(&self, blk: &fn(&A) -> bool) -> bool;\n }\n \n-#[cfg(stage0)]\n-pub trait MutableIter<A>: BaseIter<A> {\n-    fn each_mut(&mut self, blk: &fn(&mut A) -> bool);\n-}\n-#[cfg(not(stage0))]\n pub trait MutableIter<A>: BaseIter<A> {\n     fn each_mut(&mut self, blk: &fn(&mut A) -> bool) -> bool;\n }\n \n pub trait ExtendedIter<A> {\n-    #[cfg(stage0)]\n-    fn eachi(&self, blk: &fn(uint, v: &A) -> bool);\n-    #[cfg(not(stage0))]\n     fn eachi(&self, blk: &fn(uint, v: &A) -> bool) -> bool;\n     fn all(&self, blk: &fn(&A) -> bool) -> bool;\n     fn any(&self, blk: &fn(&A) -> bool) -> bool;\n@@ -64,11 +45,6 @@ pub trait ExtendedIter<A> {\n     fn flat_map_to_vec<B,IB: BaseIter<B>>(&self, op: &fn(&A) -> IB) -> ~[B];\n }\n \n-#[cfg(stage0)]\n-pub trait ExtendedMutableIter<A> {\n-    fn eachi_mut(&mut self, blk: &fn(uint, &mut A) -> bool);\n-}\n-#[cfg(not(stage0))]\n pub trait ExtendedMutableIter<A> {\n     fn eachi_mut(&mut self, blk: &fn(uint, &mut A) -> bool) -> bool;\n }\n@@ -127,11 +103,6 @@ pub fn _eachi<A,IA:BaseIter<A>>(this: &IA, blk: &fn(uint, &A) -> bool) -> bool {\n     return true;\n }\n \n-#[cfg(stage0)]\n-pub fn eachi<A,IA:BaseIter<A>>(this: &IA, blk: &fn(uint, &A) -> bool) {\n-    _eachi(this, blk);\n-}\n-#[cfg(not(stage0))]\n pub fn eachi<A,IA:BaseIter<A>>(this: &IA, blk: &fn(uint, &A) -> bool) -> bool {\n     _eachi(this, blk)\n }"}, {"sha": "bc1ffcdc81ae4652c3d17c1ac3c779b87d4de13b", "filename": "src/libcore/option.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -112,13 +112,6 @@ impl<T: Copy + Add<T,T>> Add<Option<T>, Option<T>> for Option<T> {\n impl<T> BaseIter<T> for Option<T> {\n     /// Performs an operation on the contained value by reference\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn each<'a>(&'a self, f: &fn(x: &'a T) -> bool) {\n-        match *self { None => (), Some(ref t) => { f(t); } }\n-    }\n-    /// Performs an operation on the contained value by reference\n-    #[inline(always)]\n-    #[cfg(not(stage0))]\n     fn each<'a>(&'a self, f: &fn(x: &'a T) -> bool) -> bool {\n         match *self { None => true, Some(ref t) => { f(t) } }\n     }\n@@ -130,24 +123,13 @@ impl<T> BaseIter<T> for Option<T> {\n }\n \n impl<T> MutableIter<T> for Option<T> {\n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn each_mut<'a>(&'a mut self, f: &fn(&'a mut T) -> bool) {\n-        match *self { None => (), Some(ref mut t) => { f(t); } }\n-    }\n-    #[cfg(not(stage0))]\n     #[inline(always)]\n     fn each_mut<'a>(&'a mut self, f: &fn(&'a mut T) -> bool) -> bool {\n         match *self { None => true, Some(ref mut t) => { f(t) } }\n     }\n }\n \n impl<A> ExtendedIter<A> for Option<A> {\n-    #[cfg(stage0)]\n-    pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n-        old_iter::eachi(self, blk)\n-    }\n-    #[cfg(not(stage0))]\n     pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) -> bool {\n         old_iter::eachi(self, blk)\n     }"}, {"sha": "b6943462f068bfdc09353a1a3c012497502e8acc", "filename": "src/libcore/os.rs", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -575,37 +575,8 @@ pub fn tmpdir() -> Path {\n                    getenv_nonempty(\"WINDIR\")))).get_or_default(Path(\"C:\\\\Windows\"))\n     }\n }\n+\n /// Recursively walk a directory structure\n-#[cfg(stage0)]\n-pub fn walk_dir(p: &Path, f: &fn(&Path) -> bool) {\n-\n-    walk_dir_(p, f);\n-\n-    fn walk_dir_(p: &Path, f: &fn(&Path) -> bool) -> bool {\n-        let mut keepgoing = true;\n-        do list_dir(p).each |q| {\n-            let path = &p.push(*q);\n-            if !f(path) {\n-                keepgoing = false;\n-                false\n-            } else {\n-                if path_is_dir(path) {\n-                    if !walk_dir_(path, f) {\n-                        keepgoing = false;\n-                        false\n-                    } else {\n-                        true\n-                    }\n-                } else {\n-                    true\n-                }\n-            }\n-        }\n-        return keepgoing;\n-    }\n-}\n-/// Recursively walk a directory structure\n-#[cfg(not(stage0))]\n pub fn walk_dir(p: &Path, f: &fn(&Path) -> bool) -> bool {\n     list_dir(p).each(|q| {\n         let path = &p.push(*q);"}, {"sha": "93afbea82786ad5e171d07f77481b72bd976a99c", "filename": "src/libcore/rt/comm.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fcomm.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -22,9 +22,6 @@ use ops::Drop;\n use kinds::Owned;\n use rt::sched::Coroutine;\n use rt::local_sched;\n-#[cfg(stage0)]\n-use unstable::intrinsics::{atomic_xchg};\n-#[cfg(not(stage0))]\n use unstable::intrinsics::{atomic_xchg, atomic_load};\n use util::Void;\n use comm::{GenericChan, GenericSmartChan, GenericPort, Peekable};\n@@ -210,10 +207,6 @@ impl<T> PortOne<T> {\n }\n \n impl<T> Peekable<T> for PortOne<T> {\n-    #[cfg(stage0)]\n-    fn peek(&self) -> bool { fail!() }\n-\n-    #[cfg(not(stage0))]\n     fn peek(&self) -> bool {\n         unsafe {\n             let packet: *mut Packet<T> = self.inner.packet();"}, {"sha": "0ec51a3aa941ee15c1eb83e17392d9c3af809369", "filename": "src/libcore/rt/io/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fmod.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -253,26 +253,20 @@ pub use self::stdio::println;\n \n pub use self::file::FileStream;\n pub use self::net::ip::IpAddr;\n-#[cfg(not(stage0))]\n pub use self::net::tcp::TcpListener;\n-#[cfg(not(stage0))]\n pub use self::net::tcp::TcpStream;\n pub use self::net::udp::UdpStream;\n \n // Some extension traits that all Readers and Writers get.\n-#[cfg(not(stage0))] // Requires condition! fixes\n pub use self::extensions::ReaderUtil;\n-#[cfg(not(stage0))] // Requires condition! fixes\n pub use self::extensions::ReaderByteConversions;\n-#[cfg(not(stage0))] // Requires condition! fixes\n pub use self::extensions::WriterByteConversions;\n \n /// Synchronous, non-blocking file I/O.\n pub mod file;\n \n /// Synchronous, non-blocking network I/O.\n pub mod net {\n-    #[cfg(not(stage0))]\n     pub mod tcp;\n     pub mod udp;\n     pub mod ip;\n@@ -288,7 +282,6 @@ pub mod mem;\n pub mod stdio;\n \n /// Implementations for Option\n-#[cfg(not(stage0))] // Requires condition! fixes\n mod option;\n \n /// Basic stream compression. XXX: Belongs with other flate code\n@@ -298,7 +291,6 @@ pub mod flate;\n pub mod comm_adapters;\n \n /// Extension traits\n-#[cfg(not(stage0))] // Requires condition! fixes\n mod extensions;\n \n /// Non-I/O things needed by the I/O module"}, {"sha": "fbb6753723293b169eb7dc88884a5947c26bc0ff", "filename": "src/libcore/stackwalk.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstackwalk.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -24,35 +24,6 @@ pub fn Frame(fp: *Word) -> Frame {\n     }\n }\n \n-#[cfg(stage0)]\n-pub fn walk_stack(visit: &fn(Frame) -> bool) {\n-\n-    debug!(\"beginning stack walk\");\n-\n-    do frame_address |frame_pointer| {\n-        let mut frame_address: *Word = unsafe {\n-            transmute(frame_pointer)\n-        };\n-        loop {\n-            let fr = Frame(frame_address);\n-\n-            debug!(\"frame: %x\", unsafe { transmute(fr.fp) });\n-            visit(fr);\n-\n-            unsafe {\n-                let next_fp: **Word = transmute(frame_address);\n-                frame_address = *next_fp;\n-                if *frame_address == 0u {\n-                    debug!(\"encountered task_start_wrapper. ending walk\");\n-                    // This is the task_start_wrapper_frame. There is\n-                    // no stack beneath it and it is a foreign frame.\n-                    break;\n-                }\n-            }\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n pub fn walk_stack(visit: &fn(Frame) -> bool) -> bool {\n \n     debug!(\"beginning stack walk\");"}, {"sha": "a760ff8f262772f247cff620e7229ad78e3ec8ca", "filename": "src/libcore/str.rs", "status": "modified", "additions": 8, "deletions": 374, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -557,27 +557,12 @@ pub fn slice<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n }\n \n /// Splits a string into substrings at each occurrence of a given character\n-#[cfg(stage0)]\n-pub fn each_split_char<'a>(s: &'a str, sep: char, it: &fn(&'a str) -> bool) {\n-    each_split_char_inner(s, sep, len(s), true, true, it);\n-}\n-\n-/// Splits a string into substrings at each occurrence of a given character\n-#[cfg(not(stage0))]\n pub fn each_split_char<'a>(s: &'a str, sep: char,\n                            it: &fn(&'a str) -> bool) -> bool {\n     each_split_char_inner(s, sep, len(s), true, true, it)\n }\n \n /// Like `each_split_char`, but a trailing empty string is omitted\n-#[cfg(stage0)]\n-pub fn each_split_char_no_trailing<'a>(s: &'a str,\n-                                       sep: char,\n-                                       it: &fn(&'a str) -> bool) {\n-    each_split_char_inner(s, sep, len(s), true, false, it);\n-}\n-/// Like `each_split_char`, but a trailing empty string is omitted\n-#[cfg(not(stage0))]\n pub fn each_split_char_no_trailing<'a>(s: &'a str,\n                                        sep: char,\n                                        it: &fn(&'a str) -> bool) -> bool {\n@@ -590,20 +575,6 @@ pub fn each_split_char_no_trailing<'a>(s: &'a str,\n  *\n  * The character must be a valid UTF-8/ASCII character\n  */\n-#[cfg(stage0)]\n-pub fn each_splitn_char<'a>(s: &'a str,\n-                            sep: char,\n-                            count: uint,\n-                            it: &fn(&'a str) -> bool) {\n-    each_split_char_inner(s, sep, count, true, true, it);\n-}\n-/**\n- * Splits a string into substrings at each occurrence of a given\n- * character up to 'count' times.\n- *\n- * The character must be a valid UTF-8/ASCII character\n- */\n-#[cfg(not(stage0))]\n pub fn each_splitn_char<'a>(s: &'a str,\n                             sep: char,\n                             count: uint,\n@@ -612,14 +583,6 @@ pub fn each_splitn_char<'a>(s: &'a str,\n }\n \n /// Like `each_split_char`, but omits empty strings\n-#[cfg(stage0)]\n-pub fn each_split_char_nonempty<'a>(s: &'a str,\n-                                    sep: char,\n-                                    it: &fn(&'a str) -> bool) {\n-    each_split_char_inner(s, sep, len(s), false, false, it);\n-}\n-/// Like `each_split_char`, but omits empty strings\n-#[cfg(not(stage0))]\n pub fn each_split_char_nonempty<'a>(s: &'a str,\n                                     sep: char,\n                                     it: &fn(&'a str) -> bool) -> bool {\n@@ -659,29 +622,13 @@ fn each_split_char_inner<'a>(s: &'a str,\n }\n \n /// Splits a string into substrings using a character function\n-#[cfg(stage0)]\n-pub fn each_split<'a>(s: &'a str,\n-                      sepfn: &fn(char) -> bool,\n-                      it: &fn(&'a str) -> bool) {\n-    each_split_inner(s, sepfn, len(s), true, true, it);\n-}\n-/// Splits a string into substrings using a character function\n-#[cfg(not(stage0))]\n pub fn each_split<'a>(s: &'a str,\n                       sepfn: &fn(char) -> bool,\n                       it: &fn(&'a str) -> bool) -> bool {\n     each_split_inner(s, sepfn, len(s), true, true, it)\n }\n \n /// Like `each_split`, but a trailing empty string is omitted\n-#[cfg(stage0)]\n-pub fn each_split_no_trailing<'a>(s: &'a str,\n-                                  sepfn: &fn(char) -> bool,\n-                                  it: &fn(&'a str) -> bool) {\n-    each_split_inner(s, sepfn, len(s), true, false, it);\n-}\n-/// Like `each_split`, but a trailing empty string is omitted\n-#[cfg(not(stage0))]\n pub fn each_split_no_trailing<'a>(s: &'a str,\n                                   sepfn: &fn(char) -> bool,\n                                   it: &fn(&'a str) -> bool) -> bool {\n@@ -692,18 +639,6 @@ pub fn each_split_no_trailing<'a>(s: &'a str,\n  * Splits a string into substrings using a character function, cutting at\n  * most `count` times.\n  */\n-#[cfg(stage0)]\n-pub fn each_splitn<'a>(s: &'a str,\n-                       sepfn: &fn(char) -> bool,\n-                       count: uint,\n-                       it: &fn(&'a str) -> bool) {\n-    each_split_inner(s, sepfn, count, true, true, it);\n-}\n-/**\n- * Splits a string into substrings using a character function, cutting at\n- * most `count` times.\n- */\n-#[cfg(not(stage0))]\n pub fn each_splitn<'a>(s: &'a str,\n                        sepfn: &fn(char) -> bool,\n                        count: uint,\n@@ -712,14 +647,6 @@ pub fn each_splitn<'a>(s: &'a str,\n }\n \n /// Like `each_split`, but omits empty strings\n-#[cfg(stage0)]\n-pub fn each_split_nonempty<'a>(s: &'a str,\n-                               sepfn: &fn(char) -> bool,\n-                               it: &fn(&'a str) -> bool) {\n-    each_split_inner(s, sepfn, len(s), false, false, it);\n-}\n-/// Like `each_split`, but omits empty strings\n-#[cfg(not(stage0))]\n pub fn each_split_nonempty<'a>(s: &'a str,\n                                sepfn: &fn(char) -> bool,\n                                it: &fn(&'a str) -> bool) -> bool {\n@@ -754,36 +681,6 @@ fn each_split_inner<'a>(s: &'a str,\n }\n \n // See Issue #1932 for why this is a naive search\n-#[cfg(stage0)]\n-fn iter_matches<'a,'b>(s: &'a str, sep: &'b str,\n-                       f: &fn(uint, uint) -> bool) {\n-    let sep_len = len(sep), l = len(s);\n-    assert!(sep_len > 0u);\n-    let mut i = 0u, match_start = 0u, match_i = 0u;\n-\n-    while i < l {\n-        if s[i] == sep[match_i] {\n-            if match_i == 0u { match_start = i; }\n-            match_i += 1u;\n-            // Found a match\n-            if match_i == sep_len {\n-                if !f(match_start, i + 1u) { return; }\n-                match_i = 0u;\n-            }\n-            i += 1u;\n-        } else {\n-            // Failed match, backtrack\n-            if match_i > 0u {\n-                match_i = 0u;\n-                i = match_start + 1u;\n-            } else {\n-                i += 1u;\n-            }\n-        }\n-    }\n-}\n-// See Issue #1932 for why this is a naive search\n-#[cfg(not(stage0))]\n fn iter_matches<'a,'b>(s: &'a str, sep: &'b str,\n                        f: &fn(uint, uint) -> bool) -> bool {\n     let sep_len = len(sep), l = len(s);\n@@ -813,18 +710,6 @@ fn iter_matches<'a,'b>(s: &'a str, sep: &'b str,\n     return true;\n }\n \n-#[cfg(stage0)]\n-fn iter_between_matches<'a,'b>(s: &'a str,\n-                               sep: &'b str,\n-                               f: &fn(uint, uint) -> bool) {\n-    let mut last_end = 0u;\n-    for iter_matches(s, sep) |from, to| {\n-        if !f(last_end, from) { return; }\n-        last_end = to;\n-    }\n-    f(last_end, len(s));\n-}\n-#[cfg(not(stage0))]\n fn iter_between_matches<'a,'b>(s: &'a str,\n                                sep: &'b str,\n                                f: &fn(uint, uint) -> bool) -> bool {\n@@ -847,26 +732,6 @@ fn iter_between_matches<'a,'b>(s: &'a str,\n  * assert!(v == [\"\", \"XXX\", \"YYY\", \"\"]);\n  * ~~~\n  */\n-#[cfg(stage0)]\n-pub fn each_split_str<'a,'b>(s: &'a str,\n-                             sep: &'b str,\n-                             it: &fn(&'a str) -> bool) {\n-    for iter_between_matches(s, sep) |from, to| {\n-        if !it( unsafe { raw::slice_bytes(s, from, to) } ) { return; }\n-    }\n-}\n-/**\n- * Splits a string into a vector of the substrings separated by a given string\n- *\n- * # Example\n- *\n- * ~~~\n- * let mut v = ~[];\n- * for each_split_str(\".XXX.YYY.\", \".\") |subs| { v.push(subs); }\n- * assert!(v == [\"\", \"XXX\", \"YYY\", \"\"]);\n- * ~~~\n- */\n-#[cfg(not(stage0))]\n pub fn each_split_str<'a,'b>(s: &'a str,\n                              sep: &'b str,\n                              it: &fn(&'a str) -> bool) -> bool {\n@@ -876,18 +741,6 @@ pub fn each_split_str<'a,'b>(s: &'a str,\n     return true;\n }\n \n-#[cfg(stage0)]\n-pub fn each_split_str_nonempty<'a,'b>(s: &'a str,\n-                                      sep: &'b str,\n-                                      it: &fn(&'a str) -> bool) {\n-    for iter_between_matches(s, sep) |from, to| {\n-        if to > from {\n-            if !it( unsafe { raw::slice_bytes(s, from, to) } ) { return; }\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n pub fn each_split_str_nonempty<'a,'b>(s: &'a str,\n                                       sep: &'b str,\n                                       it: &fn(&'a str) -> bool) -> bool {\n@@ -936,14 +789,6 @@ pub fn levdistance(s: &str, t: &str) -> uint {\n /**\n  * Splits a string into substrings separated by LF ('\\n').\n  */\n-#[cfg(stage0)]\n-pub fn each_line<'a>(s: &'a str, it: &fn(&'a str) -> bool) {\n-    each_split_char_no_trailing(s, '\\n', it);\n-}\n-/**\n- * Splits a string into substrings separated by LF ('\\n').\n- */\n-#[cfg(not(stage0))]\n pub fn each_line<'a>(s: &'a str, it: &fn(&'a str) -> bool) -> bool {\n     each_split_char_no_trailing(s, '\\n', it)\n }\n@@ -952,22 +797,6 @@ pub fn each_line<'a>(s: &'a str, it: &fn(&'a str) -> bool) -> bool {\n  * Splits a string into substrings separated by LF ('\\n')\n  * and/or CR LF (\"\\r\\n\")\n  */\n-#[cfg(stage0)]\n-pub fn each_line_any<'a>(s: &'a str, it: &fn(&'a str) -> bool) {\n-    for each_line(s) |s| {\n-        let l = s.len();\n-        if l > 0u && s[l - 1u] == '\\r' as u8 {\n-            if !it( unsafe { raw::slice_bytes(s, 0, l - 1) } ) { return; }\n-        } else {\n-            if !it( s ) { return; }\n-        }\n-    }\n-}\n-/**\n- * Splits a string into substrings separated by LF ('\\n')\n- * and/or CR LF (\"\\r\\n\")\n- */\n-#[cfg(not(stage0))]\n pub fn each_line_any<'a>(s: &'a str, it: &fn(&'a str) -> bool) -> bool {\n     for each_line(s) |s| {\n         let l = s.len();\n@@ -981,12 +810,6 @@ pub fn each_line_any<'a>(s: &'a str, it: &fn(&'a str) -> bool) -> bool {\n }\n \n /// Splits a string into substrings separated by whitespace\n-#[cfg(stage0)]\n-pub fn each_word<'a>(s: &'a str, it: &fn(&'a str) -> bool) {\n-    each_split_nonempty(s, char::is_whitespace, it);\n-}\n-/// Splits a string into substrings separated by whitespace\n-#[cfg(not(stage0))]\n pub fn each_word<'a>(s: &'a str, it: &fn(&'a str) -> bool) -> bool {\n     each_split_nonempty(s, char::is_whitespace, it)\n }\n@@ -1063,13 +886,6 @@ pub fn _each_split_within<'a>(ss: &'a str,\n     return cont;\n }\n \n-#[cfg(stage0)]\n-pub fn each_split_within<'a>(ss: &'a str,\n-                             lim: uint,\n-                             it: &fn(&'a str) -> bool) {\n-    _each_split_within(ss, lim, it);\n-}\n-#[cfg(not(stage0))]\n pub fn each_split_within<'a>(ss: &'a str,\n                              lim: uint,\n                              it: &fn(&'a str) -> bool) -> bool {\n@@ -1352,33 +1168,12 @@ pub fn map(ss: &str, ff: &fn(char) -> char) -> ~str {\n \n /// Iterate over the bytes in a string\n #[inline(always)]\n-#[cfg(stage0)]\n-pub fn each(s: &str, it: &fn(u8) -> bool) {\n-    eachi(s, |_i, b| it(b))\n-}\n-/// Iterate over the bytes in a string\n-#[inline(always)]\n-#[cfg(not(stage0))]\n pub fn each(s: &str, it: &fn(u8) -> bool) -> bool {\n     eachi(s, |_i, b| it(b))\n }\n \n /// Iterate over the bytes in a string, with indices\n #[inline(always)]\n-#[cfg(stage0)]\n-pub fn eachi(s: &str, it: &fn(uint, u8) -> bool) {\n-    let mut pos = 0;\n-    let len = s.len();\n-\n-    while pos < len {\n-        if !it(pos, s[pos]) { break; }\n-        pos += 1;\n-    }\n-}\n-\n-/// Iterate over the bytes in a string, with indices\n-#[inline(always)]\n-#[cfg(not(stage0))]\n pub fn eachi(s: &str, it: &fn(uint, u8) -> bool) -> bool {\n     let mut pos = 0;\n     let len = s.len();\n@@ -1392,30 +1187,12 @@ pub fn eachi(s: &str, it: &fn(uint, u8) -> bool) -> bool {\n \n /// Iterate over the bytes in a string in reverse\n #[inline(always)]\n-#[cfg(stage0)]\n-pub fn each_reverse(s: &str, it: &fn(u8) -> bool) {\n-    eachi_reverse(s, |_i, b| it(b) )\n-}\n-/// Iterate over the bytes in a string in reverse\n-#[inline(always)]\n-#[cfg(not(stage0))]\n pub fn each_reverse(s: &str, it: &fn(u8) -> bool) -> bool {\n     eachi_reverse(s, |_i, b| it(b) )\n }\n \n /// Iterate over the bytes in a string in reverse, with indices\n #[inline(always)]\n-#[cfg(stage0)]\n-pub fn eachi_reverse(s: &str, it: &fn(uint, u8) -> bool) {\n-    let mut pos = s.len();\n-    while pos > 0 {\n-        pos -= 1;\n-        if !it(pos, s[pos]) { break; }\n-    }\n-}\n-/// Iterate over the bytes in a string in reverse, with indices\n-#[inline(always)]\n-#[cfg(not(stage0))]\n pub fn eachi_reverse(s: &str, it: &fn(uint, u8) -> bool) -> bool {\n     let mut pos = s.len();\n     while pos > 0 {\n@@ -1427,19 +1204,6 @@ pub fn eachi_reverse(s: &str, it: &fn(uint, u8) -> bool) -> bool {\n \n /// Iterate over each char of a string, without allocating\n #[inline(always)]\n-#[cfg(stage0)]\n-pub fn each_char(s: &str, it: &fn(char) -> bool) {\n-    let mut i = 0;\n-    let len = len(s);\n-    while i < len {\n-        let CharRange {ch, next} = char_range_at(s, i);\n-        if !it(ch) { return; }\n-        i = next;\n-    }\n-}\n-/// Iterate over each char of a string, without allocating\n-#[inline(always)]\n-#[cfg(not(stage0))]\n pub fn each_char(s: &str, it: &fn(char) -> bool) -> bool {\n     let mut i = 0;\n     let len = len(s);\n@@ -1453,21 +1217,6 @@ pub fn each_char(s: &str, it: &fn(char) -> bool) -> bool {\n \n /// Iterates over the chars in a string, with indices\n #[inline(always)]\n-#[cfg(stage0)]\n-pub fn each_chari(s: &str, it: &fn(uint, char) -> bool) {\n-    let mut pos = 0;\n-    let mut ch_pos = 0u;\n-    let len = s.len();\n-    while pos < len {\n-        let CharRange {ch, next} = char_range_at(s, pos);\n-        pos = next;\n-        if !it(ch_pos, ch) { break; }\n-        ch_pos += 1u;\n-    }\n-}\n-/// Iterates over the chars in a string, with indices\n-#[inline(always)]\n-#[cfg(not(stage0))]\n pub fn each_chari(s: &str, it: &fn(uint, char) -> bool) -> bool {\n     let mut pos = 0;\n     let mut ch_pos = 0u;\n@@ -1483,35 +1232,12 @@ pub fn each_chari(s: &str, it: &fn(uint, char) -> bool) -> bool {\n \n /// Iterates over the chars in a string in reverse\n #[inline(always)]\n-#[cfg(stage0)]\n-pub fn each_char_reverse(s: &str, it: &fn(char) -> bool) {\n-    each_chari_reverse(s, |_, c| it(c))\n-}\n-/// Iterates over the chars in a string in reverse\n-#[inline(always)]\n-#[cfg(not(stage0))]\n pub fn each_char_reverse(s: &str, it: &fn(char) -> bool) -> bool {\n     each_chari_reverse(s, |_, c| it(c))\n }\n \n // Iterates over the chars in a string in reverse, with indices\n #[inline(always)]\n-#[cfg(stage0)]\n-pub fn each_chari_reverse(s: &str, it: &fn(uint, char) -> bool) {\n-    let mut pos = s.len();\n-    let mut ch_pos = s.char_len();\n-    while pos > 0 {\n-        let CharRange {ch, next} = char_range_at_reverse(s, pos);\n-        pos = next;\n-        ch_pos -= 1;\n-\n-        if !it(ch_pos, ch) { break; }\n-\n-    }\n-}\n-// Iterates over the chars in a string in reverse, with indices\n-#[inline(always)]\n-#[cfg(not(stage0))]\n pub fn each_chari_reverse(s: &str, it: &fn(uint, char) -> bool) -> bool {\n     let mut pos = s.len();\n     let mut ch_pos = s.char_len();\n@@ -2761,40 +2487,23 @@ pub trait StrSlice<'self> {\n     fn contains<'a>(&self, needle: &'a str) -> bool;\n     fn contains_char(&self, needle: char) -> bool;\n     fn char_iter(&self) -> StrCharIterator<'self>;\n-    #[cfg(stage0)]      fn each(&self, it: &fn(u8) -> bool);\n-    #[cfg(not(stage0))] fn each(&self, it: &fn(u8) -> bool) -> bool;\n-    #[cfg(stage0)]      fn eachi(&self, it: &fn(uint, u8) -> bool);\n-    #[cfg(not(stage0))] fn eachi(&self, it: &fn(uint, u8) -> bool) -> bool;\n-    #[cfg(stage0)]      fn each_reverse(&self, it: &fn(u8) -> bool);\n-    #[cfg(not(stage0))] fn each_reverse(&self, it: &fn(u8) -> bool) -> bool;\n-    #[cfg(stage0)]      fn eachi_reverse(&self, it: &fn(uint, u8) -> bool);\n-    #[cfg(not(stage0))] fn eachi_reverse(&self, it: &fn(uint, u8) -> bool) -> bool;\n-    #[cfg(stage0)]      fn each_char(&self, it: &fn(char) -> bool);\n-    #[cfg(not(stage0))] fn each_char(&self, it: &fn(char) -> bool) -> bool;\n-    #[cfg(stage0)]      fn each_chari(&self, it: &fn(uint, char) -> bool);\n-    #[cfg(not(stage0))] fn each_chari(&self, it: &fn(uint, char) -> bool) -> bool;\n-    #[cfg(stage0)]      fn each_char_reverse(&self, it: &fn(char) -> bool);\n-    #[cfg(not(stage0))] fn each_char_reverse(&self, it: &fn(char) -> bool) -> bool;\n-    #[cfg(stage0)]      fn each_chari_reverse(&self, it: &fn(uint, char) -> bool);\n-    #[cfg(not(stage0))] fn each_chari_reverse(&self, it: &fn(uint, char) -> bool) -> bool;\n+    fn each(&self, it: &fn(u8) -> bool) -> bool;\n+    fn eachi(&self, it: &fn(uint, u8) -> bool) -> bool;\n+    fn each_reverse(&self, it: &fn(u8) -> bool) -> bool;\n+    fn eachi_reverse(&self, it: &fn(uint, u8) -> bool) -> bool;\n+    fn each_char(&self, it: &fn(char) -> bool) -> bool;\n+    fn each_chari(&self, it: &fn(uint, char) -> bool) -> bool;\n+    fn each_char_reverse(&self, it: &fn(char) -> bool) -> bool;\n+    fn each_chari_reverse(&self, it: &fn(uint, char) -> bool) -> bool;\n     fn ends_with(&self, needle: &str) -> bool;\n     fn is_empty(&self) -> bool;\n     fn is_whitespace(&self) -> bool;\n     fn is_alphanumeric(&self) -> bool;\n     fn len(&self) -> uint;\n     fn char_len(&self) -> uint;\n     fn slice(&self, begin: uint, end: uint) -> &'self str;\n-    #[cfg(stage0)]\n-    fn each_split(&self, sepfn: &fn(char) -> bool, it: &fn(&'self str) -> bool);\n-    #[cfg(not(stage0))]\n     fn each_split(&self, sepfn: &fn(char) -> bool, it: &fn(&'self str) -> bool) -> bool;\n-    #[cfg(stage0)]\n-    fn each_split_char(&self, sep: char, it: &fn(&'self str) -> bool);\n-    #[cfg(not(stage0))]\n     fn each_split_char(&self, sep: char, it: &fn(&'self str) -> bool) -> bool;\n-    #[cfg(stage0)]\n-    fn each_split_str<'a>(&self, sep: &'a str, it: &fn(&'self str) -> bool);\n-    #[cfg(not(stage0))]\n     fn each_split_str<'a>(&self, sep: &'a str, it: &fn(&'self str) -> bool) -> bool;\n     fn starts_with<'a>(&self, needle: &'a str) -> bool;\n     fn substr(&self, begin: uint, n: uint) -> &'self str;\n@@ -2848,83 +2557,34 @@ impl<'self> StrSlice<'self> for &'self str {\n \n     /// Iterate over the bytes in a string\n     #[inline]\n-    #[cfg(stage0)]\n-    fn each(&self, it: &fn(u8) -> bool) { each(*self, it) }\n-    /// Iterate over the bytes in a string\n-    #[inline]\n-    #[cfg(not(stage0))]\n     fn each(&self, it: &fn(u8) -> bool) -> bool { each(*self, it) }\n     /// Iterate over the bytes in a string, with indices\n     #[inline]\n-    #[cfg(stage0)]\n-    fn eachi(&self, it: &fn(uint, u8) -> bool) { eachi(*self, it) }\n-    /// Iterate over the bytes in a string, with indices\n-    #[inline]\n-    #[cfg(not(stage0))]\n     fn eachi(&self, it: &fn(uint, u8) -> bool) -> bool { eachi(*self, it) }\n     /// Iterate over the bytes in a string\n     #[inline]\n-    #[cfg(stage0)]\n-    fn each_reverse(&self, it: &fn(u8) -> bool) { each_reverse(*self, it) }\n-    /// Iterate over the bytes in a string\n-    #[inline]\n-    #[cfg(not(stage0))]\n     fn each_reverse(&self, it: &fn(u8) -> bool) -> bool { each_reverse(*self, it) }\n     /// Iterate over the bytes in a string, with indices\n     #[inline]\n-    #[cfg(stage0)]\n-    fn eachi_reverse(&self, it: &fn(uint, u8) -> bool) {\n-        eachi_reverse(*self, it)\n-    }\n-    /// Iterate over the bytes in a string, with indices\n-    #[inline]\n-    #[cfg(not(stage0))]\n     fn eachi_reverse(&self, it: &fn(uint, u8) -> bool) -> bool {\n         eachi_reverse(*self, it)\n     }\n     /// Iterate over the chars in a string\n     #[inline]\n-    #[cfg(stage0)]\n-    fn each_char(&self, it: &fn(char) -> bool) { each_char(*self, it) }\n-    /// Iterate over the chars in a string\n-    #[inline]\n-    #[cfg(not(stage0))]\n     fn each_char(&self, it: &fn(char) -> bool) -> bool { each_char(*self, it) }\n     /// Iterate over the chars in a string, with indices\n     #[inline]\n-    #[cfg(stage0)]\n-    fn each_chari(&self, it: &fn(uint, char) -> bool) {\n-        each_chari(*self, it)\n-    }\n-    /// Iterate over the chars in a string, with indices\n-    #[inline]\n-    #[cfg(not(stage0))]\n     fn each_chari(&self, it: &fn(uint, char) -> bool) -> bool {\n         each_chari(*self, it)\n     }\n     /// Iterate over the chars in a string in reverse\n     #[inline]\n-    #[cfg(stage0)]\n-    fn each_char_reverse(&self, it: &fn(char) -> bool) {\n-        each_char_reverse(*self, it)\n-    }\n-    /// Iterate over the chars in a string in reverse\n-    #[inline]\n-    #[cfg(not(stage0))]\n     fn each_char_reverse(&self, it: &fn(char) -> bool) -> bool {\n         each_char_reverse(*self, it)\n     }\n     /// Iterate over the chars in a string in reverse, with indices from the\n     /// end\n     #[inline]\n-    #[cfg(stage0)]\n-    fn each_chari_reverse(&self, it: &fn(uint, char) -> bool) {\n-        each_chari_reverse(*self, it)\n-    }\n-    /// Iterate over the chars in a string in reverse, with indices from the\n-    /// end\n-    #[inline]\n-    #[cfg(not(stage0))]\n     fn each_chari_reverse(&self, it: &fn(uint, char) -> bool) -> bool {\n         each_chari_reverse(*self, it)\n     }\n@@ -2969,29 +2629,13 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n     /// Splits a string into substrings using a character function\n     #[inline]\n-    #[cfg(stage0)]\n-    fn each_split(&self, sepfn: &fn(char) -> bool, it: &fn(&'self str) -> bool) {\n-        each_split(*self, sepfn, it)\n-    }\n-    /// Splits a string into substrings using a character function\n-    #[inline]\n-    #[cfg(not(stage0))]\n     fn each_split(&self, sepfn: &fn(char) -> bool, it: &fn(&'self str) -> bool) -> bool {\n         each_split(*self, sepfn, it)\n     }\n     /**\n      * Splits a string into substrings at each occurrence of a given character\n      */\n     #[inline]\n-    #[cfg(stage0)]\n-    fn each_split_char(&self, sep: char, it: &fn(&'self str) -> bool) {\n-        each_split_char(*self, sep, it)\n-    }\n-    /**\n-     * Splits a string into substrings at each occurrence of a given character\n-     */\n-    #[inline]\n-    #[cfg(not(stage0))]\n     fn each_split_char(&self, sep: char, it: &fn(&'self str) -> bool) -> bool {\n         each_split_char(*self, sep, it)\n     }\n@@ -3000,16 +2644,6 @@ impl<'self> StrSlice<'self> for &'self str {\n      * string\n      */\n     #[inline]\n-    #[cfg(stage0)]\n-    fn each_split_str<'a>(&self, sep: &'a str, it: &fn(&'self str) -> bool) {\n-        each_split_str(*self, sep, it)\n-    }\n-    /**\n-     * Splits a string into a vector of the substrings separated by a given\n-     * string\n-     */\n-    #[inline]\n-    #[cfg(not(stage0))]\n     fn each_split_str<'a>(&self, sep: &'a str, it: &fn(&'self str) -> bool) -> bool {\n         each_split_str(*self, sep, it)\n     }"}, {"sha": "8d287b5c51f7db7dd58da67156cbbc60e3d8a9df", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -110,11 +110,6 @@ fn taskset_remove(tasks: &mut TaskSet, task: *rust_task) {\n     let was_present = tasks.remove(&task);\n     assert!(was_present);\n }\n-#[cfg(stage0)]\n-pub fn taskset_each(tasks: &TaskSet, blk: &fn(v: *rust_task) -> bool) {\n-    tasks.each(|k| blk(*k))\n-}\n-#[cfg(not(stage0))]\n pub fn taskset_each(tasks: &TaskSet, blk: &fn(v: *rust_task) -> bool) -> bool {\n     tasks.each(|k| blk(*k))\n }"}, {"sha": "5b66e94c1b4561b658b29ee6e9cb1a137793d875", "filename": "src/libcore/to_bytes.rs", "status": "modified", "additions": 2, "deletions": 346, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_bytes.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -22,19 +22,13 @@ use str;\n \n pub type Cb<'self> = &'self fn(buf: &[u8]) -> bool;\n \n-#[cfg(stage0)]\n-pub trait IterBytes {\n-    fn iter_bytes(&self, lsb0: bool, f: Cb);\n-}\n-\n /**\n  * A trait to implement in order to make a type hashable;\n  * This works in combination with the trait `Hash::Hash`, and\n  * may in the future be merged with that trait or otherwise\n  * modified when default methods and trait inheritence are\n  * completed.\n  */\n-#[cfg(not(stage0))]\n pub trait IterBytes {\n     /**\n      * Call the provided callback `f` one or more times with\n@@ -53,16 +47,6 @@ pub trait IterBytes {\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool;\n }\n \n-#[cfg(stage0)]\n-impl IterBytes for bool {\n-    #[inline(always)]\n-    fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n-        f([\n-            *self as u8\n-        ]);\n-    }\n-}\n-#[cfg(not(stage0))]\n impl IterBytes for bool {\n     #[inline(always)]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n@@ -72,16 +56,6 @@ impl IterBytes for bool {\n     }\n }\n \n-#[cfg(stage0)]\n-impl IterBytes for u8 {\n-    #[inline(always)]\n-    fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n-        f([\n-            *self\n-        ]);\n-    }\n-}\n-#[cfg(not(stage0))]\n impl IterBytes for u8 {\n     #[inline(always)]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n@@ -91,24 +65,6 @@ impl IterBytes for u8 {\n     }\n }\n \n-#[cfg(stage0)]\n-impl IterBytes for u16 {\n-    #[inline(always)]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n-        if lsb0 {\n-            f([\n-                *self as u8,\n-                (*self >> 8) as u8\n-            ]);\n-        } else {\n-            f([\n-                (*self >> 8) as u8,\n-                *self as u8\n-            ]);\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n impl IterBytes for u16 {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n@@ -126,28 +82,6 @@ impl IterBytes for u16 {\n     }\n }\n \n-#[cfg(stage0)]\n-impl IterBytes for u32 {\n-    #[inline(always)]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n-        if lsb0 {\n-            f([\n-                *self as u8,\n-                (*self >> 8) as u8,\n-                (*self >> 16) as u8,\n-                (*self >> 24) as u8,\n-            ]);\n-        } else {\n-            f([\n-                (*self >> 24) as u8,\n-                (*self >> 16) as u8,\n-                (*self >> 8) as u8,\n-                *self as u8\n-            ]);\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n impl IterBytes for u32 {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n@@ -169,36 +103,6 @@ impl IterBytes for u32 {\n     }\n }\n \n-#[cfg(stage0)]\n-impl IterBytes for u64 {\n-    #[inline(always)]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n-        if lsb0 {\n-            f([\n-                *self as u8,\n-                (*self >> 8) as u8,\n-                (*self >> 16) as u8,\n-                (*self >> 24) as u8,\n-                (*self >> 32) as u8,\n-                (*self >> 40) as u8,\n-                (*self >> 48) as u8,\n-                (*self >> 56) as u8\n-            ]);\n-        } else {\n-            f([\n-                (*self >> 56) as u8,\n-                (*self >> 48) as u8,\n-                (*self >> 40) as u8,\n-                (*self >> 32) as u8,\n-                (*self >> 24) as u8,\n-                (*self >> 16) as u8,\n-                (*self >> 8) as u8,\n-                *self as u8\n-            ]);\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n impl IterBytes for u64 {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n@@ -228,157 +132,71 @@ impl IterBytes for u64 {\n     }\n }\n \n-#[cfg(stage0)]\n-impl IterBytes for i8 {\n-    #[inline(always)]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n-        (*self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl IterBytes for i8 {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl IterBytes for i16 {\n-    #[inline(always)]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n-        (*self as u16).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl IterBytes for i16 {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as u16).iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl IterBytes for i32 {\n-    #[inline(always)]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n-        (*self as u32).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl IterBytes for i32 {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as u32).iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl IterBytes for i64 {\n-    #[inline(always)]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n-        (*self as u64).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl IterBytes for i64 {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as u64).iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl IterBytes for char {\n-    #[inline(always)]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n-        (*self as u32).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl IterBytes for char {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as u32).iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(target_word_size = \"32\", stage0)]\n-impl IterBytes for uint {\n-    #[inline(always)]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n-        (*self as u32).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(target_word_size = \"32\", not(stage0))]\n+#[cfg(target_word_size = \"32\")]\n impl IterBytes for uint {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as u32).iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(target_word_size = \"64\", stage0)]\n-impl IterBytes for uint {\n-    #[inline(always)]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n-        (*self as u64).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(target_word_size = \"64\", not(stage0))]\n+#[cfg(target_word_size = \"64\")]\n impl IterBytes for uint {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as u64).iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl IterBytes for int {\n-    #[inline(always)]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n-        (*self as uint).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl IterBytes for int {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as uint).iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<'self,A:IterBytes> IterBytes for &'self [A] {\n-    #[inline(always)]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n-        for (*self).each |elt| {\n-            do elt.iter_bytes(lsb0) |bytes| {\n-                f(bytes)\n-            }\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<'self,A:IterBytes> IterBytes for &'self [A] {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         self.each(|elt| elt.iter_bytes(lsb0, |b| f(b)))\n     }\n }\n \n-#[cfg(stage0)]\n-impl<A:IterBytes,B:IterBytes> IterBytes for (A,B) {\n-  #[inline(always)]\n-  fn iter_bytes(&self, lsb0: bool, f: Cb) {\n-    match *self {\n-      (ref a, ref b) => {\n-        iter_bytes_2(a, b, lsb0, f);\n-      }\n-    }\n-  }\n-}\n-#[cfg(not(stage0))]\n impl<A:IterBytes,B:IterBytes> IterBytes for (A,B) {\n   #[inline(always)]\n   fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n@@ -388,18 +206,6 @@ impl<A:IterBytes,B:IterBytes> IterBytes for (A,B) {\n   }\n }\n \n-#[cfg(stage0)]\n-impl<A:IterBytes,B:IterBytes,C:IterBytes> IterBytes for (A,B,C) {\n-  #[inline(always)]\n-  fn iter_bytes(&self, lsb0: bool, f: Cb) {\n-    match *self {\n-      (ref a, ref b, ref c) => {\n-        iter_bytes_3(a, b, c, lsb0, f);\n-      }\n-    }\n-  }\n-}\n-#[cfg(not(stage0))]\n impl<A:IterBytes,B:IterBytes,C:IterBytes> IterBytes for (A,B,C) {\n   #[inline(always)]\n   fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n@@ -416,29 +222,13 @@ fn borrow<'x,A>(a: &'x [A]) -> &'x [A] {\n     a\n }\n \n-#[cfg(stage0)]\n-impl<A:IterBytes> IterBytes for ~[A] {\n-    #[inline(always)]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n-        borrow(*self).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<A:IterBytes> IterBytes for ~[A] {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         borrow(*self).iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<A:IterBytes> IterBytes for @[A] {\n-    #[inline(always)]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n-        borrow(*self).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<A:IterBytes> IterBytes for @[A] {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n@@ -449,57 +239,18 @@ impl<A:IterBytes> IterBytes for @[A] {\n // NOTE: remove all of these after a snapshot, the new for-loop iteration\n //       protocol makes these unnecessary.\n \n-#[cfg(stage0)]\n-pub fn iter_bytes_2<A:IterBytes,B:IterBytes>(a: &A, b: &B,\n-                                            lsb0: bool, z: Cb) {\n-    let mut flag = true;\n-    a.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    b.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-}\n-#[cfg(not(stage0))]\n #[inline(always)]\n pub fn iter_bytes_2<A:IterBytes,B:IterBytes>(a: &A, b: &B,\n                                              lsb0: bool, z: Cb) -> bool {\n     a.iter_bytes(lsb0, z) && b.iter_bytes(lsb0, z)\n }\n \n-#[cfg(stage0)]\n-pub fn iter_bytes_3<A: IterBytes,\n-                    B: IterBytes,\n-                    C: IterBytes>(a: &A, b: &B, c: &C,\n-                                  lsb0: bool, z: Cb) {\n-    let mut flag = true;\n-    a.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    b.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    c.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-}\n-#[cfg(not(stage0))]\n pub fn iter_bytes_3<A: IterBytes,\n                     B: IterBytes,\n                     C: IterBytes>(a: &A, b: &B, c: &C, lsb0: bool, z: Cb) -> bool {\n     a.iter_bytes(lsb0, z) && b.iter_bytes(lsb0, z) && c.iter_bytes(lsb0, z)\n }\n \n-#[cfg(stage0)]\n-pub fn iter_bytes_4<A: IterBytes,\n-                B: IterBytes,\n-                C: IterBytes,\n-                D: IterBytes>(a: &A, b: &B, c: &C,\n-                              d: &D,\n-                              lsb0: bool, z: Cb) {\n-    let mut flag = true;\n-    a.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    b.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    c.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    d.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-}\n-#[cfg(not(stage0))]\n pub fn iter_bytes_4<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n@@ -510,26 +261,6 @@ pub fn iter_bytes_4<A: IterBytes,\n         d.iter_bytes(lsb0, z)\n }\n \n-#[cfg(stage0)]\n-pub fn iter_bytes_5<A: IterBytes,\n-                B: IterBytes,\n-                C: IterBytes,\n-                D: IterBytes,\n-                E: IterBytes>(a: &A, b: &B, c: &C,\n-                              d: &D, e: &E,\n-                              lsb0: bool, z: Cb) {\n-    let mut flag = true;\n-    a.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    b.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    c.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    d.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    e.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-}\n-#[cfg(not(stage0))]\n pub fn iter_bytes_5<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n@@ -541,16 +272,6 @@ pub fn iter_bytes_5<A: IterBytes,\n         d.iter_bytes(lsb0, z) && e.iter_bytes(lsb0, z)\n }\n \n-#[cfg(stage0)]\n-impl<'self> IterBytes for &'self str {\n-    #[inline(always)]\n-    fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n-        do str::byte_slice(*self) |bytes| {\n-            f(bytes);\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<'self> IterBytes for &'self str {\n     #[inline(always)]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n@@ -560,16 +281,6 @@ impl<'self> IterBytes for &'self str {\n     }\n }\n \n-#[cfg(stage0)]\n-impl IterBytes for ~str {\n-    #[inline(always)]\n-    fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n-        do str::byte_slice(*self) |bytes| {\n-            f(bytes);\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n impl IterBytes for ~str {\n     #[inline(always)]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n@@ -579,16 +290,6 @@ impl IterBytes for ~str {\n     }\n }\n \n-#[cfg(stage0)]\n-impl IterBytes for @str {\n-    #[inline(always)]\n-    fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n-        do str::byte_slice(*self) |bytes| {\n-            f(bytes);\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n impl IterBytes for @str {\n     #[inline(always)]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n@@ -598,17 +299,6 @@ impl IterBytes for @str {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<A:IterBytes> IterBytes for Option<A> {\n-    #[inline(always)]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n-        match *self {\n-          Some(ref a) => iter_bytes_2(&0u8, a, lsb0, f),\n-          None => 1u8.iter_bytes(lsb0, f)\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<A:IterBytes> IterBytes for Option<A> {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n@@ -619,44 +309,20 @@ impl<A:IterBytes> IterBytes for Option<A> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<'self,A:IterBytes> IterBytes for &'self A {\n-    #[inline(always)]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n-        (**self).iter_bytes(lsb0, f);\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<'self,A:IterBytes> IterBytes for &'self A {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (**self).iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<A:IterBytes> IterBytes for @A {\n-    #[inline(always)]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n-        (**self).iter_bytes(lsb0, f);\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<A:IterBytes> IterBytes for @A {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (**self).iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<A:IterBytes> IterBytes for ~A {\n-    #[inline(always)]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n-        (**self).iter_bytes(lsb0, f);\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<A:IterBytes> IterBytes for ~A {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n@@ -666,16 +332,6 @@ impl<A:IterBytes> IterBytes for ~A {\n \n // NB: raw-pointer IterBytes does _not_ dereference\n // to the target; it just gives you the pointer-bytes.\n-#[cfg(stage0)]\n-impl<A> IterBytes for *const A {\n-    #[inline(always)]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n-        (*self as uint).iter_bytes(lsb0, f);\n-    }\n-}\n-// NB: raw-pointer IterBytes does _not_ dereference\n-// to the target; it just gives you the pointer-bytes.\n-#[cfg(not(stage0))]\n impl<A> IterBytes for *const A {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {"}, {"sha": "13b892e700e1babf558226e1209dee8da97527a3", "filename": "src/libcore/trie.rs", "status": "modified", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftrie.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -57,56 +57,24 @@ impl<T> Map<uint, T> for TrieMap<T> {\n \n     /// Visit all key-value pairs in order\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn each<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) {\n-        self.root.each(f);\n-    }\n-\n-    /// Visit all key-value pairs in order\n-    #[inline(always)]\n-    #[cfg(not(stage0))]\n     fn each<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n         self.root.each(f)\n     }\n \n     /// Visit all keys in order\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn each_key(&self, f: &fn(&uint) -> bool) {\n-        self.each(|k, _| f(k))\n-    }\n-\n-    /// Visit all keys in order\n-    #[inline(always)]\n-    #[cfg(not(stage0))]\n     fn each_key(&self, f: &fn(&uint) -> bool) -> bool {\n         self.each(|k, _| f(k))\n     }\n \n     /// Visit all values in order\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn each_value<'a>(&'a self, f: &fn(&'a T) -> bool) {\n-        self.each(|_, v| f(v))\n-    }\n-\n-    /// Visit all values in order\n-    #[inline(always)]\n-    #[cfg(not(stage0))]\n     fn each_value<'a>(&'a self, f: &fn(&'a T) -> bool) -> bool {\n         self.each(|_, v| f(v))\n     }\n \n     /// Iterate over the map and mutate the contained values\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn mutate_values(&mut self, f: &fn(&uint, &mut T) -> bool) {\n-        self.root.mutate_values(f);\n-    }\n-\n-    /// Iterate over the map and mutate the contained values\n-    #[inline(always)]\n-    #[cfg(not(stage0))]\n     fn mutate_values(&mut self, f: &fn(&uint, &mut T) -> bool) -> bool {\n         self.root.mutate_values(f)\n     }\n@@ -183,40 +151,18 @@ pub impl<T> TrieMap<T> {\n \n     /// Visit all key-value pairs in reverse order\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn each_reverse<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) {\n-        self.root.each_reverse(f);\n-    }\n-\n-    /// Visit all key-value pairs in reverse order\n-    #[inline(always)]\n-    #[cfg(not(stage0))]\n     fn each_reverse<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n         self.root.each_reverse(f)\n     }\n \n     /// Visit all keys in reverse order\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn each_key_reverse(&self, f: &fn(&uint) -> bool) {\n-        self.each_reverse(|k, _| f(k))\n-    }\n-    /// Visit all keys in reverse order\n-    #[inline(always)]\n-    #[cfg(not(stage0))]\n     fn each_key_reverse(&self, f: &fn(&uint) -> bool) -> bool {\n         self.each_reverse(|k, _| f(k))\n     }\n \n     /// Visit all values in reverse order\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn each_value_reverse(&self, f: &fn(&T) -> bool) {\n-        self.each_reverse(|_, v| f(v))\n-    }\n-    /// Visit all values in reverse order\n-    #[inline(always)]\n-    #[cfg(not(stage0))]\n     fn each_value_reverse(&self, f: &fn(&T) -> bool) -> bool {\n         self.each_reverse(|_, v| f(v))\n     }\n@@ -229,9 +175,6 @@ pub struct TrieSet {\n impl BaseIter<uint> for TrieSet {\n     /// Visit all values in order\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn each(&self, f: &fn(&uint) -> bool) { self.map.each_key(f) }\n-    #[cfg(not(stage0))]\n     fn each(&self, f: &fn(&uint) -> bool) -> bool { self.map.each_key(f) }\n     #[inline(always)]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n@@ -240,11 +183,6 @@ impl BaseIter<uint> for TrieSet {\n impl ReverseIter<uint> for TrieSet {\n     /// Visit all values in reverse order\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn each_reverse(&self, f: &fn(&uint) -> bool) {\n-        self.map.each_key_reverse(f)\n-    }\n-    #[cfg(not(stage0))]\n     fn each_reverse(&self, f: &fn(&uint) -> bool) -> bool {\n         self.map.each_key_reverse(f)\n     }\n@@ -351,19 +289,6 @@ fn chunk(n: uint, idx: uint) -> uint {\n     (n >> sh) & MASK\n }\n \n-#[cfg(stage0)]\n-fn find_mut<'r, T>(child: &'r mut Child<T>, key: uint, idx: uint) -> Option<&'r mut T> {\n-    unsafe {\n-        (match *child {\n-            External(_, ref value) => Some(cast::transmute_mut(value)),\n-            Internal(ref x) => find_mut(cast::transmute_mut(&x.children[chunk(key, idx)]),\n-                                        key, idx + 1),\n-            Nothing => None\n-        }).map_consume(|x| cast::transmute_mut_region(x))\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n fn find_mut<'r, T>(child: &'r mut Child<T>, key: uint, idx: uint) -> Option<&'r mut T> {\n     match *child {\n         External(_, ref mut value) => Some(value),"}, {"sha": "d76da6fcc664f0900c3f21bd33564b4c1aae676e", "filename": "src/libcore/unicode.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -14,19 +14,6 @@\n \n pub mod general_category {\n \n-    #[cfg(stage0)]\n-    fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n-        use cmp::{Equal, Less, Greater};\n-        use vec::bsearch;\n-        use option::None;\n-        (do bsearch(r) |&(lo,hi)| {\n-            if lo <= c && c <= hi { Equal }\n-            else if hi < c { Less }\n-            else { Greater }\n-        }) != None\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n         use cmp::{Equal, Less, Greater};\n         use vec::bsearch;\n@@ -1462,19 +1449,6 @@ pub mod general_category {\n }\n \n pub mod derived_property {\n-    #[cfg(stage0)]\n-    fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n-        use cmp::{Equal, Less, Greater};\n-        use vec::bsearch;\n-        use option::None;\n-        (do bsearch(r) |&(lo,hi)| {\n-            if lo <= c && c <= hi { Equal }\n-            else if hi < c { Less }\n-            else { Greater }\n-        }) != None\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n         use cmp::{Equal, Less, Greater};\n         use vec::bsearch;"}, {"sha": "f332ecc63fc7eda63485789ef9a0308252ec7f61", "filename": "src/libcore/unstable/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fintrinsics.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -43,17 +43,13 @@ pub extern \"rust-intrinsic\" {\n     pub fn atomic_cxchg_rel(dst: &mut int, old: int, src: int) -> int;\n \n     /// Atomic load, sequentially consistent.\n-    #[cfg(not(stage0))]\n     pub fn atomic_load(src: &int) -> int;\n     /// Atomic load, acquire ordering.\n-    #[cfg(not(stage0))]\n     pub fn atomic_load_acq(src: &int) -> int;\n \n     /// Atomic store, sequentially consistent.\n-    #[cfg(not(stage0))]\n     pub fn atomic_store(dst: &mut int, val: int);\n     /// Atomic store, release ordering.\n-    #[cfg(not(stage0))]\n     pub fn atomic_store_rel(dst: &mut int, val: int);\n \n     /// Atomic exchange, sequentially consistent.\n@@ -111,7 +107,6 @@ pub extern \"rust-intrinsic\" {\n     pub unsafe fn init<T>() -> T;\n \n     /// Create an uninitialized value.\n-    #[cfg(not(stage0))]\n     pub unsafe fn uninit<T>() -> T;\n \n     /// Move a value out of scope without running drop glue."}, {"sha": "4b599d7562b09d322fd6fe9f89d47379d054c98b", "filename": "src/libcore/unstable/lang.rs", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Flang.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -269,15 +269,6 @@ pub unsafe fn local_free(ptr: *c_char) {\n     }\n }\n \n-#[cfg(stage0)]\n-#[lang=\"borrow_as_imm\"]\n-#[inline(always)]\n-pub unsafe fn borrow_as_imm(a: *u8) {\n-    let a: *mut BoxRepr = transmute(a);\n-    (*a).header.ref_count |= FROZEN_BIT;\n-}\n-\n-#[cfg(not(stage0))]\n #[lang=\"borrow_as_imm\"]\n #[inline(always)]\n pub unsafe fn borrow_as_imm(a: *u8, file: *c_char, line: size_t) -> uint {\n@@ -296,7 +287,6 @@ pub unsafe fn borrow_as_imm(a: *u8, file: *c_char, line: size_t) -> uint {\n     old_ref_count\n }\n \n-#[cfg(not(stage0))]\n #[lang=\"borrow_as_mut\"]\n #[inline(always)]\n pub unsafe fn borrow_as_mut(a: *u8, file: *c_char, line: size_t) -> uint {\n@@ -316,7 +306,6 @@ pub unsafe fn borrow_as_mut(a: *u8, file: *c_char, line: size_t) -> uint {\n }\n \n \n-#[cfg(not(stage0))]\n #[lang=\"record_borrow\"]\n pub unsafe fn record_borrow(a: *u8, old_ref_count: uint,\n                             file: *c_char, line: size_t) {\n@@ -332,7 +321,6 @@ pub unsafe fn record_borrow(a: *u8, old_ref_count: uint,\n     }\n }\n \n-#[cfg(not(stage0))]\n #[lang=\"unrecord_borrow\"]\n pub unsafe fn unrecord_borrow(a: *u8, old_ref_count: uint,\n                               file: *c_char, line: size_t) {\n@@ -356,19 +344,6 @@ pub unsafe fn unrecord_borrow(a: *u8, old_ref_count: uint,\n     }\n }\n \n-#[cfg(stage0)]\n-#[lang=\"return_to_mut\"]\n-#[inline(always)]\n-pub unsafe fn return_to_mut(a: *u8) {\n-    // Sometimes the box is null, if it is conditionally frozen.\n-    // See e.g. #4904.\n-    if !a.is_null() {\n-        let a: *mut BoxRepr = transmute(a);\n-        (*a).header.ref_count &= !FROZEN_BIT;\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n #[lang=\"return_to_mut\"]\n #[inline(always)]\n pub unsafe fn return_to_mut(a: *u8, orig_ref_count: uint,\n@@ -388,19 +363,6 @@ pub unsafe fn return_to_mut(a: *u8, orig_ref_count: uint,\n     }\n }\n \n-#[cfg(stage0)]\n-#[lang=\"check_not_borrowed\"]\n-#[inline(always)]\n-pub unsafe fn check_not_borrowed(a: *u8) {\n-    let a: *mut BoxRepr = transmute(a);\n-    if ((*a).header.ref_count & FROZEN_BIT) != 0 {\n-        do str::as_buf(\"XXX\") |file_p, _| {\n-            fail_borrowed(a, file_p as *c_char, 0);\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n #[lang=\"check_not_borrowed\"]\n #[inline(always)]\n pub unsafe fn check_not_borrowed(a: *u8,"}, {"sha": "734368c70c4a0342426a29a0228f043d5c2ea438", "filename": "src/libcore/unstable/sync.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fsync.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -41,18 +41,6 @@ impl<T: Owned> UnsafeAtomicRcBox<T> {\n     }\n \n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pub unsafe fn get(&self) -> *mut T\n-    {\n-        let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n-        assert!(data.count > 0);\n-        let r: *mut T = cast::transmute(data.data.get_mut_ref());\n-        cast::forget(data);\n-        return r;\n-    }\n-\n-    #[inline(always)]\n-    #[cfg(not(stage0))]\n     pub unsafe fn get(&self) -> *mut T\n     {\n         let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n@@ -63,18 +51,6 @@ impl<T: Owned> UnsafeAtomicRcBox<T> {\n     }\n \n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pub unsafe fn get_immut(&self) -> *T\n-    {\n-        let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n-        assert!(data.count > 0);\n-        let r: *T = cast::transmute(data.data.get_mut_ref());\n-        cast::forget(data);\n-        return r;\n-    }\n-\n-    #[inline(always)]\n-    #[cfg(not(stage0))]\n     pub unsafe fn get_immut(&self) -> *T\n     {\n         let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);"}, {"sha": "e2b91594d123cb00474b15efa59105262e1cd2a3", "filename": "src/libcore/util.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -60,7 +60,6 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n  * deinitialising or copying either one.\n  */\n #[inline]\n-#[cfg(not(stage0))]\n pub unsafe fn swap_ptr<T>(x: *mut T, y: *mut T) {\n     if x == y { return }\n \n@@ -78,29 +77,6 @@ pub unsafe fn swap_ptr<T>(x: *mut T, y: *mut T) {\n     cast::forget(tmp);\n }\n \n-/**\n- * Swap the values at two mutable locations of the same type, without\n- * deinitialising or copying either one.\n- */\n-#[inline]\n-#[cfg(stage0)]\n-pub unsafe fn swap_ptr<T>(x: *mut T, y: *mut T) {\n-    if x == y { return }\n-\n-    // Give ourselves some scratch space to work with\n-    let mut tmp: T = intrinsics::init();\n-    let t = ptr::to_mut_unsafe_ptr(&mut tmp);\n-\n-    // Perform the swap\n-    ptr::copy_memory(t, x, 1);\n-    ptr::copy_memory(x, y, 1);\n-    ptr::copy_memory(y, t, 1);\n-\n-    // y and t now point to the same thing, but we need to completely forget t\n-    // because it's no longer relevant.\n-    cast::forget(tmp);\n-}\n-\n /**\n  * Replace the value at a mutable location with a new one, returning the old\n  * value, without deinitialising or copying either one."}, {"sha": "14dcde2381bf3dc840d17a9dd4d24326f8bc54dd", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 0, "deletions": 234, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -583,21 +583,6 @@ pub fn consume_reverse<T>(mut v: ~[T], f: &fn(uint, v: T)) {\n }\n \n /// Remove the last element from a vector and return it\n-#[cfg(not(stage0))]\n-pub fn pop<T>(v: &mut ~[T]) -> T {\n-    let ln = v.len();\n-    if ln == 0 {\n-        fail!(\"sorry, cannot vec::pop an empty vector\")\n-    }\n-    let valptr = ptr::to_mut_unsafe_ptr(&mut v[ln - 1u]);\n-    unsafe {\n-        let val = util::replace_ptr(valptr, intrinsics::uninit());\n-        raw::set_len(v, ln - 1u);\n-        val\n-    }\n-}\n-\n-#[cfg(stage0)]\n pub fn pop<T>(v: &mut ~[T]) -> T {\n     let ln = v.len();\n     if ln == 0 {\n@@ -672,7 +657,6 @@ pub fn push_all<T:Copy>(v: &mut ~[T], rhs: &const [T]) {\n }\n \n #[inline(always)]\n-#[cfg(not(stage0))]\n pub fn push_all_move<T>(v: &mut ~[T], mut rhs: ~[T]) {\n     let new_len = v.len() + rhs.len();\n     reserve(&mut *v, new_len);\n@@ -688,25 +672,7 @@ pub fn push_all_move<T>(v: &mut ~[T], mut rhs: ~[T]) {\n     }\n }\n \n-#[inline(always)]\n-#[cfg(stage0)]\n-pub fn push_all_move<T>(v: &mut ~[T], mut rhs: ~[T]) {\n-    let new_len = v.len() + rhs.len();\n-    reserve(&mut *v, new_len);\n-    unsafe {\n-        do as_mut_buf(rhs) |p, len| {\n-            for uint::range(0, len) |i| {\n-                let x = util::replace_ptr(ptr::mut_offset(p, i),\n-                                          intrinsics::init());\n-                push(&mut *v, x);\n-            }\n-        }\n-        raw::set_len(&mut rhs, 0);\n-    }\n-}\n-\n /// Shorten a vector, dropping excess elements.\n-#[cfg(not(stage0))]\n pub fn truncate<T>(v: &mut ~[T], newlen: uint) {\n     do as_mut_buf(*v) |p, oldlen| {\n         assert!(newlen <= oldlen);\n@@ -720,26 +686,10 @@ pub fn truncate<T>(v: &mut ~[T], newlen: uint) {\n     unsafe { raw::set_len(&mut *v, newlen); }\n }\n \n-/// Shorten a vector, dropping excess elements.\n-#[cfg(stage0)]\n-pub fn truncate<T>(v: &mut ~[T], newlen: uint) {\n-    do as_mut_buf(*v) |p, oldlen| {\n-        assert!(newlen <= oldlen);\n-        unsafe {\n-            // This loop is optimized out for non-drop types.\n-            for uint::range(newlen, oldlen) |i| {\n-                util::replace_ptr(ptr::mut_offset(p, i), intrinsics::init());\n-            }\n-        }\n-    }\n-    unsafe { raw::set_len(&mut *v, newlen); }\n-}\n-\n /**\n  * Remove consecutive repeated elements from a vector; if the vector is\n  * sorted, this removes all duplicates.\n  */\n-#[cfg(not(stage0))]\n pub fn dedup<T:Eq>(v: &mut ~[T]) {\n     unsafe {\n         if v.len() < 1 { return; }\n@@ -773,45 +723,6 @@ pub fn dedup<T:Eq>(v: &mut ~[T]) {\n     }\n }\n \n-/**\n- * Remove consecutive repeated elements from a vector; if the vector is\n- * sorted, this removes all duplicates.\n- */\n-#[cfg(stage0)]\n-pub fn dedup<T:Eq>(v: &mut ~[T]) {\n-    unsafe {\n-        if v.len() < 1 { return; }\n-        let mut last_written = 0, next_to_read = 1;\n-        do as_const_buf(*v) |p, ln| {\n-            // We have a mutable reference to v, so we can make arbitrary\n-            // changes. (cf. push and pop)\n-            let p = p as *mut T;\n-            // last_written < next_to_read <= ln\n-            while next_to_read < ln {\n-                // last_written < next_to_read < ln\n-                if *ptr::mut_offset(p, next_to_read) ==\n-                    *ptr::mut_offset(p, last_written) {\n-                    util::replace_ptr(ptr::mut_offset(p, next_to_read),\n-                                      intrinsics::init());\n-                } else {\n-                    last_written += 1;\n-                    // last_written <= next_to_read < ln\n-                    if next_to_read != last_written {\n-                        util::swap_ptr(ptr::mut_offset(p, last_written),\n-                                       ptr::mut_offset(p, next_to_read));\n-                    }\n-                }\n-                // last_written <= next_to_read < ln\n-                next_to_read += 1;\n-                // last_written < next_to_read <= ln\n-            }\n-        }\n-        // last_written < next_to_read == ln\n-        raw::set_len(v, last_written + 1);\n-    }\n-}\n-\n-\n // Appending\n #[inline(always)]\n pub fn append<T:Copy>(lhs: ~[T], rhs: &const [T]) -> ~[T] {\n@@ -1557,9 +1468,6 @@ pub fn _each<'r,T>(v: &'r [T], f: &fn(&'r T) -> bool) -> bool {\n     return true;\n }\n \n-#[cfg(stage0)]\n-pub fn each<'r,T>(v: &'r [T], f: &fn(&'r T) -> bool) { _each(v, f); }\n-#[cfg(not(stage0))]\n pub fn each<'r,T>(v: &'r [T], f: &fn(&'r T) -> bool) -> bool { _each(v, f) }\n \n /// Like `each()`, but for the case where you have\n@@ -1584,11 +1492,6 @@ pub fn _each_mut<'r,T>(v: &'r mut [T], f: &fn(elem: &'r mut T) -> bool) -> bool\n     return broke;\n }\n \n-#[cfg(stage0)]\n-pub fn each_mut<'r,T>(v: &'r mut [T], f: &fn(elem: &'r mut T) -> bool) {\n-    _each_mut(v, f);\n-}\n-#[cfg(not(stage0))]\n pub fn each_mut<'r,T>(v: &'r mut [T], f: &fn(elem: &'r mut T) -> bool) -> bool {\n     _each_mut(v, f)\n }\n@@ -1608,11 +1511,6 @@ pub fn _each_const<T>(v: &const [T], f: &fn(elem: &const T) -> bool) -> bool {\n     return true;\n }\n \n-#[cfg(stage0)]\n-pub fn each_const<t>(v: &const [t], f: &fn(elem: &const t) -> bool) {\n-    _each_const(v, f);\n-}\n-#[cfg(not(stage0))]\n pub fn each_const<t>(v: &const [t], f: &fn(elem: &const t) -> bool) -> bool {\n     _each_const(v, f)\n }\n@@ -1632,9 +1530,6 @@ pub fn _eachi<'r,T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) -> bool {\n     return true;\n }\n \n-#[cfg(stage0)]\n-pub fn eachi<'r,T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) { _eachi(v, f); }\n-#[cfg(not(stage0))]\n pub fn eachi<'r,T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) -> bool {\n     _eachi(v, f)\n }\n@@ -1657,11 +1552,6 @@ pub fn _eachi_mut<'r,T>(v: &'r mut [T],\n     return true;\n }\n \n-#[cfg(stage0)]\n-pub fn eachi_mut<'r,T>(v: &'r mut [T], f: &fn(uint, v: &'r mut T) -> bool) {\n-    _eachi_mut(v, f);\n-}\n-#[cfg(not(stage0))]\n pub fn eachi_mut<'r,T>(v: &'r mut [T],\n                        f: &fn(uint, v: &'r mut T) -> bool) -> bool {\n     _eachi_mut(v, f)\n@@ -1677,11 +1567,6 @@ pub fn _each_reverse<'r,T>(v: &'r [T], blk: &fn(v: &'r T) -> bool) -> bool {\n     _eachi_reverse(v, |_i, v| blk(v))\n }\n \n-#[cfg(stage0)]\n-pub fn each_reverse<'r,T>(v: &'r [T], blk: &fn(v: &'r T) -> bool) {\n-    _each_reverse(v, blk);\n-}\n-#[cfg(not(stage0))]\n pub fn each_reverse<'r,T>(v: &'r [T], blk: &fn(v: &'r T) -> bool) -> bool {\n     _each_reverse(v, blk)\n }\n@@ -1704,11 +1589,6 @@ pub fn _eachi_reverse<'r,T>(v: &'r [T],\n     return true;\n }\n \n-#[cfg(stage0)]\n-pub fn eachi_reverse<'r,T>(v: &'r [T], blk: &fn(i: uint, v: &'r T) -> bool) {\n-    _eachi_reverse(v, blk);\n-}\n-#[cfg(not(stage0))]\n pub fn eachi_reverse<'r,T>(v: &'r [T],\n                            blk: &fn(i: uint, v: &'r T) -> bool) -> bool {\n     _eachi_reverse(v, blk)\n@@ -1732,11 +1612,6 @@ pub fn _each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) -> bool {\n     return true;\n }\n \n-#[cfg(stage0)]\n-pub fn each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) {\n-    _each2(v1, v2, f);\n-}\n-#[cfg(not(stage0))]\n pub fn each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) -> bool {\n     _each2(v1, v2, f)\n }\n@@ -1760,12 +1635,6 @@ pub fn _each2_mut<U, T>(v1: &mut [U], v2: &mut [T], f: &fn(u: &mut U, t: &mut T)\n     return true;\n }\n \n-#[cfg(stage0)]\n-pub fn each2_mut<U, T>(v1: &mut [U], v2: &mut [T], f: &fn(u: &mut U, t: &mut T) -> bool) {\n-    _each2_mut(v1, v2, f);\n-}\n-\n-#[cfg(not(stage0))]\n pub fn each2_mut<U, T>(v1: &mut [U], v2: &mut [T], f: &fn(u: &mut U, t: &mut T) -> bool) -> bool {\n     _each2_mut(v1, v2, f)\n }\n@@ -1838,29 +1707,6 @@ pub fn each_permutation<T:Copy>(values: &[T], fun: &fn(perm : &[T]) -> bool) ->\n  * ~~~\n  *\n  */\n-#[cfg(stage0)]\n-pub fn windowed<'r, T>(n: uint, v: &'r [T], it: &fn(&'r [T]) -> bool) {\n-    assert!(1u <= n);\n-    if n > v.len() { return; }\n-    for uint::range(0, v.len() - n + 1) |i| {\n-        if !it(v.slice(i, i + n)) { return }\n-    }\n-}\n-/**\n- * Iterate over all contiguous windows of length `n` of the vector `v`.\n- *\n- * # Example\n- *\n- * Print the adjacent pairs of a vector (i.e. `[1,2]`, `[2,3]`, `[3,4]`)\n- *\n- * ~~~\n- * for windowed(2, &[1,2,3,4]) |v| {\n- *     io::println(fmt!(\"%?\", v));\n- * }\n- * ~~~\n- *\n- */\n-#[cfg(not(stage0))]\n pub fn windowed<'r, T>(n: uint, v: &'r [T], it: &fn(&'r [T]) -> bool) -> bool {\n     assert!(1u <= n);\n     if n > v.len() { return true; }\n@@ -2133,13 +1979,7 @@ pub trait ImmutableVector<'self, T> {\n     fn last_opt(&self) -> Option<&'self T>;\n     fn position(&self, f: &fn(t: &T) -> bool) -> Option<uint>;\n     fn rposition(&self, f: &fn(t: &T) -> bool) -> Option<uint>;\n-    #[cfg(stage0)]\n-    fn each_reverse(&self, blk: &fn(&T) -> bool);\n-    #[cfg(not(stage0))]\n     fn each_reverse(&self, blk: &fn(&T) -> bool) -> bool;\n-    #[cfg(stage0)]\n-    fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool);\n-    #[cfg(not(stage0))]\n     fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool) -> bool;\n     fn foldr<'a, U>(&'a self, z: U, p: &fn(t: &'a T, u: U) -> U) -> U;\n     fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U];\n@@ -2226,25 +2066,11 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n \n     /// Iterates over a vector's elements in reverse.\n     #[inline]\n-    #[cfg(stage0)]\n-    fn each_reverse(&self, blk: &fn(&T) -> bool) {\n-        each_reverse(*self, blk)\n-    }\n-    /// Iterates over a vector's elements in reverse.\n-    #[inline]\n-    #[cfg(not(stage0))]\n     fn each_reverse(&self, blk: &fn(&T) -> bool) -> bool {\n         each_reverse(*self, blk)\n     }\n \n     /// Iterates over a vector's elements and indices in reverse.\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool) {\n-        eachi_reverse(*self, blk)\n-    }\n-    /// Iterates over a vector's elements and indices in reverse.\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool) -> bool {\n         eachi_reverse(*self, blk)\n@@ -2780,12 +2606,6 @@ pub mod bytes {\n // ITERATION TRAIT METHODS\n \n impl<'self,A> old_iter::BaseIter<A> for &'self [A] {\n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) {\n-        each(*self, blk)\n-    }\n-    #[cfg(not(stage0))]\n     #[inline(always)]\n     fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) -> bool {\n         each(*self, blk)\n@@ -2796,12 +2616,6 @@ impl<'self,A> old_iter::BaseIter<A> for &'self [A] {\n \n // FIXME(#4148): This should be redundant\n impl<A> old_iter::BaseIter<A> for ~[A] {\n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) {\n-        each(*self, blk)\n-    }\n-    #[cfg(not(stage0))]\n     #[inline(always)]\n     fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) -> bool {\n         each(*self, blk)\n@@ -2812,12 +2626,6 @@ impl<A> old_iter::BaseIter<A> for ~[A] {\n \n // FIXME(#4148): This should be redundant\n impl<A> old_iter::BaseIter<A> for @[A] {\n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) {\n-        each(*self, blk)\n-    }\n-    #[cfg(not(stage0))]\n     #[inline(always)]\n     fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) -> bool {\n         each(*self, blk)\n@@ -2827,12 +2635,6 @@ impl<A> old_iter::BaseIter<A> for @[A] {\n }\n \n impl<'self,A> old_iter::MutableIter<A> for &'self mut [A] {\n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn each_mut<'a>(&'a mut self, blk: &fn(v: &'a mut A) -> bool) {\n-        each_mut(*self, blk)\n-    }\n-    #[cfg(not(stage0))]\n     #[inline(always)]\n     fn each_mut<'a>(&'a mut self, blk: &fn(v: &'a mut A) -> bool) -> bool {\n         each_mut(*self, blk)\n@@ -2841,28 +2643,13 @@ impl<'self,A> old_iter::MutableIter<A> for &'self mut [A] {\n \n // FIXME(#4148): This should be redundant\n impl<A> old_iter::MutableIter<A> for ~[A] {\n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn each_mut<'a>(&'a mut self, blk: &fn(v: &'a mut A) -> bool) {\n-        each_mut(*self, blk)\n-    }\n-    #[cfg(not(stage0))]\n     #[inline(always)]\n     fn each_mut<'a>(&'a mut self, blk: &fn(v: &'a mut A) -> bool) -> bool {\n         each_mut(*self, blk)\n     }\n }\n \n // FIXME(#4148): This should be redundant\n-#[cfg(stage0)]\n-impl<A> old_iter::MutableIter<A> for @mut [A] {\n-    #[inline(always)]\n-    fn each_mut(&mut self, blk: &fn(v: &mut A) -> bool) {\n-        each_mut(*self, blk)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<A> old_iter::MutableIter<A> for @mut [A] {\n     #[inline(always)]\n     fn each_mut(&mut self, blk: &fn(v: &mut A) -> bool) -> bool {\n@@ -2871,11 +2658,6 @@ impl<A> old_iter::MutableIter<A> for @mut [A] {\n }\n \n impl<'self,A> old_iter::ExtendedIter<A> for &'self [A] {\n-    #[cfg(stage0)]\n-    pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n-        old_iter::eachi(self, blk)\n-    }\n-    #[cfg(not(stage0))]\n     pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) -> bool {\n         old_iter::eachi(self, blk)\n     }\n@@ -2902,24 +2684,13 @@ impl<'self,A> old_iter::ExtendedIter<A> for &'self [A] {\n \n impl<'self,A> old_iter::ExtendedMutableIter<A> for &'self mut [A] {\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pub fn eachi_mut(&mut self, blk: &fn(uint, v: &mut A) -> bool) {\n-        eachi_mut(*self, blk)\n-    }\n-    #[inline(always)]\n-    #[cfg(not(stage0))]\n     pub fn eachi_mut(&mut self, blk: &fn(uint, v: &mut A) -> bool) -> bool {\n         eachi_mut(*self, blk)\n     }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> old_iter::ExtendedIter<A> for ~[A] {\n-    #[cfg(stage0)]\n-    pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n-        old_iter::eachi(self, blk)\n-    }\n-    #[cfg(not(stage0))]\n     pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) -> bool {\n         old_iter::eachi(self, blk)\n     }\n@@ -2946,11 +2717,6 @@ impl<A> old_iter::ExtendedIter<A> for ~[A] {\n \n // FIXME(#4148): This should be redundant\n impl<A> old_iter::ExtendedIter<A> for @[A] {\n-    #[cfg(stage0)]\n-    pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n-        old_iter::eachi(self, blk)\n-    }\n-    #[cfg(not(stage0))]\n     pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) -> bool {\n         old_iter::eachi(self, blk)\n     }"}, {"sha": "9e0021831372cdda99f00983f7bde441ae5e3341", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -44,15 +44,6 @@ pub fn get_type_param_count(cstore: @mut cstore::CStore, def: ast::def_id)\n }\n \n /// Iterates over all the language items in the given crate.\n-#[cfg(stage0)]\n-pub fn each_lang_item(cstore: @mut cstore::CStore,\n-                      cnum: ast::crate_num,\n-                      f: &fn(ast::node_id, uint) -> bool) {\n-    let crate_data = cstore::get_crate_data(cstore, cnum);\n-    decoder::each_lang_item(crate_data, f)\n-}\n-/// Iterates over all the language items in the given crate.\n-#[cfg(not(stage0))]\n pub fn each_lang_item(cstore: @mut cstore::CStore,\n                       cnum: ast::crate_num,\n                       f: &fn(ast::node_id, uint) -> bool) -> bool {\n@@ -61,18 +52,6 @@ pub fn each_lang_item(cstore: @mut cstore::CStore,\n }\n \n /// Iterates over all the paths in the given crate.\n-#[cfg(stage0)]\n-pub fn each_path(cstore: @mut cstore::CStore,\n-                 cnum: ast::crate_num,\n-                 f: &fn(&str, decoder::def_like) -> bool) {\n-    let crate_data = cstore::get_crate_data(cstore, cnum);\n-    let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n-        cstore::get_crate_data(cstore, cnum)\n-    };\n-    decoder::each_path(cstore.intr, crate_data, get_crate_data, f);\n-}\n-/// Iterates over all the paths in the given crate.\n-#[cfg(not(stage0))]\n pub fn each_path(cstore: @mut cstore::CStore,\n                  cnum: ast::crate_num,\n                  f: &fn(&str, decoder::def_like) -> bool) -> bool {"}, {"sha": "a7131e51ef7e88850d95481daec8fb9a7eb67bbf", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -196,15 +196,6 @@ fn item_def_id(d: ebml::Doc, cdata: cmd) -> ast::def_id {\n                                                     |d| parse_def_id(d)));\n }\n \n-#[cfg(stage0)]\n-fn each_reexport(d: ebml::Doc, f: &fn(ebml::Doc) -> bool) {\n-    for reader::tagged_docs(d, tag_items_data_item_reexport) |reexport_doc| {\n-        if !f(reexport_doc) {\n-            return;\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n fn each_reexport(d: ebml::Doc, f: &fn(ebml::Doc) -> bool) -> bool {\n     for reader::tagged_docs(d, tag_items_data_item_reexport) |reexport_doc| {\n         if !f(reexport_doc) {\n@@ -465,24 +456,6 @@ fn def_like_to_def(def_like: def_like) -> ast::def {\n }\n \n /// Iterates over the language items in the given crate.\n-#[cfg(stage0)]\n-pub fn each_lang_item(cdata: cmd, f: &fn(ast::node_id, uint) -> bool) {\n-    let root = reader::Doc(cdata.data);\n-    let lang_items = reader::get_doc(root, tag_lang_items);\n-    for reader::tagged_docs(lang_items, tag_lang_items_item) |item_doc| {\n-        let id_doc = reader::get_doc(item_doc, tag_lang_items_item_id);\n-        let id = reader::doc_as_u32(id_doc) as uint;\n-        let node_id_doc = reader::get_doc(item_doc,\n-                                          tag_lang_items_item_node_id);\n-        let node_id = reader::doc_as_u32(node_id_doc) as ast::node_id;\n-\n-        if !f(node_id, id) {\n-            break;\n-        }\n-    }\n-}\n-/// Iterates over the language items in the given crate.\n-#[cfg(not(stage0))]\n pub fn each_lang_item(cdata: cmd, f: &fn(ast::node_id, uint) -> bool) -> bool {\n     let root = reader::Doc(cdata.data);\n     let lang_items = reader::get_doc(root, tag_lang_items);\n@@ -588,13 +561,6 @@ pub fn _each_path(intr: @ident_interner, cdata: cmd,\n     return broken;\n }\n \n-#[cfg(stage0)]\n-pub fn each_path(intr: @ident_interner, cdata: cmd,\n-                 get_crate_data: GetCrateDataCb,\n-                 f: &fn(&str, def_like) -> bool) {\n-    _each_path(intr, cdata, get_crate_data, f);\n-}\n-#[cfg(not(stage0))]\n pub fn each_path(intr: @ident_interner, cdata: cmd,\n                  get_crate_data: GetCrateDataCb,\n                  f: &fn(&str, def_like) -> bool) -> bool {"}, {"sha": "3bf8237df944c6dad153209bf72b51ac2c111bff", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -21,9 +21,6 @@ pub fn pick_file(file: Path, path: &Path) -> Option<Path> {\n \n pub trait FileSearch {\n     fn sysroot(&self) -> @Path;\n-    #[cfg(stage0)]\n-    fn for_each_lib_search_path(&self, f: &fn(&Path) -> bool);\n-    #[cfg(not(stage0))]\n     fn for_each_lib_search_path(&self, f: &fn(&Path) -> bool) -> bool;\n     fn get_target_lib_path(&self) -> Path;\n     fn get_target_lib_file_path(&self, file: &Path) -> Path;\n@@ -40,31 +37,6 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n     }\n     impl FileSearch for FileSearchImpl {\n         fn sysroot(&self) -> @Path { self.sysroot }\n-        #[cfg(stage0)]\n-        fn for_each_lib_search_path(&self, f: &fn(&Path) -> bool) {\n-            debug!(\"filesearch: searching additional lib search paths\");\n-            // a little weird\n-            self.addl_lib_search_paths.each(f);\n-\n-            debug!(\"filesearch: searching target lib path\");\n-            if !f(&make_target_lib_path(self.sysroot,\n-                                        self.target_triple)) {\n-                return;\n-            }\n-            debug!(\"filesearch: searching rustpkg lib path nearest\");\n-            if match get_rustpkg_lib_path_nearest() {\n-                    result::Ok(ref p) => f(p),\n-                    result::Err(_) => true\n-                } {\n-                    return;\n-                }\n-           debug!(\"filesearch: searching rustpkg lib path\");\n-           match get_rustpkg_lib_path() {\n-              result::Ok(ref p) => f(p),\n-              result::Err(_) => true\n-           };\n-        }\n-        #[cfg(not(stage0))]\n         fn for_each_lib_search_path(&self, f: &fn(&Path) -> bool) -> bool {\n             debug!(\"filesearch: searching additional lib search paths\");\n             // a little weird"}, {"sha": "8c66037e8385f2c5170e37ba36d50262d080c063", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -67,25 +67,6 @@ enum MoveError {\n pub impl<'self> CheckLoanCtxt<'self> {\n     fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n \n-    #[cfg(stage0)]\n-    fn each_issued_loan(&self,\n-                        scope_id: ast::node_id,\n-                        op: &fn(&Loan) -> bool)\n-    {\n-        //! Iterates over each loan that that has been issued\n-        //! on entrance to `scope_id`, regardless of whether it is\n-        //! actually *in scope* at that point.  Sometimes loans\n-        //! are issued for future scopes and thus they may have been\n-        //! *issued* but not yet be in effect.\n-\n-        for self.dfcx.each_bit_on_entry(scope_id) |loan_index| {\n-            let loan = &self.all_loans[loan_index];\n-            if !op(loan) {\n-                return;\n-            }\n-        }\n-    }\n-    #[cfg(not(stage0))]\n     fn each_issued_loan(&self,\n                         scope_id: ast::node_id,\n                         op: &fn(&Loan) -> bool) -> bool\n@@ -105,24 +86,6 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         return true;\n     }\n \n-    #[cfg(stage0)]\n-    fn each_in_scope_loan(&self,\n-                          scope_id: ast::node_id,\n-                          op: &fn(&Loan) -> bool)\n-    {\n-        //! Like `each_issued_loan()`, but only considers loans that are\n-        //! currently in scope.\n-\n-        let region_maps = self.tcx().region_maps;\n-        for self.each_issued_loan(scope_id) |loan| {\n-            if region_maps.is_subscope_of(scope_id, loan.kill_scope) {\n-                if !op(loan) {\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(not(stage0))]\n     fn each_in_scope_loan(&self,\n                           scope_id: ast::node_id,\n                           op: &fn(&Loan) -> bool) -> bool\n@@ -141,26 +104,6 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         return true;\n     }\n \n-    #[cfg(stage0)]\n-    fn each_in_scope_restriction(&self,\n-                                 scope_id: ast::node_id,\n-                                 loan_path: @LoanPath,\n-                                 op: &fn(&Loan, &Restriction) -> bool)\n-    {\n-        //! Iterates through all the in-scope restrictions for the\n-        //! given `loan_path`\n-\n-        for self.each_in_scope_loan(scope_id) |loan| {\n-            for loan.restrictions.each |restr| {\n-                if restr.loan_path == loan_path {\n-                    if !op(loan, restr) {\n-                        return;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(not(stage0))]\n     fn each_in_scope_restriction(&self,\n                                  scope_id: ast::node_id,\n                                  loan_path: @LoanPath,"}, {"sha": "1e6df883e17969582eccfea1a4b9bb1012b67c6b", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -21,8 +21,6 @@ use middle::dataflow::DataFlowOperator;\n use util::common::stmt_set;\n use util::ppaux::{note_and_explain_region, Repr};\n \n-#[cfg(stage0)]\n-use core; // NOTE: this can be removed after the next snapshot\n use core::hashmap::{HashSet, HashMap};\n use core::io;\n use core::result::{Result};"}, {"sha": "4508c50435d3fc623d62da899abbd7e971e0f7a7", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -182,20 +182,6 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n     }\n \n \n-    #[cfg(stage0)]\n-    pub fn each_bit_on_entry(&self,\n-                             id: ast::node_id,\n-                             f: &fn(uint) -> bool) {\n-        //! Iterates through each bit that is set on entry to `id`.\n-        //! Only useful after `propagate()` has been called.\n-\n-        let (start, end) = self.compute_id_range(id);\n-        let on_entry = vec::slice(self.on_entry, start, end);\n-        debug!(\"each_bit_on_entry(id=%?, on_entry=%s)\",\n-               id, bits_to_str(on_entry));\n-        self.each_bit(on_entry, f);\n-    }\n-    #[cfg(not(stage0))]\n     pub fn each_bit_on_entry(&self,\n                              id: ast::node_id,\n                              f: &fn(uint) -> bool) -> bool {\n@@ -209,19 +195,6 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         self.each_bit(on_entry, f)\n     }\n \n-    #[cfg(stage0)]\n-    pub fn each_gen_bit(&self,\n-                        id: ast::node_id,\n-                        f: &fn(uint) -> bool) {\n-        //! Iterates through each bit in the gen set for `id`.\n-\n-        let (start, end) = self.compute_id_range(id);\n-        let gens = vec::slice(self.gens, start, end);\n-        debug!(\"each_gen_bit(id=%?, gens=%s)\",\n-               id, bits_to_str(gens));\n-        self.each_bit(gens, f)\n-    }\n-    #[cfg(not(stage0))]\n     pub fn each_gen_bit(&self,\n                         id: ast::node_id,\n                         f: &fn(uint) -> bool) -> bool {\n@@ -234,37 +207,6 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         self.each_bit(gens, f)\n     }\n \n-    #[cfg(stage0)]\n-    fn each_bit(&self,\n-                words: &[uint],\n-                f: &fn(uint) -> bool) {\n-        //! Helper for iterating over the bits in a bit set.\n-\n-        for words.eachi |word_index, &word| {\n-            if word != 0 {\n-                let base_index = word_index * uint::bits;\n-                for uint::range(0, uint::bits) |offset| {\n-                    let bit = 1 << offset;\n-                    if (word & bit) != 0 {\n-                        // NB: we round up the total number of bits\n-                        // that we store in any given bit set so that\n-                        // it is an even multiple of uint::bits.  This\n-                        // means that there may be some stray bits at\n-                        // the end that do not correspond to any\n-                        // actual value.  So before we callback, check\n-                        // whether the bit_index is greater than the\n-                        // actual value the user specified and stop\n-                        // iterating if so.\n-                        let bit_index = base_index + offset;\n-                        if bit_index >= self.bits_per_id || !f(bit_index) {\n-                            return;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(not(stage0))]\n     fn each_bit(&self,\n                 words: &[uint],\n                 f: &fn(uint) -> bool) -> bool {"}, {"sha": "24ee587b2f986236e81bf0106431414ab1319f49", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -86,15 +86,6 @@ pub impl LanguageItems {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    fn each_item(&self, f: &fn(def_id: def_id, i: uint) -> bool) {\n-        for self.items.eachi |i, &item| {\n-            if !f(item.get(), i) {\n-                break;\n-            }\n-        }\n-    }\n-    #[cfg(not(stage0))]\n     fn each_item(&self, f: &fn(def_id: def_id, i: uint) -> bool) -> bool {\n         self.items.eachi(|i, &item| f(item.get(), i))\n     }"}, {"sha": "079fb21a4fef9b421ef63fdd56b4eaa814f16d6e", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -419,39 +419,6 @@ impl Context {\n     }\n }\n \n-#[cfg(stage0)]\n-pub fn each_lint(sess: session::Session,\n-                 attrs: &[ast::attribute],\n-                 f: &fn(@ast::meta_item, level, &~str) -> bool)\n-{\n-    for [allow, warn, deny, forbid].each |&level| {\n-        let level_name = level_to_str(level);\n-        let attrs = attr::find_attrs_by_name(attrs, level_name);\n-        for attrs.each |attr| {\n-            let meta = attr.node.value;\n-            let metas = match meta.node {\n-                ast::meta_list(_, ref metas) => metas,\n-                _ => {\n-                    sess.span_err(meta.span, ~\"malformed lint attribute\");\n-                    loop;\n-                }\n-            };\n-            for metas.each |meta| {\n-                match meta.node {\n-                    ast::meta_word(lintname) => {\n-                        if !f(*meta, level, lintname) {\n-                            return;\n-                        }\n-                    }\n-                    _ => {\n-                        sess.span_err(meta.span, ~\"malformed lint attribute\");\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n pub fn each_lint(sess: session::Session,\n                  attrs: &[ast::attribute],\n                  f: &fn(@ast::meta_item, level, &~str) -> bool) -> bool"}, {"sha": "aefbcbaa87e960bdd0b170d51f1a88e98625e602", "filename": "src/librustc/middle/resolve_stage0.rs", "status": "removed", "additions": 0, "deletions": 5324, "changes": 5324, "blob_url": "https://github.com/rust-lang/rust/blob/3a481c0f88025318eba7c48907a5c1d966e01d27/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a481c0f88025318eba7c48907a5c1d966e01d27/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs?ref=3a481c0f88025318eba7c48907a5c1d966e01d27"}, {"sha": "0274ecbfd1dd4c0785f511f8a9d2b14772f4d71d", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -1367,21 +1367,6 @@ pub struct mono_id_ {\n \n pub type mono_id = @mono_id_;\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for mono_param_id {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        match *self {\n-            mono_precise(t, ref mids) =>\n-                to_bytes::iter_bytes_3(&0u8, &ty::type_id(t), mids, lsb0, f),\n-\n-            mono_any => 1u8.iter_bytes(lsb0, f),\n-\n-            mono_repr(ref a, ref b, ref c, ref d) =>\n-                to_bytes::iter_bytes_5(&2u8, a, b, c, d, lsb0, f)\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for mono_param_id {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         match *self {\n@@ -1396,26 +1381,12 @@ impl to_bytes::IterBytes for mono_param_id {\n     }\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for MonoDataClass {\n-    fn iter_bytes(&self, lsb0: bool, f:to_bytes::Cb) {\n-        (*self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for MonoDataClass {\n     fn iter_bytes(&self, lsb0: bool, f:to_bytes::Cb) -> bool {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for mono_id_ {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_2(&self.def, &self.params, lsb0, f);\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for mono_id_ {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         to_bytes::iter_bytes_2(&self.def, &self.params, lsb0, f)"}, {"sha": "4a9a907d5b7c04f2c897f1a0fa9f676942841954", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -154,13 +154,6 @@ pub impl DatumMode {\n     }\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for DatumMode {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        (*self as uint).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for DatumMode {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         (*self as uint).iter_bytes(lsb0, f)"}, {"sha": "b80b4855538ec9026429a87d64e25245f477a335", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 254, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -26,8 +26,6 @@ use util::ppaux::{Repr, UserString};\n use util::common::{indenter};\n use util::enum_set::{EnumSet, CLike};\n \n-#[cfg(stage0)]\n-use core; // NOTE: this can be removed after the next snapshot\n use core::ptr::to_unsafe_ptr;\n use core::to_bytes;\n use core::hashmap::{HashMap, HashSet};\n@@ -136,13 +134,6 @@ pub struct creader_cache_key {\n \n type creader_cache = @mut HashMap<creader_cache_key, t>;\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for creader_cache_key {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_3(&self.cnum, &self.pos, &self.len, lsb0, f);\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for creader_cache_key {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         to_bytes::iter_bytes_3(&self.cnum, &self.pos, &self.len, lsb0, f)\n@@ -167,15 +158,6 @@ impl cmp::Eq for intern_key {\n     }\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for intern_key {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        unsafe {\n-            (*self.sty).iter_bytes(lsb0, f);\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for intern_key {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         unsafe {\n@@ -408,27 +390,12 @@ pub struct FnSig {\n     output: t\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for BareFnTy {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_3(&self.purity, &self.abis, &self.sig, lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for BareFnTy {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         to_bytes::iter_bytes_3(&self.purity, &self.abis, &self.sig, lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for ClosureTy {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_5(&self.purity, &self.sigil, &self.onceness,\n-                               &self.region, &self.sig, lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for ClosureTy {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         to_bytes::iter_bytes_5(&self.purity, &self.sigil, &self.onceness,\n@@ -747,17 +714,6 @@ pub enum InferTy {\n     FloatVar(FloatVid)\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for InferTy {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        match *self {\n-          TyVar(ref tv) => to_bytes::iter_bytes_2(&0u8, tv, lsb0, f),\n-          IntVar(ref iv) => to_bytes::iter_bytes_2(&1u8, iv, lsb0, f),\n-          FloatVar(ref fv) => to_bytes::iter_bytes_2(&2u8, fv, lsb0, f),\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for InferTy {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         match *self {\n@@ -774,16 +730,6 @@ pub enum InferRegion {\n     ReSkolemized(uint, bound_region)\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for InferRegion {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        match *self {\n-            ReVar(ref rv) => to_bytes::iter_bytes_2(&0u8, rv, lsb0, f),\n-            ReSkolemized(ref v, _) => to_bytes::iter_bytes_2(&1u8, v, lsb0, f)\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for InferRegion {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         match *self {\n@@ -872,52 +818,24 @@ impl ToStr for IntVarValue {\n     }\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for TyVid {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        self.to_uint().iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for TyVid {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for IntVid {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        self.to_uint().iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for IntVid {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for FloatVid {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        self.to_uint().iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for FloatVid {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for RegionVid {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        self.to_uint().iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for RegionVid {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         self.to_uint().iter_bytes(lsb0, f)\n@@ -2718,22 +2636,6 @@ impl cmp::TotalEq for bound_region {\n     }\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for vstore {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        match *self {\n-          vstore_fixed(ref u) =>\n-          to_bytes::iter_bytes_2(&0u8, u, lsb0, f),\n-\n-          vstore_uniq => 1u8.iter_bytes(lsb0, f),\n-          vstore_box => 2u8.iter_bytes(lsb0, f),\n-\n-          vstore_slice(ref r) =>\n-          to_bytes::iter_bytes_2(&3u8, r, lsb0, f),\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for vstore {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         match *self {\n@@ -2749,15 +2651,6 @@ impl to_bytes::IterBytes for vstore {\n     }\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for substs {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-          to_bytes::iter_bytes_3(&self.self_r,\n-                                 &self.self_ty,\n-                                 &self.tps, lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for substs {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n           to_bytes::iter_bytes_3(&self.self_r,\n@@ -2766,45 +2659,20 @@ impl to_bytes::IterBytes for substs {\n     }\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for mt {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-          to_bytes::iter_bytes_2(&self.ty,\n-                                 &self.mutbl, lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for mt {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n           to_bytes::iter_bytes_2(&self.ty,\n                                  &self.mutbl, lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for field {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-          to_bytes::iter_bytes_2(&self.ident,\n-                                 &self.mt, lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for field {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n           to_bytes::iter_bytes_2(&self.ident,\n                                  &self.mt, lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for FnSig {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_2(&self.inputs,\n-                               &self.output,\n-                               lsb0, f);\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for FnSig {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         to_bytes::iter_bytes_2(&self.inputs,\n@@ -2813,82 +2681,6 @@ impl to_bytes::IterBytes for FnSig {\n     }\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for sty {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        match *self {\n-          ty_nil => 0u8.iter_bytes(lsb0, f),\n-          ty_bool => 1u8.iter_bytes(lsb0, f),\n-\n-          ty_int(ref t) =>\n-          to_bytes::iter_bytes_2(&2u8, t, lsb0, f),\n-\n-          ty_uint(ref t) =>\n-          to_bytes::iter_bytes_2(&3u8, t, lsb0, f),\n-\n-          ty_float(ref t) =>\n-          to_bytes::iter_bytes_2(&4u8, t, lsb0, f),\n-\n-          ty_estr(ref v) =>\n-          to_bytes::iter_bytes_2(&5u8, v, lsb0, f),\n-\n-          ty_enum(ref did, ref substs) =>\n-          to_bytes::iter_bytes_3(&6u8, did, substs, lsb0, f),\n-\n-          ty_box(ref mt) =>\n-          to_bytes::iter_bytes_2(&7u8, mt, lsb0, f),\n-\n-          ty_evec(ref mt, ref v) =>\n-          to_bytes::iter_bytes_3(&8u8, mt, v, lsb0, f),\n-\n-          ty_unboxed_vec(ref mt) =>\n-          to_bytes::iter_bytes_2(&9u8, mt, lsb0, f),\n-\n-          ty_tup(ref ts) =>\n-          to_bytes::iter_bytes_2(&10u8, ts, lsb0, f),\n-\n-          ty_bare_fn(ref ft) =>\n-          to_bytes::iter_bytes_2(&12u8, ft, lsb0, f),\n-\n-          ty_self(ref did) => to_bytes::iter_bytes_2(&13u8, did, lsb0, f),\n-\n-          ty_infer(ref v) =>\n-          to_bytes::iter_bytes_2(&14u8, v, lsb0, f),\n-\n-          ty_param(ref p) =>\n-          to_bytes::iter_bytes_2(&15u8, p, lsb0, f),\n-\n-          ty_type => 16u8.iter_bytes(lsb0, f),\n-          ty_bot => 17u8.iter_bytes(lsb0, f),\n-\n-          ty_ptr(ref mt) =>\n-          to_bytes::iter_bytes_2(&18u8, mt, lsb0, f),\n-\n-          ty_uniq(ref mt) =>\n-          to_bytes::iter_bytes_2(&19u8, mt, lsb0, f),\n-\n-          ty_trait(ref did, ref substs, ref v, ref mutbl) =>\n-          to_bytes::iter_bytes_5(&20u8, did, substs, v, mutbl, lsb0, f),\n-\n-          ty_opaque_closure_ptr(ref ck) =>\n-          to_bytes::iter_bytes_2(&21u8, ck, lsb0, f),\n-\n-          ty_opaque_box => 22u8.iter_bytes(lsb0, f),\n-\n-          ty_struct(ref did, ref substs) =>\n-          to_bytes::iter_bytes_3(&23u8, did, substs, lsb0, f),\n-\n-          ty_rptr(ref r, ref mt) =>\n-          to_bytes::iter_bytes_3(&24u8, r, mt, lsb0, f),\n-\n-          ty_err => 25u8.iter_bytes(lsb0, f),\n-\n-          ty_closure(ref ct) =>\n-          to_bytes::iter_bytes_2(&26u8, ct, lsb0, f),\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for sty {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         match *self {\n@@ -4499,52 +4291,6 @@ pub fn determine_inherited_purity(parent: (ast::purity, ast::node_id),\n // Here, the supertraits are the transitive closure of the supertrait\n // relation on the supertraits from each bounded trait's constraint\n // list.\n-#[cfg(stage0)]\n-pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n-                                        bounds: &ParamBounds,\n-                                        f: &fn(@TraitRef) -> bool) {\n-    for bounds.trait_bounds.each |&bound_trait_ref| {\n-        let mut supertrait_set = HashMap::new();\n-        let mut trait_refs = ~[];\n-        let mut i = 0;\n-\n-        // Seed the worklist with the trait from the bound\n-        supertrait_set.insert(bound_trait_ref.def_id, ());\n-        trait_refs.push(bound_trait_ref);\n-\n-        // Add the given trait ty to the hash map\n-        while i < trait_refs.len() {\n-            debug!(\"each_bound_trait_and_supertraits(i=%?, trait_ref=%s)\",\n-                   i, trait_refs[i].repr(tcx));\n-\n-            if !f(trait_refs[i]) {\n-                return;\n-            }\n-\n-            // Add supertraits to supertrait_set\n-            let supertrait_refs = trait_ref_supertraits(tcx, trait_refs[i]);\n-            for supertrait_refs.each |&supertrait_ref| {\n-                debug!(\"each_bound_trait_and_supertraits(supertrait_ref=%s)\",\n-                       supertrait_ref.repr(tcx));\n-\n-                let d_id = supertrait_ref.def_id;\n-                if !supertrait_set.contains_key(&d_id) {\n-                    // FIXME(#5527) Could have same trait multiple times\n-                    supertrait_set.insert(d_id, ());\n-                    trait_refs.push(supertrait_ref);\n-                }\n-            }\n-\n-            i += 1;\n-        }\n-    }\n-}\n-// Iterate over a type parameter's bounded traits and any supertraits\n-// of those traits, ignoring kinds.\n-// Here, the supertraits are the transitive closure of the supertrait\n-// relation on the supertraits from each bounded trait's constraint\n-// list.\n-#[cfg(not(stage0))]\n pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n                                         bounds: &ParamBounds,\n                                         f: &fn(@TraitRef) -> bool) -> bool {"}, {"sha": "54537397c6263437d3eea83edf2f5b0bf45e9a96", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -828,15 +828,6 @@ pub impl FnCtxt {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    fn opt_node_ty_substs(&self, id: ast::node_id,\n-                          f: &fn(&ty::substs) -> bool) {\n-        match self.inh.node_type_substs.find(&id) {\n-            Some(s) => { f(s); }\n-            None => ()\n-        }\n-    }\n-    #[cfg(not(stage0))]\n     fn opt_node_ty_substs(&self, id: ast::node_id,\n                           f: &fn(&ty::substs) -> bool) -> bool {\n         match self.inh.node_type_substs.find(&id) {"}, {"sha": "3f3df7bf83824d90a1433aba1c9bf68852deb6bf", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -118,26 +118,6 @@ pub impl Rcx {\n     }\n \n     /// Try to resolve the type for the given node.\n-    #[config(stage0)]\n-    fn resolve_expr_type_adjusted(@mut self, expr: @ast::expr) -> ty::t {\n-        let ty_unadjusted = self.resolve_node_type(expr.id);\n-        if ty::type_is_error(ty_unadjusted) || ty::type_is_bot(ty_unadjusted) {\n-            ty_unadjusted\n-        } else {\n-            let tcx = self.fcx.tcx();\n-            let adjustments = self.fcx.inh.adjustments;\n-            match adjustments.find_copy(&expr.id) {\n-                None => ty_unadjusted,\n-                Some(adjustment) => {\n-                    ty::adjust_ty(tcx, expr.span, ty_unadjusted,\n-                                  Some(adjustment))\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Try to resolve the type for the given node.\n-    #[config(not(stage0))]\n     fn resolve_expr_type_adjusted(@mut self, expr: @ast::expr) -> ty::t {\n         let ty_unadjusted = self.resolve_node_type(expr.id);\n         if ty::type_is_error(ty_unadjusted) || ty::type_is_bot(ty_unadjusted) {"}, {"sha": "f133a010f83ab4a7c1aa04b871b01b9ec6f3045e", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -524,27 +524,6 @@ pub impl CoherenceChecker {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    fn each_provided_trait_method(&self,\n-            trait_did: ast::def_id,\n-            f: &fn(@ty::Method) -> bool) {\n-        // Make a list of all the names of the provided methods.\n-        // XXX: This is horrible.\n-        let mut provided_method_idents = HashSet::new();\n-        let tcx = self.crate_context.tcx;\n-        for ty::provided_trait_methods(tcx, trait_did).each |ident| {\n-            provided_method_idents.insert(*ident);\n-        }\n-\n-        for ty::trait_methods(tcx, trait_did).each |&method| {\n-            if provided_method_idents.contains(&method.ident) {\n-                if !f(method) {\n-                    break;\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(not(stage0))]\n     fn each_provided_trait_method(&self,\n             trait_did: ast::def_id,\n             f: &fn(x: @ty::Method) -> bool) -> bool {"}, {"sha": "89041bffd0941e00008fb4988f1dca9c6e4b66bf", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -544,8 +544,6 @@ use middle::typeck::infer::cres;\n use util::common::indenter;\n use util::ppaux::note_and_explain_region;\n \n-#[cfg(stage0)]\n-use core; // NOTE: this can be removed after next snapshot\n use core::cell::{Cell, empty_cell};\n use core::hashmap::{HashMap, HashSet};\n use core::to_bytes;\n@@ -561,22 +559,6 @@ enum Constraint {\n     ConstrainVarSubReg(RegionVid, Region)\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for Constraint {\n-   fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        match *self {\n-          ConstrainVarSubVar(ref v0, ref v1) =>\n-          to_bytes::iter_bytes_3(&0u8, v0, v1, lsb0, f),\n-\n-          ConstrainRegSubVar(ref ra, ref va) =>\n-          to_bytes::iter_bytes_3(&1u8, ra, va, lsb0, f),\n-\n-          ConstrainVarSubReg(ref va, ref ra) =>\n-          to_bytes::iter_bytes_3(&2u8, va, ra, lsb0, f)\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for Constraint {\n    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         match *self {\n@@ -1773,23 +1755,6 @@ pub impl RegionVarBindings {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    fn each_edge(&mut self,\n-                 graph: &Graph,\n-                 node_idx: RegionVid,\n-                 dir: Direction,\n-                 op: &fn(edge: &GraphEdge) -> bool) {\n-        let mut edge_idx =\n-            graph.nodes[node_idx.to_uint()].head_edge[dir as uint];\n-        while edge_idx != uint::max_value {\n-            let edge_ptr = &graph.edges[edge_idx];\n-            if !op(edge_ptr) {\n-                return;\n-            }\n-            edge_idx = edge_ptr.next_edge[dir as uint];\n-        }\n-    }\n-    #[cfg(not(stage0))]\n     fn each_edge(&mut self,\n                  graph: &Graph,\n                  node_idx: RegionVid,"}, {"sha": "72eef2ba4132c1cfdb2ad063b635f45b2b58b72a", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -75,9 +75,6 @@ pub mod middle {\n     }\n     pub mod ty;\n     pub mod subst;\n-    #[cfg(stage0)] #[path = \"resolve_stage0.rs\"]\n-    pub mod resolve;\n-    #[cfg(not(stage0))]\n     pub mod resolve;\n     #[path = \"typeck/mod.rs\"]\n     pub mod typeck;"}, {"sha": "49750c569095535ab81df5dc0b608cd7a8a952d6", "filename": "src/librustc/util/enum_set.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Futil%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibrustc%2Futil%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fenum_set.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[cfg(stage0)]\n-use core;\n-\n #[deriving(Eq, IterBytes)]\n pub struct EnumSet<E> {\n     // We must maintain the invariant that no bits are set\n@@ -60,22 +57,6 @@ pub impl<E:CLike> EnumSet<E> {\n         (self.bits & bit(e)) != 0\n     }\n \n-    #[cfg(stage0)]\n-    fn each(&self, f: &fn(E) -> bool) {\n-        let mut bits = self.bits;\n-        let mut index = 0;\n-        while bits != 0 {\n-            if (bits & 1) != 0 {\n-                let e = CLike::from_uint(index);\n-                if !f(e) {\n-                    return;\n-                }\n-            }\n-            index += 1;\n-            bits >>= 1;\n-        }\n-    }\n-    #[cfg(not(stage0))]\n     fn each(&self, f: &fn(E) -> bool) -> bool {\n         let mut bits = self.bits;\n         let mut index = 0;"}, {"sha": "9d22107931e9ecfcc4a7df4677ee51a61db09ec8", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -143,17 +143,6 @@ pub impl BigBitv {\n     }\n \n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn each_storage(&mut self, op: &fn(v: &mut uint) -> bool) {\n-        for uint::range(0, self.storage.len()) |i| {\n-            let mut w = self.storage[i];\n-            let b = op(&mut w);\n-            self.storage[i] = w;\n-            if !b { break; }\n-        }\n-    }\n-    #[inline(always)]\n-    #[cfg(not(stage0))]\n     fn each_storage(&mut self, op: &fn(v: &mut uint) -> bool) -> bool {\n         uint::range(0, self.storage.len(), |i| op(&mut self.storage[i]))\n     }\n@@ -199,19 +188,6 @@ pub impl BigBitv {\n     }\n \n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn equals(&self, b: &BigBitv, nbits: uint) -> bool {\n-        let len = b.storage.len();\n-        for uint::iterate(0, len) |i| {\n-            let mask = big_mask(nbits, i);\n-            if mask & self.storage[i] != mask & b.storage[i] {\n-                return false;\n-            }\n-        }\n-    }\n-\n-    #[inline(always)]\n-    #[cfg(not(stage0))]\n     fn equals(&self, b: &BigBitv, nbits: uint) -> bool {\n         let len = b.storage.len();\n         for uint::iterate(0, len) |i| {\n@@ -407,16 +383,6 @@ pub impl Bitv {\n     }\n \n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn each(&self, f: &fn(bool) -> bool) {\n-        let mut i = 0;\n-        while i < self.nbits {\n-            if !f(self.get(i)) { break; }\n-            i += 1;\n-        }\n-    }\n-    #[inline(always)]\n-    #[cfg(not(stage0))]\n     fn each(&self, f: &fn(bool) -> bool) -> bool {\n         let mut i = 0;\n         while i < self.nbits {\n@@ -519,15 +485,6 @@ pub impl Bitv {\n         true\n     }\n \n-    #[cfg(stage0)]\n-    fn ones(&self, f: &fn(uint) -> bool) {\n-        for uint::range(0, self.nbits) |i| {\n-            if self.get(i) {\n-                if !f(i) { break }\n-            }\n-        }\n-    }\n-    #[cfg(not(stage0))]\n     fn ones(&self, f: &fn(uint) -> bool) -> bool {\n         uint::range(0, self.nbits, |i| !self.get(i) || f(i))\n     }\n@@ -697,7 +654,6 @@ pub impl BitvSet {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl BaseIter<uint> for BitvSet {\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n \n@@ -711,7 +667,6 @@ impl BaseIter<uint> for BitvSet {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl cmp::Eq for BitvSet {\n     fn eq(&self, other: &BitvSet) -> bool {\n         if self.size != other.size {\n@@ -745,7 +700,6 @@ impl Mutable for BitvSet {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl Set<uint> for BitvSet {\n     fn contains(&self, value: &uint) -> bool {\n         *value < self.bitv.storage.len() * uint::bits && self.bitv.get(*value)\n@@ -849,7 +803,6 @@ impl Set<uint> for BitvSet {\n     }\n }\n \n-#[cfg(not(stage0))]\n priv impl BitvSet {\n     /// Visits each of the words that the two bit vectors (self and other)\n     /// both have in common. The three yielded arguments are (bit location,"}, {"sha": "60f160741778987c3dc8b923f4536f4f21822408", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -65,23 +65,11 @@ pub impl<T> Deque<T> {\n     }\n \n     /// Iterate over the elements in the deque\n-    #[cfg(stage0)]\n-    fn each(&self, f: &fn(&T) -> bool) {\n-        self.eachi(|_i, e| f(e))\n-    }\n-    /// Iterate over the elements in the deque\n-    #[cfg(not(stage0))]\n     fn each(&self, f: &fn(&T) -> bool) -> bool {\n         self.eachi(|_i, e| f(e))\n     }\n \n     /// Iterate over the elements in the deque by index\n-    #[cfg(stage0)]\n-    fn eachi(&self, f: &fn(uint, &T) -> bool) {\n-        uint::range(0, self.nelts, |i| f(i, self.get(i as int)))\n-    }\n-    /// Iterate over the elements in the deque by index\n-    #[cfg(not(stage0))]\n     fn eachi(&self, f: &fn(uint, &T) -> bool) -> bool {\n         uint::range(0, self.nelts, |i| f(i, self.get(i as int)))\n     }"}, {"sha": "100543d7d98c7810a1d2f9c3c0d96adcc8723b91", "filename": "src/libstd/dlist.rs", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibstd%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibstd%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdlist.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -391,17 +391,6 @@ pub impl<T> DList<T> {\n     }\n \n     /// Iterate over nodes.\n-    #[cfg(stage0)]\n-    fn each_node(@mut self, f: &fn(@mut DListNode<T>) -> bool) {\n-        let mut link = self.peek_n();\n-        while link.is_some() {\n-            let nobe = link.get();\n-            if !f(nobe) { break; }\n-            link = nobe.next_link();\n-        }\n-    }\n-    /// Iterate over nodes.\n-    #[cfg(not(stage0))]\n     fn each_node(@mut self, f: &fn(@mut DListNode<T>) -> bool) -> bool {\n         let mut link = self.peek_n();\n         while link.is_some() {\n@@ -508,42 +497,6 @@ impl<T> BaseIter<T> for @mut DList<T> {\n      * allow for e.g. breadth-first search with in-place enqueues), but\n      * removing the current node is forbidden.\n      */\n-    #[cfg(stage0)]\n-    fn each(&self, f: &fn(v: &T) -> bool) {\n-        let mut link = self.peek_n();\n-        while link.is_some() {\n-            let nobe = link.get();\n-            assert!(nobe.linked);\n-\n-            {\n-                let frozen_nobe = &*nobe;\n-                if !f(&frozen_nobe.data) { break; }\n-            }\n-\n-            // Check (weakly) that the user didn't do a remove.\n-            if self.size == 0 {\n-                fail!(\"The dlist became empty during iteration??\")\n-            }\n-            if !nobe.linked ||\n-                (!((nobe.prev.is_some()\n-                    || managed::mut_ptr_eq(self.hd.expect(~\"headless dlist?\"),\n-                                           nobe))\n-                   && (nobe.next.is_some()\n-                    || managed::mut_ptr_eq(self.tl.expect(~\"tailless dlist?\"),\n-                                           nobe)))) {\n-                fail!(\"Removing a dlist node during iteration is forbidden!\")\n-            }\n-            link = nobe.next_link();\n-        }\n-    }\n-    /**\n-     * Iterates through the current contents.\n-     *\n-     * Attempts to access this dlist during iteration are allowed (to\n-     * allow for e.g. breadth-first search with in-place enqueues), but\n-     * removing the current node is forbidden.\n-     */\n-    #[cfg(not(stage0))]\n     fn each(&self, f: &fn(v: &T) -> bool) -> bool {\n         let mut link = self.peek_n();\n         while link.is_some() {"}, {"sha": "a7c18ebf5cdc8c2f85c6b76f569dde7ae0a8e6ed", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -200,20 +200,6 @@ pub mod reader {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    pub fn docs(d: Doc, it: &fn(uint, Doc) -> bool) {\n-        let mut pos = d.start;\n-        while pos < d.end {\n-            let elt_tag = vuint_at(*d.data, pos);\n-            let elt_size = vuint_at(*d.data, elt_tag.next);\n-            pos = elt_size.next + elt_size.val;\n-            let doc = Doc { data: d.data, start: elt_size.next, end: pos };\n-            if !it(elt_tag.val, doc) {\n-                break;\n-            }\n-        }\n-    }\n-    #[cfg(not(stage0))]\n     pub fn docs(d: Doc, it: &fn(uint, Doc) -> bool) -> bool {\n         let mut pos = d.start;\n         while pos < d.end {\n@@ -228,23 +214,6 @@ pub mod reader {\n         return true;\n     }\n \n-    #[cfg(stage0)]\n-    pub fn tagged_docs(d: Doc, tg: uint, it: &fn(Doc) -> bool) {\n-        let mut pos = d.start;\n-        while pos < d.end {\n-            let elt_tag = vuint_at(*d.data, pos);\n-            let elt_size = vuint_at(*d.data, elt_tag.next);\n-            pos = elt_size.next + elt_size.val;\n-            if elt_tag.val == tg {\n-                let doc = Doc { data: d.data, start: elt_size.next,\n-                                end: pos };\n-                if !it(doc) {\n-                    break;\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(not(stage0))]\n     pub fn tagged_docs(d: Doc, tg: uint, it: &fn(Doc) -> bool) -> bool {\n         let mut pos = d.start;\n         while pos < d.end {\n@@ -655,16 +624,6 @@ pub mod writer {\n         fail!(\"vint to write too big: %?\", n);\n     }\n \n-    #[cfg(stage0)]\n-    pub fn Encoder(w: @io::Writer) -> Encoder {\n-        let size_positions: ~[uint] = ~[];\n-        Encoder {\n-            writer: w,\n-            mut size_positions: size_positions\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     pub fn Encoder(w: @io::Writer) -> Encoder {\n         let size_positions: ~[uint] = ~[];\n         Encoder {"}, {"sha": "25e248414cdf186ae318d7005245064369cc3ec9", "filename": "src/libstd/fileinput.rs", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibstd%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibstd%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffileinput.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -254,17 +254,6 @@ impl FileInput {\n     (line numbers and file names, see documentation for\n     `FileInputState`). Otherwise identical to `lines_each`.\n     */\n-    #[cfg(stage0)]\n-    pub fn each_line_state(&self,\n-                            f: &fn(&str, FileInputState) -> bool) {\n-         self.each_line(|line| f(line, copy self.fi.state));\n-    }\n-    /**\n-    Apply `f` to each line successively, along with some state\n-    (line numbers and file names, see documentation for\n-    `FileInputState`). Otherwise identical to `lines_each`.\n-    */\n-    #[cfg(not(stage0))]\n     pub fn each_line_state(&self,\n                             f: &fn(&str, FileInputState) -> bool) -> bool {\n          self.each_line(|line| f(line, copy self.fi.state))\n@@ -377,17 +366,6 @@ reading from `stdin`).\n \n Fails when attempting to read from a file that can't be opened.\n */\n-#[cfg(stage0)]\n-pub fn input(f: &fn(&str) -> bool) {\n-    FileInput::from_args().each_line(f);\n-}\n-/**\n-Iterate directly over the command line arguments (no arguments implies\n-reading from `stdin`).\n-\n-Fails when attempting to read from a file that can't be opened.\n-*/\n-#[cfg(not(stage0))]\n pub fn input(f: &fn(&str) -> bool) -> bool {\n     let i = FileInput::from_args();\n     i.each_line(f)\n@@ -400,18 +378,6 @@ provided at each call.\n \n Fails when attempting to read from a file that can't be opened.\n */\n-#[cfg(stage0)]\n-pub fn input_state(f: &fn(&str, FileInputState) -> bool) {\n-    FileInput::from_args().each_line_state(f);\n-}\n-/**\n-Iterate directly over the command line arguments (no arguments\n-implies reading from `stdin`) with the current state of the iteration\n-provided at each call.\n-\n-Fails when attempting to read from a file that can't be opened.\n-*/\n-#[cfg(not(stage0))]\n pub fn input_state(f: &fn(&str, FileInputState) -> bool) -> bool {\n     let i = FileInput::from_args();\n     i.each_line_state(f)\n@@ -422,16 +388,6 @@ Iterate over a vector of files (an empty vector implies just `stdin`).\n \n Fails when attempting to read from a file that can't be opened.\n */\n-#[cfg(stage0)]\n-pub fn input_vec(files: ~[Option<Path>], f: &fn(&str) -> bool) {\n-    FileInput::from_vec(files).each_line(f);\n-}\n-/**\n-Iterate over a vector of files (an empty vector implies just `stdin`).\n-\n-Fails when attempting to read from a file that can't be opened.\n-*/\n-#[cfg(not(stage0))]\n pub fn input_vec(files: ~[Option<Path>], f: &fn(&str) -> bool) -> bool {\n     let i = FileInput::from_vec(files);\n     i.each_line(f)\n@@ -443,18 +399,6 @@ with the current state of the iteration provided at each call.\n \n Fails when attempting to read from a file that can't be opened.\n */\n-#[cfg(stage0)]\n-pub fn input_vec_state(files: ~[Option<Path>],\n-                       f: &fn(&str, FileInputState) -> bool) {\n-    FileInput::from_vec(files).each_line_state(f);\n-}\n-/**\n-Iterate over a vector of files (an empty vector implies just `stdin`)\n-with the current state of the iteration provided at each call.\n-\n-Fails when attempting to read from a file that can't be opened.\n-*/\n-#[cfg(not(stage0))]\n pub fn input_vec_state(files: ~[Option<Path>],\n                        f: &fn(&str, FileInputState) -> bool) -> bool {\n     let i = FileInput::from_vec(files);"}, {"sha": "3a916233db8172423624aed83003ecf8f41034f1", "filename": "src/libstd/list.rs", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -140,21 +140,6 @@ pub fn iter<T>(l: @List<T>, f: &fn(&T)) {\n }\n \n /// Iterate over a list\n-#[cfg(stage0)]\n-pub fn each<T>(l: @List<T>, f: &fn(&T) -> bool) {\n-    let mut cur = l;\n-    loop {\n-        cur = match *cur {\n-          Cons(ref hd, tl) => {\n-            if !f(hd) { return; }\n-            tl\n-          }\n-          Nil => break\n-        }\n-    }\n-}\n-/// Iterate over a list\n-#[cfg(not(stage0))]\n pub fn each<T>(l: @List<T>, f: &fn(&T) -> bool) -> bool {\n     let mut cur = l;\n     loop {\n@@ -170,24 +155,6 @@ pub fn each<T>(l: @List<T>, f: &fn(&T) -> bool) -> bool {\n \n impl<T> MutList<T> {\n     /// Iterate over a mutable list\n-    #[cfg(stage0)]\n-    pub fn each(@mut self, f: &fn(&mut T) -> bool) {\n-        let mut cur = self;\n-        loop {\n-            let borrowed = &mut *cur;\n-            cur = match *borrowed {\n-                MutCons(ref mut hd, tl) => {\n-                    if !f(hd) {\n-                        return;\n-                    }\n-                    tl\n-                }\n-                MutNil => break\n-            }\n-        }\n-    }\n-    /// Iterate over a mutable list\n-    #[cfg(not(stage0))]\n     pub fn each(@mut self, f: &fn(&mut T) -> bool) -> bool {\n         let mut cur = self;\n         loop {"}, {"sha": "19e0dc144127588d20691387115106d9bec3d52a", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -703,13 +703,6 @@ impl ToStr for Url {\n     }\n }\n \n-#[cfg(stage0)]\n-impl IterBytes for Url {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        self.to_str().iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl IterBytes for Url {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         self.to_str().iter_bytes(lsb0, f)"}, {"sha": "2f5d12d08073bb5e0ded53149a583a63d0137824", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -22,12 +22,6 @@ impl<T:Ord> BaseIter<T> for PriorityQueue<T> {\n     /// Visit all values in the underlying vector.\n     ///\n     /// The values are **not** visited in order.\n-    #[cfg(stage0)]\n-    fn each(&self, f: &fn(&T) -> bool) { self.data.each(f) }\n-    /// Visit all values in the underlying vector.\n-    ///\n-    /// The values are **not** visited in order.\n-    #[cfg(not(stage0))]\n     fn each(&self, f: &fn(&T) -> bool) -> bool { self.data.each(f) }\n \n     fn size_hint(&self) -> Option<uint> { self.data.size_hint() }"}, {"sha": "02f824b911302df5c19a4de92cc79baedcf0ba76", "filename": "src/libstd/rc.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibstd%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frc.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -61,7 +61,6 @@ pub impl<T> Rc<T> {\n }\n \n #[unsafe_destructor]\n-#[cfg(not(stage0))]\n impl<T> Drop for Rc<T> {\n     fn finalize(&self) {\n         unsafe {\n@@ -74,21 +73,6 @@ impl<T> Drop for Rc<T> {\n     }\n }\n \n-#[unsafe_destructor]\n-#[cfg(stage0)]\n-impl<T> Drop for Rc<T> {\n-    fn finalize(&self) {\n-        unsafe {\n-            (*self.ptr).count -= 1;\n-            if (*self.ptr).count == 0 {\n-                util::replace_ptr(self.ptr, intrinsics::init());\n-                free(self.ptr as *c_void)\n-            }\n-        }\n-    }\n-}\n-\n-\n impl<T> Clone for Rc<T> {\n     /// Return a shallow copy of the reference counted pointer.\n     #[inline]\n@@ -157,7 +141,6 @@ mod test_rc {\n #[abi = \"rust-intrinsic\"]\n extern \"rust-intrinsic\" {\n     fn init<T>() -> T;\n-    #[cfg(not(stage0))]\n     fn uninit<T>() -> T;\n }\n \n@@ -228,7 +211,6 @@ pub impl<T> RcMut<T> {\n }\n \n #[unsafe_destructor]\n-#[cfg(not(stage0))]\n impl<T> Drop for RcMut<T> {\n     fn finalize(&self) {\n         unsafe {\n@@ -241,20 +223,6 @@ impl<T> Drop for RcMut<T> {\n     }\n }\n \n-#[unsafe_destructor]\n-#[cfg(stage0)]\n-impl<T> Drop for RcMut<T> {\n-    fn finalize(&self) {\n-        unsafe {\n-            (*self.ptr).count -= 1;\n-            if (*self.ptr).count == 0 {\n-                util::replace_ptr(self.ptr, init());\n-                free(self.ptr as *c_void)\n-            }\n-        }\n-    }\n-}\n-\n impl<T> Clone for RcMut<T> {\n     /// Return a shallow copy of the reference counted pointer.\n     #[inline]"}, {"sha": "3c1f53b25f7f88bf154a5a43a65551985a927b72", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -51,18 +51,6 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n     }\n \n     /// Visit all key-value pairs in order\n-    #[cfg(stage0)]\n-    fn each<'a>(&'a self, it: &fn(&uint, &'a V) -> bool) {\n-        for uint::range(0, self.v.len()) |i| {\n-            match self.v[i] {\n-              Some(ref elt) => if !it(&i, elt) { break },\n-              None => ()\n-            }\n-        }\n-    }\n-\n-    /// Visit all key-value pairs in order\n-    #[cfg(not(stage0))]\n     fn each<'a>(&'a self, it: &fn(&uint, &'a V) -> bool) -> bool {\n         for uint::range(0, self.v.len()) |i| {\n             match self.v[i] {\n@@ -73,41 +61,17 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n         return true;\n     }\n \n-    /// Visit all keys in order\n-    #[cfg(stage0)]\n-    fn each_key(&self, blk: &fn(key: &uint) -> bool) {\n-        self.each(|k, _| blk(k))\n-    }\n-    #[cfg(not(stage0))]\n     /// Visit all keys in order\n     fn each_key(&self, blk: &fn(key: &uint) -> bool) -> bool {\n         self.each(|k, _| blk(k))\n     }\n \n     /// Visit all values in order\n-    #[cfg(stage0)]\n-    fn each_value<'a>(&'a self, blk: &fn(value: &'a V) -> bool) {\n-        self.each(|_, v| blk(v))\n-    }\n-\n-    /// Visit all values in order\n-    #[cfg(not(stage0))]\n     fn each_value<'a>(&'a self, blk: &fn(value: &'a V) -> bool) -> bool {\n         self.each(|_, v| blk(v))\n     }\n \n     /// Iterate over the map and mutate the contained values\n-    #[cfg(stage0)]\n-    fn mutate_values(&mut self, it: &fn(&uint, &mut V) -> bool) {\n-        for uint::range(0, self.v.len()) |i| {\n-            match self.v[i] {\n-              Some(ref mut elt) => if !it(&i, elt) { return; },\n-              None => ()\n-            }\n-        }\n-    }\n-    /// Iterate over the map and mutate the contained values\n-    #[cfg(not(stage0))]\n     fn mutate_values(&mut self, it: &fn(&uint, &mut V) -> bool) -> bool {\n         for uint::range(0, self.v.len()) |i| {\n             match self.v[i] {\n@@ -187,18 +151,6 @@ pub impl<V> SmallIntMap<V> {\n     fn new() -> SmallIntMap<V> { SmallIntMap{v: ~[]} }\n \n     /// Visit all key-value pairs in reverse order\n-    #[cfg(stage0)]\n-    fn each_reverse<'a>(&'a self, it: &fn(uint, &'a V) -> bool) {\n-        for uint::range_rev(self.v.len(), 0) |i| {\n-            match self.v[i - 1] {\n-              Some(ref elt) => if !it(i - 1, elt) { break },\n-              None => ()\n-            }\n-        }\n-    }\n-\n-    /// Visit all key-value pairs in reverse order\n-    #[cfg(not(stage0))]\n     fn each_reverse<'a>(&'a self, it: &fn(uint, &'a V) -> bool) -> bool {\n         for uint::range_rev(self.v.len(), 0) |i| {\n             match self.v[i - 1] {"}, {"sha": "d896fa8c096f7d5974919d2836dee9aa81cb41dd", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -61,26 +61,6 @@ pub fn merge_sort<T:Copy>(v: &[T], le: Le<T>) -> ~[T] {\n     }\n }\n \n-#[cfg(stage0)]\n-fn part<T>(arr: &mut [T], left: uint,\n-           right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n-    swap(&mut arr[pivot], &mut arr[right]);\n-    let mut storage_index: uint = left;\n-    let mut i: uint = left;\n-    while i < right {\n-        let a: &mut T = &mut arr[i];\n-        let b: &mut T = &mut arr[right];\n-        if compare_func(a, b) {\n-            swap(&mut arr[i], &mut arr[storage_index]);\n-            storage_index += 1;\n-        }\n-        i += 1;\n-    }\n-    swap(&mut arr[storage_index], &mut arr[right]);\n-    return storage_index;\n-}\n-\n-#[cfg(not(stage0))]\n fn part<T>(arr: &mut [T], left: uint,\n            right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n     vec::swap(arr, pivot, right);"}, {"sha": "cdef8e220ceed4fcab87732ab9fa7e573a3d0bbf", "filename": "src/libstd/sort_stage0.rs", "status": "removed", "additions": 0, "deletions": 1240, "changes": 1240, "blob_url": "https://github.com/rust-lang/rust/blob/3a481c0f88025318eba7c48907a5c1d966e01d27/src%2Flibstd%2Fsort_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a481c0f88025318eba7c48907a5c1d966e01d27/src%2Flibstd%2Fsort_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort_stage0.rs?ref=3a481c0f88025318eba7c48907a5c1d966e01d27", "patch": "@@ -1,1240 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Sorting methods\n-\n-use core::cmp::{Eq, Ord};\n-use core::vec::len;\n-use core::vec;\n-use core::util;\n-\n-type Le<'self, T> = &'self fn(v1: &T, v2: &T) -> bool;\n-\n-/**\n- * Merge sort. Returns a new vector containing the sorted list.\n- *\n- * Has worst case O(n log n) performance, best case O(n), but\n- * is not space efficient. This is a stable sort.\n- */\n-pub fn merge_sort<T:Copy>(v: &const [T], le: Le<T>) -> ~[T] {\n-    type Slice = (uint, uint);\n-\n-    return merge_sort_(v, (0u, len(v)), le);\n-\n-    fn merge_sort_<T:Copy>(v: &const [T], slice: Slice, le: Le<T>)\n-        -> ~[T] {\n-        let begin = slice.first();\n-        let end = slice.second();\n-\n-        let v_len = end - begin;\n-        if v_len == 0 { return ~[]; }\n-        if v_len == 1 { return ~[v[begin]]; }\n-\n-        let mid = v_len / 2 + begin;\n-        let a = (begin, mid);\n-        let b = (mid, end);\n-        return merge(le, merge_sort_(v, a, le), merge_sort_(v, b, le));\n-    }\n-\n-    fn merge<T:Copy>(le: Le<T>, a: &[T], b: &[T]) -> ~[T] {\n-        let mut rs = vec::with_capacity(len(a) + len(b));\n-        let a_len = len(a);\n-        let mut a_ix = 0;\n-        let b_len = len(b);\n-        let mut b_ix = 0;\n-        while a_ix < a_len && b_ix < b_len {\n-            if le(&a[a_ix], &b[b_ix]) {\n-                rs.push(a[a_ix]);\n-                a_ix += 1;\n-            } else { rs.push(b[b_ix]); b_ix += 1; }\n-        }\n-        rs.push_all(vec::slice(a, a_ix, a_len));\n-        rs.push_all(vec::slice(b, b_ix, b_len));\n-        rs\n-    }\n-}\n-\n-#[cfg(stage0)]\n-fn part<T>(arr: &mut [T], left: uint,\n-           right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n-    vec::swap(arr, pivot, right);\n-    let mut storage_index: uint = left;\n-    let mut i: uint = left;\n-    while i < right {\n-        let a: &mut T = &mut arr[i];\n-        let b: &mut T = &mut arr[right];\n-        if compare_func(a, b) {\n-            vec::swap(arr, i, storage_index);\n-            storage_index += 1;\n-        }\n-        i += 1;\n-    }\n-    vec::swap(arr, storage_index, right);\n-    return storage_index;\n-}\n-\n-#[cfg(not(stage0))]\n-fn part<T>(arr: &mut [T], left: uint,\n-           right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n-    vec::swap(arr, pivot, right);\n-    let mut storage_index: uint = left;\n-    let mut i: uint = left;\n-    while i < right {\n-        if compare_func(&arr[i], &arr[right]) {\n-            vec::swap(arr, i, storage_index);\n-            storage_index += 1;\n-        }\n-        i += 1;\n-    }\n-    vec::swap(arr, storage_index, right);\n-    return storage_index;\n-}\n-\n-fn qsort<T>(arr: &mut [T], left: uint,\n-            right: uint, compare_func: Le<T>) {\n-    if right > left {\n-        let pivot = (left + right) / 2u;\n-        let new_pivot = part::<T>(arr, left, right, pivot, compare_func);\n-        if new_pivot != 0u {\n-            // Need to do this check before recursing due to overflow\n-            qsort::<T>(arr, left, new_pivot - 1u, compare_func);\n-        }\n-        qsort::<T>(arr, new_pivot + 1u, right, compare_func);\n-    }\n-}\n-\n-/**\n- * Quicksort. Sorts a mut vector in place.\n- *\n- * Has worst case O(n^2) performance, average case O(n log n).\n- * This is an unstable sort.\n- */\n-pub fn quick_sort<T>(arr: &mut [T], compare_func: Le<T>) {\n-    if len::<T>(arr) == 0u { return; }\n-    qsort::<T>(arr, 0u, len::<T>(arr) - 1u, compare_func);\n-}\n-\n-fn qsort3<T:Copy + Ord + Eq>(arr: &mut [T], left: int, right: int) {\n-    if right <= left { return; }\n-    let v: T = arr[right];\n-    let mut i: int = left - 1;\n-    let mut j: int = right;\n-    let mut p: int = i;\n-    let mut q: int = j;\n-    loop {\n-        i += 1;\n-        while arr[i] < v { i += 1; }\n-        j -= 1;\n-        while v < arr[j] {\n-            if j == left { break; }\n-            j -= 1;\n-        }\n-        if i >= j { break; }\n-        vec::swap(arr, i as uint, j as uint);\n-        if arr[i] == v {\n-            p += 1;\n-            vec::swap(arr, p as uint, i as uint);\n-        }\n-        if v == arr[j] {\n-            q -= 1;\n-            vec::swap(arr, j as uint, q as uint);\n-        }\n-    }\n-    vec::swap(arr, i as uint, right as uint);\n-    j = i - 1;\n-    i += 1;\n-    let mut k: int = left;\n-    while k < p {\n-        vec::swap(arr, k as uint, j as uint);\n-        k += 1;\n-        j -= 1;\n-        if k == len::<T>(arr) as int { break; }\n-    }\n-    k = right - 1;\n-    while k > q {\n-        vec::swap(arr, i as uint, k as uint);\n-        k -= 1;\n-        i += 1;\n-        if k == 0 { break; }\n-    }\n-    qsort3::<T>(arr, left, j);\n-    qsort3::<T>(arr, i, right);\n-}\n-\n-/**\n- * Fancy quicksort. Sorts a mut vector in place.\n- *\n- * Based on algorithm presented by ~[Sedgewick and Bentley]\n- * (http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf).\n- * According to these slides this is the algorithm of choice for\n- * 'randomly ordered keys, abstract compare' & 'small number of key values'.\n- *\n- * This is an unstable sort.\n- */\n-pub fn quick_sort3<T:Copy + Ord + Eq>(arr: &mut [T]) {\n-    if arr.len() <= 1 { return; }\n-    let len = arr.len() - 1; // FIXME(#5074) nested calls\n-    qsort3(arr, 0, (len - 1) as int);\n-}\n-\n-pub trait Sort {\n-    fn qsort(self);\n-}\n-\n-impl<'self, T:Copy + Ord + Eq> Sort for &'self mut [T] {\n-    fn qsort(self) { quick_sort3(self); }\n-}\n-\n-static MIN_MERGE: uint = 64;\n-static MIN_GALLOP: uint = 7;\n-static INITIAL_TMP_STORAGE: uint = 128;\n-\n-pub fn tim_sort<T:Copy + Ord>(array: &mut [T]) {\n-    let size = array.len();\n-    if size < 2 {\n-        return;\n-    }\n-\n-    if size < MIN_MERGE {\n-        let init_run_len = count_run_ascending(array);\n-        binarysort(array, init_run_len);\n-        return;\n-    }\n-\n-    let mut ms = MergeState();\n-    let min_run = min_run_length(size);\n-\n-    let mut idx = 0;\n-    let mut remaining = size;\n-    loop {\n-        let run_len: uint = {\n-            // This scope contains the slice `arr` here:\n-            let arr = vec::mut_slice(array, idx, size);\n-            let mut run_len: uint = count_run_ascending(arr);\n-\n-            if run_len < min_run {\n-                let force = if remaining <= min_run {remaining} else {min_run};\n-                let slice = vec::mut_slice(arr, 0, force);\n-                binarysort(slice, run_len);\n-                run_len = force;\n-            }\n-\n-            run_len\n-        };\n-\n-        ms.push_run(idx, run_len);\n-        ms.merge_collapse(array);\n-\n-        idx += run_len;\n-        remaining -= run_len;\n-        if remaining == 0 { break; }\n-    }\n-\n-    ms.merge_force_collapse(array);\n-}\n-\n-fn binarysort<T:Copy + Ord>(array: &mut [T], start: uint) {\n-    let size = array.len();\n-    let mut start = start;\n-    assert!(start <= size);\n-\n-    if start == 0 { start += 1; }\n-\n-    while start < size {\n-        let pivot = array[start];\n-        let mut left = 0;\n-        let mut right = start;\n-        assert!(left <= right);\n-\n-        while left < right {\n-            let mid = (left + right) >> 1;\n-            if pivot < array[mid] {\n-                right = mid;\n-            } else {\n-                left = mid+1;\n-            }\n-        }\n-        assert_eq!(left, right);\n-        let n = start-left;\n-\n-        copy_vec(array, left+1, array, left, n);\n-        array[left] = pivot;\n-        start += 1;\n-    }\n-}\n-\n-// Reverse the order of elements in a slice, in place\n-fn reverse_slice<T>(v: &mut [T], start: uint, end:uint) {\n-    let mut i = start;\n-    while i < end / 2 {\n-        vec::swap(v, i, end - i - 1);\n-        i += 1;\n-    }\n-}\n-\n-fn min_run_length(n: uint) -> uint {\n-    let mut n = n;\n-    let mut r = 0;   // becomes 1 if any 1 bits are shifted off\n-\n-    while n >= MIN_MERGE {\n-        r |= n & 1;\n-        n >>= 1;\n-    }\n-    return n + r;\n-}\n-\n-fn count_run_ascending<T:Copy + Ord>(array: &mut [T]) -> uint {\n-    let size = array.len();\n-    assert!(size > 0);\n-    if size == 1 { return 1; }\n-\n-    let mut run = 2;\n-    if array[1] < array[0] {\n-        while run < size && array[run] < array[run-1] {\n-            run += 1;\n-        }\n-        reverse_slice(array, 0, run);\n-    } else {\n-        while run < size && array[run] >= array[run-1] {\n-            run += 1;\n-        }\n-    }\n-\n-    return run;\n-}\n-\n-fn gallop_left<T:Copy + Ord>(key: &const T,\n-                             array: &const [T],\n-                             hint: uint)\n-                          -> uint {\n-    let size = array.len();\n-    assert!(size != 0 && hint < size);\n-\n-    let mut last_ofs = 0;\n-    let mut ofs = 1;\n-\n-    if *key > array[hint] {\n-        // Gallop right until array[hint+last_ofs] < key <= array[hint+ofs]\n-        let max_ofs = size - hint;\n-        while ofs < max_ofs && *key > array[hint+ofs] {\n-            last_ofs = ofs;\n-            ofs = (ofs << 1) + 1;\n-            if ofs < last_ofs { ofs = max_ofs; } // uint overflow guard\n-        }\n-        if ofs > max_ofs { ofs = max_ofs; }\n-\n-        last_ofs += hint;\n-        ofs += hint;\n-    } else {\n-        let max_ofs = hint + 1;\n-        while ofs < max_ofs && *key <= array[hint-ofs] {\n-            last_ofs = ofs;\n-            ofs = (ofs << 1) + 1;\n-            if ofs < last_ofs { ofs = max_ofs; } // uint overflow guard\n-        }\n-\n-        if ofs > max_ofs { ofs = max_ofs; }\n-\n-        let tmp = last_ofs;\n-        last_ofs = hint - ofs;\n-        ofs = hint - tmp;\n-    }\n-    assert!((last_ofs < ofs || last_ofs+1 < ofs+1) && ofs <= size);\n-\n-    last_ofs += 1;\n-    while last_ofs < ofs {\n-        let m = last_ofs + ((ofs - last_ofs) >> 1);\n-        if *key > array[m] {\n-            last_ofs = m+1;\n-        } else {\n-            ofs = m;\n-        }\n-    }\n-    assert_eq!(last_ofs, ofs);\n-    return ofs;\n-}\n-\n-fn gallop_right<T:Copy + Ord>(key: &const T,\n-                              array: &const [T],\n-                              hint: uint)\n-                           -> uint {\n-    let size = array.len();\n-    assert!(size != 0 && hint < size);\n-\n-    let mut last_ofs = 0;\n-    let mut ofs = 1;\n-\n-    if *key >= array[hint] {\n-        // Gallop right until array[hint+last_ofs] <= key < array[hint+ofs]\n-        let max_ofs = size - hint;\n-        while ofs < max_ofs && *key >= array[hint+ofs] {\n-            last_ofs = ofs;\n-            ofs = (ofs << 1) + 1;\n-            if ofs < last_ofs { ofs = max_ofs; }\n-        }\n-        if ofs > max_ofs { ofs = max_ofs; }\n-\n-        last_ofs += hint;\n-        ofs += hint;\n-    } else {\n-        // Gallop left until array[hint-ofs] <= key < array[hint-last_ofs]\n-        let max_ofs = hint + 1;\n-        while ofs < max_ofs && *key < array[hint-ofs] {\n-            last_ofs = ofs;\n-            ofs = (ofs << 1) + 1;\n-            if ofs < last_ofs { ofs = max_ofs; }\n-        }\n-        if ofs > max_ofs { ofs = max_ofs; }\n-\n-        let tmp = last_ofs;\n-        last_ofs = hint - ofs;\n-        ofs = hint - tmp;\n-    }\n-\n-    assert!((last_ofs < ofs || last_ofs+1 < ofs+1) && ofs <= size);\n-\n-    last_ofs += 1;\n-    while last_ofs < ofs {\n-        let m = last_ofs + ((ofs - last_ofs) >> 1);\n-\n-        if *key >= array[m] {\n-            last_ofs = m + 1;\n-        } else {\n-            ofs = m;\n-        }\n-    }\n-    assert_eq!(last_ofs, ofs);\n-    return ofs;\n-}\n-\n-struct RunState {\n-    base: uint,\n-    len: uint,\n-}\n-\n-struct MergeState<T> {\n-    min_gallop: uint,\n-    runs: ~[RunState],\n-}\n-\n-// Fixme (#3853) Move into MergeState\n-fn MergeState<T>() -> MergeState<T> {\n-    MergeState {\n-        min_gallop: MIN_GALLOP,\n-        runs: ~[],\n-    }\n-}\n-\n-impl<T:Copy + Ord> MergeState<T> {\n-    fn push_run(&mut self, run_base: uint, run_len: uint) {\n-        let tmp = RunState{base: run_base, len: run_len};\n-        self.runs.push(tmp);\n-    }\n-\n-    fn merge_at(&mut self, n: uint, array: &mut [T]) {\n-        let size = self.runs.len();\n-        assert!(size >= 2);\n-        assert!(n == size-2 || n == size-3);\n-\n-        let mut b1 = self.runs[n].base;\n-        let mut l1 = self.runs[n].len;\n-        let b2 = self.runs[n+1].base;\n-        let l2 = self.runs[n+1].len;\n-\n-        assert!(l1 > 0 && l2 > 0);\n-        assert_eq!(b1 + l1, b2);\n-\n-        self.runs[n].len = l1 + l2;\n-        if n == size-3 {\n-            self.runs[n+1].base = self.runs[n+2].base;\n-            self.runs[n+1].len = self.runs[n+2].len;\n-        }\n-\n-        let k = { // constrain lifetime of slice below\n-            let slice = vec::mut_slice(array, b1, b1+l1);\n-            gallop_right(&const array[b2], slice, 0)\n-        };\n-        b1 += k;\n-        l1 -= k;\n-        if l1 != 0 {\n-            let l2 = { // constrain lifetime of slice below\n-                let slice = vec::mut_slice(array, b2, b2+l2);\n-                gallop_left(&const array[b1+l1-1],slice,l2-1)\n-            };\n-            if l2 > 0 {\n-                if l1 <= l2 {\n-                    self.merge_lo(array, b1, l1, b2, l2);\n-                } else {\n-                    self.merge_hi(array, b1, l1, b2, l2);\n-                }\n-            }\n-        }\n-        self.runs.pop();\n-    }\n-\n-    fn merge_lo(&mut self, array: &mut [T], base1: uint, len1: uint,\n-                base2: uint, len2: uint) {\n-        assert!(len1 != 0 && len2 != 0 && base1+len1 == base2);\n-\n-        let mut tmp = ~[];\n-        for uint::range(base1, base1+len1) |i| {\n-            tmp.push(array[i]);\n-        }\n-\n-        let mut c1 = 0;\n-        let mut c2 = base2;\n-        let mut dest = base1;\n-        let mut len1 = len1;\n-        let mut len2 = len2;\n-\n-        vec::swap(array, dest, c2);\n-        dest += 1; c2 += 1; len2 -= 1;\n-\n-        if len2 == 0 {\n-            copy_vec(array, dest, tmp, 0, len1);\n-            return;\n-        }\n-        if len1 == 1 {\n-            copy_vec(array, dest, array, c2, len2);\n-            util::swap(&mut array[dest+len2], &mut tmp[c1]);\n-            return;\n-        }\n-\n-        let mut min_gallop = self.min_gallop;\n-        loop {\n-            let mut count1 = 0;\n-            let mut count2 = 0;\n-            let mut break_outer = false;\n-\n-            loop {\n-                assert!(len1 > 1 && len2 != 0);\n-                if array[c2] < tmp[c1] {\n-                    vec::swap(array, dest, c2);\n-                    dest += 1; c2 += 1; len2 -= 1;\n-                    count2 += 1; count1 = 0;\n-                    if len2 == 0 {\n-                        break_outer = true;\n-                    }\n-                } else {\n-                    util::swap(&mut array[dest], &mut tmp[c1]);\n-                    dest += 1; c1 += 1; len1 -= 1;\n-                    count1 += 1; count2 = 0;\n-                    if len1 == 1 {\n-                        break_outer = true;\n-                    }\n-                }\n-                if break_outer || ((count1 | count2) >= min_gallop) {\n-                    break;\n-                }\n-            }\n-            if break_outer { break; }\n-\n-            // Start to gallop\n-            loop {\n-                assert!(len1 > 1 && len2 != 0);\n-\n-                let tmp_view = vec::const_slice(tmp, c1, c1+len1);\n-                count1 = gallop_right(&const array[c2], tmp_view, 0);\n-                if count1 != 0 {\n-                    copy_vec(array, dest, tmp, c1, count1);\n-                    dest += count1; c1 += count1; len1 -= count1;\n-                    if len1 <= 1 { break_outer = true; break; }\n-                }\n-                vec::swap(array, dest, c2);\n-                dest += 1; c2 += 1; len2 -= 1;\n-                if len2 == 0 { break_outer = true; break; }\n-\n-                let tmp_view = vec::const_slice(array, c2, c2+len2);\n-                count2 = gallop_left(&const tmp[c1], tmp_view, 0);\n-                if count2 != 0 {\n-                    copy_vec(array, dest, array, c2, count2);\n-                    dest += count2; c2 += count2; len2 -= count2;\n-                    if len2 == 0 { break_outer = true; break; }\n-                }\n-                util::swap(&mut array[dest], &mut tmp[c1]);\n-                dest += 1; c1 += 1; len1 -= 1;\n-                if len1 == 1 { break_outer = true; break; }\n-                min_gallop -= 1;\n-                if !(count1 >= MIN_GALLOP || count2 >= MIN_GALLOP) {\n-                    break;\n-                }\n-            }\n-            if break_outer { break; }\n-            if min_gallop < 0 { min_gallop = 0; }\n-            min_gallop += 2; // Penalize for leaving gallop\n-        }\n-        self.min_gallop = if min_gallop < 1 { 1 } else { min_gallop };\n-\n-        if len1 == 1 {\n-            assert!(len2 > 0);\n-            copy_vec(array, dest, array, c2, len2);\n-            util::swap(&mut array[dest+len2], &mut tmp[c1]);\n-        } else if len1 == 0 {\n-            fail!(\"Comparison violates its contract!\");\n-        } else {\n-            assert_eq!(len2, 0);\n-            assert!(len1 > 1);\n-            copy_vec(array, dest, tmp, c1, len1);\n-        }\n-    }\n-\n-    fn merge_hi(&mut self, array: &mut [T], base1: uint, len1: uint,\n-                base2: uint, len2: uint) {\n-        assert!(len1 != 1 && len2 != 0 && base1+len1 == base2);\n-\n-        let mut tmp = ~[];\n-        for uint::range(base2, base2+len2) |i| {\n-            tmp.push(array[i]);\n-        }\n-\n-        let mut c1 = base1 + len1 - 1;\n-        let mut c2 = len2 - 1;\n-        let mut dest = base2 + len2 - 1;\n-        let mut len1 = len1;\n-        let mut len2 = len2;\n-\n-        vec::swap(array, dest, c1);\n-        dest -= 1; c1 -= 1; len1 -= 1;\n-\n-        if len1 == 0 {\n-            copy_vec(array, dest-(len2-1), tmp, 0, len2);\n-            return;\n-        }\n-        if len2 == 1 {\n-            dest -= len1;\n-            c1 -= len1;\n-            copy_vec(array, dest+1, array, c1+1, len1);\n-            util::swap(&mut array[dest], &mut tmp[c2]);\n-            return;\n-        }\n-\n-        let mut min_gallop = self.min_gallop;\n-        loop {\n-            let mut count1 = 0;\n-            let mut count2 = 0;\n-            let mut break_outer = false;\n-\n-            loop {\n-                assert!(len1 != 0 && len2 > 1);\n-                if tmp[c2] < array[c1] {\n-                    vec::swap(array, dest, c1);\n-                    dest -= 1; c1 -= 1; len1 -= 1;\n-                    count1 += 1; count2 = 0;\n-                    if len1 == 0 {\n-                        break_outer = true;\n-                    }\n-                } else {\n-                    util::swap(&mut array[dest], &mut tmp[c2]);\n-                    dest -= 1; c2 -= 1; len2 -= 1;\n-                    count2 += 1; count1 = 0;\n-                    if len2 == 1 {\n-                        break_outer = true;\n-                    }\n-                }\n-                if break_outer || ((count1 | count2) >= min_gallop) {\n-                    break;\n-                }\n-            }\n-            if break_outer { break; }\n-\n-            // Start to gallop\n-            loop {\n-                assert!(len2 > 1 && len1 != 0);\n-\n-                { // constrain scope of tmp_view:\n-                    let tmp_view = vec::mut_slice (array, base1, base1+len1);\n-                    count1 = len1 - gallop_right(\n-                        &const tmp[c2], tmp_view, len1-1);\n-                }\n-\n-                if count1 != 0 {\n-                    dest -= count1; c1 -= count1; len1 -= count1;\n-                    copy_vec(array, dest+1, array, c1+1, count1);\n-                    if len1 == 0 { break_outer = true; break; }\n-                }\n-\n-                util::swap(&mut array[dest], &mut tmp[c2]);\n-                dest -= 1; c2 -= 1; len2 -= 1;\n-                if len2 == 1 { break_outer = true; break; }\n-\n-                let count2;\n-                { // constrain scope of tmp_view\n-                    let tmp_view = vec::mut_slice(tmp, 0, len2);\n-                    count2 = len2 - gallop_left(&const array[c1],\n-                                                tmp_view,\n-                                                len2-1);\n-                }\n-\n-                if count2 != 0 {\n-                    dest -= count2; c2 -= count2; len2 -= count2;\n-                    copy_vec(array, dest+1, tmp, c2+1, count2);\n-                    if len2 <= 1 { break_outer = true; break; }\n-                }\n-                vec::swap(array, dest, c1);\n-                dest -= 1; c1 -= 1; len1 -= 1;\n-                if len1 == 0 { break_outer = true; break; }\n-                min_gallop -= 1;\n-                if !(count1 >= MIN_GALLOP || count2 >= MIN_GALLOP) {\n-                    break;\n-                }\n-            }\n-\n-            if break_outer { break; }\n-            if min_gallop < 0 { min_gallop = 0; }\n-            min_gallop += 2; // Penalize for leaving gallop\n-        }\n-        self.min_gallop = if min_gallop < 1 { 1 } else { min_gallop };\n-\n-        if len2 == 1 {\n-            assert!(len1 > 0);\n-            dest -= len1;\n-            c1 -= len1;\n-            copy_vec(array, dest+1, array, c1+1, len1);\n-            util::swap(&mut array[dest], &mut tmp[c2]);\n-        } else if len2 == 0 {\n-            fail!(\"Comparison violates its contract!\");\n-        } else {\n-            assert_eq!(len1, 0);\n-            assert!(len2 != 0);\n-            copy_vec(array, dest-(len2-1), tmp, 0, len2);\n-        }\n-    }\n-\n-    fn merge_collapse(&mut self, array: &mut [T]) {\n-        while self.runs.len() > 1 {\n-            let mut n = self.runs.len()-2;\n-            if n > 0 &&\n-                self.runs[n-1].len <= self.runs[n].len + self.runs[n+1].len\n-            {\n-                if self.runs[n-1].len < self.runs[n+1].len { n -= 1; }\n-            } else if self.runs[n].len <= self.runs[n+1].len {\n-                /* keep going */\n-            } else {\n-                break;\n-            }\n-            self.merge_at(n, array);\n-        }\n-    }\n-\n-    fn merge_force_collapse(&mut self, array: &mut [T]) {\n-        while self.runs.len() > 1 {\n-            let mut n = self.runs.len()-2;\n-            if n > 0 {\n-                if self.runs[n-1].len < self.runs[n+1].len {\n-                    n -= 1;\n-                }\n-            }\n-            self.merge_at(n, array);\n-        }\n-    }\n-}\n-\n-#[inline(always)]\n-fn copy_vec<T:Copy>(dest: &mut [T],\n-                    s1: uint,\n-                    from: &const [T],\n-                    s2: uint,\n-                    len: uint) {\n-    assert!(s1+len <= dest.len() && s2+len <= from.len());\n-\n-    let mut slice = ~[];\n-    for uint::range(s2, s2+len) |i| {\n-        slice.push(from[i]);\n-    }\n-\n-    for slice.eachi |i, v| {\n-        dest[s1+i] = *v;\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test_qsort3 {\n-    use sort::*;\n-\n-    use core::vec;\n-\n-    fn check_sort(v1: &mut [int], v2: &mut [int]) {\n-        let len = vec::len::<int>(v1);\n-        quick_sort3::<int>(v1);\n-        let mut i = 0;\n-        while i < len {\n-            // debug!(v2[i]);\n-            assert_eq!(v2[i], v1[i]);\n-            i += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test() {\n-        {\n-            let mut v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n-            let mut v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n-            check_sort(v1, v2);\n-        }\n-        {\n-            let mut v1 = ~[1, 1, 1];\n-            let mut v2 = ~[1, 1, 1];\n-            check_sort(v1, v2);\n-        }\n-        {\n-            let mut v1: ~[int] = ~[];\n-            let mut v2: ~[int] = ~[];\n-            check_sort(v1, v2);\n-        }\n-        { let mut v1 = ~[9]; let mut v2 = ~[9]; check_sort(v1, v2); }\n-        {\n-            let mut v1 = ~[9, 3, 3, 3, 9];\n-            let mut v2 = ~[3, 3, 3, 9, 9];\n-            check_sort(v1, v2);\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test_qsort {\n-    use sort::*;\n-\n-    use core::int;\n-    use core::vec;\n-\n-    fn check_sort(v1: &mut [int], v2: &mut [int]) {\n-        let len = vec::len::<int>(v1);\n-        fn leual(a: &int, b: &int) -> bool { *a <= *b }\n-        quick_sort::<int>(v1, leual);\n-        let mut i = 0u;\n-        while i < len {\n-            // debug!(v2[i]);\n-            assert_eq!(v2[i], v1[i]);\n-            i += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test() {\n-        {\n-            let mut v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n-            let mut v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n-            check_sort(v1, v2);\n-        }\n-        {\n-            let mut v1 = ~[1, 1, 1];\n-            let mut v2 = ~[1, 1, 1];\n-            check_sort(v1, v2);\n-        }\n-        {\n-            let mut v1: ~[int] = ~[];\n-            let mut v2: ~[int] = ~[];\n-            check_sort(v1, v2);\n-        }\n-        { let mut v1 = ~[9]; let mut v2 = ~[9]; check_sort(v1, v2); }\n-        {\n-            let mut v1 = ~[9, 3, 3, 3, 9];\n-            let mut v2 = ~[3, 3, 3, 9, 9];\n-            check_sort(v1, v2);\n-        }\n-    }\n-\n-    // Regression test for #750\n-    #[test]\n-    fn test_simple() {\n-        let mut names = ~[2, 1, 3];\n-\n-        let expected = ~[1, 2, 3];\n-\n-        do quick_sort(names) |x, y| { int::le(*x, *y) };\n-\n-        let immut_names = names;\n-\n-        let pairs = vec::zip_slice(expected, immut_names);\n-        for pairs.each |p| {\n-            let (a, b) = *p;\n-            debug!(\"%d %d\", a, b);\n-            assert_eq!(a, b);\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-\n-    use sort::*;\n-\n-    use core::vec;\n-\n-    fn check_sort(v1: &[int], v2: &[int]) {\n-        let len = vec::len::<int>(v1);\n-        pub fn le(a: &int, b: &int) -> bool { *a <= *b }\n-        let f = le;\n-        let v3 = merge_sort::<int>(v1, f);\n-        let mut i = 0u;\n-        while i < len {\n-            debug!(v3[i]);\n-            assert_eq!(v3[i], v2[i]);\n-            i += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test() {\n-        {\n-            let v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n-            let v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n-            check_sort(v1, v2);\n-        }\n-        { let v1 = ~[1, 1, 1]; let v2 = ~[1, 1, 1]; check_sort(v1, v2); }\n-        { let v1:~[int] = ~[]; let v2:~[int] = ~[]; check_sort(v1, v2); }\n-        { let v1 = ~[9]; let v2 = ~[9]; check_sort(v1, v2); }\n-        {\n-            let v1 = ~[9, 3, 3, 3, 9];\n-            let v2 = ~[3, 3, 3, 9, 9];\n-            check_sort(v1, v2);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_merge_sort_mutable() {\n-        pub fn le(a: &int, b: &int) -> bool { *a <= *b }\n-        let mut v1 = ~[3, 2, 1];\n-        let v2 = merge_sort(v1, le);\n-        assert_eq!(v2, ~[1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_merge_sort_stability() {\n-        // tjc: funny that we have to use parens\n-        fn ile(x: &(&'static str), y: &(&'static str)) -> bool\n-        {\n-            // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n-            // to_ascii_consume and to_str_consume to not do a unnecessary copy.\n-            // (Actually, could just remove the to_str_* call, but needs an deriving(Ord) on\n-            // Ascii)\n-            let x = x.to_ascii().to_lower().to_str_ascii();\n-            let y = y.to_ascii().to_lower().to_str_ascii();\n-            x <= y\n-        }\n-\n-        let names1 = ~[\"joe bob\", \"Joe Bob\", \"Jack Brown\", \"JOE Bob\",\n-                       \"Sally Mae\", \"JOE BOB\", \"Alex Andy\"];\n-        let names2 = ~[\"Alex Andy\", \"Jack Brown\", \"joe bob\", \"Joe Bob\",\n-                       \"JOE Bob\", \"JOE BOB\", \"Sally Mae\"];\n-        let names3 = merge_sort(names1, ile);\n-        assert_eq!(names3, names2);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test_tim_sort {\n-    use sort::tim_sort;\n-    use core::rand::RngUtil;\n-\n-    struct CVal {\n-        val: float,\n-    }\n-\n-    impl Ord for CVal {\n-        fn lt(&self, other: &CVal) -> bool {\n-            let rng = rand::rng();\n-            if rng.gen::<float>() > 0.995 { fail!(\"It's happening!!!\"); }\n-            (*self).val < other.val\n-        }\n-        fn le(&self, other: &CVal) -> bool { (*self).val <= other.val }\n-        fn gt(&self, other: &CVal) -> bool { (*self).val > other.val }\n-        fn ge(&self, other: &CVal) -> bool { (*self).val >= other.val }\n-    }\n-\n-    fn check_sort(v1: &mut [int], v2: &mut [int]) {\n-        let len = vec::len::<int>(v1);\n-        tim_sort::<int>(v1);\n-        let mut i = 0u;\n-        while i < len {\n-            // debug!(v2[i]);\n-            assert_eq!(v2[i], v1[i]);\n-            i += 1u;\n-        }\n-    }\n-\n-    #[test]\n-    fn test() {\n-        {\n-            let mut v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n-            let mut v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n-            check_sort(v1, v2);\n-        }\n-        {\n-            let mut v1 = ~[1, 1, 1];\n-            let mut v2 = ~[1, 1, 1];\n-            check_sort(v1, v2);\n-        }\n-        {\n-            let mut v1: ~[int] = ~[];\n-            let mut v2: ~[int] = ~[];\n-            check_sort(v1, v2);\n-        }\n-        { let mut v1 = ~[9]; let mut v2 = ~[9]; check_sort(v1, v2); }\n-        {\n-            let mut v1 = ~[9, 3, 3, 3, 9];\n-            let mut v2 = ~[3, 3, 3, 9, 9];\n-            check_sort(v1, v2);\n-        }\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    #[cfg(unix)]\n-    fn crash_test() {\n-        let rng = rand::rng();\n-        let mut arr = do vec::from_fn(1000) |_i| {\n-            CVal { val: rng.gen() }\n-        };\n-\n-        tim_sort(arr);\n-        fail!(\"Guarantee the fail\");\n-    }\n-\n-    struct DVal { val: uint }\n-\n-    impl Ord for DVal {\n-        fn lt(&self, _x: &DVal) -> bool { true }\n-        fn le(&self, _x: &DVal) -> bool { true }\n-        fn gt(&self, _x: &DVal) -> bool { true }\n-        fn ge(&self, _x: &DVal) -> bool { true }\n-    }\n-\n-    #[test]\n-    fn test_bad_Ord_impl() {\n-        let rng = rand::rng();\n-        let mut arr = do vec::from_fn(500) |_i| {\n-            DVal { val: rng.gen() }\n-        };\n-\n-        tim_sort(arr);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod big_tests {\n-    use sort::*;\n-    use core::rand::RngUtil;\n-\n-    #[test]\n-    fn test_unique() {\n-        let low = 5;\n-        let high = 10;\n-        tabulate_unique(low, high);\n-    }\n-\n-    #[test]\n-    fn test_managed() {\n-        let low = 5;\n-        let high = 10;\n-        tabulate_managed(low, high);\n-    }\n-\n-    fn multiplyVec<T:Copy>(arr: &const [T], num: uint) -> ~[T] {\n-        let size = arr.len();\n-        let res = do vec::from_fn(num) |i| {\n-            arr[i % size]\n-        };\n-        res\n-    }\n-\n-    fn makeRange(n: uint) -> ~[uint] {\n-        let one = do vec::from_fn(n) |i| { i };\n-        let mut two = copy one;\n-        vec::reverse(two);\n-        vec::append(two, one)\n-    }\n-\n-    fn tabulate_unique(lo: uint, hi: uint) {\n-        fn isSorted<T:Ord>(arr: &const [T]) {\n-            for uint::range(0, arr.len()-1) |i| {\n-                if arr[i] > arr[i+1] {\n-                    fail!(\"Array not sorted\");\n-                }\n-            }\n-        }\n-\n-        let rng = rand::rng();\n-\n-        for uint::range(lo, hi) |i| {\n-            let n = 1 << i;\n-            let mut arr: ~[float] = do vec::from_fn(n) |_i| {\n-                rng.gen()\n-            };\n-\n-            tim_sort(arr); // *sort\n-            isSorted(arr);\n-\n-            vec::reverse(arr);\n-            tim_sort(arr); // \\sort\n-            isSorted(arr);\n-\n-            tim_sort(arr); // /sort\n-            isSorted(arr);\n-\n-            for 3.times {\n-                let i1 = rng.gen_uint_range(0, n);\n-                let i2 = rng.gen_uint_range(0, n);\n-                vec::swap(arr, i1, i2);\n-            }\n-            tim_sort(arr); // 3sort\n-            isSorted(arr);\n-\n-            if n >= 10 {\n-                let size = arr.len();\n-                let mut idx = 1;\n-                while idx <= 10 {\n-                    arr[size-idx] = rng.gen();\n-                    idx += 1;\n-                }\n-            }\n-            tim_sort(arr); // +sort\n-            isSorted(arr);\n-\n-            for (n/100).times {\n-                let idx = rng.gen_uint_range(0, n);\n-                arr[idx] = rng.gen();\n-            }\n-            tim_sort(arr);\n-            isSorted(arr);\n-\n-            let mut arr = if n > 4 {\n-                let part = vec::slice(arr, 0, 4);\n-                multiplyVec(part, n)\n-            } else { arr };\n-            tim_sort(arr); // ~sort\n-            isSorted(arr);\n-\n-            let mut arr = vec::from_elem(n, -0.5);\n-            tim_sort(arr); // =sort\n-            isSorted(arr);\n-\n-            let half = n / 2;\n-            let mut arr = makeRange(half).map(|i| *i as float);\n-            tim_sort(arr); // !sort\n-            isSorted(arr);\n-        }\n-    }\n-\n-    fn tabulate_managed(lo: uint, hi: uint) {\n-        fn isSorted<T:Ord>(arr: &const [@T]) {\n-            for uint::range(0, arr.len()-1) |i| {\n-                if arr[i] > arr[i+1] {\n-                    fail!(\"Array not sorted\");\n-                }\n-            }\n-        }\n-\n-        let rng = rand::rng();\n-\n-        for uint::range(lo, hi) |i| {\n-            let n = 1 << i;\n-            let arr: ~[@float] = do vec::from_fn(n) |_i| {\n-                @rng.gen()\n-            };\n-            let mut arr = arr;\n-\n-            tim_sort(arr); // *sort\n-            isSorted(arr);\n-\n-            vec::reverse(arr);\n-            tim_sort(arr); // \\sort\n-            isSorted(arr);\n-\n-            tim_sort(arr); // /sort\n-            isSorted(arr);\n-\n-            for 3.times {\n-                let i1 = rng.gen_uint_range(0, n);\n-                let i2 = rng.gen_uint_range(0, n);\n-                vec::swap(arr, i1, i2);\n-            }\n-            tim_sort(arr); // 3sort\n-            isSorted(arr);\n-\n-            if n >= 10 {\n-                let size = arr.len();\n-                let mut idx = 1;\n-                while idx <= 10 {\n-                    arr[size-idx] = @rng.gen();\n-                    idx += 1;\n-                }\n-            }\n-            tim_sort(arr); // +sort\n-            isSorted(arr);\n-\n-            for (n/100).times {\n-                let idx = rng.gen_uint_range(0, n);\n-                arr[idx] = @rng.gen();\n-            }\n-            tim_sort(arr);\n-            isSorted(arr);\n-\n-            let mut arr = if n > 4 {\n-                let part = vec::slice(arr, 0, 4);\n-                multiplyVec(part, n)\n-            } else { arr };\n-            tim_sort(arr); // ~sort\n-            isSorted(arr);\n-\n-            let mut arr = vec::from_elem(n, @(-0.5));\n-            tim_sort(arr); // =sort\n-            isSorted(arr);\n-\n-            let half = n / 2;\n-            let mut arr = makeRange(half).map(|i| @(*i as float));\n-            tim_sort(arr); // !sort\n-            isSorted(arr);\n-        }\n-    }\n-\n-    struct LVal<'self> {\n-        val: uint,\n-        key: &'self fn(@uint),\n-    }\n-\n-    #[unsafe_destructor]\n-    impl<'self> Drop for LVal<'self> {\n-        fn finalize(&self) {\n-            let x = unsafe { local_data::local_data_get(self.key) };\n-            match x {\n-                Some(@y) => {\n-                    unsafe {\n-                        local_data::local_data_set(self.key, @(y+1));\n-                    }\n-                }\n-                _ => fail!(\"Expected key to work\"),\n-            }\n-        }\n-    }\n-\n-    impl<'self> Ord for LVal<'self> {\n-        fn lt<'a>(&self, other: &'a LVal<'self>) -> bool {\n-            (*self).val < other.val\n-        }\n-        fn le<'a>(&self, other: &'a LVal<'self>) -> bool {\n-            (*self).val <= other.val\n-        }\n-        fn gt<'a>(&self, other: &'a LVal<'self>) -> bool {\n-            (*self).val > other.val\n-        }\n-        fn ge<'a>(&self, other: &'a LVal<'self>) -> bool {\n-            (*self).val >= other.val\n-        }\n-    }\n-}\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "72f06f0befa257e1a0f2f07e29df7819688b4afe", "filename": "src/libstd/std.rc", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -63,18 +63,12 @@ pub mod flatpipes;\n \n pub mod bitv;\n pub mod deque;\n-#[cfg(not(stage0))]\n pub mod fun_treemap;\n pub mod list;\n pub mod priority_queue;\n pub mod rope;\n pub mod smallintmap;\n \n-#[cfg(stage0)]\n-#[path=\"sort_stage0.rs\"]\n-pub mod sort;\n-\n-#[cfg(not(stage0))]\n pub mod sort;\n \n pub mod dlist;"}, {"sha": "93f8d06ee0836ff942d4557a8f4d7b29c300a00f", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 0, "deletions": 208, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -105,45 +105,21 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n     }\n \n     /// Visit all key-value pairs in order\n-    #[cfg(stage0)]\n-    fn each<'a>(&'a self, f: &fn(&'a K, &'a V) -> bool) {\n-        each(&self.root, f);\n-    }\n-    /// Visit all key-value pairs in order\n-    #[cfg(not(stage0))]\n     fn each<'a>(&'a self, f: &fn(&'a K, &'a V) -> bool) -> bool {\n         each(&self.root, f)\n     }\n \n     /// Visit all keys in order\n-    #[cfg(stage0)]\n-    fn each_key(&self, f: &fn(&K) -> bool) {\n-        self.each(|k, _| f(k))\n-    }\n-    /// Visit all keys in order\n-    #[cfg(not(stage0))]\n     fn each_key(&self, f: &fn(&K) -> bool) -> bool {\n         self.each(|k, _| f(k))\n     }\n \n     /// Visit all values in order\n-    #[cfg(stage0)]\n-    fn each_value<'a>(&'a self, f: &fn(&'a V) -> bool) {\n-        self.each(|_, v| f(v))\n-    }\n-    /// Visit all values in order\n-    #[cfg(not(stage0))]\n     fn each_value<'a>(&'a self, f: &fn(&'a V) -> bool) -> bool {\n         self.each(|_, v| f(v))\n     }\n \n     /// Iterate over the map and mutate the contained values\n-    #[cfg(stage0)]\n-    fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool) {\n-        mutate_values(&mut self.root, f);\n-    }\n-    /// Iterate over the map and mutate the contained values\n-    #[cfg(not(stage0))]\n     fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool) -> bool {\n         mutate_values(&mut self.root, f)\n     }\n@@ -201,33 +177,6 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n     }\n }\n \n-#[cfg(stage0)]\n-pub impl<K: TotalOrd, V> TreeMap<K, V> {\n-    /// Create an empty TreeMap\n-    fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n-\n-    /// Visit all key-value pairs in reverse order\n-    fn each_reverse<'a>(&'a self, f: &fn(&'a K, &'a V) -> bool) {\n-        each_reverse(&self.root, f);\n-    }\n-\n-    /// Visit all keys in reverse order\n-    fn each_key_reverse(&self, f: &fn(&K) -> bool) {\n-        self.each_reverse(|k, _| f(k))\n-    }\n-\n-    /// Visit all values in reverse order\n-    fn each_value_reverse(&self, f: &fn(&V) -> bool) {\n-        self.each_reverse(|_, v| f(v))\n-    }\n-\n-    /// Get a lazy iterator over the key-value pairs in the map.\n-    /// Requires that it be frozen (immutable).\n-    fn iter<'a>(&'a self) -> TreeMapIterator<'a, K, V> {\n-        TreeMapIterator{stack: ~[], node: &self.root}\n-    }\n-}\n-#[cfg(not(stage0))]\n pub impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// Create an empty TreeMap\n     fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n@@ -297,25 +246,13 @@ pub struct TreeSet<T> {\n impl<T: TotalOrd> BaseIter<T> for TreeSet<T> {\n     /// Visit all values in order\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn each(&self, f: &fn(&T) -> bool) { self.map.each_key(f) }\n-    /// Visit all values in order\n-    #[inline(always)]\n-    #[cfg(not(stage0))]\n     fn each(&self, f: &fn(&T) -> bool) -> bool { self.map.each_key(f) }\n     #[inline(always)]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl<T: TotalOrd> ReverseIter<T> for TreeSet<T> {\n     /// Visit all values in reverse order\n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn each_reverse(&self, f: &fn(&T) -> bool) {\n-        self.map.each_key_reverse(f)\n-    }\n-    /// Visit all values in reverse order\n-    #[cfg(not(stage0))]\n     #[inline(always)]\n     fn each_reverse(&self, f: &fn(&T) -> bool) -> bool {\n         self.map.each_key_reverse(f)\n@@ -424,37 +361,6 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n \n     /// Visit the values (in-order) representing the difference\n-    #[cfg(stage0)]\n-    fn difference(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) {\n-        let mut x = self.iter();\n-        let mut y = other.iter();\n-\n-        let mut a = x.next();\n-        let mut b = y.next();\n-\n-        while a.is_some() {\n-            if b.is_none() {\n-                return do a.while_some() |a1| {\n-                    if f(a1) { x.next() } else { None }\n-                }\n-            }\n-\n-            let a1 = a.unwrap();\n-            let b1 = b.unwrap();\n-\n-            let cmp = a1.cmp(b1);\n-\n-            if cmp == Less {\n-                if !f(a1) { return }\n-                a = x.next();\n-            } else {\n-                if cmp == Equal { a = x.next() }\n-                b = y.next();\n-            }\n-        }\n-    }\n-    /// Visit the values (in-order) representing the difference\n-    #[cfg(not(stage0))]\n     fn difference(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n         let mut x = self.iter();\n         let mut y = other.iter();\n@@ -484,45 +390,6 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n \n     /// Visit the values (in-order) representing the symmetric difference\n-    #[cfg(stage0)]\n-    fn symmetric_difference(&self, other: &TreeSet<T>,\n-                                 f: &fn(&T) -> bool) {\n-        let mut x = self.iter();\n-        let mut y = other.iter();\n-\n-        let mut a = x.next();\n-        let mut b = y.next();\n-\n-        while a.is_some() {\n-            if b.is_none() {\n-                return do a.while_some() |a1| {\n-                    if f(a1) { x.next() } else { None }\n-                }\n-            }\n-\n-            let a1 = a.unwrap();\n-            let b1 = b.unwrap();\n-\n-            let cmp = a1.cmp(b1);\n-\n-            if cmp == Less {\n-                if !f(a1) { return }\n-                a = x.next();\n-            } else {\n-                if cmp == Greater {\n-                    if !f(b1) { return }\n-                } else {\n-                    a = x.next();\n-                }\n-                b = y.next();\n-            }\n-        }\n-        do b.while_some |b1| {\n-            if f(b1) { y.next() } else { None }\n-        }\n-    }\n-    /// Visit the values (in-order) representing the symmetric difference\n-    #[cfg(not(stage0))]\n     fn symmetric_difference(&self, other: &TreeSet<T>,\n                             f: &fn(&T) -> bool) -> bool {\n         let mut x = self.iter();\n@@ -557,32 +424,6 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n \n     /// Visit the values (in-order) representing the intersection\n-    #[cfg(stage0)]\n-    fn intersection(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) {\n-        let mut x = self.iter();\n-        let mut y = other.iter();\n-\n-        let mut a = x.next();\n-        let mut b = y.next();\n-\n-        while a.is_some() && b.is_some() {\n-            let a1 = a.unwrap();\n-            let b1 = b.unwrap();\n-\n-            let cmp = a1.cmp(b1);\n-\n-            if cmp == Less {\n-                a = x.next();\n-            } else {\n-                if cmp == Equal {\n-                    if !f(a1) { return }\n-                }\n-                b = y.next();\n-            }\n-        }\n-    }\n-    /// Visit the values (in-order) representing the intersection\n-    #[cfg(not(stage0))]\n     fn intersection(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n         let mut x = self.iter();\n         let mut y = other.iter();\n@@ -609,43 +450,6 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n \n     /// Visit the values (in-order) representing the union\n-    #[cfg(stage0)]\n-    fn union(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) {\n-        let mut x = self.iter();\n-        let mut y = other.iter();\n-\n-        let mut a = x.next();\n-        let mut b = y.next();\n-\n-        while a.is_some() {\n-            if b.is_none() {\n-                return do a.while_some() |a1| {\n-                    if f(a1) { x.next() } else { None }\n-                }\n-            }\n-\n-            let a1 = a.unwrap();\n-            let b1 = b.unwrap();\n-\n-            let cmp = a1.cmp(b1);\n-\n-            if cmp == Greater {\n-                if !f(b1) { return }\n-                b = y.next();\n-            } else {\n-                if !f(a1) { return }\n-                if cmp == Equal {\n-                    b = y.next();\n-                }\n-                a = x.next();\n-            }\n-        }\n-        do b.while_some |b1| {\n-            if f(b1) { y.next() } else { None }\n-        }\n-    }\n-    /// Visit the values (in-order) representing the union\n-    #[cfg(not(stage0))]\n     fn union(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n         let mut x = self.iter();\n         let mut y = other.iter();\n@@ -713,24 +517,12 @@ pub impl<K: TotalOrd, V> TreeNode<K, V> {\n     }\n }\n \n-#[cfg(stage0)]\n-fn each<'r, K: TotalOrd, V>(_: &'r Option<~TreeNode<K, V>>,\n-                            _: &fn(&'r K, &'r V) -> bool) -> bool {\n-    fail!(\"don't use me in stage0!\")\n-}\n-#[cfg(not(stage0))]\n fn each<'r, K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n                             f: &fn(&'r K, &'r V) -> bool) -> bool {\n     node.each(|x| each(&x.left, f) && f(&x.key, &x.value) &&\n                   each(&x.right, f))\n }\n \n-#[cfg(stage0)]\n-fn each_reverse<'r, K: TotalOrd, V>(_: &'r Option<~TreeNode<K, V>>,\n-                                    _: &fn(&'r K, &'r V) -> bool) -> bool {\n-    fail!(\"don't use me in stage0!\")\n-}\n-#[cfg(not(stage0))]\n fn each_reverse<'r, K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n                                     f: &fn(&'r K, &'r V) -> bool) -> bool {\n     node.each(|x| each_reverse(&x.right, f) && f(&x.key, &x.value) &&"}, {"sha": "ee57bf2f3a1b562d3f1354a6c68b544570df303f", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -97,17 +97,6 @@ struct WorkKey {\n     name: ~str\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for WorkKey {\n-    #[inline(always)]\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        let mut flag = true;\n-        self.kind.iter_bytes(lsb0, |bytes| {flag = f(bytes); flag});\n-        if !flag { return; }\n-        self.name.iter_bytes(lsb0, f);\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for WorkKey {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {"}, {"sha": "e67b5d118d365a68db03515a15679efdd0f42fe4", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -79,20 +79,6 @@ static AbiDatas: &'static [AbiData] = &[\n     AbiData {abi: RustIntrinsic, name: \"rust-intrinsic\", abi_arch: RustArch},\n ];\n \n-#[cfg(stage0)]\n-fn each_abi(op: &fn(abi: Abi) -> bool) {\n-    /*!\n-     *\n-     * Iterates through each of the defined ABIs.\n-     */\n-\n-    for AbiDatas.each |abi_data| {\n-        if !op(abi_data.abi) {\n-            return;\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n fn each_abi(op: &fn(abi: Abi) -> bool) -> bool {\n     /*!\n      *\n@@ -197,17 +183,6 @@ pub impl AbiSet {\n         self.bits |= (1 << abi.index());\n     }\n \n-    #[cfg(stage0)]\n-    fn each(&self, op: &fn(abi: Abi) -> bool) {\n-        for each_abi |abi| {\n-            if self.contains(abi) {\n-                if !op(abi) {\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(not(stage0))]\n     fn each(&self, op: &fn(abi: Abi) -> bool) -> bool {\n         each_abi(|abi| !self.contains(abi) || op(abi))\n     }\n@@ -265,26 +240,12 @@ pub impl AbiSet {\n     }\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for Abi {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        self.index().iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for Abi {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         self.index().iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for AbiSet {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        self.bits.iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for AbiSet {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         self.bits.iter_bytes(lsb0, f)"}, {"sha": "241450e7130a2e1a1c84af096209388a0fef9d69", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -95,14 +95,6 @@ impl<D:Decoder> Decodable<D> for ident {\n     }\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for ident {\n-    #[inline(always)]\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        self.repr.iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for ident {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n@@ -120,14 +112,6 @@ pub struct Lifetime {\n     ident: ident\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for Lifetime {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_3(&self.id, &self.span, &self.ident, lsb0, f)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for Lifetime {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         to_bytes::iter_bytes_3(&self.id, &self.span, &self.ident, lsb0, f)\n@@ -279,21 +263,6 @@ pub enum binding_mode {\n     bind_infer\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for binding_mode {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        match *self {\n-          bind_by_copy => 0u8.iter_bytes(lsb0, f),\n-\n-          bind_by_ref(ref m) =>\n-          to_bytes::iter_bytes_2(&1u8, m, lsb0, f),\n-\n-          bind_infer =>\n-          2u8.iter_bytes(lsb0, f),\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for binding_mode {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         match *self {\n@@ -334,13 +303,6 @@ pub enum pat_ {\n #[deriving(Eq, Encodable, Decodable)]\n pub enum mutability { m_mutbl, m_imm, m_const, }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for mutability {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        (*self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for mutability {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         (*self as u8).iter_bytes(lsb0, f)\n@@ -354,13 +316,6 @@ pub enum Sigil {\n     ManagedSigil\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for Sigil {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        (*self as uint).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for Sigil {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         (*self as uint).iter_bytes(lsb0, f)\n@@ -718,13 +673,6 @@ impl ToStr for int_ty {\n     }\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for int_ty {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        (*self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for int_ty {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         (*self as u8).iter_bytes(lsb0, f)\n@@ -740,13 +688,6 @@ impl ToStr for uint_ty {\n     }\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for uint_ty {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        (*self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for uint_ty {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         (*self as u8).iter_bytes(lsb0, f)\n@@ -762,13 +703,6 @@ impl ToStr for float_ty {\n     }\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for float_ty {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        (*self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for float_ty {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         (*self as u8).iter_bytes(lsb0, f)\n@@ -808,13 +742,6 @@ impl ToStr for Onceness {\n     }\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for Onceness {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        (*self as uint).iter_bytes(lsb0, f);\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for Onceness {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         (*self as uint).iter_bytes(lsb0, f)\n@@ -861,13 +788,6 @@ pub enum ty_ {\n     ty_infer,\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for Ty {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_2(&self.span.lo, &self.span.hi, lsb0, f);\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for Ty {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         to_bytes::iter_bytes_2(&self.span.lo, &self.span.hi, lsb0, f)\n@@ -925,13 +845,6 @@ impl ToStr for purity {\n     }\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for purity {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        (*self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for purity {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         (*self as u8).iter_bytes(lsb0, f)\n@@ -945,13 +858,6 @@ pub enum ret_style {\n     return_val, // everything else\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for ret_style {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        (*self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for ret_style {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         (*self as u8).iter_bytes(lsb0, f)\n@@ -967,20 +873,6 @@ pub enum explicit_self_ {\n     sty_uniq(mutability)                       // `~self`\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for explicit_self_ {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        match *self {\n-            sty_static => 0u8.iter_bytes(lsb0, f),\n-            sty_value => 1u8.iter_bytes(lsb0, f),\n-            sty_region(ref lft, ref mutbl) => to_bytes::iter_bytes_3(&2u8, &lft, mutbl, lsb0, f),\n-            sty_box(ref mutbl) => to_bytes::iter_bytes_2(&3u8, mutbl, lsb0, f),\n-            sty_uniq(ref mutbl) => to_bytes::iter_bytes_2(&4u8, mutbl, lsb0, f),\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for explicit_self_ {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         match *self {"}, {"sha": "bb6d13b2831186ce1efa7bf817f71fab7e309e52", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -191,15 +191,6 @@ pub fn is_call_expr(e: @expr) -> bool {\n }\n \n // This makes def_id hashable\n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for def_id {\n-    #[inline(always)]\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_2(&self.crate, &self.node, lsb0, f);\n-    }\n-}\n-// This makes def_id hashable\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for def_id {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {"}, {"sha": "2e235982a0f926114698f6294269754446a78153", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -65,13 +65,6 @@ impl Sub<BytePos, BytePos> for BytePos {\n     }\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for BytePos {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        (**self).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for BytePos {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         (**self).iter_bytes(lsb0, f)\n@@ -90,13 +83,6 @@ impl cmp::Ord for CharPos {\n     fn gt(&self, other: &CharPos) -> bool { **self > **other }\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for CharPos {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        (**self).iter_bytes(lsb0, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for CharPos {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         (**self).iter_bytes(lsb0, f)\n@@ -150,14 +136,6 @@ impl<D:Decoder> Decodable<D> for span {\n     }\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for span {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_3(&self.lo, &self.hi, &self.expn_info, lsb0, f);\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for span {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         to_bytes::iter_bytes_3(&self.lo, &self.hi, &self.expn_info, lsb0, f)\n@@ -211,14 +189,6 @@ pub struct FileMapAndLine {fm: @FileMap, line: uint}\n pub struct FileMapAndBytePos {fm: @FileMap, pos: BytePos}\n pub struct NameAndSpan {name: ~str, span: Option<span>}\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for NameAndSpan {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_2(&self.name, &self.span, lsb0, f)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for NameAndSpan {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         to_bytes::iter_bytes_2(&self.name, &self.span, lsb0, f)\n@@ -230,14 +200,6 @@ pub struct CallInfo {\n     callee: NameAndSpan\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for CallInfo {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_2(&self.call_site, &self.callee, lsb0, f)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for CallInfo {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         to_bytes::iter_bytes_2(&self.call_site, &self.callee, lsb0, f)\n@@ -249,16 +211,6 @@ pub enum ExpnInfo {\n     ExpandedFrom(CallInfo)\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for ExpnInfo {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        match *self {\n-            ExpandedFrom(ref call_info) => to_bytes::iter_bytes_2(&0u8, call_info, lsb0, f)\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for ExpnInfo {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         match *self {"}, {"sha": "7bf58bc6f324cd38ade568c49a0920a48ca383e6", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -100,21 +100,6 @@ pub impl state_ {\n \n     /// Iterate over the states that can be reached in one message\n     /// from this state.\n-    #[cfg(stage0)]\n-    fn reachable(&self, f: &fn(state) -> bool) {\n-        for self.messages.each |m| {\n-            match *m {\n-              message(_, _, _, _, Some(next_state { state: ref id, _ })) => {\n-                let state = self.proto.get_state((*id));\n-                if !f(state) { break }\n-              }\n-              _ => ()\n-            }\n-        }\n-    }\n-    /// Iterate over the states that can be reached in one message\n-    /// from this state.\n-    #[cfg(not(stage0))]\n     fn reachable(&self, f: &fn(state) -> bool) -> bool {\n         for self.messages.each |m| {\n             match *m {"}, {"sha": "db1e95d5ad5105c9b2ea2b4901a746f90537a157", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -131,14 +131,6 @@ impl<A:Eq> Eq for OptVec<A> {\n }\n \n impl<A> BaseIter<A> for OptVec<A> {\n-    #[cfg(stage0)]\n-    fn each(&self, blk: &fn(v: &A) -> bool) {\n-        match *self {\n-            Empty => {}\n-            Vec(ref v) => v.each(blk)\n-        }\n-    }\n-    #[cfg(not(stage0))]\n     fn each(&self, blk: &fn(v: &A) -> bool) -> bool {\n         match *self {\n             Empty => true,\n@@ -153,12 +145,6 @@ impl<A> BaseIter<A> for OptVec<A> {\n \n impl<A> old_iter::ExtendedIter<A> for OptVec<A> {\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn eachi(&self, blk: &fn(v: uint, v: &A) -> bool) {\n-        old_iter::eachi(self, blk)\n-    }\n-    #[inline(always)]\n-    #[cfg(not(stage0))]\n     fn eachi(&self, blk: &fn(v: uint, v: &A) -> bool) -> bool {\n         old_iter::eachi(self, blk)\n     }"}, {"sha": "0ce3ab4b3e1718dbcb56ec21091d3b960ce46f62", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -64,14 +64,6 @@ pub enum ObsoleteSyntax {\n     ObsoleteNamedExternModule,\n }\n \n-#[cfg(stage0)]\n-impl to_bytes::IterBytes for ObsoleteSyntax {\n-    #[inline(always)]\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        (*self as uint).iter_bytes(lsb0, f);\n-    }\n-}\n-#[cfg(not(stage0))]\n impl to_bytes::IterBytes for ObsoleteSyntax {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {"}, {"sha": "88fa5389089232ca2e7e3098cedf81c91d97d0ae", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -349,14 +349,6 @@ impl<'self> Equiv<@~str> for StringRef<'self> {\n     fn equiv(&self, other: &@~str) -> bool { str::eq_slice(**self, **other) }\n }\n \n-#[cfg(stage0)]\n-impl<'self> to_bytes::IterBytes for StringRef<'self> {\n-    #[inline(always)]\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        (**self).iter_bytes(lsb0, f);\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<'self> to_bytes::IterBytes for StringRef<'self> {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {"}, {"sha": "a68d2205cfba8a4eb1055ef4df8c9dca7bad8db7", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66319b027888ceddf024a5919e007caceaf369f3/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/66319b027888ceddf024a5919e007caceaf369f3/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=66319b027888ceddf024a5919e007caceaf369f3", "patch": "@@ -1,3 +1,11 @@\n+S 2013-05-17 2d28d64\n+  macos-i386 abadafb33c9f858543351c822fb468195163559f\n+  macos-x86_64 4a484693f73bcc8ce2a85708fd4f0c3f6e34969d\n+  winnt-i386 558dac018b2b6dbb23841772e1f4b9591558850c\n+  freebsd-x86_64 59ca6fc1eae2d160525c705928d551dd8993e01c\n+  linux-i386 2d3e61efe30f55176c72b3dbe31d693630f59abd\n+  linux-x86_64 86ecc1833df8e28d08ff3a9a952ec424abdcb157\n+\n S 2013-05-03 213f7b2\n   macos-i386 0bf8b88ea01cc4cdd81ac4db1d301ea9b3371f13\n   macos-x86_64 2da3990639ab5a9c9d51b3478c437cb459de84e3"}]}