{"sha": "2e8c975e17a8c165fb0ab0dd7eba2eeb64783198", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlOGM5NzVlMTdhOGMxNjVmYjBhYjBkZDdlYmEyZWViNjQ3ODMxOTg=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-06-28T03:30:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-06-28T03:30:51Z"}, "message": "Merge pull request #2809 from nrc/formatting\n\nSome formatting fixes", "tree": {"sha": "bd46146fce48d29f4570149b2561eb3d84306946", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd46146fce48d29f4570149b2561eb3d84306946"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e8c975e17a8c165fb0ab0dd7eba2eeb64783198", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbNFZrCRBK7hj4Ov3rIwAAdHIIACSLcK2xPc5Hlv40aeu1nxkO\n0NBb44a1fT6XHC2NeYP5LVwojwe6bMPMpzzucW87+YZ6uPWppsQnqg+BcddFTSAL\nPiA826KWnmy9keBzF2G/tvuiEVKnYUgKNDan65glmyh7f9/3tA9gnMvKaoQ4SbmF\nW/VeCcEvcNrpd/Gdxfu66BLywF5MqArGur02n6xlxIYLZo727JrS3LmEiF8488o3\nT+2hBRpDIuV3AnuZOOAOziG05/lCZqu01/tQ8cMqJmfv6msUFwS3UeDSNEssVpyI\nadesYuJMBgbM/QA5s8Q8q/45jzfXXmDDKBdlkzgZqKxyC2MJpmyBnyrKtM6BAjg=\n=f2jw\n-----END PGP SIGNATURE-----\n", "payload": "tree bd46146fce48d29f4570149b2561eb3d84306946\nparent d325323285476182cca404446b741af7dd6b8c7b\nparent 3abebf95cea12e396ed536cb9e29ef8dd1a6c6c1\nauthor Seiichi Uchida <seuchida@gmail.com> 1530156651 +0900\ncommitter GitHub <noreply@github.com> 1530156651 +0900\n\nMerge pull request #2809 from nrc/formatting\n\nSome formatting fixes"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e8c975e17a8c165fb0ab0dd7eba2eeb64783198", "html_url": "https://github.com/rust-lang/rust/commit/2e8c975e17a8c165fb0ab0dd7eba2eeb64783198", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e8c975e17a8c165fb0ab0dd7eba2eeb64783198/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d325323285476182cca404446b741af7dd6b8c7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d325323285476182cca404446b741af7dd6b8c7b", "html_url": "https://github.com/rust-lang/rust/commit/d325323285476182cca404446b741af7dd6b8c7b"}, {"sha": "3abebf95cea12e396ed536cb9e29ef8dd1a6c6c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3abebf95cea12e396ed536cb9e29ef8dd1a6c6c1", "html_url": "https://github.com/rust-lang/rust/commit/3abebf95cea12e396ed536cb9e29ef8dd1a6c6c1"}], "stats": {"total": 578, "additions": 410, "deletions": 168}, "files": [{"sha": "3c545bdda7042b39a435db92ea32ae7a8a3b5bec", "filename": "src/attr.rs", "status": "modified", "additions": 268, "deletions": 153, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/2e8c975e17a8c165fb0ab0dd7eba2eeb64783198/src%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8c975e17a8c165fb0ab0dd7eba2eeb64783198/src%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattr.rs?ref=2e8c975e17a8c165fb0ab0dd7eba2eeb64783198", "patch": "@@ -10,19 +10,20 @@\n \n //! Format attributes and meta items.\n \n+use comment::{contains_comment, rewrite_doc_comment};\n use config::lists::*;\n use config::IndentStyle;\n-use syntax::ast;\n-use syntax::codemap::Span;\n-\n-use comment::{combine_strs_with_missing_comments, contains_comment, rewrite_doc_comment};\n use expr::rewrite_literal;\n use lists::{itemize_list, write_list, ListFormatting};\n use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n use types::{rewrite_path, PathContext};\n use utils::{count_newlines, mk_sp};\n \n+use std::borrow::Cow;\n+use syntax::ast;\n+use syntax::codemap::{BytePos, Span, DUMMY_SP};\n+\n /// Returns attributes on the given statement.\n pub fn get_attrs_from_stmt(stmt: &ast::Stmt) -> &[ast::Attribute] {\n     match stmt.node {\n@@ -47,42 +48,63 @@ fn is_derive(attr: &ast::Attribute) -> bool {\n }\n \n /// Returns the arguments of `#[derive(...)]`.\n-fn get_derive_args<'a>(context: &'a RewriteContext, attr: &ast::Attribute) -> Option<Vec<&'a str>> {\n+fn get_derive_spans<'a>(attr: &ast::Attribute) -> Option<Vec<Span>> {\n     attr.meta_item_list().map(|meta_item_list| {\n         meta_item_list\n             .iter()\n-            .map(|nested_meta_item| context.snippet(nested_meta_item.span))\n+            .map(|nested_meta_item| nested_meta_item.span)\n             .collect()\n     })\n }\n \n-// Format `#[derive(..)]`, using visual indent & mixed style when we need to go multiline.\n-fn format_derive(context: &RewriteContext, derive_args: &[&str], shape: Shape) -> Option<String> {\n+// The shape of the arguments to a function-like attribute.\n+fn argument_shape(\n+    left: usize,\n+    right: usize,\n+    shape: Shape,\n+    context: &RewriteContext,\n+) -> Option<Shape> {\n+    match context.config.indent_style() {\n+        IndentStyle::Block => Some(\n+            shape\n+                .block_indent(context.config.tab_spaces())\n+                .with_max_width(context.config),\n+        ),\n+        IndentStyle::Visual => shape\n+            .visual_indent(0)\n+            .shrink_left(left)\n+            .and_then(|s| s.sub_width(right)),\n+    }\n+}\n+\n+fn format_derive(\n+    derive_args: &[Span],\n+    prefix: &str,\n+    shape: Shape,\n+    context: &RewriteContext,\n+) -> Option<String> {\n     let mut result = String::with_capacity(128);\n-    result.push_str(\"#[derive(\");\n-    // 11 = `#[derive()]`\n-    let initial_budget = shape.width.checked_sub(11)?;\n-    let mut budget = initial_budget;\n-    let num = derive_args.len();\n-    for (i, a) in derive_args.iter().enumerate() {\n-        // 2 = `, ` or `)]`\n-        let width = a.len() + 2;\n-        if width > budget {\n-            if i > 0 {\n-                // Remove trailing whitespace.\n-                result.pop();\n-            }\n-            result.push('\\n');\n-            // 9 = `#[derive(`\n-            result.push_str(&(shape.indent + 9).to_string(context.config));\n-            budget = initial_budget;\n-        } else {\n-            budget = budget.saturating_sub(width);\n-        }\n-        result.push_str(a);\n-        if i != num - 1 {\n-            result.push_str(\", \")\n-        }\n+    result.push_str(prefix);\n+    result.push_str(\"[derive(\");\n+\n+    let argument_shape = argument_shape(10 + prefix.len(), 2, shape, context)?;\n+    let item_str = format_arg_list(\n+        derive_args.iter(),\n+        |_| DUMMY_SP.lo(),\n+        |_| DUMMY_SP.hi(),\n+        |sp| Some(context.snippet(**sp).to_owned()),\n+        DUMMY_SP,\n+        context,\n+        argument_shape,\n+        // 10 = \"[derive()]\", 3 = \"()\" and \"]\"\n+        shape.offset_left(10 + prefix.len())?.sub_width(3)?,\n+        None,\n+    )?;\n+\n+    result.push_str(&item_str);\n+    if item_str.starts_with('\\n') {\n+        result.push(',');\n+        result.push_str(&shape.indent.to_string_with_newline(context.config));\n     }\n     result.push_str(\")]\");\n     Some(result)\n@@ -120,15 +142,14 @@ where\n     &attrs[..len]\n }\n \n-/// Rewrite the same kind of attributes at the same time. This includes doc\n-/// comments and derives.\n-fn rewrite_first_group_attrs(\n+/// Rewrite the any doc comments which come before any other attributes.\n+fn rewrite_initial_doc_comments(\n     context: &RewriteContext,\n     attrs: &[ast::Attribute],\n     shape: Shape,\n-) -> Option<(usize, String)> {\n+) -> Option<(usize, Option<String>)> {\n     if attrs.is_empty() {\n-        return Some((0, String::new()));\n+        return Some((0, None));\n     }\n     // Rewrite doc comments\n     let sugared_docs = take_while_with_pred(context, attrs, |a| a.is_sugared_doc);\n@@ -140,22 +161,15 @@ fn rewrite_first_group_attrs(\n             .join(\"\\n\");\n         return Some((\n             sugared_docs.len(),\n-            rewrite_doc_comment(&snippet, shape.comment(context.config), context.config)?,\n+            Some(rewrite_doc_comment(\n+                &snippet,\n+                shape.comment(context.config),\n+                context.config,\n+            )?),\n         ));\n     }\n-    // Rewrite `#[derive(..)]`s.\n-    if context.config.merge_derives() {\n-        let derives = take_while_with_pred(context, attrs, is_derive);\n-        if !derives.is_empty() {\n-            let mut derive_args = vec![];\n-            for derive in derives {\n-                derive_args.append(&mut get_derive_args(context, derive)?);\n-            }\n-            return Some((derives.len(), format_derive(context, &derive_args, shape)?));\n-        }\n-    }\n-    // Rewrite the first attribute.\n-    Some((1, attrs[0].rewrite(context, shape)?))\n+\n+    Some((0, None))\n }\n \n impl Rewrite for ast::NestedMetaItem {\n@@ -185,19 +199,6 @@ fn has_newlines_before_after_comment(comment: &str) -> (&str, &str) {\n     (if mlb { \"\\n\" } else { \"\" }, if mla { \"\\n\" } else { \"\" })\n }\n \n-fn allow_mixed_tactic_for_nested_metaitem_list(list: &[ast::NestedMetaItem]) -> bool {\n-    list.iter().all(|nested_metaitem| {\n-        if let ast::NestedMetaItemKind::MetaItem(ref inner_metaitem) = nested_metaitem.node {\n-            match inner_metaitem.node {\n-                ast::MetaItemKind::List(..) | ast::MetaItemKind::NameValue(..) => false,\n-                _ => true,\n-            }\n-        } else {\n-            true\n-        }\n-    })\n-}\n-\n impl Rewrite for ast::MetaItem {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         Some(match self.node {\n@@ -206,62 +207,37 @@ impl Rewrite for ast::MetaItem {\n             }\n             ast::MetaItemKind::List(ref list) => {\n                 let path = rewrite_path(context, PathContext::Type, None, &self.ident, shape)?;\n-                let item_shape = match context.config.indent_style() {\n-                    IndentStyle::Block => shape\n-                        .block_indent(context.config.tab_spaces())\n-                        .with_max_width(context.config),\n-                    // 1 = `(`, 2 = `]` and `)`\n-                    IndentStyle::Visual => shape\n-                        .visual_indent(0)\n-                        .shrink_left(path.len() + 1)\n-                        .and_then(|s| s.sub_width(2))?,\n-                };\n-                let items = itemize_list(\n-                    context.snippet_provider,\n+\n+                let snippet = context.snippet(self.span);\n+                // 2 = )] (this might go wrong if there is whitespace between the brackets, but\n+                // it's close enough).\n+                let snippet = snippet[..snippet.len() - 2].trim();\n+                let trailing_comma = if snippet.ends_with(',') { \",\" } else { \"\" };\n+\n+                let argument_shape =\n+                    argument_shape(path.len() + 1, 2 + trailing_comma.len(), shape, context)?;\n+                let item_str = format_arg_list(\n                     list.iter(),\n-                    \")\",\n-                    \",\",\n                     |nested_meta_item| nested_meta_item.span.lo(),\n                     |nested_meta_item| nested_meta_item.span.hi(),\n-                    |nested_meta_item| nested_meta_item.rewrite(context, item_shape),\n-                    self.span.lo(),\n-                    self.span.hi(),\n-                    false,\n-                );\n-                let item_vec = items.collect::<Vec<_>>();\n-                let tactic = if allow_mixed_tactic_for_nested_metaitem_list(list) {\n-                    DefinitiveListTactic::Mixed\n+                    |nested_meta_item| nested_meta_item.rewrite(context, argument_shape),\n+                    self.span,\n+                    context,\n+                    argument_shape,\n+                    // 3 = \"()\" and \"]\"\n+                    shape\n+                        .offset_left(path.len())?\n+                        .sub_width(3 + trailing_comma.len())?,\n+                    Some(context.config.width_heuristics().fn_call_width),\n+                )?;\n+\n+                let indent = if item_str.starts_with('\\n') {\n+                    shape.indent.to_string_with_newline(context.config)\n                 } else {\n-                    ::lists::definitive_tactic(\n-                        &item_vec,\n-                        ListTactic::HorizontalVertical,\n-                        ::lists::Separator::Comma,\n-                        item_shape.width,\n-                    )\n+                    Cow::Borrowed(\"\")\n                 };\n-                let fmt = ListFormatting {\n-                    tactic,\n-                    separator: \",\",\n-                    trailing_separator: SeparatorTactic::Never,\n-                    separator_place: SeparatorPlace::Back,\n-                    shape: item_shape,\n-                    ends_with_newline: false,\n-                    preserve_newline: false,\n-                    nested: false,\n-                    config: context.config,\n-                };\n-                let item_str = write_list(&item_vec, &fmt)?;\n-                // 3 = \"()\" and \"]\"\n-                let one_line_budget = shape.offset_left(path.len())?.sub_width(3)?.width;\n-                if context.config.indent_style() == IndentStyle::Visual\n-                    || (!item_str.contains('\\n') && item_str.len() <= one_line_budget)\n-                {\n-                    format!(\"{}({})\", path, item_str)\n-                } else {\n-                    let indent = shape.indent.to_string_with_newline(context.config);\n-                    let nested_indent = item_shape.indent.to_string_with_newline(context.config);\n-                    format!(\"{}({}{}{})\", path, nested_indent, item_str, indent)\n-                }\n+\n+                format!(\"{}({}{}{})\", path, item_str, trailing_comma, indent)\n             }\n             ast::MetaItemKind::NameValue(ref literal) => {\n                 let path = rewrite_path(context, PathContext::Type, None, &self.ident, shape)?;\n@@ -281,16 +257,76 @@ impl Rewrite for ast::MetaItem {\n     }\n }\n \n+fn format_arg_list<I, T, F1, F2, F3>(\n+    list: I,\n+    get_lo: F1,\n+    get_hi: F2,\n+    get_item_string: F3,\n+    span: Span,\n+    context: &RewriteContext,\n+    shape: Shape,\n+    one_line_shape: Shape,\n+    one_line_limit: Option<usize>,\n+) -> Option<String>\n+where\n+    I: Iterator<Item = T>,\n+    F1: Fn(&T) -> BytePos,\n+    F2: Fn(&T) -> BytePos,\n+    F3: Fn(&T) -> Option<String>,\n+{\n+    let items = itemize_list(\n+        context.snippet_provider,\n+        list,\n+        \")\",\n+        \",\",\n+        get_lo,\n+        get_hi,\n+        get_item_string,\n+        span.lo(),\n+        span.hi(),\n+        false,\n+    );\n+    let item_vec = items.collect::<Vec<_>>();\n+    let tactic = if let Some(limit) = one_line_limit {\n+        ListTactic::LimitedHorizontalVertical(limit)\n+    } else {\n+        ListTactic::HorizontalVertical\n+    };\n+\n+    let tactic =\n+        ::lists::definitive_tactic(&item_vec, tactic, ::lists::Separator::Comma, shape.width);\n+    let fmt = ListFormatting {\n+        tactic,\n+        separator: \",\",\n+        trailing_separator: SeparatorTactic::Never,\n+        separator_place: SeparatorPlace::Back,\n+        shape,\n+        ends_with_newline: false,\n+        preserve_newline: false,\n+        nested: false,\n+        config: context.config,\n+    };\n+    let item_str = write_list(&item_vec, &fmt)?;\n+\n+    let one_line_budget = one_line_shape.width;\n+    if context.config.indent_style() == IndentStyle::Visual\n+        || (!item_str.contains('\\n') && item_str.len() <= one_line_budget)\n+    {\n+        Some(item_str)\n+    } else {\n+        let nested_indent = shape.indent.to_string_with_newline(context.config);\n+        Some(format!(\"{}{}\", nested_indent, item_str))\n+    }\n+}\n+\n impl Rewrite for ast::Attribute {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        let prefix = match self.style {\n-            ast::AttrStyle::Inner => \"#!\",\n-            ast::AttrStyle::Outer => \"#\",\n-        };\n         let snippet = context.snippet(self.span);\n         if self.is_sugared_doc {\n             rewrite_doc_comment(snippet, shape.comment(context.config), context.config)\n         } else {\n+            let prefix = attr_prefix(self);\n+\n             if contains_comment(snippet) {\n                 return Some(snippet.to_owned());\n             }\n@@ -310,47 +346,126 @@ impl<'a> Rewrite for [ast::Attribute] {\n         if self.is_empty() {\n             return Some(String::new());\n         }\n-        let (first_group_len, first_group_str) = rewrite_first_group_attrs(context, self, shape)?;\n-        if self.len() == 1 || first_group_len == self.len() {\n-            Some(first_group_str)\n-        } else {\n-            let rest_str = self[first_group_len..].rewrite(context, shape)?;\n-            let missing_span = mk_sp(\n-                self[first_group_len - 1].span.hi(),\n-                self[first_group_len].span.lo(),\n-            );\n-            // Preserve an empty line before/after doc comments.\n-            if self[0].is_sugared_doc || self[first_group_len].is_sugared_doc {\n-                let snippet = context.snippet(missing_span);\n-                let (mla, mlb) = has_newlines_before_after_comment(snippet);\n+\n+        // The current remaining attributes.\n+        let mut attrs = self;\n+        let mut result = String::new();\n+\n+        // This is not just a simple map because we need to handle doc comments\n+        // (where we take as many doc comment attributes as possible) and possibly\n+        // merging derives into a single attribute.\n+        loop {\n+            if attrs.is_empty() {\n+                return Some(result);\n+            }\n+\n+            // Handle doc comments.\n+            let (doc_comment_len, doc_comment_str) =\n+                rewrite_initial_doc_comments(context, attrs, shape)?;\n+            if doc_comment_len > 0 {\n+                let doc_comment_str = doc_comment_str.expect(\"doc comments, but no result\");\n+                result.push_str(&doc_comment_str);\n+\n+                let missing_span = attrs\n+                    .get(doc_comment_len)\n+                    .map(|next| mk_sp(attrs[doc_comment_len - 1].span.hi(), next.span.lo()));\n+                if let Some(missing_span) = missing_span {\n+                    let snippet = context.snippet(missing_span);\n+                    let (mla, mlb) = has_newlines_before_after_comment(snippet);\n+                    let comment = ::comment::recover_missing_comment_in_span(\n+                        missing_span,\n+                        shape.with_max_width(context.config),\n+                        context,\n+                        0,\n+                    )?;\n+                    let comment = if comment.is_empty() {\n+                        format!(\"\\n{}\", mlb)\n+                    } else {\n+                        format!(\"{}{}\\n{}\", mla, comment, mlb)\n+                    };\n+                    result.push_str(&comment);\n+                    result.push_str(&shape.indent.to_string(context.config));\n+                }\n+\n+                attrs = &attrs[doc_comment_len..];\n+\n+                continue;\n+            }\n+\n+            // Handle derives if we will merge them.\n+            if context.config.merge_derives() && is_derive(&attrs[0]) {\n+                let derives = take_while_with_pred(context, attrs, is_derive);\n+                let mut derive_spans = vec![];\n+                for derive in derives {\n+                    derive_spans.append(&mut get_derive_spans(derive)?);\n+                }\n+                let derive_str =\n+                    format_derive(&derive_spans, attr_prefix(&attrs[0]), shape, context)?;\n+                result.push_str(&derive_str);\n+\n+                let missing_span = attrs\n+                    .get(derives.len())\n+                    .map(|next| mk_sp(attrs[derives.len() - 1].span.hi(), next.span.lo()));\n+                if let Some(missing_span) = missing_span {\n+                    let comment = ::comment::recover_missing_comment_in_span(\n+                        missing_span,\n+                        shape.with_max_width(context.config),\n+                        context,\n+                        0,\n+                    )?;\n+                    result.push_str(&comment);\n+                    if let Some(next) = attrs.get(derives.len()) {\n+                        if next.is_sugared_doc {\n+                            let snippet = context.snippet(missing_span);\n+                            let (_, mlb) = has_newlines_before_after_comment(snippet);\n+                            result.push_str(&mlb);\n+                        }\n+                    }\n+                    result.push('\\n');\n+                    result.push_str(&shape.indent.to_string(context.config));\n+                }\n+\n+                attrs = &attrs[derives.len()..];\n+\n+                continue;\n+            }\n+\n+            // If we get here, then we have a regular attribute, just handle one\n+            // at a time.\n+\n+            let formatted_attr = attrs[0].rewrite(context, shape)?;\n+            result.push_str(&formatted_attr);\n+\n+            let missing_span = attrs\n+                .get(1)\n+                .map(|next| mk_sp(attrs[0].span.hi(), next.span.lo()));\n+            if let Some(missing_span) = missing_span {\n                 let comment = ::comment::recover_missing_comment_in_span(\n                     missing_span,\n                     shape.with_max_width(context.config),\n                     context,\n                     0,\n                 )?;\n-                let comment = if comment.is_empty() {\n-                    format!(\"\\n{}\", mlb)\n-                } else {\n-                    format!(\"{}{}\\n{}\", mla, comment, mlb)\n-                };\n-                Some(format!(\n-                    \"{}{}{}{}\",\n-                    first_group_str,\n-                    comment,\n-                    shape.indent.to_string(context.config),\n-                    rest_str\n-                ))\n-            } else {\n-                combine_strs_with_missing_comments(\n-                    context,\n-                    &first_group_str,\n-                    &rest_str,\n-                    missing_span,\n-                    shape,\n-                    false,\n-                )\n+                result.push_str(&comment);\n+                if let Some(next) = attrs.get(1) {\n+                    if next.is_sugared_doc {\n+                        let snippet = context.snippet(missing_span);\n+                        let (_, mlb) = has_newlines_before_after_comment(snippet);\n+                        result.push_str(&mlb);\n+                    }\n+                }\n+                result.push('\\n');\n+                result.push_str(&shape.indent.to_string(context.config));\n             }\n+\n+            attrs = &attrs[1..];\n         }\n     }\n }\n+\n+fn attr_prefix(attr: &ast::Attribute) -> &'static str {\n+    match attr.style {\n+        ast::AttrStyle::Inner => \"#!\",\n+        ast::AttrStyle::Outer => \"#\",\n+    }\n+}"}, {"sha": "d0ac21d4bba840b088864fb4026a69abb1ae9755", "filename": "src/lists.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e8c975e17a8c165fb0ab0dd7eba2eeb64783198/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8c975e17a8c165fb0ab0dd7eba2eeb64783198/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=2e8c975e17a8c165fb0ab0dd7eba2eeb64783198", "patch": "@@ -533,7 +533,7 @@ where\n             let pre_snippet = self\n                 .snippet_provider\n                 .span_to_snippet(mk_sp(self.prev_span_end, (self.get_lo)(&item)))\n-                .unwrap();\n+                .unwrap_or(\"\");\n             let trimmed_pre_snippet = pre_snippet.trim();\n             let has_single_line_comment = trimmed_pre_snippet.starts_with(\"//\");\n             let has_block_comment = trimmed_pre_snippet.starts_with(\"/*\");\n@@ -572,7 +572,7 @@ where\n             let post_snippet = self\n                 .snippet_provider\n                 .span_to_snippet(mk_sp((self.get_hi)(&item), next_start))\n-                .unwrap();\n+                .unwrap_or(\"\");\n \n             let comment_end = match self.inner.peek() {\n                 Some(..) => {"}, {"sha": "87bce7fab04947ad9164882dab83d7ee16be01ca", "filename": "src/matches.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2e8c975e17a8c165fb0ab0dd7eba2eeb64783198/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8c975e17a8c165fb0ab0dd7eba2eeb64783198/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=2e8c975e17a8c165fb0ab0dd7eba2eeb64783198", "patch": "@@ -289,7 +289,13 @@ fn rewrite_match_pattern(\n     let pats_str = rewrite_multiple_patterns(context, pats, pat_shape)?;\n \n     // Guard\n-    let guard_str = rewrite_guard(context, guard, shape, trimmed_last_line_width(&pats_str))?;\n+    let guard_str = rewrite_guard(\n+        context,\n+        guard,\n+        shape,\n+        trimmed_last_line_width(&pats_str),\n+        pats_str.contains(\"\\n\"),\n+    )?;\n \n     Some(format!(\"{}{}\", pats_str, guard_str))\n }\n@@ -450,17 +456,20 @@ fn rewrite_guard(\n     // The amount of space used up on this line for the pattern in\n     // the arm (excludes offset).\n     pattern_width: usize,\n+    multiline_pattern: bool,\n ) -> Option<String> {\n     if let Some(ref guard) = *guard {\n         // First try to fit the guard string on the same line as the pattern.\n         // 4 = ` if `, 5 = ` => {`\n         let cond_shape = shape\n             .offset_left(pattern_width + 4)\n             .and_then(|s| s.sub_width(5));\n-        if let Some(cond_shape) = cond_shape {\n-            if let Some(cond_str) = guard.rewrite(context, cond_shape) {\n-                if !cond_str.contains('\\n') || pattern_width <= context.config.tab_spaces() {\n-                    return Some(format!(\" if {}\", cond_str));\n+        if !multiline_pattern {\n+            if let Some(cond_shape) = cond_shape {\n+                if let Some(cond_str) = guard.rewrite(context, cond_shape) {\n+                    if !cond_str.contains('\\n') || pattern_width <= context.config.tab_spaces() {\n+                        return Some(format!(\" if {}\", cond_str));\n+                    }\n                 }\n             }\n         }"}, {"sha": "ab33826c028f9ca28209cf8cff240fd90ee185ba", "filename": "src/shape.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e8c975e17a8c165fb0ab0dd7eba2eeb64783198/src%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8c975e17a8c165fb0ab0dd7eba2eeb64783198/src%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshape.rs?ref=2e8c975e17a8c165fb0ab0dd7eba2eeb64783198", "patch": "@@ -27,6 +27,7 @@ pub struct Indent {\n const INDENT_BUFFER_LEN: usize = 80;\n const INDENT_BUFFER: &str =\n     \"\\n                                                                                \";\n+\n impl Indent {\n     pub fn new(block_indent: usize, alignment: usize) -> Indent {\n         Indent {"}, {"sha": "708147f0e6fe562dcb78a1dee41a073f9dee81c0", "filename": "tests/source/attrib.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2e8c975e17a8c165fb0ab0dd7eba2eeb64783198/tests%2Fsource%2Fattrib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8c975e17a8c165fb0ab0dd7eba2eeb64783198/tests%2Fsource%2Fattrib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fattrib.rs?ref=2e8c975e17a8c165fb0ab0dd7eba2eeb64783198", "patch": "@@ -151,7 +151,13 @@ fn attributes_on_statements() {\n     foo!();\n }\n \n-// Large derive\n+// Large derives\n+#[derive(Add, Sub, Mul, Div, Clone, Copy, Eq, PartialEq, Ord, PartialOrd, Debug, Hash, Serialize, Mul)]\n+\n+\n+/// Foo bar baz\n+\n+\n #[derive(Add, Sub, Mul, Div, Clone, Copy, Eq, PartialEq, Ord, PartialOrd, Debug, Hash, Serialize, Deserialize)]\n pub struct HP(pub u8);\n \n@@ -168,3 +174,22 @@ pub fn foo() {}\n #[clippy::bar(a, b, c)]\n pub fn foo() {}\n \n+mod issue_2620 {\n+    #[derive(Debug, StructOpt)]\n+#[structopt(about = \"Display information about the character on FF Logs\")]\n+pub struct Params {\n+  #[structopt(help = \"The server the character is on\")]\n+  server: String,\n+  #[structopt(help = \"The character's first name\")]\n+  first_name: String,\n+  #[structopt(help = \"The character's last name\")]\n+  last_name: String,\n+  #[structopt(\n+    short = \"j\",\n+    long = \"job\",\n+    help = \"The job to look at\",\n+    parse(try_from_str)\n+  )]\n+  job: Option<Job>\n+}\n+}"}, {"sha": "8ff7afb7a4463b7e49bf5af226c6e52fbb1b919b", "filename": "tests/source/match.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2e8c975e17a8c165fb0ab0dd7eba2eeb64783198/tests%2Fsource%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8c975e17a8c165fb0ab0dd7eba2eeb64783198/tests%2Fsource%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fmatch.rs?ref=2e8c975e17a8c165fb0ab0dd7eba2eeb64783198", "patch": "@@ -491,3 +491,19 @@ fn issue_2621() {\n         | Foo::I => println!(\"With comment\"), // Comment after line\n     }\n }\n+\n+fn issue_2377() {\n+    match tok {\n+        Tok::Not\n+        | Tok::BNot\n+        | Tok::Plus\n+        | Tok::Minus\n+        | Tok::PlusPlus\n+        | Tok::MinusMinus\n+        | Tok::Void\n+        | Tok::Delete if prec <= 16 => {\n+            // code here...\n+        }\n+        Tok::TypeOf if prec <= 16 => {}\n+    }\n+}"}, {"sha": "1e069458ea169e63a07bca33380589c322f4f5df", "filename": "tests/target/attrib.rs", "status": "modified", "additions": 51, "deletions": 4, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/2e8c975e17a8c165fb0ab0dd7eba2eeb64783198/tests%2Ftarget%2Fattrib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8c975e17a8c165fb0ab0dd7eba2eeb64783198/tests%2Ftarget%2Fattrib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fattrib.rs?ref=2e8c975e17a8c165fb0ab0dd7eba2eeb64783198", "patch": "@@ -76,7 +76,14 @@ struct Foo {\n // #1668\n \n /// Default path (*nix)\n-#[cfg(all(unix, not(target_os = \"macos\"), not(target_os = \"ios\"), not(target_os = \"android\")))]\n+#[cfg(\n+    all(\n+        unix,\n+        not(target_os = \"macos\"),\n+        not(target_os = \"ios\"),\n+        not(target_os = \"android\")\n+    )\n+)]\n fn foo() {\n     #[cfg(target_os = \"freertos\")]\n     match port_id {\n@@ -155,9 +162,29 @@ fn attributes_on_statements() {\n     foo!();\n }\n \n-// Large derive\n-#[derive(Add, Sub, Mul, Div, Clone, Copy, Eq, PartialEq, Ord, PartialOrd, Debug, Hash, Serialize,\n-         Deserialize)]\n+// Large derives\n+#[derive(\n+    Add, Sub, Mul, Div, Clone, Copy, Eq, PartialEq, Ord, PartialOrd, Debug, Hash, Serialize, Mul,\n+)]\n+\n+/// Foo bar baz\n+\n+#[derive(\n+    Add,\n+    Sub,\n+    Mul,\n+    Div,\n+    Clone,\n+    Copy,\n+    Eq,\n+    PartialEq,\n+    Ord,\n+    PartialOrd,\n+    Debug,\n+    Hash,\n+    Serialize,\n+    Deserialize,\n+)]\n pub struct HP(pub u8);\n \n // Long `#[doc = \"...\"]`\n@@ -177,3 +204,23 @@ pub fn foo() {}\n #[clippy::bar=foo]\n #[clippy::bar(a, b, c)]\n pub fn foo() {}\n+\n+mod issue_2620 {\n+    #[derive(Debug, StructOpt)]\n+    #[structopt(about = \"Display information about the character on FF Logs\")]\n+    pub struct Params {\n+        #[structopt(help = \"The server the character is on\")]\n+        server: String,\n+        #[structopt(help = \"The character's first name\")]\n+        first_name: String,\n+        #[structopt(help = \"The character's last name\")]\n+        last_name: String,\n+        #[structopt(\n+            short = \"j\",\n+            long = \"job\",\n+            help = \"The job to look at\",\n+            parse(try_from_str)\n+        )]\n+        job: Option<Job>,\n+    }\n+}"}, {"sha": "33eb211a4b5f55d8416448d480146ac41eaff48b", "filename": "tests/target/enum.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2e8c975e17a8c165fb0ab0dd7eba2eeb64783198/tests%2Ftarget%2Fenum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8c975e17a8c165fb0ab0dd7eba2eeb64783198/tests%2Ftarget%2Fenum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fenum.rs?ref=2e8c975e17a8c165fb0ab0dd7eba2eeb64783198", "patch": "@@ -255,7 +255,12 @@ pub enum QlError {\n     #[fail(display = \"Translation error: from {} to {}\", 0, 1)]\n     TranslationError(String, String),\n     // (kind, input, expected)\n-    #[fail(display = \"Could not find {}: Found: {}, expected: {:?}\", 0, 1, 2)]\n+    #[fail(\n+        display = \"Could not find {}: Found: {}, expected: {:?}\",\n+        0,\n+        1,\n+        2\n+    )]\n     ResolveError(&'static str, String, Option<String>),\n }\n "}, {"sha": "cda0ed2abe57fe294762080648d2c8a82ae01c1b", "filename": "tests/target/match.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2e8c975e17a8c165fb0ab0dd7eba2eeb64783198/tests%2Ftarget%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8c975e17a8c165fb0ab0dd7eba2eeb64783198/tests%2Ftarget%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmatch.rs?ref=2e8c975e17a8c165fb0ab0dd7eba2eeb64783198", "patch": "@@ -518,3 +518,21 @@ fn issue_2621() {\n         Foo::I => println!(\"With comment\"), // Comment after line\n     }\n }\n+\n+fn issue_2377() {\n+    match tok {\n+        Tok::Not\n+        | Tok::BNot\n+        | Tok::Plus\n+        | Tok::Minus\n+        | Tok::PlusPlus\n+        | Tok::MinusMinus\n+        | Tok::Void\n+        | Tok::Delete\n+            if prec <= 16 =>\n+        {\n+            // code here...\n+        }\n+        Tok::TypeOf if prec <= 16 => {}\n+    }\n+}"}, {"sha": "0f461b98bc737b035683458efb4534feb195279f", "filename": "tests/target/struct-field-attributes.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2e8c975e17a8c165fb0ab0dd7eba2eeb64783198/tests%2Ftarget%2Fstruct-field-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8c975e17a8c165fb0ab0dd7eba2eeb64783198/tests%2Ftarget%2Fstruct-field-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fstruct-field-attributes.rs?ref=2e8c975e17a8c165fb0ab0dd7eba2eeb64783198", "patch": "@@ -39,13 +39,19 @@ fn new_foo() -> Foo {\n // #2044\n pub enum State {\n     Closure(\n-        #[cfg_attr(feature = \"serde_derive\", serde(state_with = \"::serialization::closure\"))]\n+        #[cfg_attr(\n+            feature = \"serde_derive\",\n+            serde(state_with = \"::serialization::closure\")\n+        )]\n         GcPtr<ClosureData>,\n     ),\n }\n \n struct Fields(\n-    #[cfg_attr(feature = \"serde_derive\", serde(state_with = \"::base::serialization::shared\"))]\n+    #[cfg_attr(\n+        feature = \"serde_derive\",\n+        serde(state_with = \"::base::serialization::shared\")\n+    )]\n     Arc<Vec<InternedStr>>,\n );\n "}]}