{"sha": "a6c477152026f9b652bbca3fd1dbe13c7a47ffdf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2YzQ3NzE1MjAyNmY5YjY1MmJiY2EzZmQxZGJlMTNjN2E0N2ZmZGY=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-11-30T18:31:12Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-11-30T18:31:12Z"}, "message": "Rollup merge of #56214 - scalexm:unification, r=nikomatsakis\n\nImplement chalk unification routines\n\n`ResolventOps` and `AggregateOps` are mostly straightforwardly translated from chalk. I had caught a few bugs already in my `chalk` branch and backported fixes to this branch, but there may be other ones left. EDIT: I hope there are none left now :)\n\nFixes #54935.", "tree": {"sha": "f7d8b25b1458f3510341df1ff85dba2a910fecf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7d8b25b1458f3510341df1ff85dba2a910fecf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6c477152026f9b652bbca3fd1dbe13c7a47ffdf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlwBgfEACgkQ/vbIBR0O\nATwV9xAArFocdvPkxq9K1TsiN7OBTHTC6dCEOx2y40WNl5X1rXZJmjbNKrlufKPE\ni3XErekaprAsfk2cy/EZTFxEtOyz2LAUZar8s348ecWiRb5Fhy+d72lrHspbUIYE\n/J6ZNA9a9CGN0nV7jEhe3XAGsmiR/SV1r2e7GaOSs5gOeDH5pyFBL4CAknyXP0nJ\nmjNOoQ8IG5JRTcZWpHQ0aEhusNdfNcEgL2pZA9y/pz5aK3XKaaBlurWDQ8xURmrP\n+YE8VzunAvHFMak2JN1KhIbHAw3q9e6A8l54qDdPcaQ+UWxnXTONDNpt/qpWd5lW\nFzI8cg2ipbavqMzoyqpn0sbN45MMA5ze1/mcHYtQWmEQtiAQZo/9OrOWfeJHf+SF\nJGRD3Sb2QxjR+n+Htfv/rna3w5DJO0Jth0i/T0FyV8BunByqtKfy8vbYdPJ4xz6r\nNbG2Wx0g+AVa3K6SNJf7YzONJejcnCRIplJ8bYRwq0mHQHYMjn/T5v8NmcBDazkk\nKItdVjJIQ+RSzph3Kpa4LaJBXe1O6IccyQa/Bs4nztN5SzpoA3pTG9IS7m7I7jwe\nIxo/KbTIPnjhTh3CQ5Q0TB9FVawEyw1fHpI0M9Es07RktuGIZYiPB1T6bTWAxN9f\npl+KyXIA58xMEqe5+R2XDxy4g+LYD1Uvx1MqDY+wpPT9f5MNez8=\n=12Oz\n-----END PGP SIGNATURE-----", "payload": "tree f7d8b25b1458f3510341df1ff85dba2a910fecf3\nparent f3be931ab76a9be593e7f6540eee8b7eb54c3baf\nparent 1fce415649784ecaf3bcb3a6916e10284c0affec\nauthor kennytm <kennytm@gmail.com> 1543602672 +0800\ncommitter kennytm <kennytm@gmail.com> 1543602672 +0800\n\nRollup merge of #56214 - scalexm:unification, r=nikomatsakis\n\nImplement chalk unification routines\n\n`ResolventOps` and `AggregateOps` are mostly straightforwardly translated from chalk. I had caught a few bugs already in my `chalk` branch and backported fixes to this branch, but there may be other ones left. EDIT: I hope there are none left now :)\n\nFixes #54935.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6c477152026f9b652bbca3fd1dbe13c7a47ffdf", "html_url": "https://github.com/rust-lang/rust/commit/a6c477152026f9b652bbca3fd1dbe13c7a47ffdf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6c477152026f9b652bbca3fd1dbe13c7a47ffdf/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3be931ab76a9be593e7f6540eee8b7eb54c3baf", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3be931ab76a9be593e7f6540eee8b7eb54c3baf", "html_url": "https://github.com/rust-lang/rust/commit/f3be931ab76a9be593e7f6540eee8b7eb54c3baf"}, {"sha": "1fce415649784ecaf3bcb3a6916e10284c0affec", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fce415649784ecaf3bcb3a6916e10284c0affec", "html_url": "https://github.com/rust-lang/rust/commit/1fce415649784ecaf3bcb3a6916e10284c0affec"}], "stats": {"total": 1136, "additions": 985, "deletions": 151}, "files": [{"sha": "972ba16f7e2c7e156d5ceb344a32ba1a059bd920", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 226, "deletions": 96, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/a6c477152026f9b652bbca3fd1dbe13c7a47ffdf/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6c477152026f9b652bbca3fd1dbe13c7a47ffdf/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=a6c477152026f9b652bbca3fd1dbe13c7a47ffdf", "patch": "@@ -11,30 +11,41 @@\n //! This code is kind of an alternate way of doing subtyping,\n //! supertyping, and type equating, distinct from the `combine.rs`\n //! code but very similar in its effect and design. Eventually the two\n-//! ought to be merged. This code is intended for use in NLL.\n+//! ought to be merged. This code is intended for use in NLL and chalk.\n //!\n //! Here are the key differences:\n //!\n-//! - This code generally assumes that there are no unbound type\n-//!   inferences variables, because at NLL\n-//!   time types are fully inferred up-to regions.\n-//!   - Actually, to support user-given type annotations like\n-//!     `Vec<_>`, we do have some measure of support for type\n-//!     inference variables, but we impose some simplifying\n-//!     assumptions on them that would not be suitable for the infer\n-//!     code more generally. This could be fixed.\n+//! - This code may choose to bypass some checks (e.g. the occurs check)\n+//!   in the case where we know that there are no unbound type inference\n+//!   variables. This is the case for NLL, because at NLL time types are fully\n+//!   inferred up-to regions.\n //! - This code uses \"universes\" to handle higher-ranked regions and\n //!   not the leak-check. This is \"more correct\" than what rustc does\n //!   and we are generally migrating in this direction, but NLL had to\n //!   get there first.\n+//!\n+//! Also, this code assumes that there are no bound types at all, not even\n+//! free ones. This is ok because:\n+//! - we are not relating anything quantified over some type variable\n+//! - we will have instantiated all the bound type vars already (the one\n+//!   thing we relate in chalk are basically domain goals and their\n+//!   constituents)\n \n use crate::infer::InferCtxt;\n use crate::ty::fold::{TypeFoldable, TypeVisitor};\n use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use crate::ty::subst::Kind;\n use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::error::TypeError;\n+use crate::traits::DomainGoal;\n use rustc_data_structures::fx::FxHashMap;\n \n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum NormalizationStrategy {\n+    Lazy,\n+    Eager,\n+}\n+\n pub struct TypeRelating<'me, 'gcx: 'tcx, 'tcx: 'me, D>\n where\n     D: TypeRelatingDelegate<'tcx>,\n@@ -75,6 +86,10 @@ pub trait TypeRelatingDelegate<'tcx> {\n     /// delegate.\n     fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>);\n \n+    /// Push a domain goal that will need to be proved for the two types to\n+    /// be related. Used for lazy normalization.\n+    fn push_domain_goal(&mut self, domain_goal: DomainGoal<'tcx>);\n+\n     /// Creates a new universe index. Used when instantiating placeholders.\n     fn create_next_universe(&mut self) -> ty::UniverseIndex;\n \n@@ -105,6 +120,13 @@ pub trait TypeRelatingDelegate<'tcx> {\n     /// relate `Foo<'?0>` with `Foo<'a>` (and probably add an outlives\n     /// relation stating that `'?0: 'a`).\n     fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx>;\n+\n+    /// Define the normalization strategy to use, eager or lazy.\n+    fn normalization() -> NormalizationStrategy;\n+\n+    /// Enable some optimizations if we do not expect inference variables\n+    /// in the RHS of the relation.\n+    fn forbid_inference_vars() -> bool;\n }\n \n #[derive(Clone, Debug)]\n@@ -242,15 +264,79 @@ where\n         self.delegate.push_outlives(sup, sub);\n     }\n \n-    /// When we encounter a canonical variable `var` in the output,\n-    /// equate it with `kind`. If the variable has been previously\n-    /// equated, then equate it again.\n-    fn relate_var(&mut self, var_ty: Ty<'tcx>, value_ty: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"equate_var(var_ty={:?}, value_ty={:?})\", var_ty, value_ty);\n+    /// Relate a projection type and some value type lazily. This will always\n+    /// succeed, but we push an additional `ProjectionEq` goal depending\n+    /// on the value type:\n+    /// - if the value type is any type `T` which is not a projection, we push\n+    ///   `ProjectionEq(projection = T)`.\n+    /// - if the value type is another projection `other_projection`, we create\n+    ///   a new inference variable `?U` and push the two goals\n+    ///   `ProjectionEq(projection = ?U)`, `ProjectionEq(other_projection = ?U)`.\n+    fn relate_projection_ty(\n+        &mut self,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+        value_ty: ty::Ty<'tcx>\n+    ) -> Ty<'tcx> {\n+        use crate::infer::type_variable::TypeVariableOrigin;\n+        use crate::traits::WhereClause;\n+        use syntax_pos::DUMMY_SP;\n+\n+        match value_ty.sty {\n+            ty::Projection(other_projection_ty) => {\n+                let var = self.infcx.next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n+                self.relate_projection_ty(projection_ty, var);\n+                self.relate_projection_ty(other_projection_ty, var);\n+                var\n+            }\n+\n+            _ => {\n+                let projection = ty::ProjectionPredicate {\n+                    projection_ty,\n+                    ty: value_ty,\n+                };\n+                self.delegate.push_domain_goal(\n+                    DomainGoal::Holds(WhereClause::ProjectionEq(projection))\n+                );\n+                value_ty\n+            }\n+        }\n+    }\n+\n+    /// Relate a type inference variable with a value type.\n+    fn relate_ty_var(\n+        &mut self,\n+        vid: ty::TyVid,\n+        value_ty: Ty<'tcx>\n+    ) -> RelateResult<'tcx, Ty<'tcx>> {\n+        debug!(\"relate_ty_var(vid={:?}, value_ty={:?})\", vid, value_ty);\n+\n+        match value_ty.sty {\n+            ty::Infer(ty::TyVar(value_vid)) => {\n+                // Two type variables: just equate them.\n+                self.infcx.type_variables.borrow_mut().equate(vid, value_vid);\n+                return Ok(value_ty);\n+            }\n+\n+            ty::Projection(projection_ty)\n+                if D::normalization() == NormalizationStrategy::Lazy =>\n+            {\n+                return Ok(self.relate_projection_ty(projection_ty, self.infcx.tcx.mk_var(vid)));\n+            }\n+\n+            _ => (),\n+        }\n+\n+        let generalized_ty = self.generalize_value(value_ty, vid)?;\n+        debug!(\"relate_ty_var: generalized_ty = {:?}\", generalized_ty);\n+\n+        if D::forbid_inference_vars() {\n+            // In NLL, we don't have type inference variables\n+            // floating around, so we can do this rather imprecise\n+            // variant of the occurs-check.\n+            assert!(!generalized_ty.has_infer_types());\n+        }\n \n-        let generalized_ty = self.generalize_value(value_ty);\n-        self.infcx\n-            .force_instantiate_unchecked(var_ty, generalized_ty);\n+        self.infcx.type_variables.borrow_mut().instantiate(vid, generalized_ty);\n \n         // The generalized values we extract from `canonical_var_values` have\n         // been fully instantiated and hence the set of scopes we have\n@@ -264,22 +350,27 @@ where\n         // Restore the old scopes now.\n         self.a_scopes = old_a_scopes;\n \n-        debug!(\"equate_var: complete, result = {:?}\", result);\n+        debug!(\"relate_ty_var: complete, result = {:?}\", result);\n         result\n     }\n \n-    fn generalize_value<T: Relate<'tcx>>(&mut self, value: T) -> T {\n-        TypeGeneralizer {\n-            tcx: self.infcx.tcx,\n+    fn generalize_value<T: Relate<'tcx>>(\n+        &mut self,\n+        value: T,\n+        for_vid: ty::TyVid\n+    ) -> RelateResult<'tcx, T> {\n+        let universe = self.infcx.probe_ty_var(for_vid).unwrap_err();\n+\n+        let mut generalizer = TypeGeneralizer {\n+            infcx: self.infcx,\n             delegate: &mut self.delegate,\n             first_free_index: ty::INNERMOST,\n             ambient_variance: self.ambient_variance,\n+            for_vid_sub_root: self.infcx.type_variables.borrow_mut().sub_root_var(for_vid),\n+            universe,\n+        };\n \n-            // These always correspond to an `_` or `'_` written by\n-            // user, and those are always in the root universe.\n-            universe: ty::UniverseIndex::ROOT,\n-        }.relate(&value, &value)\n-            .unwrap()\n+        generalizer.relate(&value, &value)\n     }\n }\n \n@@ -327,11 +418,35 @@ where\n         Ok(r)\n     }\n \n-    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+    fn tys(&mut self, a: Ty<'tcx>, mut b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         let a = self.infcx.shallow_resolve(a);\n-        match a.sty {\n-            ty::Infer(ty::TyVar(_)) | ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_)) => {\n-                self.relate_var(a.into(), b.into())\n+\n+        if !D::forbid_inference_vars() {\n+            b = self.infcx.shallow_resolve(b);\n+        }\n+\n+        match (&a.sty, &b.sty) {\n+            (_, &ty::Infer(ty::TyVar(vid))) => {\n+                if D::forbid_inference_vars() {\n+                    // Forbid inference variables in the RHS.\n+                    bug!(\"unexpected inference var {:?}\", b)\n+                } else {\n+                    self.relate_ty_var(vid, a)\n+                }\n+            }\n+\n+            (&ty::Infer(ty::TyVar(vid)), _) => self.relate_ty_var(vid, b),\n+\n+            (&ty::Projection(projection_ty), _)\n+                if D::normalization() == NormalizationStrategy::Lazy =>\n+            {\n+                Ok(self.relate_projection_ty(projection_ty, b))\n+            }\n+\n+            (_, &ty::Projection(projection_ty))\n+                if D::normalization() == NormalizationStrategy::Lazy =>\n+            {\n+                Ok(self.relate_projection_ty(projection_ty, a))\n             }\n \n             _ => {\n@@ -340,7 +455,8 @@ where\n                     a, b, self.ambient_variance\n                 );\n \n-                relate::super_relate_tys(self, a, b)\n+                // Will also handle unification of `IntVar` and `FloatVar`.\n+                self.infcx.super_combine_tys(self, a, b)\n             }\n         }\n     }\n@@ -551,7 +667,7 @@ struct TypeGeneralizer<'me, 'gcx: 'tcx, 'tcx: 'me, D>\n where\n     D: TypeRelatingDelegate<'tcx> + 'me,\n {\n-    tcx: TyCtxt<'me, 'gcx, 'tcx>,\n+    infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n \n     delegate: &'me mut D,\n \n@@ -561,6 +677,14 @@ where\n \n     first_free_index: ty::DebruijnIndex,\n \n+    /// The vid of the type variable that is in the process of being\n+    /// instantiated. If we find this within the value we are folding,\n+    /// that means we would have created a cyclic value.\n+    for_vid_sub_root: ty::TyVid,\n+\n+    /// The universe of the type variable that is in the process of being\n+    /// instantiated. If we find anything that this universe cannot name,\n+    /// we reject the relation.\n     universe: ty::UniverseIndex,\n }\n \n@@ -569,7 +693,7 @@ where\n     D: TypeRelatingDelegate<'tcx>,\n {\n     fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n-        self.tcx\n+        self.infcx.tcx\n     }\n \n     fn tag(&self) -> &'static str {\n@@ -609,17 +733,84 @@ where\n     }\n \n     fn tys(&mut self, a: Ty<'tcx>, _: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        use crate::infer::type_variable::TypeVariableValue;\n+\n         debug!(\"TypeGeneralizer::tys(a={:?})\", a,);\n \n         match a.sty {\n-            ty::Infer(ty::TyVar(_)) | ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_)) => {\n+            ty::Infer(ty::TyVar(_)) | ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_))\n+                if D::forbid_inference_vars() =>\n+            {\n                 bug!(\n                     \"unexpected inference variable encountered in NLL generalization: {:?}\",\n                     a\n                 );\n             }\n \n-            _ => relate::super_relate_tys(self, a, a),\n+            ty::Infer(ty::TyVar(vid)) => {\n+                let mut variables = self.infcx.type_variables.borrow_mut();\n+                let vid = variables.root_var(vid);\n+                let sub_vid = variables.sub_root_var(vid);\n+                if sub_vid == self.for_vid_sub_root {\n+                    // If sub-roots are equal, then `for_vid` and\n+                    // `vid` are related via subtyping.\n+                    debug!(\"TypeGeneralizer::tys: occurs check failed\");\n+                    return Err(TypeError::Mismatch);\n+                } else {\n+                    match variables.probe(vid) {\n+                        TypeVariableValue::Known { value: u } => {\n+                            drop(variables);\n+                            self.relate(&u, &u)\n+                        }\n+                        TypeVariableValue::Unknown { universe: _universe } => {\n+                            if self.ambient_variance == ty::Bivariant {\n+                                // FIXME: we may need a WF predicate (related to #54105).\n+                            }\n+\n+                            let origin = *variables.var_origin(vid);\n+\n+                            // Replacing with a new variable in the universe `self.universe`,\n+                            // it will be unified later with the original type variable in\n+                            // the universe `_universe`.\n+                            let new_var_id = variables.new_var(self.universe, false, origin);\n+\n+                            let u = self.tcx().mk_var(new_var_id);\n+                            debug!(\n+                                \"generalize: replacing original vid={:?} with new={:?}\",\n+                                vid,\n+                                u\n+                            );\n+                            return Ok(u);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            ty::Infer(ty::IntVar(_)) |\n+            ty::Infer(ty::FloatVar(_)) => {\n+                // No matter what mode we are in,\n+                // integer/floating-point types must be equal to be\n+                // relatable.\n+                Ok(a)\n+            }\n+\n+            ty::Placeholder(placeholder) => {\n+                if self.universe.cannot_name(placeholder.universe) {\n+                    debug!(\n+                        \"TypeGeneralizer::tys: root universe {:?} cannot name\\\n+                        placeholder in universe {:?}\",\n+                        self.universe,\n+                        placeholder.universe\n+                    );\n+                    Err(TypeError::Mismatch)\n+                } else {\n+                    Ok(a)\n+                }\n+            }\n+\n+            _ => {\n+                relate::super_relate_tys(self, a, a)\n+            }\n         }\n     }\n \n@@ -673,64 +864,3 @@ where\n         Ok(ty::Binder::bind(result))\n     }\n }\n-\n-impl InferCtxt<'_, '_, 'tcx> {\n-    /// A hacky sort of method used by the NLL type-relating code:\n-    ///\n-    /// - `var` must be some unbound type variable.\n-    /// - `value` must be a suitable type to use as its value.\n-    ///\n-    /// `var` will then be equated with `value`. Note that this\n-    /// sidesteps a number of important checks, such as the \"occurs\n-    /// check\" that prevents cyclic types, so it is important not to\n-    /// use this method during regular type-check.\n-    fn force_instantiate_unchecked(&self, var: Ty<'tcx>, value: Ty<'tcx>) {\n-        match (&var.sty, &value.sty) {\n-            (&ty::Infer(ty::TyVar(vid)), _) => {\n-                let mut type_variables = self.type_variables.borrow_mut();\n-\n-                // In NLL, we don't have type inference variables\n-                // floating around, so we can do this rather imprecise\n-                // variant of the occurs-check.\n-                assert!(!value.has_infer_types());\n-\n-                type_variables.instantiate(vid, value);\n-            }\n-\n-            (&ty::Infer(ty::IntVar(vid)), &ty::Int(value)) => {\n-                let mut int_unification_table = self.int_unification_table.borrow_mut();\n-                int_unification_table\n-                    .unify_var_value(vid, Some(ty::IntVarValue::IntType(value)))\n-                    .unwrap_or_else(|_| {\n-                        bug!(\"failed to unify int var `{:?}` with `{:?}`\", vid, value);\n-                    });\n-            }\n-\n-            (&ty::Infer(ty::IntVar(vid)), &ty::Uint(value)) => {\n-                let mut int_unification_table = self.int_unification_table.borrow_mut();\n-                int_unification_table\n-                    .unify_var_value(vid, Some(ty::IntVarValue::UintType(value)))\n-                    .unwrap_or_else(|_| {\n-                        bug!(\"failed to unify int var `{:?}` with `{:?}`\", vid, value);\n-                    });\n-            }\n-\n-            (&ty::Infer(ty::FloatVar(vid)), &ty::Float(value)) => {\n-                let mut float_unification_table = self.float_unification_table.borrow_mut();\n-                float_unification_table\n-                    .unify_var_value(vid, Some(ty::FloatVarValue(value)))\n-                    .unwrap_or_else(|_| {\n-                        bug!(\"failed to unify float var `{:?}` with `{:?}`\", vid, value)\n-                    });\n-            }\n-\n-            _ => {\n-                bug!(\n-                    \"force_instantiate_unchecked invoked with bad combination: var={:?} value={:?}\",\n-                    var,\n-                    value,\n-                );\n-            }\n-        }\n-    }\n-}"}, {"sha": "20f64597b7876fcd7d9c1a6b749f60f7b5fc2b0b", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a6c477152026f9b652bbca3fd1dbe13c7a47ffdf/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6c477152026f9b652bbca3fd1dbe13c7a47ffdf/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=a6c477152026f9b652bbca3fd1dbe13c7a47ffdf", "patch": "@@ -680,24 +680,31 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n // vars. See comment on `shift_vars_through_binders` method in\n // `subst.rs` for more details.\n \n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+enum Direction {\n+    In,\n+    Out,\n+}\n+\n struct Shifter<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-\n     current_index: ty::DebruijnIndex,\n     amount: u32,\n+    direction: Direction,\n }\n \n impl Shifter<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, amount: u32) -> Self {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, amount: u32, direction: Direction) -> Self {\n         Shifter {\n             tcx,\n             current_index: ty::INNERMOST,\n             amount,\n+            direction,\n         }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Shifter<'a, 'gcx, 'tcx> {\n+impl TypeFolder<'gcx, 'tcx> for Shifter<'a, 'gcx, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n@@ -713,7 +720,14 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Shifter<'a, 'gcx, 'tcx> {\n                 if self.amount == 0 || debruijn < self.current_index {\n                     r\n                 } else {\n-                    let shifted = ty::ReLateBound(debruijn.shifted_in(self.amount), br);\n+                    let debruijn = match self.direction {\n+                        Direction::In => debruijn.shifted_in(self.amount),\n+                        Direction::Out => {\n+                            assert!(debruijn.as_u32() >= self.amount);\n+                            debruijn.shifted_out(self.amount)\n+                        }\n+                    };\n+                    let shifted = ty::ReLateBound(debruijn, br);\n                     self.tcx.mk_region(shifted)\n                 }\n             }\n@@ -727,8 +741,15 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Shifter<'a, 'gcx, 'tcx> {\n                 if self.amount == 0 || debruijn < self.current_index {\n                     ty\n                 } else {\n+                    let debruijn = match self.direction {\n+                        Direction::In => debruijn.shifted_in(self.amount),\n+                        Direction::Out => {\n+                            assert!(debruijn.as_u32() >= self.amount);\n+                            debruijn.shifted_out(self.amount)\n+                        }\n+                    };\n                     self.tcx.mk_ty(\n-                        ty::Bound(debruijn.shifted_in(self.amount), bound_ty)\n+                        ty::Bound(debruijn, bound_ty)\n                     )\n                 }\n             }\n@@ -761,7 +782,18 @@ pub fn shift_vars<'a, 'gcx, 'tcx, T>(\n     debug!(\"shift_vars(value={:?}, amount={})\",\n            value, amount);\n \n-    value.fold_with(&mut Shifter::new(tcx, amount))\n+    value.fold_with(&mut Shifter::new(tcx, amount, Direction::In))\n+}\n+\n+pub fn shift_out_vars<'a, 'gcx, 'tcx, T>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    value: &T,\n+    amount: u32\n+) -> T where T: TypeFoldable<'tcx> {\n+    debug!(\"shift_out_vars(value={:?}, amount={})\",\n+           value, amount);\n+\n+    value.fold_with(&mut Shifter::new(tcx, amount, Direction::Out))\n }\n \n /// An \"escaping var\" is a bound var whose binder is not part of `t`. A bound var can be a"}, {"sha": "1b64a686794c0a4de2da60fb605b61fc0a3be18c", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 293, "deletions": 2, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/a6c477152026f9b652bbca3fd1dbe13c7a47ffdf/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6c477152026f9b652bbca3fd1dbe13c7a47ffdf/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=a6c477152026f9b652bbca3fd1dbe13c7a47ffdf", "patch": "@@ -25,6 +25,7 @@ use std::rc::Rc;\n use std::iter;\n use rustc_target::spec::abi;\n use hir as ast;\n+use traits;\n \n pub type RelateResult<'tcx, T> = Result<T, TypeError<'tcx>>;\n \n@@ -371,6 +372,10 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             bug!(\"var types encountered in super_relate_tys\")\n         }\n \n+        (ty::Bound(..), _) | (_, ty::Bound(..)) => {\n+            bug!(\"bound types encountered in super_relate_tys\")\n+        }\n+\n         (&ty::Error, _) | (_, &ty::Error) =>\n         {\n             Ok(tcx.types.err)\n@@ -394,6 +399,10 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(a)\n         }\n \n+        (ty::Placeholder(p1), ty::Placeholder(p2)) if p1 == p2 => {\n+            Ok(a)\n+        }\n+\n         (&ty::Adt(a_def, a_substs), &ty::Adt(b_def, b_substs))\n             if a_def == b_def =>\n         {\n@@ -556,8 +565,13 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.mk_fn_ptr(fty))\n         }\n \n-        (&ty::Projection(ref a_data), &ty::Projection(ref b_data)) =>\n-        {\n+        (ty::UnnormalizedProjection(a_data), ty::UnnormalizedProjection(b_data)) => {\n+            let projection_ty = relation.relate(a_data, b_data)?;\n+            Ok(tcx.mk_ty(ty::UnnormalizedProjection(projection_ty)))\n+        }\n+\n+        // these two are already handled downstream in case of lazy normalization\n+        (ty::Projection(a_data), ty::Projection(b_data)) => {\n             let projection_ty = relation.relate(a_data, b_data)?;\n             Ok(tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs))\n         }\n@@ -710,6 +724,283 @@ impl<'tcx> Relate<'tcx> for Kind<'tcx> {\n     }\n }\n \n+impl<'tcx> Relate<'tcx> for ty::TraitPredicate<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &ty::TraitPredicate<'tcx>,\n+        b: &ty::TraitPredicate<'tcx>\n+    ) -> RelateResult<'tcx, ty::TraitPredicate<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        Ok(ty::TraitPredicate {\n+            trait_ref: relation.relate(&a.trait_ref, &b.trait_ref)?,\n+        })\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for ty::ProjectionPredicate<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &ty::ProjectionPredicate<'tcx>,\n+        b: &ty::ProjectionPredicate<'tcx>,\n+    ) -> RelateResult<'tcx, ty::ProjectionPredicate<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        Ok(ty::ProjectionPredicate {\n+            projection_ty: relation.relate(&a.projection_ty, &b.projection_ty)?,\n+            ty: relation.relate(&a.ty, &b.ty)?,\n+        })\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::WhereClause<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::WhereClause<'tcx>,\n+        b: &traits::WhereClause<'tcx>\n+    ) -> RelateResult<'tcx, traits::WhereClause<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        use traits::WhereClause::*;\n+        match (a, b) {\n+            (Implemented(a_pred), Implemented(b_pred)) => {\n+                Ok(Implemented(relation.relate(a_pred, b_pred)?))\n+            }\n+\n+            (ProjectionEq(a_pred), ProjectionEq(b_pred)) => {\n+                Ok(ProjectionEq(relation.relate(a_pred, b_pred)?))\n+            }\n+\n+            (RegionOutlives(a_pred), RegionOutlives(b_pred)) => {\n+                Ok(RegionOutlives(ty::OutlivesPredicate(\n+                    relation.relate(&a_pred.0, &b_pred.0)?,\n+                    relation.relate(&a_pred.1, &b_pred.1)?,\n+                )))\n+            }\n+\n+            (TypeOutlives(a_pred), TypeOutlives(b_pred)) => {\n+                Ok(TypeOutlives(ty::OutlivesPredicate(\n+                    relation.relate(&a_pred.0, &b_pred.0)?,\n+                    relation.relate(&a_pred.1, &b_pred.1)?,\n+                )))\n+            }\n+\n+            _ =>  Err(TypeError::Mismatch),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::WellFormed<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::WellFormed<'tcx>,\n+        b: &traits::WellFormed<'tcx>\n+    ) -> RelateResult<'tcx, traits::WellFormed<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        use traits::WellFormed::*;\n+        match (a, b) {\n+            (Trait(a_pred), Trait(b_pred)) => Ok(Trait(relation.relate(a_pred, b_pred)?)),\n+            (Ty(a_ty), Ty(b_ty)) => Ok(Ty(relation.relate(a_ty, b_ty)?)),\n+            _ =>  Err(TypeError::Mismatch),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::FromEnv<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::FromEnv<'tcx>,\n+        b: &traits::FromEnv<'tcx>\n+    ) -> RelateResult<'tcx, traits::FromEnv<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        use traits::FromEnv::*;\n+        match (a, b) {\n+            (Trait(a_pred), Trait(b_pred)) => Ok(Trait(relation.relate(a_pred, b_pred)?)),\n+            (Ty(a_ty), Ty(b_ty)) => Ok(Ty(relation.relate(a_ty, b_ty)?)),\n+            _ =>  Err(TypeError::Mismatch),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::DomainGoal<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::DomainGoal<'tcx>,\n+        b: &traits::DomainGoal<'tcx>\n+    ) -> RelateResult<'tcx, traits::DomainGoal<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        use traits::DomainGoal::*;\n+        match (a, b) {\n+            (Holds(a_wc), Holds(b_wc)) => Ok(Holds(relation.relate(a_wc, b_wc)?)),\n+            (WellFormed(a_wf), WellFormed(b_wf)) => Ok(WellFormed(relation.relate(a_wf, b_wf)?)),\n+            (FromEnv(a_fe), FromEnv(b_fe)) => Ok(FromEnv(relation.relate(a_fe, b_fe)?)),\n+\n+            (Normalize(a_pred), Normalize(b_pred)) => {\n+                Ok(Normalize(relation.relate(a_pred, b_pred)?))\n+            }\n+\n+            _ =>  Err(TypeError::Mismatch),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::Goal<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::Goal<'tcx>,\n+        b: &traits::Goal<'tcx>\n+    ) -> RelateResult<'tcx, traits::Goal<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        use traits::GoalKind::*;\n+        match (a, b) {\n+            (Implies(a_clauses, a_goal), Implies(b_clauses, b_goal)) => {\n+                let clauses = relation.relate(a_clauses, b_clauses)?;\n+                let goal = relation.relate(a_goal, b_goal)?;\n+                Ok(relation.tcx().mk_goal(Implies(clauses, goal)))\n+            }\n+\n+            (And(a_left, a_right), And(b_left, b_right)) => {\n+                let left = relation.relate(a_left, b_left)?;\n+                let right = relation.relate(a_right, b_right)?;\n+                Ok(relation.tcx().mk_goal(And(left, right)))\n+            }\n+\n+            (Not(a_goal), Not(b_goal)) => {\n+                let goal = relation.relate(a_goal, b_goal)?;\n+                Ok(relation.tcx().mk_goal(Not(goal)))\n+            }\n+\n+            (DomainGoal(a_goal), DomainGoal(b_goal)) => {\n+                let goal = relation.relate(a_goal, b_goal)?;\n+                Ok(relation.tcx().mk_goal(DomainGoal(goal)))\n+            }\n+\n+            (Quantified(a_qkind, a_goal), Quantified(b_qkind, b_goal))\n+                if a_qkind == b_qkind =>\n+            {\n+                let goal = relation.relate(a_goal, b_goal)?;\n+                Ok(relation.tcx().mk_goal(Quantified(*a_qkind, goal)))\n+            }\n+\n+            (CannotProve, CannotProve) => Ok(*a),\n+\n+            _ => Err(TypeError::Mismatch),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::Goals<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::Goals<'tcx>,\n+        b: &traits::Goals<'tcx>\n+    ) -> RelateResult<'tcx, traits::Goals<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        if a.len() != b.len() {\n+            return Err(TypeError::Mismatch);\n+        }\n+\n+        let tcx = relation.tcx();\n+        let goals = a.iter().zip(b.iter()).map(|(a, b)| relation.relate(a, b));\n+        Ok(tcx.mk_goals(goals)?)\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::Clause<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::Clause<'tcx>,\n+        b: &traits::Clause<'tcx>\n+    ) -> RelateResult<'tcx, traits::Clause<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        use traits::Clause::*;\n+        match (a, b) {\n+            (Implies(a_clause), Implies(b_clause)) => {\n+                let clause = relation.relate(a_clause, b_clause)?;\n+                Ok(Implies(clause))\n+            }\n+\n+            (ForAll(a_clause), ForAll(b_clause)) => {\n+                let clause = relation.relate(a_clause, b_clause)?;\n+                Ok(ForAll(clause))\n+            }\n+\n+            _ => Err(TypeError::Mismatch),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::Clauses<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::Clauses<'tcx>,\n+        b: &traits::Clauses<'tcx>\n+    ) -> RelateResult<'tcx, traits::Clauses<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        if a.len() != b.len() {\n+            return Err(TypeError::Mismatch);\n+        }\n+\n+        let tcx = relation.tcx();\n+        let clauses = a.iter().zip(b.iter()).map(|(a, b)| relation.relate(a, b));\n+        Ok(tcx.mk_clauses(clauses)?)\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::ProgramClause<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::ProgramClause<'tcx>,\n+        b: &traits::ProgramClause<'tcx>\n+    ) -> RelateResult<'tcx, traits::ProgramClause<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        Ok(traits::ProgramClause {\n+            goal: relation.relate(&a.goal, &b.goal)?,\n+            hypotheses: relation.relate(&a.hypotheses, &b.hypotheses)?,\n+            category: traits::ProgramClauseCategory::Other,\n+        })\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::Environment<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::Environment<'tcx>,\n+        b: &traits::Environment<'tcx>\n+    ) -> RelateResult<'tcx, traits::Environment<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        Ok(traits::Environment {\n+            clauses: relation.relate(&a.clauses, &b.clauses)?,\n+        })\n+    }\n+}\n+\n+impl<'tcx, G> Relate<'tcx> for traits::InEnvironment<'tcx, G>\n+    where G: Relate<'tcx>\n+{\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::InEnvironment<'tcx, G>,\n+        b: &traits::InEnvironment<'tcx, G>\n+    ) -> RelateResult<'tcx, traits::InEnvironment<'tcx, G>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        Ok(traits::InEnvironment {\n+            environment: relation.relate(&a.environment, &b.environment)?,\n+            goal: relation.relate(&a.goal, &b.goal)?,\n+        })\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Error handling\n "}, {"sha": "225e2841fb0ac15dd4e7c837f589d9541c431e6e", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a6c477152026f9b652bbca3fd1dbe13c7a47ffdf/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6c477152026f9b652bbca3fd1dbe13c7a47ffdf/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=a6c477152026f9b652bbca3fd1dbe13c7a47ffdf", "patch": "@@ -10,10 +10,11 @@\n \n use borrow_check::nll::constraints::OutlivesConstraint;\n use borrow_check::nll::type_check::{BorrowCheckContext, Locations};\n-use rustc::infer::nll_relate::{TypeRelating, TypeRelatingDelegate};\n+use rustc::infer::nll_relate::{TypeRelating, TypeRelatingDelegate, NormalizationStrategy};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n use rustc::mir::ConstraintCategory;\n use rustc::traits::query::Fallible;\n+use rustc::traits::DomainGoal;\n use rustc::ty::relate::TypeRelation;\n use rustc::ty::{self, Ty};\n \n@@ -38,7 +39,7 @@ pub(super) fn relate_types<'tcx>(\n     TypeRelating::new(\n         infcx,\n         NllTypeRelatingDelegate::new(infcx, borrowck_context, locations, category),\n-        v,\n+        v\n     ).relate(&a, &b)?;\n     Ok(())\n }\n@@ -115,4 +116,16 @@ impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, '_, 'tcx> {\n                 });\n         }\n     }\n+\n+    fn push_domain_goal(&mut self, _: DomainGoal<'tcx>) {\n+        bug!(\"should never be invoked with eager normalization\")\n+    }\n+\n+    fn normalization() -> NormalizationStrategy {\n+        NormalizationStrategy::Eager\n+    }\n+\n+    fn forbid_inference_vars() -> bool {\n+        true\n+    }\n }"}, {"sha": "58a8d2abd9962960384e1f818f4a4958b017673a", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 74, "deletions": 45, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/a6c477152026f9b652bbca3fd1dbe13c7a47ffdf/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6c477152026f9b652bbca3fd1dbe13c7a47ffdf/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=a6c477152026f9b652bbca3fd1dbe13c7a47ffdf", "patch": "@@ -9,13 +9,25 @@\n // except according to those terms.\n \n mod program_clauses;\n-\n-use chalk_engine::fallible::Fallible as ChalkEngineFallible;\n-use chalk_engine::{context, hh::HhGoal, DelayedLiteral, Literal, ExClause};\n+mod resolvent_ops;\n+mod unify;\n+\n+use chalk_engine::fallible::{Fallible, NoSolution};\n+use chalk_engine::{\n+    context,\n+    hh::HhGoal,\n+    DelayedLiteral,\n+    Literal,\n+    ExClause\n+};\n+use rustc::infer::{InferCtxt, LateBoundRegionConversionTime};\n use rustc::infer::canonical::{\n-    Canonical, CanonicalVarValues, OriginalQueryValues, QueryRegionConstraint, QueryResponse,\n+    Canonical,\n+    CanonicalVarValues,\n+    OriginalQueryValues,\n+    QueryResponse,\n+    Certainty,\n };\n-use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use rustc::traits::{\n     DomainGoal,\n     ExClauseFold,\n@@ -27,14 +39,15 @@ use rustc::traits::{\n     Environment,\n     InEnvironment,\n };\n+use rustc::ty::{self, TyCtxt};\n use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use rustc::ty::subst::{Kind, UnpackedKind};\n-use rustc::ty::{self, TyCtxt};\n+use syntax_pos::DUMMY_SP;\n \n use std::fmt::{self, Debug};\n use std::marker::PhantomData;\n \n-use syntax_pos::DUMMY_SP;\n+use self::unify::*;\n \n #[derive(Copy, Clone, Debug)]\n crate struct ChalkArenas<'gcx> {\n@@ -55,10 +68,12 @@ crate struct ChalkInferenceContext<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n #[derive(Copy, Clone, Debug)]\n crate struct UniverseMap;\n \n+crate type RegionConstraint<'tcx> = ty::OutlivesPredicate<Kind<'tcx>, ty::Region<'tcx>>;\n+\n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n crate struct ConstrainedSubst<'tcx> {\n     subst: CanonicalVarValues<'tcx>,\n-    constraints: Vec<QueryRegionConstraint<'tcx>>,\n+    constraints: Vec<RegionConstraint<'tcx>>,\n }\n \n BraceStructTypeFoldableImpl! {\n@@ -86,7 +101,7 @@ impl context::Context for ChalkArenas<'tcx> {\n \n     type GoalInEnvironment = InEnvironment<'tcx, Goal<'tcx>>;\n \n-    type RegionConstraint = QueryRegionConstraint<'tcx>;\n+    type RegionConstraint = RegionConstraint<'tcx>;\n \n     type Substitution = CanonicalVarValues<'tcx>;\n \n@@ -104,7 +119,7 @@ impl context::Context for ChalkArenas<'tcx> {\n \n     type ProgramClauses = Vec<Clause<'tcx>>;\n \n-    type UnificationResult = InferOk<'tcx, ()>;\n+    type UnificationResult = UnificationResult<'tcx>;\n \n     fn goal_in_environment(\n         env: &Environment<'tcx>,\n@@ -118,9 +133,34 @@ impl context::AggregateOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n     fn make_solution(\n         &self,\n         _root_goal: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n-        _simplified_answers: impl context::AnswerStream<ChalkArenas<'gcx>>,\n+        mut simplified_answers: impl context::AnswerStream<ChalkArenas<'gcx>>,\n     ) -> Option<Canonical<'gcx, QueryResponse<'gcx, ()>>> {\n-        unimplemented!()\n+        use chalk_engine::SimplifiedAnswer;\n+\n+        if simplified_answers.peek_answer().is_none() {\n+            return None;\n+        }\n+\n+        let SimplifiedAnswer { subst, ambiguous } = simplified_answers\n+            .next_answer()\n+            .unwrap();\n+\n+        let ambiguous = simplified_answers.peek_answer().is_some() || ambiguous;\n+\n+        Some(subst.unchecked_map(|subst| {\n+            QueryResponse {\n+                var_values: subst.subst,\n+                region_constraints: subst.constraints\n+                    .into_iter()\n+                    .map(|c| ty::Binder::bind(c))\n+                    .collect(),\n+                certainty: match ambiguous {\n+                    true => Certainty::Ambiguous,\n+                    false => Certainty::Proven,\n+                },\n+                value: (),\n+            }\n+        }))\n     }\n }\n \n@@ -197,7 +237,7 @@ impl context::ContextOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n \n     fn is_trivial_substitution(\n         u_canon: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n-        canonical_subst: &Canonical<'tcx, ConstrainedSubst<'tcx>>,\n+        canonical_subst: &Canonical<'gcx, ConstrainedSubst<'gcx>>,\n     ) -> bool {\n         let subst = &canonical_subst.value.subst;\n         assert_eq!(u_canon.variables.len(), subst.var_values.len());\n@@ -282,30 +322,6 @@ impl context::InferenceTable<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n     }\n }\n \n-impl context::ResolventOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n-    for ChalkInferenceContext<'cx, 'gcx, 'tcx>\n-{\n-    fn resolvent_clause(\n-        &mut self,\n-        _environment: &Environment<'tcx>,\n-        _goal: &DomainGoal<'tcx>,\n-        _subst: &CanonicalVarValues<'tcx>,\n-        _clause: &Clause<'tcx>,\n-    ) -> chalk_engine::fallible::Fallible<Canonical<'gcx, ChalkExClause<'gcx>>> {\n-        panic!()\n-    }\n-\n-    fn apply_answer_subst(\n-        &mut self,\n-        _ex_clause: ChalkExClause<'tcx>,\n-        _selected_goal: &InEnvironment<'tcx, Goal<'tcx>>,\n-        _answer_table_goal: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n-        _canonical_answer_subst: &Canonical<'gcx, ConstrainedSubst<'gcx>>,\n-    ) -> chalk_engine::fallible::Fallible<ChalkExClause<'tcx>> {\n-        panic!()\n-    }\n-}\n-\n impl context::TruncateOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n     for ChalkInferenceContext<'cx, 'gcx, 'tcx>\n {\n@@ -376,7 +392,7 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n     fn canonicalize_constrained_subst(\n         &mut self,\n         subst: CanonicalVarValues<'tcx>,\n-        constraints: Vec<QueryRegionConstraint<'tcx>>,\n+        constraints: Vec<RegionConstraint<'tcx>>,\n     ) -> Canonical<'gcx, ConstrainedSubst<'gcx>> {\n         self.infcx.canonicalize_response(&ConstrainedSubst { subst, constraints })\n     }\n@@ -400,11 +416,13 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n \n     fn unify_parameters(\n         &mut self,\n-        _environment: &Environment<'tcx>,\n-        _a: &Kind<'tcx>,\n-        _b: &Kind<'tcx>,\n-    ) -> ChalkEngineFallible<InferOk<'tcx, ()>> {\n-        panic!()\n+        environment: &Environment<'tcx>,\n+        a: &Kind<'tcx>,\n+        b: &Kind<'tcx>,\n+    ) -> Fallible<UnificationResult<'tcx>> {\n+        self.infcx.commit_if_ok(|_| {\n+            unify(self.infcx, *environment, a, b).map_err(|_| NoSolution)\n+        })\n     }\n \n     fn sink_answer_subset(\n@@ -421,11 +439,22 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n         panic!(\"lift\")\n     }\n \n-    fn into_ex_clause(&mut self, _result: InferOk<'tcx, ()>, _ex_clause: &mut ChalkExClause<'tcx>) {\n-        panic!(\"TBD\")\n+    fn into_ex_clause(\n+        &mut self,\n+        result: UnificationResult<'tcx>,\n+        ex_clause: &mut ChalkExClause<'tcx>\n+    ) {\n+        into_ex_clause(result, ex_clause);\n     }\n }\n \n+crate fn into_ex_clause(result: UnificationResult<'tcx>, ex_clause: &mut ChalkExClause<'tcx>) {\n+    ex_clause.subgoals.extend(\n+        result.goals.into_iter().map(Literal::Positive)\n+    );\n+    ex_clause.constraints.extend(result.constraints);\n+}\n+\n type ChalkHhGoal<'tcx> = HhGoal<ChalkArenas<'tcx>>;\n \n type ChalkExClause<'tcx> = ExClause<ChalkArenas<'tcx>>;"}, {"sha": "df6458a766d4e89f128697551a741469333627a0", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "added", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/a6c477152026f9b652bbca3fd1dbe13c7a47ffdf/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6c477152026f9b652bbca3fd1dbe13c7a47ffdf/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=a6c477152026f9b652bbca3fd1dbe13c7a47ffdf", "patch": "@@ -0,0 +1,241 @@\n+use chalk_engine::fallible::{Fallible, NoSolution};\n+use chalk_engine::{\n+    context,\n+    Literal,\n+    ExClause\n+};\n+use rustc::infer::{InferCtxt, LateBoundRegionConversionTime};\n+use rustc::infer::canonical::{Canonical, CanonicalVarValues};\n+use rustc::traits::{\n+    DomainGoal,\n+    Goal,\n+    GoalKind,\n+    Clause,\n+    ProgramClause,\n+    Environment,\n+    InEnvironment,\n+};\n+use rustc::ty::{self, Ty};\n+use rustc::ty::subst::Kind;\n+use rustc::ty::relate::{Relate, RelateResult, TypeRelation};\n+use syntax_pos::DUMMY_SP;\n+\n+use super::{ChalkInferenceContext, ChalkArenas, ChalkExClause, ConstrainedSubst};\n+use super::unify::*;\n+\n+impl context::ResolventOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n+    for ChalkInferenceContext<'cx, 'gcx, 'tcx>\n+{\n+    fn resolvent_clause(\n+        &mut self,\n+        environment: &Environment<'tcx>,\n+        goal: &DomainGoal<'tcx>,\n+        subst: &CanonicalVarValues<'tcx>,\n+        clause: &Clause<'tcx>,\n+    ) -> Fallible<Canonical<'gcx, ChalkExClause<'gcx>>> {\n+        use chalk_engine::context::UnificationOps;\n+\n+        self.infcx.probe(|_| {\n+            let ProgramClause {\n+                goal: consequence,\n+                hypotheses,\n+                ..\n+            } = match clause {\n+                Clause::Implies(program_clause) => *program_clause,\n+                Clause::ForAll(program_clause) => self.infcx.replace_bound_vars_with_fresh_vars(\n+                    DUMMY_SP,\n+                    LateBoundRegionConversionTime::HigherRankedType,\n+                    program_clause\n+                ).0,\n+            };\n+\n+            let result = unify(self.infcx, *environment, goal, &consequence)\n+                .map_err(|_| NoSolution)?;\n+\n+            let mut ex_clause = ExClause {\n+                subst: subst.clone(),\n+                delayed_literals: vec![],\n+                constraints: vec![],\n+                subgoals: vec![],\n+            };\n+\n+            self.into_ex_clause(result, &mut ex_clause);\n+\n+            ex_clause.subgoals.extend(\n+                hypotheses.iter().map(|g| match g {\n+                    GoalKind::Not(g) => Literal::Negative(environment.with(*g)),\n+                    g => Literal::Positive(environment.with(*g)),\n+                })\n+            );\n+\n+            let canonical_ex_clause = self.canonicalize_ex_clause(&ex_clause);\n+            Ok(canonical_ex_clause)\n+        })\n+    }\n+\n+    fn apply_answer_subst(\n+        &mut self,\n+        ex_clause: ChalkExClause<'tcx>,\n+        selected_goal: &InEnvironment<'tcx, Goal<'tcx>>,\n+        answer_table_goal: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n+        canonical_answer_subst: &Canonical<'gcx, ConstrainedSubst<'gcx>>,\n+    ) -> Fallible<ChalkExClause<'tcx>> {\n+        let (answer_subst, _) = self.infcx.instantiate_canonical_with_fresh_inference_vars(\n+            DUMMY_SP,\n+            canonical_answer_subst\n+        );\n+\n+        let mut substitutor = AnswerSubstitutor {\n+            infcx: self.infcx,\n+            environment: selected_goal.environment,\n+            answer_subst: answer_subst.subst,\n+            binder_index: ty::INNERMOST,\n+            ex_clause,\n+        };\n+\n+        substitutor.relate(&answer_table_goal.value, &selected_goal)\n+            .map_err(|_| NoSolution)?;\n+\n+        let mut ex_clause = substitutor.ex_clause;\n+        ex_clause.constraints.extend(answer_subst.constraints);\n+        Ok(ex_clause)\n+    }\n+}\n+\n+struct AnswerSubstitutor<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+    environment: Environment<'tcx>,\n+    answer_subst: CanonicalVarValues<'tcx>,\n+    binder_index: ty::DebruijnIndex,\n+    ex_clause: ChalkExClause<'tcx>,\n+}\n+\n+impl AnswerSubstitutor<'cx, 'gcx, 'tcx> {\n+    fn unify_free_answer_var(\n+        &mut self,\n+        answer_var: ty::BoundVar,\n+        pending: Kind<'tcx>\n+    ) -> RelateResult<'tcx, ()> {\n+        let answer_param = &self.answer_subst.var_values[answer_var];\n+        let pending = &ty::fold::shift_out_vars(\n+            self.infcx.tcx,\n+            &pending,\n+            self.binder_index.as_u32()\n+        );\n+\n+        super::into_ex_clause(\n+            unify(self.infcx, self.environment, answer_param, pending)?,\n+            &mut self.ex_clause\n+        );\n+\n+        Ok(())\n+    }\n+}\n+\n+impl TypeRelation<'cx, 'gcx, 'tcx> for AnswerSubstitutor<'cx, 'gcx, 'tcx> {\n+    fn tcx(&self) -> ty::TyCtxt<'cx, 'gcx, 'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn tag(&self) -> &'static str {\n+        \"chalk_context::answer_substitutor\"\n+    }\n+\n+    fn a_is_expected(&self) -> bool {\n+        true\n+    }\n+\n+    fn relate_with_variance<T: Relate<'tcx>>(\n+        &mut self,\n+        _variance: ty::Variance,\n+        a: &T,\n+        b: &T,\n+    ) -> RelateResult<'tcx, T> {\n+        // We don't care about variance.\n+        self.relate(a, b)\n+    }\n+\n+    fn binders<T: Relate<'tcx>>(\n+        &mut self,\n+        a: &ty::Binder<T>,\n+        b: &ty::Binder<T>,\n+    ) -> RelateResult<'tcx, ty::Binder<T>> {\n+        self.binder_index.shift_in(1);\n+        let result = self.relate(a.skip_binder(), b.skip_binder())?;\n+        self.binder_index.shift_out(1);\n+        Ok(ty::Binder::bind(result))\n+    }\n+\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        let b = self.infcx.shallow_resolve(b);\n+\n+        if let &ty::Bound(debruijn, bound_ty) = &a.sty {\n+            // Free bound var\n+            if debruijn == self.binder_index {\n+                self.unify_free_answer_var(bound_ty.var, b.into())?;\n+                return Ok(b);\n+            }\n+        }\n+\n+        match (&a.sty, &b.sty) {\n+            (&ty::Bound(a_debruijn, a_bound), &ty::Bound(b_debruijn, b_bound)) => {\n+                assert_eq!(a_debruijn, b_debruijn);\n+                assert_eq!(a_bound.var, b_bound.var);\n+                Ok(a)\n+            }\n+\n+            // Those should have been canonicalized away.\n+            (ty::Placeholder(..), _) => {\n+                bug!(\"unexpected placeholder ty in `AnswerSubstitutor`: {:?} \", a);\n+            }\n+\n+            // Everything else should just be a perfect match as well,\n+            // and we forbid inference variables.\n+            _ => match ty::relate::super_relate_tys(self, a, b) {\n+                Ok(ty) => Ok(ty),\n+                Err(err) => bug!(\"type mismatch in `AnswerSubstitutor`: {}\", err),\n+            }\n+        }\n+    }\n+\n+    fn regions(\n+        &mut self,\n+        a: ty::Region<'tcx>,\n+        b: ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        let b = match b {\n+            &ty::ReVar(vid) => self.infcx\n+                .borrow_region_constraints()\n+                .opportunistic_resolve_var(self.infcx.tcx, vid),\n+\n+            other => other,\n+        };\n+\n+        if let &ty::ReLateBound(debruijn, bound) = a {\n+            // Free bound region\n+            if debruijn == self.binder_index {\n+                self.unify_free_answer_var(bound.assert_bound_var(), b.into())?;\n+                return Ok(b);\n+            }\n+        }\n+\n+        match (a, b) {\n+            (&ty::ReLateBound(a_debruijn, a_bound), &ty::ReLateBound(b_debruijn, b_bound)) => {\n+                assert_eq!(a_debruijn, b_debruijn);\n+                assert_eq!(a_bound.assert_bound_var(), b_bound.assert_bound_var());\n+            }\n+\n+            (ty::ReStatic, ty::ReStatic) |\n+            (ty::ReErased, ty::ReErased) |\n+            (ty::ReEmpty, ty::ReEmpty) => (),\n+\n+            (&ty::ReFree(a_free), &ty::ReFree(b_free)) => {\n+                assert_eq!(a_free, b_free);\n+            }\n+\n+            _ => bug!(\"unexpected regions in `AnswerSubstitutor`: {:?}, {:?}\", a, b),\n+        }\n+\n+        Ok(a)\n+    }\n+}"}, {"sha": "3a9c3918d137e81d5b85c1565a4f0bd510f4fe86", "filename": "src/librustc_traits/chalk_context/unify.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/a6c477152026f9b652bbca3fd1dbe13c7a47ffdf/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6c477152026f9b652bbca3fd1dbe13c7a47ffdf/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs?ref=a6c477152026f9b652bbca3fd1dbe13c7a47ffdf", "patch": "@@ -0,0 +1,98 @@\n+use rustc::infer::nll_relate::{TypeRelating, TypeRelatingDelegate, NormalizationStrategy};\n+use rustc::infer::{InferCtxt, RegionVariableOrigin};\n+use rustc::traits::{DomainGoal, Goal, Environment, InEnvironment};\n+use rustc::ty::relate::{Relate, TypeRelation, RelateResult};\n+use rustc::ty;\n+use syntax_pos::DUMMY_SP;\n+\n+crate struct UnificationResult<'tcx> {\n+    crate goals: Vec<InEnvironment<'tcx, Goal<'tcx>>>,\n+    crate constraints: Vec<super::RegionConstraint<'tcx>>,\n+}\n+\n+crate fn unify<'me, 'gcx, 'tcx, T: Relate<'tcx>>(\n+    infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+    environment: Environment<'tcx>,\n+    a: &T,\n+    b: &T\n+) -> RelateResult<'tcx, UnificationResult<'tcx>> {\n+    let mut delegate = ChalkTypeRelatingDelegate::new(\n+        infcx,\n+        environment\n+    );\n+\n+    TypeRelating::new(\n+        infcx,\n+        &mut delegate,\n+        ty::Variance::Invariant\n+    ).relate(a, b)?;\n+\n+    Ok(UnificationResult {\n+        goals: delegate.goals,\n+        constraints: delegate.constraints,\n+    })\n+}\n+\n+struct ChalkTypeRelatingDelegate<'me, 'gcx: 'tcx, 'tcx: 'me> {\n+    infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+    environment: Environment<'tcx>,\n+    goals: Vec<InEnvironment<'tcx, Goal<'tcx>>>,\n+    constraints: Vec<super::RegionConstraint<'tcx>>,\n+}\n+\n+impl ChalkTypeRelatingDelegate<'me, 'gcx, 'tcx> {\n+    fn new(\n+        infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+        environment: Environment<'tcx>,\n+    ) -> Self {\n+        Self {\n+            infcx,\n+            environment,\n+            goals: Vec::new(),\n+            constraints: Vec::new(),\n+        }\n+    }\n+}\n+\n+impl TypeRelatingDelegate<'tcx> for &mut ChalkTypeRelatingDelegate<'_, '_, 'tcx> {\n+    fn create_next_universe(&mut self) -> ty::UniverseIndex {\n+        self.infcx.create_next_universe()\n+    }\n+\n+    fn next_existential_region_var(&mut self) -> ty::Region<'tcx> {\n+        self.infcx.next_region_var(RegionVariableOrigin::MiscVariable(DUMMY_SP))\n+    }\n+\n+    fn next_placeholder_region(\n+        &mut self,\n+        placeholder: ty::PlaceholderRegion\n+    ) -> ty::Region<'tcx> {\n+        self.infcx.tcx.mk_region(ty::RePlaceholder(placeholder))\n+    }\n+\n+    fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx> {\n+        self.infcx.next_region_var_in_universe(\n+            RegionVariableOrigin::MiscVariable(DUMMY_SP),\n+            universe\n+        )\n+    }\n+\n+    fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>) {\n+        self.constraints.push(ty::OutlivesPredicate(sup.into(), sub));\n+    }\n+\n+    fn push_domain_goal(&mut self, domain_goal: DomainGoal<'tcx>) {\n+        let goal = self.environment.with(\n+            self.infcx.tcx.mk_goal(domain_goal.into_goal())\n+        );\n+        self.goals.push(goal);\n+    }\n+\n+    fn normalization() -> NormalizationStrategy {\n+        NormalizationStrategy::Lazy\n+    }\n+\n+    fn forbid_inference_vars() -> bool {\n+        false\n+    }\n+}"}]}