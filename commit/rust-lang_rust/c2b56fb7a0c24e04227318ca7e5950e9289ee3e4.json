{"sha": "c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyYjU2ZmI3YTBjMjRlMDQyMjczMThjYTdlNTk1MGU5Mjg5ZWUzZTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-30T01:44:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-06-30T01:44:27Z"}, "message": "Auto merge of #34552 - Manishearth:rollup, r=Manishearth\n\nRollup of 11 pull requests\n\n- Successful merges: #34355, #34446, #34459, #34460, #34467, #34495, #34497, #34499, #34513, #34536, #34542\n- Failed merges:", "tree": {"sha": "6c202a81fd84a821d4b6731835f7bd4e68ec8a97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c202a81fd84a821d4b6731835f7bd4e68ec8a97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "html_url": "https://github.com/rust-lang/rust/commit/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5dd10012537aad9181a8ebf4216afa6193e49954", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dd10012537aad9181a8ebf4216afa6193e49954", "html_url": "https://github.com/rust-lang/rust/commit/5dd10012537aad9181a8ebf4216afa6193e49954"}, {"sha": "8e2598c3d2eb61e487e4ee5908f40211350a44e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e2598c3d2eb61e487e4ee5908f40211350a44e2", "html_url": "https://github.com/rust-lang/rust/commit/8e2598c3d2eb61e487e4ee5908f40211350a44e2"}], "stats": {"total": 1065, "additions": 620, "deletions": 445}, "files": [{"sha": "2cc39412182dc5a771417a8f7e714cdf6cad4a3d", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -50,6 +50,7 @@ use session::Session;\n use std::collections::BTreeMap;\n use std::iter;\n use syntax::ast::*;\n+use syntax::errors;\n use syntax::ptr::P;\n use syntax::codemap::{respan, Spanned};\n use syntax::parse::token;\n@@ -60,7 +61,7 @@ use syntax_pos::Span;\n pub struct LoweringContext<'a> {\n     crate_root: Option<&'static str>,\n     // Use to assign ids to hir nodes that do not directly correspond to an ast node\n-    id_assigner: &'a NodeIdAssigner,\n+    sess: Option<&'a Session>,\n     // As we walk the AST we must keep track of the current 'parent' def id (in\n     // the form of a DefIndex) so that if we create a new node which introduces\n     // a definition, then we can properly create the def id.\n@@ -99,7 +100,6 @@ impl Resolver for DummyResolver {\n \n pub fn lower_crate(sess: &Session,\n                    krate: &Crate,\n-                   id_assigner: &NodeIdAssigner,\n                    resolver: &mut Resolver)\n                    -> hir::Crate {\n     // We're constructing the HIR here; we don't care what we will\n@@ -115,17 +115,17 @@ pub fn lower_crate(sess: &Session,\n         } else {\n             Some(\"std\")\n         },\n-        id_assigner: id_assigner,\n+        sess: Some(sess),\n         parent_def: None,\n         resolver: resolver,\n     }.lower_crate(krate)\n }\n \n impl<'a> LoweringContext<'a> {\n-    pub fn testing_context(id_assigner: &'a NodeIdAssigner, resolver: &'a mut Resolver) -> Self {\n+    pub fn testing_context(resolver: &'a mut Resolver) -> Self {\n         LoweringContext {\n             crate_root: None,\n-            id_assigner: id_assigner,\n+            sess: None,\n             parent_def: None,\n             resolver: resolver,\n         }\n@@ -161,7 +161,12 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn next_id(&self) -> NodeId {\n-        self.id_assigner.next_node_id()\n+        self.sess.map(Session::next_node_id).unwrap_or(0)\n+    }\n+\n+    fn diagnostic(&self) -> &errors::Handler {\n+        self.sess.map(Session::diagnostic)\n+                 .unwrap_or_else(|| panic!(\"this lowerer cannot emit diagnostics\"))\n     }\n \n     fn str_to_ident(&self, s: &'static str) -> Name {\n@@ -786,7 +791,7 @@ impl<'a> LoweringContext<'a> {\n         if let Some(SelfKind::Explicit(..)) = sig.decl.get_self().map(|eself| eself.node) {\n             match hir_sig.decl.get_self().map(|eself| eself.node) {\n                 Some(hir::SelfKind::Value(..)) | Some(hir::SelfKind::Region(..)) => {\n-                    self.id_assigner.diagnostic().span_err(sig.decl.inputs[0].ty.span,\n+                    self.diagnostic().span_err(sig.decl.inputs[0].ty.span,\n                         \"the type placeholder `_` is not allowed within types on item signatures\");\n                 }\n                 _ => {}\n@@ -1212,7 +1217,7 @@ impl<'a> LoweringContext<'a> {\n                             make_struct(self, e, &[\"RangeInclusive\", \"NonEmpty\"],\n                                                  &[(\"start\", e1), (\"end\", e2)]),\n \n-                        _ => panic!(self.id_assigner.diagnostic()\n+                        _ => panic!(self.diagnostic()\n                                         .span_fatal(e.span, \"inclusive range with no end\")),\n                     };\n                 }"}, {"sha": "2b89695ab41cad2fdbb39f846547a314f1ece101", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -25,15 +25,15 @@ pub struct DefCollector<'ast> {\n     // If we are walking HIR (c.f., AST), we need to keep a reference to the\n     // crate.\n     hir_crate: Option<&'ast hir::Crate>,\n-    pub definitions: Definitions,\n+    definitions: &'ast mut Definitions,\n     parent_def: Option<DefIndex>,\n }\n \n impl<'ast> DefCollector<'ast> {\n-    pub fn root() -> DefCollector<'ast> {\n+    pub fn root(definitions: &'ast mut Definitions) -> DefCollector<'ast> {\n         let mut collector = DefCollector {\n             hir_crate: None,\n-            definitions: Definitions::new(),\n+            definitions: definitions,\n             parent_def: None,\n         };\n         let root = collector.create_def_with_parent(None, CRATE_NODE_ID, DefPathData::CrateRoot);\n@@ -48,7 +48,7 @@ impl<'ast> DefCollector<'ast> {\n     pub fn extend(parent_node: NodeId,\n                   parent_def_path: DefPath,\n                   parent_def_id: DefId,\n-                  definitions: Definitions)\n+                  definitions: &'ast mut Definitions)\n                   -> DefCollector<'ast> {\n         let mut collector = DefCollector {\n             hir_crate: None,"}, {"sha": "3317585f820aa60b30647c97d7b33c1561a7b784", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -10,8 +10,9 @@\n \n use middle::cstore::LOCAL_CRATE;\n use hir::def_id::{DefId, DefIndex};\n+use hir::map::def_collector::DefCollector;\n use rustc_data_structures::fnv::FnvHashMap;\n-use syntax::ast;\n+use syntax::{ast, visit};\n use syntax::parse::token::InternedString;\n use util::nodemap::NodeMap;\n \n@@ -189,6 +190,11 @@ impl Definitions {\n         }\n     }\n \n+    pub fn collect(&mut self, krate: &ast::Crate) {\n+        let mut def_collector = DefCollector::root(self);\n+        visit::walk_crate(&mut def_collector, krate);\n+    }\n+\n     /// Get the number of definitions.\n     pub fn len(&self) -> usize {\n         self.data.len()"}, {"sha": "960e32ae99faf0810cdde1ff5fe9adf479c7f7dc", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -24,7 +24,6 @@ use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID, };\n use syntax::codemap::Spanned;\n-use syntax::visit;\n use syntax_pos::Span;\n \n use hir::*;\n@@ -780,12 +779,6 @@ impl<F: FoldOps> Folder for IdAndSpanUpdater<F> {\n     }\n }\n \n-pub fn collect_definitions<'ast>(krate: &'ast ast::Crate) -> Definitions {\n-    let mut def_collector = DefCollector::root();\n-    visit::walk_crate(&mut def_collector, krate);\n-    def_collector.definitions\n-}\n-\n pub fn map_crate<'ast>(forest: &'ast mut Forest,\n                        definitions: Definitions)\n                        -> Map<'ast> {\n@@ -842,13 +835,12 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n     let ii = map.forest.inlined_items.alloc(ii);\n     let ii_parent_id = fld.new_id(DUMMY_NODE_ID);\n \n-    let defs = mem::replace(&mut *map.definitions.borrow_mut(), Definitions::new());\n+    let defs = &mut *map.definitions.borrow_mut();\n     let mut def_collector = DefCollector::extend(ii_parent_id,\n                                                  parent_def_path.clone(),\n                                                  parent_def_id,\n                                                  defs);\n     def_collector.walk_item(ii, map.krate());\n-    *map.definitions.borrow_mut() = def_collector.definitions;\n \n     let mut collector = NodeCollector::extend(map.krate(),\n                                               ii,"}, {"sha": "fdaf182c6054246e0ed2d62b6958f8dc38c1c5f1", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -20,7 +20,7 @@ use ty::tls;\n use util::nodemap::{NodeMap, FnvHashMap};\n use mir::transform as mir_pass;\n \n-use syntax::ast::{NodeId, NodeIdAssigner, Name};\n+use syntax::ast::{NodeId, Name};\n use errors::{self, DiagnosticBuilder};\n use errors::emitter::{Emitter, BasicEmitter, EmitterWriter};\n use syntax::json::JsonEmitter;\n@@ -272,6 +272,9 @@ impl Session {\n \n         id\n     }\n+    pub fn next_node_id(&self) -> NodeId {\n+        self.reserve_node_ids(1)\n+    }\n     pub fn diagnostic<'a>(&'a self) -> &'a errors::Handler {\n         &self.parse_sess.span_diagnostic\n     }\n@@ -345,20 +348,6 @@ impl Session {\n     }\n }\n \n-impl NodeIdAssigner for Session {\n-    fn next_node_id(&self) -> NodeId {\n-        self.reserve_node_ids(1)\n-    }\n-\n-    fn peek_node_id(&self) -> NodeId {\n-        self.next_node_id.get().checked_add(1).unwrap()\n-    }\n-\n-    fn diagnostic(&self) -> &errors::Handler {\n-        self.diagnostic()\n-    }\n-}\n-\n fn split_msg_into_multilines(msg: &str) -> Option<String> {\n     // Conditions for enabling multi-line errors:\n     if !msg.contains(\"mismatched types\") &&"}, {"sha": "6c37662206ce252f5592eeeee86853fe43c4b1e6", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 41, "deletions": 48, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -543,54 +543,47 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let result = match e.node {\n       hir::ExprUnary(hir::UnNeg, ref inner) => {\n         // unary neg literals already got their sign during creation\n-        match inner.node {\n-            hir::ExprLit(ref lit) => {\n-                use syntax::ast::*;\n-                use syntax::ast::LitIntType::*;\n-                const I8_OVERFLOW: u64 = ::std::i8::MAX as u64 + 1;\n-                const I16_OVERFLOW: u64 = ::std::i16::MAX as u64 + 1;\n-                const I32_OVERFLOW: u64 = ::std::i32::MAX as u64 + 1;\n-                const I64_OVERFLOW: u64 = ::std::i64::MAX as u64 + 1;\n-                match (&lit.node, ety.map(|t| &t.sty)) {\n-                    (&LitKind::Int(I8_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I8))) |\n-                    (&LitKind::Int(I8_OVERFLOW, Signed(IntTy::I8)), _) => {\n-                        return Ok(Integral(I8(::std::i8::MIN)))\n-                    },\n-                    (&LitKind::Int(I16_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I16))) |\n-                    (&LitKind::Int(I16_OVERFLOW, Signed(IntTy::I16)), _) => {\n-                        return Ok(Integral(I16(::std::i16::MIN)))\n-                    },\n-                    (&LitKind::Int(I32_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I32))) |\n-                    (&LitKind::Int(I32_OVERFLOW, Signed(IntTy::I32)), _) => {\n-                        return Ok(Integral(I32(::std::i32::MIN)))\n-                    },\n-                    (&LitKind::Int(I64_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I64))) |\n-                    (&LitKind::Int(I64_OVERFLOW, Signed(IntTy::I64)), _) => {\n-                        return Ok(Integral(I64(::std::i64::MIN)))\n-                    },\n-                    (&LitKind::Int(n, Unsuffixed), Some(&ty::TyInt(IntTy::Is))) |\n-                    (&LitKind::Int(n, Signed(IntTy::Is)), _) => {\n-                        match tcx.sess.target.int_type {\n-                            IntTy::I16 => if n == I16_OVERFLOW {\n-                                return Ok(Integral(Isize(Is16(::std::i16::MIN))));\n-                            },\n-                            IntTy::I32 => if n == I32_OVERFLOW {\n-                                return Ok(Integral(Isize(Is32(::std::i32::MIN))));\n-                            },\n-                            IntTy::I64 => if n == I64_OVERFLOW {\n-                                return Ok(Integral(Isize(Is64(::std::i64::MIN))));\n-                            },\n-                            _ => bug!(),\n-                        }\n-                    },\n-                    _ => {},\n-                }\n-            },\n-            hir::ExprUnary(hir::UnNeg, ref inner) => {\n-                // skip `--$expr`\n-                return eval_const_expr_partial(tcx, inner, ty_hint, fn_args);\n-            },\n-            _ => {},\n+        if let hir::ExprLit(ref lit) = inner.node {\n+            use syntax::ast::*;\n+            use syntax::ast::LitIntType::*;\n+            const I8_OVERFLOW: u64 = ::std::i8::MAX as u64 + 1;\n+            const I16_OVERFLOW: u64 = ::std::i16::MAX as u64 + 1;\n+            const I32_OVERFLOW: u64 = ::std::i32::MAX as u64 + 1;\n+            const I64_OVERFLOW: u64 = ::std::i64::MAX as u64 + 1;\n+            match (&lit.node, ety.map(|t| &t.sty)) {\n+                (&LitKind::Int(I8_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I8))) |\n+                (&LitKind::Int(I8_OVERFLOW, Signed(IntTy::I8)), _) => {\n+                    return Ok(Integral(I8(::std::i8::MIN)))\n+                },\n+                (&LitKind::Int(I16_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I16))) |\n+                (&LitKind::Int(I16_OVERFLOW, Signed(IntTy::I16)), _) => {\n+                    return Ok(Integral(I16(::std::i16::MIN)))\n+                },\n+                (&LitKind::Int(I32_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I32))) |\n+                (&LitKind::Int(I32_OVERFLOW, Signed(IntTy::I32)), _) => {\n+                    return Ok(Integral(I32(::std::i32::MIN)))\n+                },\n+                (&LitKind::Int(I64_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I64))) |\n+                (&LitKind::Int(I64_OVERFLOW, Signed(IntTy::I64)), _) => {\n+                    return Ok(Integral(I64(::std::i64::MIN)))\n+                },\n+                (&LitKind::Int(n, Unsuffixed), Some(&ty::TyInt(IntTy::Is))) |\n+                (&LitKind::Int(n, Signed(IntTy::Is)), _) => {\n+                    match tcx.sess.target.int_type {\n+                        IntTy::I16 => if n == I16_OVERFLOW {\n+                            return Ok(Integral(Isize(Is16(::std::i16::MIN))));\n+                        },\n+                        IntTy::I32 => if n == I32_OVERFLOW {\n+                            return Ok(Integral(Isize(Is32(::std::i32::MIN))));\n+                        },\n+                        IntTy::I64 => if n == I64_OVERFLOW {\n+                            return Ok(Integral(Isize(Is64(::std::i64::MIN))));\n+                        },\n+                        _ => bug!(),\n+                    }\n+                },\n+                _ => {},\n+            }\n         }\n         match eval_const_expr_partial(tcx, &inner, ty_hint, fn_args)? {\n           Float(f) => Float(-f),"}, {"sha": "46009e581309444f7496ba886aff3f180899840f", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 35, "deletions": 50, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::dep_graph::DepGraph;\n use rustc::hir;\n use rustc::hir::{map as hir_map, FreevarMap, TraitMap};\n use rustc::hir::def::DefMap;\n@@ -27,7 +26,7 @@ use rustc::util::nodemap::NodeSet;\n use rustc_back::sha2::{Sha256, Digest};\n use rustc_borrowck as borrowck;\n use rustc_incremental;\n-use rustc_resolve as resolve;\n+use rustc_resolve::{MakeGlobMap, Resolver};\n use rustc_metadata::macro_import;\n use rustc_metadata::creader::read_local_crates;\n use rustc_metadata::cstore::CStore;\n@@ -49,13 +48,11 @@ use std::ffi::{OsString, OsStr};\n use std::fs;\n use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n-use syntax::ast::{self, NodeIdAssigner};\n+use syntax::{ast, diagnostics, visit};\n use syntax::attr::{self, AttrMetaMethods};\n-use syntax::diagnostics;\n use syntax::fold::Folder;\n use syntax::parse::{self, PResult, token};\n use syntax::util::node_count::NodeCounter;\n-use syntax::visit;\n use syntax;\n use syntax_ext;\n \n@@ -293,7 +290,7 @@ pub struct CompileController<'a> {\n     pub after_analysis: PhaseController<'a>,\n     pub after_llvm: PhaseController<'a>,\n \n-    pub make_glob_map: resolve::MakeGlobMap,\n+    pub make_glob_map: MakeGlobMap,\n }\n \n impl<'a> CompileController<'a> {\n@@ -305,7 +302,7 @@ impl<'a> CompileController<'a> {\n             after_hir_lowering: PhaseController::basic(),\n             after_analysis: PhaseController::basic(),\n             after_llvm: PhaseController::basic(),\n-            make_glob_map: resolve::MakeGlobMap::No,\n+            make_glob_map: MakeGlobMap::No,\n         }\n     }\n }\n@@ -564,7 +561,7 @@ pub fn phase_2_configure_and_expand<'a>(sess: &Session,\n                                         mut krate: ast::Crate,\n                                         crate_name: &'a str,\n                                         addl_plugins: Option<Vec<String>>,\n-                                        make_glob_map: resolve::MakeGlobMap)\n+                                        make_glob_map: MakeGlobMap)\n                                         -> Result<ExpansionResult<'a>, usize> {\n     let time_passes = sess.time_passes();\n \n@@ -729,13 +726,16 @@ pub fn phase_2_configure_and_expand<'a>(sess: &Session,\n \n     krate = assign_node_ids(sess, krate);\n \n+    let resolver_arenas = Resolver::arenas();\n+    let mut resolver = Resolver::new(sess, make_glob_map, &resolver_arenas);\n+\n     // Collect defintions for def ids.\n-    let mut defs =\n-        time(sess.time_passes(), \"collecting defs\", || hir_map::collect_definitions(&krate));\n+    time(sess.time_passes(), \"collecting defs\", || resolver.definitions.collect(&krate));\n \n-    time(sess.time_passes(),\n-         \"external crate/lib resolution\",\n-         || read_local_crates(sess, &cstore, &defs, &krate, crate_name, &sess.dep_graph));\n+    time(sess.time_passes(), \"external crate/lib resolution\", || {\n+        let defs = &resolver.definitions;\n+        read_local_crates(sess, &cstore, defs, &krate, crate_name, &sess.dep_graph)\n+    });\n \n     time(sess.time_passes(),\n          \"early lint checks\",\n@@ -745,8 +745,14 @@ pub fn phase_2_configure_and_expand<'a>(sess: &Session,\n          \"AST validation\",\n          || ast_validation::check_crate(sess, &krate));\n \n-    let (analysis, resolutions, hir_forest) =\n-        lower_and_resolve(sess, crate_name, &mut defs, &krate, &sess.dep_graph, make_glob_map);\n+    time(sess.time_passes(), \"name resolution\", || {\n+        resolver.resolve_crate(&krate);\n+    });\n+\n+    // Lower ast -> hir.\n+    let hir_forest = time(sess.time_passes(), \"lowering ast -> hir\", || {\n+        hir_map::Forest::new(lower_crate(sess, &krate, &mut resolver), &sess.dep_graph)\n+    });\n \n     // Discard MTWT tables that aren't required past lowering to HIR.\n     if !keep_mtwt_tables(sess) {\n@@ -755,9 +761,20 @@ pub fn phase_2_configure_and_expand<'a>(sess: &Session,\n \n     Ok(ExpansionResult {\n         expanded_crate: krate,\n-        defs: defs,\n-        analysis: analysis,\n-        resolutions: resolutions,\n+        defs: resolver.definitions,\n+        analysis: ty::CrateAnalysis {\n+            export_map: resolver.export_map,\n+            access_levels: AccessLevels::default(),\n+            reachable: NodeSet(),\n+            name: crate_name,\n+            glob_map: if resolver.make_glob_map { Some(resolver.glob_map) } else { None },\n+        },\n+        resolutions: Resolutions {\n+            def_map: resolver.def_map,\n+            freevars: resolver.freevars,\n+            trait_map: resolver.trait_map,\n+            maybe_unused_trait_imports: resolver.maybe_unused_trait_imports,\n+        },\n         hir_forest: hir_forest\n     })\n }\n@@ -809,38 +826,6 @@ pub fn assign_node_ids(sess: &Session, krate: ast::Crate) -> ast::Crate {\n     krate\n }\n \n-pub fn lower_and_resolve<'a>(sess: &Session,\n-                             id: &'a str,\n-                             defs: &mut hir_map::Definitions,\n-                             krate: &ast::Crate,\n-                             dep_graph: &DepGraph,\n-                             make_glob_map: resolve::MakeGlobMap)\n-                             -> (ty::CrateAnalysis<'a>, Resolutions, hir_map::Forest) {\n-    resolve::with_resolver(sess, defs, make_glob_map, |mut resolver| {\n-        time(sess.time_passes(), \"name resolution\", || {\n-            resolve::resolve_crate(&mut resolver, krate);\n-        });\n-\n-        // Lower ast -> hir.\n-        let hir_forest = time(sess.time_passes(), \"lowering ast -> hir\", || {\n-            hir_map::Forest::new(lower_crate(sess, krate, sess, &mut resolver), dep_graph)\n-        });\n-\n-        (ty::CrateAnalysis {\n-            export_map: resolver.export_map,\n-            access_levels: AccessLevels::default(),\n-            reachable: NodeSet(),\n-            name: &id,\n-            glob_map: if resolver.make_glob_map { Some(resolver.glob_map) } else { None },\n-        }, Resolutions {\n-            def_map: resolver.def_map,\n-            freevars: resolver.freevars,\n-            trait_map: resolver.trait_map,\n-            maybe_unused_trait_imports: resolver.maybe_unused_trait_imports,\n-        }, hir_forest)\n-    })\n-}\n-\n /// Run the resolution, typechecking, region checking and other\n /// miscellaneous analysis passes on the crate. Return various\n /// structures carrying the results of the analysis."}, {"sha": "7ef00b971c57ba6262f24be7b313c4798c9621ee", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -38,7 +38,6 @@ use rustc::ty::subst;\n use rustc::ty::{self, Ty, TyCtxt};\n \n use syntax::ast;\n-use syntax::ast::NodeIdAssigner;\n use syntax::ptr::P;\n use syntax_pos;\n \n@@ -56,7 +55,6 @@ use rustc_serialize::{Encodable, EncoderHelpers};\n \n #[cfg(test)] use std::io::Cursor;\n #[cfg(test)] use syntax::parse;\n-#[cfg(test)] use syntax::ast::NodeId;\n #[cfg(test)] use rustc::hir::print as pprust;\n #[cfg(test)] use rustc::hir::lowering::{LoweringContext, DummyResolver};\n \n@@ -1295,32 +1293,15 @@ impl FakeExtCtxt for parse::ParseSess {\n     fn parse_sess(&self) -> &parse::ParseSess { self }\n }\n \n-#[cfg(test)]\n-struct FakeNodeIdAssigner;\n-\n-#[cfg(test)]\n-// It should go without saying that this may give unexpected results. Avoid\n-// lowering anything which needs new nodes.\n-impl NodeIdAssigner for FakeNodeIdAssigner {\n-    fn next_node_id(&self) -> NodeId {\n-        0\n-    }\n-\n-    fn peek_node_id(&self) -> NodeId {\n-        0\n-    }\n-}\n-\n #[cfg(test)]\n fn mk_ctxt() -> parse::ParseSess {\n     parse::ParseSess::new()\n }\n \n #[cfg(test)]\n fn with_testing_context<T, F: FnOnce(&mut LoweringContext) -> T>(f: F) -> T {\n-    let assigner = FakeNodeIdAssigner;\n     let mut resolver = DummyResolver;\n-    let mut lcx = LoweringContext::testing_context(&assigner, &mut resolver);\n+    let mut lcx = LoweringContext::testing_context(&mut resolver);\n     f(&mut lcx)\n }\n "}, {"sha": "3e860150a35fdfbe3f2379e81cc727f3783f4778", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 207, "deletions": 82, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -16,6 +16,8 @@\n register_long_diagnostics! {\n \n E0154: r##\"\n+## Note: this error code is no longer emitted by the compiler.\n+\n Imports (`use` statements) are not allowed after non-item statements, such as\n variable declarations and expression statements.\n \n@@ -50,6 +52,8 @@ https://doc.rust-lang.org/reference.html#statements\n \"##,\n \n E0251: r##\"\n+## Note: this error code is no longer emitted by the compiler.\n+\n Two items of the same name cannot be imported without rebinding one of the\n items under a new local name.\n \n@@ -75,9 +79,9 @@ E0252: r##\"\n Two items of the same name cannot be imported without rebinding one of the\n items under a new local name.\n \n-An example of this error:\n+Erroneous code example:\n \n-```compile_fail\n+```compile_fail,E0252\n use foo::baz;\n use bar::baz; // error, do `use bar::baz as quux` instead\n \n@@ -87,6 +91,41 @@ mod foo {\n     pub struct baz;\n }\n \n+mod bar {\n+    pub mod baz {}\n+}\n+```\n+\n+You can use aliases in order to fix this error. Example:\n+\n+```\n+use foo::baz as foo_baz;\n+use bar::baz; // ok!\n+\n+fn main() {}\n+\n+mod foo {\n+    pub struct baz;\n+}\n+\n+mod bar {\n+    pub mod baz {}\n+}\n+```\n+\n+Or you can reference the item with its parent:\n+\n+```\n+use bar::baz;\n+\n+fn main() {\n+    let x = foo::baz; // ok!\n+}\n+\n+mod foo {\n+    pub struct baz;\n+}\n+\n mod bar {\n     pub mod baz {}\n }\n@@ -95,16 +134,20 @@ mod bar {\n \n E0253: r##\"\n Attempt was made to import an unimportable value. This can happen when trying\n-to import a method from a trait. An example of this error:\n+to import a method from a trait.\n \n-```compile_fail\n+Erroneous code example:\n+\n+```compile_fail,E0253\n mod foo {\n     pub trait MyTrait {\n         fn do_something();\n     }\n }\n \n use foo::MyTrait::do_something;\n+\n+fn main() {}\n ```\n \n It's invalid to directly import methods belonging to a trait or concrete type.\n@@ -114,10 +157,10 @@ E0255: r##\"\n You can't import a value whose name is the same as another value defined in the\n module.\n \n-An example of this error:\n+Erroneous code example:\n \n-```compile_fail\n-use bar::foo; // error, do `use bar::foo as baz` instead\n+```compile_fail,E0255\n+use bar::foo; // error: an item named `foo` is already in scope\n \n fn foo() {}\n \n@@ -127,9 +170,39 @@ mod bar {\n \n fn main() {}\n ```\n+\n+You can use aliases in order to fix this error. Example:\n+\n+```\n+use bar::foo as bar_foo; // ok!\n+\n+fn foo() {}\n+\n+mod bar {\n+     pub fn foo() {}\n+}\n+\n+fn main() {}\n+```\n+\n+Or you can reference the item with its parent:\n+\n+```\n+fn foo() {}\n+\n+mod bar {\n+     pub fn foo() {}\n+}\n+\n+fn main() {\n+    bar::foo(); // we get the item by referring to its parent\n+}\n+```\n \"##,\n \n E0256: r##\"\n+## Note: this error code is no longer emitted by the compiler.\n+\n You can't import a type or module when the name of the item being imported is\n the same as another type or submodule defined in the module.\n \n@@ -154,9 +227,11 @@ that has been imported into the current module.\n \n Erroneous code example:\n \n-```compile_fail\n-extern crate a;\n-extern crate crate_a as a;\n+```compile_fail,E0259\n+extern crate std;\n+extern crate libc as std;\n+\n+fn main() {}\n ```\n \n The solution is to choose a different name that doesn't conflict with any\n@@ -165,17 +240,17 @@ external crate imported into the current module.\n Correct example:\n \n ```ignore\n-extern crate a;\n-extern crate crate_a as other_name;\n+extern crate std;\n+extern crate libc as other_name;\n ```\n \"##,\n \n E0260: r##\"\n The name for an item declaration conflicts with an external crate's name.\n \n-For instance:\n+Erroneous code example:\n \n-```ignore\n+```ignore,E0260\n extern crate abc;\n \n struct abc;\n@@ -206,28 +281,32 @@ https://doc.rust-lang.org/reference.html#statements\n \"##,\n \n E0364: r##\"\n-Private items cannot be publicly re-exported.  This error indicates that you\n+Private items cannot be publicly re-exported. This error indicates that you\n attempted to `pub use` a type or value that was not itself public.\n \n-Here is an example that demonstrates the error:\n+Erroneous code example:\n \n ```compile_fail\n mod foo {\n     const X: u32 = 1;\n }\n \n pub use foo::X;\n+\n+fn main() {}\n ```\n \n The solution to this problem is to ensure that the items that you are\n re-exporting are themselves marked with `pub`:\n \n-```ignore\n+```\n mod foo {\n     pub const X: u32 = 1;\n }\n \n pub use foo::X;\n+\n+fn main() {}\n ```\n \n See the 'Use Declarations' section of the reference for more information on\n@@ -240,25 +319,29 @@ E0365: r##\"\n Private modules cannot be publicly re-exported. This error indicates that you\n attempted to `pub use` a module that was not itself public.\n \n-Here is an example that demonstrates the error:\n+Erroneous code example:\n \n-```compile_fail\n+```compile_fail,E0365\n mod foo {\n     pub const X: u32 = 1;\n }\n \n pub use foo as foo2;\n+\n+fn main() {}\n ```\n \n The solution to this problem is to ensure that the module that you are\n re-exporting is itself marked with `pub`:\n \n-```ignore\n+```\n pub mod foo {\n     pub const X: u32 = 1;\n }\n \n pub use foo as foo2;\n+\n+fn main() {}\n ```\n \n See the 'Use Declarations' section of the reference for more information\n@@ -269,9 +352,11 @@ https://doc.rust-lang.org/reference.html#use-declarations\n \n E0401: r##\"\n Inner items do not inherit type parameters from the functions they are embedded\n-in. For example, this will not compile:\n+in.\n \n-```compile_fail\n+Erroneous code example:\n+\n+```compile_fail,E0401\n fn foo<T>(x: T) {\n     fn bar(y: T) { // T is defined in the \"outer\" function\n         // ..\n@@ -282,7 +367,7 @@ fn foo<T>(x: T) {\n \n Nor will this:\n \n-```compile_fail\n+```compile_fail,E0401\n fn foo<T>(x: T) {\n     type MaybeT = Option<T>;\n     // ...\n@@ -291,7 +376,7 @@ fn foo<T>(x: T) {\n \n Or this:\n \n-```compile_fail\n+```compile_fail,E0401\n fn foo<T>(x: T) {\n     struct Foo {\n         x: T,\n@@ -374,9 +459,11 @@ closures or copying the parameters should still work.\n \"##,\n \n E0403: r##\"\n-Some type parameters have the same name. Example of erroneous code:\n+Some type parameters have the same name.\n \n-```compile_fail\n+Erroneous code example:\n+\n+```compile_fail,E0403\n fn foo<T, T>(s: T, u: T) {} // error: the name `T` is already used for a type\n                             //        parameter in this type parameter list\n ```\n@@ -390,10 +477,11 @@ fn foo<T, Y>(s: T, u: Y) {} // ok!\n \"##,\n \n E0404: r##\"\n-You tried to implement something which was not a trait on an object. Example of\n-erroneous code:\n+You tried to implement something which was not a trait on an object.\n \n-```compile_fail\n+Erroneous code example:\n+\n+```compile_fail,E0404\n struct Foo;\n struct Bar;\n \n@@ -416,9 +504,11 @@ impl Foo for Bar { // ok!\n \"##,\n \n E0405: r##\"\n-The code refers to a trait that is not in scope. Example of erroneous code:\n+The code refers to a trait that is not in scope.\n \n-```compile_fail\n+Erroneous code example:\n+\n+```compile_fail,E0405\n struct Foo;\n \n impl SomeTrait for Foo {} // error: trait `SomeTrait` is not in scope\n@@ -446,9 +536,11 @@ impl SomeTrait for Foo { // ok!\n \n E0407: r##\"\n A definition of a method not in the implemented trait was given in a trait\n-implementation. Example of erroneous code:\n+implementation.\n \n-```compile_fail\n+Erroneous code example:\n+\n+```compile_fail,E0407\n trait Foo {\n     fn a();\n }\n@@ -501,9 +593,9 @@ E0408: r##\"\n An \"or\" pattern was used where the variable bindings are not consistently bound\n across patterns.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n-```compile_fail\n+```compile_fail,E0408\n match x {\n     Some(y) | None => { /* use y */ } // error: variable `y` from pattern #1 is\n                                       //        not bound in pattern #2\n@@ -545,9 +637,9 @@ E0409: r##\"\n An \"or\" pattern was used where the variable bindings are not consistently bound\n across patterns.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n-```compile_fail\n+```compile_fail,E0409\n let x = (0, 2);\n match x {\n     (0, ref y) | (y, 0) => { /* use y */} // error: variable `y` is bound with\n@@ -583,9 +675,11 @@ match x {\n \"##,\n \n E0411: r##\"\n-The `Self` keyword was used outside an impl or a trait. Erroneous code example:\n+The `Self` keyword was used outside an impl or a trait.\n \n-```compile_fail\n+Erroneous code example:\n+\n+```compile_fail,E0411\n <Self>::foo; // error: use of `Self` outside of an impl or trait\n ```\n \n@@ -639,9 +733,11 @@ trait Baz : Foo + Foo2 {\n \"##,\n \n E0412: r##\"\n-The type name used is not in scope. Example of erroneous codes:\n+The type name used is not in scope.\n \n-```compile_fail\n+Erroneous code examples:\n+\n+```compile_fail,E0412\n impl Something {} // error: type name `Something` is not in scope\n \n // or:\n@@ -678,9 +774,11 @@ fn foo<T>(x: T) {} // ok!\n \"##,\n \n E0415: r##\"\n-More than one function parameter have the same name. Example of erroneous code:\n+More than one function parameter have the same name.\n \n-```compile_fail\n+Erroneous code example:\n+\n+```compile_fail,E0415\n fn foo(f: i32, f: i32) {} // error: identifier `f` is bound more than\n                           //        once in this parameter list\n ```\n@@ -693,9 +791,11 @@ fn foo(f: i32, g: i32) {} // ok!\n \"##,\n \n E0416: r##\"\n-An identifier is bound more than once in a pattern. Example of erroneous code:\n+An identifier is bound more than once in a pattern.\n \n-```compile_fail\n+Erroneous code example:\n+\n+```compile_fail,E0416\n match (1, 2) {\n     (x, x) => {} // error: identifier `x` is bound more than once in the\n                  //        same pattern\n@@ -722,9 +822,10 @@ match (A, B, C) {\n \n E0422: r##\"\n You are trying to use an identifier that is either undefined or not a struct.\n-For instance:\n \n-``` compile_fail\n+Erroneous code example:\n+\n+``` compile_fail,E0422\n fn main () {\n     let x = Foo { x: 1, y: 2 };\n }\n@@ -733,7 +834,7 @@ fn main () {\n In this case, `Foo` is undefined, so it inherently isn't anything, and\n definitely not a struct.\n \n-```compile_fail\n+```compile_fail,E0422\n fn main () {\n     let foo = 1;\n     let x = foo { x: 1, y: 2 };\n@@ -745,10 +846,11 @@ one.\n \"##,\n \n E0423: r##\"\n-A `struct` variant name was used like a function name. Example of erroneous\n-code:\n+A `struct` variant name was used like a function name.\n \n-```compile_fail\n+Erroneous code example:\n+\n+```compile_fail,E0423\n struct Foo { a: bool};\n \n let f = Foo();\n@@ -767,9 +869,11 @@ let f = Foo(); // ok!\n \"##,\n \n E0424: r##\"\n-The `self` keyword was used in a static method. Example of erroneous code:\n+The `self` keyword was used in a static method.\n \n-```compile_fail\n+Erroneous code example:\n+\n+```compile_fail,E0424\n struct Foo;\n \n impl Foo {\n@@ -799,9 +903,11 @@ impl Foo {\n \"##,\n \n E0425: r##\"\n-An unresolved name was used. Example of erroneous codes:\n+An unresolved name was used.\n \n-```compile_fail\n+Erroneous code examples:\n+\n+```compile_fail,E0425\n something_that_doesnt_exist::foo;\n // error: unresolved name `something_that_doesnt_exist::foo`\n \n@@ -857,9 +963,11 @@ current module, then it must also be declared as public (e.g., `pub fn`).\n \"##,\n \n E0426: r##\"\n-An undeclared label was used. Example of erroneous code:\n+An undeclared label was used.\n \n-```compile_fail\n+Erroneous code example:\n+\n+```compile_fail,E0426\n loop {\n     break 'a; // error: use of undeclared label `'a`\n }\n@@ -875,10 +983,11 @@ Please verify you spelt or declare the label correctly. Example:\n \"##,\n \n E0428: r##\"\n-A type or module has been defined more than once. Example of erroneous\n-code:\n+A type or module has been defined more than once.\n \n-```compile_fail\n+Erroneous code example:\n+\n+```compile_fail,E0428\n struct Bar;\n struct Bar; // error: duplicate definition of value `Bar`\n ```\n@@ -896,9 +1005,9 @@ E0429: r##\"\n The `self` keyword cannot appear alone as the last segment in a `use`\n declaration.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n-```compile_fail\n+```compile_fail,E0429\n use std::fmt::self; // error: `self` imports are only allowed within a { } list\n ```\n \n@@ -917,9 +1026,11 @@ use std::fmt;\n \"##,\n \n E0430: r##\"\n-The `self` import appears more than once in the list. Erroneous code example:\n+The `self` import appears more than once in the list.\n \n-```compile_fail\n+Erroneous code example:\n+\n+```compile_fail,E0430\n use something::{self, self}; // error: `self` import can only appear once in\n                              //        the list\n ```\n@@ -933,9 +1044,11 @@ use something::self; // ok!\n \"##,\n \n E0431: r##\"\n-An invalid `self` import was made. Erroneous code example:\n+An invalid `self` import was made.\n \n-```compile_fail\n+Erroneous code example:\n+\n+```compile_fail,E0431\n use {self}; // error: `self` import can only appear in an import list with a\n             //        non-empty prefix\n ```\n@@ -945,9 +1058,11 @@ or verify you didn't misspell it.\n \"##,\n \n E0432: r##\"\n-An import was unresolved. Erroneous code example:\n+An import was unresolved.\n \n-```compile_fail\n+Erroneous code example:\n+\n+```compile_fail,E0432\n use something::Foo; // error: unresolved import `something::Foo`.\n ```\n \n@@ -976,24 +1091,33 @@ use homura::Madoka;\n \"##,\n \n E0433: r##\"\n-Invalid import. Example of erroneous code:\n+An undeclared type or module was used.\n \n-```compile_fail\n-use something_which_doesnt_exist;\n-// error: unresolved import `something_which_doesnt_exist`\n+Erroneous code example:\n+\n+```compile_fail,E0433\n+let map = HashMap::new();\n+// error: failed to resolve. Use of undeclared type or module `HashMap`\n ```\n \n-Please verify you didn't misspell the import's name.\n+Please verify you didn't misspell the type/module's name or that you didn't\n+forgot to import it:\n+\n+\n+```\n+use std::collections::HashMap; // HashMap has been imported.\n+let map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n+```\n \"##,\n \n E0434: r##\"\n This error indicates that a variable usage inside an inner function is invalid\n because the variable comes from a dynamic environment. Inner functions do not\n have access to their containing environment.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n-```compile_fail\n+```compile_fail,E0434\n fn foo() {\n     let y = 5;\n     fn bar() -> u32 {\n@@ -1032,10 +1156,11 @@ fn foo() {\n \"##,\n \n E0435: r##\"\n-A non-constant value was used to initialise a constant. Example of erroneous\n-code:\n+A non-constant value was used to initialise a constant.\n \n-```compile_fail\n+Erroneous code example:\n+\n+```compile_fail,E0435\n let foo = 42u32;\n const FOO : u32 = foo; // error: attempt to use a non-constant value in a\n                        //        constant\n@@ -1061,9 +1186,9 @@ the trait in question. This error indicates that you attempted to implement\n an associated type whose name does not match the name of any associated type\n in the trait.\n \n-Here is an example that demonstrates the error:\n+Erroneous code example:\n \n-```compile_fail\n+```compile_fail,E0437\n trait Foo {}\n \n impl Foo for i32 {\n@@ -1086,9 +1211,9 @@ members of the trait in question. This error indicates that you\n attempted to implement an associated constant whose name does not\n match the name of any associated constant in the trait.\n \n-Here is an example that demonstrates the error:\n+Erroneous code example:\n \n-```compile_fail\n+```compile_fail,E0438\n #![feature(associated_consts)]\n \n trait Foo {}"}, {"sha": "ed400af66855a66145924a9cf66ac240e542e37b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 39, "deletions": 54, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -47,7 +47,7 @@ use rustc::hir::{self, PrimTy, TyBool, TyChar, TyFloat, TyInt, TyUint, TyStr};\n use rustc::session::Session;\n use rustc::lint;\n use rustc::hir::def::*;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::ty;\n use rustc::ty::subst::{ParamSpace, FnSpace, TypeSpace};\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n@@ -925,7 +925,7 @@ impl PrimitiveTypeTable {\n pub struct Resolver<'a> {\n     session: &'a Session,\n \n-    definitions: &'a mut Definitions,\n+    pub definitions: Definitions,\n \n     graph_root: Module<'a>,\n \n@@ -1001,7 +1001,7 @@ pub struct Resolver<'a> {\n     arenas: &'a ResolverArenas<'a>,\n }\n \n-struct ResolverArenas<'a> {\n+pub struct ResolverArenas<'a> {\n     modules: arena::TypedArena<ModuleS<'a>>,\n     local_modules: RefCell<Vec<Module<'a>>>,\n     name_bindings: arena::TypedArena<NameBinding<'a>>,\n@@ -1079,7 +1079,7 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n     }\n \n     fn definitions(&mut self) -> Option<&mut Definitions> {\n-        Some(self.definitions)\n+        Some(&mut self.definitions)\n     }\n }\n \n@@ -1100,12 +1100,9 @@ impl Named for hir::PathSegment {\n }\n \n impl<'a> Resolver<'a> {\n-    fn new(session: &'a Session,\n-           definitions: &'a mut Definitions,\n-           make_glob_map: MakeGlobMap,\n-           arenas: &'a ResolverArenas<'a>)\n-           -> Resolver<'a> {\n-        let root_def_id = definitions.local_def_id(CRATE_NODE_ID);\n+    pub fn new(session: &'a Session, make_glob_map: MakeGlobMap, arenas: &'a ResolverArenas<'a>)\n+               -> Resolver<'a> {\n+        let root_def_id = DefId::local(CRATE_DEF_INDEX);\n         let graph_root =\n             ModuleS::new(NoParentLink, Some(Def::Mod(root_def_id)), false, arenas);\n         let graph_root = arenas.alloc_module(graph_root);\n@@ -1115,7 +1112,7 @@ impl<'a> Resolver<'a> {\n         Resolver {\n             session: session,\n \n-            definitions: definitions,\n+            definitions: Definitions::new(),\n \n             // The outermost module has def ID 0; this is not reflected in the\n             // AST.\n@@ -1158,7 +1155,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn arenas() -> ResolverArenas<'a> {\n+    pub fn arenas() -> ResolverArenas<'a> {\n         ResolverArenas {\n             modules: arena::TypedArena::new(),\n             local_modules: RefCell::new(Vec::new()),\n@@ -1168,6 +1165,27 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    /// Entry point to crate resolution.\n+    pub fn resolve_crate(&mut self, krate: &Crate) {\n+        // Currently, we ignore the name resolution data structures for\n+        // the purposes of dependency tracking. Instead we will run name\n+        // resolution and include its output in the hash of each item,\n+        // much like we do for macro expansion. In other words, the hash\n+        // reflects not just its contents but the results of name\n+        // resolution on those contents. Hopefully we'll push this back at\n+        // some point.\n+        let _ignore = self.session.dep_graph.in_ignore();\n+\n+        self.build_reduced_graph(krate);\n+        resolve_imports::resolve_imports(self);\n+\n+        self.current_module = self.graph_root;\n+        visit::walk_crate(self, krate);\n+\n+        check_unused::check_crate(self, krate);\n+        self.report_privacy_errors();\n+    }\n+\n     fn new_module(&self, parent_link: ParentLink<'a>, def: Option<Def>, external: bool)\n                   -> Module<'a> {\n         self.arenas.alloc_module(ModuleS::new(parent_link, def, external, self.arenas))\n@@ -1568,12 +1586,6 @@ impl<'a> Resolver<'a> {\n         None\n     }\n \n-    fn resolve_crate(&mut self, krate: &Crate) {\n-        debug!(\"(resolving crate) starting\");\n-        self.current_module = self.graph_root;\n-        visit::walk_crate(self, krate);\n-    }\n-\n     fn resolve_item(&mut self, item: &Item) {\n         let name = item.ident.name;\n \n@@ -2287,24 +2299,25 @@ impl<'a> Resolver<'a> {\n                 PatKind::Ident(bmode, ref ident, ref opt_pat) => {\n                     // First try to resolve the identifier as some existing\n                     // entity, then fall back to a fresh binding.\n-                    let resolution = if let Ok(resolution) = self.resolve_path(pat.id,\n-                                &Path::from_ident(ident.span, ident.node), 0, ValueNS) {\n+                    let local_def = self.resolve_identifier(ident.node, ValueNS, true);\n+                    let resolution = if let Some(LocalDef { def, .. }) = local_def {\n                         let always_binding = !pat_src.is_refutable() || opt_pat.is_some() ||\n                                              bmode != BindingMode::ByValue(Mutability::Immutable);\n-                        match resolution.base_def {\n+                        match def {\n                             Def::Struct(..) | Def::Variant(..) |\n                             Def::Const(..) | Def::AssociatedConst(..) if !always_binding => {\n                                 // A constant, unit variant, etc pattern.\n-                                resolution\n+                                PathResolution::new(def)\n                             }\n                             Def::Struct(..) | Def::Variant(..) |\n                             Def::Const(..) | Def::AssociatedConst(..) | Def::Static(..) => {\n                                 // A fresh binding that shadows something unacceptable.\n+                                let kind_name = PathResolution::new(def).kind_name();\n                                 resolve_error(\n                                     self,\n                                     ident.span,\n                                     ResolutionError::BindingShadowsSomethingUnacceptable(\n-                                        pat_src.descr(), resolution.kind_name(), ident.node.name)\n+                                        pat_src.descr(), kind_name, ident.node.name)\n                                 );\n                                 err_path_resolution()\n                             }\n@@ -3194,7 +3207,9 @@ impl<'a> Resolver<'a> {\n                     if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n                         // add the module to the lookup\n                         let is_extern = in_module_is_extern || name_binding.is_extern_crate();\n-                        worklist.push((module, path_segments, is_extern));\n+                        if !worklist.iter().any(|&(m, _, _)| m.def == module.def) {\n+                            worklist.push((module, path_segments, is_extern));\n+                        }\n                     }\n                 }\n             })\n@@ -3454,34 +3469,4 @@ pub enum MakeGlobMap {\n     No,\n }\n \n-/// Entry point to crate resolution.\n-pub fn resolve_crate<'a, 'b>(resolver: &'b mut Resolver<'a>, krate: &'b Crate) {\n-    // Currently, we ignore the name resolution data structures for\n-    // the purposes of dependency tracking. Instead we will run name\n-    // resolution and include its output in the hash of each item,\n-    // much like we do for macro expansion. In other words, the hash\n-    // reflects not just its contents but the results of name\n-    // resolution on those contents. Hopefully we'll push this back at\n-    // some point.\n-    let _ignore = resolver.session.dep_graph.in_ignore();\n-\n-    resolver.build_reduced_graph(krate);\n-    resolve_imports::resolve_imports(resolver);\n-    resolver.resolve_crate(krate);\n-\n-    check_unused::check_crate(resolver, krate);\n-    resolver.report_privacy_errors();\n-}\n-\n-pub fn with_resolver<'a, T, F>(session: &'a Session,\n-                               definitions: &'a mut Definitions,\n-                               make_glob_map: MakeGlobMap,\n-                               f: F) -> T\n-    where F: for<'b> FnOnce(Resolver<'b>) -> T,\n-{\n-    let arenas = Resolver::arenas();\n-    let resolver = Resolver::new(session, definitions, make_glob_map, &arenas);\n-    f(resolver)\n-}\n-\n __build_diagnostic_array! { librustc_resolve, DIAGNOSTICS }"}, {"sha": "48acf31b993679f4c2630c0159a15137f657e1d7", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -1696,6 +1696,9 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n     document(w, cx, item)?;\n \n     let mut indices = (0..items.len()).filter(|i| {\n+        if let clean::DefaultImplItem(..) = items[*i].inner {\n+            return false;\n+        }\n         !cx.maybe_ignore_item(&items[*i])\n     }).collect::<Vec<usize>>();\n "}, {"sha": "b8e40790646a7eab87cdf78d558404baf8628823", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -12,6 +12,7 @@ use rustc::hir::def_id::DefId;\n use rustc::middle::privacy::AccessLevels;\n use rustc::util::nodemap::DefIdSet;\n use std::cmp;\n+use std::mem;\n use std::string::String;\n use std::usize;\n \n@@ -29,7 +30,8 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n     // strip all #[doc(hidden)] items\n     let krate = {\n         struct Stripper<'a> {\n-            retained: &'a mut DefIdSet\n+            retained: &'a mut DefIdSet,\n+            update_retained: bool,\n         }\n         impl<'a> fold::DocFolder for Stripper<'a> {\n             fn fold_item(&mut self, i: Item) -> Option<Item> {\n@@ -38,17 +40,25 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n                     // use a dedicated hidden item for given item type if any\n                     match i.inner {\n                         clean::StructFieldItem(..) | clean::ModuleItem(..) => {\n-                            return Strip(i).fold()\n+                            // We need to recurse into stripped modules to\n+                            // strip things like impl methods but when doing so\n+                            // we must not add any items to the `retained` set.\n+                            let old = mem::replace(&mut self.update_retained, false);\n+                            let ret = Strip(self.fold_item_recur(i).unwrap()).fold();\n+                            self.update_retained = old;\n+                            return ret;\n                         }\n                         _ => return None,\n                     }\n                 } else {\n-                    self.retained.insert(i.def_id);\n+                    if self.update_retained {\n+                        self.retained.insert(i.def_id);\n+                    }\n                 }\n                 self.fold_item_recur(i)\n             }\n         }\n-        let mut stripper = Stripper{ retained: &mut retained };\n+        let mut stripper = Stripper{ retained: &mut retained, update_retained: true };\n         stripper.fold_crate(krate)\n     };\n \n@@ -69,6 +79,7 @@ pub fn strip_private(mut krate: clean::Crate) -> plugins::PluginResult {\n         let mut stripper = Stripper {\n             retained: &mut retained,\n             access_levels: &access_levels,\n+            update_retained: true,\n         };\n         krate = ImportStripper.fold_crate(stripper.fold_crate(krate));\n     }\n@@ -81,12 +92,21 @@ pub fn strip_private(mut krate: clean::Crate) -> plugins::PluginResult {\n struct Stripper<'a> {\n     retained: &'a mut DefIdSet,\n     access_levels: &'a AccessLevels<DefId>,\n+    update_retained: bool,\n }\n \n impl<'a> fold::DocFolder for Stripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         match i.inner {\n-            clean::StrippedItem(..) => return Some(i),\n+            clean::StrippedItem(..) => {\n+                // We need to recurse into stripped modules to strip things\n+                // like impl methods but when doing so we must not add any\n+                // items to the `retained` set.\n+                let old = mem::replace(&mut self.update_retained, false);\n+                let ret = self.fold_item_recur(i);\n+                self.update_retained = old;\n+                return ret;\n+            }\n             // These items can all get re-exported\n             clean::TypedefItem(..) | clean::StaticItem(..) |\n             clean::StructItem(..) | clean::EnumItem(..) |\n@@ -109,18 +129,13 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n \n             clean::ModuleItem(..) => {\n                 if i.def_id.is_local() && i.visibility != Some(clean::Public) {\n-                    return Strip(self.fold_item_recur(i).unwrap()).fold()\n+                    let old = mem::replace(&mut self.update_retained, false);\n+                    let ret = Strip(self.fold_item_recur(i).unwrap()).fold();\n+                    self.update_retained = old;\n+                    return ret;\n                 }\n             }\n \n-            // trait impls for private items should be stripped\n-            clean::ImplItem(clean::Impl{\n-                for_: clean::ResolvedPath{ did, is_generic, .. }, ..\n-            }) => {\n-                if did.is_local() && !is_generic && !self.access_levels.is_exported(did) {\n-                    return None;\n-                }\n-            }\n             // handled in the `strip-priv-imports` pass\n             clean::ExternCrateItem(..) | clean::ImportItem(..) => {}\n \n@@ -152,21 +167,24 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n         };\n \n         let i = if fastreturn {\n-            self.retained.insert(i.def_id);\n+            if self.update_retained {\n+                self.retained.insert(i.def_id);\n+            }\n             return Some(i);\n         } else {\n             self.fold_item_recur(i)\n         };\n \n         i.and_then(|i| {\n             match i.inner {\n-                // emptied modules/impls have no need to exist\n+                // emptied modules have no need to exist\n                 clean::ModuleItem(ref m)\n                     if m.items.is_empty() &&\n                        i.doc_value().is_none() => None,\n-                clean::ImplItem(ref i) if i.items.is_empty() => None,\n                 _ => {\n-                    self.retained.insert(i.def_id);\n+                    if self.update_retained {\n+                        self.retained.insert(i.def_id);\n+                    }\n                     Some(i)\n                 }\n             }\n@@ -182,6 +200,10 @@ struct ImplStripper<'a> {\n impl<'a> fold::DocFolder for ImplStripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if let clean::ImplItem(ref imp) = i.inner {\n+            // emptied none trait impls can be stripped\n+            if imp.trait_.is_none() && imp.items.is_empty() {\n+                return None;\n+            }\n             if let Some(did) = imp.for_.def_id() {\n                 if did.is_local() && !imp.for_.is_generic() &&\n                     !self.retained.contains(&did)"}, {"sha": "cc033cec8b8b1db948ee3f47ae983315a6e8d81e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -19,7 +19,6 @@ pub use util::ThinVec;\n use syntax_pos::{mk_sp, Span, DUMMY_SP, ExpnId};\n use codemap::{respan, Spanned};\n use abi::Abi;\n-use errors;\n use parse::token::{self, keywords, InternedString};\n use print::pprust;\n use ptr::P;\n@@ -362,15 +361,6 @@ pub const CRATE_NODE_ID: NodeId = 0;\n /// small, positive ids.\n pub const DUMMY_NODE_ID: NodeId = !0;\n \n-pub trait NodeIdAssigner {\n-    fn next_node_id(&self) -> NodeId;\n-    fn peek_node_id(&self) -> NodeId;\n-\n-    fn diagnostic(&self) -> &errors::Handler {\n-        panic!(\"this ID assigner cannot emit diagnostics\")\n-    }\n-}\n-\n /// The AST represents all type param bounds as types.\n /// typeck::collect::compute_bounds matches these against\n /// the \"special\" built-in traits (see middle::lang_items) and"}, {"sha": "3c88fb8f6703b6796655bdd20020943a2a118bee", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -839,7 +839,7 @@ impl HasAttrs for StmtKind {\n     fn attrs(&self) -> &[Attribute] {\n         match *self {\n             StmtKind::Local(ref local) => local.attrs(),\n-            StmtKind::Item(ref item) => item.attrs(),\n+            StmtKind::Item(..) => &[],\n             StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => expr.attrs(),\n             StmtKind::Mac(ref mac) => {\n                 let (_, _, ref attrs) = **mac;\n@@ -851,7 +851,7 @@ impl HasAttrs for StmtKind {\n     fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(self, f: F) -> Self {\n         match self {\n             StmtKind::Local(local) => StmtKind::Local(local.map_attrs(f)),\n-            StmtKind::Item(item) => StmtKind::Item(item.map_attrs(f)),\n+            StmtKind::Item(..) => self,\n             StmtKind::Expr(expr) => StmtKind::Expr(expr.map_attrs(f)),\n             StmtKind::Semi(expr) => StmtKind::Semi(expr.map_attrs(f)),\n             StmtKind::Mac(mac) => StmtKind::Mac(mac.map(|(mac, style, attrs)| {"}, {"sha": "eaf82f5f43ded1fe71823722f8ddd4cdada45b7d", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -213,12 +213,7 @@ impl<'a> fold::Folder for StripUnconfigured<'a> {\n     }\n \n     fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n-        // avoid calling `visit_stmt_or_expr_attrs` on items\n-        match stmt.node {\n-            ast::StmtKind::Item(_) => {}\n-            _ => self.visit_stmt_or_expr_attrs(stmt.attrs()),\n-        }\n-\n+        self.visit_stmt_or_expr_attrs(stmt.attrs());\n         self.configure(stmt).map(|stmt| fold::noop_fold_stmt(stmt, self))\n                             .unwrap_or(SmallVector::zero())\n     }"}, {"sha": "ca38ef068d05f4c610f7480e9f5444392af7afbd", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -443,6 +443,10 @@ impl MacResult for DummyResult {\n             span: self.span,\n         }))\n     }\n+\n+    fn make_ty(self: Box<DummyResult>) -> Option<P<ast::Ty>> {\n+        Some(DummyResult::raw_ty(self.span))\n+    }\n }\n \n /// An enum representing the different kinds of syntax extensions."}, {"sha": "c670283e559d9b8c60451dc964c617302ccada20", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 47, "deletions": 98, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -43,18 +43,19 @@ trait MacroGenerable: Sized {\n     fn fold_with<F: Folder>(self, folder: &mut F) -> Self;\n     fn visit_with<V: Visitor>(&self, visitor: &mut V);\n \n-    // Return a placeholder expansion to allow compilation to continue after an erroring expansion.\n-    fn dummy(span: Span) -> Self;\n-\n     // The user-friendly name of the node type (e.g. \"expression\", \"item\", etc.) for diagnostics.\n     fn kind_name() -> &'static str;\n+\n+    // Return a placeholder expansion to allow compilation to continue after an erroring expansion.\n+    fn dummy(span: Span) -> Self {\n+        Self::make_with(DummyResult::any(span)).unwrap()\n+    }\n }\n \n macro_rules! impl_macro_generable {\n     ($($ty:ty: $kind_name:expr, .$make:ident,\n                $(.$fold:ident)*  $(lift .$fold_elt:ident)*,\n-               $(.$visit:ident)* $(lift .$visit_elt:ident)*,\n-               |$span:ident| $dummy:expr;)*) => { $(\n+               $(.$visit:ident)* $(lift .$visit_elt:ident)*;)*) => { $(\n         impl MacroGenerable for $ty {\n             fn kind_name() -> &'static str { $kind_name }\n             fn make_with<'a>(result: Box<MacResult + 'a>) -> Option<Self> { result.$make() }\n@@ -66,31 +67,24 @@ macro_rules! impl_macro_generable {\n                 $( visitor.$visit(self) )*\n                 $( for item in self.as_slice() { visitor. $visit_elt (item) } )*\n             }\n-            fn dummy($span: Span) -> Self { $dummy }\n         }\n     )* }\n }\n \n impl_macro_generable! {\n-    P<ast::Pat>: \"pattern\", .make_pat, .fold_pat, .visit_pat, |span| P(DummyResult::raw_pat(span));\n-    P<ast::Ty>:  \"type\",    .make_ty,  .fold_ty,  .visit_ty,  |span| DummyResult::raw_ty(span);\n-    P<ast::Expr>:\n-        \"expression\", .make_expr, .fold_expr, .visit_expr, |span| DummyResult::raw_expr(span);\n-    SmallVector<ast::Stmt>:\n-        \"statement\",  .make_stmts, lift .fold_stmt, lift .visit_stmt, |_span| SmallVector::zero();\n-    SmallVector<P<ast::Item>>:\n-        \"item\",       .make_items, lift .fold_item, lift .visit_item, |_span| SmallVector::zero();\n+    P<ast::Expr>: \"expression\", .make_expr, .fold_expr, .visit_expr;\n+    P<ast::Pat>:  \"pattern\",    .make_pat,  .fold_pat,  .visit_pat;\n+    P<ast::Ty>:   \"type\",       .make_ty,   .fold_ty,   .visit_ty;\n+    SmallVector<ast::Stmt>: \"statement\", .make_stmts, lift .fold_stmt, lift .visit_stmt;\n+    SmallVector<P<ast::Item>>: \"item\",   .make_items, lift .fold_item, lift .visit_item;\n     SmallVector<ast::TraitItem>:\n-        \"trait item\", .make_trait_items, lift .fold_trait_item, lift .visit_trait_item,\n-        |_span| SmallVector::zero();\n+        \"trait item\", .make_trait_items, lift .fold_trait_item, lift .visit_trait_item;\n     SmallVector<ast::ImplItem>:\n-        \"impl item\",  .make_impl_items,  lift .fold_impl_item,  lift .visit_impl_item,\n-        |_span| SmallVector::zero();\n+        \"impl item\",  .make_impl_items,  lift .fold_impl_item,  lift .visit_impl_item;\n }\n \n impl MacroGenerable for Option<P<ast::Expr>> {\n     fn kind_name() -> &'static str { \"expression\" }\n-    fn dummy(_span: Span) -> Self { None }\n     fn make_with<'a>(result: Box<MacResult + 'a>) -> Option<Self> {\n         result.make_expr().map(Some)\n     }\n@@ -208,7 +202,7 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n                                           &fld.cx.ecfg.features.unwrap());\n         }\n \n-        if path.segments.len() > 1 {\n+        if path.segments.len() > 1 || path.global || !path.segments[0].parameters.is_empty() {\n             fld.cx.span_err(path.span, \"expected macro name without module separators\");\n             return None;\n         }\n@@ -691,7 +685,7 @@ impl<'a> Folder for PatIdentRenamer<'a> {\n }\n \n fn expand_multi_modified(a: Annotatable, fld: &mut MacroExpander) -> SmallVector<Annotatable> {\n-    let new_items: SmallVector<Annotatable> = match a {\n+    match a {\n         Annotatable::Item(it) => match it.node {\n             ast::ItemKind::Mac(..) => {\n                 it.and_then(|it| match it.node {\n@@ -728,63 +722,6 @@ fn expand_multi_modified(a: Annotatable, fld: &mut MacroExpander) -> SmallVector\n             expand_impl_item(ii.unwrap(), fld).into_iter().\n                 map(|ii| Annotatable::ImplItem(P(ii))).collect()\n         }\n-    };\n-\n-    new_items.into_iter().flat_map(|a| decorate(a, fld)).collect()\n-}\n-\n-fn decorate(a: Annotatable, fld: &mut MacroExpander) -> SmallVector<Annotatable> {\n-    let mut decorator_items = SmallVector::zero();\n-    let mut new_attrs = Vec::new();\n-    expand_decorators(a.clone(), fld, &mut decorator_items, &mut new_attrs);\n-\n-    let mut new_items = SmallVector::one(a.fold_attrs(new_attrs));\n-    new_items.push_all(decorator_items);\n-    new_items\n-}\n-\n-fn expand_decorators(a: Annotatable,\n-                     fld: &mut MacroExpander,\n-                     decorator_items: &mut SmallVector<Annotatable>,\n-                     new_attrs: &mut Vec<ast::Attribute>)\n-{\n-    for attr in a.attrs() {\n-        let mname = intern(&attr.name());\n-        match fld.cx.syntax_env.find(mname) {\n-            Some(rc) => match *rc {\n-                MultiDecorator(ref dec) => {\n-                    attr::mark_used(&attr);\n-\n-                    fld.cx.bt_push(ExpnInfo {\n-                        call_site: attr.span,\n-                        callee: NameAndSpan {\n-                            format: MacroAttribute(mname),\n-                            span: Some(attr.span),\n-                            // attributes can do whatever they like,\n-                            // for now.\n-                            allow_internal_unstable: true,\n-                        }\n-                    });\n-\n-                    let mut items: SmallVector<Annotatable> = SmallVector::zero();\n-                    dec.expand(fld.cx,\n-                               attr.span,\n-                               &attr.node.value,\n-                               &a,\n-                               &mut |ann| items.push(ann));\n-\n-                    for item in items {\n-                        for configured_item in item.fold_with(&mut fld.strip_unconfigured()) {\n-                            decorator_items.extend(expand_annotatable(configured_item, fld));\n-                        }\n-                    }\n-\n-                    fld.cx.bt_pop();\n-                }\n-                _ => new_attrs.push((*attr).clone()),\n-            },\n-            _ => new_attrs.push((*attr).clone()),\n-        }\n     }\n }\n \n@@ -793,9 +730,12 @@ fn expand_annotatable(mut item: Annotatable, fld: &mut MacroExpander) -> SmallVe\n     item = item.map_attrs(|mut attrs| {\n         for i in 0..attrs.len() {\n             if let Some(extension) = fld.cx.syntax_env.find(intern(&attrs[i].name())) {\n-                if let MultiModifier(..) = *extension {\n-                    multi_modifier = Some((attrs.remove(i), extension));\n-                    break;\n+                match *extension {\n+                    MultiModifier(..) | MultiDecorator(..) => {\n+                        multi_modifier = Some((attrs.remove(i), extension));\n+                        break;\n+                    }\n+                    _ => {}\n                 }\n             }\n         }\n@@ -804,23 +744,32 @@ fn expand_annotatable(mut item: Annotatable, fld: &mut MacroExpander) -> SmallVe\n \n     match multi_modifier {\n         None => expand_multi_modified(item, fld),\n-        Some((attr, extension)) => match *extension {\n-            MultiModifier(ref mac) => {\n-                attr::mark_used(&attr);\n-                fld.cx.bt_push(ExpnInfo {\n-                    call_site: attr.span,\n-                    callee: NameAndSpan {\n-                        format: MacroAttribute(intern(&attr.name())),\n-                        span: Some(attr.span),\n-                        // attributes can do whatever they like, for now\n-                        allow_internal_unstable: true,\n-                    }\n-                });\n-                let modified = mac.expand(fld.cx, attr.span, &attr.node.value, item);\n-                fld.cx.bt_pop();\n-                modified.into_iter().flat_map(|it| expand_annotatable(it, fld)).collect()\n-            }\n-            _ => unreachable!(),\n+        Some((attr, extension)) => {\n+            attr::mark_used(&attr);\n+            fld.cx.bt_push(ExpnInfo {\n+                call_site: attr.span,\n+                callee: NameAndSpan {\n+                    format: MacroAttribute(intern(&attr.name())),\n+                    span: Some(attr.span),\n+                    // attributes can do whatever they like, for now\n+                    allow_internal_unstable: true,\n+                }\n+            });\n+\n+            let modified = match *extension {\n+                MultiModifier(ref mac) => mac.expand(fld.cx, attr.span, &attr.node.value, item),\n+                MultiDecorator(ref mac) => {\n+                    let mut items = Vec::new();\n+                    mac.expand(fld.cx, attr.span, &attr.node.value, &item,\n+                               &mut |item| items.push(item));\n+                    items.push(item);\n+                    items\n+                }\n+                _ => unreachable!(),\n+            };\n+\n+            fld.cx.bt_pop();\n+            modified.into_iter().flat_map(|it| expand_annotatable(it, fld)).collect()\n         }\n     }\n }"}, {"sha": "ed6f09eed645f7741951542aaeea87665667266c", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -1102,7 +1102,6 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n \n pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mut T) -> Expr {\n     Expr {\n-        id: folder.new_id(id),\n         node: match node {\n             ExprKind::Box(e) => {\n                 ExprKind::Box(folder.fold_expr(e))\n@@ -1270,9 +1269,19 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                         fields.move_map(|x| folder.fold_field(x)),\n                         maybe_expr.map(|x| folder.fold_expr(x)))\n             },\n-            ExprKind::Paren(ex) => ExprKind::Paren(folder.fold_expr(ex)),\n+            ExprKind::Paren(ex) => {\n+                let sub_expr = folder.fold_expr(ex);\n+                return Expr {\n+                    // Nodes that are equal modulo `Paren` sugar no-ops should have the same ids.\n+                    id: sub_expr.id,\n+                    node: ExprKind::Paren(sub_expr),\n+                    span: folder.new_span(span),\n+                    attrs: fold_attrs(attrs.into(), folder).into(),\n+                };\n+            }\n             ExprKind::Try(ex) => ExprKind::Try(folder.fold_expr(ex)),\n         },\n+        id: folder.new_id(id),\n         span: folder.new_span(span),\n         attrs: fold_attrs(attrs.into(), folder).into(),\n     }"}, {"sha": "20a54228d016cdb222a1975dc219332586227349", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -553,10 +553,6 @@ impl<'a> Parser<'a> {\n         self.expect_one_of(edible, inedible)\n     }\n \n-    pub fn commit_stmt_expecting(&mut self, edible: token::Token) -> PResult<'a, ()> {\n-        self.commit_stmt(&[edible], &[])\n-    }\n-\n     /// returns the span of expr, if it was not interpolated or the span of the interpolated token\n     fn interpolated_or_expr_span(&self,\n                                  expr: PResult<'a, P<Expr>>)\n@@ -4122,7 +4118,7 @@ impl<'a> Parser<'a> {\n                 _ => { // all other kinds of statements:\n                     let mut hi = span.hi;\n                     if classify::stmt_ends_with_semi(&node) {\n-                        self.commit_stmt_expecting(token::Semi)?;\n+                        self.commit_stmt(&[token::Semi], &[])?;\n                         hi = self.last_span.hi;\n                     }\n "}, {"sha": "e01f4ed1f9bd233a932762ebf3cd110078703805", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -345,15 +345,18 @@ pub fn combine_substructure<'a>(f: CombineSubstructureFunc<'a>)\n /// This method helps to extract all the type parameters referenced from a\n /// type. For a type parameter `<T>`, it looks for either a `TyPath` that\n /// is not global and starts with `T`, or a `TyQPath`.\n-fn find_type_parameters(ty: &ast::Ty, ty_param_names: &[ast::Name]) -> Vec<P<ast::Ty>> {\n+fn find_type_parameters(ty: &ast::Ty, ty_param_names: &[ast::Name], span: Span, cx: &ExtCtxt)\n+                        -> Vec<P<ast::Ty>> {\n     use syntax::visit;\n \n-    struct Visitor<'a> {\n+    struct Visitor<'a, 'b: 'a> {\n+        cx: &'a ExtCtxt<'b>,\n+        span: Span,\n         ty_param_names: &'a [ast::Name],\n         types: Vec<P<ast::Ty>>,\n     }\n \n-    impl<'a> visit::Visitor for Visitor<'a> {\n+    impl<'a, 'b> visit::Visitor for Visitor<'a, 'b> {\n         fn visit_ty(&mut self, ty: &ast::Ty) {\n             match ty.node {\n                 ast::TyKind::Path(_, ref path) if !path.global => {\n@@ -371,11 +374,18 @@ fn find_type_parameters(ty: &ast::Ty, ty_param_names: &[ast::Name]) -> Vec<P<ast\n \n             visit::walk_ty(self, ty)\n         }\n+\n+        fn visit_mac(&mut self, mac: &ast::Mac) {\n+            let span = Span { expn_id: self.span.expn_id, ..mac.span };\n+            self.cx.span_err(span, \"`derive` cannot be used on items with type macros\");\n+        }\n     }\n \n     let mut visitor = Visitor {\n         ty_param_names: ty_param_names,\n         types: Vec::new(),\n+        span: span,\n+        cx: cx,\n     };\n \n     visit::Visitor::visit_ty(&mut visitor, ty);\n@@ -556,7 +566,7 @@ impl<'a> TraitDef<'a> {\n \n             let mut processed_field_types = HashSet::new();\n             for field_ty in field_tys {\n-                let tys = find_type_parameters(&field_ty, &ty_param_names);\n+                let tys = find_type_parameters(&field_ty, &ty_param_names, self.span, cx);\n \n                 for ty in tys {\n                     // if we have already handled this type, skip it"}, {"sha": "1186e3d62f73aa291eda379ca80e1a117db4be2d", "filename": "src/test/compile-fail/auxiliary/recursive_reexports.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Frecursive_reexports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Frecursive_reexports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Frecursive_reexports.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub mod foo {\n+    pub use foo;\n+}"}, {"sha": "e8ca1c1fa98ff4a99c755f274b3a7d3aa2c8f799", "filename": "src/test/compile-fail/issue-32950.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Ftest%2Fcompile-fail%2Fissue-32950.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Ftest%2Fcompile-fail%2Fissue-32950.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32950.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(type_macros, concat_idents, rustc_attrs)]\n-#![allow(unused)]\n+#![feature(type_macros, concat_idents)]\n \n-#[derive(Debug)] struct FooBar;\n-#[derive(Debug)] struct Baz<T>(T, concat_idents!(Foo, Bar));\n+#[derive(Debug)] //~ NOTE in this expansion\n+struct Baz<T>(\n+    concat_idents!(Foo, Bar) //~ ERROR `derive` cannot be used on items with type macros\n+);\n \n-#[rustc_error]\n-fn main() {} //~ ERROR compilation successful\n+fn main() {}"}, {"sha": "e99dfb9aa0f0e9b6a425e6c9329ff3896feb9899", "filename": "src/test/compile-fail/lint-type-overflow2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Ftest%2Fcompile-fail%2Flint-type-overflow2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Ftest%2Fcompile-fail%2Flint-type-overflow2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-type-overflow2.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -15,6 +15,7 @@\n #[allow(unused_variables)]\n fn main() {\n     let x2: i8 = --128; //~ error: literal out of range for i8\n+    //~^ error: attempted to negate with overflow\n \n     let x = -3.40282348e+38_f32; //~ error: literal out of range for f32\n     let x =  3.40282348e+38_f32; //~ error: literal out of range for f32"}, {"sha": "408bb15ba28cdd165cbf9246f2bdf1f891760b4e", "filename": "src/test/compile-fail/macro-with-seps-err-msg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Ftest%2Fcompile-fail%2Fmacro-with-seps-err-msg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Ftest%2Fcompile-fail%2Fmacro-with-seps-err-msg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-with-seps-err-msg.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:expected macro name without module separators\n-\n fn main() {\n-    globnar::brotz!();\n+    globnar::brotz!(); //~ ERROR expected macro name without module separators\n+    ::foo!(); //~ ERROR expected macro name without module separators\n+    foo::<T>!(); //~ ERROR expected macro name without module separators\n }"}, {"sha": "6fd52beeec62c444243a402978169da346c07c39", "filename": "src/test/compile-fail/recursive-reexports.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Ftest%2Fcompile-fail%2Frecursive-reexports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Ftest%2Fcompile-fail%2Frecursive-reexports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frecursive-reexports.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:recursive_reexports.rs\n+\n+fn f() -> recursive_reexports::S {} //~ ERROR undeclared\n+\n+fn main() {}"}, {"sha": "96070332f06df4b94a4daec87b18d85ae1874770", "filename": "src/test/parse-fail/issue-33455.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Ftest%2Fparse-fail%2Fissue-33455.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Ftest%2Fparse-fail%2Fissue-33455.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-33455.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use foo.bar; //~ ERROR expected one of `::`, `;`, or `as`, found `.`"}, {"sha": "203c56e9e2e00173282b287bfca3144521d23172", "filename": "src/test/rustdoc/hidden-impls.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Ftest%2Frustdoc%2Fhidden-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Ftest%2Frustdoc%2Fhidden-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fhidden-impls.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"foo\"]\n+\n+mod hidden {\n+    #[derive(Clone)]\n+    pub struct Foo;\n+}\n+\n+#[doc(hidden)]\n+pub mod __hidden {\n+    pub use hidden::Foo;\n+}\n+\n+// @has foo/trait.Clone.html\n+// @!has - 'Foo'\n+// @has implementors/foo/trait.Clone.js\n+// @!has - 'Foo'\n+pub use std::clone::Clone;"}, {"sha": "18f5f086cd1a4ea85ad386c2c6831daf26bfa25e", "filename": "src/test/rustdoc/hidden-methods.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Ftest%2Frustdoc%2Fhidden-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Ftest%2Frustdoc%2Fhidden-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fhidden-methods.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"foo\"]\n+\n+#[doc(hidden)]\n+pub mod hidden {\n+    pub struct Foo;\n+\n+    impl Foo {\n+        #[doc(hidden)]\n+        pub fn this_should_be_hidden() {}\n+    }\n+\n+    pub struct Bar;\n+\n+    impl Bar {\n+        fn this_should_be_hidden() {}\n+    }\n+}\n+\n+// @has foo/struct.Foo.html\n+// @!has - 'Methods'\n+// @!has - 'impl Foo'\n+// @!has - 'this_should_be_hidden'\n+pub use hidden::Foo;\n+\n+// @has foo/struct.Bar.html\n+// @!has - 'Methods'\n+// @!has - 'impl Bar'\n+// @!has - 'this_should_be_hidden'\n+pub use hidden::Bar;"}, {"sha": "7be3c50073166001e870e60fa7b83b648173dd3a", "filename": "src/test/rustdoc/module-impls.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Ftest%2Frustdoc%2Fmodule-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Ftest%2Frustdoc%2Fmodule-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fmodule-impls.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"foo\"]\n+\n+pub use std::marker::Send;\n+\n+// @!has foo/index.html 'Implementations'"}, {"sha": "6830f32bb2ce117bb522b0762ef4a57fdf04a15f", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b56fb7a0c24e04227318ca7e5950e9289ee3e4/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=c2b56fb7a0c24e04227318ca7e5950e9289ee3e4", "patch": "@@ -254,6 +254,17 @@ pub fn run_tests(config: &Config) {\n \n     match config.mode {\n         DebugInfoLldb => {\n+            if let Some(lldb_version) = config.lldb_version.as_ref() {\n+                if is_blacklisted_lldb_version(&lldb_version[..]) {\n+                    println!(\"WARNING: The used version of LLDB ({}) has a \\\n+                              known issue that breaks debuginfo tests. See \\\n+                              issue #32520 for more information. Skipping all \\\n+                              LLDB-based tests!\",\n+                             lldb_version);\n+                    return\n+                }\n+            }\n+\n             // Some older versions of LLDB seem to have problems with multiple\n             // instances running in parallel, so only run one test thread at a\n             // time.\n@@ -524,3 +535,7 @@ fn extract_lldb_version(full_version_line: Option<String>) -> Option<String> {\n     }\n     None\n }\n+\n+fn is_blacklisted_lldb_version(version: &str) -> bool {\n+    version == \"350\"\n+}"}]}