{"sha": "fa010a6ee45f5ca106a4a475e06f4fa75d0c0970", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhMDEwYTZlZTQ1ZjVjYTEwNmE0YTQ3NWUwNmY0ZmE3NWQwYzA5NzA=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-02T00:26:50Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-02T01:21:41Z"}, "message": "De-export std::{uv, uv_ll, uv_iotask, uv_global_loop}. Part of #3583.", "tree": {"sha": "5f8f3cc01281000c563e28c10fa1f109e48768ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f8f3cc01281000c563e28c10fa1f109e48768ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa010a6ee45f5ca106a4a475e06f4fa75d0c0970", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa010a6ee45f5ca106a4a475e06f4fa75d0c0970", "html_url": "https://github.com/rust-lang/rust/commit/fa010a6ee45f5ca106a4a475e06f4fa75d0c0970", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa010a6ee45f5ca106a4a475e06f4fa75d0c0970/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13979eb7e2fddd3f46f4e83fbc41ed656636ce80", "url": "https://api.github.com/repos/rust-lang/rust/commits/13979eb7e2fddd3f46f4e83fbc41ed656636ce80", "html_url": "https://github.com/rust-lang/rust/commit/13979eb7e2fddd3f46f4e83fbc41ed656636ce80"}], "stats": {"total": 306, "additions": 139, "deletions": 167}, "files": [{"sha": "4d5eefec0534ec46b8d9aea46242585bd54536cb", "filename": "src/libstd/std.rc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa010a6ee45f5ca106a4a475e06f4fa75d0c0970/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/fa010a6ee45f5ca106a4a475e06f4fa75d0c0970/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=fa010a6ee45f5ca106a4a475e06f4fa75d0c0970", "patch": "@@ -55,13 +55,9 @@ mod net_tcp;\n mod net_url;\n \n // libuv modules\n-#[legacy_exports]\n mod uv;\n-#[legacy_exports]\n mod uv_ll;\n-#[legacy_exports]\n mod uv_iotask;\n-#[legacy_exports]\n mod uv_global_loop;\n \n "}, {"sha": "e0fd013907c8efe04de9111c868bf7c04398c641", "filename": "src/libstd/uv.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fa010a6ee45f5ca106a4a475e06f4fa75d0c0970/src%2Flibstd%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa010a6ee45f5ca106a4a475e06f4fa75d0c0970/src%2Flibstd%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv.rs?ref=fa010a6ee45f5ca106a4a475e06f4fa75d0c0970", "patch": "@@ -23,11 +23,6 @@\n  * facilities.\n  */\n \n-use ll = uv_ll;\n-export ll;\n-\n-use iotask = uv_iotask;\n-export iotask;\n-\n-use global_loop = uv_global_loop;\n-export global_loop;\n+pub use ll = uv_ll;\n+pub use iotask = uv_iotask;\n+pub use global_loop = uv_global_loop;"}, {"sha": "869c3efa38f9a0b7e14028f84194b65e505786b6", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa010a6ee45f5ca106a4a475e06f4fa75d0c0970/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa010a6ee45f5ca106a4a475e06f4fa75d0c0970/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=fa010a6ee45f5ca106a4a475e06f4fa75d0c0970", "patch": "@@ -2,8 +2,6 @@\n \n #[forbid(deprecated_mode)];\n \n-export get;\n-\n use ll = uv_ll;\n use iotask = uv_iotask;\n use get_gl = get;\n@@ -15,7 +13,6 @@ use task::TaskBuilder;\n use either::{Left, Right};\n \n extern mod rustrt {\n-    #[legacy_exports];\n     fn rust_uv_get_kernel_global_chan_ptr() -> *libc::uintptr_t;\n }\n \n@@ -31,7 +28,7 @@ extern mod rustrt {\n  * * A `hl::high_level_loop` that encapsulates communication with the global\n  * loop.\n  */\n-fn get() -> IoTask {\n+pub fn get() -> IoTask {\n     return get_monitor_task_gl();\n }\n \n@@ -112,7 +109,6 @@ fn spawn_loop() -> IoTask {\n \n #[cfg(test)]\n mod test {\n-    #[legacy_exports];\n     extern fn simple_timer_close_cb(timer_ptr: *ll::uv_timer_t) unsafe {\n         let exit_ch_ptr = ll::get_data_for_uv_handle(\n             timer_ptr as *libc::c_void) as *comm::Chan<bool>;"}, {"sha": "876aa6f4af0b450eff1bef5f0680f0a72f5f0ca5", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fa010a6ee45f5ca106a4a475e06f4fa75d0c0970/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa010a6ee45f5ca106a4a475e06f4fa75d0c0970/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=fa010a6ee45f5ca106a4a475e06f4fa75d0c0970", "patch": "@@ -7,11 +7,6 @@\n \n #[forbid(deprecated_mode)];\n \n-export IoTask;\n-export spawn_iotask;\n-export interact;\n-export exit;\n-\n use libc::c_void;\n use ptr::p2::addr_of;\n use comm = core::comm;\n@@ -20,14 +15,14 @@ use task::TaskBuilder;\n use ll = uv_ll;\n \n /// Used to abstract-away direct interaction with a libuv loop.\n-enum IoTask {\n+pub enum IoTask {\n     IoTask_({\n         async_handle: *ll::uv_async_t,\n         op_chan: Chan<IoTaskMsg>\n     })\n }\n \n-fn spawn_iotask(+task: task::TaskBuilder) -> IoTask {\n+pub fn spawn_iotask(+task: task::TaskBuilder) -> IoTask {\n \n     do listen |iotask_ch| {\n \n@@ -64,7 +59,7 @@ fn spawn_iotask(+task: task::TaskBuilder) -> IoTask {\n  * module. It is not safe to send the `loop_ptr` param to this callback out\n  * via ports/chans.\n  */\n-unsafe fn interact(iotask: IoTask,\n+pub unsafe fn interact(iotask: IoTask,\n                    +cb: fn~(*c_void)) {\n     send_msg(iotask, Interaction(move cb));\n }\n@@ -76,7 +71,7 @@ unsafe fn interact(iotask: IoTask,\n  * async handle and do a sanity check to make sure that all other handles are\n  * closed, causing a failure otherwise.\n  */\n-fn exit(iotask: IoTask) unsafe {\n+pub fn exit(iotask: IoTask) unsafe {\n     send_msg(iotask, TeardownLoop);\n }\n \n@@ -170,7 +165,6 @@ extern fn tear_down_close_cb(handle: *ll::uv_async_t) unsafe {\n \n #[cfg(test)]\n mod test {\n-    #[legacy_exports];\n     extern fn async_close_cb(handle: *ll::uv_async_t) unsafe {\n         log(debug, fmt!(\"async_close_cb handle %?\", handle));\n         let exit_ch = (*(ll::get_data_for_uv_handle(handle)"}, {"sha": "f0594475d04eb7a39060cbb5361e8dec33897628", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 131, "deletions": 140, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/fa010a6ee45f5ca106a4a475e06f4fa75d0c0970/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa010a6ee45f5ca106a4a475e06f4fa75d0c0970/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=fa010a6ee45f5ca106a4a475e06f4fa75d0c0970", "patch": "@@ -27,13 +27,13 @@ use comm = core::comm;\n use ptr::to_unsafe_ptr;\n \n // libuv struct mappings\n-type uv_ip4_addr = {\n+pub type uv_ip4_addr = {\n     ip: ~[u8],\n     port: int\n };\n-type uv_ip6_addr = uv_ip4_addr;\n+pub type uv_ip6_addr = uv_ip4_addr;\n \n-enum uv_handle_type {\n+pub enum uv_handle_type {\n     UNKNOWN_HANDLE = 0,\n     UV_TCP,\n     UV_UDP,\n@@ -51,17 +51,17 @@ enum uv_handle_type {\n     UV_FS_EVENT\n }\n \n-type handle_type = libc::c_uint;\n+pub type handle_type = libc::c_uint;\n \n-type uv_handle_fields = {\n+pub type uv_handle_fields = {\n    loop_handle: *libc::c_void,\n    type_: handle_type,\n    close_cb: *u8,\n    mut data: *libc::c_void,\n };\n \n // unix size: 8\n-type uv_err_t = {\n+pub type uv_err_t = {\n     code: libc::c_int,\n     sys_errno_: libc::c_int\n };\n@@ -71,13 +71,13 @@ type uv_err_t = {\n // in other types as a pointer to be used in other\n // operations (so mostly treat it as opaque, once you\n // have it in this form..)\n-type uv_stream_t = {\n+pub type uv_stream_t = {\n     fields: uv_handle_fields\n };\n \n // 64bit unix size: 272\n #[cfg(unix)]\n-type uv_tcp_t = {\n+pub type uv_tcp_t = {\n     fields: uv_handle_fields,\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n     a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n@@ -91,19 +91,19 @@ type uv_tcp_t = {\n };\n // 32bit unix size: 328 (164)\n #[cfg(target_arch=\"x86_64\")]\n-type uv_tcp_t_32bit_unix_riders = {\n+pub type uv_tcp_t_32bit_unix_riders = {\n     a29: *u8\n };\n #[cfg(target_arch=\"x86\")]\n-type uv_tcp_t_32bit_unix_riders = {\n+pub type uv_tcp_t_32bit_unix_riders = {\n     a29: *u8, a30: *u8, a31: *u8,\n     a32: *u8, a33: *u8, a34: *u8,\n     a35: *u8, a36: *u8\n };\n \n // 32bit win32 size: 240 (120)\n #[cfg(windows)]\n-type uv_tcp_t = {\n+pub type uv_tcp_t = {\n     fields: uv_handle_fields,\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n     a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n@@ -116,20 +116,20 @@ type uv_tcp_t = {\n \n // unix size: 48\n #[cfg(unix)]\n-type uv_connect_t = {\n+pub type uv_connect_t = {\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n     a04: *u8, a05: *u8\n };\n // win32 size: 88 (44)\n #[cfg(windows)]\n-type uv_connect_t = {\n+pub type uv_connect_t = {\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n     a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n     a08: *u8, a09: *u8, a10: *u8\n };\n \n // unix size: 16\n-type uv_buf_t = {\n+pub type uv_buf_t = {\n     base: *u8,\n     len: libc::size_t\n };\n@@ -138,7 +138,7 @@ type uv_buf_t = {\n \n // unix size: 144\n #[cfg(unix)]\n-type uv_write_t = {\n+pub type uv_write_t = {\n     fields: uv_handle_fields,\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n     a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n@@ -147,16 +147,16 @@ type uv_write_t = {\n     a14: uv_write_t_32bit_unix_riders\n };\n #[cfg(target_arch=\"x86_64\")]\n-type uv_write_t_32bit_unix_riders = {\n+pub type uv_write_t_32bit_unix_riders = {\n     a13: *u8\n };\n #[cfg(target_arch=\"x86\")]\n-type uv_write_t_32bit_unix_riders = {\n+pub type uv_write_t_32bit_unix_riders = {\n     a13: *u8, a14: *u8\n };\n // win32 size: 136 (68)\n #[cfg(windows)]\n-type uv_write_t = {\n+pub type uv_write_t = {\n     fields: uv_handle_fields,\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n     a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n@@ -166,24 +166,24 @@ type uv_write_t = {\n // 64bit unix size: 120\n // 32bit unix size: 152 (76)\n #[cfg(unix)]\n-type uv_async_t = {\n+pub type uv_async_t = {\n     fields: uv_handle_fields,\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n     a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n     a08: *u8, a09: *u8,\n     a11: uv_async_t_32bit_unix_riders\n };\n #[cfg(target_arch=\"x86_64\")]\n-type uv_async_t_32bit_unix_riders = {\n+pub type uv_async_t_32bit_unix_riders = {\n     a10: *u8\n };\n #[cfg(target_arch=\"x86\")]\n-type uv_async_t_32bit_unix_riders = {\n+pub type uv_async_t_32bit_unix_riders = {\n     a10: *u8, a11: *u8, a12: *u8, a13: *u8\n };\n // win32 size 132 (68)\n #[cfg(windows)]\n-type uv_async_t = {\n+pub type uv_async_t = {\n     fields: uv_handle_fields,\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n     a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n@@ -194,33 +194,33 @@ type uv_async_t = {\n // 64bit unix size: 128\n // 32bit unix size: 84\n #[cfg(unix)]\n-type uv_timer_t = {\n+pub type uv_timer_t = {\n     fields: uv_handle_fields,\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n     a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n     a08: *u8, a09: *u8,\n     a11: uv_timer_t_32bit_unix_riders\n };\n #[cfg(target_arch=\"x86_64\")]\n-type uv_timer_t_32bit_unix_riders = {\n+pub type uv_timer_t_32bit_unix_riders = {\n     a10: *u8, a11: *u8\n };\n #[cfg(target_arch=\"x86\")]\n-type uv_timer_t_32bit_unix_riders = {\n+pub type uv_timer_t_32bit_unix_riders = {\n     a10: *u8, a11: *u8, a12: *u8, a13: *u8,\n     a14: *u8, a15: *u8, a16: *u8\n };\n // win32 size: 64\n #[cfg(windows)]\n-type uv_timer_t = {\n+pub type uv_timer_t = {\n     fields: uv_handle_fields,\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n     a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n     a08: *u8, a09: *u8, a10: *u8, a11: *u8\n };\n \n // unix size: 16\n-type sockaddr_in = {\n+pub type sockaddr_in = {\n     mut sin_family: u16,\n     mut sin_port: u16,\n     mut sin_addr: u32, // in_addr: this is an opaque, per-platform struct\n@@ -230,12 +230,12 @@ type sockaddr_in = {\n // unix size: 28 .. FIXME #1645\n // stuck with 32 becuse of rust padding structs?\n #[cfg(target_arch=\"x86_64\")]\n-type sockaddr_in6 = {\n+pub type sockaddr_in6 = {\n     a0: *u8, a1: *u8,\n     a2: *u8, a3: *u8\n };\n #[cfg(target_arch=\"x86\")]\n-type sockaddr_in6 = {\n+pub type sockaddr_in6 = {\n     a0: *u8, a1: *u8,\n     a2: *u8, a3: *u8,\n     a4: *u8, a5: *u8,\n@@ -244,83 +244,77 @@ type sockaddr_in6 = {\n \n // unix size: 28 .. FIXME #1645\n // stuck with 32 becuse of rust padding structs?\n-type addr_in = addr_in_impl::addr_in;\n+pub type addr_in = addr_in_impl::addr_in;\n #[cfg(unix)]\n-mod addr_in_impl {\n-    #[legacy_exports];\n+pub mod addr_in_impl {\n     #[cfg(target_arch=\"x86_64\")]\n-    type addr_in = {\n+    pub type addr_in = {\n         a0: *u8, a1: *u8,\n         a2: *u8, a3: *u8\n     };\n     #[cfg(target_arch=\"x86\")]\n-    type addr_in = {\n+    pub type addr_in = {\n         a0: *u8, a1: *u8,\n         a2: *u8, a3: *u8,\n         a4: *u8, a5: *u8,\n         a6: *u8, a7: *u8,\n     };\n }\n #[cfg(windows)]\n-mod addr_in_impl {\n-    #[legacy_exports];\n-    type addr_in = {\n+pub mod addr_in_impl {\n+    pub type addr_in = {\n         a0: *u8, a1: *u8,\n         a2: *u8, a3: *u8\n     };\n }\n \n // unix size: 48, 32bit: 32\n-type addrinfo = addrinfo_impl::addrinfo;\n+pub type addrinfo = addrinfo_impl::addrinfo;\n #[cfg(target_os=\"linux\")]\n-mod addrinfo_impl {\n-    #[legacy_exports];\n+pub mod addrinfo_impl {\n     #[cfg(target_arch=\"x86_64\")]\n-    type addrinfo = {\n+    pub type addrinfo = {\n         a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n         a04: *u8, a05: *u8\n     };\n     #[cfg(target_arch=\"x86\")]\n-    type addrinfo = {\n+    pub type addrinfo = {\n         a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n         a04: *u8, a05: *u8, a06: *u8, a07: *u8\n     };\n }\n #[cfg(target_os=\"macos\")]\n #[cfg(target_os=\"freebsd\")]\n-mod addrinfo_impl {\n-    #[legacy_exports];\n-    type addrinfo = {\n+pub mod addrinfo_impl {\n+    pub type addrinfo = {\n         a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n         a04: *u8, a05: *u8\n     };\n }\n #[cfg(windows)]\n-mod addrinfo_impl {\n-    #[legacy_exports];\n-    type addrinfo = {\n+pub mod addrinfo_impl {\n+    pub type addrinfo = {\n         a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n         a04: *u8, a05: *u8\n     };\n }\n \n // unix size: 72\n-type uv_getaddrinfo_t = {\n+pub type uv_getaddrinfo_t = {\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8, a04: *u8, a05: *u8,\n     a06: *u8, a07: *u8, a08: *u8\n };\n \n-mod uv_ll_struct_stubgen {\n-    #[legacy_exports];\n-    fn gen_stub_uv_tcp_t() -> uv_tcp_t {\n+pub mod uv_ll_struct_stubgen {\n+    pub fn gen_stub_uv_tcp_t() -> uv_tcp_t {\n         return gen_stub_os();\n         #[cfg(target_os = \"linux\")]\n         #[cfg(target_os = \"macos\")]\n         #[cfg(target_os = \"freebsd\")]\n-        fn gen_stub_os() -> uv_tcp_t {\n+        pub fn gen_stub_os() -> uv_tcp_t {\n             return gen_stub_arch();\n             #[cfg(target_arch=\"x86_64\")]\n-            fn gen_stub_arch() -> uv_tcp_t {\n+            pub fn gen_stub_arch() -> uv_tcp_t {\n                 return { fields: { loop_handle: ptr::null(), type_: 0u32,\n                                 close_cb: ptr::null(),\n                                 mut data: ptr::null() },\n@@ -345,7 +339,7 @@ mod uv_ll_struct_stubgen {\n                 };\n             }\n             #[cfg(target_arch=\"x86\")]\n-            fn gen_stub_arch() -> uv_tcp_t {\n+            pub fn gen_stub_arch() -> uv_tcp_t {\n                 return { fields: { loop_handle: ptr::null(), type_: 0u32,\n                                 close_cb: ptr::null(),\n                                 mut data: ptr::null() },\n@@ -373,7 +367,7 @@ mod uv_ll_struct_stubgen {\n             }\n         }\n         #[cfg(windows)]\n-        fn gen_stub_os() -> uv_tcp_t {\n+        pub fn gen_stub_os() -> uv_tcp_t {\n             return { fields: { loop_handle: ptr::null(), type_: 0u32,\n                             close_cb: ptr::null(),\n                             mut data: ptr::null() },\n@@ -394,15 +388,15 @@ mod uv_ll_struct_stubgen {\n         }\n     }\n     #[cfg(unix)]\n-    fn gen_stub_uv_connect_t() -> uv_connect_t {\n+    pub fn gen_stub_uv_connect_t() -> uv_connect_t {\n         return {\n             a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n             a03: 0 as *u8,\n             a04: 0 as *u8, a05: 0 as *u8\n         };\n     }\n     #[cfg(windows)]\n-    fn gen_stub_uv_connect_t() -> uv_connect_t {\n+    pub fn gen_stub_uv_connect_t() -> uv_connect_t {\n         return {\n             a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n             a03: 0 as *u8,\n@@ -412,10 +406,10 @@ mod uv_ll_struct_stubgen {\n         };\n     }\n     #[cfg(unix)]\n-    fn gen_stub_uv_async_t() -> uv_async_t {\n+    pub fn gen_stub_uv_async_t() -> uv_async_t {\n         return gen_stub_arch();\n         #[cfg(target_arch = \"x86_64\")]\n-        fn gen_stub_arch() -> uv_async_t {\n+        pub fn gen_stub_arch() -> uv_async_t {\n             return { fields: { loop_handle: ptr::null(), type_: 0u32,\n                             close_cb: ptr::null(),\n                             mut data: ptr::null() },\n@@ -430,7 +424,7 @@ mod uv_ll_struct_stubgen {\n             };\n         }\n         #[cfg(target_arch = \"x86\")]\n-        fn gen_stub_arch() -> uv_async_t {\n+        pub fn gen_stub_arch() -> uv_async_t {\n             return { fields: { loop_handle: ptr::null(), type_: 0u32,\n                             close_cb: ptr::null(),\n                             mut data: ptr::null() },\n@@ -447,7 +441,7 @@ mod uv_ll_struct_stubgen {\n         }\n     }\n     #[cfg(windows)]\n-    fn gen_stub_uv_async_t() -> uv_async_t {\n+    pub fn gen_stub_uv_async_t() -> uv_async_t {\n         return { fields: { loop_handle: ptr::null(), type_: 0u32,\n                         close_cb: ptr::null(),\n                         mut data: ptr::null() },\n@@ -461,10 +455,10 @@ mod uv_ll_struct_stubgen {\n         };\n     }\n     #[cfg(unix)]\n-    fn gen_stub_uv_timer_t() -> uv_timer_t {\n+    pub fn gen_stub_uv_timer_t() -> uv_timer_t {\n         return gen_stub_arch();\n         #[cfg(target_arch = \"x86_64\")]\n-        fn gen_stub_arch() -> uv_timer_t {\n+        pub fn gen_stub_arch() -> uv_timer_t {\n             return { fields: { loop_handle: ptr::null(), type_: 0u32,\n                             close_cb: ptr::null(),\n                             mut data: ptr::null() },\n@@ -479,7 +473,7 @@ mod uv_ll_struct_stubgen {\n             };\n         }\n         #[cfg(target_arch = \"x86\")]\n-        fn gen_stub_arch() -> uv_timer_t {\n+        pub fn gen_stub_arch() -> uv_timer_t {\n             return { fields: { loop_handle: ptr::null(), type_: 0u32,\n                             close_cb: ptr::null(),\n                             mut data: ptr::null() },\n@@ -498,7 +492,7 @@ mod uv_ll_struct_stubgen {\n         }\n     }\n     #[cfg(windows)]\n-    fn gen_stub_uv_timer_t() -> uv_timer_t {\n+    pub fn gen_stub_uv_timer_t() -> uv_timer_t {\n         return { fields: { loop_handle: ptr::null(), type_: 0u32,\n                         close_cb: ptr::null(),\n                         mut data: ptr::null() },\n@@ -511,10 +505,10 @@ mod uv_ll_struct_stubgen {\n         };\n     }\n     #[cfg(unix)]\n-    fn gen_stub_uv_write_t() -> uv_write_t {\n+    pub fn gen_stub_uv_write_t() -> uv_write_t {\n         return gen_stub_arch();\n         #[cfg(target_arch=\"x86_64\")]\n-        fn gen_stub_arch() -> uv_write_t {\n+        pub fn gen_stub_arch() -> uv_write_t {\n             return { fields: { loop_handle: ptr::null(), type_: 0u32,\n                             close_cb: ptr::null(),\n                             mut data: ptr::null() },\n@@ -528,7 +522,7 @@ mod uv_ll_struct_stubgen {\n             };\n         }\n         #[cfg(target_arch=\"x86\")]\n-        fn gen_stub_arch() -> uv_write_t {\n+        pub fn gen_stub_arch() -> uv_write_t {\n             return { fields: { loop_handle: ptr::null(), type_: 0u32,\n                             close_cb: ptr::null(),\n                             mut data: ptr::null() },\n@@ -543,7 +537,7 @@ mod uv_ll_struct_stubgen {\n         }\n     }\n     #[cfg(windows)]\n-    fn gen_stub_uv_write_t() -> uv_write_t {\n+    pub fn gen_stub_uv_write_t() -> uv_write_t {\n         return { fields: { loop_handle: ptr::null(), type_: 0u32,\n                         close_cb: ptr::null(),\n                         mut data: ptr::null() },\n@@ -556,7 +550,7 @@ mod uv_ll_struct_stubgen {\n             a12: 0 as *u8\n         };\n     }\n-    fn gen_stub_uv_getaddrinfo_t() -> uv_getaddrinfo_t {\n+    pub fn gen_stub_uv_getaddrinfo_t() -> uv_getaddrinfo_t {\n         {\n             a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8, a03: 0 as *u8,\n             a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8, a07: 0 as *u8,\n@@ -567,7 +561,6 @@ mod uv_ll_struct_stubgen {\n \n #[nolink]\n extern mod rustrt {\n-    #[legacy_exports];\n     // libuv public API\n     fn rust_uv_loop_new() -> *libc::c_void;\n     fn rust_uv_loop_delete(lp: *libc::c_void);\n@@ -686,32 +679,32 @@ extern mod rustrt {\n     fn rust_uv_helper_addr_in_size() -> libc::c_uint;\n }\n \n-unsafe fn loop_new() -> *libc::c_void {\n+pub unsafe fn loop_new() -> *libc::c_void {\n     return rustrt::rust_uv_loop_new();\n }\n \n-unsafe fn loop_delete(loop_handle: *libc::c_void) {\n+pub unsafe fn loop_delete(loop_handle: *libc::c_void) {\n     rustrt::rust_uv_loop_delete(loop_handle);\n }\n \n-unsafe fn loop_refcount(loop_ptr: *libc::c_void) -> libc::c_int {\n+pub unsafe fn loop_refcount(loop_ptr: *libc::c_void) -> libc::c_int {\n     return rustrt::rust_uv_loop_refcount(loop_ptr);\n }\n \n-unsafe fn run(loop_handle: *libc::c_void) {\n+pub unsafe fn run(loop_handle: *libc::c_void) {\n     rustrt::rust_uv_run(loop_handle);\n }\n \n-unsafe fn close<T>(handle: *T, cb: *u8) {\n+pub unsafe fn close<T>(handle: *T, cb: *u8) {\n     rustrt::rust_uv_close(handle as *libc::c_void, cb);\n }\n \n-unsafe fn tcp_init(loop_handle: *libc::c_void, handle: *uv_tcp_t)\n+pub unsafe fn tcp_init(loop_handle: *libc::c_void, handle: *uv_tcp_t)\n     -> libc::c_int {\n     return rustrt::rust_uv_tcp_init(loop_handle, handle);\n }\n // FIXME ref #2064\n-unsafe fn tcp_connect(connect_ptr: *uv_connect_t,\n+pub unsafe fn tcp_connect(connect_ptr: *uv_connect_t,\n                       tcp_handle_ptr: *uv_tcp_t,\n                       addr_ptr: *sockaddr_in,\n                       after_connect_cb: *u8)\n@@ -722,7 +715,7 @@ unsafe fn tcp_connect(connect_ptr: *uv_connect_t,\n                                     after_connect_cb, addr_ptr);\n }\n // FIXME ref #2064\n-unsafe fn tcp_connect6(connect_ptr: *uv_connect_t,\n+pub unsafe fn tcp_connect6(connect_ptr: *uv_connect_t,\n                       tcp_handle_ptr: *uv_tcp_t,\n                       addr_ptr: *sockaddr_in6,\n                       after_connect_cb: *u8)\n@@ -731,70 +724,70 @@ unsafe fn tcp_connect6(connect_ptr: *uv_connect_t,\n                                     after_connect_cb, addr_ptr);\n }\n // FIXME ref #2064\n-unsafe fn tcp_bind(tcp_server_ptr: *uv_tcp_t,\n+pub unsafe fn tcp_bind(tcp_server_ptr: *uv_tcp_t,\n                    addr_ptr: *sockaddr_in) -> libc::c_int {\n     return rustrt::rust_uv_tcp_bind(tcp_server_ptr,\n                                  addr_ptr);\n }\n // FIXME ref #2064\n-unsafe fn tcp_bind6(tcp_server_ptr: *uv_tcp_t,\n+pub unsafe fn tcp_bind6(tcp_server_ptr: *uv_tcp_t,\n                    addr_ptr: *sockaddr_in6) -> libc::c_int {\n     return rustrt::rust_uv_tcp_bind6(tcp_server_ptr,\n                                  addr_ptr);\n }\n \n-unsafe fn listen<T>(stream: *T, backlog: libc::c_int,\n+pub unsafe fn listen<T>(stream: *T, backlog: libc::c_int,\n                  cb: *u8) -> libc::c_int {\n     return rustrt::rust_uv_listen(stream as *libc::c_void, backlog, cb);\n }\n \n-unsafe fn accept(server: *libc::c_void, client: *libc::c_void)\n+pub unsafe fn accept(server: *libc::c_void, client: *libc::c_void)\n     -> libc::c_int {\n     return rustrt::rust_uv_accept(server as *libc::c_void,\n                                client as *libc::c_void);\n }\n \n-unsafe fn write<T>(req: *uv_write_t, stream: *T,\n+pub unsafe fn write<T>(req: *uv_write_t, stream: *T,\n          buf_in: *~[uv_buf_t], cb: *u8) -> libc::c_int {\n     let buf_ptr = vec::raw::to_ptr(*buf_in);\n     let buf_cnt = vec::len(*buf_in) as i32;\n     return rustrt::rust_uv_write(req as *libc::c_void,\n                               stream as *libc::c_void,\n                               buf_ptr, buf_cnt, cb);\n }\n-unsafe fn read_start(stream: *uv_stream_t, on_alloc: *u8,\n+pub unsafe fn read_start(stream: *uv_stream_t, on_alloc: *u8,\n                      on_read: *u8) -> libc::c_int {\n     return rustrt::rust_uv_read_start(stream as *libc::c_void,\n                                    on_alloc, on_read);\n }\n \n-unsafe fn read_stop(stream: *uv_stream_t) -> libc::c_int {\n+pub unsafe fn read_stop(stream: *uv_stream_t) -> libc::c_int {\n     return rustrt::rust_uv_read_stop(stream as *libc::c_void);\n }\n \n-unsafe fn last_error(loop_handle: *libc::c_void) -> uv_err_t {\n+pub unsafe fn last_error(loop_handle: *libc::c_void) -> uv_err_t {\n     return rustrt::rust_uv_last_error(loop_handle);\n }\n \n-unsafe fn strerror(err: *uv_err_t) -> *libc::c_char {\n+pub unsafe fn strerror(err: *uv_err_t) -> *libc::c_char {\n     return rustrt::rust_uv_strerror(err);\n }\n-unsafe fn err_name(err: *uv_err_t) -> *libc::c_char {\n+pub unsafe fn err_name(err: *uv_err_t) -> *libc::c_char {\n     return rustrt::rust_uv_err_name(err);\n }\n \n-unsafe fn async_init(loop_handle: *libc::c_void,\n+pub unsafe fn async_init(loop_handle: *libc::c_void,\n                      async_handle: *uv_async_t,\n                      cb: *u8) -> libc::c_int {\n     return rustrt::rust_uv_async_init(loop_handle,\n                                    async_handle,\n                                    cb);\n }\n \n-unsafe fn async_send(async_handle: *uv_async_t) {\n+pub unsafe fn async_send(async_handle: *uv_async_t) {\n     return rustrt::rust_uv_async_send(async_handle);\n }\n-unsafe fn buf_init(input: *u8, len: uint) -> uv_buf_t {\n+pub unsafe fn buf_init(input: *u8, len: uint) -> uv_buf_t {\n     let out_buf = { base: ptr::null(), len: 0 as libc::size_t };\n     let out_buf_ptr = ptr::addr_of(&out_buf);\n     log(debug, fmt!(\"buf_init - input %u len %u out_buf: %u\",\n@@ -814,21 +807,21 @@ unsafe fn buf_init(input: *u8, len: uint) -> uv_buf_t {\n     return out_buf;\n     //return result;\n }\n-unsafe fn ip4_addr(ip: &str, port: int)\n+pub unsafe fn ip4_addr(ip: &str, port: int)\n -> sockaddr_in {\n     do str::as_c_str(ip) |ip_buf| {\n         rustrt::rust_uv_ip4_addr(ip_buf as *u8,\n                                  port as libc::c_int)\n     }\n }\n-unsafe fn ip6_addr(ip: &str, port: int)\n+pub unsafe fn ip6_addr(ip: &str, port: int)\n -> sockaddr_in6 {\n     do str::as_c_str(ip) |ip_buf| {\n         rustrt::rust_uv_ip6_addr(ip_buf as *u8,\n                                  port as libc::c_int)\n     }\n }\n-unsafe fn ip4_name(src: &sockaddr_in) -> ~str {\n+pub unsafe fn ip4_name(src: &sockaddr_in) -> ~str {\n     // ipv4 addr max size: 15 + 1 trailing null byte\n     let dst: ~[u8] = ~[0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n                      0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8];\n@@ -844,7 +837,7 @@ unsafe fn ip4_name(src: &sockaddr_in) -> ~str {\n         str::raw::from_buf(dst_buf)\n     }\n }\n-unsafe fn ip6_name(src: &sockaddr_in6) -> ~str {\n+pub unsafe fn ip6_name(src: &sockaddr_in6) -> ~str {\n     // ipv6 addr max size: 45 + 1 trailing null byte\n     let dst: ~[u8] = ~[0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n                        0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n@@ -865,19 +858,19 @@ unsafe fn ip6_name(src: &sockaddr_in6) -> ~str {\n     }\n }\n \n-unsafe fn timer_init(loop_ptr: *libc::c_void,\n+pub unsafe fn timer_init(loop_ptr: *libc::c_void,\n                      timer_ptr: *uv_timer_t) -> libc::c_int {\n     return rustrt::rust_uv_timer_init(loop_ptr, timer_ptr);\n }\n-unsafe fn timer_start(timer_ptr: *uv_timer_t, cb: *u8, timeout: uint,\n+pub unsafe fn timer_start(timer_ptr: *uv_timer_t, cb: *u8, timeout: uint,\n                       repeat: uint) -> libc::c_int {\n     return rustrt::rust_uv_timer_start(timer_ptr, cb, timeout as libc::c_uint,\n                                     repeat as libc::c_uint);\n }\n-unsafe fn timer_stop(timer_ptr: *uv_timer_t) -> libc::c_int {\n+pub unsafe fn timer_stop(timer_ptr: *uv_timer_t) -> libc::c_int {\n     return rustrt::rust_uv_timer_stop(timer_ptr);\n }\n-unsafe fn getaddrinfo(loop_ptr: *libc::c_void,\n+pub unsafe fn getaddrinfo(loop_ptr: *libc::c_void,\n                            handle: *uv_getaddrinfo_t,\n                            cb: *u8,\n                            node_name_ptr: *u8,\n@@ -890,83 +883,84 @@ unsafe fn getaddrinfo(loop_ptr: *libc::c_void,\n                            service_name_ptr,\n                            hints)\n }\n-unsafe fn freeaddrinfo(res: *addrinfo) {\n+pub unsafe fn freeaddrinfo(res: *addrinfo) {\n     rustrt::rust_uv_freeaddrinfo(res);\n }\n \n // libuv struct initializers\n-unsafe fn tcp_t() -> uv_tcp_t {\n+pub unsafe fn tcp_t() -> uv_tcp_t {\n     return uv_ll_struct_stubgen::gen_stub_uv_tcp_t();\n }\n-unsafe fn connect_t() -> uv_connect_t {\n+pub unsafe fn connect_t() -> uv_connect_t {\n     return uv_ll_struct_stubgen::gen_stub_uv_connect_t();\n }\n-unsafe fn write_t() -> uv_write_t {\n+pub unsafe fn write_t() -> uv_write_t {\n     return uv_ll_struct_stubgen::gen_stub_uv_write_t();\n }\n-unsafe fn async_t() -> uv_async_t {\n+pub unsafe fn async_t() -> uv_async_t {\n     return uv_ll_struct_stubgen::gen_stub_uv_async_t();\n }\n-unsafe fn timer_t() -> uv_timer_t {\n+pub unsafe fn timer_t() -> uv_timer_t {\n     return uv_ll_struct_stubgen::gen_stub_uv_timer_t();\n }\n-unsafe fn getaddrinfo_t() -> uv_getaddrinfo_t {\n+pub unsafe fn getaddrinfo_t() -> uv_getaddrinfo_t {\n     return uv_ll_struct_stubgen::gen_stub_uv_getaddrinfo_t();\n }\n \n // data access helpers\n-unsafe fn get_loop_for_uv_handle<T>(handle: *T)\n+pub unsafe fn get_loop_for_uv_handle<T>(handle: *T)\n     -> *libc::c_void {\n     return rustrt::rust_uv_get_loop_for_uv_handle(handle as *libc::c_void);\n }\n-unsafe fn get_stream_handle_from_connect_req(connect: *uv_connect_t)\n+pub unsafe fn get_stream_handle_from_connect_req(connect: *uv_connect_t)\n     -> *uv_stream_t {\n     return rustrt::rust_uv_get_stream_handle_from_connect_req(\n         connect);\n }\n-unsafe fn get_stream_handle_from_write_req(\n+pub unsafe fn get_stream_handle_from_write_req(\n     write_req: *uv_write_t)\n     -> *uv_stream_t {\n     return rustrt::rust_uv_get_stream_handle_from_write_req(\n         write_req);\n }\n-unsafe fn get_data_for_uv_loop(loop_ptr: *libc::c_void) -> *libc::c_void {\n+pub unsafe fn get_data_for_uv_loop(loop_ptr: *libc::c_void) -> *libc::c_void {\n     rustrt::rust_uv_get_data_for_uv_loop(loop_ptr)\n }\n-unsafe fn set_data_for_uv_loop(loop_ptr: *libc::c_void, data: *libc::c_void) {\n+pub unsafe fn set_data_for_uv_loop(loop_ptr: *libc::c_void,\n+                                   data: *libc::c_void) {\n     rustrt::rust_uv_set_data_for_uv_loop(loop_ptr, data);\n }\n-unsafe fn get_data_for_uv_handle<T>(handle: *T) -> *libc::c_void {\n+pub unsafe fn get_data_for_uv_handle<T>(handle: *T) -> *libc::c_void {\n     return rustrt::rust_uv_get_data_for_uv_handle(handle as *libc::c_void);\n }\n-unsafe fn set_data_for_uv_handle<T, U>(handle: *T,\n+pub unsafe fn set_data_for_uv_handle<T, U>(handle: *T,\n                     data: *U) {\n     rustrt::rust_uv_set_data_for_uv_handle(handle as *libc::c_void,\n                                            data as *libc::c_void);\n }\n-unsafe fn get_data_for_req<T>(req: *T) -> *libc::c_void {\n+pub unsafe fn get_data_for_req<T>(req: *T) -> *libc::c_void {\n     return rustrt::rust_uv_get_data_for_req(req as *libc::c_void);\n }\n-unsafe fn set_data_for_req<T, U>(req: *T,\n+pub unsafe fn set_data_for_req<T, U>(req: *T,\n                     data: *U) {\n     rustrt::rust_uv_set_data_for_req(req as *libc::c_void,\n                                      data as *libc::c_void);\n }\n-unsafe fn get_base_from_buf(buf: uv_buf_t) -> *u8 {\n+pub unsafe fn get_base_from_buf(buf: uv_buf_t) -> *u8 {\n     return rustrt::rust_uv_get_base_from_buf(buf);\n }\n-unsafe fn get_len_from_buf(buf: uv_buf_t) -> libc::size_t {\n+pub unsafe fn get_len_from_buf(buf: uv_buf_t) -> libc::size_t {\n     return rustrt::rust_uv_get_len_from_buf(buf);\n }\n-unsafe fn malloc_buf_base_of(suggested_size: libc::size_t)\n+pub unsafe fn malloc_buf_base_of(suggested_size: libc::size_t)\n     -> *u8 {\n     return rustrt::rust_uv_malloc_buf_base_of(suggested_size);\n }\n-unsafe fn free_base_of_buf(buf: uv_buf_t) {\n+pub unsafe fn free_base_of_buf(buf: uv_buf_t) {\n     rustrt::rust_uv_free_base_of_buf(buf);\n }\n \n-unsafe fn get_last_err_info(uv_loop: *libc::c_void) -> ~str {\n+pub unsafe fn get_last_err_info(uv_loop: *libc::c_void) -> ~str {\n     let err = last_error(uv_loop);\n     let err_ptr = ptr::addr_of(&err);\n     let err_name = str::raw::from_c_str(err_name(err_ptr));\n@@ -975,41 +969,41 @@ unsafe fn get_last_err_info(uv_loop: *libc::c_void) -> ~str {\n                     err_name, err_msg);\n }\n \n-unsafe fn get_last_err_data(uv_loop: *libc::c_void) -> uv_err_data {\n+pub unsafe fn get_last_err_data(uv_loop: *libc::c_void) -> uv_err_data {\n     let err = last_error(uv_loop);\n     let err_ptr = ptr::addr_of(&err);\n     let err_name = str::raw::from_c_str(err_name(err_ptr));\n     let err_msg = str::raw::from_c_str(strerror(err_ptr));\n     { err_name: err_name, err_msg: err_msg }\n }\n \n-type uv_err_data = {\n+pub type uv_err_data = {\n     err_name: ~str,\n     err_msg: ~str\n };\n \n-unsafe fn is_ipv4_addrinfo(input: *addrinfo) -> bool {\n+pub unsafe fn is_ipv4_addrinfo(input: *addrinfo) -> bool {\n     rustrt::rust_uv_is_ipv4_addrinfo(input)\n }\n-unsafe fn is_ipv6_addrinfo(input: *addrinfo) -> bool {\n+pub unsafe fn is_ipv6_addrinfo(input: *addrinfo) -> bool {\n     rustrt::rust_uv_is_ipv6_addrinfo(input)\n }\n-unsafe fn get_INADDR_NONE() -> u32 {\n+pub unsafe fn get_INADDR_NONE() -> u32 {\n     rustrt::rust_uv_helper_get_INADDR_NONE()\n }\n-unsafe fn get_next_addrinfo(input: *addrinfo) -> *addrinfo {\n+pub unsafe fn get_next_addrinfo(input: *addrinfo) -> *addrinfo {\n     rustrt::rust_uv_get_next_addrinfo(input)\n }\n-unsafe fn addrinfo_as_sockaddr_in(input: *addrinfo) -> *sockaddr_in {\n+pub unsafe fn addrinfo_as_sockaddr_in(input: *addrinfo) -> *sockaddr_in {\n     rustrt::rust_uv_addrinfo_as_sockaddr_in(input)\n }\n-unsafe fn addrinfo_as_sockaddr_in6(input: *addrinfo) -> *sockaddr_in6 {\n+pub unsafe fn addrinfo_as_sockaddr_in6(input: *addrinfo) -> *sockaddr_in6 {\n     rustrt::rust_uv_addrinfo_as_sockaddr_in6(input)\n }\n \n #[cfg(test)]\n-mod test {\n-    #[legacy_exports];\n+pub mod test {\n+\n     enum tcp_read_data {\n         tcp_read_eof,\n         tcp_read_more(~[u8]),\n@@ -1510,22 +1504,19 @@ mod test {\n     #[cfg(target_os=\"win32\")]\n     #[cfg(target_os=\"darwin\")]\n     #[cfg(target_os=\"linux\")]\n-    mod tcp_and_server_client_test {\n-        #[legacy_exports];\n+    pub mod tcp_and_server_client_test {\n         #[cfg(target_arch=\"x86_64\")]\n-        mod impl64 {\n-            #[legacy_exports];\n+        pub mod impl64 {\n             #[test]\n-            fn test_uv_ll_tcp_server_and_request() unsafe {\n+            pub fn test_uv_ll_tcp_server_and_request() unsafe {\n                 impl_uv_tcp_server_and_request();\n             }\n         }\n         #[cfg(target_arch=\"x86\")]\n-        mod impl32 {\n-            #[legacy_exports];\n+        pub mod impl32 {\n             #[test]\n             #[ignore(cfg(target_os = \"linux\"))]\n-            fn test_uv_ll_tcp_server_and_request() unsafe {\n+            pub fn test_uv_ll_tcp_server_and_request() unsafe {\n                 impl_uv_tcp_server_and_request();\n             }\n         }"}]}