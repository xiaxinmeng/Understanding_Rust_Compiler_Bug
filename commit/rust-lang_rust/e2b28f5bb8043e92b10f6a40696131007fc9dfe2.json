{"sha": "e2b28f5bb8043e92b10f6a40696131007fc9dfe2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyYjI4ZjViYjgwNDNlOTJiMTBmNmE0MDY5NjEzMTAwN2ZjOWRmZTI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-07-19T07:43:01Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-07-19T10:16:25Z"}, "message": "migrate ra_hir to the new rowan", "tree": {"sha": "c14306038e386d71ddc894d63415bf8e9a94f7e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c14306038e386d71ddc894d63415bf8e9a94f7e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2b28f5bb8043e92b10f6a40696131007fc9dfe2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2b28f5bb8043e92b10f6a40696131007fc9dfe2", "html_url": "https://github.com/rust-lang/rust/commit/e2b28f5bb8043e92b10f6a40696131007fc9dfe2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e02aa0efff228126ffc43e81e5e127e1b9e32dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e02aa0efff228126ffc43e81e5e127e1b9e32dd", "html_url": "https://github.com/rust-lang/rust/commit/7e02aa0efff228126ffc43e81e5e127e1b9e32dd"}], "stats": {"total": 416, "additions": 206, "deletions": 210}, "files": [{"sha": "c65446df4a486b4fceb0a97776c93c3cf683d185", "filename": "crates/ra_hir/src/adt.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=e2b28f5bb8043e92b10f6a40696131007fc9dfe2", "patch": "@@ -4,10 +4,7 @@\n use std::sync::Arc;\n \n use ra_arena::{impl_arena_id, Arena, RawId};\n-use ra_syntax::{\n-    ast::{self, NameOwner, StructKind, TypeAscriptionOwner},\n-    TreeArc,\n-};\n+use ra_syntax::ast::{self, NameOwner, StructKind, TypeAscriptionOwner};\n \n use crate::{\n     type_ref::TypeRef, AsName, AstDatabase, Crate, DefDatabase, Enum, EnumVariant, FieldSource,\n@@ -59,21 +56,21 @@ impl StructData {\n         struct_: Struct,\n     ) -> Arc<StructData> {\n         let src = struct_.source(db);\n-        Arc::new(StructData::new(&*src.ast))\n+        Arc::new(StructData::new(&src.ast))\n     }\n }\n \n-fn variants(enum_def: &ast::EnumDef) -> impl Iterator<Item = &ast::EnumVariant> {\n+fn variants(enum_def: &ast::EnumDef) -> impl Iterator<Item = ast::EnumVariant> {\n     enum_def.variant_list().into_iter().flat_map(|it| it.variants())\n }\n \n impl EnumVariant {\n     pub(crate) fn source_impl(\n         self,\n         db: &(impl DefDatabase + AstDatabase),\n-    ) -> Source<TreeArc<ast::EnumVariant>> {\n+    ) -> Source<ast::EnumVariant> {\n         let src = self.parent.source(db);\n-        let ast = variants(&*src.ast)\n+        let ast = variants(&src.ast)\n             .zip(db.enum_data(self.parent).variants.iter())\n             .find(|(_syntax, (id, _))| *id == self.id)\n             .unwrap()\n@@ -96,7 +93,7 @@ impl EnumData {\n     pub(crate) fn enum_data_query(db: &(impl DefDatabase + AstDatabase), e: Enum) -> Arc<EnumData> {\n         let src = e.source(db);\n         let name = src.ast.name().map(|n| n.as_name());\n-        let variants = variants(&*src.ast)\n+        let variants = variants(&src.ast)\n             .map(|var| EnumVariantData {\n                 name: var.name().map(|it| it.as_name()),\n                 variant_data: Arc::new(VariantData::new(var.kind())),"}, {"sha": "779764590cab63873df4b82f762eaf4e431bd5c5", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=e2b28f5bb8043e92b10f6a40696131007fc9dfe2", "patch": "@@ -4,10 +4,7 @@ pub(crate) mod docs;\n use std::sync::Arc;\n \n use ra_db::{CrateId, Edition, FileId, SourceRootId};\n-use ra_syntax::{\n-    ast::{self, NameOwner, TypeAscriptionOwner},\n-    TreeArc,\n-};\n+use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n \n use crate::{\n     adt::{EnumVariantId, StructFieldId, VariantDef},\n@@ -155,8 +152,8 @@ impl_froms!(\n );\n \n pub enum ModuleSource {\n-    SourceFile(TreeArc<ast::SourceFile>),\n-    Module(TreeArc<ast::Module>),\n+    SourceFile(ast::SourceFile),\n+    Module(ast::Module),\n }\n \n impl ModuleSource {\n@@ -199,7 +196,7 @@ impl Module {\n         self,\n         db: &impl HirDatabase,\n         import: ImportId,\n-    ) -> Either<TreeArc<ast::UseTree>, TreeArc<ast::ExternCrateItem>> {\n+    ) -> Either<ast::UseTree, ast::ExternCrateItem> {\n         let src = self.definition_source(db);\n         let (_, source_map) = db.raw_items_with_source_map(src.file_id);\n         source_map.get(&src.ast, import)\n@@ -321,8 +318,8 @@ pub struct StructField {\n \n #[derive(Debug)]\n pub enum FieldSource {\n-    Named(TreeArc<ast::NamedFieldDef>),\n-    Pos(TreeArc<ast::PosFieldDef>),\n+    Named(ast::NamedFieldDef),\n+    Pos(ast::PosFieldDef),\n }\n \n impl StructField {\n@@ -736,15 +733,15 @@ impl ConstData {\n         konst: Const,\n     ) -> Arc<ConstData> {\n         let node = konst.source(db).ast;\n-        const_data_for(&*node)\n+        const_data_for(&node)\n     }\n \n     pub(crate) fn static_data_query(\n         db: &(impl DefDatabase + AstDatabase),\n         konst: Static,\n     ) -> Arc<ConstData> {\n         let node = konst.source(db).ast;\n-        const_data_for(&*node)\n+        const_data_for(&node)\n     }\n }\n "}, {"sha": "a2b4d8e9752286a7c19f8a3c5955b00320f9c692", "filename": "crates/ra_hir/src/code_model/docs.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fdocs.rs?ref=e2b28f5bb8043e92b10f6a40696131007fc9dfe2", "patch": "@@ -71,21 +71,21 @@ pub(crate) fn documentation_query(\n     def: DocDef,\n ) -> Option<Documentation> {\n     match def {\n-        DocDef::Module(it) => docs_from_ast(&*it.declaration_source(db)?.ast),\n+        DocDef::Module(it) => docs_from_ast(&it.declaration_source(db)?.ast),\n         DocDef::StructField(it) => match it.source(db).ast {\n-            FieldSource::Named(named) => docs_from_ast(&*named),\n+            FieldSource::Named(named) => docs_from_ast(&named),\n             FieldSource::Pos(..) => None,\n         },\n-        DocDef::Struct(it) => docs_from_ast(&*it.source(db).ast),\n-        DocDef::Enum(it) => docs_from_ast(&*it.source(db).ast),\n-        DocDef::EnumVariant(it) => docs_from_ast(&*it.source(db).ast),\n-        DocDef::Static(it) => docs_from_ast(&*it.source(db).ast),\n-        DocDef::Const(it) => docs_from_ast(&*it.source(db).ast),\n-        DocDef::Function(it) => docs_from_ast(&*it.source(db).ast),\n-        DocDef::Union(it) => docs_from_ast(&*it.source(db).ast),\n-        DocDef::Trait(it) => docs_from_ast(&*it.source(db).ast),\n-        DocDef::TypeAlias(it) => docs_from_ast(&*it.source(db).ast),\n-        DocDef::MacroDef(it) => docs_from_ast(&*it.source(db).ast),\n+        DocDef::Struct(it) => docs_from_ast(&it.source(db).ast),\n+        DocDef::Enum(it) => docs_from_ast(&it.source(db).ast),\n+        DocDef::EnumVariant(it) => docs_from_ast(&it.source(db).ast),\n+        DocDef::Static(it) => docs_from_ast(&it.source(db).ast),\n+        DocDef::Const(it) => docs_from_ast(&it.source(db).ast),\n+        DocDef::Function(it) => docs_from_ast(&it.source(db).ast),\n+        DocDef::Union(it) => docs_from_ast(&it.source(db).ast),\n+        DocDef::Trait(it) => docs_from_ast(&it.source(db).ast),\n+        DocDef::TypeAlias(it) => docs_from_ast(&it.source(db).ast),\n+        DocDef::MacroDef(it) => docs_from_ast(&it.source(db).ast),\n     }\n }\n "}, {"sha": "32bd9c661ee14878deb5b5dd480c8e14b707dc9c", "filename": "crates/ra_hir/src/code_model/src.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs?ref=e2b28f5bb8043e92b10f6a40696131007fc9dfe2", "patch": "@@ -1,4 +1,4 @@\n-use ra_syntax::{ast, TreeArc};\n+use ra_syntax::ast;\n \n use crate::{\n     ids::AstItemDef, AstDatabase, Const, DefDatabase, Enum, EnumVariant, FieldSource, Function,\n@@ -34,7 +34,7 @@ impl Module {\n     pub fn declaration_source(\n         self,\n         db: &(impl DefDatabase + AstDatabase),\n-    ) -> Option<Source<TreeArc<ast::Module>>> {\n+    ) -> Option<Source<ast::Module>> {\n         let def_map = db.crate_def_map(self.krate);\n         let decl = def_map[self.module_id].declaration?;\n         let ast = decl.to_node(db);\n@@ -49,62 +49,62 @@ impl HasSource for StructField {\n     }\n }\n impl HasSource for Struct {\n-    type Ast = TreeArc<ast::StructDef>;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::StructDef>> {\n+    type Ast = ast::StructDef;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::StructDef> {\n         self.id.source(db)\n     }\n }\n impl HasSource for Union {\n-    type Ast = TreeArc<ast::StructDef>;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::StructDef>> {\n+    type Ast = ast::StructDef;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::StructDef> {\n         self.id.source(db)\n     }\n }\n impl HasSource for Enum {\n-    type Ast = TreeArc<ast::EnumDef>;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::EnumDef>> {\n+    type Ast = ast::EnumDef;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::EnumDef> {\n         self.id.source(db)\n     }\n }\n impl HasSource for EnumVariant {\n-    type Ast = TreeArc<ast::EnumVariant>;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::EnumVariant>> {\n+    type Ast = ast::EnumVariant;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::EnumVariant> {\n         self.source_impl(db)\n     }\n }\n impl HasSource for Function {\n-    type Ast = TreeArc<ast::FnDef>;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::FnDef>> {\n+    type Ast = ast::FnDef;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::FnDef> {\n         self.id.source(db)\n     }\n }\n impl HasSource for Const {\n-    type Ast = TreeArc<ast::ConstDef>;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::ConstDef>> {\n+    type Ast = ast::ConstDef;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::ConstDef> {\n         self.id.source(db)\n     }\n }\n impl HasSource for Static {\n-    type Ast = TreeArc<ast::StaticDef>;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::StaticDef>> {\n+    type Ast = ast::StaticDef;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::StaticDef> {\n         self.id.source(db)\n     }\n }\n impl HasSource for Trait {\n-    type Ast = TreeArc<ast::TraitDef>;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::TraitDef>> {\n+    type Ast = ast::TraitDef;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::TraitDef> {\n         self.id.source(db)\n     }\n }\n impl HasSource for TypeAlias {\n-    type Ast = TreeArc<ast::TypeAliasDef>;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::TypeAliasDef>> {\n+    type Ast = ast::TypeAliasDef;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::TypeAliasDef> {\n         self.id.source(db)\n     }\n }\n impl HasSource for MacroDef {\n-    type Ast = TreeArc<ast::MacroCall>;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::MacroCall>> {\n+    type Ast = ast::MacroCall;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::MacroCall> {\n         Source { file_id: self.id.0.file_id(), ast: self.id.0.to_node(db) }\n     }\n }"}, {"sha": "358365176301aae445d6f6e9f7eceeafa97038c1", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=e2b28f5bb8043e92b10f6a40696131007fc9dfe2", "patch": "@@ -2,7 +2,7 @@ use std::sync::Arc;\n \n use parking_lot::Mutex;\n use ra_db::{salsa, SourceDatabase};\n-use ra_syntax::{ast, Parse, SmolStr, SyntaxNode, TreeArc};\n+use ra_syntax::{ast, Parse, SmolStr, SyntaxNode};\n \n use crate::{\n     adt::{EnumData, StructData},\n@@ -62,11 +62,11 @@ pub trait AstDatabase: InternDatabase {\n \n     #[salsa::transparent]\n     #[salsa::invoke(crate::source_id::AstIdMap::file_item_query)]\n-    fn ast_id_to_node(&self, file_id: HirFileId, ast_id: ErasedFileAstId) -> TreeArc<SyntaxNode>;\n+    fn ast_id_to_node(&self, file_id: HirFileId, ast_id: ErasedFileAstId) -> SyntaxNode;\n \n     #[salsa::transparent]\n     #[salsa::invoke(crate::ids::HirFileId::parse_or_expand_query)]\n-    fn parse_or_expand(&self, file_id: HirFileId) -> Option<TreeArc<SyntaxNode>>;\n+    fn parse_or_expand(&self, file_id: HirFileId) -> Option<SyntaxNode>;\n \n     #[salsa::invoke(crate::ids::HirFileId::parse_macro_query)]\n     fn parse_macro(&self, macro_file: ids::MacroFile) -> Option<Parse<SyntaxNode>>;"}, {"sha": "0290483b389729685267d63c73522274e097f113", "filename": "crates/ra_hir/src/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs?ref=e2b28f5bb8043e92b10f6a40696131007fc9dfe2", "patch": "@@ -1,6 +1,6 @@\n use std::{any::Any, fmt};\n \n-use ra_syntax::{ast, AstNode, AstPtr, SyntaxNode, SyntaxNodePtr, TextRange, TreeArc};\n+use ra_syntax::{ast, AstNode, AstPtr, SyntaxNode, SyntaxNodePtr, TextRange};\n use relative_path::RelativePathBuf;\n \n use crate::{HirDatabase, HirFileId, Name};\n@@ -33,9 +33,9 @@ pub trait AstDiagnostic {\n }\n \n impl dyn Diagnostic {\n-    pub fn syntax_node(&self, db: &impl HirDatabase) -> TreeArc<SyntaxNode> {\n+    pub fn syntax_node(&self, db: &impl HirDatabase) -> SyntaxNode {\n         let node = db.parse_or_expand(self.file()).unwrap();\n-        self.syntax_node_ptr().to_node(&*node).to_owned()\n+        self.syntax_node_ptr().to_node(&node)\n     }\n \n     pub fn downcast_ref<D: Diagnostic>(&self) -> Option<&D> {\n@@ -143,11 +143,11 @@ impl Diagnostic for MissingFields {\n }\n \n impl AstDiagnostic for MissingFields {\n-    type AST = TreeArc<ast::NamedFieldList>;\n+    type AST = ast::NamedFieldList;\n \n     fn ast(&self, db: &impl HirDatabase) -> Self::AST {\n         let root = db.parse_or_expand(self.file()).unwrap();\n-        let node = self.syntax_node_ptr().to_node(&*root);\n-        ast::NamedFieldList::cast(&node).unwrap().to_owned()\n+        let node = self.syntax_node_ptr().to_node(&root);\n+        ast::NamedFieldList::cast(node).unwrap()\n     }\n }"}, {"sha": "70af3f119ebf62870a0f5745fd3ca7fc35a24de5", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=e2b28f5bb8043e92b10f6a40696131007fc9dfe2", "patch": "@@ -550,7 +550,7 @@ where\n         self.exprs.alloc(block)\n     }\n \n-    fn collect_expr(&mut self, expr: &ast::Expr) -> ExprId {\n+    fn collect_expr(&mut self, expr: ast::Expr) -> ExprId {\n         let syntax_ptr = SyntaxNodePtr::new(expr.syntax());\n         match expr.kind() {\n             ast::ExprKind::IfExpr(e) => {\n@@ -565,7 +565,8 @@ where\n                         .map(|b| match b {\n                             ast::ElseBranch::Block(it) => self.collect_block(it),\n                             ast::ElseBranch::IfExpr(elif) => {\n-                                let expr: &ast::Expr = ast::Expr::cast(elif.syntax()).unwrap();\n+                                let expr: ast::Expr =\n+                                    ast::Expr::cast(elif.syntax().clone()).unwrap();\n                                 self.collect_expr(expr)\n                             }\n                         })\n@@ -582,7 +583,7 @@ where\n                     let else_branch = e.else_branch().map(|b| match b {\n                         ast::ElseBranch::Block(it) => self.collect_block(it),\n                         ast::ElseBranch::IfExpr(elif) => {\n-                            let expr: &ast::Expr = ast::Expr::cast(elif.syntax()).unwrap();\n+                            let expr: ast::Expr = ast::Expr::cast(elif.syntax().clone()).unwrap();\n                             self.collect_expr(expr)\n                         }\n                     });\n@@ -689,7 +690,7 @@ where\n                 let struct_lit = if let Some(nfl) = e.named_field_list() {\n                     let fields = nfl\n                         .fields()\n-                        .inspect(|field| field_ptrs.push(AstPtr::new(*field)))\n+                        .inspect(|field| field_ptrs.push(AstPtr::new(field)))\n                         .map(|field| StructLitField {\n                             name: field\n                                 .name_ref()\n@@ -699,7 +700,7 @@ where\n                                 self.collect_expr(e)\n                             } else if let Some(nr) = field.name_ref() {\n                                 // field shorthand\n-                                let id = self.exprs.alloc(Expr::Path(Path::from_name_ref(nr)));\n+                                let id = self.exprs.alloc(Expr::Path(Path::from_name_ref(&nr)));\n                                 self.source_map\n                                     .expr_map\n                                     .insert(SyntaxNodePtr::new(nr.syntax()), id);\n@@ -837,19 +838,19 @@ where\n                 let ast_id = self\n                     .db\n                     .ast_id_map(self.current_file_id)\n-                    .ast_id(e)\n+                    .ast_id(&e)\n                     .with_file_id(self.current_file_id);\n \n                 if let Some(path) = e.path().and_then(Path::from_ast) {\n                     if let Some(def) = self.resolver.resolve_path_as_macro(self.db, &path) {\n                         let call_id = MacroCallLoc { def: def.id, ast_id }.id(self.db);\n                         let file_id = call_id.as_file(MacroFileKind::Expr);\n                         if let Some(node) = self.db.parse_or_expand(file_id) {\n-                            if let Some(expr) = ast::Expr::cast(&*node) {\n+                            if let Some(expr) = ast::Expr::cast(node) {\n                                 log::debug!(\"macro expansion {}\", expr.syntax().debug_dump());\n                                 let old_file_id =\n                                     std::mem::replace(&mut self.current_file_id, file_id);\n-                                let id = self.collect_expr(&expr);\n+                                let id = self.collect_expr(expr);\n                                 self.current_file_id = old_file_id;\n                                 return id;\n                             }\n@@ -863,15 +864,15 @@ where\n         }\n     }\n \n-    fn collect_expr_opt(&mut self, expr: Option<&ast::Expr>) -> ExprId {\n+    fn collect_expr_opt(&mut self, expr: Option<ast::Expr>) -> ExprId {\n         if let Some(expr) = expr {\n             self.collect_expr(expr)\n         } else {\n             self.exprs.alloc(Expr::Missing)\n         }\n     }\n \n-    fn collect_block(&mut self, block: &ast::Block) -> ExprId {\n+    fn collect_block(&mut self, block: ast::Block) -> ExprId {\n         let statements = block\n             .statements()\n             .map(|s| match s.kind() {\n@@ -890,15 +891,15 @@ where\n         self.alloc_expr(Expr::Block { statements, tail }, SyntaxNodePtr::new(block.syntax()))\n     }\n \n-    fn collect_block_opt(&mut self, block: Option<&ast::Block>) -> ExprId {\n+    fn collect_block_opt(&mut self, block: Option<ast::Block>) -> ExprId {\n         if let Some(block) = block {\n             self.collect_block(block)\n         } else {\n             self.exprs.alloc(Expr::Missing)\n         }\n     }\n \n-    fn collect_pat(&mut self, pat: &ast::Pat) -> PatId {\n+    fn collect_pat(&mut self, pat: ast::Pat) -> PatId {\n         let pattern = match pat.kind() {\n             ast::PatKind::BindPat(bp) => {\n                 let name = bp.name().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n@@ -932,7 +933,8 @@ where\n                 let mut fields: Vec<_> = field_pat_list\n                     .bind_pats()\n                     .filter_map(|bind_pat| {\n-                        let ast_pat = ast::Pat::cast(bind_pat.syntax()).expect(\"bind pat is a pat\");\n+                        let ast_pat =\n+                            ast::Pat::cast(bind_pat.syntax().clone()).expect(\"bind pat is a pat\");\n                         let pat = self.collect_pat(ast_pat);\n                         let name = bind_pat.name()?.as_name();\n                         Some(FieldPat { name, pat })\n@@ -953,32 +955,32 @@ where\n             ast::PatKind::LiteralPat(_) => Pat::Missing,\n             ast::PatKind::SlicePat(_) | ast::PatKind::RangePat(_) => Pat::Missing,\n         };\n-        let ptr = AstPtr::new(pat);\n+        let ptr = AstPtr::new(&pat);\n         self.alloc_pat(pattern, Either::A(ptr))\n     }\n \n-    fn collect_pat_opt(&mut self, pat: Option<&ast::Pat>) -> PatId {\n+    fn collect_pat_opt(&mut self, pat: Option<ast::Pat>) -> PatId {\n         if let Some(pat) = pat {\n             self.collect_pat(pat)\n         } else {\n             self.pats.alloc(Pat::Missing)\n         }\n     }\n \n-    fn collect_const_body(&mut self, node: &ast::ConstDef) {\n+    fn collect_const_body(&mut self, node: ast::ConstDef) {\n         let body = self.collect_expr_opt(node.body());\n         self.body_expr = Some(body);\n     }\n \n-    fn collect_static_body(&mut self, node: &ast::StaticDef) {\n+    fn collect_static_body(&mut self, node: ast::StaticDef) {\n         let body = self.collect_expr_opt(node.body());\n         self.body_expr = Some(body);\n     }\n \n-    fn collect_fn_body(&mut self, node: &ast::FnDef) {\n+    fn collect_fn_body(&mut self, node: ast::FnDef) {\n         if let Some(param_list) = node.param_list() {\n             if let Some(self_param) = param_list.self_param() {\n-                let ptr = AstPtr::new(self_param);\n+                let ptr = AstPtr::new(&self_param);\n                 let param_pat = self.alloc_pat(\n                     Pat::Bind {\n                         name: SELF_PARAM,\n@@ -1027,17 +1029,17 @@ pub(crate) fn body_with_source_map_query(\n         DefWithBody::Const(ref c) => {\n             let src = c.source(db);\n             collector = ExprCollector::new(def, src.file_id, def.resolver(db), db);\n-            collector.collect_const_body(&src.ast)\n+            collector.collect_const_body(src.ast)\n         }\n         DefWithBody::Function(ref f) => {\n             let src = f.source(db);\n             collector = ExprCollector::new(def, src.file_id, def.resolver(db), db);\n-            collector.collect_fn_body(&src.ast)\n+            collector.collect_fn_body(src.ast)\n         }\n         DefWithBody::Static(ref s) => {\n             let src = s.source(db);\n             collector = ExprCollector::new(def, src.file_id, def.resolver(db), db);\n-            collector.collect_static_body(&src.ast)\n+            collector.collect_static_body(src.ast)\n         }\n     }\n "}, {"sha": "6589b782c49aa5ca5622854c7f14ec4897f367c2", "filename": "crates/ra_hir/src/expr/scope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs?ref=e2b28f5bb8043e92b10f6a40696131007fc9dfe2", "patch": "@@ -190,7 +190,7 @@ mod tests {\n \n         let (db, _source_root, file_id) = MockDatabase::with_single_file(&code);\n         let file = db.parse(file_id).ok().unwrap();\n-        let marker: &ast::PathExpr = find_node_at_offset(file.syntax(), off).unwrap();\n+        let marker: ast::PathExpr = find_node_at_offset(file.syntax(), off).unwrap();\n         let analyzer = SourceAnalyzer::new(&db, file_id, marker.syntax(), None);\n \n         let scopes = analyzer.scopes();\n@@ -290,10 +290,10 @@ mod tests {\n         let file = db.parse(file_id).ok().unwrap();\n         let expected_name = find_node_at_offset::<ast::Name>(file.syntax(), expected_offset.into())\n             .expect(\"failed to find a name at the target offset\");\n-        let name_ref: &ast::NameRef = find_node_at_offset(file.syntax(), off).unwrap();\n+        let name_ref: ast::NameRef = find_node_at_offset(file.syntax(), off).unwrap();\n         let analyzer = SourceAnalyzer::new(&db, file_id, name_ref.syntax(), None);\n \n-        let local_name_entry = analyzer.resolve_local_name(name_ref).unwrap();\n+        let local_name_entry = analyzer.resolve_local_name(&name_ref).unwrap();\n         let local_name =\n             local_name_entry.ptr().either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr());\n         assert_eq!(local_name.range(), expected_name.syntax().range());"}, {"sha": "82a06ca25c759fe6cc3851b89998e55739bdcfd9", "filename": "crates/ra_hir/src/expr/validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs?ref=e2b28f5bb8043e92b10f6a40696131007fc9dfe2", "patch": "@@ -79,7 +79,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             .and_then(StructLit::cast)\n             .and_then(|lit| lit.named_field_list())\n         {\n-            let field_list_ptr = AstPtr::new(field_list_node);\n+            let field_list_ptr = AstPtr::new(&field_list_node);\n             self.sink.push(MissingFields {\n                 file: file_id,\n                 field_list: field_list_ptr,"}, {"sha": "bcbb4988d5c58dbf3fdb85ce1646cdb9f68a86a4", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=e2b28f5bb8043e92b10f6a40696131007fc9dfe2", "patch": "@@ -76,17 +76,17 @@ impl GenericParams {\n         generics.parent_params = parent.map(|p| db.generic_params(p));\n         let start = generics.parent_params.as_ref().map(|p| p.params.len()).unwrap_or(0) as u32;\n         match def {\n-            GenericDef::Function(it) => generics.fill(&*it.source(db).ast, start),\n-            GenericDef::Struct(it) => generics.fill(&*it.source(db).ast, start),\n-            GenericDef::Union(it) => generics.fill(&*it.source(db).ast, start),\n-            GenericDef::Enum(it) => generics.fill(&*it.source(db).ast, start),\n+            GenericDef::Function(it) => generics.fill(&it.source(db).ast, start),\n+            GenericDef::Struct(it) => generics.fill(&it.source(db).ast, start),\n+            GenericDef::Union(it) => generics.fill(&it.source(db).ast, start),\n+            GenericDef::Enum(it) => generics.fill(&it.source(db).ast, start),\n             GenericDef::Trait(it) => {\n                 // traits get the Self type as an implicit first type parameter\n                 generics.params.push(GenericParam { idx: start, name: SELF_TYPE, default: None });\n-                generics.fill(&*it.source(db).ast, start + 1);\n+                generics.fill(&it.source(db).ast, start + 1);\n             }\n-            GenericDef::TypeAlias(it) => generics.fill(&*it.source(db).ast, start),\n-            GenericDef::ImplBlock(it) => generics.fill(&*it.source(db).ast, start),\n+            GenericDef::TypeAlias(it) => generics.fill(&it.source(db).ast, start),\n+            GenericDef::ImplBlock(it) => generics.fill(&it.source(db).ast, start),\n             GenericDef::EnumVariant(_) => {}\n         }\n \n@@ -102,9 +102,9 @@ impl GenericParams {\n         }\n     }\n \n-    fn fill_params(&mut self, params: &ast::TypeParamList, start: u32) {\n+    fn fill_params(&mut self, params: ast::TypeParamList, start: u32) {\n         for (idx, type_param) in params.type_params().enumerate() {\n-            let name = type_param.name().map(AsName::as_name).unwrap_or_else(Name::missing);\n+            let name = type_param.name().map_or_else(Name::missing, |it| it.as_name());\n             let default = type_param.default_type().and_then(|t| t.path()).and_then(Path::from_ast);\n \n             let param = GenericParam { idx: idx as u32 + start, name: name.clone(), default };\n@@ -121,7 +121,7 @@ impl GenericParams {\n         }\n     }\n \n-    fn fill_where_predicates(&mut self, where_clause: &ast::WhereClause) {\n+    fn fill_where_predicates(&mut self, where_clause: ast::WhereClause) {\n         for pred in where_clause.predicates() {\n             let type_ref = match pred.type_ref() {\n                 Some(type_ref) => type_ref,\n@@ -134,7 +134,7 @@ impl GenericParams {\n         }\n     }\n \n-    fn add_where_predicate_from_bound(&mut self, bound: &ast::TypeBound, type_ref: TypeRef) {\n+    fn add_where_predicate_from_bound(&mut self, bound: ast::TypeBound, type_ref: TypeRef) {\n         let path = bound\n             .type_ref()\n             .and_then(|tr| match tr.kind() {"}, {"sha": "05a18eb56803edfbd2a306518016a5b23d9f82f4", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=e2b28f5bb8043e92b10f6a40696131007fc9dfe2", "patch": "@@ -6,7 +6,7 @@ use std::{\n use mbe::MacroRules;\n use ra_db::{salsa, FileId};\n use ra_prof::profile;\n-use ra_syntax::{ast, AstNode, Parse, SyntaxNode, TreeArc};\n+use ra_syntax::{ast, AstNode, Parse, SyntaxNode};\n \n use crate::{AstDatabase, AstId, DefDatabase, FileAstId, InternDatabase, Module, Source};\n \n@@ -58,11 +58,11 @@ impl HirFileId {\n     pub(crate) fn parse_or_expand_query(\n         db: &impl AstDatabase,\n         file_id: HirFileId,\n-    ) -> Option<TreeArc<SyntaxNode>> {\n+    ) -> Option<SyntaxNode> {\n         match file_id.0 {\n-            HirFileIdRepr::File(file_id) => Some(db.parse(file_id).tree().syntax().to_owned()),\n+            HirFileIdRepr::File(file_id) => Some(db.parse(file_id).tree().syntax().clone()),\n             HirFileIdRepr::Macro(macro_file) => {\n-                db.parse_macro(macro_file).map(|it| it.tree().to_owned())\n+                db.parse_macro(macro_file).map(|it| it.syntax_node())\n             }\n         }\n     }\n@@ -123,7 +123,7 @@ pub struct MacroDefId(pub(crate) AstId<ast::MacroCall>);\n pub(crate) fn macro_def_query(db: &impl AstDatabase, id: MacroDefId) -> Option<Arc<MacroRules>> {\n     let macro_call = id.0.to_node(db);\n     let arg = macro_call.token_tree()?;\n-    let (tt, _) = mbe::ast_to_token_tree(arg).or_else(|| {\n+    let (tt, _) = mbe::ast_to_token_tree(&arg).or_else(|| {\n         log::warn!(\"fail on macro_def to token tree: {:#?}\", arg);\n         None\n     })?;\n@@ -138,7 +138,7 @@ pub(crate) fn macro_arg_query(db: &impl AstDatabase, id: MacroCallId) -> Option<\n     let loc = id.loc(db);\n     let macro_call = loc.ast_id.to_node(db);\n     let arg = macro_call.token_tree()?;\n-    let (tt, _) = mbe::ast_to_token_tree(arg)?;\n+    let (tt, _) = mbe::ast_to_token_tree(&arg)?;\n     Some(Arc::new(tt))\n }\n \n@@ -262,7 +262,7 @@ pub(crate) trait AstItemDef<N: AstNode>: salsa::InternKey + Clone {\n         let loc = ItemLoc { module: ctx.module, ast_id: ast_id.with_file_id(ctx.file_id) };\n         Self::intern(ctx.db, loc)\n     }\n-    fn source(self, db: &(impl AstDatabase + DefDatabase)) -> Source<TreeArc<N>> {\n+    fn source(self, db: &(impl AstDatabase + DefDatabase)) -> Source<N> {\n         let loc = self.lookup_intern(db);\n         let ast = loc.ast_id.to_node(db);\n         Source { file_id: loc.ast_id.file_id(), ast }"}, {"sha": "8e62cf66d46c10ac235c9e4fdbf301ac236e29c5", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=e2b28f5bb8043e92b10f6a40696131007fc9dfe2", "patch": "@@ -4,7 +4,7 @@ use std::sync::Arc;\n use ra_arena::{impl_arena_id, map::ArenaMap, Arena, RawId};\n use ra_syntax::{\n     ast::{self, AstNode},\n-    AstPtr, SourceFile, TreeArc,\n+    AstPtr, SourceFile,\n };\n \n use crate::{\n@@ -28,9 +28,9 @@ impl ImplSourceMap {\n         self.map.insert(impl_id, AstPtr::new(impl_block))\n     }\n \n-    pub fn get(&self, source: &ModuleSource, impl_id: ImplId) -> TreeArc<ast::ImplBlock> {\n+    pub fn get(&self, source: &ModuleSource, impl_id: ImplId) -> ast::ImplBlock {\n         let file = match source {\n-            ModuleSource::SourceFile(file) => &*file,\n+            ModuleSource::SourceFile(file) => file.clone(),\n             ModuleSource::Module(m) => m.syntax().ancestors().find_map(SourceFile::cast).unwrap(),\n         };\n \n@@ -45,8 +45,8 @@ pub struct ImplBlock {\n }\n \n impl HasSource for ImplBlock {\n-    type Ast = TreeArc<ast::ImplBlock>;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::ImplBlock>> {\n+    type Ast = ast::ImplBlock;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::ImplBlock> {\n         let source_map = db.impls_in_module_with_source_map(self.module).1;\n         let src = self.module.definition_source(db);\n         Source { file_id: src.file_id, ast: source_map.get(&src.ast, self.impl_id) }\n@@ -132,9 +132,9 @@ impl ImplData {\n             item_list\n                 .impl_items()\n                 .map(|item_node| match item_node.kind() {\n-                    ast::ImplItemKind::FnDef(it) => Function { id: ctx.to_def(it) }.into(),\n-                    ast::ImplItemKind::ConstDef(it) => Const { id: ctx.to_def(it) }.into(),\n-                    ast::ImplItemKind::TypeAliasDef(it) => TypeAlias { id: ctx.to_def(it) }.into(),\n+                    ast::ImplItemKind::FnDef(it) => Function { id: ctx.to_def(&it) }.into(),\n+                    ast::ImplItemKind::ConstDef(it) => Const { id: ctx.to_def(&it) }.into(),\n+                    ast::ImplItemKind::TypeAliasDef(it) => TypeAlias { id: ctx.to_def(&it) }.into(),\n                 })\n                 .collect()\n         } else {\n@@ -202,20 +202,20 @@ impl ModuleImplBlocks {\n \n         let src = m.module.definition_source(db);\n         let node = match &src.ast {\n-            ModuleSource::SourceFile(node) => node.syntax(),\n+            ModuleSource::SourceFile(node) => node.syntax().clone(),\n             ModuleSource::Module(node) => {\n-                node.item_list().expect(\"inline module should have item list\").syntax()\n+                node.item_list().expect(\"inline module should have item list\").syntax().clone()\n             }\n         };\n \n         for impl_block_ast in node.children().filter_map(ast::ImplBlock::cast) {\n-            let impl_block = ImplData::from_ast(db, src.file_id, m.module, impl_block_ast);\n+            let impl_block = ImplData::from_ast(db, src.file_id, m.module, &impl_block_ast);\n             let id = m.impls.alloc(impl_block);\n             for &impl_item in &m.impls[id].items {\n                 m.impls_by_def.insert(impl_item, id);\n             }\n \n-            source_map.insert(id, impl_block_ast);\n+            source_map.insert(id, &impl_block_ast);\n         }\n \n         m"}, {"sha": "fd6609fb8af7185744210c11f75b778e3772c159", "filename": "crates/ra_hir/src/lang_item.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flang_item.rs?ref=e2b28f5bb8043e92b10f6a40696131007fc9dfe2", "patch": "@@ -1,7 +1,7 @@\n use rustc_hash::FxHashMap;\n use std::sync::Arc;\n \n-use ra_syntax::{ast::AttrsOwner, SmolStr, TreeArc};\n+use ra_syntax::{ast::AttrsOwner, SmolStr};\n \n use crate::{\n     AstDatabase, Crate, DefDatabase, Enum, Function, HasSource, HirDatabase, ImplBlock, Module,\n@@ -95,7 +95,7 @@ impl LangItems {\n         // Look for impl targets\n         for impl_block in module.impl_blocks(db) {\n             let src = impl_block.source(db);\n-            if let Some(lang_item_name) = lang_item_name(&*src.ast) {\n+            if let Some(lang_item_name) = lang_item_name(&src.ast) {\n                 self.items\n                     .entry(lang_item_name)\n                     .or_insert_with(|| LangItemTarget::ImplBlock(impl_block));\n@@ -137,11 +137,11 @@ impl LangItems {\n         item: T,\n         constructor: fn(T) -> LangItemTarget,\n     ) where\n-        T: Copy + HasSource<Ast = TreeArc<N>>,\n+        T: Copy + HasSource<Ast = N>,\n         N: AttrsOwner,\n     {\n         let node = item.source(db).ast;\n-        if let Some(lang_item_name) = lang_item_name(&*node) {\n+        if let Some(lang_item_name) = lang_item_name(&node) {\n             self.items.entry(lang_item_name).or_insert_with(|| constructor(item));\n         }\n     }"}, {"sha": "c589f8aba6ece254267847af91b255b0cb16590a", "filename": "crates/ra_hir/src/name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fname.rs?ref=e2b28f5bb8043e92b10f6a40696131007fc9dfe2", "patch": "@@ -75,7 +75,7 @@ impl AsName for ast::Name {\n     }\n }\n \n-impl<'a> AsName for ast::FieldKind<'a> {\n+impl AsName for ast::FieldKind {\n     fn as_name(&self) -> Name {\n         match self {\n             ast::FieldKind::Name(nr) => nr.as_name(),"}, {"sha": "8517f3c430dda9215aab89dbcbef8324453fee4d", "filename": "crates/ra_hir/src/nameres/raw.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs?ref=e2b28f5bb8043e92b10f6a40696131007fc9dfe2", "patch": "@@ -3,7 +3,7 @@ use std::{ops::Index, sync::Arc};\n use ra_arena::{impl_arena_id, map::ArenaMap, Arena, RawId};\n use ra_syntax::{\n     ast::{self, AttrsOwner, NameOwner},\n-    AstNode, AstPtr, SmolStr, SourceFile, TreeArc,\n+    AstNode, AstPtr, SmolStr, SourceFile,\n };\n use test_utils::tested_by;\n \n@@ -32,7 +32,7 @@ pub struct ImportSourceMap {\n }\n \n type ImportSourcePtr = Either<AstPtr<ast::UseTree>, AstPtr<ast::ExternCrateItem>>;\n-type ImportSource = Either<TreeArc<ast::UseTree>, TreeArc<ast::ExternCrateItem>>;\n+type ImportSource = Either<ast::UseTree, ast::ExternCrateItem>;\n \n impl ImportSourcePtr {\n     fn to_node(self, file: &SourceFile) -> ImportSource {\n@@ -50,11 +50,11 @@ impl ImportSourceMap {\n \n     pub(crate) fn get(&self, source: &ModuleSource, import: ImportId) -> ImportSource {\n         let file = match source {\n-            ModuleSource::SourceFile(file) => &*file,\n+            ModuleSource::SourceFile(file) => file.clone(),\n             ModuleSource::Module(m) => m.syntax().ancestors().find_map(SourceFile::cast).unwrap(),\n         };\n \n-        self.map[import].to_node(file)\n+        self.map[import].to_node(&file)\n     }\n }\n \n@@ -76,8 +76,8 @@ impl RawItems {\n             source_map: ImportSourceMap::default(),\n         };\n         if let Some(node) = db.parse_or_expand(file_id) {\n-            if let Some(source_file) = ast::SourceFile::cast(&node) {\n-                collector.process_module(None, &*source_file);\n+            if let Some(source_file) = ast::SourceFile::cast(node) {\n+                collector.process_module(None, source_file);\n             }\n         }\n         (Arc::new(collector.raw_items), Arc::new(collector.source_map))\n@@ -188,7 +188,7 @@ struct RawItemsCollector {\n }\n \n impl RawItemsCollector {\n-    fn process_module(&mut self, current_module: Option<Module>, body: &impl ast::ModuleItemOwner) {\n+    fn process_module(&mut self, current_module: Option<Module>, body: impl ast::ModuleItemOwner) {\n         for item_or_macro in body.items_with_macros() {\n             match item_or_macro {\n                 ast::ItemOrMacro::Macro(m) => self.add_macro(current_module, m),\n@@ -197,7 +197,7 @@ impl RawItemsCollector {\n         }\n     }\n \n-    fn add_item(&mut self, current_module: Option<Module>, item: &ast::ModuleItem) {\n+    fn add_item(&mut self, current_module: Option<Module>, item: ast::ModuleItem) {\n         let (kind, name) = match item.kind() {\n             ast::ModuleItemKind::Module(module) => {\n                 self.add_module(current_module, module);\n@@ -216,7 +216,7 @@ impl RawItemsCollector {\n                 return;\n             }\n             ast::ModuleItemKind::StructDef(it) => {\n-                let id = self.source_ast_id_map.ast_id(it);\n+                let id = self.source_ast_id_map.ast_id(&it);\n                 let name = it.name();\n                 if it.is_union() {\n                     (DefKind::Union(id), name)\n@@ -225,22 +225,22 @@ impl RawItemsCollector {\n                 }\n             }\n             ast::ModuleItemKind::EnumDef(it) => {\n-                (DefKind::Enum(self.source_ast_id_map.ast_id(it)), it.name())\n+                (DefKind::Enum(self.source_ast_id_map.ast_id(&it)), it.name())\n             }\n             ast::ModuleItemKind::FnDef(it) => {\n-                (DefKind::Function(self.source_ast_id_map.ast_id(it)), it.name())\n+                (DefKind::Function(self.source_ast_id_map.ast_id(&it)), it.name())\n             }\n             ast::ModuleItemKind::TraitDef(it) => {\n-                (DefKind::Trait(self.source_ast_id_map.ast_id(it)), it.name())\n+                (DefKind::Trait(self.source_ast_id_map.ast_id(&it)), it.name())\n             }\n             ast::ModuleItemKind::TypeAliasDef(it) => {\n-                (DefKind::TypeAlias(self.source_ast_id_map.ast_id(it)), it.name())\n+                (DefKind::TypeAlias(self.source_ast_id_map.ast_id(&it)), it.name())\n             }\n             ast::ModuleItemKind::ConstDef(it) => {\n-                (DefKind::Const(self.source_ast_id_map.ast_id(it)), it.name())\n+                (DefKind::Const(self.source_ast_id_map.ast_id(&it)), it.name())\n             }\n             ast::ModuleItemKind::StaticDef(it) => {\n-                (DefKind::Static(self.source_ast_id_map.ast_id(it)), it.name())\n+                (DefKind::Static(self.source_ast_id_map.ast_id(&it)), it.name())\n             }\n         };\n         if let Some(name) = name {\n@@ -250,14 +250,14 @@ impl RawItemsCollector {\n         }\n     }\n \n-    fn add_module(&mut self, current_module: Option<Module>, module: &ast::Module) {\n+    fn add_module(&mut self, current_module: Option<Module>, module: ast::Module) {\n         let name = match module.name() {\n             Some(it) => it.as_name(),\n             None => return,\n         };\n \n-        let attr_path = extract_mod_path_attribute(module);\n-        let ast_id = self.source_ast_id_map.ast_id(module);\n+        let attr_path = extract_mod_path_attribute(&module);\n+        let ast_id = self.source_ast_id_map.ast_id(&module);\n         if module.has_semi() {\n             let item =\n                 self.raw_items.modules.alloc(ModuleData::Declaration { name, ast_id, attr_path });\n@@ -278,10 +278,10 @@ impl RawItemsCollector {\n         tested_by!(name_res_works_for_broken_modules);\n     }\n \n-    fn add_use_item(&mut self, current_module: Option<Module>, use_item: &ast::UseItem) {\n+    fn add_use_item(&mut self, current_module: Option<Module>, use_item: ast::UseItem) {\n         let is_prelude = use_item.has_atom_attr(\"prelude_import\");\n \n-        Path::expand_use_item(use_item, |path, use_tree, is_glob, alias| {\n+        Path::expand_use_item(&use_item, |path, use_tree, is_glob, alias| {\n             let import_data =\n                 ImportData { path, alias, is_glob, is_prelude, is_extern_crate: false };\n             self.push_import(current_module, import_data, Either::A(AstPtr::new(use_tree)));\n@@ -291,30 +291,30 @@ impl RawItemsCollector {\n     fn add_extern_crate_item(\n         &mut self,\n         current_module: Option<Module>,\n-        extern_crate: &ast::ExternCrateItem,\n+        extern_crate: ast::ExternCrateItem,\n     ) {\n         if let Some(name_ref) = extern_crate.name_ref() {\n-            let path = Path::from_name_ref(name_ref);\n-            let alias = extern_crate.alias().and_then(|a| a.name()).map(AsName::as_name);\n+            let path = Path::from_name_ref(&name_ref);\n+            let alias = extern_crate.alias().and_then(|a| a.name()).map(|it| it.as_name());\n             let import_data = ImportData {\n                 path,\n                 alias,\n                 is_glob: false,\n                 is_prelude: false,\n                 is_extern_crate: true,\n             };\n-            self.push_import(current_module, import_data, Either::B(AstPtr::new(extern_crate)));\n+            self.push_import(current_module, import_data, Either::B(AstPtr::new(&extern_crate)));\n         }\n     }\n \n-    fn add_macro(&mut self, current_module: Option<Module>, m: &ast::MacroCall) {\n+    fn add_macro(&mut self, current_module: Option<Module>, m: ast::MacroCall) {\n         let path = match m.path().and_then(Path::from_ast) {\n             Some(it) => it,\n             _ => return,\n         };\n \n         let name = m.name().map(|it| it.as_name());\n-        let ast_id = self.source_ast_id_map.ast_id(m);\n+        let ast_id = self.source_ast_id_map.ast_id(&m);\n         let export = m.has_atom_attr(\"macro_export\");\n         let m = self.raw_items.macros.alloc(MacroData { ast_id, path, name, export });\n         self.push_item(current_module, RawItem::Macro(m));"}, {"sha": "882db76816209175bff5ca16428bb34d6cfb005a", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=e2b28f5bb8043e92b10f6a40696131007fc9dfe2", "patch": "@@ -47,17 +47,17 @@ pub enum PathKind {\n \n impl Path {\n     /// Calls `cb` with all paths, represented by this use item.\n-    pub fn expand_use_item<'a>(\n-        item: &'a ast::UseItem,\n-        mut cb: impl FnMut(Path, &'a ast::UseTree, bool, Option<Name>),\n+    pub fn expand_use_item(\n+        item: &ast::UseItem,\n+        mut cb: impl FnMut(Path, &ast::UseTree, bool, Option<Name>),\n     ) {\n         if let Some(tree) = item.use_tree() {\n             expand_use_tree(None, tree, &mut cb);\n         }\n     }\n \n     /// Converts an `ast::Path` to `Path`. Works with use trees.\n-    pub fn from_ast(mut path: &ast::Path) -> Option<Path> {\n+    pub fn from_ast(mut path: ast::Path) -> Option<Path> {\n         let mut kind = PathKind::Plain;\n         let mut segments = Vec::new();\n         loop {\n@@ -87,15 +87,15 @@ impl Path {\n                     break;\n                 }\n             }\n-            path = match qualifier(path) {\n+            path = match qualifier(&path) {\n                 Some(it) => it,\n                 None => break,\n             };\n         }\n         segments.reverse();\n         return Some(Path { kind, segments });\n \n-        fn qualifier(path: &ast::Path) -> Option<&ast::Path> {\n+        fn qualifier(path: &ast::Path) -> Option<ast::Path> {\n             if let Some(q) = path.qualifier() {\n                 return Some(q);\n             }\n@@ -136,7 +136,7 @@ impl Path {\n }\n \n impl GenericArgs {\n-    pub(crate) fn from_ast(node: &ast::TypeArgList) -> Option<GenericArgs> {\n+    pub(crate) fn from_ast(node: ast::TypeArgList) -> Option<GenericArgs> {\n         let mut args = Vec::new();\n         for type_arg in node.type_args() {\n             let type_ref = TypeRef::from_ast_opt(type_arg.type_ref());\n@@ -160,10 +160,10 @@ impl From<Name> for Path {\n     }\n }\n \n-fn expand_use_tree<'a>(\n+fn expand_use_tree(\n     prefix: Option<Path>,\n-    tree: &'a ast::UseTree,\n-    cb: &mut impl FnMut(Path, &'a ast::UseTree, bool, Option<Name>),\n+    tree: ast::UseTree,\n+    cb: &mut impl FnMut(Path, &ast::UseTree, bool, Option<Name>),\n ) {\n     if let Some(use_tree_list) = tree.use_tree_list() {\n         let prefix = match tree.path() {\n@@ -188,23 +188,23 @@ fn expand_use_tree<'a>(\n                 if let Some(segment) = ast_path.segment() {\n                     if segment.kind() == Some(ast::PathSegmentKind::SelfKw) {\n                         if let Some(prefix) = prefix {\n-                            cb(prefix, tree, false, alias);\n+                            cb(prefix, &tree, false, alias);\n                             return;\n                         }\n                     }\n                 }\n             }\n             if let Some(path) = convert_path(prefix, ast_path) {\n                 let is_glob = tree.has_star();\n-                cb(path, tree, is_glob, alias)\n+                cb(path, &tree, is_glob, alias)\n             }\n             // FIXME: report errors somewhere\n             // We get here if we do\n         }\n     }\n }\n \n-fn convert_path(prefix: Option<Path>, path: &ast::Path) -> Option<Path> {\n+fn convert_path(prefix: Option<Path>, path: ast::Path) -> Option<Path> {\n     let prefix =\n         if let Some(qual) = path.qualifier() { Some(convert_path(prefix, qual)?) } else { prefix };\n     let segment = path.segment()?;"}, {"sha": "e7bc4df978898b7d2a7b736c1626d581fb7cdd5b", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=e2b28f5bb8043e92b10f6a40696131007fc9dfe2", "patch": "@@ -37,7 +37,7 @@ pub fn module_from_file_id(db: &impl HirDatabase, file_id: FileId) -> Option<Mod\n pub fn module_from_declaration(\n     db: &impl HirDatabase,\n     file_id: FileId,\n-    decl: &ast::Module,\n+    decl: ast::Module,\n ) -> Option<Module> {\n     let parent_module = module_from_file_id(db, file_id);\n     let child_name = decl.name();\n@@ -50,21 +50,21 @@ pub fn module_from_declaration(\n /// Locates the module by position in the source code.\n pub fn module_from_position(db: &impl HirDatabase, position: FilePosition) -> Option<Module> {\n     let parse = db.parse(position.file_id);\n-    match find_node_at_offset::<ast::Module>(parse.tree().syntax(), position.offset) {\n-        Some(m) if !m.has_semi() => module_from_inline(db, position.file_id, m),\n+    match &find_node_at_offset::<ast::Module>(parse.tree().syntax(), position.offset) {\n+        Some(m) if !m.has_semi() => module_from_inline(db, position.file_id, m.clone()),\n         _ => module_from_file_id(db, position.file_id),\n     }\n }\n \n fn module_from_inline(\n     db: &impl HirDatabase,\n     file_id: FileId,\n-    module: &ast::Module,\n+    module: ast::Module,\n ) -> Option<Module> {\n     assert!(!module.has_semi());\n     let file_id = file_id.into();\n     let ast_id_map = db.ast_id_map(file_id);\n-    let item_id = ast_id_map.ast_id(module).with_file_id(file_id);\n+    let item_id = ast_id_map.ast_id(&module).with_file_id(file_id);\n     module_from_source(db, file_id, Some(item_id))\n }\n \n@@ -127,16 +127,16 @@ fn try_get_resolver_for_node(\n     file_id: FileId,\n     node: &SyntaxNode,\n ) -> Option<Resolver> {\n-    if let Some(module) = ast::Module::cast(node) {\n+    if let Some(module) = ast::Module::cast(node.clone()) {\n         Some(module_from_declaration(db, file_id, module)?.resolver(db))\n-    } else if let Some(_) = ast::SourceFile::cast(node) {\n+    } else if let Some(_) = ast::SourceFile::cast(node.clone()) {\n         Some(module_from_source(db, file_id.into(), None)?.resolver(db))\n-    } else if let Some(s) = ast::StructDef::cast(node) {\n+    } else if let Some(s) = ast::StructDef::cast(node.clone()) {\n         let module = module_from_child_node(db, file_id, s.syntax())?;\n-        Some(struct_from_module(db, module, s).resolver(db))\n-    } else if let Some(e) = ast::EnumDef::cast(node) {\n+        Some(struct_from_module(db, module, &s).resolver(db))\n+    } else if let Some(e) = ast::EnumDef::cast(node.clone()) {\n         let module = module_from_child_node(db, file_id, e.syntax())?;\n-        Some(enum_from_module(db, module, e).resolver(db))\n+        Some(enum_from_module(db, module, &e).resolver(db))\n     } else if node.kind() == FN_DEF || node.kind() == CONST_DEF || node.kind() == STATIC_DEF {\n         Some(def_with_body_from_child_node(db, file_id, node)?.resolver(db))\n     } else {\n@@ -153,14 +153,14 @@ fn def_with_body_from_child_node(\n     let module = module_from_child_node(db, file_id, node)?;\n     let ctx = LocationCtx::new(db, module, file_id.into());\n     node.ancestors().find_map(|node| {\n-        if let Some(def) = ast::FnDef::cast(node) {\n-            return Some(Function { id: ctx.to_def(def) }.into());\n+        if let Some(def) = ast::FnDef::cast(node.clone()) {\n+            return Some(Function { id: ctx.to_def(&def) }.into());\n         }\n-        if let Some(def) = ast::ConstDef::cast(node) {\n-            return Some(Const { id: ctx.to_def(def) }.into());\n+        if let Some(def) = ast::ConstDef::cast(node.clone()) {\n+            return Some(Const { id: ctx.to_def(&def) }.into());\n         }\n-        if let Some(def) = ast::StaticDef::cast(node) {\n-            return Some(Static { id: ctx.to_def(def) }.into());\n+        if let Some(def) = ast::StaticDef::cast(node.clone()) {\n+            return Some(Static { id: ctx.to_def(&def) }.into());\n         }\n         None\n     })\n@@ -237,7 +237,7 @@ impl SourceAnalyzer {\n             SourceAnalyzer {\n                 resolver: node\n                     .ancestors()\n-                    .find_map(|node| try_get_resolver_for_node(db, file_id, node))\n+                    .find_map(|node| try_get_resolver_for_node(db, file_id, &node))\n                     .unwrap_or_default(),\n                 body_source_map: None,\n                 infer: None,\n@@ -257,17 +257,17 @@ impl SourceAnalyzer {\n     }\n \n     pub fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<Function> {\n-        let expr_id = self.body_source_map.as_ref()?.node_expr(call.into())?;\n+        let expr_id = self.body_source_map.as_ref()?.node_expr(&call.clone().into())?;\n         self.infer.as_ref()?.method_resolution(expr_id)\n     }\n \n     pub fn resolve_field(&self, field: &ast::FieldExpr) -> Option<crate::StructField> {\n-        let expr_id = self.body_source_map.as_ref()?.node_expr(field.into())?;\n+        let expr_id = self.body_source_map.as_ref()?.node_expr(&field.clone().into())?;\n         self.infer.as_ref()?.field_resolution(expr_id)\n     }\n \n     pub fn resolve_variant(&self, struct_lit: &ast::StructLit) -> Option<crate::VariantDef> {\n-        let expr_id = self.body_source_map.as_ref()?.node_expr(struct_lit.into())?;\n+        let expr_id = self.body_source_map.as_ref()?.node_expr(&struct_lit.clone().into())?;\n         self.infer.as_ref()?.variant_resolution(expr_id)\n     }\n \n@@ -290,18 +290,18 @@ impl SourceAnalyzer {\n \n     pub fn resolve_path(&self, db: &impl HirDatabase, path: &ast::Path) -> Option<PathResolution> {\n         if let Some(path_expr) = path.syntax().parent().and_then(ast::PathExpr::cast) {\n-            let expr_id = self.body_source_map.as_ref()?.node_expr(path_expr.into())?;\n+            let expr_id = self.body_source_map.as_ref()?.node_expr(&path_expr.into())?;\n             if let Some(assoc) = self.infer.as_ref()?.assoc_resolutions_for_expr(expr_id) {\n                 return Some(PathResolution::AssocItem(assoc));\n             }\n         }\n         if let Some(path_pat) = path.syntax().parent().and_then(ast::PathPat::cast) {\n-            let pat_id = self.body_source_map.as_ref()?.node_pat(path_pat.into())?;\n+            let pat_id = self.body_source_map.as_ref()?.node_pat(&path_pat.into())?;\n             if let Some(assoc) = self.infer.as_ref()?.assoc_resolutions_for_pat(pat_id) {\n                 return Some(PathResolution::AssocItem(assoc));\n             }\n         }\n-        let hir_path = crate::Path::from_ast(path)?;\n+        let hir_path = crate::Path::from_ast(path.clone())?;\n         let res = self.resolver.resolve_path_without_assoc_items(db, &hir_path);\n         let res = res.clone().take_types().or_else(|| res.take_values())?;\n         let res = match res {\n@@ -343,12 +343,12 @@ impl SourceAnalyzer {\n         // FIXME: at least, this should work with any DefWithBody, but ideally\n         // this should be hir-based altogether\n         let fn_def = pat.syntax().ancestors().find_map(ast::FnDef::cast).unwrap();\n-        let ptr = Either::A(AstPtr::new(pat.into()));\n+        let ptr = Either::A(AstPtr::new(&ast::Pat::from(pat.clone())));\n         fn_def\n             .syntax()\n             .descendants()\n             .filter_map(ast::NameRef::cast)\n-            .filter(|name_ref| match self.resolve_local_name(*name_ref) {\n+            .filter(|name_ref| match self.resolve_local_name(&name_ref) {\n                 None => false,\n                 Some(entry) => entry.ptr() == ptr,\n             })\n@@ -411,7 +411,7 @@ fn scope_for(\n     node: &SyntaxNode,\n ) -> Option<ScopeId> {\n     node.ancestors()\n-        .map(SyntaxNodePtr::new)\n+        .map(|it| SyntaxNodePtr::new(&it))\n         .filter_map(|ptr| source_map.syntax_expr(ptr))\n         .find_map(|it| scopes.scope_for(it))\n }"}, {"sha": "51cd65ddad502ae915a47cfbe500ff722bece119", "filename": "crates/ra_hir/src/source_id.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fsource_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fsource_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_id.rs?ref=e2b28f5bb8043e92b10f6a40696131007fc9dfe2", "patch": "@@ -5,7 +5,7 @@ use std::{\n };\n \n use ra_arena::{impl_arena_id, Arena, RawId};\n-use ra_syntax::{ast, AstNode, SyntaxNode, SyntaxNodePtr, TreeArc};\n+use ra_syntax::{ast, AstNode, SyntaxNode, SyntaxNodePtr};\n \n use crate::{AstDatabase, HirFileId};\n \n@@ -42,9 +42,9 @@ impl<N: AstNode> AstId<N> {\n         self.file_id\n     }\n \n-    pub(crate) fn to_node(&self, db: &impl AstDatabase) -> TreeArc<N> {\n+    pub(crate) fn to_node(&self, db: &impl AstDatabase) -> N {\n         let syntax_node = db.ast_id_to_node(self.file_id, self.file_ast_id.raw);\n-        N::cast(&syntax_node).unwrap().to_owned()\n+        N::cast(syntax_node).unwrap()\n     }\n }\n \n@@ -93,7 +93,7 @@ pub struct AstIdMap {\n impl AstIdMap {\n     pub(crate) fn ast_id_map_query(db: &impl AstDatabase, file_id: HirFileId) -> Arc<AstIdMap> {\n         let map = if let Some(node) = db.parse_or_expand(file_id) {\n-            AstIdMap::from_source(&*node)\n+            AstIdMap::from_source(&node)\n         } else {\n             AstIdMap::default()\n         };\n@@ -104,9 +104,9 @@ impl AstIdMap {\n         db: &impl AstDatabase,\n         file_id: HirFileId,\n         ast_id: ErasedFileAstId,\n-    ) -> TreeArc<SyntaxNode> {\n+    ) -> SyntaxNode {\n         let node = db.parse_or_expand(file_id).unwrap();\n-        db.ast_id_map(file_id).arena[ast_id].to_node(&*node).to_owned()\n+        db.ast_id_map(file_id).arena[ast_id].to_node(&node)\n     }\n \n     pub(crate) fn ast_id<N: AstNode>(&self, item: &N) -> FileAstId<N> {\n@@ -131,7 +131,7 @@ impl AstIdMap {\n         // change parent's id. This means that, say, adding a new function to a\n         // trait does not change ids of top-level items, which helps caching.\n         bfs(node, |it| {\n-            if let Some(module_item) = ast::ModuleItem::cast(it) {\n+            if let Some(module_item) = ast::ModuleItem::cast(it.clone()) {\n                 res.alloc(module_item.syntax());\n             } else if let Some(macro_call) = ast::MacroCall::cast(it) {\n                 res.alloc(macro_call.syntax());\n@@ -146,8 +146,8 @@ impl AstIdMap {\n }\n \n /// Walks the subtree in bfs order, calling `f` for each node.\n-fn bfs(node: &SyntaxNode, mut f: impl FnMut(&SyntaxNode)) {\n-    let mut curr_layer = vec![node];\n+fn bfs(node: &SyntaxNode, mut f: impl FnMut(SyntaxNode)) {\n+    let mut curr_layer = vec![node.clone()];\n     let mut next_layer = vec![];\n     while !curr_layer.is_empty() {\n         curr_layer.drain(..).for_each(|node| {"}, {"sha": "de26f1a68fed22397318f8937a20a64850ad81e5", "filename": "crates/ra_hir/src/traits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftraits.rs?ref=e2b28f5bb8043e92b10f6a40696131007fc9dfe2", "patch": "@@ -31,9 +31,9 @@ impl TraitData {\n             item_list\n                 .impl_items()\n                 .map(|item_node| match item_node.kind() {\n-                    ast::ImplItemKind::FnDef(it) => Function { id: ctx.to_def(it) }.into(),\n-                    ast::ImplItemKind::ConstDef(it) => Const { id: ctx.to_def(it) }.into(),\n-                    ast::ImplItemKind::TypeAliasDef(it) => TypeAlias { id: ctx.to_def(it) }.into(),\n+                    ast::ImplItemKind::FnDef(it) => Function { id: ctx.to_def(&it) }.into(),\n+                    ast::ImplItemKind::ConstDef(it) => Const { id: ctx.to_def(&it) }.into(),\n+                    ast::ImplItemKind::TypeAliasDef(it) => TypeAlias { id: ctx.to_def(&it) }.into(),\n                 })\n                 .collect()\n         } else {"}, {"sha": "265740e542035dd469c7da9c3cf0cc933efebd0a", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=e2b28f5bb8043e92b10f6a40696131007fc9dfe2", "patch": "@@ -3086,7 +3086,7 @@ fn type_at_pos(db: &MockDatabase, pos: FilePosition) -> String {\n     let file = db.parse(pos.file_id).ok().unwrap();\n     let expr = algo::find_node_at_offset::<ast::Expr>(file.syntax(), pos.offset).unwrap();\n     let analyzer = SourceAnalyzer::new(db, pos.file_id, expr.syntax(), Some(pos.offset));\n-    let ty = analyzer.type_of(db, expr).unwrap();\n+    let ty = analyzer.type_of(db, &expr).unwrap();\n     ty.display(db).to_string()\n }\n \n@@ -3126,7 +3126,7 @@ fn infer(content: &str) -> String {\n         types.sort_by_key(|(ptr, _)| (ptr.range().start(), ptr.range().end()));\n         for (syntax_ptr, ty) in &types {\n             let node = syntax_ptr.to_node(source_file.syntax());\n-            let (range, text) = if let Some(self_param) = ast::SelfParam::cast(node) {\n+            let (range, text) = if let Some(self_param) = ast::SelfParam::cast(node.clone()) {\n                 (self_param.self_kw_token().range(), \"self\".to_string())\n             } else {\n                 (syntax_ptr.range(), node.text().to_string().replace(\"\\n\", \" \"))\n@@ -3137,7 +3137,7 @@ fn infer(content: &str) -> String {\n \n     for node in source_file.syntax().descendants() {\n         if node.kind() == FN_DEF || node.kind() == CONST_DEF || node.kind() == STATIC_DEF {\n-            let analyzer = SourceAnalyzer::new(&db, file_id, node, None);\n+            let analyzer = SourceAnalyzer::new(&db, file_id, &node, None);\n             infer_def(analyzer.inference_result(), analyzer.body_source_map());\n         }\n     }\n@@ -3179,7 +3179,7 @@ fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n         let node =\n             algo::find_token_at_offset(file.syntax(), pos.offset).right_biased().unwrap().parent();\n         let events = db.log_executed(|| {\n-            SourceAnalyzer::new(&db, pos.file_id, node, None);\n+            SourceAnalyzer::new(&db, pos.file_id, &node, None);\n         });\n         assert!(format!(\"{:?}\", events).contains(\"infer\"))\n     }\n@@ -3200,7 +3200,7 @@ fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n         let node =\n             algo::find_token_at_offset(file.syntax(), pos.offset).right_biased().unwrap().parent();\n         let events = db.log_executed(|| {\n-            SourceAnalyzer::new(&db, pos.file_id, node, None);\n+            SourceAnalyzer::new(&db, pos.file_id, &node, None);\n         });\n         assert!(!format!(\"{:?}\", events).contains(\"infer\"), \"{:#?}\", events)\n     }"}, {"sha": "8536ae44a155478cdbf97154ff39777a552dc0f4", "filename": "crates/ra_hir/src/type_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs?ref=e2b28f5bb8043e92b10f6a40696131007fc9dfe2", "patch": "@@ -56,7 +56,7 @@ pub enum TypeRef {\n \n impl TypeRef {\n     /// Converts an `ast::TypeRef` to a `hir::TypeRef`.\n-    pub(crate) fn from_ast(node: &ast::TypeRef) -> Self {\n+    pub(crate) fn from_ast(node: ast::TypeRef) -> Self {\n         use ra_syntax::ast::TypeRefKind::*;\n         match node.kind() {\n             ParenType(inner) => TypeRef::from_ast_opt(inner.type_ref()),\n@@ -95,7 +95,7 @@ impl TypeRef {\n         }\n     }\n \n-    pub(crate) fn from_ast_opt(node: Option<&ast::TypeRef>) -> Self {\n+    pub(crate) fn from_ast_opt(node: Option<ast::TypeRef>) -> Self {\n         if let Some(node) = node {\n             TypeRef::from_ast(node)\n         } else {"}, {"sha": "2dca4e3e857d125ecd469ebc338053ff76829afa", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b28f5bb8043e92b10f6a40696131007fc9dfe2/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=e2b28f5bb8043e92b10f6a40696131007fc9dfe2", "patch": "@@ -75,7 +75,7 @@ impl<T> Parse<T> {\n         Parse { green, errors: Arc::new(errors), _ty: PhantomData }\n     }\n \n-    fn syntax_node(&self) -> SyntaxNode {\n+    pub fn syntax_node(&self) -> SyntaxNode {\n         SyntaxNode::new(self.green.clone())\n     }\n }"}]}