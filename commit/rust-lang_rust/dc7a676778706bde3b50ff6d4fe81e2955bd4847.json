{"sha": "dc7a676778706bde3b50ff6d4fe81e2955bd4847", "node_id": "C_kwDOAAsO6NoAKGRjN2E2NzY3Nzg3MDZiZGUzYjUwZmY2ZDRmZTgxZTI5NTViZDQ4NDc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-16T00:12:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-16T00:12:54Z"}, "message": "Auto merge of #108096 - matthiaskrgr:rollup-ncexzf6, r=matthiaskrgr\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #107034 (Migrating rustc_infer to session diagnostics (part 4))\n - #107972 (Fix unintentional UB in ui tests)\n - #108010 (Make `InferCtxt::can_eq` and `InferCtxt::can_sub` return booleans)\n - #108021 (make x look for x.py if shell script does not exist)\n - #108047 (Use `target` instead of `machine` for mir interpreter integer handling.)\n - #108049 (Don't suggest `#[doc(hidden)]` trait methods with matching return type)\n - #108066 (Better names for illegal impl trait positions)\n - #108076 (rustdoc: Use more let chain)\n - #108088 (clarify correctness of `black_box`)\n - #108094 (Demonstrate I/O in File examples)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "dd267ba6f6baeeff00d23d95cde13690bccad0f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd267ba6f6baeeff00d23d95cde13690bccad0f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc7a676778706bde3b50ff6d4fe81e2955bd4847", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc7a676778706bde3b50ff6d4fe81e2955bd4847", "html_url": "https://github.com/rust-lang/rust/commit/dc7a676778706bde3b50ff6d4fe81e2955bd4847", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc7a676778706bde3b50ff6d4fe81e2955bd4847/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5283576ec18937d98889679a54aa8f2dee2b875", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5283576ec18937d98889679a54aa8f2dee2b875", "html_url": "https://github.com/rust-lang/rust/commit/c5283576ec18937d98889679a54aa8f2dee2b875"}, {"sha": "55471015a0238f2fa2bf85adb38eb6bedf5ef26e", "url": "https://api.github.com/repos/rust-lang/rust/commits/55471015a0238f2fa2bf85adb38eb6bedf5ef26e", "html_url": "https://github.com/rust-lang/rust/commit/55471015a0238f2fa2bf85adb38eb6bedf5ef26e"}], "stats": {"total": 1900, "additions": 1121, "deletions": 779}, "files": [{"sha": "c4442b34fe42bc4a43e09db5f81210488b4f091a", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -139,13 +139,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ExprKind::Cast(expr, ty) => {\n                     let expr = self.lower_expr(expr);\n                     let ty =\n-                        self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                        self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Cast));\n                     hir::ExprKind::Cast(expr, ty)\n                 }\n                 ExprKind::Type(expr, ty) => {\n                     let expr = self.lower_expr(expr);\n                     let ty =\n-                        self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                        self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Cast));\n                     hir::ExprKind::Type(expr, ty)\n                 }\n                 ExprKind::AddrOf(k, m, ohs) => {"}, {"sha": "6bafbfbc14c736434928d400a33d49af769fa496", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -378,8 +378,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             )\n                         });\n \n-                        let lowered_ty = this\n-                            .lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                        let lowered_ty = this.lower_ty(\n+                            ty,\n+                            &ImplTraitContext::Disallowed(ImplTraitPosition::ImplSelf),\n+                        );\n \n                         (trait_ref, lowered_ty)\n                     });\n@@ -458,7 +460,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         span: Span,\n         body: Option<&Expr>,\n     ) -> (&'hir hir::Ty<'hir>, hir::BodyId) {\n-        let ty = self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+        let ty = self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::ConstTy));\n         (ty, self.lower_const_body(span, body))\n     }\n \n@@ -608,8 +610,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     hir::ForeignItemKind::Fn(fn_dec, fn_args, generics)\n                 }\n                 ForeignItemKind::Static(t, m, _) => {\n-                    let ty =\n-                        self.lower_ty(t, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                    let ty = self\n+                        .lower_ty(t, &ImplTraitContext::Disallowed(ImplTraitPosition::StaticTy));\n                     hir::ForeignItemKind::Static(ty, *m)\n                 }\n                 ForeignItemKind::TyAlias(..) => hir::ForeignItemKind::Type,\n@@ -679,11 +681,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 qself,\n                 path,\n                 ParamMode::ExplicitNamed, // no `'_` in declarations (Issue #61124)\n-                &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                &ImplTraitContext::Disallowed(ImplTraitPosition::FieldTy),\n             );\n             self.arena.alloc(t)\n         } else {\n-            self.lower_ty(&f.ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type))\n+            self.lower_ty(&f.ty, &ImplTraitContext::Disallowed(ImplTraitPosition::FieldTy))\n         };\n         let hir_id = self.lower_node_id(f.id);\n         self.lower_attrs(hir_id, &f.attrs);\n@@ -708,7 +710,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         let (generics, kind, has_default) = match &i.kind {\n             AssocItemKind::Const(_, ty, default) => {\n-                let ty = self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                let ty =\n+                    self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::ConstTy));\n                 let body = default.as_ref().map(|x| self.lower_const_body(i.span, Some(x)));\n                 (hir::Generics::empty(), hir::TraitItemKind::Const(ty, body), body.is_some())\n             }\n@@ -746,7 +749,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                     |this| {\n                         let ty = ty.as_ref().map(|x| {\n-                            this.lower_ty(x, &ImplTraitContext::Disallowed(ImplTraitPosition::Type))\n+                            this.lower_ty(\n+                                x,\n+                                &ImplTraitContext::Disallowed(ImplTraitPosition::AssocTy),\n+                            )\n                         });\n                         hir::TraitItemKind::Type(\n                             this.lower_param_bounds(\n@@ -805,7 +811,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         let (generics, kind) = match &i.kind {\n             AssocItemKind::Const(_, ty, expr) => {\n-                let ty = self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                let ty =\n+                    self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::ConstTy));\n                 (\n                     hir::Generics::empty(),\n                     hir::ImplItemKind::Const(ty, self.lower_const_body(i.span, expr.as_deref())),\n@@ -1441,7 +1448,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 hir_id: self.next_id(),\n                 bound_generic_params: self.lower_generic_params(bound_generic_params),\n                 bounded_ty: self\n-                    .lower_ty(bounded_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type)),\n+                    .lower_ty(bounded_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Bound)),\n                 bounds: self.arena.alloc_from_iter(bounds.iter().map(|bound| {\n                     self.lower_param_bound(\n                         bound,\n@@ -1465,9 +1472,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             WherePredicate::EqPredicate(WhereEqPredicate { lhs_ty, rhs_ty, span }) => {\n                 hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n                     lhs_ty: self\n-                        .lower_ty(lhs_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type)),\n+                        .lower_ty(lhs_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Bound)),\n                     rhs_ty: self\n-                        .lower_ty(rhs_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type)),\n+                        .lower_ty(rhs_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Bound)),\n                     span: self.lower_span(*span),\n                 })\n             }"}, {"sha": "b543be3be50839ffa0ef2eee5bd5068c922f4cec", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -253,7 +253,6 @@ enum ImplTraitContext {\n enum ImplTraitPosition {\n     Path,\n     Variable,\n-    Type,\n     Trait,\n     AsyncBlock,\n     Bound,\n@@ -270,14 +269,20 @@ enum ImplTraitPosition {\n     FnTraitReturn,\n     TraitReturn,\n     ImplReturn,\n+    GenericDefault,\n+    ConstTy,\n+    StaticTy,\n+    AssocTy,\n+    FieldTy,\n+    Cast,\n+    ImplSelf,\n }\n \n impl std::fmt::Display for ImplTraitPosition {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         let name = match self {\n             ImplTraitPosition::Path => \"path\",\n             ImplTraitPosition::Variable => \"variable binding\",\n-            ImplTraitPosition::Type => \"type\",\n             ImplTraitPosition::Trait => \"trait\",\n             ImplTraitPosition::AsyncBlock => \"async block\",\n             ImplTraitPosition::Bound => \"bound\",\n@@ -294,6 +299,13 @@ impl std::fmt::Display for ImplTraitPosition {\n             ImplTraitPosition::FnTraitReturn => \"`Fn` trait return\",\n             ImplTraitPosition::TraitReturn => \"trait method return\",\n             ImplTraitPosition::ImplReturn => \"`impl` method return\",\n+            ImplTraitPosition::GenericDefault => \"generic parameter default\",\n+            ImplTraitPosition::ConstTy => \"const type\",\n+            ImplTraitPosition::StaticTy => \"static type\",\n+            ImplTraitPosition::AssocTy => \"associated type\",\n+            ImplTraitPosition::FieldTy => \"field type\",\n+            ImplTraitPosition::Cast => \"cast type\",\n+            ImplTraitPosition::ImplSelf => \"impl header\",\n         };\n \n         write!(f, \"{name}\")\n@@ -2166,15 +2178,21 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             GenericParamKind::Type { default, .. } => {\n                 let kind = hir::GenericParamKind::Type {\n                     default: default.as_ref().map(|x| {\n-                        self.lower_ty(x, &ImplTraitContext::Disallowed(ImplTraitPosition::Type))\n+                        self.lower_ty(\n+                            x,\n+                            &ImplTraitContext::Disallowed(ImplTraitPosition::GenericDefault),\n+                        )\n                     }),\n                     synthetic: false,\n                 };\n \n                 (hir::ParamName::Plain(self.lower_ident(param.ident)), kind)\n             }\n             GenericParamKind::Const { ty, kw_span: _, default } => {\n-                let ty = self.lower_ty(&ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                let ty = self.lower_ty(\n+                    &ty,\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::GenericDefault),\n+                );\n                 let default = default.as_ref().map(|def| self.lower_anon_const(def));\n                 (\n                     hir::ParamName::Plain(self.lower_ident(param.ident)),"}, {"sha": "c4e4e0517ece3f73a0c1bf0f1a1c4334ea2499e9", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1144,7 +1144,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 LateBoundRegionConversionTime::FnCall,\n                                 tcx.fn_sig(method_did).subst(tcx, method_substs).input(0),\n                             )\n-                            && infcx.can_eq(self.param_env, ty, self_ty).is_ok()\n+                            && infcx.can_eq(self.param_env, ty, self_ty)\n                         {\n                             err.span_suggestion_verbose(\n                                 fn_call_span.shrink_to_lo(),"}, {"sha": "45f7c7560558461385ab86aba5df96a397bed13d", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -186,7 +186,7 @@ pub(super) fn op_to_const<'tcx>(\n                         0,\n                     ),\n                 };\n-                let len = b.to_machine_usize(ecx).unwrap();\n+                let len = b.to_target_usize(ecx).unwrap();\n                 let start = start.try_into().unwrap();\n                 let len: usize = len.try_into().unwrap();\n                 ConstValue::Slice { data, start, end: start + len }"}, {"sha": "a44f70ed0590634159dd145cc5c26d91e9b52fd9", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -244,7 +244,7 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n         assert_eq!(args.len(), 2);\n \n         let ptr = self.read_pointer(&args[0])?;\n-        let target_align = self.read_scalar(&args[1])?.to_machine_usize(self)?;\n+        let target_align = self.read_scalar(&args[1])?.to_target_usize(self)?;\n \n         if !target_align.is_power_of_two() {\n             throw_ub_format!(\"`align_offset` called with non-power-of-two align: {}\", target_align);\n@@ -276,7 +276,7 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n                     Ok(ControlFlow::Break(()))\n                 } else {\n                     // Not alignable in const, return `usize::MAX`.\n-                    let usize_max = Scalar::from_machine_usize(self.machine_usize_max(), self);\n+                    let usize_max = Scalar::from_target_usize(self.target_usize_max(), self);\n                     self.write_scalar(usize_max, dest)?;\n                     self.return_to_block(ret)?;\n                     Ok(ControlFlow::Break(()))\n@@ -470,8 +470,8 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                 ecx.write_scalar(Scalar::from_u8(cmp), dest)?;\n             }\n             sym::const_allocate => {\n-                let size = ecx.read_scalar(&args[0])?.to_machine_usize(ecx)?;\n-                let align = ecx.read_scalar(&args[1])?.to_machine_usize(ecx)?;\n+                let size = ecx.read_scalar(&args[0])?.to_target_usize(ecx)?;\n+                let align = ecx.read_scalar(&args[1])?.to_target_usize(ecx)?;\n \n                 let align = match Align::from_bytes(align) {\n                     Ok(a) => a,\n@@ -487,8 +487,8 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n             }\n             sym::const_deallocate => {\n                 let ptr = ecx.read_pointer(&args[0])?;\n-                let size = ecx.read_scalar(&args[1])?.to_machine_usize(ecx)?;\n-                let align = ecx.read_scalar(&args[2])?.to_machine_usize(ecx)?;\n+                let size = ecx.read_scalar(&args[1])?.to_target_usize(ecx)?;\n+                let align = ecx.read_scalar(&args[2])?.to_target_usize(ecx)?;\n \n                 let size = Size::from_bytes(size);\n                 let align = match Align::from_bytes(align) {"}, {"sha": "3cdf1e6e30c99f85f4303dce637d745f0ad3e4ff", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -155,7 +155,7 @@ pub(crate) fn deref_mir_constant<'tcx>(\n         // In case of unsized types, figure out the real type behind.\n         MemPlaceMeta::Meta(scalar) => match mplace.layout.ty.kind() {\n             ty::Str => bug!(\"there's no sized equivalent of a `str`\"),\n-            ty::Slice(elem_ty) => tcx.mk_array(*elem_ty, scalar.to_machine_usize(&tcx).unwrap()),\n+            ty::Slice(elem_ty) => tcx.mk_array(*elem_ty, scalar.to_target_usize(&tcx).unwrap()),\n             _ => bug!(\n                 \"type {} should not have metadata, but had {:?}\",\n                 mplace.layout.ty,"}, {"sha": "a73f778d4db2091471fe63bd08e84ba7a000a132", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -239,7 +239,7 @@ fn create_pointee_place<'tcx>(\n         MPlaceTy::from_aligned_ptr_with_meta(\n             ptr.into(),\n             layout,\n-            MemPlaceMeta::Meta(Scalar::from_machine_usize(num_elems as u64, &tcx)),\n+            MemPlaceMeta::Meta(Scalar::from_target_usize(num_elems as u64, &tcx)),\n         )\n     } else {\n         create_mplace_from_layout(ecx, ty)\n@@ -355,7 +355,7 @@ fn valtree_into_mplace<'tcx>(\n             let imm = match inner_ty.kind() {\n                 ty::Slice(_) | ty::Str => {\n                     let len = valtree.unwrap_branch().len();\n-                    let len_scalar = Scalar::from_machine_usize(len as u64, &tcx);\n+                    let len_scalar = Scalar::from_target_usize(len as u64, &tcx);\n \n                     Immediate::ScalarPair(\n                         Scalar::from_maybe_pointer((*pointee_place).ptr, &tcx),\n@@ -426,7 +426,7 @@ fn valtree_into_mplace<'tcx>(\n                         place\n                             .offset_with_meta(\n                                 offset,\n-                                MemPlaceMeta::Meta(Scalar::from_machine_usize(\n+                                MemPlaceMeta::Meta(Scalar::from_target_usize(\n                                     num_elems as u64,\n                                     &tcx,\n                                 )),"}, {"sha": "68a91eabda7b9ed6a0eeab25085f618810d59338", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -231,7 +231,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // First cast to usize.\n         let scalar = src.to_scalar();\n         let addr = self.cast_from_int_like(scalar, src.layout, self.tcx.types.usize)?;\n-        let addr = addr.to_machine_usize(self)?;\n+        let addr = addr.to_target_usize(self)?;\n \n         // Then turn address into pointer.\n         let ptr = M::ptr_from_addr_cast(&self, addr)?;"}, {"sha": "c8bf769cfd8b714928a5ced247366b20a852962c", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -639,7 +639,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             ty::Slice(_) | ty::Str => {\n-                let len = metadata.unwrap_meta().to_machine_usize(self)?;\n+                let len = metadata.unwrap_meta().to_target_usize(self)?;\n                 let elem = layout.field(self, 0);\n \n                 // Make sure the slice is not too big."}, {"sha": "8877bb479d488e294ffbc16366dd356dd7e7a4cb", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -71,15 +71,15 @@ pub(crate) fn eval_nullary_intrinsic<'tcx>(\n         sym::pref_align_of => {\n             // Correctly handles non-monomorphic calls, so there is no need for ensure_monomorphic_enough.\n             let layout = tcx.layout_of(param_env.and(tp_ty)).map_err(|e| err_inval!(Layout(e)))?;\n-            ConstValue::from_machine_usize(layout.align.pref.bytes(), &tcx)\n+            ConstValue::from_target_usize(layout.align.pref.bytes(), &tcx)\n         }\n         sym::type_id => {\n             ensure_monomorphic_enough(tcx, tp_ty)?;\n             ConstValue::from_u64(tcx.type_id_hash(tp_ty))\n         }\n         sym::variant_count => match tp_ty.kind() {\n             // Correctly handles non-monomorphic calls, so there is no need for ensure_monomorphic_enough.\n-            ty::Adt(adt, _) => ConstValue::from_machine_usize(adt.variants().len() as u64, &tcx),\n+            ty::Adt(adt, _) => ConstValue::from_target_usize(adt.variants().len() as u64, &tcx),\n             ty::Alias(..) | ty::Param(_) | ty::Placeholder(_) | ty::Infer(_) => {\n                 throw_inval!(TooGeneric)\n             }\n@@ -104,7 +104,7 @@ pub(crate) fn eval_nullary_intrinsic<'tcx>(\n             | ty::GeneratorWitnessMIR(_, _)\n             | ty::Never\n             | ty::Tuple(_)\n-            | ty::Error(_) => ConstValue::from_machine_usize(0u64, &tcx),\n+            | ty::Error(_) => ConstValue::from_target_usize(0u64, &tcx),\n         },\n         other => bug!(\"`{}` is not a zero arg intrinsic\", other),\n     })\n@@ -156,7 +156,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     _ => bug!(),\n                 };\n \n-                self.write_scalar(Scalar::from_machine_usize(result, self), dest)?;\n+                self.write_scalar(Scalar::from_target_usize(result, self), dest)?;\n             }\n \n             sym::pref_align_of\n@@ -302,15 +302,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             sym::offset => {\n                 let ptr = self.read_pointer(&args[0])?;\n-                let offset_count = self.read_machine_isize(&args[1])?;\n+                let offset_count = self.read_target_isize(&args[1])?;\n                 let pointee_ty = substs.type_at(0);\n \n                 let offset_ptr = self.ptr_offset_inbounds(ptr, pointee_ty, offset_count)?;\n                 self.write_pointer(offset_ptr, dest)?;\n             }\n             sym::arith_offset => {\n                 let ptr = self.read_pointer(&args[0])?;\n-                let offset_count = self.read_machine_isize(&args[1])?;\n+                let offset_count = self.read_target_isize(&args[1])?;\n                 let pointee_ty = substs.type_at(0);\n \n                 let pointee_size = i64::try_from(self.layout_of(pointee_ty)?.size.bytes()).unwrap();\n@@ -376,7 +376,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         // The signed form of the intrinsic allows this. If we interpret the\n                         // difference as isize, we'll get the proper signed difference. If that\n                         // seems *positive*, they were more than isize::MAX apart.\n-                        let dist = val.to_machine_isize(self)?;\n+                        let dist = val.to_target_isize(self)?;\n                         if dist >= 0 {\n                             throw_ub_format!(\n                                 \"`{}` called when first pointer is too far before second\",\n@@ -386,7 +386,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         dist\n                     } else {\n                         // b >= a\n-                        let dist = val.to_machine_isize(self)?;\n+                        let dist = val.to_target_isize(self)?;\n                         // If converting to isize produced a *negative* result, we had an overflow\n                         // because they were more than isize::MAX apart.\n                         if dist < 0 {\n@@ -411,10 +411,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n                 // Perform division by size to compute return value.\n                 let ret_layout = if intrinsic_name == sym::ptr_offset_from_unsigned {\n-                    assert!(0 <= dist && dist <= self.machine_isize_max());\n+                    assert!(0 <= dist && dist <= self.target_isize_max());\n                     usize_layout\n                 } else {\n-                    assert!(self.machine_isize_min() <= dist && dist <= self.machine_isize_max());\n+                    assert!(self.target_isize_min() <= dist && dist <= self.target_isize_max());\n                     isize_layout\n                 };\n                 let pointee_layout = self.layout_of(substs.type_at(0))?;\n@@ -531,12 +531,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             sym::vtable_size => {\n                 let ptr = self.read_pointer(&args[0])?;\n                 let (size, _align) = self.get_vtable_size_and_align(ptr)?;\n-                self.write_scalar(Scalar::from_machine_usize(size.bytes(), self), dest)?;\n+                self.write_scalar(Scalar::from_target_usize(size.bytes(), self), dest)?;\n             }\n             sym::vtable_align => {\n                 let ptr = self.read_pointer(&args[0])?;\n                 let (_size, align) = self.get_vtable_size_and_align(ptr)?;\n-                self.write_scalar(Scalar::from_machine_usize(align.bytes(), self), dest)?;\n+                self.write_scalar(Scalar::from_target_usize(align.bytes(), self), dest)?;\n             }\n \n             _ => return Ok(false),\n@@ -675,10 +675,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         count: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::Provenance>,\n         nonoverlapping: bool,\n     ) -> InterpResult<'tcx> {\n-        let count = self.read_machine_usize(&count)?;\n+        let count = self.read_target_usize(&count)?;\n         let layout = self.layout_of(src.layout.ty.builtin_deref(true).unwrap().ty)?;\n         let (size, align) = (layout.size, layout.align.abi);\n-        // `checked_mul` enforces a too small bound (the correct one would probably be machine_isize_max),\n+        // `checked_mul` enforces a too small bound (the correct one would probably be target_isize_max),\n         // but no actual allocation can be big enough for the difference to be noticeable.\n         let size = size.checked_mul(count, self).ok_or_else(|| {\n             err_ub_format!(\n@@ -703,9 +703,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         let dst = self.read_pointer(&dst)?;\n         let byte = self.read_scalar(&byte)?.to_u8()?;\n-        let count = self.read_machine_usize(&count)?;\n+        let count = self.read_target_usize(&count)?;\n \n-        // `checked_mul` enforces a too small bound (the correct one would probably be machine_isize_max),\n+        // `checked_mul` enforces a too small bound (the correct one would probably be target_isize_max),\n         // but no actual allocation can be big enough for the difference to be noticeable.\n         let len = layout\n             .size"}, {"sha": "635987d039e09342742bd4c2582343ff8a577539", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -425,7 +425,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     throw_ub!(PointerOutOfBounds {\n                         alloc_id,\n                         alloc_size,\n-                        ptr_offset: self.machine_usize_to_isize(offset.bytes()),\n+                        ptr_offset: self.target_usize_to_isize(offset.bytes()),\n                         ptr_size: size,\n                         msg,\n                     })"}, {"sha": "ba41019aa938c5d27e8ae79fcd555b56273711cf", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -52,7 +52,7 @@ impl<Prov: Provenance> Immediate<Prov> {\n     }\n \n     pub fn new_slice(val: Scalar<Prov>, len: u64, cx: &impl HasDataLayout) -> Self {\n-        Immediate::ScalarPair(val, Scalar::from_machine_usize(len, cx))\n+        Immediate::ScalarPair(val, Scalar::from_target_usize(len, cx))\n     }\n \n     pub fn new_dyn_trait(\n@@ -414,12 +414,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.read_scalar(op)?.to_pointer(self)\n     }\n     /// Read a pointer-sized unsigned integer from a place.\n-    pub fn read_machine_usize(&self, op: &OpTy<'tcx, M::Provenance>) -> InterpResult<'tcx, u64> {\n-        self.read_scalar(op)?.to_machine_usize(self)\n+    pub fn read_target_usize(&self, op: &OpTy<'tcx, M::Provenance>) -> InterpResult<'tcx, u64> {\n+        self.read_scalar(op)?.to_target_usize(self)\n     }\n     /// Read a pointer-sized signed integer from a place.\n-    pub fn read_machine_isize(&self, op: &OpTy<'tcx, M::Provenance>) -> InterpResult<'tcx, i64> {\n-        self.read_scalar(op)?.to_machine_isize(self)\n+    pub fn read_target_isize(&self, op: &OpTy<'tcx, M::Provenance>) -> InterpResult<'tcx, i64> {\n+        self.read_scalar(op)?.to_target_isize(self)\n     }\n \n     /// Turn the wide MPlace into a string (must already be dereferenced!)"}, {"sha": "88485c06ed86cde303c10f226586c74cd59a60ba", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -229,7 +229,7 @@ impl<'tcx, Prov: Provenance> MPlaceTy<'tcx, Prov> {\n         if self.layout.is_unsized() {\n             // We need to consult `meta` metadata\n             match self.layout.ty.kind() {\n-                ty::Slice(..) | ty::Str => self.mplace.meta.unwrap_meta().to_machine_usize(cx),\n+                ty::Slice(..) | ty::Str => self.mplace.meta.unwrap_meta().to_target_usize(cx),\n                 _ => bug!(\"len not supported on unsized type {:?}\", self.layout.ty),\n             }\n         } else {\n@@ -756,7 +756,7 @@ where\n         mutbl: Mutability,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::Provenance>> {\n         let ptr = self.allocate_bytes_ptr(str.as_bytes(), Align::ONE, kind, mutbl)?;\n-        let meta = Scalar::from_machine_usize(u64::try_from(str.len()).unwrap(), self);\n+        let meta = Scalar::from_target_usize(u64::try_from(str.len()).unwrap(), self);\n         let mplace = MemPlace { ptr: ptr.into(), meta: MemPlaceMeta::Meta(meta) };\n \n         let ty = self.tcx.mk_ref("}, {"sha": "91da930db4fbf121be79afbba9b62a3a9a50128d", "filename": "compiler/rustc_const_eval/src/interpret/projection.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -319,7 +319,7 @@ where\n             // implement this.\n             ty::Array(inner, _) => (MemPlaceMeta::None, self.tcx.mk_array(*inner, inner_len)),\n             ty::Slice(..) => {\n-                let len = Scalar::from_machine_usize(inner_len, self);\n+                let len = Scalar::from_target_usize(inner_len, self);\n                 (MemPlaceMeta::Meta(len), base.layout.ty)\n             }\n             _ => {\n@@ -363,7 +363,7 @@ where\n             Index(local) => {\n                 let layout = self.layout_of(self.tcx.types.usize)?;\n                 let n = self.local_to_op(self.frame(), local, Some(layout))?;\n-                let n = self.read_machine_usize(&n)?;\n+                let n = self.read_target_usize(&n)?;\n                 self.place_index(base, n)?\n             }\n             ConstantIndex { offset, min_length, from_end } => {\n@@ -392,7 +392,7 @@ where\n             Index(local) => {\n                 let layout = self.layout_of(self.tcx.types.usize)?;\n                 let n = self.local_to_op(self.frame(), local, Some(layout))?;\n-                let n = self.read_machine_usize(&n)?;\n+                let n = self.read_target_usize(&n)?;\n                 self.operand_index(base, n)?\n             }\n             ConstantIndex { offset, min_length, from_end } => {"}, {"sha": "8252e73c5d9374624ddaaebddb0ac5c617dfb108", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -242,7 +242,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let src = self.eval_place(place)?;\n                 let op = self.place_to_op(&src)?;\n                 let len = op.len(self)?;\n-                self.write_scalar(Scalar::from_machine_usize(len, self), &dest)?;\n+                self.write_scalar(Scalar::from_target_usize(len, self), &dest)?;\n             }\n \n             Ref(_, borrow_kind, place) => {\n@@ -297,7 +297,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     mir::NullOp::SizeOf => layout.size.bytes(),\n                     mir::NullOp::AlignOf => layout.align.abi.bytes(),\n                 };\n-                self.write_scalar(Scalar::from_machine_usize(val, self), &dest)?;\n+                self.write_scalar(Scalar::from_target_usize(val, self), &dest)?;\n             }\n \n             ShallowInitBox(ref operand, _) => {"}, {"sha": "820ee320474248d76d31f8fc886c1873b2b1d81d", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -348,7 +348,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 // FIXME: check if the type/trait match what ty::Dynamic says?\n             }\n             ty::Slice(..) | ty::Str => {\n-                let _len = meta.unwrap_meta().to_machine_usize(self.ecx)?;\n+                let _len = meta.unwrap_meta().to_target_usize(self.ecx)?;\n                 // We do not check that `len * elem_size <= isize::MAX`:\n                 // that is only required for references, and there it falls out of the\n                 // \"dereferenceable\" check performed by Stacked Borrows."}, {"sha": "c5b2b6c2d735758dddf390e189091c1e96ba6306", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -140,6 +140,18 @@ infer_lifetime_param_suggestion_elided = each elided lifetime in input position\n \n infer_region_explanation = {$pref_kind ->\n     *[should_not_happen] [{$pref_kind}]\n+    [ref_valid_for] ...the reference is valid for\n+    [content_valid_for] ...but the borrowed content is only valid for\n+    [type_obj_valid_for] object type is valid for\n+    [source_pointer_valid_for] source pointer is only valid for\n+    [type_satisfy] type must satisfy\n+    [type_outlive] type must outlive\n+    [lf_param_instantiated_with] lifetime parameter instantiated with\n+    [lf_param_must_outlive] but lifetime parameter must outlive\n+    [lf_instantiated_with] lifetime instantiated with\n+    [lf_must_outlive] but lifetime must outlive\n+    [pointer_valid_for] the pointer is valid for\n+    [data_valid_for] but the referenced data is only valid for\n     [empty] {\"\"}\n }{$pref_kind ->\n     [empty] {\"\"}\n@@ -148,7 +160,6 @@ infer_region_explanation = {$pref_kind ->\n     *[should_not_happen] [{$desc_kind}]\n     [restatic] the static lifetime\n     [revar] lifetime {$desc_arg}\n-\n     [as_defined] the lifetime `{$desc_arg}` as defined here\n     [as_defined_anon] the anonymous lifetime as defined here\n     [defined_here] the anonymous lifetime defined here\n@@ -158,8 +169,16 @@ infer_region_explanation = {$pref_kind ->\n     *[should_not_happen] [{$suff_kind}]\n     [empty]{\"\"}\n     [continues] ...\n+    [req_by_binding] {\" \"}as required by this binding\n }\n \n+infer_outlives_content = lifetime of reference outlives lifetime of borrowed content...\n+infer_outlives_bound = lifetime of the source pointer does not outlive lifetime bound of the object type\n+infer_fullfill_req_lifetime = the type `{$ty}` does not fulfill the required lifetime\n+infer_lf_bound_not_satisfied = lifetime bound not satisfied\n+infer_borrowed_too_long = a value of type `{$ty}` is borrowed for too long\n+infer_ref_longer_than_data = in type `{$ty}`, reference has a longer lifetime than the data it references\n+\n infer_mismatched_static_lifetime = incompatible lifetime on type\n infer_does_not_outlive_static_from_impl = ...does not necessarily outlive the static lifetime introduced by the compatible `impl`\n infer_implicit_static_lifetime_note = this has an implicit `'static` lifetime requirement\n@@ -308,3 +327,21 @@ infer_ril_introduced_here = `'static` requirement introduced here\n infer_ril_introduced_by = requirement introduced by this return type\n infer_ril_because_of = because of this returned expression\n infer_ril_static_introduced_by = \"`'static` lifetime requirement introduced by the return type\n+\n+infer_where_remove = remove the `where` clause\n+infer_where_copy_predicates = copy the `where` clause predicates from the trait\n+\n+infer_srs_remove_and_box = consider removing this semicolon and boxing the expressions\n+infer_srs_remove = consider removing this semicolon\n+infer_srs_add = consider returning the local binding `{$ident}`\n+infer_srs_add_one = consider returning one of these bindings\n+\n+infer_await_both_futures = consider `await`ing on both `Future`s\n+infer_await_future = consider `await`ing on the `Future`\n+infer_await_note = calling an async function returns a future\n+\n+infer_prlf_defined_with_sub = the lifetime `{$sub_symbol}` defined here...\n+infer_prlf_defined_without_sub = the lifetime defined here...\n+infer_prlf_must_oultive_with_sup = ...must outlive the lifetime `{$sup_symbol}` defined here\n+infer_prlf_must_oultive_without_sup = ...must outlive the lifetime defined here\n+infer_prlf_known_limitation = this is a known limitation that will be removed in the future (see issue #100013 <https://github.com/rust-lang/rust/issues/100013> for more information)"}, {"sha": "0a243b47b5c71e81bc7b6ff72c90661f64baeb51", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -2232,7 +2232,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                         tcx.erase_regions(impl_.self_ty()),\n                                         tcx.erase_regions(qself_ty),\n                                     )\n-                                    .is_ok()\n                             })\n                             && tcx.impl_polarity(impl_def_id) != ty::ImplPolarity::Negative\n                         })"}, {"sha": "6b0eade2d32666b726a461f1afa1995727de4966", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1106,7 +1106,7 @@ fn compare_self_type<'tcx>(\n \n         let infcx = tcx.infer_ctxt().build();\n         let self_arg_ty = tcx.liberate_late_bound_regions(method.def_id, self_arg_ty);\n-        let can_eq_self = |ty| infcx.can_eq(param_env, untransformed_self_ty, ty).is_ok();\n+        let can_eq_self = |ty| infcx.can_eq(param_env, untransformed_self_ty, ty);\n         match ExplicitSelf::determine(self_arg_ty, can_eq_self) {\n             ExplicitSelf::ByValue => \"self\".to_owned(),\n             ExplicitSelf::ByReference(_, hir::Mutability::Not) => \"&self\".to_owned(),"}, {"sha": "c64d507f82848772c1bf8480a5d5b9c8cabe3e86", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1716,7 +1716,7 @@ fn receiver_is_valid<'tcx>(\n     let cause =\n         ObligationCause::new(span, wfcx.body_def_id, traits::ObligationCauseCode::MethodReceiver);\n \n-    let can_eq_self = |ty| infcx.can_eq(wfcx.param_env, self_ty, ty).is_ok();\n+    let can_eq_self = |ty| infcx.can_eq(wfcx.param_env, self_ty, ty);\n \n     // `self: Self` is always valid.\n     if can_eq_self(receiver_ty) {"}, {"sha": "149c7dbef22f5d0dbdb8cac7024abb7495b02fa9", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -321,7 +321,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let mut param_args = FxHashMap::default();\n                 let mut param_expected = FxHashMap::default();\n                 let mut param_found = FxHashMap::default();\n-                if self.can_eq(self.param_env, ty, found).is_ok() {\n+                if self.can_eq(self.param_env, ty, found) {\n                     // We only point at the first place where the found type was inferred.\n                     for (i, param_ty) in sig.inputs().skip_binder().iter().skip(1).enumerate() {\n                         if def_self_ty.contains(*param_ty) && let ty::Param(_) = param_ty.kind() {\n@@ -369,7 +369,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 for (param, (arg, arg_ty)) in param_args.iter() {\n                     let Some(expected) = param_expected.get(param) else { continue; };\n                     let Some(found) = param_found.get(param) else { continue; };\n-                    if self.can_eq(self.param_env, *arg_ty, *found).is_err() { continue; }\n+                    if !self.can_eq(self.param_env, *arg_ty, *found) { continue; }\n                     self.emit_coerce_suggestions(err, arg, *found, *expected, None, None);\n                 }\n \n@@ -379,7 +379,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n                 if ty != prev\n                     && param_args.is_empty()\n-                    && self.can_eq(self.param_env, ty, found).is_ok()\n+                    && self.can_eq(self.param_env, ty, found)\n                 {\n                     // We only point at the first place where the found type was inferred.\n                     if !segment.ident.span.overlaps(mismatch_span) {\n@@ -401,7 +401,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n                 if ty != prev\n                     && let Some(span) = prev_span\n-                    && self.can_eq(self.param_env, ty, found).is_ok()\n+                    && self.can_eq(self.param_env, ty, found)\n                 {\n                     // We only point at the first place where the found type was inferred.\n                     // We use the *previous* span because if the type is known *here* it means\n@@ -764,7 +764,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if let ty::Adt(expected_adt, substs) = expected.kind() {\n             if let hir::ExprKind::Field(base, ident) = expr.kind {\n                 let base_ty = self.typeck_results.borrow().expr_ty(base);\n-                if self.can_eq(self.param_env, base_ty, expected).is_ok()\n+                if self.can_eq(self.param_env, base_ty, expected)\n                     && let Some(base_span) = base.span.find_ancestor_inside(expr.span)\n                 {\n                     err.span_suggestion_verbose(\n@@ -1357,7 +1357,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, ref expr),\n                 _,\n                 &ty::Ref(_, checked, _),\n-            ) if self.can_sub(self.param_env, checked, expected).is_ok() => {\n+            ) if self.can_sub(self.param_env, checked, expected) => {\n                 // We have `&T`, check if what was expected was `T`. If so,\n                 // we may want to suggest removing a `&`.\n                 if sm.is_imported(expr.span) {\n@@ -2003,7 +2003,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n         let hir::StmtKind::Semi(tail_expr) = stmt.kind else { return; };\n         let Some(ty) = self.node_ty_opt(tail_expr.hir_id) else { return; };\n-        if self.can_eq(self.param_env, expected_ty, ty).is_ok() {\n+        if self.can_eq(self.param_env, expected_ty, ty) {\n             err.span_suggestion_short(\n                 stmt.span.with_lo(tail_expr.span.hi()),\n                 \"remove this semicolon\","}, {"sha": "7ce721e94cb238d938403bac1b78e48404051f31", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1015,7 +1015,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let expr_inner_ty = substs.type_at(0);\n             let expected_inner_ty = expected_substs.type_at(0);\n             if let ty::Ref(_, ty, hir::Mutability::Not) = expr_inner_ty.kind()\n-                && self.can_eq(self.param_env, *ty, expected_inner_ty).is_ok()\n+                && self.can_eq(self.param_env, *ty, expected_inner_ty)\n             {\n                 let def_path = self.tcx.def_path_str(adt_def.did());\n                 if self.type_is_copy_modulo_regions(self.param_env, *ty, expr.span) {\n@@ -1054,7 +1054,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if let Some(result_did) = self.tcx.get_diagnostic_item(sym::Result)\n             && adt_def.did() == result_did\n             // Check that the error types are equal\n-            && self.can_eq(self.param_env, substs.type_at(1), expected_substs.type_at(1)).is_ok()\n+            && self.can_eq(self.param_env, substs.type_at(1), expected_substs.type_at(1))\n         {\n             return suggest_copied_or_cloned();\n         } else if let Some(option_did) = self.tcx.get_diagnostic_item(sym::Option)"}, {"sha": "287a5bf0067c39f15b648a32758cdd41626bf936", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -936,7 +936,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         return false;\n                     }\n                 }\n-                self.can_sub(self.param_env, fty.output(), expected).is_ok()\n+                self.can_sub(self.param_env, fty.output(), expected)\n             }),\n             _ => false,\n         }"}, {"sha": "3881efe87db5c4030cd11920b9f73210c718db2d", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -90,7 +90,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             self.demand_eqtype_with_origin(&self.pattern_cause(ti, cause_span), expected, actual)?;\n         if let Some(expr) = ti.origin_expr {\n             self.suggest_fn_call(&mut diag, expr, expected, |output| {\n-                self.can_eq(self.param_env, output, actual).is_ok()\n+                self.can_eq(self.param_env, output, actual)\n             });\n         }\n         Some(diag)\n@@ -675,7 +675,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) {\n         match (expected.kind(), actual.kind(), ba) {\n             (ty::Ref(_, inner_ty, _), _, hir::BindingAnnotation::NONE)\n-                if self.can_eq(self.param_env, *inner_ty, actual).is_ok() =>\n+                if self.can_eq(self.param_env, *inner_ty, actual) =>\n             {\n                 err.span_suggestion_verbose(\n                     span.shrink_to_lo(),\n@@ -685,7 +685,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n             }\n             (_, ty::Ref(_, inner_ty, _), hir::BindingAnnotation::REF)\n-                if self.can_eq(self.param_env, expected, *inner_ty).is_ok() =>\n+                if self.can_eq(self.param_env, expected, *inner_ty) =>\n             {\n                 err.span_suggestion_verbose(\n                     span.with_hi(span.lo() + BytePos(4)),"}, {"sha": "0c2713fb1a7c80d61620f700017799b5c5ea0b5d", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -933,3 +933,216 @@ pub struct ButNeedsToSatisfy {\n     pub has_lifetime: bool,\n     pub lifetime: String,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_outlives_content, code = \"E0312\")]\n+pub struct OutlivesContent<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub notes: Vec<note_and_explain::RegionExplanation<'a>>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_outlives_bound, code = \"E0476\")]\n+pub struct OutlivesBound<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub notes: Vec<note_and_explain::RegionExplanation<'a>>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_fullfill_req_lifetime, code = \"E0477\")]\n+pub struct FullfillReqLifetime<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: Ty<'a>,\n+    #[subdiagnostic]\n+    pub note: Option<note_and_explain::RegionExplanation<'a>>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_lf_bound_not_satisfied, code = \"E0478\")]\n+pub struct LfBoundNotSatisfied<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub notes: Vec<note_and_explain::RegionExplanation<'a>>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_ref_longer_than_data, code = \"E0491\")]\n+pub struct RefLongerThanData<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: Ty<'a>,\n+    #[subdiagnostic]\n+    pub notes: Vec<note_and_explain::RegionExplanation<'a>>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum WhereClauseSuggestions {\n+    #[suggestion(\n+        infer_where_remove,\n+        code = \"\",\n+        applicability = \"machine-applicable\",\n+        style = \"verbose\"\n+    )]\n+    Remove {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[suggestion(\n+        infer_where_copy_predicates,\n+        code = \"{space}where {trait_predicates}\",\n+        applicability = \"machine-applicable\",\n+        style = \"verbose\"\n+    )]\n+    CopyPredicates {\n+        #[primary_span]\n+        span: Span,\n+        space: &'static str,\n+        trait_predicates: String,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum SuggestRemoveSemiOrReturnBinding {\n+    #[multipart_suggestion(infer_srs_remove_and_box, applicability = \"machine-applicable\")]\n+    RemoveAndBox {\n+        #[suggestion_part(code = \"Box::new(\")]\n+        first_lo: Span,\n+        #[suggestion_part(code = \")\")]\n+        first_hi: Span,\n+        #[suggestion_part(code = \"Box::new(\")]\n+        second_lo: Span,\n+        #[suggestion_part(code = \")\")]\n+        second_hi: Span,\n+        #[suggestion_part(code = \"\")]\n+        sp: Span,\n+    },\n+    #[suggestion(\n+        infer_srs_remove,\n+        style = \"short\",\n+        code = \"\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    Remove {\n+        #[primary_span]\n+        sp: Span,\n+    },\n+    #[suggestion(\n+        infer_srs_add,\n+        style = \"verbose\",\n+        code = \"{code}\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    Add {\n+        #[primary_span]\n+        sp: Span,\n+        code: String,\n+        ident: Ident,\n+    },\n+    #[note(infer_srs_add_one)]\n+    AddOne {\n+        #[primary_span]\n+        spans: MultiSpan,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum ConsiderAddingAwait {\n+    #[help(infer_await_both_futures)]\n+    BothFuturesHelp,\n+    #[multipart_suggestion(infer_await_both_futures, applicability = \"maybe-incorrect\")]\n+    BothFuturesSugg {\n+        #[suggestion_part(code = \".await\")]\n+        first: Span,\n+        #[suggestion_part(code = \".await\")]\n+        second: Span,\n+    },\n+    #[suggestion(\n+        infer_await_future,\n+        code = \".await\",\n+        style = \"verbose\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    FutureSugg {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[note(infer_await_note)]\n+    FutureSuggNote {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[multipart_suggestion(\n+        infer_await_future,\n+        style = \"verbose\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    FutureSuggMultiple {\n+        #[suggestion_part(code = \".await\")]\n+        spans: Vec<Span>,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+pub enum PlaceholderRelationLfNotSatisfied {\n+    #[diag(infer_lf_bound_not_satisfied)]\n+    HasBoth {\n+        #[primary_span]\n+        span: Span,\n+        #[note(infer_prlf_defined_with_sub)]\n+        sub_span: Span,\n+        #[note(infer_prlf_must_oultive_with_sup)]\n+        sup_span: Span,\n+        sub_symbol: Symbol,\n+        sup_symbol: Symbol,\n+        #[note(infer_prlf_known_limitation)]\n+        note: (),\n+    },\n+    #[diag(infer_lf_bound_not_satisfied)]\n+    HasSub {\n+        #[primary_span]\n+        span: Span,\n+        #[note(infer_prlf_defined_with_sub)]\n+        sub_span: Span,\n+        #[note(infer_prlf_must_oultive_without_sup)]\n+        sup_span: Span,\n+        sub_symbol: Symbol,\n+        #[note(infer_prlf_known_limitation)]\n+        note: (),\n+    },\n+    #[diag(infer_lf_bound_not_satisfied)]\n+    HasSup {\n+        #[primary_span]\n+        span: Span,\n+        #[note(infer_prlf_defined_without_sub)]\n+        sub_span: Span,\n+        #[note(infer_prlf_must_oultive_with_sup)]\n+        sup_span: Span,\n+        sup_symbol: Symbol,\n+        #[note(infer_prlf_known_limitation)]\n+        note: (),\n+    },\n+    #[diag(infer_lf_bound_not_satisfied)]\n+    HasNone {\n+        #[primary_span]\n+        span: Span,\n+        #[note(infer_prlf_defined_without_sub)]\n+        sub_span: Span,\n+        #[note(infer_prlf_must_oultive_without_sup)]\n+        sup_span: Span,\n+        #[note(infer_prlf_known_limitation)]\n+        note: (),\n+    },\n+    #[diag(infer_lf_bound_not_satisfied)]\n+    OnlyPrimarySpan {\n+        #[primary_span]\n+        span: Span,\n+        #[note(infer_prlf_known_limitation)]\n+        note: (),\n+    },\n+}"}, {"sha": "cb96aeec5f34f4c11d83ad3feb83d74d98e9d920", "filename": "compiler/rustc_infer/src/errors/note_and_explain.rs", "status": "modified", "additions": 37, "deletions": 7, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -121,16 +121,42 @@ impl<'a> DescriptionCtx<'a> {\n \n pub enum PrefixKind {\n     Empty,\n+    RefValidFor,\n+    ContentValidFor,\n+    TypeObjValidFor,\n+    SourcePointerValidFor,\n+    TypeSatisfy,\n+    TypeOutlive,\n+    LfParamInstantiatedWith,\n+    LfParamMustOutlive,\n+    LfInstantiatedWith,\n+    LfMustOutlive,\n+    PointerValidFor,\n+    DataValidFor,\n }\n \n pub enum SuffixKind {\n+    Empty,\n     Continues,\n+    ReqByBinding,\n }\n \n impl IntoDiagnosticArg for PrefixKind {\n     fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n         let kind = match self {\n             Self::Empty => \"empty\",\n+            Self::RefValidFor => \"ref_valid_for\",\n+            Self::ContentValidFor => \"content_valid_for\",\n+            Self::TypeObjValidFor => \"type_obj_valid_for\",\n+            Self::SourcePointerValidFor => \"source_pointer_valid_for\",\n+            Self::TypeSatisfy => \"type_satisfy\",\n+            Self::TypeOutlive => \"type_outlive\",\n+            Self::LfParamInstantiatedWith => \"lf_param_instantiated_with\",\n+            Self::LfParamMustOutlive => \"lf_param_must_outlive\",\n+            Self::LfInstantiatedWith => \"lf_instantiated_with\",\n+            Self::LfMustOutlive => \"lf_must_outlive\",\n+            Self::PointerValidFor => \"pointer_valid_for\",\n+            Self::DataValidFor => \"data_valid_for\",\n         }\n         .into();\n         rustc_errors::DiagnosticArgValue::Str(kind)\n@@ -140,7 +166,9 @@ impl IntoDiagnosticArg for PrefixKind {\n impl IntoDiagnosticArg for SuffixKind {\n     fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n         let kind = match self {\n+            Self::Empty => \"empty\",\n             Self::Continues => \"continues\",\n+            Self::ReqByBinding => \"req_by_binding\",\n         }\n         .into();\n         rustc_errors::DiagnosticArgValue::Str(kind)\n@@ -166,17 +194,19 @@ impl RegionExplanation<'_> {\n }\n \n impl AddToDiagnostic for RegionExplanation<'_> {\n-    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, f: F)\n     where\n         F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n     {\n-        if let Some(span) = self.desc.span {\n-            diag.span_note(span, fluent::infer_region_explanation);\n-        } else {\n-            diag.note(fluent::infer_region_explanation);\n-        }\n-        self.desc.add_to(diag);\n         diag.set_arg(\"pref_kind\", self.prefix);\n         diag.set_arg(\"suff_kind\", self.suffix);\n+        let desc_span = self.desc.span;\n+        self.desc.add_to(diag);\n+        let msg = f(diag, fluent::infer_region_explanation.into());\n+        if let Some(span) = desc_span {\n+            diag.span_note(span, msg);\n+        } else {\n+            diag.note(msg);\n+        }\n     }\n }"}, {"sha": "bb7947e3141ba7bde55a53a9620201737d644671", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -751,15 +751,16 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     };\n                     let msg = \"`match` arms have incompatible types\";\n                     err.span_label(outer, msg);\n-                    self.suggest_remove_semi_or_return_binding(\n-                        err,\n+                    if let Some(subdiag) = self.suggest_remove_semi_or_return_binding(\n                         prior_arm_block_id,\n                         prior_arm_ty,\n                         prior_arm_span,\n                         arm_block_id,\n                         arm_ty,\n                         arm_span,\n-                    );\n+                    ) {\n+                        err.subdiagnostic(subdiag);\n+                    }\n                     if let Some(ret_sp) = opt_suggest_box_span {\n                         // Get return type span and point to it.\n                         self.suggest_boxing_for_return_impl_trait(\n@@ -784,15 +785,16 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 if let Some(sp) = outer_span {\n                     err.span_label(sp, \"`if` and `else` have incompatible types\");\n                 }\n-                self.suggest_remove_semi_or_return_binding(\n-                    err,\n+                if let Some(subdiag) = self.suggest_remove_semi_or_return_binding(\n                     Some(then_id),\n                     then_ty,\n                     then_span,\n                     Some(else_id),\n                     else_ty,\n                     else_span,\n-                );\n+                ) {\n+                    err.subdiagnostic(subdiag);\n+                }\n                 if let Some(ret_sp) = opt_suggest_box_span {\n                     self.suggest_boxing_for_return_impl_trait(\n                         err,"}, {"sha": "e8d94f0c04eaaa69db8eddaa0f8d3fca09f241bc", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/placeholder_relation.rs", "status": "modified", "additions": 37, "deletions": 29, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_relation.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,5 +1,8 @@\n-use crate::infer::{\n-    error_reporting::nice_region_error::NiceRegionError, RegionResolutionError, SubregionOrigin,\n+use crate::{\n+    errors::PlaceholderRelationLfNotSatisfied,\n+    infer::{\n+        error_reporting::nice_region_error::NiceRegionError, RegionResolutionError, SubregionOrigin,\n+    },\n };\n use rustc_data_structures::intern::Interned;\n use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed};\n@@ -16,8 +19,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n                 Region(Interned(RePlaceholder(ty::Placeholder { name: sub_name, .. }), _)),\n                 Region(Interned(RePlaceholder(ty::Placeholder { name: sup_name, .. }), _)),\n             )) => {\n-                let msg = \"lifetime bound not satisfied\";\n-                let mut err = self.tcx().sess.struct_span_err(*span, msg);\n+                let span = *span;\n                 let (sub_span, sub_symbol) = match sub_name {\n                     ty::BrNamed(def_id, symbol) => {\n                         (Some(self.tcx().def_span(def_id)), Some(symbol))\n@@ -32,41 +34,47 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n                     ty::BrAnon(_, span) => (*span, None),\n                     ty::BrEnv => (None, None),\n                 };\n-                match (sub_span, sup_span, sub_symbol, sup_symbol) {\n-                    (Some(sub_span), Some(sup_span), Some(sub_symbol), Some(sup_symbol)) => {\n-                        err.span_note(\n+                let diag = match (sub_span, sup_span, sub_symbol, sup_symbol) {\n+                    (Some(sub_span), Some(sup_span), Some(&sub_symbol), Some(&sup_symbol)) => {\n+                        PlaceholderRelationLfNotSatisfied::HasBoth {\n+                            span,\n                             sub_span,\n-                            format!(\"the lifetime `{sub_symbol}` defined here...\"),\n-                        );\n-                        err.span_note(\n                             sup_span,\n-                            format!(\"...must outlive the lifetime `{sup_symbol}` defined here\"),\n-                        );\n+                            sub_symbol,\n+                            sup_symbol,\n+                            note: (),\n+                        }\n                     }\n-                    (Some(sub_span), Some(sup_span), _, Some(sup_symbol)) => {\n-                        err.span_note(sub_span, \"the lifetime defined here...\");\n-                        err.span_note(\n+                    (Some(sub_span), Some(sup_span), _, Some(&sup_symbol)) => {\n+                        PlaceholderRelationLfNotSatisfied::HasSup {\n+                            span,\n+                            sub_span,\n                             sup_span,\n-                            format!(\"...must outlive the lifetime `{sup_symbol}` defined here\"),\n-                        );\n+                            sup_symbol,\n+                            note: (),\n+                        }\n                     }\n-                    (Some(sub_span), Some(sup_span), Some(sub_symbol), _) => {\n-                        err.span_note(\n+                    (Some(sub_span), Some(sup_span), Some(&sub_symbol), _) => {\n+                        PlaceholderRelationLfNotSatisfied::HasSub {\n+                            span,\n                             sub_span,\n-                            format!(\"the lifetime `{sub_symbol}` defined here...\"),\n-                        );\n-                        err.span_note(sup_span, \"...must outlive the lifetime defined here\");\n+                            sup_span,\n+                            sub_symbol,\n+                            note: (),\n+                        }\n                     }\n                     (Some(sub_span), Some(sup_span), _, _) => {\n-                        err.span_note(sub_span, \"the lifetime defined here...\");\n-                        err.span_note(sup_span, \"...must outlive the lifetime defined here\");\n+                        PlaceholderRelationLfNotSatisfied::HasNone {\n+                            span,\n+                            sub_span,\n+                            sup_span,\n+                            note: (),\n+                        }\n                     }\n-                    _ => {}\n-                }\n-                err.note(\"this is a known limitation that will be removed in the future (see issue #100013 <https://github.com/rust-lang/rust/issues/100013> for more information)\");\n-                Some(err)\n+                    _ => PlaceholderRelationLfNotSatisfied::OnlyPrimarySpan { span, note: () },\n+                };\n+                Some(self.tcx().sess.create_err(diag))\n             }\n-\n             _ => None,\n         }\n     }"}, {"sha": "e0e89158a58386ec0e7eb4dd944dfef060e089c7", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 83, "deletions": 111, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,9 +1,11 @@\n-use crate::errors::RegionOriginNote;\n+use crate::errors::{\n+    note_and_explain, FullfillReqLifetime, LfBoundNotSatisfied, OutlivesBound, OutlivesContent,\n+    RefLongerThanData, RegionOriginNote, WhereClauseSuggestions,\n+};\n use crate::infer::error_reporting::{note_and_explain_region, TypeErrCtxt};\n use crate::infer::{self, SubregionOrigin};\n use rustc_errors::{\n-    fluent, struct_span_err, AddToDiagnostic, Applicability, Diagnostic, DiagnosticBuilder,\n-    ErrorGuaranteed,\n+    fluent, AddToDiagnostic, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic,\n };\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::traits::ObligationCauseCode;\n@@ -119,130 +121,105 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 err\n             }\n             infer::Reborrow(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0312,\n-                    \"lifetime of reference outlives lifetime of borrowed content...\"\n-                );\n-                note_and_explain_region(\n+                let reference_valid = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"...the reference is valid for \",\n                     sub,\n-                    \"...\",\n                     None,\n+                    note_and_explain::PrefixKind::RefValidFor,\n+                    note_and_explain::SuffixKind::Continues,\n                 );\n-                note_and_explain_region(\n+                let content_valid = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"...but the borrowed content is only valid for \",\n                     sup,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::ContentValidFor,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                err\n+                OutlivesContent {\n+                    span,\n+                    notes: reference_valid.into_iter().chain(content_valid).collect(),\n+                }\n+                .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic)\n             }\n             infer::RelateObjectBound(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0476,\n-                    \"lifetime of the source pointer does not outlive lifetime bound of the \\\n-                     object type\"\n-                );\n-                note_and_explain_region(\n+                let object_valid = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"object type is valid for \",\n                     sub,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::TypeObjValidFor,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                note_and_explain_region(\n+                let pointer_valid = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"source pointer is only valid for \",\n                     sup,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::SourcePointerValidFor,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                err\n+                OutlivesBound {\n+                    span,\n+                    notes: object_valid.into_iter().chain(pointer_valid).collect(),\n+                }\n+                .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic)\n             }\n             infer::RelateParamBound(span, ty, opt_span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0477,\n-                    \"the type `{}` does not fulfill the required lifetime\",\n-                    self.ty_to_string(ty)\n+                let prefix = match *sub {\n+                    ty::ReStatic => note_and_explain::PrefixKind::TypeSatisfy,\n+                    _ => note_and_explain::PrefixKind::TypeOutlive,\n+                };\n+                let suffix = if opt_span.is_some() {\n+                    note_and_explain::SuffixKind::ReqByBinding\n+                } else {\n+                    note_and_explain::SuffixKind::Empty\n+                };\n+                let note = note_and_explain::RegionExplanation::new(\n+                    self.tcx, sub, opt_span, prefix, suffix,\n                 );\n-                match *sub {\n-                    ty::ReStatic => note_and_explain_region(\n-                        self.tcx,\n-                        &mut err,\n-                        \"type must satisfy \",\n-                        sub,\n-                        if opt_span.is_some() { \" as required by this binding\" } else { \"\" },\n-                        opt_span,\n-                    ),\n-                    _ => note_and_explain_region(\n-                        self.tcx,\n-                        &mut err,\n-                        \"type must outlive \",\n-                        sub,\n-                        if opt_span.is_some() { \" as required by this binding\" } else { \"\" },\n-                        opt_span,\n-                    ),\n-                }\n-                err\n+                FullfillReqLifetime { span, ty: self.resolve_vars_if_possible(ty), note }\n+                    .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic)\n             }\n             infer::RelateRegionParamBound(span) => {\n-                let mut err =\n-                    struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n-                note_and_explain_region(\n+                let param_instantiated = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"lifetime parameter instantiated with \",\n                     sup,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::LfParamInstantiatedWith,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                note_and_explain_region(\n+                let param_must_outlive = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"but lifetime parameter must outlive \",\n                     sub,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::LfParamMustOutlive,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                err\n+                LfBoundNotSatisfied {\n+                    span,\n+                    notes: param_instantiated.into_iter().chain(param_must_outlive).collect(),\n+                }\n+                .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic)\n             }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0491,\n-                    \"in type `{}`, reference has a longer lifetime than the data it references\",\n-                    self.ty_to_string(ty)\n-                );\n-                note_and_explain_region(\n+                let pointer_valid = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"the pointer is valid for \",\n                     sub,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::PointerValidFor,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                note_and_explain_region(\n+                let data_valid = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"but the referenced data is only valid for \",\n                     sup,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::DataValidFor,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                err\n+                RefLongerThanData {\n+                    span,\n+                    ty: self.resolve_vars_if_possible(ty),\n+                    notes: pointer_valid.into_iter().chain(data_valid).collect(),\n+                }\n+                .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic)\n             }\n             infer::CompareImplItemObligation { span, impl_item_def_id, trait_item_def_id } => {\n                 let mut err = self.report_extra_impl_obligation(\n@@ -279,25 +256,25 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 err\n             }\n             infer::AscribeUserTypeProvePredicate(span) => {\n-                let mut err =\n-                    struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n-                note_and_explain_region(\n+                let instantiated = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"lifetime instantiated with \",\n                     sup,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::LfInstantiatedWith,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                note_and_explain_region(\n+                let must_outlive = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"but lifetime must outlive \",\n                     sub,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::LfMustOutlive,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                err\n+                LfBoundNotSatisfied {\n+                    span,\n+                    notes: instantiated.into_iter().chain(must_outlive).collect(),\n+                }\n+                .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic)\n             }\n         };\n         if sub.is_error() || sup.is_error() {\n@@ -347,22 +324,17 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n \n         let Some(generics) = self.tcx.hir().get_generics(impl_item_def_id) else { return; };\n \n-        if trait_predicates.is_empty() {\n-            err.span_suggestion_verbose(\n-                generics.where_clause_span,\n-                \"remove the `where` clause\",\n-                String::new(),\n-                Applicability::MachineApplicable,\n-            );\n+        let suggestion = if trait_predicates.is_empty() {\n+            WhereClauseSuggestions::Remove { span: generics.where_clause_span }\n         } else {\n             let space = if generics.where_clause_span.is_empty() { \" \" } else { \"\" };\n-            err.span_suggestion_verbose(\n-                generics.where_clause_span,\n-                \"copy the `where` clause predicates from the trait\",\n-                format!(\"{space}where {}\", trait_predicates.join(\", \")),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n+            WhereClauseSuggestions::CopyPredicates {\n+                span: generics.where_clause_span,\n+                space,\n+                trait_predicates: trait_predicates.join(\", \"),\n+            }\n+        };\n+        err.subdiagnostic(suggestion);\n     }\n \n     pub(super) fn report_placeholder_failure("}, {"sha": "b6337d6853fa3c835a095c427aea97099df672ec", "filename": "compiler/rustc_infer/src/infer/error_reporting/note_and_explain.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -504,7 +504,9 @@ fn foo(&self) -> Self::T { String::new() }\n         let methods: Vec<(Span, String)> = items\n             .in_definition_order()\n             .filter(|item| {\n-                ty::AssocKind::Fn == item.kind && Some(item.name) != current_method_ident\n+                ty::AssocKind::Fn == item.kind\n+                    && Some(item.name) != current_method_ident\n+                    && !tcx.is_doc_hidden(item.def_id)\n             })\n             .filter_map(|item| {\n                 let method = tcx.fn_sig(item.def_id).subst_identity();\n@@ -576,7 +578,7 @@ fn foo(&self) -> Self::T { String::new() }\n                                 tcx.impl_defaultness(item.id.owner_id)\n                             {\n                                 let assoc_ty = tcx.bound_type_of(item.id.owner_id).subst_identity();\n-                                if self.infcx.can_eq(param_env, assoc_ty, found).is_ok() {\n+                                if self.infcx.can_eq(param_env, assoc_ty, found) {\n                                     diag.span_label(\n                                         item.span,\n                                         \"associated type defaults can't be assumed inside the \\\n@@ -598,7 +600,7 @@ fn foo(&self) -> Self::T { String::new() }\n                     if let hir::AssocItemKind::Type = item.kind {\n                         let assoc_ty = tcx.bound_type_of(item.id.owner_id).subst_identity();\n \n-                        if self.infcx.can_eq(param_env, assoc_ty, found).is_ok() {\n+                        if self.infcx.can_eq(param_env, assoc_ty, found) {\n                             diag.span_label(item.span, \"expected this associated type\");\n                             return true;\n                         }"}, {"sha": "18c5097a26289d5530f9a2600768808e522cfe62", "filename": "compiler/rustc_infer/src/infer/error_reporting/suggest.rs", "status": "modified", "additions": 70, "deletions": 77, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -11,21 +11,22 @@ use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self as ty, IsSuggestable, Ty, TypeVisitable};\n use rustc_span::{sym, BytePos, Span};\n \n-use crate::errors::SuggAddLetForLetChains;\n+use crate::errors::{\n+    ConsiderAddingAwait, SuggAddLetForLetChains, SuggestRemoveSemiOrReturnBinding,\n+};\n \n use super::TypeErrCtxt;\n \n impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     pub(super) fn suggest_remove_semi_or_return_binding(\n         &self,\n-        err: &mut Diagnostic,\n         first_id: Option<hir::HirId>,\n         first_ty: Ty<'tcx>,\n         first_span: Span,\n         second_id: Option<hir::HirId>,\n         second_ty: Ty<'tcx>,\n         second_span: Span,\n-    ) {\n+    ) -> Option<SuggestRemoveSemiOrReturnBinding> {\n         let remove_semicolon = [\n             (first_id, self.resolve_vars_if_possible(second_ty)),\n             (second_id, self.resolve_vars_if_possible(first_ty)),\n@@ -37,35 +38,29 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         });\n         match remove_semicolon {\n             Some((sp, StatementAsExpression::NeedsBoxing)) => {\n-                err.multipart_suggestion(\n-                    \"consider removing this semicolon and boxing the expressions\",\n-                    vec![\n-                        (first_span.shrink_to_lo(), \"Box::new(\".to_string()),\n-                        (first_span.shrink_to_hi(), \")\".to_string()),\n-                        (second_span.shrink_to_lo(), \"Box::new(\".to_string()),\n-                        (second_span.shrink_to_hi(), \")\".to_string()),\n-                        (sp, String::new()),\n-                    ],\n-                    Applicability::MachineApplicable,\n-                );\n+                Some(SuggestRemoveSemiOrReturnBinding::RemoveAndBox {\n+                    first_lo: first_span.shrink_to_lo(),\n+                    first_hi: first_span.shrink_to_hi(),\n+                    second_lo: second_span.shrink_to_lo(),\n+                    second_hi: second_span.shrink_to_hi(),\n+                    sp,\n+                })\n             }\n             Some((sp, StatementAsExpression::CorrectType)) => {\n-                err.span_suggestion_short(\n-                    sp,\n-                    \"consider removing this semicolon\",\n-                    \"\",\n-                    Applicability::MachineApplicable,\n-                );\n+                Some(SuggestRemoveSemiOrReturnBinding::Remove { sp })\n             }\n             None => {\n+                let mut ret = None;\n                 for (id, ty) in [(first_id, second_ty), (second_id, first_ty)] {\n                     if let Some(id) = id\n                         && let hir::Node::Block(blk) = self.tcx.hir().get(id)\n-                        && self.consider_returning_binding(blk, ty, err)\n+                        && let Some(diag) = self.consider_returning_binding_diag(blk, ty)\n                     {\n+                        ret = Some(diag);\n                         break;\n                     }\n                 }\n+                ret\n             }\n         }\n     }\n@@ -198,7 +193,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             return;\n         }\n \n-        match (\n+        let subdiag = match (\n             self.get_impl_future_output_ty(exp_found.expected),\n             self.get_impl_future_output_ty(exp_found.found),\n         ) {\n@@ -207,65 +202,56 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             {\n                 ObligationCauseCode::IfExpression(box IfExpressionCause { then_id, .. }) => {\n                     let then_span = self.find_block_span_from_hir_id(*then_id);\n-                    diag.multipart_suggestion(\n-                        \"consider `await`ing on both `Future`s\",\n-                        vec![\n-                            (then_span.shrink_to_hi(), \".await\".to_string()),\n-                            (exp_span.shrink_to_hi(), \".await\".to_string()),\n-                        ],\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                    Some(ConsiderAddingAwait::BothFuturesSugg {\n+                        first: then_span.shrink_to_hi(),\n+                        second: exp_span.shrink_to_hi(),\n+                    })\n                 }\n                 ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n                     prior_arms,\n                     ..\n                 }) => {\n                     if let [.., arm_span] = &prior_arms[..] {\n-                        diag.multipart_suggestion(\n-                            \"consider `await`ing on both `Future`s\",\n-                            vec![\n-                                (arm_span.shrink_to_hi(), \".await\".to_string()),\n-                                (exp_span.shrink_to_hi(), \".await\".to_string()),\n-                            ],\n-                            Applicability::MaybeIncorrect,\n-                        );\n+                        Some(ConsiderAddingAwait::BothFuturesSugg {\n+                            first: arm_span.shrink_to_hi(),\n+                            second: exp_span.shrink_to_hi(),\n+                        })\n                     } else {\n-                        diag.help(\"consider `await`ing on both `Future`s\");\n+                        Some(ConsiderAddingAwait::BothFuturesHelp)\n                     }\n                 }\n-                _ => {\n-                    diag.help(\"consider `await`ing on both `Future`s\");\n-                }\n+                _ => Some(ConsiderAddingAwait::BothFuturesHelp),\n             },\n             (_, Some(ty)) if self.same_type_modulo_infer(exp_found.expected, ty) => {\n-                self.suggest_await_on_future(diag, exp_span);\n-                diag.span_note(exp_span, \"calling an async function returns a future\");\n+                // FIXME: Seems like we can't have a suggestion and a note with different spans in a single subdiagnostic\n+                diag.subdiagnostic(ConsiderAddingAwait::FutureSugg {\n+                    span: exp_span.shrink_to_hi(),\n+                });\n+                Some(ConsiderAddingAwait::FutureSuggNote { span: exp_span })\n             }\n             (Some(ty), _) if self.same_type_modulo_infer(ty, exp_found.found) => match cause.code()\n             {\n                 ObligationCauseCode::Pattern { span: Some(then_span), .. } => {\n-                    self.suggest_await_on_future(diag, then_span.shrink_to_hi());\n+                    Some(ConsiderAddingAwait::FutureSugg { span: then_span.shrink_to_hi() })\n                 }\n                 ObligationCauseCode::IfExpression(box IfExpressionCause { then_id, .. }) => {\n                     let then_span = self.find_block_span_from_hir_id(*then_id);\n-                    self.suggest_await_on_future(diag, then_span.shrink_to_hi());\n+                    Some(ConsiderAddingAwait::FutureSugg { span: then_span.shrink_to_hi() })\n                 }\n                 ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n                     ref prior_arms,\n                     ..\n-                }) => {\n-                    diag.multipart_suggestion_verbose(\n-                        \"consider `await`ing on the `Future`\",\n-                        prior_arms\n-                            .iter()\n-                            .map(|arm| (arm.shrink_to_hi(), \".await\".to_string()))\n-                            .collect(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                _ => {}\n+                }) => Some({\n+                    ConsiderAddingAwait::FutureSuggMultiple {\n+                        spans: prior_arms.iter().map(|arm| arm.shrink_to_hi()).collect(),\n+                    }\n+                }),\n+                _ => None,\n             },\n-            _ => {}\n+            _ => None,\n+        };\n+        if let Some(subdiag) = subdiag {\n+            diag.subdiagnostic(subdiag);\n         }\n     }\n \n@@ -655,16 +641,15 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n \n     /// Suggest returning a local binding with a compatible type if the block\n     /// has no return expression.\n-    pub fn consider_returning_binding(\n+    pub fn consider_returning_binding_diag(\n         &self,\n         blk: &'tcx hir::Block<'tcx>,\n         expected_ty: Ty<'tcx>,\n-        err: &mut Diagnostic,\n-    ) -> bool {\n+    ) -> Option<SuggestRemoveSemiOrReturnBinding> {\n         let blk = blk.innermost_block();\n         // Do not suggest if we have a tail expr.\n         if blk.expr.is_some() {\n-            return false;\n+            return None;\n         }\n         let mut shadowed = FxIndexSet::default();\n         let mut candidate_idents = vec![];\n@@ -733,7 +718,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         match &candidate_idents[..] {\n             [(ident, _ty)] => {\n                 let sm = self.tcx.sess.source_map();\n-                if let Some(stmt) = blk.stmts.last() {\n+                let (span, sugg) = if let Some(stmt) = blk.stmts.last() {\n                     let stmt_span = sm.stmt_span(stmt.span, blk.span);\n                     let sugg = if sm.is_multiline(blk.span)\n                         && let Some(spacing) = sm.indentation_before(stmt_span)\n@@ -742,12 +727,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     } else {\n                         format!(\" {ident}\")\n                     };\n-                    err.span_suggestion_verbose(\n-                        stmt_span.shrink_to_hi(),\n-                        format!(\"consider returning the local binding `{ident}`\"),\n-                        sugg,\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                    (stmt_span.shrink_to_hi(), sugg)\n                 } else {\n                     let sugg = if sm.is_multiline(blk.span)\n                         && let Some(spacing) = sm.indentation_before(blk.span.shrink_to_lo())\n@@ -757,21 +737,34 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                         format!(\" {ident} \")\n                     };\n                     let left_span = sm.span_through_char(blk.span, '{').shrink_to_hi();\n-                    err.span_suggestion_verbose(\n+                    (\n                         sm.span_extend_while(left_span, |c| c.is_whitespace()).unwrap_or(left_span),\n-                        format!(\"consider returning the local binding `{ident}`\"),\n                         sugg,\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                true\n+                    )\n+                };\n+                Some(SuggestRemoveSemiOrReturnBinding::Add { sp: span, code: sugg, ident: *ident })\n             }\n             values if (1..3).contains(&values.len()) => {\n                 let spans = values.iter().map(|(ident, _)| ident.span).collect::<Vec<_>>();\n-                err.span_note(spans, \"consider returning one of these bindings\");\n+                Some(SuggestRemoveSemiOrReturnBinding::AddOne { spans: spans.into() })\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn consider_returning_binding(\n+        &self,\n+        blk: &'tcx hir::Block<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+        err: &mut Diagnostic,\n+    ) -> bool {\n+        let diag = self.consider_returning_binding_diag(blk, expected_ty);\n+        match diag {\n+            Some(diag) => {\n+                err.subdiagnostic(diag);\n                 true\n             }\n-            _ => false,\n+            None => false,\n         }\n     }\n }"}, {"sha": "17e734f0700321bfd4abbaae605029566968106b", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -880,30 +880,20 @@ impl<'tcx> InferCtxt<'tcx> {\n         self.inner.borrow_mut().unwrap_region_constraints().add_given(sub, sup);\n     }\n \n-    pub fn can_sub<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> UnitResult<'tcx>\n+    pub fn can_sub<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> bool\n     where\n         T: at::ToTrace<'tcx>,\n     {\n         let origin = &ObligationCause::dummy();\n-        self.probe(|_| {\n-            self.at(origin, param_env).sub(a, b).map(|InferOk { obligations: _, .. }| {\n-                // Ignore obligations, since we are unrolling\n-                // everything anyway.\n-            })\n-        })\n+        self.probe(|_| self.at(origin, param_env).sub(a, b).is_ok())\n     }\n \n-    pub fn can_eq<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> UnitResult<'tcx>\n+    pub fn can_eq<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> bool\n     where\n         T: at::ToTrace<'tcx>,\n     {\n         let origin = &ObligationCause::dummy();\n-        self.probe(|_| {\n-            self.at(origin, param_env).eq(a, b).map(|InferOk { obligations: _, .. }| {\n-                // Ignore obligations, since we are unrolling\n-                // everything anyway.\n-            })\n-        })\n+        self.probe(|_| self.at(origin, param_env).eq(a, b).is_ok())\n     }\n \n     #[instrument(skip(self), level = \"debug\")]"}, {"sha": "60927eed85d3b34748325cee677200666e77d2f2", "filename": "compiler/rustc_middle/src/mir/interpret/pointer.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -19,29 +19,29 @@ pub trait PointerArithmetic: HasDataLayout {\n \n     #[inline(always)]\n     fn max_size_of_val(&self) -> Size {\n-        Size::from_bytes(self.machine_isize_max())\n+        Size::from_bytes(self.target_isize_max())\n     }\n \n     #[inline]\n-    fn machine_usize_max(&self) -> u64 {\n+    fn target_usize_max(&self) -> u64 {\n         self.pointer_size().unsigned_int_max().try_into().unwrap()\n     }\n \n     #[inline]\n-    fn machine_isize_min(&self) -> i64 {\n+    fn target_isize_min(&self) -> i64 {\n         self.pointer_size().signed_int_min().try_into().unwrap()\n     }\n \n     #[inline]\n-    fn machine_isize_max(&self) -> i64 {\n+    fn target_isize_max(&self) -> i64 {\n         self.pointer_size().signed_int_max().try_into().unwrap()\n     }\n \n     #[inline]\n-    fn machine_usize_to_isize(&self, val: u64) -> i64 {\n+    fn target_usize_to_isize(&self, val: u64) -> i64 {\n         let val = val as i64;\n         // Now wrap-around into the machine_isize range.\n-        if val > self.machine_isize_max() {\n+        if val > self.target_isize_max() {\n             // This can only happen if the ptr size is < 64, so we know max_usize_plus_1 fits into\n             // i64.\n             debug_assert!(self.pointer_size().bits() < 64);\n@@ -76,11 +76,11 @@ pub trait PointerArithmetic: HasDataLayout {\n         let n = i.unsigned_abs();\n         if i >= 0 {\n             let (val, over) = self.overflowing_offset(val, n);\n-            (val, over || i > self.machine_isize_max())\n+            (val, over || i > self.target_isize_max())\n         } else {\n             let res = val.overflowing_sub(n);\n             let (val, over) = self.truncate_to_ptr(res);\n-            (val, over || i < self.machine_isize_min())\n+            (val, over || i < self.target_isize_min())\n         }\n     }\n "}, {"sha": "36dbbe4bf77650895d05a7133213976331c47c4f", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -75,8 +75,8 @@ impl<'tcx> ConstValue<'tcx> {\n         self.try_to_scalar_int()?.try_into().ok()\n     }\n \n-    pub fn try_to_machine_usize(&self, tcx: TyCtxt<'tcx>) -> Option<u64> {\n-        self.try_to_scalar_int()?.try_to_machine_usize(tcx).ok()\n+    pub fn try_to_target_usize(&self, tcx: TyCtxt<'tcx>) -> Option<u64> {\n+        self.try_to_scalar_int()?.try_to_target_usize(tcx).ok()\n     }\n \n     pub fn try_to_bits_for_ty(\n@@ -97,8 +97,8 @@ impl<'tcx> ConstValue<'tcx> {\n         ConstValue::Scalar(Scalar::from_u64(i))\n     }\n \n-    pub fn from_machine_usize(i: u64, cx: &impl HasDataLayout) -> Self {\n-        ConstValue::Scalar(Scalar::from_machine_usize(i, cx))\n+    pub fn from_target_usize(i: u64, cx: &impl HasDataLayout) -> Self {\n+        ConstValue::Scalar(Scalar::from_target_usize(i, cx))\n     }\n }\n \n@@ -241,7 +241,7 @@ impl<Prov> Scalar<Prov> {\n     }\n \n     #[inline]\n-    pub fn from_machine_usize(i: u64, cx: &impl HasDataLayout) -> Self {\n+    pub fn from_target_usize(i: u64, cx: &impl HasDataLayout) -> Self {\n         Self::from_uint(i, cx.data_layout().pointer_size)\n     }\n \n@@ -268,7 +268,7 @@ impl<Prov> Scalar<Prov> {\n     }\n \n     #[inline]\n-    pub fn from_machine_isize(i: i64, cx: &impl HasDataLayout) -> Self {\n+    pub fn from_target_isize(i: i64, cx: &impl HasDataLayout) -> Self {\n         Self::from_int(i, cx.data_layout().pointer_size)\n     }\n \n@@ -429,7 +429,7 @@ impl<'tcx, Prov: Provenance> Scalar<Prov> {\n \n     /// Converts the scalar to produce a machine-pointer-sized unsigned integer.\n     /// Fails if the scalar is a pointer.\n-    pub fn to_machine_usize(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, u64> {\n+    pub fn to_target_usize(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, u64> {\n         let b = self.to_uint(cx.data_layout().pointer_size)?;\n         Ok(u64::try_from(b).unwrap())\n     }\n@@ -469,7 +469,7 @@ impl<'tcx, Prov: Provenance> Scalar<Prov> {\n \n     /// Converts the scalar to produce a machine-pointer-sized signed integer.\n     /// Fails if the scalar is a pointer.\n-    pub fn to_machine_isize(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, i64> {\n+    pub fn to_target_isize(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, i64> {\n         let b = self.to_int(cx.data_layout().pointer_size)?;\n         Ok(i64::try_from(b).unwrap())\n     }"}, {"sha": "c596e91160c8a267f62765e925ac61c685c43d1f", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -2357,10 +2357,10 @@ impl<'tcx> ConstantKind<'tcx> {\n     ) -> Option<u64> {\n         match self {\n             Self::Ty(ct) => ct.try_eval_target_usize(tcx, param_env),\n-            Self::Val(val, _) => val.try_to_machine_usize(tcx),\n+            Self::Val(val, _) => val.try_to_target_usize(tcx),\n             Self::Unevaluated(uneval, _) => {\n                 match tcx.const_eval_resolve(param_env, *uneval, None) {\n-                    Ok(val) => val.try_to_machine_usize(tcx),\n+                    Ok(val) => val.try_to_target_usize(tcx),\n                     Err(_) => None,\n                 }\n             }"}, {"sha": "927f18f59b979660a7c87aa5f72b474c6dc50149", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -206,7 +206,7 @@ impl<'tcx> Const<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         param_env: ParamEnv<'tcx>,\n     ) -> Option<u64> {\n-        self.kind().eval(tcx, param_env).try_to_machine_usize(tcx)\n+        self.kind().eval(tcx, param_env).try_to_target_usize(tcx)\n     }\n \n     #[inline]"}, {"sha": "eecd78ab6c0484aeb1c7b7ac1d770589a8a2f657", "filename": "compiler/rustc_middle/src/ty/consts/int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -232,7 +232,7 @@ impl ScalarInt {\n     }\n \n     #[inline]\n-    pub fn try_to_machine_usize(&self, tcx: TyCtxt<'_>) -> Result<u64, Size> {\n+    pub fn try_to_target_usize(&self, tcx: TyCtxt<'_>) -> Result<u64, Size> {\n         Ok(self.to_bits(tcx.data_layout.pointer_size)? as u64)\n     }\n "}, {"sha": "58c5e21df66b9bd220dbba1177d8ed08ae8c8079", "filename": "compiler/rustc_middle/src/ty/consts/kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -125,8 +125,8 @@ impl<'tcx> ConstKind<'tcx> {\n     }\n \n     #[inline]\n-    pub fn try_to_machine_usize(self, tcx: TyCtxt<'tcx>) -> Option<u64> {\n-        self.try_to_value()?.try_to_machine_usize(tcx)\n+    pub fn try_to_target_usize(self, tcx: TyCtxt<'tcx>) -> Option<u64> {\n+        self.try_to_value()?.try_to_target_usize(tcx)\n     }\n }\n "}, {"sha": "5ed4af2e9229db0b0d35e2f016a96cce792fbcbf", "filename": "compiler/rustc_middle/src/ty/consts/valtree.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -78,8 +78,8 @@ impl<'tcx> ValTree<'tcx> {\n         }\n     }\n \n-    pub fn try_to_machine_usize(self, tcx: TyCtxt<'tcx>) -> Option<u64> {\n-        self.try_to_scalar_int().map(|s| s.try_to_machine_usize(tcx).ok()).flatten()\n+    pub fn try_to_target_usize(self, tcx: TyCtxt<'tcx>) -> Option<u64> {\n+        self.try_to_scalar_int().map(|s| s.try_to_target_usize(tcx).ok()).flatten()\n     }\n \n     /// Get the values inside the ValTree as a slice of bytes. This only works for"}, {"sha": "e268553f8268b3605993937f5d87e833631def45", "filename": "compiler/rustc_middle/src/ty/inhabitedness/inhabited_predicate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Finhabited_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Finhabited_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Finhabited_predicate.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -159,7 +159,7 @@ impl<'tcx> InhabitedPredicate<'tcx> {\n         match self {\n             Self::ConstIsZero(c) => {\n                 let c = ty::EarlyBinder(c).subst(tcx, substs);\n-                let pred = match c.kind().try_to_machine_usize(tcx) {\n+                let pred = match c.kind().try_to_target_usize(tcx) {\n                     Some(0) => Self::True,\n                     Some(1..) => Self::False,\n                     None => Self::ConstIsZero(c),"}, {"sha": "690c0d58e01c18379cc12a6c93a30a51c8a1930a", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -191,7 +191,7 @@ fn inhabited_predicate_type<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> InhabitedP\n \n         // If we can evaluate the array length before having a `ParamEnv`, then\n         // we can simplify the predicate. This is an optimization.\n-        Array(ty, len) => match len.kind().try_to_machine_usize(tcx) {\n+        Array(ty, len) => match len.kind().try_to_target_usize(tcx) {\n             Some(0) => InhabitedPredicate::True,\n             Some(1..) => ty.inhabited_predicate(tcx),\n             None => ty.inhabited_predicate(tcx).or(tcx, InhabitedPredicate::ConstIsZero(len)),"}, {"sha": "cecacfa1b3e0830dd157809d8990421b80f3bf41", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1628,7 +1628,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 // Eventually I'll need to implement param-env-aware\n                 // `\u0393\u2081 \u22a6 \u03c6\u2081 => \u0393\u2082 \u22a6 \u03c6\u2082` logic.\n                 let param_env = ty::ParamEnv::empty();\n-                if self.can_sub(param_env, error, implication).is_ok() {\n+                if self.can_sub(param_env, error, implication) {\n                     debug!(\"error_implies: {:?} -> {:?} -> {:?}\", cond, error, implication);\n                     return true;\n                 }"}, {"sha": "52ed64868c053466ee4a048d1ddaaef92bff6062", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -72,7 +72,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n             let impl_self_ty = impl_trait_ref.self_ty();\n \n-            if let Ok(..) = self.can_eq(param_env, trait_self_ty, impl_self_ty) {\n+            if self.can_eq(param_env, trait_self_ty, impl_self_ty) {\n                 self_match_impls.push((def_id, impl_substs));\n \n                 if iter::zip(\n@@ -261,7 +261,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             // Arrays give us `[]`, `[{ty}; _]` and `[{ty}; N]`\n             if let ty::Array(aty, len) = self_ty.kind() {\n                 flags.push((sym::_Self, Some(\"[]\".to_string())));\n-                let len = len.kind().try_to_value().and_then(|v| v.try_to_machine_usize(self.tcx));\n+                let len = len.kind().try_to_value().and_then(|v| v.try_to_target_usize(self.tcx));\n                 flags.push((sym::_Self, Some(format!(\"[{}; _]\", aty))));\n                 if let Some(n) = len {\n                     flags.push((sym::_Self, Some(format!(\"[{}; {}]\", aty, n))));"}, {"sha": "135232d1b2089da0b49b139e285ab7942379d008", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -748,10 +748,11 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             let real_ty = real_trait_pred.self_ty();\n             // We `erase_late_bound_regions` here because `make_subregion` does not handle\n             // `ReLateBound`, and we don't particularly care about the regions.\n-            if self\n-                .can_eq(obligation.param_env, self.tcx.erase_late_bound_regions(real_ty), arg_ty)\n-                .is_err()\n-            {\n+            if !self.can_eq(\n+                obligation.param_env,\n+                self.tcx.erase_late_bound_regions(real_ty),\n+                arg_ty,\n+            ) {\n                 continue;\n             }\n \n@@ -3690,7 +3691,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     let Some((span, (assoc, ty))) = entry else { continue; };\n                     if primary_spans.is_empty() || type_diffs.iter().any(|diff| {\n                         let Sorts(expected_found) = diff else { return false; };\n-                        self.can_eq(param_env, expected_found.found, ty).is_ok()\n+                        self.can_eq(param_env, expected_found.found, ty)\n                     }) {\n                         // FIXME: this doesn't quite work for `Iterator::collect`\n                         // because we have `Vec<i32>` and `()`, but we'd want `i32`\n@@ -3717,10 +3718,10 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         let ty_str = with_forced_trimmed_paths!(self.ty_to_string(ty));\n \n                         let assoc = with_forced_trimmed_paths!(self.tcx.def_path_str(assoc));\n-                        if self.can_eq(param_env, ty, *prev_ty).is_err() {\n+                        if !self.can_eq(param_env, ty, *prev_ty) {\n                             if type_diffs.iter().any(|diff| {\n                                 let Sorts(expected_found) = diff else { return false; };\n-                                self.can_eq(param_env, expected_found.found, ty).is_ok()\n+                                self.can_eq(param_env, expected_found.found, ty)\n                             }) {\n                                 primary_spans.push(span);\n                             }\n@@ -3868,7 +3869,7 @@ fn hint_missing_borrow<'tcx>(\n         let (found_ty, found_refs) = get_deref_type_and_refs(*found_arg);\n         let (expected_ty, expected_refs) = get_deref_type_and_refs(*expected_arg);\n \n-        if infcx.can_eq(param_env, found_ty, expected_ty).is_ok() {\n+        if infcx.can_eq(param_env, found_ty, expected_ty) {\n             // FIXME: This could handle more exotic cases like mutability mismatches too!\n             if found_refs.len() < expected_refs.len()\n                 && found_refs[..] == expected_refs[expected_refs.len() - found_refs.len()..]"}, {"sha": "ee13dae60b1984da3c8628aabdb64b871b48f551", "filename": "library/core/src/hint.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/library%2Fcore%2Fsrc%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/library%2Fcore%2Fsrc%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhint.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -216,7 +216,8 @@ pub fn spin_loop() {\n ///\n /// Note however, that `black_box` is only (and can only be) provided on a \"best-effort\" basis. The\n /// extent to which it can block optimisations may vary depending upon the platform and code-gen\n-/// backend used. Programs cannot rely on `black_box` for *correctness* in any way.\n+/// backend used. Programs cannot rely on `black_box` for *correctness*, beyond it behaving as the\n+/// identity function.\n ///\n /// [`std::convert::identity`]: crate::convert::identity\n ///"}, {"sha": "c550378e7d6b79ba680de269dc5db64ed327e4c4", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -334,6 +334,10 @@ impl File {\n     ///\n     /// See the [`OpenOptions::open`] method for more details.\n     ///\n+    /// If you only need to read the entire file contents,\n+    /// consider [`std::fs::read()`][self::read] or\n+    /// [`std::fs::read_to_string()`][self::read_to_string] instead.\n+    ///\n     /// # Errors\n     ///\n     /// This function will return an error if `path` does not already exist.\n@@ -343,9 +347,12 @@ impl File {\n     ///\n     /// ```no_run\n     /// use std::fs::File;\n+    /// use std::io::Read;\n     ///\n     /// fn main() -> std::io::Result<()> {\n     ///     let mut f = File::open(\"foo.txt\")?;\n+    ///     let mut data = vec![];\n+    ///     f.read_to_end(&mut data)?;\n     ///     Ok(())\n     /// }\n     /// ```\n@@ -361,16 +368,20 @@ impl File {\n     ///\n     /// Depending on the platform, this function may fail if the\n     /// full directory path does not exist.\n-    ///\n     /// See the [`OpenOptions::open`] function for more details.\n     ///\n+    /// See also [`std::fs::write()`][self::write] for a simple function to\n+    /// create a file with a given data.\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run\n     /// use std::fs::File;\n+    /// use std::io::Write;\n     ///\n     /// fn main() -> std::io::Result<()> {\n     ///     let mut f = File::create(\"foo.txt\")?;\n+    ///     f.write_all(&1234_u32.to_be_bytes())?;\n     ///     Ok(())\n     /// }\n     /// ```\n@@ -397,9 +408,11 @@ impl File {\n     /// #![feature(file_create_new)]\n     ///\n     /// use std::fs::File;\n+    /// use std::io::Write;\n     ///\n     /// fn main() -> std::io::Result<()> {\n     ///     let mut f = File::create_new(\"foo.txt\")?;\n+    ///     f.write_all(\"Hello, world!\".as_bytes())?;\n     ///     Ok(())\n     /// }\n     /// ```\n@@ -426,9 +439,11 @@ impl File {\n     ///\n     /// ```no_run\n     /// use std::fs::File;\n+    /// use std::io::Write;\n     ///\n     /// fn main() -> std::io::Result<()> {\n     ///     let mut f = File::options().append(true).open(\"example.log\")?;\n+    ///     writeln!(&mut f, \"new line\")?;\n     ///     Ok(())\n     /// }\n     /// ```\n@@ -966,6 +981,9 @@ impl OpenOptions {\n     /// In order for the file to be created, [`OpenOptions::write`] or\n     /// [`OpenOptions::append`] access must be used.\n     ///\n+    /// See also [`std::fs::write()`][self::write] for a simple function to\n+    /// create a file with a given data.\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run"}, {"sha": "dd58a5b51fc1a1d2726b992c8bc778cfdc510191", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -164,10 +164,10 @@ impl Cfg {\n     /// Renders the configuration for human display, as a short HTML description.\n     pub(crate) fn render_short_html(&self) -> String {\n         let mut msg = Display(self, Format::ShortHtml).to_string();\n-        if self.should_capitalize_first_letter() {\n-            if let Some(i) = msg.find(|c: char| c.is_ascii_alphanumeric()) {\n-                msg[i..i + 1].make_ascii_uppercase();\n-            }\n+        if self.should_capitalize_first_letter() &&\n+            let Some(i) = msg.find(|c: char| c.is_ascii_alphanumeric())\n+        {\n+            msg[i..i + 1].make_ascii_uppercase();\n         }\n         msg\n     }"}, {"sha": "8bb8f122e2268b373de9b7a5c0f1d6d1ca355a72", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -390,18 +390,17 @@ pub(crate) fn build_impl(\n \n     // Only inline impl if the implemented trait is\n     // reachable in rustdoc generated documentation\n-    if !did.is_local() {\n-        if let Some(traitref) = associated_trait {\n-            let did = traitref.def_id;\n-            if !cx.cache.effective_visibilities.is_directly_public(tcx, did) {\n-                return;\n-            }\n+    if !did.is_local() && let Some(traitref) = associated_trait {\n+        let did = traitref.def_id;\n+        if !cx.cache.effective_visibilities.is_directly_public(tcx, did) {\n+            return;\n+        }\n \n-            if let Some(stab) = tcx.lookup_stability(did) {\n-                if stab.is_unstable() && stab.feature == sym::rustc_private {\n-                    return;\n-                }\n-            }\n+        if let Some(stab) = tcx.lookup_stability(did) &&\n+            stab.is_unstable() &&\n+            stab.feature == sym::rustc_private\n+        {\n+            return;\n         }\n     }\n \n@@ -525,10 +524,8 @@ pub(crate) fn build_impl(\n     }\n \n     while let Some(ty) = stack.pop() {\n-        if let Some(did) = ty.def_id(&cx.cache) {\n-            if tcx.is_doc_hidden(did) {\n-                return;\n-            }\n+        if let Some(did) = ty.def_id(&cx.cache) && tcx.is_doc_hidden(did) {\n+            return;\n         }\n         if let Some(generics) = ty.generics() {\n             stack.extend(generics);"}, {"sha": "65736bb16fc05e1d18ab2b6571238ced860459a7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 57, "deletions": 62, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -787,43 +787,43 @@ fn clean_ty_generics<'tcx>(\n                 None\n             })();\n \n-            if let Some(param_idx) = param_idx {\n-                if let Some(b) = impl_trait.get_mut(&param_idx.into()) {\n-                    let p: WherePredicate = clean_predicate(*p, cx)?;\n+            if let Some(param_idx) = param_idx\n+                && let Some(b) = impl_trait.get_mut(&param_idx.into())\n+            {\n+                let p: WherePredicate = clean_predicate(*p, cx)?;\n+\n+                b.extend(\n+                    p.get_bounds()\n+                        .into_iter()\n+                        .flatten()\n+                        .cloned()\n+                        .filter(|b| !b.is_sized_bound(cx)),\n+                );\n \n-                    b.extend(\n-                        p.get_bounds()\n+                let proj = projection.map(|p| {\n+                    (\n+                        clean_projection(p.map_bound(|p| p.projection_ty), cx, None),\n+                        p.map_bound(|p| p.term),\n+                    )\n+                });\n+                if let Some(((_, trait_did, name), rhs)) = proj\n+                    .as_ref()\n+                    .and_then(|(lhs, rhs): &(Type, _)| Some((lhs.projection()?, rhs)))\n+                {\n+                    // FIXME(...): Remove this unwrap()\n+                    impl_trait_proj.entry(param_idx).or_default().push((\n+                        trait_did,\n+                        name,\n+                        rhs.map_bound(|rhs| rhs.ty().unwrap()),\n+                        p.get_bound_params()\n                             .into_iter()\n                             .flatten()\n-                            .cloned()\n-                            .filter(|b| !b.is_sized_bound(cx)),\n-                    );\n-\n-                    let proj = projection.map(|p| {\n-                        (\n-                            clean_projection(p.map_bound(|p| p.projection_ty), cx, None),\n-                            p.map_bound(|p| p.term),\n-                        )\n-                    });\n-                    if let Some(((_, trait_did, name), rhs)) = proj\n-                        .as_ref()\n-                        .and_then(|(lhs, rhs): &(Type, _)| Some((lhs.projection()?, rhs)))\n-                    {\n-                        // FIXME(...): Remove this unwrap()\n-                        impl_trait_proj.entry(param_idx).or_default().push((\n-                            trait_did,\n-                            name,\n-                            rhs.map_bound(|rhs| rhs.ty().unwrap()),\n-                            p.get_bound_params()\n-                                .into_iter()\n-                                .flatten()\n-                                .map(|param| GenericParamDef::lifetime(param.0))\n-                                .collect(),\n-                        ));\n-                    }\n-\n-                    return None;\n+                            .map(|param| GenericParamDef::lifetime(param.0))\n+                            .collect(),\n+                    ));\n                 }\n+\n+                return None;\n             }\n \n             Some(p)\n@@ -886,7 +886,7 @@ fn clean_ty_generics<'tcx>(\n     // `?Sized` bound for each one we didn't find to be `Sized`.\n     for tp in &stripped_params {\n         if let types::GenericParamDefKind::Type { .. } = tp.kind\n-        && !sized_params.contains(&tp.name)\n+            && !sized_params.contains(&tp.name)\n         {\n             where_predicates.push(WherePredicate::BoundPredicate {\n                 ty: Type::Generic(tp.name),\n@@ -1461,10 +1461,10 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n             // Try to normalize `<X as Y>::T` to a type\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n             // `hir_to_ty` can return projection types with escaping vars for GATs, e.g. `<() as Trait>::Gat<'_>`\n-            if !ty.has_escaping_bound_vars() {\n-                if let Some(normalized_value) = normalize(cx, ty::Binder::dummy(ty)) {\n-                    return clean_middle_ty(normalized_value, cx, None);\n-                }\n+            if !ty.has_escaping_bound_vars()\n+                && let Some(normalized_value) = normalize(cx, ty::Binder::dummy(ty))\n+            {\n+                return clean_middle_ty(normalized_value, cx, None);\n             }\n \n             let trait_segments = &p.segments[..p.segments.len() - 1];\n@@ -1878,11 +1878,9 @@ fn clean_middle_opaque_bounds<'tcx>(\n                 _ => return None,\n             };\n \n-            if let Some(sized) = cx.tcx.lang_items().sized_trait() {\n-                if trait_ref.def_id() == sized {\n-                    has_sized = true;\n-                    return None;\n-                }\n+            if let Some(sized) = cx.tcx.lang_items().sized_trait() && trait_ref.def_id() == sized {\n+                has_sized = true;\n+                return None;\n             }\n \n             let bindings: ThinVec<_> = bounds\n@@ -2392,17 +2390,15 @@ fn clean_use_statement_inner<'tcx>(\n     let is_visible_from_parent_mod =\n         visibility.is_accessible_from(parent_mod, cx.tcx) && !current_mod.is_top_level_module();\n \n-    if pub_underscore {\n-        if let Some(ref inline) = inline_attr {\n-            rustc_errors::struct_span_err!(\n-                cx.tcx.sess,\n-                inline.span(),\n-                E0780,\n-                \"anonymous imports cannot be inlined\"\n-            )\n-            .span_label(import.span, \"anonymous import\")\n-            .emit();\n-        }\n+    if pub_underscore && let Some(ref inline) = inline_attr {\n+        rustc_errors::struct_span_err!(\n+            cx.tcx.sess,\n+            inline.span(),\n+            E0780,\n+            \"anonymous imports cannot be inlined\"\n+        )\n+        .span_label(import.span, \"anonymous import\")\n+        .emit();\n     }\n \n     // We consider inlining the documentation of `pub use` statements, but we\n@@ -2438,14 +2434,13 @@ fn clean_use_statement_inner<'tcx>(\n         }\n         Import::new_glob(resolve_use_source(cx, path), true)\n     } else {\n-        if inline_attr.is_none() {\n-            if let Res::Def(DefKind::Mod, did) = path.res {\n-                if !did.is_local() && did.is_crate_root() {\n-                    // if we're `pub use`ing an extern crate root, don't inline it unless we\n-                    // were specifically asked for it\n-                    denied = true;\n-                }\n-            }\n+        if inline_attr.is_none()\n+            && let Res::Def(DefKind::Mod, did) = path.res\n+            && !did.is_local() && did.is_crate_root()\n+        {\n+            // if we're `pub use`ing an extern crate root, don't inline it unless we\n+            // were specifically asked for it\n+            denied = true;\n         }\n         if !denied {\n             let mut visited = DefIdSet::default();"}, {"sha": "fc1396e86f6b1341bb3fbe8a231d2e8b54724706", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -182,10 +182,8 @@ impl ExternalCrate {\n             return Local;\n         }\n \n-        if extern_url_takes_precedence {\n-            if let Some(url) = extern_url {\n-                return to_remote(url);\n-            }\n+        if extern_url_takes_precedence && let Some(url) = extern_url {\n+            return to_remote(url);\n         }\n \n         // Failing that, see if there's an attribute specifying where to find this\n@@ -1176,10 +1174,10 @@ impl GenericBound {\n \n     pub(crate) fn is_sized_bound(&self, cx: &DocContext<'_>) -> bool {\n         use rustc_hir::TraitBoundModifier as TBM;\n-        if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, TBM::None) = *self {\n-            if Some(trait_.def_id()) == cx.tcx.lang_items().sized_trait() {\n-                return true;\n-            }\n+        if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, TBM::None) = *self &&\n+            Some(trait_.def_id()) == cx.tcx.lang_items().sized_trait()\n+        {\n+            return true;\n         }\n         false\n     }"}, {"sha": "4d8ce54dc5c62669e9b6e2d167e56de5b262275a", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -345,10 +345,10 @@ pub(crate) fn is_literal_expr(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n             return true;\n         }\n \n-        if let hir::ExprKind::Unary(hir::UnOp::Neg, expr) = &expr.kind {\n-            if let hir::ExprKind::Lit(_) = &expr.kind {\n-                return true;\n-            }\n+        if let hir::ExprKind::Unary(hir::UnOp::Neg, expr) = &expr.kind &&\n+            let hir::ExprKind::Lit(_) = &expr.kind\n+        {\n+            return true;\n         }\n     }\n "}, {"sha": "0eba81c7c1ee3e0f7a2d836a41ca1ce7941b236b", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 27, "deletions": 32, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -229,11 +229,11 @@ fn scrape_test_config(attrs: &[ast::Attribute]) -> GlobalTestOptions {\n         if attr.has_name(sym::no_crate_inject) {\n             opts.no_crate_inject = true;\n         }\n-        if attr.has_name(sym::attr) {\n-            if let Some(l) = attr.meta_item_list() {\n-                for item in l {\n-                    opts.attrs.push(pprust::meta_list_item_to_string(item));\n-                }\n+        if attr.has_name(sym::attr)\n+            && let Some(l) = attr.meta_item_list()\n+        {\n+            for item in l {\n+                opts.attrs.push(pprust::meta_list_item_to_string(item));\n             }\n         }\n     }\n@@ -594,31 +594,28 @@ pub(crate) fn make_test(\n             loop {\n                 match parser.parse_item(ForceCollect::No) {\n                     Ok(Some(item)) => {\n-                        if !found_main {\n-                            if let ast::ItemKind::Fn(..) = item.kind {\n-                                if item.ident.name == sym::main {\n-                                    found_main = true;\n-                                }\n-                            }\n+                        if !found_main &&\n+                            let ast::ItemKind::Fn(..) = item.kind &&\n+                            item.ident.name == sym::main\n+                        {\n+                            found_main = true;\n                         }\n \n-                        if !found_extern_crate {\n-                            if let ast::ItemKind::ExternCrate(original) = item.kind {\n-                                // This code will never be reached if `crate_name` is none because\n-                                // `found_extern_crate` is initialized to `true` if it is none.\n-                                let crate_name = crate_name.unwrap();\n+                        if !found_extern_crate &&\n+                            let ast::ItemKind::ExternCrate(original) = item.kind\n+                        {\n+                            // This code will never be reached if `crate_name` is none because\n+                            // `found_extern_crate` is initialized to `true` if it is none.\n+                            let crate_name = crate_name.unwrap();\n \n-                                match original {\n-                                    Some(name) => found_extern_crate = name.as_str() == crate_name,\n-                                    None => found_extern_crate = item.ident.as_str() == crate_name,\n-                                }\n+                            match original {\n+                                Some(name) => found_extern_crate = name.as_str() == crate_name,\n+                                None => found_extern_crate = item.ident.as_str() == crate_name,\n                             }\n                         }\n \n-                        if !found_macro {\n-                            if let ast::ItemKind::MacCall(..) = item.kind {\n-                                found_macro = true;\n-                            }\n+                        if !found_macro && let ast::ItemKind::MacCall(..) = item.kind {\n+                            found_macro = true;\n                         }\n \n                         if found_main && found_extern_crate {\n@@ -972,14 +969,12 @@ impl Collector {\n     fn get_filename(&self) -> FileName {\n         if let Some(ref source_map) = self.source_map {\n             let filename = source_map.span_to_filename(self.position);\n-            if let FileName::Real(ref filename) = filename {\n-                if let Ok(cur_dir) = env::current_dir() {\n-                    if let Some(local_path) = filename.local_path() {\n-                        if let Ok(path) = local_path.strip_prefix(&cur_dir) {\n-                            return path.to_owned().into();\n-                        }\n-                    }\n-                }\n+            if let FileName::Real(ref filename) = filename &&\n+                let Ok(cur_dir) = env::current_dir() &&\n+                let Some(local_path) = filename.local_path() &&\n+                let Ok(path) = local_path.strip_prefix(&cur_dir)\n+            {\n+                return path.to_owned().into();\n             }\n             filename\n         } else if let Some(ref filename) = self.filename {"}, {"sha": "b1db16cfe3cacd6081854c4143289d41151f04c5", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -229,16 +229,15 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n         }\n \n         // Collect all the implementors of traits.\n-        if let clean::ImplItem(ref i) = *item.kind {\n-            if let Some(trait_) = &i.trait_ {\n-                if !i.kind.is_blanket() {\n-                    self.cache\n-                        .implementors\n-                        .entry(trait_.def_id())\n-                        .or_default()\n-                        .push(Impl { impl_item: item.clone() });\n-                }\n-            }\n+        if let clean::ImplItem(ref i) = *item.kind &&\n+            let Some(trait_) = &i.trait_ &&\n+            !i.kind.is_blanket()\n+        {\n+            self.cache\n+                .implementors\n+                .entry(trait_.def_id())\n+                .or_default()\n+                .push(Impl { impl_item: item.clone() });\n         }\n \n         // Index this method for searching later on."}, {"sha": "1ed0b0bc2d558eec00c7b93f7fbbc10226d4d216", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -710,11 +710,9 @@ pub(crate) fn href_with_root_path(\n             }\n         }\n     };\n-    if !is_remote {\n-        if let Some(root_path) = root_path {\n-            let root = root_path.trim_end_matches('/');\n-            url_parts.push_front(root);\n-        }\n+    if !is_remote && let Some(root_path) = root_path {\n+        let root = root_path.trim_end_matches('/');\n+        url_parts.push_front(root);\n     }\n     debug!(?url_parts);\n     match shortty {"}, {"sha": "2c9fc4e3ca37824f4455dc47f397bc1e8f79525c", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -466,10 +466,8 @@ impl<'a> PeekIter<'a> {\n     }\n     /// Returns the next item after the current one. It doesn't interfere with `peek_next` output.\n     fn peek(&mut self) -> Option<&(TokenKind, &'a str)> {\n-        if self.stored.is_empty() {\n-            if let Some(next) = self.iter.next() {\n-                self.stored.push_back(next);\n-            }\n+        if self.stored.is_empty() && let Some(next) = self.iter.next() {\n+            self.stored.push_back(next);\n         }\n         self.stored.front()\n     }"}, {"sha": "5e4a595627b4a367385ca479c30f8257cdf3579e", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -705,14 +705,12 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             shared.fs.write(scrape_examples_help_file, v)?;\n         }\n \n-        if let Some(ref redirections) = shared.redirections {\n-            if !redirections.borrow().is_empty() {\n-                let redirect_map_path =\n-                    self.dst.join(crate_name.as_str()).join(\"redirect-map.json\");\n-                let paths = serde_json::to_string(&*redirections.borrow()).unwrap();\n-                shared.ensure_dir(&self.dst.join(crate_name.as_str()))?;\n-                shared.fs.write(redirect_map_path, paths)?;\n-            }\n+        if let Some(ref redirections) = shared.redirections && !redirections.borrow().is_empty() {\n+            let redirect_map_path =\n+                self.dst.join(crate_name.as_str()).join(\"redirect-map.json\");\n+            let paths = serde_json::to_string(&*redirections.borrow()).unwrap();\n+            shared.ensure_dir(&self.dst.join(crate_name.as_str()))?;\n+            shared.fs.write(redirect_map_path, paths)?;\n         }\n \n         // No need for it anymore."}, {"sha": "e6a040d02e565b464792ba16784b377367ae42ea", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -2225,14 +2225,13 @@ fn sidebar_deref_methods(\n         })\n     {\n         debug!(\"found target, real_target: {:?} {:?}\", target, real_target);\n-        if let Some(did) = target.def_id(c) {\n-            if let Some(type_did) = impl_.inner_impl().for_.def_id(c) {\n-                // `impl Deref<Target = S> for S`\n-                if did == type_did || !derefs.insert(did) {\n-                    // Avoid infinite cycles\n-                    return;\n-                }\n-            }\n+        if let Some(did) = target.def_id(c) &&\n+            let Some(type_did) = impl_.inner_impl().for_.def_id(c) &&\n+            // `impl Deref<Target = S> for S`\n+            (did == type_did || !derefs.insert(did))\n+        {\n+            // Avoid infinite cycles\n+            return;\n         }\n         let deref_mut = v.iter().any(|i| i.trait_did() == cx.tcx().lang_items().deref_mut_trait());\n         let inner_impl = target\n@@ -2266,25 +2265,24 @@ fn sidebar_deref_methods(\n         }\n \n         // Recurse into any further impls that might exist for `target`\n-        if let Some(target_did) = target.def_id(c) {\n-            if let Some(target_impls) = c.impls.get(&target_did) {\n-                if let Some(target_deref_impl) = target_impls.iter().find(|i| {\n-                    i.inner_impl()\n-                        .trait_\n-                        .as_ref()\n-                        .map(|t| Some(t.def_id()) == cx.tcx().lang_items().deref_trait())\n-                        .unwrap_or(false)\n-                }) {\n-                    sidebar_deref_methods(\n-                        cx,\n-                        out,\n-                        target_deref_impl,\n-                        target_impls,\n-                        derefs,\n-                        used_links,\n-                    );\n-                }\n-            }\n+        if let Some(target_did) = target.def_id(c) &&\n+            let Some(target_impls) = c.impls.get(&target_did) &&\n+            let Some(target_deref_impl) = target_impls.iter().find(|i| {\n+                i.inner_impl()\n+                    .trait_\n+                    .as_ref()\n+                    .map(|t| Some(t.def_id()) == cx.tcx().lang_items().deref_trait())\n+                    .unwrap_or(false)\n+            })\n+        {\n+            sidebar_deref_methods(\n+                cx,\n+                out,\n+                target_deref_impl,\n+                target_impls,\n+                derefs,\n+                used_links,\n+            );\n         }\n     }\n }"}, {"sha": "e3788fe57d013d8eb06fc50a963272055266da59", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -80,12 +80,11 @@ impl<'tcx> JsonRenderer<'tcx> {\n                         // document primitive items in an arbitrary crate by using\n                         // `doc(primitive)`.\n                         let mut is_primitive_impl = false;\n-                        if let clean::types::ItemKind::ImplItem(ref impl_) = *item.kind {\n-                            if impl_.trait_.is_none() {\n-                                if let clean::types::Type::Primitive(_) = impl_.for_ {\n-                                    is_primitive_impl = true;\n-                                }\n-                            }\n+                        if let clean::types::ItemKind::ImplItem(ref impl_) = *item.kind &&\n+                            impl_.trait_.is_none() &&\n+                            let clean::types::Type::Primitive(_) = impl_.for_\n+                        {\n+                            is_primitive_impl = true;\n                         }\n \n                         if item.item_id.is_local() || is_primitive_impl {"}, {"sha": "a39d57d42b72e1910b9ea2c61e31b51039cca559", "filename": "src/librustdoc/passes/check_doc_test_visibility.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -82,18 +82,17 @@ pub(crate) fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -\n     let def_id = item.item_id.expect_def_id().expect_local();\n \n     // check if parent is trait impl\n-    if let Some(parent_def_id) = cx.tcx.opt_local_parent(def_id) {\n-        if let Some(parent_node) = cx.tcx.hir().find_by_def_id(parent_def_id) {\n-            if matches!(\n-                parent_node,\n-                hir::Node::Item(hir::Item {\n-                    kind: hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }),\n-                    ..\n-                })\n-            ) {\n-                return false;\n-            }\n-        }\n+    if let Some(parent_def_id) = cx.tcx.opt_local_parent(def_id) &&\n+        let Some(parent_node) = cx.tcx.hir().find_by_def_id(parent_def_id) &&\n+        matches!(\n+            parent_node,\n+            hir::Node::Item(hir::Item {\n+                kind: hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }),\n+                ..\n+            })\n+        )\n+    {\n+        return false;\n     }\n \n     if cx.tcx.is_doc_hidden(def_id.to_def_id())"}, {"sha": "189b37b69d132db3785e4cfcd1dbb6ea7c9ec0cf", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -156,39 +156,38 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n \n     // scan through included items ahead of time to splice in Deref targets to the \"valid\" sets\n     for it in new_items_external.iter().chain(new_items_local.iter()) {\n-        if let ImplItem(box Impl { ref for_, ref trait_, ref items, .. }) = *it.kind {\n-            if trait_.as_ref().map(|t| t.def_id()) == cx.tcx.lang_items().deref_trait()\n-                && cleaner.keep_impl(for_, true)\n-            {\n-                let target = items\n-                    .iter()\n-                    .find_map(|item| match *item.kind {\n-                        AssocTypeItem(ref t, _) => Some(&t.type_),\n-                        _ => None,\n-                    })\n-                    .expect(\"Deref impl without Target type\");\n+        if let ImplItem(box Impl { ref for_, ref trait_, ref items, .. }) = *it.kind &&\n+            trait_.as_ref().map(|t| t.def_id()) == cx.tcx.lang_items().deref_trait() &&\n+            cleaner.keep_impl(for_, true)\n+        {\n+            let target = items\n+                .iter()\n+                .find_map(|item| match *item.kind {\n+                    AssocTypeItem(ref t, _) => Some(&t.type_),\n+                    _ => None,\n+                })\n+                .expect(\"Deref impl without Target type\");\n \n-                if let Some(prim) = target.primitive_type() {\n-                    cleaner.prims.insert(prim);\n-                } else if let Some(did) = target.def_id(&cx.cache) {\n-                    cleaner.items.insert(did.into());\n-                }\n-                if let Some(for_did) = for_.def_id(&cx.cache) {\n-                    if type_did_to_deref_target.insert(for_did, target).is_none() {\n-                        // Since only the `DefId` portion of the `Type` instances is known to be same for both the\n-                        // `Deref` target type and the impl for type positions, this map of types is keyed by\n-                        // `DefId` and for convenience uses a special cleaner that accepts `DefId`s directly.\n-                        if cleaner.keep_impl_with_def_id(for_did.into()) {\n-                            let mut targets = DefIdSet::default();\n-                            targets.insert(for_did);\n-                            add_deref_target(\n-                                cx,\n-                                &type_did_to_deref_target,\n-                                &mut cleaner,\n-                                &mut targets,\n-                                for_did,\n-                            );\n-                        }\n+            if let Some(prim) = target.primitive_type() {\n+                cleaner.prims.insert(prim);\n+            } else if let Some(did) = target.def_id(&cx.cache) {\n+                cleaner.items.insert(did.into());\n+            }\n+            if let Some(for_did) = for_.def_id(&cx.cache) {\n+                if type_did_to_deref_target.insert(for_did, target).is_none() {\n+                    // Since only the `DefId` portion of the `Type` instances is known to be same for both the\n+                    // `Deref` target type and the impl for type positions, this map of types is keyed by\n+                    // `DefId` and for convenience uses a special cleaner that accepts `DefId`s directly.\n+                    if cleaner.keep_impl_with_def_id(for_did.into()) {\n+                        let mut targets = DefIdSet::default();\n+                        targets.insert(for_did);\n+                        add_deref_target(\n+                            cx,\n+                            &type_did_to_deref_target,\n+                            &mut cleaner,\n+                            &mut targets,\n+                            for_did,\n+                        );\n                     }\n                 }\n             }"}, {"sha": "eac362b37b20988d60a1fa17c5db65199e834ee9", "filename": "src/librustdoc/passes/lint/html_tags.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fpasses%2Flint%2Fhtml_tags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fpasses%2Flint%2Fhtml_tags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Flint%2Fhtml_tags.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -210,11 +210,9 @@ fn extract_path_backwards(text: &str, end_pos: usize) -> Option<usize> {\n             .take_while(|(_, c)| is_id_start(*c) || is_id_continue(*c))\n             .reduce(|_accum, item| item)\n             .and_then(|(new_pos, c)| is_id_start(c).then_some(new_pos));\n-        if let Some(new_pos) = new_pos {\n-            if current_pos != new_pos {\n-                current_pos = new_pos;\n-                continue;\n-            }\n+        if let Some(new_pos) = new_pos && current_pos != new_pos {\n+            current_pos = new_pos;\n+            continue;\n         }\n         break;\n     }"}, {"sha": "cba55e5fe655c7eb19c2a12266b190ec4f7ec6d0", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -201,27 +201,25 @@ impl<'a> DocFolder for ImplStripper<'a, '_> {\n             // Because we don't inline in `maybe_inline_local` if the output format is JSON,\n             // we need to make a special check for JSON output: we want to keep it unless it has\n             // a `#[doc(hidden)]` attribute if the `for_` type is exported.\n-            if let Some(did) = imp.for_.def_id(self.cache) {\n-                if !imp.for_.is_assoc_ty() && !self.should_keep_impl(&i, did) {\n-                    debug!(\"ImplStripper: impl item for stripped type; removing\");\n-                    return None;\n-                }\n+            if let Some(did) = imp.for_.def_id(self.cache) &&\n+                !imp.for_.is_assoc_ty() && !self.should_keep_impl(&i, did)\n+            {\n+                debug!(\"ImplStripper: impl item for stripped type; removing\");\n+                return None;\n             }\n-            if let Some(did) = imp.trait_.as_ref().map(|t| t.def_id()) {\n-                if !self.should_keep_impl(&i, did) {\n-                    debug!(\"ImplStripper: impl item for stripped trait; removing\");\n-                    return None;\n-                }\n+            if let Some(did) = imp.trait_.as_ref().map(|t| t.def_id()) &&\n+                !self.should_keep_impl(&i, did) {\n+                debug!(\"ImplStripper: impl item for stripped trait; removing\");\n+                return None;\n             }\n             if let Some(generics) = imp.trait_.as_ref().and_then(|t| t.generics()) {\n                 for typaram in generics {\n-                    if let Some(did) = typaram.def_id(self.cache) {\n-                        if !self.should_keep_impl(&i, did) {\n-                            debug!(\n-                                \"ImplStripper: stripped item in trait's generics; removing impl\"\n-                            );\n-                            return None;\n-                        }\n+                    if let Some(did) = typaram.def_id(self.cache) && !self.should_keep_impl(&i, did)\n+                    {\n+                        debug!(\n+                            \"ImplStripper: stripped item in trait's generics; removing impl\"\n+                        );\n+                        return None;\n                     }\n                 }\n             }"}, {"sha": "4dc750c03b488d1a80cd5e66a33e4b09a9dcba18", "filename": "src/tools/clippy/clippy_lints/src/large_const_arrays.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -54,7 +54,7 @@ impl<'tcx> LateLintPass<'tcx> for LargeConstArrays {\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n             if let ty::Array(element_type, cst) = ty.kind();\n             if let ConstKind::Value(ty::ValTree::Leaf(element_count)) = cst.kind();\n-            if let Ok(element_count) = element_count.try_to_machine_usize(cx.tcx);\n+            if let Ok(element_count) = element_count.try_to_target_usize(cx.tcx);\n             if let Ok(element_size) = cx.layout_of(*element_type).map(|l| l.size.bytes());\n             if self.maximum_allowed_size < u128::from(element_count) * u128::from(element_size);\n "}, {"sha": "32c6312e06946a1180235d3de00db25ebff23a8c", "filename": "src/tools/clippy/clippy_lints/src/large_stack_arrays.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -41,7 +41,7 @@ impl<'tcx> LateLintPass<'tcx> for LargeStackArrays {\n         if let ExprKind::Repeat(_, _) = expr.kind\n           && let ty::Array(element_type, cst) = cx.typeck_results().expr_ty(expr).kind()\n           && let ConstKind::Value(ty::ValTree::Leaf(element_count)) = cst.kind()\n-          && let Ok(element_count) = element_count.try_to_machine_usize(cx.tcx)\n+          && let Ok(element_count) = element_count.try_to_target_usize(cx.tcx)\n           && let Ok(element_size) = cx.layout_of(*element_type).map(|l| l.size.bytes())\n           && !cx.tcx.hir().parent_iter(expr.hir_id)\n               .any(|(_, node)| matches!(node, Node::Item(Item { kind: ItemKind::Static(..), .. })))"}, {"sha": "8b00ce2cc258632bed3ee8259c169a86870e2ec4", "filename": "src/tools/clippy/clippy_utils/src/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -640,7 +640,7 @@ pub fn miri_to_const<'tcx>(tcx: TyCtxt<'tcx>, result: mir::ConstantKind<'tcx>) -\n         },\n         mir::ConstantKind::Val(ConstValue::ByRef { alloc, offset: _ }, _) => match result.ty().kind() {\n             ty::Array(sub_type, len) => match sub_type.kind() {\n-                ty::Float(FloatTy::F32) => match len.kind().try_to_machine_usize(tcx) {\n+                ty::Float(FloatTy::F32) => match len.kind().try_to_target_usize(tcx) {\n                     Some(len) => alloc\n                         .inner()\n                         .inspect_with_uninit_and_ptr_outside_interpreter(0..(4 * usize::try_from(len).unwrap()))\n@@ -651,7 +651,7 @@ pub fn miri_to_const<'tcx>(tcx: TyCtxt<'tcx>, result: mir::ConstantKind<'tcx>) -\n                         .map(Constant::Vec),\n                     _ => None,\n                 },\n-                ty::Float(FloatTy::F64) => match len.kind().try_to_machine_usize(tcx) {\n+                ty::Float(FloatTy::F64) => match len.kind().try_to_target_usize(tcx) {\n                     Some(len) => alloc\n                         .inner()\n                         .inspect_with_uninit_and_ptr_outside_interpreter(0..(8 * usize::try_from(len).unwrap()))"}, {"sha": "cf1ff603281ee3255b9d400ede5781d70aa61fff", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -718,7 +718,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n             throw_ub!(PointerOutOfBounds {\n                 alloc_id,\n                 alloc_size,\n-                ptr_offset: this.machine_usize_to_isize(base_offset.bytes()),\n+                ptr_offset: this.target_usize_to_isize(base_offset.bytes()),\n                 ptr_size: size,\n                 msg: CheckInAllocMsg::InboundsTest\n             });"}, {"sha": "d61e17cbf9a4aee3de02fabb8917b71baef32e19", "filename": "src/tools/miri/src/eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -236,7 +236,7 @@ impl MainThreadState {\n                     this.machine.main_fn_ret_place.unwrap().ptr,\n                     this.machine.layouts.isize,\n                 );\n-                let exit_code = this.read_machine_isize(&ret_place.into())?;\n+                let exit_code = this.read_target_isize(&ret_place.into())?;\n                 // Need to call this ourselves since we are not going to return to the scheduler\n                 // loop, and we want the main thread TLS to not show up as memory leaks.\n                 this.terminate_active_thread()?;\n@@ -287,7 +287,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     // First argument is constructed later, because it's skipped if the entry function uses #[start].\n \n     // Second argument (argc): length of `config.args`.\n-    let argc = Scalar::from_machine_usize(u64::try_from(config.args.len()).unwrap(), &ecx);\n+    let argc = Scalar::from_target_usize(u64::try_from(config.args.len()).unwrap(), &ecx);\n     // Third argument (`argv`): created from `config.args`.\n     let argv = {\n         // Put each argument in memory, collect pointers."}, {"sha": "5286023e0f64e0174e22c1dfb4f64288e2be77ad", "filename": "src/tools/miri/src/helpers.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -758,10 +758,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n         let seconds_place = this.mplace_field(tp, 0)?;\n         let seconds_scalar = this.read_scalar(&seconds_place.into())?;\n-        let seconds = seconds_scalar.to_machine_isize(this)?;\n+        let seconds = seconds_scalar.to_target_isize(this)?;\n         let nanoseconds_place = this.mplace_field(tp, 1)?;\n         let nanoseconds_scalar = this.read_scalar(&nanoseconds_place.into())?;\n-        let nanoseconds = nanoseconds_scalar.to_machine_isize(this)?;\n+        let nanoseconds = nanoseconds_scalar.to_target_isize(this)?;\n \n         Ok(try {\n             // tv_sec must be non-negative."}, {"sha": "2ba18293121dcaa3bb7c11a875953b1b86f0ff6e", "filename": "src/tools/miri/src/intptrcast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -207,7 +207,7 @@ impl<'mir, 'tcx> GlobalStateInner {\n                     .checked_add(max(size.bytes(), 1))\n                     .ok_or_else(|| err_exhaust!(AddressSpaceFull))?;\n                 // Even if `Size` didn't overflow, we might still have filled up the address space.\n-                if global_state.next_base_addr > ecx.machine_usize_max() {\n+                if global_state.next_base_addr > ecx.target_usize_max() {\n                     throw_exhaust!(AddressSpaceFull);\n                 }\n                 // Given that `next_base_addr` increases in each allocation, pushing the"}, {"sha": "79d5dfb5551bd47a72425068cb495c490a28c8be", "filename": "src/tools/miri/src/operator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Foperator.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -56,7 +56,7 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriInterpCx<'mir, 'tcx> {\n             Offset => {\n                 assert!(left.layout.ty.is_unsafe_ptr());\n                 let ptr = left.to_scalar().to_pointer(self)?;\n-                let offset = right.to_scalar().to_machine_isize(self)?;\n+                let offset = right.to_scalar().to_target_isize(self)?;\n \n                 let pointee_ty =\n                     left.layout.ty.builtin_deref(true).expect(\"Offset called on non-ptr type\").ty;\n@@ -73,14 +73,14 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriInterpCx<'mir, 'tcx> {\n                 // We do the actual operation with usize-typed scalars.\n                 let left = ImmTy::from_uint(ptr.addr().bytes(), self.machine.layouts.usize);\n                 let right = ImmTy::from_uint(\n-                    right.to_scalar().to_machine_usize(self)?,\n+                    right.to_scalar().to_target_usize(self)?,\n                     self.machine.layouts.usize,\n                 );\n                 let (result, overflowing, _ty) =\n                     self.overflowing_binary_op(bin_op, &left, &right)?;\n                 // Construct a new pointer with the provenance of `ptr` (the LHS).\n                 let result_ptr =\n-                    Pointer::new(ptr.provenance, Size::from_bytes(result.to_machine_usize(self)?));\n+                    Pointer::new(ptr.provenance, Size::from_bytes(result.to_target_usize(self)?));\n                 (Scalar::from_maybe_pointer(result_ptr, self), overflowing, left.layout.ty)\n             }\n "}, {"sha": "1e4ab2f0f622730109c28c5ccec807c646ef62fb", "filename": "src/tools/miri/src/shims/backtrace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fbacktrace.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -24,7 +24,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         let frame_count = this.active_thread_stack().len();\n \n-        this.write_scalar(Scalar::from_machine_usize(frame_count.try_into().unwrap(), this), dest)\n+        this.write_scalar(Scalar::from_target_usize(frame_count.try_into().unwrap(), this), dest)\n     }\n \n     fn handle_miri_get_backtrace(\n@@ -205,11 +205,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             }\n             1 => {\n                 this.write_scalar(\n-                    Scalar::from_machine_usize(name.len().try_into().unwrap(), this),\n+                    Scalar::from_target_usize(name.len().try_into().unwrap(), this),\n                     &this.mplace_field(&dest, 0)?.into(),\n                 )?;\n                 this.write_scalar(\n-                    Scalar::from_machine_usize(filename.len().try_into().unwrap(), this),\n+                    Scalar::from_target_usize(filename.len().try_into().unwrap(), this),\n                     &this.mplace_field(&dest, 1)?.into(),\n                 )?;\n             }"}, {"sha": "f50c135435fd778713745547338c39baf6d69530", "filename": "src/tools/miri/src/shims/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -323,7 +323,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         this.assert_target_os_is_unix(\"getcwd\");\n \n         let buf = this.read_pointer(buf_op)?;\n-        let size = this.read_machine_usize(size_op)?;\n+        let size = this.read_target_usize(size_op)?;\n \n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n             this.reject_in_isolation(\"`getcwd`\", reject_with)?;"}, {"sha": "e628c44a86788697d70a2911364628166fb19655", "filename": "src/tools/miri/src/shims/ffi_support.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fffi_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fffi_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fffi_support.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -36,7 +36,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             ty::Int(IntTy::Isize) => {\n                 // This will fail if host != target, but then the entire FFI thing probably won't work well\n                 // in that situation.\n-                return Ok(CArg::ISize(k.to_machine_isize(cx)?.try_into().unwrap()));\n+                return Ok(CArg::ISize(k.to_target_isize(cx)?.try_into().unwrap()));\n             }\n             // the uints\n             ty::Uint(UintTy::U8) => {\n@@ -54,7 +54,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             ty::Uint(UintTy::Usize) => {\n                 // This will fail if host != target, but then the entire FFI thing probably won't work well\n                 // in that situation.\n-                return Ok(CArg::USize(k.to_machine_usize(cx)?.try_into().unwrap()));\n+                return Ok(CArg::USize(k.to_target_usize(cx)?.try_into().unwrap()));\n             }\n             _ => {}\n         }"}, {"sha": "2d9eb37a2580672c442241150276505535bce3c5", "filename": "src/tools/miri/src/shims/foreign_items.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -449,7 +449,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let [ptr, out, out_size] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n                 let ptr = this.read_pointer(ptr)?;\n                 let out = this.read_pointer(out)?;\n-                let out_size = this.read_scalar(out_size)?.to_machine_usize(this)?;\n+                let out_size = this.read_scalar(out_size)?.to_target_usize(this)?;\n \n                 // The host affects program behavior here, so this requires isolation to be disabled.\n                 this.check_no_isolation(\"`miri_host_to_target_path`\")?;\n@@ -490,7 +490,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let [bytes] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n                 let (ptr, len) = this.read_immediate(bytes)?.to_scalar_pair();\n                 let ptr = ptr.to_pointer(this)?;\n-                let len = len.to_machine_usize(this)?;\n+                let len = len.to_target_usize(this)?;\n                 let msg = this.read_bytes_ptr_strip_provenance(ptr, Size::from_bytes(len))?;\n \n                 // Note: we're ignoring errors writing to host stdout/stderr.\n@@ -504,15 +504,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             // Standard C allocation\n             \"malloc\" => {\n                 let [size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                let size = this.read_machine_usize(size)?;\n+                let size = this.read_target_usize(size)?;\n                 let res = this.malloc(size, /*zero_init:*/ false, MiriMemoryKind::C)?;\n                 this.write_pointer(res, dest)?;\n             }\n             \"calloc\" => {\n                 let [items, len] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                let items = this.read_machine_usize(items)?;\n-                let len = this.read_machine_usize(len)?;\n+                let items = this.read_target_usize(items)?;\n+                let len = this.read_target_usize(len)?;\n                 let size = items\n                     .checked_mul(len)\n                     .ok_or_else(|| err_ub_format!(\"overflow during calloc size computation\"))?;\n@@ -528,16 +528,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let [old_ptr, new_size] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let old_ptr = this.read_pointer(old_ptr)?;\n-                let new_size = this.read_machine_usize(new_size)?;\n+                let new_size = this.read_target_usize(new_size)?;\n                 let res = this.realloc(old_ptr, new_size, MiriMemoryKind::C)?;\n                 this.write_pointer(res, dest)?;\n             }\n \n             // Rust allocation\n             \"__rust_alloc\" | \"miri_alloc\" => {\n                 let [size, align] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n-                let size = this.read_machine_usize(size)?;\n-                let align = this.read_machine_usize(align)?;\n+                let size = this.read_target_usize(size)?;\n+                let align = this.read_target_usize(align)?;\n \n                 let default = |this: &mut MiriInterpCx<'mir, 'tcx>| {\n                     Self::check_alloc_request(size, align)?;\n@@ -569,8 +569,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             }\n             \"__rust_alloc_zeroed\" => {\n                 let [size, align] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n-                let size = this.read_machine_usize(size)?;\n-                let align = this.read_machine_usize(align)?;\n+                let size = this.read_target_usize(size)?;\n+                let align = this.read_target_usize(align)?;\n \n                 return this.emulate_allocator(Symbol::intern(\"__rg_alloc_zeroed\"), |this| {\n                     Self::check_alloc_request(size, align)?;\n@@ -593,8 +593,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             \"__rust_dealloc\" | \"miri_dealloc\" => {\n                 let [ptr, old_size, align] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n                 let ptr = this.read_pointer(ptr)?;\n-                let old_size = this.read_machine_usize(old_size)?;\n-                let align = this.read_machine_usize(align)?;\n+                let old_size = this.read_target_usize(old_size)?;\n+                let align = this.read_target_usize(align)?;\n \n                 let default = |this: &mut MiriInterpCx<'mir, 'tcx>| {\n                     let memory_kind = match link_name.as_str() {\n@@ -625,9 +625,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let [ptr, old_size, align, new_size] =\n                     this.check_shim(abi, Abi::Rust, link_name, args)?;\n                 let ptr = this.read_pointer(ptr)?;\n-                let old_size = this.read_machine_usize(old_size)?;\n-                let align = this.read_machine_usize(align)?;\n-                let new_size = this.read_machine_usize(new_size)?;\n+                let old_size = this.read_target_usize(old_size)?;\n+                let align = this.read_target_usize(align)?;\n+                let new_size = this.read_target_usize(new_size)?;\n                 // No need to check old_size; we anyway check that they match the allocation.\n \n                 return this.emulate_allocator(Symbol::intern(\"__rg_realloc\"), |this| {\n@@ -651,7 +651,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let left = this.read_pointer(left)?;\n                 let right = this.read_pointer(right)?;\n-                let n = Size::from_bytes(this.read_machine_usize(n)?);\n+                let n = Size::from_bytes(this.read_target_usize(n)?);\n \n                 let result = {\n                     let left_bytes = this.read_bytes_ptr_strip_provenance(left, n)?;\n@@ -672,7 +672,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let ptr = this.read_pointer(ptr)?;\n                 let val = this.read_scalar(val)?.to_i32()?;\n-                let num = this.read_machine_usize(num)?;\n+                let num = this.read_target_usize(num)?;\n                 // The docs say val is \"interpreted as unsigned char\".\n                 #[allow(clippy::cast_sign_loss, clippy::cast_possible_truncation)]\n                 let val = val as u8;\n@@ -696,7 +696,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let ptr = this.read_pointer(ptr)?;\n                 let val = this.read_scalar(val)?.to_i32()?;\n-                let num = this.read_machine_usize(num)?;\n+                let num = this.read_target_usize(num)?;\n                 // The docs say val is \"interpreted as unsigned char\".\n                 #[allow(clippy::cast_sign_loss, clippy::cast_possible_truncation)]\n                 let val = val as u8;\n@@ -717,7 +717,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let ptr = this.read_pointer(ptr)?;\n                 let n = this.read_c_str(ptr)?.len();\n                 this.write_scalar(\n-                    Scalar::from_machine_usize(u64::try_from(n).unwrap(), this),\n+                    Scalar::from_target_usize(u64::try_from(n).unwrap(), this),\n                     dest,\n                 )?;\n             }"}, {"sha": "d21a1560699c24f0ddd9806022e3f919aef0ed3e", "filename": "src/tools/miri/src/shims/intrinsics/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fmod.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -111,8 +111,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let ty_layout = this.layout_of(ty)?;\n                 let val_byte = this.read_scalar(val_byte)?.to_u8()?;\n                 let ptr = this.read_pointer(ptr)?;\n-                let count = this.read_machine_usize(count)?;\n-                // `checked_mul` enforces a too small bound (the correct one would probably be machine_isize_max),\n+                let count = this.read_target_usize(count)?;\n+                // `checked_mul` enforces a too small bound (the correct one would probably be target_isize_max),\n                 // but no actual allocation can be big enough for the difference to be noticeable.\n                 let byte_count = ty_layout.size.checked_mul(count, this).ok_or_else(|| {\n                     err_ub_format!(\"overflow computing total size of `{intrinsic_name}`\")\n@@ -124,7 +124,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let [ptr, mask] = check_arg_count(args)?;\n \n                 let ptr = this.read_pointer(ptr)?;\n-                let mask = this.read_machine_usize(mask)?;\n+                let mask = this.read_target_usize(mask)?;\n \n                 let masked_addr = Size::from_bytes(ptr.addr().bytes() & mask);\n "}, {"sha": "f2e16521290fe98e8fdd397f14a15eb7e670eb73", "filename": "src/tools/miri/src/shims/intrinsics/simd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fsimd.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -202,7 +202,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                         }\n                         Op::WrappingOffset => {\n                             let ptr = left.to_scalar().to_pointer(this)?;\n-                            let offset_count = right.to_scalar().to_machine_isize(this)?;\n+                            let offset_count = right.to_scalar().to_target_isize(this)?;\n                             let pointee_ty = left.layout.ty.builtin_deref(true).unwrap().ty;\n \n                             let pointee_size = i64::try_from(this.layout_of(pointee_ty)?.size.bytes()).unwrap();"}, {"sha": "dbc48876a4b0651c2a8e14534ec5a64b4d9a3bf9", "filename": "src/tools/miri/src/shims/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fmod.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -80,7 +80,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             return Ok(false);\n         }\n \n-        let req_align = this.read_machine_usize(align_op)?;\n+        let req_align = this.read_target_usize(align_op)?;\n \n         // Stop if the alignment is not a power of two.\n         if !req_align.is_power_of_two() {\n@@ -106,7 +106,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n \n         // Return error result (usize::MAX), and jump to caller.\n-        this.write_scalar(Scalar::from_machine_usize(this.machine_usize_max(), this), dest)?;\n+        this.write_scalar(Scalar::from_target_usize(this.target_usize_max(), this), dest)?;\n         this.go_to_block(ret);\n         Ok(true)\n     }"}, {"sha": "e9119f9e1eced337bee74b36c0f743e258686161", "filename": "src/tools/miri/src/shims/tls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -108,7 +108,7 @@ impl<'tcx> TlsData<'tcx> {\n     ) -> InterpResult<'tcx> {\n         match self.keys.get_mut(&key) {\n             Some(TlsEntry { data, .. }) => {\n-                if new_data.to_machine_usize(cx)? != 0 {\n+                if new_data.to_target_usize(cx)? != 0 {\n                     trace!(\"TLS key {} for thread {:?} stored: {:?}\", key, thread_id, new_data);\n                     data.insert(thread_id, new_data);\n                 } else {\n@@ -356,7 +356,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             state.last_key = Some(key);\n             trace!(\"Running TLS dtor {:?} on {:?} at {:?}\", instance, ptr, active_thread);\n             assert!(\n-                !ptr.to_machine_usize(this).unwrap() != 0,\n+                !ptr.to_target_usize(this).unwrap() != 0,\n                 \"data can't be NULL when dtor is called!\"\n             );\n "}, {"sha": "c371e85c312e8ff0f6f7d1051d9f83e6c9a06276", "filename": "src/tools/miri/src/shims/unix/foreign_items.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fforeign_items.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -78,19 +78,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let [fd, buf, count] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let fd = this.read_scalar(fd)?.to_i32()?;\n                 let buf = this.read_pointer(buf)?;\n-                let count = this.read_machine_usize(count)?;\n+                let count = this.read_target_usize(count)?;\n                 let result = this.read(fd, buf, count)?;\n-                this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n+                this.write_scalar(Scalar::from_target_isize(result, this), dest)?;\n             }\n             \"write\" => {\n                 let [fd, buf, n] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let fd = this.read_scalar(fd)?.to_i32()?;\n                 let buf = this.read_pointer(buf)?;\n-                let count = this.read_machine_usize(n)?;\n+                let count = this.read_target_usize(n)?;\n                 trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, count);\n                 let result = this.write(fd, buf, count)?;\n                 // Now, `result` is the value we return back to the program.\n-                this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n+                this.write_scalar(Scalar::from_target_isize(result, this), dest)?;\n             }\n             \"unlink\" => {\n                 let [path] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n@@ -151,14 +151,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             \"readlink\" => {\n                 let [pathname, buf, bufsize] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.readlink(pathname, buf, bufsize)?;\n-                this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n+                this.write_scalar(Scalar::from_target_isize(result, this), dest)?;\n             }\n             \"posix_fadvise\" => {\n                 let [fd, offset, len, advice] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.read_scalar(fd)?.to_i32()?;\n-                this.read_machine_isize(offset)?;\n-                this.read_machine_isize(len)?;\n+                this.read_target_isize(offset)?;\n+                this.read_target_isize(len)?;\n                 this.read_scalar(advice)?.to_i32()?;\n                 // fadvise is only informational, we can ignore it.\n                 this.write_null(dest)?;\n@@ -191,8 +191,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             \"posix_memalign\" => {\n                 let [ret, align, size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let ret = this.deref_operand(ret)?;\n-                let align = this.read_machine_usize(align)?;\n-                let size = this.read_machine_usize(size)?;\n+                let align = this.read_target_usize(align)?;\n+                let size = this.read_target_usize(size)?;\n                 // Align must be power of 2, and also at least ptr-sized (POSIX rules).\n                 // But failure to adhere to this is not UB, it's an error condition.\n                 if !align.is_power_of_two() || align < this.pointer_size().bytes() {\n@@ -216,7 +216,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             // Dynamic symbol loading\n             \"dlsym\" => {\n                 let [handle, symbol] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                this.read_machine_usize(handle)?;\n+                this.read_target_usize(handle)?;\n                 let symbol = this.read_pointer(symbol)?;\n                 let symbol_name = this.read_c_str(symbol)?;\n                 if let Some(dlsym) = Dlsym::from_str(symbol_name, &this.tcx.sess.target.os)? {\n@@ -472,7 +472,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let [errnum, buf, buflen] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let errnum = this.read_scalar(errnum)?;\n                 let buf = this.read_pointer(buf)?;\n-                let buflen = this.read_machine_usize(buflen)?;\n+                let buflen = this.read_target_usize(buflen)?;\n \n                 let error = this.try_errnum_to_io_error(errnum)?;\n                 let formatted = match error {\n@@ -565,7 +565,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let uid = this.read_scalar(uid)?.to_u32()?;\n                 let pwd = this.deref_operand(pwd)?;\n                 let buf = this.read_pointer(buf)?;\n-                let buflen = this.read_machine_usize(buflen)?;\n+                let buflen = this.read_target_usize(buflen)?;\n                 let result = this.deref_operand(result)?;\n \n                 // Must be for \"us\"."}, {"sha": "d05c4d98fad6fd0b315f5d3c1556b7ee850e3f2c", "filename": "src/tools/miri/src/shims/unix/fs.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -754,7 +754,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // We cap the number of read bytes to the largest value that we are able to fit in both the\n         // host's and target's `isize`. This saves us from having to handle overflows later.\n         let count = count\n-            .min(u64::try_from(this.machine_isize_max()).unwrap())\n+            .min(u64::try_from(this.target_isize_max()).unwrap())\n             .min(u64::try_from(isize::MAX).unwrap());\n         let communicate = this.machine.communicate();\n \n@@ -807,7 +807,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // We cap the number of written bytes to the largest value that we are able to fit in both the\n         // host's and target's `isize`. This saves us from having to handle overflows later.\n         let count = count\n-            .min(u64::try_from(this.machine_isize_max()).unwrap())\n+            .min(u64::try_from(this.target_isize_max()).unwrap())\n             .min(u64::try_from(isize::MAX).unwrap());\n         let communicate = this.machine.communicate();\n \n@@ -1290,7 +1290,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // The libc API for opendir says that this method returns a pointer to an opaque\n                 // structure, but we are returning an ID number. Thus, pass it as a scalar of\n                 // pointer width.\n-                Ok(Scalar::from_machine_usize(id, this))\n+                Ok(Scalar::from_target_usize(id, this))\n             }\n             Err(e) => {\n                 this.set_last_error_from_io_error(e.kind())?;\n@@ -1307,7 +1307,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         this.assert_target_os(\"linux\", \"readdir64\");\n \n-        let dirp = this.read_machine_usize(dirp_op)?;\n+        let dirp = this.read_target_usize(dirp_op)?;\n \n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n@@ -1399,7 +1399,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         this.assert_target_os(\"macos\", \"readdir_r\");\n \n-        let dirp = this.read_machine_usize(dirp_op)?;\n+        let dirp = this.read_target_usize(dirp_op)?;\n \n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n@@ -1492,7 +1492,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn closedir(&mut self, dirp_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let dirp = this.read_machine_usize(dirp_op)?;\n+        let dirp = this.read_target_usize(dirp_op)?;\n \n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n@@ -1656,7 +1656,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         let pathname = this.read_path_from_c_str(this.read_pointer(pathname_op)?)?;\n         let buf = this.read_pointer(buf_op)?;\n-        let bufsize = this.read_machine_usize(bufsize_op)?;\n+        let bufsize = this.read_target_usize(bufsize_op)?;\n \n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n@@ -1727,7 +1727,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             this.reject_in_isolation(\"`realpath`\", reject_with)?;\n             let eacc = this.eval_libc(\"EACCES\");\n             this.set_last_error(eacc)?;\n-            return Ok(Scalar::from_machine_usize(0, this));\n+            return Ok(Scalar::from_target_usize(0, this));\n         }\n \n         let result = std::fs::canonicalize(pathname);\n@@ -1758,7 +1758,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                         // seems like a bit of a mess anyway: <https://eklitzke.org/path-max-is-tricky>.\n                         let enametoolong = this.eval_libc(\"ENAMETOOLONG\");\n                         this.set_last_error(enametoolong)?;\n-                        return Ok(Scalar::from_machine_usize(0, this));\n+                        return Ok(Scalar::from_target_usize(0, this));\n                     }\n                     processed_ptr\n                 };\n@@ -1767,7 +1767,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             }\n             Err(e) => {\n                 this.set_last_error_from_io_error(e.kind())?;\n-                Ok(Scalar::from_machine_usize(0, this))\n+                Ok(Scalar::from_target_usize(0, this))\n             }\n         }\n     }"}, {"sha": "9f6938424fb2d5c40d7f6c47d39cd96f21730e1b", "filename": "src/tools/miri/src/shims/unix/linux/foreign_items.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -119,18 +119,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // argument, we have to also check all arguments *before* it to ensure that they\n                 // have the right type.\n \n-                let sys_getrandom = this.eval_libc(\"SYS_getrandom\").to_machine_usize(this)?;\n+                let sys_getrandom = this.eval_libc(\"SYS_getrandom\").to_target_usize(this)?;\n \n-                let sys_statx = this.eval_libc(\"SYS_statx\").to_machine_usize(this)?;\n+                let sys_statx = this.eval_libc(\"SYS_statx\").to_target_usize(this)?;\n \n-                let sys_futex = this.eval_libc(\"SYS_futex\").to_machine_usize(this)?;\n+                let sys_futex = this.eval_libc(\"SYS_futex\").to_target_usize(this)?;\n \n                 if args.is_empty() {\n                     throw_ub_format!(\n                         \"incorrect number of arguments for syscall: got 0, expected at least 1\"\n                     );\n                 }\n-                match this.read_machine_usize(&args[0])? {\n+                match this.read_target_usize(&args[0])? {\n                     // `libc::syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), GRND_NONBLOCK)`\n                     // is called if a `HashMap` is created the regular way (e.g. HashMap<K, V>).\n                     id if id == sys_getrandom => {\n@@ -155,7 +155,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                         }\n                         let result =\n                             this.linux_statx(&args[1], &args[2], &args[3], &args[4], &args[5])?;\n-                        this.write_scalar(Scalar::from_machine_isize(result.into(), this), dest)?;\n+                        this.write_scalar(Scalar::from_target_isize(result.into(), this), dest)?;\n                     }\n                     // `futex` is used by some synchonization primitives.\n                     id if id == sys_futex => {\n@@ -178,7 +178,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let [pid, cpusetsize, mask] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.read_scalar(pid)?.to_i32()?;\n-                this.read_machine_usize(cpusetsize)?;\n+                this.read_target_usize(cpusetsize)?;\n                 this.deref_operand(mask)?;\n                 // FIXME: we just return an error; `num_cpus` then falls back to `sysconf`.\n                 let einval = this.eval_libc(\"EINVAL\");\n@@ -210,14 +210,14 @@ fn getrandom<'tcx>(\n     dest: &PlaceTy<'tcx, Provenance>,\n ) -> InterpResult<'tcx> {\n     let ptr = this.read_pointer(ptr)?;\n-    let len = this.read_machine_usize(len)?;\n+    let len = this.read_target_usize(len)?;\n \n     // The only supported flags are GRND_RANDOM and GRND_NONBLOCK,\n     // neither of which have any effect on our current PRNG.\n     // See <https://github.com/rust-lang/rust/pull/79196> for a discussion of argument sizes.\n     let _flags = this.read_scalar(flags)?.to_i32();\n \n     this.gen_random(ptr, len)?;\n-    this.write_scalar(Scalar::from_machine_usize(len, this), dest)?;\n+    this.write_scalar(Scalar::from_target_usize(len, this), dest)?;\n     Ok(())\n }"}, {"sha": "ffe3ca69c5866197a68fd91638b33d86455f71a1", "filename": "src/tools/miri/src/shims/unix/linux/sync.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -81,7 +81,7 @@ pub fn futex<'tcx>(\n             if bitset == 0 {\n                 let einval = this.eval_libc(\"EINVAL\");\n                 this.set_last_error(einval)?;\n-                this.write_scalar(Scalar::from_machine_isize(-1, this), dest)?;\n+                this.write_scalar(Scalar::from_target_isize(-1, this), dest)?;\n                 return Ok(());\n             }\n \n@@ -101,7 +101,7 @@ pub fn futex<'tcx>(\n                     None => {\n                         let einval = this.eval_libc(\"EINVAL\");\n                         this.set_last_error(einval)?;\n-                        this.write_scalar(Scalar::from_machine_isize(-1, this), dest)?;\n+                        this.write_scalar(Scalar::from_target_isize(-1, this), dest)?;\n                         return Ok(());\n                     }\n                 };\n@@ -173,7 +173,7 @@ pub fn futex<'tcx>(\n                 this.block_thread(thread);\n                 this.futex_wait(addr_usize, thread, bitset);\n                 // Succesfully waking up from FUTEX_WAIT always returns zero.\n-                this.write_scalar(Scalar::from_machine_isize(0, this), dest)?;\n+                this.write_scalar(Scalar::from_target_isize(0, this), dest)?;\n                 // Register a timeout callback if a timeout was specified.\n                 // This callback will override the return value when the timeout triggers.\n                 if let Some(timeout_time) = timeout_time {\n@@ -196,7 +196,7 @@ pub fn futex<'tcx>(\n                             this.futex_remove_waiter(self.addr_usize, self.thread);\n                             let etimedout = this.eval_libc(\"ETIMEDOUT\");\n                             this.set_last_error(etimedout)?;\n-                            this.write_scalar(Scalar::from_machine_isize(-1, this), &self.dest)?;\n+                            this.write_scalar(Scalar::from_target_isize(-1, this), &self.dest)?;\n \n                             Ok(())\n                         }\n@@ -213,7 +213,7 @@ pub fn futex<'tcx>(\n                 // right away without sleeping: -1 and errno set to EAGAIN.\n                 let eagain = this.eval_libc(\"EAGAIN\");\n                 this.set_last_error(eagain)?;\n-                this.write_scalar(Scalar::from_machine_isize(-1, this), dest)?;\n+                this.write_scalar(Scalar::from_target_isize(-1, this), dest)?;\n             }\n         }\n         // FUTEX_WAKE: (int *addr, int op = FUTEX_WAKE, int val)\n@@ -239,7 +239,7 @@ pub fn futex<'tcx>(\n             if bitset == 0 {\n                 let einval = this.eval_libc(\"EINVAL\");\n                 this.set_last_error(einval)?;\n-                this.write_scalar(Scalar::from_machine_isize(-1, this), dest)?;\n+                this.write_scalar(Scalar::from_target_isize(-1, this), dest)?;\n                 return Ok(());\n             }\n             // Together with the SeqCst fence in futex_wait, this makes sure that futex_wait\n@@ -257,7 +257,7 @@ pub fn futex<'tcx>(\n                     break;\n                 }\n             }\n-            this.write_scalar(Scalar::from_machine_isize(n, this), dest)?;\n+            this.write_scalar(Scalar::from_target_isize(n, this), dest)?;\n         }\n         op => throw_unsup_format!(\"Miri does not support `futex` syscall with op={}\", op),\n     }"}, {"sha": "9177ecefe1207372ff3c4b5f9938a2328038b489", "filename": "src/tools/miri/src/shims/unix/macos/dlsym.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fdlsym.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -39,7 +39,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             Dlsym::getentropy => {\n                 let [ptr, len] = check_arg_count(args)?;\n                 let ptr = this.read_pointer(ptr)?;\n-                let len = this.read_machine_usize(len)?;\n+                let len = this.read_target_usize(len)?;\n                 this.gen_random(ptr, len)?;\n                 this.write_null(dest)?;\n             }"}, {"sha": "1271788a97ef069998bcd46c3a3bee4936b4d69e", "filename": "src/tools/miri/src/shims/unix/macos/foreign_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -161,13 +161,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             // Querying system information\n             \"pthread_get_stackaddr_np\" => {\n                 let [thread] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                this.read_machine_usize(thread)?;\n+                this.read_target_usize(thread)?;\n                 let stack_addr = Scalar::from_uint(this.machine.stack_addr, this.pointer_size());\n                 this.write_scalar(stack_addr, dest)?;\n             }\n             \"pthread_get_stacksize_np\" => {\n                 let [thread] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                this.read_machine_usize(thread)?;\n+                this.read_target_usize(thread)?;\n                 let stack_size = Scalar::from_uint(this.machine.stack_size, this.pointer_size());\n                 this.write_scalar(stack_size, dest)?;\n             }\n@@ -176,7 +176,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             \"pthread_setname_np\" => {\n                 let [name] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let thread = this.pthread_self()?;\n-                let max_len = this.eval_libc(\"MAXTHREADNAMESIZE\").to_machine_usize(this)?;\n+                let max_len = this.eval_libc(\"MAXTHREADNAMESIZE\").to_target_usize(this)?;\n                 let res = this.pthread_setname_np(\n                     thread,\n                     this.read_scalar(name)?,"}, {"sha": "6165cfd2823070991e8b212c67db0e17d400674b", "filename": "src/tools/miri/src/shims/unix/thread.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fthread.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -42,7 +42,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             throw_unsup_format!(\"Miri supports pthread_join only with retval==NULL\");\n         }\n \n-        let thread_id = this.read_machine_usize(thread)?;\n+        let thread_id = this.read_target_usize(thread)?;\n         this.join_thread_exclusive(thread_id.try_into().expect(\"thread ID should fit in u32\"))?;\n \n         Ok(0)\n@@ -51,7 +51,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn pthread_detach(&mut self, thread: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let thread_id = this.read_machine_usize(thread)?;\n+        let thread_id = this.read_target_usize(thread)?;\n         this.detach_thread(\n             thread_id.try_into().expect(\"thread ID should fit in u32\"),\n             /*allow_terminated_joined*/ false,\n@@ -64,7 +64,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         let thread_id = this.get_active_thread();\n-        Ok(Scalar::from_machine_usize(thread_id.into(), this))\n+        Ok(Scalar::from_target_usize(thread_id.into(), this))\n     }\n \n     /// Set the name of the current thread. `max_name_len` is the maximal length of the name\n@@ -77,7 +77,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n \n-        let thread = ThreadId::try_from(thread.to_machine_usize(this)?).unwrap();\n+        let thread = ThreadId::try_from(thread.to_target_usize(this)?).unwrap();\n         let name = name.to_pointer(this)?;\n \n         let name = this.read_c_str(name)?.to_owned();\n@@ -100,9 +100,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n \n-        let thread = ThreadId::try_from(thread.to_machine_usize(this)?).unwrap();\n+        let thread = ThreadId::try_from(thread.to_target_usize(this)?).unwrap();\n         let name_out = name_out.to_pointer(this)?;\n-        let len = len.to_machine_usize(this)?;\n+        let len = len.to_target_usize(this)?;\n \n         let name = this.get_thread_name(thread).to_owned();\n         let (success, _written) = this.write_c_str(&name, name_out, len)?;"}, {"sha": "60dd299c438130bc8d58a5d97a1cb66801e8632d", "filename": "src/tools/miri/src/shims/windows/dlsym.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fdlsym.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -67,10 +67,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     byte_offset,\n                     _key,\n                 ] = check_arg_count(args)?;\n-                let handle = this.read_machine_isize(handle)?;\n+                let handle = this.read_target_isize(handle)?;\n                 let buf = this.read_pointer(buf)?;\n                 let n = this.read_scalar(n)?.to_u32()?;\n-                let byte_offset = this.read_machine_usize(byte_offset)?; // is actually a pointer\n+                let byte_offset = this.read_target_usize(byte_offset)?; // is actually a pointer\n                 let io_status_block = this.deref_operand(io_status_block)?;\n \n                 if byte_offset != 0 {\n@@ -104,7 +104,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     let io_status_information =\n                         this.mplace_field_named(&io_status_block, \"Information\")?;\n                     this.write_scalar(\n-                        Scalar::from_machine_usize(n.into(), this),\n+                        Scalar::from_target_usize(n.into(), this),\n                         &io_status_information.into(),\n                     )?;\n                 }"}, {"sha": "a3d7176a9768623e9ff8c2f726aab6cc40c8862a", "filename": "src/tools/miri/src/shims/windows/foreign_items.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -73,9 +73,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             \"HeapAlloc\" => {\n                 let [handle, flags, size] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-                this.read_machine_isize(handle)?;\n+                this.read_target_isize(handle)?;\n                 let flags = this.read_scalar(flags)?.to_u32()?;\n-                let size = this.read_machine_usize(size)?;\n+                let size = this.read_target_usize(size)?;\n                 let heap_zero_memory = 0x00000008; // HEAP_ZERO_MEMORY\n                 let zero_init = (flags & heap_zero_memory) == heap_zero_memory;\n                 let res = this.malloc(size, zero_init, MiriMemoryKind::WinHeap)?;\n@@ -84,7 +84,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             \"HeapFree\" => {\n                 let [handle, flags, ptr] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-                this.read_machine_isize(handle)?;\n+                this.read_target_isize(handle)?;\n                 this.read_scalar(flags)?.to_u32()?;\n                 let ptr = this.read_pointer(ptr)?;\n                 this.free(ptr, MiriMemoryKind::WinHeap)?;\n@@ -93,10 +93,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             \"HeapReAlloc\" => {\n                 let [handle, flags, ptr, size] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-                this.read_machine_isize(handle)?;\n+                this.read_target_isize(handle)?;\n                 this.read_scalar(flags)?.to_u32()?;\n                 let ptr = this.read_pointer(ptr)?;\n-                let size = this.read_machine_usize(size)?;\n+                let size = this.read_target_usize(size)?;\n                 let res = this.realloc(ptr, size, MiriMemoryKind::WinHeap)?;\n                 this.write_pointer(res, dest)?;\n             }\n@@ -299,7 +299,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 #[allow(non_snake_case)]\n                 let [hModule, lpProcName] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-                this.read_machine_isize(hModule)?;\n+                this.read_target_isize(hModule)?;\n                 let name = this.read_c_str(this.read_pointer(lpProcName)?)?;\n                 if let Some(dlsym) = Dlsym::from_str(name, &this.tcx.sess.target.os)? {\n                     let ptr = this.create_fn_alloc_ptr(FnVal::Other(dlsym));\n@@ -323,7 +323,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let [algorithm, ptr, len, flags] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let algorithm = this.read_scalar(algorithm)?;\n-                let algorithm = algorithm.to_machine_usize(this)?;\n+                let algorithm = algorithm.to_target_usize(this)?;\n                 let ptr = this.read_pointer(ptr)?;\n                 let len = this.read_scalar(len)?.to_u32()?;\n                 let flags = this.read_scalar(flags)?.to_u32()?;\n@@ -357,7 +357,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // `term` needs this, so we fake it.\n                 let [console, buffer_info] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-                this.read_machine_isize(console)?;\n+                this.read_target_isize(console)?;\n                 this.deref_operand(buffer_info)?;\n                 // Indicate an error.\n                 // FIXME: we should set last_error, but to what?\n@@ -371,7 +371,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // one it is. This is very fake, but libtest needs it so we cannot make it a\n                 // std-only shim.\n                 // FIXME: this should return real HANDLEs when io support is added\n-                this.write_scalar(Scalar::from_machine_isize(which.into(), this), dest)?;\n+                this.write_scalar(Scalar::from_target_isize(which.into(), this), dest)?;\n             }\n             \"CloseHandle\" => {\n                 let [handle] =\n@@ -386,7 +386,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.check_no_isolation(\"`GetModuleFileNameW`\")?;\n \n-                let handle = this.read_machine_usize(handle)?;\n+                let handle = this.read_target_usize(handle)?;\n                 let filename = this.read_pointer(filename)?;\n                 let size = this.read_scalar(size)?.to_u32()?;\n \n@@ -473,7 +473,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             \"GetConsoleMode\" if this.frame_in_std() => {\n                 let [console, mode] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-                this.read_machine_isize(console)?;\n+                this.read_target_isize(console)?;\n                 this.deref_operand(mode)?;\n                 // Indicate an error.\n                 this.write_null(dest)?;"}, {"sha": "8bffa9991c75af7bbb07a8e9bbaf18efecad9d05", "filename": "src/tools/miri/src/shims/windows/handle.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fhandle.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -124,14 +124,14 @@ impl Handle {\n         // see https://docs.microsoft.com/en-us/windows/win32/winprog64/interprocess-communication\n         #[allow(clippy::cast_possible_wrap)] // we want it to wrap\n         let signed_handle = self.to_packed() as i32;\n-        Scalar::from_machine_isize(signed_handle.into(), cx)\n+        Scalar::from_target_isize(signed_handle.into(), cx)\n     }\n \n     pub fn from_scalar<'tcx>(\n         handle: Scalar<Provenance>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Option<Self>> {\n-        let sign_extended_handle = handle.to_machine_isize(cx)?;\n+        let sign_extended_handle = handle.to_target_isize(cx)?;\n \n         #[allow(clippy::cast_sign_loss)] // we want to lose the sign\n         let handle = if let Ok(signed_handle) = i32::try_from(sign_extended_handle) {"}, {"sha": "b9cc3e15be9fe3135eb57a2d4cc6511925c77bd4", "filename": "src/tools/miri/src/shims/windows/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -273,7 +273,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         let ptr = this.read_pointer(ptr_op)?;\n         let compare = this.read_pointer(compare_op)?;\n-        let size = this.read_machine_usize(size_op)?;\n+        let size = this.read_target_usize(size_op)?;\n         let timeout_ms = this.read_scalar(timeout_op)?.to_u32()?;\n \n         let thread = this.get_active_thread();"}, {"sha": "9cbae1588598507ac5741edcf36dea2d0a1a59fd", "filename": "src/tools/miri/src/shims/windows/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fthread.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -21,7 +21,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         let security = this.read_pointer(security_op)?;\n         // stacksize is ignored, but still needs to be a valid usize\n-        this.read_machine_usize(stacksize_op)?;\n+        this.read_target_usize(stacksize_op)?;\n         let start_routine = this.read_pointer(start_op)?;\n         let func_arg = this.read_immediate(arg_op)?;\n         let flags = this.read_scalar(flags_op)?.to_u32()?;"}, {"sha": "84a42ca36ef1c3c48692b93444dcf46f0d0897fc", "filename": "src/tools/x/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fx%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fx%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fx%2FCargo.toml?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"x\"\n-version = \"0.1.0\"\n+version = \"0.1.1\"\n description = \"Run x.py slightly more conveniently\"\n edition = \"2021\"\n publish = false"}, {"sha": "5da8a2888ec8385c6c6ab54a0189a787182e72c5", "filename": "src/tools/x/src/main.rs", "status": "modified", "additions": 59, "deletions": 15, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fx%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/src%2Ftools%2Fx%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fx%2Fsrc%2Fmain.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -9,11 +9,47 @@\n //! We also don't use `pwsh` on Windows, because it is not installed by default;\n \n use std::{\n-    env, io,\n+    env::{self, consts::EXE_EXTENSION},\n+    io,\n     path::Path,\n     process::{self, Command, ExitStatus},\n };\n \n+const PYTHON: &str = \"python\";\n+const PYTHON2: &str = \"python2\";\n+const PYTHON3: &str = \"python3\";\n+\n+fn python() -> &'static str {\n+    let val = match env::var_os(\"PATH\") {\n+        Some(val) => val,\n+        None => return PYTHON,\n+    };\n+\n+    let mut python2 = false;\n+    let mut python3 = false;\n+\n+    for dir in env::split_paths(&val) {\n+        // `python` should always take precedence over python2 / python3 if it exists\n+        if dir.join(PYTHON).with_extension(EXE_EXTENSION).exists() {\n+            return PYTHON;\n+        }\n+\n+        python2 |= dir.join(PYTHON2).with_extension(EXE_EXTENSION).exists();\n+        python3 |= dir.join(PYTHON3).with_extension(EXE_EXTENSION).exists();\n+    }\n+\n+    // try 3 before 2\n+    if python3 {\n+        PYTHON3\n+    } else if python2 {\n+        PYTHON2\n+    } else {\n+        // Python was not found on path, so exit\n+        eprintln!(\"Unable to find python in your PATH. Please check it is installed.\");\n+        process::exit(1);\n+    }\n+}\n+\n #[cfg(windows)]\n fn x_command(dir: &Path) -> Command {\n     let mut cmd = Command::new(\"powershell.exe\");\n@@ -51,6 +87,17 @@ fn exec_or_status(command: &mut Command) -> io::Result<ExitStatus> {\n     command.status()\n }\n \n+fn handle_result(result: io::Result<ExitStatus>, cmd: Command) {\n+    match result {\n+        Err(error) => {\n+            eprintln!(\"Failed to invoke `{:?}`: {}\", cmd, error);\n+        }\n+        Ok(status) => {\n+            process::exit(status.code().unwrap_or(1));\n+        }\n+    }\n+}\n+\n fn main() {\n     match env::args().skip(1).next().as_deref() {\n         Some(\"--wrapper-version\") => {\n@@ -70,22 +117,19 @@ fn main() {\n \n     for dir in current.ancestors() {\n         let candidate = dir.join(\"x.py\");\n-\n         if candidate.exists() {\n-            let mut cmd = x_command(dir);\n-\n-            cmd.args(env::args().skip(1)).current_dir(dir);\n-\n-            let result = exec_or_status(&mut cmd);\n-\n-            match result {\n-                Err(error) => {\n-                    eprintln!(\"Failed to invoke `{:?}`: {}\", cmd, error);\n-                }\n-                Ok(status) => {\n-                    process::exit(status.code().unwrap_or(1));\n-                }\n+            let shell_script_candidate = dir.join(\"x\");\n+            let mut cmd: Command;\n+            if shell_script_candidate.exists() {\n+                cmd = x_command(dir);\n+                cmd.args(env::args().skip(1)).current_dir(dir);\n+            } else {\n+                // For older checkouts that do not have the x shell script, default to python\n+                cmd = Command::new(python());\n+                cmd.arg(&candidate).args(env::args().skip(1)).current_dir(dir);\n             }\n+            let result = exec_or_status(&mut cmd);\n+            handle_result(result, cmd);\n         }\n     }\n "}, {"sha": "08570d4a5d982e65ff4d362fac7cfcfc65d49796", "filename": "tests/ui/associated-consts/issue-105330.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fassociated-consts%2Fissue-105330.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fassociated-consts%2Fissue-105330.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-consts%2Fissue-105330.stderr?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -33,7 +33,7 @@ LL | fn main<A: TraitWAssocConst<A=32>>() {\n    = note: see issue #92827 <https://github.com/rust-lang/rust/issues/92827> for more information\n    = help: add `#![feature(associated_const_equality)]` to the crate attributes to enable\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in impl header\n   --> $DIR/issue-105330.rs:6:27\n    |\n LL | impl TraitWAssocConst for impl Demo {"}, {"sha": "b74b5e94e2b751ae00a03c7abedad480802cd9d8", "filename": "tests/ui/closures/2229_closure_analysis/migrations/auto_traits.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.fixed?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -26,7 +26,7 @@ fn test_send_trait() {\n         //~| HELP: add a dummy let to cause `fptr` to be fully captured\n         *fptr.0 = 20;\n         //~^ NOTE: in Rust 2018, this closure captures all of `fptr`, but in Rust 2021, it will only capture `fptr.0`\n-    } });\n+    } }).join().unwrap();\n }\n \n /* Test Sync Trait Migration */\n@@ -47,7 +47,7 @@ fn test_sync_trait() {\n         //~| HELP: add a dummy let to cause `fptr` to be fully captured\n         *fptr.0.0 = 20;\n         //~^ NOTE: in Rust 2018, this closure captures all of `fptr`, but in Rust 2021, it will only capture `fptr.0.0`\n-    } });\n+    } }).join().unwrap();\n }\n \n /* Test Clone Trait Migration */"}, {"sha": "e4965e33cc16fce2f117efe56ae8549063d29bf7", "filename": "tests/ui/closures/2229_closure_analysis/migrations/auto_traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -26,7 +26,7 @@ fn test_send_trait() {\n         //~| HELP: add a dummy let to cause `fptr` to be fully captured\n         *fptr.0 = 20;\n         //~^ NOTE: in Rust 2018, this closure captures all of `fptr`, but in Rust 2021, it will only capture `fptr.0`\n-    });\n+    }).join().unwrap();\n }\n \n /* Test Sync Trait Migration */\n@@ -47,7 +47,7 @@ fn test_sync_trait() {\n         //~| HELP: add a dummy let to cause `fptr` to be fully captured\n         *fptr.0.0 = 20;\n         //~^ NOTE: in Rust 2018, this closure captures all of `fptr`, but in Rust 2021, it will only capture `fptr.0.0`\n-    });\n+    }).join().unwrap();\n }\n \n /* Test Clone Trait Migration */"}, {"sha": "856ec4a5b9eb3fa7007409608e3640b642c65152", "filename": "tests/ui/closures/2229_closure_analysis/migrations/auto_traits.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.stderr?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -19,7 +19,7 @@ LL ~     thread::spawn(move || { let _ = &fptr; unsafe {\n LL |\n  ...\n LL |\n-LL ~     } });\n+LL ~     } }).join().unwrap();\n    |\n \n error: changes to closure capture in Rust 2021 will affect which traits the closure implements\n@@ -41,7 +41,7 @@ LL ~     thread::spawn(move || { let _ = &fptr; unsafe {\n LL |\n  ...\n LL |\n-LL ~     } });\n+LL ~     } }).join().unwrap();\n    |\n \n error: changes to closure capture in Rust 2021 will affect drop order and which traits the closure implements"}, {"sha": "bde8c7497310d76149bd2c341caca5771d7feae8", "filename": "tests/ui/closures/2229_closure_analysis/migrations/multi_diagnostics.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.fixed?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -145,7 +145,7 @@ fn test_multi_traits_issues() {\n         //~^ NOTE: in Rust 2018, this closure captures all of `fptr1`, but in Rust 2021, it will only capture `fptr1.0.0`\n         *fptr2.0 = 20;\n         //~^ NOTE: in Rust 2018, this closure captures all of `fptr2`, but in Rust 2021, it will only capture `fptr2.0`\n-    } });\n+    } }).join().unwrap();\n }\n \n fn main() {"}, {"sha": "584c52ea134303adecd8b6e7eba7cc4ff597125e", "filename": "tests/ui/closures/2229_closure_analysis/migrations/multi_diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -141,7 +141,7 @@ fn test_multi_traits_issues() {\n         //~^ NOTE: in Rust 2018, this closure captures all of `fptr1`, but in Rust 2021, it will only capture `fptr1.0.0`\n         *fptr2.0 = 20;\n         //~^ NOTE: in Rust 2018, this closure captures all of `fptr2`, but in Rust 2021, it will only capture `fptr2.0`\n-    });\n+    }).join().unwrap();\n }\n \n fn main() {"}, {"sha": "344bc662ee73feddf4236ba7c82f89658db804ae", "filename": "tests/ui/closures/2229_closure_analysis/migrations/multi_diagnostics.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.stderr?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -111,7 +111,7 @@ LL ~     thread::spawn(move || { let _ = (&fptr1, &fptr2); unsafe {\n LL |\n  ...\n LL |\n-LL ~     } });\n+LL ~     } }).join().unwrap();\n    |\n \n error: aborting due to 5 previous errors"}, {"sha": "c9aaa6e558747f482244580b1136fcd971fdc6c6", "filename": "tests/ui/consts/const-eval/issue-91827-extern-types.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fconsts%2Fconst-eval%2Fissue-91827-extern-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fconsts%2Fconst-eval%2Fissue-91827-extern-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fissue-91827-extern-types.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -28,7 +28,10 @@ pub struct ListImpl<T, const N: usize> {\n \n impl<T> List<T> {\n     const fn as_slice(&self) -> &[T] {\n-        unsafe { std::slice::from_raw_parts(self.data.as_ptr(), self.len) }\n+        unsafe {\n+            let ptr = addr_of!(self.tail) as *const T;\n+            std::slice::from_raw_parts(ptr, self.len)\n+        }\n     }\n }\n "}, {"sha": "6f2919b6c0909a2627721a805c5d3b8a85dbb4ba", "filename": "tests/ui/feature-gates/feature-gate-associated_type_bounds.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.stderr?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -115,13 +115,13 @@ LL |     let _: impl Tr1<As1: Copy> = S1;\n    = note: see issue #52662 <https://github.com/rust-lang/rust/issues/52662> for more information\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in const type\n   --> $DIR/feature-gate-associated_type_bounds.rs:58:14\n    |\n LL | const _cdef: impl Tr1<As1: Copy> = S1;\n    |              ^^^^^^^^^^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in const type\n   --> $DIR/feature-gate-associated_type_bounds.rs:64:15\n    |\n LL | static _sdef: impl Tr1<As1: Copy> = S1;"}, {"sha": "f591c07bcf5f48f723c9fcd7af5fec630740680a", "filename": "tests/ui/impl-trait/issues/issue-58956.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fimpl-trait%2Fissues%2Fissue-58956.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fimpl-trait%2Fissues%2Fissue-58956.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fissues%2Fissue-58956.stderr?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,4 +1,4 @@\n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in const type\n   --> $DIR/issue-58956.rs:7:11\n    |\n LL | const _A: impl Lam = {"}, {"sha": "a227f0ba7d135416bb3749009a2aa8c79ea493ae", "filename": "tests/ui/impl-trait/issues/issue-83929-impl-trait-in-generic-default.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fimpl-trait%2Fissues%2Fissue-83929-impl-trait-in-generic-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fimpl-trait%2Fissues%2Fissue-83929-impl-trait-in-generic-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fissues%2Fissue-83929-impl-trait-in-generic-default.stderr?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,10 +1,10 @@\n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in generic parameter default\n   --> $DIR/issue-83929-impl-trait-in-generic-default.rs:1:16\n    |\n LL | struct Foo<T = impl Copy>(T);\n    |                ^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in generic parameter default\n   --> $DIR/issue-83929-impl-trait-in-generic-default.rs:4:20\n    |\n LL | type Result<T, E = impl std::error::Error> = std::result::Result<T, E>;"}, {"sha": "a137777840b31d8163e2766446465cd048e4a6c2", "filename": "tests/ui/impl-trait/issues/issue-86642.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fimpl-trait%2Fissues%2Fissue-86642.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fimpl-trait%2Fissues%2Fissue-86642.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fissues%2Fissue-86642.stderr?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,4 +1,4 @@\n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in const type\n   --> $DIR/issue-86642.rs:1:11\n    |\n LL | static x: impl Fn(&str) -> Result<&str, ()> = move |source| {"}, {"sha": "201aba3adff969cb43bf8034c31de0c083a724ab", "filename": "tests/ui/impl-trait/where-allowed.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fimpl-trait%2Fwhere-allowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fimpl-trait%2Fwhere-allowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fwhere-allowed.stderr?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -115,31 +115,31 @@ error[E0562]: `impl Trait` only allowed in function and inherent method return t\n LL | fn in_Fn_return_in_generics<F: Fn() -> impl Debug> (_: F) { panic!() }\n    |                                        ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in field type\n   --> $DIR/where-allowed.rs:81:32\n    |\n LL | struct InBraceStructField { x: impl Debug }\n    |                                ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in path\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in field type\n   --> $DIR/where-allowed.rs:85:41\n    |\n LL | struct InAdtInBraceStructField { x: Vec<impl Debug> }\n    |                                         ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in field type\n   --> $DIR/where-allowed.rs:89:27\n    |\n LL | struct InTupleStructField(impl Debug);\n    |                           ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in field type\n   --> $DIR/where-allowed.rs:94:25\n    |\n LL |     InBraceVariant { x: impl Debug },\n    |                         ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in field type\n   --> $DIR/where-allowed.rs:96:20\n    |\n LL |     InTupleVariant(impl Debug),\n@@ -187,31 +187,31 @@ error[E0562]: `impl Trait` only allowed in function and inherent method return t\n LL | impl PartialEq<impl Debug> for () {\n    |                ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in impl header\n   --> $DIR/where-allowed.rs:166:24\n    |\n LL | impl PartialEq<()> for impl Debug {\n    |                        ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in impl header\n   --> $DIR/where-allowed.rs:171:6\n    |\n LL | impl impl Debug {\n    |      ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in impl header\n   --> $DIR/where-allowed.rs:177:24\n    |\n LL | impl InInherentImplAdt<impl Debug> {\n    |                        ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in bound\n   --> $DIR/where-allowed.rs:183:11\n    |\n LL |     where impl Debug: Debug\n    |           ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in bound\n   --> $DIR/where-allowed.rs:190:15\n    |\n LL |     where Vec<impl Debug>: Debug\n@@ -235,37 +235,37 @@ error[E0562]: `impl Trait` only allowed in function and inherent method return t\n LL |     where T: Fn() -> impl Debug\n    |                      ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in generic parameter default\n   --> $DIR/where-allowed.rs:217:40\n    |\n LL | struct InStructGenericParamDefault<T = impl Debug>(T);\n    |                                        ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in generic parameter default\n   --> $DIR/where-allowed.rs:221:36\n    |\n LL | enum InEnumGenericParamDefault<T = impl Debug> { Variant(T) }\n    |                                    ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in generic parameter default\n   --> $DIR/where-allowed.rs:225:38\n    |\n LL | trait InTraitGenericParamDefault<T = impl Debug> {}\n    |                                      ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in generic parameter default\n   --> $DIR/where-allowed.rs:229:41\n    |\n LL | type InTypeAliasGenericParamDefault<T = impl Debug> = T;\n    |                                         ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in generic parameter default\n   --> $DIR/where-allowed.rs:233:11\n    |\n LL | impl <T = impl Debug> T {}\n    |           ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in generic parameter default\n   --> $DIR/where-allowed.rs:240:40\n    |\n LL | fn in_method_generic_param_default<T = impl Debug>(_: T) {}"}, {"sha": "ae7ef47e1d4deaa24980d60beb99dcbf5ed38906", "filename": "tests/ui/suggestions/trait-hidden-method.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsuggestions%2Ftrait-hidden-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsuggestions%2Ftrait-hidden-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftrait-hidden-method.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -0,0 +1,11 @@\n+// #107983 - testing that `__iterator_get_unchecked` isn't suggested\n+// HELP included so that compiletest errors on the bad suggestion\n+pub fn i_can_has_iterator() -> impl Iterator<Item = u32> {\n+    //~^ ERROR expected `Box<dyn Iterator>`\n+    //~| HELP consider constraining the associated type\n+    Box::new(1..=10) as Box<dyn Iterator>\n+    //~^ ERROR the value of the associated type `Item`\n+    //~| HELP specify the associated type\n+}\n+\n+fn main() {}"}, {"sha": "a5a65d193db062691dd50c431df6667f96b4a39c", "filename": "tests/ui/suggestions/trait-hidden-method.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsuggestions%2Ftrait-hidden-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsuggestions%2Ftrait-hidden-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftrait-hidden-method.stderr?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -0,0 +1,24 @@\n+error[E0191]: the value of the associated type `Item` (from trait `Iterator`) must be specified\n+  --> $DIR/trait-hidden-method.rs:6:33\n+   |\n+LL |     Box::new(1..=10) as Box<dyn Iterator>\n+   |                                 ^^^^^^^^ help: specify the associated type: `Iterator<Item = Type>`\n+\n+error[E0271]: expected `Box<dyn Iterator>` to be an iterator that yields `u32`, but it yields `<dyn Iterator as Iterator>::Item`\n+  --> $DIR/trait-hidden-method.rs:3:32\n+   |\n+LL | pub fn i_can_has_iterator() -> impl Iterator<Item = u32> {\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^ expected associated type, found `u32`\n+...\n+LL |     Box::new(1..=10) as Box<dyn Iterator>\n+   |     ------------------------------------- return type was inferred to be `Box<dyn Iterator>` here\n+   |\n+   = note: expected associated type `<dyn Iterator as Iterator>::Item`\n+                         found type `u32`\n+   = help: consider constraining the associated type `<dyn Iterator as Iterator>::Item` to `u32` or calling a method that returns `<dyn Iterator as Iterator>::Item`\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0191, E0271.\n+For more information about an error, try `rustc --explain E0191`."}, {"sha": "a3f92be6cf61fccbb4c549cdd76c0223dc31f135", "filename": "tests/ui/unsized/unsized3-rpass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Funsized%2Funsized3-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Funsized%2Funsized3-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funsized%2Funsized3-rpass.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -59,7 +59,7 @@ pub fn main() {\n         }\n \n         let data: Box<Foo_<i32>> = Box::new(Foo_ { f: [1, 2, 3] });\n-        let x: &Foo<i32> = mem::transmute(slice::from_raw_parts(&*data, 3));\n+        let x: &Foo<i32> = mem::transmute(ptr::slice_from_raw_parts(&*data, 3));\n         assert_eq!(x.f.len(), 3);\n         assert_eq!(x.f[0], 1);\n \n@@ -70,7 +70,7 @@ pub fn main() {\n \n         let data: Box<_> =\n             Box::new(Baz_ { f1: 42, f2: ['a' as u8, 'b' as u8, 'c' as u8, 'd' as u8, 'e' as u8] });\n-        let x: &Baz = mem::transmute(slice::from_raw_parts(&*data, 5));\n+        let x: &Baz = mem::transmute(ptr::slice_from_raw_parts(&*data, 5));\n         assert_eq!(x.f1, 42);\n         let chs: Vec<char> = x.f2.chars().collect();\n         assert_eq!(chs.len(), 5);"}]}