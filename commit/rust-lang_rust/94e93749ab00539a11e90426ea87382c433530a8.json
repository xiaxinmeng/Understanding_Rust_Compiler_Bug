{"sha": "94e93749ab00539a11e90426ea87382c433530a8", "node_id": "C_kwDOAAsO6NoAKDk0ZTkzNzQ5YWIwMDUzOWExMWU5MDQyNmVhODczODJjNDMzNTMwYTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-28T16:10:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-28T16:10:30Z"}, "message": "Auto merge of #98188 - mystor:fast_group_punct, r=eddyb\n\nproc_macro/bridge: stop using a remote object handle for proc_macro Punct and Group\n\nThis is the third part of https://github.com/rust-lang/rust/pull/86822, split off as requested in https://github.com/rust-lang/rust/pull/86822#pullrequestreview-1008655452. This patch transforms the `Punct` and `Group` types into structs serialized over IPC rather than handles, making them more efficient to create and manipulate from within proc-macros.", "tree": {"sha": "178939ed78998026622554acc730248d61f3f1d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/178939ed78998026622554acc730248d61f3f1d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94e93749ab00539a11e90426ea87382c433530a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94e93749ab00539a11e90426ea87382c433530a8", "html_url": "https://github.com/rust-lang/rust/commit/94e93749ab00539a11e90426ea87382c433530a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94e93749ab00539a11e90426ea87382c433530a8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "html_url": "https://github.com/rust-lang/rust/commit/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e"}, {"sha": "64a7d57046bc4653dddb346b51cd66a8980f3533", "url": "https://api.github.com/repos/rust-lang/rust/commits/64a7d57046bc4653dddb346b51cd66a8980f3533", "html_url": "https://github.com/rust-lang/rust/commit/64a7d57046bc4653dddb346b51cd66a8980f3533"}], "stats": {"total": 613, "additions": 259, "deletions": 354}, "files": [{"sha": "0e909e2f98270f9635832e5f67f821cfe769c52a", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 174, "deletions": 281, "changes": 455, "blob_url": "https://github.com/rust-lang/rust/blob/94e93749ab00539a11e90426ea87382c433530a8/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94e93749ab00539a11e90426ea87382c433530a8/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=94e93749ab00539a11e90426ea87382c433530a8", "patch": "@@ -2,7 +2,7 @@ use crate::base::ExtCtxt;\n \n use rustc_ast as ast;\n use rustc_ast::token;\n-use rustc_ast::tokenstream::{self, DelimSpan, Spacing::*, TokenStream, TreeAndSpacing};\n+use rustc_ast::tokenstream::{self, Spacing::*, TokenStream};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n@@ -14,8 +14,8 @@ use rustc_span::def_id::CrateNum;\n use rustc_span::symbol::{self, kw, sym, Symbol};\n use rustc_span::{BytePos, FileName, Pos, SourceFile, Span};\n \n-use pm::bridge::{server, ExpnGlobals, TokenTree};\n-use pm::{Delimiter, Level, LineColumn, Spacing};\n+use pm::bridge::{server, DelimSpan, ExpnGlobals, Group, Punct, TokenTree};\n+use pm::{Delimiter, Level, LineColumn};\n use std::ops::Bound;\n use std::{ascii, panic};\n \n@@ -49,158 +49,170 @@ impl ToInternal<token::Delimiter> for Delimiter {\n     }\n }\n \n-impl FromInternal<(TreeAndSpacing, &'_ mut Vec<Self>, &mut Rustc<'_, '_>)>\n-    for TokenTree<Group, Punct, Ident, Literal>\n+impl FromInternal<(TokenStream, &mut Rustc<'_, '_>)>\n+    for Vec<TokenTree<TokenStream, Span, Ident, Literal>>\n {\n-    fn from_internal(\n-        ((tree, spacing), stack, rustc): (TreeAndSpacing, &mut Vec<Self>, &mut Rustc<'_, '_>),\n-    ) -> Self {\n+    fn from_internal((stream, rustc): (TokenStream, &mut Rustc<'_, '_>)) -> Self {\n         use rustc_ast::token::*;\n \n-        let joint = spacing == Joint;\n-        let Token { kind, span } = match tree {\n-            tokenstream::TokenTree::Delimited(span, delim, tts) => {\n-                let delimiter = pm::Delimiter::from_internal(delim);\n-                return TokenTree::Group(Group { delimiter, stream: tts, span, flatten: false });\n-            }\n-            tokenstream::TokenTree::Token(token) => token,\n-        };\n+        // Estimate the capacity as `stream.len()` rounded up to the next power\n+        // of two to limit the number of required reallocations.\n+        let mut trees = Vec::with_capacity(stream.len().next_power_of_two());\n+        let mut cursor = stream.into_trees();\n \n-        macro_rules! tt {\n-            ($ty:ident { $($field:ident $(: $value:expr)*),+ $(,)? }) => (\n-                TokenTree::$ty(self::$ty {\n-                    $($field $(: $value)*,)+\n-                    span,\n-                })\n-            );\n-            ($ty:ident::$method:ident($($value:expr),*)) => (\n-                TokenTree::$ty(self::$ty::$method($($value,)* span))\n-            );\n-        }\n-        macro_rules! op {\n-            ($a:expr) => {\n-                tt!(Punct::new($a, joint))\n+        while let Some((tree, spacing)) = cursor.next_with_spacing() {\n+            let joint = spacing == Joint;\n+            let Token { kind, span } = match tree {\n+                tokenstream::TokenTree::Delimited(span, delim, tts) => {\n+                    let delimiter = pm::Delimiter::from_internal(delim);\n+                    trees.push(TokenTree::Group(Group {\n+                        delimiter,\n+                        stream: Some(tts),\n+                        span: DelimSpan {\n+                            open: span.open,\n+                            close: span.close,\n+                            entire: span.entire(),\n+                        },\n+                    }));\n+                    continue;\n+                }\n+                tokenstream::TokenTree::Token(token) => token,\n             };\n-            ($a:expr, $b:expr) => {{\n-                stack.push(tt!(Punct::new($b, joint)));\n-                tt!(Punct::new($a, true))\n-            }};\n-            ($a:expr, $b:expr, $c:expr) => {{\n-                stack.push(tt!(Punct::new($c, joint)));\n-                stack.push(tt!(Punct::new($b, true)));\n-                tt!(Punct::new($a, true))\n-            }};\n-        }\n \n-        match kind {\n-            Eq => op!('='),\n-            Lt => op!('<'),\n-            Le => op!('<', '='),\n-            EqEq => op!('=', '='),\n-            Ne => op!('!', '='),\n-            Ge => op!('>', '='),\n-            Gt => op!('>'),\n-            AndAnd => op!('&', '&'),\n-            OrOr => op!('|', '|'),\n-            Not => op!('!'),\n-            Tilde => op!('~'),\n-            BinOp(Plus) => op!('+'),\n-            BinOp(Minus) => op!('-'),\n-            BinOp(Star) => op!('*'),\n-            BinOp(Slash) => op!('/'),\n-            BinOp(Percent) => op!('%'),\n-            BinOp(Caret) => op!('^'),\n-            BinOp(And) => op!('&'),\n-            BinOp(Or) => op!('|'),\n-            BinOp(Shl) => op!('<', '<'),\n-            BinOp(Shr) => op!('>', '>'),\n-            BinOpEq(Plus) => op!('+', '='),\n-            BinOpEq(Minus) => op!('-', '='),\n-            BinOpEq(Star) => op!('*', '='),\n-            BinOpEq(Slash) => op!('/', '='),\n-            BinOpEq(Percent) => op!('%', '='),\n-            BinOpEq(Caret) => op!('^', '='),\n-            BinOpEq(And) => op!('&', '='),\n-            BinOpEq(Or) => op!('|', '='),\n-            BinOpEq(Shl) => op!('<', '<', '='),\n-            BinOpEq(Shr) => op!('>', '>', '='),\n-            At => op!('@'),\n-            Dot => op!('.'),\n-            DotDot => op!('.', '.'),\n-            DotDotDot => op!('.', '.', '.'),\n-            DotDotEq => op!('.', '.', '='),\n-            Comma => op!(','),\n-            Semi => op!(';'),\n-            Colon => op!(':'),\n-            ModSep => op!(':', ':'),\n-            RArrow => op!('-', '>'),\n-            LArrow => op!('<', '-'),\n-            FatArrow => op!('=', '>'),\n-            Pound => op!('#'),\n-            Dollar => op!('$'),\n-            Question => op!('?'),\n-            SingleQuote => op!('\\''),\n-\n-            Ident(name, false) if name == kw::DollarCrate => tt!(Ident::dollar_crate()),\n-            Ident(name, is_raw) => tt!(Ident::new(rustc.sess(), name, is_raw)),\n-            Lifetime(name) => {\n-                let ident = symbol::Ident::new(name, span).without_first_quote();\n-                stack.push(tt!(Ident::new(rustc.sess(), ident.name, false)));\n-                tt!(Punct::new('\\'', true))\n-            }\n-            Literal(lit) => tt!(Literal { lit }),\n-            DocComment(_, attr_style, data) => {\n-                let mut escaped = String::new();\n-                for ch in data.as_str().chars() {\n-                    escaped.extend(ch.escape_debug());\n-                }\n-                let stream = [\n-                    Ident(sym::doc, false),\n-                    Eq,\n-                    TokenKind::lit(token::Str, Symbol::intern(&escaped), None),\n-                ]\n-                .into_iter()\n-                .map(|kind| tokenstream::TokenTree::token(kind, span))\n-                .collect();\n-                stack.push(TokenTree::Group(Group {\n-                    delimiter: pm::Delimiter::Bracket,\n-                    stream,\n-                    span: DelimSpan::from_single(span),\n-                    flatten: false,\n+            let mut op = |s: &str| {\n+                assert!(s.is_ascii());\n+                trees.extend(s.as_bytes().iter().enumerate().map(|(idx, &ch)| {\n+                    TokenTree::Punct(Punct { ch, joint: joint || idx != s.len() - 1, span })\n                 }));\n-                if attr_style == ast::AttrStyle::Inner {\n-                    stack.push(tt!(Punct::new('!', false)));\n+            };\n+\n+            match kind {\n+                Eq => op(\"=\"),\n+                Lt => op(\"<\"),\n+                Le => op(\"<=\"),\n+                EqEq => op(\"==\"),\n+                Ne => op(\"!=\"),\n+                Ge => op(\">=\"),\n+                Gt => op(\">\"),\n+                AndAnd => op(\"&&\"),\n+                OrOr => op(\"||\"),\n+                Not => op(\"!\"),\n+                Tilde => op(\"~\"),\n+                BinOp(Plus) => op(\"+\"),\n+                BinOp(Minus) => op(\"-\"),\n+                BinOp(Star) => op(\"*\"),\n+                BinOp(Slash) => op(\"/\"),\n+                BinOp(Percent) => op(\"%\"),\n+                BinOp(Caret) => op(\"^\"),\n+                BinOp(And) => op(\"&\"),\n+                BinOp(Or) => op(\"|\"),\n+                BinOp(Shl) => op(\"<<\"),\n+                BinOp(Shr) => op(\">>\"),\n+                BinOpEq(Plus) => op(\"+=\"),\n+                BinOpEq(Minus) => op(\"-=\"),\n+                BinOpEq(Star) => op(\"*=\"),\n+                BinOpEq(Slash) => op(\"/=\"),\n+                BinOpEq(Percent) => op(\"%=\"),\n+                BinOpEq(Caret) => op(\"^=\"),\n+                BinOpEq(And) => op(\"&=\"),\n+                BinOpEq(Or) => op(\"|=\"),\n+                BinOpEq(Shl) => op(\"<<=\"),\n+                BinOpEq(Shr) => op(\">>=\"),\n+                At => op(\"@\"),\n+                Dot => op(\".\"),\n+                DotDot => op(\"..\"),\n+                DotDotDot => op(\"...\"),\n+                DotDotEq => op(\"..=\"),\n+                Comma => op(\",\"),\n+                Semi => op(\";\"),\n+                Colon => op(\":\"),\n+                ModSep => op(\"::\"),\n+                RArrow => op(\"->\"),\n+                LArrow => op(\"<-\"),\n+                FatArrow => op(\"=>\"),\n+                Pound => op(\"#\"),\n+                Dollar => op(\"$\"),\n+                Question => op(\"?\"),\n+                SingleQuote => op(\"'\"),\n+\n+                Ident(name, false) if name == kw::DollarCrate => trees.push(TokenTree::Ident(Ident::dollar_crate(span))),\n+                Ident(name, is_raw) => trees.push(TokenTree::Ident(Ident::new(rustc.sess(), name, is_raw, span))),\n+                Lifetime(name) => {\n+                    let ident = symbol::Ident::new(name, span).without_first_quote();\n+                    trees.extend([\n+                        TokenTree::Punct(Punct { ch: b'\\'', joint: true, span }),\n+                        TokenTree::Ident(Ident::new(rustc.sess(), ident.name, false, span)),\n+                    ]);\n+                }\n+                Literal(lit) => trees.push(TokenTree::Literal(self::Literal { lit, span })),\n+                DocComment(_, attr_style, data) => {\n+                    let mut escaped = String::new();\n+                    for ch in data.as_str().chars() {\n+                        escaped.extend(ch.escape_debug());\n+                    }\n+                    let stream = [\n+                        Ident(sym::doc, false),\n+                        Eq,\n+                        TokenKind::lit(token::Str, Symbol::intern(&escaped), None),\n+                    ]\n+                    .into_iter()\n+                    .map(|kind| tokenstream::TokenTree::token(kind, span))\n+                    .collect();\n+                    trees.push(TokenTree::Punct(Punct { ch: b'#', joint: false, span }));\n+                    if attr_style == ast::AttrStyle::Inner {\n+                        trees.push(TokenTree::Punct(Punct { ch: b'!', joint: false, span }));\n+                    }\n+                    trees.push(TokenTree::Group(Group {\n+                        delimiter: pm::Delimiter::Bracket,\n+                        stream: Some(stream),\n+                        span: DelimSpan::from_single(span),\n+                    }));\n                 }\n-                tt!(Punct::new('#', false))\n-            }\n \n-            Interpolated(nt) if let NtIdent(ident, is_raw) = *nt => {\n-                TokenTree::Ident(Ident::new(rustc.sess(), ident.name, is_raw, ident.span))\n-            }\n-            Interpolated(nt) => {\n-                TokenTree::Group(Group {\n-                    delimiter: pm::Delimiter::None,\n-                    stream: TokenStream::from_nonterminal_ast(&nt),\n-                    span: DelimSpan::from_single(span),\n-                    flatten: crate::base::nt_pretty_printing_compatibility_hack(&nt, rustc.sess()),\n-                })\n-            }\n+                Interpolated(nt) if let NtIdent(ident, is_raw) = *nt => {\n+                    trees.push(TokenTree::Ident(Ident::new(rustc.sess(), ident.name, is_raw, ident.span)))\n+                }\n+\n+                Interpolated(nt) => {\n+                    let stream = TokenStream::from_nonterminal_ast(&nt);\n+                    // A hack used to pass AST fragments to attribute and derive\n+                    // macros as a single nonterminal token instead of a token\n+                    // stream.  Such token needs to be \"unwrapped\" and not\n+                    // represented as a delimited group.\n+                    // FIXME: It needs to be removed, but there are some\n+                    // compatibility issues (see #73345).\n+                    if crate::base::nt_pretty_printing_compatibility_hack(&nt, rustc.sess()) {\n+                        trees.extend(Self::from_internal((stream, rustc)));\n+                    } else {\n+                        trees.push(TokenTree::Group(Group {\n+                            delimiter: pm::Delimiter::None,\n+                            stream: Some(stream),\n+                            span: DelimSpan::from_single(span),\n+                        }))\n+                    }\n+                }\n \n-            OpenDelim(..) | CloseDelim(..) => unreachable!(),\n-            Eof => unreachable!(),\n+                OpenDelim(..) | CloseDelim(..) => unreachable!(),\n+                Eof => unreachable!(),\n+            }\n         }\n+        trees\n     }\n }\n \n-impl ToInternal<TokenStream> for TokenTree<Group, Punct, Ident, Literal> {\n+impl ToInternal<TokenStream> for TokenTree<TokenStream, Span, Ident, Literal> {\n     fn to_internal(self) -> TokenStream {\n         use rustc_ast::token::*;\n \n         let (ch, joint, span) = match self {\n             TokenTree::Punct(Punct { ch, joint, span }) => (ch, joint, span),\n-            TokenTree::Group(Group { delimiter, stream, span, .. }) => {\n-                return tokenstream::TokenTree::Delimited(span, delimiter.to_internal(), stream)\n-                    .into();\n+            TokenTree::Group(Group { delimiter, stream, span: DelimSpan { open, close, .. } }) => {\n+                return tokenstream::TokenTree::Delimited(\n+                    tokenstream::DelimSpan { open, close },\n+                    delimiter.to_internal(),\n+                    stream.unwrap_or_default(),\n+                )\n+                .into();\n             }\n             TokenTree::Ident(self::Ident { sym, is_raw, span }) => {\n                 return tokenstream::TokenTree::token(Ident(sym, is_raw), span).into();\n@@ -233,28 +245,28 @@ impl ToInternal<TokenStream> for TokenTree<Group, Punct, Ident, Literal> {\n         };\n \n         let kind = match ch {\n-            '=' => Eq,\n-            '<' => Lt,\n-            '>' => Gt,\n-            '!' => Not,\n-            '~' => Tilde,\n-            '+' => BinOp(Plus),\n-            '-' => BinOp(Minus),\n-            '*' => BinOp(Star),\n-            '/' => BinOp(Slash),\n-            '%' => BinOp(Percent),\n-            '^' => BinOp(Caret),\n-            '&' => BinOp(And),\n-            '|' => BinOp(Or),\n-            '@' => At,\n-            '.' => Dot,\n-            ',' => Comma,\n-            ';' => Semi,\n-            ':' => Colon,\n-            '#' => Pound,\n-            '$' => Dollar,\n-            '?' => Question,\n-            '\\'' => SingleQuote,\n+            b'=' => Eq,\n+            b'<' => Lt,\n+            b'>' => Gt,\n+            b'!' => Not,\n+            b'~' => Tilde,\n+            b'+' => BinOp(Plus),\n+            b'-' => BinOp(Minus),\n+            b'*' => BinOp(Star),\n+            b'/' => BinOp(Slash),\n+            b'%' => BinOp(Percent),\n+            b'^' => BinOp(Caret),\n+            b'&' => BinOp(And),\n+            b'|' => BinOp(Or),\n+            b'@' => At,\n+            b'.' => Dot,\n+            b',' => Comma,\n+            b';' => Semi,\n+            b':' => Colon,\n+            b'#' => Pound,\n+            b'$' => Dollar,\n+            b'?' => Question,\n+            b'\\'' => SingleQuote,\n             _ => unreachable!(),\n         };\n \n@@ -277,38 +289,6 @@ impl ToInternal<rustc_errors::Level> for Level {\n \n pub struct FreeFunctions;\n \n-#[derive(Clone)]\n-pub struct Group {\n-    delimiter: Delimiter,\n-    stream: TokenStream,\n-    span: DelimSpan,\n-    /// A hack used to pass AST fragments to attribute and derive macros\n-    /// as a single nonterminal token instead of a token stream.\n-    /// FIXME: It needs to be removed, but there are some compatibility issues (see #73345).\n-    flatten: bool,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Punct {\n-    ch: char,\n-    // NB. not using `Spacing` here because it doesn't implement `Hash`.\n-    joint: bool,\n-    span: Span,\n-}\n-\n-impl Punct {\n-    fn new(ch: char, joint: bool, span: Span) -> Punct {\n-        const LEGAL_CHARS: &[char] = &[\n-            '=', '<', '>', '!', '~', '+', '-', '*', '/', '%', '^', '&', '|', '@', '.', ',', ';',\n-            ':', '#', '$', '?', '\\'',\n-        ];\n-        if !LEGAL_CHARS.contains(&ch) {\n-            panic!(\"unsupported character `{:?}`\", ch)\n-        }\n-        Punct { ch, joint, span }\n-    }\n-}\n-\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Ident {\n     sym: Symbol,\n@@ -377,8 +357,6 @@ impl<'a, 'b> Rustc<'a, 'b> {\n impl server::Types for Rustc<'_, '_> {\n     type FreeFunctions = FreeFunctions;\n     type TokenStream = TokenStream;\n-    type Group = Group;\n-    type Punct = Punct;\n     type Ident = Ident;\n     type Literal = Literal;\n     type SourceFile = Lrc<SourceFile>;\n@@ -471,15 +449,15 @@ impl server::TokenStream for Rustc<'_, '_> {\n \n     fn from_token_tree(\n         &mut self,\n-        tree: TokenTree<Self::Group, Self::Punct, Self::Ident, Self::Literal>,\n+        tree: TokenTree<Self::TokenStream, Self::Span, Self::Ident, Self::Literal>,\n     ) -> Self::TokenStream {\n         tree.to_internal()\n     }\n \n     fn concat_trees(\n         &mut self,\n         base: Option<Self::TokenStream>,\n-        trees: Vec<TokenTree<Self::Group, Self::Punct, Self::Ident, Self::Literal>>,\n+        trees: Vec<TokenTree<Self::TokenStream, Self::Span, Self::Ident, Self::Literal>>,\n     ) -> Self::TokenStream {\n         let mut builder = tokenstream::TokenStreamBuilder::new();\n         if let Some(base) = base {\n@@ -509,93 +487,8 @@ impl server::TokenStream for Rustc<'_, '_> {\n     fn into_trees(\n         &mut self,\n         stream: Self::TokenStream,\n-    ) -> Vec<TokenTree<Self::Group, Self::Punct, Self::Ident, Self::Literal>> {\n-        // FIXME: This is a raw port of the previous approach (which had a\n-        // `TokenStreamIter` server-side object with a single `next` method),\n-        // and can probably be optimized (for bulk conversion).\n-        let mut cursor = stream.into_trees();\n-        let mut stack = Vec::new();\n-        let mut tts = Vec::new();\n-        loop {\n-            let next = stack.pop().or_else(|| {\n-                let next = cursor.next_with_spacing()?;\n-                Some(TokenTree::from_internal((next, &mut stack, self)))\n-            });\n-            match next {\n-                Some(TokenTree::Group(group)) => {\n-                    // A hack used to pass AST fragments to attribute and derive\n-                    // macros as a single nonterminal token instead of a token\n-                    // stream.  Such token needs to be \"unwrapped\" and not\n-                    // represented as a delimited group.\n-                    // FIXME: It needs to be removed, but there are some\n-                    // compatibility issues (see #73345).\n-                    if group.flatten {\n-                        tts.append(&mut self.into_trees(group.stream));\n-                    } else {\n-                        tts.push(TokenTree::Group(group));\n-                    }\n-                }\n-                Some(tt) => tts.push(tt),\n-                None => return tts,\n-            }\n-        }\n-    }\n-}\n-\n-impl server::Group for Rustc<'_, '_> {\n-    fn new(&mut self, delimiter: Delimiter, stream: Option<Self::TokenStream>) -> Self::Group {\n-        Group {\n-            delimiter,\n-            stream: stream.unwrap_or_default(),\n-            span: DelimSpan::from_single(self.call_site),\n-            flatten: false,\n-        }\n-    }\n-\n-    fn delimiter(&mut self, group: &Self::Group) -> Delimiter {\n-        group.delimiter\n-    }\n-\n-    fn stream(&mut self, group: &Self::Group) -> Self::TokenStream {\n-        group.stream.clone()\n-    }\n-\n-    fn span(&mut self, group: &Self::Group) -> Self::Span {\n-        group.span.entire()\n-    }\n-\n-    fn span_open(&mut self, group: &Self::Group) -> Self::Span {\n-        group.span.open\n-    }\n-\n-    fn span_close(&mut self, group: &Self::Group) -> Self::Span {\n-        group.span.close\n-    }\n-\n-    fn set_span(&mut self, group: &mut Self::Group, span: Self::Span) {\n-        group.span = DelimSpan::from_single(span);\n-    }\n-}\n-\n-impl server::Punct for Rustc<'_, '_> {\n-    fn new(&mut self, ch: char, spacing: Spacing) -> Self::Punct {\n-        Punct::new(ch, spacing == Spacing::Joint, self.call_site)\n-    }\n-\n-    fn as_char(&mut self, punct: Self::Punct) -> char {\n-        punct.ch\n-    }\n-\n-    fn spacing(&mut self, punct: Self::Punct) -> Spacing {\n-        if punct.joint { Spacing::Joint } else { Spacing::Alone }\n-    }\n-\n-    fn span(&mut self, punct: Self::Punct) -> Self::Span {\n-        punct.span\n-    }\n-\n-    fn with_span(&mut self, punct: Self::Punct, span: Self::Span) -> Self::Punct {\n-        Punct { span, ..punct }\n+    ) -> Vec<TokenTree<Self::TokenStream, Self::Span, Self::Ident, Self::Literal>> {\n+        FromInternal::from_internal((stream, self))\n     }\n }\n "}, {"sha": "8254bd6e5024a5d6232951a21adc9070e7b0df6f", "filename": "library/proc_macro/src/bridge/client.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/94e93749ab00539a11e90426ea87382c433530a8/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94e93749ab00539a11e90426ea87382c433530a8/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs?ref=94e93749ab00539a11e90426ea87382c433530a8", "patch": "@@ -175,14 +175,12 @@ define_handles! {\n     'owned:\n     FreeFunctions,\n     TokenStream,\n-    Group,\n     Literal,\n     SourceFile,\n     MultiSpan,\n     Diagnostic,\n \n     'interned:\n-    Punct,\n     Ident,\n     Span,\n }\n@@ -199,12 +197,6 @@ impl Clone for TokenStream {\n     }\n }\n \n-impl Clone for Group {\n-    fn clone(&self) -> Self {\n-        self.clone()\n-    }\n-}\n-\n impl Clone for Literal {\n     fn clone(&self) -> Self {\n         self.clone()"}, {"sha": "048ba3a8fdb79ff992931d5162fef9f690427baf", "filename": "library/proc_macro/src/bridge/mod.rs", "status": "modified", "additions": 48, "deletions": 32, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/94e93749ab00539a11e90426ea87382c433530a8/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94e93749ab00539a11e90426ea87382c433530a8/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs?ref=94e93749ab00539a11e90426ea87382c433530a8", "patch": "@@ -65,37 +65,19 @@ macro_rules! with_api {\n                 fn from_str(src: &str) -> $S::TokenStream;\n                 fn to_string($self: &$S::TokenStream) -> String;\n                 fn from_token_tree(\n-                    tree: TokenTree<$S::Group, $S::Punct, $S::Ident, $S::Literal>,\n+                    tree: TokenTree<$S::TokenStream, $S::Span, $S::Ident, $S::Literal>,\n                 ) -> $S::TokenStream;\n                 fn concat_trees(\n                     base: Option<$S::TokenStream>,\n-                    trees: Vec<TokenTree<$S::Group, $S::Punct, $S::Ident, $S::Literal>>,\n+                    trees: Vec<TokenTree<$S::TokenStream, $S::Span, $S::Ident, $S::Literal>>,\n                 ) -> $S::TokenStream;\n                 fn concat_streams(\n                     base: Option<$S::TokenStream>,\n                     streams: Vec<$S::TokenStream>,\n                 ) -> $S::TokenStream;\n                 fn into_trees(\n                     $self: $S::TokenStream\n-                ) -> Vec<TokenTree<$S::Group, $S::Punct, $S::Ident, $S::Literal>>;\n-            },\n-            Group {\n-                fn drop($self: $S::Group);\n-                fn clone($self: &$S::Group) -> $S::Group;\n-                fn new(delimiter: Delimiter, stream: Option<$S::TokenStream>) -> $S::Group;\n-                fn delimiter($self: &$S::Group) -> Delimiter;\n-                fn stream($self: &$S::Group) -> $S::TokenStream;\n-                fn span($self: &$S::Group) -> $S::Span;\n-                fn span_open($self: &$S::Group) -> $S::Span;\n-                fn span_close($self: &$S::Group) -> $S::Span;\n-                fn set_span($self: &mut $S::Group, span: $S::Span);\n-            },\n-            Punct {\n-                fn new(ch: char, spacing: Spacing) -> $S::Punct;\n-                fn as_char($self: $S::Punct) -> char;\n-                fn spacing($self: $S::Punct) -> Spacing;\n-                fn span($self: $S::Punct) -> $S::Span;\n-                fn with_span($self: $S::Punct, span: $S::Span) -> $S::Punct;\n+                ) -> Vec<TokenTree<$S::TokenStream, $S::Span, $S::Ident, $S::Literal>>;\n             },\n             Ident {\n                 fn new(string: &str, span: $S::Span, is_raw: bool) -> $S::Ident;\n@@ -343,6 +325,7 @@ mark_noop! {\n     &'_ [u8],\n     &'_ str,\n     String,\n+    u8,\n     usize,\n     Delimiter,\n     Level,\n@@ -448,16 +431,49 @@ compound_traits!(\n     }\n );\n \n+#[derive(Copy, Clone)]\n+pub struct DelimSpan<Span> {\n+    pub open: Span,\n+    pub close: Span,\n+    pub entire: Span,\n+}\n+\n+impl<Span: Copy> DelimSpan<Span> {\n+    pub fn from_single(span: Span) -> Self {\n+        DelimSpan { open: span, close: span, entire: span }\n+    }\n+}\n+\n+compound_traits!(struct DelimSpan<Span> { open, close, entire });\n+\n+#[derive(Clone)]\n+pub struct Group<TokenStream, Span> {\n+    pub delimiter: Delimiter,\n+    pub stream: Option<TokenStream>,\n+    pub span: DelimSpan<Span>,\n+}\n+\n+compound_traits!(struct Group<TokenStream, Span> { delimiter, stream, span });\n+\n+#[derive(Clone)]\n+pub struct Punct<Span> {\n+    pub ch: u8,\n+    pub joint: bool,\n+    pub span: Span,\n+}\n+\n+compound_traits!(struct Punct<Span> { ch, joint, span });\n+\n #[derive(Clone)]\n-pub enum TokenTree<G, P, I, L> {\n-    Group(G),\n-    Punct(P),\n-    Ident(I),\n-    Literal(L),\n+pub enum TokenTree<TokenStream, Span, Ident, Literal> {\n+    Group(Group<TokenStream, Span>),\n+    Punct(Punct<Span>),\n+    Ident(Ident),\n+    Literal(Literal),\n }\n \n compound_traits!(\n-    enum TokenTree<G, P, I, L> {\n+    enum TokenTree<TokenStream, Span, Ident, Literal> {\n         Group(tt),\n         Punct(tt),\n         Ident(tt),\n@@ -468,12 +484,12 @@ compound_traits!(\n /// Globals provided alongside the initial inputs for a macro expansion.\n /// Provides values such as spans which are used frequently to avoid RPC.\n #[derive(Clone)]\n-pub struct ExpnGlobals<S> {\n-    pub def_site: S,\n-    pub call_site: S,\n-    pub mixed_site: S,\n+pub struct ExpnGlobals<Span> {\n+    pub def_site: Span,\n+    pub call_site: Span,\n+    pub mixed_site: Span,\n }\n \n compound_traits!(\n-    struct ExpnGlobals<Sp> { def_site, call_site, mixed_site }\n+    struct ExpnGlobals<Span> { def_site, call_site, mixed_site }\n );"}, {"sha": "ea8b833b48fde53109e3eecca3b4a15827bc2093", "filename": "library/proc_macro/src/bridge/server.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94e93749ab00539a11e90426ea87382c433530a8/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94e93749ab00539a11e90426ea87382c433530a8/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs?ref=94e93749ab00539a11e90426ea87382c433530a8", "patch": "@@ -8,8 +8,6 @@ use super::client::HandleStore;\n pub trait Types {\n     type FreeFunctions: 'static;\n     type TokenStream: 'static + Clone;\n-    type Group: 'static + Clone;\n-    type Punct: 'static + Copy + Eq + Hash;\n     type Ident: 'static + Copy + Eq + Hash;\n     type Literal: 'static + Clone;\n     type SourceFile: 'static + Clone;"}, {"sha": "9ab5061c668078c06c8feaa27ab40ae79b31a85e", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/94e93749ab00539a11e90426ea87382c433530a8/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94e93749ab00539a11e90426ea87382c433530a8/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=94e93749ab00539a11e90426ea87382c433530a8", "patch": "@@ -212,8 +212,8 @@ pub use quote::{quote, quote_span};\n fn tree_to_bridge_tree(\n     tree: TokenTree,\n ) -> bridge::TokenTree<\n-    bridge::client::Group,\n-    bridge::client::Punct,\n+    bridge::client::TokenStream,\n+    bridge::client::Span,\n     bridge::client::Ident,\n     bridge::client::Literal,\n > {\n@@ -238,8 +238,8 @@ impl From<TokenTree> for TokenStream {\n struct ConcatTreesHelper {\n     trees: Vec<\n         bridge::TokenTree<\n-            bridge::client::Group,\n-            bridge::client::Punct,\n+            bridge::client::TokenStream,\n+            bridge::client::Span,\n             bridge::client::Ident,\n             bridge::client::Literal,\n         >,\n@@ -365,8 +365,8 @@ pub mod token_stream {\n     pub struct IntoIter(\n         std::vec::IntoIter<\n             bridge::TokenTree<\n-                bridge::client::Group,\n-                bridge::client::Punct,\n+                bridge::client::TokenStream,\n+                bridge::client::Span,\n                 bridge::client::Ident,\n                 bridge::client::Literal,\n             >,\n@@ -788,7 +788,7 @@ impl fmt::Display for TokenTree {\n /// A `Group` internally contains a `TokenStream` which is surrounded by `Delimiter`s.\n #[derive(Clone)]\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n-pub struct Group(bridge::client::Group);\n+pub struct Group(bridge::Group<bridge::client::TokenStream, bridge::client::Span>);\n \n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl !Send for Group {}\n@@ -825,13 +825,17 @@ impl Group {\n     /// method below.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn new(delimiter: Delimiter, stream: TokenStream) -> Group {\n-        Group(bridge::client::Group::new(delimiter, stream.0))\n+        Group(bridge::Group {\n+            delimiter,\n+            stream: stream.0,\n+            span: bridge::DelimSpan::from_single(Span::call_site().0),\n+        })\n     }\n \n     /// Returns the delimiter of this `Group`\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn delimiter(&self) -> Delimiter {\n-        self.0.delimiter()\n+        self.0.delimiter\n     }\n \n     /// Returns the `TokenStream` of tokens that are delimited in this `Group`.\n@@ -840,7 +844,7 @@ impl Group {\n     /// returned above.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn stream(&self) -> TokenStream {\n-        TokenStream(Some(self.0.stream()))\n+        TokenStream(self.0.stream.clone())\n     }\n \n     /// Returns the span for the delimiters of this token stream, spanning the\n@@ -852,7 +856,7 @@ impl Group {\n     /// ```\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn span(&self) -> Span {\n-        Span(self.0.span())\n+        Span(self.0.span.entire)\n     }\n \n     /// Returns the span pointing to the opening delimiter of this group.\n@@ -863,7 +867,7 @@ impl Group {\n     /// ```\n     #[stable(feature = \"proc_macro_group_span\", since = \"1.55.0\")]\n     pub fn span_open(&self) -> Span {\n-        Span(self.0.span_open())\n+        Span(self.0.span.open)\n     }\n \n     /// Returns the span pointing to the closing delimiter of this group.\n@@ -874,7 +878,7 @@ impl Group {\n     /// ```\n     #[stable(feature = \"proc_macro_group_span\", since = \"1.55.0\")]\n     pub fn span_close(&self) -> Span {\n-        Span(self.0.span_close())\n+        Span(self.0.span.close)\n     }\n \n     /// Configures the span for this `Group`'s delimiters, but not its internal\n@@ -885,7 +889,7 @@ impl Group {\n     /// tokens at the level of the `Group`.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn set_span(&mut self, span: Span) {\n-        self.0.set_span(span.0);\n+        self.0.span = bridge::DelimSpan::from_single(span.0);\n     }\n }\n \n@@ -925,7 +929,7 @@ impl fmt::Debug for Group {\n /// forms of `Spacing` returned.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n #[derive(Clone)]\n-pub struct Punct(bridge::client::Punct);\n+pub struct Punct(bridge::Punct<bridge::client::Span>);\n \n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl !Send for Punct {}\n@@ -958,13 +962,24 @@ impl Punct {\n     /// which can be further configured with the `set_span` method below.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn new(ch: char, spacing: Spacing) -> Punct {\n-        Punct(bridge::client::Punct::new(ch, spacing))\n+        const LEGAL_CHARS: &[char] = &[\n+            '=', '<', '>', '!', '~', '+', '-', '*', '/', '%', '^', '&', '|', '@', '.', ',', ';',\n+            ':', '#', '$', '?', '\\'',\n+        ];\n+        if !LEGAL_CHARS.contains(&ch) {\n+            panic!(\"unsupported character `{:?}`\", ch);\n+        }\n+        Punct(bridge::Punct {\n+            ch: ch as u8,\n+            joint: spacing == Spacing::Joint,\n+            span: Span::call_site().0,\n+        })\n     }\n \n     /// Returns the value of this punctuation character as `char`.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn as_char(&self) -> char {\n-        self.0.as_char()\n+        self.0.ch as char\n     }\n \n     /// Returns the spacing of this punctuation character, indicating whether it's immediately\n@@ -973,28 +988,19 @@ impl Punct {\n     /// (`Alone`) so the operator has certainly ended.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn spacing(&self) -> Spacing {\n-        self.0.spacing()\n+        if self.0.joint { Spacing::Joint } else { Spacing::Alone }\n     }\n \n     /// Returns the span for this punctuation character.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn span(&self) -> Span {\n-        Span(self.0.span())\n+        Span(self.0.span)\n     }\n \n     /// Configure the span for this punctuation character.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn set_span(&mut self, span: Span) {\n-        self.0 = self.0.with_span(span.0);\n-    }\n-}\n-\n-// N.B., the bridge only provides `to_string`, implement `fmt::Display`\n-// based on it (the reverse of the usual relationship between the two).\n-#[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n-impl ToString for Punct {\n-    fn to_string(&self) -> String {\n-        TokenStream::from(TokenTree::from(self.clone())).to_string()\n+        self.0.span = span.0;\n     }\n }\n \n@@ -1003,7 +1009,7 @@ impl ToString for Punct {\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Display for Punct {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.to_string())\n+        write!(f, \"{}\", self.as_char())\n     }\n }\n "}, {"sha": "ecbb6ebf55b9a4ba5cb9294dd6ba47db7b823194", "filename": "src/test/ui/proc-macro/invalid-punct-ident-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94e93749ab00539a11e90426ea87382c433530a8/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94e93749ab00539a11e90426ea87382c433530a8/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-1.rs?ref=94e93749ab00539a11e90426ea87382c433530a8", "patch": "@@ -2,7 +2,7 @@\n // rustc-env:RUST_BACKTRACE=0\n \n // FIXME https://github.com/rust-lang/rust/issues/59998\n-// normalize-stderr-test \"thread.*panicked.*proc_macro_server.rs.*\\n\" -> \"\"\n+// normalize-stderr-test \"thread.*panicked.*proc_macro.*lib.rs.*\\n\" -> \"\"\n // normalize-stderr-test \"note:.*RUST_BACKTRACE=1.*\\n\" -> \"\"\n // normalize-stderr-test \"\\nerror: internal compiler error.*\\n\\n\" -> \"\"\n // normalize-stderr-test \"note:.*unexpectedly panicked.*\\n\\n\" -> \"\""}]}