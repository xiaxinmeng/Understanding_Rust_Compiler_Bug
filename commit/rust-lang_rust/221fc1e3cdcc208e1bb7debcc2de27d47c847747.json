{"sha": "221fc1e3cdcc208e1bb7debcc2de27d47c847747", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyMWZjMWUzY2RjYzIwOGUxYmI3ZGViY2MyZGUyN2Q0N2M4NDc3NDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-31T02:27:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-31T02:27:15Z"}, "message": "auto merge of #18459 : alexcrichton/rust/rollup, r=alexcrichton", "tree": {"sha": "5e2d393fe5a4a94cd6a09d93f4ddcf5a4f6aecaa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e2d393fe5a4a94cd6a09d93f4ddcf5a4f6aecaa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/221fc1e3cdcc208e1bb7debcc2de27d47c847747", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/221fc1e3cdcc208e1bb7debcc2de27d47c847747", "html_url": "https://github.com/rust-lang/rust/commit/221fc1e3cdcc208e1bb7debcc2de27d47c847747", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/221fc1e3cdcc208e1bb7debcc2de27d47c847747/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a12d06b73fcb38cf23dfe71da725428a1094395f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a12d06b73fcb38cf23dfe71da725428a1094395f", "html_url": "https://github.com/rust-lang/rust/commit/a12d06b73fcb38cf23dfe71da725428a1094395f"}, {"sha": "6fcba8826fd26028341a35d88b07208378ac05ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fcba8826fd26028341a35d88b07208378ac05ea", "html_url": "https://github.com/rust-lang/rust/commit/6fcba8826fd26028341a35d88b07208378ac05ea"}], "stats": {"total": 2609, "additions": 1170, "deletions": 1439}, "files": [{"sha": "a40913a5db2a2250e781aaf9facb52f57641a32c", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -1013,7 +1013,7 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n                 if prefix_matches(line, prefixes[i].as_slice()) &&\n                     line.contains(ee.kind.as_slice()) &&\n                     line.contains(ee.msg.as_slice()) {\n-                    *found_flags.get_mut(i) = true;\n+                    found_flags[i] = true;\n                     was_expected = true;\n                     break;\n                 }"}, {"sha": "940a4ca6db7b3e9b4709d80e36dd063a305b91b3", "filename": "src/doc/complement-bugreport.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Fdoc%2Fcomplement-bugreport.md", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Fdoc%2Fcomplement-bugreport.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-bugreport.md?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -47,7 +47,7 @@ release: 0.12.0\n ```\n \n Finally, if you can run the offending command under gdb, pasting a stack trace can be\n-useful; to do so, you will need to set a breakpoint on `rust_fail`.\n+useful; to do so, you will need to set a breakpoint on `rust_panic`.\n \n # I submitted a bug, but nobody has commented on it!\n "}, {"sha": "b6ea1ddb3949d3e3d7c83a1558a275ae546ed770", "filename": "src/doc/guide-lifetimes.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Fdoc%2Fguide-lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Fdoc%2Fguide-lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-lifetimes.md?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -56,7 +56,7 @@ a reference.\n fn compute_distance(p1: &Point, p2: &Point) -> f64 {\n     let x_d = p1.x - p2.x;\n     let y_d = p1.y - p2.y;\n-    sqrt(x_d * x_d + y_d * y_d)\n+    (x_d * x_d + y_d * y_d).sqrt()\n }\n ~~~\n "}, {"sha": "084309e9978f6d70a63550179a60abc77482a134", "filename": "src/doc/reference.md", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -1153,7 +1153,7 @@ exposing an API making it possible for it to occur in safe code.\n \n * Data races\n * Dereferencing a null/dangling raw pointer\n-* Mutating an immutable value/reference\n+* Mutating an immutable value/reference without `UnsafeCell`\n * Reads of [undef](http://llvm.org/docs/LangRef.html#undefined-values)\n   (uninitialized) memory\n * Breaking the [pointer aliasing\n@@ -1166,11 +1166,14 @@ exposing an API making it possible for it to occur in safe code.\n   * Using `std::ptr::copy_nonoverlapping_memory` (`memcpy32`/`memcpy64`\n     instrinsics) on overlapping buffers\n * Invalid values in primitive types, even in private fields/locals:\n-  * Dangling/null pointers in non-raw pointers, or slices\n+  * Dangling/null references or boxes\n   * A value other than `false` (0) or `true` (1) in a `bool`\n   * A discriminant in an `enum` not included in the type definition\n   * A value in a `char` which is a surrogate or above `char::MAX`\n   * non-UTF-8 byte sequences in a `str`\n+* Unwinding into Rust from foreign code or unwinding from Rust into foreign\n+  code. Rust's failure system is not compatible with exception handling in\n+  other languages. Unwinding must be caught and handled at FFI boundaries.\n \n ##### Behaviour not considered unsafe\n "}, {"sha": "a4641c40165aca9ede5d17025b5b0d32d9858e0b", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -59,20 +59,20 @@ fn parse_token_list(file: &str) -> HashMap<String, Token> {\n             \"FLOAT_SUFFIX\"      => id(),\n             \"INT_SUFFIX\"        => id(),\n             \"SHL\"               => token::BinOp(token::Shl),\n-            \"LBRACE\"            => token::LBrace,\n+            \"LBRACE\"            => token::OpenDelim(token::Brace),\n             \"RARROW\"            => token::Rarrow,\n             \"LIT_STR\"           => token::LitStr(Name(0)),\n             \"DOTDOT\"            => token::DotDot,\n             \"MOD_SEP\"           => token::ModSep,\n             \"DOTDOTDOT\"         => token::DotDotDot,\n             \"NOT\"               => token::Not,\n             \"AND\"               => token::BinOp(token::And),\n-            \"LPAREN\"            => token::LParen,\n+            \"LPAREN\"            => token::OpenDelim(token::Paren),\n             \"ANDAND\"            => token::AndAnd,\n             \"AT\"                => token::At,\n-            \"LBRACKET\"          => token::LBracket,\n+            \"LBRACKET\"          => token::OpenDelim(token::Bracket),\n             \"LIT_STR_RAW\"       => token::LitStrRaw(Name(0), 0),\n-            \"RPAREN\"            => token::RParen,\n+            \"RPAREN\"            => token::CloseDelim(token::Paren),\n             \"SLASH\"             => token::BinOp(token::Slash),\n             \"COMMA\"             => token::Comma,\n             \"LIFETIME\"          => token::Lifetime(ast::Ident { name: Name(0), ctxt: 0 }),\n@@ -83,15 +83,15 @@ fn parse_token_list(file: &str) -> HashMap<String, Token> {\n             \"LIT_CHAR\"          => token::LitChar(Name(0)),\n             \"LIT_BYTE\"          => token::LitByte(Name(0)),\n             \"EQ\"                => token::Eq,\n-            \"RBRACKET\"          => token::RBracket,\n+            \"RBRACKET\"          => token::CloseDelim(token::Bracket),\n             \"COMMENT\"           => token::Comment,\n             \"DOC_COMMENT\"       => token::DocComment(Name(0)),\n             \"DOT\"               => token::Dot,\n             \"EQEQ\"              => token::EqEq,\n             \"NE\"                => token::Ne,\n             \"GE\"                => token::Ge,\n             \"PERCENT\"           => token::BinOp(token::Percent),\n-            \"RBRACE\"            => token::RBrace,\n+            \"RBRACE\"            => token::CloseDelim(token::Brace),\n             \"BINOP\"             => token::BinOp(token::Plus),\n             \"POUND\"             => token::Pound,\n             \"OROR\"              => token::OrOr,"}, {"sha": "0e3010ad30ab3aed379481a1482464e53f91fdf2", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -29,7 +29,7 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![feature(unsafe_destructor)]\n-#![allow(missing_doc)]\n+#![allow(missing_docs)]\n \n use std::cell::{Cell, RefCell};\n use std::cmp;\n@@ -208,13 +208,13 @@ impl Arena {\n     }\n \n     #[inline]\n-    fn alloc_copy<T>(&self, op: || -> T) -> &T {\n+    fn alloc_copy<T>(&self, op: || -> T) -> &mut T {\n         unsafe {\n             let ptr = self.alloc_copy_inner(mem::size_of::<T>(),\n                                             mem::min_align_of::<T>());\n             let ptr = ptr as *mut T;\n             ptr::write(&mut (*ptr), op());\n-            return &*ptr;\n+            return &mut *ptr;\n         }\n     }\n \n@@ -262,7 +262,7 @@ impl Arena {\n     }\n \n     #[inline]\n-    fn alloc_noncopy<T>(&self, op: || -> T) -> &T {\n+    fn alloc_noncopy<T>(&self, op: || -> T) -> &mut T {\n         unsafe {\n             let tydesc = get_tydesc::<T>();\n             let (ty_ptr, ptr) =\n@@ -279,14 +279,14 @@ impl Arena {\n             // the object is there.\n             *ty_ptr = bitpack_tydesc_ptr(tydesc, true);\n \n-            return &*ptr;\n+            return &mut *ptr;\n         }\n     }\n \n     /// Allocates a new item in the arena, using `op` to initialize the value,\n     /// and returns a reference to it.\n     #[inline]\n-    pub fn alloc<T>(&self, op: || -> T) -> &T {\n+    pub fn alloc<T>(&self, op: || -> T) -> &mut T {\n         unsafe {\n             if intrinsics::needs_drop::<T>() {\n                 self.alloc_noncopy(op)\n@@ -458,12 +458,12 @@ impl<T> TypedArena<T> {\n \n     /// Allocates an object in the `TypedArena`, returning a reference to it.\n     #[inline]\n-    pub fn alloc(&self, object: T) -> &T {\n+    pub fn alloc(&self, object: T) -> &mut T {\n         if self.ptr == self.end {\n             self.grow()\n         }\n \n-        let ptr: &T = unsafe {\n+        let ptr: &mut T = unsafe {\n             let ptr: &mut T = mem::transmute(self.ptr);\n             ptr::write(ptr, object);\n             self.ptr.set(self.ptr.get().offset(1));"}, {"sha": "1b12fdcb8dc0406d70bbb79a22c2893155a45c52", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -243,7 +243,7 @@ impl Bitv {\n         let used_bits = bitv.nbits % u32::BITS;\n         if init && used_bits != 0 {\n             let largest_used_word = (bitv.nbits + u32::BITS - 1) / u32::BITS - 1;\n-            *bitv.storage.get_mut(largest_used_word) &= (1 << used_bits) - 1;\n+            bitv.storage[largest_used_word] &= (1 << used_bits) - 1;\n         }\n \n         bitv\n@@ -297,8 +297,9 @@ impl Bitv {\n         let w = i / u32::BITS;\n         let b = i % u32::BITS;\n         let flag = 1 << b;\n-        *self.storage.get_mut(w) = if x { self.storage[w] | flag }\n-                          else { self.storage[w] & !flag };\n+        let val = if x { self.storage[w] | flag }\n+                  else { self.storage[w] & !flag };\n+        self.storage[w] = val;\n     }\n \n     /// Sets all bits to 1.\n@@ -617,7 +618,7 @@ impl Bitv {\n             self.storage.truncate(word_len);\n             if len % u32::BITS > 0 {\n                 let mask = (1 << len % u32::BITS) - 1;\n-                *self.storage.get_mut(word_len - 1) &= mask;\n+                self.storage[word_len - 1] &= mask;\n             }\n         }\n     }\n@@ -681,15 +682,15 @@ impl Bitv {\n             let overhang = self.nbits % u32::BITS; // # of already-used bits\n             let mask = !((1 << overhang) - 1);  // e.g. 5 unused bits => 111110....0\n             if value {\n-                *self.storage.get_mut(old_last_word) |= mask;\n+                self.storage[old_last_word] |= mask;\n             } else {\n-                *self.storage.get_mut(old_last_word) &= !mask;\n+                self.storage[old_last_word] &= !mask;\n             }\n         }\n         // Fill in words after the old tail word\n         let stop_idx = cmp::min(self.storage.len(), new_nwords);\n         for idx in range(old_last_word + 1, stop_idx) {\n-            *self.storage.get_mut(idx) = full_value;\n+            self.storage[idx] = full_value;\n         }\n         // Allocate new words, if needed\n         if new_nwords > self.storage.len() {\n@@ -700,7 +701,7 @@ impl Bitv {\n             if value {\n                 let tail_word = new_nwords - 1;\n                 let used_bits = new_nbits % u32::BITS;\n-                *self.storage.get_mut(tail_word) &= (1 << used_bits) - 1;\n+                self.storage[tail_word] &= (1 << used_bits) - 1;\n             }\n         }\n         // Adjust internal bit count\n@@ -728,7 +729,7 @@ impl Bitv {\n         let ret = self.get(self.nbits - 1);\n         // If we are unusing a whole word, make sure it is zeroed out\n         if self.nbits % u32::BITS == 1 {\n-            *self.storage.get_mut(self.nbits / u32::BITS) = 0;\n+            self.storage[self.nbits / u32::BITS] = 0;\n         }\n         self.nbits -= 1;\n         ret\n@@ -1184,7 +1185,7 @@ impl BitvSet {\n         for (i, w) in other_words {\n             let old = self_bitv.storage[i];\n             let new = f(old, w);\n-            *self_bitv.storage.get_mut(i) = new;\n+            self_bitv.storage[i] = new;\n         }\n     }\n "}, {"sha": "dc7d935619f9ef08052cbf8c615fdc14510ebec5", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -690,6 +690,12 @@ impl<K: Ord, V> Index<K, V> for BTreeMap<K, V> {\n     }\n }\n \n+impl<K: Ord, V> IndexMut<K, V> for BTreeMap<K, V> {\n+    fn index_mut(&mut self, key: &K) -> &mut V {\n+        self.find_mut(key).expect(\"no entry found for key\")\n+    }\n+}\n+\n /// Genericises over how to get the correct type of iterator from the correct type\n /// of Node ownership.\n trait Traverse<N> {"}, {"sha": "65fd8ce4f54d96cdce47f9e52a2aa7c12b59b0f3", "filename": "src/libcollections/priority_queue.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcollections%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcollections%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fpriority_queue.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -71,7 +71,7 @@\n //!     let mut pq = PriorityQueue::new();\n //!\n //!     // We're at `start`, with a zero cost\n-//!     *dist.get_mut(start) = 0u;\n+//!     dist[start] = 0u;\n //!     pq.push(State { cost: 0u, position: start });\n //!\n //!     // Examine the frontier with lower cost nodes first (min-heap)\n@@ -96,7 +96,7 @@\n //!             if next.cost < dist[next.position] {\n //!                 pq.push(next);\n //!                 // Relaxation, we have now found a better way\n-//!                 *dist.get_mut(next.position) = next.cost;\n+//!                 dist[next.position] = next.cost;\n //!             }\n //!         }\n //!     }\n@@ -151,7 +151,7 @@\n //! }\n //! ```\n \n-#![allow(missing_doc)]\n+#![allow(missing_docs)]\n \n use core::prelude::*;\n \n@@ -330,7 +330,7 @@ impl<T: Ord> PriorityQueue<T> {\n             None           => { None }\n             Some(mut item) => {\n                 if !self.is_empty() {\n-                    swap(&mut item, self.data.get_mut(0));\n+                    swap(&mut item, &mut self.data[0]);\n                     self.siftdown(0);\n                 }\n                 Some(item)\n@@ -378,7 +378,7 @@ impl<T: Ord> PriorityQueue<T> {\n     /// ```\n     pub fn push_pop(&mut self, mut item: T) -> T {\n         if !self.is_empty() && *self.top().unwrap() > item {\n-            swap(&mut item, self.data.get_mut(0));\n+            swap(&mut item, &mut self.data[0]);\n             self.siftdown(0);\n         }\n         item\n@@ -402,7 +402,7 @@ impl<T: Ord> PriorityQueue<T> {\n     /// ```\n     pub fn replace(&mut self, mut item: T) -> Option<T> {\n         if !self.is_empty() {\n-            swap(&mut item, self.data.get_mut(0));\n+            swap(&mut item, &mut self.data[0]);\n             self.siftdown(0);\n             Some(item)\n         } else {\n@@ -462,40 +462,40 @@ impl<T: Ord> PriorityQueue<T> {\n     // compared to using swaps, which involves twice as many moves.\n     fn siftup(&mut self, start: uint, mut pos: uint) {\n         unsafe {\n-            let new = replace(self.data.get_mut(pos), zeroed());\n+            let new = replace(&mut self.data[pos], zeroed());\n \n             while pos > start {\n                 let parent = (pos - 1) >> 1;\n                 if new > self.data[parent] {\n-                    let x = replace(self.data.get_mut(parent), zeroed());\n-                    ptr::write(self.data.get_mut(pos), x);\n+                    let x = replace(&mut self.data[parent], zeroed());\n+                    ptr::write(&mut self.data[pos], x);\n                     pos = parent;\n                     continue\n                 }\n                 break\n             }\n-            ptr::write(self.data.get_mut(pos), new);\n+            ptr::write(&mut self.data[pos], new);\n         }\n     }\n \n     fn siftdown_range(&mut self, mut pos: uint, end: uint) {\n         unsafe {\n             let start = pos;\n-            let new = replace(self.data.get_mut(pos), zeroed());\n+            let new = replace(&mut self.data[pos], zeroed());\n \n             let mut child = 2 * pos + 1;\n             while child < end {\n                 let right = child + 1;\n                 if right < end && !(self.data[child] > self.data[right]) {\n                     child = right;\n                 }\n-                let x = replace(self.data.get_mut(child), zeroed());\n-                ptr::write(self.data.get_mut(pos), x);\n+                let x = replace(&mut self.data[child], zeroed());\n+                ptr::write(&mut self.data[pos], x);\n                 pos = child;\n                 child = 2 * pos + 1;\n             }\n \n-            ptr::write(self.data.get_mut(pos), new);\n+            ptr::write(&mut self.data[pos], new);\n             self.siftup(start, pos);\n         }\n     }"}, {"sha": "81e4361ec39493907ab075484f69dbe2529fa73e", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -58,7 +58,7 @@ impl<T> Deque<T> for RingBuf<T> {\n \n     /// Returns a mutable reference to the first element in the `RingBuf`.\n     fn front_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n-        if self.nelts > 0 { Some(self.get_mut(0)) } else { None }\n+        if self.nelts > 0 { Some(&mut self[0]) } else { None }\n     }\n \n     /// Returns a reference to the last element in the `RingBuf`.\n@@ -69,13 +69,13 @@ impl<T> Deque<T> for RingBuf<T> {\n     /// Returns a mutable reference to the last element in the `RingBuf`.\n     fn back_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n         let nelts = self.nelts;\n-        if nelts > 0 { Some(self.get_mut(nelts - 1)) } else { None }\n+        if nelts > 0 { Some(&mut self[nelts - 1]) } else { None }\n     }\n \n     /// Removes and returns the first element in the `RingBuf`, or `None` if it\n     /// is empty.\n     fn pop_front(&mut self) -> Option<T> {\n-        let result = self.elts.get_mut(self.lo).take();\n+        let result = self.elts[self.lo].take();\n         if result.is_some() {\n             self.lo = (self.lo + 1u) % self.elts.len();\n             self.nelts -= 1u;\n@@ -91,7 +91,7 @@ impl<T> Deque<T> for RingBuf<T> {\n         if self.lo == 0u {\n             self.lo = self.elts.len() - 1u;\n         } else { self.lo -= 1u; }\n-        *self.elts.get_mut(self.lo) = Some(t);\n+        self.elts[self.lo] = Some(t);\n         self.nelts += 1u;\n     }\n }\n@@ -102,14 +102,14 @@ impl<T> MutableSeq<T> for RingBuf<T> {\n             grow(self.nelts, &mut self.lo, &mut self.elts);\n         }\n         let hi = self.raw_index(self.nelts);\n-        *self.elts.get_mut(hi) = Some(t);\n+        self.elts[hi] = Some(t);\n         self.nelts += 1u;\n     }\n     fn pop(&mut self) -> Option<T> {\n         if self.nelts > 0 {\n             self.nelts -= 1;\n             let hi = self.raw_index(self.nelts);\n-            self.elts.get_mut(hi).take()\n+            self.elts[hi].take()\n         } else {\n             None\n         }\n@@ -140,6 +140,7 @@ impl<T> RingBuf<T> {\n     /// # Example\n     ///\n     /// ```rust\n+    /// # #![allow(deprecated)]\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n@@ -149,12 +150,9 @@ impl<T> RingBuf<T> {\n     /// *buf.get_mut(1) = 7;\n     /// assert_eq!(buf[1], 7);\n     /// ```\n+    #[deprecated = \"use indexing instead: `buf[index] = value`\"]\n     pub fn get_mut<'a>(&'a mut self, i: uint) -> &'a mut T {\n-        let idx = self.raw_index(i);\n-        match *self.elts.get_mut(idx) {\n-            None => panic!(),\n-            Some(ref mut v) => v\n-        }\n+        &mut self[i]\n     }\n \n     /// Swaps elements at indices `i` and `j`.\n@@ -466,13 +464,16 @@ impl<A> Index<uint, A> for RingBuf<A> {\n     }\n }\n \n-// FIXME(#12825) Indexing will always try IndexMut first and that causes issues.\n-/*impl<A> IndexMut<uint, A> for RingBuf<A> {\n+impl<A> IndexMut<uint, A> for RingBuf<A> {\n     #[inline]\n-    fn index_mut<'a>(&'a mut self, index: &uint) -> &'a mut A {\n-        self.get_mut(*index)\n+    fn index_mut<'a>(&'a mut self, i: &uint) -> &'a mut A {\n+        let idx = self.raw_index(*i);\n+        match *(&mut self.elts[idx]) {\n+            None => panic!(),\n+            Some(ref mut v) => v\n+        }\n     }\n-}*/\n+}\n \n impl<A> FromIterator<A> for RingBuf<A> {\n     fn from_iter<T: Iterator<A>>(iterator: T) -> RingBuf<A> {"}, {"sha": "a552e4caa2d21415b0310b9ce7858bc9694bb0fc", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -109,7 +109,7 @@ pub use core::slice::{Found, NotFound};\n \n // Functional utilities\n \n-#[allow(missing_doc)]\n+#[allow(missing_docs)]\n pub trait VectorVector<T> for Sized? {\n     // FIXME #5898: calling these .concat and .connect conflicts with\n     // StrVector::con{cat,nect}, since they have generic contents."}, {"sha": "9e6485103e19247e4aef5ab2cf581ddc0f45f702", "filename": "src/libcollections/smallintmap.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcollections%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcollections%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fsmallintmap.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -11,7 +11,7 @@\n //! A simple map based on a vector for small integer keys. Space requirements\n //! are O(highest integer key).\n \n-#![allow(missing_doc)]\n+#![allow(missing_docs)]\n \n use core::prelude::*;\n \n@@ -100,7 +100,7 @@ impl<V> MutableMap<uint, V> for SmallIntMap<V> {\n     /// Returns a mutable reference to the value corresponding to the key.\n     fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut V> {\n         if *key < self.v.len() {\n-            match *self.v.get_mut(*key) {\n+            match *self.v.index_mut(key) {\n               Some(ref mut value) => Some(value),\n               None => None\n             }\n@@ -118,7 +118,7 @@ impl<V> MutableMap<uint, V> for SmallIntMap<V> {\n         if len <= key {\n             self.v.grow_fn(key - len + 1, |_| None);\n         }\n-        *self.v.get_mut(key) = Some(value);\n+        self.v[key] = Some(value);\n         !exists\n     }\n \n@@ -145,7 +145,7 @@ impl<V> MutableMap<uint, V> for SmallIntMap<V> {\n         if *key >= self.v.len() {\n             return None;\n         }\n-        self.v.get_mut(*key).take()\n+        self.v[*key].take()\n     }\n }\n \n@@ -405,13 +405,12 @@ impl<V> Index<uint, V> for SmallIntMap<V> {\n     }\n }\n \n-// FIXME(#12825) Indexing will always try IndexMut first and that causes issues.\n-/*impl<V> IndexMut<uint, V> for SmallIntMap<V> {\n+impl<V> IndexMut<uint, V> for SmallIntMap<V> {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, i: &uint) -> &'a mut V {\n         self.find_mut(i).expect(\"key not present\")\n     }\n-}*/\n+}\n \n macro_rules! iterator {\n     (impl $name:ident -> $elem:ty, $($getter:ident),+) => {"}, {"sha": "86a640d1aeb9b4b228cbfd613e767d3022710b0d", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 4, "deletions": 73, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -692,17 +692,17 @@ pub trait StrAllocating: Str {\n         for (i, sc) in me.chars().enumerate() {\n \n             let mut current = i;\n-            *dcol.get_mut(0) = current + 1;\n+            dcol[0] = current + 1;\n \n             for (j, tc) in t.chars().enumerate() {\n \n                 let next = dcol[j + 1];\n \n                 if sc == tc {\n-                    *dcol.get_mut(j + 1) = current;\n+                    dcol[j + 1] = current;\n                 } else {\n-                    *dcol.get_mut(j + 1) = cmp::min(current, next);\n-                    *dcol.get_mut(j + 1) = cmp::min(dcol[j + 1], dcol[j]) + 1;\n+                    dcol[j + 1] = cmp::min(current, next);\n+                    dcol[j + 1] = cmp::min(dcol[j + 1], dcol[j]) + 1;\n                 }\n \n                 current = next;\n@@ -1677,40 +1677,6 @@ mod tests {\n         assert_eq!(pos, p.len());\n     }\n \n-    #[test]\n-    fn test_split_char_iterator() {\n-        let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n-\n-        let split: Vec<&str> = data.split(' ').collect();\n-        assert_eq!( split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n-\n-        let mut rsplit: Vec<&str> = data.split(' ').rev().collect();\n-        rsplit.reverse();\n-        assert_eq!(rsplit, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n-\n-        let split: Vec<&str> = data.split(|c: char| c == ' ').collect();\n-        assert_eq!( split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n-\n-        let mut rsplit: Vec<&str> = data.split(|c: char| c == ' ').rev().collect();\n-        rsplit.reverse();\n-        assert_eq!(rsplit, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n-\n-        // Unicode\n-        let split: Vec<&str> = data.split('\u00e4').collect();\n-        assert_eq!( split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n-\n-        let mut rsplit: Vec<&str> = data.split('\u00e4').rev().collect();\n-        rsplit.reverse();\n-        assert_eq!(rsplit, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n-\n-        let split: Vec<&str> = data.split(|c: char| c == '\u00e4').collect();\n-        assert_eq!( split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n-\n-        let mut rsplit: Vec<&str> = data.split(|c: char| c == '\u00e4').rev().collect();\n-        rsplit.reverse();\n-        assert_eq!(rsplit, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n-    }\n-\n     #[test]\n     fn test_splitn_char_iterator() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n@@ -1729,28 +1695,6 @@ mod tests {\n         assert_eq!(split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n     }\n \n-    #[test]\n-    fn test_rsplitn_char_iterator() {\n-        let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n-\n-        let mut split: Vec<&str> = data.rsplitn(3, ' ').collect();\n-        split.reverse();\n-        assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n-\n-        let mut split: Vec<&str> = data.rsplitn(3, |c: char| c == ' ').collect();\n-        split.reverse();\n-        assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n-\n-        // Unicode\n-        let mut split: Vec<&str> = data.rsplitn(3, '\u00e4').collect();\n-        split.reverse();\n-        assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n-\n-        let mut split: Vec<&str> = data.rsplitn(3, |c: char| c == '\u00e4').collect();\n-        split.reverse();\n-        assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n-    }\n-\n     #[test]\n     fn test_split_char_iterator_no_trailing() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n@@ -1762,19 +1706,6 @@ mod tests {\n         assert_eq!(split, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n     }\n \n-    #[test]\n-    fn test_rev_split_char_iterator_no_trailing() {\n-        let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n-\n-        let mut split: Vec<&str> = data.split('\\n').rev().collect();\n-        split.reverse();\n-        assert_eq!(split, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n-\n-        let mut split: Vec<&str> = data.split_terminator('\\n').rev().collect();\n-        split.reverse();\n-        assert_eq!(split, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n-    }\n-\n     #[test]\n     fn test_words() {\n         let data = \"\\n \\tM\u00e4ry   h\u00e4d\\t\u00e4  little l\u00e4mb\\nLittle l\u00e4mb\\n\";"}, {"sha": "507cfbf191c4ac604c051c2cc95e7903d3ae20b9", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -744,6 +744,11 @@ impl ops::Slice<uint, str> for String {\n     }\n }\n \n+#[experimental = \"waiting on Deref stabilization\"]\n+impl ops::Deref<str> for String {\n+    fn deref<'a>(&'a self) -> &'a str { self.as_slice() }\n+}\n+\n /// Wrapper type providing a `&String` reference via `Deref`.\n #[experimental]\n pub struct DerefString<'a> {"}, {"sha": "ea4d541aab94a1f1b30ab4be851b6d63aae20003", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -257,12 +257,12 @@ impl<K: Ord, V> Index<K, V> for TreeMap<K, V> {\n     }\n }\n \n-/*impl<K: Ord, V> IndexMut<K, V> for TreeMap<K, V> {\n+impl<K: Ord, V> IndexMut<K, V> for TreeMap<K, V> {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, i: &K) -> &'a mut V {\n         self.find_mut(i).expect(\"no entry found for key\")\n     }\n-}*/\n+}\n \n impl<K: Ord, V> TreeMap<K, V> {\n     /// Creates an empty `TreeMap`."}, {"sha": "8c18a6488ba50bb34b1004d56e09311a93c2db4b", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -515,13 +515,12 @@ impl<T> Index<uint, T> for TrieMap<T> {\n     }\n }\n \n-// FIXME(#12825) Indexing will always try IndexMut first and that causes issues.\n-/*impl<T> IndexMut<uint, T> for TrieMap<T> {\n+impl<T> IndexMut<uint, T> for TrieMap<T> {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, i: &uint) -> &'a mut T {\n         self.find_mut(i).expect(\"key not present\")\n     }\n-}*/\n+}\n \n /// A set implemented as a radix trie.\n ///"}, {"sha": "b190093bafcb371418b2de0fbdf4fc6e57bdc4d1", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 23, "deletions": 374, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -28,8 +28,7 @@ use core::raw::Slice as RawSlice;\n use core::uint;\n \n use {Mutable, MutableSeq};\n-use slice::{MutableOrdSlice, MutableSliceAllocating, CloneableVector};\n-use slice::{Items, MutItems};\n+use slice::{CloneableVector};\n \n /// An owned, growable vector.\n ///\n@@ -46,7 +45,7 @@ use slice::{Items, MutItems};\n /// assert_eq!(vec.pop(), Some(2));\n /// assert_eq!(vec.len(), 1);\n ///\n-/// *vec.get_mut(0) = 7i;\n+/// vec[0] = 7i;\n /// assert_eq!(vec[0], 7);\n ///\n /// vec.push_all([1, 2, 3]);\n@@ -414,11 +413,10 @@ impl<T> Index<uint,T> for Vec<T> {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl<T> IndexMut<uint,T> for Vec<T> {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, index: &uint) -> &'a mut T {\n-        self.get_mut(*index)\n+        &mut self.as_mut_slice()[*index]\n     }\n }\n \n@@ -464,6 +462,16 @@ impl<T> ops::SliceMut<uint, [T]> for Vec<T> {\n     }\n }\n \n+#[experimental = \"waiting on Deref stability\"]\n+impl<T> ops::Deref<[T]> for Vec<T> {\n+    fn deref<'a>(&'a self) -> &'a [T] { self.as_slice() }\n+}\n+\n+#[experimental = \"waiting on DerefMut stability\"]\n+impl<T> ops::DerefMut<[T]> for Vec<T> {\n+    fn deref_mut<'a>(&'a mut self) -> &'a mut [T] { self.as_mut_slice() }\n+}\n+\n #[experimental = \"waiting on FromIterator stability\"]\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n@@ -712,14 +720,6 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Deprecated, use `.extend(other.into_iter())`\n-    #[inline]\n-    #[deprecated = \"use .extend(other.into_iter())\"]\n-    #[cfg(stage0)]\n-    pub fn push_all_move(&mut self, other: Vec<T>) {\n-            self.extend(other.into_iter());\n-    }\n-\n     /// Returns a mutable slice of the elements of `self`.\n     ///\n     /// # Example\n@@ -735,7 +735,7 @@ impl<T> Vec<T> {\n     pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n         unsafe {\n             mem::transmute(RawSlice {\n-                data: self.as_mut_ptr() as *const T,\n+                data: self.ptr as *const T,\n                 len: self.len,\n             })\n         }\n@@ -799,134 +799,17 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// let mut vec = vec![1i, 2, 3];\n     /// *vec.get_mut(1) = 4;\n     /// assert_eq!(vec, vec![1i, 4, 3]);\n     /// ```\n     #[inline]\n-    #[unstable = \"this is likely to be moved to actual indexing\"]\n+    #[deprecated = \"use `foo[index] = bar` instead\"]\n     pub fn get_mut<'a>(&'a mut self, index: uint) -> &'a mut T {\n         &mut self.as_mut_slice()[index]\n     }\n \n-    /// Returns an iterator over references to the elements of the vector in\n-    /// order.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let vec = vec![1i, 2, 3];\n-    /// for num in vec.iter() {\n-    ///     println!(\"{}\", *num);\n-    /// }\n-    /// ```\n-    #[inline]\n-    pub fn iter<'a>(&'a self) -> Items<'a,T> {\n-        self.as_slice().iter()\n-    }\n-\n-    /// Returns an iterator over mutable references to the elements of the\n-    /// vector in order.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let mut vec = vec![1i, 2, 3];\n-    /// for num in vec.iter_mut() {\n-    ///     *num = 0;\n-    /// }\n-    /// assert_eq!(vec, vec![0i, 0, 0]);\n-    /// ```\n-    #[inline]\n-    pub fn iter_mut<'a>(&'a mut self) -> MutItems<'a,T> {\n-        self.as_mut_slice().iter_mut()\n-    }\n-\n-    /// Sorts the vector, in place, using `compare` to compare elements.\n-    ///\n-    /// This sort is `O(n log n)` worst-case and stable, but allocates\n-    /// approximately `2 * n`, where `n` is the length of `self`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let mut v = vec![5i, 4, 1, 3, 2];\n-    /// v.sort_by(|a, b| a.cmp(b));\n-    /// assert_eq!(v, vec![1i, 2, 3, 4, 5]);\n-    ///\n-    /// // reverse sorting\n-    /// v.sort_by(|a, b| b.cmp(a));\n-    /// assert_eq!(v, vec![5i, 4, 3, 2, 1]);\n-    /// ```\n-    #[inline]\n-    pub fn sort_by(&mut self, compare: |&T, &T| -> Ordering) {\n-        self.as_mut_slice().sort_by(compare)\n-    }\n-\n-    /// Returns a slice of self spanning the interval [`start`, `end`).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails when the slice (or part of it) is outside the bounds of self, or when\n-    /// `start` > `end`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec[0..2] == [1, 2]);\n-    /// ```\n-    #[inline]\n-    pub fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T] {\n-        self[start..end]\n-    }\n-\n-    /// Returns a slice containing all but the first element of the vector.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails when the vector is empty.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let vec = vec![1i, 2, 3];\n-    /// assert!(vec.tail() == [2, 3]);\n-    /// ```\n-    #[inline]\n-    pub fn tail<'a>(&'a self) -> &'a [T] {\n-        self[].tail()\n-    }\n-\n-    /// Returns a reference to the last element of a vector, or `None` if it is\n-    /// empty.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let vec = vec![1i, 2, 3];\n-    /// assert!(vec.last() == Some(&3));\n-    /// ```\n-    #[inline]\n-    pub fn last<'a>(&'a self) -> Option<&'a T> {\n-        self[].last()\n-    }\n-\n-    /// Returns a mutable reference to the last element of a vector, or `None`\n-    /// if it is empty.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let mut vec = vec![1i, 2, 3];\n-    /// *vec.last_mut().unwrap() = 4;\n-    /// assert_eq!(vec, vec![1i, 2, 4]);\n-    /// ```\n-    #[inline]\n-    pub fn last_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n-        self.as_mut_slice().last_mut()\n-    }\n-\n     /// Removes an element from anywhere in the vector and return it, replacing\n     /// it with the last element. This does not preserve ordering, but is O(1).\n     ///\n@@ -1035,215 +918,6 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Returns a mutable slice of `self` between `start` and `end`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails when `start` or `end` point outside the bounds of `self`, or when\n-    /// `start` > `end`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let mut vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec[mut 0..2] == [1, 2]);\n-    /// ```\n-    #[inline]\n-    pub fn slice_mut<'a>(&'a mut self, start: uint, end: uint)\n-                         -> &'a mut [T] {\n-        self[mut start..end]\n-    }\n-\n-    /// Returns a mutable slice of `self` from `start` to the end of the `Vec`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails when `start` points outside the bounds of self.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let mut vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec[mut 2..] == [3, 4]);\n-    /// ```\n-    #[inline]\n-    pub fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n-        self[mut start..]\n-    }\n-\n-    /// Returns a mutable slice of `self` from the start of the `Vec` to `end`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails when `end` points outside the bounds of self.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let mut vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec[mut ..2] == [1, 2]);\n-    /// ```\n-    #[inline]\n-    pub fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n-        self[mut ..end]\n-    }\n-\n-    /// Returns a pair of mutable slices that divides the `Vec` at an index.\n-    ///\n-    /// The first will contain all indices from `[0, mid)` (excluding\n-    /// the index `mid` itself) and the second will contain all\n-    /// indices from `[mid, len)` (excluding the index `len` itself).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if `mid > len`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let mut vec = vec![1i, 2, 3, 4, 5, 6];\n-    ///\n-    /// // scoped to restrict the lifetime of the borrows\n-    /// {\n-    ///    let (left, right) = vec.split_at_mut(0);\n-    ///    assert!(left == &mut []);\n-    ///    assert!(right == &mut [1, 2, 3, 4, 5, 6]);\n-    /// }\n-    ///\n-    /// {\n-    ///     let (left, right) = vec.split_at_mut(2);\n-    ///     assert!(left == &mut [1, 2]);\n-    ///     assert!(right == &mut [3, 4, 5, 6]);\n-    /// }\n-    ///\n-    /// {\n-    ///     let (left, right) = vec.split_at_mut(6);\n-    ///     assert!(left == &mut [1, 2, 3, 4, 5, 6]);\n-    ///     assert!(right == &mut []);\n-    /// }\n-    /// ```\n-    #[inline]\n-    pub fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n-        self[mut].split_at_mut(mid)\n-    }\n-\n-    /// Reverses the order of elements in a vector, in place.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let mut v = vec![1i, 2, 3];\n-    /// v.reverse();\n-    /// assert_eq!(v, vec![3i, 2, 1]);\n-    /// ```\n-    #[inline]\n-    pub fn reverse(&mut self) {\n-        self[mut].reverse()\n-    }\n-\n-    /// Returns a slice of `self` from `start` to the end of the vec.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails when `start` points outside the bounds of self.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let vec = vec![1i, 2, 3];\n-    /// assert!(vec[1..] == [2, 3]);\n-    /// ```\n-    #[inline]\n-    pub fn slice_from<'a>(&'a self, start: uint) -> &'a [T] {\n-        self[start..]\n-    }\n-\n-    /// Returns a slice of self from the start of the vec to `end`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails when `end` points outside the bounds of self.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec[..2] == [1, 2]);\n-    /// ```\n-    #[inline]\n-    pub fn slice_to<'a>(&'a self, end: uint) -> &'a [T] {\n-        self[..end]\n-    }\n-\n-    /// Returns a slice containing all but the last element of the vector.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the vector is empty\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let vec = vec![1i, 2, 3];\n-    /// assert!(vec.init() == [1, 2]);\n-    /// ```\n-    #[inline]\n-    pub fn init<'a>(&'a self) -> &'a [T] {\n-        self[0..self.len() - 1]\n-    }\n-\n-\n-    /// Returns an unsafe pointer to the vector's buffer.\n-    ///\n-    /// The caller must ensure that the vector outlives the pointer this\n-    /// function returns, or else it will end up pointing to garbage.\n-    ///\n-    /// Modifying the vector may cause its buffer to be reallocated, which\n-    /// would also make any pointers to it invalid.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let v = vec![1i, 2, 3];\n-    /// let p = v.as_ptr();\n-    /// unsafe {\n-    ///     // Examine each element manually\n-    ///     assert_eq!(*p, 1i);\n-    ///     assert_eq!(*p.offset(1), 2i);\n-    ///     assert_eq!(*p.offset(2), 3i);\n-    /// }\n-    /// ```\n-    #[inline]\n-    pub fn as_ptr(&self) -> *const T {\n-        self.ptr as *const T\n-    }\n-\n-    /// Returns a mutable unsafe pointer to the vector's buffer.\n-    ///\n-    /// The caller must ensure that the vector outlives the pointer this\n-    /// function returns, or else it will end up pointing to garbage.\n-    ///\n-    /// Modifying the vector may cause its buffer to be reallocated, which\n-    /// would also make any pointers to it invalid.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::ptr;\n-    ///\n-    /// let mut v = vec![1i, 2, 3];\n-    /// let p = v.as_mut_ptr();\n-    /// unsafe {\n-    ///     ptr::write(p, 9i);\n-    ///     ptr::write(p.offset(2), 5i);\n-    /// }\n-    /// assert_eq!(v, vec![9i, 2, 5]);\n-    /// ```\n-    #[inline]\n-    pub fn as_mut_ptr(&mut self) -> *mut T {\n-        self.ptr\n-    }\n-\n     /// Retains only the elements specified by the predicate.\n     ///\n     /// In other words, remove all elements `e` such that `f(&e)` returns false.\n@@ -1297,24 +971,6 @@ impl<T> Vec<T> {\n     }\n }\n \n-impl<T:Ord> Vec<T> {\n-    /// Sorts the vector in place.\n-    ///\n-    /// This sort is `O(n log n)` worst-case and stable, but allocates\n-    /// approximately `2 * n`, where `n` is the length of `self`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let mut vec = vec![3i, 1, 2];\n-    /// vec.sort();\n-    /// assert_eq!(vec, vec![1, 2, 3]);\n-    /// ```\n-    pub fn sort(&mut self) {\n-        self.as_mut_slice().sort()\n-    }\n-}\n-\n #[experimental = \"waiting on Mutable stability\"]\n impl<T> Mutable for Vec<T> {\n     #[inline]\n@@ -1325,19 +981,6 @@ impl<T> Mutable for Vec<T> {\n }\n \n impl<T: PartialEq> Vec<T> {\n-    /// Returns true if a vector contains an element equal to the given value.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let vec = vec![1i, 2, 3];\n-    /// assert!(vec.contains(&1));\n-    /// ```\n-    #[inline]\n-    pub fn contains(&self, x: &T) -> bool {\n-        self.as_slice().contains(x)\n-    }\n-\n     /// Removes consecutive repeated elements in the vector.\n     ///\n     /// If the vector is sorted, this removes all duplicates.\n@@ -1449,7 +1092,12 @@ impl<T> AsSlice<T> for Vec<T> {\n     #[inline]\n     #[stable]\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n-        unsafe { mem::transmute(RawSlice { data: self.as_ptr(), len: self.len }) }\n+        unsafe {\n+            mem::transmute(RawSlice {\n+                data: self.ptr as *const T,\n+                len: self.len\n+            })\n+        }\n     }\n }\n \n@@ -1697,6 +1345,7 @@ pub fn as_vec<'a, T>(x: &'a [T]) -> DerefVec<'a, T> {\n pub mod raw {\n     use super::Vec;\n     use core::ptr;\n+    use core::slice::MutableSlice;\n \n     /// Constructs a vector from an unsafe pointer to a buffer.\n     ///"}, {"sha": "b8a91a912ba3c96e7201c4db7246e485603a8167", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(missing_doc)]\n+#![allow(missing_docs)]\n \n use char;\n use collections::Collection;"}, {"sha": "65107d6ab7d832556cb0e6e038407dfa92efdb4a", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -10,7 +10,7 @@\n \n //! Utilities for formatting and printing strings\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n use any;\n use cell::{Cell, Ref, RefMut};\n@@ -733,7 +733,7 @@ macro_rules! tuple (\n     () => ();\n     ( $($name:ident,)+ ) => (\n         impl<$($name:Show),*> Show for ($($name,)*) {\n-            #[allow(non_snake_case, dead_assignment)]\n+            #[allow(non_snake_case, unused_assignments)]\n             fn fmt(&self, f: &mut Formatter) -> Result {\n                 try!(write!(f, \"(\"));\n                 let ($(ref $name,)*) = *self;"}, {"sha": "568528f6ae29ee2ab0208b477a8e26906e2d48a3", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -12,7 +12,7 @@\n \n // FIXME: #6220 Implement floating point formatting\n \n-#![allow(unsigned_negate)]\n+#![allow(unsigned_negation)]\n \n use collections::Collection;\n use fmt;"}, {"sha": "9d5c2113cb2565c12949b33e1b40c57f3f389bca", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 98, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -42,7 +42,7 @@ A quick refresher on memory ordering:\n */\n \n #![experimental]\n-#![allow(missing_doc)]\n+#![allow(missing_docs)]\n \n pub type GlueFn = extern \"Rust\" fn(*const i8);\n \n@@ -57,107 +57,10 @@ pub struct TyDesc {\n     // Called when a value of type `T` is no longer needed\n     pub drop_glue: GlueFn,\n \n-    // Called by reflection visitor to visit a value of type `T`\n-    #[cfg(stage0)]\n-    pub visit_glue: GlueFn,\n-\n     // Name corresponding to the type\n     pub name: &'static str,\n }\n \n-#[cfg(stage0)]\n-#[lang=\"opaque\"]\n-pub enum Opaque { }\n-\n-#[cfg(stage0)]\n-pub type Disr = u64;\n-\n-#[cfg(stage0)]\n-#[lang=\"ty_visitor\"]\n-pub trait TyVisitor {\n-    fn visit_bot(&mut self) -> bool;\n-    fn visit_nil(&mut self) -> bool;\n-    fn visit_bool(&mut self) -> bool;\n-\n-    fn visit_int(&mut self) -> bool;\n-    fn visit_i8(&mut self) -> bool;\n-    fn visit_i16(&mut self) -> bool;\n-    fn visit_i32(&mut self) -> bool;\n-    fn visit_i64(&mut self) -> bool;\n-\n-    fn visit_uint(&mut self) -> bool;\n-    fn visit_u8(&mut self) -> bool;\n-    fn visit_u16(&mut self) -> bool;\n-    fn visit_u32(&mut self) -> bool;\n-    fn visit_u64(&mut self) -> bool;\n-\n-    fn visit_f32(&mut self) -> bool;\n-    fn visit_f64(&mut self) -> bool;\n-\n-    fn visit_char(&mut self) -> bool;\n-\n-    fn visit_estr_slice(&mut self) -> bool;\n-\n-    fn visit_box(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;\n-    fn visit_uniq(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;\n-    fn visit_ptr(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;\n-    fn visit_rptr(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;\n-\n-    fn visit_evec_slice(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;\n-    fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,\n-                        inner: *const TyDesc) -> bool;\n-\n-    fn visit_enter_rec(&mut self, n_fields: uint,\n-                       sz: uint, align: uint) -> bool;\n-    fn visit_rec_field(&mut self, i: uint, name: &str,\n-                       mtbl: uint, inner: *const TyDesc) -> bool;\n-    fn visit_leave_rec(&mut self, n_fields: uint,\n-                       sz: uint, align: uint) -> bool;\n-\n-    fn visit_enter_class(&mut self, name: &str, named_fields: bool, n_fields: uint,\n-                         sz: uint, align: uint) -> bool;\n-    fn visit_class_field(&mut self, i: uint, name: &str, named: bool,\n-                         mtbl: uint, inner: *const TyDesc) -> bool;\n-    fn visit_leave_class(&mut self, name: &str, named_fields: bool, n_fields: uint,\n-                         sz: uint, align: uint) -> bool;\n-\n-    fn visit_enter_tup(&mut self, n_fields: uint,\n-                       sz: uint, align: uint) -> bool;\n-    fn visit_tup_field(&mut self, i: uint, inner: *const TyDesc) -> bool;\n-    fn visit_leave_tup(&mut self, n_fields: uint,\n-                       sz: uint, align: uint) -> bool;\n-\n-    fn visit_enter_enum(&mut self, n_variants: uint,\n-                        get_disr: unsafe extern fn(ptr: *const Opaque) -> Disr,\n-                        sz: uint, align: uint) -> bool;\n-    fn visit_enter_enum_variant(&mut self, variant: uint,\n-                                disr_val: Disr,\n-                                n_fields: uint,\n-                                name: &str) -> bool;\n-    fn visit_enum_variant_field(&mut self, i: uint, offset: uint,\n-                                inner: *const TyDesc) -> bool;\n-    fn visit_leave_enum_variant(&mut self, variant: uint,\n-                                disr_val: Disr,\n-                                n_fields: uint,\n-                                name: &str) -> bool;\n-    fn visit_leave_enum(&mut self, n_variants: uint,\n-                        get_disr: unsafe extern fn(ptr: *const Opaque) -> Disr,\n-                        sz: uint, align: uint) -> bool;\n-\n-    fn visit_enter_fn(&mut self, purity: uint, proto: uint,\n-                      n_inputs: uint, retstyle: uint) -> bool;\n-    fn visit_fn_input(&mut self, i: uint, mode: uint,\n-                      inner: *const TyDesc) -> bool;\n-    fn visit_fn_output(&mut self, retstyle: uint, variadic: bool,\n-                       converging: bool, inner: *const TyDesc) -> bool;\n-    fn visit_leave_fn(&mut self, purity: uint, proto: uint,\n-                      n_inputs: uint, retstyle: uint) -> bool;\n-\n-    fn visit_trait(&mut self, name: &str) -> bool;\n-    fn visit_param(&mut self, i: uint) -> bool;\n-    fn visit_self(&mut self) -> bool;\n-}\n-\n extern \"rust-intrinsic\" {\n \n     // NB: These intrinsics take unsafe pointers because they mutate aliased"}, {"sha": "a7be23e53e074012dbc50863b1b2df7241c6cdda", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -60,7 +60,7 @@\n #![allow(unknown_features)]\n #![feature(globs, intrinsics, lang_items, macro_rules, phase)]\n #![feature(simd, unsafe_destructor, slicing_syntax)]\n-#![deny(missing_doc)]\n+#![deny(missing_docs)]\n \n mod macros;\n "}, {"sha": "521085bca7638a0c84f7758b24568dba7a3d2b85", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -12,7 +12,7 @@\n \n #![doc(primitive = \"f32\")]\n // FIXME: MIN_VALUE and MAX_VALUE literals are parsed as -inf and inf #14353\n-#![allow(type_overflow)]\n+#![allow(overflowing_literals)]\n \n use intrinsics;\n use mem;"}, {"sha": "78065d7803e0b610c53b9f21233aee07da752ee9", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -12,7 +12,7 @@\n \n #![doc(primitive = \"f64\")]\n // FIXME: MIN_VALUE and MAX_VALUE literals are parsed as -inf and inf #14353\n-#![allow(type_overflow)]\n+#![allow(overflowing_literals)]\n \n use intrinsics;\n use mem;"}, {"sha": "a177b89058c8bc172c8f7a8c127e6d1671e4c9e3", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -12,7 +12,7 @@\n \n //! Numeric traits and functions for generic mathematics\n \n-#![allow(missing_doc)]\n+#![allow(missing_docs)]\n \n use intrinsics;\n use {int, i8, i16, i32, i64};\n@@ -1353,7 +1353,7 @@ checked_impl!(CheckedMul, checked_mul, i64, intrinsics::i64_mul_with_overflow)\n /// wrapping around on underflow and overflow.\n pub trait CheckedDiv: Div<Self, Self> {\n     /// Divides two numbers, checking for underflow, overflow and division by zero. If any of that\n-    /// happens, / `None` is returned.\n+    /// happens, `None` is returned.\n     ///\n     /// # Example\n     ///\n@@ -1502,7 +1502,7 @@ pub trait Float: Signed + Primitive {\n \n     /// Take the square root of a number.\n     ///\n-    /// Returns NaN if `self` is not a non-negative number.\n+    /// Returns NaN if `self` is a negative number.\n     fn sqrt(self) -> Self;\n     /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n     fn rsqrt(self) -> Self;"}, {"sha": "39de04c27cecb15e0b857ff2f3ecf55e9078d149", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -28,7 +28,7 @@\n //! one function. Currently, the actual symbol is declared in the standard\n //! library, but the location of this may change over time.\n \n-#![allow(dead_code, missing_doc)]\n+#![allow(dead_code, missing_docs)]\n \n use fmt;\n use intrinsics;\n@@ -63,7 +63,7 @@ fn panic_bounds_check(file_line: &(&'static str, uint),\n #[cfg(stage0)]\n #[cold] #[inline(never)]\n pub fn panic_fmt(fmt: &fmt::Arguments, file_line: &(&'static str, uint)) -> ! {\n-    #[allow(ctypes)]\n+    #[allow(improper_ctypes)]\n     extern {\n         #[lang = \"fail_fmt\"]\n         fn panic_impl(fmt: &fmt::Arguments, file: &'static str,\n@@ -104,7 +104,7 @@ fn panic_bounds_check(file_line: &(&'static str, uint),\n #[cfg(not(stage0))]\n #[cold] #[inline(never)]\n pub fn panic_fmt(fmt: &fmt::Arguments, file_line: &(&'static str, uint)) -> ! {\n-    #[allow(ctypes)]\n+    #[allow(improper_ctypes)]\n     extern {\n         #[lang = \"panic_fmt\"]\n         fn panic_impl(fmt: &fmt::Arguments, file: &'static str,"}, {"sha": "d156f71462dd1dda740e1d3791a546e132528f17", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(missing_doc)]\n+#![allow(missing_docs)]\n #![experimental]\n \n //! Contains struct definitions for the layout of compiler built-in types."}, {"sha": "2b6f97cf6a5c4102468fd6b83688ac3d1253d149", "filename": "src/libcore/simd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcore%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcore%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsimd.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -35,7 +35,7 @@\n //! warning.\n \n #![allow(non_camel_case_types)]\n-#![allow(missing_doc)]\n+#![allow(missing_docs)]\n \n #[experimental]\n #[simd]"}, {"sha": "433a3ce1109add127c8e068f6c0ec9935af24861", "filename": "src/libcore/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -768,7 +768,7 @@ Section: Comparing strings\n /// to compare &[u8] byte slices that are not necessarily valid UTF-8.\n #[inline]\n fn eq_slice_(a: &str, b: &str) -> bool {\n-    #[allow(ctypes)]\n+    #[allow(improper_ctypes)]\n     extern { fn memcmp(s1: *const i8, s2: *const i8, n: uint) -> i32; }\n     a.len() == b.len() && unsafe {\n         memcmp(a.as_ptr() as *const i8,\n@@ -1118,7 +1118,7 @@ pub mod raw {\n Section: Trait implementations\n */\n \n-#[allow(missing_doc)]\n+#[allow(missing_docs)]\n pub mod traits {\n     use cmp::{Ord, Ordering, Less, Equal, Greater, PartialEq, PartialOrd, Equiv, Eq};\n     use collections::Collection;"}, {"sha": "56ea7a4e7a1e98f724d6b50ea07b86d8d91b8f33", "filename": "src/libcore/tuple/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcore%2Ftuple%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcore%2Ftuple%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple%2Fmod.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -81,7 +81,7 @@ macro_rules! tuple_impls {\n         }\n     )+) => {\n         $(\n-            #[allow(missing_doc)]\n+            #[allow(missing_docs)]\n             #[stable]\n             pub trait $Tuple<$($T),+> {\n                 $(\n@@ -97,21 +97,21 @@ macro_rules! tuple_impls {\n             impl<$($T),+> $Tuple<$($T),+> for ($($T,)+) {\n                 $(\n                     #[inline]\n-                    #[allow(unused_variable)]\n+                    #[allow(unused_variables)]\n                     #[unstable = \"may rename pending accessor naming conventions\"]\n                     fn $valN(self) -> $T {\n                         let ($($x,)+) = self; $ret\n                     }\n \n                     #[inline]\n-                    #[allow(unused_variable)]\n+                    #[allow(unused_variables)]\n                     #[unstable = \"may rename pending accessor naming conventions\"]\n                     fn $refN<'a>(&'a self) -> &'a $T {\n                         let ($(ref $x,)+) = *self; $ret\n                     }\n \n                     #[inline]\n-                    #[allow(unused_variable)]\n+                    #[allow(unused_variables)]\n                     #[unstable = \"may rename pending accessor naming conventions\"]\n                     fn $mutN<'a>(&'a mut self) -> &'a mut $T {\n                         let ($(ref mut $x,)+) = *self; $ret"}, {"sha": "868e14b928a40cebf3a88cd759435ba4dbeb84ce", "filename": "src/libcoretest/fmt/num.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcoretest%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcoretest%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Fnum.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -7,7 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![allow(unsigned_negate)]\n+#![allow(unsigned_negation)]\n \n use core::fmt::radix;\n "}, {"sha": "d3f77c47c44bcb7845ea26ac56e1751d724cdf80", "filename": "src/libcoretest/str.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcoretest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibcoretest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fstr.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -38,3 +38,72 @@ fn test_strslice_contains() {\n     let x = \"There are moments, Jeeves, when one asks oneself, 'Do trousers matter?'\";\n     check_contains_all_substrings(x);\n }\n+\n+#[test]\n+fn test_rsplitn_char_iterator() {\n+    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+    let mut split: Vec<&str> = data.rsplitn(3, ' ').collect();\n+    split.reverse();\n+    assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+    let mut split: Vec<&str> = data.rsplitn(3, |c: char| c == ' ').collect();\n+    split.reverse();\n+    assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+    // Unicode\n+    let mut split: Vec<&str> = data.rsplitn(3, '\u00e4').collect();\n+    split.reverse();\n+    assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+\n+    let mut split: Vec<&str> = data.rsplitn(3, |c: char| c == '\u00e4').collect();\n+    split.reverse();\n+    assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+}\n+\n+#[test]\n+fn test_split_char_iterator() {\n+    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+    let split: Vec<&str> = data.split(' ').collect();\n+    assert_eq!( split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+    let mut rsplit: Vec<&str> = data.split(' ').rev().collect();\n+    rsplit.reverse();\n+    assert_eq!(rsplit, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+    let split: Vec<&str> = data.split(|c: char| c == ' ').collect();\n+    assert_eq!( split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+    let mut rsplit: Vec<&str> = data.split(|c: char| c == ' ').rev().collect();\n+    rsplit.reverse();\n+    assert_eq!(rsplit, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+    // Unicode\n+    let split: Vec<&str> = data.split('\u00e4').collect();\n+    assert_eq!( split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+\n+    let mut rsplit: Vec<&str> = data.split('\u00e4').rev().collect();\n+    rsplit.reverse();\n+    assert_eq!(rsplit, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+\n+    let split: Vec<&str> = data.split(|c: char| c == '\u00e4').collect();\n+    assert_eq!( split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+\n+    let mut rsplit: Vec<&str> = data.split(|c: char| c == '\u00e4').rev().collect();\n+    rsplit.reverse();\n+    assert_eq!(rsplit, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+}\n+\n+#[test]\n+fn test_rev_split_char_iterator_no_trailing() {\n+    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+    let mut split: Vec<&str> = data.split('\\n').rev().collect();\n+    split.reverse();\n+    assert_eq!(split, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n+\n+    let mut split: Vec<&str> = data.split_terminator('\\n').rev().collect();\n+    split.reverse();\n+    assert_eq!(split, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n+}"}, {"sha": "906ca45fcc85efa3a989ac6c68a64588c44b6565", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -89,7 +89,7 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![feature(globs, phase)]\n #![feature(import_shadowing)]\n-#![deny(missing_doc)]\n+#![deny(missing_docs)]\n \n #[cfg(test)] #[phase(plugin, link)] extern crate log;\n \n@@ -201,7 +201,7 @@ pub enum Fail_ {\n \n /// The type of failure that occurred.\n #[deriving(PartialEq, Eq)]\n-#[allow(missing_doc)]\n+#[allow(missing_docs)]\n pub enum FailType {\n     ArgumentMissing_,\n     UnrecognizedOption_,\n@@ -614,29 +614,29 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                     if name_pos == names.len() && !i_arg.is_none() {\n                         return Err(UnexpectedArgument(nm.to_string()));\n                     }\n-                    vals.get_mut(optid).push(Given);\n+                    vals[optid].push(Given);\n                   }\n                   Maybe => {\n                     if !i_arg.is_none() {\n-                        vals.get_mut(optid)\n+                        vals[optid]\n                             .push(Val((i_arg.clone())\n                             .unwrap()));\n                     } else if name_pos < names.len() || i + 1 == l ||\n                             is_arg(args[i + 1].as_slice()) {\n-                        vals.get_mut(optid).push(Given);\n+                        vals[optid].push(Given);\n                     } else {\n                         i += 1;\n-                        vals.get_mut(optid).push(Val(args[i].clone()));\n+                        vals[optid].push(Val(args[i].clone()));\n                     }\n                   }\n                   Yes => {\n                     if !i_arg.is_none() {\n-                        vals.get_mut(optid).push(Val(i_arg.clone().unwrap()));\n+                        vals[optid].push(Val(i_arg.clone().unwrap()));\n                     } else if i + 1 == l {\n                         return Err(ArgumentMissing(nm.to_string()));\n                     } else {\n                         i += 1;\n-                        vals.get_mut(optid).push(Val(args[i].clone()));\n+                        vals[optid].push(Val(args[i].clone()));\n                     }\n                   }\n                 }"}, {"sha": "a4d794d1f99fb0a0ce9a6c2f99b37feee4ee26a5", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -58,7 +58,7 @@ impl<'a,T> IntoMaybeOwnedVector<'a,T> for &'a [T] {\n impl<'a,T> MaybeOwnedVector<'a,T> {\n     pub fn iter(&'a self) -> slice::Items<'a,T> {\n         match self {\n-            &Growable(ref v) => v.iter(),\n+            &Growable(ref v) => v.as_slice().iter(),\n             &Borrowed(ref v) => v.iter(),\n         }\n     }"}, {"sha": "6756d4b21ff78153a07fd3ffa2c501a567538868", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -75,8 +75,8 @@\n \n #![allow(non_camel_case_types)]\n #![allow(non_snake_case)]\n-#![allow(non_uppercase_statics)]\n-#![allow(missing_doc)]\n+#![allow(non_upper_case_globals)]\n+#![allow(missing_docs)]\n #![allow(non_snake_case)]\n \n extern crate core;"}, {"sha": "b626b66427df3580a56f926b7ffe37382db278d1", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -167,7 +167,7 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![feature(macro_rules)]\n-#![deny(missing_doc)]\n+#![deny(missing_docs)]\n \n extern crate regex;\n "}, {"sha": "ee6aa26ede22c60cf4355e5328292ffe54f9d937", "filename": "src/libnative/io/c_windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibnative%2Fio%2Fc_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibnative%2Fio%2Fc_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_windows.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -10,7 +10,7 @@\n \n //! C definitions used by libnative that don't belong in liblibc\n \n-#![allow(type_overflow)]\n+#![allow(overflowing_literals)]\n \n use libc;\n "}, {"sha": "c17c541fc01e64a0c558e8979c83deaa6ea29824", "filename": "src/libnative/io/timer_windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibnative%2Fio%2Ftimer_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibnative%2Fio%2Ftimer_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_windows.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -79,7 +79,7 @@ fn helper(input: libc::HANDLE, messages: Receiver<Req>, _: ()) {\n             }\n         } else {\n             let remove = {\n-                match chans.get_mut(idx as uint - 1) {\n+                match &mut chans[idx as uint - 1] {\n                     &(ref mut c, oneshot) => { c.call(); oneshot }\n                 }\n             };"}, {"sha": "c0ec4c16ab01fd90b7d0dba4bb1d2b2b355c2538", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -55,7 +55,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![deny(unused_result, unused_must_use)]\n+#![deny(unused_results, unused_must_use)]\n #![allow(non_camel_case_types)]\n #![allow(unknown_features)]\n #![feature(default_type_params, lang_items, slicing_syntax)]"}, {"sha": "49d60a98b64962a5c14b5169742e307691770422", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -118,7 +118,7 @@ impl IsaacRng {\n \n     /// Refills the output buffer (`self.rsl`)\n     #[inline]\n-    #[allow(unsigned_negate)]\n+    #[allow(unsigned_negation)]\n     fn isaac(&mut self) {\n         self.c += 1;\n         // abbreviations"}, {"sha": "95b6d9a17dd1875e64e61a55d597a976a39d9eda", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -26,7 +26,7 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![allow(unknown_features)]\n #![feature(macro_rules, phase, slicing_syntax)]\n-#![allow(missing_doc)]\n+#![allow(missing_docs)]\n \n extern crate serialize;\n "}, {"sha": "2b82b620e3968da2a9115881a29ffce1527121fd", "filename": "src/libregex/compile.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibregex%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibregex%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fcompile.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -157,7 +157,7 @@ impl<'r> Compiler<'r> {\n                 if cap >= len {\n                     self.names.grow(10 + cap - len, None)\n                 }\n-                *self.names.get_mut(cap) = name;\n+                self.names[cap] = name;\n \n                 self.push(Save(2 * cap));\n                 self.compile(*x);\n@@ -243,7 +243,7 @@ impl<'r> Compiler<'r> {\n     /// `panic!` is called.\n     #[inline]\n     fn set_split(&mut self, i: InstIdx, pc1: InstIdx, pc2: InstIdx) {\n-        let split = self.insts.get_mut(i);\n+        let split = &mut self.insts[i];\n         match *split {\n             Split(_, _) => *split = Split(pc1, pc2),\n             _ => panic!(\"BUG: Invalid split index.\"),\n@@ -263,7 +263,7 @@ impl<'r> Compiler<'r> {\n     /// `panic!` is called.\n     #[inline]\n     fn set_jump(&mut self, i: InstIdx, pc: InstIdx) {\n-        let jmp = self.insts.get_mut(i);\n+        let jmp = &mut self.insts[i];\n         match *jmp {\n             Jump(_) => *jmp = Jump(pc),\n             _ => panic!(\"BUG: Invalid jump index.\"),"}, {"sha": "f3633a006b13eb98da33ff3b9d5e1483c210699e", "filename": "src/libregex/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -370,7 +370,7 @@\n \n #![allow(unknown_features)]\n #![feature(macro_rules, phase, slicing_syntax)]\n-#![deny(missing_doc)]\n+#![deny(missing_docs)]\n \n #[cfg(test)]\n extern crate \"test\" as stdtest;"}, {"sha": "3115161682f02b192f11d988478a9297e8555dbf", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -978,7 +978,7 @@ fn combine_ranges(unordered: Vec<(char, char)>) -> Vec<(char, char)> {\n         }\n         match which {\n             None => ordered.push((us, ue)),\n-            Some(i) => *ordered.get_mut(i) = (us, ue),\n+            Some(i) => ordered[i] = (us, ue),\n         }\n     }\n     ordered.sort();"}, {"sha": "ce06828e7643fbc6b7e54c7ff3476aa7f9a9c0dd", "filename": "src/libregex/vm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibregex%2Fvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibregex%2Fvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fvm.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -461,21 +461,21 @@ impl Threads {\n     }\n \n     fn add(&mut self, pc: uint, groups: &[Option<uint>], empty: bool) {\n-        let t = self.queue.get_mut(self.size);\n+        let t = &mut self.queue[self.size];\n         t.pc = pc;\n         match (empty, self.which) {\n             (_, Exists) | (true, _) => {},\n             (false, Location) => {\n-                *t.groups.get_mut(0) = groups[0];\n-                *t.groups.get_mut(1) = groups[1];\n+                t.groups[0] = groups[0];\n+                t.groups[1] = groups[1];\n             }\n             (false, Submatches) => {\n                 for (slot, val) in t.groups.iter_mut().zip(groups.iter()) {\n                     *slot = *val;\n                 }\n             }\n         }\n-        *self.sparse.get_mut(pc) = self.size;\n+        self.sparse[pc] = self.size;\n         self.size += 1;\n     }\n \n@@ -497,7 +497,7 @@ impl Threads {\n \n     #[inline]\n     fn groups<'r>(&'r mut self, i: uint) -> &'r mut [Option<uint>] {\n-        self.queue.get_mut(i).groups.as_mut_slice()\n+        self.queue[i].groups.as_mut_slice()\n     }\n }\n "}, {"sha": "3cc6d361e3c58992bbc62d3dfc1cef160d839c89", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -179,7 +179,7 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n     }\n \n     impl<'t> Nfa<'t> {\n-        #[allow(unused_variable)]\n+        #[allow(unused_variables)]\n         fn run(&mut self, start: uint, end: uint) -> Vec<Option<uint>> {\n             let mut matched = false;\n             let prefix_bytes: &[u8] = $prefix_bytes;\n@@ -226,7 +226,7 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n         }\n \n         // Sometimes `nlist` is never used (for empty regexes).\n-        #[allow(unused_variable)]\n+        #[allow(unused_variables)]\n         #[inline]\n         fn step(&self, groups: &mut Captures, nlist: &mut Threads,\n                 caps: &mut Captures, pc: uint) -> StepState {"}, {"sha": "031fc731f41c1f858dc1ba6b240f3237a8d57150", "filename": "src/librustc/back/write.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fwrite.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -226,12 +226,10 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n         }\n     };\n \n-    unsafe {\n-        sess.targ_cfg\n-             .target_strs\n-             .target_triple\n-             .as_slice()\n-             .with_c_str(|t| {\n+    let triple = sess.targ_cfg.target_strs.target_triple.as_slice();\n+\n+    let tm = unsafe {\n+            triple.with_c_str(|t| {\n             sess.opts.cg.target_cpu.as_slice().with_c_str(|cpu| {\n                 target_feature(sess).with_c_str(|features| {\n                     llvm::LLVMRustCreateTargetMachine(\n@@ -249,7 +247,15 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n                 })\n             })\n         })\n-    }\n+    };\n+\n+    if tm.is_null() {\n+        llvm_err(sess.diagnostic().handler(),\n+                 format!(\"Could not create LLVM TargetMachine for triple: {}\",\n+                         triple).to_string());\n+    } else {\n+        return tm;\n+    };\n }\n \n "}, {"sha": "ace5ba26fdbaa9d3196daa34eb953b7e2e13d105", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -498,7 +498,7 @@ pub fn get_os(triple: &str) -> Option<abi::Os> {\n     }\n     None\n }\n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n static os_names : &'static [(&'static str, abi::Os)] = &[\n     (\"mingw32\",   abi::OsWindows),\n     (\"win32\",     abi::OsWindows),\n@@ -516,7 +516,7 @@ pub fn get_arch(triple: &str) -> Option<abi::Architecture> {\n     }\n     None\n }\n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n static architecture_abis : &'static [(&'static str, abi::Architecture)] = &[\n     (\"i386\",   abi::X86),\n     (\"i486\",   abi::X86),"}, {"sha": "028d0ec607ab66832c5d08fee2a1fcc33da242c9", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -255,7 +255,8 @@ Available lint options:\n         for (name, to) in lints.into_iter() {\n             let name = name.chars().map(|x| x.to_lowercase())\n                            .collect::<String>().replace(\"_\", \"-\");\n-            let desc = to.into_iter().map(|x| x.as_str()).collect::<Vec<String>>().connect(\", \");\n+            let desc = to.into_iter().map(|x| x.as_str().replace(\"_\", \"-\"))\n+                         .collect::<Vec<String>>().connect(\", \");\n             println!(\"    {}  {}\",\n                      padded(name.as_slice()), desc);\n         }"}, {"sha": "3e53620cbd4757ff9a26e299b42b77b839c5c707", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -1021,7 +1021,7 @@ declare_lint!(UNUSED_PARENS, Warn,\n pub struct UnusedParens;\n \n impl UnusedParens {\n-    fn check_unnecessary_parens_core(&self, cx: &Context, value: &ast::Expr, msg: &str,\n+    fn check_unused_parens_core(&self, cx: &Context, value: &ast::Expr, msg: &str,\n                                      struct_lit_needs_parens: bool) {\n         match value.node {\n             ast::ExprParen(ref inner) => {\n@@ -1090,7 +1090,7 @@ impl LintPass for UnusedParens {\n             ast::ExprAssignOp(_, _, ref value) => (value, \"assigned value\", false),\n             _ => return\n         };\n-        self.check_unnecessary_parens_core(cx, &**value, msg, struct_lit_needs_parens);\n+        self.check_unused_parens_core(cx, &**value, msg, struct_lit_needs_parens);\n     }\n \n     fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n@@ -1104,7 +1104,7 @@ impl LintPass for UnusedParens {\n             },\n             _ => return\n         };\n-        self.check_unnecessary_parens_core(cx, &**value, msg, false);\n+        self.check_unused_parens_core(cx, &**value, msg, false);\n     }\n }\n \n@@ -1364,7 +1364,7 @@ impl MissingDoc {\n         *self.doc_hidden_stack.last().expect(\"empty doc_hidden_stack\")\n     }\n \n-    fn check_missing_doc_attrs(&self,\n+    fn check_missing_docs_attrs(&self,\n                                cx: &Context,\n                                id: Option<ast::NodeId>,\n                                attrs: &[ast::Attribute],\n@@ -1374,7 +1374,7 @@ impl MissingDoc {\n         // documentation is probably not really relevant right now.\n         if cx.sess().opts.test { return }\n \n-        // `#[doc(hidden)]` disables missing_doc check.\n+        // `#[doc(hidden)]` disables missing_docs check.\n         if self.doc_hidden() { return }\n \n         // Only check publicly-visible items, using the result from the privacy pass.\n@@ -1429,7 +1429,7 @@ impl LintPass for MissingDoc {\n     }\n \n     fn check_crate(&mut self, cx: &Context, krate: &ast::Crate) {\n-        self.check_missing_doc_attrs(cx, None, krate.attrs.as_slice(),\n+        self.check_missing_docs_attrs(cx, None, krate.attrs.as_slice(),\n                                      krate.span, \"crate\");\n     }\n \n@@ -1442,7 +1442,7 @@ impl LintPass for MissingDoc {\n             ast::ItemTrait(..) => \"a trait\",\n             _ => return\n         };\n-        self.check_missing_doc_attrs(cx, Some(it.id), it.attrs.as_slice(),\n+        self.check_missing_docs_attrs(cx, Some(it.id), it.attrs.as_slice(),\n                                      it.span, desc);\n     }\n \n@@ -1456,15 +1456,15 @@ impl LintPass for MissingDoc {\n \n                 // Otherwise, doc according to privacy. This will also check\n                 // doc for default methods defined on traits.\n-                self.check_missing_doc_attrs(cx, Some(m.id), m.attrs.as_slice(),\n+                self.check_missing_docs_attrs(cx, Some(m.id), m.attrs.as_slice(),\n                                              m.span, \"a method\");\n             }\n             _ => {}\n         }\n     }\n \n     fn check_ty_method(&mut self, cx: &Context, tm: &ast::TypeMethod) {\n-        self.check_missing_doc_attrs(cx, Some(tm.id), tm.attrs.as_slice(),\n+        self.check_missing_docs_attrs(cx, Some(tm.id), tm.attrs.as_slice(),\n                                      tm.span, \"a type method\");\n     }\n \n@@ -1473,7 +1473,7 @@ impl LintPass for MissingDoc {\n             ast::NamedField(_, vis) if vis == ast::Public => {\n                 let cur_struct_def = *self.struct_def_stack.last()\n                     .expect(\"empty struct_def_stack\");\n-                self.check_missing_doc_attrs(cx, Some(cur_struct_def),\n+                self.check_missing_docs_attrs(cx, Some(cur_struct_def),\n                                              sf.node.attrs.as_slice(), sf.span,\n                                              \"a struct field\")\n             }\n@@ -1482,7 +1482,7 @@ impl LintPass for MissingDoc {\n     }\n \n     fn check_variant(&mut self, cx: &Context, v: &ast::Variant, _: &ast::Generics) {\n-        self.check_missing_doc_attrs(cx, Some(v.node.id), v.node.attrs.as_slice(),\n+        self.check_missing_docs_attrs(cx, Some(v.node.id), v.node.attrs.as_slice(),\n                                      v.span, \"a variant\");\n     }\n }"}, {"sha": "aa8e1ed270368d578dbab7822b3118a19203c4dd", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -221,8 +221,8 @@ impl LintStore {\n \n         add_lint_group!(sess, \"unused\",\n                         UNUSED_IMPORTS, UNUSED_VARIABLES, UNUSED_ASSIGNMENTS, DEAD_CODE,\n-                        UNUSED_MUT, UNREACHABLE_CODE, UNUSED_EXTERN_CRATES, UNUSED_MUST_USE,\n-                        UNUSED_UNSAFE, UNUSED_RESULTS, PATH_STATEMENTS)\n+                        UNUSED_MUT, UNREACHABLE_CODE, UNUSED_MUST_USE,\n+                        UNUSED_UNSAFE, PATH_STATEMENTS)\n \n         // We have one lint pass defined in this module.\n         self.register_pass(sess, false, box GatherNodeLevels as LintPassObject);\n@@ -254,21 +254,19 @@ impl LintStore {\n \n     }\n \n-    #[allow(unused_variable)]\n+    #[allow(unused_variables)]\n     fn find_lint(&self, lint_name: &str, sess: &Session, span: Option<Span>)\n                  -> Option<LintId>\n     {\n         match self.by_name.find_equiv(&lint_name) {\n             Some(&Id(lint_id)) => Some(lint_id),\n             Some(&Renamed(ref new_name, lint_id)) => {\n-                // NOTE(stage0): add the following code after the next snapshot\n-\n-                // let warning = format!(\"lint {} has been renamed to {}\",\n-                //                       lint_name, new_name);\n-                // match span {\n-                //     Some(span) => sess.span_warn(span, warning.as_slice()),\n-                //     None => sess.warn(warning.as_slice()),\n-                // };\n+                let warning = format!(\"lint {} has been renamed to {}\",\n+                                      lint_name, new_name);\n+                match span {\n+                    Some(span) => sess.span_warn(span, warning.as_slice()),\n+                    None => sess.warn(warning.as_slice()),\n+                };\n                 Some(lint_id)\n             }\n             None => None"}, {"sha": "0202aa185585c407e920837d4008781c637a8667", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -98,7 +98,7 @@ macro_rules! declare_lint (\n #[macro_export]\n macro_rules! lint_array ( ($( $lint:expr ),*) => (\n     {\n-        #[allow(non_uppercase_statics)]\n+        #[allow(non_upper_case_globals)]\n         static array: LintArray = &[ $( &$lint ),* ];\n         array\n     }"}, {"sha": "bc58097b8607286df5df5b2f0953eb00a3b53a44", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_camel_case_types, non_uppercase_statics)]\n+#![allow(non_camel_case_types, non_upper_case_globals)]\n \n use std::mem;\n use back::svh::Svh;"}, {"sha": "e126449b2481ed95e4db718d44b17d071a965503", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -1330,9 +1330,9 @@ pub fn get_missing_lang_items(cdata: Cmd)\n {\n     let items = reader::get_doc(rbml::Doc::new(cdata.data()), tag_lang_items);\n     let mut result = Vec::new();\n-    reader::tagged_docs(items, tag_lang_items_missing, |missing_doc| {\n+    reader::tagged_docs(items, tag_lang_items_missing, |missing_docs| {\n         let item: lang_items::LangItem =\n-            FromPrimitive::from_u32(reader::doc_as_u32(missing_doc)).unwrap();\n+            FromPrimitive::from_u32(reader::doc_as_u32(missing_docs)).unwrap();\n         result.push(item);\n         true\n     });"}, {"sha": "fd983075218a505e78b15feb6c165cd63a3af078", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -1619,7 +1619,7 @@ fn encode_index<T: Hash>(rbml_w: &mut Encoder, index: Vec<entry<T>>,\n     let mut buckets: Vec<Vec<entry<T>>> = Vec::from_fn(256, |_| Vec::new());\n     for elt in index.into_iter() {\n         let h = hash::hash(&elt.val) as uint;\n-        buckets.get_mut(h % 256).push(elt);\n+        buckets[h % 256].push(elt);\n     }\n \n     rbml_w.start_tag(tag_index);\n@@ -2028,7 +2028,7 @@ fn encode_dylib_dependency_formats(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n }\n \n // NB: Increment this as you change the metadata encoding version.\n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n pub const metadata_encoding_version : &'static [u8] = &[b'r', b'u', b's', b't', 0, 0, 0, 1 ];\n \n pub fn encode_metadata(parms: EncodeParams, krate: &Crate) -> Vec<u8> {"}, {"sha": "98376726913c351fe982ad487430b703781a76a8", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -83,7 +83,7 @@ impl Clone for MovePathIndex {\n     }\n }\n \n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n static InvalidMovePathIndex: MovePathIndex =\n     MovePathIndex(uint::MAX);\n \n@@ -97,7 +97,7 @@ impl MoveIndex {\n     }\n }\n \n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n static InvalidMoveIndex: MoveIndex =\n     MoveIndex(uint::MAX);\n \n@@ -214,13 +214,13 @@ impl MoveData {\n     fn set_path_first_move(&self,\n                            index: MovePathIndex,\n                            first_move: MoveIndex) {\n-        self.paths.borrow_mut().get_mut(index.get()).first_move = first_move\n+        (*self.paths.borrow_mut())[index.get()].first_move = first_move\n     }\n \n     fn set_path_first_child(&self,\n                             index: MovePathIndex,\n                             first_child: MovePathIndex) {\n-        self.paths.borrow_mut().get_mut(index.get()).first_child = first_child\n+        (*self.paths.borrow_mut())[index.get()].first_child = first_child\n     }\n \n     fn move_next_move(&self, index: MoveIndex) -> MoveIndex {"}, {"sha": "ad0040608ece86ed511a5f616b79315d4446ac0f", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![allow(non_camel_case_types)]\n-#![allow(unsigned_negate)]\n+#![allow(unsigned_negation)]\n \n use metadata::csearch;\n use middle::astencode;"}, {"sha": "3baa8eb0cc0400c6a64a30b54cb8aed0a6fe1309", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -161,7 +161,7 @@ fn calculate_type(sess: &session::Session,\n         if src.dylib.is_none() && !formats.contains_key(&cnum) {\n             assert!(src.rlib.is_some());\n             add_library(sess, cnum, cstore::RequireStatic, &mut formats);\n-            *ret.get_mut(cnum as uint - 1) = Some(cstore::RequireStatic);\n+            ret[cnum as uint - 1] = Some(cstore::RequireStatic);\n             debug!(\"adding staticlib: {}\", data.name);\n         }\n     });"}, {"sha": "18ecc9dd05331d0a081e4204bbfb31880caf4c20", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -66,20 +66,20 @@ impl<E: Show> Show for Edge<E> {\n \n #[deriving(Clone, PartialEq, Show)]\n pub struct NodeIndex(pub uint);\n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n pub const InvalidNodeIndex: NodeIndex = NodeIndex(uint::MAX);\n \n #[deriving(PartialEq, Show)]\n pub struct EdgeIndex(pub uint);\n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n pub const InvalidEdgeIndex: EdgeIndex = EdgeIndex(uint::MAX);\n \n // Use a private field here to guarantee no more instances are created:\n #[deriving(Show)]\n pub struct Direction { repr: uint }\n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n pub const Outgoing: Direction = Direction { repr: 0 };\n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n pub const Incoming: Direction = Direction { repr: 1 };\n \n impl NodeIndex {\n@@ -142,7 +142,7 @@ impl<N,E> Graph<N,E> {\n     }\n \n     pub fn mut_node_data<'a>(&'a mut self, idx: NodeIndex) -> &'a mut N {\n-        &mut self.nodes.get_mut(idx.get()).data\n+        &mut self.nodes[idx.get()].data\n     }\n \n     pub fn node_data<'a>(&'a self, idx: NodeIndex) -> &'a N {\n@@ -182,14 +182,14 @@ impl<N,E> Graph<N,E> {\n         });\n \n         // adjust the firsts for each node target be the next object.\n-        self.nodes.get_mut(source.get()).first_edge[Outgoing.repr] = idx;\n-        self.nodes.get_mut(target.get()).first_edge[Incoming.repr] = idx;\n+        self.nodes[source.get()].first_edge[Outgoing.repr] = idx;\n+        self.nodes[target.get()].first_edge[Incoming.repr] = idx;\n \n         return idx;\n     }\n \n     pub fn mut_edge_data<'a>(&'a mut self, idx: EdgeIndex) -> &'a mut E {\n-        &mut self.edges.get_mut(idx.get()).data\n+        &mut self.edges[idx.get()].data\n     }\n \n     pub fn edge_data<'a>(&'a self, idx: EdgeIndex) -> &'a E {"}, {"sha": "80eba56ea6ce0290529c219abae228b987fafa3c", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -756,7 +756,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn init_empty(&mut self, ln: LiveNode, succ_ln: LiveNode) {\n-        *self.successors.get_mut(ln.get()) = succ_ln;\n+        self.successors[ln.get()] = succ_ln;\n \n         // It is not necessary to initialize the\n         // values to empty because this is the value\n@@ -770,10 +770,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn init_from_succ(&mut self, ln: LiveNode, succ_ln: LiveNode) {\n         // more efficient version of init_empty() / merge_from_succ()\n-        *self.successors.get_mut(ln.get()) = succ_ln;\n+        self.successors[ln.get()] = succ_ln;\n \n         self.indices2(ln, succ_ln, |this, idx, succ_idx| {\n-            *this.users.get_mut(idx) = this.users[succ_idx]\n+            this.users[idx] = this.users[succ_idx]\n         });\n         debug!(\"init_from_succ(ln={}, succ={})\",\n                self.ln_str(ln), self.ln_str(succ_ln));\n@@ -789,11 +789,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         let mut changed = false;\n         self.indices2(ln, succ_ln, |this, idx, succ_idx| {\n             changed |= copy_if_invalid(this.users[succ_idx].reader,\n-                                       &mut this.users.get_mut(idx).reader);\n+                                       &mut this.users[idx].reader);\n             changed |= copy_if_invalid(this.users[succ_idx].writer,\n-                                       &mut this.users.get_mut(idx).writer);\n+                                       &mut this.users[idx].writer);\n             if this.users[succ_idx].used && !this.users[idx].used {\n-                this.users.get_mut(idx).used = true;\n+                this.users[idx].used = true;\n                 changed = true;\n             }\n         });\n@@ -817,8 +817,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     // this) so we just clear out all the data.\n     fn define(&mut self, writer: LiveNode, var: Variable) {\n         let idx = self.idx(writer, var);\n-        self.users.get_mut(idx).reader = invalid_node();\n-        self.users.get_mut(idx).writer = invalid_node();\n+        self.users[idx].reader = invalid_node();\n+        self.users[idx].writer = invalid_node();\n \n         debug!(\"{} defines {} (idx={}): {}\", writer.to_string(), var.to_string(),\n                idx, self.ln_str(writer));\n@@ -830,7 +830,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                ln.to_string(), acc, var.to_string(), self.ln_str(ln));\n \n         let idx = self.idx(ln, var);\n-        let user = self.users.get_mut(idx);\n+        let user = &mut self.users[idx];\n \n         if (acc & ACC_WRITE) != 0 {\n             user.reader = invalid_node();"}, {"sha": "383a60e51da7b6ca29ccc0607e940caf02aa47a5", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -2596,7 +2596,7 @@ impl<'a> Resolver<'a> {\n \n         // We've successfully resolved the import. Write the results in.\n         let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-        let import_resolution = import_resolutions.get_mut(&target);\n+        let import_resolution = &mut (*import_resolutions)[target];\n \n         match value_result {\n             BoundResult(ref target_module, ref name_bindings) => {\n@@ -3158,7 +3158,7 @@ impl<'a> Resolver<'a> {\n                                         (_, _) => {\n                                             search_module = module_def.clone();\n \n-                                            // track extern crates for unused_extern_crate lint\n+                                            // track extern crates for unused_extern_crates lint\n                                             match module_def.def_id.get() {\n                                                 Some(did) => {\n                                                     self.used_crates.insert(did.krate);\n@@ -5697,7 +5697,7 @@ impl<'a> Resolver<'a> {\n \n         let mut smallest = 0;\n         for (i, other) in maybes.iter().enumerate() {\n-            *values.get_mut(i) = name.lev_distance(other.get());\n+            values[i] = name.lev_distance(other.get());\n \n             if values[i] <= values[smallest] {\n                 smallest = i;"}, {"sha": "93ad29cff906a02184681e495e8f0276f4b193f8", "filename": "src/librustc/middle/save/span_utils.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fspan_utils.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -145,7 +145,7 @@ impl<'a> SpanUtils<'a> {\n             last_span = None;\n             let mut next = toks.next_token();\n \n-            if (next.tok == token::LParen ||\n+            if (next.tok == token::OpenDelim(token::Paren) ||\n                 next.tok == token::Lt) &&\n                bracket_count == 0 &&\n                prev.tok.is_ident() {\n@@ -164,8 +164,8 @@ impl<'a> SpanUtils<'a> {\n             }\n \n             bracket_count += match prev.tok {\n-                token::LParen | token::Lt => 1,\n-                token::RParen | token::Gt => -1,\n+                token::OpenDelim(token::Paren) | token::Lt => 1,\n+                token::CloseDelim(token::Paren) | token::Gt => -1,\n                 token::BinOp(token::Shr) => -2,\n                 _ => 0\n             };"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/librustc/middle/traexpr", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a12d06b73fcb38cf23dfe71da725428a1094395f/src%2Flibrustc%2Fmiddle%2Ftraexpr", "raw_url": "https://github.com/rust-lang/rust/raw/a12d06b73fcb38cf23dfe71da725428a1094395f/src%2Flibrustc%2Fmiddle%2Ftraexpr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraexpr?ref=a12d06b73fcb38cf23dfe71da725428a1094395f"}, {"sha": "70aef4504f031c1e1602ab9f6338698e0bb18a8a", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -403,7 +403,7 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n \n         let mut pats = br.pats.clone();\n-        *pats.get_mut(col) = pat;\n+        pats[col] = pat;\n         Match {\n             pats: pats,\n             data: &*br.data,"}, {"sha": "98d02dfb8d7a8ab474dfc2922b29889ef3b4c1ce", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -43,7 +43,7 @@\n  *   taken to it, implementing them for Rust seems difficult.\n  */\n \n-#![allow(unsigned_negate)]\n+#![allow(unsigned_negation)]\n \n use std::collections::Map;\n use std::num::Int;\n@@ -393,12 +393,12 @@ fn mk_cenum(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> Repr {\n fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntType {\n     debug!(\"range_to_inttype: {} {}\", hint, bounds);\n     // Lists of sizes to try.  u64 is always allowed as a fallback.\n-    #[allow(non_uppercase_statics)]\n+    #[allow(non_upper_case_globals)]\n     static choose_shortest: &'static[IntType] = &[\n         attr::UnsignedInt(ast::TyU8), attr::SignedInt(ast::TyI8),\n         attr::UnsignedInt(ast::TyU16), attr::SignedInt(ast::TyI16),\n         attr::UnsignedInt(ast::TyU32), attr::SignedInt(ast::TyI32)];\n-    #[allow(non_uppercase_statics)]\n+    #[allow(non_upper_case_globals)]\n     static at_least_32: &'static[IntType] = &[\n         attr::UnsignedInt(ast::TyU32), attr::SignedInt(ast::TyI32)];\n "}, {"sha": "2782970b975ae8274b16a0ff7e6e547819120a2c", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_uppercase_statics)]\n+#![allow(non_upper_case_globals)]\n \n use llvm;\n use llvm::{Integer, Pointer, Float, Double, Struct, Array};"}, {"sha": "5fe10d2d8e7ca95873a3633caac76add4eb5b572", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_uppercase_statics)]\n+#![allow(non_upper_case_globals)]\n \n use libc::c_uint;\n use std::cmp;"}, {"sha": "d9819ee729456195e1597bb7810f6861d0fe1f71", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -11,7 +11,7 @@\n // The classification code for the x86_64 ABI is taken from the clay language\n // https://github.com/jckarter/clay/blob/master/compiler/src/externals.cpp\n \n-#![allow(non_uppercase_statics)]\n+#![allow(non_upper_case_globals)]\n \n use llvm;\n use llvm::{Integer, Pointer, Float, Double};"}, {"sha": "5a4979d9dcd5e67a85c22e393f92a3fe325df88c", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -469,7 +469,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         assert!(self.is_valid_custom_scope(custom_scope));\n \n         let mut scopes = self.scopes.borrow_mut();\n-        let scope = scopes.get_mut(custom_scope.index);\n+        let scope = &mut (*scopes)[custom_scope.index];\n         scope.cleanups.push(cleanup);\n         scope.clear_cached_exits();\n     }"}, {"sha": "c688749a38959b8b6ede9b3fdcddd1b1e95f122c", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -218,20 +218,20 @@ use syntax::parse::token::special_idents;\n \n static DW_LANG_RUST: c_uint = 0x9000;\n \n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n static DW_TAG_auto_variable: c_uint = 0x100;\n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n static DW_TAG_arg_variable: c_uint = 0x101;\n \n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n static DW_ATE_boolean: c_uint = 0x02;\n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n static DW_ATE_float: c_uint = 0x04;\n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n static DW_ATE_signed: c_uint = 0x05;\n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n static DW_ATE_unsigned: c_uint = 0x07;\n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n static DW_ATE_unsigned_char: c_uint = 0x08;\n \n static UNKNOWN_LINE_NUMBER: c_uint = 0;"}, {"sha": "3bfa6af4a9bcb5751dbb3434fc125f925e3d133f", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -833,7 +833,7 @@ fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let _icx = push_ctxt(\"trans_def_lvalue\");\n     match def {\n-        def::DefFn(..) | def::DefStaticMethod(..) |\n+        def::DefFn(..) | def::DefStaticMethod(..) | def::DefMethod(..) |\n         def::DefStruct(_) | def::DefVariant(..) => {\n             trans_def_fn_unadjusted(bcx, ref_expr, def)\n         }\n@@ -1191,10 +1191,12 @@ fn trans_def_fn_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let llfn = match def {\n         def::DefFn(did, _, _) |\n         def::DefStruct(did) | def::DefVariant(_, did, _) |\n-        def::DefStaticMethod(did, def::FromImpl(_), _) => {\n+        def::DefStaticMethod(did, def::FromImpl(_), _) |\n+        def::DefMethod(did, _, def::FromImpl(_)) => {\n             callee::trans_fn_ref(bcx, did, ExprId(ref_expr.id))\n         }\n-        def::DefStaticMethod(impl_did, def::FromTrait(trait_did), _) => {\n+        def::DefStaticMethod(impl_did, def::FromTrait(trait_did), _) |\n+        def::DefMethod(impl_did, _, def::FromTrait(trait_did)) => {\n             meth::trans_static_method_callee(bcx, impl_did,\n                                              trait_did, ref_expr.id)\n         }\n@@ -1331,7 +1333,7 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                           field_ty.name == field.ident.node.name);\n             match opt_pos {\n                 Some(i) => {\n-                    *need_base.get_mut(i) = false;\n+                    need_base[i] = false;\n                     (i, &*field.expr)\n                 }\n                 None => {"}, {"sha": "906e9e8bfa0147a0302c89dc7141fc93f9b4c935", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_uppercase_statics)]\n+#![allow(non_upper_case_globals)]\n \n use llvm;\n use llvm::{SequentiallyConsistent, Acquire, Release, AtomicXchg, ValueRef};"}, {"sha": "60c38af3e72abc98a5f55748373994082cdde4f1", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -310,26 +310,23 @@ pub fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     return expr::trans_into(bcx, &**element, Ignore);\n                 }\n                 SaveIn(lldest) => {\n-                    let count = ty::eval_repeat_count(bcx.tcx(), &**count_expr);\n-                    if count == 0 {\n-                        return bcx;\n+                    match ty::eval_repeat_count(bcx.tcx(), &**count_expr) {\n+                        0 => bcx,\n+                        1 => expr::trans_into(bcx, &**element, SaveIn(lldest)),\n+                        count => {\n+                            let elem = unpack_datum!(bcx, expr::trans(bcx, &**element));\n+                            assert!(!ty::type_moves_by_default(bcx.tcx(), elem.ty));\n+\n+                            let bcx = iter_vec_loop(bcx, lldest, vt,\n+                                                    C_uint(bcx.ccx(), count),\n+                                                    |set_bcx, lleltptr, _| {\n+                                                        elem.shallow_copy(set_bcx, lleltptr)\n+                                                    });\n+\n+                            elem.add_clean_if_rvalue(bcx, element.id);\n+                            bcx\n+                        }\n                     }\n-\n-                    // Some cleanup would be required in the case in which panic happens\n-                    // during a copy. But given that copy constructors are not overridable,\n-                    // this can only happen as a result of OOM. So we just skip out on the\n-                    // cleanup since things would *probably* be broken at that point anyways.\n-\n-                    let elem = unpack_datum!(bcx, expr::trans(bcx, &**element));\n-                    assert!(!ty::type_moves_by_default(bcx.tcx(), elem.ty));\n-\n-                    let bcx = iter_vec_loop(bcx, lldest, vt,\n-                                  C_uint(bcx.ccx(), count), |set_bcx, lleltptr, _| {\n-                        elem.shallow_copy(set_bcx, lleltptr)\n-                    });\n-\n-                    elem.add_clean_if_rvalue(bcx, element.id);\n-                    bcx\n                 }\n             }\n         }"}, {"sha": "851552592ddad54fe67cf707ed453409ce9ad8e4", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_uppercase_statics)]\n+#![allow(non_upper_case_globals)]\n \n use llvm;\n use llvm::{TypeRef, Bool, False, True, TypeKind, ValueRef};\n@@ -284,7 +284,7 @@ impl Type {\n                 return Vec::new();\n             }\n             let mut elts = Vec::from_elem(n_elts, 0 as TypeRef);\n-            llvm::LLVMGetStructElementTypes(self.to_ref(), elts.get_mut(0));\n+            llvm::LLVMGetStructElementTypes(self.to_ref(), &mut elts[0]);\n             mem::transmute(elts)\n         }\n     }"}, {"sha": "6defc594fb8b5b7001d7352c9482241f0e3ac078", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -2215,7 +2215,7 @@ macro_rules! def_type_content_sets(\n         mod $mname {\n             use middle::ty::TypeContents;\n             $(\n-                #[allow(non_uppercase_statics)]\n+                #[allow(non_upper_case_globals)]\n                 pub const $name: TypeContents = TypeContents { bits: $bits };\n              )+\n         }\n@@ -3631,7 +3631,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                 def::DefFn(_, _, true) => RvalueDpsExpr,\n \n                 // Fn pointers are just scalar values.\n-                def::DefFn(..) | def::DefStaticMethod(..) => RvalueDatumExpr,\n+                def::DefFn(..) | def::DefStaticMethod(..) | def::DefMethod(..) => RvalueDatumExpr,\n \n                 // Note: there is actually a good case to be made that\n                 // DefArg's, particularly those of immediate type, ought to\n@@ -4670,7 +4670,7 @@ pub fn unboxed_closure_upvars(tcx: &ctxt, closure_id: ast::DefId, substs: &Subst\n }\n \n pub fn is_binopable(cx: &ctxt, ty: t, op: ast::BinOp) -> bool {\n-    #![allow(non_uppercase_statics)]\n+    #![allow(non_upper_case_globals)]\n     static tycat_other: int = 0;\n     static tycat_bool: int = 1;\n     static tycat_char: int = 2;"}, {"sha": "66d4f73eacc876615e5fa83e735907c81d0643a1", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -674,7 +674,7 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                             return constr(ty::mk_str(tcx));\n                         }\n                         RPtr(r) => {\n-                            return ty::mk_str_slice(tcx, r, ast::MutImmutable);\n+                            return ty::mk_str_slice(tcx, r, a_seq_mutbl);\n                         }\n                     }\n                 }"}, {"sha": "4334cf7db7a23142a338a28cf997564c9b3749b1", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -648,7 +648,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                     ByValueExplicitSelfCategory => {\n                         let mut n = (*m).clone();\n                         let self_ty = n.fty.sig.inputs[0];\n-                        *n.fty.sig.inputs.get_mut(0) = ty::mk_uniq(tcx, self_ty);\n+                        n.fty.sig.inputs[0] = ty::mk_uniq(tcx, self_ty);\n                         m = Rc::new(n);\n                     }\n                     _ => { }"}, {"sha": "13ffc1f4fcbaa379a857271abdef6924575f4923", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -5456,7 +5456,7 @@ pub fn check_bounds_are_used(ccx: &CrateCtxt,\n             match ty::get(t).sty {\n                 ty::ty_param(ParamTy {idx, ..}) => {\n                     debug!(\"Found use of ty param num {}\", idx);\n-                    *tps_used.get_mut(idx) = true;\n+                    tps_used[idx] = true;\n                 }\n                 _ => ()\n             }"}, {"sha": "d0338333badee30a46a950d3ef4163817823ef85", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -1757,7 +1757,7 @@ fn adjust_upvar_borrow_kind_for_mut(rcx: &Rcx,\n                         // is inferred to mutable if necessary\n                         let mut upvar_borrow_map =\n                             rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n-                        let ub = upvar_borrow_map.get_mut(upvar_id);\n+                        let ub = &mut (*upvar_borrow_map)[*upvar_id];\n                         return adjust_upvar_borrow_kind(rcx, *upvar_id, ub, ty::MutBorrow);\n                     }\n \n@@ -1807,7 +1807,7 @@ fn adjust_upvar_borrow_kind_for_unique(rcx: &Rcx, cmt: mc::cmt) {\n                         // borrow_kind of the upvar to make sure it\n                         // is inferred to unique if necessary\n                         let mut ub = rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n-                        let ub = ub.get_mut(upvar_id);\n+                        let ub = &mut (*ub)[*upvar_id];\n                         return adjust_upvar_borrow_kind(rcx, *upvar_id, ub, ty::UniqueImmBorrow);\n                     }\n "}, {"sha": "a17194f0085654446499bff354f3dc9c43690133", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -402,15 +402,25 @@ pub fn maybe_report_ambiguity(fcx: &FnCtxt, obligation: &Obligation) {\n         // has_errors() to be sure that compilation isn't happening\n         // anyway. In that case, why inundate the user.\n         if !fcx.tcx().sess.has_errors() {\n-            fcx.tcx().sess.span_err(\n-                obligation.cause.span,\n-                format!(\n-                    \"unable to infer enough type information to \\\n-                     locate the impl of the trait `{}` for \\\n-                     the type `{}`; type annotations required\",\n-                    trait_ref.user_string(fcx.tcx()),\n-                    self_ty.user_string(fcx.tcx())).as_slice());\n-            note_obligation_cause(fcx, obligation);\n+            if fcx.ccx.tcx.lang_items.sized_trait()\n+                  .map_or(false, |sized_id| sized_id == trait_ref.def_id) {\n+                fcx.tcx().sess.span_err(\n+                    obligation.cause.span,\n+                    format!(\n+                        \"unable to infer enough type information about `{}`; type annotations \\\n+                         required\",\n+                        self_ty.user_string(fcx.tcx())).as_slice());\n+            } else {\n+                fcx.tcx().sess.span_err(\n+                    obligation.cause.span,\n+                    format!(\n+                        \"unable to infer enough type information to \\\n+                         locate the impl of the trait `{}` for \\\n+                         the type `{}`; type annotations required\",\n+                        trait_ref.user_string(fcx.tcx()),\n+                        self_ty.user_string(fcx.tcx())).as_slice());\n+                note_obligation_cause(fcx, obligation);\n+            }\n         }\n     } else if !fcx.tcx().sess.has_errors() {\n          // Ambiguity. Coherence should have reported an error."}, {"sha": "b53318861b891a87a024605ea7ba6f2ba998ef86", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -282,7 +282,9 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                             }\n                             _ => {\n                                 span_err!(self.tcx().sess, reason.span(self.tcx()), E0100,\n-                                    \"cannot coerce non-statically resolved bare fn\");\n+                                    \"cannot coerce non-statically resolved bare fn to closure\");\n+                                span_help!(self.tcx().sess, reason.span(self.tcx()),\n+                                    \"consider embedding the function in a closure\");\n                             }\n                         }\n "}, {"sha": "ff1ded726c566a631a66fd2869e567acc310ad82", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -261,7 +261,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         if snapshot.length == 0 {\n             undo_log.truncate(0);\n         } else {\n-            *undo_log.get_mut(snapshot.length) = CommitedSnapshot;\n+            (*undo_log)[snapshot.length] = CommitedSnapshot;\n         }\n     }\n "}, {"sha": "73f595dbedc2e52a5638cb569493eafd416921d5", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -46,7 +46,7 @@\n // future).  If you want to resolve everything but one type, you are\n // probably better off writing `resolve_all - resolve_ivar`.\n \n-#![allow(non_uppercase_statics)]\n+#![allow(non_upper_case_globals)]\n \n use middle::ty::{FloatVar, FloatVid, IntVar, IntVid, RegionVid, TyVar, TyVid};\n use middle::ty::{IntType, UintType};"}, {"sha": "1383f7aa4dc982558c0759399789cb653ba66326", "filename": "src/librustc/middle/typeck/infer/type_variable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -159,12 +159,12 @@ impl sv::SnapshotVecDelegate<TypeVariableData,UndoEntry> for Delegate {\n                action: UndoEntry) {\n         match action {\n             SpecifyVar(vid, relations) => {\n-                values.get_mut(vid.index).value = Bounded(relations);\n+                values[vid.index].value = Bounded(relations);\n             }\n \n             Relate(a, b) => {\n-                relations(values.get_mut(a.index)).pop();\n-                relations(values.get_mut(b.index)).pop();\n+                relations(&mut (*values)[a.index]).pop();\n+                relations(&mut (*values)[b.index]).pop();\n             }\n         }\n     }"}, {"sha": "5e62a8e9451687a45e6aa583ee848da09b7acef3", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -715,7 +715,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             _ => {\n-                self.terms_cx.arena.alloc(|| TransformTerm(v1, v2))\n+                &*self.terms_cx.arena.alloc(|| TransformTerm(v1, v2))\n             }\n         }\n     }\n@@ -994,7 +994,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                             new_value,\n                             term.to_string());\n \n-                    *self.solutions.get_mut(inferred) = new_value;\n+                    self.solutions[inferred] = new_value;\n                     changed = true;\n                 }\n             }"}, {"sha": "6d99fc7156ca8f1f9be0fa1618b227868d8b24fc", "filename": "src/librustc/util/snapshot_vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -105,7 +105,7 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n          * action.\n          */\n \n-        self.values.get_mut(index)\n+        &mut self.values[index]\n     }\n \n     pub fn set(&mut self, index: uint, new_elem: T) {\n@@ -114,7 +114,7 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n          * saved (and perhaps restored) if a snapshot is active.\n          */\n \n-        let old_elem = mem::replace(self.values.get_mut(index), new_elem);\n+        let old_elem = mem::replace(&mut self.values[index], new_elem);\n         if self.in_snapshot() {\n             self.undo_log.push(SetElem(index, old_elem));\n         }\n@@ -162,7 +162,7 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n                 }\n \n                 SetElem(i, v) => {\n-                    *self.values.get_mut(i) = v;\n+                    self.values[i] = v;\n                 }\n \n                 Other(u) => {\n@@ -189,7 +189,7 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n             // The root snapshot.\n             self.undo_log.truncate(0);\n         } else {\n-            *self.undo_log.get_mut(snapshot.length) = CommittedSnapshot;\n+            self.undo_log[snapshot.length] = CommittedSnapshot;\n         }\n     }\n }"}, {"sha": "19dd6b8459f0424cc858472c337ead8d3f8794c3", "filename": "src/librustc_back/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc_back%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc_back%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fabi.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_uppercase_statics)]\n+#![allow(non_upper_case_globals)]\n \n pub const box_field_refcnt: uint = 0u;\n pub const box_field_drop_glue: uint = 1u;"}, {"sha": "06456a91e03f361cf655a4d990cb339e4c2b1155", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_uppercase_statics)]\n+#![allow(non_upper_case_globals)]\n #![allow(non_camel_case_types)]\n #![allow(non_snake_case)]\n #![allow(dead_code)]"}, {"sha": "4797ac7c66ac666d89f16335889e0588fa51788f", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -97,8 +97,8 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n \n             // miscellaneous, no highlighting\n             token::Dot | token::DotDot | token::DotDotDot | token::Comma | token::Semi |\n-                token::Colon | token::ModSep | token::LArrow | token::LParen |\n-                token::RParen | token::LBracket | token::LBrace | token::RBrace |\n+                token::Colon | token::ModSep | token::LArrow | token::OpenDelim(_) |\n+                token::CloseDelim(token::Brace) | token::CloseDelim(token::Paren) |\n                 token::Question => \"\",\n             token::Dollar => {\n                 if lexer.peek().tok.is_ident() {\n@@ -118,7 +118,7 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n                 try!(write!(out, r\"<span class='attribute'>#\"));\n                 continue\n             }\n-            token::RBracket => {\n+            token::CloseDelim(token::Bracket) => {\n                 if is_attribute {\n                     is_attribute = false;\n                     try!(write!(out, \"]</span>\"));"}, {"sha": "3e8ebc00579e3b990b60f6c59147c2eff04f0be6", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -212,7 +212,7 @@ pub fn maketest(s: &str, cratename: Option<&str>, lints: bool, dont_insert_main:\n     if lints {\n         prog.push_str(r\"\n #![deny(warnings)]\n-#![allow(unused_variable, dead_assignment, unused_mut, unused_attribute, dead_code)]\n+#![allow(unused_variables, unused_assignments, unused_mut, unused_attributes, dead_code)]\n \");\n     }\n "}, {"sha": "2932a3dd4a824cf86d446ffe7d2e4b6fef0034dc", "filename": "src/librustrt/libunwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustrt%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustrt%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flibunwind.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -10,7 +10,7 @@\n \n //! Unwind library interface\n \n-#![allow(non_uppercase_statics)]\n+#![allow(non_upper_case_globals)]\n #![allow(non_camel_case_types)]\n #![allow(non_snake_case)]\n #![allow(dead_code)] // these are just bindings"}, {"sha": "14275d070f0c91c5a5190e2f371545348a2cc4a2", "filename": "src/librustrt/local_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustrt%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustrt%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_data.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -66,7 +66,7 @@ use task::{Task, LocalStorage};\n  */\n pub type Key<T> = &'static KeyValue<T>;\n \n-#[allow(missing_doc)]\n+#[allow(missing_docs)]\n pub enum KeyValue<T> { KeyValueKey }\n \n // The task-local-map stores all TLD information for the currently running"}, {"sha": "c5fc0084ed9327dc5d8389e45c31245ee6f2ae8a", "filename": "src/librustrt/unwind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustrt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustrt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Funwind.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -177,7 +177,7 @@ pub unsafe fn try(f: ||) -> ::core::result::Result<(), Box<Any + Send>> {\n // An uninlined, unmangled function upon which to slap yer breakpoints\n #[inline(never)]\n #[no_mangle]\n-fn rust_fail(cause: Box<Any + Send>) -> ! {\n+fn rust_panic(cause: Box<Any + Send>) -> ! {\n     rtdebug!(\"begin_unwind()\");\n \n     unsafe {\n@@ -588,7 +588,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n     // (hopefully someone printed something about this).\n     let mut task: Box<Task> = match Local::try_take() {\n         Some(task) => task,\n-        None => rust_fail(msg),\n+        None => rust_panic(msg),\n     };\n \n     if task.unwinder.unwinding {\n@@ -605,7 +605,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n     // requires the task. We need a handle to its unwinder, however, so after\n     // this we unsafely extract it and continue along.\n     Local::put(task);\n-    rust_fail(msg);\n+    rust_panic(msg);\n }\n \n /// Register a callback to be invoked when a task unwinds."}, {"sha": "06d1efdcd704aeb886efa0e91ce1fa5aced289ef", "filename": "src/librustrt/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustrt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibrustrt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Futil.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -28,9 +28,9 @@ pub const ENFORCE_SANITY: bool = true || !cfg!(rtopt) || cfg!(rtdebug) ||\n \n pub struct Stdio(libc::c_int);\n \n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n pub const Stdout: Stdio = Stdio(libc::STDOUT_FILENO);\n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n pub const Stderr: Stdio = Stdio(libc::STDERR_FILENO);\n \n impl fmt::FormatWriter for Stdio {"}, {"sha": "84b5cdd3cc82bec6dc6d301c982de91fc4435d70", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -12,7 +12,7 @@\n // Copyright (c) 2011 Google Inc.\n \n #![forbid(non_camel_case_types)]\n-#![allow(missing_doc)]\n+#![allow(missing_docs)]\n \n /*!\n JSON parsing and serialization\n@@ -1231,7 +1231,7 @@ impl Stack {\n             InternalIndex(i) => { i + 1 }\n             _ => { panic!(); }\n         };\n-        *self.stack.get_mut(len - 1) = InternalIndex(idx);\n+        self.stack[len - 1] = InternalIndex(idx);\n     }\n }\n "}, {"sha": "31f37a8a1bbda38e7eca9f3247a584b3b0d44b45", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -331,8 +331,7 @@ impl IntoStr for Vec<Ascii> {\n     #[inline]\n     fn into_string(self) -> String {\n         unsafe {\n-            let s: &str = mem::transmute(self.as_slice());\n-            String::from_str(s)\n+            string::raw::from_utf8(self.into_bytes())\n         }\n     }\n }"}, {"sha": "97a1f68606f540cefa9a8a1ab49ae51c0eb6073f", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -258,7 +258,7 @@ macro_rules! bitflags {\n }\n \n #[cfg(test)]\n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n mod tests {\n     use hash;\n     use option::{Some, None};"}, {"sha": "cb47c28f8bef2643bb81ddaa607a5e253d8c926d", "filename": "src/libstd/collections/hashmap/map.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -14,19 +14,14 @@ use clone::Clone;\n use cmp::{max, Eq, Equiv, PartialEq};\n use collections::{Collection, Mutable, MutableSet, Map, MutableMap};\n use default::Default;\n-use fmt::Show;\n-use fmt;\n+use fmt::{mod, Show};\n use hash::{Hash, Hasher, RandomSipHasher};\n-use iter::{Iterator, FromIterator, Extendable};\n-use iter;\n-use mem::replace;\n-use mem;\n+use iter::{mod, Iterator, FromIterator, Extendable};\n+use mem::{mod, replace};\n use num;\n-use ops::Deref;\n+use ops::{Deref, Index, IndexMut};\n use option::{Some, None, Option};\n-use result::{Ok, Err};\n-use ops::Index;\n-use core::result::Result;\n+use result::{Result, Ok, Err};\n \n use super::table;\n use super::table::{\n@@ -837,6 +832,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// # Example\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map = HashMap::new();\n@@ -852,11 +848,9 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// *map.get_mut(&\"a\") = -2;\n     /// assert_eq!(map[\"a\"], -2);\n     /// ```\n+    #[deprecated = \"use indexing instead: `&mut map[key]`\"]\n     pub fn get_mut<'a>(&'a mut self, k: &K) -> &'a mut V {\n-        match self.find_mut(k) {\n-            Some(v) => v,\n-            None => panic!(\"no entry found for key\")\n-        }\n+        &mut self[*k]\n     }\n \n     /// Return true if the map contains a value for the specified key,\n@@ -1194,13 +1188,15 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Index<K, V> for HashMap<K, V, H> {\n     }\n }\n \n-// FIXME(#12825) Indexing will always try IndexMut first and that causes issues.\n-/*impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> ops::IndexMut<K, V> for HashMap<K, V, H> {\n+impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> IndexMut<K, V> for HashMap<K, V, H> {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, index: &K) -> &'a mut V {\n-        self.get_mut(index)\n+        match self.find_mut(index) {\n+            Some(v) => v,\n+            None => panic!(\"no entry found for key\")\n+        }\n     }\n-}*/\n+}\n \n /// HashMap iterator\n pub struct Entries<'a, K: 'a, V: 'a> {"}, {"sha": "ec6eef07c9541f123c36326944433fe09051ac2a", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -17,7 +17,7 @@ A simple wrapper over the platform's dynamic library facilities\n */\n \n #![experimental]\n-#![allow(missing_doc)]\n+#![allow(missing_docs)]\n \n use clone::Clone;\n use collections::MutableSeq;\n@@ -286,6 +286,7 @@ pub mod dl {\n     use os;\n     use ptr;\n     use result::{Ok, Err, Result};\n+    use slice::ImmutableSlice;\n     use str::StrSlice;\n     use str;\n     use string::String;"}, {"sha": "91f3f38f89dcbb1a3722be827826da3b56bb1cfe", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -15,7 +15,7 @@ use comm::{Sender, Receiver};\n use io;\n use option::{None, Some};\n use result::{Ok, Err};\n-use slice::{bytes, CloneableVector};\n+use slice::{bytes, CloneableVector, ImmutableSlice};\n use super::{Buffer, Reader, Writer, IoResult};\n use vec::Vec;\n "}, {"sha": "06ed183e93679c92f0d4816ce75cb47ddb95c352", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -10,7 +10,7 @@\n \n //! Utility mixins that apply to all Readers and Writers\n \n-#![allow(missing_doc)]\n+#![allow(missing_docs)]\n \n // FIXME: Not sure how this should be structured\n // FIXME: Iteration should probably be considered separately"}, {"sha": "f193ce8cffacb3a9cb29f2c397789a0b3f5d5f49", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -963,7 +963,7 @@ mod test {\n \n     macro_rules! error( ($e:expr, $s:expr) => (\n         match $e {\n-            Ok(val) => panic!(\"Unexpected success. Should've been: {}\", $s),\n+            Ok(_) => panic!(\"Unexpected success. Should've been: {}\", $s),\n             Err(ref err) => assert!(err.to_string().as_slice().contains($s.as_slice()),\n                                     format!(\"`{}` did not contain `{}`\", err, $s))\n         }"}, {"sha": "6d6c0c0dd758bd06dd893a7e8762138667e956bc", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -1856,60 +1856,60 @@ bitflags! {\n         const ALL_PERMISSIONS = USER_RWX.bits | GROUP_RWX.bits | OTHER_RWX.bits,\n \n         // Deprecated names\n-        #[allow(non_uppercase_statics)]\n+        #[allow(non_upper_case_globals)]\n         #[deprecated = \"use USER_READ instead\"]\n         const UserRead     = USER_READ.bits,\n-        #[allow(non_uppercase_statics)]\n+        #[allow(non_upper_case_globals)]\n         #[deprecated = \"use USER_WRITE instead\"]\n         const UserWrite    = USER_WRITE.bits,\n-        #[allow(non_uppercase_statics)]\n+        #[allow(non_upper_case_globals)]\n         #[deprecated = \"use USER_EXECUTE instead\"]\n         const UserExecute  = USER_EXECUTE.bits,\n-        #[allow(non_uppercase_statics)]\n+        #[allow(non_upper_case_globals)]\n         #[deprecated = \"use GROUP_READ instead\"]\n         const GroupRead    = GROUP_READ.bits,\n-        #[allow(non_uppercase_statics)]\n+        #[allow(non_upper_case_globals)]\n         #[deprecated = \"use GROUP_WRITE instead\"]\n         const GroupWrite   = GROUP_WRITE.bits,\n-        #[allow(non_uppercase_statics)]\n+        #[allow(non_upper_case_globals)]\n         #[deprecated = \"use GROUP_EXECUTE instead\"]\n         const GroupExecute = GROUP_EXECUTE.bits,\n-        #[allow(non_uppercase_statics)]\n+        #[allow(non_upper_case_globals)]\n         #[deprecated = \"use OTHER_READ instead\"]\n         const OtherRead    = OTHER_READ.bits,\n-        #[allow(non_uppercase_statics)]\n+        #[allow(non_upper_case_globals)]\n         #[deprecated = \"use OTHER_WRITE instead\"]\n         const OtherWrite   = OTHER_WRITE.bits,\n-        #[allow(non_uppercase_statics)]\n+        #[allow(non_upper_case_globals)]\n         #[deprecated = \"use OTHER_EXECUTE instead\"]\n         const OtherExecute = OTHER_EXECUTE.bits,\n \n-        #[allow(non_uppercase_statics)]\n+        #[allow(non_upper_case_globals)]\n         #[deprecated = \"use USER_RWX instead\"]\n         const UserRWX  = USER_RWX.bits,\n-        #[allow(non_uppercase_statics)]\n+        #[allow(non_upper_case_globals)]\n         #[deprecated = \"use GROUP_RWX instead\"]\n         const GroupRWX = GROUP_RWX.bits,\n-        #[allow(non_uppercase_statics)]\n+        #[allow(non_upper_case_globals)]\n         #[deprecated = \"use OTHER_RWX instead\"]\n         const OtherRWX = OTHER_RWX.bits,\n \n         #[doc = \"Deprecated: use `USER_FILE` instead.\"]\n-        #[allow(non_uppercase_statics)]\n+        #[allow(non_upper_case_globals)]\n         #[deprecated = \"use USER_FILE instead\"]\n         const UserFile = USER_FILE.bits,\n \n         #[doc = \"Deprecated: use `USER_DIR` instead.\"]\n-        #[allow(non_uppercase_statics)]\n+        #[allow(non_upper_case_globals)]\n         #[deprecated = \"use USER_DIR instead\"]\n         const UserDir  = USER_DIR.bits,\n         #[doc = \"Deprecated: use `USER_EXEC` instead.\"]\n-        #[allow(non_uppercase_statics)]\n+        #[allow(non_upper_case_globals)]\n         #[deprecated = \"use USER_EXEC instead\"]\n         const UserExec = USER_EXEC.bits,\n \n         #[doc = \"Deprecated: use `ALL_PERMISSIONS` instead\"]\n-        #[allow(non_uppercase_statics)]\n+        #[allow(non_upper_case_globals)]\n         #[deprecated = \"use ALL_PERMISSIONS instead\"]\n         const AllPermissions = ALL_PERMISSIONS.bits,\n     }"}, {"sha": "3c72f58b10d8fdf8918ad318f901e9997401d75b", "filename": "src/libstd/io/net/addrinfo.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -17,7 +17,7 @@ getaddrinfo()\n \n */\n \n-#![allow(missing_doc)]\n+#![allow(missing_docs)]\n \n use iter::Iterator;\n use io::{IoResult, IoError};\n@@ -91,7 +91,7 @@ pub fn get_host_addresses(host: &str) -> IoResult<Vec<IpAddr>> {\n ///\n /// FIXME: this is not public because the `Hint` structure is not ready for public\n ///      consumption just yet.\n-#[allow(unused_variable)]\n+#[allow(unused_variables)]\n fn lookup(hostname: Option<&str>, servname: Option<&str>, hint: Option<Hint>)\n           -> IoResult<Vec<Info>> {\n     let hint = hint.map(|Hint { family, socktype, protocol, flags }| {\n@@ -125,6 +125,7 @@ fn lookup(hostname: Option<&str>, servname: Option<&str>, hint: Option<Hint>)\n // permission without help of apk\n #[cfg(all(test, not(target_os = \"android\")))]\n mod test {\n+    use prelude::*;\n     use super::*;\n     use io::net::ip::*;\n "}, {"sha": "e93af7446990a83b4ef0ca6d9f653065bbdb3acc", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -13,7 +13,7 @@\n //! This module contains functions useful for parsing, formatting, and\n //! manipulating IP addresses.\n \n-#![allow(missing_doc)]\n+#![allow(missing_docs)]\n \n use collections::Collection;\n use fmt;"}, {"sha": "8c7deadebea10279ae386389584eda0aa2664c47", "filename": "src/libstd/io/net/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -22,7 +22,7 @@ instances as clients.\n \n */\n \n-#![allow(missing_doc)]\n+#![allow(missing_docs)]\n \n use prelude::*;\n "}, {"sha": "c77cffd561e66fdef30f609120bc8324e2efa5f5", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -13,7 +13,7 @@\n //! Currently these aren't particularly useful, there only exists bindings\n //! enough so that pipes can be created to child processes.\n \n-#![allow(missing_doc)]\n+#![allow(missing_docs)]\n \n use prelude::*;\n "}, {"sha": "4e5f8822acb40f097df7993627fef3e3fdeb423c", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -11,7 +11,7 @@\n //! Bindings for executing child processes\n \n #![allow(experimental)]\n-#![allow(non_uppercase_statics)]\n+#![allow(non_upper_case_globals)]\n \n use prelude::*;\n "}, {"sha": "67080f4551f06661a6222095ca83f01f85bb9400", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -113,7 +113,7 @@\n // Don't link to std. We are std.\n #![no_std]\n \n-#![deny(missing_doc)]\n+#![deny(missing_docs)]\n \n #![reexport_test_harness_main = \"test_main\"]\n "}, {"sha": "0712719dd042d0c2f30c2ce88ca2f5512f423c2e", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -304,11 +304,11 @@ macro_rules! println(\n #[macro_export]\n macro_rules! local_data_key(\n     ($name:ident: $ty:ty) => (\n-        #[allow(non_uppercase_statics)]\n+        #[allow(non_upper_case_globals)]\n         static $name: ::std::local_data::Key<$ty> = &::std::local_data::KeyValueKey;\n     );\n     (pub $name:ident: $ty:ty) => (\n-        #[allow(non_uppercase_statics)]\n+        #[allow(non_upper_case_globals)]\n         pub static $name: ::std::local_data::Key<$ty> = &::std::local_data::KeyValueKey;\n     );\n )"}, {"sha": "0b2f17b8f93cc95f52476026a1f9c36578f28abf", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -11,8 +11,8 @@\n //! Operations and constants for 32-bits floats (`f32` type)\n \n #![experimental]\n-#![allow(missing_doc)]\n-#![allow(unsigned_negate)]\n+#![allow(missing_docs)]\n+#![allow(unsigned_negation)]\n #![doc(primitive = \"f32\")]\n \n use prelude::*;"}, {"sha": "35555b140815a8f04a472a325d10cf87c0be2042", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -11,7 +11,7 @@\n //! Operations and constants for 64-bits floats (`f64` type)\n \n #![experimental]\n-#![allow(missing_doc)]\n+#![allow(missing_docs)]\n #![doc(primitive = \"f64\")]\n \n use prelude::*;"}, {"sha": "ffe162cbc64fcc80b75251e9ea7eea553a9381b3", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -14,7 +14,7 @@\n //! u32, u64, uint, i8, i16, i32, i64, int, f32, f64}`.\n \n #![experimental]\n-#![allow(missing_doc)]\n+#![allow(missing_docs)]\n \n use option::Option;\n "}, {"sha": "3b17f0bc79fa7c5700d1dd27e4f09f25a3ea8063", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -10,7 +10,7 @@\n //\n // ignore-lexer-test FIXME #15679\n \n-#![allow(missing_doc)]\n+#![allow(missing_docs)]\n \n use char;\n use clone::Clone;\n@@ -424,10 +424,10 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n                     // or set to 0 if max and carry the 1.\n                     let current_digit = ascii2value(buf[i as uint]);\n                     if current_digit < (radix - 1) {\n-                        *buf.get_mut(i as uint) = value2ascii(current_digit+1);\n+                        buf[i as uint] = value2ascii(current_digit+1);\n                         break;\n                     } else {\n-                        *buf.get_mut(i as uint) = value2ascii(0);\n+                        buf[i as uint] = value2ascii(0);\n                         i -= 1;\n                     }\n                 }"}, {"sha": "c69c3ffa41c0e49c8e6ebdca4ffa294247243857", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -11,7 +11,7 @@\n #![experimental]\n #![macro_escape]\n #![doc(hidden)]\n-#![allow(unsigned_negate)]\n+#![allow(unsigned_negation)]\n \n macro_rules! uint_module (($T:ty) => (\n "}, {"sha": "d4e6251cebeb0204975a726d5dc33d84eb66f68a", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -28,7 +28,7 @@\n \n #![experimental]\n \n-#![allow(missing_doc)]\n+#![allow(missing_docs)]\n #![allow(non_snake_case)]\n \n use clone::Clone;\n@@ -144,7 +144,7 @@ pub mod windows {\n     use option::{None, Option};\n     use option;\n     use os::TMPBUF_SZ;\n-    use slice::MutableSlice;\n+    use slice::{MutableSlice, ImmutableSlice};\n     use string::String;\n     use str::StrSlice;\n     use vec::Vec;"}, {"sha": "0d7a467b313f2e9d201d159ff981bde566c5e156", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -457,9 +457,9 @@ fn normalize_helper<'a>(v: &'a [u8], is_abs: bool) -> Option<Vec<&'a [u8]>> {\n     }\n }\n \n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n static dot_static: &'static [u8] = b\".\";\n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n static dot_dot_static: &'static [u8] = b\"..\";\n \n #[cfg(test)]"}, {"sha": "1ddc027a07eab3f331b6840d80a1cc19de600c67", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -776,15 +776,15 @@ impl Path {\n                                 let mut s = String::from_str(s.slice_to(len));\n                                 unsafe {\n                                     let v = s.as_mut_vec();\n-                                    *v.get_mut(0) = (*v)[0]\n+                                    v[0] = (*v)[0]\n                                                      .to_ascii()\n                                                      .to_uppercase()\n                                                      .to_byte();\n                                 }\n                                 if is_abs {\n                                     // normalize C:/ to C:\\\n                                     unsafe {\n-                                        *s.as_mut_vec().get_mut(2) = SEP_BYTE;\n+                                        s.as_mut_vec()[2] = SEP_BYTE;\n                                     }\n                                 }\n                                 Some(s)\n@@ -794,7 +794,7 @@ impl Path {\n                                 let mut s = String::from_str(s.slice_to(len));\n                                 unsafe {\n                                     let v = s.as_mut_vec();\n-                                    *v.get_mut(4) = (*v)[4].to_ascii().to_uppercase().to_byte();\n+                                    v[4] = (*v)[4].to_ascii().to_uppercase().to_byte();\n                                 }\n                                 Some(s)\n                             }"}, {"sha": "48be404b0d02a88ffdbf049b0d79ed54a97555fc", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -76,7 +76,7 @@\n #[doc(no_inline)] pub use num::{FloatMath, ToPrimitive, FromPrimitive};\n #[doc(no_inline)] pub use boxed::Box;\n #[doc(no_inline)] pub use path::{GenericPath, Path, PosixPath, WindowsPath};\n-#[doc(no_inline)] pub use ptr::RawPtr;\n+#[doc(no_inline)] pub use ptr::{RawPtr, RawMutPtr};\n #[doc(no_inline)] pub use io::{Buffer, Writer, Reader, Seek};\n #[doc(no_inline)] pub use str::{Str, StrVector, StrSlice};\n #[doc(no_inline)] pub use str::{IntoMaybeOwned, StrAllocating, UnicodeStrSlice};"}, {"sha": "21e531d211a85076fee0fd0fcae727a82ca4df7f", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -411,7 +411,7 @@ pub fn sample<T, I: Iterator<T>, R: Rng>(rng: &mut R,\n     for (i, elem) in iter.enumerate() {\n         let k = rng.gen_range(0, i + 1 + amount);\n         if k < amount {\n-            *reservoir.get_mut(k) = elem;\n+            reservoir[k] = elem;\n         }\n     }\n     return reservoir;"}, {"sha": "bf5bdc8a308e39de711093969d99bfa70851f1f2", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -88,7 +88,7 @@ mod imp {\n     #[repr(C)]\n     struct SecRandom;\n \n-    #[allow(non_uppercase_statics)]\n+    #[allow(non_upper_case_globals)]\n     static kSecRandomDefault: *const SecRandom = 0 as *const SecRandom;\n \n     #[link(name = \"Security\", kind = \"framework\")]"}, {"sha": "b97e80d0dc1d06e778719e6138917d86e35ee83e", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -52,7 +52,7 @@ Several modules in `core` are clients of `rt`:\n #![experimental]\n \n // FIXME: this should not be here.\n-#![allow(missing_doc)]\n+#![allow(missing_docs)]\n \n use failure;\n use rustrt;"}, {"sha": "be0af3a3f1ae320357b9528e1054232b46a7d2da", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -24,7 +24,7 @@\n  * ```\n  */\n \n-#![allow(missing_doc)]\n+#![allow(missing_docs)]\n \n use core::prelude::*;\n use core::mem::replace;"}, {"sha": "42de6f66289a205a7b6fd5b6967ce8b49ad8984b", "filename": "src/libsync/comm/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsync%2Fcomm%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsync%2Fcomm%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fsync.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -426,15 +426,15 @@ impl<T> Buffer<T> {\n     fn enqueue(&mut self, t: T) {\n         let pos = (self.start + self.size) % self.buf.len();\n         self.size += 1;\n-        let prev = mem::replace(self.buf.get_mut(pos), Some(t));\n+        let prev = mem::replace(&mut self.buf[pos], Some(t));\n         assert!(prev.is_none());\n     }\n \n     fn dequeue(&mut self) -> T {\n         let start = self.start;\n         self.size -= 1;\n         self.start = (self.start + 1) % self.buf.len();\n-        self.buf.get_mut(start).take().unwrap()\n+        self.buf[start].take().unwrap()\n     }\n \n     fn size(&self) -> uint { self.size }"}, {"sha": "ffff32f04c488a4e2337d283f2d89c4682044d46", "filename": "src/libsync/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsync%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsync%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Flib.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -29,7 +29,7 @@\n \n #![feature(phase, globs, macro_rules, unsafe_destructor)]\n #![feature(import_shadowing)]\n-#![deny(missing_doc)]\n+#![deny(missing_docs)]\n #![no_std]\n \n #[phase(plugin, link)] extern crate core;"}, {"sha": "f75511ecbc2e42d87d4ed9394a3b524e345ad213", "filename": "src/libsync/mpmc_bounded_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsync%2Fmpmc_bounded_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsync%2Fmpmc_bounded_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmpmc_bounded_queue.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -26,7 +26,7 @@\n  */\n \n #![experimental]\n-#![allow(missing_doc, dead_code)]\n+#![allow(missing_docs, dead_code)]\n \n // http://www.1024cores.net/home/lock-free-algorithms/queues/bounded-mpmc-queue\n "}, {"sha": "1410091b924ba97e7c8eb1435161b3e684c0fe21", "filename": "src/libsync/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsync%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsync%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fraw.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -308,7 +308,7 @@ impl<'a> Condvar<'a> {\n                     // To avoid :broadcast_heavy, we make a new waitqueue,\n                     // swap it out with the old one, and broadcast on the\n                     // old one outside of the little-lock.\n-                    queue = Some(mem::replace(state.blocked.get_mut(condvar_id),\n+                    queue = Some(mem::replace(&mut state.blocked[condvar_id],\n                                               WaitQueue::new()));\n                 } else {\n                     out_of_bounds = Some(state.blocked.len());"}, {"sha": "dc41f3d9279578574429d9198e0b552af610dbf9", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -47,9 +47,9 @@ pub enum Architecture {\n     Mipsel\n }\n \n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n const IntelBits: u32 = (1 << (X86 as uint)) | (1 << (X86_64 as uint));\n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n const ArmBits: u32 = (1 << (Arm as uint));\n \n pub struct AbiData {\n@@ -72,7 +72,7 @@ pub enum AbiArchitecture {\n     Archs(u32)\n }\n \n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n static AbiDatas: &'static [AbiData] = &[\n     // Platform-specific ABIs\n     AbiData {abi: Cdecl, name: \"cdecl\", abi_arch: Archs(IntelBits)},"}, {"sha": "a2c859cf9fd3c4ae0207e9be401842d0092d6dd5", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -595,17 +595,38 @@ pub enum CaptureClause {\n     CaptureByRef,\n }\n \n-/// A token that delimits a sequence of token trees\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n-pub struct Delimiter {\n-    pub span: Span,\n-    pub token: ::parse::token::Token,\n-}\n+/// A delimited sequence of token trees\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub struct Delimited {\n+    /// The type of delimiter\n+    pub delim: token::DelimToken,\n+    /// The span covering the opening delimiter\n+    pub open_span: Span,\n+    /// The delimited sequence of token trees\n+    pub tts: Vec<TokenTree>,\n+    /// The span covering the closing delimiter\n+    pub close_span: Span,\n+}\n+\n+impl Delimited {\n+    /// Returns the opening delimiter as a token.\n+    pub fn open_token(&self) -> token::Token {\n+        token::OpenDelim(self.delim)\n+    }\n+\n+    /// Returns the closing delimiter as a token.\n+    pub fn close_token(&self) -> token::Token {\n+        token::CloseDelim(self.delim)\n+    }\n+\n+    /// Returns the opening delimiter as a token tree.\n+    pub fn open_tt(&self) -> TokenTree {\n+        TtToken(self.open_span, self.open_token())\n+    }\n \n-impl Delimiter {\n-    /// Convert the delimiter to a `TtToken`\n-    pub fn to_tt(&self) -> TokenTree {\n-        TtToken(self.span, self.token.clone())\n+    /// Returns the closing delimiter as a token tree.\n+    pub fn close_tt(&self) -> TokenTree {\n+        TtToken(self.close_span, self.close_token())\n     }\n }\n \n@@ -635,15 +656,15 @@ pub enum KleeneOp {\n #[doc=\"For macro invocations; parsing is delegated to the macro\"]\n pub enum TokenTree {\n     /// A single token\n-    TtToken(Span, ::parse::token::Token),\n+    TtToken(Span, token::Token),\n     /// A delimited sequence of token trees\n-    TtDelimited(Span, Rc<(Delimiter, Vec<TokenTree>, Delimiter)>),\n+    TtDelimited(Span, Rc<Delimited>),\n \n     // These only make sense for right-hand-sides of MBE macros:\n \n     /// A Kleene-style repetition sequence with an optional separator.\n     // FIXME(eddyb) #6308 Use Rc<[TokenTree]> after DST.\n-    TtSequence(Span, Rc<Vec<TokenTree>>, Option<::parse::token::Token>, KleeneOp),\n+    TtSequence(Span, Rc<Vec<TokenTree>>, Option<token::Token>, KleeneOp),\n     /// A syntactic variable that will be filled in by macro expansion.\n     TtNonterminal(Span, Ident)\n }\n@@ -715,10 +736,10 @@ pub type Matcher = Spanned<Matcher_>;\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Matcher_ {\n     /// Match one token\n-    MatchTok(::parse::token::Token),\n+    MatchTok(token::Token),\n     /// Match repetitions of a sequence: body, separator, Kleene operator,\n     /// lo, hi position-in-match-array used:\n-    MatchSeq(Vec<Matcher> , Option<::parse::token::Token>, KleeneOp, uint, uint),\n+    MatchSeq(Vec<Matcher>, Option<token::Token>, KleeneOp, uint, uint),\n     /// Parse a Rust NT: name to bind, name of NT, position in match array:\n     MatchNonterminal(Ident, Ident, uint)\n }"}, {"sha": "fa36577ebdb1f5978ceeb1620224e15019cbb9ad", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -712,7 +712,7 @@ impl<'ast> NodeCollector<'ast> {\n         if id as uint >= len {\n             self.map.grow(id as uint - len + 1, NotPresent);\n         }\n-        *self.map.get_mut(id as uint) = entry;\n+        self.map[id as uint] = entry;\n     }\n \n     fn insert(&mut self, id: NodeId, node: Node<'ast>) {"}, {"sha": "8b0e1f32fd4c90dadaf277d4d3722cc39758b3df", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -291,7 +291,7 @@ pub fn operator_prec(op: ast::BinOp) -> uint {\n \n /// Precedence of the `as` operator, which is a binary operator\n /// not appearing in the prior table.\n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n pub static as_prec: uint = 12u;\n \n pub fn empty_generics() -> Generics {"}, {"sha": "b4bf793d4e197f51464f22e8598a5099dfb2db03", "filename": "src/libsyntax/diagnostics/macros.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -39,6 +39,13 @@ macro_rules! span_note(\n     })\n )\n \n+#[macro_export]\n+macro_rules! span_help(\n+    ($session:expr, $span:expr, $($message:tt)*) => ({\n+        ($session).span_help($span, format!($($message)*).as_slice())\n+    })\n+)\n+\n #[macro_export]\n macro_rules! register_diagnostics(\n     ($($code:tt),*) => ("}, {"sha": "d57d6e52d7fd4ffe0dc6d09a07cabc8b1da8769d", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -84,9 +84,9 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n                     let span = p.last_span;\n \n-                    p.expect(&token::LParen);\n+                    p.expect(&token::OpenDelim(token::Paren));\n                     let out = p.parse_expr();\n-                    p.expect(&token::RParen);\n+                    p.expect(&token::CloseDelim(token::Paren));\n \n                     // Expands a read+write operand into two operands.\n                     //\n@@ -129,9 +129,9 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                         cx.span_err(p.last_span, \"input operand constraint contains '+'\");\n                     }\n \n-                    p.expect(&token::LParen);\n+                    p.expect(&token::OpenDelim(token::Paren));\n                     let input = p.parse_expr();\n-                    p.expect(&token::RParen);\n+                    p.expect(&token::CloseDelim(token::Paren));\n \n                     inputs.push((constraint, input));\n                 }"}, {"sha": "e641abbfeee64763f7eb8a0cfd8f2585b075039a", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -785,6 +785,6 @@ impl SyntaxEnv {\n \n     pub fn info<'a>(&'a mut self) -> &'a mut BlockInfo {\n         let last_chain_index = self.chain.len() - 1;\n-        &mut self.chain.get_mut(last_chain_index).info\n+        &mut self.chain[last_chain_index].info\n     }\n }"}, {"sha": "fa9a844233a199d79f72deee0f25dd196f843310", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -247,7 +247,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     self.verify_same(self.args[arg].span, &ty, arg_type);\n                 }\n                 if self.arg_types[arg].is_none() {\n-                    *self.arg_types.get_mut(arg) = Some(ty);\n+                    self.arg_types[arg] = Some(ty);\n                 }\n             }\n \n@@ -567,7 +567,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             let lname = self.ecx.ident_of(format!(\"__arg{}\",\n                                                   *name).as_slice());\n             pats.push(self.ecx.pat_ident(e.span, lname));\n-            *names.get_mut(self.name_positions[*name]) =\n+            names[self.name_positions[*name]] =\n                 Some(Context::format_arg(self.ecx, e.span, arg_ty,\n                                          self.ecx.expr_ident(e.span, lname)));\n             heads.push(self.ecx.expr_addr_of(e.span, e));"}, {"sha": "f751655c9ff622e31b85b3c3fb0e4aa984bbccd3", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -531,7 +531,16 @@ fn mk_binop(cx: &ExtCtxt, sp: Span, bop: token::BinOpToken) -> P<ast::Expr> {\n     mk_token_path(cx, sp, name)\n }\n \n-#[allow(non_uppercase_statics)] // NOTE(stage0): remove this attribute after the next snapshot\n+fn mk_delim(cx: &ExtCtxt, sp: Span, delim: token::DelimToken) -> P<ast::Expr> {\n+    let name = match delim {\n+        token::Paren     => \"Paren\",\n+        token::Bracket   => \"Bracket\",\n+        token::Brace     => \"Brace\",\n+    };\n+    mk_token_path(cx, sp, name)\n+}\n+\n+#[allow(non_upper_case_globals)]\n fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n     match *tok {\n         token::BinOp(binop) => {\n@@ -542,6 +551,15 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n                                 vec!(mk_binop(cx, sp, binop)));\n         }\n \n+        token::OpenDelim(delim) => {\n+            return cx.expr_call(sp, mk_token_path(cx, sp, \"OpenDelim\"),\n+                                vec![mk_delim(cx, sp, delim)]);\n+        }\n+        token::CloseDelim(delim) => {\n+            return cx.expr_call(sp, mk_token_path(cx, sp, \"CloseDelim\"),\n+                                vec![mk_delim(cx, sp, delim)]);\n+        }\n+\n         token::LitByte(i) => {\n             let e_byte = mk_name(cx, sp, i.ident());\n \n@@ -625,12 +643,6 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n         token::RArrow       => \"RArrow\",\n         token::LArrow       => \"LArrow\",\n         token::FatArrow     => \"FatArrow\",\n-        token::LParen       => \"LParen\",\n-        token::RParen       => \"RParen\",\n-        token::LBracket     => \"LBracket\",\n-        token::RBracket     => \"RBracket\",\n-        token::LBrace       => \"LBrace\",\n-        token::RBrace       => \"RBrace\",\n         token::Pound        => \"Pound\",\n         token::Dollar       => \"Dollar\",\n         token::Underscore   => \"Underscore\",\n@@ -640,7 +652,6 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n     mk_token_path(cx, sp, name)\n }\n \n-\n fn mk_tt(cx: &ExtCtxt, _: Span, tt: &ast::TokenTree) -> Vec<P<ast::Stmt>> {\n     match *tt {\n         ast::TtToken(sp, ref tok) => {\n@@ -656,10 +667,9 @@ fn mk_tt(cx: &ExtCtxt, _: Span, tt: &ast::TokenTree) -> Vec<P<ast::Stmt>> {\n             vec!(cx.stmt_expr(e_push))\n         },\n         ast::TtDelimited(sp, ref delimed) => {\n-            let (ref open, ref tts, ref close) = **delimed;\n-            mk_tt(cx, sp, &open.to_tt()).into_iter()\n-                .chain(tts.iter().flat_map(|tt| mk_tt(cx, sp, tt).into_iter()))\n-                .chain(mk_tt(cx, sp, &close.to_tt()).into_iter())\n+            mk_tt(cx, sp, &delimed.open_tt()).into_iter()\n+                .chain(delimed.tts.iter().flat_map(|tt| mk_tt(cx, sp, tt).into_iter()))\n+                .chain(mk_tt(cx, sp, &delimed.close_tt()).into_iter())\n                 .collect()\n         },\n         ast::TtSequence(..) => panic!(\"TtSequence in quote!\"),"}, {"sha": "b522d5881d7622212a20baf9e0c78be4627b07df", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -288,8 +288,7 @@ pub fn parse(sess: &ParseSess,\n                         // Only touch the binders we have actually bound\n                         for idx in range(ei.match_lo, ei.match_hi) {\n                             let sub = (ei.matches[idx]).clone();\n-                            new_pos.matches\n-                                   .get_mut(idx)\n+                            new_pos.matches[idx]\n                                    .push(Rc::new(MatchedSeq(sub, mk_sp(ei.sp_lo,\n                                                                        sp.hi))));\n                         }\n@@ -331,8 +330,7 @@ pub fn parse(sess: &ParseSess,\n                         new_ei.idx += 1u;\n                         //we specifically matched zero repeats.\n                         for idx in range(match_idx_lo, match_idx_hi) {\n-                            new_ei.matches\n-                                  .get_mut(idx)\n+                            new_ei.matches[idx]\n                                   .push(Rc::new(MatchedSeq(Vec::new(), sp)));\n                         }\n \n@@ -355,10 +353,8 @@ pub fn parse(sess: &ParseSess,\n                     // Built-in nonterminals never start with these tokens,\n                     // so we can eliminate them from consideration.\n                     match tok {\n-                        token::RParen |\n-                        token::RBrace |\n-                        token::RBracket => {},\n-                        _ => bb_eis.push(ei)\n+                        token::CloseDelim(_) => {},\n+                        _ => bb_eis.push(ei),\n                     }\n                   }\n                   MatchTok(ref t) => {\n@@ -376,7 +372,7 @@ pub fn parse(sess: &ParseSess,\n         if token_name_eq(&tok, &token::Eof) {\n             if eof_eis.len() == 1u {\n                 let mut v = Vec::new();\n-                for dv in eof_eis.get_mut(0).matches.iter_mut() {\n+                for dv in eof_eis[0].matches.iter_mut() {\n                     v.push(dv.pop().unwrap());\n                 }\n                 return Success(nameize(sess, ms, v.as_slice()));\n@@ -417,7 +413,7 @@ pub fn parse(sess: &ParseSess,\n                 match ei.elts[ei.idx].node {\n                   MatchNonterminal(_, name, idx) => {\n                     let name_string = token::get_ident(name);\n-                    ei.matches.get_mut(idx).push(Rc::new(MatchedNonterminal(\n+                    ei.matches[idx].push(Rc::new(MatchedNonterminal(\n                         parse_nt(&mut rust_parser, name_string.get()))));\n                     ei.idx += 1u;\n                   }"}, {"sha": "e50d4457af2492af1931b700ea62778fe82cba67", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -172,10 +172,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                     MatchedNonterminal(NtTT(ref tt)) => {\n                         match **tt {\n                             // ignore delimiters\n-                            TtDelimited(_, ref delimed) => {\n-                                let (_, ref tts, _) = **delimed;\n-                                tts.clone()\n-                            },\n+                            TtDelimited(_, ref delimed) => delimed.tts.clone(),\n                             _ => cx.span_fatal(sp, \"macro rhs must be delimited\"),\n                         }\n                     },"}, {"sha": "249a985a6488aa131cead26320825202a31c23cd", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -129,8 +129,7 @@ impl Add<LockstepIterSize, LockstepIterSize> for LockstepIterSize {\n fn lockstep_iter_size(t: &TokenTree, r: &TtReader) -> LockstepIterSize {\n     match *t {\n         TtDelimited(_, ref delimed) => {\n-            let (_, ref tts, _) = **delimed;\n-            tts.iter().fold(LisUnconstrained, |size, tt| {\n+            delimed.tts.iter().fold(LisUnconstrained, |size, tt| {\n                 size + lockstep_iter_size(tt, r)\n             })\n         },\n@@ -207,14 +206,13 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n         };\n         match t {\n             TtDelimited(_, ref delimed) => {\n-                let (ref open, ref tts, ref close) = **delimed;\n-                let mut forest = Vec::with_capacity(1 + tts.len() + 1);\n-                forest.push(open.to_tt());\n-                forest.extend(tts.iter().map(|x| (*x).clone()));\n-                forest.push(close.to_tt());\n+                let mut tts = Vec::with_capacity(1 + delimed.tts.len() + 1);\n+                tts.push(delimed.open_tt());\n+                tts.extend(delimed.tts.iter().map(|tt| tt.clone()));\n+                tts.push(delimed.close_tt());\n \n                 r.stack.push(TtFrame {\n-                    forest: Rc::new(forest),\n+                    forest: Rc::new(tts),\n                     idx: 0,\n                     dotdotdoted: false,\n                     sep: None"}, {"sha": "9a55f07e98d798f51bf845e43aee0cfa5e5f10cb", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -572,18 +572,14 @@ pub fn noop_fold_tt<T: Folder>(tt: &TokenTree, fld: &mut T) -> TokenTree {\n         TtToken(span, ref tok) =>\n             TtToken(span, fld.fold_token(tok.clone())),\n         TtDelimited(span, ref delimed) => {\n-            let (ref open, ref tts, ref close) = **delimed;\n-            TtDelimited(span, Rc::new((\n-                            Delimiter {\n-                                span: open.span,\n-                                token: fld.fold_token(open.token.clone())\n-                            },\n-                            fld.fold_tts(tts.as_slice()),\n-                            Delimiter {\n-                                span: close.span,\n-                                token: fld.fold_token(close.token.clone())\n-                            },\n-                        )))\n+            TtDelimited(span, Rc::new(\n+                            Delimited {\n+                                delim: delimed.delim,\n+                                open_span: delimed.open_span,\n+                                tts: fld.fold_tts(delimed.tts.as_slice()),\n+                                close_span: delimed.close_span,\n+                            }\n+                        ))\n         },\n         TtSequence(span, ref pattern, ref sep, is_optional) =>\n             TtSequence(span,"}, {"sha": "aefac804e4d88267e1881aad97f6f7002fec2912", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -81,10 +81,10 @@ impl<'a> ParserAttr for Parser<'a> {\n                     ast::AttrOuter\n                 };\n \n-                self.expect(&token::LBracket);\n+                self.expect(&token::OpenDelim(token::Bracket));\n                 let meta_item = self.parse_meta_item();\n                 let hi = self.span.hi;\n-                self.expect(&token::RBracket);\n+                self.expect(&token::CloseDelim(token::Bracket));\n \n                 (mk_sp(lo, hi), meta_item, style)\n             }\n@@ -194,7 +194,7 @@ impl<'a> ParserAttr for Parser<'a> {\n                 let hi = self.span.hi;\n                 P(spanned(lo, hi, ast::MetaNameValue(name, lit)))\n             }\n-            token::LParen => {\n+            token::OpenDelim(token::Paren) => {\n                 let inner_items = self.parse_meta_seq();\n                 let hi = self.span.hi;\n                 P(spanned(lo, hi, ast::MetaList(name, inner_items)))\n@@ -208,15 +208,15 @@ impl<'a> ParserAttr for Parser<'a> {\n \n     /// matches meta_seq = ( COMMASEP(meta_item) )\n     fn parse_meta_seq(&mut self) -> Vec<P<ast::MetaItem>> {\n-        self.parse_seq(&token::LParen,\n-                       &token::RParen,\n+        self.parse_seq(&token::OpenDelim(token::Paren),\n+                       &token::CloseDelim(token::Paren),\n                        seq_sep_trailing_disallowed(token::Comma),\n                        |p| p.parse_meta_item()).node\n     }\n \n     fn parse_optional_meta(&mut self) -> Vec<P<ast::MetaItem>> {\n         match self.token {\n-            token::LParen => self.parse_meta_seq(),\n+            token::OpenDelim(token::Paren) => self.parse_meta_seq(),\n             _ => Vec::new()\n         }\n     }"}, {"sha": "293b91111b5b2cce4d00df543f86da064b19ab3c", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -967,12 +967,12 @@ impl<'a> StringReader<'a> {\n                   token::Dot\n               };\n           }\n-          '(' => { self.bump(); return token::LParen; }\n-          ')' => { self.bump(); return token::RParen; }\n-          '{' => { self.bump(); return token::LBrace; }\n-          '}' => { self.bump(); return token::RBrace; }\n-          '[' => { self.bump(); return token::LBracket; }\n-          ']' => { self.bump(); return token::RBracket; }\n+          '(' => { self.bump(); return token::OpenDelim(token::Paren); }\n+          ')' => { self.bump(); return token::CloseDelim(token::Paren); }\n+          '{' => { self.bump(); return token::OpenDelim(token::Brace); }\n+          '}' => { self.bump(); return token::CloseDelim(token::Brace); }\n+          '[' => { self.bump(); return token::OpenDelim(token::Bracket); }\n+          ']' => { self.bump(); return token::CloseDelim(token::Bracket); }\n           '@' => { self.bump(); return token::At; }\n           '#' => { self.bump(); return token::Pound; }\n           '~' => { self.bump(); return token::Tilde; }"}, {"sha": "83499ec54c6766cf4e71cfa1f5c476ba86b245ea", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 27, "deletions": 43, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -799,29 +799,23 @@ mod test {\n              ast::TtDelimited(_, ref macro_delimed)]\n             if name_macro_rules.as_str() == \"macro_rules\"\n             && name_zip.as_str() == \"zip\" => {\n-                let (ref macro_open, ref macro_tts, ref macro_close) = **macro_delimed;\n-                match (macro_open, macro_tts.as_slice(), macro_close) {\n-                    (&ast::Delimiter { token: token::LParen, .. },\n-                     [ast::TtDelimited(_, ref first_delimed),\n-                      ast::TtToken(_, token::FatArrow),\n-                      ast::TtDelimited(_, ref second_delimed)],\n-                     &ast::Delimiter { token: token::RParen, .. }) => {\n-                        let (ref first_open, ref first_tts, ref first_close) = **first_delimed;\n-                        match (first_open, first_tts.as_slice(), first_close) {\n-                            (&ast::Delimiter { token: token::LParen, .. },\n-                             [ast::TtToken(_, token::Dollar),\n-                              ast::TtToken(_, token::Ident(name, token::Plain))],\n-                             &ast::Delimiter { token: token::RParen, .. })\n-                            if name.as_str() == \"a\" => {},\n+                match macro_delimed.tts.as_slice() {\n+                    [ast::TtDelimited(_, ref first_delimed),\n+                     ast::TtToken(_, token::FatArrow),\n+                     ast::TtDelimited(_, ref second_delimed)]\n+                    if macro_delimed.delim == token::Paren => {\n+                        match first_delimed.tts.as_slice() {\n+                            [ast::TtToken(_, token::Dollar),\n+                             ast::TtToken(_, token::Ident(name, token::Plain))]\n+                            if first_delimed.delim == token::Paren\n+                            && name.as_str() == \"a\" => {},\n                             _ => panic!(\"value 3: {}\", **first_delimed),\n                         }\n-                        let (ref second_open, ref second_tts, ref second_close) = **second_delimed;\n-                        match (second_open, second_tts.as_slice(), second_close) {\n-                            (&ast::Delimiter { token: token::LParen, .. },\n-                             [ast::TtToken(_, token::Dollar),\n-                              ast::TtToken(_, token::Ident(name, token::Plain))],\n-                             &ast::Delimiter { token: token::RParen, .. })\n-                            if name.as_str() == \"a\" => {},\n+                        match second_delimed.tts.as_slice() {\n+                            [ast::TtToken(_, token::Dollar),\n+                             ast::TtToken(_, token::Ident(name, token::Plain))]\n+                            if second_delimed.delim == token::Paren\n+                            && name.as_str() == \"a\" => {},\n                             _ => panic!(\"value 4: {}\", **second_delimed),\n                         }\n                     },\n@@ -867,12 +861,10 @@ mod test {\n         \\\"variant\\\":\\\"TtDelimited\\\",\\\n         \\\"fields\\\":[\\\n             null,\\\n-            [\\\n-                {\\\n-                    \\\"span\\\":null,\\\n-                    \\\"token\\\":\\\"LParen\\\"\\\n-                },\\\n-                [\\\n+            {\\\n+                \\\"delim\\\":\\\"Paren\\\",\\\n+                \\\"open_span\\\":null,\\\n+                \\\"tts\\\":[\\\n                     {\\\n                         \\\"variant\\\":\\\"TtToken\\\",\\\n                         \\\"fields\\\":[\\\n@@ -907,23 +899,18 @@ mod test {\n                         ]\\\n                     }\\\n                 ],\\\n-                {\\\n-                    \\\"span\\\":null,\\\n-                    \\\"token\\\":\\\"RParen\\\"\\\n-                }\\\n-            ]\\\n+                \\\"close_span\\\":null\\\n+            }\\\n         ]\\\n     },\\\n     {\\\n         \\\"variant\\\":\\\"TtDelimited\\\",\\\n         \\\"fields\\\":[\\\n             null,\\\n-            [\\\n-                {\\\n-                    \\\"span\\\":null,\\\n-                    \\\"token\\\":\\\"LBrace\\\"\\\n-                },\\\n-                [\\\n+            {\\\n+                \\\"delim\\\":\\\"Brace\\\",\\\n+                \\\"open_span\\\":null,\\\n+                \\\"tts\\\":[\\\n                     {\\\n                         \\\"variant\\\":\\\"TtToken\\\",\\\n                         \\\"fields\\\":[\\\n@@ -945,11 +932,8 @@ mod test {\n                         ]\\\n                     }\\\n                 ],\\\n-                {\\\n-                    \\\"span\\\":null,\\\n-                    \\\"token\\\":\\\"RBrace\\\"\\\n-                }\\\n-            ]\\\n+                \\\"close_span\\\":null\\\n+            }\\\n         ]\\\n     }\\\n ]\".to_string()"}, {"sha": "aa3b9668d46320f502a80a184228bd91dc13f0cb", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 228, "deletions": 207, "changes": 435, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -48,7 +48,7 @@ use ast::{StmtExpr, StmtSemi, StmtMac, StructDef, StructField};\n use ast::{StructVariantKind, BiSub};\n use ast::StrStyle;\n use ast::{SelfExplicit, SelfRegion, SelfStatic, SelfValue};\n-use ast::{Delimiter, TokenTree, TraitItem, TraitRef, TtDelimited, TtSequence, TtToken};\n+use ast::{Delimited, TokenTree, TraitItem, TraitRef, TtDelimited, TtSequence, TtToken};\n use ast::{TtNonterminal, TupleVariantKind, Ty, Ty_, TyBot};\n use ast::{TypeField, TyFixedLengthVec, TyClosure, TyProc, TyBareFn};\n use ast::{TyTypeof, TyInfer, TypeMethod};\n@@ -474,15 +474,15 @@ impl<'a> Parser<'a> {\n     /// recover (without consuming any expected input token).  Returns\n     /// true if and only if input was consumed for recovery.\n     pub fn check_for_erroneous_unit_struct_expecting(&mut self, expected: &[token::Token]) -> bool {\n-        if self.token == token::LBrace\n-            && expected.iter().all(|t| *t != token::LBrace)\n-            && self.look_ahead(1, |t| *t == token::RBrace) {\n+        if self.token == token::OpenDelim(token::Brace)\n+            && expected.iter().all(|t| *t != token::OpenDelim(token::Brace))\n+            && self.look_ahead(1, |t| *t == token::CloseDelim(token::Brace)) {\n             // matched; signal non-fatal error and recover.\n             let span = self.span;\n             self.span_err(span,\n                           \"unit-like struct construction is written with no trailing `{ }`\");\n-            self.eat(&token::LBrace);\n-            self.eat(&token::RBrace);\n+            self.eat(&token::OpenDelim(token::Brace));\n+            self.eat(&token::CloseDelim(token::Brace));\n             true\n         } else {\n             false\n@@ -1265,8 +1265,8 @@ impl<'a> Parser<'a> {\n     /// Parse the items in a trait declaration\n     pub fn parse_trait_items(&mut self) -> Vec<TraitItem> {\n         self.parse_unspanned_seq(\n-            &token::LBrace,\n-            &token::RBrace,\n+            &token::OpenDelim(token::Brace),\n+            &token::CloseDelim(token::Brace),\n             seq_sep_none(),\n             |p| {\n             let attrs = p.parse_outer_attributes();\n@@ -1319,7 +1319,7 @@ impl<'a> Parser<'a> {\n                         vis: vis,\n                     })\n                   }\n-                  token::LBrace => {\n+                  token::OpenDelim(token::Brace) => {\n                     debug!(\"parse_trait_methods(): parsing provided method\");\n                     let (inner_attrs, body) =\n                         p.parse_inner_attrs_and_block();\n@@ -1411,9 +1411,9 @@ impl<'a> Parser<'a> {\n \n         let lo = self.span.lo;\n \n-        let t = if self.token == token::LParen {\n+        let t = if self.token == token::OpenDelim(token::Paren) {\n             self.bump();\n-            if self.token == token::RParen {\n+            if self.token == token::CloseDelim(token::Paren) {\n                 self.bump();\n                 TyNil\n             } else {\n@@ -1424,7 +1424,7 @@ impl<'a> Parser<'a> {\n                 let mut one_tuple = false;\n                 while self.token == token::Comma {\n                     self.bump();\n-                    if self.token != token::RParen {\n+                    if self.token != token::CloseDelim(token::Paren) {\n                         ts.push(self.parse_ty(true));\n                     }\n                     else {\n@@ -1433,11 +1433,11 @@ impl<'a> Parser<'a> {\n                 }\n \n                 if ts.len() == 1 && !one_tuple {\n-                    self.expect(&token::RParen);\n+                    self.expect(&token::CloseDelim(token::Paren));\n                     TyParen(ts.into_iter().nth(0).unwrap())\n                 } else {\n                     let t = TyTup(ts);\n-                    self.expect(&token::RParen);\n+                    self.expect(&token::CloseDelim(token::Paren));\n                     t\n                 }\n             }\n@@ -1446,17 +1446,17 @@ impl<'a> Parser<'a> {\n             self.bump();\n             let last_span = self.last_span;\n             match self.token {\n-                token::LBracket => self.obsolete(last_span, ObsoleteOwnedVector),\n+                token::OpenDelim(token::Bracket) => self.obsolete(last_span, ObsoleteOwnedVector),\n                 _ => self.obsolete(last_span, ObsoleteOwnedType)\n             }\n             TyUniq(self.parse_ty(false))\n         } else if self.token == token::BinOp(token::Star) {\n             // STAR POINTER (bare pointer?)\n             self.bump();\n             TyPtr(self.parse_ptr())\n-        } else if self.token == token::LBracket {\n+        } else if self.token == token::OpenDelim(token::Bracket) {\n             // VECTOR\n-            self.expect(&token::LBracket);\n+            self.expect(&token::OpenDelim(token::Bracket));\n             let t = self.parse_ty(true);\n \n             // Parse the `, ..e` in `[ int, ..e ]`\n@@ -1465,7 +1465,7 @@ impl<'a> Parser<'a> {\n                 None => TyVec(t),\n                 Some(suffix) => TyFixedLengthVec(t, suffix)\n             };\n-            self.expect(&token::RBracket);\n+            self.expect(&token::CloseDelim(token::Bracket));\n             t\n         } else if self.token == token::BinOp(token::And) ||\n                 self.token == token::AndAnd {\n@@ -1490,9 +1490,9 @@ impl<'a> Parser<'a> {\n         } else if self.eat_keyword(keywords::Typeof) {\n             // TYPEOF\n             // In order to not be ambiguous, the type must be surrounded by parens.\n-            self.expect(&token::LParen);\n+            self.expect(&token::OpenDelim(token::Paren));\n             let e = self.parse_expr();\n-            self.expect(&token::RParen);\n+            self.expect(&token::CloseDelim(token::Paren));\n             TyTypeof(e)\n         } else if self.eat_keyword(keywords::Proc) {\n             self.parse_proc_type()\n@@ -1661,7 +1661,10 @@ impl<'a> Parser<'a> {\n                 LitBinary(parse::binary_lit(i.as_str())),\n             token::LitBinaryRaw(i, _) =>\n                 LitBinary(Rc::new(i.as_str().as_bytes().iter().map(|&x| x).collect())),\n-            token::LParen => { self.expect(&token::RParen); LitNil },\n+            token::OpenDelim(token::Paren) => {\n+                self.expect(&token::CloseDelim(token::Paren));\n+                LitNil\n+            },\n             _ => { self.unexpected_last(tok); }\n         }\n     }\n@@ -2013,6 +2016,16 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n+    fn expect_open_delim(&mut self) -> token::DelimToken {\n+        match self.token {\n+            token::OpenDelim(delim) => {\n+                self.bump();\n+                delim\n+            },\n+            _ => self.fatal(\"expected open delimiter\"),\n+        }\n+    }\n+\n     /// At the bottom (top?) of the precedence hierarchy,\n     /// parse things like parenthesized exprs,\n     /// macros, return, etc.\n@@ -2025,39 +2038,40 @@ impl<'a> Parser<'a> {\n         let ex: Expr_;\n \n         match self.token {\n-            token::LParen => {\n+            token::OpenDelim(token::Paren) => {\n                 self.bump();\n                 // (e) is parenthesized e\n                 // (e,) is a tuple with only one field, e\n                 let mut trailing_comma = false;\n-                if self.token == token::RParen {\n+                if self.token == token::CloseDelim(token::Paren) {\n                     hi = self.span.hi;\n                     self.bump();\n                     let lit = P(spanned(lo, hi, LitNil));\n                     return self.mk_expr(lo, hi, ExprLit(lit));\n                 }\n                 let mut es = vec!(self.parse_expr());\n-                self.commit_expr(&**es.last().unwrap(), &[], &[token::Comma, token::RParen]);\n+                self.commit_expr(&**es.last().unwrap(), &[],\n+                                 &[token::Comma, token::CloseDelim(token::Paren)]);\n                 while self.token == token::Comma {\n                     self.bump();\n-                    if self.token != token::RParen {\n+                    if self.token != token::CloseDelim(token::Paren) {\n                         es.push(self.parse_expr());\n                         self.commit_expr(&**es.last().unwrap(), &[],\n-                                         &[token::Comma, token::RParen]);\n+                                         &[token::Comma, token::CloseDelim(token::Paren)]);\n                     } else {\n                         trailing_comma = true;\n                     }\n                 }\n                 hi = self.span.hi;\n-                self.commit_expr_expecting(&**es.last().unwrap(), token::RParen);\n+                self.commit_expr_expecting(&**es.last().unwrap(), token::CloseDelim(token::Paren));\n \n                 return if es.len() == 1 && !trailing_comma {\n                    self.mk_expr(lo, hi, ExprParen(es.into_iter().nth(0).unwrap()))\n                 } else {\n                     self.mk_expr(lo, hi, ExprTup(es))\n                 }\n             },\n-            token::LBrace => {\n+            token::OpenDelim(token::Brace) => {\n                 self.bump();\n                 let blk = self.parse_block_tail(lo, DefaultBlock);\n                 return self.mk_expr(blk.span.lo, blk.span.hi,\n@@ -2077,10 +2091,10 @@ impl<'a> Parser<'a> {\n                 ex = ExprPath(path);\n                 hi = self.last_span.hi;\n             }\n-            token::LBracket => {\n+            token::OpenDelim(token::Bracket) => {\n                 self.bump();\n \n-                if self.token == token::RBracket {\n+                if self.token == token::CloseDelim(token::Bracket) {\n                     // Empty vector.\n                     self.bump();\n                     ex = ExprVec(Vec::new());\n@@ -2093,13 +2107,13 @@ impl<'a> Parser<'a> {\n                         self.bump();\n                         self.bump();\n                         let count = self.parse_expr();\n-                        self.expect(&token::RBracket);\n+                        self.expect(&token::CloseDelim(token::Bracket));\n                         ex = ExprRepeat(first_expr, count);\n                     } else if self.token == token::Comma {\n                         // Vector with two or more elements.\n                         self.bump();\n                         let remaining_exprs = self.parse_seq_to_end(\n-                            &token::RBracket,\n+                            &token::CloseDelim(token::Bracket),\n                             seq_sep_trailing_allowed(token::Comma),\n                             |p| p.parse_expr()\n                                 );\n@@ -2108,7 +2122,7 @@ impl<'a> Parser<'a> {\n                         ex = ExprVec(exprs);\n                     } else {\n                         // Vector with one element.\n-                        self.expect(&token::RBracket);\n+                        self.expect(&token::CloseDelim(token::Bracket));\n                         ex = ExprVec(vec!(first_expr));\n                     }\n                 }\n@@ -2209,14 +2223,9 @@ impl<'a> Parser<'a> {\n                         // MACRO INVOCATION expression\n                         self.bump();\n \n-                        let ket = self.token.get_close_delimiter()\n-                            .unwrap_or_else(|| {\n-                                self.fatal(\"expected open delimiter\")\n-                            });\n-                        self.bump();\n-\n+                        let delim = self.expect_open_delim();\n                         let tts = self.parse_seq_to_end(\n-                            &ket,\n+                            &token::CloseDelim(delim),\n                             seq_sep_none(),\n                             |p| p.parse_token_tree());\n                         let hi = self.span.hi;\n@@ -2227,7 +2236,7 @@ impl<'a> Parser<'a> {\n                                                            tts,\n                                                            EMPTY_CTXT));\n                     }\n-                    if self.token == token::LBrace {\n+                    if self.token == token::OpenDelim(token::Brace) {\n                         // This is a struct literal, unless we're prohibited\n                         // from parsing struct literals here.\n                         if !self.restrictions.contains(RESTRICTION_NO_STRUCT_LITERAL) {\n@@ -2236,7 +2245,7 @@ impl<'a> Parser<'a> {\n                             let mut fields = Vec::new();\n                             let mut base = None;\n \n-                            while self.token != token::RBrace {\n+                            while self.token != token::CloseDelim(token::Brace) {\n                                 if self.eat(&token::DotDot) {\n                                     base = Some(self.parse_expr());\n                                     break;\n@@ -2245,7 +2254,7 @@ impl<'a> Parser<'a> {\n                                 fields.push(self.parse_field());\n                                 self.commit_expr(&*fields.last().unwrap().expr,\n                                                  &[token::Comma],\n-                                                 &[token::RBrace]);\n+                                                 &[token::CloseDelim(token::Brace)]);\n                             }\n \n                             if fields.len() == 0 && base.is_none() {\n@@ -2258,7 +2267,7 @@ impl<'a> Parser<'a> {\n                             }\n \n                             hi = self.span.hi;\n-                            self.expect(&token::RBrace);\n+                            self.expect(&token::CloseDelim(token::Brace));\n                             ex = ExprStruct(pth, fields, base);\n                             return self.mk_expr(lo, hi, ex);\n                         }\n@@ -2281,7 +2290,7 @@ impl<'a> Parser<'a> {\n     /// Parse a block or unsafe block\n     pub fn parse_block_expr(&mut self, lo: BytePos, blk_mode: BlockCheckMode)\n                             -> P<Expr> {\n-        self.expect(&token::LBrace);\n+        self.expect(&token::OpenDelim(token::Brace));\n         let blk = self.parse_block_tail(lo, blk_mode);\n         return self.mk_expr(blk.span.lo, blk.span.hi, ExprBlock(blk));\n     }\n@@ -2313,10 +2322,10 @@ impl<'a> Parser<'a> {\n \n                     // expr.f() method call\n                     match self.token {\n-                        token::LParen => {\n+                        token::OpenDelim(token::Paren) => {\n                             let mut es = self.parse_unspanned_seq(\n-                                &token::LParen,\n-                                &token::RParen,\n+                                &token::OpenDelim(token::Paren),\n+                                &token::CloseDelim(token::Paren),\n                                 seq_sep_trailing_allowed(token::Comma),\n                                 |p| p.parse_expr()\n                             );\n@@ -2376,10 +2385,10 @@ impl<'a> Parser<'a> {\n             if self.expr_is_complete(&*e) { break; }\n             match self.token {\n               // expr(...)\n-              token::LParen => {\n+              token::OpenDelim(token::Paren) => {\n                 let es = self.parse_unspanned_seq(\n-                    &token::LParen,\n-                    &token::RParen,\n+                    &token::OpenDelim(token::Paren),\n+                    &token::CloseDelim(token::Paren),\n                     seq_sep_trailing_allowed(token::Comma),\n                     |p| p.parse_expr()\n                 );\n@@ -2393,7 +2402,7 @@ impl<'a> Parser<'a> {\n               // Could be either an index expression or a slicing expression.\n               // Any slicing non-terminal can have a mutable version with `mut`\n               // after the opening square bracket.\n-              token::LBracket => {\n+              token::OpenDelim(token::Bracket) => {\n                 self.bump();\n                 let mutbl = if self.eat_keyword(keywords::Mut) {\n                     MutMutable\n@@ -2402,7 +2411,7 @@ impl<'a> Parser<'a> {\n                 };\n                 match self.token {\n                     // e[]\n-                    token::RBracket => {\n+                    token::CloseDelim(token::Bracket) => {\n                         self.bump();\n                         hi = self.span.hi;\n                         let slice = self.mk_slice(e, None, None, mutbl);\n@@ -2413,7 +2422,7 @@ impl<'a> Parser<'a> {\n                         self.bump();\n                         match self.token {\n                             // e[..]\n-                            token::RBracket => {\n+                            token::CloseDelim(token::Bracket) => {\n                                 self.bump();\n                                 hi = self.span.hi;\n                                 let slice = self.mk_slice(e, None, None, mutbl);\n@@ -2427,7 +2436,7 @@ impl<'a> Parser<'a> {\n                             _ => {\n                                 hi = self.span.hi;\n                                 let e2 = self.parse_expr();\n-                                self.commit_expr_expecting(&*e2, token::RBracket);\n+                                self.commit_expr_expecting(&*e2, token::CloseDelim(token::Bracket));\n                                 let slice = self.mk_slice(e, None, Some(e2), mutbl);\n                                 e = self.mk_expr(lo, hi, slice)\n                             }\n@@ -2442,14 +2451,15 @@ impl<'a> Parser<'a> {\n                                 self.bump();\n                                 let e2 = match self.token {\n                                     // e[e..]\n-                                    token::RBracket => {\n+                                    token::CloseDelim(token::Bracket) => {\n                                         self.bump();\n                                         None\n                                     }\n                                     // e[e..e]\n                                     _ => {\n                                         let e2 = self.parse_expr();\n-                                        self.commit_expr_expecting(&*e2, token::RBracket);\n+                                        self.commit_expr_expecting(&*e2,\n+                                            token::CloseDelim(token::Bracket));\n                                         Some(e2)\n                                     }\n                                 };\n@@ -2464,7 +2474,7 @@ impl<'a> Parser<'a> {\n                                                   \"`mut` keyword is invalid in index expressions\");\n                                 }\n                                 hi = self.span.hi;\n-                                self.commit_expr_expecting(&*ix, token::RBracket);\n+                                self.commit_expr_expecting(&*ix, token::CloseDelim(token::Bracket));\n                                 let index = self.mk_index(e, ix);\n                                 e = self.mk_expr(lo, hi, index)\n                             }\n@@ -2525,7 +2535,7 @@ impl<'a> Parser<'a> {\n         fn parse_non_delim_tt_tok(p: &mut Parser) -> TokenTree {\n             maybe_whole!(deref p, NtTT);\n             match p.token {\n-              token::RParen | token::RBrace | token::RBracket => {\n+              token::CloseDelim(_) => {\n                   // This is a conservative error: only report the last unclosed delimiter. The\n                   // previous unclosed delimiters could actually be closed! The parser just hasn't\n                   // gotten to them yet.\n@@ -2542,10 +2552,10 @@ impl<'a> Parser<'a> {\n                 p.bump();\n                 let sp = p.span;\n \n-                if p.token == token::LParen {\n+                if p.token == token::OpenDelim(token::Paren) {\n                     let seq = p.parse_seq(\n-                        &token::LParen,\n-                        &token::RParen,\n+                        &token::OpenDelim(token::Paren),\n+                        &token::CloseDelim(token::Paren),\n                         seq_sep_none(),\n                         |p| p.parse_token_tree()\n                     );\n@@ -2564,45 +2574,48 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        match (&self.token, self.token.get_close_delimiter()) {\n-            (&token::Eof, _) => {\n+        match self.token {\n+            token::Eof => {\n                 let open_braces = self.open_braces.clone();\n                 for sp in open_braces.iter() {\n                     self.span_note(*sp, \"Did you mean to close this delimiter?\");\n                 }\n                 // There shouldn't really be a span, but it's easier for the test runner\n                 // if we give it one\n                 self.fatal(\"this file contains an un-closed delimiter \");\n-            }\n-            (_, Some(close_delim)) => {\n+            },\n+            token::OpenDelim(delim) => {\n                 // The span for beginning of the delimited section\n                 let pre_span = self.span;\n \n                 // Parse the open delimiter.\n                 self.open_braces.push(self.span);\n-                let open = Delimiter {\n-                    span: self.span,\n-                    token: self.bump_and_get(),\n-                };\n+                let open_span = self.span;\n+                self.bump();\n \n                 // Parse the token trees within the delimeters\n                 let tts = self.parse_seq_to_before_end(\n-                    &close_delim, seq_sep_none(), |p| p.parse_token_tree()\n+                    &token::CloseDelim(delim),\n+                    seq_sep_none(),\n+                    |p| p.parse_token_tree()\n                 );\n \n                 // Parse the close delimiter.\n-                let close = Delimiter {\n-                    span: self.span,\n-                    token: self.bump_and_get(),\n-                };\n+                let close_span = self.span;\n+                self.bump();\n                 self.open_braces.pop().unwrap();\n \n                 // Expand to cover the entire delimited token tree\n                 let span = Span { hi: self.span.hi, ..pre_span };\n \n-                TtDelimited(span, Rc::new((open, tts, close)))\n-            }\n-            _ => parse_non_delim_tt_tok(self)\n+                TtDelimited(span, Rc::new(Delimited {\n+                    delim: delim,\n+                    open_span: open_span,\n+                    tts: tts,\n+                    close_span: close_span,\n+                }))\n+            },\n+            _ => parse_non_delim_tt_tok(self),\n         }\n     }\n \n@@ -2621,13 +2634,8 @@ impl<'a> Parser<'a> {\n         // the interpolation of Matcher's\n         maybe_whole!(self, NtMatchers);\n         let mut name_idx = 0u;\n-        match self.token.get_close_delimiter() {\n-            Some(other_delimiter) => {\n-                self.bump();\n-                self.parse_matcher_subseq_upto(&mut name_idx, &other_delimiter)\n-            }\n-            None => self.fatal(\"expected open delimiter\")\n-        }\n+        let delim = self.expect_open_delim();\n+        self.parse_matcher_subseq_upto(&mut name_idx, &token::CloseDelim(delim))\n     }\n \n     /// This goofy function is necessary to correctly match parens in Matcher's.\n@@ -2641,8 +2649,8 @@ impl<'a> Parser<'a> {\n         let mut lparens = 0u;\n \n         while self.token != *ket || lparens > 0u {\n-            if self.token == token::LParen { lparens += 1u; }\n-            if self.token == token::RParen { lparens -= 1u; }\n+            if self.token == token::OpenDelim(token::Paren) { lparens += 1u; }\n+            if self.token == token::CloseDelim(token::Paren) { lparens -= 1u; }\n             ret_val.push(self.parse_matcher(name_idx));\n         }\n \n@@ -2656,11 +2664,11 @@ impl<'a> Parser<'a> {\n \n         let m = if self.token == token::Dollar {\n             self.bump();\n-            if self.token == token::LParen {\n+            if self.token == token::OpenDelim(token::Paren) {\n                 let name_idx_lo = *name_idx;\n                 self.bump();\n                 let ms = self.parse_matcher_subseq_upto(name_idx,\n-                                                        &token::RParen);\n+                                                        &token::CloseDelim(token::Paren));\n                 if ms.len() == 0u {\n                     self.fatal(\"repetition body must be nonempty\");\n                 }\n@@ -2717,7 +2725,9 @@ impl<'a> Parser<'a> {\n             self.bump();\n             let last_span = self.last_span;\n             match self.token {\n-                token::LBracket => self.obsolete(last_span, ObsoleteOwnedVector),\n+                token::OpenDelim(token::Bracket) => {\n+                    self.obsolete(last_span, ObsoleteOwnedVector)\n+                },\n                 _ => self.obsolete(last_span, ObsoleteOwnedExpr)\n             }\n \n@@ -2730,14 +2740,28 @@ impl<'a> Parser<'a> {\n                 return self.parse_dot_or_call_expr();\n             }\n \n+            let lo = self.span.lo;\n+\n             self.bump();\n \n             // Check for a place: `box(PLACE) EXPR`.\n-            if self.eat(&token::LParen) {\n+            if self.eat(&token::OpenDelim(token::Paren)) {\n                 // Support `box() EXPR` as the default.\n-                if !self.eat(&token::RParen) {\n+                if !self.eat(&token::CloseDelim(token::Paren)) {\n                     let place = self.parse_expr();\n-                    self.expect(&token::RParen);\n+                    self.expect(&token::CloseDelim(token::Paren));\n+                    // Give a suggestion to use `box()` when a parenthesised expression is used\n+                    if !self.token.can_begin_expr() {\n+                        let span = self.span;\n+                        let this_token_to_string = self.this_token_to_string();\n+                        self.span_err(span,\n+                                      format!(\"expected expression, found `{}`\",\n+                                              this_token_to_string).as_slice());\n+                        let box_span = mk_sp(lo, self.last_span.hi);\n+                        self.span_help(box_span,\n+                                       \"perhaps you meant `box() (foo)` instead?\");\n+                        self.abort_if_errors();\n+                    }\n                     let subexpression = self.parse_prefix_expr();\n                     hi = subexpression.span.hi;\n                     ex = ExprBox(place, subexpression);\n@@ -2966,9 +2990,9 @@ impl<'a> Parser<'a> {\n     fn parse_match_expr(&mut self) -> P<Expr> {\n         let lo = self.last_span.lo;\n         let discriminant = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL);\n-        self.commit_expr_expecting(&*discriminant, token::LBrace);\n+        self.commit_expr_expecting(&*discriminant, token::OpenDelim(token::Brace));\n         let mut arms: Vec<Arm> = Vec::new();\n-        while self.token != token::RBrace {\n+        while self.token != token::CloseDelim(token::Brace) {\n             arms.push(self.parse_arm());\n         }\n         let hi = self.span.hi;\n@@ -2988,10 +3012,10 @@ impl<'a> Parser<'a> {\n \n         let require_comma =\n             !classify::expr_is_simple_block(&*expr)\n-            && self.token != token::RBrace;\n+            && self.token != token::CloseDelim(token::Brace);\n \n         if require_comma {\n-            self.commit_expr(&*expr, &[token::Comma], &[token::RBrace]);\n+            self.commit_expr(&*expr, &[token::Comma], &[token::CloseDelim(token::Brace)]);\n         } else {\n             self.eat(&token::Comma);\n         }\n@@ -3047,7 +3071,7 @@ impl<'a> Parser<'a> {\n         let mut first = true;\n         let mut before_slice = true;\n \n-        while self.token != token::RBracket {\n+        while self.token != token::CloseDelim(token::Bracket) {\n             if first {\n                 first = false;\n             } else {\n@@ -3059,7 +3083,7 @@ impl<'a> Parser<'a> {\n                     self.bump();\n \n                     if self.token == token::Comma ||\n-                            self.token == token::RBracket {\n+                            self.token == token::CloseDelim(token::Bracket) {\n                         slice = Some(P(ast::Pat {\n                             id: ast::DUMMY_NODE_ID,\n                             node: PatWild(PatWildMulti),\n@@ -3095,21 +3119,21 @@ impl<'a> Parser<'a> {\n         let mut fields = Vec::new();\n         let mut etc = false;\n         let mut first = true;\n-        while self.token != token::RBrace {\n+        while self.token != token::CloseDelim(token::Brace) {\n             if first {\n                 first = false;\n             } else {\n                 self.expect(&token::Comma);\n                 // accept trailing commas\n-                if self.token == token::RBrace { break }\n+                if self.token == token::CloseDelim(token::Brace) { break }\n             }\n \n             let lo = self.span.lo;\n             let hi;\n \n             if self.token == token::DotDot {\n                 self.bump();\n-                if self.token != token::RBrace {\n+                if self.token != token::CloseDelim(token::Brace) {\n                     let token_str = self.this_token_to_string();\n                     self.fatal(format!(\"expected `{}`, found `{}`\", \"}\",\n                                        token_str).as_slice())\n@@ -3205,10 +3229,10 @@ impl<'a> Parser<'a> {\n                 span: mk_sp(lo, hi)\n             })\n           }\n-          token::LParen => {\n+          token::OpenDelim(token::Paren) => {\n             // parse (pat,pat,pat,...) as tuple\n             self.bump();\n-            if self.token == token::RParen {\n+            if self.token == token::CloseDelim(token::Paren) {\n                 hi = self.span.hi;\n                 self.bump();\n                 let lit = P(codemap::Spanned {\n@@ -3218,15 +3242,15 @@ impl<'a> Parser<'a> {\n                 pat = PatLit(expr);\n             } else {\n                 let mut fields = vec!(self.parse_pat());\n-                if self.look_ahead(1, |t| *t != token::RParen) {\n+                if self.look_ahead(1, |t| *t != token::CloseDelim(token::Paren)) {\n                     while self.token == token::Comma {\n                         self.bump();\n-                        if self.token == token::RParen { break; }\n+                        if self.token == token::CloseDelim(token::Paren) { break; }\n                         fields.push(self.parse_pat());\n                     }\n                 }\n                 if fields.len() == 1 { self.expect(&token::Comma); }\n-                self.expect(&token::RParen);\n+                self.expect(&token::CloseDelim(token::Paren));\n                 pat = PatTup(fields);\n             }\n             hi = self.last_span.hi;\n@@ -3236,13 +3260,13 @@ impl<'a> Parser<'a> {\n                 span: mk_sp(lo, hi)\n             })\n           }\n-          token::LBracket => {\n+          token::OpenDelim(token::Bracket) => {\n             // parse [pat,pat,...] as vector pattern\n             self.bump();\n             let (before, slice, after) =\n                 self.parse_pat_vec_elements();\n \n-            self.expect(&token::RBracket);\n+            self.expect(&token::CloseDelim(token::Bracket));\n             pat = ast::PatVec(before, slice, after);\n             hi = self.last_span.hi;\n             return P(ast::Pat {\n@@ -3266,7 +3290,7 @@ impl<'a> Parser<'a> {\n             let val = self.parse_literal_maybe_minus();\n             if (self.token == token::DotDotDot) &&\n                     self.look_ahead(1, |t| {\n-                        *t != token::Comma && *t != token::RBracket\n+                        *t != token::Comma && *t != token::CloseDelim(token::Bracket)\n                     }) {\n                 self.bump();\n                 let end = if self.token.is_ident() || self.token.is_path() {\n@@ -3303,15 +3327,14 @@ impl<'a> Parser<'a> {\n         } else {\n             let can_be_enum_or_struct = self.look_ahead(1, |t| {\n                 match *t {\n-                    token::LParen | token::LBracket | token::Lt |\n-                    token::LBrace | token::ModSep => true,\n+                    token::OpenDelim(_) | token::Lt | token::ModSep => true,\n                     _ => false,\n                 }\n             });\n \n             if self.look_ahead(1, |t| *t == token::DotDotDot) &&\n                     self.look_ahead(2, |t| {\n-                        *t != token::Comma && *t != token::RBracket\n+                        *t != token::Comma && *t != token::CloseDelim(token::Bracket)\n                     }) {\n                 let start = self.parse_expr_res(RESTRICTION_NO_BAR_OP);\n                 self.eat(&token::DotDotDot);\n@@ -3323,11 +3346,8 @@ impl<'a> Parser<'a> {\n                 let pth1 = codemap::Spanned{span:id_span, node: id};\n                 if self.eat(&token::Not) {\n                     // macro invocation\n-                    let ket = self.token.get_close_delimiter()\n-                                    .unwrap_or_else(|| self.fatal(\"expected open delimiter\"));\n-                    self.bump();\n-\n-                    let tts = self.parse_seq_to_end(&ket,\n+                    let delim = self.expect_open_delim();\n+                    let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n                                                     seq_sep_none(),\n                                                     |p| p.parse_token_tree());\n \n@@ -3348,7 +3368,7 @@ impl<'a> Parser<'a> {\n                 let enum_path = self.parse_path(LifetimeAndTypesWithColons)\n                                     .path;\n                 match self.token {\n-                    token::LBrace => {\n+                    token::OpenDelim(token::Brace) => {\n                         self.bump();\n                         let (fields, etc) =\n                             self.parse_pat_fields();\n@@ -3358,7 +3378,7 @@ impl<'a> Parser<'a> {\n                     _ => {\n                         let mut args: Vec<P<Pat>> = Vec::new();\n                         match self.token {\n-                          token::LParen => {\n+                          token::OpenDelim(token::Paren) => {\n                             let is_dotdot = self.look_ahead(1, |t| {\n                                 match *t {\n                                     token::DotDot => true,\n@@ -3369,12 +3389,12 @@ impl<'a> Parser<'a> {\n                                 // This is a \"top constructor only\" pat\n                                 self.bump();\n                                 self.bump();\n-                                self.expect(&token::RParen);\n+                                self.expect(&token::CloseDelim(token::Paren));\n                                 pat = PatEnum(enum_path, None);\n                             } else {\n                                 args = self.parse_enum_variant_seq(\n-                                    &token::LParen,\n-                                    &token::RParen,\n+                                    &token::OpenDelim(token::Paren),\n+                                    &token::CloseDelim(token::Paren),\n                                     seq_sep_trailing_allowed(token::Comma),\n                                     |p| p.parse_pat()\n                                 );\n@@ -3443,7 +3463,7 @@ impl<'a> Parser<'a> {\n         // leads to a parse error.  Note that if there is no explicit\n         // binding mode then we do not end up here, because the lookahead\n         // will direct us over to parse_enum_variant()\n-        if self.token == token::LParen {\n+        if self.token == token::OpenDelim(token::Paren) {\n             let last_span = self.last_span;\n             self.span_fatal(\n                 last_span,\n@@ -3543,18 +3563,17 @@ impl<'a> Parser<'a> {\n             let pth = self.parse_path(NoTypesAllowed).path;\n             self.bump();\n \n-            let id = if self.token.get_close_delimiter().is_some() {\n-                token::special_idents::invalid // no special identifier\n-            } else {\n-                self.parse_ident()\n+            let id = match self.token {\n+                token::OpenDelim(_) => token::special_idents::invalid, // no special identifier\n+                _ => self.parse_ident(),\n             };\n \n             // check that we're pointing at delimiters (need to check\n             // again after the `if`, because of `parse_ident`\n             // consuming more tokens).\n-            let (bra, ket) = match self.token.get_close_delimiter() {\n-                Some(ket) => (self.token.clone(), ket),\n-                None      => {\n+            let delim = match self.token {\n+                token::OpenDelim(delim) => delim,\n+                _ => {\n                     // we only expect an ident if we didn't parse one\n                     // above.\n                     let ident_str = if id.name == token::special_idents::invalid.name {\n@@ -3566,18 +3585,28 @@ impl<'a> Parser<'a> {\n                     self.fatal(format!(\"expected {}`(` or `{{`, found `{}`\",\n                                        ident_str,\n                                        tok_str).as_slice())\n-                }\n+                },\n             };\n \n             let tts = self.parse_unspanned_seq(\n-                &bra,\n-                &ket,\n+                &token::OpenDelim(delim),\n+                &token::CloseDelim(delim),\n                 seq_sep_none(),\n                 |p| p.parse_token_tree()\n             );\n             let hi = self.span.hi;\n \n             if id.name == token::special_idents::invalid.name {\n+                if self.token == token::Dot {\n+                    let span = self.span;\n+                    let token_string = self.this_token_to_string();\n+                    self.span_err(span,\n+                                  format!(\"expected statement, found `{}`\",\n+                                          token_string).as_slice());\n+                    let mac_span = mk_sp(lo, hi);\n+                    self.span_help(mac_span, \"try parenthesizing this macro invocation\");\n+                    self.abort_if_errors();\n+                }\n                 P(spanned(lo, hi, StmtMac(\n                     spanned(lo, hi, MacInvocTT(pth, tts, EMPTY_CTXT)), false)))\n             } else {\n@@ -3632,7 +3661,7 @@ impl<'a> Parser<'a> {\n         maybe_whole!(no_clone self, NtBlock);\n \n         let lo = self.span.lo;\n-        self.expect(&token::LBrace);\n+        self.expect(&token::OpenDelim(token::Brace));\n \n         return self.parse_block_tail_(lo, DefaultBlock, Vec::new());\n     }\n@@ -3644,7 +3673,7 @@ impl<'a> Parser<'a> {\n         maybe_whole!(pair_empty self, NtBlock);\n \n         let lo = self.span.lo;\n-        self.expect(&token::LBrace);\n+        self.expect(&token::OpenDelim(token::Brace));\n         let (inner, next) = self.parse_inner_attrs_and_next();\n \n         (inner, self.parse_block_tail_(lo, DefaultBlock, next))\n@@ -3681,7 +3710,7 @@ impl<'a> Parser<'a> {\n \n         let mut attributes_box = attrs_remaining;\n \n-        while self.token != token::RBrace {\n+        while self.token != token::CloseDelim(token::Brace) {\n             // parsing items even when they're not allowed lets us give\n             // better error messages and recover more gracefully.\n             attributes_box.push_all(self.parse_outer_attributes().as_slice());\n@@ -3695,7 +3724,7 @@ impl<'a> Parser<'a> {\n                     }\n                     self.bump(); // empty\n                 }\n-                token::RBrace => {\n+                token::CloseDelim(token::Brace) => {\n                     // fall through and out.\n                 }\n                 _ => {\n@@ -3706,7 +3735,8 @@ impl<'a> Parser<'a> {\n                             // expression without semicolon\n                             if classify::expr_requires_semi_to_be_stmt(&*e) {\n                                 // Just check for errors and recover; do not eat semicolon yet.\n-                                self.commit_stmt(&[], &[token::Semi, token::RBrace]);\n+                                self.commit_stmt(&[], &[token::Semi,\n+                                    token::CloseDelim(token::Brace)]);\n                             }\n \n                             match self.token {\n@@ -3722,7 +3752,7 @@ impl<'a> Parser<'a> {\n                                         span: span_with_semi,\n                                     }));\n                                 }\n-                                token::RBrace => {\n+                                token::CloseDelim(token::Brace) => {\n                                     expr = Some(e);\n                                 }\n                                 _ => {\n@@ -3743,7 +3773,7 @@ impl<'a> Parser<'a> {\n                                     }));\n                                     self.bump();\n                                 }\n-                                token::RBrace => {\n+                                token::CloseDelim(token::Brace) => {\n                                     // if a block ends in `m!(arg)` without\n                                     // a `;`, it must be an expr\n                                     expr = Some(\n@@ -3838,10 +3868,10 @@ impl<'a> Parser<'a> {\n                 token::ModSep | token::Ident(..) => {\n                     let path =\n                         self.parse_path(LifetimeAndTypesWithoutColons).path;\n-                    if self.token == token::LParen {\n+                    if self.token == token::OpenDelim(token::Paren) {\n                         self.bump();\n                         let inputs = self.parse_seq_to_end(\n-                            &token::RParen,\n+                            &token::CloseDelim(token::Paren),\n                             seq_sep_trailing_allowed(token::Comma),\n                             |p| p.parse_arg_general(false));\n                         let (return_style, output) = self.parse_ret_ty();\n@@ -4035,14 +4065,14 @@ impl<'a> Parser<'a> {\n         let sp = self.span;\n         let mut args: Vec<Option<Arg>> =\n             self.parse_unspanned_seq(\n-                &token::LParen,\n-                &token::RParen,\n+                &token::OpenDelim(token::Paren),\n+                &token::CloseDelim(token::Paren),\n                 seq_sep_trailing_allowed(token::Comma),\n                 |p| {\n                     if p.token == token::DotDotDot {\n                         p.bump();\n                         if allow_variadic {\n-                            if p.token != token::RParen {\n+                            if p.token != token::CloseDelim(token::Paren) {\n                                 let span = p.span;\n                                 p.span_fatal(span,\n                                     \"`...` must be last in argument list for variadic function\");\n@@ -4154,7 +4184,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        self.expect(&token::LParen);\n+        self.expect(&token::OpenDelim(token::Paren));\n \n         // A bit of complexity and lookahead is needed here in order to be\n         // backwards compatible.\n@@ -4249,14 +4279,14 @@ impl<'a> Parser<'a> {\n                     self.bump();\n                     let sep = seq_sep_trailing_allowed(token::Comma);\n                     let mut fn_inputs = self.parse_seq_to_before_end(\n-                        &token::RParen,\n+                        &token::CloseDelim(token::Paren),\n                         sep,\n                         parse_arg_fn\n                     );\n                     fn_inputs.insert(0, Arg::new_self(explicit_self_sp, mutbl_self, $self_id));\n                     fn_inputs\n                 }\n-                token::RParen => {\n+                token::CloseDelim(token::Paren) => {\n                     vec!(Arg::new_self(explicit_self_sp, mutbl_self, $self_id))\n                 }\n                 _ => {\n@@ -4271,15 +4301,15 @@ impl<'a> Parser<'a> {\n         let fn_inputs = match explicit_self {\n             SelfStatic =>  {\n                 let sep = seq_sep_trailing_allowed(token::Comma);\n-                self.parse_seq_to_before_end(&token::RParen, sep, parse_arg_fn)\n+                self.parse_seq_to_before_end(&token::CloseDelim(token::Paren), sep, parse_arg_fn)\n             }\n             SelfValue(id) => parse_remaining_arguments!(id),\n             SelfRegion(_,_,id) => parse_remaining_arguments!(id),\n             SelfExplicit(_,id) => parse_remaining_arguments!(id),\n         };\n \n \n-        self.expect(&token::RParen);\n+        self.expect(&token::CloseDelim(token::Paren));\n \n         let hi = self.span.hi;\n \n@@ -4335,8 +4365,8 @@ impl<'a> Parser<'a> {\n     /// Parses the `(arg, arg) -> return_type` header on a procedure.\n     fn parse_proc_decl(&mut self) -> P<FnDecl> {\n         let inputs =\n-            self.parse_unspanned_seq(&token::LParen,\n-                                     &token::RParen,\n+            self.parse_unspanned_seq(&token::OpenDelim(token::Paren),\n+                                     &token::CloseDelim(token::Paren),\n                                      seq_sep_trailing_allowed(token::Comma),\n                                      |p| p.parse_fn_block_arg());\n \n@@ -4405,22 +4435,17 @@ impl<'a> Parser<'a> {\n         let (method_, hi, new_attrs) = {\n             if !self.token.is_any_keyword()\n                 && self.look_ahead(1, |t| *t == token::Not)\n-                && (self.look_ahead(2, |t| *t == token::LParen)\n-                    || self.look_ahead(2, |t| *t == token::LBrace)) {\n+                && (self.look_ahead(2, |t| *t == token::OpenDelim(token::Paren))\n+                    || self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))) {\n                 // method macro.\n                 let pth = self.parse_path(NoTypesAllowed).path;\n                 self.expect(&token::Not);\n \n                 // eat a matched-delimiter token tree:\n-                let tts = match self.token.get_close_delimiter() {\n-                    Some(ket) => {\n-                        self.bump();\n-                        self.parse_seq_to_end(&ket,\n-                                              seq_sep_none(),\n-                                              |p| p.parse_token_tree())\n-                    }\n-                    None => self.fatal(\"expected open delimiter\")\n-                };\n+                let delim = self.expect_open_delim();\n+                let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n+                                                seq_sep_none(),\n+                                                |p| p.parse_token_tree());\n                 let m_ = ast::MacInvocTT(pth, tts, EMPTY_CTXT);\n                 let m: ast::Mac = codemap::Spanned { node: m_,\n                                                  span: mk_sp(self.span.lo,\n@@ -4484,10 +4509,10 @@ impl<'a> Parser<'a> {\n \n     fn parse_impl_items(&mut self) -> (Vec<ImplItem>, Vec<Attribute>) {\n         let mut impl_items = Vec::new();\n-        self.expect(&token::LBrace);\n+        self.expect(&token::OpenDelim(token::Brace));\n         let (inner_attrs, mut method_attrs) =\n             self.parse_inner_attrs_and_next();\n-        while !self.eat(&token::RBrace) {\n+        while !self.eat(&token::CloseDelim(token::Brace)) {\n             method_attrs.extend(self.parse_outer_attributes().into_iter());\n             let vis = self.parse_visibility();\n             if self.eat_keyword(keywords::Type) {\n@@ -4513,7 +4538,7 @@ impl<'a> Parser<'a> {\n \n         // Special case: if the next identifier that follows is '(', don't\n         // allow this to be parsed as a trait.\n-        let could_be_trait = self.token != token::LParen;\n+        let could_be_trait = self.token != token::OpenDelim(token::Paren);\n \n         // Parse the trait.\n         let mut ty = self.parse_ty(true);\n@@ -4571,11 +4596,11 @@ impl<'a> Parser<'a> {\n         let mut fields: Vec<StructField>;\n         let is_tuple_like;\n \n-        if self.eat(&token::LBrace) {\n+        if self.eat(&token::OpenDelim(token::Brace)) {\n             // It's a record-like struct.\n             is_tuple_like = false;\n             fields = Vec::new();\n-            while self.token != token::RBrace {\n+            while self.token != token::CloseDelim(token::Brace) {\n                 fields.push(self.parse_struct_decl_field());\n             }\n             if fields.len() == 0 {\n@@ -4584,12 +4609,12 @@ impl<'a> Parser<'a> {\n                                    token::get_ident(class_name)).as_slice());\n             }\n             self.bump();\n-        } else if self.token == token::LParen {\n+        } else if self.token == token::OpenDelim(token::Paren) {\n             // It's a tuple-like struct.\n             is_tuple_like = true;\n             fields = self.parse_unspanned_seq(\n-                &token::LParen,\n-                &token::RParen,\n+                &token::OpenDelim(token::Paren),\n+                &token::CloseDelim(token::Paren),\n                 seq_sep_trailing_allowed(token::Comma),\n                 |p| {\n                 let attrs = p.parse_outer_attributes();\n@@ -4639,7 +4664,7 @@ impl<'a> Parser<'a> {\n             token::Comma => {\n                 self.bump();\n             }\n-            token::RBrace => {}\n+            token::CloseDelim(token::Brace) => {}\n             _ => {\n                 let span = self.span;\n                 let token_str = self.this_token_to_string();\n@@ -4771,13 +4796,13 @@ impl<'a> Parser<'a> {\n             (id, m, Some(attrs))\n         } else {\n             self.push_mod_path(id, outer_attrs);\n-            self.expect(&token::LBrace);\n+            self.expect(&token::OpenDelim(token::Brace));\n             let mod_inner_lo = self.span.lo;\n             let old_owns_directory = self.owns_directory;\n             self.owns_directory = true;\n             let (inner, next) = self.parse_inner_attrs_and_next();\n-            let m = self.parse_mod_items(token::RBrace, next, mod_inner_lo);\n-            self.expect(&token::RBrace);\n+            let m = self.parse_mod_items(token::CloseDelim(token::Brace), next, mod_inner_lo);\n+            self.expect(&token::CloseDelim(token::Brace));\n             self.owns_directory = old_owns_directory;\n             self.pop_mod_path();\n             (id, ItemMod(m), Some(inner))\n@@ -4978,7 +5003,7 @@ impl<'a> Parser<'a> {\n             self.span_err(last_span,\n                           Parser::expected_item_err(attrs_remaining.as_slice()));\n         }\n-        assert!(self.token == token::RBrace);\n+        assert!(self.token == token::CloseDelim(token::Brace));\n         ast::ForeignMod {\n             abi: abi,\n             view_items: view_items,\n@@ -5065,13 +5090,13 @@ impl<'a> Parser<'a> {\n                               attrs: Vec<Attribute> )\n                               -> ItemOrViewItem {\n \n-        self.expect(&token::LBrace);\n+        self.expect(&token::OpenDelim(token::Brace));\n \n         let abi = opt_abi.unwrap_or(abi::C);\n \n         let (inner, next) = self.parse_inner_attrs_and_next();\n         let m = self.parse_foreign_mod_items(abi, next);\n-        self.expect(&token::RBrace);\n+        self.expect(&token::CloseDelim(token::Brace));\n \n         let last_span = self.last_span;\n         let item = self.mk_item(lo,\n@@ -5098,7 +5123,7 @@ impl<'a> Parser<'a> {\n     /// this should probably be renamed or refactored...\n     fn parse_struct_def(&mut self) -> P<StructDef> {\n         let mut fields: Vec<StructField> = Vec::new();\n-        while self.token != token::RBrace {\n+        while self.token != token::CloseDelim(token::Brace) {\n             fields.push(self.parse_struct_decl_field());\n         }\n         self.bump();\n@@ -5114,7 +5139,7 @@ impl<'a> Parser<'a> {\n         let mut variants = Vec::new();\n         let mut all_nullary = true;\n         let mut any_disr = None;\n-        while self.token != token::RBrace {\n+        while self.token != token::CloseDelim(token::Brace) {\n             let variant_attrs = self.parse_outer_attributes();\n             let vlo = self.span.lo;\n \n@@ -5125,15 +5150,15 @@ impl<'a> Parser<'a> {\n             let mut args = Vec::new();\n             let mut disr_expr = None;\n             ident = self.parse_ident();\n-            if self.eat(&token::LBrace) {\n+            if self.eat(&token::OpenDelim(token::Brace)) {\n                 // Parse a struct variant.\n                 all_nullary = false;\n                 kind = StructVariantKind(self.parse_struct_def());\n-            } else if self.token == token::LParen {\n+            } else if self.token == token::OpenDelim(token::Paren) {\n                 all_nullary = false;\n                 let arg_tys = self.parse_enum_variant_seq(\n-                    &token::LParen,\n-                    &token::RParen,\n+                    &token::OpenDelim(token::Paren),\n+                    &token::CloseDelim(token::Paren),\n                     seq_sep_trailing_allowed(token::Comma),\n                     |p| p.parse_ty(true)\n                 );\n@@ -5164,7 +5189,7 @@ impl<'a> Parser<'a> {\n \n             if !self.eat(&token::Comma) { break; }\n         }\n-        self.expect(&token::RBrace);\n+        self.expect(&token::CloseDelim(token::Brace));\n         match any_disr {\n             Some(disr_span) if !all_nullary =>\n                 self.span_err(disr_span,\n@@ -5180,15 +5205,15 @@ impl<'a> Parser<'a> {\n         let id = self.parse_ident();\n         let mut generics = self.parse_generics();\n         self.parse_where_clause(&mut generics);\n-        self.expect(&token::LBrace);\n+        self.expect(&token::OpenDelim(token::Brace));\n \n         let enum_definition = self.parse_enum_def(&generics);\n         (id, ItemEnum(enum_definition, generics), None)\n     }\n \n     fn fn_expr_lookahead(tok: &token::Token) -> bool {\n         match *tok {\n-          token::LParen | token::At | token::Tilde | token::BinOp(_) => true,\n+          token::OpenDelim(token::Paren) | token::At | token::Tilde | token::BinOp(_) => true,\n           _ => false\n         }\n     }\n@@ -5291,7 +5316,7 @@ impl<'a> Parser<'a> {\n                                         visibility,\n                                         maybe_append(attrs, extra_attrs));\n                 return IoviItem(item);\n-            } else if self.token == token::LBrace {\n+            } else if self.token == token::OpenDelim(token::Brace) {\n                 return self.parse_item_foreign_mod(lo, opt_abi, visibility, attrs);\n             }\n \n@@ -5356,7 +5381,7 @@ impl<'a> Parser<'a> {\n             return IoviItem(item);\n         }\n         if self.token.is_keyword(keywords::Unsafe)\n-            && self.look_ahead(1u, |t| *t != token::LBrace) {\n+            && self.look_ahead(1u, |t| *t != token::OpenDelim(token::Brace)) {\n             // UNSAFE FUNCTION ITEM\n             self.bump();\n             let abi = if self.eat_keyword(keywords::Extern) {\n@@ -5486,8 +5511,8 @@ impl<'a> Parser<'a> {\n         if macros_allowed && !self.token.is_any_keyword()\n                 && self.look_ahead(1, |t| *t == token::Not)\n                 && (self.look_ahead(2, |t| t.is_plain_ident())\n-                    || self.look_ahead(2, |t| *t == token::LParen)\n-                    || self.look_ahead(2, |t| *t == token::LBrace)) {\n+                    || self.look_ahead(2, |t| *t == token::OpenDelim(token::Paren))\n+                    || self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))) {\n             // MACRO INVOCATION ITEM\n \n             // item macro.\n@@ -5503,15 +5528,10 @@ impl<'a> Parser<'a> {\n                 token::special_idents::invalid // no special identifier\n             };\n             // eat a matched-delimiter token tree:\n-            let tts = match self.token.get_close_delimiter() {\n-                Some(ket) => {\n-                    self.bump();\n-                    self.parse_seq_to_end(&ket,\n-                                          seq_sep_none(),\n-                                          |p| p.parse_token_tree())\n-                }\n-                None => self.fatal(\"expected open delimiter\")\n-            };\n+            let delim = self.expect_open_delim();\n+            let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n+                                            seq_sep_none(),\n+                                            |p| p.parse_token_tree());\n             // single-variant-enum... :\n             let m = ast::MacInvocTT(pth, tts, EMPTY_CTXT);\n             let m: ast::Mac = codemap::Spanned { node: m,\n@@ -5573,10 +5593,11 @@ impl<'a> Parser<'a> {\n     fn parse_view_path(&mut self) -> P<ViewPath> {\n         let lo = self.span.lo;\n \n-        if self.token == token::LBrace {\n+        if self.token == token::OpenDelim(token::Brace) {\n             // use {foo,bar}\n             let idents = self.parse_unspanned_seq(\n-                &token::LBrace, &token::RBrace,\n+                &token::OpenDelim(token::Brace),\n+                &token::CloseDelim(token::Brace),\n                 seq_sep_trailing_allowed(token::Comma),\n                 |p| p.parse_path_list_item());\n             let path = ast::Path {\n@@ -5631,10 +5652,10 @@ impl<'a> Parser<'a> {\n                   }\n \n                   // foo::bar::{a,b,c}\n-                  token::LBrace => {\n+                  token::OpenDelim(token::Brace) => {\n                     let idents = self.parse_unspanned_seq(\n-                        &token::LBrace,\n-                        &token::RBrace,\n+                        &token::OpenDelim(token::Brace),\n+                        &token::CloseDelim(token::Brace),\n                         seq_sep_trailing_allowed(token::Comma),\n                         |p| p.parse_path_list_item()\n                     );\n@@ -5793,7 +5814,7 @@ impl<'a> Parser<'a> {\n         loop {\n             match self.parse_foreign_item(attrs, macros_allowed) {\n                 IoviNone(returned_attrs) => {\n-                    if self.token == token::RBrace {\n+                    if self.token == token::CloseDelim(token::Brace) {\n                         attrs = returned_attrs;\n                         break\n                     }"}, {"sha": "d56aa8da72a8421e5f2721f80162368bd6807730", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 39, "deletions": 43, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -56,12 +56,6 @@ use std::rc::Rc;\n #[cfg(stage0)] pub use self::RArrow         as RARROW;\n #[cfg(stage0)] pub use self::LArrow         as LARROW;\n #[cfg(stage0)] pub use self::FatArrow       as FAT_ARROW;\n-#[cfg(stage0)] pub use self::LParen         as LPAREN;\n-#[cfg(stage0)] pub use self::RParen         as RPAREN;\n-#[cfg(stage0)] pub use self::LBracket       as LBRACKET;\n-#[cfg(stage0)] pub use self::RBracket       as RBRACKET;\n-#[cfg(stage0)] pub use self::LBrace         as LBRACE;\n-#[cfg(stage0)] pub use self::RBrace         as RBRACE;\n #[cfg(stage0)] pub use self::Pound          as POUND;\n #[cfg(stage0)] pub use self::Dollar         as DOLLAR;\n #[cfg(stage0)] pub use self::Question       as QUESTION;\n@@ -82,6 +76,12 @@ use std::rc::Rc;\n #[cfg(stage0)] pub use self::Comment        as COMMENT;\n #[cfg(stage0)] pub use self::Shebang        as SHEBANG;\n #[cfg(stage0)] pub use self::Eof            as EOF;\n+#[cfg(stage0)] pub const LPAREN:    Token = OpenDelim(Paren);\n+#[cfg(stage0)] pub const RPAREN:    Token = CloseDelim(Paren);\n+#[cfg(stage0)] pub const LBRACKET:  Token = OpenDelim(Bracket);\n+#[cfg(stage0)] pub const RBRACKET:  Token = CloseDelim(Bracket);\n+#[cfg(stage0)] pub const LBRACE:    Token = OpenDelim(Brace);\n+#[cfg(stage0)] pub const RBRACE:    Token = CloseDelim(Brace);\n \n #[allow(non_camel_case_types)]\n #[deriving(Clone, Encodable, Decodable, PartialEq, Eq, Hash, Show)]\n@@ -98,11 +98,22 @@ pub enum BinOpToken {\n     Shr,\n }\n \n+/// A delimeter token\n+#[deriving(Clone, Encodable, Decodable, PartialEq, Eq, Hash, Show)]\n+pub enum DelimToken {\n+    /// A round parenthesis: `(` or `)`\n+    Paren,\n+    /// A square bracket: `[` or `]`\n+    Bracket,\n+    /// A curly brace: `{` or `}`\n+    Brace,\n+}\n+\n #[cfg(stage0)]\n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n pub const ModName: bool = true;\n #[cfg(stage0)]\n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n pub const Plain: bool = false;\n \n #[deriving(Clone, Encodable, Decodable, PartialEq, Eq, Hash, Show)]\n@@ -143,15 +154,13 @@ pub enum Token {\n     RArrow,\n     LArrow,\n     FatArrow,\n-    LParen,\n-    RParen,\n-    LBracket,\n-    RBracket,\n-    LBrace,\n-    RBrace,\n     Pound,\n     Dollar,\n     Question,\n+    /// An opening delimeter, eg. `{`\n+    OpenDelim(DelimToken),\n+    /// A closing delimeter, eg. `}`\n+    CloseDelim(DelimToken),\n \n     /* Literals */\n     LitByte(ast::Name),\n@@ -192,9 +201,7 @@ impl Token {\n     /// Returns `true` if the token can appear at the start of an expression.\n     pub fn can_begin_expr(&self) -> bool {\n         match *self {\n-            LParen                      => true,\n-            LBrace                      => true,\n-            LBracket                    => true,\n+            OpenDelim(_)                => true,\n             Ident(_, _)                 => true,\n             Underscore                  => true,\n             Tilde                       => true,\n@@ -223,17 +230,6 @@ impl Token {\n         }\n     }\n \n-    /// Returns the matching close delimiter if this is an open delimiter,\n-    /// otherwise `None`.\n-    pub fn get_close_delimiter(&self) -> Option<Token> {\n-        match *self {\n-            LParen   => Some(RParen),\n-            LBrace   => Some(RBrace),\n-            LBracket => Some(RBracket),\n-            _        => None,\n-        }\n-    }\n-\n     /// Returns `true` if the token is any literal\n     pub fn is_lit(&self) -> bool {\n         match *self {\n@@ -267,11 +263,11 @@ impl Token {\n \n     /// Returns `true` if the token is a path that is not followed by a `::`\n     /// token.\n-    #[allow(non_uppercase_statics)] // NOTE(stage0): remove this attribute after the next snapshot\n+    #[allow(non_upper_case_globals)]\n     pub fn is_plain_ident(&self) -> bool {\n         match *self {\n             Ident(_, Plain) => true,\n-            _                    => false,\n+            _               => false,\n         }\n     }\n \n@@ -315,7 +311,7 @@ impl Token {\n     }\n \n     /// Returns `true` if the token is a given keyword, `kw`.\n-    #[allow(non_uppercase_statics)] // NOTE(stage0): remove this attribute after the next snapshot\n+    #[allow(non_upper_case_globals)]\n     pub fn is_keyword(&self, kw: keywords::Keyword) -> bool {\n         match *self {\n             Ident(sid, Plain) => kw.to_name() == sid.name,\n@@ -325,7 +321,7 @@ impl Token {\n \n     /// Returns `true` if the token is either a special identifier, or a strict\n     /// or reserved keyword.\n-    #[allow(non_uppercase_statics)] // NOTE(stage0): remove this attribute after the next snapshot\n+    #[allow(non_upper_case_globals)]\n     pub fn is_any_keyword(&self) -> bool {\n         match *self {\n             Ident(sid, Plain) => {\n@@ -342,7 +338,7 @@ impl Token {\n     }\n \n     /// Returns `true` if the token may not appear as an identifier.\n-    #[allow(non_uppercase_statics)] // NOTE(stage0): remove this attribute after the next snapshot\n+    #[allow(non_upper_case_globals)]\n     pub fn is_strict_keyword(&self) -> bool {\n         match *self {\n             Ident(sid, Plain) => {\n@@ -368,7 +364,7 @@ impl Token {\n \n     /// Returns `true` if the token is a keyword that has been reserved for\n     /// possible future use.\n-    #[allow(non_uppercase_statics)] // NOTE(stage0): remove this attribute after the next snapshot\n+    #[allow(non_upper_case_globals)]\n     pub fn is_reserved_keyword(&self) -> bool {\n         match *self {\n             Ident(sid, Plain) => {\n@@ -396,20 +392,20 @@ impl Token {\n #[deriving(Clone, Encodable, Decodable, PartialEq, Eq, Hash)]\n /// For interpolation during macro expansion.\n pub enum Nonterminal {\n-    NtItem( P<ast::Item>),\n+    NtItem(P<ast::Item>),\n     NtBlock(P<ast::Block>),\n-    NtStmt( P<ast::Stmt>),\n-    NtPat(  P<ast::Pat>),\n-    NtExpr( P<ast::Expr>),\n-    NtTy(   P<ast::Ty>),\n+    NtStmt(P<ast::Stmt>),\n+    NtPat(P<ast::Pat>),\n+    NtExpr(P<ast::Expr>),\n+    NtTy(P<ast::Ty>),\n     #[cfg(stage0)]\n     NtIdent(Box<ast::Ident>, bool),\n     #[cfg(not(stage0))]\n     NtIdent(Box<ast::Ident>, IdentStyle),\n     /// Stuff inside brackets for attributes\n-    NtMeta( P<ast::MetaItem>),\n+    NtMeta(P<ast::MetaItem>),\n     NtPath(Box<ast::Path>),\n-    NtTT(   P<ast::TokenTree>), // needs P'ed to break a circularity\n+    NtTT(P<ast::TokenTree>), // needs P'ed to break a circularity\n     NtMatchers(Vec<ast::Matcher>)\n }\n \n@@ -469,7 +465,7 @@ macro_rules! declare_special_idents_and_keywords {(\n     pub mod special_idents {\n         use ast;\n         $(\n-            #[allow(non_uppercase_statics)]\n+            #[allow(non_upper_case_globals)]\n             pub const $si_static: ast::Ident = ast::Ident {\n                 name: ast::Name($si_name),\n                 ctxt: 0,\n@@ -480,7 +476,7 @@ macro_rules! declare_special_idents_and_keywords {(\n     pub mod special_names {\n         use ast;\n         $(\n-            #[allow(non_uppercase_statics)]\n+            #[allow(non_upper_case_globals)]\n             pub const $si_static: ast::Name =  ast::Name($si_name);\n         )*\n     }"}, {"sha": "5523f85acebc889a6e9907b37ffd947ba47ea56e", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -303,7 +303,7 @@ impl Printer {\n     }\n     // be very careful with this!\n     pub fn replace_last_token(&mut self, t: Token) {\n-        *self.token.get_mut(self.right) = t;\n+        self.token[self.right] = t;\n     }\n     pub fn pretty_print(&mut self, t: Token) -> io::IoResult<()> {\n         debug!(\"pp ~[{},{}]\", self.left, self.right);\n@@ -327,8 +327,8 @@ impl Printer {\n             } else { self.advance_right(); }\n             debug!(\"pp Begin({})/buffer ~[{},{}]\",\n                    b.offset, self.left, self.right);\n-            *self.token.get_mut(self.right) = t;\n-            *self.size.get_mut(self.right) = -self.right_total;\n+            self.token[self.right] = t;\n+            self.size[self.right] = -self.right_total;\n             let right = self.right;\n             self.scan_push(right);\n             Ok(())\n@@ -340,8 +340,8 @@ impl Printer {\n             } else {\n                 debug!(\"pp End/buffer ~[{},{}]\", self.left, self.right);\n                 self.advance_right();\n-                *self.token.get_mut(self.right) = t;\n-                *self.size.get_mut(self.right) = -1;\n+                self.token[self.right] = t;\n+                self.size[self.right] = -1;\n                 let right = self.right;\n                 self.scan_push(right);\n                 Ok(())\n@@ -359,8 +359,8 @@ impl Printer {\n             self.check_stack(0);\n             let right = self.right;\n             self.scan_push(right);\n-            *self.token.get_mut(self.right) = t;\n-            *self.size.get_mut(self.right) = -self.right_total;\n+            self.token[self.right] = t;\n+            self.size[self.right] = -self.right_total;\n             self.right_total += b.blank_space;\n             Ok(())\n           }\n@@ -373,8 +373,8 @@ impl Printer {\n                 debug!(\"pp String('{}')/buffer ~[{},{}]\",\n                        *s, self.left, self.right);\n                 self.advance_right();\n-                *self.token.get_mut(self.right) = t.clone();\n-                *self.size.get_mut(self.right) = len;\n+                self.token[self.right] = t.clone();\n+                self.size[self.right] = len;\n                 self.right_total += len;\n                 self.check_stream()\n             }\n@@ -391,7 +391,7 @@ impl Printer {\n                 if self.left == self.scan_stack[self.bottom] {\n                     debug!(\"setting {} to infinity and popping\", self.left);\n                     let scanned = self.scan_pop_bottom();\n-                    *self.size.get_mut(scanned) = SIZE_INFINITY;\n+                    self.size[scanned] = SIZE_INFINITY;\n                 }\n             }\n             let left = self.token[self.left].clone();\n@@ -412,7 +412,7 @@ impl Printer {\n             self.top %= self.buf_len;\n             assert!((self.top != self.bottom));\n         }\n-        *self.scan_stack.get_mut(self.top) = x;\n+        self.scan_stack[self.top] = x;\n     }\n     pub fn scan_pop(&mut self) -> uint {\n         assert!((!self.scan_stack_empty));\n@@ -474,20 +474,19 @@ impl Printer {\n                 Begin(_) => {\n                     if k > 0 {\n                         let popped = self.scan_pop();\n-                        *self.size.get_mut(popped) = self.size[x] +\n-                            self.right_total;\n+                        self.size[popped] = self.size[x] + self.right_total;\n                         self.check_stack(k - 1);\n                     }\n                 }\n                 End => {\n                     // paper says + not =, but that makes no sense.\n                     let popped = self.scan_pop();\n-                    *self.size.get_mut(popped) = 1;\n+                    self.size[popped] = 1;\n                     self.check_stack(k + 1);\n                 }\n                 _ => {\n                     let popped = self.scan_pop();\n-                    *self.size.get_mut(popped) = self.size[x] + self.right_total;\n+                    self.size[popped] = self.size[x] + self.right_total;\n                     if k > 0 {\n                         self.check_stack(k);\n                     }"}, {"sha": "386fd8ae5a617aefc19b207618d9acbc24021fec", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -90,10 +90,10 @@ pub fn rust_printer_annotated<'a>(writer: Box<io::Writer+'static>,\n     }\n }\n \n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n pub const indent_unit: uint = 4u;\n \n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n pub const default_columns: uint = 78u;\n \n /// Requires you to pass an input filename and reader so that\n@@ -225,12 +225,12 @@ pub fn token_to_string(tok: &Token) -> String {\n         token::RArrow               => \"->\".into_string(),\n         token::LArrow               => \"<-\".into_string(),\n         token::FatArrow             => \"=>\".into_string(),\n-        token::LParen               => \"(\".into_string(),\n-        token::RParen               => \")\".into_string(),\n-        token::LBracket             => \"[\".into_string(),\n-        token::RBracket             => \"]\".into_string(),\n-        token::LBrace               => \"{\".into_string(),\n-        token::RBrace               => \"}\".into_string(),\n+        token::OpenDelim(token::Paren) => \"(\".into_string(),\n+        token::CloseDelim(token::Paren) => \")\".into_string(),\n+        token::OpenDelim(token::Bracket) => \"[\".into_string(),\n+        token::CloseDelim(token::Bracket) => \"]\".into_string(),\n+        token::OpenDelim(token::Brace) => \"{\".into_string(),\n+        token::CloseDelim(token::Brace) => \"}\".into_string(),\n         token::Pound                => \"#\".into_string(),\n         token::Dollar               => \"$\".into_string(),\n         token::Question             => \"?\".into_string(),\n@@ -1121,12 +1121,11 @@ impl<'a> State<'a> {\n     pub fn print_tt(&mut self, tt: &ast::TokenTree) -> IoResult<()> {\n         match *tt {\n             ast::TtDelimited(_, ref delimed) => {\n-                let (ref open, ref tts, ref close) = **delimed;\n-                try!(word(&mut self.s, token_to_string(&open.token).as_slice()));\n+                try!(word(&mut self.s, token_to_string(&delimed.open_token()).as_slice()));\n                 try!(space(&mut self.s));\n-                try!(self.print_tts(tts.as_slice()));\n+                try!(self.print_tts(delimed.tts.as_slice()));\n                 try!(space(&mut self.s));\n-                word(&mut self.s, token_to_string(&close.token).as_slice())\n+                word(&mut self.s, token_to_string(&delimed.close_token()).as_slice())\n             },\n             ast::TtToken(_, ref tk) => {\n                 try!(word(&mut self.s, token_to_string(tk).as_slice()));"}, {"sha": "02a2613d4818a498806d7e03b2ce7e05ef2e4f4d", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -52,7 +52,7 @@\n #![allow(unknown_features)]\n #![feature(macro_rules, phase, slicing_syntax)]\n \n-#![deny(missing_doc)]\n+#![deny(missing_docs)]\n \n #[phase(plugin, link)] extern crate log;\n "}, {"sha": "5a0f10ce5207245f126122e65d842a5c62081363", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -38,7 +38,7 @@ enum FormatState {\n }\n \n /// Types of parameters a capability can use\n-#[allow(missing_doc)]\n+#[allow(missing_docs)]\n #[deriving(Clone)]\n pub enum Param {\n     Words(String),"}, {"sha": "9eb7216fba0bfedea7a58cbdd764310a081b7ef9", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_uppercase_statics)]\n+#![allow(non_upper_case_globals)]\n \n //! ncurses-compatible compiled terminfo format parsing (term(5))\n "}, {"sha": "2cc694176de5959705d1e854e1bd4532cf07184b", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(missing_doc)]\n+#![allow(missing_docs)]\n \n use std::collections::hashmap;\n use std::collections::hashmap::{Occupied, Vacant};\n@@ -128,7 +128,7 @@ pub trait Stats <T: FloatMath + FromPrimitive>{\n \n /// Extracted collection of all the summary statistics of a sample set.\n #[deriving(Clone, PartialEq)]\n-#[allow(missing_doc)]\n+#[allow(missing_docs)]\n pub struct Summary<T> {\n     pub sum: T,\n     pub min: T,\n@@ -185,15 +185,15 @@ impl<'a, T: FloatMath + FromPrimitive> Stats<T> for &'a [T] {\n                 let hi = x + y;\n                 let lo = y - (hi - x);\n                 if !lo.is_zero() {\n-                    *partials.get_mut(j) = lo;\n+                    partials[j] = lo;\n                     j += 1;\n                 }\n                 x = hi;\n             }\n             if j >= partials.len() {\n                 partials.push(x);\n             } else {\n-                *partials.get_mut(j) = x;\n+                partials[j] = x;\n                 partials.truncate(j+1);\n             }\n         }"}, {"sha": "5fe91a87056d42dd5e70bc654ecb1fd2e4a8dd5b", "filename": "src/libunicode/tables.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibunicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Flibunicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Ftables.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -10,7 +10,7 @@\n \n // NOTE: The following code was generated by \"src/etc/unicode.py\", do not edit directly\n \n-#![allow(missing_doc, non_uppercase_statics, non_snake_case)]\n+#![allow(missing_docs, non_upper_case_globals, non_snake_case)]\n \n /// The version of [Unicode](http://www.unicode.org/)\n /// that the `UnicodeChar` and `UnicodeStrSlice` traits are based on."}, {"sha": "8f83c9ec94fbd86c0b60e8b931a5f17a38afe710", "filename": "src/test/compile-fail-fulldeps/syntax-extension-regex-unused-static.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-regex-unused-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-regex-unused-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-regex-unused-static.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -15,9 +15,9 @@\n extern crate regex;\n #[phase(plugin)] extern crate regex_macros;\n \n-#[deny(unused_variable)]\n+#[deny(unused_variables)]\n #[deny(dead_code)]\n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n \n // Tests to make sure that extraneous dead code warnings aren't emitted from\n // the code generated by regex!."}, {"sha": "b4dda05f42d2b3e5820db2c16498bf22a89a9009", "filename": "src/test/compile-fail-fulldeps/syntax-extension-regex-unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-regex-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-regex-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-regex-unused.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -15,7 +15,7 @@\n extern crate regex;\n #[phase(plugin)] extern crate regex_macros;\n \n-#[deny(unused_variable)]\n+#[deny(unused_variables)]\n #[deny(dead_code)]\n \n // Tests to make sure that extraneous dead code warnings aren't emitted from"}, {"sha": "b29899e1940e24c1fe1de03e53e30c8a74ba6045", "filename": "src/test/compile-fail/asm-misplaced-option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fasm-misplaced-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fasm-misplaced-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fasm-misplaced-option.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -12,7 +12,7 @@\n \n #![feature(asm)]\n \n-#![allow(dead_code, non_uppercase_statics)]\n+#![allow(dead_code, non_upper_case_globals)]\n \n #[cfg(any(target_arch = \"x86\",\n           target_arch = \"x86_64\"))]"}, {"sha": "0b40a78425f6ee45c21eb30f55a14797b1c5b07e", "filename": "src/test/compile-fail/borrowck-lend-flow-match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(unused_variable)]\n-#![allow(dead_assignment)]\n+#![allow(unused_variables)]\n+#![allow(unused_assignments)]\n \n fn separate_arms() {\n     // Here both arms perform assignments, but only is illegal."}, {"sha": "9f258aee746f2312643c467075e59878ccc26feb", "filename": "src/test/compile-fail/coerce-bare-fn-to-closure-and-proc.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fcoerce-bare-fn-to-closure-and-proc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fcoerce-bare-fn-to-closure-and-proc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoerce-bare-fn-to-closure-and-proc.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -13,7 +13,9 @@ fn foo() {}\n fn main() {\n     let f = foo;\n     let f_closure: || = f;\n-    //~^ ERROR: cannot coerce non-statically resolved bare fn\n+    //~^ ERROR: cannot coerce non-statically resolved bare fn to closure\n+    //~^^ HELP: consider embedding the function in a closure\n     let f_proc: proc() = f;\n-    //~^ ERROR: cannot coerce non-statically resolved bare fn\n+    //~^ ERROR: cannot coerce non-statically resolved bare fn to closure\n+    //~^^ HELP: consider embedding the function in a closure\n }"}, {"sha": "0b335a526a4e372f6acecfd20b3a7d43b23431d4", "filename": "src/test/compile-fail/issue-10656.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fissue-10656.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fissue-10656.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10656.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -10,5 +10,5 @@\n \n // error-pattern: missing documentation for crate\n \n-#![deny(missing_doc)]\n+#![deny(missing_docs)]\n #![crate_type=\"lib\"]"}, {"sha": "9225889ef6348df7df644b98304b1b30162d4947", "filename": "src/test/compile-fail/issue-14309.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fissue-14309.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fissue-14309.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14309.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![deny(ctypes)]\n+#![deny(improper_ctypes)]\n #![allow(dead_code)]\n \n struct A {"}, {"sha": "2207e10add451719ba53b51ebdf986f3180a0a92", "filename": "src/test/compile-fail/issue-16562.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fissue-16562.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fissue-16562.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16562.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -16,8 +16,7 @@ struct Col<D, C> {\n }\n \n impl<T, M: MatrixShape> Collection for Col<M, uint> {\n-//~^ ERROR unable to infer enough type information to locate the impl of the trait\n-//~^^ NOTE the trait `core::kinds::Sized` must be implemented because it is required by\n+//~^ ERROR unable to infer enough type information\n     fn len(&self) -> uint {\n         unimplemented!()\n     }"}, {"sha": "e7f61a4f3ff5f55329866531dc631c1db77c534f", "filename": "src/test/compile-fail/issue-17551.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fissue-17551.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fissue-17551.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17551.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -13,6 +13,6 @@\n struct B<T>;\n \n fn main() {\n-    let foo = B; //~ ERROR unable to infer enough type information to locate the impl of the trait\n+    let foo = B; //~ ERROR unable to infer enough type information\n     let closure = |:| foo;\n }"}, {"sha": "e3ad2dd1b067b5c6d0fefba3462089cf243bfbba", "filename": "src/test/compile-fail/issue-17999.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fissue-17999.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fissue-17999.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17999.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![deny(unused_variable)]\n+#![deny(unused_variables)]\n \n fn main() {\n     for _ in range(1i, 101) {"}, {"sha": "e46bcf46cc3983dca3e36ab72d65278b3db1bb23", "filename": "src/test/compile-fail/issue-18159.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fissue-18159.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fissue-18159.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18159.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let x; //~ ERROR unable to infer enough type information\n+}"}, {"sha": "455cde63f272afa43f0e6e81de36575b9a3781a1", "filename": "src/test/compile-fail/issue-2150.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![deny(unreachable_code)]\n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n #![allow(dead_code)]\n \n fn fail_len(v: Vec<int> ) -> uint {"}, {"sha": "dea933085de4e0c098e6a5a0790f8b2e9c487fb2", "filename": "src/test/compile-fail/lint-ctypes-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-ctypes-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-ctypes-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-ctypes-enum.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![deny(ctypes)]\n+#![deny(improper_ctypes)]\n #![allow(dead_code)]\n \n enum Z { }"}, {"sha": "1755a9a2481b4ef9a034785e8b3b1facf8d6c401", "filename": "src/test/compile-fail/lint-ctypes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![deny(ctypes)]\n+#![deny(improper_ctypes)]\n \n extern crate libc;\n "}, {"sha": "1283c61e41a004a9cc83b88718b2c7e4eb8f7e74", "filename": "src/test/compile-fail/lint-dead-code-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n #![no_std]\n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n #![allow(non_camel_case_types)]\n-#![allow(non_uppercase_statics)]\n+#![allow(non_upper_case_globals)]\n #![deny(dead_code)]\n \n #![crate_type=\"lib\"]"}, {"sha": "c7199eec8a3e89ac120a1fe72aba1a32366e5403", "filename": "src/test/compile-fail/lint-dead-code-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-dead-code-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-dead-code-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-2.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n #![deny(dead_code)]\n \n struct Foo;"}, {"sha": "4ef76030bcc5414f6ec1b2cce602781ac065b39b", "filename": "src/test/compile-fail/lint-dead-code-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n #![allow(non_camel_case_types)]\n #![deny(dead_code)]\n "}, {"sha": "a698bf61f5894bc416d617a901c6904a9739639a", "filename": "src/test/compile-fail/lint-dead-code-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![feature(struct_variant)]\n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n #![allow(non_camel_case_types)]\n #![deny(dead_code)]\n "}, {"sha": "1f0d91dcb3cd93665731c6bfbba7ca410cd84af2", "filename": "src/test/compile-fail/lint-dead-code-5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-dead-code-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-dead-code-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-5.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![feature(struct_variant)]\n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n #![deny(dead_code)]\n \n enum Enum1 {"}, {"sha": "efb284495648a548dac117905a788bd3e9cd03e5", "filename": "src/test/compile-fail/lint-directives-on-use-items-issue-10534.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-directives-on-use-items-issue-10534.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-directives-on-use-items-issue-10534.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-directives-on-use-items-issue-10534.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![deny(unused_imports)]\n-#![allow(non_uppercase_statics)]\n+#![allow(non_upper_case_globals)]\n \n // The aim of this test is to ensure that deny/allow/warn directives\n // are applied to individual \"use\" statements instead of silently"}, {"sha": "18ea5a383f6b49e7ca8fd1e8dbf361d2855676c3", "filename": "src/test/compile-fail/lint-misplaced-attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-misplaced-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-misplaced-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-misplaced-attr.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -11,7 +11,7 @@\n // When denying at the crate level, be sure to not get random warnings from the\n // injected intrinsics by the compiler.\n \n-#![deny(unused_attribute)]\n+#![deny(unused_attributes)]\n \n mod a {\n     #![crate_type = \"bin\"] //~ ERROR unused attribute"}, {"sha": "f0b6abe28d37af117d09c423fa4412527ec17a68", "filename": "src/test/compile-fail/lint-missing-doc.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -12,7 +12,7 @@\n // injected intrinsics by the compiler.\n #![feature(struct_variant)]\n #![feature(globs)]\n-#![deny(missing_doc)]\n+#![deny(missing_docs)]\n #![allow(dead_code)]\n \n //! Some garbage docs for the crate here\n@@ -28,7 +28,7 @@ pub struct PubFoo { //~ ERROR: missing documentation\n     b: int,\n }\n \n-#[allow(missing_doc)]\n+#[allow(missing_docs)]\n pub struct PubFoo2 {\n     pub a: int,\n     pub c: int,\n@@ -41,7 +41,7 @@ pub mod pub_module_no_dox {} //~ ERROR: missing documentation\n pub fn foo() {}\n pub fn foo2() {} //~ ERROR: missing documentation\n fn foo3() {}\n-#[allow(missing_doc)] pub fn foo4() {}\n+#[allow(missing_docs)] pub fn foo4() {}\n \n /// dox\n pub trait A {\n@@ -50,7 +50,7 @@ pub trait A {\n     /// dox\n     fn foo_with_impl() {}\n }\n-#[allow(missing_doc)]\n+#[allow(missing_docs)]\n trait B {\n     fn foo();\n     fn foo_with_impl() {}\n@@ -59,7 +59,7 @@ pub trait C { //~ ERROR: missing documentation\n     fn foo(); //~ ERROR: missing documentation\n     fn foo_with_impl() {} //~ ERROR: missing documentation\n }\n-#[allow(missing_doc)] pub trait D {}\n+#[allow(missing_docs)] pub trait D {}\n \n impl Foo {\n     pub fn foo() {}\n@@ -71,10 +71,10 @@ impl PubFoo {\n     /// dox\n     pub fn foo1() {}\n     fn foo2() {}\n-    #[allow(missing_doc)] pub fn foo3() {}\n+    #[allow(missing_docs)] pub fn foo3() {}\n }\n \n-#[allow(missing_doc)]\n+#[allow(missing_docs)]\n trait F {\n     fn a();\n     fn b(&self);\n@@ -86,7 +86,7 @@ impl F for Foo {\n     fn b(&self) {}\n }\n \n-// It sure is nice if doc(hidden) implies allow(missing_doc), and that it\n+// It sure is nice if doc(hidden) implies allow(missing_docs), and that it\n // applies recursively\n #[doc(hidden)]\n mod a {\n@@ -121,7 +121,7 @@ pub enum PubBaz2 {\n     },\n }\n \n-#[allow(missing_doc)]\n+#[allow(missing_docs)]\n pub enum PubBaz3 {\n     PubBaz3A {\n         pub a: int,"}, {"sha": "7ff5cafd097a2d990629141b547637d3158b74bc", "filename": "src/test/compile-fail/lint-non-uppercase-statics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-non-uppercase-statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-non-uppercase-statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-non-uppercase-statics.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![forbid(non_uppercase_statics)]\n+#![forbid(non_upper_case_globals)]\n #![allow(dead_code)]\n \n static foo: int = 1; //~ ERROR static constant `foo` should have an uppercase name such as `FOO`"}, {"sha": "e4fd042d09845369a6226777abb947d308a0ee09", "filename": "src/test/compile-fail/lint-obsolete-attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-obsolete-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-obsolete-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-obsolete-attr.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -11,7 +11,7 @@\n // When denying at the crate level, be sure to not get random warnings from the\n // injected intrinsics by the compiler.\n \n-#![deny(unused_attribute)]\n+#![deny(unused_attributes)]\n #![allow(dead_code)]\n \n #[abi=\"stdcall\"] extern {} //~ ERROR unused attribute"}, {"sha": "5ee16f0aa26e5687c394102f4b289a44677bb943", "filename": "src/test/compile-fail/lint-owned-heap-memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-owned-heap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-owned-heap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-owned-heap-memory.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![allow(dead_code)]\n-#![forbid(owned_heap_memory)]\n+#![forbid(box_pointers)]\n \n \n struct Foo {"}, {"sha": "18a5a8ecc5d527d72fc7d2579bc45ba718f4002f", "filename": "src/test/compile-fail/lint-qualification.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-qualification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-qualification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-qualification.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![deny(unnecessary_qualification)]\n+#![deny(unused_qualifications)]\n \n mod foo {\n     pub fn bar() {}"}, {"sha": "7ffec37772fe8587c6bbdccb3dc1b28be73f141d", "filename": "src/test/compile-fail/lint-renaming.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-renaming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-renaming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-renaming.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that lint deprecation works\n+\n+#[deny(unused_variable)] //~ warning: lint unused_variable has been renamed to unused_variables\n+pub fn main() {\n+    let x = 0u8; //~ error: unused variable:\n+}"}, {"sha": "47dc93dae13e9a8cbb7573f12fe74c3289e2436b", "filename": "src/test/compile-fail/lint-type-overflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-type-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-type-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-type-overflow.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -9,13 +9,13 @@\n // except according to those terms.\n //\n \n-#![deny(type_overflow)]\n+#![deny(overflowing_literals)]\n \n fn test(x: i8) {\n     println!(\"x {}\", x);\n }\n \n-#[allow(unused_variable)]\n+#[allow(unused_variables)]\n fn main() {\n     let x1: u8 = 255; // should be OK\n     let x1: u8 = 256; //~ error: literal out of range for its type"}, {"sha": "e4cb92477c2997b52ae26c97df6eb3b7c49b8313", "filename": "src/test/compile-fail/lint-unknown-attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-unknown-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-unknown-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unknown-attr.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -11,7 +11,7 @@\n // When denying at the crate level, be sure to not get random warnings from the\n // injected intrinsics by the compiler.\n \n-#![deny(unused_attribute)]\n+#![deny(unused_attributes)]\n \n #![mutable_doc] //~ ERROR unused attribute\n "}, {"sha": "b3cf8257b8f6efa42e6a2f0538e98d0b8a10f554", "filename": "src/test/compile-fail/lint-unnecessary-casts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-casts.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![forbid(unnecessary_typecast)]\n+#![forbid(unused_typecasts)]\n \n fn foo_i32(_: i32) {}\n "}, {"sha": "1c0401ec56b853bbbde4ced5ec2aef8f51b75ab3", "filename": "src/test/compile-fail/lint-unnecessary-import-braces.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-import-braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-import-braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-import-braces.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![deny(unnecessary_import_braces)]\n+#![deny(unused_import_braces)]\n #![allow(dead_code)]\n #![allow(unused_imports)]\n "}, {"sha": "826a4ea5a8080d83a4e730100813f9b7c6ce2e41", "filename": "src/test/compile-fail/lint-unnecessary-parens.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-parens.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![deny(unnecessary_parens)]\n+#![deny(unused_parens)]\n #![feature(if_let,while_let)]\n \n #[deriving(Eq, PartialEq)]"}, {"sha": "8899d06804f1e88442f7f6bc45195b5dbbaf4f52", "filename": "src/test/compile-fail/lint-unsafe-block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-unsafe-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-unsafe-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unsafe-block.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -10,12 +10,12 @@\n \n #![allow(unused_unsafe)]\n #![allow(dead_code)]\n-#![deny(unsafe_block)]\n+#![deny(unsafe_blocks)]\n #![feature(macro_rules)]\n \n unsafe fn allowed() {}\n \n-#[allow(unsafe_block)] fn also_allowed() { unsafe {} }\n+#[allow(unsafe_blocks)] fn also_allowed() { unsafe {} }\n \n macro_rules! unsafe_in_macro {\n     () => {"}, {"sha": "a63e8e913f4c429b5b75e128832b4112d85748bc", "filename": "src/test/compile-fail/lint-unused-extern-crate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-unused-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-unused-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-extern-crate.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n #![feature(globs)]\n-#![deny(unused_extern_crate)]\n-#![allow(unused_variable)]\n+#![deny(unused_extern_crates)]\n+#![allow(unused_variables)]\n \n extern crate libc; //~ ERROR: unused extern crate\n "}, {"sha": "370f664e4303304d0df03566c2f22fc954352d87", "filename": "src/test/compile-fail/lint-unused-mut-self.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-self.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(dead_assignment)]\n-#![allow(unused_variable)]\n+#![allow(unused_assignments)]\n+#![allow(unused_variables)]\n #![allow(dead_code)]\n #![deny(unused_mut)]\n "}, {"sha": "29b4686198be1fc8a91a539d3282ba4e5b3cef9d", "filename": "src/test/compile-fail/lint-unused-mut-variables.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -10,8 +10,8 @@\n \n // Exercise the unused_mut attribute in some positive and negative cases\n \n-#![allow(dead_assignment)]\n-#![allow(unused_variable)]\n+#![allow(unused_assignments)]\n+#![allow(unused_variables)]\n #![allow(dead_code)]\n #![deny(unused_mut)]\n "}, {"sha": "18baf7a9c3f75a8888d316e8c4338dde27f13168", "filename": "src/test/compile-fail/liveness-dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fliveness-dead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fliveness-dead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-dead.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![allow(dead_code)]\n-#![deny(dead_assignment)]\n+#![deny(unused_assignments)]\n \n fn f1(x: &mut int) {\n     *x = 1; // no error"}, {"sha": "a747615199e6f6a4ad758591bce5251864c74f12", "filename": "src/test/compile-fail/liveness-unused.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![deny(unused_variable)]\n-#![deny(dead_assignment)]\n+#![deny(unused_variables)]\n+#![deny(unused_assignments)]\n #![allow(dead_code, non_camel_case_types)]\n \n fn f1(x: int) {\n@@ -20,7 +20,7 @@ fn f1b(x: &mut int) {\n     //~^ ERROR unused variable: `x`\n }\n \n-#[allow(unused_variable)]\n+#[allow(unused_variables)]\n fn f1c(x: int) {}\n \n fn f1d() {\n@@ -48,14 +48,14 @@ fn f3b() {\n     }\n }\n \n-#[allow(unused_variable)]\n+#[allow(unused_variables)]\n fn f3c() {\n     let mut z = 3i;\n     loop { z += 4i; }\n }\n \n-#[allow(unused_variable)]\n-#[allow(dead_assignment)]\n+#[allow(unused_variables)]\n+#[allow(unused_assignments)]\n fn f3d() {\n     let mut x = 3i;\n     x += 4i;"}, {"sha": "bd45b76dd5afcdd2cfac74c5cb948d52cb4bfeff", "filename": "src/test/compile-fail/macro-invocation-dot-help.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fmacro-invocation-dot-help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fmacro-invocation-dot-help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-invocation-dot-help.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    foo!() //~ HELP try parenthesizing this macro invocation\n+    .bar //~ ERROR expected statement\n+}"}, {"sha": "15a832aad89ad8af60baa74a9dd6b10e127de9ce", "filename": "src/test/compile-fail/match-static-const-lc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fmatch-static-const-lc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fmatch-static-const-lc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-static-const-lc.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -11,9 +11,9 @@\n // Issue #7526: lowercase static constants in patterns look like bindings\n \n #![allow(dead_code)]\n-#![deny(non_uppercase_statics)]\n+#![deny(non_upper_case_globals)]\n \n-#[allow(non_uppercase_statics)]\n+#[allow(non_upper_case_globals)]\n pub const a : int = 97;\n \n fn f() {\n@@ -26,7 +26,7 @@ fn f() {\n }\n \n mod m {\n-    #[allow(non_uppercase_statics)]\n+    #[allow(non_upper_case_globals)]\n     pub const aha : int = 7;\n }\n "}, {"sha": "05bbaec37af02339feb045d1449ba88e5e729bde", "filename": "src/test/compile-fail/parenthesized-box-expr-message.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fparenthesized-box-expr-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fparenthesized-box-expr-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fparenthesized-box-expr-message.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    box(1 + 1) //~ HELP perhaps you meant `box() (foo)` instead?\n+    ; //~ ERROR expected expression, found `;`\n+}"}, {"sha": "4c90b1f0eeabfa9fbbdc05b8d5a2cae73c10e428", "filename": "src/test/compile-fail/regions-fn-subtyping-return-static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping-return-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping-return-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping-return-static.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -17,7 +17,7 @@\n // lifetimes are sublifetimes of 'static.\n \n #![allow(dead_code)]\n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n struct S;\n "}, {"sha": "b31e2538ab97bb022f989b207c6e45943c506370", "filename": "src/test/compile-fail/removed-syntax-record.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-record.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-record.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-record.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-type t = { f: () }; //~ ERROR expected type, found token LBrace\n+type t = { f: () }; //~ ERROR expected type, found token OpenDelim(Brace)"}, {"sha": "ba39f3e0d176d4fd22e099ad10de744c6ac18053", "filename": "src/test/compile-fail/unique-vec-res.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -29,14 +29,16 @@ impl<'a> Drop for r<'a> {\n fn f<T>(_i: Vec<T> , _j: Vec<T> ) {\n }\n \n+fn clone<T: Clone>(t: &T) -> T { t.clone() }\n+\n fn main() {\n     let i1 = &Cell::new(0);\n     let i2 = &Cell::new(1);\n     let r1 = vec!(box r { i: i1 });\n     let r2 = vec!(box r { i: i2 });\n-    f(r1.clone(), r2.clone());\n-    //~^ ERROR does not implement any method in scope named `clone`\n-    //~^^ ERROR does not implement any method in scope named `clone`\n+    f(clone(&r1), clone(&r2));\n+    //~^ ERROR the trait `core::clone::Clone` is not implemented for the type\n+    //~^^ ERROR the trait `core::clone::Clone` is not implemented for the type\n     println!(\"{}\", (r2, i1.get()));\n     println!(\"{}\", (r1, i2.get()));\n }"}, {"sha": "87342352e9ae40b5fcffd8cd5fe12b18eb742abe", "filename": "src/test/compile-fail/unreachable-code.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Funreachable-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Funreachable-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funreachable-code.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![deny(unreachable_code)]\n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n fn main() {\n   loop{}"}, {"sha": "e797c7eec5f5fcbdb0a268eb7191c7c2ee982810", "filename": "src/test/compile-fail/unused-attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Funused-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Funused-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funused-attr.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -7,7 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![deny(unused_attribute)]\n+#![deny(unused_attributes)]\n #![allow(dead_code, unused_imports)]\n \n #![foo] //~ ERROR unused attribute"}, {"sha": "1263d7c5710f60062d0208143bcebe58f1a9c7d8", "filename": "src/test/compile-fail/unused-result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Funused-result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Funused-result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funused-result.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![deny(unused_result, unused_must_use)]\n+#![deny(unused_results, unused_must_use)]\n #![allow(dead_code)]\n \n #[must_use]\n@@ -23,14 +23,14 @@ fn bar() -> int { return foo::<int>(); }\n fn baz() -> MustUse { return foo::<MustUse>(); }\n fn qux() -> MustUseMsg { return foo::<MustUseMsg>(); }\n \n-#[allow(unused_result)]\n+#[allow(unused_results)]\n fn test() {\n     foo::<int>();\n     foo::<MustUse>(); //~ ERROR: unused result which must be used\n     foo::<MustUseMsg>(); //~ ERROR: unused result which must be used: some message\n }\n \n-#[allow(unused_result, unused_must_use)]\n+#[allow(unused_results, unused_must_use)]\n fn test2() {\n     foo::<int>();\n     foo::<MustUse>();"}, {"sha": "5f7a2f69c4f918e27c510d61306e8ac1d5495c40", "filename": "src/test/compile-fail/warn-foreign-int-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fwarn-foreign-int-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fcompile-fail%2Fwarn-foreign-int-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwarn-foreign-int-types.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![forbid(ctypes)]\n+#![forbid(improper_ctypes)]\n #![allow(dead_code)]\n \n mod xx {"}, {"sha": "b2f82493fa78d3a3b9575507aedc21df8c865989", "filename": "src/test/debuginfo/basic-types-globals-metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fbasic-types-globals-metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fbasic-types-globals-metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fbasic-types-globals-metadata.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -46,7 +46,7 @@\n // gdb-check:type = f64\n // gdb-command:continue\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n #![allow(dead_code)]\n \n "}, {"sha": "d08feadefdac086a8ec204926468ee56739b6a41", "filename": "src/test/debuginfo/basic-types-globals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fbasic-types-globals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fbasic-types-globals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fbasic-types-globals.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -52,7 +52,7 @@\n // gdb-check:$14 = 3.5\n // gdb-command:continue\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n static B: bool = false;\n static I: int = -1;"}, {"sha": "e46177c884481241843fc787a3e2a4a079c2144b", "filename": "src/test/debuginfo/basic-types-metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fbasic-types-metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fbasic-types-metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fbasic-types-metadata.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -49,7 +49,7 @@\n // gdb-check:[...]![...]_yyy([...])([...]);\n // gdb-command:continue\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n fn main() {\n     let unit: () = ();"}, {"sha": "241bfcd7510c8ec73977e8c2b4372c807de4ace9", "filename": "src/test/debuginfo/basic-types-mut-globals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fbasic-types-mut-globals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fbasic-types-mut-globals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fbasic-types-mut-globals.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -87,7 +87,7 @@\n // gdb-command:detach\n // gdb-command:quit\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n static mut B: bool = false;\n static mut I: int = -1;"}, {"sha": "525d71b560fc495093629d010dda631e1f5af5dc", "filename": "src/test/debuginfo/basic-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fbasic-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fbasic-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fbasic-types.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -89,7 +89,7 @@\n // lldb-command:print f64\n // lldb-check:[...]$12 = 3.5\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n fn main() {\n     let b: bool = false;"}, {"sha": "eac3652f163c0b4341e12dfca92aa3beb40f947d", "filename": "src/test/debuginfo/borrowed-basic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fborrowed-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fborrowed-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fborrowed-basic.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -110,7 +110,7 @@\n // lldb-command:print *f64_ref\n // lldb-check:[...]$12 = 3.5\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n fn main() {\n     let bool_val: bool = true;"}, {"sha": "b2431d7221fe8059de1be66f254b6836be8460b6", "filename": "src/test/debuginfo/borrowed-c-style-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fborrowed-c-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fborrowed-c-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fborrowed-c-style-enum.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -42,7 +42,7 @@\n // lldb-command:print *the_c_ref\n // lldb-check:[...]$2 = TheC\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n enum ABC { TheA, TheB, TheC }\n "}, {"sha": "8b72f2538c556c1ca44ebde3b4106f2e24d8986c", "filename": "src/test/debuginfo/borrowed-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fborrowed-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fborrowed-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fborrowed-enum.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -41,7 +41,7 @@\n // lldb-command:print *univariant_ref\n // lldb-check:[...]$2 = TheOnlyCase(4820353753753434)\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n #![feature(struct_variant)]\n \n // The first element is to ensure proper alignment, irrespective of the machines word size. Since"}, {"sha": "a9c5a59488f1840a32d3bcea7e0636957c117c39", "filename": "src/test/debuginfo/borrowed-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fborrowed-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fborrowed-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fborrowed-struct.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -65,7 +65,7 @@\n // lldb-command:print *unique_val_interior_ref_2\n // lldb-check:[...]$6 = 26.5\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n struct SomeStruct {\n     x: int,"}, {"sha": "f5afa008d2e80cd0967ece7ef6de62d6ce61a1a3", "filename": "src/test/debuginfo/borrowed-tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fborrowed-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fborrowed-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fborrowed-tuple.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -43,7 +43,7 @@\n // lldb-check:[...]$2 = (-17, -22)\n \n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n fn main() {\n     let stack_val: (i16, f32) = (-14, -19f32);"}, {"sha": "2592b166256630e384ae37cc0c9de452a9c01a43", "filename": "src/test/debuginfo/borrowed-unique-basic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fborrowed-unique-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fborrowed-unique-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fborrowed-unique-basic.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -112,7 +112,7 @@\n // lldb-command:print *f64_ref\n // lldb-check:[...]$12 = 3.5\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n \n fn main() {"}, {"sha": "8075d9ab69d9fd3d2df15f9cb3d13089f816e287", "filename": "src/test/debuginfo/box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fbox.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -33,7 +33,7 @@\n // lldb-command:print *b\n // lldb-check:[...]$1 = (2, 3.5)\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n fn main() {\n     let a = box 1i;"}, {"sha": "87eea49dd0c4baa4cdadafbbc983458f17346de7", "filename": "src/test/debuginfo/boxed-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fboxed-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fboxed-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fboxed-struct.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -36,7 +36,7 @@\n // lldb-command:print *unique_dtor\n // lldb-check:[...]$1 = StructWithDestructor { x: 77, y: 777, z: 7777, w: 77777 }\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n struct StructWithSomePadding {\n     x: i16,"}, {"sha": "ec385840d1df796c670ef895e97dbde03d63002b", "filename": "src/test/debuginfo/c-style-enum-in-composite.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fc-style-enum-in-composite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fc-style-enum-in-composite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fc-style-enum-in-composite.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -66,7 +66,7 @@\n // lldb-command:print struct_with_drop\n // lldb-check:[...]$6 = (StructWithDrop { a: OneHundred, b: Vienna }, 9)\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n enum AnEnum {\n     OneHundred = 100,"}, {"sha": "9f80f6475e25235531596c8ab8c0e75ba652f025", "filename": "src/test/debuginfo/c-style-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fc-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fc-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fc-style-enum.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -101,7 +101,7 @@\n // lldb-command:print single_variant\n // lldb-check:[...]$6 = TheOnlyVariant\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n #![allow(dead_code)]\n \n enum AutoDiscriminant {"}, {"sha": "993a1a55012df15ada5bbdb015eca76426ba0a02", "filename": "src/test/debuginfo/destructured-fn-argument.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fdestructured-fn-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fdestructured-fn-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fdestructured-fn-argument.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -333,7 +333,7 @@\n // lldb-check:[...]$48 = 62\n // lldb-command:continue\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n \n struct Struct {"}, {"sha": "a16298349ed8538974c28c64e5754111f8e32bcd", "filename": "src/test/debuginfo/destructured-local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fdestructured-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fdestructured-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fdestructured-local.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -245,7 +245,7 @@\n // lldb-check:[...]$42 = 56\n \n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n struct Struct {\n     a: i64,"}, {"sha": "66407d68aa6b42f48bc74490a86be84641d72ab2", "filename": "src/test/debuginfo/evec-in-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fevec-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fevec-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fevec-in-struct.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -53,7 +53,7 @@\n // lldb-command:print struct_padded_at_end\n // lldb-check:[...]$4 = StructPaddedAtEnd { x: [22, 23], y: [24, 25] }\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n struct NoPadding1 {\n     x: [u32, ..3],"}, {"sha": "ea9802afe94467fce21af8551303eca7bf3301a7", "filename": "src/test/debuginfo/function-arg-initialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Ffunction-arg-initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Ffunction-arg-initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-arg-initialization.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -236,7 +236,7 @@\n \n \n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n \n "}, {"sha": "359d14d2a5009fc7fd9103abd5034745bafcd975", "filename": "src/test/debuginfo/function-prologue-stepping-no-stack-check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -245,7 +245,7 @@\n // lldb-check:[...]$31 = 45\n // lldb-command:continue\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n #[no_stack_check]\n fn immediate_args(a: int, b: bool, c: f64) {"}, {"sha": "dbeb87fd44afe1662b80e4f646161e12b3789e02", "filename": "src/test/debuginfo/function-prologue-stepping-regular.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-regular.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-regular.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-regular.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -125,7 +125,7 @@\n // lldb-check:[...]$31 = 45\n // lldb-command:continue\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n fn immediate_args(a: int, b: bool, c: f64) {\n     ()"}, {"sha": "378b27b3597430800ef162a509d05d370ceec885", "filename": "src/test/debuginfo/include_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Finclude_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Finclude_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Finclude_string.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -37,7 +37,7 @@\n \n // lldb-command:continue\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n // This test case makes sure that debug info does not ICE when include_str is\n // used multiple times (see issue #11322)."}, {"sha": "191b1d2a09cbd0a4ffa8bf6bc4780f8aca8831da", "filename": "src/test/debuginfo/lexical-scopes-in-block-expression.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Flexical-scopes-in-block-expression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Flexical-scopes-in-block-expression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scopes-in-block-expression.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -373,8 +373,8 @@\n // lldb-check:[...]$47 = 10\n // lldb-command:continue\n \n-#![allow(unused_variable)]\n-#![allow(dead_assignment)]\n+#![allow(unused_variables)]\n+#![allow(unused_assignments)]\n \n static mut MUT_INT: int = 0;\n "}, {"sha": "292e42ba30bbb0e8eebfc205c5f42e25000a6e77", "filename": "src/test/debuginfo/limited-debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Flimited-debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Flimited-debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flimited-debuginfo.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -31,7 +31,7 @@\n // gdb-command:continue\n \n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n struct Struct {\n     a: i64,"}, {"sha": "6bb2313100f8a14c692b2c0af9ab4f5120342cbe", "filename": "src/test/debuginfo/multiple-functions-equal-var-names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fmultiple-functions-equal-var-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fmultiple-functions-equal-var-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmultiple-functions-equal-var-names.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -48,7 +48,7 @@\n // lldb-command:print abc\n // lldb-check:[...]$2 = 30303\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n fn function_one() {\n     let abc = 10101i;"}, {"sha": "58fe9d250c97df11a66bcaeda5adabc0affee9af", "filename": "src/test/debuginfo/multiple-functions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fmultiple-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fmultiple-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmultiple-functions.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -48,7 +48,7 @@\n // lldb-command:print c\n // lldb-check:[...]$2 = 30303\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n fn function_one() {\n     let a = 10101i;"}, {"sha": "a0c726157536adefcf8d281ccad1b55a73020093", "filename": "src/test/debuginfo/nil-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fnil-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fnil-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fnil-enum.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -24,7 +24,7 @@\n // gdb-command:print second\n // gdb-check:$2 = {<No data fields>}\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n enum ANilEnum {}\n enum AnotherNilEnum {}"}, {"sha": "a739c9ee5fae378c63c501a77c434466374d888a", "filename": "src/test/debuginfo/no-debug-attribute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fno-debug-attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fno-debug-attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fno-debug-attribute.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -25,7 +25,7 @@\n // gdb-check:abc = 10\n // gdb-command:continue\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n fn function_with_debuginfo() {\n     let abc = 10u;"}, {"sha": "438a771b7be9d14510f92cd147a0c2624b05440d", "filename": "src/test/debuginfo/packed-struct-with-destructor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fpacked-struct-with-destructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fpacked-struct-with-destructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpacked-struct-with-destructor.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -76,7 +76,7 @@\n // lldb-check:[...]$7 = DeeplyNested { a: PackedInPacked { a: 1, b: Packed { x: 2, y: 3, z: 4 }, c: 5, d: Packed { x: 6, y: 7, z: 8 } }, b: UnpackedInPackedWithDrop { a: 9, b: Unpacked { x: 10, y: 11, z: 12 }, c: Unpacked { x: 13, y: 14, z: 15 }, d: 16 }, c: PackedInUnpacked { a: 17, b: Packed { x: 18, y: 19, z: 20 }, c: 21, d: Packed { x: 22, y: 23, z: 24 } }, d: PackedInUnpackedWithDrop { a: 25, b: Packed { x: 26, y: 27, z: 28 }, c: 29, d: Packed { x: 30, y: 31, z: 32 } }, e: UnpackedInPacked { a: 33, b: Unpacked { x: 34, y: 35, z: 36 }, c: Unpacked { x: 37, y: 38, z: 39 }, d: 40 }, f: PackedInPackedWithDrop { a: 41, b: Packed { x: 42, y: 43, z: 44 }, c: 45, d: Packed { x: 46, y: 47, z: 48 } } }\n \n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n #[repr(packed)]\n struct Packed {"}, {"sha": "906a1f4685b5e97570630d16ca18706e1e4b9da3", "filename": "src/test/debuginfo/packed-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fpacked-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fpacked-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpacked-struct.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -62,7 +62,7 @@\n // lldb-command:print sizeof(packedInPacked)\n // lldb-check:[...]$5 = 40\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n #[repr(packed)]\n struct Packed {"}, {"sha": "6d26e2eff7a468818eeec240f0c394cf06b71ccb", "filename": "src/test/debuginfo/recursive-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Frecursive-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Frecursive-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Frecursive-enum.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -18,7 +18,7 @@\n // Test whether compiling a recursive enum definition crashes debug info generation. The test case\n // is taken from issue #11083.\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n pub struct Window<'a> {\n     callbacks: WindowCallbacks<'a>"}, {"sha": "1e64dc3a031456564abe93055e5c254b09123f77", "filename": "src/test/debuginfo/recursive-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Frecursive-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Frecursive-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Frecursive-struct.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -72,7 +72,7 @@\n \n // gdb-command:continue\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n #![feature(struct_variant)]\n \n enum Opt<T> {"}, {"sha": "d8854eb9084534d4163d6dad08cca9cc985f116c", "filename": "src/test/debuginfo/simd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fsimd.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -44,7 +44,7 @@\n // gdb-command:continue\n \n #![allow(experimental)]\n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n use std::simd::{i8x16, i16x8,i32x4,i64x2,u8x16,u16x8,u32x4,u64x2,f32x4,f64x2};\n "}, {"sha": "83f77b08b6830710df157df3025e62b792a4826f", "filename": "src/test/debuginfo/simple-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fsimple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fsimple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fsimple-struct.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -99,7 +99,7 @@\n // lldb-command:print padding_at_end\n // lldb-check:[...]$5 = PaddingAtEnd { x: -10014, y: 10015 }\n \n-#![allow(unused_variable)];\n+#![allow(unused_variables)];\n #![allow(dead_code)];\n \n struct NoPadding16 {"}, {"sha": "26239f7f62b0b33a522713daeece89908eaf3db6", "filename": "src/test/debuginfo/simple-tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fsimple-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fsimple-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fsimple-tuple.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -95,7 +95,7 @@\n // lldb-command:print paddingAtEnd\n // lldb-check:[...]$6 = (15, 16)\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n #![allow(dead_code)]\n \n static mut NO_PADDING_8: (i8, u8) = (-50, 50);"}, {"sha": "5e2ae478d7db5641629f6f3c75d33dd257cdc11f", "filename": "src/test/debuginfo/struct-in-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fstruct-in-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fstruct-in-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fstruct-in-enum.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -43,7 +43,7 @@\n // lldb-command:print univariant\n // lldb-check:[...]$2 = TheOnlyCase(Struct { x: 123, y: 456, z: 789 })\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n struct Struct {\n     x: u32,"}, {"sha": "1e0b84f1ef1afb3cfcddd4e91996517737e81b12", "filename": "src/test/debuginfo/struct-in-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fstruct-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fstruct-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fstruct-in-struct.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -59,7 +59,7 @@\n // lldb-command:print tree\n // lldb-check:[...]$7 = Tree { x: Simple { x: 25 }, y: InternalPaddingParent { x: InternalPadding { x: 26, y: 27 }, y: InternalPadding { x: 28, y: 29 }, z: InternalPadding { x: 30, y: 31 } }, z: BagInBag { x: Bag { x: Simple { x: 32 } } } }\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n struct Simple {\n     x: i32"}, {"sha": "d23c65e71a0d0998128f127be6fae41d47a4e4b8", "filename": "src/test/debuginfo/struct-style-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -50,7 +50,7 @@\n // lldb-command:print univariant\n // lldb-check:[...]$3 = TheOnlyCase { a: -1 }\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n #![feature(struct_variant)]\n \n // The first element is to ensure proper alignment, irrespective of the machines word size. Since"}, {"sha": "c2372da35aaa4c3efd76cd3719b57c3da6d9e19a", "filename": "src/test/debuginfo/struct-with-destructor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fstruct-with-destructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fstruct-with-destructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fstruct-with-destructor.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -46,7 +46,7 @@\n // lldb-command:print nested\n // lldb-check:[...]$3 = NestedOuter { a: NestedInner { a: WithDestructor { x: 7890, y: 9870 } } }\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n struct NoDestructor {\n     x: i32,"}, {"sha": "de74a4d8f91a1d647be4cca6d25e43914782610b", "filename": "src/test/debuginfo/trait-pointers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Ftrait-pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Ftrait-pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftrait-pointers.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -15,7 +15,7 @@\n // compile-flags:-g\n // gdb-command:run\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n \n trait Trait {"}, {"sha": "5a47b1646483728a1e6bcbbe7f5569cfa52f2ff9", "filename": "src/test/debuginfo/tuple-in-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Ftuple-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Ftuple-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftuple-in-struct.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -42,7 +42,7 @@\n // gdb-command:print mixed_padding\n // gdb-check:$10 = {x = {{40, 41, 42}, {43, 44}}, y = {45, 46, 47, 48}}\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n struct NoPadding1 {\n     x: (i32, i32),"}, {"sha": "b7f4b0efe0ce1963d8a421df23b4f46bd3f665e7", "filename": "src/test/debuginfo/tuple-in-tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Ftuple-in-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Ftuple-in-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftuple-in-tuple.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -59,7 +59,7 @@\n // lldb-command:print padding_at_end2\n // lldb-check:[...]$6 = ((21, 22), 23)\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n fn main() {\n     let no_padding1: ((u32, u32), u32, u32) = ((0, 1), 2, 3);"}, {"sha": "1c933637e3e776621e0a879ee0a56cb37372d929", "filename": "src/test/debuginfo/tuple-style-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -50,7 +50,7 @@\n // lldb-command:print univariant\n // lldb-check:[...]$3 = TheOnlyCase(-1)\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n // The first element is to ensure proper alignment, irrespective of the machines word size. Since\n // the size of the discriminant value is machine dependent, this has be taken into account when"}, {"sha": "33382542ef298560da79c3277f6c942c412dd715", "filename": "src/test/debuginfo/unique-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Funique-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Funique-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Funique-enum.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -43,7 +43,7 @@\n // lldb-command:print *univariant\n // lldb-check:[...]$2 = TheOnlyCase(123234)\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n #![feature(struct_variant)]\n \n // The first element is to ensure proper alignment, irrespective of the machines word size. Since"}, {"sha": "8f128c428e78978fc612b560d431bc3488353ee7", "filename": "src/test/debuginfo/var-captured-in-nested-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-nested-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-nested-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-nested-closure.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -81,7 +81,7 @@\n // lldb-check:[...]$11 = 8\n // lldb-command:continue\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n struct Struct {\n     a: int,"}, {"sha": "da2726782e9a66b36edcb7118fa905bbaf4a9e6d", "filename": "src/test/debuginfo/var-captured-in-sendable-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-sendable-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-sendable-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-sendable-closure.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -38,7 +38,7 @@\n // lldb-command:print *owned\n // lldb-check:[...]$2 = 5\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n struct Struct {\n     a: int,"}, {"sha": "5d484bbacc8b8e66e7586728255160ecd27aeb48", "filename": "src/test/debuginfo/var-captured-in-stack-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-stack-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-stack-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-stack-closure.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -46,7 +46,7 @@\n // lldb-command:print *owned\n // lldb-check:[...]$4 = 6\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n struct Struct {\n     a: int,"}, {"sha": "6d56ed32c31ead701fc39368676f1bef6ee4126d", "filename": "src/test/debuginfo/vec-slices.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -80,7 +80,7 @@\n // lldb-command:print padded_struct\n // lldb-check:[...]$5 = &[AStruct { x: 10, y: 11, z: 12 }, AStruct { x: 13, y: 14, z: 15 }]\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n #![feature(slicing_syntax)]\n \n struct AStruct {"}, {"sha": "872d66fdc88db8bbc4341905bb1310023d82b281", "filename": "src/test/debuginfo/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Fdebuginfo%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvec.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -32,7 +32,7 @@\n // lldb-command:print a\n // lldb-check:[...]$0 = [1, 2, 3]\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n static mut VECT: [i32, ..3] = [1, 2, 3];\n "}, {"sha": "ae6e72bdd4f3261d865bdf63c17bedcaf73f9786", "filename": "src/test/run-fail/explicit-fail-msg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Frun-fail%2Fexplicit-fail-msg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Frun-fail%2Fexplicit-fail-msg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexplicit-fail-msg.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(dead_assignment)]\n-#![allow(unused_variable)]\n+#![allow(unused_assignments)]\n+#![allow(unused_variables)]\n \n // error-pattern:wooooo\n fn main() {"}, {"sha": "0846ba2e71a4f467d58cc094fbb66156f121bf06", "filename": "src/test/run-fail/issue-3029.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Frun-fail%2Fissue-3029.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Frun-fail%2Fissue-3029.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-3029.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(unnecessary_allocation)]\n+#![allow(unused_allocation)]\n #![allow(unreachable_code)]\n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n \n // error-pattern:so long"}, {"sha": "e51e8d93eb0ca0771485b3eb7fffd33463f03c32", "filename": "src/test/run-fail/issue-948.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Frun-fail%2Fissue-948.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Frun-fail%2Fissue-948.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-948.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -10,7 +10,7 @@\n \n // error-pattern:beep boop\n \n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n struct Point { x: int, y: int }\n "}, {"sha": "2b1672ad4e53763e73e76fae51c8fc2e1e54ad9c", "filename": "src/test/run-fail/match-bot-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Frun-fail%2Fmatch-bot-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Frun-fail%2Fmatch-bot-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmatch-bot-fail.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -11,7 +11,7 @@\n // error-pattern:explicit panic\n \n #![allow(unreachable_code)]\n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n fn foo(s: String) { }\n "}, {"sha": "ff4040ded5f382722a9a1873f1a89f9e5050fe88", "filename": "src/test/run-fail/rhs-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Frun-fail%2Frhs-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Frun-fail%2Frhs-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frhs-type.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -13,7 +13,7 @@\n // error-pattern:bye\n \n #![allow(unreachable_code)]\n-#![allow(unused_variable)]\n+#![allow(unused_variables)]\n \n struct T { t: String }\n "}, {"sha": "fa38dcc1986730b08e7f16949a5f99635950f9e2", "filename": "src/test/run-pass/issue-17361.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Frun-pass%2Fissue-17361.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Frun-pass%2Fissue-17361.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17361.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that astconv doesn't forget about mutability of &mut str\n+\n+fn main() {\n+    fn foo<Sized? T>(_: &mut T) {}\n+    let _f: fn(&mut str) = foo;\n+}"}, {"sha": "c03301f17f31fe15776d32e126dcd41f5cb8e4cb", "filename": "src/test/run-pass/issue-18412.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Frun-pass%2Fissue-18412.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Frun-pass%2Fissue-18412.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18412.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(tuple_indexing)]\n+\n+// Test that non-static methods can be assigned to local variables as\n+// function pointers.\n+\n+trait Foo {\n+    fn foo(&self) -> uint;\n+}\n+\n+struct A(uint);\n+\n+impl A {\n+    fn bar(&self) -> uint { self.0 }\n+}\n+\n+impl Foo for A {\n+    fn foo(&self) -> uint { self.bar() }\n+}\n+\n+fn main() {\n+    let f = A::bar;\n+    let g = Foo::foo;\n+    let a = A(42);\n+\n+    assert_eq!(f(&a), g(&a));\n+}"}, {"sha": "6bb244bf88f424d24958e95e37995338ec57c777", "filename": "src/test/run-pass/issue-18425.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Frun-pass%2Fissue-18425.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221fc1e3cdcc208e1bb7debcc2de27d47c847747/src%2Ftest%2Frun-pass%2Fissue-18425.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18425.rs?ref=221fc1e3cdcc208e1bb7debcc2de27d47c847747", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that trans doesn't ICE when translating an array repeat\n+// expression with a count of 1 and a non-Copy element type.\n+\n+fn main() {\n+    let _ = [box 1u, ..1];\n+}"}]}