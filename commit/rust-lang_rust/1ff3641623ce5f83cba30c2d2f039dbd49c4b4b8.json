{"sha": "1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmZjM2NDE2MjNjZTVmODNjYmEzMGMyZDJmMDM5ZGJkNDljNGI0Yjg=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-01-26T01:21:50Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-01-26T11:41:28Z"}, "message": "rustc: don't call the HIR AST.", "tree": {"sha": "3ac656117f229e7a34a1cf15fd32c39b74fb0e0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ac656117f229e7a34a1cf15fd32c39b74fb0e0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8", "html_url": "https://github.com/rust-lang/rust/commit/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "html_url": "https://github.com/rust-lang/rust/commit/45c8c5678a3065c5d1f75b2413bd800a792cf3d9"}], "stats": {"total": 708, "additions": 345, "deletions": 363}, "files": [{"sha": "944b77dbf01fd21367234a21bd59997bc46ac4d6", "filename": "src/librustc/cfg/graphviz.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fgraphviz.rs?ref=1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8", "patch": "@@ -17,14 +17,14 @@ use graphviz::IntoCow;\n \n use syntax::ast;\n \n-use hir::map as ast_map;\n+use hir::map as hir_map;\n use cfg;\n \n pub type Node<'a> = (cfg::CFGIndex, &'a cfg::CFGNode);\n pub type Edge<'a> = &'a cfg::CFGEdge;\n \n-pub struct LabelledCFG<'a, 'ast: 'a> {\n-    pub ast_map: &'a ast_map::Map<'ast>,\n+pub struct LabelledCFG<'a, 'hir: 'a> {\n+    pub hir_map: &'a hir_map::Map<'hir>,\n     pub cfg: &'a cfg::CFG,\n     pub name: String,\n     /// `labelled_edges` controls whether we emit labels on the edges\n@@ -52,7 +52,7 @@ fn replace_newline_with_backslash_l(s: String) -> String {\n     }\n }\n \n-impl<'a, 'ast> dot::Labeller<'a> for LabelledCFG<'a, 'ast> {\n+impl<'a, 'hir> dot::Labeller<'a> for LabelledCFG<'a, 'hir> {\n     type Node = Node<'a>;\n     type Edge = Edge<'a>;\n     fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(&self.name[..]).unwrap() }\n@@ -69,7 +69,7 @@ impl<'a, 'ast> dot::Labeller<'a> for LabelledCFG<'a, 'ast> {\n         } else if n.data.id() == ast::DUMMY_NODE_ID {\n             dot::LabelText::LabelStr(\"(dummy_node)\".into_cow())\n         } else {\n-            let s = self.ast_map.node_to_string(n.data.id());\n+            let s = self.hir_map.node_to_string(n.data.id());\n             // left-aligns the lines\n             let s = replace_newline_with_backslash_l(s);\n             dot::LabelText::EscStr(s.into_cow())\n@@ -88,7 +88,7 @@ impl<'a, 'ast> dot::Labeller<'a> for LabelledCFG<'a, 'ast> {\n             } else {\n                 put_one = true;\n             }\n-            let s = self.ast_map.node_to_string(node_id);\n+            let s = self.hir_map.node_to_string(node_id);\n             // left-aligns the lines\n             let s = replace_newline_with_backslash_l(s);\n             label.push_str(&format!(\"exiting scope_{} {}\",\n@@ -120,7 +120,7 @@ impl<'a> dot::GraphWalk<'a> for &'a cfg::CFG {\n     }\n }\n \n-impl<'a, 'ast> dot::GraphWalk<'a> for LabelledCFG<'a, 'ast>\n+impl<'a, 'hir> dot::GraphWalk<'a> for LabelledCFG<'a, 'hir>\n {\n     type Node = Node<'a>;\n     type Edge = Edge<'a>;"}, {"sha": "d4095c6875c1d10e44b61a8c37060440893502e6", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8", "patch": "@@ -1085,13 +1085,13 @@ impl IdRange {\n }\n \n \n-pub struct IdRangeComputingVisitor<'a, 'ast: 'a> {\n+pub struct IdRangeComputingVisitor<'a, 'hir: 'a> {\n     result: IdRange,\n-    map: &'a map::Map<'ast>,\n+    map: &'a map::Map<'hir>,\n }\n \n-impl<'a, 'ast> IdRangeComputingVisitor<'a, 'ast> {\n-    pub fn new(map: &'a map::Map<'ast>) -> IdRangeComputingVisitor<'a, 'ast> {\n+impl<'a, 'hir> IdRangeComputingVisitor<'a, 'hir> {\n+    pub fn new(map: &'a map::Map<'hir>) -> IdRangeComputingVisitor<'a, 'hir> {\n         IdRangeComputingVisitor { result: IdRange::max(), map: map }\n     }\n \n@@ -1100,8 +1100,8 @@ impl<'a, 'ast> IdRangeComputingVisitor<'a, 'ast> {\n     }\n }\n \n-impl<'a, 'ast> Visitor<'ast> for IdRangeComputingVisitor<'a, 'ast> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'ast> {\n+impl<'a, 'hir> Visitor<'hir> for IdRangeComputingVisitor<'a, 'hir> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'hir> {\n         NestedVisitorMap::OnlyBodies(&self.map)\n     }\n "}, {"sha": "904f74b8787fd5d6a633491937ab97df93345bd2", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8", "patch": "@@ -16,17 +16,17 @@ use syntax::ast::{NodeId, CRATE_NODE_ID};\n use syntax_pos::Span;\n \n /// A Visitor that walks over the HIR and collects Nodes into a HIR map\n-pub struct NodeCollector<'ast> {\n+pub struct NodeCollector<'hir> {\n     /// The crate\n-    pub krate: &'ast Crate,\n+    pub krate: &'hir Crate,\n     /// The node map\n-    pub(super) map: Vec<MapEntry<'ast>>,\n+    pub(super) map: Vec<MapEntry<'hir>>,\n     /// The parent of this node\n     pub parent_node: NodeId,\n }\n \n-impl<'ast> NodeCollector<'ast> {\n-    pub fn root(krate: &'ast Crate) -> NodeCollector<'ast> {\n+impl<'hir> NodeCollector<'hir> {\n+    pub fn root(krate: &'hir Crate) -> NodeCollector<'hir> {\n         let mut collector = NodeCollector {\n             krate: krate,\n             map: vec![],\n@@ -37,16 +37,16 @@ impl<'ast> NodeCollector<'ast> {\n         collector\n     }\n \n-    fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'ast>) {\n-        debug!(\"ast_map: {:?} => {:?}\", id, entry);\n+    fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'hir>) {\n+        debug!(\"hir_map: {:?} => {:?}\", id, entry);\n         let len = self.map.len();\n         if id.as_usize() >= len {\n             self.map.extend(repeat(NotPresent).take(id.as_usize() - len + 1));\n         }\n         self.map[id.as_usize()] = entry;\n     }\n \n-    fn insert(&mut self, id: NodeId, node: Node<'ast>) {\n+    fn insert(&mut self, id: NodeId, node: Node<'hir>) {\n         let entry = MapEntry::from_node(self.parent_node, node);\n         self.insert_entry(id, entry);\n     }\n@@ -59,12 +59,12 @@ impl<'ast> NodeCollector<'ast> {\n     }\n }\n \n-impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n+impl<'hir> Visitor<'hir> for NodeCollector<'hir> {\n     /// Because we want to track parent items and so forth, enable\n     /// deep walking so that we walk nested items in the context of\n     /// their outer items.\n \n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'ast> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'hir> {\n         panic!(\"visit_nested_xxx must be manually implemented in this visitor\")\n     }\n \n@@ -85,7 +85,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         self.visit_body(self.krate.body(id));\n     }\n \n-    fn visit_item(&mut self, i: &'ast Item) {\n+    fn visit_item(&mut self, i: &'hir Item) {\n         debug!(\"visit_item: {:?}\", i);\n \n         self.insert(i.id, NodeItem(i));\n@@ -104,39 +104,39 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         });\n     }\n \n-    fn visit_foreign_item(&mut self, foreign_item: &'ast ForeignItem) {\n+    fn visit_foreign_item(&mut self, foreign_item: &'hir ForeignItem) {\n         self.insert(foreign_item.id, NodeForeignItem(foreign_item));\n \n         self.with_parent(foreign_item.id, |this| {\n             intravisit::walk_foreign_item(this, foreign_item);\n         });\n     }\n \n-    fn visit_generics(&mut self, generics: &'ast Generics) {\n+    fn visit_generics(&mut self, generics: &'hir Generics) {\n         for ty_param in generics.ty_params.iter() {\n             self.insert(ty_param.id, NodeTyParam(ty_param));\n         }\n \n         intravisit::walk_generics(self, generics);\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'ast TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'hir TraitItem) {\n         self.insert(ti.id, NodeTraitItem(ti));\n \n         self.with_parent(ti.id, |this| {\n             intravisit::walk_trait_item(this, ti);\n         });\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'ast ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'hir ImplItem) {\n         self.insert(ii.id, NodeImplItem(ii));\n \n         self.with_parent(ii.id, |this| {\n             intravisit::walk_impl_item(this, ii);\n         });\n     }\n \n-    fn visit_pat(&mut self, pat: &'ast Pat) {\n+    fn visit_pat(&mut self, pat: &'hir Pat) {\n         let node = if let PatKind::Binding(..) = pat.node {\n             NodeLocal(pat)\n         } else {\n@@ -149,15 +149,15 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         });\n     }\n \n-    fn visit_expr(&mut self, expr: &'ast Expr) {\n+    fn visit_expr(&mut self, expr: &'hir Expr) {\n         self.insert(expr.id, NodeExpr(expr));\n \n         self.with_parent(expr.id, |this| {\n             intravisit::walk_expr(this, expr);\n         });\n     }\n \n-    fn visit_stmt(&mut self, stmt: &'ast Stmt) {\n+    fn visit_stmt(&mut self, stmt: &'hir Stmt) {\n         let id = stmt.node.id();\n         self.insert(id, NodeStmt(stmt));\n \n@@ -166,40 +166,40 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         });\n     }\n \n-    fn visit_ty(&mut self, ty: &'ast Ty) {\n+    fn visit_ty(&mut self, ty: &'hir Ty) {\n         self.insert(ty.id, NodeTy(ty));\n \n         self.with_parent(ty.id, |this| {\n             intravisit::walk_ty(this, ty);\n         });\n     }\n \n-    fn visit_trait_ref(&mut self, tr: &'ast TraitRef) {\n+    fn visit_trait_ref(&mut self, tr: &'hir TraitRef) {\n         self.insert(tr.ref_id, NodeTraitRef(tr));\n \n         self.with_parent(tr.ref_id, |this| {\n             intravisit::walk_trait_ref(this, tr);\n         });\n     }\n \n-    fn visit_fn(&mut self, fk: intravisit::FnKind<'ast>, fd: &'ast FnDecl,\n+    fn visit_fn(&mut self, fk: intravisit::FnKind<'hir>, fd: &'hir FnDecl,\n                 b: BodyId, s: Span, id: NodeId) {\n         assert_eq!(self.parent_node, id);\n         intravisit::walk_fn(self, fk, fd, b, s, id);\n     }\n \n-    fn visit_block(&mut self, block: &'ast Block) {\n+    fn visit_block(&mut self, block: &'hir Block) {\n         self.insert(block.id, NodeBlock(block));\n         self.with_parent(block.id, |this| {\n             intravisit::walk_block(this, block);\n         });\n     }\n \n-    fn visit_lifetime(&mut self, lifetime: &'ast Lifetime) {\n+    fn visit_lifetime(&mut self, lifetime: &'hir Lifetime) {\n         self.insert(lifetime.id, NodeLifetime(lifetime));\n     }\n \n-    fn visit_vis(&mut self, visibility: &'ast Visibility) {\n+    fn visit_vis(&mut self, visibility: &'hir Visibility) {\n         match *visibility {\n             Visibility::Public |\n             Visibility::Crate |\n@@ -213,19 +213,19 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         }\n     }\n \n-    fn visit_macro_def(&mut self, macro_def: &'ast MacroDef) {\n+    fn visit_macro_def(&mut self, macro_def: &'hir MacroDef) {\n         self.insert_entry(macro_def.id, NotPresent);\n     }\n \n-    fn visit_variant(&mut self, v: &'ast Variant, g: &'ast Generics, item_id: NodeId) {\n+    fn visit_variant(&mut self, v: &'hir Variant, g: &'hir Generics, item_id: NodeId) {\n         let id = v.node.data.id();\n         self.insert(id, NodeVariant(v));\n         self.with_parent(id, |this| {\n             intravisit::walk_variant(this, v, g, item_id);\n         });\n     }\n \n-    fn visit_struct_field(&mut self, field: &'ast StructField) {\n+    fn visit_struct_field(&mut self, field: &'hir StructField) {\n         self.insert(field.id, NodeField(field));\n         self.with_parent(field.id, |this| {\n             intravisit::walk_struct_field(this, field);"}, {"sha": "9f31b5b456b9f27c7446d88fc636cd240b96610a", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 76, "deletions": 76, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8", "patch": "@@ -38,67 +38,67 @@ mod def_collector;\n pub mod definitions;\n \n #[derive(Copy, Clone, Debug)]\n-pub enum Node<'ast> {\n-    NodeItem(&'ast Item),\n-    NodeForeignItem(&'ast ForeignItem),\n-    NodeTraitItem(&'ast TraitItem),\n-    NodeImplItem(&'ast ImplItem),\n-    NodeVariant(&'ast Variant),\n-    NodeField(&'ast StructField),\n-    NodeExpr(&'ast Expr),\n-    NodeStmt(&'ast Stmt),\n-    NodeTy(&'ast Ty),\n-    NodeTraitRef(&'ast TraitRef),\n-    NodeLocal(&'ast Pat),\n-    NodePat(&'ast Pat),\n-    NodeBlock(&'ast Block),\n+pub enum Node<'hir> {\n+    NodeItem(&'hir Item),\n+    NodeForeignItem(&'hir ForeignItem),\n+    NodeTraitItem(&'hir TraitItem),\n+    NodeImplItem(&'hir ImplItem),\n+    NodeVariant(&'hir Variant),\n+    NodeField(&'hir StructField),\n+    NodeExpr(&'hir Expr),\n+    NodeStmt(&'hir Stmt),\n+    NodeTy(&'hir Ty),\n+    NodeTraitRef(&'hir TraitRef),\n+    NodeLocal(&'hir Pat),\n+    NodePat(&'hir Pat),\n+    NodeBlock(&'hir Block),\n \n     /// NodeStructCtor represents a tuple struct.\n-    NodeStructCtor(&'ast VariantData),\n+    NodeStructCtor(&'hir VariantData),\n \n-    NodeLifetime(&'ast Lifetime),\n-    NodeTyParam(&'ast TyParam),\n-    NodeVisibility(&'ast Visibility),\n+    NodeLifetime(&'hir Lifetime),\n+    NodeTyParam(&'hir TyParam),\n+    NodeVisibility(&'hir Visibility),\n }\n \n /// Represents an entry and its parent NodeID.\n /// The odd layout is to bring down the total size.\n #[derive(Copy, Debug)]\n-enum MapEntry<'ast> {\n+enum MapEntry<'hir> {\n     /// Placeholder for holes in the map.\n     NotPresent,\n \n     /// All the node types, with a parent ID.\n-    EntryItem(NodeId, &'ast Item),\n-    EntryForeignItem(NodeId, &'ast ForeignItem),\n-    EntryTraitItem(NodeId, &'ast TraitItem),\n-    EntryImplItem(NodeId, &'ast ImplItem),\n-    EntryVariant(NodeId, &'ast Variant),\n-    EntryField(NodeId, &'ast StructField),\n-    EntryExpr(NodeId, &'ast Expr),\n-    EntryStmt(NodeId, &'ast Stmt),\n-    EntryTy(NodeId, &'ast Ty),\n-    EntryTraitRef(NodeId, &'ast TraitRef),\n-    EntryLocal(NodeId, &'ast Pat),\n-    EntryPat(NodeId, &'ast Pat),\n-    EntryBlock(NodeId, &'ast Block),\n-    EntryStructCtor(NodeId, &'ast VariantData),\n-    EntryLifetime(NodeId, &'ast Lifetime),\n-    EntryTyParam(NodeId, &'ast TyParam),\n-    EntryVisibility(NodeId, &'ast Visibility),\n+    EntryItem(NodeId, &'hir Item),\n+    EntryForeignItem(NodeId, &'hir ForeignItem),\n+    EntryTraitItem(NodeId, &'hir TraitItem),\n+    EntryImplItem(NodeId, &'hir ImplItem),\n+    EntryVariant(NodeId, &'hir Variant),\n+    EntryField(NodeId, &'hir StructField),\n+    EntryExpr(NodeId, &'hir Expr),\n+    EntryStmt(NodeId, &'hir Stmt),\n+    EntryTy(NodeId, &'hir Ty),\n+    EntryTraitRef(NodeId, &'hir TraitRef),\n+    EntryLocal(NodeId, &'hir Pat),\n+    EntryPat(NodeId, &'hir Pat),\n+    EntryBlock(NodeId, &'hir Block),\n+    EntryStructCtor(NodeId, &'hir VariantData),\n+    EntryLifetime(NodeId, &'hir Lifetime),\n+    EntryTyParam(NodeId, &'hir TyParam),\n+    EntryVisibility(NodeId, &'hir Visibility),\n \n     /// Roots for node trees.\n     RootCrate,\n }\n \n-impl<'ast> Clone for MapEntry<'ast> {\n-    fn clone(&self) -> MapEntry<'ast> {\n+impl<'hir> Clone for MapEntry<'hir> {\n+    fn clone(&self) -> MapEntry<'hir> {\n         *self\n     }\n }\n \n-impl<'ast> MapEntry<'ast> {\n-    fn from_node(p: NodeId, node: Node<'ast>) -> MapEntry<'ast> {\n+impl<'hir> MapEntry<'hir> {\n+    fn from_node(p: NodeId, node: Node<'hir>) -> MapEntry<'hir> {\n         match node {\n             NodeItem(n) => EntryItem(p, n),\n             NodeForeignItem(n) => EntryForeignItem(p, n),\n@@ -145,7 +145,7 @@ impl<'ast> MapEntry<'ast> {\n         })\n     }\n \n-    fn to_node(self) -> Option<Node<'ast>> {\n+    fn to_node(self) -> Option<Node<'hir>> {\n         Some(match self {\n             EntryItem(_, n) => NodeItem(n),\n             EntryForeignItem(_, n) => NodeForeignItem(n),\n@@ -225,7 +225,7 @@ impl Forest {\n         }\n     }\n \n-    pub fn krate<'ast>(&'ast self) -> &'ast Crate {\n+    pub fn krate<'hir>(&'hir self) -> &'hir Crate {\n         self.dep_graph.read(DepNode::Krate);\n         &self.krate\n     }\n@@ -234,9 +234,9 @@ impl Forest {\n /// Represents a mapping from Node IDs to AST elements and their parent\n /// Node IDs\n #[derive(Clone)]\n-pub struct Map<'ast> {\n+pub struct Map<'hir> {\n     /// The backing storage for all the AST nodes.\n-    pub forest: &'ast Forest,\n+    pub forest: &'hir Forest,\n \n     /// Same as the dep_graph in forest, just available with one fewer\n     /// deref. This is a gratuitious micro-optimization.\n@@ -251,15 +251,15 @@ pub struct Map<'ast> {\n     ///\n     /// Also, indexing is pretty quick when you've got a vector and\n     /// plain old integers.\n-    map: Vec<MapEntry<'ast>>,\n+    map: Vec<MapEntry<'hir>>,\n \n     definitions: Definitions,\n \n     /// Bodies inlined from other crates are cached here.\n-    inlined_bodies: RefCell<DefIdMap<&'ast Body>>,\n+    inlined_bodies: RefCell<DefIdMap<&'hir Body>>,\n }\n \n-impl<'ast> Map<'ast> {\n+impl<'hir> Map<'hir> {\n     /// Registers a read in the dependency graph of the AST node with\n     /// the given `id`. This needs to be called each time a public\n     /// function returns the HIR for a node -- in other words, when it\n@@ -388,31 +388,31 @@ impl<'ast> Map<'ast> {\n         self.map.len()\n     }\n \n-    fn find_entry(&self, id: NodeId) -> Option<MapEntry<'ast>> {\n+    fn find_entry(&self, id: NodeId) -> Option<MapEntry<'hir>> {\n         self.map.get(id.as_usize()).cloned()\n     }\n \n-    pub fn krate(&self) -> &'ast Crate {\n+    pub fn krate(&self) -> &'hir Crate {\n         self.forest.krate()\n     }\n \n-    pub fn trait_item(&self, id: TraitItemId) -> &'ast TraitItem {\n+    pub fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem {\n         self.read(id.node_id);\n \n         // NB: intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n         self.forest.krate.trait_item(id)\n     }\n \n-    pub fn impl_item(&self, id: ImplItemId) -> &'ast ImplItem {\n+    pub fn impl_item(&self, id: ImplItemId) -> &'hir ImplItem {\n         self.read(id.node_id);\n \n         // NB: intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n         self.forest.krate.impl_item(id)\n     }\n \n-    pub fn body(&self, id: BodyId) -> &'ast Body {\n+    pub fn body(&self, id: BodyId) -> &'hir Body {\n         self.read(id.node_id);\n \n         // NB: intentionally bypass `self.forest.krate()` so that we\n@@ -440,28 +440,28 @@ impl<'ast> Map<'ast> {\n     /// Get the attributes on the krate. This is preferable to\n     /// invoking `krate.attrs` because it registers a tighter\n     /// dep-graph access.\n-    pub fn krate_attrs(&self) -> &'ast [ast::Attribute] {\n+    pub fn krate_attrs(&self) -> &'hir [ast::Attribute] {\n         let crate_root_def_id = DefId::local(CRATE_DEF_INDEX);\n         self.dep_graph.read(DepNode::Hir(crate_root_def_id));\n         &self.forest.krate.attrs\n     }\n \n     /// Retrieve the Node corresponding to `id`, panicking if it cannot\n     /// be found.\n-    pub fn get(&self, id: NodeId) -> Node<'ast> {\n+    pub fn get(&self, id: NodeId) -> Node<'hir> {\n         match self.find(id) {\n             Some(node) => node, // read recorded by `find`\n             None => bug!(\"couldn't find node id {} in the AST map\", id)\n         }\n     }\n \n-    pub fn get_if_local(&self, id: DefId) -> Option<Node<'ast>> {\n+    pub fn get_if_local(&self, id: DefId) -> Option<Node<'hir>> {\n         self.as_local_node_id(id).map(|id| self.get(id)) // read recorded by `get`\n     }\n \n     /// Retrieve the Node corresponding to `id`, returning None if\n     /// cannot be found.\n-    pub fn find(&self, id: NodeId) -> Option<Node<'ast>> {\n+    pub fn find(&self, id: NodeId) -> Option<Node<'hir>> {\n         let result = self.find_entry(id).and_then(|x| x.to_node());\n         if result.is_some() {\n             self.read(id);\n@@ -508,7 +508,7 @@ impl<'ast> Map<'ast> {\n     /// is not an error, since items in the crate module have the crate root as\n     /// parent.\n     fn walk_parent_nodes<F>(&self, start_id: NodeId, found: F) -> Result<NodeId, NodeId>\n-        where F: Fn(&Node<'ast>) -> bool\n+        where F: Fn(&Node<'hir>) -> bool\n     {\n         let mut id = start_id;\n         loop {\n@@ -611,28 +611,28 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    pub fn expect_item(&self, id: NodeId) -> &'ast Item {\n+    pub fn expect_item(&self, id: NodeId) -> &'hir Item {\n         match self.find(id) { // read recorded by `find`\n             Some(NodeItem(item)) => item,\n             _ => bug!(\"expected item, found {}\", self.node_to_string(id))\n         }\n     }\n \n-    pub fn expect_impl_item(&self, id: NodeId) -> &'ast ImplItem {\n+    pub fn expect_impl_item(&self, id: NodeId) -> &'hir ImplItem {\n         match self.find(id) {\n             Some(NodeImplItem(item)) => item,\n             _ => bug!(\"expected impl item, found {}\", self.node_to_string(id))\n         }\n     }\n \n-    pub fn expect_trait_item(&self, id: NodeId) -> &'ast TraitItem {\n+    pub fn expect_trait_item(&self, id: NodeId) -> &'hir TraitItem {\n         match self.find(id) {\n             Some(NodeTraitItem(item)) => item,\n             _ => bug!(\"expected trait item, found {}\", self.node_to_string(id))\n         }\n     }\n \n-    pub fn expect_variant_data(&self, id: NodeId) -> &'ast VariantData {\n+    pub fn expect_variant_data(&self, id: NodeId) -> &'hir VariantData {\n         match self.find(id) {\n             Some(NodeItem(i)) => {\n                 match i.node {\n@@ -653,35 +653,35 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    pub fn expect_variant(&self, id: NodeId) -> &'ast Variant {\n+    pub fn expect_variant(&self, id: NodeId) -> &'hir Variant {\n         match self.find(id) {\n             Some(NodeVariant(variant)) => variant,\n             _ => bug!(\"expected variant, found {}\", self.node_to_string(id)),\n         }\n     }\n \n-    pub fn expect_foreign_item(&self, id: NodeId) -> &'ast ForeignItem {\n+    pub fn expect_foreign_item(&self, id: NodeId) -> &'hir ForeignItem {\n         match self.find(id) {\n             Some(NodeForeignItem(item)) => item,\n             _ => bug!(\"expected foreign item, found {}\", self.node_to_string(id))\n         }\n     }\n \n-    pub fn expect_expr(&self, id: NodeId) -> &'ast Expr {\n+    pub fn expect_expr(&self, id: NodeId) -> &'hir Expr {\n         match self.find(id) { // read recorded by find\n             Some(NodeExpr(expr)) => expr,\n             _ => bug!(\"expected expr, found {}\", self.node_to_string(id))\n         }\n     }\n \n-    pub fn get_inlined_body(&self, def_id: DefId) -> Option<&'ast Body> {\n+    pub fn get_inlined_body(&self, def_id: DefId) -> Option<&'hir Body> {\n         self.inlined_bodies.borrow().get(&def_id).map(|&body| {\n             self.dep_graph.read(DepNode::MetaData(def_id));\n             body\n         })\n     }\n \n-    pub fn intern_inlined_body(&self, def_id: DefId, body: Body) -> &'ast Body {\n+    pub fn intern_inlined_body(&self, def_id: DefId, body: Body) -> &'hir Body {\n         let body = self.forest.inlined_bodies.alloc(body);\n         self.inlined_bodies.borrow_mut().insert(def_id, body);\n         body\n@@ -706,7 +706,7 @@ impl<'ast> Map<'ast> {\n \n     /// Given a node ID, get a list of attributes associated with the AST\n     /// corresponding to the Node ID\n-    pub fn attrs(&self, id: NodeId) -> &'ast [ast::Attribute] {\n+    pub fn attrs(&self, id: NodeId) -> &'hir [ast::Attribute] {\n         self.read(id); // reveals attributes on the node\n         let attrs = match self.find(id) {\n             Some(NodeItem(i)) => Some(&i.attrs[..]),\n@@ -735,7 +735,7 @@ impl<'ast> Map<'ast> {\n     /// such as `foo::bar::quux`, `bar::quux`, `other::bar::quux`, and\n     /// any other such items it can find in the map.\n     pub fn nodes_matching_suffix<'a>(&'a self, parts: &'a [String])\n-                                 -> NodesMatchingSuffix<'a, 'ast> {\n+                                 -> NodesMatchingSuffix<'a, 'hir> {\n         NodesMatchingSuffix {\n             map: self,\n             item_name: parts.last().unwrap(),\n@@ -790,14 +790,14 @@ impl<'ast> Map<'ast> {\n     }\n }\n \n-pub struct NodesMatchingSuffix<'a, 'ast:'a> {\n-    map: &'a Map<'ast>,\n+pub struct NodesMatchingSuffix<'a, 'hir:'a> {\n+    map: &'a Map<'hir>,\n     item_name: &'a String,\n     in_which: &'a [String],\n     idx: NodeId,\n }\n \n-impl<'a, 'ast> NodesMatchingSuffix<'a, 'ast> {\n+impl<'a, 'hir> NodesMatchingSuffix<'a, 'hir> {\n     /// Returns true only if some suffix of the module path for parent\n     /// matches `self.in_which`.\n     ///\n@@ -853,7 +853,7 @@ impl<'a, 'ast> NodesMatchingSuffix<'a, 'ast> {\n     }\n }\n \n-impl<'a, 'ast> Iterator for NodesMatchingSuffix<'a, 'ast> {\n+impl<'a, 'hir> Iterator for NodesMatchingSuffix<'a, 'hir> {\n     type Item = NodeId;\n \n     fn next(&mut self) -> Option<NodeId> {\n@@ -892,9 +892,9 @@ impl Named for StructField { fn name(&self) -> Name { self.name } }\n impl Named for TraitItem { fn name(&self) -> Name { self.name } }\n impl Named for ImplItem { fn name(&self) -> Name { self.name } }\n \n-pub fn map_crate<'ast>(forest: &'ast mut Forest,\n+pub fn map_crate<'hir>(forest: &'hir mut Forest,\n                        definitions: Definitions)\n-                       -> Map<'ast> {\n+                       -> Map<'hir> {\n     let mut collector = NodeCollector::root(&forest.krate);\n     intravisit::walk_crate(&mut collector, &forest.krate);\n     let map = collector.map;\n@@ -926,7 +926,7 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest,\n \n /// Identical to the `PpAnn` implementation for `hir::Crate`,\n /// except it avoids creating a dependency on the whole crate.\n-impl<'ast> print::PpAnn for Map<'ast> {\n+impl<'hir> print::PpAnn for Map<'hir> {\n     fn nested(&self, state: &mut print::State, nested: print::Nested) -> io::Result<()> {\n         match nested {\n             Nested::Item(id) => state.print_item(self.expect_item(id.id)),\n@@ -966,7 +966,7 @@ impl<'a> print::State<'a> {\n             NodeTyParam(_)     => bug!(\"cannot print TyParam\"),\n             NodeField(_)       => bug!(\"cannot print StructField\"),\n             // these cases do not carry enough information in the\n-            // ast_map to reconstruct their full structure for pretty\n+            // hir_map to reconstruct their full structure for pretty\n             // printing.\n             NodeStructCtor(_)  => bug!(\"cannot print isolated StructCtor\"),\n         }"}, {"sha": "73b5fda275819dee9c931f360b17c8ad68fa920f", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8", "patch": "@@ -73,7 +73,7 @@ use super::region_inference::SameRegions;\n \n use std::collections::HashSet;\n \n-use hir::map as ast_map;\n+use hir::map as hir_map;\n use hir;\n \n use lint;\n@@ -152,8 +152,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 };\n                 let tag = match self.hir.find(scope.node_id(&self.region_maps)) {\n-                    Some(ast_map::NodeBlock(_)) => \"block\",\n-                    Some(ast_map::NodeExpr(expr)) => match expr.node {\n+                    Some(hir_map::NodeBlock(_)) => \"block\",\n+                    Some(hir_map::NodeExpr(expr)) => match expr.node {\n                         hir::ExprCall(..) => \"call\",\n                         hir::ExprMethodCall(..) => \"method call\",\n                         hir::ExprMatch(.., hir::MatchSource::IfLetDesugar { .. }) => \"if let\",\n@@ -162,10 +162,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         hir::ExprMatch(..) => \"match\",\n                         _ => \"expression\",\n                     },\n-                    Some(ast_map::NodeStmt(_)) => \"statement\",\n-                    Some(ast_map::NodeItem(it)) => item_scope_tag(&it),\n-                    Some(ast_map::NodeTraitItem(it)) => trait_item_scope_tag(&it),\n-                    Some(ast_map::NodeImplItem(it)) => impl_item_scope_tag(&it),\n+                    Some(hir_map::NodeStmt(_)) => \"statement\",\n+                    Some(hir_map::NodeItem(it)) => item_scope_tag(&it),\n+                    Some(hir_map::NodeTraitItem(it)) => trait_item_scope_tag(&it),\n+                    Some(hir_map::NodeImplItem(it)) => impl_item_scope_tag(&it),\n                     Some(_) | None => {\n                         err.span_note(span, &unknown_scope());\n                         return;\n@@ -207,11 +207,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 let node = fr.scope.node_id(&self.region_maps);\n                 let unknown;\n                 let tag = match self.hir.find(node) {\n-                    Some(ast_map::NodeBlock(_)) |\n-                    Some(ast_map::NodeExpr(_)) => \"body\",\n-                    Some(ast_map::NodeItem(it)) => item_scope_tag(&it),\n-                    Some(ast_map::NodeTraitItem(it)) => trait_item_scope_tag(&it),\n-                    Some(ast_map::NodeImplItem(it)) => impl_item_scope_tag(&it),\n+                    Some(hir_map::NodeBlock(_)) |\n+                    Some(hir_map::NodeExpr(_)) => \"body\",\n+                    Some(hir_map::NodeItem(it)) => item_scope_tag(&it),\n+                    Some(hir_map::NodeTraitItem(it)) => trait_item_scope_tag(&it),\n+                    Some(hir_map::NodeImplItem(it)) => impl_item_scope_tag(&it),\n \n                     // this really should not happen, but it does:\n                     // FIXME(#27942)\n@@ -471,14 +471,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             let parent_node = tcx.hir.find(parent);\n             match parent_node {\n                 Some(node) => match node {\n-                    ast_map::NodeItem(item) => match item.node {\n+                    hir_map::NodeItem(item) => match item.node {\n                         hir::ItemFn(..) => {\n                             Some(FreeRegionsFromSameFn::new(fr1, fr2, scope_id))\n                         },\n                         _ => None\n                     },\n-                    ast_map::NodeImplItem(..) |\n-                    ast_map::NodeTraitItem(..) => {\n+                    hir_map::NodeImplItem(..) |\n+                    hir_map::NodeTraitItem(..) => {\n                         Some(FreeRegionsFromSameFn::new(fr1, fr2, scope_id))\n                     },\n                     _ => None\n@@ -1074,17 +1074,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let life_giver = LifeGiver::with_taken(&taken[..]);\n         let node_inner = match parent_node {\n             Some(ref node) => match *node {\n-                ast_map::NodeItem(ref item) => {\n+                hir_map::NodeItem(ref item) => {\n                     match item.node {\n                         hir::ItemFn(ref fn_decl, unsafety, constness, _, ref gen, body) => {\n                             Some((fn_decl, gen, unsafety, constness, item.name, item.span, body))\n                         }\n                         _ => None,\n                     }\n                 }\n-                ast_map::NodeImplItem(item) => {\n+                hir_map::NodeImplItem(item) => {\n                     let id = self.tcx.hir.get_parent(item.id);\n-                    if let Some(ast_map::NodeItem(parent_scope)) = self.tcx.hir.find(id) {\n+                    if let Some(hir_map::NodeItem(parent_scope)) = self.tcx.hir.find(id) {\n                         if let hir::ItemImpl(_, _, _, None, _, _) = parent_scope.node {\n                             // this impl scope implements a trait, do not recomend\n                             // using explicit lifetimes (#37363)\n@@ -1103,7 +1103,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         None\n                     }\n                 },\n-                ast_map::NodeTraitItem(item) => {\n+                hir_map::NodeTraitItem(item) => {\n                     match item.node {\n                         hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Provided(body)) => {\n                             Some((&sig.decl,\n@@ -1894,14 +1894,14 @@ fn lifetimes_in_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     let parent = tcx.hir.get_parent(scope_id);\n     let method_id_opt = match tcx.hir.find(parent) {\n         Some(node) => match node {\n-            ast_map::NodeItem(item) => match item.node {\n+            hir_map::NodeItem(item) => match item.node {\n                 hir::ItemFn(.., ref gen, _) => {\n                     taken.extend_from_slice(&gen.lifetimes);\n                     None\n                 },\n                 _ => None\n             },\n-            ast_map::NodeImplItem(ii) => {\n+            hir_map::NodeImplItem(ii) => {\n                 match ii.node {\n                     hir::ImplItemKind::Method(ref sig, _) => {\n                         taken.extend_from_slice(&sig.generics.lifetimes);\n@@ -1918,7 +1918,7 @@ fn lifetimes_in_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         let parent = tcx.hir.get_parent(method_id);\n         if let Some(node) = tcx.hir.find(parent) {\n             match node {\n-                ast_map::NodeItem(item) => match item.node {\n+                hir_map::NodeItem(item) => match item.node {\n                     hir::ItemImpl(_, _, ref gen, ..) => {\n                         taken.extend_from_slice(&gen.lifetimes);\n                     }"}, {"sha": "ae349667f9dc67826d36c80692865dc46a187836", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8", "patch": "@@ -13,7 +13,7 @@\n // from live codes are live, and everything else is dead.\n \n use dep_graph::DepNode;\n-use hir::map as ast_map;\n+use hir::map as hir_map;\n use hir::{self, PatKind};\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::itemlikevisit::ItemLikeVisitor;\n@@ -36,10 +36,10 @@ use syntax_pos;\n fn should_explore<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             node_id: ast::NodeId) -> bool {\n     match tcx.hir.find(node_id) {\n-        Some(ast_map::NodeItem(..)) |\n-        Some(ast_map::NodeImplItem(..)) |\n-        Some(ast_map::NodeForeignItem(..)) |\n-        Some(ast_map::NodeTraitItem(..)) =>\n+        Some(hir_map::NodeItem(..)) |\n+        Some(hir_map::NodeImplItem(..)) |\n+        Some(hir_map::NodeForeignItem(..)) |\n+        Some(hir_map::NodeTraitItem(..)) =>\n             true,\n         _ =>\n             false\n@@ -150,13 +150,13 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_node(&mut self, node: &ast_map::Node<'tcx>) {\n+    fn visit_node(&mut self, node: &hir_map::Node<'tcx>) {\n         let had_extern_repr = self.struct_has_extern_repr;\n         self.struct_has_extern_repr = false;\n         let had_inherited_pub_visibility = self.inherited_pub_visibility;\n         self.inherited_pub_visibility = false;\n         match *node {\n-            ast_map::NodeItem(item) => {\n+            hir_map::NodeItem(item) => {\n                 match item.node {\n                     hir::ItemStruct(..) | hir::ItemUnion(..) => {\n                         self.struct_has_extern_repr = item.attrs.iter().any(|attr| {\n@@ -179,13 +179,13 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                     _ => ()\n                 }\n             }\n-            ast_map::NodeTraitItem(trait_item) => {\n+            hir_map::NodeTraitItem(trait_item) => {\n                 intravisit::walk_trait_item(self, trait_item);\n             }\n-            ast_map::NodeImplItem(impl_item) => {\n+            hir_map::NodeImplItem(impl_item) => {\n                 intravisit::walk_impl_item(self, impl_item);\n             }\n-            ast_map::NodeForeignItem(foreign_item) => {\n+            hir_map::NodeForeignItem(foreign_item) => {\n                 intravisit::walk_foreign_item(self, &foreign_item);\n             }\n             _ => ()"}, {"sha": "ff7adfb327ad45308c3f5c303e079c7d0128da1e", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8", "patch": "@@ -10,7 +10,7 @@\n \n \n use dep_graph::DepNode;\n-use hir::map as ast_map;\n+use hir::map as hir_map;\n use hir::def_id::{CRATE_DEF_INDEX};\n use session::{config, Session};\n use syntax::ast::NodeId;\n@@ -23,7 +23,7 @@ use hir::itemlikevisit::ItemLikeVisitor;\n struct EntryContext<'a, 'tcx: 'a> {\n     session: &'a Session,\n \n-    map: &'a ast_map::Map<'tcx>,\n+    map: &'a hir_map::Map<'tcx>,\n \n     // The top-level function called 'main'\n     main_fn: Option<(NodeId, Span)>,\n@@ -56,8 +56,8 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for EntryContext<'a, 'tcx> {\n     }\n }\n \n-pub fn find_entry_point(session: &Session, ast_map: &ast_map::Map) {\n-    let _task = ast_map.dep_graph.in_task(DepNode::EntryPoint);\n+pub fn find_entry_point(session: &Session, hir_map: &hir_map::Map) {\n+    let _task = hir_map.dep_graph.in_task(DepNode::EntryPoint);\n \n     let any_exe = session.crate_types.borrow().iter().any(|ty| {\n         *ty == config::CrateTypeExecutable\n@@ -68,21 +68,21 @@ pub fn find_entry_point(session: &Session, ast_map: &ast_map::Map) {\n     }\n \n     // If the user wants no main function at all, then stop here.\n-    if attr::contains_name(&ast_map.krate().attrs, \"no_main\") {\n+    if attr::contains_name(&hir_map.krate().attrs, \"no_main\") {\n         session.entry_type.set(Some(config::EntryNone));\n         return\n     }\n \n     let mut ctxt = EntryContext {\n         session: session,\n-        map: ast_map,\n+        map: hir_map,\n         main_fn: None,\n         attr_main_fn: None,\n         start_fn: None,\n         non_main_fns: Vec::new(),\n     };\n \n-    ast_map.krate().visit_all_item_likes(&mut ctxt);\n+    hir_map.krate().visit_all_item_likes(&mut ctxt);\n \n     configure_main(&mut ctxt);\n }"}, {"sha": "b9f1611f62bafd2344a8291bd02c820949f0de51", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8", "patch": "@@ -117,7 +117,7 @@ impl LanguageItems {\n struct LanguageItemCollector<'a, 'tcx: 'a> {\n     items: LanguageItems,\n \n-    ast_map: &'a hir_map::Map<'tcx>,\n+    hir_map: &'a hir_map::Map<'tcx>,\n \n     session: &'a Session,\n \n@@ -130,9 +130,9 @@ impl<'a, 'v, 'tcx> ItemLikeVisitor<'v> for LanguageItemCollector<'a, 'tcx> {\n             let item_index = self.item_refs.get(&*value.as_str()).cloned();\n \n             if let Some(item_index) = item_index {\n-                self.collect_item(item_index, self.ast_map.local_def_id(item.id))\n+                self.collect_item(item_index, self.hir_map.local_def_id(item.id))\n             } else {\n-                let span = self.ast_map.span(item.id);\n+                let span = self.hir_map.span(item.id);\n                 span_err!(self.session, span, E0522,\n                           \"definition of an unknown language item: `{}`.\",\n                           value);\n@@ -150,15 +150,15 @@ impl<'a, 'v, 'tcx> ItemLikeVisitor<'v> for LanguageItemCollector<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n-    pub fn new(session: &'a Session, ast_map: &'a hir_map::Map<'tcx>)\n+    pub fn new(session: &'a Session, hir_map: &'a hir_map::Map<'tcx>)\n                -> LanguageItemCollector<'a, 'tcx> {\n         let mut item_refs = FxHashMap();\n \n         $( item_refs.insert($name, $variant as usize); )*\n \n         LanguageItemCollector {\n             session: session,\n-            ast_map: ast_map,\n+            hir_map: hir_map,\n             items: LanguageItems::new(),\n             item_refs: item_refs,\n         }\n@@ -171,7 +171,7 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n             Some(original_def_id) if original_def_id != item_def_id => {\n                 let cstore = &self.session.cstore;\n                 let name = LanguageItems::item_name(item_index);\n-                let mut err = match self.ast_map.span_if_local(item_def_id) {\n+                let mut err = match self.hir_map.span_if_local(item_def_id) {\n                     Some(span) => struct_span_err!(\n                         self.session,\n                         span,\n@@ -183,7 +183,7 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n                             cstore.crate_name(item_def_id.krate),\n                             name)),\n                 };\n-                if let Some(span) = self.ast_map.span_if_local(original_def_id) {\n+                if let Some(span) = self.hir_map.span_if_local(original_def_id) {\n                     span_note!(&mut err, span,\n                                \"first defined here.\");\n                 } else {"}, {"sha": "126d43aa6900e79b87eb24c6e15420b88121819f", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8", "patch": "@@ -71,7 +71,7 @@ pub use self::Note::*;\n use self::Aliasability::*;\n \n use hir::def_id::DefId;\n-use hir::map as ast_map;\n+use hir::map as hir_map;\n use infer::InferCtxt;\n use hir::def::{Def, CtorKind};\n use ty::adjustment;\n@@ -269,7 +269,7 @@ impl MutabilityCategory {\n \n     fn from_local(tcx: TyCtxt, id: ast::NodeId) -> MutabilityCategory {\n         let ret = match tcx.hir.get(id) {\n-            ast_map::NodeLocal(p) => match p.node {\n+            hir_map::NodeLocal(p) => match p.node {\n                 PatKind::Binding(bind_mode, ..) => {\n                     if bind_mode == hir::BindByValue(hir::MutMutable) {\n                         McDeclared\n@@ -699,7 +699,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // a free region within it\n         let fn_body_id = {\n             let fn_expr = match self.tcx().hir.find(upvar_id.closure_expr_id) {\n-                Some(ast_map::NodeExpr(e)) => e,\n+                Some(hir_map::NodeExpr(e)) => e,\n                 _ => bug!()\n             };\n "}, {"sha": "4ec43e368a60dc9036e7ca96c9675ecbd3612c2e", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8", "patch": "@@ -16,7 +16,7 @@\n // reachable as well.\n \n use dep_graph::DepNode;\n-use hir::map as ast_map;\n+use hir::map as hir_map;\n use hir::def::Def;\n use hir::def_id::DefId;\n use ty::{self, TyCtxt};\n@@ -65,7 +65,7 @@ fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n     if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_src) {\n         match tcx.hir.find(impl_node_id) {\n-            Some(ast_map::NodeItem(item)) =>\n+            Some(hir_map::NodeItem(item)) =>\n                 item_might_be_inlined(&item),\n             Some(..) | None =>\n                 span_bug!(impl_item.span, \"impl did is not an item\")\n@@ -153,21 +153,21 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         };\n \n         match self.tcx.hir.find(node_id) {\n-            Some(ast_map::NodeItem(item)) => {\n+            Some(hir_map::NodeItem(item)) => {\n                 match item.node {\n                     hir::ItemFn(..) => item_might_be_inlined(&item),\n                     _ => false,\n                 }\n             }\n-            Some(ast_map::NodeTraitItem(trait_method)) => {\n+            Some(hir_map::NodeTraitItem(trait_method)) => {\n                 match trait_method.node {\n                     hir::TraitItemKind::Const(_, ref default) => default.is_some(),\n                     hir::TraitItemKind::Method(_, hir::TraitMethod::Provided(_)) => true,\n                     hir::TraitItemKind::Method(_, hir::TraitMethod::Required(_)) |\n                     hir::TraitItemKind::Type(..) => false,\n                 }\n             }\n-            Some(ast_map::NodeImplItem(impl_item)) => {\n+            Some(hir_map::NodeImplItem(impl_item)) => {\n                 match impl_item.node {\n                     hir::ImplItemKind::Const(..) => true,\n                     hir::ImplItemKind::Method(ref sig, _) => {\n@@ -216,12 +216,12 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         }\n     }\n \n-    fn propagate_node(&mut self, node: &ast_map::Node<'tcx>,\n+    fn propagate_node(&mut self, node: &hir_map::Node<'tcx>,\n                       search_item: ast::NodeId) {\n         if !self.any_library {\n             // If we are building an executable, only explicitly extern\n             // types need to be exported.\n-            if let ast_map::NodeItem(item) = *node {\n+            if let hir_map::NodeItem(item) = *node {\n                 let reachable = if let hir::ItemFn(.., abi, _, _) = item.node {\n                     abi != Abi::Rust\n                 } else {\n@@ -242,7 +242,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         }\n \n         match *node {\n-            ast_map::NodeItem(item) => {\n+            hir_map::NodeItem(item) => {\n                 match item.node {\n                     hir::ItemFn(.., body) => {\n                         if item_might_be_inlined(&item) {\n@@ -268,7 +268,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::ItemUnion(..) | hir::ItemDefaultImpl(..) => {}\n                 }\n             }\n-            ast_map::NodeTraitItem(trait_method) => {\n+            hir_map::NodeTraitItem(trait_method) => {\n                 match trait_method.node {\n                     hir::TraitItemKind::Const(_, None) |\n                     hir::TraitItemKind::Method(_, hir::TraitMethod::Required(_)) => {\n@@ -281,7 +281,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::TraitItemKind::Type(..) => {}\n                 }\n             }\n-            ast_map::NodeImplItem(impl_item) => {\n+            hir_map::NodeImplItem(impl_item) => {\n                 match impl_item.node {\n                     hir::ImplItemKind::Const(_, body) => {\n                         self.visit_nested_body(body);\n@@ -296,11 +296,11 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 }\n             }\n             // Nothing to recurse on for these\n-            ast_map::NodeForeignItem(_) |\n-            ast_map::NodeVariant(_) |\n-            ast_map::NodeStructCtor(_) |\n-            ast_map::NodeField(_) |\n-            ast_map::NodeTy(_) => {}\n+            hir_map::NodeForeignItem(_) |\n+            hir_map::NodeVariant(_) |\n+            hir_map::NodeStructCtor(_) |\n+            hir_map::NodeField(_) |\n+            hir_map::NodeTy(_) => {}\n             _ => {\n                 bug!(\"found unexpected thingy in worklist: {}\",\n                      self.tcx.hir.node_to_string(search_item))"}, {"sha": "7337c03795b6d4a006e762027b009d80daa8c398", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8", "patch": "@@ -17,7 +17,7 @@\n //! `middle/infer/region_inference/README.md`\n \n use dep_graph::DepNode;\n-use hir::map as ast_map;\n+use hir::map as hir_map;\n use session::Session;\n use util::nodemap::{FxHashMap, NodeMap, NodeSet};\n use ty;\n@@ -217,9 +217,9 @@ impl CodeExtent {\n     /// Returns the span of this CodeExtent.  Note that in general the\n     /// returned span may not correspond to the span of any node id in\n     /// the AST.\n-    pub fn span(&self, region_maps: &RegionMaps, ast_map: &ast_map::Map) -> Option<Span> {\n-        match ast_map.find(self.node_id(region_maps)) {\n-            Some(ast_map::NodeBlock(ref blk)) => {\n+    pub fn span(&self, region_maps: &RegionMaps, hir_map: &hir_map::Map) -> Option<Span> {\n+        match hir_map.find(self.node_id(region_maps)) {\n+            Some(hir_map::NodeBlock(ref blk)) => {\n                 match region_maps.code_extent_data(*self) {\n                     CodeExtentData::CallSiteScope { .. } |\n                     CodeExtentData::ParameterScope { .. } |\n@@ -240,9 +240,9 @@ impl CodeExtent {\n                     }\n                 }\n             }\n-            Some(ast_map::NodeExpr(ref expr)) => Some(expr.span),\n-            Some(ast_map::NodeStmt(ref stmt)) => Some(stmt.span),\n-            Some(ast_map::NodeItem(ref item)) => Some(item.span),\n+            Some(hir_map::NodeExpr(ref expr)) => Some(expr.span),\n+            Some(hir_map::NodeStmt(ref stmt)) => Some(stmt.span),\n+            Some(hir_map::NodeItem(ref item)) => Some(item.span),\n             Some(_) | None => None,\n          }\n     }\n@@ -302,15 +302,15 @@ pub struct Context {\n     parent: CodeExtent\n }\n \n-struct RegionResolutionVisitor<'ast: 'a, 'a> {\n+struct RegionResolutionVisitor<'hir: 'a, 'a> {\n     sess: &'a Session,\n \n     // Generated maps:\n     region_maps: &'a RegionMaps,\n \n     cx: Context,\n \n-    map: &'a ast_map::Map<'ast>,\n+    map: &'a hir_map::Map<'hir>,\n \n     /// `terminating_scopes` is a set containing the ids of each\n     /// statement, or conditional/repeating expression. These scopes\n@@ -1137,7 +1137,7 @@ fn resolve_fn<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n     visitor.terminating_scopes = outer_ts;\n }\n \n-impl<'ast, 'a> RegionResolutionVisitor<'ast, 'a> {\n+impl<'hir, 'a> RegionResolutionVisitor<'hir, 'a> {\n     /// Records the current parent (if any) as the parent of `child_scope`.\n     fn new_code_extent(&mut self, child_scope: CodeExtentData) -> CodeExtent {\n         self.region_maps.intern_code_extent(child_scope, self.cx.parent)\n@@ -1173,49 +1173,49 @@ impl<'ast, 'a> RegionResolutionVisitor<'ast, 'a> {\n     }\n }\n \n-impl<'ast, 'a> Visitor<'ast> for RegionResolutionVisitor<'ast, 'a> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'ast> {\n+impl<'hir, 'a> Visitor<'hir> for RegionResolutionVisitor<'hir, 'a> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'hir> {\n         NestedVisitorMap::OnlyBodies(&self.map)\n     }\n \n-    fn visit_block(&mut self, b: &'ast Block) {\n+    fn visit_block(&mut self, b: &'hir Block) {\n         resolve_block(self, b);\n     }\n \n-    fn visit_item(&mut self, i: &'ast Item) {\n+    fn visit_item(&mut self, i: &'hir Item) {\n         resolve_item_like(self, i.id, |this| intravisit::walk_item(this, i));\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'ast hir::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'hir hir::ImplItem) {\n         resolve_item_like(self, ii.id, |this| intravisit::walk_impl_item(this, ii));\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'ast hir::TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'hir hir::TraitItem) {\n         resolve_item_like(self, ti.id, |this| intravisit::walk_trait_item(this, ti));\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'ast>, fd: &'ast FnDecl,\n+    fn visit_fn(&mut self, fk: FnKind<'hir>, fd: &'hir FnDecl,\n                 b: hir::BodyId, s: Span, n: NodeId) {\n         resolve_fn(self, fk, fd, b, s, n);\n     }\n-    fn visit_arm(&mut self, a: &'ast Arm) {\n+    fn visit_arm(&mut self, a: &'hir Arm) {\n         resolve_arm(self, a);\n     }\n-    fn visit_pat(&mut self, p: &'ast Pat) {\n+    fn visit_pat(&mut self, p: &'hir Pat) {\n         resolve_pat(self, p);\n     }\n-    fn visit_stmt(&mut self, s: &'ast Stmt) {\n+    fn visit_stmt(&mut self, s: &'hir Stmt) {\n         resolve_stmt(self, s);\n     }\n-    fn visit_expr(&mut self, ex: &'ast Expr) {\n+    fn visit_expr(&mut self, ex: &'hir Expr) {\n         resolve_expr(self, ex);\n     }\n-    fn visit_local(&mut self, l: &'ast Local) {\n+    fn visit_local(&mut self, l: &'hir Local) {\n         resolve_local(self, l);\n     }\n }\n \n-pub fn resolve_crate(sess: &Session, map: &ast_map::Map) -> RegionMaps {\n+pub fn resolve_crate(sess: &Session, map: &hir_map::Map) -> RegionMaps {\n     let _task = map.dep_graph.in_task(DepNode::RegionResolveCrate);\n     let krate = map.krate();\n "}, {"sha": "c78ba3b8a9bbfdec606c7e0c2597f6a2fdc62848", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8", "patch": "@@ -16,7 +16,7 @@ use middle;\n use hir::TraitMap;\n use hir::def::Def;\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n-use hir::map as ast_map;\n+use hir::map as hir_map;\n use hir::map::DisambiguatedDefPathData;\n use middle::free_region::FreeRegionMap;\n use middle::region::RegionMaps;\n@@ -428,7 +428,7 @@ pub struct GlobalCtxt<'tcx> {\n     /// additional acyclicity requirements).\n     pub super_predicates: RefCell<DepTrackingMap<maps::Predicates<'tcx>>>,\n \n-    pub hir: ast_map::Map<'tcx>,\n+    pub hir: hir_map::Map<'tcx>,\n \n     /// Maps from the def-id of a function/method or const/static\n     /// to its MIR. Mutation is done at an item granularity to\n@@ -730,7 +730,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                   arena: &'tcx DroplessArena,\n                                   resolutions: ty::Resolutions,\n                                   named_region_map: resolve_lifetime::NamedRegionMap,\n-                                  hir: ast_map::Map<'tcx>,\n+                                  hir: hir_map::Map<'tcx>,\n                                   region_maps: RegionMaps,\n                                   lang_items: middle::lang_items::LanguageItems,\n                                   stability: stability::Index<'tcx>,"}, {"sha": "5681e8c7766231c2201c591a13cc694fb73aba38", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8", "patch": "@@ -17,7 +17,7 @@ pub use self::LvaluePreference::*;\n pub use self::fold::TypeFoldable;\n \n use dep_graph::{self, DepNode};\n-use hir::{map as ast_map, FreevarMap, TraitMap};\n+use hir::{map as hir_map, FreevarMap, TraitMap};\n use middle;\n use hir::def::{Def, CtorKind, ExportMap};\n use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -1199,7 +1199,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n     pub fn for_item(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: NodeId)\n                     -> ParameterEnvironment<'tcx> {\n         match tcx.hir.find(id) {\n-            Some(ast_map::NodeImplItem(ref impl_item)) => {\n+            Some(hir_map::NodeImplItem(ref impl_item)) => {\n                 match impl_item.node {\n                     hir::ImplItemKind::Type(_) | hir::ImplItemKind::Const(..) => {\n                         // associated types don't have their own entry (for some reason),\n@@ -1218,7 +1218,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                     }\n                 }\n             }\n-            Some(ast_map::NodeTraitItem(trait_item)) => {\n+            Some(hir_map::NodeTraitItem(trait_item)) => {\n                 match trait_item.node {\n                     hir::TraitItemKind::Type(..) | hir::TraitItemKind::Const(..) => {\n                         // associated types don't have their own entry (for some reason),\n@@ -1247,7 +1247,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                     }\n                 }\n             }\n-            Some(ast_map::NodeItem(item)) => {\n+            Some(hir_map::NodeItem(item)) => {\n                 match item.node {\n                     hir::ItemFn(.., body_id) => {\n                         // We assume this is a function.\n@@ -1284,7 +1284,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                     }\n                 }\n             }\n-            Some(ast_map::NodeExpr(expr)) => {\n+            Some(hir_map::NodeExpr(expr)) => {\n                 // This is a convenience to allow closures to work.\n                 if let hir::ExprClosure(.., body, _) = expr.node {\n                     let def_id = tcx.hir.local_def_id(id);\n@@ -1297,7 +1297,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                     tcx.empty_parameter_environment()\n                 }\n             }\n-            Some(ast_map::NodeForeignItem(item)) => {\n+            Some(hir_map::NodeForeignItem(item)) => {\n                 let def_id = tcx.hir.local_def_id(id);\n                 tcx.construct_parameter_environment(item.span,\n                                                     def_id,\n@@ -1945,7 +1945,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn expr_span(self, id: NodeId) -> Span {\n         match self.hir.find(id) {\n-            Some(ast_map::NodeExpr(e)) => {\n+            Some(hir_map::NodeExpr(e)) => {\n                 e.span\n             }\n             Some(f) => {\n@@ -1959,7 +1959,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn local_var_name_str(self, id: NodeId) -> InternedString {\n         match self.hir.find(id) {\n-            Some(ast_map::NodeLocal(pat)) => {\n+            Some(hir_map::NodeLocal(pat)) => {\n                 match pat.node {\n                     hir::PatKind::Binding(_, _, ref path1, _) => path1.node.as_str(),\n                     _ => {\n@@ -2225,7 +2225,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn def_key(self, id: DefId) -> ast_map::DefKey {\n+    pub fn def_key(self, id: DefId) -> hir_map::DefKey {\n         if id.is_local() {\n             self.hir.def_key(id)\n         } else {\n@@ -2238,7 +2238,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// Note that if `id` is not local to this crate, the result will\n     //  be a non-local `DefPath`.\n-    pub fn def_path(self, id: DefId) -> ast_map::DefPath {\n+    pub fn def_path(self, id: DefId) -> hir_map::DefPath {\n         if id.is_local() {\n             self.hir.def_path(id)\n         } else {\n@@ -2266,7 +2266,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         } else {\n             let def_key = self.sess.cstore.def_key(id);\n             // The name of a StructCtor is that of its struct parent.\n-            if let ast_map::DefPathData::StructCtor = def_key.disambiguated_data.data {\n+            if let hir_map::DefPathData::StructCtor = def_key.disambiguated_data.data {\n                 self.item_name(DefId {\n                     krate: id.krate,\n                     index: def_key.parent.unwrap()"}, {"sha": "c05375c47b03a1bc6c7fbadc4d9731da842dab8e", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8", "patch": "@@ -13,7 +13,7 @@\n use hir::def_id::DefId;\n use hir::map::DefPathData;\n use infer::InferCtxt;\n-use hir::map as ast_map;\n+use hir::map as hir_map;\n use traits::{self, Reveal};\n use ty::{self, Ty, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n use ty::{Disr, ParameterEnvironment};\n@@ -429,7 +429,7 @@ impl<'a, 'gcx, 'tcx, W> TypeIdHasher<'a, 'gcx, 'tcx, W>\n         self.def_path(&path)\n     }\n \n-    pub fn def_path(&mut self, def_path: &ast_map::DefPath) {\n+    pub fn def_path(&mut self, def_path: &hir_map::DefPath) {\n         def_path.deterministic_hash_to(self.tcx, &mut self.state);\n     }\n }"}, {"sha": "2047a58f8ed85a24da6f28fd2ae7ae9d64c65d0b", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8", "patch": "@@ -490,7 +490,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n     /// Adds a new record for a match of `base_lp`, downcast to\n     /// variant `lp`, that occurs at location `pattern_id`.  (One\n     /// should be able to recover the span info from the\n-    /// `pattern_id` and the ast_map, I think.)\n+    /// `pattern_id` and the hir_map, I think.)\n     pub fn add_variant_match(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              lp: Rc<LoanPath<'tcx>>,\n                              pattern_id: ast::NodeId,"}, {"sha": "a9dcb1ed8961330a9573435ec8382fed4181bddc", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8", "patch": "@@ -15,7 +15,7 @@ use rustc::middle::const_val::ConstVal;\n use self::ErrKind::*;\n use self::EvalHint::*;\n \n-use rustc::hir::map as ast_map;\n+use rustc::hir::map as hir_map;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::traits;\n use rustc::hir::def::Def;\n@@ -55,7 +55,7 @@ fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   -> Option<(&'tcx Expr, Option<&'a ty::TypeckTables<'tcx>>)> {\n     if let Some(variant_node_id) = tcx.hir.as_local_node_id(variant_def) {\n         let enum_node_id = tcx.hir.get_parent(variant_node_id);\n-        if let Some(ast_map::NodeItem(it)) = tcx.hir.find(enum_node_id) {\n+        if let Some(hir_map::NodeItem(it)) = tcx.hir.find(enum_node_id) {\n             if let hir::ItemEnum(ref edef, _) = it.node {\n                 for variant in &edef.variants {\n                     if variant.node.data.id() == variant_node_id {\n@@ -86,17 +86,17 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n         match tcx.hir.find(node_id) {\n             None => None,\n-            Some(ast_map::NodeItem(&hir::Item {\n+            Some(hir_map::NodeItem(&hir::Item {\n                 node: hir::ItemConst(ref ty, body), ..\n             })) |\n-            Some(ast_map::NodeImplItem(&hir::ImplItem {\n+            Some(hir_map::NodeImplItem(&hir::ImplItem {\n                 node: hir::ImplItemKind::Const(ref ty, body), ..\n             })) => {\n                 Some((&tcx.hir.body(body).value,\n                       tcx.tables.borrow().get(&def_id).cloned(),\n                       tcx.ast_ty_to_prim_ty(ty)))\n             }\n-            Some(ast_map::NodeTraitItem(ti)) => match ti.node {\n+            Some(hir_map::NodeTraitItem(ti)) => match ti.node {\n                 hir::TraitItemKind::Const(ref ty, default) => {\n                     if let Some(substs) = substs {\n                         // If we have a trait item and the substitutions for it,"}, {"sha": "a7188f6da1ff9a9faee6ed93ef7bd1d1f8979e17", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8", "patch": "@@ -340,7 +340,7 @@ pub struct CompileState<'a, 'tcx: 'a> {\n     pub arenas: Option<&'tcx GlobalArenas<'tcx>>,\n     pub expanded_crate: Option<&'a ast::Crate>,\n     pub hir_crate: Option<&'a hir::Crate>,\n-    pub ast_map: Option<&'a hir_map::Map<'tcx>>,\n+    pub hir_map: Option<&'a hir_map::Map<'tcx>>,\n     pub resolutions: Option<&'a Resolutions>,\n     pub analysis: Option<&'a ty::CrateAnalysis<'tcx>>,\n     pub tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n@@ -366,7 +366,7 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n             output_filenames: None,\n             expanded_crate: None,\n             hir_crate: None,\n-            ast_map: None,\n+            hir_map: None,\n             resolutions: None,\n             analysis: None,\n             tcx: None,\n@@ -427,7 +427,7 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n             arena: Some(arena),\n             arenas: Some(arenas),\n             cstore: Some(cstore),\n-            ast_map: Some(hir_map),\n+            hir_map: Some(hir_map),\n             analysis: Some(analysis),\n             resolutions: Some(resolutions),\n             expanded_crate: Some(krate),"}, {"sha": "7fd4fa44ca45dff0ad42b8577283e3df38663cf3", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8", "patch": "@@ -454,7 +454,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                 };\n                 control.after_hir_lowering.callback = box move |state| {\n                     pretty::print_after_hir_lowering(state.session,\n-                                                     state.ast_map.unwrap(),\n+                                                     state.hir_map.unwrap(),\n                                                      state.analysis.unwrap(),\n                                                      state.resolutions.unwrap(),\n                                                      state.input,"}, {"sha": "21fe13997b787d05e5c765b065aa910c5370e9b8", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 59, "deletions": 77, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8", "patch": "@@ -167,7 +167,7 @@ impl PpSourceMode {\n     /// Constructs a `PrinterSupport` object and passes it to `f`.\n     fn call_with_pp_support<'tcx, A, B, F>(&self,\n                                            sess: &'tcx Session,\n-                                           ast_map: Option<&hir_map::Map<'tcx>>,\n+                                           hir_map: Option<&hir_map::Map<'tcx>>,\n                                            payload: B,\n                                            f: F)\n                                            -> A\n@@ -177,22 +177,21 @@ impl PpSourceMode {\n             PpmNormal | PpmEveryBodyLoops | PpmExpanded => {\n                 let annotation = NoAnn {\n                     sess: sess,\n-                    ast_map: ast_map.map(|m| m.clone()),\n+                    hir_map: hir_map.map(|m| m.clone()),\n                 };\n                 f(&annotation, payload)\n             }\n \n             PpmIdentified | PpmExpandedIdentified => {\n                 let annotation = IdentifiedAnnotation {\n                     sess: sess,\n-                    ast_map: ast_map.map(|m| m.clone()),\n+                    hir_map: hir_map.map(|m| m.clone()),\n                 };\n                 f(&annotation, payload)\n             }\n             PpmExpandedHygiene => {\n                 let annotation = HygieneAnnotation {\n                     sess: sess,\n-                    ast_map: ast_map.map(|m| m.clone()),\n                 };\n                 f(&annotation, payload)\n             }\n@@ -201,7 +200,7 @@ impl PpSourceMode {\n     }\n     fn call_with_pp_support_hir<'tcx, A, B, F>(&self,\n                                                sess: &'tcx Session,\n-                                               ast_map: &hir_map::Map<'tcx>,\n+                                               hir_map: &hir_map::Map<'tcx>,\n                                                analysis: &ty::CrateAnalysis<'tcx>,\n                                                resolutions: &Resolutions,\n                                                arena: &'tcx DroplessArena,\n@@ -216,21 +215,21 @@ impl PpSourceMode {\n             PpmNormal => {\n                 let annotation = NoAnn {\n                     sess: sess,\n-                    ast_map: Some(ast_map.clone()),\n+                    hir_map: Some(hir_map.clone()),\n                 };\n-                f(&annotation, payload, ast_map.forest.krate())\n+                f(&annotation, payload, hir_map.forest.krate())\n             }\n \n             PpmIdentified => {\n                 let annotation = IdentifiedAnnotation {\n                     sess: sess,\n-                    ast_map: Some(ast_map.clone()),\n+                    hir_map: Some(hir_map.clone()),\n                 };\n-                f(&annotation, payload, ast_map.forest.krate())\n+                f(&annotation, payload, hir_map.forest.krate())\n             }\n             PpmTyped => {\n                 abort_on_err(driver::phase_3_run_analysis_passes(sess,\n-                                                                 ast_map.clone(),\n+                                                                 hir_map.clone(),\n                                                                  analysis.clone(),\n                                                                  resolutions.clone(),\n                                                                  arena,\n@@ -243,7 +242,7 @@ impl PpSourceMode {\n                         tables: Cell::new(&empty_tables)\n                     };\n                     let _ignore = tcx.dep_graph.in_ignore();\n-                    f(&annotation, payload, ast_map.forest.krate())\n+                    f(&annotation, payload, hir_map.forest.krate())\n                 }),\n                              sess)\n             }\n@@ -252,30 +251,26 @@ impl PpSourceMode {\n     }\n }\n \n-trait PrinterSupport<'ast>: pprust::PpAnn {\n+trait PrinterSupport: pprust::PpAnn {\n     /// Provides a uniform interface for re-extracting a reference to a\n     /// `Session` from a value that now owns it.\n     fn sess<'a>(&'a self) -> &'a Session;\n \n-    /// Provides a uniform interface for re-extracting a reference to an\n-    /// `hir_map::Map` from a value that now owns it.\n-    fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>>;\n-\n     /// Produces the pretty-print annotation object.\n     ///\n     /// (Rust does not yet support upcasting from a trait object to\n     /// an object for one of its super-traits.)\n     fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn;\n }\n \n-trait HirPrinterSupport<'ast>: pprust_hir::PpAnn {\n+trait HirPrinterSupport<'hir>: pprust_hir::PpAnn {\n     /// Provides a uniform interface for re-extracting a reference to a\n     /// `Session` from a value that now owns it.\n     fn sess<'a>(&'a self) -> &'a Session;\n \n     /// Provides a uniform interface for re-extracting a reference to an\n     /// `hir_map::Map` from a value that now owns it.\n-    fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>>;\n+    fn hir_map<'a>(&'a self) -> Option<&'a hir_map::Map<'hir>>;\n \n     /// Produces the pretty-print annotation object.\n     ///\n@@ -285,7 +280,7 @@ trait HirPrinterSupport<'ast>: pprust_hir::PpAnn {\n \n     /// Computes an user-readable representation of a path, if possible.\n     fn node_path(&self, id: ast::NodeId) -> Option<String> {\n-        self.ast_map().and_then(|map| map.def_path_from_id(id)).map(|path| {\n+        self.hir_map().and_then(|map| map.def_path_from_id(id)).map(|path| {\n             path.data\n                 .into_iter()\n                 .map(|elem| elem.data.to_string())\n@@ -295,71 +290,63 @@ trait HirPrinterSupport<'ast>: pprust_hir::PpAnn {\n     }\n }\n \n-struct NoAnn<'ast> {\n-    sess: &'ast Session,\n-    ast_map: Option<hir_map::Map<'ast>>,\n+struct NoAnn<'hir> {\n+    sess: &'hir Session,\n+    hir_map: Option<hir_map::Map<'hir>>,\n }\n \n-impl<'ast> PrinterSupport<'ast> for NoAnn<'ast> {\n+impl<'hir> PrinterSupport for NoAnn<'hir> {\n     fn sess<'a>(&'a self) -> &'a Session {\n         self.sess\n     }\n \n-    fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n-        self.ast_map.as_ref()\n-    }\n-\n     fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn {\n         self\n     }\n }\n \n-impl<'ast> HirPrinterSupport<'ast> for NoAnn<'ast> {\n+impl<'hir> HirPrinterSupport<'hir> for NoAnn<'hir> {\n     fn sess<'a>(&'a self) -> &'a Session {\n         self.sess\n     }\n \n-    fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n-        self.ast_map.as_ref()\n+    fn hir_map<'a>(&'a self) -> Option<&'a hir_map::Map<'hir>> {\n+        self.hir_map.as_ref()\n     }\n \n     fn pp_ann<'a>(&'a self) -> &'a pprust_hir::PpAnn {\n         self\n     }\n }\n \n-impl<'ast> pprust::PpAnn for NoAnn<'ast> {}\n-impl<'ast> pprust_hir::PpAnn for NoAnn<'ast> {\n+impl<'hir> pprust::PpAnn for NoAnn<'hir> {}\n+impl<'hir> pprust_hir::PpAnn for NoAnn<'hir> {\n     fn nested(&self, state: &mut pprust_hir::State, nested: pprust_hir::Nested)\n               -> io::Result<()> {\n-        if let Some(ref map) = self.ast_map {\n+        if let Some(ref map) = self.hir_map {\n             pprust_hir::PpAnn::nested(map, state, nested)\n         } else {\n             Ok(())\n         }\n     }\n }\n \n-struct IdentifiedAnnotation<'ast> {\n-    sess: &'ast Session,\n-    ast_map: Option<hir_map::Map<'ast>>,\n+struct IdentifiedAnnotation<'hir> {\n+    sess: &'hir Session,\n+    hir_map: Option<hir_map::Map<'hir>>,\n }\n \n-impl<'ast> PrinterSupport<'ast> for IdentifiedAnnotation<'ast> {\n+impl<'hir> PrinterSupport for IdentifiedAnnotation<'hir> {\n     fn sess<'a>(&'a self) -> &'a Session {\n         self.sess\n     }\n \n-    fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n-        self.ast_map.as_ref()\n-    }\n-\n     fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn {\n         self\n     }\n }\n \n-impl<'ast> pprust::PpAnn for IdentifiedAnnotation<'ast> {\n+impl<'hir> pprust::PpAnn for IdentifiedAnnotation<'hir> {\n     fn pre(&self, s: &mut pprust::State, node: pprust::AnnNode) -> io::Result<()> {\n         match node {\n             pprust::NodeExpr(_) => s.popen(),\n@@ -396,24 +383,24 @@ impl<'ast> pprust::PpAnn for IdentifiedAnnotation<'ast> {\n     }\n }\n \n-impl<'ast> HirPrinterSupport<'ast> for IdentifiedAnnotation<'ast> {\n+impl<'hir> HirPrinterSupport<'hir> for IdentifiedAnnotation<'hir> {\n     fn sess<'a>(&'a self) -> &'a Session {\n         self.sess\n     }\n \n-    fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n-        self.ast_map.as_ref()\n+    fn hir_map<'a>(&'a self) -> Option<&'a hir_map::Map<'hir>> {\n+        self.hir_map.as_ref()\n     }\n \n     fn pp_ann<'a>(&'a self) -> &'a pprust_hir::PpAnn {\n         self\n     }\n }\n \n-impl<'ast> pprust_hir::PpAnn for IdentifiedAnnotation<'ast> {\n+impl<'hir> pprust_hir::PpAnn for IdentifiedAnnotation<'hir> {\n     fn nested(&self, state: &mut pprust_hir::State, nested: pprust_hir::Nested)\n               -> io::Result<()> {\n-        if let Some(ref map) = self.ast_map {\n+        if let Some(ref map) = self.hir_map {\n             pprust_hir::PpAnn::nested(map, state, nested)\n         } else {\n             Ok(())\n@@ -453,26 +440,21 @@ impl<'ast> pprust_hir::PpAnn for IdentifiedAnnotation<'ast> {\n     }\n }\n \n-struct HygieneAnnotation<'ast> {\n-    sess: &'ast Session,\n-    ast_map: Option<hir_map::Map<'ast>>,\n+struct HygieneAnnotation<'a> {\n+    sess: &'a Session\n }\n \n-impl<'ast> PrinterSupport<'ast> for HygieneAnnotation<'ast> {\n-    fn sess<'a>(&'a self) -> &'a Session {\n+impl<'a> PrinterSupport for HygieneAnnotation<'a> {\n+    fn sess(&self) -> &Session {\n         self.sess\n     }\n \n-    fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n-        self.ast_map.as_ref()\n-    }\n-\n-    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn {\n+    fn pp_ann(&self) -> &pprust::PpAnn {\n         self\n     }\n }\n \n-impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n+impl<'a> pprust::PpAnn for HygieneAnnotation<'a> {\n     fn post(&self, s: &mut pprust::State, node: pprust::AnnNode) -> io::Result<()> {\n         match node {\n             pprust::NodeIdent(&ast::Ident { name, ctxt }) => {\n@@ -501,7 +483,7 @@ impl<'b, 'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n         &self.tcx.sess\n     }\n \n-    fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'tcx>> {\n+    fn hir_map<'a>(&'a self) -> Option<&'a hir_map::Map<'tcx>> {\n         Some(&self.tcx.hir)\n     }\n \n@@ -579,12 +561,12 @@ impl FromStr for UserIdentifiedItem {\n     }\n }\n \n-enum NodesMatchingUII<'a, 'ast: 'a> {\n+enum NodesMatchingUII<'a, 'hir: 'a> {\n     NodesMatchingDirect(option::IntoIter<ast::NodeId>),\n-    NodesMatchingSuffix(hir_map::NodesMatchingSuffix<'a, 'ast>),\n+    NodesMatchingSuffix(hir_map::NodesMatchingSuffix<'a, 'hir>),\n }\n \n-impl<'a, 'ast> Iterator for NodesMatchingUII<'a, 'ast> {\n+impl<'a, 'hir> Iterator for NodesMatchingUII<'a, 'hir> {\n     type Item = ast::NodeId;\n \n     fn next(&mut self) -> Option<ast::NodeId> {\n@@ -603,9 +585,9 @@ impl UserIdentifiedItem {\n         }\n     }\n \n-    fn all_matching_node_ids<'a, 'ast>(&'a self,\n-                                       map: &'a hir_map::Map<'ast>)\n-                                       -> NodesMatchingUII<'a, 'ast> {\n+    fn all_matching_node_ids<'a, 'hir>(&'a self,\n+                                       map: &'a hir_map::Map<'hir>)\n+                                       -> NodesMatchingUII<'a, 'hir> {\n         match *self {\n             ItemViaNode(node_id) => NodesMatchingDirect(Some(node_id).into_iter()),\n             ItemViaPath(ref parts) => NodesMatchingSuffix(map.nodes_matching_suffix(&parts[..])),\n@@ -745,7 +727,7 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n     };\n     let labelled_edges = mode != PpFlowGraphMode::UnlabelledEdges;\n     let lcfg = LabelledCFG {\n-        ast_map: &tcx.hir,\n+        hir_map: &tcx.hir,\n         cfg: &cfg,\n         name: format!(\"node_{}\", code.id()),\n         labelled_edges: labelled_edges,\n@@ -855,7 +837,7 @@ pub fn print_after_parsing(sess: &Session,\n }\n \n pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n-                                                ast_map: &hir_map::Map<'tcx>,\n+                                                hir_map: &hir_map::Map<'tcx>,\n                                                 analysis: &ty::CrateAnalysis<'tcx>,\n                                                 resolutions: &Resolutions,\n                                                 input: &Input,\n@@ -871,7 +853,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n \n     if ppm.needs_analysis() {\n         print_with_analysis(sess,\n-                            ast_map,\n+                            hir_map,\n                             analysis,\n                             resolutions,\n                             crate_name,\n@@ -892,7 +874,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n             (PpmSource(s), _) => {\n                 // Silently ignores an identified node.\n                 let out: &mut Write = &mut out;\n-                s.call_with_pp_support(sess, Some(ast_map), box out, |annotation, out| {\n+                s.call_with_pp_support(sess, Some(hir_map), box out, |annotation, out| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     pprust::print_crate(sess.codemap(),\n@@ -909,7 +891,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n             (PpmHir(s), None) => {\n                 let out: &mut Write = &mut out;\n                 s.call_with_pp_support_hir(sess,\n-                                           ast_map,\n+                                           hir_map,\n                                            analysis,\n                                            resolutions,\n                                            arena,\n@@ -933,7 +915,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n             (PpmHir(s), Some(uii)) => {\n                 let out: &mut Write = &mut out;\n                 s.call_with_pp_support_hir(sess,\n-                                           ast_map,\n+                                           hir_map,\n                                            analysis,\n                                            resolutions,\n                                            arena,\n@@ -943,16 +925,16 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                            |annotation, (out, uii), _| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n-                    let ast_map = annotation.ast_map().expect(\"--unpretty missing HIR map\");\n+                    let hir_map = annotation.hir_map().expect(\"--unpretty missing HIR map\");\n                     let mut pp_state = pprust_hir::State::new_from_input(sess.codemap(),\n                                                                          &sess.parse_sess,\n                                                                          src_name.to_string(),\n                                                                          &mut rdr,\n                                                                          box out,\n                                                                          annotation.pp_ann(),\n                                                                          true);\n-                    for node_id in uii.all_matching_node_ids(ast_map) {\n-                        let node = ast_map.get(node_id);\n+                    for node_id in uii.all_matching_node_ids(hir_map) {\n+                        let node = hir_map.get(node_id);\n                         pp_state.print_node(node)?;\n                         pp::space(&mut pp_state.s)?;\n                         let path = annotation.node_path(node_id)\n@@ -975,7 +957,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n // with a different callback than the standard driver, so that isn't easy.\n // Instead, we call that function ourselves.\n fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n-                                       ast_map: &hir_map::Map<'tcx>,\n+                                       hir_map: &hir_map::Map<'tcx>,\n                                        analysis: &ty::CrateAnalysis<'tcx>,\n                                        resolutions: &Resolutions,\n                                        crate_name: &str,\n@@ -986,7 +968,7 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                        ofile: Option<&Path>) {\n     let nodeid = if let Some(uii) = uii {\n         debug!(\"pretty printing for {:?}\", uii);\n-        Some(uii.to_one_node_id(\"--unpretty\", sess, &ast_map))\n+        Some(uii.to_one_node_id(\"--unpretty\", sess, &hir_map))\n     } else {\n         debug!(\"pretty printing for whole crate\");\n         None\n@@ -995,7 +977,7 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n     let mut out = Vec::new();\n \n     abort_on_err(driver::phase_3_run_analysis_passes(sess,\n-                                                     ast_map.clone(),\n+                                                     hir_map.clone(),\n                                                      analysis.clone(),\n                                                      resolutions.clone(),\n                                                      arena,"}, {"sha": "59f6889ba4d94af645732e8af68cf004b56d0f30", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8", "patch": "@@ -131,19 +131,19 @@ fn test_env<F>(source_string: &str,\n \n     let arena = DroplessArena::new();\n     let arenas = ty::GlobalArenas::new();\n-    let ast_map = hir_map::map_crate(&mut hir_forest, defs);\n+    let hir_map = hir_map::map_crate(&mut hir_forest, defs);\n \n     // run just enough stuff to build a tcx:\n-    let lang_items = lang_items::collect_language_items(&sess, &ast_map);\n-    let named_region_map = resolve_lifetime::krate(&sess, &ast_map);\n-    let region_map = region::resolve_crate(&sess, &ast_map);\n-    let index = stability::Index::new(&ast_map);\n+    let lang_items = lang_items::collect_language_items(&sess, &hir_map);\n+    let named_region_map = resolve_lifetime::krate(&sess, &hir_map);\n+    let region_map = region::resolve_crate(&sess, &hir_map);\n+    let index = stability::Index::new(&hir_map);\n     TyCtxt::create_and_enter(&sess,\n                              &arenas,\n                              &arena,\n                              resolutions,\n                              named_region_map.unwrap(),\n-                             ast_map,\n+                             hir_map,\n                              region_map,\n                              lang_items,\n                              index,"}, {"sha": "a5bd69fff0138b73e71f7da9dce746733db4b670", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8", "patch": "@@ -43,9 +43,9 @@ enum Context {\n }\n \n #[derive(Copy, Clone)]\n-struct CheckLoopVisitor<'a, 'ast: 'a> {\n+struct CheckLoopVisitor<'a, 'hir: 'a> {\n     sess: &'a Session,\n-    hir_map: &'a Map<'ast>,\n+    hir_map: &'a Map<'hir>,\n     cx: Context,\n }\n \n@@ -59,20 +59,20 @@ pub fn check_crate(sess: &Session, map: &Map) {\n     }.as_deep_visitor());\n }\n \n-impl<'a, 'ast> Visitor<'ast> for CheckLoopVisitor<'a, 'ast> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'ast> {\n+impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'hir> {\n         NestedVisitorMap::OnlyBodies(&self.hir_map)\n     }\n \n-    fn visit_item(&mut self, i: &'ast hir::Item) {\n+    fn visit_item(&mut self, i: &'hir hir::Item) {\n         self.with_context(Normal, |v| intravisit::walk_item(v, i));\n     }\n \n-    fn visit_impl_item(&mut self, i: &'ast hir::ImplItem) {\n+    fn visit_impl_item(&mut self, i: &'hir hir::ImplItem) {\n         self.with_context(Normal, |v| intravisit::walk_impl_item(v, i));\n     }\n \n-    fn visit_expr(&mut self, e: &'ast hir::Expr) {\n+    fn visit_expr(&mut self, e: &'hir hir::Expr) {\n         match e.node {\n             hir::ExprWhile(ref e, ref b, _) => {\n                 self.with_context(Loop(LoopKind::WhileLoop), |v| {\n@@ -125,9 +125,9 @@ impl<'a, 'ast> Visitor<'ast> for CheckLoopVisitor<'a, 'ast> {\n     }\n }\n \n-impl<'a, 'ast> CheckLoopVisitor<'a, 'ast> {\n+impl<'a, 'hir> CheckLoopVisitor<'a, 'hir> {\n     fn with_context<F>(&mut self, cx: Context, f: F)\n-        where F: FnOnce(&mut CheckLoopVisitor<'a, 'ast>)\n+        where F: FnOnce(&mut CheckLoopVisitor<'a, 'hir>)\n     {\n         let old_cx = self.cx;\n         self.cx = cx;"}, {"sha": "1ef8a5b0080f3ca2451bf714f27a0db582b67774", "filename": "src/librustc_passes/static_recursion.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=1ff3641623ce5f83cba30c2d2f039dbd49c4b4b8", "patch": "@@ -12,7 +12,7 @@\n // recursively.\n \n use rustc::dep_graph::DepNode;\n-use rustc::hir::map as ast_map;\n+use rustc::hir::map as hir_map;\n use rustc::session::{CompileResult, Session};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::util::nodemap::{NodeMap, NodeSet};\n@@ -23,9 +23,9 @@ use syntax_pos::Span;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir;\n \n-struct CheckCrateVisitor<'a, 'ast: 'a> {\n+struct CheckCrateVisitor<'a, 'hir: 'a> {\n     sess: &'a Session,\n-    ast_map: &'a ast_map::Map<'ast>,\n+    hir_map: &'a hir_map::Map<'hir>,\n     // `discriminant_map` is a cache that associates the `NodeId`s of local\n     // variant definitions with the discriminant expression that applies to\n     // each one. If the variant uses the default values (starting from `0`),\n@@ -34,12 +34,12 @@ struct CheckCrateVisitor<'a, 'ast: 'a> {\n     detected_recursive_ids: NodeSet,\n }\n \n-impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'ast> {\n+impl<'a, 'hir: 'a> Visitor<'hir> for CheckCrateVisitor<'a, 'hir> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'hir> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_item(&mut self, it: &'ast hir::Item) {\n+    fn visit_item(&mut self, it: &'hir hir::Item) {\n         match it.node {\n             hir::ItemStatic(..) |\n             hir::ItemConst(..) => {\n@@ -64,7 +64,7 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n         intravisit::walk_item(self, it)\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'ast hir::TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'hir hir::TraitItem) {\n         match ti.node {\n             hir::TraitItemKind::Const(_, ref default) => {\n                 if let Some(_) = *default {\n@@ -77,7 +77,7 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n         intravisit::walk_trait_item(self, ti)\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'ast hir::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'hir hir::ImplItem) {\n         match ii.node {\n             hir::ImplItemKind::Const(..) => {\n                 let mut recursion_visitor = CheckItemRecursionVisitor::new(self, &ii.span);\n@@ -89,36 +89,36 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n     }\n }\n \n-pub fn check_crate<'ast>(sess: &Session, ast_map: &ast_map::Map<'ast>) -> CompileResult {\n-    let _task = ast_map.dep_graph.in_task(DepNode::CheckStaticRecursion);\n+pub fn check_crate<'hir>(sess: &Session, hir_map: &hir_map::Map<'hir>) -> CompileResult {\n+    let _task = hir_map.dep_graph.in_task(DepNode::CheckStaticRecursion);\n \n     let mut visitor = CheckCrateVisitor {\n         sess: sess,\n-        ast_map: ast_map,\n+        hir_map: hir_map,\n         discriminant_map: NodeMap(),\n         detected_recursive_ids: NodeSet(),\n     };\n     sess.track_errors(|| {\n         // FIXME(#37712) could use ItemLikeVisitor if trait items were item-like\n-        ast_map.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n+        hir_map.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n     })\n }\n \n-struct CheckItemRecursionVisitor<'a, 'b: 'a, 'ast: 'b> {\n+struct CheckItemRecursionVisitor<'a, 'b: 'a, 'hir: 'b> {\n     root_span: &'b Span,\n     sess: &'b Session,\n-    ast_map: &'b ast_map::Map<'ast>,\n+    hir_map: &'b hir_map::Map<'hir>,\n     discriminant_map: &'a mut NodeMap<Option<hir::BodyId>>,\n     idstack: Vec<ast::NodeId>,\n     detected_recursive_ids: &'a mut NodeSet,\n }\n \n-impl<'a, 'b: 'a, 'ast: 'b> CheckItemRecursionVisitor<'a, 'b, 'ast> {\n-    fn new(v: &'a mut CheckCrateVisitor<'b, 'ast>, span: &'b Span) -> Self {\n+impl<'a, 'b: 'a, 'hir: 'b> CheckItemRecursionVisitor<'a, 'b, 'hir> {\n+    fn new(v: &'a mut CheckCrateVisitor<'b, 'hir>, span: &'b Span) -> Self {\n         CheckItemRecursionVisitor {\n             root_span: span,\n             sess: v.sess,\n-            ast_map: v.ast_map,\n+            hir_map: v.hir_map,\n             discriminant_map: &mut v.discriminant_map,\n             idstack: Vec::new(),\n             detected_recursive_ids: &mut v.detected_recursive_ids,\n@@ -133,7 +133,7 @@ impl<'a, 'b: 'a, 'ast: 'b> CheckItemRecursionVisitor<'a, 'b, 'ast> {\n             }\n             self.detected_recursive_ids.insert(id);\n             let any_static = self.idstack.iter().any(|&x| {\n-                if let ast_map::NodeItem(item) = self.ast_map.get(x) {\n+                if let hir_map::NodeItem(item) = self.hir_map.get(x) {\n                     if let hir::ItemStatic(..) = item.node {\n                         true\n                     } else {\n@@ -170,7 +170,7 @@ impl<'a, 'b: 'a, 'ast: 'b> CheckItemRecursionVisitor<'a, 'b, 'ast> {\n     // So for every variant, we need to track whether there is an expression\n     // somewhere in the enum definition that controls its discriminant. We do\n     // this by starting from the end and searching backward.\n-    fn populate_enum_discriminants(&mut self, enum_definition: &'ast hir::EnumDef) {\n+    fn populate_enum_discriminants(&mut self, enum_definition: &'hir hir::EnumDef) {\n         // Get the map, and return if we already processed this enum or if it\n         // has no variants.\n         match enum_definition.variants.first() {\n@@ -204,26 +204,26 @@ impl<'a, 'b: 'a, 'ast: 'b> CheckItemRecursionVisitor<'a, 'b, 'ast> {\n     }\n }\n \n-impl<'a, 'b: 'a, 'ast: 'b> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'b, 'ast> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'ast> {\n-        NestedVisitorMap::OnlyBodies(&self.ast_map)\n+impl<'a, 'b: 'a, 'hir: 'b> Visitor<'hir> for CheckItemRecursionVisitor<'a, 'b, 'hir> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'hir> {\n+        NestedVisitorMap::OnlyBodies(&self.hir_map)\n     }\n-    fn visit_item(&mut self, it: &'ast hir::Item) {\n+    fn visit_item(&mut self, it: &'hir hir::Item) {\n         self.with_item_id_pushed(it.id, |v| intravisit::walk_item(v, it), it.span);\n     }\n \n     fn visit_enum_def(&mut self,\n-                      enum_definition: &'ast hir::EnumDef,\n-                      generics: &'ast hir::Generics,\n+                      enum_definition: &'hir hir::EnumDef,\n+                      generics: &'hir hir::Generics,\n                       item_id: ast::NodeId,\n                       _: Span) {\n         self.populate_enum_discriminants(enum_definition);\n         intravisit::walk_enum_def(self, enum_definition, generics, item_id);\n     }\n \n     fn visit_variant(&mut self,\n-                     variant: &'ast hir::Variant,\n-                     _: &'ast hir::Generics,\n+                     variant: &'hir hir::Variant,\n+                     _: &'hir hir::Generics,\n                      _: ast::NodeId) {\n         let variant_id = variant.node.data.id();\n         let maybe_expr = *self.discriminant_map.get(&variant_id).unwrap_or_else(|| {\n@@ -234,34 +234,34 @@ impl<'a, 'b: 'a, 'ast: 'b> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'b, '\n         // If `maybe_expr` is `None`, that's because no discriminant is\n         // specified that affects this variant. Thus, no risk of recursion.\n         if let Some(expr) = maybe_expr {\n-            let expr = &self.ast_map.body(expr).value;\n+            let expr = &self.hir_map.body(expr).value;\n             self.with_item_id_pushed(expr.id, |v| intravisit::walk_expr(v, expr), expr.span);\n         }\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'ast hir::TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'hir hir::TraitItem) {\n         self.with_item_id_pushed(ti.id, |v| intravisit::walk_trait_item(v, ti), ti.span);\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'ast hir::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'hir hir::ImplItem) {\n         self.with_item_id_pushed(ii.id, |v| intravisit::walk_impl_item(v, ii), ii.span);\n     }\n \n-    fn visit_path(&mut self, path: &'ast hir::Path, _: ast::NodeId) {\n+    fn visit_path(&mut self, path: &'hir hir::Path, _: ast::NodeId) {\n         match path.def {\n             Def::Static(def_id, _) |\n             Def::AssociatedConst(def_id) |\n             Def::Const(def_id) => {\n-                if let Some(node_id) = self.ast_map.as_local_node_id(def_id) {\n-                    match self.ast_map.get(node_id) {\n-                        ast_map::NodeItem(item) => self.visit_item(item),\n-                        ast_map::NodeTraitItem(item) => self.visit_trait_item(item),\n-                        ast_map::NodeImplItem(item) => self.visit_impl_item(item),\n-                        ast_map::NodeForeignItem(_) => {}\n+                if let Some(node_id) = self.hir_map.as_local_node_id(def_id) {\n+                    match self.hir_map.get(node_id) {\n+                        hir_map::NodeItem(item) => self.visit_item(item),\n+                        hir_map::NodeTraitItem(item) => self.visit_trait_item(item),\n+                        hir_map::NodeImplItem(item) => self.visit_impl_item(item),\n+                        hir_map::NodeForeignItem(_) => {}\n                         _ => {\n                             span_bug!(path.span,\n                                       \"expected item, found {}\",\n-                                      self.ast_map.node_to_string(node_id));\n+                                      self.hir_map.node_to_string(node_id));\n                         }\n                     }\n                 }\n@@ -271,10 +271,10 @@ impl<'a, 'b: 'a, 'ast: 'b> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'b, '\n             // the whole enum definition to see what expression that\n             // might be (if any).\n             Def::VariantCtor(variant_id, CtorKind::Const) => {\n-                if let Some(variant_id) = self.ast_map.as_local_node_id(variant_id) {\n-                    let variant = self.ast_map.expect_variant(variant_id);\n-                    let enum_id = self.ast_map.get_parent(variant_id);\n-                    let enum_item = self.ast_map.expect_item(enum_id);\n+                if let Some(variant_id) = self.hir_map.as_local_node_id(variant_id) {\n+                    let variant = self.hir_map.expect_variant(variant_id);\n+                    let enum_id = self.hir_map.get_parent(variant_id);\n+                    let enum_item = self.hir_map.expect_item(enum_id);\n                     if let hir::ItemEnum(ref enum_def, ref generics) = enum_item.node {\n                         self.populate_enum_discriminants(enum_def);\n                         self.visit_variant(variant, generics, enum_id);"}]}