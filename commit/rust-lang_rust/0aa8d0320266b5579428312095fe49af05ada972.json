{"sha": "0aa8d0320266b5579428312095fe49af05ada972", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhYThkMDMyMDI2NmI1NTc5NDI4MzEyMDk1ZmU0OWFmMDVhZGE5NzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-10T19:18:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-10T19:18:22Z"}, "message": "Auto merge of #53177 - nikomatsakis:nll-redundant-borrows-and-escaping-values, r=pnkfelix\n\noptimize redundant borrows and escaping paths in NLL\n\nThis builds on https://github.com/rust-lang/rust/pull/53168 and adds a commit that addresses https://github.com/rust-lang/rust/issues/53176 -- or at least I think it does. I marked this as WIP because I want to see the test results (and measure the performance). I also want to double check we're not adding in any unsoundness here.", "tree": {"sha": "960f951e09e562b034e3ab14964738e448088dcc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/960f951e09e562b034e3ab14964738e448088dcc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0aa8d0320266b5579428312095fe49af05ada972", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0aa8d0320266b5579428312095fe49af05ada972", "html_url": "https://github.com/rust-lang/rust/commit/0aa8d0320266b5579428312095fe49af05ada972", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0aa8d0320266b5579428312095fe49af05ada972/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a77dfcc79fe3e7e1a10ae4dccfd4b2e5e0e49195", "url": "https://api.github.com/repos/rust-lang/rust/commits/a77dfcc79fe3e7e1a10ae4dccfd4b2e5e0e49195", "html_url": "https://github.com/rust-lang/rust/commit/a77dfcc79fe3e7e1a10ae4dccfd4b2e5e0e49195"}, {"sha": "ff7f6d57de1112805272bae57ff5918d4f25e0ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff7f6d57de1112805272bae57ff5918d4f25e0ab", "html_url": "https://github.com/rust-lang/rust/commit/ff7f6d57de1112805272bae57ff5918d4f25e0ab"}], "stats": {"total": 590, "additions": 388, "deletions": 202}, "files": [{"sha": "2e0cbf4326bc1e03acce2e5b14d67ddae1dd971f", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aa8d0320266b5579428312095fe49af05ada972/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa8d0320266b5579428312095fe49af05ada972/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=0aa8d0320266b5579428312095fe49af05ada972", "patch": "@@ -159,7 +159,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n         location: mir::Location,\n     ) {\n         if let mir::Rvalue::Ref(region, kind, ref borrowed_place) = *rvalue {\n-            if borrowed_place.is_unsafe_place(self.tcx, self.mir) {\n+            if borrowed_place.ignore_borrow(self.tcx, self.mir) {\n                 return;\n             }\n "}, {"sha": "1a1094b570bd107ca5de46a493a8874f75eb554a", "filename": "src/librustc_mir/borrow_check/nll/constraints/graph.rs", "status": "modified", "additions": 88, "deletions": 24, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/0aa8d0320266b5579428312095fe49af05ada972/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa8d0320266b5579428312095fe49af05ada972/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs?ref=0aa8d0320266b5579428312095fe49af05ada972", "patch": "@@ -8,41 +8,102 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::nll::constraints::{ConstraintIndex, ConstraintSet};\n+use borrow_check::nll::constraints::{ConstraintIndex, ConstraintSet, OutlivesConstraint};\n use rustc::ty::RegionVid;\n use rustc_data_structures::graph;\n use rustc_data_structures::indexed_vec::IndexVec;\n \n-crate struct ConstraintGraph {\n+/// The construct graph organizes the constraints by their end-points.\n+/// It can be used to view a `R1: R2` constraint as either an edge `R1\n+/// -> R2` or `R2 -> R1` depending on the direction type `D`.\n+crate struct ConstraintGraph<D: ConstraintGraphDirecton> {\n+    _direction: D,\n     first_constraints: IndexVec<RegionVid, Option<ConstraintIndex>>,\n     next_constraints: IndexVec<ConstraintIndex, Option<ConstraintIndex>>,\n }\n \n-impl ConstraintGraph {\n+crate type NormalConstraintGraph = ConstraintGraph<Normal>;\n+\n+crate type ReverseConstraintGraph = ConstraintGraph<Reverse>;\n+\n+/// Marker trait that controls whether a `R1: R2` constraint\n+/// represents an edge `R1 -> R2` or `R2 -> R1`.\n+crate trait ConstraintGraphDirecton: Copy + 'static {\n+    fn start_region(c: &OutlivesConstraint) -> RegionVid;\n+    fn end_region(c: &OutlivesConstraint) -> RegionVid;\n+}\n+\n+/// In normal mode, a `R1: R2` constraint results in an edge `R1 ->\n+/// R2`. This is what we use when constructing the SCCs for\n+/// inference. This is because we compute the value of R1 by union'ing\n+/// all the things that it relies on.\n+#[derive(Copy, Clone, Debug)]\n+crate struct Normal;\n+\n+impl ConstraintGraphDirecton for Normal {\n+    fn start_region(c: &OutlivesConstraint) -> RegionVid {\n+        c.sup\n+    }\n+\n+    fn end_region(c: &OutlivesConstraint) -> RegionVid {\n+        c.sub\n+    }\n+}\n+\n+/// In reverse mode, a `R1: R2` constraint results in an edge `R2 ->\n+/// R1`. We use this for optimizing liveness computation, because then\n+/// we wish to iterate from a region (e.g., R2) to all the regions\n+/// that will outlive it (e.g., R1).\n+#[derive(Copy, Clone, Debug)]\n+crate struct Reverse;\n+\n+impl ConstraintGraphDirecton for Reverse {\n+    fn start_region(c: &OutlivesConstraint) -> RegionVid {\n+        c.sub\n+    }\n+\n+    fn end_region(c: &OutlivesConstraint) -> RegionVid {\n+        c.sup\n+    }\n+}\n+\n+impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n     /// Create a \"dependency graph\" where each region constraint `R1:\n     /// R2` is treated as an edge `R1 -> R2`. We use this graph to\n     /// construct SCCs for region inference but also for error\n     /// reporting.\n-    crate fn new(set: &ConstraintSet, num_region_vars: usize) -> Self {\n+    crate fn new(\n+        direction: D,\n+        set: &ConstraintSet,\n+        num_region_vars: usize,\n+    ) -> Self {\n         let mut first_constraints = IndexVec::from_elem_n(None, num_region_vars);\n         let mut next_constraints = IndexVec::from_elem(None, &set.constraints);\n \n         for (idx, constraint) in set.constraints.iter_enumerated().rev() {\n-            let head = &mut first_constraints[constraint.sup];\n+            let head = &mut first_constraints[D::start_region(constraint)];\n             let next = &mut next_constraints[idx];\n             debug_assert!(next.is_none());\n             *next = *head;\n             *head = Some(idx);\n         }\n \n         Self {\n+            _direction: direction,\n             first_constraints,\n             next_constraints,\n         }\n     }\n \n+    /// Given the constraint set from which this graph was built\n+    /// creates a region graph so that you can iterate over *regions*\n+    /// and not constraints.\n+    crate fn region_graph<'rg>(&'rg self, set: &'rg ConstraintSet) -> RegionGraph<'rg, D> {\n+        RegionGraph::new(set, self)\n+    }\n+\n     /// Given a region `R`, iterate over all constraints `R: R1`.\n-    crate fn outgoing_edges(&self, region_sup: RegionVid) -> Edges<'_> {\n+    crate fn outgoing_edges(&self, region_sup: RegionVid) -> Edges<'_, D> {\n         let first = self.first_constraints[region_sup];\n         Edges {\n             graph: self,\n@@ -51,12 +112,12 @@ impl ConstraintGraph {\n     }\n }\n \n-crate struct Edges<'s> {\n-    graph: &'s ConstraintGraph,\n+crate struct Edges<'s, D: ConstraintGraphDirecton> {\n+    graph: &'s ConstraintGraph<D>,\n     pointer: Option<ConstraintIndex>,\n }\n \n-impl<'s> Iterator for Edges<'s> {\n+impl<'s, D: ConstraintGraphDirecton> Iterator for Edges<'s, D> {\n     type Item = ConstraintIndex;\n \n     fn next(&mut self) -> Option<Self::Item> {\n@@ -69,17 +130,20 @@ impl<'s> Iterator for Edges<'s> {\n     }\n }\n \n-crate struct RegionGraph<'s> {\n+/// This struct brings together a constraint set and a (normal, not\n+/// reverse) constraint graph. It implements the graph traits and is\n+/// usd for doing the SCC computation.\n+crate struct RegionGraph<'s, D: ConstraintGraphDirecton> {\n     set: &'s ConstraintSet,\n-    constraint_graph: &'s ConstraintGraph,\n+    constraint_graph: &'s ConstraintGraph<D>,\n }\n \n-impl<'s> RegionGraph<'s> {\n+impl<'s, D: ConstraintGraphDirecton> RegionGraph<'s, D> {\n     /// Create a \"dependency graph\" where each region constraint `R1:\n     /// R2` is treated as an edge `R1 -> R2`. We use this graph to\n     /// construct SCCs for region inference but also for error\n     /// reporting.\n-    crate fn new(set: &'s ConstraintSet, constraint_graph: &'s ConstraintGraph) -> Self {\n+    crate fn new(set: &'s ConstraintSet, constraint_graph: &'s ConstraintGraph<D>) -> Self {\n         Self {\n             set,\n             constraint_graph,\n@@ -88,47 +152,47 @@ impl<'s> RegionGraph<'s> {\n \n     /// Given a region `R`, iterate over all regions `R1` such that\n     /// there exists a constraint `R: R1`.\n-    crate fn sub_regions(&self, region_sup: RegionVid) -> Successors<'_> {\n+    crate fn outgoing_regions(&self, region_sup: RegionVid) -> Successors<'_, D> {\n         Successors {\n             set: self.set,\n             edges: self.constraint_graph.outgoing_edges(region_sup),\n         }\n     }\n }\n \n-crate struct Successors<'s> {\n+crate struct Successors<'s, D: ConstraintGraphDirecton> {\n     set: &'s ConstraintSet,\n-    edges: Edges<'s>,\n+    edges: Edges<'s, D>,\n }\n \n-impl<'s> Iterator for Successors<'s> {\n+impl<'s, D: ConstraintGraphDirecton> Iterator for Successors<'s, D> {\n     type Item = RegionVid;\n \n     fn next(&mut self) -> Option<Self::Item> {\n-        self.edges.next().map(|c| self.set[c].sub)\n+        self.edges.next().map(|c| D::end_region(&self.set[c]))\n     }\n }\n \n-impl<'s> graph::DirectedGraph for RegionGraph<'s> {\n+impl<'s, D: ConstraintGraphDirecton> graph::DirectedGraph for RegionGraph<'s, D> {\n     type Node = RegionVid;\n }\n \n-impl<'s> graph::WithNumNodes for RegionGraph<'s> {\n+impl<'s, D: ConstraintGraphDirecton> graph::WithNumNodes for RegionGraph<'s, D> {\n     fn num_nodes(&self) -> usize {\n         self.constraint_graph.first_constraints.len()\n     }\n }\n \n-impl<'s> graph::WithSuccessors for RegionGraph<'s> {\n+impl<'s, D: ConstraintGraphDirecton> graph::WithSuccessors for RegionGraph<'s, D> {\n     fn successors<'graph>(\n         &'graph self,\n         node: Self::Node,\n     ) -> <Self as graph::GraphSuccessors<'graph>>::Iter {\n-        self.sub_regions(node)\n+        self.outgoing_regions(node)\n     }\n }\n \n-impl<'s, 'graph> graph::GraphSuccessors<'graph> for RegionGraph<'s> {\n+impl<'s, 'graph, D: ConstraintGraphDirecton> graph::GraphSuccessors<'graph> for RegionGraph<'s, D> {\n     type Item = RegionVid;\n-    type Iter = Successors<'graph>;\n+    type Iter = Successors<'graph, D>;\n }"}, {"sha": "4cb92262ff08590a9d2c6f8ab00f4c25419eb13d", "filename": "src/librustc_mir/borrow_check/nll/constraints/mod.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0aa8d0320266b5579428312095fe49af05ada972/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa8d0320266b5579428312095fe49af05ada972/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs?ref=0aa8d0320266b5579428312095fe49af05ada972", "patch": "@@ -36,22 +36,30 @@ impl ConstraintSet {\n         self.constraints.push(constraint);\n     }\n \n-    /// Constructs a graph from the constraint set; the graph makes it\n-    /// easy to find the constraints affecting a particular region\n-    /// (you should not mutate the set once this graph is\n-    /// constructed).\n-    crate fn graph(&self, num_region_vars: usize) -> graph::ConstraintGraph {\n-        graph::ConstraintGraph::new(self, num_region_vars)\n+    /// Constructs a \"normal\" graph from the constraint set; the graph makes it\n+    /// easy to find the constraints affecting a particular region.\n+    ///\n+    /// NB: This graph contains a \"frozen\" view of the current\n+    /// constraints.  any new constraints added to the `ConstraintSet`\n+    /// after the graph is built will not be present in the graph.\n+    crate fn graph(&self, num_region_vars: usize) -> graph::NormalConstraintGraph {\n+        graph::ConstraintGraph::new(graph::Normal, self, num_region_vars)\n+    }\n+\n+    /// Like `graph`, but constraints a reverse graph where `R1: R2`\n+    /// represents an edge `R2 -> R1`.\n+    crate fn reverse_graph(&self, num_region_vars: usize) -> graph::ReverseConstraintGraph {\n+        graph::ConstraintGraph::new(graph::Reverse, self, num_region_vars)\n     }\n \n     /// Compute cycles (SCCs) in the graph of regions. In particular,\n     /// find all regions R1, R2 such that R1: R2 and R2: R1 and group\n     /// them into an SCC, and find the relationships between SCCs.\n     crate fn compute_sccs(\n         &self,\n-        constraint_graph: &graph::ConstraintGraph,\n+        constraint_graph: &graph::NormalConstraintGraph,\n     ) -> Sccs<RegionVid, ConstraintSccIndex> {\n-        let region_graph = &graph::RegionGraph::new(self, constraint_graph);\n+        let region_graph = &constraint_graph.region_graph(self);\n         Sccs::new(region_graph)\n     }\n }"}, {"sha": "cbd9c9a4e1a85368906de6d91bd210585a731c7b", "filename": "src/librustc_mir/borrow_check/nll/liveness_map.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/a77dfcc79fe3e7e1a10ae4dccfd4b2e5e0e49195/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fliveness_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77dfcc79fe3e7e1a10ae4dccfd4b2e5e0e49195/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fliveness_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fliveness_map.rs?ref=a77dfcc79fe3e7e1a10ae4dccfd4b2e5e0e49195", "patch": "@@ -1,77 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! For the NLL computation, we need to compute liveness, but only for those\n-//! local variables whose types contain regions. The others are not of interest\n-//! to us. This file defines a new index type (LocalWithRegion) that indexes into\n-//! a list of \"variables whose type contain regions\". It also defines a map from\n-//! Local to LocalWithRegion and vice versa -- this map can be given to the\n-//! liveness code so that it only operates over variables with regions in their\n-//! types, instead of all variables.\n-\n-use rustc::ty::TypeFoldable;\n-use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc::mir::{Mir, Local};\n-use util::liveness::LiveVariableMap;\n-\n-use rustc_data_structures::indexed_vec::Idx;\n-\n-/// Map between Local and LocalWithRegion indices: this map is supplied to the\n-/// liveness code so that it will only analyze those variables whose types\n-/// contain regions.\n-crate struct NllLivenessMap {\n-    /// For each local variable, contains either None (if the type has no regions)\n-    /// or Some(i) with a suitable index.\n-    pub from_local: IndexVec<Local, Option<LocalWithRegion>>,\n-    /// For each LocalWithRegion, maps back to the original Local index.\n-    pub to_local: IndexVec<LocalWithRegion, Local>,\n-\n-}\n-\n-impl LiveVariableMap for NllLivenessMap {\n-\n-    fn from_local(&self, local: Local) -> Option<Self::LiveVar> {\n-        self.from_local[local]\n-    }\n-\n-    type LiveVar = LocalWithRegion;\n-\n-    fn from_live_var(&self, local: Self::LiveVar) -> Local {\n-        self.to_local[local]\n-    }\n-\n-    fn num_variables(&self) -> usize {\n-        self.to_local.len()\n-    }\n-}\n-\n-impl NllLivenessMap {\n-    /// Iterates over the variables in Mir and assigns each Local whose type contains\n-    /// regions a LocalWithRegion index. Returns a map for converting back and forth.\n-    pub fn compute(mir: &Mir) -> Self {\n-        let mut to_local = IndexVec::default();\n-        let from_local: IndexVec<Local,Option<_>> = mir\n-            .local_decls\n-            .iter_enumerated()\n-            .map(|(local, local_decl)| {\n-                if local_decl.ty.has_free_regions() {\n-                    Some(to_local.push(local))\n-                }\n-                    else {\n-                        None\n-                    }\n-            }).collect();\n-\n-        Self { from_local, to_local }\n-    }\n-}\n-\n-/// Index given to each local variable whose type contains a region.\n-newtype_index!(LocalWithRegion);"}, {"sha": "f54d80d5f4f7e7e86701ca6fdbc53bc0f52dc389", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0aa8d0320266b5579428312095fe49af05ada972/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa8d0320266b5579428312095fe49af05ada972/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=0aa8d0320266b5579428312095fe49af05ada972", "patch": "@@ -11,9 +11,9 @@\n use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::{LocationIndex, LocationTable};\n use borrow_check::nll::facts::AllFactsExt;\n-use borrow_check::nll::type_check::MirTypeckRegionConstraints;\n+use borrow_check::nll::type_check::{MirTypeckResults, MirTypeckRegionConstraints};\n+use borrow_check::nll::type_check::liveness::liveness_map::{NllLivenessMap, LocalWithRegion};\n use borrow_check::nll::region_infer::values::RegionValueElements;\n-use borrow_check::nll::liveness_map::{NllLivenessMap, LocalWithRegion};\n use dataflow::indexes::BorrowIndex;\n use dataflow::move_paths::MoveData;\n use dataflow::FlowAtLocation;\n@@ -47,7 +47,6 @@ crate mod region_infer;\n mod renumber;\n crate mod type_check;\n mod universal_regions;\n-crate mod liveness_map;\n \n mod constraints;\n \n@@ -109,17 +108,19 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     let elements = &Rc::new(RegionValueElements::new(mir));\n \n     // Run the MIR type-checker.\n-    let liveness_map = NllLivenessMap::compute(&mir);\n-    let liveness = LivenessResults::compute(mir, &liveness_map);\n-    let (constraint_sets, universal_region_relations) = type_check::type_check(\n+    let MirTypeckResults {\n+        constraints,\n+        universal_region_relations,\n+        liveness,\n+        liveness_map,\n+    } = type_check::type_check(\n         infcx,\n         param_env,\n         mir,\n         def_id,\n         &universal_regions,\n         location_table,\n         borrow_set,\n-        &liveness,\n         &mut all_facts,\n         flow_inits,\n         move_data,\n@@ -141,7 +142,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n         mut liveness_constraints,\n         outlives_constraints,\n         type_tests,\n-    } = constraint_sets;\n+    } = constraints;\n \n     constraint_generation::generate_constraints(\n         infcx,\n@@ -205,6 +206,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     dump_mir_results(\n         infcx,\n         &liveness,\n+        &liveness_map,\n         MirSource::item(def_id),\n         &mir,\n         &regioncx,\n@@ -221,6 +223,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n fn dump_mir_results<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     liveness: &LivenessResults<LocalWithRegion>,\n+    liveness_map: &NllLivenessMap,\n     source: MirSource,\n     mir: &Mir<'tcx>,\n     regioncx: &RegionInferenceContext,\n@@ -230,16 +233,14 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n         return;\n     }\n \n-    let map = &NllLivenessMap::compute(mir);\n-\n     let regular_liveness_per_location: FxHashMap<_, _> = mir\n         .basic_blocks()\n         .indices()\n         .flat_map(|bb| {\n             let mut results = vec![];\n             liveness\n                 .regular\n-                .simulate_block(&mir, bb, map, |location, local_set| {\n+                .simulate_block(&mir, bb, liveness_map, |location, local_set| {\n                     results.push((location, local_set.clone()));\n                 });\n             results\n@@ -253,7 +254,7 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n             let mut results = vec![];\n             liveness\n                 .drop\n-                .simulate_block(&mir, bb, map, |location, local_set| {\n+                .simulate_block(&mir, bb, liveness_map, |location, local_set| {\n                     results.push((location, local_set.clone()));\n                 });\n             results"}, {"sha": "f7dfa5a7ae582a1798e15d77d45757798c5eb6e9", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0aa8d0320266b5579428312095fe49af05ada972/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa8d0320266b5579428312095fe49af05ada972/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=0aa8d0320266b5579428312095fe49af05ada972", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use super::universal_regions::UniversalRegions;\n-use borrow_check::nll::constraints::graph::ConstraintGraph;\n+use borrow_check::nll::constraints::graph::NormalConstraintGraph;\n use borrow_check::nll::constraints::{\n     ConstraintIndex, ConstraintSccIndex, ConstraintSet, OutlivesConstraint,\n };\n@@ -61,7 +61,7 @@ pub struct RegionInferenceContext<'tcx> {\n     /// The constraint-set, but in graph form, making it easy to traverse\n     /// the constraints adjacent to a particular region. Used to construct\n     /// the SCC (see `constraint_sccs`) and for error reporting.\n-    constraint_graph: Rc<ConstraintGraph>,\n+    constraint_graph: Rc<NormalConstraintGraph>,\n \n     /// The SCC computed from `constraints` and the constraint graph. Used to compute the values\n     /// of each region."}, {"sha": "89e8c76b22fb456ed31ec645f7e6b253c9d254f7", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/liveness_map.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/0aa8d0320266b5579428312095fe49af05ada972/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fliveness_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa8d0320266b5579428312095fe49af05ada972/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fliveness_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fliveness_map.rs?ref=0aa8d0320266b5579428312095fe49af05ada972", "patch": "@@ -0,0 +1,97 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! For the NLL computation, we need to compute liveness, but only for those\n+//! local variables whose types contain regions. The others are not of interest\n+//! to us. This file defines a new index type (LocalWithRegion) that indexes into\n+//! a list of \"variables whose type contain regions\". It also defines a map from\n+//! Local to LocalWithRegion and vice versa -- this map can be given to the\n+//! liveness code so that it only operates over variables with regions in their\n+//! types, instead of all variables.\n+\n+use borrow_check::nll::ToRegionVid;\n+use rustc::mir::{Local, Mir};\n+use rustc::ty::{RegionVid, TyCtxt};\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use util::liveness::LiveVariableMap;\n+\n+/// Map between Local and LocalWithRegion indices: the purpose of this\n+/// map is to define the subset of local variables for which we need\n+/// to do a liveness computation. We only need to compute whether a\n+/// variable `X` is live if that variable contains some region `R` in\n+/// its type where `R` is not known to outlive a free region (i.e.,\n+/// where `R` may be valid for just a subset of the fn body).\n+crate struct NllLivenessMap {\n+    /// For each local variable, contains `Some(i)` if liveness is\n+    /// needed for this variable.\n+    pub from_local: IndexVec<Local, Option<LocalWithRegion>>,\n+\n+    /// For each `LocalWithRegion`, maps back to the original `Local` index.\n+    pub to_local: IndexVec<LocalWithRegion, Local>,\n+}\n+\n+impl LiveVariableMap for NllLivenessMap {\n+    fn from_local(&self, local: Local) -> Option<Self::LiveVar> {\n+        self.from_local[local]\n+    }\n+\n+    type LiveVar = LocalWithRegion;\n+\n+    fn from_live_var(&self, local: Self::LiveVar) -> Local {\n+        self.to_local[local]\n+    }\n+\n+    fn num_variables(&self) -> usize {\n+        self.to_local.len()\n+    }\n+}\n+\n+impl NllLivenessMap {\n+    crate fn compute(\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        free_regions: &FxHashSet<RegionVid>,\n+        mir: &Mir<'tcx>,\n+    ) -> Self {\n+        let mut to_local = IndexVec::default();\n+        let from_local: IndexVec<Local, Option<_>> = mir.local_decls\n+            .iter_enumerated()\n+            .map(|(local, local_decl)| {\n+                if tcx.all_free_regions_meet(&local_decl.ty, |r| {\n+                    free_regions.contains(&r.to_region_vid())\n+                }) {\n+                    // If all the regions in the type are free regions\n+                    // (or there are no regions), then we don't need\n+                    // to track liveness for this variable.\n+                    None\n+                } else {\n+                    Some(to_local.push(local))\n+                }\n+            })\n+            .collect();\n+\n+        debug!(\"{} total variables\", mir.local_decls.len());\n+        debug!(\"{} variables need liveness\", to_local.len());\n+        debug!(\"{} regions outlive free regions\", free_regions.len());\n+\n+        Self {\n+            from_local,\n+            to_local,\n+        }\n+    }\n+\n+    /// True if there are no local variables that need liveness computation.\n+    crate fn is_empty(&self) -> bool {\n+        self.to_local.is_empty()\n+    }\n+}\n+\n+/// Index given to each local variable whose type contains a region.\n+newtype_index!(LocalWithRegion);"}, {"sha": "a9b69cfe761abc4dded3ee3da2ab797dc9b55b72", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/mod.rs", "status": "renamed", "additions": 81, "deletions": 18, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/0aa8d0320266b5579428312095fe49af05ada972/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa8d0320266b5579428312095fe49af05ada972/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs?ref=0aa8d0320266b5579428312095fe49af05ada972", "patch": "@@ -8,8 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::nll::{NllLivenessMap, LocalWithRegion};\n+use borrow_check::nll::constraints::ConstraintSet;\n use borrow_check::nll::type_check::AtLocation;\n+use borrow_check::nll::{LocalWithRegion, NllLivenessMap};\n+use borrow_check::nll::universal_regions::UniversalRegions;\n use dataflow::move_paths::{HasMoveData, MoveData};\n use dataflow::MaybeInitializedPlaces;\n use dataflow::{FlowAtLocation, FlowsAtLocation};\n@@ -18,13 +20,15 @@ use rustc::mir::{BasicBlock, Location, Mir};\n use rustc::traits::query::dropck_outlives::DropckOutlivesResult;\n use rustc::traits::query::type_op::outlives::DropckOutlives;\n use rustc::traits::query::type_op::TypeOp;\n-use rustc::ty::{Ty, TypeFoldable};\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc::ty::{RegionVid, Ty, TypeFoldable};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use std::rc::Rc;\n-use util::liveness::{LivenessResults, LiveVariableMap };\n+use util::liveness::{LiveVariableMap, LivenessResults};\n \n use super::TypeChecker;\n \n+crate mod liveness_map;\n+\n /// Combines liveness analysis with initialization analysis to\n /// determine which variables are live at which points, both due to\n /// ordinary uses and drops. Returns a set of (ty, location) pairs\n@@ -36,23 +40,77 @@ use super::TypeChecker;\n pub(super) fn generate<'gcx, 'tcx>(\n     cx: &mut TypeChecker<'_, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n-    liveness: &LivenessResults<LocalWithRegion>,\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n-) {\n-    let mut generator = TypeLivenessGenerator {\n-        cx,\n-        mir,\n-        liveness,\n-        flow_inits,\n-        move_data,\n-        drop_data: FxHashMap(),\n-        map: &NllLivenessMap::compute(mir),\n+) -> (LivenessResults<LocalWithRegion>, NllLivenessMap) {\n+    let free_regions = {\n+        let borrowck_context = cx.borrowck_context.as_ref().unwrap();\n+        regions_that_outlive_free_regions(\n+            cx.infcx.num_region_vars(),\n+            &borrowck_context.universal_regions,\n+            &borrowck_context.constraints.outlives_constraints,\n+        )\n     };\n+    let liveness_map = NllLivenessMap::compute(cx.tcx(), &free_regions, mir);\n+    let liveness = LivenessResults::compute(mir, &liveness_map);\n+\n+    // For everything else, it is only live where it is actually used.\n+    if !liveness_map.is_empty() {\n+        let mut generator = TypeLivenessGenerator {\n+            cx,\n+            mir,\n+            liveness: &liveness,\n+            flow_inits,\n+            move_data,\n+            drop_data: FxHashMap(),\n+            map: &liveness_map,\n+        };\n+\n+        for bb in mir.basic_blocks().indices() {\n+            generator.add_liveness_constraints(bb);\n+        }\n+    }\n+\n+    (liveness, liveness_map)\n+}\n+\n+/// Compute all regions that are (currently) known to outlive free\n+/// regions. For these regions, we do not need to compute\n+/// liveness, since the outlives constraints will ensure that they\n+/// are live over the whole fn body anyhow.\n+fn regions_that_outlive_free_regions(\n+    num_region_vars: usize,\n+    universal_regions: &UniversalRegions<'tcx>,\n+    constraint_set: &ConstraintSet,\n+) -> FxHashSet<RegionVid> {\n+    // Build a graph of the outlives constraints thus far. This is\n+    // a reverse graph, so for each constraint `R1: R2` we have an\n+    // edge `R2 -> R1`. Therefore, if we find all regions\n+    // reachable from each free region, we will have all the\n+    // regions that are forced to outlive some free region.\n+    let rev_constraint_graph = constraint_set.reverse_graph(num_region_vars);\n+    let rev_region_graph = rev_constraint_graph.region_graph(constraint_set);\n+\n+    // Stack for the depth-first search. Start out with all the free regions.\n+    let mut stack: Vec<_> = universal_regions.universal_regions().collect();\n \n-    for bb in mir.basic_blocks().indices() {\n-        generator.add_liveness_constraints(bb);\n+    // Set of all free regions, plus anything that outlives them. Initially\n+    // just contains the free regions.\n+    let mut outlives_free_region: FxHashSet<_> = stack.iter().cloned().collect();\n+\n+    // Do the DFS -- for each thing in the stack, find all things\n+    // that outlive it and add them to the set. If they are not,\n+    // push them onto the stack for later.\n+    while let Some(sub_region) = stack.pop() {\n+        stack.extend(\n+            rev_region_graph\n+                .outgoing_regions(sub_region)\n+                .filter(|&r| outlives_free_region.insert(r)),\n+        );\n     }\n+\n+    // Return the final set of things we visited.\n+    outlives_free_region\n }\n \n struct TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx>\n@@ -174,8 +232,13 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n \n         cx.tcx().for_each_free_region(&value, |live_region| {\n             if let Some(ref mut borrowck_context) = cx.borrowck_context {\n-                let region_vid = borrowck_context.universal_regions.to_region_vid(live_region);\n-                borrowck_context.constraints.liveness_constraints.add_element(region_vid, location);\n+                let region_vid = borrowck_context\n+                    .universal_regions\n+                    .to_region_vid(live_region);\n+                borrowck_context\n+                    .constraints\n+                    .liveness_constraints\n+                    .add_element(region_vid, location);\n \n                 if let Some(all_facts) = borrowck_context.all_facts {\n                     let start_index = borrowck_context.location_table.start_index(location);", "previous_filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs"}, {"sha": "eb689f0a9c6c9602f9e8c9f34009a125af601ca5", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0aa8d0320266b5579428312095fe49af05ada972/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa8d0320266b5579428312095fe49af05ada972/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=0aa8d0320266b5579428312095fe49af05ada972", "patch": "@@ -18,6 +18,7 @@ use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::values::{RegionValueElements, LivenessValues};\n use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n use borrow_check::nll::type_check::free_region_relations::{CreateResult, UniversalRegionRelations};\n+use borrow_check::nll::type_check::liveness::liveness_map::NllLivenessMap;\n use borrow_check::nll::universal_regions::UniversalRegions;\n use borrow_check::nll::LocalWithRegion;\n use borrow_check::nll::ToRegionVid;\n@@ -74,7 +75,7 @@ macro_rules! span_mirbug_and_err {\n mod constraint_conversion;\n pub mod free_region_relations;\n mod input_output;\n-mod liveness;\n+crate mod liveness;\n mod relate_tys;\n \n /// Type checks the given `mir` in the context of the inference\n@@ -115,16 +116,12 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n     universal_regions: &Rc<UniversalRegions<'tcx>>,\n     location_table: &LocationTable,\n     borrow_set: &BorrowSet<'tcx>,\n-    liveness: &LivenessResults<LocalWithRegion>,\n     all_facts: &mut Option<AllFacts>,\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     elements: &Rc<RegionValueElements>,\n     errors_buffer: &mut Vec<Diagnostic>,\n-) -> (\n-    MirTypeckRegionConstraints<'tcx>,\n-    Rc<UniversalRegionRelations<'tcx>>,\n-) {\n+) -> MirTypeckResults<'tcx> {\n     let implicit_region_bound = infcx.tcx.mk_region(ty::ReVar(universal_regions.fr_fn_body));\n     let mut constraints = MirTypeckRegionConstraints {\n         liveness_constraints: LivenessValues::new(elements),\n@@ -147,7 +144,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n         all_facts,\n     );\n \n-    {\n+    let (liveness, liveness_map) = {\n         let mut borrowck_context = BorrowCheckContext {\n             universal_regions,\n             location_table,\n@@ -166,22 +163,27 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n             Some(&mut borrowck_context),\n             Some(errors_buffer),\n             |cx| {\n-                liveness::generate(cx, mir, liveness, flow_inits, move_data);\n                 cx.equate_inputs_and_outputs(\n                     mir,\n                     mir_def_id,\n                     universal_regions,\n                     &universal_region_relations,\n                     &normalized_inputs_and_output,\n                 );\n+                liveness::generate(cx, mir, flow_inits, move_data)\n             },\n-        );\n-    }\n+        )\n+    };\n \n-    (constraints, universal_region_relations)\n+    MirTypeckResults {\n+        constraints,\n+        universal_region_relations,\n+        liveness,\n+        liveness_map,\n+    }\n }\n \n-fn type_check_internal<'a, 'gcx, 'tcx, F>(\n+fn type_check_internal<'a, 'gcx, 'tcx, R>(\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     mir_def_id: DefId,\n     param_env: ty::ParamEnv<'gcx>,\n@@ -190,10 +192,8 @@ fn type_check_internal<'a, 'gcx, 'tcx, F>(\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n     errors_buffer: Option<&mut Vec<Diagnostic>>,\n-    mut extra: F,\n-) where\n-    F: FnMut(&mut TypeChecker<'a, 'gcx, 'tcx>),\n-{\n+    mut extra: impl FnMut(&mut TypeChecker<'a, 'gcx, 'tcx>) -> R,\n+) -> R where {\n     let mut checker = TypeChecker::new(\n         infcx,\n         mir,\n@@ -214,7 +214,7 @@ fn type_check_internal<'a, 'gcx, 'tcx, F>(\n         checker.typeck_mir(mir, errors_buffer);\n     }\n \n-    extra(&mut checker);\n+    extra(&mut checker)\n }\n \n fn mirbug(tcx: TyCtxt, span: Span, msg: &str) {\n@@ -655,6 +655,13 @@ struct BorrowCheckContext<'a, 'tcx: 'a> {\n     constraints: &'a mut MirTypeckRegionConstraints<'tcx>,\n }\n \n+crate struct MirTypeckResults<'tcx> {\n+    crate constraints: MirTypeckRegionConstraints<'tcx>,\n+    crate universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n+    crate liveness: LivenessResults<LocalWithRegion>,\n+    crate liveness_map: NllLivenessMap,\n+}\n+\n /// A collection of region constraints that must be satisfied for the\n /// program to be considered well-typed.\n crate struct MirTypeckRegionConstraints<'tcx> {"}, {"sha": "be0091068c2e20326f77e64b1bc9d8e2d21cf7ce", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0aa8d0320266b5579428312095fe49af05ada972/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa8d0320266b5579428312095fe49af05ada972/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=0aa8d0320266b5579428312095fe49af05ada972", "patch": "@@ -15,16 +15,19 @@ use rustc::ty::{self, TyCtxt};\n \n /// Extension methods for the `Place` type.\n crate trait PlaceExt<'tcx> {\n-    /// True if this is a deref of a raw pointer.\n-    fn is_unsafe_place(&self, tcx: TyCtxt<'_, '_, 'tcx>, mir: &Mir<'tcx>) -> bool;\n+    /// Returns true if we can safely ignore borrows of this place.\n+    /// This is true whenever there is no action that the user can do\n+    /// to the place `self` that would invalidate the borrow. This is true\n+    /// for borrows of raw pointer dereferents as well as shared references.\n+    fn ignore_borrow(&self, tcx: TyCtxt<'_, '_, 'tcx>, mir: &Mir<'tcx>) -> bool;\n \n     /// If this is a place like `x.f.g`, returns the local\n     /// `x`. Returns `None` if this is based in a static.\n     fn root_local(&self) -> Option<Local>;\n }\n \n impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n-    fn is_unsafe_place(&self, tcx: TyCtxt<'_, '_, 'tcx>, mir: &Mir<'tcx>) -> bool {\n+    fn ignore_borrow(&self, tcx: TyCtxt<'_, '_, 'tcx>, mir: &Mir<'tcx>) -> bool {\n         match self {\n             Place::Promoted(_) |\n             Place::Local(_) => false,\n@@ -36,12 +39,23 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n                 | ProjectionElem::Downcast(..)\n                 | ProjectionElem::Subslice { .. }\n                 | ProjectionElem::ConstantIndex { .. }\n-                | ProjectionElem::Index(_) => proj.base.is_unsafe_place(tcx, mir),\n+                | ProjectionElem::Index(_) => proj.base.ignore_borrow(tcx, mir),\n+\n                 ProjectionElem::Deref => {\n                     let ty = proj.base.ty(mir, tcx).to_ty(tcx);\n                     match ty.sty {\n-                        ty::TyRawPtr(..) => true,\n-                        _ => proj.base.is_unsafe_place(tcx, mir),\n+                        // For both derefs of raw pointers and `&T`\n+                        // references, the original path is `Copy` and\n+                        // therefore not significant.  In particular,\n+                        // there is nothing the user can do to the\n+                        // original path that would invalidate the\n+                        // newly created reference -- and if there\n+                        // were, then the user could have copied the\n+                        // original path into a new variable and\n+                        // borrowed *that* one, leaving the original\n+                        // path unborrowed.\n+                        ty::TyRawPtr(..) | ty::TyRef(_, _, hir::MutImmutable) => true,\n+                        _ => proj.base.ignore_borrow(tcx, mir),\n                     }\n                 }\n             },"}, {"sha": "b0c4d37814e8b02b84118cfb0edf36e8a21f5b78", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aa8d0320266b5579428312095fe49af05ada972/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa8d0320266b5579428312095fe49af05ada972/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=0aa8d0320266b5579428312095fe49af05ada972", "patch": "@@ -233,7 +233,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                 // propagate_call_return method.\n \n                 if let mir::Rvalue::Ref(region, _, ref place) = *rhs {\n-                    if place.is_unsafe_place(self.tcx, self.mir) { return; }\n+                    if place.ignore_borrow(self.tcx, self.mir) { return; }\n                     let index = self.borrow_set.location_map.get(&location).unwrap_or_else(|| {\n                         panic!(\"could not find BorrowIndex for location {:?}\", location);\n                     });"}, {"sha": "52f1547bce6f86f33b7bcd359e41186aef326d06", "filename": "src/test/ui/borrowck/promote-ref-mut-in-let-issue-46557.nll.stderr", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0aa8d0320266b5579428312095fe49af05ada972/src%2Ftest%2Fui%2Fborrowck%2Fpromote-ref-mut-in-let-issue-46557.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0aa8d0320266b5579428312095fe49af05ada972/src%2Ftest%2Fui%2Fborrowck%2Fpromote-ref-mut-in-let-issue-46557.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fpromote-ref-mut-in-let-issue-46557.nll.stderr?ref=0aa8d0320266b5579428312095fe49af05ada972", "patch": "@@ -1,30 +1,24 @@\n error[E0597]: borrowed value does not live long enough\n   --> $DIR/promote-ref-mut-in-let-issue-46557.rs:15:21\n    |\n-LL |   fn gimme_static_mut_let() -> &'static mut u32 {\n-   |  _______________________________________________-\n-LL | |     let ref mut x = 1234543; //~ ERROR\n-   | |                     ^^^^^^^ temporary value does not live long enough\n-LL | |     x\n-LL | | }\n-   | | -\n-   | | |\n-   | |_temporary value only lives until here\n-   |   borrow later used here\n+LL |     let ref mut x = 1234543; //~ ERROR\n+   |                     ^^^^^^^ temporary value does not live long enough\n+LL |     x\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n \n error[E0597]: borrowed value does not live long enough\n   --> $DIR/promote-ref-mut-in-let-issue-46557.rs:20:25\n    |\n-LL |   fn gimme_static_mut_let_nested() -> &'static mut u32 {\n-   |  ______________________________________________________-\n-LL | |     let (ref mut x, ) = (1234543, ); //~ ERROR\n-   | |                         ^^^^^^^^^^^ temporary value does not live long enough\n-LL | |     x\n-LL | | }\n-   | | -\n-   | | |\n-   | |_temporary value only lives until here\n-   |   borrow later used here\n+LL |     let (ref mut x, ) = (1234543, ); //~ ERROR\n+   |                         ^^^^^^^^^^^ temporary value does not live long enough\n+LL |     x\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n \n error[E0597]: borrowed value does not live long enough\n   --> $DIR/promote-ref-mut-in-let-issue-46557.rs:25:11"}, {"sha": "580dce3c0fe632691f65bc1d8d35d1e153275397", "filename": "src/test/ui/nll/get_default.nll.stderr", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0aa8d0320266b5579428312095fe49af05ada972/src%2Ftest%2Fui%2Fnll%2Fget_default.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0aa8d0320266b5579428312095fe49af05ada972/src%2Ftest%2Fui%2Fnll%2Fget_default.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fget_default.nll.stderr?ref=0aa8d0320266b5579428312095fe49af05ada972", "patch": "@@ -63,9 +63,18 @@ LL |         match map.get() {\n LL |             Some(v) => {\n LL |                 map.set(String::new()); // Both AST and MIR error here\n    |                 ^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n-...\n-LL |                 return v;\n-   |                        - borrow later used here\n+   |\n+note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 41:1...\n+  --> $DIR/get_default.rs:41:1\n+   |\n+LL | / fn err(map: &mut Map) -> &String {\n+LL | |     loop {\n+LL | |         match map.get() {\n+LL | |             Some(v) => {\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n \n error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Mir)\n   --> $DIR/get_default.rs:51:17"}, {"sha": "2f8eab907c7bb5185353420d28460e9ac2cd38e6", "filename": "src/test/ui/nll/get_default.stderr", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0aa8d0320266b5579428312095fe49af05ada972/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0aa8d0320266b5579428312095fe49af05ada972/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr?ref=0aa8d0320266b5579428312095fe49af05ada972", "patch": "@@ -63,9 +63,18 @@ LL |         match map.get() {\n LL |             Some(v) => {\n LL |                 map.set(String::new()); // Both AST and MIR error here\n    |                 ^^^ mutable borrow occurs here\n-...\n-LL |                 return v;\n-   |                        - borrow later used here\n+   |\n+note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 41:1...\n+  --> $DIR/get_default.rs:41:1\n+   |\n+LL | / fn err(map: &mut Map) -> &String {\n+LL | |     loop {\n+LL | |         match map.get() {\n+LL | |             Some(v) => {\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n \n error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Mir)\n   --> $DIR/get_default.rs:51:17"}, {"sha": "f441085f242edddc102c2078ba1fd1691134b523", "filename": "src/test/ui/nll/return-ref-mut-issue-46557.stderr", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0aa8d0320266b5579428312095fe49af05ada972/src%2Ftest%2Fui%2Fnll%2Freturn-ref-mut-issue-46557.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0aa8d0320266b5579428312095fe49af05ada972/src%2Ftest%2Fui%2Fnll%2Freturn-ref-mut-issue-46557.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Freturn-ref-mut-issue-46557.stderr?ref=0aa8d0320266b5579428312095fe49af05ada972", "patch": "@@ -1,16 +1,13 @@\n error[E0597]: borrowed value does not live long enough\n   --> $DIR/return-ref-mut-issue-46557.rs:17:21\n    |\n-LL |   fn gimme_static_mut() -> &'static mut u32 {\n-   |  ___________________________________________-\n-LL | |     let ref mut x = 1234543; //~ ERROR borrowed value does not live long enough [E0597]\n-   | |                     ^^^^^^^ temporary value does not live long enough\n-LL | |     x\n-LL | | }\n-   | | -\n-   | | |\n-   | |_temporary value only lives until here\n-   |   borrow later used here\n+LL |     let ref mut x = 1234543; //~ ERROR borrowed value does not live long enough [E0597]\n+   |                     ^^^^^^^ temporary value does not live long enough\n+LL |     x\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n \n error: aborting due to previous error\n "}]}