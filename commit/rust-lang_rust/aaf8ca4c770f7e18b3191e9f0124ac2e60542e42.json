{"sha": "aaf8ca4c770f7e18b3191e9f0124ac2e60542e42", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhZjhjYTRjNzcwZjdlMThiMzE5MWU5ZjAxMjRhYzJlNjA1NDJlNDI=", "commit": {"author": {"name": "JCTyBlaidd", "email": "JCTyblaidd@users.noreply.github.com", "date": "2020-12-09T13:35:42Z"}, "committer": {"name": "JCTyblaidd", "email": "JCTyblaidd@users.noreply.github.com", "date": "2020-12-13T11:04:58Z"}, "message": "Fix review changes", "tree": {"sha": "84b72b7d86523a82c7b62a72ad5c1265a29eb2b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84b72b7d86523a82c7b62a72ad5c1265a29eb2b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42", "html_url": "https://github.com/rust-lang/rust/commit/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/comments", "author": {"login": "JCTyblaidd", "id": 8288600, "node_id": "MDQ6VXNlcjgyODg2MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8288600?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JCTyblaidd", "html_url": "https://github.com/JCTyblaidd", "followers_url": "https://api.github.com/users/JCTyblaidd/followers", "following_url": "https://api.github.com/users/JCTyblaidd/following{/other_user}", "gists_url": "https://api.github.com/users/JCTyblaidd/gists{/gist_id}", "starred_url": "https://api.github.com/users/JCTyblaidd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JCTyblaidd/subscriptions", "organizations_url": "https://api.github.com/users/JCTyblaidd/orgs", "repos_url": "https://api.github.com/users/JCTyblaidd/repos", "events_url": "https://api.github.com/users/JCTyblaidd/events{/privacy}", "received_events_url": "https://api.github.com/users/JCTyblaidd/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JCTyblaidd", "id": 8288600, "node_id": "MDQ6VXNlcjgyODg2MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8288600?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JCTyblaidd", "html_url": "https://github.com/JCTyblaidd", "followers_url": "https://api.github.com/users/JCTyblaidd/followers", "following_url": "https://api.github.com/users/JCTyblaidd/following{/other_user}", "gists_url": "https://api.github.com/users/JCTyblaidd/gists{/gist_id}", "starred_url": "https://api.github.com/users/JCTyblaidd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JCTyblaidd/subscriptions", "organizations_url": "https://api.github.com/users/JCTyblaidd/orgs", "repos_url": "https://api.github.com/users/JCTyblaidd/repos", "events_url": "https://api.github.com/users/JCTyblaidd/events{/privacy}", "received_events_url": "https://api.github.com/users/JCTyblaidd/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e74f9f013f6093a4f1cb601667a07aadac75b42", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e74f9f013f6093a4f1cb601667a07aadac75b42", "html_url": "https://github.com/rust-lang/rust/commit/4e74f9f013f6093a4f1cb601667a07aadac75b42"}], "stats": {"total": 128, "additions": 107, "deletions": 21}, "files": [{"sha": "2fff13a80661d42955c3fb3cb544d33562ae84e3", "filename": "src/data_race.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/src%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/src%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdata_race.rs?ref=aaf8ca4c770f7e18b3191e9f0124ac2e60542e42", "patch": "@@ -9,6 +9,9 @@\n //! Relaxed stores now unconditionally block all currently active release sequences and so per-thread tracking of release\n //! sequences is not needed.\n //!\n+//! The implementation also models races with memory allocation and deallocation via treating allocation and\n+//! deallocation as a type of write internally for detecting data-races.\n+//!\n //! This does not explore weak memory orders and so can still miss data-races\n //! but should not report false-positives\n //!\n@@ -192,13 +195,22 @@ struct AtomicMemoryCellClocks {\n     sync_vector: VClock,\n }\n \n+/// Type of write operation: allocating memory\n+/// non-atomic writes and deallocating memory\n+/// are all treated as writes for the purpose\n+/// of the data-race detector.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum WriteType {\n     /// Allocate memory.\n     Allocate,\n+\n     /// Standard unsynchronized write.\n     Write,\n-    /// Deallocate memory\n+\n+    /// Deallocate memory.\n+    /// Some races with deallocation will be missed and instead\n+    /// reported as invalid accesses of freed memory due to\n+    /// the order of checks.\n     Deallocate,\n }\n impl WriteType {\n@@ -681,7 +693,7 @@ impl VClockAlloc {\n             let (alloc_index, clocks) = global.current_thread_state();\n             let alloc_timestamp = clocks.clock[alloc_index];\n             (alloc_timestamp, alloc_index)\n-        }else{\n+        } else {\n             (0, VectorIdx::MAX_INDEX)\n         };\n         VClockAlloc {\n@@ -695,7 +707,7 @@ impl VClockAlloc {\n     // Find an index, if one exists where the value\n     // in `l` is greater than the value in `r`.\n     fn find_gt_index(l: &VClock, r: &VClock) -> Option<VectorIdx> {\n-        log::info!(\"Find index where not {:?} <= {:?}\", l, r);\n+        log::trace!(\"Find index where not {:?} <= {:?}\", l, r);\n         let l_slice = l.as_slice();\n         let r_slice = r.as_slice();\n         l_slice\n@@ -1168,7 +1180,7 @@ impl GlobalState {\n             vector_info.push(thread)\n         };\n \n-        log::info!(\"Creating thread = {:?} with vector index = {:?}\", thread, created_index);\n+        log::trace!(\"Creating thread = {:?} with vector index = {:?}\", thread, created_index);\n \n         // Mark the chosen vector index as in use by the thread.\n         thread_info[thread].vector_index = Some(created_index);"}, {"sha": "9825467a2cae16de37d11a8f3c3ce7eea0b1fb6b", "filename": "src/machine.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=aaf8ca4c770f7e18b3191e9f0124ac2e60542e42", "patch": "@@ -480,7 +480,10 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         let race_alloc = if let Some(data_race) = &memory_extra.data_race {\n             match kind {\n                 // V-Table generation is lazy and so racy, so do not track races.\n-                // Also V-Tables are read only so no data races can be detected.\n+                // Also V-Tables are read only so no data races can be occur.\n+                // Must be disabled since V-Tables are initialized via interpreter\n+                // writes on demand and can incorrectly cause the data-race detector\n+                // to trigger.\n                 MemoryKind::Vtable => None,\n                 // User allocated and stack memory should track allocation.\n                 MemoryKind::Machine("}, {"sha": "fc1e9d30e637ab8a9ec5b4d3c4ca75bcdc15e09f", "filename": "tests/compile-fail/data_race/alloc_read_race.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/tests%2Fcompile-fail%2Fdata_race%2Falloc_read_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/tests%2Fcompile-fail%2Fdata_race%2Falloc_read_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Falloc_read_race.rs?ref=aaf8ca4c770f7e18b3191e9f0124ac2e60542e42", "patch": "@@ -3,6 +3,7 @@\n use std::thread::spawn;\n use std::ptr::null_mut;\n use std::sync::atomic::{Ordering, AtomicPtr};\n+use std::mem::MaybeUninit;\n \n #[derive(Copy, Clone)]\n struct EvilSend<T>(pub T);\n@@ -12,8 +13,8 @@ unsafe impl<T> Sync for EvilSend<T> {}\n \n pub fn main() {\n     // Shared atomic pointer\n-    let pointer = AtomicPtr::new(null_mut::<usize>());\n-    let ptr = EvilSend(&pointer as *const AtomicPtr<usize>);\n+    let pointer = AtomicPtr::new(null_mut::<MaybeUninit<usize>>());\n+    let ptr = EvilSend(&pointer as *const AtomicPtr<MaybeUninit<usize>>);\n \n     // Note: this is scheduler-dependent\n     // the operations need to occur in\n@@ -28,14 +29,14 @@ pub fn main() {\n             // Uses relaxed semantics to not generate\n             // a release sequence.\n             let pointer = &*ptr.0;\n-            pointer.store(Box::into_raw(Box::new(0usize)), Ordering::Relaxed);\n+            pointer.store(Box::into_raw(Box::new(MaybeUninit::uninit())), Ordering::Relaxed);\n         });\n \n         let j2 = spawn(move || {\n             let pointer = &*ptr.0;\n \n-            //Note detects with write due to the initialization of memory\n-            *pointer.load(Ordering::Relaxed) //~ ERROR Data race detected between Read on Thread(id = 2) and Write on Thread(id = 1)\n+            // Note: could also error due to reading uninitialized memory, but the data-race detector triggers first.\n+            *pointer.load(Ordering::Relaxed) //~ ERROR Data race detected between Read on Thread(id = 2) and Allocate on Thread(id = 1)\n         });\n \n         j1.join().unwrap();"}, {"sha": "ad539ec5b08398c5de432323cc4a956abab5f2b1", "filename": "tests/compile-fail/data_race/dangling_thread_async_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/tests%2Fcompile-fail%2Fdata_race%2Fdangling_thread_async_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/tests%2Fcompile-fail%2Fdata_race%2Fdangling_thread_async_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fdangling_thread_async_race.rs?ref=aaf8ca4c770f7e18b3191e9f0124ac2e60542e42", "patch": "@@ -26,7 +26,7 @@ fn main() {\n \n     // Detach the thread and sleep until it terminates\n     mem::drop(join);\n-    sleep(Duration::from_millis(1000));\n+    sleep(Duration::from_millis(200));\n \n     // Spawn and immediately join a thread\n     // to execute the join code-path"}, {"sha": "755ba8efdae957412b45c42d3942c0d761a57c5f", "filename": "tests/compile-fail/data_race/dangling_thread_race.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/tests%2Fcompile-fail%2Fdata_race%2Fdangling_thread_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/tests%2Fcompile-fail%2Fdata_race%2Fdangling_thread_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fdangling_thread_race.rs?ref=aaf8ca4c770f7e18b3191e9f0124ac2e60542e42", "patch": "@@ -24,9 +24,9 @@ fn main() {\n         })\n     };\n \n-    // Detatch the thread and sleep until it terminates\n+    // Detach the thread and sleep until it terminates\n     mem::drop(join);\n-    sleep(Duration::from_millis(1000));\n+    sleep(Duration::from_millis(200));\n \n     // Spawn and immediately join a thread\n     // to execute the join code-path"}, {"sha": "14b02e95cc2330b5ce769af108f6e80035c51737", "filename": "tests/compile-fail/data_race/dealloc_read_race1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race1.rs?ref=aaf8ca4c770f7e18b3191e9f0124ac2e60542e42", "previous_filename": "tests/compile-fail/data_race/dealloc_read_race.rs"}, {"sha": "a4bf210ef439f24acb96fc71ffc2ff658961a626", "filename": "tests/compile-fail/data_race/dealloc_read_race2.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race2.rs?ref=aaf8ca4c770f7e18b3191e9f0124ac2e60542e42", "patch": "@@ -0,0 +1,34 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+\n+use std::thread::spawn;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+extern \"Rust\" {\n+    fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize);\n+}\n+\n+pub fn main() {\n+    // Shared atomic pointer\n+    let pointer: *mut usize = Box::into_raw(Box::new(0usize));\n+    let ptr = EvilSend(pointer);\n+\n+    unsafe {\n+        let j1 = spawn(move || {\n+            __rust_dealloc(ptr.0 as *mut _, std::mem::size_of::<usize>(), std::mem::align_of::<usize>())\n+        });\n+\n+        let j2 = spawn(move || {\n+            // Also an error of the form: Data race detected between Read on Thread(id = 2) and Deallocate on Thread(id = 1) \n+            // but the invalid allocation is detected first.\n+            *ptr.0 //~ ERROR dereferenced after this allocation got freed\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+    }\n+}"}, {"sha": "31960fb2162bf781a208ff857a8b45657de94a7f", "filename": "tests/compile-fail/data_race/dealloc_read_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race_stack.rs?ref=aaf8ca4c770f7e18b3191e9f0124ac2e60542e42", "patch": "@@ -36,7 +36,7 @@ pub fn main() {\n \n                 pointer.store(&mut stack_var as *mut _, Ordering::Release);\n \n-                sleep(Duration::from_millis(1000));\n+                sleep(Duration::from_millis(200));\n \n             } //~ ERROR Data race detected between Deallocate on Thread(id = 1) and Read on Thread(id = 2)\n         });"}, {"sha": "44950a34db2f855ba29e39f0b8dc1cb31c3a7165", "filename": "tests/compile-fail/data_race/dealloc_read_race_stack_drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race_stack_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race_stack_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race_stack_drop.rs?ref=aaf8ca4c770f7e18b3191e9f0124ac2e60542e42", "patch": "@@ -36,7 +36,7 @@ pub fn main() {\n \n             pointer.store(&mut stack_var as *mut _, Ordering::Release);\n \n-            sleep(Duration::from_millis(1000));\n+            sleep(Duration::from_millis(200));\n \n             drop(stack_var);\n         });  //~ ERROR Data race detected between Deallocate on Thread(id = 1) and Read on Thread(id = 2)"}, {"sha": "edcdfffdb5f53b5443545cc1707c1f3dcbce094c", "filename": "tests/compile-fail/data_race/dealloc_write_race1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race1.rs?ref=aaf8ca4c770f7e18b3191e9f0124ac2e60542e42", "previous_filename": "tests/compile-fail/data_race/dealloc_write_race.rs"}, {"sha": "20c05fa8f17bcfe91612cf7979cb2308d414b7b1", "filename": "tests/compile-fail/data_race/dealloc_write_race2.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race2.rs?ref=aaf8ca4c770f7e18b3191e9f0124ac2e60542e42", "patch": "@@ -0,0 +1,33 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+\n+use std::thread::spawn;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+extern \"Rust\" {\n+    fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize);\n+}\n+pub fn main() {\n+    // Shared atomic pointer\n+    let pointer: *mut usize = Box::into_raw(Box::new(0usize));\n+    let ptr = EvilSend(pointer);\n+\n+    unsafe {\n+        let j1 = spawn(move || {\n+            __rust_dealloc(ptr.0 as *mut _, std::mem::size_of::<usize>(), std::mem::align_of::<usize>());\n+        });\n+\n+        let j2 = spawn(move || {\n+            // Also an error of the form: Data race detected between Write on Thread(id = 2) and Deallocate on Thread(id = 1)\n+            // but the invalid allocation is detected first.\n+            *ptr.0 = 2; //~ ERROR dereferenced after this allocation got freed\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+    }\n+}"}, {"sha": "25dea65fe7e09019e6cfcd577e5d6f9ea10a2de0", "filename": "tests/compile-fail/data_race/dealloc_write_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race_stack.rs?ref=aaf8ca4c770f7e18b3191e9f0124ac2e60542e42", "patch": "@@ -36,7 +36,7 @@ pub fn main() {\n \n                 pointer.store(&mut stack_var as *mut _, Ordering::Release);\n \n-                sleep(Duration::from_millis(1000));\n+                sleep(Duration::from_millis(200));\n \n             } //~ ERROR Data race detected between Deallocate on Thread(id = 1) and Write on Thread(id = 2)\n         });"}, {"sha": "1d239e9eb74d02f69d06bb1af8fdaa965c8bda9f", "filename": "tests/compile-fail/data_race/dealloc_write_race_stack_drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race_stack_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race_stack_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race_stack_drop.rs?ref=aaf8ca4c770f7e18b3191e9f0124ac2e60542e42", "patch": "@@ -36,7 +36,7 @@ pub fn main() {\n \n             pointer.store(&mut stack_var as *mut _, Ordering::Release);\n             \n-            sleep(Duration::from_millis(1000));\n+            sleep(Duration::from_millis(200));\n \n             // Note: Implicit read for drop(_) races with write, would detect race with deallocate after.\n             drop(stack_var); //~ ERROR Data race detected between Read on Thread(id = 1) and Write on Thread(id = 2)"}, {"sha": "0cf915cdef2b1fd868ccc9a0d30ec0c053b1adc7", "filename": "tests/compile-fail/data_race/read_write_race_stack.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/tests%2Fcompile-fail%2Fdata_race%2Fread_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/tests%2Fcompile-fail%2Fdata_race%2Fread_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fread_write_race_stack.rs?ref=aaf8ca4c770f7e18b3191e9f0124ac2e60542e42", "patch": "@@ -1,6 +1,9 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n // compile-flags: -Zmiri-disable-isolation -Zmir-opt-level=0\n \n+// Note: mir-opt-level set to 0 to prevent the read of stack_var in thread 1\n+// from being optimized away and preventing the detection of the data-race.\n+\n use std::thread::{spawn, sleep};\n use std::ptr::null_mut;\n use std::sync::atomic::{Ordering, AtomicPtr};\n@@ -38,7 +41,7 @@ pub fn main() {\n \n             pointer.store(&mut stack_var as *mut _, Ordering::Release);\n             \n-            sleep(Duration::from_millis(1000));\n+            sleep(Duration::from_millis(200));\n \n             stack_var //~ ERROR Data race detected between Read on Thread(id = 1) and Write on Thread(id = 2)\n         });"}, {"sha": "29c428b388d430ecb4025e896cd822b1d03f8fd9", "filename": "tests/compile-fail/data_race/release_seq_race.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/tests%2Fcompile-fail%2Fdata_race%2Frelease_seq_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/tests%2Fcompile-fail%2Fdata_race%2Frelease_seq_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Frelease_seq_race.rs?ref=aaf8ca4c770f7e18b3191e9f0124ac2e60542e42", "patch": "@@ -30,7 +30,7 @@ pub fn main() {\n         let j1 = spawn(move || {\n             *c.0 = 1;\n             SYNC.store(1, Ordering::Release);\n-            sleep(Duration::from_millis(1000));\n+            sleep(Duration::from_millis(200));\n             SYNC.store(3, Ordering::Relaxed);\n         });\n \n@@ -40,7 +40,7 @@ pub fn main() {\n         });\n \n         let j3 = spawn(move || {\n-            sleep(Duration::from_millis(5000));\n+            sleep(Duration::from_millis(500));\n             if SYNC.load(Ordering::Acquire) == 3 {\n                 *c.0 //~ ERROR Data race detected between Read on Thread(id = 3) and Write on Thread(id = 1)\n             } else {"}, {"sha": "aa1428f8a74b7522e86f177b6cd9ec2c6f3ceda0", "filename": "tests/compile-fail/data_race/write_write_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/tests%2Fcompile-fail%2Fdata_race%2Fwrite_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaf8ca4c770f7e18b3191e9f0124ac2e60542e42/tests%2Fcompile-fail%2Fdata_race%2Fwrite_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fwrite_write_race_stack.rs?ref=aaf8ca4c770f7e18b3191e9f0124ac2e60542e42", "patch": "@@ -38,7 +38,7 @@ pub fn main() {\n \n             pointer.store(&mut stack_var as *mut _, Ordering::Release);\n             \n-            sleep(Duration::from_millis(1000));\n+            sleep(Duration::from_millis(200));\n \n             stack_var = 1usize; //~ ERROR Data race detected between Write on Thread(id = 1) and Write on Thread(id = 2)\n             "}]}