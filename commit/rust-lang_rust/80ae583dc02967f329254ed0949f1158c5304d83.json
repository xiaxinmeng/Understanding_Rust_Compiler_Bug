{"sha": "80ae583dc02967f329254ed0949f1158c5304d83", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwYWU1ODNkYzAyOTY3ZjMyOTI1NGVkMDk0OWYxMTU4YzUzMDRkODM=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-02-01T12:20:35Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-02-01T12:33:18Z"}, "message": "Use body lowering for block_def_map tests\n\nRemoves the hacky and buggy custom lowering code", "tree": {"sha": "af470e5fe493caed21a3afd64b12e6cb93a55f44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af470e5fe493caed21a3afd64b12e6cb93a55f44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80ae583dc02967f329254ed0949f1158c5304d83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80ae583dc02967f329254ed0949f1158c5304d83", "html_url": "https://github.com/rust-lang/rust/commit/80ae583dc02967f329254ed0949f1158c5304d83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80ae583dc02967f329254ed0949f1158c5304d83/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cc7d57429542a547f2ea57cf99e370b67e24564", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cc7d57429542a547f2ea57cf99e370b67e24564", "html_url": "https://github.com/rust-lang/rust/commit/9cc7d57429542a547f2ea57cf99e370b67e24564"}], "stats": {"total": 185, "additions": 117, "deletions": 68}, "files": [{"sha": "da60072ceb37fc7540e0c6793aef46af022f2945", "filename": "crates/hir_def/src/body/tests.rs", "status": "modified", "additions": 114, "deletions": 2, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/80ae583dc02967f329254ed0949f1158c5304d83/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ae583dc02967f329254ed0949f1158c5304d83/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests.rs?ref=80ae583dc02967f329254ed0949f1158c5304d83", "patch": "@@ -1,7 +1,10 @@\n-use base_db::{fixture::WithFixture, SourceDatabase};\n+mod block;\n+\n+use base_db::{fixture::WithFixture, FilePosition, SourceDatabase};\n+use expect_test::Expect;\n use test_utils::mark;\n \n-use crate::{test_db::TestDB, ModuleDefId};\n+use crate::{test_db::TestDB, BlockId, ModuleDefId};\n \n use super::*;\n \n@@ -31,6 +34,115 @@ fn check_diagnostics(ra_fixture: &str) {\n     db.check_diagnostics();\n }\n \n+fn block_def_map_at(ra_fixture: &str) -> Arc<DefMap> {\n+    let (db, position) = crate::test_db::TestDB::with_position(ra_fixture);\n+\n+    let krate = db.crate_graph().iter().next().unwrap();\n+    let def_map = db.crate_def_map(krate);\n+\n+    let mut block =\n+        block_at_pos(&db, &def_map, position).expect(\"couldn't find enclosing function or block\");\n+    loop {\n+        let def_map = db.block_def_map(block);\n+        let new_block = block_at_pos(&db, &def_map, position);\n+        match new_block {\n+            Some(new_block) => {\n+                assert_ne!(block, new_block);\n+                block = new_block;\n+            }\n+            None => {\n+                return def_map;\n+            }\n+        }\n+    }\n+}\n+\n+fn block_at_pos(db: &dyn DefDatabase, def_map: &DefMap, position: FilePosition) -> Option<BlockId> {\n+    let mut size = None;\n+    let mut fn_def = None;\n+    for (_, module) in def_map.modules() {\n+        let file_id = module.definition_source(db).file_id;\n+        if file_id != position.file_id.into() {\n+            continue;\n+        }\n+        let root = db.parse_or_expand(file_id).unwrap();\n+        let ast_map = db.ast_id_map(file_id);\n+        let item_tree = db.item_tree(file_id);\n+        for decl in module.scope.declarations() {\n+            if let ModuleDefId::FunctionId(it) = decl {\n+                let ast = ast_map.get(item_tree[it.lookup(db).id.value].ast_id).to_node(&root);\n+                let range = ast.syntax().text_range();\n+\n+                // Find the smallest (innermost) function containing the cursor.\n+                if !range.contains(position.offset) {\n+                    continue;\n+                }\n+\n+                let new_size = match size {\n+                    None => range.len(),\n+                    Some(size) => {\n+                        if range.len() < size {\n+                            range.len()\n+                        } else {\n+                            size\n+                        }\n+                    }\n+                };\n+                if size != Some(new_size) {\n+                    size = Some(new_size);\n+                    fn_def = Some(it);\n+                }\n+            }\n+        }\n+    }\n+\n+    let (body, source_map) = db.body_with_source_map(fn_def?.into());\n+\n+    // Now find the smallest encompassing block expression in the function body.\n+    let mut size = None;\n+    let mut block_id = None;\n+    for (expr_id, expr) in body.exprs.iter() {\n+        if let Expr::Block { id, .. } = expr {\n+            if let Ok(ast) = source_map.expr_syntax(expr_id) {\n+                if ast.file_id != position.file_id.into() {\n+                    continue;\n+                }\n+\n+                let root = db.parse_or_expand(ast.file_id).unwrap();\n+                let ast = ast.value.to_node(&root);\n+                let range = ast.syntax().text_range();\n+\n+                if !range.contains(position.offset) {\n+                    continue;\n+                }\n+\n+                let new_size = match size {\n+                    None => range.len(),\n+                    Some(size) => {\n+                        if range.len() < size {\n+                            range.len()\n+                        } else {\n+                            size\n+                        }\n+                    }\n+                };\n+                if size != Some(new_size) {\n+                    size = Some(new_size);\n+                    block_id = Some(*id);\n+                }\n+            }\n+        }\n+    }\n+\n+    Some(block_id.expect(\"can't find block containing cursor\"))\n+}\n+\n+fn check_at(ra_fixture: &str, expect: Expect) {\n+    let def_map = block_def_map_at(ra_fixture);\n+    let actual = def_map.dump();\n+    expect.assert_eq(&actual);\n+}\n+\n #[test]\n fn your_stack_belongs_to_me() {\n     mark::check!(your_stack_belongs_to_me);"}, {"sha": "6b1ed2555752b700b6ddd2a281bc805e13b7406b", "filename": "crates/hir_def/src/body/tests/block.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ae583dc02967f329254ed0949f1158c5304d83/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ae583dc02967f329254ed0949f1158c5304d83/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests%2Fblock.rs?ref=80ae583dc02967f329254ed0949f1158c5304d83", "patch": "@@ -1,4 +1,5 @@\n use super::*;\n+use expect_test::expect;\n \n #[test]\n fn inner_item_smoke() {", "previous_filename": "crates/hir_def/src/nameres/tests/block.rs"}, {"sha": "723481c367fc243caa9403f36f7c7f71289efcc7", "filename": "crates/hir_def/src/nameres/tests.rs", "status": "modified", "additions": 2, "deletions": 66, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/80ae583dc02967f329254ed0949f1158c5304d83/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ae583dc02967f329254ed0949f1158c5304d83/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests.rs?ref=80ae583dc02967f329254ed0949f1158c5304d83", "patch": "@@ -4,91 +4,27 @@ mod macros;\n mod mod_resolution;\n mod diagnostics;\n mod primitives;\n-mod block;\n \n use std::sync::Arc;\n \n-use base_db::{fixture::WithFixture, FilePosition, SourceDatabase};\n+use base_db::{fixture::WithFixture, SourceDatabase};\n use expect_test::{expect, Expect};\n-use syntax::AstNode;\n use test_utils::mark;\n \n-use crate::{db::DefDatabase, nameres::*, test_db::TestDB, Lookup};\n+use crate::{db::DefDatabase, nameres::*, test_db::TestDB};\n \n fn compute_crate_def_map(ra_fixture: &str) -> Arc<DefMap> {\n     let db = TestDB::with_files(ra_fixture);\n     let krate = db.crate_graph().iter().next().unwrap();\n     db.crate_def_map(krate)\n }\n \n-fn compute_block_def_map(ra_fixture: &str) -> Arc<DefMap> {\n-    let (db, position) = TestDB::with_position(ra_fixture);\n-\n-    // FIXME: perhaps we should make this use body lowering tests instead?\n-\n-    let module = db.module_for_file(position.file_id);\n-    let mut def_map = db.crate_def_map(module.krate);\n-    while let Some(new_def_map) = descend_def_map_at_position(&db, position, def_map.clone()) {\n-        def_map = new_def_map;\n-    }\n-\n-    // FIXME: select the right module, not the root\n-\n-    def_map\n-}\n-\n-fn descend_def_map_at_position(\n-    db: &dyn DefDatabase,\n-    position: FilePosition,\n-    def_map: Arc<DefMap>,\n-) -> Option<Arc<DefMap>> {\n-    for (local_id, module_data) in def_map.modules() {\n-        let mod_def = module_data.origin.definition_source(db);\n-        let ast_map = db.ast_id_map(mod_def.file_id);\n-        let item_tree = db.item_tree(mod_def.file_id);\n-        let root = db.parse_or_expand(mod_def.file_id).unwrap();\n-        for item in module_data.scope.declarations() {\n-            match item {\n-                ModuleDefId::FunctionId(it) => {\n-                    // Technically blocks can be inside any type (due to arrays and const generics),\n-                    // and also in const/static initializers. For tests we only really care about\n-                    // functions though.\n-\n-                    let ast = ast_map.get(item_tree[it.lookup(db).id.value].ast_id).to_node(&root);\n-\n-                    if ast.syntax().text_range().contains(position.offset) {\n-                        // Cursor inside function, descend into its body's DefMap.\n-                        // Note that we don't handle block *expressions* inside function bodies.\n-                        let ast_map = db.ast_id_map(position.file_id.into());\n-                        let ast_id = ast_map.ast_id(&ast.body().unwrap());\n-                        let block = BlockLoc {\n-                            ast_id: InFile::new(position.file_id.into(), ast_id),\n-                            module: def_map.module_id(local_id),\n-                        };\n-                        let block_id = db.intern_block(block);\n-                        return Some(db.block_def_map(block_id));\n-                    }\n-                }\n-                _ => continue,\n-            }\n-        }\n-    }\n-\n-    None\n-}\n-\n fn check(ra_fixture: &str, expect: Expect) {\n     let def_map = compute_crate_def_map(ra_fixture);\n     let actual = def_map.dump();\n     expect.assert_eq(&actual);\n }\n \n-fn check_at(ra_fixture: &str, expect: Expect) {\n-    let def_map = compute_block_def_map(ra_fixture);\n-    let actual = def_map.dump();\n-    expect.assert_eq(&actual);\n-}\n-\n #[test]\n fn crate_def_map_smoke_test() {\n     check("}]}