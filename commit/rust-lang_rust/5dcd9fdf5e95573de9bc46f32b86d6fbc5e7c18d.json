{"sha": "5dcd9fdf5e95573de9bc46f32b86d6fbc5e7c18d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkY2Q5ZmRmNWU5NTU3M2RlOWJjNDZmMzJiODZkNmZiYzVlN2MxOGQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-01-29T20:09:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-29T20:09:49Z"}, "message": "Merge #2895\n\n2895: Rewrite ra_prof's profile printing r=michalt a=michalt\n\nThis changes the way we print things to first construct a mapping from\r\nevents to the children and uses that mapping to actually print things.\r\nIt should not change the actual output that we produce.\r\n\r\nThe new approach two benefits:\r\n\r\n * It avoids a potential quadratic behavior of the previous approach.\r\n   For instance, for a vector of N elements:\r\n   ```\r\n   [Message{level: (N - 1)}, ..., Message{level: 1}, Message{level: 0}]\r\n   ```\r\n   we would first do a linear scan to find entry with level 0, then\r\n   another scan to find one with level 1, etc.\r\n\r\n * It makes it much easier to improve the output in the future, because\r\n   we now pre-compute the children for each entry and can easily take\r\n   that into account when printing.\r\n\r\nSigned-off-by: Michal Terepeta <michal.terepeta@gmail.com>\n\nCo-authored-by: Michal Terepeta <michal.terepeta@gmail.com>", "tree": {"sha": "0dd24c080fb5052428023373cb3109bd566f8f83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0dd24c080fb5052428023373cb3109bd566f8f83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5dcd9fdf5e95573de9bc46f32b86d6fbc5e7c18d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeMeaNCRBK7hj4Ov3rIwAAdHIIAG4oBUToDuCn0Nk1P8MC8gJ6\nLKpaJgSrz6FgpRc9WTJqLFJWalueypH5D7/7LGa7xipe8egIPLOFfI7LRK7AwqHf\nR6cdWaVsIdnJLiWlvpejdcRgLDF1/oUTqiDTfH7PJemLRs/P7tEaYsI5Xe2AkS1R\nvvkwhQ2zOzMS2Dkai+qUxpIsunXEpDyzGpBdnVS3mPcnhZvXLo2hIcf69jVdOwsL\nTq4ts3ruNhiT2C7KhMBU9JK87Pej3vR9arSndW/dHYlSylN0AtKlMqgPxcl7sTU/\nJ6IZnbwqcOOnvgdWDC1rVGsut9KDeLJjjtOD5h2NFwH86S4tSqsQq3oBLbVMxa0=\n=8LDu\n-----END PGP SIGNATURE-----\n", "payload": "tree 0dd24c080fb5052428023373cb3109bd566f8f83\nparent d92a15c1637860a669970142abe37d1daf5f2c73\nparent 644c383f65324b5fe1ada42680923c2529accb26\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1580328589 +0000\ncommitter GitHub <noreply@github.com> 1580328589 +0000\n\nMerge #2895\n\n2895: Rewrite ra_prof's profile printing r=michalt a=michalt\n\nThis changes the way we print things to first construct a mapping from\r\nevents to the children and uses that mapping to actually print things.\r\nIt should not change the actual output that we produce.\r\n\r\nThe new approach two benefits:\r\n\r\n * It avoids a potential quadratic behavior of the previous approach.\r\n   For instance, for a vector of N elements:\r\n   ```\r\n   [Message{level: (N - 1)}, ..., Message{level: 1}, Message{level: 0}]\r\n   ```\r\n   we would first do a linear scan to find entry with level 0, then\r\n   another scan to find one with level 1, etc.\r\n\r\n * It makes it much easier to improve the output in the future, because\r\n   we now pre-compute the children for each entry and can easily take\r\n   that into account when printing.\r\n\r\nSigned-off-by: Michal Terepeta <michal.terepeta@gmail.com>\n\nCo-authored-by: Michal Terepeta <michal.terepeta@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5dcd9fdf5e95573de9bc46f32b86d6fbc5e7c18d", "html_url": "https://github.com/rust-lang/rust/commit/5dcd9fdf5e95573de9bc46f32b86d6fbc5e7c18d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5dcd9fdf5e95573de9bc46f32b86d6fbc5e7c18d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d92a15c1637860a669970142abe37d1daf5f2c73", "url": "https://api.github.com/repos/rust-lang/rust/commits/d92a15c1637860a669970142abe37d1daf5f2c73", "html_url": "https://github.com/rust-lang/rust/commit/d92a15c1637860a669970142abe37d1daf5f2c73"}, {"sha": "644c383f65324b5fe1ada42680923c2529accb26", "url": "https://api.github.com/repos/rust-lang/rust/commits/644c383f65324b5fe1ada42680923c2529accb26", "html_url": "https://github.com/rust-lang/rust/commit/644c383f65324b5fe1ada42680923c2529accb26"}], "stats": {"total": 117, "additions": 71, "deletions": 46}, "files": [{"sha": "4a49e9f95d3b14dc81755f4b5e4c2e6b5b3f4369", "filename": "crates/ra_prof/src/lib.rs", "status": "modified", "additions": 71, "deletions": 46, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/5dcd9fdf5e95573de9bc46f32b86d6fbc5e7c18d/crates%2Fra_prof%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dcd9fdf5e95573de9bc46f32b86d6fbc5e7c18d/crates%2Fra_prof%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2Fsrc%2Flib.rs?ref=5dcd9fdf5e95573de9bc46f32b86d6fbc5e7c18d", "patch": "@@ -6,9 +6,9 @@ mod google_cpu_profiler;\n \n use std::{\n     cell::RefCell,\n+    collections::BTreeMap,\n     collections::HashSet,\n     io::{stderr, Write},\n-    iter::repeat,\n     mem,\n     sync::{\n         atomic::{AtomicBool, Ordering},\n@@ -17,7 +17,6 @@ use std::{\n     time::{Duration, Instant},\n };\n \n-use itertools::Itertools;\n use once_cell::sync::Lazy;\n \n pub use crate::memory_usage::{Bytes, MemoryUsage};\n@@ -216,7 +215,7 @@ impl Drop for Profiler {\n                         // (otherwise we could print `0ms` despite user's `>0` filter when\n                         // `duration` is just a few nanos).\n                         if duration.as_millis() > longer_than.as_millis() {\n-                            print(0, &stack.messages, &mut stdout.lock(), longer_than, None);\n+                            print(&stack.messages, longer_than, &mut stdout.lock());\n                         }\n                         stack.messages.clear();\n                     }\n@@ -227,59 +226,85 @@ impl Drop for Profiler {\n     }\n }\n \n-fn print(\n-    lvl: usize,\n-    msgs: &[Message],\n-    out: &mut impl Write,\n-    longer_than: Duration,\n-    total: Option<Duration>,\n-) {\n+fn print(msgs: &[Message], longer_than: Duration, out: &mut impl Write) {\n     if msgs.is_empty() {\n         return;\n     }\n-    // The index of the first element that will be included in the slice when we recurse.\n-    let mut next_start = 0;\n-    let indent = repeat(\"    \").take(lvl).collect::<String>();\n-    // We output hierarchy for long calls, but sum up all short calls\n-    let mut short = Vec::new();\n+    let children_map = idx_to_children(msgs);\n+    let root_idx = msgs.len() - 1;\n+    print_for_idx(root_idx, &children_map, msgs, longer_than, out);\n+}\n+\n+fn print_for_idx(\n+    current_idx: usize,\n+    children_map: &[Vec<usize>],\n+    msgs: &[Message],\n+    longer_than: Duration,\n+    out: &mut impl Write,\n+) {\n+    let current = &msgs[current_idx];\n+    let current_indent = \"    \".repeat(current.level);\n+    writeln!(out, \"{}{:5}ms - {}\", current_indent, current.duration.as_millis(), current.message)\n+        .expect(\"printing profiling info\");\n+\n+    let longer_than_millis = longer_than.as_millis();\n+    let children_indices = &children_map[current_idx];\n     let mut accounted_for = Duration::default();\n-    for (i, &Message { level, duration, message: ref msg }) in msgs.iter().enumerate() {\n-        if level != lvl {\n-            continue;\n-        }\n-        accounted_for += duration;\n-        if duration.as_millis() > longer_than.as_millis() {\n-            writeln!(out, \"{}{:5}ms - {}\", indent, duration.as_millis(), msg)\n-                .expect(\"printing profiling info to stdout\");\n+    let mut short_children = BTreeMap::new(); // Use `BTreeMap` to get deterministic output.\n \n-            print(lvl + 1, &msgs[next_start..i], out, longer_than, Some(duration));\n+    for child_idx in children_indices.iter() {\n+        let child = &msgs[*child_idx];\n+        if child.duration.as_millis() > longer_than_millis {\n+            print_for_idx(*child_idx, children_map, msgs, longer_than, out);\n         } else {\n-            short.push((msg, duration))\n+            let pair = short_children.entry(&child.message).or_insert((Duration::default(), 0));\n+            pair.0 += child.duration;\n+            pair.1 += 1;\n         }\n+        accounted_for += child.duration;\n+    }\n \n-        next_start = i + 1;\n+    for (child_msg, (duration, count)) in short_children.iter() {\n+        let millis = duration.as_millis();\n+        writeln!(out, \"    {}{:5}ms - {} ({} calls)\", current_indent, millis, child_msg, count)\n+            .expect(\"printing profiling info\");\n     }\n-    short.sort_by_key(|(msg, _time)| *msg);\n-    for (msg, entires) in short.iter().group_by(|(msg, _time)| msg).into_iter() {\n-        let mut count = 0;\n-        let mut total_duration = Duration::default();\n-        entires.for_each(|(_msg, time)| {\n-            count += 1;\n-            total_duration += *time;\n-        });\n-        writeln!(out, \"{}{:5}ms - {} ({} calls)\", indent, total_duration.as_millis(), msg, count)\n-            .expect(\"printing profiling info to stdout\");\n+\n+    let unaccounted_millis = (current.duration - accounted_for).as_millis();\n+    if !children_indices.is_empty()\n+        && unaccounted_millis > 0\n+        && unaccounted_millis > longer_than_millis\n+    {\n+        writeln!(out, \"    {}{:5}ms - ???\", current_indent, unaccounted_millis)\n+            .expect(\"printing profiling info\");\n     }\n+}\n \n-    if let Some(total) = total {\n-        if let Some(unaccounted) = total.checked_sub(accounted_for) {\n-            let unaccounted_millis = unaccounted.as_millis();\n-            if unaccounted_millis > longer_than.as_millis() && unaccounted_millis > 0 {\n-                writeln!(out, \"{}{:5}ms - ???\", indent, unaccounted_millis)\n-                    .expect(\"printing profiling info to stdout\");\n-            }\n+/// Returns a mapping from an index in the `msgs` to the vector with the indices of its children.\n+///\n+/// This assumes that the entries in `msgs` are in the order of when the calls to `profile` finish.\n+/// In other words, a postorder of the call graph. In particular, the root is the last element of\n+/// `msgs`.\n+fn idx_to_children(msgs: &[Message]) -> Vec<Vec<usize>> {\n+    // Initialize with the index of the root; `msgs` and `ancestors` should be never empty.\n+    assert!(!msgs.is_empty());\n+    let mut ancestors = vec![msgs.len() - 1];\n+    let mut result: Vec<Vec<usize>> = vec![vec![]; msgs.len()];\n+    for (idx, msg) in msgs[..msgs.len() - 1].iter().enumerate().rev() {\n+        // We need to find the parent of the current message, i.e., the last ancestor that has a\n+        // level lower than the current message.\n+        while msgs[*ancestors.last().unwrap()].level >= msg.level {\n+            ancestors.pop();\n         }\n+        result[*ancestors.last().unwrap()].push(idx);\n+        ancestors.push(idx);\n+    }\n+    // Note that above we visited all children from the last to the first one. Let's reverse vectors\n+    // to get the more natural order where the first element is the first child.\n+    for vec in result.iter_mut() {\n+        vec.reverse();\n     }\n+    result\n }\n \n /// Prints backtrace to stderr, useful for debugging.\n@@ -388,7 +413,7 @@ mod tests {\n             Message { level: 1, duration: Duration::from_nanos(2), message: \"bar\".to_owned() },\n             Message { level: 0, duration: Duration::from_millis(1), message: \"foo\".to_owned() },\n         ];\n-        print(0, &msgs, &mut result, Duration::from_millis(0), Some(Duration::from_millis(1)));\n+        print(&msgs, Duration::from_millis(0), &mut result);\n         // The calls to `bar` are so short that they'll be rounded to 0ms and should get collapsed\n         // when printing.\n         assert_eq!(\n@@ -404,7 +429,7 @@ mod tests {\n             Message { level: 1, duration: Duration::from_millis(2), message: \"bar\".to_owned() },\n             Message { level: 0, duration: Duration::from_millis(5), message: \"foo\".to_owned() },\n         ];\n-        print(0, &msgs, &mut result, Duration::from_millis(0), Some(Duration::from_millis(1)));\n+        print(&msgs, Duration::from_millis(0), &mut result);\n         assert_eq!(\n             std::str::from_utf8(&result).unwrap().lines().collect::<Vec<_>>(),\n             vec![\n@@ -426,7 +451,7 @@ mod tests {\n             Message { level: 1, duration: Duration::from_millis(4), message: \"bar\".to_owned() },\n             Message { level: 0, duration: Duration::from_millis(9), message: \"foo\".to_owned() },\n         ];\n-        print(0, &msgs, &mut result, Duration::from_millis(0), None);\n+        print(&msgs, Duration::from_millis(0), &mut result);\n         assert_eq!(\n             std::str::from_utf8(&result).unwrap().lines().collect::<Vec<_>>(),\n             vec!["}]}