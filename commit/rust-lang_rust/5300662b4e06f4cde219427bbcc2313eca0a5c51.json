{"sha": "5300662b4e06f4cde219427bbcc2313eca0a5c51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzMDA2NjJiNGUwNmY0Y2RlMjE5NDI3YmJjYzIzMTNlY2EwYTVjNTE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-07T00:37:37Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-07T14:25:41Z"}, "message": "Refactor inference so that subtyping/lub/glb share more code", "tree": {"sha": "88c1da1f5b4f0c8977d80d8630d7df9025817539", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88c1da1f5b4f0c8977d80d8630d7df9025817539"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5300662b4e06f4cde219427bbcc2313eca0a5c51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5300662b4e06f4cde219427bbcc2313eca0a5c51", "html_url": "https://github.com/rust-lang/rust/commit/5300662b4e06f4cde219427bbcc2313eca0a5c51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5300662b4e06f4cde219427bbcc2313eca0a5c51/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f42b14b4f57d602ffa446a8f30840c2dcbeb127", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f42b14b4f57d602ffa446a8f30840c2dcbeb127", "html_url": "https://github.com/rust-lang/rust/commit/2f42b14b4f57d602ffa446a8f30840c2dcbeb127"}], "stats": {"total": 1080, "additions": 435, "deletions": 645}, "files": [{"sha": "aac422dbca7ebe074f8ce0e594ac1a69e417ad5f", "filename": "src/rustc/middle/infer.rs", "status": "modified", "additions": 435, "deletions": 645, "changes": 1080, "blob_url": "https://github.com/rust-lang/rust/blob/5300662b4e06f4cde219427bbcc2313eca0a5c51/src%2Frustc%2Fmiddle%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5300662b4e06f4cde219427bbcc2313eca0a5c51/src%2Frustc%2Fmiddle%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Finfer.rs?ref=5300662b4e06f4cde219427bbcc2313eca0a5c51", "patch": "@@ -68,32 +68,17 @@ fn new_infer_ctxt(tcx: ty::ctxt) -> infer_ctxt {\n \n fn mk_subty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n     #debug[\"mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx)];\n-    indent {||\n-        cx.commit {||\n-            cx.tys(a, b)\n-        }\n-    }\n+    indent {|| cx.commit {|| sub(cx).tys(a, b) } }.to_ures()\n }\n \n fn mk_eqty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n     #debug[\"mk_eqty(%s <: %s)\", a.to_str(cx), b.to_str(cx)];\n-    indent {||\n-        cx.commit {||\n-            cx.eq_tys(a, b)\n-        }\n-    }\n+    indent {|| cx.commit {|| cx.eq_tys(a, b) } }.to_ures()\n }\n \n fn compare_tys(tcx: ty::ctxt, a: ty::t, b: ty::t) -> ures {\n     let infcx = new_infer_ctxt(tcx);\n-    #debug[\"compare_tys(%s == %s)\", a.to_str(infcx), b.to_str(infcx)];\n-    indent {||\n-        infcx.commit {||\n-            mk_subty(infcx, a, b).then {||\n-                mk_subty(infcx, b, a)\n-            }\n-        }\n-    }\n+    mk_eqty(infcx, a, b)\n }\n \n fn resolve_type_structure(cx: infer_ctxt, a: ty::t) -> fres<ty::t> {\n@@ -115,6 +100,25 @@ impl methods for ures {\n     }\n }\n \n+impl methods<T:copy> for cres<T> {\n+    fn to_ures() -> ures {\n+        alt self {\n+          ok(_v) { ok(()) }\n+          err(e) { err(e) }\n+        }\n+    }\n+\n+    fn compare(t: T, f: fn() -> ty::type_err) -> cres<T> {\n+        self.chain {|s|\n+            if s == t {\n+                self\n+            } else {\n+                err(f())\n+            }\n+        }\n+    }\n+}\n+\n iface to_str {\n     fn to_str(cx: infer_ctxt) -> str;\n }\n@@ -164,14 +168,14 @@ impl<V:copy vid, T:copy to_str> of to_str for var_value<V,T> {\n }\n \n iface st {\n-    fn st(infcx: infer_ctxt, b: self) -> ures;\n+    fn sub(infcx: infer_ctxt, b: self) -> ures;\n     fn lub(infcx: infer_ctxt, b: self) -> cres<self>;\n     fn glb(infcx: infer_ctxt, b: self) -> cres<self>;\n }\n \n impl of st for ty::t {\n-    fn st(infcx: infer_ctxt, b: ty::t) -> ures {\n-        infcx.tys(self, b)\n+    fn sub(infcx: infer_ctxt, b: ty::t) -> ures {\n+        sub(infcx).tys(self, b).to_ures()\n     }\n \n     fn lub(infcx: infer_ctxt, b: ty::t) -> cres<ty::t> {\n@@ -184,8 +188,8 @@ impl of st for ty::t {\n }\n \n impl of st for ty::region {\n-    fn st(infcx: infer_ctxt, b: ty::region) -> ures {\n-        infcx.regions(self, b)\n+    fn sub(infcx: infer_ctxt, b: ty::region) -> ures {\n+        sub(infcx).regions(self, b).chain {|_r| ok(()) }\n     }\n \n     fn lub(infcx: infer_ctxt, b: ty::region) -> cres<ty::region> {\n@@ -208,7 +212,6 @@ impl of st for ty::region {\n // the old range).  They therefore return a result.\n impl unify_methods for infer_ctxt {\n     fn uok() -> ures {\n-        #debug[\"Unification OK\"];\n         ok(())\n     }\n \n@@ -297,18 +300,6 @@ impl unify_methods for infer_ctxt {\n         }\n     }\n \n-    fn get_var(vid: ty_vid)\n-        -> {root: ty_vid, bounds:bounds<ty::t>} {\n-\n-        ret self.get(self.vb, vid);\n-    }\n-\n-    fn get_region(rid: region_vid)\n-        -> {root: region_vid, bounds:bounds<ty::region>} {\n-\n-        ret self.get(self.rb, rid);\n-    }\n-\n     // Combines the two bounds into a more general bound.\n     fn merge_bnd<V:copy to_str>(\n         a: bound<V>, b: bound<V>,\n@@ -429,7 +420,7 @@ impl unify_methods for infer_ctxt {\n         // see if we can make those types subtypes.\n         alt (a_bounds.ub, b_bounds.lb) {\n           (some(a_ub), some(b_lb)) {\n-            let r = self.try {|| a_ub.st(self, b_lb) };\n+            let r = self.try {|| a_ub.sub(self, b_lb) };\n             alt r {\n               ok(()) { ret result::ok(()); }\n               err(_) { /*fallthrough */ }\n@@ -474,142 +465,6 @@ impl unify_methods for infer_ctxt {\n         self.set_var_to_merged_bounds(vb, b_id, a_bounds, b_bounds)\n     }\n \n-    fn regions(a: ty::region, b: ty::region) -> ures {\n-        #debug[\"regions(%s <= %s)\", a.to_str(self), b.to_str(self)];\n-        indent {||\n-            alt (a, b) {\n-              (ty::re_var(a_id), ty::re_var(b_id)) {\n-                self.vars(self.rb, a_id, b_id)\n-              }\n-              (ty::re_var(a_id), _) {\n-                self.vart(self.rb, a_id, b)\n-              }\n-              (_, ty::re_var(b_id)) {\n-                self.tvar(self.rb, a, b_id)\n-              }\n-\n-              _ {\n-                lub(self).regions(a, b).chain {|r|\n-                    if b == r {\n-                        self.uok()\n-                    } else {\n-                        err(ty::terr_regions_differ(b, a))\n-                    }\n-                }\n-              }\n-            }\n-        }\n-    }\n-\n-    fn mts(a: ty::mt, b: ty::mt) -> ures {\n-        #debug(\"mts(%s <: %s)\", a.to_str(self), b.to_str(self));\n-\n-        if a.mutbl != b.mutbl && b.mutbl != ast::m_const {\n-            ret self.uerr(ty::terr_mutability);\n-        }\n-\n-        alt b.mutbl {\n-          ast::m_mutbl {\n-            // If supertype is mut, subtype must match exactly\n-            // (i.e., invariant if mut):\n-            self.eq_tys(a.ty, b.ty)\n-          }\n-          ast::m_imm | ast::m_const {\n-            // Otherwise we can be covariant:\n-            self.tys(a.ty, b.ty)\n-          }\n-        }\n-    }\n-\n-    fn flds(a: ty::field, b: ty::field) -> ures {\n-        if b.ident != a.ident {\n-            // Note: the error object expects the \"expected\" field to\n-            // come first, which is generally the supertype (b).\n-            ret self.uerr(ty::terr_record_fields(b.ident, a.ident));\n-        }\n-\n-        self.mts(a.mt, b.mt).chain_err {|err|\n-            self.uerr(ty::terr_in_field(@err, a.ident))\n-        }\n-    }\n-\n-    fn tps(as: [ty::t], bs: [ty::t]) -> ures {\n-        // Note: type parameters are always treated as *invariant*\n-        // (otherwise the type system would be unsound).  In the\n-        // future we could allow type parameters to declare a\n-        // variance.  In that case, you would have to change c_tps()\n-        // for LUB/GLB, which currently always returns `as`.\n-        if check vec::same_length(as, bs) {\n-            iter2(as, bs) {|a, b| self.eq_tys(a, b) }\n-        } else {\n-            self.uerr(ty::terr_ty_param_size(bs.len(), as.len()))\n-        }\n-    }\n-\n-    fn protos(a: ast::proto, b: ast::proto) -> ures {\n-        alt (a, b) {\n-          (_, ast::proto_any) { self.uok() }\n-          (ast::proto_bare, _) { self.uok() }\n-          (_, _) if a == b { self.uok() }\n-          _ { self.uerr(ty::terr_proto_mismatch(b, a)) }\n-        }\n-    }\n-\n-    fn ret_styles(\n-        a_ret_style: ret_style,\n-        b_ret_style: ret_style) -> ures {\n-\n-        if b_ret_style != ast::noreturn && b_ret_style != a_ret_style {\n-            /* even though typestate checking is mostly\n-               responsible for checking control flow annotations,\n-               this check is necessary to ensure that the\n-               annotation in an object method matches the\n-               declared object type */\n-            self.uerr(ty::terr_ret_style_mismatch(b_ret_style, a_ret_style))\n-        } else {\n-            self.uok()\n-        }\n-    }\n-\n-    fn modes(a: ast::mode, b: ast::mode) -> ures {\n-        alt ty::unify_mode(self.tcx, a, b) {\n-          ok(_) { self.uok() }\n-          err(e) { self.uerr(e) }\n-        }\n-    }\n-\n-    fn args(a: ty::arg, b: ty::arg) -> ures {\n-        self.modes(a.mode, b.mode).then {||\n-            self.tys(b.ty, a.ty) // Note: contravariant\n-        }\n-    }\n-\n-    fn argvecs(\n-        a_args: [ty::arg],\n-        b_args: [ty::arg]) -> ures {\n-\n-        if check vec::same_length(a_args, b_args) {\n-            iter2(a_args, b_args) {|a, b| self.args(a, b) }\n-        } else {\n-            ret self.uerr(ty::terr_arg_count);\n-        }\n-    }\n-\n-    fn fns(a_f: ty::fn_ty, b_f: ty::fn_ty) -> ures {\n-        self.protos(a_f.proto, b_f.proto).then {||\n-            self.ret_styles(a_f.ret_style, b_f.ret_style).then {||\n-                self.argvecs(a_f.inputs, b_f.inputs).then {||\n-                    self.tys(a_f.output, b_f.output).then {||\n-                        //TODO self.constrvecs(a_f.constraints,\n-                        //TODO                 b_f.constraints).then {||\n-                            self.uok()\n-                        //TODO }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     fn constrs(\n         expected: @ty::type_constr,\n         actual_constr: @ty::type_constr) -> ures {\n@@ -665,7 +520,7 @@ impl unify_methods for infer_ctxt {\n                 self.uok()\n               }\n               (some(t_a), some(t_b)) {\n-                t_a.st(self, t_b)\n+                t_a.sub(self, t_b)\n               }\n             }\n         }\n@@ -683,111 +538,13 @@ impl unify_methods for infer_ctxt {\n         }\n     }\n \n-    fn eq_tys(a: ty::t, b: ty::t) -> ures {\n-        self.tys(a, b).then {||\n-            self.tys(b, a)\n-        }\n+    fn sub_tys(a: ty::t, b: ty::t) -> ures {\n+        sub(self).tys(a, b).chain {|_t| ok(()) }\n     }\n \n-    fn tys(a: ty::t, b: ty::t) -> ures {\n-        #debug(\"tys(%s <: %s)\",\n-               ty_to_str(self.tcx, a),\n-               ty_to_str(self.tcx, b));\n-\n-        // Fast path.\n-        if a == b { ret self.uok(); }\n-\n-        alt (ty::get(a).struct, ty::get(b).struct) {\n-          (ty::ty_bot, _) { self.uok() }\n-\n-          (ty::ty_var(a_id), ty::ty_var(b_id)) {\n-            self.vars(self.vb, a_id, b_id)\n-          }\n-          (ty::ty_var(a_id), _) {\n-            self.vart(self.vb, a_id, b)\n-          }\n-          (_, ty::ty_var(b_id)) {\n-            self.tvar(self.vb, a, b_id)\n-          }\n-\n-          (ty::ty_nil, _) |\n-          (ty::ty_bool, _) |\n-          (ty::ty_int(_), _) |\n-          (ty::ty_uint(_), _) |\n-          (ty::ty_float(_), _) |\n-          (ty::ty_str, _) {\n-            let cfg = self.tcx.sess.targ_cfg;\n-            if ty::mach_sty(cfg, a) == ty::mach_sty(cfg, b) {\n-                self.uok()\n-            } else {\n-                self.uerr(ty::terr_sorts(b, a))\n-            }\n-          }\n-\n-          (ty::ty_param(a_n, _), ty::ty_param(b_n, _))\n-          if a_n == b_n {\n-            self.uok()\n-          }\n-\n-          (ty::ty_enum(a_id, a_tps), ty::ty_enum(b_id, b_tps)) |\n-          (ty::ty_iface(a_id, a_tps), ty::ty_iface(b_id, b_tps)) |\n-          (ty::ty_class(a_id, a_tps), ty::ty_class(b_id, b_tps))\n-          if a_id == b_id {\n-            self.tps(a_tps, b_tps)\n-          }\n-\n-          (ty::ty_box(a_mt), ty::ty_box(b_mt)) |\n-          (ty::ty_uniq(a_mt), ty::ty_uniq(b_mt)) |\n-          (ty::ty_vec(a_mt), ty::ty_vec(b_mt)) |\n-          (ty::ty_ptr(a_mt), ty::ty_ptr(b_mt)) {\n-            self.mts(a_mt, b_mt)\n-          }\n-\n-          (ty::ty_rptr(a_r, a_mt), ty::ty_rptr(b_r, b_mt)) {\n-            self.mts(a_mt, b_mt).then {||\n-                // Non-obvious: for &a.T to be a subtype of &b.T, &a\n-                // must exist for LONGER than &b.  That is, &b <= &a.\n-                self.regions(b_r, a_r)\n-            }\n-          }\n-\n-          (ty::ty_res(a_id, a_t, a_tps), ty::ty_res(b_id, b_t, b_tps))\n-          if a_id == b_id {\n-            self.tys(a_t, b_t).then {||\n-                self.tps(a_tps, b_tps)\n-            }\n-          }\n-\n-          (ty::ty_rec(a_fields), ty::ty_rec(b_fields)) {\n-            if check vec::same_length(a_fields, b_fields) {\n-                iter2(a_fields, b_fields) {|a,b|\n-                    self.flds(a, b)\n-                }\n-            } else {\n-                ret self.uerr(ty::terr_record_size(b_fields.len(),\n-                                                   a_fields.len()));\n-            }\n-          }\n-\n-          (ty::ty_tup(a_tys), ty::ty_tup(b_tys)) {\n-            if check vec::same_length(a_tys, b_tys) {\n-                iter2(a_tys, b_tys) {|a,b| self.tys(a,b) }\n-            } else {\n-                self.uerr(ty::terr_tuple_size(b_tys.len(), a_tys.len()))\n-            }\n-          }\n-\n-          (ty::ty_fn(a_fty), ty::ty_fn(b_fty)) {\n-            self.fns(a_fty, b_fty)\n-          }\n-\n-          (ty::ty_constr(a_t, a_constrs), ty::ty_constr(b_t, b_constrs)) {\n-            self.tys(a_t, b_t).then {||\n-                self.constrvecs(a_constrs, b_constrs)\n-            }\n-          }\n-\n-          _ { self.uerr(ty::terr_sorts(b, a)) }\n+    fn eq_tys(a: ty::t, b: ty::t) -> ures {\n+        self.sub_tys(a, b).then {||\n+            self.sub_tys(b, a)\n         }\n     }\n }\n@@ -964,11 +721,7 @@ type cres<T> = result<T,ty::type_err>;\n iface combine {\n     fn infcx() -> infer_ctxt;\n     fn tag() -> str;\n-    fn bnd<V:copy>(b: bounds<V>) -> option<V>;\n-    fn with_bnd<V:copy>(b: bounds<V>, v: V) -> bounds<V>;\n \n-    fn bot_ty(b: ty::t) -> cres<ty::t>;\n-    fn ty_bot(b: ty::t) -> cres<ty::t>;\n     fn mts(a: ty::mt, b: ty::mt) -> cres<ty::mt>;\n     fn contratys(a: ty::t, b: ty::t) -> cres<ty::t>;\n     fn tys(a: ty::t, b: ty::t) -> cres<ty::t>;\n@@ -979,118 +732,27 @@ iface combine {\n     fn args(a: ty::arg, b: ty::arg) -> cres<ty::arg>;\n     fn protos(p1: ast::proto, p2: ast::proto) -> cres<ast::proto>;\n     fn ret_styles(r1: ret_style, r2: ret_style) -> cres<ret_style>;\n-    fn tvars(a: ty::ty_vid, b: ty::ty_vid) -> cres<ty::t>;\n-    fn tvar_ty(a: ty::ty_vid, b: ty::t) -> cres<ty::t>;\n-    fn ty_tvar(a: ty::t, b: ty::ty_vid) -> cres<ty::t>;\n-\n-    // Combining regions (along with some specific cases that are\n-    // different for LUB/GLB):\n-    fn contraregions(\n-        a: ty::region, b: ty::region) -> cres<ty::region>;\n-    fn regions(\n-        a: ty::region, b: ty::region) -> cres<ty::region>;\n-    fn regions_static_r(r: ty::region) -> cres<ty::region>;\n-    fn regions_r_static(r: ty::region) -> cres<ty::region>;\n-    fn regions_scope_scope(\n-        a: ty::region, a_id: ast::node_id,\n-        b: ty::region, b_id: ast::node_id) -> cres<ty::region>;\n-    fn regions_scope_free(\n-        a: ty::region, a_id: ast::node_id,\n-        b: ty::region, b_id: ast::node_id, b_br: ty::bound_region)\n-        -> cres<ty::region>;\n-    fn regions_free_scope(\n-        a: ty::region, a_id: ast::node_id, a_br: ty::bound_region,\n-        b: ty::region, b_id: ast::node_id) -> cres<ty::region>;\n-    fn rvars(a: ty::region_vid, b: ty::region_vid) -> cres<ty::region>;\n-    fn rvar_r(a: ty::region_vid, b: ty::region) -> cres<ty::region>;\n-    fn r_rvar(a: ty::region, b: ty::region_vid) -> cres<ty::region>;\n+    fn contraregions(a: ty::region, b: ty::region) -> cres<ty::region>;\n+    fn regions(a: ty::region, b: ty::region) -> cres<ty::region>;\n }\n \n-enum lub = infer_ctxt;\n-enum glb = infer_ctxt;\n-\n-fn super_vars<V:copy vid, C:combine, T:copy to_str st>(\n-    self: C, vb: vals_and_bindings<V, T>,\n-    a_t: T, a_vid: V, b_vid: V,\n-    c_ts: fn(T, T) -> cres<T>) -> cres<T> {\n-\n-    // The comments in this function are written for LUB and types,\n-    // but they apply equally well to GLB and regions if you inverse\n-    // upper/lower/sub/super/etc.\n-\n-    // Need to find a type that is a supertype of both a and b:\n-    let {root: a_vid, bounds: a_bounds} = self.infcx().get(vb, a_vid);\n-    let {root: b_vid, bounds: b_bounds} = self.infcx().get(vb, b_vid);\n-\n-    #debug[\"%s.vars(%s=%s <: %s=%s)\",\n-           self.tag(),\n-           a_vid.to_str(), a_bounds.to_str(self.infcx()),\n-           b_vid.to_str(), b_bounds.to_str(self.infcx())];\n-\n-    if a_vid == b_vid {\n-        ret ok(a_t);\n-    }\n-\n-    // If both A and B have an UB type, then we can just compute the\n-    // LUB of those types:\n-    let a_bnd = self.bnd(a_bounds), b_bnd = self.bnd(b_bounds);\n-    alt (a_bnd, b_bnd) {\n-      (some(a_ty), some(b_ty)) {\n-        alt self.infcx().try {|| c_ts(a_ty, b_ty) } {\n-            ok(t) { ret ok(t); }\n-            err(_) { /*fallthrough */ }\n-        }\n-      }\n-      _ {/*fallthrough*/}\n-    }\n-\n-    // Otherwise, we need to merge A and B into one variable.  We can\n-    // then use either variable as an upper bound:\n-    self.infcx().vars(vb, a_vid, b_vid).then {||\n-        ok(a_t)\n-    }\n-}\n-\n-fn super_var_t<V:copy vid, C:combine, T:copy to_str st>(\n-    self: C, vb: vals_and_bindings<V, T>,\n-    a_vid: V, b: T,\n-    c_ts: fn(T, T) -> cres<T>) -> cres<T> {\n-\n-    let {root: a_id, bounds: a_bounds} = self.infcx().get(vb, a_vid);\n-\n-    // The comments in this function are written for LUB, but they\n-    // apply equally well to GLB if you inverse upper/lower/sub/super/etc.\n-\n-    #debug[\"%s.var_ty(%s=%s <: %s)\",\n-           self.tag(),\n-           a_id.to_str(), a_bounds.to_str(self.infcx()),\n-           b.to_str(self.infcx())];\n-\n-    alt self.bnd(a_bounds) {\n-      some(a_bnd) {\n-        // If a has an upper bound, return it.\n-        #debug[\"bnd=some(%s)\", a_bnd.to_str(self.infcx())];\n-        ret c_ts(a_bnd, b);\n-      }\n-      none {\n-        // If a does not have an upper bound, make b the upper bound of a\n-        // and then return b.\n-        #debug[\"bnd=none\"];\n-        let a_bounds = self.with_bnd(a_bounds, b);\n-        self.infcx().bnds(a_bounds.lb, a_bounds.ub).then {||\n-            self.infcx().set(vb, a_id, bounded(a_bounds));\n-            ok(b)\n-        }\n-      }\n-    }\n-}\n+enum sub = infer_ctxt;  // \"less than\" == \"subtype\" or \"subregion\"\n+enum lub = infer_ctxt;  // \"least upper bound\" (common supertype)\n+enum glb = infer_ctxt;  // \"greatest lower bound\" (common subtype)\n \n fn super_tps<C:combine>(\n-    self: C, as: [ty::t], bs: [ty::t])\n-    -> cres<[ty::t]> {\n-\n-    self.infcx().tps(as, bs).then {||\n-        ok(as)\n+    self: C, as: [ty::t], bs: [ty::t]) -> cres<[ty::t]> {\n+\n+    // Note: type parameters are always treated as *invariant*\n+    // (otherwise the type system would be unsound).  In the\n+    // future we could allow type parameters to declare a\n+    // variance.\n+    if check vec::same_length(as, bs) {\n+        iter2(as, bs) {|a, b| self.infcx().eq_tys(a, b) }.then {||\n+            ok(as)\n+        }\n+    } else {\n+        err(ty::terr_ty_param_size(bs.len(), as.len()))\n     }\n }\n \n@@ -1100,6 +762,8 @@ fn super_flds<C:combine>(\n     if a.ident == b.ident {\n         self.mts(a.mt, b.mt).chain {|mt|\n             ok({ident: a.ident, mt: mt})\n+        }.chain_err {|e|\n+            err(ty::terr_in_field(@e, a.ident))\n         }\n     } else {\n         err(ty::terr_record_fields(b.ident, a.ident))\n@@ -1119,8 +783,7 @@ fn super_args<C:combine>(\n     -> cres<ty::arg> {\n \n     self.modes(a.mode, b.mode).chain {|m|\n-        // Note: contravariant\n-        self.contratys(b.ty, a.ty).chain {|t|\n+        self.contratys(a.ty, b.ty).chain {|t|\n             ok({mode: m, ty: t})\n         }\n     }\n@@ -1161,35 +824,17 @@ fn super_tys<C:combine>(\n     self: C, a: ty::t, b: ty::t) -> cres<ty::t> {\n \n     let tcx = self.infcx().tcx;\n-\n-    #debug(\"%s.tys(%s, %s)\",\n-           self.tag(),\n-           ty_to_str(tcx, a),\n-           ty_to_str(tcx, b));\n-\n-    // Fast path.\n-    if a == b { ret ok(a); }\n-\n-    indent {||\n     alt (ty::get(a).struct, ty::get(b).struct) {\n-      (ty::ty_bot, _) {\n-        self.ty_bot(b)\n-      }\n-\n-      (_, ty::ty_bot) {\n-        self.bot_ty(b)\n-      }\n-\n-      (ty::ty_var(a_id), ty::ty_var(b_id)) {\n-        self.tvars(a_id, b_id)\n-      }\n-\n-      (ty::ty_var(v_id), _) {\n-        self.tvar_ty(v_id, b)\n-      }\n-\n-      (_, ty::ty_var(v_id)) {\n-        self.ty_tvar(a, v_id)\n+      // The \"subtype\" ought to be handling cases involving bot or var:\n+      (ty::ty_bot, _) |\n+      (_, ty::ty_bot) |\n+      (ty::ty_var(_), _) |\n+      (_, ty::ty_var(_)) {\n+        tcx.sess.bug(\n+            #fmt[\"%s: bot and var types should have been handled (%s,%s)\",\n+                 self.tag(),\n+                 a.to_str(self.infcx()),\n+                 b.to_str(self.infcx())]);\n       }\n \n       (ty::ty_nil, _) |\n@@ -1308,101 +953,139 @@ fn super_tys<C:combine>(\n \n       _ { err(ty::terr_sorts(b, a)) }\n     }\n-    }\n }\n \n-fn super_regions<C:combine>(\n-    self: C, a: ty::region, b: ty::region) -> cres<ty::region> {\n-\n-    #debug[\"%s.regions(%?, %?)\",\n-           self.tag(),\n-           a.to_str(self.infcx()),\n-           b.to_str(self.infcx())];\n+impl of combine for sub {\n+    fn infcx() -> infer_ctxt { *self }\n+    fn tag() -> str { \"sub\" }\n \n-    indent {||\n-    alt (a, b) {\n-      (ty::re_static, r) {\n-        self.regions_static_r(r)\n-      }\n+    fn lub() -> lub { lub(*self) }\n \n-      (r, ty::re_static) {\n-        self.regions_r_static(r)\n-      }\n-\n-      (ty::re_var(a_id), ty::re_var(b_id)) {\n-        self.rvars(a_id, b_id)\n-      }\n+    fn contratys(a: ty::t, b: ty::t) -> cres<ty::t> {\n+        self.tys(b, a)\n+    }\n \n-      (ty::re_var(v_id), _) {\n-        self.rvar_r(v_id, b)\n-      }\n+    fn contraregions(a: ty::region, b: ty::region) -> cres<ty::region> {\n+        self.regions(b, a)\n+    }\n \n-      (_, ty::re_var(v_id)) {\n-        self.r_rvar(a, v_id)\n-      }\n+    fn regions(a: ty::region, b: ty::region) -> cres<ty::region> {\n+        #debug[\"regions(%s <= %s)\", a.to_str(*self), b.to_str(*self)];\n+        indent {||\n+            alt (a, b) {\n+              (ty::re_var(a_id), ty::re_var(b_id)) {\n+                self.infcx().vars(self.rb, a_id, b_id).then {||\n+                    ok(a)\n+                }\n+              }\n+              (ty::re_var(a_id), _) {\n+                  self.infcx().vart(self.rb, a_id, b).then {||\n+                      ok(a)\n+                  }\n+              }\n+              (_, ty::re_var(b_id)) {\n+                  self.infcx().tvar(self.rb, a, b_id).then {||\n+                      ok(a)\n+                  }\n+              }\n+              _ {\n+                self.lub().regions(a, b).compare(b) {||\n+                    ty::terr_regions_differ(b, a)\n+                }\n+              }\n+            }\n+        }\n+    }\n \n-      (ty::re_free(a_id, a_br), ty::re_scope(b_id)) {\n-        self.regions_free_scope(a, a_id, a_br, b, b_id)\n-      }\n+    fn mts(a: ty::mt, b: ty::mt) -> cres<ty::mt> {\n+        #debug(\"mts(%s <: %s)\", a.to_str(*self), b.to_str(*self));\n \n-      (ty::re_scope(a_id), ty::re_free(b_id, b_br)) {\n-        self.regions_scope_free(b, b_id, b, b_id, b_br)\n-      }\n+        if a.mutbl != b.mutbl && b.mutbl != ast::m_const {\n+            ret err(ty::terr_mutability);\n+        }\n \n-      (ty::re_scope(a_id), ty::re_scope(b_id)) {\n-        self.regions_scope_scope(a, a_id, b, b_id)\n-      }\n+        alt b.mutbl {\n+          ast::m_mutbl {\n+            // If supertype is mut, subtype must match exactly\n+            // (i.e., invariant if mut):\n+            self.infcx().eq_tys(a.ty, b.ty).then {|| ok(a) }\n+          }\n+          ast::m_imm | ast::m_const {\n+            // Otherwise we can be covariant:\n+            self.tys(a.ty, b.ty).chain {|_t| ok(a) }\n+          }\n+        }\n+    }\n \n-      // For these types, we cannot define any additional relationship:\n-      (ty::re_free(_, _), ty::re_free(_, _)) |\n-      (ty::re_bound(_), ty::re_bound(_)) |\n-      (ty::re_bound(_), ty::re_free(_, _)) |\n-      (ty::re_bound(_), ty::re_scope(_)) |\n-      (ty::re_free(_, _), ty::re_bound(_)) |\n-      (ty::re_scope(_), ty::re_bound(_)) {\n-        if a == b {\n-            #debug[\"... yes, %s == %s.\",\n-                   a.to_str(self.infcx()),\n-                   b.to_str(self.infcx())];\n-            ok(a)\n-        } else {\n-            #debug[\"... no, %s != %s.\",\n-                   a.to_str(self.infcx()),\n-                   b.to_str(self.infcx())];\n-            err(ty::terr_regions_differ(b, a))\n+    fn protos(a: ast::proto, b: ast::proto) -> cres<ast::proto> {\n+        self.lub().protos(a, b).compare(b) {||\n+            ty::terr_proto_mismatch(b, a)\n         }\n-      }\n+    }\n \n-      (ty::re_default, _) |\n-      (_, ty::re_default) {\n-        // actually a compiler bug, I think.\n-        err(ty::terr_regions_differ(b, a))\n-      }\n+    fn ret_styles(a: ret_style, b: ret_style) -> cres<ret_style> {\n+        self.lub().ret_styles(a, b).compare(b) {||\n+            ty::terr_ret_style_mismatch(b, a)\n+        }\n     }\n+\n+    fn tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n+        #debug(\"%s.tys(%s, %s)\", self.tag(),\n+               a.to_str(*self), b.to_str(*self));\n+        if a == b { ret ok(a); }\n+        indent {||\n+            alt (ty::get(a).struct, ty::get(b).struct) {\n+              (ty::ty_bot, _) {\n+                ok(a)\n+              }\n+              (ty::ty_var(a_id), ty::ty_var(b_id)) {\n+                self.infcx().vars(self.vb, a_id, b_id).then {|| ok(a) }\n+              }\n+              (ty::ty_var(a_id), _) {\n+                self.infcx().vart(self.vb, a_id, b).then {|| ok(a) }\n+              }\n+              (_, ty::ty_var(b_id)) {\n+                self.infcx().tvar(self.vb, a, b_id).then {|| ok(a) }\n+              }\n+              (_, ty::ty_bot) {\n+                err(ty::terr_sorts(b, a))\n+              }\n+              _ {\n+                super_tys(self, a, b)\n+              }\n+            }\n+        }\n     }\n-}\n \n-impl of combine for lub {\n-    fn infcx() -> infer_ctxt { *self }\n+    // Traits please:\n \n-    fn tag() -> str { \"lub\" }\n+    fn flds(a: ty::field, b: ty::field) -> cres<ty::field> {\n+        super_flds(self, a, b)\n+    }\n \n-    fn bnd<V:copy>(b: bounds<V>) -> option<V> {\n-        b.ub\n+    fn modes(a: ast::mode, b: ast::mode) -> cres<ast::mode> {\n+        super_modes(self, a, b)\n     }\n \n-    fn with_bnd<V:copy>(b: bounds<V>, v: V) -> bounds<V> {\n-        assert b.ub == none;\n-        {ub: some(v) with b}\n+    fn args(a: ty::arg, b: ty::arg) -> cres<ty::arg> {\n+        super_args(self, a, b)\n     }\n \n-    fn bot_ty(b: ty::t) -> cres<ty::t> {\n-        ok(b)\n+    fn fns(a: ty::fn_ty, b: ty::fn_ty) -> cres<ty::fn_ty> {\n+        super_fns(self, a, b)\n     }\n \n-    fn ty_bot(b: ty::t) -> cres<ty::t> {\n-        self.bot_ty(b) // LUB is commutative\n+    fn tps(as: [ty::t], bs: [ty::t]) -> cres<[ty::t]> {\n+        super_tps(self, as, bs)\n     }\n+}\n+\n+impl of combine for lub {\n+    fn infcx() -> infer_ctxt { *self }\n+    fn tag() -> str { \"lub\" }\n+\n+    fn bot_ty(b: ty::t) -> cres<ty::t> { ok(b) }\n+    fn ty_bot(b: ty::t) -> cres<ty::t> { self.bot_ty(b) } // commutative\n \n     fn mts(a: ty::mt, b: ty::mt) -> cres<ty::mt> {\n         let tcx = self.infcx().tcx;\n@@ -1471,85 +1154,77 @@ impl of combine for lub {\n         ret glb(self.infcx()).regions(a, b);\n     }\n \n-    fn regions_static_r(_r: ty::region) -> cres<ty::region> {\n-        // nothing lives longer than static\n-        ret ok(ty::re_static);\n-    }\n+    fn regions(a: ty::region, b: ty::region) -> cres<ty::region> {\n+        #debug[\"%s.regions(%?, %?)\",\n+               self.tag(),\n+               a.to_str(self.infcx()),\n+               b.to_str(self.infcx())];\n \n-    fn regions_r_static(r: ty::region) -> cres<ty::region> {\n-        self.regions_static_r(r) // LUB is commutative\n-    }\n+        indent {||\n+            alt (a, b) {\n+              (ty::re_static, _) | (_, ty::re_static) {\n+                ok(ty::re_static) // nothing lives longer than static\n+              }\n \n-    fn regions_free_scope(\n-        a: ty::region, _a_id: ast::node_id, _a_br: ty::bound_region,\n-        _b: ty::region, _b_id: ast::node_id) -> cres<ty::region> {\n+              (ty::re_var(a_id), ty::re_var(b_id)) {\n+                lattice_vars(self, self.infcx().rb,\n+                           a, a_id, b_id,\n+                           {|x, y| self.regions(x, y) })\n+              }\n \n-        // for LUB, the scope is within the function and the free\n-        // region is always a parameter to the method.\n-        ret ok(a); // NDM--not so for nested functions\n-    }\n+              (ty::re_var(v_id), r) |\n+              (r, ty::re_var(v_id)) {\n+                lattice_var_t(self, self.infcx().rb,\n+                              v_id, r,\n+                              {|x, y| self.regions(x, y) })\n+              }\n \n-    fn regions_scope_free(\n-        a: ty::region, a_id: ast::node_id,\n-        b: ty::region, b_id: ast::node_id, b_br: ty::bound_region)\n-        -> cres<ty::region> {\n+              (f @ ty::re_free(f_id, f_br), ty::re_scope(s_id)) |\n+              (ty::re_scope(s_id), f @ ty::re_free(f_id, f_br)) {\n+                // for LUB, the scope is within the function and the free\n+                // region is always a parameter to the method.\n+                ok(f) // NDM--not so for nested functions\n+              }\n \n-        // LUB is commutative:\n-        self.regions_free_scope(b, b_id, b_br, a, a_id)\n-    }\n+              (ty::re_scope(a_id), ty::re_scope(b_id)) {\n+                // The region corresponding to an outer block is a\n+                // subtype of the region corresponding to an inner\n+                // block.\n+                let rm = self.infcx().tcx.region_map;\n+                alt region::nearest_common_ancestor(rm, a_id, b_id) {\n+                  some(r_id) { ok(ty::re_scope(r_id)) }\n+                  _ { err(ty::terr_regions_differ(b, a)) }\n+                }\n+              }\n \n-    fn regions_scope_scope(a: ty::region, a_id: ast::node_id,\n-                             b: ty::region, b_id: ast::node_id)\n-        -> cres<ty::region> {\n+              // For these types, we cannot define any additional\n+              // relationship:\n+              (ty::re_free(_, _), ty::re_free(_, _)) |\n+              (ty::re_bound(_), ty::re_bound(_)) |\n+              (ty::re_bound(_), ty::re_free(_, _)) |\n+              (ty::re_bound(_), ty::re_scope(_)) |\n+              (ty::re_free(_, _), ty::re_bound(_)) |\n+              (ty::re_scope(_), ty::re_bound(_)) {\n+                if a == b {\n+                    ok(a)\n+                } else {\n+                    err(ty::terr_regions_differ(b, a))\n+                }\n+              }\n \n-        // The region corresponding to an outer block is a subtype of the\n-        // region corresponding to an inner block.\n-        let rm = self.infcx().tcx.region_map;\n-        alt region::nearest_common_ancestor(rm, a_id, b_id) {\n-          some(r_id) { ok(ty::re_scope(r_id)) }\n-          _ { err(ty::terr_regions_differ(b, a)) }\n+              (ty::re_default, _) |\n+              (_, ty::re_default) {\n+                // actually a compiler bug, I think.\n+                err(ty::terr_regions_differ(b, a))\n+              }\n+            }\n         }\n     }\n \n-    fn tvars(a: ty::ty_vid, b: ty::ty_vid) -> cres<ty::t> {\n-        super_vars(self, self.infcx().vb,\n-                   ty::mk_var(self.infcx().tcx, a), a, b,\n-                   {|x, y| self.tys(x, y) })\n-    }\n-\n-    fn tvar_ty(a: ty::ty_vid, b: ty::t) -> cres<ty::t> {\n-        super_var_t(self, self.infcx().vb, a, b,\n-                    {|x, y| self.tys(x, y) })\n-    }\n-\n-    fn ty_tvar(a: ty::t, b: ty::ty_vid) -> cres<ty::t> {\n-        self.tvar_ty(b, a) // commutative\n-    }\n-\n-    fn rvars(a: ty::region_vid, b: ty::region_vid) -> cres<ty::region> {\n-        super_vars(self, self.infcx().rb,\n-                   ty::re_var(a), a, b,\n-                   {|x, y| self.regions(x, y) })\n-    }\n-\n-    fn rvar_r(a: ty::region_vid, b: ty::region) -> cres<ty::region> {\n-        super_var_t(self, self.infcx().rb,\n-                    a, b,\n-                    {|x, y| self.regions(x, y) })\n-    }\n-\n-    fn r_rvar(a: ty::region, b: ty::region_vid) -> cres<ty::region> {\n-        self.rvar_r(b, a) // commutative\n-    }\n-\n     // Traits please:\n \n     fn tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n-        super_tys(self, a, b)\n-    }\n-\n-    fn regions(a: ty::region, b: ty::region) -> cres<ty::region> {\n-        super_regions(self, a, b)\n+        lattice_tys(self, a, b)\n     }\n \n     fn flds(a: ty::field, b: ty::field) -> cres<ty::field> {\n@@ -1575,26 +1250,8 @@ impl of combine for lub {\n \n impl of combine for glb {\n     fn infcx() -> infer_ctxt { *self }\n-\n     fn tag() -> str { \"glb\" }\n \n-    fn bnd<V:copy>(b: bounds<V>) -> option<V> {\n-        b.lb\n-    }\n-\n-    fn with_bnd<V:copy>(b: bounds<V>, v: V) -> bounds<V> {\n-        assert b.lb == none;\n-        {lb: some(v) with b}\n-    }\n-\n-    fn bot_ty(_b: ty::t) -> cres<ty::t> {\n-        ok(ty::mk_bot(self.infcx().tcx))\n-    }\n-\n-    fn ty_bot(b: ty::t) -> cres<ty::t> {\n-        self.bot_ty(b) // GLB is commutative\n-    }\n-\n     fn mts(a: ty::mt, b: ty::mt) -> cres<ty::mt> {\n         let tcx = self.infcx().tcx;\n \n@@ -1607,12 +1264,12 @@ impl of combine for glb {\n           // If one side or both is mut, then the GLB must use\n           // the precise type from the mut side.\n           (ast::m_mutbl, ast::m_const) {\n-            self.infcx().tys(a.ty, b.ty).then {||\n+            sub(*self).tys(a.ty, b.ty).chain {|_t|\n                 ok({ty: a.ty, mutbl: ast::m_mutbl})\n             }\n           }\n           (ast::m_const, ast::m_mutbl) {\n-            self.infcx().tys(b.ty, a.ty).then {||\n+            sub(*self).tys(b.ty, a.ty).chain {|_t|\n                 ok({ty: b.ty, mutbl: ast::m_mutbl})\n             }\n           }\n@@ -1677,110 +1334,243 @@ impl of combine for glb {\n     }\n \n     fn regions(a: ty::region, b: ty::region) -> cres<ty::region> {\n-        super_regions(self, a, b)\n+        #debug[\"%s.regions(%?, %?)\",\n+               self.tag(),\n+               a.to_str(self.infcx()),\n+               b.to_str(self.infcx())];\n+\n+        indent {||\n+            alt (a, b) {\n+              (ty::re_static, r) | (r, ty::re_static) {\n+                // static lives longer than everything else\n+                ok(r)\n+              }\n+\n+              (ty::re_var(a_id), ty::re_var(b_id)) {\n+                lattice_vars(self, self.infcx().rb,\n+                             a, a_id, b_id,\n+                             {|x, y| self.regions(x, y) })\n+              }\n+\n+              (ty::re_var(v_id), _) | (_, ty::re_var(v_id)) {\n+               lattice_var_t(self, self.infcx().rb,\n+                             v_id, b,\n+                             {|x, y| self.regions(x, y) })\n+              }\n+\n+              (f @ ty::re_free(f_id, f_br), ty::re_scope(s_id)) |\n+              (ty::re_scope(s_id), f @ ty::re_free(f_id, f_br)) {\n+                // for GLB, the scope is within the function and the free\n+                // region is always a parameter to the method.  So the GLB\n+                // must be the scope.\n+                ok(b) // NDM--not so for nested functions\n+              }\n+\n+              (ty::re_scope(a_id), ty::re_scope(b_id)) {\n+                // We want to generate a region that is contained by both of\n+                // these: so, if one of these scopes is a subscope of the\n+                // other, return it.  Otherwise fail.\n+                let rm = self.infcx().tcx.region_map;\n+                alt region::nearest_common_ancestor(rm, a_id, b_id) {\n+                  some(r_id) if a_id == r_id { ok(b) }\n+                  some(r_id) if b_id == r_id { ok(a) }\n+                  _ { err(ty::terr_regions_differ(b, a)) }\n+                }\n+              }\n+\n+              // For these types, we cannot define any additional\n+              // relationship:\n+              (ty::re_free(_, _), ty::re_free(_, _)) |\n+              (ty::re_bound(_), ty::re_bound(_)) |\n+              (ty::re_bound(_), ty::re_free(_, _)) |\n+              (ty::re_bound(_), ty::re_scope(_)) |\n+              (ty::re_free(_, _), ty::re_bound(_)) |\n+              (ty::re_scope(_), ty::re_bound(_)) {\n+                if a == b {\n+                    ok(a)\n+                } else {\n+                    err(ty::terr_regions_differ(b, a))\n+                }\n+              }\n+\n+              (ty::re_default, _) |\n+              (_, ty::re_default) {\n+                // actually a compiler bug, I think.\n+                err(ty::terr_regions_differ(b, a))\n+              }\n+            }\n+        }\n     }\n \n     fn contraregions(a: ty::region, b: ty::region) -> cres<ty::region> {\n         lub(self.infcx()).regions(a, b)\n     }\n \n-    fn regions_static_r(r: ty::region) -> cres<ty::region> {\n-        // static lives longer than everything else\n-        ret ok(r);\n+    fn tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n+        lattice_tys(self, a, b)\n     }\n \n-    fn regions_r_static(r: ty::region) -> cres<ty::region> {\n-        self.regions_static_r(r) // GLB is commutative\n+    // Traits please:\n+\n+    fn flds(a: ty::field, b: ty::field) -> cres<ty::field> {\n+        super_flds(self, a, b)\n     }\n \n-    fn regions_free_scope(\n-        _a: ty::region, _a_id: ast::node_id, _a_br: ty::bound_region,\n-        b: ty::region, _b_id: ast::node_id) -> cres<ty::region> {\n+    fn modes(a: ast::mode, b: ast::mode) -> cres<ast::mode> {\n+        super_modes(self, a, b)\n+    }\n \n-        // for GLB, the scope is within the function and the free\n-        // region is always a parameter to the method.  So the GLB\n-        // must be the scope.\n-        ret ok(b); // NDM--not so for nested functions\n+    fn args(a: ty::arg, b: ty::arg) -> cres<ty::arg> {\n+        super_args(self, a, b)\n     }\n \n-    fn regions_scope_free(\n-        a: ty::region, a_id: ast::node_id,\n-        b: ty::region, b_id: ast::node_id, b_br: ty::bound_region)\n-        -> cres<ty::region> {\n+    fn fns(a: ty::fn_ty, b: ty::fn_ty) -> cres<ty::fn_ty> {\n+        super_fns(self, a, b)\n+    }\n \n-        // GLB is commutative:\n-        self.regions_free_scope(b, b_id, b_br, a, a_id)\n+    fn tps(as: [ty::t], bs: [ty::t]) -> cres<[ty::t]> {\n+        super_tps(self, as, bs)\n     }\n+}\n \n-    fn regions_scope_scope(a: ty::region, a_id: ast::node_id,\n-                             b: ty::region, b_id: ast::node_id)\n-        -> cres<ty::region> {\n+// ______________________________________________________________________\n+// Lattice operations on variables\n+//\n+// this is common code used by both LUB and GLB\n \n-        // We want to generate a region that is contained by both of\n-        // these: so, if one of these scopes is a subscope of the\n-        // other, return it.  Otherwise fail.\n-        let rm = self.infcx().tcx.region_map;\n-        alt region::nearest_common_ancestor(rm, a_id, b_id) {\n-          some(r_id) if a_id == r_id { ok(b) }\n-          some(r_id) if b_id == r_id { ok(a) }\n-          _ { err(ty::terr_regions_differ(b, a)) }\n-        }\n-    }\n+iface lattice_ops {\n+    fn bnd<T:copy>(b: bounds<T>) -> option<T>;\n+    fn with_bnd<T:copy>(b: bounds<T>, t: T) -> bounds<T>;\n+    fn ty_bot(t: ty::t) -> cres<ty::t>;\n+}\n \n-    fn tvars(a: ty::ty_vid, b: ty::ty_vid) -> cres<ty::t> {\n-        super_vars(self, self.infcx().vb,\n-                   ty::mk_var(self.infcx().tcx, a), a, b,\n-                   {|x, y| self.tys(x, y) })\n+impl of lattice_ops for lub {\n+    fn bnd<T:copy>(b: bounds<T>) -> option<T> { b.ub }\n+    fn with_bnd<T:copy>(b: bounds<T>, t: T) -> bounds<T> {\n+        {ub: some(t) with b}\n     }\n-\n-    fn tvar_ty(a: ty::ty_vid, b: ty::t) -> cres<ty::t> {\n-        super_var_t(self, self.infcx().vb, a, b,\n-                    {|x, y| self.tys(x, y) })\n+    fn ty_bot(t: ty::t) -> cres<ty::t> {\n+        ok(t)\n     }\n+}\n \n-    fn ty_tvar(a: ty::t, b: ty::ty_vid) -> cres<ty::t> {\n-        self.tvar_ty(b, a) // commutative\n+impl of lattice_ops for glb {\n+    fn bnd<T:copy>(b: bounds<T>) -> option<T> { b.lb }\n+    fn with_bnd<T:copy>(b: bounds<T>, t: T) -> bounds<T> {\n+        {lb: some(t) with b}\n     }\n-\n-    fn rvars(a: ty::region_vid, b: ty::region_vid) -> cres<ty::region> {\n-        super_vars(self, self.infcx().rb,\n-                   ty::re_var(a), a, b,\n-                   {|x, y| self.regions(x, y) })\n+    fn ty_bot(_t: ty::t) -> cres<ty::t> {\n+        ok(ty::mk_bot(self.infcx().tcx))\n     }\n+}\n \n-    fn rvar_r(a: ty::region_vid, b: ty::region) -> cres<ty::region> {\n-        super_var_t(self, self.infcx().rb,\n-                    a, b,\n-                    {|x, y| self.regions(x, y) })\n-    }\n+fn lattice_tys<L:lattice_ops combine>(\n+    self: L, a: ty::t, b: ty::t) -> cres<ty::t> {\n \n-    fn r_rvar(a: ty::region, b: ty::region_vid) -> cres<ty::region> {\n-        self.rvar_r(b, a) // commutative\n-    }\n+    #debug(\"%s.tys(%s, %s)\", self.tag(),\n+           a.to_str(self.infcx()),\n+           b.to_str(self.infcx()));\n+    if a == b { ret ok(a); }\n+    indent {||\n+        alt (ty::get(a).struct, ty::get(b).struct) {\n+          (ty::ty_bot, _) { self.ty_bot(b) }\n+          (_, ty::ty_bot) { self.ty_bot(a) }\n \n-    // Traits please:\n+          (ty::ty_var(a_id), ty::ty_var(b_id)) {\n+            lattice_vars(self, self.infcx().vb,\n+                         a, a_id, b_id,\n+                         {|x, y| self.tys(x, y) })\n+          }\n \n-    fn tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n-        super_tys(self, a, b)\n-    }\n+          (ty::ty_var(a_id), _) {\n+            lattice_var_t(self, self.infcx().vb, a_id, b,\n+                          {|x, y| self.tys(x, y) })\n+          }\n \n-    fn flds(a: ty::field, b: ty::field) -> cres<ty::field> {\n-        super_flds(self, a, b)\n+          (_, ty::ty_var(b_id)) {\n+            lattice_var_t(self, self.infcx().vb, b_id, a,\n+                          {|x, y| self.tys(x, y) })\n+          }\n+\n+          _ {\n+            super_tys(self, a, b)\n+          }\n+        }\n     }\n+}\n \n-    fn modes(a: ast::mode, b: ast::mode) -> cres<ast::mode> {\n-        super_modes(self, a, b)\n+fn lattice_vars<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n+    self: L, vb: vals_and_bindings<V, T>,\n+    a_t: T, a_vid: V, b_vid: V,\n+    c_ts: fn(T, T) -> cres<T>) -> cres<T> {\n+\n+    // The comments in this function are written for LUB and types,\n+    // but they apply equally well to GLB and regions if you inverse\n+    // upper/lower/sub/super/etc.\n+\n+    // Need to find a type that is a supertype of both a and b:\n+    let {root: a_vid, bounds: a_bounds} = self.infcx().get(vb, a_vid);\n+    let {root: b_vid, bounds: b_bounds} = self.infcx().get(vb, b_vid);\n+\n+    #debug[\"%s.vars(%s=%s <: %s=%s)\",\n+           self.tag(),\n+           a_vid.to_str(), a_bounds.to_str(self.infcx()),\n+           b_vid.to_str(), b_bounds.to_str(self.infcx())];\n+\n+    if a_vid == b_vid {\n+        ret ok(a_t);\n     }\n \n-    fn args(a: ty::arg, b: ty::arg) -> cres<ty::arg> {\n-        super_args(self, a, b)\n+    // If both A and B have an UB type, then we can just compute the\n+    // LUB of those types:\n+    let a_bnd = self.bnd(a_bounds), b_bnd = self.bnd(b_bounds);\n+    alt (a_bnd, b_bnd) {\n+      (some(a_ty), some(b_ty)) {\n+        alt self.infcx().try {|| c_ts(a_ty, b_ty) } {\n+            ok(t) { ret ok(t); }\n+            err(_) { /*fallthrough */ }\n+        }\n+      }\n+      _ {/*fallthrough*/}\n     }\n \n-    fn fns(a: ty::fn_ty, b: ty::fn_ty) -> cres<ty::fn_ty> {\n-        super_fns(self, a, b)\n+    // Otherwise, we need to merge A and B into one variable.  We can\n+    // then use either variable as an upper bound:\n+    self.infcx().vars(vb, a_vid, b_vid).then {||\n+        ok(a_t)\n     }\n+}\n \n-    fn tps(as: [ty::t], bs: [ty::t]) -> cres<[ty::t]> {\n-        super_tps(self, as, bs)\n+fn lattice_var_t<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n+    self: L, vb: vals_and_bindings<V, T>,\n+    a_vid: V, b: T,\n+    c_ts: fn(T, T) -> cres<T>) -> cres<T> {\n+\n+    let {root: a_id, bounds: a_bounds} = self.infcx().get(vb, a_vid);\n+\n+    // The comments in this function are written for LUB, but they\n+    // apply equally well to GLB if you inverse upper/lower/sub/super/etc.\n+\n+    #debug[\"%s.var_ty(%s=%s <: %s)\",\n+           self.tag(),\n+           a_id.to_str(), a_bounds.to_str(self.infcx()),\n+           b.to_str(self.infcx())];\n+\n+    alt self.bnd(a_bounds) {\n+      some(a_bnd) {\n+        // If a has an upper bound, return it.\n+        #debug[\"bnd=some(%s)\", a_bnd.to_str(self.infcx())];\n+        ret c_ts(a_bnd, b);\n+      }\n+      none {\n+        // If a does not have an upper bound, make b the upper bound of a\n+        // and then return b.\n+        #debug[\"bnd=none\"];\n+        let a_bounds = self.with_bnd(a_bounds, b);\n+        self.infcx().bnds(a_bounds.lb, a_bounds.ub).then {||\n+            self.infcx().set(vb, a_id, bounded(a_bounds));\n+            ok(b)\n+        }\n+      }\n     }\n }"}]}