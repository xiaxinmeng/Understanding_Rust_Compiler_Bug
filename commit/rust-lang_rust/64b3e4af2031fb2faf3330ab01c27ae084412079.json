{"sha": "64b3e4af2031fb2faf3330ab01c27ae084412079", "node_id": "C_kwDOAAsO6NoAKDY0YjNlNGFmMjAzMWZiMmZhZjMzMzBhYjAxYzI3YWUwODQ0MTIwNzk", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2022-08-19T17:51:20Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2022-08-19T17:51:20Z"}, "message": "suggest adding a reference to a trait assoc item", "tree": {"sha": "2d515f61eb2d3ee419afd87219de9029ed0a180f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d515f61eb2d3ee419afd87219de9029ed0a180f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64b3e4af2031fb2faf3330ab01c27ae084412079", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64b3e4af2031fb2faf3330ab01c27ae084412079", "html_url": "https://github.com/rust-lang/rust/commit/64b3e4af2031fb2faf3330ab01c27ae084412079", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64b3e4af2031fb2faf3330ab01c27ae084412079/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75b7e52e92c3b00fc891b47f5b2efdff0a2be55a", "url": "https://api.github.com/repos/rust-lang/rust/commits/75b7e52e92c3b00fc891b47f5b2efdff0a2be55a", "html_url": "https://github.com/rust-lang/rust/commit/75b7e52e92c3b00fc891b47f5b2efdff0a2be55a"}], "stats": {"total": 241, "additions": 156, "deletions": 85}, "files": [{"sha": "28b3d886b50b5392327a649f9fe17e3cd46c19c0", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 101, "deletions": 85, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/64b3e4af2031fb2faf3330ab01c27ae084412079/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b3e4af2031fb2faf3330ab01c27ae084412079/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=64b3e4af2031fb2faf3330ab01c27ae084412079", "patch": "@@ -882,6 +882,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             obligation.cause.code()\n         {\n             &parent_code\n+        } else if let ObligationCauseCode::ItemObligation(_) = obligation.cause.code() {\n+            obligation.cause.code()\n         } else if let ExpnKind::Desugaring(DesugaringKind::ForLoop) =\n             span.ctxt().outer_expn_data().kind\n         {\n@@ -906,102 +908,116 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let param_env = obligation.param_env;\n \n         // Try to apply the original trait binding obligation by borrowing.\n-        let mut try_borrowing =\n-            |old_pred: ty::PolyTraitPredicate<'tcx>, blacklist: &[DefId]| -> bool {\n-                if blacklist.contains(&old_pred.def_id()) {\n-                    return false;\n-                }\n-                // We map bounds to `&T` and `&mut T`\n-                let trait_pred_and_imm_ref = old_pred.map_bound(|trait_pred| {\n-                    (\n-                        trait_pred,\n-                        self.tcx.mk_imm_ref(self.tcx.lifetimes.re_static, trait_pred.self_ty()),\n-                    )\n-                });\n-                let trait_pred_and_mut_ref = old_pred.map_bound(|trait_pred| {\n-                    (\n-                        trait_pred,\n-                        self.tcx.mk_mut_ref(self.tcx.lifetimes.re_static, trait_pred.self_ty()),\n-                    )\n-                });\n+        let mut try_borrowing = |old_pred: ty::PolyTraitPredicate<'tcx>,\n+                                 blacklist: &[DefId]|\n+         -> bool {\n+            if blacklist.contains(&old_pred.def_id()) {\n+                return false;\n+            }\n+            // We map bounds to `&T` and `&mut T`\n+            let trait_pred_and_imm_ref = old_pred.map_bound(|trait_pred| {\n+                (\n+                    trait_pred,\n+                    self.tcx.mk_imm_ref(self.tcx.lifetimes.re_static, trait_pred.self_ty()),\n+                )\n+            });\n+            let trait_pred_and_mut_ref = old_pred.map_bound(|trait_pred| {\n+                (\n+                    trait_pred,\n+                    self.tcx.mk_mut_ref(self.tcx.lifetimes.re_static, trait_pred.self_ty()),\n+                )\n+            });\n \n-                let mk_result = |trait_pred_and_new_ty| {\n-                    let obligation =\n-                        self.mk_trait_obligation_with_new_self_ty(param_env, trait_pred_and_new_ty);\n-                    self.predicate_must_hold_modulo_regions(&obligation)\n+            let mk_result = |trait_pred_and_new_ty| {\n+                let obligation =\n+                    self.mk_trait_obligation_with_new_self_ty(param_env, trait_pred_and_new_ty);\n+                self.predicate_must_hold_modulo_regions(&obligation)\n+            };\n+            let imm_result = mk_result(trait_pred_and_imm_ref);\n+            let mut_result = mk_result(trait_pred_and_mut_ref);\n+\n+            let ref_inner_ty_result =\n+                if let ObligationCauseCode::ItemObligation(_) = obligation.cause.code()\n+                    && let ty::Ref(_, ty, mutability) = old_pred.self_ty().skip_binder().kind()\n+                {\n+                    Some((mk_result(old_pred.map_bound(|trait_pred| (trait_pred, *ty))), mutability))\n+                } else {\n+                    None\n                 };\n-                let imm_result = mk_result(trait_pred_and_imm_ref);\n-                let mut_result = mk_result(trait_pred_and_mut_ref);\n-\n-                if imm_result || mut_result {\n-                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n-                        // We have a very specific type of error, where just borrowing this argument\n-                        // might solve the problem. In cases like this, the important part is the\n-                        // original type obligation, not the last one that failed, which is arbitrary.\n-                        // Because of this, we modify the error to refer to the original obligation and\n-                        // return early in the caller.\n-\n-                        let msg = format!(\"the trait bound `{}` is not satisfied\", old_pred);\n-                        if has_custom_message {\n-                            err.note(&msg);\n-                        } else {\n-                            err.message =\n-                                vec![(rustc_errors::DiagnosticMessage::Str(msg), Style::NoStyle)];\n-                        }\n-                        if snippet.starts_with('&') {\n-                            // This is already a literal borrow and the obligation is failing\n-                            // somewhere else in the obligation chain. Do not suggest non-sense.\n-                            return false;\n-                        }\n-                        err.span_label(\n-                            span,\n-                            &format!(\n-                                \"expected an implementor of trait `{}`\",\n-                                old_pred.print_modifiers_and_trait_path(),\n-                            ),\n-                        );\n \n-                        // This if is to prevent a special edge-case\n-                        if matches!(\n-                            span.ctxt().outer_expn_data().kind,\n-                            ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop)\n-                        ) {\n-                            // We don't want a borrowing suggestion on the fields in structs,\n-                            // ```\n-                            // struct Foo {\n-                            //  the_foos: Vec<Foo>\n-                            // }\n-                            // ```\n+            if imm_result || mut_result || ref_inner_ty_result.map_or(false, |(result, _)| result) {\n+                if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                    // We have a very specific type of error, where just borrowing this argument\n+                    // might solve the problem. In cases like this, the important part is the\n+                    // original type obligation, not the last one that failed, which is arbitrary.\n+                    // Because of this, we modify the error to refer to the original obligation and\n+                    // return early in the caller.\n+\n+                    let msg = format!(\"the trait bound `{}` is not satisfied\", old_pred);\n+                    if has_custom_message {\n+                        err.note(&msg);\n+                    } else {\n+                        err.message =\n+                            vec![(rustc_errors::DiagnosticMessage::Str(msg), Style::NoStyle)];\n+                    }\n+                    if snippet.starts_with('&') {\n+                        // This is already a literal borrow and the obligation is failing\n+                        // somewhere else in the obligation chain. Do not suggest non-sense.\n+                        return false;\n+                    }\n+                    err.span_label(\n+                        span,\n+                        &format!(\n+                            \"expected an implementor of trait `{}`\",\n+                            old_pred.print_modifiers_and_trait_path(),\n+                        ),\n+                    );\n \n-                            if imm_result && mut_result {\n-                                err.span_suggestions(\n-                                    span.shrink_to_lo(),\n-                                    \"consider borrowing here\",\n-                                    [\"&\".to_string(), \"&mut \".to_string()].into_iter(),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            } else {\n-                                err.span_suggestion_verbose(\n-                                    span.shrink_to_lo(),\n-                                    &format!(\n-                                        \"consider{} borrowing here\",\n-                                        if mut_result { \" mutably\" } else { \"\" }\n-                                    ),\n-                                    format!(\"&{}\", if mut_result { \"mut \" } else { \"\" }),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            }\n+                    // This if is to prevent a special edge-case\n+                    if matches!(\n+                        span.ctxt().outer_expn_data().kind,\n+                        ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop)\n+                    ) {\n+                        // We don't want a borrowing suggestion on the fields in structs,\n+                        // ```\n+                        // struct Foo {\n+                        //  the_foos: Vec<Foo>\n+                        // }\n+                        // ```\n+\n+                        if imm_result && mut_result {\n+                            err.span_suggestions(\n+                                span.shrink_to_lo(),\n+                                \"consider borrowing here\",\n+                                [\"&\".to_string(), \"&mut \".to_string()].into_iter(),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        } else {\n+                            let is_mut = mut_result\n+                                || ref_inner_ty_result.map_or(false, |(_, mutabl)| {\n+                                    matches!(mutabl, hir::Mutability::Mut)\n+                                });\n+                            err.span_suggestion_verbose(\n+                                span.shrink_to_lo(),\n+                                &format!(\n+                                    \"consider{} borrowing here\",\n+                                    if is_mut { \" mutably\" } else { \"\" }\n+                                ),\n+                                format!(\"&{}\", if is_mut { \"mut \" } else { \"\" }),\n+                                Applicability::MaybeIncorrect,\n+                            );\n                         }\n-                        return true;\n                     }\n+                    return true;\n                 }\n-                return false;\n-            };\n+            }\n+            return false;\n+        };\n \n         if let ObligationCauseCode::ImplDerivedObligation(cause) = &*code {\n             try_borrowing(cause.derived.parent_trait_pred, &[])\n         } else if let ObligationCauseCode::BindingObligation(_, _)\n-        | ObligationCauseCode::ItemObligation(_) = code\n+        | ObligationCauseCode::ItemObligation(..) = code\n         {\n             try_borrowing(poly_trait_pred, &never_suggest_borrow)\n         } else {"}, {"sha": "e9b8a9caa484a6be3c8e9f0ca772725ded05f9bc", "filename": "src/test/ui/suggestions/suggest-adding-reference-to-trait-assoc-item.fixed", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/64b3e4af2031fb2faf3330ab01c27ae084412079/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-adding-reference-to-trait-assoc-item.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/64b3e4af2031fb2faf3330ab01c27ae084412079/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-adding-reference-to-trait-assoc-item.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-adding-reference-to-trait-assoc-item.fixed?ref=64b3e4af2031fb2faf3330ab01c27ae084412079", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+#![allow(unused_variables)]\n+\n+fn foo(foo: &mut usize) {\n+    todo!()\n+}\n+\n+fn bar(bar: &usize) {\n+    todo!()\n+}\n+\n+fn main() {\n+    foo(&mut Default::default()); //~ the trait bound `&mut usize: Default` is not satisfied\n+    bar(&Default::default()); //~ the trait bound `&usize: Default` is not satisfied\n+}"}, {"sha": "5fae21cccef23da3db1d02e7c4fec5d09abfb179", "filename": "src/test/ui/suggestions/suggest-adding-reference-to-trait-assoc-item.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/64b3e4af2031fb2faf3330ab01c27ae084412079/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-adding-reference-to-trait-assoc-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b3e4af2031fb2faf3330ab01c27ae084412079/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-adding-reference-to-trait-assoc-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-adding-reference-to-trait-assoc-item.rs?ref=64b3e4af2031fb2faf3330ab01c27ae084412079", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+#![allow(unused_variables)]\n+\n+fn foo(foo: &mut usize) {\n+    todo!()\n+}\n+\n+fn bar(bar: &usize) {\n+    todo!()\n+}\n+\n+fn main() {\n+    foo(Default::default()); //~ the trait bound `&mut usize: Default` is not satisfied\n+    bar(Default::default()); //~ the trait bound `&usize: Default` is not satisfied\n+}"}, {"sha": "b930d22a3915eb39298983424be06de67f585d4a", "filename": "src/test/ui/suggestions/suggest-adding-reference-to-trait-assoc-item.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/64b3e4af2031fb2faf3330ab01c27ae084412079/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-adding-reference-to-trait-assoc-item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64b3e4af2031fb2faf3330ab01c27ae084412079/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-adding-reference-to-trait-assoc-item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-adding-reference-to-trait-assoc-item.stderr?ref=64b3e4af2031fb2faf3330ab01c27ae084412079", "patch": "@@ -0,0 +1,25 @@\n+error[E0277]: the trait bound `&mut usize: Default` is not satisfied\n+  --> $DIR/suggest-adding-reference-to-trait-assoc-item.rs:13:9\n+   |\n+LL |     foo(Default::default());\n+   |         ^^^^^^^^^^^^^^^^ expected an implementor of trait `Default`\n+   |\n+help: consider mutably borrowing here\n+   |\n+LL |     foo(&mut Default::default());\n+   |         ++++\n+\n+error[E0277]: the trait bound `&usize: Default` is not satisfied\n+  --> $DIR/suggest-adding-reference-to-trait-assoc-item.rs:14:9\n+   |\n+LL |     bar(Default::default());\n+   |         ^^^^^^^^^^^^^^^^ expected an implementor of trait `Default`\n+   |\n+help: consider borrowing here\n+   |\n+LL |     bar(&Default::default());\n+   |         +\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}]}