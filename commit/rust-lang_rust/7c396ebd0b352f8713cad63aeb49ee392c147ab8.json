{"sha": "7c396ebd0b352f8713cad63aeb49ee392c147ab8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjMzk2ZWJkMGIzNTJmODcxM2NhZDYzYWViNDllZTM5MmMxNDdhYjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-18T07:35:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-18T07:35:43Z"}, "message": "Auto merge of #48985 - scalexm:lowering, r=nikomatsakis\n\nMVP for chalkification\n\nr? @nikomatsakis", "tree": {"sha": "fbe9f0b27e984ff7317a180307c4088eb8dd46f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fbe9f0b27e984ff7317a180307c4088eb8dd46f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c396ebd0b352f8713cad63aeb49ee392c147ab8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c396ebd0b352f8713cad63aeb49ee392c147ab8", "html_url": "https://github.com/rust-lang/rust/commit/7c396ebd0b352f8713cad63aeb49ee392c147ab8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c396ebd0b352f8713cad63aeb49ee392c147ab8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "html_url": "https://github.com/rust-lang/rust/commit/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11"}, {"sha": "ef3b4e1f5bfb8cf5347b086ed60aefd519a3335d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef3b4e1f5bfb8cf5347b086ed60aefd519a3335d", "html_url": "https://github.com/rust-lang/rust/commit/ef3b4e1f5bfb8cf5347b086ed60aefd519a3335d"}], "stats": {"total": 529, "additions": 526, "deletions": 3}, "files": [{"sha": "744e3a5eaabccb4c2dd346506152aecf55c64b79", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c396ebd0b352f8713cad63aeb49ee392c147ab8/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c396ebd0b352f8713cad63aeb49ee392c147ab8/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=7c396ebd0b352f8713cad63aeb49ee392c147ab8", "patch": "@@ -648,6 +648,8 @@ define_dep_nodes!( <'tcx>\n     [] GetSymbolExportLevel(DefId),\n \n     [input] Features,\n+\n+    [] ProgramClausesFor(DefId),\n );\n \n trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {"}, {"sha": "7f91bbd6ea27c90af17e771b64e856b9fd5e1416", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/7c396ebd0b352f8713cad63aeb49ee392c147ab8/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c396ebd0b352f8713cad63aeb49ee392c147ab8/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=7c396ebd0b352f8713cad63aeb49ee392c147ab8", "patch": "@@ -1285,3 +1285,86 @@ impl_stable_hash_for!(struct infer::canonical::QueryRegionConstraints<'tcx> {\n impl_stable_hash_for!(enum infer::canonical::Certainty {\n     Proven, Ambiguous\n });\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::WhereClauseAtom<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use traits::WhereClauseAtom::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match self {\n+            Implemented(trait_ref) => trait_ref.hash_stable(hcx, hasher),\n+            ProjectionEq(projection) => projection.hash_stable(hcx, hasher),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::DomainGoal<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use traits::DomainGoal::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match self {\n+            Holds(where_clause) |\n+            WellFormed(where_clause) |\n+            FromEnv(where_clause) => where_clause.hash_stable(hcx, hasher),\n+\n+            WellFormedTy(ty) => ty.hash_stable(hcx, hasher),\n+            FromEnvTy(ty) => ty.hash_stable(hcx, hasher),\n+            RegionOutlives(predicate) => predicate.hash_stable(hcx, hasher),\n+            TypeOutlives(predicate) => predicate.hash_stable(hcx, hasher),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::Goal<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use traits::Goal::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match self {\n+            Implies(hypotheses, goal) => {\n+                hypotheses.hash_stable(hcx, hasher);\n+                goal.hash_stable(hcx, hasher);\n+            },\n+            And(goal1, goal2) => {\n+                goal1.hash_stable(hcx, hasher);\n+                goal2.hash_stable(hcx, hasher);\n+            }\n+            Not(goal) => goal.hash_stable(hcx, hasher),\n+            DomainGoal(domain_goal) => domain_goal.hash_stable(hcx, hasher),\n+            Quantified(quantifier, goal) => {\n+                quantifier.hash_stable(hcx, hasher);\n+                goal.hash_stable(hcx, hasher);\n+            },\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::Clause<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use traits::Clause::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match self {\n+            Implies(hypotheses, goal) => {\n+                hypotheses.hash_stable(hcx, hasher);\n+                goal.hash_stable(hcx, hasher);\n+            }\n+            DomainGoal(domain_goal) => domain_goal.hash_stable(hcx, hasher),\n+            ForAll(clause) => clause.hash_stable(hcx, hasher),\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum traits::QuantifierKind {\n+    Universal,\n+    Existential\n+});"}, {"sha": "a0ba88f7d559af588dc43214c3b381a1b849a780", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/7c396ebd0b352f8713cad63aeb49ee392c147ab8/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c396ebd0b352f8713cad63aeb49ee392c147ab8/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=7c396ebd0b352f8713cad63aeb49ee392c147ab8", "patch": "@@ -29,6 +29,7 @@ use infer::{InferCtxt};\n \n use rustc_data_structures::sync::Lrc;\n use std::rc::Rc;\n+use std::convert::From;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -244,6 +245,69 @@ pub type Obligations<'tcx, O> = Vec<Obligation<'tcx, O>>;\n pub type PredicateObligations<'tcx> = Vec<PredicateObligation<'tcx>>;\n pub type TraitObligations<'tcx> = Vec<TraitObligation<'tcx>>;\n \n+/// The following types:\n+/// * `WhereClauseAtom`\n+/// * `DomainGoal`\n+/// * `Goal`\n+/// * `Clause`\n+/// are used for representing the trait system in the form of\n+/// logic programming clauses. They are part of the interface\n+/// for the chalk SLG solver.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub enum WhereClauseAtom<'tcx> {\n+    Implemented(ty::TraitPredicate<'tcx>),\n+    ProjectionEq(ty::ProjectionPredicate<'tcx>),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub enum DomainGoal<'tcx> {\n+    Holds(WhereClauseAtom<'tcx>),\n+    WellFormed(WhereClauseAtom<'tcx>),\n+    FromEnv(WhereClauseAtom<'tcx>),\n+    WellFormedTy(Ty<'tcx>),\n+    FromEnvTy(Ty<'tcx>),\n+    RegionOutlives(ty::RegionOutlivesPredicate<'tcx>),\n+    TypeOutlives(ty::TypeOutlivesPredicate<'tcx>),\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum QuantifierKind {\n+    Universal,\n+    Existential,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum Goal<'tcx> {\n+    // FIXME: use interned refs instead of `Box`\n+    Implies(Vec<Clause<'tcx>>, Box<Goal<'tcx>>),\n+    And(Box<Goal<'tcx>>, Box<Goal<'tcx>>),\n+    Not(Box<Goal<'tcx>>),\n+    DomainGoal(DomainGoal<'tcx>),\n+    Quantified(QuantifierKind, Box<ty::Binder<Goal<'tcx>>>)\n+}\n+\n+impl<'tcx> From<DomainGoal<'tcx>> for Goal<'tcx> {\n+    fn from(domain_goal: DomainGoal<'tcx>) -> Self {\n+        Goal::DomainGoal(domain_goal)\n+    }\n+}\n+\n+impl<'tcx> From<DomainGoal<'tcx>> for Clause<'tcx> {\n+    fn from(domain_goal: DomainGoal<'tcx>) -> Self {\n+        Clause::DomainGoal(domain_goal)\n+    }\n+}\n+\n+/// This matches the definition from Page 7 of \"A Proof Procedure for the Logic of Hereditary\n+/// Harrop Formulas\".\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum Clause<'tcx> {\n+    // FIXME: again, use interned refs instead of `Box`\n+    Implies(Vec<Goal<'tcx>>, DomainGoal<'tcx>),\n+    DomainGoal(DomainGoal<'tcx>),\n+    ForAll(Box<ty::Binder<Clause<'tcx>>>),\n+}\n+\n pub type Selection<'tcx> = Vtable<'tcx, PredicateObligation<'tcx>>;\n \n #[derive(Clone,Debug)]"}, {"sha": "d6e6f0e98adc48afb18f4f61efdae5ac64dec78d", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/7c396ebd0b352f8713cad63aeb49ee392c147ab8/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c396ebd0b352f8713cad63aeb49ee392c147ab8/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=7c396ebd0b352f8713cad63aeb49ee392c147ab8", "patch": "@@ -425,3 +425,138 @@ BraceStructTypeFoldableImpl! {\n         obligations\n     } where T: TypeFoldable<'tcx>\n }\n+\n+impl<'tcx> fmt::Display for traits::WhereClauseAtom<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        use traits::WhereClauseAtom::*;\n+\n+        match self {\n+            Implemented(trait_ref) => write!(fmt, \"Implemented({})\", trait_ref),\n+            ProjectionEq(projection) => write!(fmt, \"ProjectionEq({})\", projection),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::DomainGoal<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        use traits::DomainGoal::*;\n+        use traits::WhereClauseAtom::*;\n+\n+        match self {\n+            Holds(wc) => write!(fmt, \"{}\", wc),\n+            WellFormed(Implemented(trait_ref)) => write!(fmt, \"WellFormed({})\", trait_ref),\n+            WellFormed(ProjectionEq(projection)) => write!(fmt, \"WellFormed({})\", projection),\n+            FromEnv(Implemented(trait_ref)) => write!(fmt, \"FromEnv({})\", trait_ref),\n+            FromEnv(ProjectionEq(projection)) => write!(fmt, \"FromEnv({})\", projection),\n+            WellFormedTy(ty) => write!(fmt, \"WellFormed({})\", ty),\n+            FromEnvTy(ty) => write!(fmt, \"FromEnv({})\", ty),\n+            RegionOutlives(predicate) => write!(fmt, \"RegionOutlives({})\", predicate),\n+            TypeOutlives(predicate) => write!(fmt, \"TypeOutlives({})\", predicate),\n+        }\n+    }\n+}\n+\n+impl fmt::Display for traits::QuantifierKind {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        use traits::QuantifierKind::*;\n+\n+        match self {\n+            Universal => write!(fmt, \"forall\"),\n+            Existential => write!(fmt, \"exists\"),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::Goal<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        use traits::Goal::*;\n+\n+        match self {\n+            Implies(hypotheses, goal) => {\n+                write!(fmt, \"if (\")?;\n+                for (index, hyp) in hypotheses.iter().enumerate() {\n+                    if index > 0 {\n+                        write!(fmt, \", \")?;\n+                    }\n+                    write!(fmt, \"{}\", hyp)?;\n+                }\n+                write!(fmt, \") {{ {} }}\", goal)\n+            }\n+            And(goal1, goal2) => write!(fmt, \"({} && {})\", goal1, goal2),\n+            Not(goal) => write!(fmt, \"not {{ {} }}\", goal),\n+            DomainGoal(goal) => write!(fmt, \"{}\", goal),\n+            Quantified(qkind, goal) => {\n+                // FIXME: appropriate binder names\n+                write!(fmt, \"{}<> {{ {} }}\", qkind, goal.skip_binder())\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::Clause<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        use traits::Clause::*;\n+\n+        match self {\n+            Implies(hypotheses, goal) => {\n+                write!(fmt, \"{}\", goal)?;\n+                if !hypotheses.is_empty() {\n+                    write!(fmt, \" :- \")?;\n+                    for (index, condition) in hypotheses.iter().enumerate() {\n+                        if index > 0 {\n+                            write!(fmt, \", \")?;\n+                        }\n+                        write!(fmt, \"{}\", condition)?;\n+                    }\n+                }\n+                write!(fmt, \".\")\n+            }\n+            DomainGoal(domain_goal) => write!(fmt, \"{}.\", domain_goal),\n+            ForAll(clause) => {\n+                // FIXME: appropriate binder names\n+                write!(fmt, \"forall<> {{ {} }}\", clause.skip_binder())\n+            }\n+        }\n+    }\n+}\n+\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for traits::WhereClauseAtom<'tcx> {\n+        (traits::WhereClauseAtom::Implemented)(trait_ref),\n+        (traits::WhereClauseAtom::ProjectionEq)(projection),\n+    }\n+}\n+\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for traits::DomainGoal<'tcx> {\n+        (traits::DomainGoal::Holds)(wc),\n+        (traits::DomainGoal::WellFormed)(wc),\n+        (traits::DomainGoal::FromEnv)(wc),\n+        (traits::DomainGoal::WellFormedTy)(ty),\n+        (traits::DomainGoal::FromEnvTy)(ty),\n+        (traits::DomainGoal::RegionOutlives)(predicate),\n+        (traits::DomainGoal::TypeOutlives)(predicate),\n+    }\n+}\n+\n+CloneTypeFoldableImpls! {\n+    traits::QuantifierKind,\n+}\n+\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for traits::Goal<'tcx> {\n+        (traits::Goal::Implies)(hypotheses, goal),\n+        (traits::Goal::And)(goal1, goal2),\n+        (traits::Goal::Not)(goal),\n+        (traits::Goal::DomainGoal)(domain_goal),\n+        (traits::Goal::Quantified)(qkind, goal),\n+    }\n+}\n+\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for traits::Clause<'tcx> {\n+        (traits::Clause::Implies)(hypotheses, goal),\n+        (traits::Clause::DomainGoal)(domain_goal),\n+        (traits::Clause::ForAll)(clause),\n+    }\n+}"}, {"sha": "a3a0e26a843ac02f010c6b822efa7824c94e6c02", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c396ebd0b352f8713cad63aeb49ee392c147ab8/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c396ebd0b352f8713cad63aeb49ee392c147ab8/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=7c396ebd0b352f8713cad63aeb49ee392c147ab8", "patch": "@@ -693,6 +693,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::generics_of<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::program_clauses_for<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: DefId) -> String {\n+        format!(\"generating chalk-style clauses\")\n+    }\n+}\n+\n macro_rules! impl_disk_cacheable_query(\n     ($query_name:ident, |$key:tt| $cond:expr) => {\n         impl<'tcx> QueryDescription<'tcx> for queries::$query_name<'tcx> {"}, {"sha": "b6b7361bb2f72b2758851fc126a7b2d5b4466e9f", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c396ebd0b352f8713cad63aeb49ee392c147ab8/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c396ebd0b352f8713cad63aeb49ee392c147ab8/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=7c396ebd0b352f8713cad63aeb49ee392c147ab8", "patch": "@@ -38,6 +38,7 @@ use traits::query::{CanonicalProjectionGoal, CanonicalTyGoal, NoSolution};\n use traits::query::dropck_outlives::{DtorckConstraint, DropckOutlivesResult};\n use traits::query::normalize::NormalizationResult;\n use traits::specialization_graph;\n+use traits::Clause;\n use ty::{self, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt};\n use ty::steal::Steal;\n use ty::subst::Substs;\n@@ -417,6 +418,8 @@ define_maps! { <'tcx>\n         -> usize,\n \n     [] fn features_query: features_node(CrateNum) -> Lrc<feature_gate::Features>,\n+\n+    [] fn program_clauses_for: ProgramClausesFor(DefId) -> Lrc<Vec<Clause<'tcx>>>,\n }\n \n //////////////////////////////////////////////////////////////////////"}, {"sha": "dd65d4b4190718ff5fbcfdf49bb1235bff36a1f7", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c396ebd0b352f8713cad63aeb49ee392c147ab8/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c396ebd0b352f8713cad63aeb49ee392c147ab8/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=7c396ebd0b352f8713cad63aeb49ee392c147ab8", "patch": "@@ -935,6 +935,8 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n \n         DepKind::GetSymbolExportLevel => { force!(symbol_export_level, def_id!()); }\n         DepKind::Features => { force!(features_query, LOCAL_CRATE); }\n+\n+        DepKind::ProgramClausesFor => { force!(program_clauses_for, def_id!()); }\n     }\n \n     true"}, {"sha": "c915022351925f835a8afc49de54dd2b082425f7", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7c396ebd0b352f8713cad63aeb49ee392c147ab8/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c396ebd0b352f8713cad63aeb49ee392c147ab8/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=7c396ebd0b352f8713cad63aeb49ee392c147ab8", "patch": "@@ -1073,9 +1073,12 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct OutlivesPredicate<A,B>(pub A, pub B); // `A : B`\n pub type PolyOutlivesPredicate<A,B> = ty::Binder<OutlivesPredicate<A,B>>;\n-pub type PolyRegionOutlivesPredicate<'tcx> = PolyOutlivesPredicate<ty::Region<'tcx>,\n-                                                                   ty::Region<'tcx>>;\n-pub type PolyTypeOutlivesPredicate<'tcx> = PolyOutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>;\n+pub type RegionOutlivesPredicate<'tcx> = OutlivesPredicate<ty::Region<'tcx>,\n+                                                           ty::Region<'tcx>>;\n+pub type TypeOutlivesPredicate<'tcx> = OutlivesPredicate<Ty<'tcx>,\n+                                                         ty::Region<'tcx>>;\n+pub type PolyRegionOutlivesPredicate<'tcx> = ty::Binder<RegionOutlivesPredicate<'tcx>>;\n+pub type PolyTypeOutlivesPredicate<'tcx> = ty::Binder<TypeOutlivesPredicate<'tcx>>;\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct SubtypePredicate<'tcx> {"}, {"sha": "f2fe6542db171d02b6cf4c8926f02dfda2b00560", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c396ebd0b352f8713cad63aeb49ee392c147ab8/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c396ebd0b352f8713cad63aeb49ee392c147ab8/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=7c396ebd0b352f8713cad63aeb49ee392c147ab8", "patch": "@@ -1091,6 +1091,10 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(trans: &TransCrate,\n \n         time(sess, \"lint checking\", || lint::check_crate(tcx));\n \n+        time(sess,\n+             \"dumping chalk-like clauses\",\n+             || rustc_traits::lowering::dump_program_clauses(tcx));\n+\n         return Ok(f(tcx, analysis, rx, tcx.sess.compile_status()));\n     })\n }"}, {"sha": "2a0f076cefde3c610f3085890744cadd4883de81", "filename": "src/librustc_traits/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c396ebd0b352f8713cad63aeb49ee392c147ab8/src%2Flibrustc_traits%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c396ebd0b352f8713cad63aeb49ee392c147ab8/src%2Flibrustc_traits%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flib.rs?ref=7c396ebd0b352f8713cad63aeb49ee392c147ab8", "patch": "@@ -29,6 +29,7 @@ mod dropck_outlives;\n mod normalize_projection_ty;\n mod normalize_erasing_regions;\n mod util;\n+pub mod lowering;\n \n use rustc::ty::maps::Providers;\n \n@@ -39,6 +40,7 @@ pub fn provide(p: &mut Providers) {\n         normalize_projection_ty: normalize_projection_ty::normalize_projection_ty,\n         normalize_ty_after_erasing_regions:\n             normalize_erasing_regions::normalize_ty_after_erasing_regions,\n+        program_clauses_for: lowering::program_clauses_for,\n         ..*p\n     };\n }"}, {"sha": "c9666f55d440e4480bfcd2d246235b10660a4d93", "filename": "src/librustc_traits/lowering.rs", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/7c396ebd0b352f8713cad63aeb49ee392c147ab8/src%2Flibrustc_traits%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c396ebd0b352f8713cad63aeb49ee392c147ab8/src%2Flibrustc_traits%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering.rs?ref=7c396ebd0b352f8713cad63aeb49ee392c147ab8", "patch": "@@ -0,0 +1,184 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir::{self, ImplPolarity};\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc::ty::{self, TyCtxt};\n+use rustc::traits::{QuantifierKind, Goal, DomainGoal, Clause, WhereClauseAtom};\n+use syntax::ast;\n+use rustc_data_structures::sync::Lrc;\n+\n+trait Lower<T> {\n+    /// Lower a rustc construction (e.g. `ty::TraitPredicate`) to a chalk-like type.\n+    fn lower(&self) -> T;\n+}\n+\n+impl<T, U> Lower<Vec<U>> for Vec<T> where T: Lower<U> {\n+    fn lower(&self) -> Vec<U> {\n+        self.iter().map(|item| item.lower()).collect()\n+    }\n+}\n+\n+impl<'tcx> Lower<WhereClauseAtom<'tcx>> for ty::TraitPredicate<'tcx> {\n+    fn lower(&self) -> WhereClauseAtom<'tcx> {\n+        WhereClauseAtom::Implemented(*self)\n+    }\n+}\n+\n+impl<'tcx> Lower<WhereClauseAtom<'tcx>> for ty::ProjectionPredicate<'tcx> {\n+    fn lower(&self) -> WhereClauseAtom<'tcx> {\n+        WhereClauseAtom::ProjectionEq(*self)\n+    }\n+}\n+\n+impl<'tcx, T> Lower<DomainGoal<'tcx>> for T where T: Lower<WhereClauseAtom<'tcx>> {\n+    fn lower(&self) -> DomainGoal<'tcx> {\n+        DomainGoal::Holds(self.lower())\n+    }\n+}\n+\n+impl<'tcx> Lower<DomainGoal<'tcx>> for ty::RegionOutlivesPredicate<'tcx> {\n+    fn lower(&self) -> DomainGoal<'tcx> {\n+        DomainGoal::RegionOutlives(*self)\n+    }\n+}\n+\n+impl<'tcx> Lower<DomainGoal<'tcx>> for ty::TypeOutlivesPredicate<'tcx> {\n+    fn lower(&self) -> DomainGoal<'tcx> {\n+        DomainGoal::TypeOutlives(*self)\n+    }\n+}\n+\n+/// `ty::Binder` is used for wrapping a rustc construction possibly containing generic\n+/// lifetimes, e.g. `for<'a> T: Fn(&'a i32)`. Instead of representing higher-ranked things\n+/// in that leaf-form (i.e. `Holds(Implemented(Binder<TraitPredicate>))` in the previous\n+/// example), we model them with quantified goals, e.g. as for the previous example:\n+/// `forall<'a> { T: Fn(&'a i32) }` which corresponds to something like\n+/// `Binder<Holds(Implemented(TraitPredicate))>`.\n+///\n+/// Also, if `self` does not contain generic lifetimes, we can safely drop the binder and we\n+/// can directly lower to a leaf goal instead of a quantified goal.\n+impl<'tcx, T> Lower<Goal<'tcx>> for ty::Binder<T>\n+    where T: Lower<DomainGoal<'tcx>> + ty::fold::TypeFoldable<'tcx> + Copy\n+{\n+    fn lower(&self) -> Goal<'tcx> {\n+        match self.no_late_bound_regions() {\n+            Some(p) => p.lower().into(),\n+            None => Goal::Quantified(\n+                QuantifierKind::Universal,\n+                Box::new(self.map_bound(|p| p.lower().into()))\n+            ),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Lower<Goal<'tcx>> for ty::Predicate<'tcx> {\n+    fn lower(&self) -> Goal<'tcx> {\n+        use rustc::ty::Predicate::*;\n+\n+        match self {\n+            Trait(predicate) => predicate.lower(),\n+            RegionOutlives(predicate) => predicate.lower(),\n+            TypeOutlives(predicate) => predicate.lower(),\n+            Projection(predicate) => predicate.lower(),\n+            WellFormed(ty) => DomainGoal::WellFormedTy(*ty).into(),\n+            ObjectSafe(..) |\n+            ClosureKind(..) |\n+            Subtype(..) |\n+            ConstEvaluatable(..) => unimplemented!(),\n+        }\n+    }\n+}\n+\n+crate fn program_clauses_for<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n+    -> Lrc<Vec<Clause<'tcx>>>\n+{\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let item = tcx.hir.expect_item(node_id);\n+    match item.node {\n+        hir::ItemImpl(..) => program_clauses_for_impl(tcx, def_id),\n+\n+        // FIXME: other constructions e.g. traits, associated types...\n+        _ => Lrc::new(vec![]),\n+    }\n+}\n+\n+fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n+    -> Lrc<Vec<Clause<'tcx>>>\n+{\n+    if let ImplPolarity::Negative = tcx.impl_polarity(def_id) {\n+        return Lrc::new(vec![]);\n+    }\n+\n+    // Rule Implemented-From-Impl\n+    //\n+    // (see rustc guide)\n+\n+    let trait_ref = tcx.impl_trait_ref(def_id).unwrap();\n+    let trait_ref = ty::TraitPredicate { trait_ref }.lower();\n+    let where_clauses = tcx.predicates_of(def_id).predicates.lower();\n+\n+    let clause = Clause::Implies(where_clauses, trait_ref);\n+    Lrc::new(vec![clause])\n+}\n+\n+pub fn dump_program_clauses<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    if !tcx.features().rustc_attrs {\n+        return;\n+    }\n+\n+    let mut visitor = ClauseDumper { tcx };\n+    tcx.hir.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n+}\n+\n+struct ClauseDumper<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+}\n+\n+impl <'a, 'tcx> ClauseDumper<'a, 'tcx > {\n+    fn process_attrs(&mut self, node_id: ast::NodeId, attrs: &[ast::Attribute]) {\n+        let def_id = self.tcx.hir.local_def_id(node_id);\n+        for attr in attrs {\n+            if attr.check_name(\"rustc_dump_program_clauses\") {\n+                let clauses = self.tcx.program_clauses_for(def_id);\n+                for clause in &*clauses {\n+                    self.tcx.sess.struct_span_err(attr.span, &format!(\"{}\", clause)).emit();\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for ClauseDumper<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n+    }\n+\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        self.process_attrs(item.id, &item.attrs);\n+        intravisit::walk_item(self, item);\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n+        self.process_attrs(trait_item.id, &trait_item.attrs);\n+        intravisit::walk_trait_item(self, trait_item);\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n+        self.process_attrs(impl_item.id, &impl_item.attrs);\n+        intravisit::walk_impl_item(self, impl_item);\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n+        self.process_attrs(s.id, &s.attrs);\n+        intravisit::walk_struct_field(self, s);\n+    }\n+}"}, {"sha": "fa600cd686064a796a392d43a6250597581a14bc", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c396ebd0b352f8713cad63aeb49ee392c147ab8/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c396ebd0b352f8713cad63aeb49ee392c147ab8/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=7c396ebd0b352f8713cad63aeb49ee392c147ab8", "patch": "@@ -832,6 +832,13 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                                           across crates and will never be stable\",\n                                                           cfg_fn!(rustc_attrs))),\n \n+    (\"rustc_dump_program_clauses\", Whitelisted, Gated(Stability::Unstable,\n+                                                     \"rustc_attrs\",\n+                                                     \"the `#[rustc_dump_program_clauses]` \\\n+                                                      attribute is just used for rustc unit \\\n+                                                      tests and will never be stable\",\n+                                                     cfg_fn!(rustc_attrs))),\n+\n     // RFC #2094\n     (\"nll\", Whitelisted, Gated(Stability::Unstable,\n                                \"nll\","}, {"sha": "2083ada6d2de5481b7177e8f246ffceadcdc9cad", "filename": "src/test/ui/chalkify/lower_impl.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7c396ebd0b352f8713cad63aeb49ee392c147ab8/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c396ebd0b352f8713cad63aeb49ee392c147ab8/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.rs?ref=7c396ebd0b352f8713cad63aeb49ee392c147ab8", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+trait Foo { }\n+\n+#[rustc_dump_program_clauses] //~ ERROR Implemented(T: Foo) :-\n+impl<T: 'static> Foo for T where T: Iterator<Item = i32> { }\n+\n+fn main() {\n+    println!(\"hello\");\n+}"}, {"sha": "b5d791d640ada9dcd79a4c07aff37b2e845f90fa", "filename": "src/test/ui/chalkify/lower_impl.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c396ebd0b352f8713cad63aeb49ee392c147ab8/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c396ebd0b352f8713cad63aeb49ee392c147ab8/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.stderr?ref=7c396ebd0b352f8713cad63aeb49ee392c147ab8", "patch": "@@ -0,0 +1,8 @@\n+error: Implemented(T: Foo) :- ProjectionEq(<T as std::iter::Iterator>::Item == i32), TypeOutlives(T : 'static), Implemented(T: std::iter::Iterator), Implemented(T: std::marker::Sized).\n+  --> $DIR/lower_impl.rs:15:1\n+   |\n+LL | #[rustc_dump_program_clauses] //~ ERROR Implemented(T: Foo) :-\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}]}