{"sha": "0beaccb9bb4398e60b0df55afdc6b9112896fbfd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiZWFjY2I5YmI0Mzk4ZTYwYjBkZjU1YWZkYzZiOTExMjg5NmZiZmQ=", "commit": {"author": {"name": "Matt McPherrin", "email": "git@mcpherrin.ca", "date": "2014-11-22T07:01:38Z"}, "committer": {"name": "Matt McPherrin", "email": "git@mcpherrin.ca", "date": "2014-11-22T07:01:38Z"}, "message": "Rename variables called pq to heap\n\nThe old name was sensible when this module was PriorityQueue but isn't\nanymore.", "tree": {"sha": "aced3e1eef59d39a64beb2b13e8de7aa3be31652", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aced3e1eef59d39a64beb2b13e8de7aa3be31652"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0beaccb9bb4398e60b0df55afdc6b9112896fbfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0beaccb9bb4398e60b0df55afdc6b9112896fbfd", "html_url": "https://github.com/rust-lang/rust/commit/0beaccb9bb4398e60b0df55afdc6b9112896fbfd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0beaccb9bb4398e60b0df55afdc6b9112896fbfd/comments", "author": {"login": "mcpherrinm", "id": 47425, "node_id": "MDQ6VXNlcjQ3NDI1", "avatar_url": "https://avatars.githubusercontent.com/u/47425?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcpherrinm", "html_url": "https://github.com/mcpherrinm", "followers_url": "https://api.github.com/users/mcpherrinm/followers", "following_url": "https://api.github.com/users/mcpherrinm/following{/other_user}", "gists_url": "https://api.github.com/users/mcpherrinm/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcpherrinm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcpherrinm/subscriptions", "organizations_url": "https://api.github.com/users/mcpherrinm/orgs", "repos_url": "https://api.github.com/users/mcpherrinm/repos", "events_url": "https://api.github.com/users/mcpherrinm/events{/privacy}", "received_events_url": "https://api.github.com/users/mcpherrinm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcpherrinm", "id": 47425, "node_id": "MDQ6VXNlcjQ3NDI1", "avatar_url": "https://avatars.githubusercontent.com/u/47425?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcpherrinm", "html_url": "https://github.com/mcpherrinm", "followers_url": "https://api.github.com/users/mcpherrinm/followers", "following_url": "https://api.github.com/users/mcpherrinm/following{/other_user}", "gists_url": "https://api.github.com/users/mcpherrinm/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcpherrinm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcpherrinm/subscriptions", "organizations_url": "https://api.github.com/users/mcpherrinm/orgs", "repos_url": "https://api.github.com/users/mcpherrinm/repos", "events_url": "https://api.github.com/users/mcpherrinm/events{/privacy}", "received_events_url": "https://api.github.com/users/mcpherrinm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a4c0100fe5eead03b8b566748c1909a7b9b903b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a4c0100fe5eead03b8b566748c1909a7b9b903b", "html_url": "https://github.com/rust-lang/rust/commit/2a4c0100fe5eead03b8b566748c1909a7b9b903b"}], "stats": {"total": 106, "additions": 53, "deletions": 53}, "files": [{"sha": "963b88eda560986a9f2116b6568e838c688154e5", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/0beaccb9bb4398e60b0df55afdc6b9112896fbfd/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beaccb9bb4398e60b0df55afdc6b9112896fbfd/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=0beaccb9bb4398e60b0df55afdc6b9112896fbfd", "patch": "@@ -68,15 +68,15 @@\n //!     // dist[node] = current shortest distance from `start` to `node`\n //!     let mut dist = Vec::from_elem(adj_list.len(), uint::MAX);\n //!\n-//!     let mut pq = BinaryHeap::new();\n+//!     let mut heap = BinaryHeap::new();\n //!\n //!     // We're at `start`, with a zero cost\n //!     dist[start] = 0u;\n-//!     pq.push(State { cost: 0u, position: start });\n+//!     heap.push(State { cost: 0u, position: start });\n //!\n //!     // Examine the frontier with lower cost nodes first (min-heap)\n //!     loop {\n-//!         let State { cost, position } = match pq.pop() {\n+//!         let State { cost, position } = match heap.pop() {\n //!             None => break, // empty\n //!             Some(s) => s\n //!         };\n@@ -94,7 +94,7 @@\n //!\n //!             // If so, add it to the frontier and continue\n //!             if next.cost < dist[next.position] {\n-//!                 pq.push(next);\n+//!                 heap.push(next);\n //!                 // Relaxation, we have now found a better way\n //!                 dist[next.position] = next.cost;\n //!             }\n@@ -184,7 +184,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let pq: BinaryHeap<uint> = BinaryHeap::new();\n+    /// let heap: BinaryHeap<uint> = BinaryHeap::new();\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> BinaryHeap<T> { BinaryHeap{data: vec!(),} }\n@@ -198,7 +198,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let pq: BinaryHeap<uint> = BinaryHeap::with_capacity(10u);\n+    /// let heap: BinaryHeap<uint> = BinaryHeap::with_capacity(10u);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn with_capacity(capacity: uint) -> BinaryHeap<T> {\n@@ -212,7 +212,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let pq = BinaryHeap::from_vec(vec![9i, 1, 2, 7, 3, 2]);\n+    /// let heap = BinaryHeap::from_vec(vec![9i, 1, 2, 7, 3, 2]);\n     /// ```\n     pub fn from_vec(xs: Vec<T>) -> BinaryHeap<T> {\n         let mut q = BinaryHeap{data: xs,};\n@@ -231,10 +231,10 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let pq = BinaryHeap::from_vec(vec![1i, 2, 3, 4]);\n+    /// let heap = BinaryHeap::from_vec(vec![1i, 2, 3, 4]);\n     ///\n     /// // Print 1, 2, 3, 4 in arbitrary order\n-    /// for x in pq.iter() {\n+    /// for x in heap.iter() {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n@@ -250,13 +250,13 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = BinaryHeap::new();\n-    /// assert_eq!(pq.top(), None);\n+    /// let mut heap = BinaryHeap::new();\n+    /// assert_eq!(heap.top(), None);\n     ///\n-    /// pq.push(1i);\n-    /// pq.push(5i);\n-    /// pq.push(2i);\n-    /// assert_eq!(pq.top(), Some(&5i));\n+    /// heap.push(1i);\n+    /// heap.push(5i);\n+    /// heap.push(2i);\n+    /// assert_eq!(heap.top(), Some(&5i));\n     ///\n     /// ```\n     pub fn top<'a>(&'a self) -> Option<&'a T> {\n@@ -270,8 +270,8 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let pq: BinaryHeap<uint> = BinaryHeap::with_capacity(100u);\n-    /// assert!(pq.capacity() >= 100u);\n+    /// let heap: BinaryHeap<uint> = BinaryHeap::with_capacity(100u);\n+    /// assert!(heap.capacity() >= 100u);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn capacity(&self) -> uint { self.data.capacity() }\n@@ -292,9 +292,9 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq: BinaryHeap<uint> = BinaryHeap::new();\n-    /// pq.reserve_exact(100u);\n-    /// assert!(pq.capacity() >= 100u);\n+    /// let mut heap: BinaryHeap<uint> = BinaryHeap::new();\n+    /// heap.reserve_exact(100u);\n+    /// assert!(heap.capacity() >= 100u);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn reserve_exact(&mut self, additional: uint) { self.data.reserve_exact(additional) }\n@@ -311,9 +311,9 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq: BinaryHeap<uint> = BinaryHeap::new();\n-    /// pq.reserve(100u);\n-    /// assert!(pq.capacity() >= 100u);\n+    /// let mut heap: BinaryHeap<uint> = BinaryHeap::new();\n+    /// heap.reserve(100u);\n+    /// assert!(heap.capacity() >= 100u);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn reserve(&mut self, additional: uint) {\n@@ -334,11 +334,11 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = BinaryHeap::from_vec(vec![1i, 3]);\n+    /// let mut heap = BinaryHeap::from_vec(vec![1i, 3]);\n     ///\n-    /// assert_eq!(pq.pop(), Some(3i));\n-    /// assert_eq!(pq.pop(), Some(1i));\n-    /// assert_eq!(pq.pop(), None);\n+    /// assert_eq!(heap.pop(), Some(3i));\n+    /// assert_eq!(heap.pop(), Some(1i));\n+    /// assert_eq!(heap.pop(), None);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn pop(&mut self) -> Option<T> {\n@@ -361,13 +361,13 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = BinaryHeap::new();\n-    /// pq.push(3i);\n-    /// pq.push(5i);\n-    /// pq.push(1i);\n+    /// let mut heap = BinaryHeap::new();\n+    /// heap.push(3i);\n+    /// heap.push(5i);\n+    /// heap.push(1i);\n     ///\n-    /// assert_eq!(pq.len(), 3);\n-    /// assert_eq!(pq.top(), Some(&5i));\n+    /// assert_eq!(heap.len(), 3);\n+    /// assert_eq!(heap.top(), Some(&5i));\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn push(&mut self, item: T) {\n@@ -384,14 +384,14 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = BinaryHeap::new();\n-    /// pq.push(1i);\n-    /// pq.push(5i);\n+    /// let mut heap = BinaryHeap::new();\n+    /// heap.push(1i);\n+    /// heap.push(5i);\n     ///\n-    /// assert_eq!(pq.push_pop(3i), 5);\n-    /// assert_eq!(pq.push_pop(9i), 9);\n-    /// assert_eq!(pq.len(), 2);\n-    /// assert_eq!(pq.top(), Some(&3i));\n+    /// assert_eq!(heap.push_pop(3i), 5);\n+    /// assert_eq!(heap.push_pop(9i), 9);\n+    /// assert_eq!(heap.len(), 2);\n+    /// assert_eq!(heap.top(), Some(&3i));\n     /// ```\n     pub fn push_pop(&mut self, mut item: T) -> T {\n         if !self.is_empty() && *self.top().unwrap() > item {\n@@ -410,12 +410,12 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = BinaryHeap::new();\n+    /// let mut heap = BinaryHeap::new();\n     ///\n-    /// assert_eq!(pq.replace(1i), None);\n-    /// assert_eq!(pq.replace(3i), Some(1i));\n-    /// assert_eq!(pq.len(), 1);\n-    /// assert_eq!(pq.top(), Some(&3i));\n+    /// assert_eq!(heap.replace(1i), None);\n+    /// assert_eq!(heap.replace(3i), Some(1i));\n+    /// assert_eq!(heap.len(), 1);\n+    /// assert_eq!(heap.top(), Some(&3i));\n     /// ```\n     pub fn replace(&mut self, mut item: T) -> Option<T> {\n         if !self.is_empty() {\n@@ -436,8 +436,8 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let pq = BinaryHeap::from_vec(vec![1i, 2, 3, 4, 5, 6, 7]);\n-    /// let vec = pq.into_vec();\n+    /// let heap = BinaryHeap::from_vec(vec![1i, 2, 3, 4, 5, 6, 7]);\n+    /// let vec = heap.into_vec();\n     ///\n     /// // Will print in some order\n     /// for x in vec.iter() {\n@@ -454,11 +454,11 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = BinaryHeap::from_vec(vec![1i, 2, 4, 5, 7]);\n-    /// pq.push(6);\n-    /// pq.push(3);\n+    /// let mut heap = BinaryHeap::from_vec(vec![1i, 2, 4, 5, 7]);\n+    /// heap.push(6);\n+    /// heap.push(3);\n     ///\n-    /// let vec = pq.into_sorted_vec();\n+    /// let vec = heap.into_sorted_vec();\n     /// assert_eq!(vec, vec![1i, 2, 3, 4, 5, 6, 7]);\n     /// ```\n     pub fn into_sorted_vec(self) -> Vec<T> {\n@@ -578,9 +578,9 @@ mod tests {\n     fn test_iterator() {\n         let data = vec!(5i, 9, 3);\n         let iterout = [9i, 5, 3];\n-        let pq = BinaryHeap::from_vec(data);\n+        let heap = BinaryHeap::from_vec(data);\n         let mut i = 0;\n-        for el in pq.iter() {\n+        for el in heap.iter() {\n             assert_eq!(*el, iterout[i]);\n             i += 1;\n         }"}]}