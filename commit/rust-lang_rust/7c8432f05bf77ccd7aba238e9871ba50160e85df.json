{"sha": "7c8432f05bf77ccd7aba238e9871ba50160e85df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjODQzMmYwNWJmNzdjY2Q3YWJhMjM4ZTk4NzFiYTUwMTYwZTg1ZGY=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-05-23T06:35:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-05-23T06:35:21Z"}, "message": "Merge pull request #1572 from topecongiro/nested-block\n\nNesting of block indented expressions", "tree": {"sha": "69e6a0cdceb630460c8ca27288b53b2c52925f35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69e6a0cdceb630460c8ca27288b53b2c52925f35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c8432f05bf77ccd7aba238e9871ba50160e85df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c8432f05bf77ccd7aba238e9871ba50160e85df", "html_url": "https://github.com/rust-lang/rust/commit/7c8432f05bf77ccd7aba238e9871ba50160e85df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c8432f05bf77ccd7aba238e9871ba50160e85df/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb8d67196ca91205fd98f498485c6679f7a26324", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb8d67196ca91205fd98f498485c6679f7a26324", "html_url": "https://github.com/rust-lang/rust/commit/eb8d67196ca91205fd98f498485c6679f7a26324"}, {"sha": "f83c22f24f2f497c454531e101cf63bf825e3bd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f83c22f24f2f497c454531e101cf63bf825e3bd5", "html_url": "https://github.com/rust-lang/rust/commit/f83c22f24f2f497c454531e101cf63bf825e3bd5"}], "stats": {"total": 683, "additions": 568, "deletions": 115}, "files": [{"sha": "ad0d654175de754dfe63e31398fac441ed214962", "filename": "src/expr.rs", "status": "modified", "additions": 181, "deletions": 75, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/7c8432f05bf77ccd7aba238e9871ba50160e85df/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8432f05bf77ccd7aba238e9871ba50160e85df/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=7c8432f05bf77ccd7aba238e9871ba50160e85df", "patch": "@@ -96,9 +96,7 @@ fn format_expr(expr: &ast::Expr,\n                                expr.span,\n                                shape)\n         }\n-        ast::ExprKind::Tup(ref items) => {\n-            rewrite_tuple(context, items.iter().map(|x| &**x), expr.span, shape)\n-        }\n+        ast::ExprKind::Tup(ref items) => rewrite_tuple(context, items, expr.span, shape),\n         ast::ExprKind::While(ref cond, ref block, label) => {\n             ControlFlow::new_while(None, cond, block, label, expr.span).rewrite(context, shape)\n         }\n@@ -1334,18 +1332,23 @@ impl Rewrite for ast::Arm {\n \n         let pats_str = format!(\"{}{}\", pats_str, guard_str);\n \n-        let body = match body.node {\n+        let (mut extend, body) = match body.node {\n             ast::ExprKind::Block(ref block) if !is_unsafe_block(block) &&\n                                                is_simple_block(block, context.codemap) &&\n                                                context.config.wrap_match_arms() => {\n                 if let ast::StmtKind::Expr(ref expr) = block.stmts[0].node {\n-                    expr\n+                    (false, &**expr)\n                 } else {\n-                    &**body\n+                    (false, &**body)\n                 }\n             }\n-            _ => &**body,\n+            ast::ExprKind::Call(_, ref args) => (args.len() == 1, &**body),\n+            ast::ExprKind::Closure(..) |\n+            ast::ExprKind::Struct(..) |\n+            ast::ExprKind::Tup(..) => (true, &**body),\n+            _ => (false, &**body),\n         };\n+        extend &= context.config.fn_call_style() == IndentStyle::Block;\n \n         let comma = arm_comma(&context.config, body);\n         let alt_block_sep = String::from(\"\\n\") +\n@@ -1371,6 +1374,7 @@ impl Rewrite for ast::Arm {\n                 Some(ref body_str) if (!body_str.contains('\\n') &&\n                                        body_str.len() <= arm_shape.width) ||\n                                       !context.config.wrap_match_arms() ||\n+                                      (extend && first_line_width(body_str) <= arm_shape.width) ||\n                                       is_block => {\n                     let block_sep = match context.config.control_brace_style() {\n                         ControlBraceStyle::AlwaysNextLine if is_block => alt_block_sep.as_str(),\n@@ -1608,20 +1612,20 @@ pub fn rewrite_call<R>(context: &RewriteContext,\n                        -> Option<String>\n     where R: Rewrite\n {\n-    let closure =\n-        |callee_max_width| rewrite_call_inner(context, callee, callee_max_width, args, span, shape);\n+    let closure = |callee_max_width| {\n+        rewrite_call_inner(context, callee, callee_max_width, args, span, shape, false)\n+    };\n \n-    // 2 is for parens\n-    let max_width = try_opt!(shape.width.checked_sub(2));\n-    binary_search(1, max_width, closure)\n+    binary_search(1, shape.width, closure)\n }\n \n fn rewrite_call_inner<R>(context: &RewriteContext,\n                          callee: &R,\n                          max_callee_width: usize,\n                          args: &[ptr::P<ast::Expr>],\n                          span: Span,\n-                         shape: Shape)\n+                         shape: Shape,\n+                         force_trailing_comma: bool)\n                          -> Result<String, Ordering>\n     where R: Rewrite\n {\n@@ -1635,61 +1639,52 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n         .rewrite(context, callee_shape)\n         .ok_or(Ordering::Greater)?;\n \n-    // 4 = `(  )`, 2 = `()`\n+    // 2 = `( `, 1 = `(`\n     let paren_overhead = if context.config.spaces_within_parens() {\n-        4\n-    } else {\n         2\n+    } else {\n+        1\n     };\n     let used_width = extra_offset(&callee_str, shape);\n     let one_line_width = shape\n         .width\n-        .checked_sub(used_width + paren_overhead)\n+        .checked_sub(used_width + 2 * paren_overhead)\n         .ok_or(Ordering::Greater)?;\n \n-    let nested_shape = match context.config.fn_call_style() {\n-            IndentStyle::Block => shape.block().block_left(context.config.tab_spaces()),\n-            // 1 = (\n-            IndentStyle::Visual => {\n-                shape\n-                    .visual_indent(used_width + 1)\n-                    .sub_width(used_width + paren_overhead)\n-            }\n-        }\n+    let nested_shape = shape_from_fn_call_style(context,\n+                                                shape,\n+                                                used_width + 2 * paren_overhead,\n+                                                used_width + paren_overhead)\n         .ok_or(Ordering::Greater)?;\n \n     let span_lo = context.codemap.span_after(span, \"(\");\n     let span = mk_sp(span_lo, span.hi);\n \n-    let list_str = rewrite_call_args(context, args, span, nested_shape, one_line_width)\n+    let (extendable, list_str) = rewrite_call_args(context,\n+                                                   args,\n+                                                   span,\n+                                                   nested_shape,\n+                                                   one_line_width,\n+                                                   force_trailing_comma)\n         .ok_or(Ordering::Less)?;\n-\n-    let result = if context.config.fn_call_style() == IndentStyle::Visual ||\n-                    (!list_str.contains('\\n') && list_str.chars().last().unwrap_or(' ') != ',') {\n-        if context.config.spaces_within_parens() && list_str.len() > 0 {\n-            format!(\"{}( {} )\", callee_str, list_str)\n-        } else {\n-            format!(\"{}({})\", callee_str, list_str)\n-        }\n-    } else {\n-        format!(\"{}(\\n{}{}\\n{})\",\n-                callee_str,\n-                nested_shape.indent.to_string(context.config),\n-                list_str,\n-                shape.block().indent.to_string(context.config))\n-    };\n-\n-    Ok(result)\n+    let arg_one_line_budget = min(one_line_width, context.config.fn_call_width());\n+    Ok(format!(\"{}{}\",\n+               callee_str,\n+               wrap_args_with_parens(context,\n+                                     &list_str,\n+                                     extendable,\n+                                     arg_one_line_budget,\n+                                     shape,\n+                                     nested_shape)))\n }\n \n fn rewrite_call_args(context: &RewriteContext,\n                      args: &[ptr::P<ast::Expr>],\n                      span: Span,\n                      shape: Shape,\n-                     one_line_width: usize)\n-                     -> Option<String> {\n-    let arg_count = args.len();\n-\n+                     one_line_width: usize,\n+                     force_trailing_comma: bool)\n+                     -> Option<(bool, String)> {\n     let items = itemize_list(context.codemap,\n                              args.iter(),\n                              \")\",\n@@ -1703,31 +1698,32 @@ fn rewrite_call_args(context: &RewriteContext,\n     // Try letting the last argument overflow to the next line with block\n     // indentation. If its first line fits on one line with the other arguments,\n     // we format the function arguments horizontally.\n-    let overflow_last = match args.last().map(|x| &x.node) {\n-        Some(&ast::ExprKind::Closure(..)) |\n-        Some(&ast::ExprKind::Block(..)) |\n-        Some(&ast::ExprKind::Match(..)) if arg_count > 1 => true,\n-        _ => false,\n-    };\n+    let overflow_last = can_be_overflowed(context, args);\n \n     let mut orig_last = None;\n     let mut placeholder = None;\n \n     // Replace the last item with its first line to see if it fits with\n     // first arguments.\n     if overflow_last {\n-        let nested_shape = Shape {\n-            indent: shape.indent.block_only(),\n-            ..shape\n+        let arg_shape = if context.config.fn_call_style() == IndentStyle::Block &&\n+                           is_extendable(args) {\n+            Shape {\n+                width: context.config.fn_call_width(),\n+                indent: shape.block().indent.block_unindent(context.config),\n+                offset: 0,\n+            }\n+        } else {\n+            shape.block()\n         };\n-        let rewrite = args.last().unwrap().rewrite(context, nested_shape);\n+        let rewrite = args.last().unwrap().rewrite(context, arg_shape);\n+        swap(&mut item_vec[args.len() - 1].item, &mut orig_last);\n \n         if let Some(rewrite) = rewrite {\n             let rewrite_first_line = Some(rewrite[..first_line_width(&rewrite)].to_owned());\n             placeholder = Some(rewrite);\n \n-            swap(&mut item_vec[arg_count - 1].item, &mut orig_last);\n-            item_vec[arg_count - 1].item = rewrite_first_line;\n+            item_vec[args.len() - 1].item = rewrite_first_line;\n         }\n     }\n \n@@ -1745,20 +1741,21 @@ fn rewrite_call_args(context: &RewriteContext,\n     // succeeded and its first line fits with the other arguments.\n     match (overflow_last, tactic, placeholder) {\n         (true, DefinitiveListTactic::Horizontal, placeholder @ Some(..)) => {\n-            item_vec[arg_count - 1].item = placeholder;\n+            item_vec[args.len() - 1].item = placeholder;\n         }\n         (true, _, _) => {\n-            item_vec[arg_count - 1].item = orig_last;\n+            item_vec[args.len() - 1].item = orig_last;\n         }\n         (false, _, _) => {}\n     }\n \n     let mut fmt = ListFormatting {\n         tactic: tactic,\n         separator: \",\",\n-        trailing_separator: if context.inside_macro ||\n-                               context.config.fn_call_style() == IndentStyle::Visual ||\n-                               arg_count <= 1 {\n+        trailing_separator: if force_trailing_comma {\n+            SeparatorTactic::Always\n+        } else if context.inside_macro || context.config.fn_call_style() == IndentStyle::Visual ||\n+                  args.len() <= 1 {\n             SeparatorTactic::Never\n         } else {\n             context.config.trailing_comma()\n@@ -1768,18 +1765,93 @@ fn rewrite_call_args(context: &RewriteContext,\n         config: context.config,\n     };\n \n+    let args_in_single_line =\n+        item_vec\n+            .iter()\n+            .rev()\n+            .skip(1)\n+            .all(|item| item.item.as_ref().map_or(false, |s| !s.contains('\\n')));\n+\n     match write_list(&item_vec, &fmt) {\n         // If arguments do not fit in a single line and do not contain newline,\n         // try to put it on the next line. Try this only when we are in block mode\n         // and not rewriting macro.\n         Some(ref s) if context.config.fn_call_style() == IndentStyle::Block &&\n                        !context.inside_macro &&\n-                       (!s.contains('\\n') &&\n-                        (s.len() > one_line_width || s.len() > context.config.fn_call_width())) => {\n+                       (!can_be_overflowed(context, args) && args.len() == 1 && s.contains('\\n') ||\n+                        first_line_width(s) > one_line_width ||\n+                        first_line_width(s) > context.config.fn_call_width()) => {\n             fmt.trailing_separator = SeparatorTactic::Vertical;\n-            write_list(&item_vec, &fmt)\n+            fmt.tactic = DefinitiveListTactic::Vertical;\n+            write_list(&item_vec, &fmt).map(|rw| (false, rw))\n+        }\n+        rewrite @ _ => rewrite.map(|rw| (args_in_single_line && is_extendable(args), rw)),\n+    }\n+}\n+\n+fn can_be_overflowed(context: &RewriteContext, args: &[ptr::P<ast::Expr>]) -> bool {\n+    match args.last().map(|x| &x.node) {\n+        Some(&ast::ExprKind::Block(..)) |\n+        Some(&ast::ExprKind::Match(..)) => {\n+            (context.config.fn_call_style() == IndentStyle::Block && args.len() == 1) ||\n+            (context.config.fn_call_style() == IndentStyle::Visual && args.len() > 1)\n+        }\n+        Some(&ast::ExprKind::Closure(..)) => {\n+            context.config.fn_call_style() == IndentStyle::Block ||\n+            context.config.fn_call_style() == IndentStyle::Visual && args.len() > 1\n         }\n-        rewrite @ _ => rewrite,\n+        Some(&ast::ExprKind::Call(..)) |\n+        Some(&ast::ExprKind::Struct(..)) => {\n+            context.config.fn_call_style() == IndentStyle::Block && args.len() == 1\n+        }\n+        Some(&ast::ExprKind::Tup(..)) => context.config.fn_call_style() == IndentStyle::Block,\n+        _ => false,\n+    }\n+}\n+\n+fn is_extendable(args: &[ptr::P<ast::Expr>]) -> bool {\n+    if args.len() == 1 {\n+        match args[0].node {\n+            ast::ExprKind::Block(..) |\n+            ast::ExprKind::Call(..) |\n+            ast::ExprKind::Closure(..) |\n+            ast::ExprKind::Match(..) |\n+            ast::ExprKind::Struct(..) |\n+            ast::ExprKind::Tup(..) => true,\n+            _ => false,\n+        }\n+    } else if args.len() > 1 {\n+        match args[args.len() - 1].node {\n+            ast::ExprKind::Closure(..) |\n+            ast::ExprKind::Tup(..) => true,\n+            _ => false,\n+        }\n+    } else {\n+        false\n+    }\n+}\n+\n+fn wrap_args_with_parens(context: &RewriteContext,\n+                         args_str: &str,\n+                         is_extendable: bool,\n+                         one_line_budget: usize,\n+                         shape: Shape,\n+                         nested_shape: Shape)\n+                         -> String {\n+    if context.config.fn_call_style() == IndentStyle::Visual ||\n+       (context.inside_macro && !args_str.contains('\\n')) ||\n+       ((is_extendable || !args_str.contains('\\n')) &&\n+        first_line_width(&args_str) <= one_line_budget) {\n+        if context.config.spaces_within_parens() && args_str.len() > 0 {\n+            format!(\"( {} )\", args_str)\n+        } else {\n+            format!(\"({})\", args_str)\n+        }\n+    } else {\n+        format!(\"(\\n{}{}\\n{})\",\n+                nested_shape.indent.to_string(context.config),\n+                args_str,\n+                shape.block().indent.to_string(context.config))\n     }\n }\n \n@@ -1962,17 +2034,28 @@ fn rewrite_field(context: &RewriteContext, field: &ast::Field, shape: Shape) ->\n     }\n }\n \n-pub fn rewrite_tuple<'a, I>(context: &RewriteContext,\n-                            mut items: I,\n-                            span: Span,\n-                            shape: Shape)\n-                            -> Option<String>\n+fn shape_from_fn_call_style(context: &RewriteContext,\n+                            shape: Shape,\n+                            overhead: usize,\n+                            offset: usize)\n+                            -> Option<Shape> {\n+    match context.config.fn_call_style() {\n+        IndentStyle::Block => Some(shape.block().block_indent(context.config.tab_spaces())),\n+        IndentStyle::Visual => shape.visual_indent(offset).sub_width(overhead),\n+    }\n+}\n+\n+pub fn rewrite_tuple_type<'a, I>(context: &RewriteContext,\n+                                 mut items: I,\n+                                 span: Span,\n+                                 shape: Shape)\n+                                 -> Option<String>\n     where I: ExactSizeIterator,\n           <I as Iterator>::Item: Deref,\n           <I::Item as Deref>::Target: Rewrite + Spanned + 'a\n {\n-    debug!(\"rewrite_tuple {:?}\", shape);\n     // In case of length 1, need a trailing comma\n+    debug!(\"rewrite_tuple_type {:?}\", shape);\n     if items.len() == 1 {\n         // 3 = \"(\" + \",)\"\n         let nested_shape = try_opt!(shape.sub_width(3)).visual_indent(1);\n@@ -2006,6 +2089,29 @@ pub fn rewrite_tuple<'a, I>(context: &RewriteContext,\n     }\n }\n \n+pub fn rewrite_tuple(context: &RewriteContext,\n+                     items: &[ptr::P<ast::Expr>],\n+                     span: Span,\n+                     shape: Shape)\n+                     -> Option<String> {\n+    debug!(\"rewrite_tuple {:?}\", shape);\n+    // Use old `rewrite_tuple`\n+    if context.config.fn_call_style() == IndentStyle::Visual {\n+        return rewrite_tuple_type(context, items.iter().map(|x| &**x), span, shape);\n+    }\n+\n+    // We use the same rule as funcation call for rewriting tuple.\n+    // 1 = \",\"\n+    rewrite_call_inner(context,\n+                       &String::new(),\n+                       shape.width.checked_sub(1).unwrap_or(0),\n+                       items,\n+                       span,\n+                       shape,\n+                       items.len() == 1)\n+        .ok()\n+}\n+\n pub fn rewrite_unary_prefix<R: Rewrite>(context: &RewriteContext,\n                                         prefix: &str,\n                                         rewrite: &R,"}, {"sha": "8f99be11d1a8b0608fdd99902293fe56120b95ab", "filename": "src/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c8432f05bf77ccd7aba238e9871ba50160e85df/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8432f05bf77ccd7aba238e9871ba50160e85df/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=7c8432f05bf77ccd7aba238e9871ba50160e85df", "patch": "@@ -22,7 +22,7 @@ use codemap::SpanUtils;\n use lists::{format_item_list, itemize_list, format_fn_args};\n use rewrite::{Rewrite, RewriteContext};\n use utils::{extra_offset, format_mutability, colon_spaces, wrap_str};\n-use expr::{rewrite_unary_prefix, rewrite_pair, rewrite_tuple};\n+use expr::{rewrite_unary_prefix, rewrite_pair, rewrite_tuple_type};\n use config::TypeDensity;\n use itertools::Itertools;\n \n@@ -662,7 +662,7 @@ impl Rewrite for ast::Ty {\n                          })\n             }\n             ast::TyKind::Tup(ref items) => {\n-                rewrite_tuple(context, items.iter().map(|x| &**x), self.span, shape)\n+                rewrite_tuple_type(context, items.iter().map(|x| &**x), self.span, shape)\n             }\n             ast::TyKind::Path(ref q_self, ref path) => {\n                 rewrite_path(context, PathContext::Type, q_self.as_ref(), path, shape)"}, {"sha": "664d538fbb9bb707f3bdf1be2405ca420dc4f67d", "filename": "src/utils.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7c8432f05bf77ccd7aba238e9871ba50160e85df/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8432f05bf77ccd7aba238e9871ba50160e85df/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=7c8432f05bf77ccd7aba238e9871ba50160e85df", "patch": "@@ -299,29 +299,32 @@ pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, shape: Shape) -> Option<S\n     {\n         let snippet = s.as_ref();\n \n-        if !snippet.contains('\\n') && snippet.len() > shape.width {\n-            return None;\n-        } else {\n-            let mut lines = snippet.lines();\n-\n-            // The caller of this function has already placed `shape.offset`\n-            // characters on the first line.\n-            let first_line_max_len = try_opt!(max_width.checked_sub(shape.indent.width()));\n-            if lines.next().unwrap().len() > first_line_max_len {\n+        if !snippet.is_empty() {\n+            if !snippet.contains('\\n') && snippet.len() > shape.width {\n                 return None;\n-            }\n+            } else {\n+                let mut lines = snippet.lines();\n+\n+                // The caller of this function has already placed `shape.offset`\n+                // characters on the first line.\n+                let first_line_max_len = try_opt!(max_width.checked_sub(shape.indent.width()));\n+                if lines.next().unwrap().len() > first_line_max_len {\n+                    return None;\n+                }\n \n-            // The other lines must fit within the maximum width.\n-            if lines.any(|line| line.len() > max_width) {\n-                return None;\n-            }\n+                // The other lines must fit within the maximum width.\n+                if lines.any(|line| line.len() > max_width) {\n+                    return None;\n+                }\n \n-            // `width` is the maximum length of the last line, excluding\n-            // indentation.\n-            // A special check for the last line, since the caller may\n-            // place trailing characters on this line.\n-            if snippet.lines().rev().next().unwrap().len() > shape.indent.width() + shape.width {\n-                return None;\n+                // `width` is the maximum length of the last line, excluding\n+                // indentation.\n+                // A special check for the last line, since the caller may\n+                // place trailing characters on this line.\n+                if snippet.lines().rev().next().unwrap().len() >\n+                   shape.indent.width() + shape.width {\n+                    return None;\n+                }\n             }\n         }\n     }"}, {"sha": "6f613fb10bb4a656394ef920c3ddb5475d066bde", "filename": "tests/source/configs-fn_call_style-block-trailing-comma.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c8432f05bf77ccd7aba238e9871ba50160e85df/tests%2Fsource%2Fconfigs-fn_call_style-block-trailing-comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8432f05bf77ccd7aba238e9871ba50160e85df/tests%2Fsource%2Fconfigs-fn_call_style-block-trailing-comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fconfigs-fn_call_style-block-trailing-comma.rs?ref=7c8432f05bf77ccd7aba238e9871ba50160e85df", "patch": "@@ -4,4 +4,5 @@\n // rustfmt should not add trailing comma when rewriting macro. See #1528.\n fn a() {\n     panic!(\"this is a long string that goes past the maximum line length causing rustfmt to insert a comma here:\");\n+    foo(oooptoptoptoptptooptoptoptoptptooptoptoptoptptoptoptoptoptpt());\n }"}, {"sha": "6708966fa691ba1df0f17e13506bb71985392947", "filename": "tests/source/configs-fn_call_style-block.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7c8432f05bf77ccd7aba238e9871ba50160e85df/tests%2Fsource%2Fconfigs-fn_call_style-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8432f05bf77ccd7aba238e9871ba50160e85df/tests%2Fsource%2Fconfigs-fn_call_style-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fconfigs-fn_call_style-block.rs?ref=7c8432f05bf77ccd7aba238e9871ba50160e85df", "patch": "@@ -45,3 +45,54 @@ fn query(conn: &Connection) -> Result<()> {\n \n     Ok(())\n }\n+\n+// #1449\n+fn future_rayon_wait_1_thread() {\n+    // run with only 1 worker thread; this would deadlock if we couldn't make progress\n+    let mut result = None;\n+    ThreadPool::new(Configuration::new().num_threads(1))\n+        .unwrap()\n+        .install(\n+            || {\n+                scope(\n+                    |s| {\n+                        use std::sync::mpsc::channel;\n+                        let (tx, rx) = channel();\n+                        let a = s.spawn_future(lazy(move || Ok::<usize, ()>(rx.recv().unwrap())));\n+                        //                          ^^^^ FIXME: why is this needed?\n+                        let b = s.spawn_future(a.map(|v| v + 1));\n+                        let c = s.spawn_future(b.map(|v| v + 1));\n+                        s.spawn(move |_| tx.send(20).unwrap());\n+                        result = Some(c.rayon_wait().unwrap());\n+                    },\n+                );\n+            },\n+        );\n+    assert_eq!(result, Some(22));\n+}\n+\n+// #1494\n+impl Cursor {\n+    fn foo() {\n+        self.cur_type()\n+            .num_template_args()\n+            .or_else(|| {\n+                let n: c_int = unsafe { clang_Cursor_getNumTemplateArguments(self.x) };\n+\n+                if n >= 0 {\n+                    Some(n as u32)\n+                } else {\n+                    debug_assert_eq!(n, -1);\n+                    None\n+                }\n+            })\n+            .or_else(|| {\n+                let canonical = self.canonical();\n+                if canonical != *self {\n+                    canonical.num_template_args()\n+                } else {\n+                    None\n+                }\n+            });\n+    }\n+}"}, {"sha": "27f7ff67da9a507353456787e32631ce5eaae8dd", "filename": "tests/source/expr-block.rs", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/7c8432f05bf77ccd7aba238e9871ba50160e85df/tests%2Fsource%2Fexpr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8432f05bf77ccd7aba238e9871ba50160e85df/tests%2Fsource%2Fexpr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fexpr-block.rs?ref=7c8432f05bf77ccd7aba238e9871ba50160e85df", "patch": "@@ -143,3 +143,132 @@ fn foo() {\n          DefinitiveListTactic::Horizontal\n     }\n }\n+\n+fn combine_block() {\n+    foo(\n+        Bar {\n+            x: value,\n+            y: value2,\n+        },\n+    );\n+\n+    foo((Bar {\n+        x: value,\n+        y: value2,\n+    },));\n+\n+    foo((1, 2, 3, Bar {\n+        x: value,\n+        y: value2,\n+    }));\n+\n+    foo((1, 2, 3, |x| {\n+        let y = x + 1;\n+        let z = y + 1;\n+        z\n+    }));\n+\n+    let opt = Some(\n+        Struct(\n+            long_argument_one,\n+            long_argument_two,\n+            long_argggggggg,\n+        ),\n+    );\n+\n+    do_thing(\n+        |param| {\n+            action();\n+            foo(param)\n+        },\n+    );\n+\n+    do_thing(\n+        x,\n+        |param| {\n+            action();\n+            foo(param)\n+        },\n+    );\n+\n+    do_thing(\n+        x,\n+        (\n+            1,\n+            2,\n+            3,\n+            |param| {\n+                action();\n+                foo(param)\n+            },\n+        ),\n+    );\n+\n+    Ok(\n+        some_function(\n+            lllllllllong_argument_one,\n+            lllllllllong_argument_two,\n+            lllllllllllllllllllllllllllllong_argument_three,\n+        ),\n+    );\n+\n+    foo(\n+        thing,\n+        bar(\n+            param2,\n+            pparam1param1param1param1param1param1param1param1param1param1aram1,\n+            param3,\n+        ),\n+    );\n+\n+    foo.map_or(\n+        || {\n+            Ok(\n+                SomeStruct {\n+                    f1: 0,\n+                    f2: 0,\n+                    f3: 0,\n+                },\n+            )\n+        },\n+    );\n+\n+    match opt {\n+        Some(x) => somefunc(anotherfunc(\n+            long_argument_one,\n+            long_argument_two,\n+            long_argument_three,\n+        )),\n+        Some(x) => |x| {\n+            let y = x + 1;\n+            let z = y + 1;\n+            z\n+        },\n+        Some(x) => (1, 2, |x| {\n+            let y = x + 1;\n+            let z = y + 1;\n+            z\n+        }),\n+        Some(x) => SomeStruct {\n+            f1: long_argument_one,\n+            f2: long_argument_two,\n+            f3: long_argument_three,\n+        },\n+        None => Ok(SomeStruct {\n+            f1: long_argument_one,\n+            f2: long_argument_two,\n+            f3: long_argument_three,\n+        }),\n+    };\n+\n+    match x {\n+        y => func(\n+            xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,\n+        ),\n+        _ => func(\n+            x,\n+            yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy,\n+            zzz,\n+        ),\n+    }\n+}"}, {"sha": "5d1e1de0f68981711bd849cc999b970fb57ec9d8", "filename": "tests/target/closure-block-inside-macro.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7c8432f05bf77ccd7aba238e9871ba50160e85df/tests%2Ftarget%2Fclosure-block-inside-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8432f05bf77ccd7aba238e9871ba50160e85df/tests%2Ftarget%2Fclosure-block-inside-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fclosure-block-inside-macro.rs?ref=7c8432f05bf77ccd7aba238e9871ba50160e85df", "patch": "@@ -1,15 +1,13 @@\n // rustfmt-fn_call_style: Block\n \n // #1547\n-fuzz_target!(\n-    |data: &[u8]| {\n-        if let Some(first) = data.first() {\n-            let index = *first as usize;\n-            if index >= ENCODINGS.len() {\n-                return;\n-            }\n-            let encoding = ENCODINGS[index];\n-            dispatch_test(encoding, &data[1..]);\n+fuzz_target!(|data: &[u8]| {\n+    if let Some(first) = data.first() {\n+        let index = *first as usize;\n+        if index >= ENCODINGS.len() {\n+            return;\n         }\n+        let encoding = ENCODINGS[index];\n+        dispatch_test(encoding, &data[1..]);\n     }\n-);\n+});"}, {"sha": "ebdf41d0e3b3c9d13c511fc4c23d120131949d7d", "filename": "tests/target/configs-fn_call_style-block-trailing-comma.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c8432f05bf77ccd7aba238e9871ba50160e85df/tests%2Ftarget%2Fconfigs-fn_call_style-block-trailing-comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8432f05bf77ccd7aba238e9871ba50160e85df/tests%2Ftarget%2Fconfigs-fn_call_style-block-trailing-comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs-fn_call_style-block-trailing-comma.rs?ref=7c8432f05bf77ccd7aba238e9871ba50160e85df", "patch": "@@ -4,4 +4,7 @@\n // rustfmt should not add trailing comma when rewriting macro. See #1528.\n fn a() {\n     panic!(\"this is a long string that goes past the maximum line length causing rustfmt to insert a comma here:\");\n+    foo(\n+        oooptoptoptoptptooptoptoptoptptooptoptoptoptptoptoptoptoptpt(),\n+    );\n }"}, {"sha": "cd19d8bb838c3d4988f9b32a1b1398a9be94000a", "filename": "tests/target/configs-fn_call_style-block.rs", "status": "modified", "additions": 56, "deletions": 7, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/7c8432f05bf77ccd7aba238e9871ba50160e85df/tests%2Ftarget%2Fconfigs-fn_call_style-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8432f05bf77ccd7aba238e9871ba50160e85df/tests%2Ftarget%2Fconfigs-fn_call_style-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs-fn_call_style-block.rs?ref=7c8432f05bf77ccd7aba238e9871ba50160e85df", "patch": "@@ -13,18 +13,20 @@ fn main() {\n         \"elit\",\n     );\n     // #1501\n-    let hyper = Arc::new(\n-        Client::with_connector(HttpsConnector::new(TlsClient::new())),\n-    );\n+    let hyper = Arc::new(Client::with_connector(\n+        HttpsConnector::new(TlsClient::new()),\n+    ));\n }\n \n // #1521\n impl Foo {\n     fn map_pixel_to_coords(&self, point: &Vector2i, view: &View) -> Vector2f {\n         unsafe {\n-            Vector2f::from_raw(\n-                ffi::sfRenderTexture_mapPixelToCoords(self.render_texture, point.raw(), view.raw()),\n-            )\n+            Vector2f::from_raw(ffi::sfRenderTexture_mapPixelToCoords(\n+                self.render_texture,\n+                point.raw(),\n+                view.raw(),\n+            ))\n         }\n     }\n }\n@@ -34,7 +36,7 @@ fn issue1420() {\n         r#\"\n         # Getting started\n         ...\n-    \"#\n+    \"#,\n     )\n         .running(waltz)\n }\n@@ -58,3 +60,50 @@ fn query(conn: &Connection) -> Result<()> {\n \n     Ok(())\n }\n+\n+// #1449\n+fn future_rayon_wait_1_thread() {\n+    // run with only 1 worker thread; this would deadlock if we couldn't make progress\n+    let mut result = None;\n+    ThreadPool::new(Configuration::new().num_threads(1))\n+        .unwrap()\n+        .install(|| {\n+            scope(|s| {\n+                use std::sync::mpsc::channel;\n+                let (tx, rx) = channel();\n+                let a = s.spawn_future(lazy(move || Ok::<usize, ()>(rx.recv().unwrap())));\n+                //                          ^^^^ FIXME: why is this needed?\n+                let b = s.spawn_future(a.map(|v| v + 1));\n+                let c = s.spawn_future(b.map(|v| v + 1));\n+                s.spawn(move |_| tx.send(20).unwrap());\n+                result = Some(c.rayon_wait().unwrap());\n+            });\n+        });\n+    assert_eq!(result, Some(22));\n+}\n+\n+// #1494\n+impl Cursor {\n+    fn foo() {\n+        self.cur_type()\n+            .num_template_args()\n+            .or_else(|| {\n+                let n: c_int = unsafe { clang_Cursor_getNumTemplateArguments(self.x) };\n+\n+                if n >= 0 {\n+                    Some(n as u32)\n+                } else {\n+                    debug_assert_eq!(n, -1);\n+                    None\n+                }\n+            })\n+            .or_else(|| {\n+                let canonical = self.canonical();\n+                if canonical != *self {\n+                    canonical.num_template_args()\n+                } else {\n+                    None\n+                }\n+            });\n+    }\n+}"}, {"sha": "b4d86ed82f5bdc3298700123782883609f63d6e8", "filename": "tests/target/expr-block.rs", "status": "modified", "additions": 114, "deletions": 1, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/7c8432f05bf77ccd7aba238e9871ba50160e85df/tests%2Ftarget%2Fexpr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8432f05bf77ccd7aba238e9871ba50160e85df/tests%2Ftarget%2Fexpr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr-block.rs?ref=7c8432f05bf77ccd7aba238e9871ba50160e85df", "patch": "@@ -102,7 +102,7 @@ fn arrays() {\n             Weighted { weight: 1, item: 1 },\n             Weighted { weight: x, item: 2 },\n             Weighted { weight: 1, item: 3 },\n-        ]\n+        ],\n     );\n \n     let z = [\n@@ -213,3 +213,116 @@ fn foo() {\n         DefinitiveListTactic::Horizontal\n     }\n }\n+\n+fn combine_block() {\n+    foo(Bar {\n+        x: value,\n+        y: value2,\n+    });\n+\n+    foo((Bar {\n+        x: value,\n+        y: value2,\n+    },));\n+\n+    foo((\n+        1,\n+        2,\n+        3,\n+        Bar {\n+            x: value,\n+            y: value2,\n+        },\n+    ));\n+\n+    foo((1, 2, 3, |x| {\n+        let y = x + 1;\n+        let z = y + 1;\n+        z\n+    }));\n+\n+    let opt = Some(Struct(\n+        long_argument_one,\n+        long_argument_two,\n+        long_argggggggg,\n+    ));\n+\n+    do_thing(|param| {\n+        action();\n+        foo(param)\n+    });\n+\n+    do_thing(x, |param| {\n+        action();\n+        foo(param)\n+    });\n+\n+    do_thing(x, (1, 2, 3, |param| {\n+        action();\n+        foo(param)\n+    }));\n+\n+    Ok(some_function(\n+        lllllllllong_argument_one,\n+        lllllllllong_argument_two,\n+        lllllllllllllllllllllllllllllong_argument_three,\n+    ));\n+\n+    foo(\n+        thing,\n+        bar(\n+            param2,\n+            pparam1param1param1param1param1param1param1param1param1param1aram1,\n+            param3,\n+        ),\n+    );\n+\n+    foo.map_or(|| {\n+        Ok(SomeStruct {\n+            f1: 0,\n+            f2: 0,\n+            f3: 0,\n+        })\n+    });\n+\n+    match opt {\n+        Some(x) => somefunc(anotherfunc(\n+            long_argument_one,\n+            long_argument_two,\n+            long_argument_three,\n+        )),\n+        Some(x) => |x| {\n+            let y = x + 1;\n+            let z = y + 1;\n+            z\n+        },\n+        Some(x) => (1, 2, |x| {\n+            let y = x + 1;\n+            let z = y + 1;\n+            z\n+        }),\n+        Some(x) => SomeStruct {\n+            f1: long_argument_one,\n+            f2: long_argument_two,\n+            f3: long_argument_three,\n+        },\n+        None => Ok(SomeStruct {\n+            f1: long_argument_one,\n+            f2: long_argument_two,\n+            f3: long_argument_three,\n+        }),\n+    };\n+\n+    match x {\n+        y => func(\n+            xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,\n+        ),\n+        _ => {\n+            func(\n+                x,\n+                yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy,\n+                zzz,\n+            )\n+        }\n+    }\n+}"}]}