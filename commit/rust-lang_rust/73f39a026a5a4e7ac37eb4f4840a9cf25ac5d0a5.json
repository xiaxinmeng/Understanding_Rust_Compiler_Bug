{"sha": "73f39a026a5a4e7ac37eb4f4840a9cf25ac5d0a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczZjM5YTAyNmE1YTRlN2FjMzdlYjRmNDg0MGE5Y2YyNWFjNWQwYTU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2016-04-14T12:49:39Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-05-03T15:30:10Z"}, "message": "Short-cut Sized matching on ADTs\n\nPut a constraint type on every ADT def, such that the ADT def is sized iff the constraint\ntype is, and use that in selection. This ignores types that are obviously sized.\n\nThis improves typeck performance by ~15%.", "tree": {"sha": "5cd29bda4ff13408b1ef3fe0e8c17c8b44e15b20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5cd29bda4ff13408b1ef3fe0e8c17c8b44e15b20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73f39a026a5a4e7ac37eb4f4840a9cf25ac5d0a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73f39a026a5a4e7ac37eb4f4840a9cf25ac5d0a5", "html_url": "https://github.com/rust-lang/rust/commit/73f39a026a5a4e7ac37eb4f4840a9cf25ac5d0a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73f39a026a5a4e7ac37eb4f4840a9cf25ac5d0a5/comments", "author": null, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3157691f963a86776cb7e6a7842f566032890aba", "url": "https://api.github.com/repos/rust-lang/rust/commits/3157691f963a86776cb7e6a7842f566032890aba", "html_url": "https://github.com/rust-lang/rust/commit/3157691f963a86776cb7e6a7842f566032890aba"}], "stats": {"total": 308, "additions": 225, "deletions": 83}, "files": [{"sha": "85b4b4f59c49a1f9076b7bfdb3f56f38446aecee", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73f39a026a5a4e7ac37eb4f4840a9cf25ac5d0a5/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f39a026a5a4e7ac37eb4f4840a9cf25ac5d0a5/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=73f39a026a5a4e7ac37eb4f4840a9cf25ac5d0a5", "patch": "@@ -88,6 +88,7 @@ pub enum DepNode<D: Clone + Debug> {\n     ImplOrTraitItems(D),\n     ItemSignature(D),\n     FieldTy(D),\n+    SizedConstraint(D),\n     TraitItemDefIds(D),\n     InherentImpls(D),\n     ImplItems(D),\n@@ -193,6 +194,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             ImplOrTraitItems(ref d) => op(d).map(ImplOrTraitItems),\n             ItemSignature(ref d) => op(d).map(ItemSignature),\n             FieldTy(ref d) => op(d).map(FieldTy),\n+            SizedConstraint(ref d) => op(d).map(SizedConstraint),\n             TraitItemDefIds(ref d) => op(d).map(TraitItemDefIds),\n             InherentImpls(ref d) => op(d).map(InherentImpls),\n             ImplItems(ref d) => op(d).map(ImplItems),"}, {"sha": "9267ea393ac9f6ab19b790e87d79f652d9a2905b", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 73, "deletions": 82, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/73f39a026a5a4e7ac37eb4f4840a9cf25ac5d0a5/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f39a026a5a4e7ac37eb4f4840a9cf25ac5d0a5/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=73f39a026a5a4e7ac37eb4f4840a9cf25ac5d0a5", "patch": "@@ -13,7 +13,6 @@\n pub use self::MethodMatchResult::*;\n pub use self::MethodMatchedData::*;\n use self::SelectionCandidate::*;\n-use self::BuiltinBoundConditions::*;\n use self::EvaluationResult::*;\n \n use super::coherence;\n@@ -232,10 +231,18 @@ struct EvaluatedCandidate<'tcx> {\n     evaluation: EvaluationResult,\n }\n \n-enum BuiltinBoundConditions<'tcx> {\n-    If(ty::Binder<Vec<Ty<'tcx>>>),\n-    ParameterBuiltin,\n-    AmbiguousBuiltin\n+/// When does the builtin impl for `T: Trait` apply?\n+enum BuiltinImplConditions<'tcx> {\n+    /// The impl is conditional on T1,T2,.. : Trait\n+    Where(ty::Binder<Vec<Ty<'tcx>>>),\n+    /// There is no built-in impl. There may be some other\n+    /// candidate (a where-clause or user-defined impl).\n+    None,\n+    /// There is *no* impl for this, builtin or not. Ignore\n+    /// all where-clauses.\n+    Never(SelectionError<'tcx>),\n+    /// It is unknown whether there is an impl.\n+    Ambiguous\n }\n \n #[derive(Copy, Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n@@ -1608,39 +1615,45 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // those will hopefully change to library-defined traits in the\n     // future.\n \n+    // HACK: if this returns an error, selection exits without considering\n+    // other impls.\n     fn assemble_builtin_bound_candidates<'o>(&mut self,\n                                              bound: ty::BuiltinBound,\n                                              obligation: &TraitObligation<'tcx>,\n                                              candidates: &mut SelectionCandidateSet<'tcx>)\n                                              -> Result<(),SelectionError<'tcx>>\n     {\n         match self.builtin_bound(bound, obligation) {\n-            Ok(If(..)) => {\n+            BuiltinImplConditions::Where(..) => {\n                 debug!(\"builtin_bound: bound={:?}\",\n                        bound);\n                 candidates.vec.push(BuiltinCandidate(bound));\n                 Ok(())\n             }\n-            Ok(ParameterBuiltin) => { Ok(()) }\n-            Ok(AmbiguousBuiltin) => {\n+            BuiltinImplConditions::None => { Ok(()) }\n+            BuiltinImplConditions::Ambiguous => {\n                 debug!(\"assemble_builtin_bound_candidates: ambiguous builtin\");\n                 Ok(candidates.ambiguous = true)\n             }\n-            Err(e) => { Err(e) }\n+            BuiltinImplConditions::Never(e) => { Err(e) }\n         }\n     }\n \n     fn builtin_bound(&mut self,\n                      bound: ty::BuiltinBound,\n                      obligation: &TraitObligation<'tcx>)\n-                     -> Result<BuiltinBoundConditions<'tcx>,SelectionError<'tcx>>\n+                     -> BuiltinImplConditions<'tcx>\n     {\n         // Note: these tests operate on types that may contain bound\n         // regions. To be proper, we ought to skolemize here, but we\n         // forego the skolemization and defer it until the\n         // confirmation step.\n \n         let self_ty = self.infcx.shallow_resolve(obligation.predicate.0.self_ty());\n+\n+        let always = BuiltinImplConditions::Where(ty::Binder(Vec::new()));\n+        let never = BuiltinImplConditions::Never(Unimplemented);\n+\n         return match self_ty.sty {\n             ty::TyInfer(ty::IntVar(_)) |\n             ty::TyInfer(ty::FloatVar(_)) |\n@@ -1652,14 +1665,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::TyFnPtr(_) |\n             ty::TyChar => {\n                 // safe for everything\n-                ok_if(Vec::new())\n+                always\n             }\n \n             ty::TyBox(_) => {  // Box<T>\n                 match bound {\n-                    ty::BoundCopy => Err(Unimplemented),\n-\n-                    ty::BoundSized => ok_if(Vec::new()),\n+                    ty::BoundCopy => never,\n+                    ty::BoundSized => always,\n \n                     ty::BoundSync | ty::BoundSend => {\n                         bug!(\"Send/Sync shouldn't occur in builtin_bounds()\");\n@@ -1669,7 +1681,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ty::TyRawPtr(..) => {     // *const T, *mut T\n                 match bound {\n-                    ty::BoundCopy | ty::BoundSized => ok_if(Vec::new()),\n+                    ty::BoundCopy | ty::BoundSized => always,\n \n                     ty::BoundSync | ty::BoundSend => {\n                         bug!(\"Send/Sync shouldn't occur in builtin_bounds()\");\n@@ -1679,10 +1691,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ty::TyTrait(ref data) => {\n                 match bound {\n-                    ty::BoundSized => Err(Unimplemented),\n+                    ty::BoundSized => never,\n                     ty::BoundCopy => {\n+                        // FIXME(#32963): bit-rot fungus infestation\n                         if data.bounds.builtin_bounds.contains(&bound) {\n-                            ok_if(Vec::new())\n+                            always\n                         } else {\n                             // Recursively check all supertraits to find out if any further\n                             // bounds are required and thus we must fulfill.\n@@ -1692,11 +1705,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             let copy_def_id = obligation.predicate.def_id();\n                             for tr in util::supertraits(self.tcx(), principal) {\n                                 if tr.def_id() == copy_def_id {\n-                                    return ok_if(Vec::new())\n+                                    return always\n                                 }\n                             }\n \n-                            Err(Unimplemented)\n+                            never\n                         }\n                     }\n                     ty::BoundSync | ty::BoundSend => {\n@@ -1711,14 +1724,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     ty::BoundCopy => {\n                         match mutbl {\n                             // &mut T is affine and hence never `Copy`\n-                            hir::MutMutable => Err(Unimplemented),\n+                            hir::MutMutable => never,\n \n                             // &T is always copyable\n-                            hir::MutImmutable => ok_if(Vec::new()),\n+                            hir::MutImmutable => always\n                         }\n                     }\n \n-                    ty::BoundSized => ok_if(Vec::new()),\n+                    ty::BoundSized => always,\n \n                     ty::BoundSync | ty::BoundSend => {\n                         bug!(\"Send/Sync shouldn't occur in builtin_bounds()\");\n@@ -1730,7 +1743,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // [T; n]\n                 match bound {\n                     ty::BoundCopy => ok_if(vec![element_ty]),\n-                    ty::BoundSized => ok_if(Vec::new()),\n+                    ty::BoundSized => always,\n                     ty::BoundSync | ty::BoundSend => {\n                         bug!(\"Send/Sync shouldn't occur in builtin_bounds()\");\n                     }\n@@ -1743,65 +1756,61 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         bug!(\"Send/Sync shouldn't occur in builtin_bounds()\");\n                     }\n \n-                    ty::BoundCopy | ty::BoundSized => Err(Unimplemented),\n+                    ty::BoundCopy | ty::BoundSized => never\n                 }\n             }\n \n             // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n             ty::TyTuple(ref tys) => ok_if(tys.clone()),\n \n-            ty::TyClosure(_, ref substs) => {\n-                // FIXME -- This case is tricky. In the case of by-ref\n-                // closures particularly, we need the results of\n-                // inference to decide how to reflect the type of each\n-                // upvar (the upvar may have type `T`, but the runtime\n-                // type could be `&mut`, `&`, or just `T`). For now,\n-                // though, we'll do this unsoundly and assume that all\n-                // captures are by value. Really what we ought to do\n-                // is reserve judgement and then intertwine this\n-                // analysis with closure inference.\n-\n-                // Unboxed closures shouldn't be\n-                // implicitly copyable\n-                if bound == ty::BoundCopy {\n-                    return Ok(ParameterBuiltin);\n-                }\n+            ty::TyClosure(..) => {\n+                match bound {\n+                    ty::BoundSync | ty::BoundSend => {\n+                        bug!(\"Send/Sync shouldn't occur in builtin_bounds()\");\n+                    }\n \n-                // Upvars are always local variables or references to\n-                // local variables, and local variables cannot be\n-                // unsized, so the closure struct as a whole must be\n-                // Sized.\n-                if bound == ty::BoundSized {\n-                    return ok_if(Vec::new());\n+                    ty::BoundCopy => never,\n+                    ty::BoundSized => always\n                 }\n-\n-                ok_if(substs.upvar_tys.clone())\n             }\n \n             ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n-                let types: Vec<Ty> = def.all_fields().map(|f| {\n-                    f.ty(self.tcx(), substs)\n-                }).collect();\n-                nominal(bound, types)\n+                match bound {\n+                    // Fallback to whatever user-defined impls exist in this case.\n+                    ty::BoundCopy => BuiltinImplConditions::None,\n+\n+                    // Sized if all the component types are sized.\n+                    ty::BoundSized => {\n+                        let sized_crit = def.sized_constraint(self.tcx());\n+                        if sized_crit == self.tcx().types.bool {\n+                            always\n+                        } else {\n+                            ok_if(vec![sized_crit.subst(self.tcx(), substs)])\n+                        }\n+                    }\n+\n+                    // Shouldn't be coming through here.\n+                    ty::BoundSend | ty::BoundSync => bug!(),\n+                }\n             }\n \n             ty::TyProjection(_) | ty::TyParam(_) => {\n                 // Note: A type parameter is only considered to meet a\n                 // particular bound if there is a where clause telling\n                 // us that it does, and that case is handled by\n                 // `assemble_candidates_from_caller_bounds()`.\n-                Ok(ParameterBuiltin)\n+                BuiltinImplConditions::None\n             }\n \n             ty::TyInfer(ty::TyVar(_)) => {\n                 // Unbound type variable. Might or might not have\n                 // applicable impls and so forth, depending on what\n                 // those type variables wind up being bound to.\n                 debug!(\"assemble_builtin_bound_candidates: ambiguous builtin\");\n-                Ok(AmbiguousBuiltin)\n+                BuiltinImplConditions::Ambiguous\n             }\n \n-            ty::TyError => ok_if(Vec::new()),\n+            ty::TyError => always,\n \n             ty::TyInfer(ty::FreshTy(_))\n             | ty::TyInfer(ty::FreshIntTy(_))\n@@ -1811,26 +1820,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n         };\n \n-        fn ok_if<'tcx>(v: Vec<Ty<'tcx>>)\n-                       -> Result<BuiltinBoundConditions<'tcx>, SelectionError<'tcx>> {\n-            Ok(If(ty::Binder(v)))\n-        }\n-\n-        fn nominal<'cx, 'tcx>(bound: ty::BuiltinBound,\n-                              types: Vec<Ty<'tcx>>)\n-                              -> Result<BuiltinBoundConditions<'tcx>, SelectionError<'tcx>>\n-        {\n-            // First check for markers and other nonsense.\n-            match bound {\n-                // Fallback to whatever user-defined impls exist in this case.\n-                ty::BoundCopy => Ok(ParameterBuiltin),\n-\n-                // Sized if all the component types are sized.\n-                ty::BoundSized => ok_if(types),\n-\n-                // Shouldn't be coming through here.\n-                ty::BoundSend | ty::BoundSync => bug!(),\n-            }\n+        fn ok_if<'tcx>(v: Vec<Ty<'tcx>>) -> BuiltinImplConditions<'tcx> {\n+            BuiltinImplConditions::Where(ty::Binder(v))\n         }\n     }\n \n@@ -1999,7 +1990,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match candidate {\n             BuiltinCandidate(builtin_bound) => {\n                 Ok(VtableBuiltin(\n-                    self.confirm_builtin_candidate(obligation, builtin_bound)?))\n+                    self.confirm_builtin_candidate(obligation, builtin_bound)))\n             }\n \n             ParamCandidate(param) => {\n@@ -2100,18 +2091,18 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn confirm_builtin_candidate(&mut self,\n                                  obligation: &TraitObligation<'tcx>,\n                                  bound: ty::BuiltinBound)\n-                                 -> Result<VtableBuiltinData<PredicateObligation<'tcx>>,\n-                                           SelectionError<'tcx>>\n+                                 -> VtableBuiltinData<PredicateObligation<'tcx>>\n     {\n         debug!(\"confirm_builtin_candidate({:?})\",\n                obligation);\n \n-        match self.builtin_bound(bound, obligation)? {\n-            If(nested) => Ok(self.vtable_builtin_data(obligation, bound, nested)),\n-            AmbiguousBuiltin | ParameterBuiltin => {\n+        match self.builtin_bound(bound, obligation) {\n+            BuiltinImplConditions::Where(nested) =>\n+                self.vtable_builtin_data(obligation, bound, nested),\n+            _ => {\n                 span_bug!(\n                     obligation.cause.span,\n-                    \"builtin bound for {:?} was ambig\",\n+                    \"confiriming builtin impl for {:?} where none exists\",\n                     obligation);\n             }\n         }"}, {"sha": "b3ca120bd9f136b090b66bb78ce91f3fc2ec9f62", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 150, "deletions": 1, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/73f39a026a5a4e7ac37eb4f4840a9cf25ac5d0a5/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f39a026a5a4e7ac37eb4f4840a9cf25ac5d0a5/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=73f39a026a5a4e7ac37eb4f4840a9cf25ac5d0a5", "patch": "@@ -1498,6 +1498,7 @@ pub struct AdtDefData<'tcx, 'container: 'tcx> {\n     pub variants: Vec<VariantDefData<'tcx, 'container>>,\n     destructor: Cell<Option<DefId>>,\n     flags: Cell<AdtFlags>,\n+    sized_constraint: ivar::TyIVar<'tcx, 'container>,\n }\n \n impl<'tcx, 'container> PartialEq for AdtDefData<'tcx, 'container> {\n@@ -1575,7 +1576,8 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n             did: did,\n             variants: variants,\n             flags: Cell::new(flags),\n-            destructor: Cell::new(None)\n+            destructor: Cell::new(None),\n+            sized_constraint: ivar::TyIVar::new(),\n         }\n     }\n \n@@ -1716,6 +1718,153 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n             None => NoDtor,\n         }\n     }\n+\n+    /// Returns a simpler type such that `Self: Sized` if and only\n+    /// if that type is Sized, or `TyErr` if this type is recursive.\n+    pub fn sized_constraint(&self, tcx: &ty::TyCtxt<'tcx>) -> Ty<'tcx> {\n+        let dep_node = DepNode::SizedConstraint(self.did);\n+        match self.sized_constraint.get(dep_node) {\n+            None => {\n+                let this = tcx.lookup_adt_def_master(self.did);\n+                this.calculate_sized_constraint_inner(tcx, &mut Vec::new());\n+                self.sized_constraint.unwrap(dep_node)\n+            }\n+            Some(ty) => ty\n+        }\n+    }\n+}\n+\n+impl<'tcx> AdtDefData<'tcx, 'tcx> {\n+    fn sized_constraint_for_tys<TYS>(\n+        &'tcx self,\n+        tcx: &ty::TyCtxt<'tcx>,\n+        stack: &mut Vec<AdtDefMaster<'tcx>>,\n+        tys: TYS\n+    ) -> Ty<'tcx>\n+        where TYS: IntoIterator<Item=Ty<'tcx>>\n+    {\n+        let tys : Vec<_> = tys.into_iter()\n+            .map(|ty| self.sized_constraint_for_ty(tcx, stack, ty))\n+            .filter(|ty| *ty != tcx.types.bool)\n+            .collect();\n+\n+        match tys.len() {\n+            0 => tcx.types.bool,\n+            1 => tys[0],\n+            _ => tcx.mk_tup(tys)\n+        }\n+    }\n+    fn sized_constraint_for_ty(\n+        &'tcx self,\n+        tcx: &ty::TyCtxt<'tcx>,\n+        stack: &mut Vec<AdtDefMaster<'tcx>>,\n+        ty: Ty<'tcx>\n+    ) -> Ty<'tcx> {\n+        let result = match ty.sty {\n+            TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n+            TyBox(..) | TyRawPtr(..) | TyRef(..) | TyFnDef(..) | TyFnPtr(_) |\n+            TyArray(..) | TyClosure(..) => {\n+                // these are always sized - return a primitive\n+                tcx.types.bool\n+            }\n+\n+            TyStr | TyTrait(..) | TySlice(_) => {\n+                // these are never sized - return the target type\n+                ty\n+            }\n+\n+            TyTuple(ref tys) => {\n+                self.sized_constraint_for_tys(tcx, stack, tys.iter().cloned())\n+            }\n+\n+            TyEnum(adt, substs) | TyStruct(adt, substs) => {\n+                // recursive case\n+                let adt = tcx.lookup_adt_def_master(adt.did);\n+                adt.calculate_sized_constraint_inner(tcx, stack);\n+                let adt_ty =\n+                    adt.sized_constraint\n+                    .unwrap(DepNode::SizedConstraint(adt.did))\n+                    .subst(tcx, substs);\n+                debug!(\"sized_constraint_for_ty({:?}) intermediate = {:?}\",\n+                       ty, adt_ty);\n+                self.sized_constraint_for_ty(tcx, stack, adt_ty)\n+            }\n+\n+            TyProjection(..) => {\n+                // must calculate explicitly.\n+                // FIXME: consider special-casing always-Sized projections\n+                ty\n+            }\n+\n+            TyParam(..) => {\n+                let sized_trait = match tcx.lang_items.sized_trait() {\n+                    Some(x) => x,\n+                    _ => return ty\n+                };\n+                let sized_predicate = Binder(TraitRef {\n+                    def_id: sized_trait,\n+                    substs: tcx.mk_substs(Substs::new_trait(\n+                        vec![], vec![], ty\n+                    ))\n+                }).to_predicate();\n+                let predicates = tcx.lookup_predicates(self.did).predicates;\n+                if predicates.into_iter().any(|p| p == sized_predicate) {\n+                    tcx.types.bool\n+                } else {\n+                    ty\n+                }\n+            }\n+\n+            TyInfer(..) | TyError => {\n+                bug!(\"unexpected type `{:?}` in sized_constraint_for_ty\",\n+                     ty)\n+            }\n+        };\n+        debug!(\"sized_constraint_for_ty({:?}) = {:?}\", ty, result);\n+        result\n+    }\n+\n+    /// Calculates the Sized-constraint. This replaces all always-Sized\n+    /// types with bool. I could have made the TyIVar an Option, but that\n+    /// would have been so much code.\n+    fn calculate_sized_constraint_inner(&'tcx self, tcx: &ty::TyCtxt<'tcx>,\n+                                        stack: &mut Vec<AdtDefMaster<'tcx>>)\n+    {\n+\n+        let dep_node = DepNode::SizedConstraint(self.did);\n+\n+        if self.sized_constraint.get(dep_node).is_some() {\n+            return;\n+        }\n+\n+        if stack.contains(&self) {\n+            debug!(\"calculate_sized_constraint: {:?} is recursive\", self);\n+            self.sized_constraint.fulfill(dep_node, tcx.types.err);\n+            return;\n+        }\n+\n+        stack.push(self);\n+        let ty = self.sized_constraint_for_tys(\n+            tcx, stack,\n+            self.variants.iter().flat_map(|v| {\n+                v.fields.last()\n+            }).map(|f| f.unsubst_ty())\n+        );\n+\n+        let self_ = stack.pop().unwrap();\n+        assert_eq!(self_, self);\n+\n+        match self.sized_constraint.get(dep_node) {\n+            Some(old_ty) => {\n+                debug!(\"calculate_sized_constraint: {:?} recurred\", self);\n+                assert_eq!(old_ty, tcx.types.err)\n+            }\n+            None => {\n+                debug!(\"calculate_sized_constraint: {:?} => {:?}\", self, ty);\n+                self.sized_constraint.fulfill(dep_node, ty)\n+            }\n+        }\n+    }\n }\n \n impl<'tcx, 'container> VariantDefData<'tcx, 'container> {"}]}