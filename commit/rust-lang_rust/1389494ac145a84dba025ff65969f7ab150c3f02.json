{"sha": "1389494ac145a84dba025ff65969f7ab150c3f02", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzODk0OTRhYzE0NWE4NGRiYTAyNWZmNjU5NjlmN2FiMTUwYzNmMDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-11T14:46:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-11T14:46:17Z"}, "message": "Auto merge of #67000 - spastorino:remove-promoted-from-place, r=oli-obk\n\nPromote references to constants instead of statics\n\nr? @oli-obk", "tree": {"sha": "a26ccd59b4b7ee66e7893cbf18de4b5f780e770d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a26ccd59b4b7ee66e7893cbf18de4b5f780e770d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1389494ac145a84dba025ff65969f7ab150c3f02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1389494ac145a84dba025ff65969f7ab150c3f02", "html_url": "https://github.com/rust-lang/rust/commit/1389494ac145a84dba025ff65969f7ab150c3f02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1389494ac145a84dba025ff65969f7ab150c3f02/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "html_url": "https://github.com/rust-lang/rust/commit/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4"}, {"sha": "e51eccd2eff685bda7b5d6734ff4923b706bd476", "url": "https://api.github.com/repos/rust-lang/rust/commits/e51eccd2eff685bda7b5d6734ff4923b706bd476", "html_url": "https://github.com/rust-lang/rust/commit/e51eccd2eff685bda7b5d6734ff4923b706bd476"}], "stats": {"total": 2709, "additions": 1116, "deletions": 1593}, "files": [{"sha": "ed57f81e782167638a72f317bc7b101a4c759d6c", "filename": "src/librustc/mir/interpret/queries.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Fmir%2Finterpret%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Fmir%2Finterpret%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fqueries.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -36,11 +36,16 @@ impl<'tcx> TyCtxt<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         def_id: DefId,\n         substs: SubstsRef<'tcx>,\n+        promoted: Option<mir::Promoted>,\n         span: Option<Span>,\n     ) -> ConstEvalResult<'tcx> {\n         let instance = ty::Instance::resolve(self, param_env, def_id, substs);\n         if let Some(instance) = instance {\n-            self.const_eval_instance(param_env, instance, span)\n+            if let Some(promoted) = promoted {\n+                self.const_eval_promoted(param_env, instance, promoted)\n+            } else {\n+                self.const_eval_instance(param_env, instance, span)\n+            }\n         } else {\n             Err(ErrorHandled::TooGeneric)\n         }\n@@ -63,11 +68,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Evaluate a promoted constant.\n     pub fn const_eval_promoted(\n         self,\n+        param_env: ty::ParamEnv<'tcx>,\n         instance: ty::Instance<'tcx>,\n         promoted: mir::Promoted,\n     ) -> ConstEvalResult<'tcx> {\n         let cid = GlobalId { instance, promoted: Some(promoted) };\n-        let param_env = ty::ParamEnv::reveal_all();\n         self.const_eval_validated(param_env.and(cid))\n     }\n }"}, {"sha": "281cf46bdc2dc1a65d70f819f1bb6c3ac52f9cb3", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 25, "deletions": 144, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -166,6 +166,16 @@ pub struct Body<'tcx> {\n \n     /// A span representing this MIR, for error reporting.\n     pub span: Span,\n+\n+    /// The user may be writing e.g. &[(SOME_CELL, 42)][i].1 and this would get promoted, because\n+    /// we'd statically know that no thing with interior mutability will ever be available to the\n+    /// user without some serious unsafe code.  Now this means that our promoted is actually\n+    /// &[(SOME_CELL, 42)] and the MIR using it will do the &promoted[i].1 projection because the\n+    /// index may be a runtime value. Such a promoted value is illegal because it has reachable\n+    /// interior mutability. This flag just makes this situation very obvious where the previous\n+    /// implementation without the flag hid this situation silently.\n+    /// FIXME(oli-obk): rewrite the promoted during promotion to eliminate the cell components.\n+    pub ignore_interior_mut_in_const_validation: bool,\n }\n \n impl<'tcx> Body<'tcx> {\n@@ -202,6 +212,7 @@ impl<'tcx> Body<'tcx> {\n             spread_arg: None,\n             var_debug_info,\n             span,\n+            ignore_interior_mut_in_const_validation: false,\n             control_flow_destroyed,\n         }\n     }\n@@ -1642,68 +1653,16 @@ impl Debug for Statement<'_> {\n \n /// A path to a value; something that can be evaluated without\n /// changing or disturbing program state.\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, HashStable)]\n pub struct Place<'tcx> {\n-    pub base: PlaceBase<'tcx>,\n+    pub local: Local,\n \n     /// projection out of a place (access a field, deref a pointer, etc)\n     pub projection: &'tcx List<PlaceElem<'tcx>>,\n }\n \n impl<'tcx> rustc_serialize::UseSpecializedDecodable for Place<'tcx> {}\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable)]\n-pub enum PlaceBase<'tcx> {\n-    /// local variable\n-    Local(Local),\n-\n-    /// static or static mut variable\n-    Static(Box<Static<'tcx>>),\n-}\n-\n-/// We store the normalized type to avoid requiring normalization when reading MIR\n-#[derive(\n-    Clone,\n-    Debug,\n-    PartialEq,\n-    Eq,\n-    PartialOrd,\n-    Ord,\n-    Hash,\n-    RustcEncodable,\n-    RustcDecodable,\n-    HashStable\n-)]\n-pub struct Static<'tcx> {\n-    pub ty: Ty<'tcx>,\n-    pub kind: StaticKind<'tcx>,\n-    /// The `DefId` of the item this static was declared in. For promoted values, usually, this is\n-    /// the same as the `DefId` of the `mir::Body` containing the `Place` this promoted appears in.\n-    /// However, after inlining, that might no longer be the case as inlined `Place`s are copied\n-    /// into the calling frame.\n-    pub def_id: DefId,\n-}\n-\n-#[derive(\n-    Clone,\n-    Debug,\n-    PartialEq,\n-    Eq,\n-    PartialOrd,\n-    Ord,\n-    Hash,\n-    HashStable,\n-    RustcEncodable,\n-    RustcDecodable\n-)]\n-pub enum StaticKind<'tcx> {\n-    /// Promoted references consist of an id (`Promoted`) and the substs necessary to monomorphize\n-    /// it. Usually, these substs are just the identity substs for the item. However, the inliner\n-    /// will adjust these substs when it inlines a function based on the substs at the callsite.\n-    Promoted(Promoted, SubstsRef<'tcx>),\n-    Static,\n-}\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n #[derive(RustcEncodable, RustcDecodable, HashStable)]\n pub enum ProjectionElem<V, T> {\n@@ -1791,14 +1750,14 @@ rustc_index::newtype_index! {\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct PlaceRef<'a, 'tcx> {\n-    pub base: &'a PlaceBase<'tcx>,\n+    pub local: &'a Local,\n     pub projection: &'a [PlaceElem<'tcx>],\n }\n \n impl<'tcx> Place<'tcx> {\n     // FIXME change this to a const fn by also making List::empty a const fn.\n     pub fn return_place() -> Place<'tcx> {\n-        Place { base: PlaceBase::Local(RETURN_PLACE), projection: List::empty() }\n+        Place { local: RETURN_PLACE, projection: List::empty() }\n     }\n \n     /// Returns `true` if this `Place` contains a `Deref` projection.\n@@ -1815,10 +1774,8 @@ impl<'tcx> Place<'tcx> {\n     // FIXME: can we safely swap the semantics of `fn base_local` below in here instead?\n     pub fn local_or_deref_local(&self) -> Option<Local> {\n         match self.as_ref() {\n-            PlaceRef { base: &PlaceBase::Local(local), projection: &[] }\n-            | PlaceRef { base: &PlaceBase::Local(local), projection: &[ProjectionElem::Deref] } => {\n-                Some(local)\n-            }\n+            PlaceRef { local, projection: &[] }\n+            | PlaceRef { local, projection: &[ProjectionElem::Deref] } => Some(*local),\n             _ => None,\n         }\n     }\n@@ -1830,19 +1787,13 @@ impl<'tcx> Place<'tcx> {\n     }\n \n     pub fn as_ref(&self) -> PlaceRef<'_, 'tcx> {\n-        PlaceRef { base: &self.base, projection: &self.projection }\n+        PlaceRef { local: &self.local, projection: &self.projection }\n     }\n }\n \n impl From<Local> for Place<'_> {\n     fn from(local: Local) -> Self {\n-        Place { base: local.into(), projection: List::empty() }\n-    }\n-}\n-\n-impl From<Local> for PlaceBase<'_> {\n-    fn from(local: Local) -> Self {\n-        PlaceBase::Local(local)\n+        Place { local, projection: List::empty() }\n     }\n }\n \n@@ -1853,10 +1804,8 @@ impl<'a, 'tcx> PlaceRef<'a, 'tcx> {\n     // FIXME: can we safely swap the semantics of `fn base_local` below in here instead?\n     pub fn local_or_deref_local(&self) -> Option<Local> {\n         match self {\n-            PlaceRef { base: PlaceBase::Local(local), projection: [] }\n-            | PlaceRef { base: PlaceBase::Local(local), projection: [ProjectionElem::Deref] } => {\n-                Some(*local)\n-            }\n+            PlaceRef { local, projection: [] }\n+            | PlaceRef { local, projection: [ProjectionElem::Deref] } => Some(**local),\n             _ => None,\n         }\n     }\n@@ -1865,7 +1814,7 @@ impl<'a, 'tcx> PlaceRef<'a, 'tcx> {\n     /// projections, return `Some(_X)`.\n     pub fn as_local(&self) -> Option<Local> {\n         match self {\n-            PlaceRef { base: PlaceBase::Local(l), projection: [] } => Some(*l),\n+            PlaceRef { local, projection: [] } => Some(**local),\n             _ => None,\n         }\n     }\n@@ -1887,7 +1836,7 @@ impl Debug for Place<'_> {\n             }\n         }\n \n-        write!(fmt, \"{:?}\", self.base)?;\n+        write!(fmt, \"{:?}\", self.local)?;\n \n         for elem in self.projection.iter() {\n             match elem {\n@@ -1931,22 +1880,6 @@ impl Debug for Place<'_> {\n     }\n }\n \n-impl Debug for PlaceBase<'_> {\n-    fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            PlaceBase::Local(id) => write!(fmt, \"{:?}\", id),\n-            PlaceBase::Static(box self::Static { ty, kind: StaticKind::Static, def_id }) => {\n-                write!(fmt, \"({}: {:?})\", ty::tls::with(|tcx| tcx.def_path_str(def_id)), ty)\n-            }\n-            PlaceBase::Static(box self::Static {\n-                ty,\n-                kind: StaticKind::Promoted(promoted, _),\n-                def_id: _,\n-            }) => write!(fmt, \"({:?}: {:?})\", promoted, ty),\n-        }\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Scopes\n \n@@ -3007,27 +2940,11 @@ impl<'tcx> TypeFoldable<'tcx> for GeneratorKind {\n \n impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        Place { base: self.base.fold_with(folder), projection: self.projection.fold_with(folder) }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.base.visit_with(visitor) || self.projection.visit_with(visitor)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for PlaceBase<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        match self {\n-            PlaceBase::Local(local) => PlaceBase::Local(local.fold_with(folder)),\n-            PlaceBase::Static(static_) => PlaceBase::Static(static_.fold_with(folder)),\n-        }\n+        Place { local: self.local.fold_with(folder), projection: self.projection.fold_with(folder) }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match self {\n-            PlaceBase::Local(local) => local.visit_with(visitor),\n-            PlaceBase::Static(static_) => (**static_).visit_with(visitor),\n-        }\n+        self.local.visit_with(visitor) || self.projection.visit_with(visitor)\n     }\n }\n \n@@ -3042,42 +2959,6 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<PlaceElem<'tcx>> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for Static<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        Static {\n-            ty: self.ty.fold_with(folder),\n-            kind: self.kind.fold_with(folder),\n-            def_id: self.def_id,\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        let Static { ty, kind, def_id: _ } = self;\n-\n-        ty.visit_with(visitor) || kind.visit_with(visitor)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for StaticKind<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        match self {\n-            StaticKind::Promoted(promoted, substs) => {\n-                StaticKind::Promoted(promoted.fold_with(folder), substs.fold_with(folder))\n-            }\n-            StaticKind::Static => StaticKind::Static,\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match self {\n-            StaticKind::Promoted(promoted, substs) => {\n-                promoted.visit_with(visitor) || substs.visit_with(visitor)\n-            }\n-            StaticKind::Static => false,\n-        }\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         use crate::mir::Rvalue::*;"}, {"sha": "e2aac562cc4ccf9ef81482b263e37f30ce8688e3", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -114,7 +114,7 @@ impl<'tcx> PlaceTy<'tcx> {\n \n impl<'tcx> Place<'tcx> {\n     pub fn ty_from<D>(\n-        base: &PlaceBase<'tcx>,\n+        local: &Local,\n         projection: &[PlaceElem<'tcx>],\n         local_decls: &D,\n         tcx: TyCtxt<'tcx>,\n@@ -124,26 +124,16 @@ impl<'tcx> Place<'tcx> {\n     {\n         projection\n             .iter()\n-            .fold(base.ty(local_decls), |place_ty, elem| place_ty.projection_ty(tcx, elem))\n+            .fold(PlaceTy::from_ty(local_decls.local_decls()[*local].ty), |place_ty, elem| {\n+                place_ty.projection_ty(tcx, elem)\n+            })\n     }\n \n     pub fn ty<D>(&self, local_decls: &D, tcx: TyCtxt<'tcx>) -> PlaceTy<'tcx>\n     where\n         D: HasLocalDecls<'tcx>,\n     {\n-        Place::ty_from(&self.base, &self.projection, local_decls, tcx)\n-    }\n-}\n-\n-impl<'tcx> PlaceBase<'tcx> {\n-    pub fn ty<D>(&self, local_decls: &D) -> PlaceTy<'tcx>\n-    where\n-        D: HasLocalDecls<'tcx>,\n-    {\n-        match self {\n-            PlaceBase::Local(index) => PlaceTy::from_ty(local_decls.local_decls()[*index].ty),\n-            PlaceBase::Static(data) => PlaceTy::from_ty(data.ty),\n-        }\n+        Place::ty_from(&self.local, &self.projection, local_decls, tcx)\n     }\n }\n "}, {"sha": "4c5db1b07d225d783e49c97b765698bb5bf96f1f", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -164,10 +164,10 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn visit_place_base(&mut self,\n-                                base: & $($mutability)? PlaceBase<'tcx>,\n+                                local: & $($mutability)? Local,\n                                 context: PlaceContext,\n                                 location: Location) {\n-                self.super_place_base(base, context, location);\n+                self.super_place_base(local, context, location);\n             }\n \n             visit_place_fns!($($mutability)?);\n@@ -705,17 +705,10 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_place_base(&mut self,\n-                                place_base: & $($mutability)? PlaceBase<'tcx>,\n+                                local: & $($mutability)? Local,\n                                 context: PlaceContext,\n                                 location: Location) {\n-                match place_base {\n-                    PlaceBase::Local(local) => {\n-                        self.visit_local(local, context, location);\n-                    }\n-                    PlaceBase::Static(box Static { kind: _, ty, def_id: _ }) => {\n-                        self.visit_ty(& $($mutability)? *ty, TyContext::Location(location));\n-                    }\n-                }\n+                self.visit_local(local, context, location);\n             }\n \n             fn super_local_decl(&mut self,\n@@ -848,7 +841,7 @@ macro_rules! visit_place_fns {\n             context: PlaceContext,\n             location: Location,\n         ) {\n-            self.visit_place_base(&mut place.base, context, location);\n+            self.visit_place_base(&mut place.local, context, location);\n \n             if let Some(new_projection) = self.process_projection(&place.projection) {\n                 place.projection = self.tcx().intern_place_elems(&new_projection);\n@@ -889,23 +882,23 @@ macro_rules! visit_place_fns {\n     () => (\n         fn visit_projection(\n             &mut self,\n-            base: &PlaceBase<'tcx>,\n+            local: &Local,\n             projection: &[PlaceElem<'tcx>],\n             context: PlaceContext,\n             location: Location,\n         ) {\n-            self.super_projection(base, projection, context, location);\n+            self.super_projection(local, projection, context, location);\n         }\n \n         fn visit_projection_elem(\n             &mut self,\n-            base: &PlaceBase<'tcx>,\n+            local: &Local,\n             proj_base: &[PlaceElem<'tcx>],\n             elem: &PlaceElem<'tcx>,\n             context: PlaceContext,\n             location: Location,\n         ) {\n-            self.super_projection_elem(base, proj_base, elem, context, location);\n+            self.super_projection_elem(local, proj_base, elem, context, location);\n         }\n \n         fn super_place(\n@@ -924,31 +917,31 @@ macro_rules! visit_place_fns {\n                 };\n             }\n \n-            self.visit_place_base(&place.base, context, location);\n+            self.visit_place_base(&place.local, context, location);\n \n-            self.visit_projection(&place.base,\n+            self.visit_projection(&place.local,\n                                   &place.projection,\n                                   context,\n                                   location);\n         }\n \n         fn super_projection(\n             &mut self,\n-            base: &PlaceBase<'tcx>,\n+            local: &Local,\n             projection: &[PlaceElem<'tcx>],\n             context: PlaceContext,\n             location: Location,\n         ) {\n             let mut cursor = projection;\n             while let [proj_base @ .., elem] = cursor {\n                 cursor = proj_base;\n-                self.visit_projection_elem(base, cursor, elem, context, location);\n+                self.visit_projection_elem(local, cursor, elem, context, location);\n             }\n         }\n \n         fn super_projection_elem(\n             &mut self,\n-            _base: &PlaceBase<'tcx>,\n+            _local: &Local,\n             _proj_base: &[PlaceElem<'tcx>],\n             elem: &PlaceElem<'tcx>,\n             _context: PlaceContext,"}, {"sha": "46ece6fc4059364039f0d72d885d6411476a39b3", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -515,6 +515,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                             obligation.param_env,\n                             def_id,\n                             substs,\n+                            None,\n                             Some(obligation.cause.span),\n                         ) {\n                             Ok(_) => ProcessResult::Changed(vec![]),"}, {"sha": "e96697cc7e09d4360581ea9fb4f24b2b5b9a719e", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -802,8 +802,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ty::Predicate::ConstEvaluatable(def_id, substs) => {\n                 if !(obligation.param_env, substs).has_local_value() {\n-                    match self.tcx().const_eval_resolve(obligation.param_env, def_id, substs, None)\n-                    {\n+                    match self.tcx().const_eval_resolve(\n+                        obligation.param_env,\n+                        def_id,\n+                        substs,\n+                        None,\n+                        None,\n+                    ) {\n                         Ok(_) => Ok(EvaluatedToOk),\n                         Err(_) => Ok(EvaluatedToErr),\n                     }"}, {"sha": "2301395f557f13d0d9b1ce2c123175c8039940db", "filename": "src/librustc/traits/wf.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fwf.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -359,7 +359,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n     /// Pushes the obligations required for an array length to be WF\n     /// into `self.out`.\n     fn compute_array_len(&mut self, constant: ty::Const<'tcx>) {\n-        if let ty::ConstKind::Unevaluated(def_id, substs) = constant.val {\n+        if let ty::ConstKind::Unevaluated(def_id, substs, promoted) = constant.val {\n+            assert!(promoted.is_none());\n+\n             let obligations = self.nominal_obligations(def_id, substs);\n             self.out.extend(obligations);\n "}, {"sha": "df1602b2ac46d83dd9265983a1eca524d252e490", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -226,11 +226,11 @@ pub fn decode_place<D>(decoder: &mut D) -> Result<mir::Place<'tcx>, D::Error>\n where\n     D: TyDecoder<'tcx>,\n {\n-    let base: mir::PlaceBase<'tcx> = Decodable::decode(decoder)?;\n+    let local: mir::Local = Decodable::decode(decoder)?;\n     let len = decoder.read_usize()?;\n     let projection: &'tcx List<mir::PlaceElem<'tcx>> =\n         decoder.tcx().mk_place_elems((0..len).map(|_| Decodable::decode(decoder)))?;\n-    Ok(mir::Place { base, projection })\n+    Ok(mir::Place { local, projection })\n }\n \n #[inline]"}, {"sha": "af079736db544d8698e68bb87b886539caf00fbc", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -2434,7 +2434,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let mut projection = place.projection.to_vec();\n         projection.push(elem);\n \n-        Place { base: place.base, projection: self.intern_place_elems(&projection) }\n+        Place { local: place.local, projection: self.intern_place_elems(&projection) }\n     }\n \n     pub fn intern_existential_predicates("}, {"sha": "4a4280ba7dc4dd3fabe48f0479d55bf27cc3fb36", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -219,7 +219,7 @@ impl FlagComputation {\n     fn add_const(&mut self, c: &ty::Const<'_>) {\n         self.add_ty(c.ty);\n         match c.val {\n-            ty::ConstKind::Unevaluated(_, substs) => {\n+            ty::ConstKind::Unevaluated(_, substs, _) => {\n                 self.add_substs(substs);\n                 self.add_flags(TypeFlags::HAS_PROJECTION);\n             }"}, {"sha": "8b1b2bb586597662a39a5c5cd05e278469d2e3ed", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -841,23 +841,31 @@ pub trait PrettyPrinter<'tcx>:\n \n         match (ct.val, &ct.ty.kind) {\n             (_, ty::FnDef(did, substs)) => p!(print_value_path(*did, substs)),\n-            (ty::ConstKind::Unevaluated(did, substs), _) => match self.tcx().def_kind(did) {\n-                Some(DefKind::Static) | Some(DefKind::Const) | Some(DefKind::AssocConst) => {\n-                    p!(print_value_path(did, substs))\n-                }\n-                _ => {\n-                    if did.is_local() {\n-                        let span = self.tcx().def_span(did);\n-                        if let Ok(snip) = self.tcx().sess.source_map().span_to_snippet(span) {\n-                            p!(write(\"{}\", snip))\n-                        } else {\n-                            p!(write(\"_: \"), print(ct.ty))\n+            (ty::ConstKind::Unevaluated(did, substs, promoted), _) => {\n+                if let Some(promoted) = promoted {\n+                    p!(print_value_path(did, substs));\n+                    p!(write(\"::{:?}\", promoted));\n+                } else {\n+                    match self.tcx().def_kind(did) {\n+                        Some(DefKind::Static)\n+                        | Some(DefKind::Const)\n+                        | Some(DefKind::AssocConst) => p!(print_value_path(did, substs)),\n+                        _ => {\n+                            if did.is_local() {\n+                                let span = self.tcx().def_span(did);\n+                                if let Ok(snip) = self.tcx().sess.source_map().span_to_snippet(span)\n+                                {\n+                                    p!(write(\"{}\", snip))\n+                                } else {\n+                                    p!(write(\"_: \"), print(ct.ty))\n+                                }\n+                            } else {\n+                                p!(write(\"_: \"), print(ct.ty))\n+                            }\n                         }\n-                    } else {\n-                        p!(write(\"_: \"), print(ct.ty))\n                     }\n                 }\n-            },\n+            }\n             (ty::ConstKind::Infer(..), _) => p!(write(\"_: \"), print(ct.ty)),\n             (ty::ConstKind::Param(ParamConst { name, .. }), _) => p!(write(\"{}\", name)),\n             (ty::ConstKind::Value(value), _) => return self.pretty_print_const_value(value, ct.ty),"}, {"sha": "3b9df72266f09a688f0ff5c2061f529c1a8accfc", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -568,12 +568,12 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n \n         // FIXME(const_generics): this is wrong, as it is a projection\n         (\n-            ty::ConstKind::Unevaluated(a_def_id, a_substs),\n-            ty::ConstKind::Unevaluated(b_def_id, b_substs),\n-        ) if a_def_id == b_def_id => {\n+            ty::ConstKind::Unevaluated(a_def_id, a_substs, a_promoted),\n+            ty::ConstKind::Unevaluated(b_def_id, b_substs, b_promoted),\n+        ) if a_def_id == b_def_id && a_promoted == b_promoted => {\n             let substs =\n                 relation.relate_with_variance(ty::Variance::Invariant, &a_substs, &b_substs)?;\n-            Ok(ty::ConstKind::Unevaluated(a_def_id, &substs))\n+            Ok(ty::ConstKind::Unevaluated(a_def_id, &substs, a_promoted))\n         }\n         _ => Err(TypeError::ConstMismatch(expected_found(relation, &a, &b))),\n     };"}, {"sha": "62e895af7f355262852cc5f50f2ccd9dc623231b", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -1037,8 +1037,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ConstKind<'tcx> {\n         match *self {\n             ty::ConstKind::Infer(ic) => ty::ConstKind::Infer(ic.fold_with(folder)),\n             ty::ConstKind::Param(p) => ty::ConstKind::Param(p.fold_with(folder)),\n-            ty::ConstKind::Unevaluated(did, substs) => {\n-                ty::ConstKind::Unevaluated(did, substs.fold_with(folder))\n+            ty::ConstKind::Unevaluated(did, substs, promoted) => {\n+                ty::ConstKind::Unevaluated(did, substs.fold_with(folder), promoted)\n             }\n             ty::ConstKind::Value(_) | ty::ConstKind::Bound(..) | ty::ConstKind::Placeholder(..) => {\n                 *self\n@@ -1050,7 +1050,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ConstKind<'tcx> {\n         match *self {\n             ty::ConstKind::Infer(ic) => ic.visit_with(visitor),\n             ty::ConstKind::Param(p) => p.visit_with(visitor),\n-            ty::ConstKind::Unevaluated(_, substs) => substs.visit_with(visitor),\n+            ty::ConstKind::Unevaluated(_, substs, _) => substs.visit_with(visitor),\n             ty::ConstKind::Value(_) | ty::ConstKind::Bound(..) | ty::ConstKind::Placeholder(_) => {\n                 false\n             }"}, {"sha": "842361284823dffd707ae39f5478b9e71c3cc463", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -9,6 +9,7 @@ use crate::infer::canonical::Canonical;\n use crate::middle::region;\n use crate::mir::interpret::ConstValue;\n use crate::mir::interpret::Scalar;\n+use crate::mir::Promoted;\n use crate::ty::layout::VariantIdx;\n use crate::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst, SubstsRef};\n use crate::ty::{self, AdtDef, DefIdTree, Discr, Ty, TyCtxt, TypeFlags, TypeFoldable};\n@@ -2375,7 +2376,7 @@ impl<'tcx> Const<'tcx> {\n \n     #[inline]\n     pub fn eval(&self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> &Const<'tcx> {\n-        let try_const_eval = |did, param_env: ParamEnv<'tcx>, substs| {\n+        let try_const_eval = |did, param_env: ParamEnv<'tcx>, substs, promoted| {\n             let param_env_and_substs = param_env.with_reveal_all().and(substs);\n \n             // Avoid querying `tcx.const_eval(...)` with any e.g. inference vars.\n@@ -2387,11 +2388,11 @@ impl<'tcx> Const<'tcx> {\n \n             // try to resolve e.g. associated constants to their definition on an impl, and then\n             // evaluate the const.\n-            tcx.const_eval_resolve(param_env, did, substs, None).ok()\n+            tcx.const_eval_resolve(param_env, did, substs, promoted, None).ok()\n         };\n \n         match self.val {\n-            ConstKind::Unevaluated(did, substs) => {\n+            ConstKind::Unevaluated(did, substs, promoted) => {\n                 // HACK(eddyb) when substs contain e.g. inference variables,\n                 // attempt using identity substs instead, that will succeed\n                 // when the expression doesn't depend on any parameters.\n@@ -2401,12 +2402,12 @@ impl<'tcx> Const<'tcx> {\n                     let identity_substs = InternalSubsts::identity_for_item(tcx, did);\n                     // The `ParamEnv` needs to match the `identity_substs`.\n                     let identity_param_env = tcx.param_env(did);\n-                    match try_const_eval(did, identity_param_env, identity_substs) {\n+                    match try_const_eval(did, identity_param_env, identity_substs, promoted) {\n                         Some(ct) => ct.subst(tcx, substs),\n                         None => self,\n                     }\n                 } else {\n-                    try_const_eval(did, param_env, substs).unwrap_or(self)\n+                    try_const_eval(did, param_env, substs, promoted).unwrap_or(self)\n                 }\n             }\n             _ => self,\n@@ -2470,7 +2471,7 @@ pub enum ConstKind<'tcx> {\n \n     /// Used in the HIR by using `Unevaluated` everywhere and later normalizing to one of the other\n     /// variants when the code is monomorphic enough for that.\n-    Unevaluated(DefId, SubstsRef<'tcx>),\n+    Unevaluated(DefId, SubstsRef<'tcx>, Option<Promoted>),\n \n     /// Used to hold computed value.\n     Value(ConstValue<'tcx>),"}, {"sha": "da08fbcf14432f384a097ccec4c13f569b1b85cb", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -81,7 +81,8 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n         | ty::Bound(..)\n         | ty::Foreign(..) => {}\n         ty::Array(ty, len) => {\n-            if let ty::ConstKind::Unevaluated(_, substs) = len.val {\n+            if let ty::ConstKind::Unevaluated(_, substs, promoted) = len.val {\n+                assert!(promoted.is_none());\n                 stack.extend(substs.types().rev());\n             }\n             stack.push(len.ty);"}, {"sha": "d1f70ad43bd2888622e7b9ff283f35d7a56917dd", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -1286,9 +1286,9 @@ fn generator_layout_and_saved_local_names(\n     let generator_layout = body.generator_layout.as_ref().unwrap();\n     let mut generator_saved_local_names = IndexVec::from_elem(None, &generator_layout.field_tys);\n \n-    let state_arg = mir::PlaceBase::Local(mir::Local::new(1));\n+    let state_arg = mir::Local::new(1);\n     for var in &body.var_debug_info {\n-        if var.place.base != state_arg {\n+        if var.place.local != state_arg {\n             continue;\n         }\n         match var.place.projection[..] {"}, {"sha": "c3affd233f8e3b00fc1b7693543505c0a7120aff", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -14,7 +14,6 @@ use rustc::ty::layout::{HasTyCtxt, LayoutOf};\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_span::DUMMY_SP;\n \n pub fn non_ssa_locals<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     fx: &FunctionCx<'a, 'tcx, Bx>,\n@@ -129,17 +128,13 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n             };\n             if is_consume {\n                 let base_ty =\n-                    mir::Place::ty_from(place_ref.base, proj_base, *self.fx.mir, cx.tcx());\n+                    mir::Place::ty_from(place_ref.local, proj_base, *self.fx.mir, cx.tcx());\n                 let base_ty = self.fx.monomorphize(&base_ty);\n \n                 // ZSTs don't require any actual memory access.\n                 let elem_ty = base_ty.projection_ty(cx.tcx(), elem).ty;\n                 let elem_ty = self.fx.monomorphize(&elem_ty);\n-                let span = if let mir::PlaceBase::Local(index) = place_ref.base {\n-                    self.fx.mir.local_decls[*index].source_info.span\n-                } else {\n-                    DUMMY_SP\n-                };\n+                let span = self.fx.mir.local_decls[*place_ref.local].source_info.span;\n                 if cx.spanned_layout_of(elem_ty, span).is_zst() {\n                     return;\n                 }\n@@ -179,9 +174,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n                     // We use `NonUseContext::VarDebugInfo` for the base,\n                     // which might not force the base local to memory,\n                     // so we have to do it manually.\n-                    if let mir::PlaceBase::Local(local) = place_ref.base {\n-                        self.visit_local(&local, context, location);\n-                    }\n+                    self.visit_local(place_ref.local, context, location);\n                 }\n             }\n \n@@ -192,7 +185,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n             }\n \n             self.process_place(\n-                &mir::PlaceRef { base: place_ref.base, projection: proj_base },\n+                &mir::PlaceRef { local: place_ref.local, projection: proj_base },\n                 base_context,\n                 location,\n             );\n@@ -219,8 +212,8 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n                 };\n             }\n \n-            self.visit_place_base(place_ref.base, context, location);\n-            self.visit_projection(place_ref.base, place_ref.projection, context, location);\n+            self.visit_place_base(place_ref.local, context, location);\n+            self.visit_projection(place_ref.local, place_ref.projection, context, location);\n         }\n     }\n }"}, {"sha": "9169010da88019412ee851aba349f765aad454db", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 13, "deletions": 49, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -10,8 +10,8 @@ use crate::traits::*;\n use crate::MemFlags;\n \n use rustc::middle::lang_items;\n+use rustc::mir;\n use rustc::mir::interpret::PanicInfo;\n-use rustc::mir::{self, PlaceBase, Static, StaticKind};\n use rustc::ty::layout::{self, FnAbiExt, HasTyCtxt, LayoutOf};\n use rustc::ty::{self, Instance, Ty, TypeFoldable};\n use rustc_index::vec::Idx;\n@@ -609,53 +609,17 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     // checked by const-qualification, which also\n                     // promotes any complex rvalues to constants.\n                     if i == 2 && intrinsic.unwrap().starts_with(\"simd_shuffle\") {\n-                        match arg {\n-                            // The shuffle array argument is usually not an explicit constant,\n-                            // but specified directly in the code. This means it gets promoted\n-                            // and we can then extract the value by evaluating the promoted.\n-                            mir::Operand::Copy(place) | mir::Operand::Move(place) => {\n-                                if let mir::PlaceRef {\n-                                    base:\n-                                        &PlaceBase::Static(box Static {\n-                                            kind: StaticKind::Promoted(promoted, substs),\n-                                            ty,\n-                                            def_id,\n-                                        }),\n-                                    projection: &[],\n-                                } = place.as_ref()\n-                                {\n-                                    let c = bx.tcx().const_eval_promoted(\n-                                        Instance::new(def_id, self.monomorphize(&substs)),\n-                                        promoted,\n-                                    );\n-                                    let (llval, ty) = self.simd_shuffle_indices(\n-                                        &bx,\n-                                        terminator.source_info.span,\n-                                        ty,\n-                                        c,\n-                                    );\n-                                    return OperandRef {\n-                                        val: Immediate(llval),\n-                                        layout: bx.layout_of(ty),\n-                                    };\n-                                } else {\n-                                    span_bug!(span, \"shuffle indices must be constant\");\n-                                }\n-                            }\n-\n-                            mir::Operand::Constant(constant) => {\n-                                let c = self.eval_mir_constant(constant);\n-                                let (llval, ty) = self.simd_shuffle_indices(\n-                                    &bx,\n-                                    constant.span,\n-                                    constant.literal.ty,\n-                                    c,\n-                                );\n-                                return OperandRef {\n-                                    val: Immediate(llval),\n-                                    layout: bx.layout_of(ty),\n-                                };\n-                            }\n+                        if let mir::Operand::Constant(constant) = arg {\n+                            let c = self.eval_mir_constant(constant);\n+                            let (llval, ty) = self.simd_shuffle_indices(\n+                                &bx,\n+                                constant.span,\n+                                constant.literal.ty,\n+                                c,\n+                            );\n+                            return OperandRef { val: Immediate(llval), layout: bx.layout_of(ty) };\n+                        } else {\n+                            span_bug!(span, \"shuffle indices must be constant\");\n                         }\n                     }\n \n@@ -1147,7 +1111,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         } else {\n             self.codegen_place(\n                 bx,\n-                &mir::PlaceRef { base: &dest.base, projection: &dest.projection },\n+                &mir::PlaceRef { local: &dest.local, projection: &dest.projection },\n             )\n         };\n         if fn_ret.is_indirect() {"}, {"sha": "3ce916d78127922251c64a89d0476440e81c8441", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -20,7 +20,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             // use `get_static` to get at their id.\n             // FIXME(oli-obk): can we unify this somehow, maybe by making const eval of statics\n             // always produce `&STATIC`. This may also simplify how const eval works with statics.\n-            ty::ConstKind::Unevaluated(def_id, substs) if self.cx.tcx().is_static(def_id) => {\n+            ty::ConstKind::Unevaluated(def_id, substs, None) if self.cx.tcx().is_static(def_id) => {\n                 assert!(substs.is_empty(), \"we don't support generic statics yet\");\n                 let static_ = bx.get_static(def_id);\n                 // we treat operands referring to statics as if they were `&STATIC` instead\n@@ -40,16 +40,18 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         constant: &mir::Constant<'tcx>,\n     ) -> Result<&'tcx ty::Const<'tcx>, ErrorHandled> {\n         match constant.literal.val {\n-            ty::ConstKind::Unevaluated(def_id, substs) => {\n+            ty::ConstKind::Unevaluated(def_id, substs, promoted) => {\n                 let substs = self.monomorphize(&substs);\n                 self.cx\n                     .tcx()\n-                    .const_eval_resolve(ty::ParamEnv::reveal_all(), def_id, substs, None)\n+                    .const_eval_resolve(ty::ParamEnv::reveal_all(), def_id, substs, promoted, None)\n                     .map_err(|err| {\n-                        self.cx\n-                            .tcx()\n-                            .sess\n-                            .span_err(constant.span, \"erroneous constant encountered\");\n+                        if promoted.is_none() {\n+                            self.cx\n+                                .tcx()\n+                                .sess\n+                                .span_err(constant.span, \"erroneous constant encountered\");\n+                        }\n                         err\n                     })\n             }"}, {"sha": "e0aec5d6dd512038aca6502b570d1c1d0241522e", "filename": "src/librustc_codegen_ssa/mir/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -258,9 +258,7 @@ pub fn per_local_var_debug_info(\n     if tcx.sess.opts.debuginfo == DebugInfo::Full || !tcx.sess.fewer_names() {\n         let mut per_local = IndexVec::from_elem(vec![], &body.local_decls);\n         for var in &body.var_debug_info {\n-            if let mir::PlaceBase::Local(local) = var.place.base {\n-                per_local[local].push(var);\n-            }\n+            per_local[var.place.local].push(var);\n         }\n         Some(per_local)\n     } else {"}, {"sha": "a155a6e78f7c3e3e6dd708501256b3460011b495", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 29, "deletions": 33, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -373,44 +373,40 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     ) -> Option<OperandRef<'tcx, Bx::Value>> {\n         debug!(\"maybe_codegen_consume_direct(place_ref={:?})\", place_ref);\n \n-        if let mir::PlaceBase::Local(index) = place_ref.base {\n-            match self.locals[*index] {\n-                LocalRef::Operand(Some(mut o)) => {\n-                    // Moves out of scalar and scalar pair fields are trivial.\n-                    for elem in place_ref.projection.iter() {\n-                        match elem {\n-                            mir::ProjectionElem::Field(ref f, _) => {\n-                                o = o.extract_field(bx, f.index());\n-                            }\n-                            mir::ProjectionElem::Index(_)\n-                            | mir::ProjectionElem::ConstantIndex { .. } => {\n-                                // ZSTs don't require any actual memory access.\n-                                // FIXME(eddyb) deduplicate this with the identical\n-                                // checks in `codegen_consume` and `extract_field`.\n-                                let elem = o.layout.field(bx.cx(), 0);\n-                                if elem.is_zst() {\n-                                    o = OperandRef::new_zst(bx, elem);\n-                                } else {\n-                                    return None;\n-                                }\n+        match self.locals[*place_ref.local] {\n+            LocalRef::Operand(Some(mut o)) => {\n+                // Moves out of scalar and scalar pair fields are trivial.\n+                for elem in place_ref.projection.iter() {\n+                    match elem {\n+                        mir::ProjectionElem::Field(ref f, _) => {\n+                            o = o.extract_field(bx, f.index());\n+                        }\n+                        mir::ProjectionElem::Index(_)\n+                        | mir::ProjectionElem::ConstantIndex { .. } => {\n+                            // ZSTs don't require any actual memory access.\n+                            // FIXME(eddyb) deduplicate this with the identical\n+                            // checks in `codegen_consume` and `extract_field`.\n+                            let elem = o.layout.field(bx.cx(), 0);\n+                            if elem.is_zst() {\n+                                o = OperandRef::new_zst(bx, elem);\n+                            } else {\n+                                return None;\n                             }\n-                            _ => return None,\n                         }\n+                        _ => return None,\n                     }\n-\n-                    Some(o)\n-                }\n-                LocalRef::Operand(None) => {\n-                    bug!(\"use of {:?} before def\", place_ref);\n-                }\n-                LocalRef::Place(..) | LocalRef::UnsizedPlace(..) => {\n-                    // watch out for locals that do not have an\n-                    // alloca; they are handled somewhat differently\n-                    None\n                 }\n+\n+                Some(o)\n+            }\n+            LocalRef::Operand(None) => {\n+                bug!(\"use of {:?} before def\", place_ref);\n+            }\n+            LocalRef::Place(..) | LocalRef::UnsizedPlace(..) => {\n+                // watch out for locals that do not have an\n+                // alloca; they are handled somewhat differently\n+                None\n             }\n-        } else {\n-            None\n         }\n     }\n "}, {"sha": "5e03a35b8a6fd662cde4077f3e4f54b91e79b7af", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 15, "deletions": 74, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -9,7 +9,7 @@ use crate::MemFlags;\n use rustc::mir;\n use rustc::mir::tcx::PlaceTy;\n use rustc::ty::layout::{self, Align, HasTyCtxt, LayoutOf, TyLayout, VariantIdx};\n-use rustc::ty::{self, Instance, Ty};\n+use rustc::ty::{self, Ty};\n \n #[derive(Copy, Clone, Debug)]\n pub struct PlaceRef<'tcx, V> {\n@@ -37,15 +37,6 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         PlaceRef { llval, llextra: None, layout, align }\n     }\n \n-    fn new_thin_place<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n-        bx: &mut Bx,\n-        llval: V,\n-        layout: TyLayout<'tcx>,\n-    ) -> PlaceRef<'tcx, V> {\n-        assert!(!bx.cx().type_has_metadata(layout.ty));\n-        PlaceRef { llval, llextra: None, layout, align: layout.align.abi }\n-    }\n-\n     // FIXME(eddyb) pass something else for the name so no work is done\n     // unless LLVM IR names are turned on (e.g. for `--emit=llvm-ir`).\n     pub fn alloca<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n@@ -424,76 +415,26 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let tcx = self.cx.tcx();\n \n         let result = match place_ref {\n-            mir::PlaceRef { base: mir::PlaceBase::Local(index), projection: [] } => {\n-                match self.locals[*index] {\n-                    LocalRef::Place(place) => {\n-                        return place;\n-                    }\n-                    LocalRef::UnsizedPlace(place) => {\n-                        return bx.load_operand(place).deref(cx);\n-                    }\n-                    LocalRef::Operand(..) => {\n-                        bug!(\"using operand local {:?} as place\", place_ref);\n-                    }\n+            mir::PlaceRef { local, projection: [] } => match self.locals[**local] {\n+                LocalRef::Place(place) => {\n+                    return place;\n                 }\n-            }\n-            mir::PlaceRef {\n-                base:\n-                    mir::PlaceBase::Static(box mir::Static {\n-                        ty,\n-                        kind: mir::StaticKind::Promoted(promoted, substs),\n-                        def_id,\n-                    }),\n-                projection: [],\n-            } => {\n-                let instance = Instance::new(*def_id, self.monomorphize(substs));\n-                let layout = cx.layout_of(self.monomorphize(&ty));\n-                match bx.tcx().const_eval_promoted(instance, *promoted) {\n-                    Ok(val) => match val.val {\n-                        ty::ConstKind::Value(mir::interpret::ConstValue::ByRef {\n-                            alloc,\n-                            offset,\n-                        }) => bx.cx().from_const_alloc(layout, alloc, offset),\n-                        _ => bug!(\"promoteds should have an allocation: {:?}\", val),\n-                    },\n-                    Err(_) => {\n-                        // This is unreachable as long as runtime\n-                        // and compile-time agree perfectly.\n-                        // With floats that won't always be true,\n-                        // so we generate a (safe) abort.\n-                        bx.abort();\n-                        // We still have to return a place but it doesn't matter,\n-                        // this code is unreachable.\n-                        let llval =\n-                            bx.cx().const_undef(bx.cx().type_ptr_to(bx.cx().backend_type(layout)));\n-                        PlaceRef::new_sized(llval, layout)\n-                    }\n+                LocalRef::UnsizedPlace(place) => {\n+                    return bx.load_operand(place).deref(cx);\n                 }\n-            }\n-            mir::PlaceRef {\n-                base:\n-                    mir::PlaceBase::Static(box mir::Static {\n-                        ty,\n-                        kind: mir::StaticKind::Static,\n-                        def_id,\n-                    }),\n-                projection: [],\n-            } => {\n-                // NB: The layout of a static may be unsized as is the case when working\n-                // with a static that is an extern_type.\n-                let layout = cx.layout_of(self.monomorphize(&ty));\n-                let static_ = bx.get_static(*def_id);\n-                PlaceRef::new_thin_place(bx, static_, layout)\n-            }\n-            mir::PlaceRef { base, projection: [proj_base @ .., mir::ProjectionElem::Deref] } => {\n+                LocalRef::Operand(..) => {\n+                    bug!(\"using operand local {:?} as place\", place_ref);\n+                }\n+            },\n+            mir::PlaceRef { local, projection: [proj_base @ .., mir::ProjectionElem::Deref] } => {\n                 // Load the pointer from its location.\n-                self.codegen_consume(bx, &mir::PlaceRef { base, projection: proj_base })\n+                self.codegen_consume(bx, &mir::PlaceRef { local, projection: proj_base })\n                     .deref(bx.cx())\n             }\n-            mir::PlaceRef { base, projection: [proj_base @ .., elem] } => {\n+            mir::PlaceRef { local, projection: [proj_base @ .., elem] } => {\n                 // FIXME turn this recursion into iteration\n                 let cg_base =\n-                    self.codegen_place(bx, &mir::PlaceRef { base, projection: proj_base });\n+                    self.codegen_place(bx, &mir::PlaceRef { local, projection: proj_base });\n \n                 match elem {\n                     mir::ProjectionElem::Deref => bug!(),\n@@ -558,7 +499,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n     pub fn monomorphized_place_ty(&self, place_ref: &mir::PlaceRef<'_, 'tcx>) -> Ty<'tcx> {\n         let tcx = self.cx.tcx();\n-        let place_ty = mir::Place::ty_from(place_ref.base, place_ref.projection, *self.mir, tcx);\n+        let place_ty = mir::Place::ty_from(place_ref.local, place_ref.projection, *self.mir, tcx);\n         self.monomorphize(&place_ty.ty)\n     }\n }"}, {"sha": "f2a44986cc4d4edccd167c26899abfb557130883", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -208,9 +208,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n \n             self.insert_as_pending_if_two_phase(location, &assigned_place, kind, idx);\n \n-            if let mir::PlaceBase::Local(local) = borrowed_place.base {\n-                self.local_map.entry(local).or_default().insert(idx);\n-            }\n+            self.local_map.entry(borrowed_place.local).or_default().insert(idx);\n         }\n \n         self.super_assign(assigned_place, rvalue, location)"}, {"sha": "0f6a360c7933b3f5d525272717d9ec5d54492bbb", "filename": "src/librustc_mir/borrow_check/constraint_generation.rs", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -2,8 +2,8 @@ use rustc::infer::InferCtxt;\n use rustc::mir::visit::TyContext;\n use rustc::mir::visit::Visitor;\n use rustc::mir::{\n-    BasicBlock, BasicBlockData, Body, Local, Location, Place, PlaceBase, PlaceRef, ProjectionElem,\n-    Rvalue, SourceInfo, Statement, StatementKind, Terminator, TerminatorKind, UserTypeProjection,\n+    BasicBlock, BasicBlockData, Body, Local, Location, Place, PlaceRef, ProjectionElem, Rvalue,\n+    SourceInfo, Statement, StatementKind, Terminator, TerminatorKind, UserTypeProjection,\n };\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::SubstsRef;\n@@ -16,7 +16,6 @@ use crate::borrow_check::{\n \n pub(super) fn generate_constraints<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n     liveness_constraints: &mut LivenessValues<RegionVid>,\n     all_facts: &mut Option<AllFacts>,\n     location_table: &LocationTable,\n@@ -30,7 +29,6 @@ pub(super) fn generate_constraints<'cx, 'tcx>(\n         location_table,\n         all_facts,\n         body,\n-        param_env,\n     };\n \n     for (bb, data) in body.basic_blocks().iter_enumerated() {\n@@ -41,7 +39,6 @@ pub(super) fn generate_constraints<'cx, 'tcx>(\n /// 'cg = the duration of the constraint generation process itself.\n struct ConstraintGeneration<'cg, 'cx, 'tcx> {\n     infcx: &'cg InferCtxt<'cx, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n     all_facts: &'cg mut Option<AllFacts>,\n     location_table: &'cg LocationTable,\n     liveness_constraints: &'cg mut LivenessValues<RegionVid>,\n@@ -191,11 +188,8 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n             //   of the borrows are killed: the ones whose `borrowed_place`\n             //   conflicts with the `place`.\n             match place.as_ref() {\n-                PlaceRef { base: &PlaceBase::Local(local), projection: &[] }\n-                | PlaceRef {\n-                    base: &PlaceBase::Local(local),\n-                    projection: &[ProjectionElem::Deref],\n-                } => {\n+                PlaceRef { local, projection: &[] }\n+                | PlaceRef { local, projection: &[ProjectionElem::Deref] } => {\n                     debug!(\n                         \"Recording `killed` facts for borrows of local={:?} at location={:?}\",\n                         local, location\n@@ -205,28 +199,23 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n                         all_facts,\n                         self.borrow_set,\n                         self.location_table,\n-                        &local,\n+                        local,\n                         location,\n                     );\n                 }\n \n-                PlaceRef { base: &PlaceBase::Static(_), .. } => {\n-                    // Ignore kills of static or static mut variables.\n-                }\n-\n-                PlaceRef { base: &PlaceBase::Local(local), projection: &[.., _] } => {\n+                PlaceRef { local, projection: &[.., _] } => {\n                     // Kill conflicting borrows of the innermost local.\n                     debug!(\n                         \"Recording `killed` facts for borrows of \\\n                             innermost projected local={:?} at location={:?}\",\n                         local, location\n                     );\n \n-                    if let Some(borrow_indices) = self.borrow_set.local_map.get(&local) {\n+                    if let Some(borrow_indices) = self.borrow_set.local_map.get(local) {\n                         for &borrow_index in borrow_indices {\n                             let places_conflict = places_conflict::places_conflict(\n                                 self.infcx.tcx,\n-                                self.param_env,\n                                 self.body,\n                                 &self.borrow_set.borrows[borrow_index].borrowed_place,\n                                 place,"}, {"sha": "08333ae423da727a3bbce26beec5abf39ed705ea", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 26, "deletions": 33, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -1,7 +1,7 @@\n use rustc::mir::{\n     self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, ConstraintCategory,\n-    FakeReadCause, Local, LocalDecl, LocalInfo, LocalKind, Location, Operand, Place, PlaceBase,\n-    PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind, VarBindingForm,\n+    FakeReadCause, Local, LocalDecl, LocalInfo, LocalKind, Location, Operand, Place, PlaceRef,\n+    ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind, VarBindingForm,\n };\n use rustc::traits::error_reporting::suggest_constraining_type_param;\n use rustc::ty::{self, Ty};\n@@ -186,7 +186,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n \n             let ty =\n-                Place::ty_from(used_place.base, used_place.projection, *self.body, self.infcx.tcx)\n+                Place::ty_from(used_place.local, used_place.projection, *self.body, self.infcx.tcx)\n                     .ty;\n             let needs_note = match ty.kind {\n                 ty::Closure(id, _) => {\n@@ -597,15 +597,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // field access to a union. If we find that, then we will keep the place of the\n                 // union being accessed and the field that was being accessed so we can check the\n                 // second borrowed place for the same union and a access to a different field.\n-                let Place { base, projection } = first_borrowed_place;\n+                let Place { local, projection } = first_borrowed_place;\n \n                 let mut cursor = projection.as_ref();\n                 while let [proj_base @ .., elem] = cursor {\n                     cursor = proj_base;\n \n                     match elem {\n-                        ProjectionElem::Field(field, _) if union_ty(base, proj_base).is_some() => {\n-                            return Some((PlaceRef { base: base, projection: proj_base }, field));\n+                        ProjectionElem::Field(field, _) if union_ty(local, proj_base).is_some() => {\n+                            return Some((PlaceRef { local, projection: proj_base }, field));\n                         }\n                         _ => {}\n                     }\n@@ -615,21 +615,21 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             .and_then(|(target_base, target_field)| {\n                 // With the place of a union and a field access into it, we traverse the second\n                 // borrowed place and look for a access to a different field of the same union.\n-                let Place { base, projection } = second_borrowed_place;\n+                let Place { local, projection } = second_borrowed_place;\n \n                 let mut cursor = projection.as_ref();\n                 while let [proj_base @ .., elem] = cursor {\n                     cursor = proj_base;\n \n                     if let ProjectionElem::Field(field, _) = elem {\n-                        if let Some(union_ty) = union_ty(base, proj_base) {\n+                        if let Some(union_ty) = union_ty(local, proj_base) {\n                             if field != target_field\n-                                && base == target_base.base\n+                                && local == target_base.local\n                                 && proj_base == target_base.projection\n                             {\n                                 // FIXME when we avoid clone reuse describe_place closure\n                                 let describe_base_place = self\n-                                    .describe_place(PlaceRef { base: base, projection: proj_base })\n+                                    .describe_place(PlaceRef { local, projection: proj_base })\n                                     .unwrap_or_else(|| \"_\".to_owned());\n \n                                 return Some((\n@@ -686,15 +686,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let borrow_span = borrow_spans.var_or_use();\n \n         assert!(root_place.projection.is_empty());\n-        let proper_span = match root_place.base {\n-            PlaceBase::Local(local) => self.body.local_decls[*local].source_info.span,\n-            _ => drop_span,\n-        };\n+        let proper_span = self.body.local_decls[*root_place.local].source_info.span;\n \n         let root_place_projection = self.infcx.tcx.intern_place_elems(root_place.projection);\n \n         if self.access_place_error_reported.contains(&(\n-            Place { base: root_place.base.clone(), projection: root_place_projection },\n+            Place { local: root_place.local.clone(), projection: root_place_projection },\n             borrow_span,\n         )) {\n             debug!(\n@@ -705,18 +702,17 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n \n         self.access_place_error_reported.insert((\n-            Place { base: root_place.base.clone(), projection: root_place_projection },\n+            Place { local: root_place.local.clone(), projection: root_place_projection },\n             borrow_span,\n         ));\n \n-        if let PlaceBase::Local(local) = borrow.borrowed_place.base {\n-            if self.body.local_decls[local].is_ref_to_thread_local() {\n-                let err = self\n-                    .report_thread_local_value_does_not_live_long_enough(drop_span, borrow_span);\n-                err.buffer(&mut self.errors_buffer);\n-                return;\n-            }\n-        };\n+        let borrowed_local = borrow.borrowed_place.local;\n+        if self.body.local_decls[borrowed_local].is_ref_to_thread_local() {\n+            let err =\n+                self.report_thread_local_value_does_not_live_long_enough(drop_span, borrow_span);\n+            err.buffer(&mut self.errors_buffer);\n+            return;\n+        }\n \n         if let StorageDeadOrDrop::Destructor(dropped_ty) =\n             self.classify_drop_access_kind(borrow.borrowed_place.as_ref())\n@@ -1142,12 +1138,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         } else {\n             let root_place =\n                 self.prefixes(borrow.borrowed_place.as_ref(), PrefixSet::All).last().unwrap();\n-            let local =\n-                if let PlaceRef { base: PlaceBase::Local(local), projection: [] } = root_place {\n-                    local\n-                } else {\n-                    bug!(\"try_report_cannot_return_reference_to_local: not a local\")\n-                };\n+            let local = root_place.local;\n             match self.body.local_kind(*local) {\n                 LocalKind::ReturnPointer | LocalKind::Temp => {\n                     (\"temporary value\".to_string(), \"temporary value created here\".to_string())\n@@ -1514,23 +1505,25 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             [proj_base @ .., elem] => {\n                 // FIXME(spastorino) make this iterate\n                 let base_access = self.classify_drop_access_kind(PlaceRef {\n-                    base: place.base,\n+                    local: place.local,\n                     projection: proj_base,\n                 });\n                 match elem {\n                     ProjectionElem::Deref => match base_access {\n                         StorageDeadOrDrop::LocalStorageDead\n                         | StorageDeadOrDrop::BoxedStorageDead => {\n                             assert!(\n-                                Place::ty_from(&place.base, proj_base, *self.body, tcx).ty.is_box(),\n+                                Place::ty_from(&place.local, proj_base, *self.body, tcx)\n+                                    .ty\n+                                    .is_box(),\n                                 \"Drop of value behind a reference or raw pointer\"\n                             );\n                             StorageDeadOrDrop::BoxedStorageDead\n                         }\n                         StorageDeadOrDrop::Destructor(_) => base_access,\n                     },\n                     ProjectionElem::Field(..) | ProjectionElem::Downcast(..) => {\n-                        let base_ty = Place::ty_from(&place.base, proj_base, *self.body, tcx).ty;\n+                        let base_ty = Place::ty_from(&place.local, proj_base, *self.body, tcx).ty;\n                         match base_ty.kind {\n                             ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                 // Report the outermost adt with a destructor"}, {"sha": "3f3bdb9d36c76352d429503a78f7677a41f3f92b", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 29, "deletions": 48, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -2,8 +2,7 @@\n \n use rustc::mir::{\n     AggregateKind, Constant, Field, Local, LocalInfo, LocalKind, Location, Operand, Place,\n-    PlaceBase, PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, Static, StaticKind,\n-    Terminator, TerminatorKind,\n+    PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind,\n };\n use rustc::ty::layout::VariantIdx;\n use rustc::ty::print::Print;\n@@ -169,42 +168,30 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         including_downcast: &IncludingDowncast,\n     ) -> Result<(), ()> {\n         match place {\n-            PlaceRef { base: PlaceBase::Local(local), projection: [] } => {\n+            PlaceRef { local, projection: [] } => {\n                 self.append_local_to_string(*local, buf)?;\n             }\n-            PlaceRef {\n-                base: PlaceBase::Static(box Static { kind: StaticKind::Promoted(..), .. }),\n-                projection: [],\n-            } => {\n-                buf.push_str(\"promoted\");\n-            }\n-            PlaceRef {\n-                base: PlaceBase::Static(box Static { kind: StaticKind::Static, def_id, .. }),\n-                projection: [],\n-            } => {\n-                buf.push_str(&self.infcx.tcx.item_name(*def_id).to_string());\n-            }\n-            PlaceRef { base: &PlaceBase::Local(local), projection: [ProjectionElem::Deref] }\n-                if self.body.local_decls[local].is_ref_for_guard() =>\n+            PlaceRef { local, projection: [ProjectionElem::Deref] }\n+                if self.body.local_decls[*local].is_ref_for_guard() =>\n             {\n                 self.append_place_to_string(\n-                    PlaceRef { base: &PlaceBase::Local(local), projection: &[] },\n+                    PlaceRef { local: local, projection: &[] },\n                     buf,\n                     autoderef,\n                     &including_downcast,\n                 )?;\n             }\n-            PlaceRef { base: &PlaceBase::Local(local), projection: [ProjectionElem::Deref] }\n-                if self.body.local_decls[local].is_ref_to_static() =>\n+            PlaceRef { local, projection: [ProjectionElem::Deref] }\n+                if self.body.local_decls[*local].is_ref_to_static() =>\n             {\n-                let local_info = &self.body.local_decls[local].local_info;\n+                let local_info = &self.body.local_decls[*local].local_info;\n                 if let LocalInfo::StaticRef { def_id, .. } = *local_info {\n                     buf.push_str(&self.infcx.tcx.item_name(def_id).as_str());\n                 } else {\n                     unreachable!();\n                 }\n             }\n-            PlaceRef { base, projection: [proj_base @ .., elem] } => {\n+            PlaceRef { local, projection: [proj_base @ .., elem] } => {\n                 match elem {\n                     ProjectionElem::Deref => {\n                         let upvar_field_projection = self.is_upvar_field_projection(place);\n@@ -220,29 +207,25 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             if autoderef {\n                                 // FIXME turn this recursion into iteration\n                                 self.append_place_to_string(\n-                                    PlaceRef { base, projection: proj_base },\n+                                    PlaceRef { local, projection: proj_base },\n                                     buf,\n                                     autoderef,\n                                     &including_downcast,\n                                 )?;\n                             } else {\n-                                match (proj_base, base) {\n-                                    _ => {\n-                                        buf.push_str(&\"*\");\n-                                        self.append_place_to_string(\n-                                            PlaceRef { base, projection: proj_base },\n-                                            buf,\n-                                            autoderef,\n-                                            &including_downcast,\n-                                        )?;\n-                                    }\n-                                }\n+                                buf.push_str(&\"*\");\n+                                self.append_place_to_string(\n+                                    PlaceRef { local, projection: proj_base },\n+                                    buf,\n+                                    autoderef,\n+                                    &including_downcast,\n+                                )?;\n                             }\n                         }\n                     }\n                     ProjectionElem::Downcast(..) => {\n                         self.append_place_to_string(\n-                            PlaceRef { base, projection: proj_base },\n+                            PlaceRef { local, projection: proj_base },\n                             buf,\n                             autoderef,\n                             &including_downcast,\n@@ -261,9 +244,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             buf.push_str(&name);\n                         } else {\n                             let field_name = self\n-                                .describe_field(PlaceRef { base, projection: proj_base }, *field);\n+                                .describe_field(PlaceRef { local, projection: proj_base }, *field);\n                             self.append_place_to_string(\n-                                PlaceRef { base, projection: proj_base },\n+                                PlaceRef { local, projection: proj_base },\n                                 buf,\n                                 autoderef,\n                                 &including_downcast,\n@@ -275,7 +258,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         autoderef = true;\n \n                         self.append_place_to_string(\n-                            PlaceRef { base, projection: proj_base },\n+                            PlaceRef { local, projection: proj_base },\n                             buf,\n                             autoderef,\n                             &including_downcast,\n@@ -292,7 +275,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         // then use another while the borrow is held, don't output indices details\n                         // to avoid confusing the end-user\n                         self.append_place_to_string(\n-                            PlaceRef { base, projection: proj_base },\n+                            PlaceRef { local, projection: proj_base },\n                             buf,\n                             autoderef,\n                             &including_downcast,\n@@ -323,20 +306,18 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn describe_field(&self, place: PlaceRef<'cx, 'tcx>, field: Field) -> String {\n         // FIXME Place2 Make this work iteratively\n         match place {\n-            PlaceRef { base: PlaceBase::Local(local), projection: [] } => {\n+            PlaceRef { local, projection: [] } => {\n                 let local = &self.body.local_decls[*local];\n                 self.describe_field_from_ty(&local.ty, field, None)\n             }\n-            PlaceRef { base: PlaceBase::Static(static_), projection: [] } => {\n-                self.describe_field_from_ty(&static_.ty, field, None)\n-            }\n-            PlaceRef { base, projection: [proj_base @ .., elem] } => match elem {\n+            PlaceRef { local, projection: [proj_base @ .., elem] } => match elem {\n                 ProjectionElem::Deref => {\n-                    self.describe_field(PlaceRef { base, projection: proj_base }, field)\n+                    self.describe_field(PlaceRef { local, projection: proj_base }, field)\n                 }\n                 ProjectionElem::Downcast(_, variant_index) => {\n                     let base_ty =\n-                        Place::ty_from(place.base, place.projection, *self.body, self.infcx.tcx).ty;\n+                        Place::ty_from(place.local, place.projection, *self.body, self.infcx.tcx)\n+                            .ty;\n                     self.describe_field_from_ty(&base_ty, field, Some(*variant_index))\n                 }\n                 ProjectionElem::Field(_, field_type) => {\n@@ -345,7 +326,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 ProjectionElem::Index(..)\n                 | ProjectionElem::ConstantIndex { .. }\n                 | ProjectionElem::Subslice { .. } => {\n-                    self.describe_field(PlaceRef { base, projection: proj_base }, field)\n+                    self.describe_field(PlaceRef { local, projection: proj_base }, field)\n                 }\n             },\n         }\n@@ -466,7 +447,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         // If we didn't find an overloaded deref or index, then assume it's a\n         // built in deref and check the type of the base.\n-        let base_ty = Place::ty_from(deref_base.base, deref_base.projection, *self.body, tcx).ty;\n+        let base_ty = Place::ty_from(deref_base.local, deref_base.projection, *self.body, tcx).ty;\n         if base_ty.is_unsafe_ptr() {\n             BorrowedContentSource::DerefRawPointer\n         } else if base_ty.is_mutable_ptr() {"}, {"sha": "eb6db7c145c3cde6f10425a8a85a49da3602b884", "filename": "src/librustc_mir/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -243,9 +243,6 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             );\n             (\n                 match kind {\n-                    IllegalMoveOriginKind::Static => {\n-                        unreachable!();\n-                    }\n                     IllegalMoveOriginKind::BorrowedContent { target_place } => self\n                         .report_cannot_move_from_borrowed_content(\n                             original_path,\n@@ -276,7 +273,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let description = if place.projection.len() == 1 {\n             format!(\"static item `{}`\", self.describe_place(place.as_ref()).unwrap())\n         } else {\n-            let base_static = PlaceRef { base: &place.base, projection: &[ProjectionElem::Deref] };\n+            let base_static =\n+                PlaceRef { local: &place.local, projection: &[ProjectionElem::Deref] };\n \n             format!(\n                 \"`{:?}` as `{:?}` is a static item\",\n@@ -305,12 +303,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n         let deref_base = match deref_target_place.projection.as_ref() {\n             &[ref proj_base @ .., ProjectionElem::Deref] => {\n-                PlaceRef { base: &deref_target_place.base, projection: &proj_base }\n+                PlaceRef { local: &deref_target_place.local, projection: &proj_base }\n             }\n             _ => bug!(\"deref_target_place is not a deref projection\"),\n         };\n \n-        if let PlaceRef { base: PlaceBase::Local(local), projection: [] } = deref_base {\n+        if let PlaceRef { local, projection: [] } = deref_base {\n             let decl = &self.body.local_decls[*local];\n             if decl.is_ref_for_guard() {\n                 let mut err = self.cannot_move_out_of("}, {"sha": "ae468e83ae253f790d97638f9217ca2f6dbcd0af", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -1,5 +1,5 @@\n use rustc::mir::{self, ClearCrossCrate, Local, LocalInfo, Location, ReadOnlyBodyAndCache};\n-use rustc::mir::{Mutability, Place, PlaceBase, PlaceRef, ProjectionElem};\n+use rustc::mir::{Mutability, Place, PlaceRef, ProjectionElem};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_hir as hir;\n use rustc_hir::Node;\n@@ -42,7 +42,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         debug!(\"report_mutability_error: access_place_desc={:?}\", access_place_desc);\n \n         match the_place_err {\n-            PlaceRef { base: PlaceBase::Local(local), projection: [] } => {\n+            PlaceRef { local, projection: [] } => {\n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                 if access_place.as_local().is_some() {\n                     reason = \", as it is not declared as mutable\".to_string();\n@@ -53,11 +53,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n \n             PlaceRef {\n-                base: _,\n+                local,\n                 projection: [proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             } => {\n                 debug_assert!(is_closure_or_generator(\n-                    Place::ty_from(&the_place_err.base, proj_base, *self.body, self.infcx.tcx).ty\n+                    Place::ty_from(local, proj_base, *self.body, self.infcx.tcx).ty\n                 ));\n \n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n@@ -69,21 +69,21 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n \n-            PlaceRef { base: &PlaceBase::Local(local), projection: [ProjectionElem::Deref] }\n-                if self.body.local_decls[local].is_ref_for_guard() =>\n+            PlaceRef { local, projection: [ProjectionElem::Deref] }\n+                if self.body.local_decls[*local].is_ref_for_guard() =>\n             {\n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                 reason = \", as it is immutable for the pattern guard\".to_string();\n             }\n-            PlaceRef { base: &PlaceBase::Local(local), projection: [ProjectionElem::Deref] }\n-                if self.body.local_decls[local].is_ref_to_static() =>\n+            PlaceRef { local, projection: [ProjectionElem::Deref] }\n+                if self.body.local_decls[*local].is_ref_to_static() =>\n             {\n                 if access_place.projection.len() == 1 {\n                     item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());\n                     reason = String::new();\n                 } else {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                    let local_info = &self.body.local_decls[local].local_info;\n+                    let local_info = &self.body.local_decls[*local].local_info;\n                     if let LocalInfo::StaticRef { def_id, .. } = *local_info {\n                         let static_name = &self.infcx.tcx.item_name(def_id);\n                         reason = format!(\", as `{}` is an immutable static item\", static_name);\n@@ -92,16 +92,16 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     }\n                 }\n             }\n-            PlaceRef { base: _, projection: [proj_base @ .., ProjectionElem::Deref] } => {\n-                if the_place_err.base == &PlaceBase::Local(Local::new(1))\n+            PlaceRef { local: _, projection: [proj_base @ .., ProjectionElem::Deref] } => {\n+                if *the_place_err.local == Local::new(1)\n                     && proj_base.is_empty()\n                     && !self.upvars.is_empty()\n                 {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                     debug_assert!(self.body.local_decls[Local::new(1)].ty.is_region_ptr());\n                     debug_assert!(is_closure_or_generator(\n                         Place::ty_from(\n-                            the_place_err.base,\n+                            the_place_err.local,\n                             the_place_err.projection,\n                             *self.body,\n                             self.infcx.tcx\n@@ -116,7 +116,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     }\n                 } else {\n                     let source = self.borrowed_content_source(PlaceRef {\n-                        base: the_place_err.base,\n+                        local: the_place_err.local,\n                         projection: proj_base,\n                     });\n                     let pointer_type = source.describe_for_immutable_place();\n@@ -136,11 +136,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n \n-            PlaceRef { base: PlaceBase::Static(_), .. }\n-            | PlaceRef { base: _, projection: [.., ProjectionElem::Index(_)] }\n-            | PlaceRef { base: _, projection: [.., ProjectionElem::ConstantIndex { .. }] }\n-            | PlaceRef { base: _, projection: [.., ProjectionElem::Subslice { .. }] }\n-            | PlaceRef { base: _, projection: [.., ProjectionElem::Downcast(..)] } => {\n+            PlaceRef { local: _, projection: [.., ProjectionElem::Index(_)] }\n+            | PlaceRef { local: _, projection: [.., ProjectionElem::ConstantIndex { .. }] }\n+            | PlaceRef { local: _, projection: [.., ProjectionElem::Subslice { .. }] }\n+            | PlaceRef { local: _, projection: [.., ProjectionElem::Downcast(..)] } => {\n                 bug!(\"Unexpected immutable place.\")\n             }\n         }\n@@ -188,15 +187,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // struct we've got a field access of (it must be a reference since there's a deref\n             // after the field access).\n             PlaceRef {\n-                base,\n+                local,\n                 projection:\n                     [proj_base @ .., ProjectionElem::Deref, ProjectionElem::Field(field, _), ProjectionElem::Deref],\n             } => {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n \n                 if let Some((span, message)) = annotate_struct_field(\n                     self.infcx.tcx,\n-                    Place::ty_from(base, proj_base, *self.body, self.infcx.tcx).ty,\n+                    Place::ty_from(local, proj_base, *self.body, self.infcx.tcx).ty,\n                     field,\n                 ) {\n                     err.span_suggestion(\n@@ -209,7 +208,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n \n             // Suggest removing a `&mut` from the use of a mutable reference.\n-            PlaceRef { base: PlaceBase::Local(local), projection: [] }\n+            PlaceRef { local, projection: [] }\n                 if {\n                     self.body\n                         .local_decls\n@@ -247,7 +246,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n             // We want to suggest users use `let mut` for local (user\n             // variable) mutations...\n-            PlaceRef { base: PlaceBase::Local(local), projection: [] }\n+            PlaceRef { local, projection: [] }\n                 if self.body.local_decls[*local].can_be_made_mutable() =>\n             {\n                 // ... but it doesn't make sense to suggest it on\n@@ -268,11 +267,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n             // Also suggest adding mut for upvars\n             PlaceRef {\n-                base,\n+                local,\n                 projection: [proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             } => {\n                 debug_assert!(is_closure_or_generator(\n-                    Place::ty_from(base, proj_base, *self.body, self.infcx.tcx).ty\n+                    Place::ty_from(local, proj_base, *self.body, self.infcx.tcx).ty\n                 ));\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n@@ -299,7 +298,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // complete hack to approximate old AST-borrowck\n             // diagnostic: if the span starts with a mutable borrow of\n             // a local variable, then just suggest the user remove it.\n-            PlaceRef { base: PlaceBase::Local(_), projection: [] }\n+            PlaceRef { local: _, projection: [] }\n                 if {\n                     if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n                         snippet.starts_with(\"&mut \")\n@@ -312,7 +311,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 err.span_label(span, \"try removing `&mut` here\");\n             }\n \n-            PlaceRef { base: PlaceBase::Local(local), projection: [ProjectionElem::Deref] }\n+            PlaceRef { local, projection: [ProjectionElem::Deref] }\n                 if self.body.local_decls[*local].is_ref_for_guard() =>\n             {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n@@ -326,7 +325,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             //\n             // FIXME: can this case be generalized to work for an\n             // arbitrary base for the projection?\n-            PlaceRef { base: PlaceBase::Local(local), projection: [ProjectionElem::Deref] }\n+            PlaceRef { local, projection: [ProjectionElem::Deref] }\n                 if self.body.local_decls[*local].is_user_variable() =>\n             {\n                 let local_decl = &self.body.local_decls[*local];\n@@ -409,18 +408,18 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n \n             PlaceRef {\n-                base,\n+                local,\n                 projection: [ProjectionElem::Deref],\n                 // FIXME document what is this 1 magic number about\n-            } if *base == PlaceBase::Local(Local::new(1)) && !self.upvars.is_empty() => {\n+            } if *local == Local::new(1) && !self.upvars.is_empty() => {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.span_help(\n                     self.body.span,\n                     \"consider changing this to accept closures that implement `FnMut`\",\n                 );\n             }\n \n-            PlaceRef { base: _, projection: [.., ProjectionElem::Deref] } => {\n+            PlaceRef { local: _, projection: [.., ProjectionElem::Deref] } => {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n \n                 match opt_source {"}, {"sha": "bb56c11872a29039e086838627db5c0bab629ba5", "filename": "src/librustc_mir/borrow_check/invalidation.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -3,7 +3,7 @@ use rustc::mir::TerminatorKind;\n use rustc::mir::{BasicBlock, Body, Location, Place, ReadOnlyBodyAndCache, Rvalue};\n use rustc::mir::{BorrowKind, Mutability, Operand};\n use rustc::mir::{Statement, StatementKind};\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::TyCtxt;\n use rustc_data_structures::graph::dominators::Dominators;\n \n use crate::dataflow::indexes::BorrowIndex;\n@@ -16,7 +16,6 @@ use crate::borrow_check::{\n \n pub(super) fn generate_invalidates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n     all_facts: &mut Option<AllFacts>,\n     location_table: &LocationTable,\n     body: ReadOnlyBodyAndCache<'_, 'tcx>,\n@@ -33,7 +32,6 @@ pub(super) fn generate_invalidates<'tcx>(\n         let mut ig = InvalidationGenerator {\n             all_facts,\n             borrow_set,\n-            param_env,\n             tcx,\n             location_table,\n             body: &body,\n@@ -45,7 +43,6 @@ pub(super) fn generate_invalidates<'tcx>(\n \n struct InvalidationGenerator<'cx, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n     all_facts: &'cx mut AllFacts,\n     location_table: &'cx LocationTable,\n     body: &'cx Body<'tcx>,\n@@ -337,13 +334,11 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n         );\n         let tcx = self.tcx;\n         let body = self.body;\n-        let param_env = self.param_env;\n         let borrow_set = self.borrow_set.clone();\n         let indices = self.borrow_set.borrows.indices();\n         each_borrow_involving_path(\n             self,\n             tcx,\n-            param_env,\n             body,\n             location,\n             (sd, place),"}, {"sha": "7b0a103fd00383effcbd24cc91092986002362c7", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 64, "deletions": 127, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -5,7 +5,7 @@ use rustc::lint::builtin::MUTABLE_BORROW_RESERVATION_CONFLICT;\n use rustc::lint::builtin::UNUSED_MUT;\n use rustc::mir::{\n     read_only, Body, BodyAndCache, ClearCrossCrate, Local, Location, Mutability, Operand, Place,\n-    PlaceBase, PlaceElem, PlaceRef, ReadOnlyBodyAndCache, Static, StaticKind,\n+    PlaceElem, PlaceRef, ReadOnlyBodyAndCache,\n };\n use rustc::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n use rustc::mir::{Field, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n@@ -239,7 +239,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         def_id,\n         &attributes,\n         &dead_unwinds,\n-        Borrows::new(tcx, &body, param_env, regioncx.clone(), &borrow_set),\n+        Borrows::new(tcx, &body, regioncx.clone(), &borrow_set),\n         |rs, i| DebugFormatted::new(&rs.location(i)),\n     ));\n     let flow_uninits = FlowAtLocation::new(do_dataflow(\n@@ -275,7 +275,6 @@ fn do_mir_borrowck<'a, 'tcx>(\n         infcx,\n         body,\n         mir_def_id: def_id,\n-        param_env,\n         move_data: &mdpe.move_data,\n         location_table,\n         movable_generator,\n@@ -418,7 +417,6 @@ crate struct MirBorrowckCtxt<'cx, 'tcx> {\n     crate infcx: &'cx InferCtxt<'cx, 'tcx>,\n     body: ReadOnlyBodyAndCache<'cx, 'tcx>,\n     mir_def_id: DefId,\n-    param_env: ty::ParamEnv<'tcx>,\n     move_data: &'cx MoveData<'tcx>,\n \n     /// Map from MIR `Location` to `LocationIndex`; created\n@@ -817,7 +815,7 @@ enum InitializationRequiringAction {\n }\n \n struct RootPlace<'d, 'tcx> {\n-    place_base: &'d PlaceBase<'tcx>,\n+    place_local: &'d Local,\n     place_projection: &'d [PlaceElem<'tcx>],\n     is_local_mutation_allowed: LocalMutationIsAllowed,\n }\n@@ -926,13 +924,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let tcx = self.infcx.tcx;\n         let body = self.body;\n         let body: &Body<'_> = &body;\n-        let param_env = self.param_env;\n         let location_table = self.location_table.start_index(location);\n         let borrow_set = self.borrow_set.clone();\n         each_borrow_involving_path(\n             self,\n             tcx,\n-            param_env,\n             body,\n             location,\n             (sd, place_span.0),\n@@ -1255,8 +1251,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 if let Some(field) = this.is_upvar_field_projection(place.as_ref()) {\n                     this.used_mut_upvars.push(field);\n                 }\n-            } else if let PlaceBase::Local(local) = place.base {\n-                this.used_mut.insert(local);\n+            } else {\n+                this.used_mut.insert(place.local);\n             }\n         };\n \n@@ -1380,28 +1376,24 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         debug!(\"check_for_invalidation_at_exit({:?})\", borrow);\n         let place = &borrow.borrowed_place;\n         let deref = [ProjectionElem::Deref];\n-        let mut root_place = PlaceRef { base: &place.base, projection: &[] };\n+        let mut root_place = PlaceRef { local: &place.local, projection: &[] };\n \n         // FIXME(nll-rfc#40): do more precise destructor tracking here. For now\n         // we just know that all locals are dropped at function exit (otherwise\n         // we'll have a memory leak) and assume that all statics have a destructor.\n         //\n         // FIXME: allow thread-locals to borrow other thread locals?\n \n-        let (might_be_alive, will_be_dropped) = match root_place.base {\n-            PlaceBase::Static(_) => (true, false),\n-            PlaceBase::Local(local) => {\n-                if self.body.local_decls[*local].is_ref_to_thread_local() {\n-                    // Thread-locals might be dropped after the function exits\n-                    // We have to dereference the outer reference because\n-                    // borrows don't conflict behind shared references.\n-                    root_place.projection = &deref;\n-                    (true, true)\n-                } else {\n-                    (false, self.locals_are_invalidated_at_exit)\n-                }\n-            }\n-        };\n+        let (might_be_alive, will_be_dropped) =\n+            if self.body.local_decls[*root_place.local].is_ref_to_thread_local() {\n+                // Thread-locals might be dropped after the function exits\n+                // We have to dereference the outer reference because\n+                // borrows don't conflict behind shared references.\n+                root_place.projection = &deref;\n+                (true, true)\n+            } else {\n+                (false, self.locals_are_invalidated_at_exit)\n+            };\n \n         if !will_be_dropped {\n             debug!(\"place_is_invalidated_at_exit({:?}) - won't be dropped\", place);\n@@ -1412,7 +1404,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         if places_conflict::borrow_conflicts_with_place(\n             self.infcx.tcx,\n-            self.param_env,\n             &self.body,\n             place,\n             borrow.kind,\n@@ -1654,26 +1645,20 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // This code covers scenarios 1, 2, and 3.\n \n         debug!(\"check_if_full_path_is_moved place: {:?}\", place_span.0);\n-        match self.move_path_closest_to(place_span.0) {\n-            Ok((prefix, mpi)) => {\n-                if maybe_uninits.contains(mpi) {\n-                    self.report_use_of_moved_or_uninitialized(\n-                        location,\n-                        desired_action,\n-                        (prefix, place_span.0, place_span.1),\n-                        mpi,\n-                    );\n-                }\n-            }\n-            Err(NoMovePathFound::ReachedStatic) => {\n-                // Okay: we do not build MoveData for static variables\n-            } // Only query longest prefix with a MovePath, not further\n-              // ancestors; dataflow recurs on children when parents\n-              // move (to support partial (re)inits).\n-              //\n-              // (I.e., querying parents breaks scenario 7; but may want\n-              // to do such a query based on partial-init feature-gate.)\n-        }\n+        let (prefix, mpi) = self.move_path_closest_to(place_span.0);\n+        if maybe_uninits.contains(mpi) {\n+            self.report_use_of_moved_or_uninitialized(\n+                location,\n+                desired_action,\n+                (prefix, place_span.0, place_span.1),\n+                mpi,\n+            );\n+        } // Only query longest prefix with a MovePath, not further\n+        // ancestors; dataflow recurs on children when parents\n+        // move (to support partial (re)inits).\n+        //\n+        // (I.e., querying parents breaks scenario 7; but may want\n+        // to do such a query based on partial-init feature-gate.)\n     }\n \n     /// Subslices correspond to multiple move paths, so we iterate through the\n@@ -1746,9 +1731,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             place_span.0.projection\n         {\n             let place_ty =\n-                Place::ty_from(place_span.0.base, base_proj, self.body(), self.infcx.tcx);\n+                Place::ty_from(place_span.0.local, base_proj, self.body(), self.infcx.tcx);\n             if let ty::Array(..) = place_ty.ty.kind {\n-                let array_place = PlaceRef { base: place_span.0.base, projection: base_proj };\n+                let array_place = PlaceRef { local: place_span.0.local, projection: base_proj };\n                 self.check_if_subslice_element_is_moved(\n                     location,\n                     desired_action,\n@@ -1797,12 +1782,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn move_path_closest_to(\n         &mut self,\n         place: PlaceRef<'_, 'tcx>,\n-    ) -> Result<(PlaceRef<'cx, 'tcx>, MovePathIndex), NoMovePathFound> {\n+    ) -> (PlaceRef<'cx, 'tcx>, MovePathIndex) {\n         match self.move_data.rev_lookup.find(place) {\n             LookupResult::Parent(Some(mpi)) | LookupResult::Exact(mpi) => {\n-                Ok((self.move_data.move_paths[mpi].place.as_ref(), mpi))\n+                (self.move_data.move_paths[mpi].place.as_ref(), mpi)\n             }\n-            LookupResult::Parent(None) => Err(NoMovePathFound::ReachedStatic),\n+            LookupResult::Parent(None) => panic!(\"should have move path for every Local\"),\n         }\n     }\n \n@@ -1845,7 +1830,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     self.check_if_full_path_is_moved(\n                         location, InitializationRequiringAction::Use,\n                         (PlaceRef {\n-                            base: &place.base,\n+                            local: &place.local,\n                             projection: proj_base,\n                         }, span), flow_state);\n                     // (base initialized; no need to\n@@ -1863,13 +1848,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     // assigning to `P.f` requires `P` itself\n                     // be already initialized\n                     let tcx = self.infcx.tcx;\n-                    let base_ty = Place::ty_from(&place.base, proj_base, self.body(), tcx).ty;\n+                    let base_ty = Place::ty_from(&place.local, proj_base, self.body(), tcx).ty;\n                     match base_ty.kind {\n                         ty::Adt(def, _) if def.has_dtor(tcx) => {\n                             self.check_if_path_or_subpath_is_moved(\n                                 location, InitializationRequiringAction::Assignment,\n                                 (PlaceRef {\n-                                    base: &place.base,\n+                                    local: &place.local,\n                                     projection: proj_base,\n                                 }, span), flow_state);\n \n@@ -1882,21 +1867,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         // is allowed, remove this match arm.\n                         ty::Adt(..) | ty::Tuple(..) => {\n                             check_parent_of_field(self, location, PlaceRef {\n-                                base: &place.base,\n+                                local: &place.local,\n                                 projection: proj_base,\n                             }, span, flow_state);\n \n-                            if let PlaceBase::Local(local) = place.base {\n-                                // rust-lang/rust#21232,\n-                                // #54499, #54986: during\n-                                // period where we reject\n-                                // partial initialization, do\n-                                // not complain about\n-                                // unnecessary `mut` on an\n-                                // attempt to do a partial\n-                                // initialization.\n-                                self.used_mut.insert(local);\n-                            }\n+                            // rust-lang/rust#21232, #54499, #54986: during period where we reject\n+                            // partial initialization, do not complain about unnecessary `mut` on\n+                            // an attempt to do a partial initialization.\n+                            self.used_mut.insert(place.local);\n                         }\n \n                         _ => {}\n@@ -1974,7 +1952,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // of the union - we should error in that case.\n                 let tcx = this.infcx.tcx;\n                 if let ty::Adt(def, _) =\n-                    Place::ty_from(base.base, base.projection, this.body(), tcx).ty.kind\n+                    Place::ty_from(base.local, base.projection, this.body(), tcx).ty.kind\n                 {\n                     if def.is_union() {\n                         if this.move_data.path_map[mpi].iter().any(|moi| {\n@@ -2093,11 +2071,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // partial initialization, do not complain about mutability\n         // errors except for actual mutation (as opposed to an attempt\n         // to do a partial initialization).\n-        let previously_initialized = if let PlaceBase::Local(local) = place.base {\n-            self.is_local_ever_initialized(local, flow_state).is_some()\n-        } else {\n-            true\n-        };\n+        let previously_initialized =\n+            self.is_local_ever_initialized(place.local, flow_state).is_some();\n \n         // at this point, we have set up the error reporting state.\n         if previously_initialized {\n@@ -2126,11 +2101,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Adds the place into the used mutable variables set\n     fn add_used_mut<'d>(&mut self, root_place: RootPlace<'d, 'tcx>, flow_state: &Flows<'cx, 'tcx>) {\n         match root_place {\n-            RootPlace {\n-                place_base: PlaceBase::Local(local),\n-                place_projection: [],\n-                is_local_mutation_allowed,\n-            } => {\n+            RootPlace { place_local: local, place_projection: [], is_local_mutation_allowed } => {\n                 // If the local may have been initialized, and it is now currently being\n                 // mutated, then it is justified to be annotated with the `mut`\n                 // keyword, since the mutation may be a possible reassignment.\n@@ -2141,27 +2112,22 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n             }\n             RootPlace {\n-                place_base: _,\n+                place_local: _,\n                 place_projection: _,\n                 is_local_mutation_allowed: LocalMutationIsAllowed::Yes,\n             } => {}\n             RootPlace {\n-                place_base,\n+                place_local,\n                 place_projection: place_projection @ [.., _],\n                 is_local_mutation_allowed: _,\n             } => {\n                 if let Some(field) = self.is_upvar_field_projection(PlaceRef {\n-                    base: &place_base,\n-                    projection: &place_projection,\n+                    local: place_local,\n+                    projection: place_projection,\n                 }) {\n                     self.used_mut_upvars.push(field);\n                 }\n             }\n-            RootPlace {\n-                place_base: PlaceBase::Static(..),\n-                place_projection: [],\n-                is_local_mutation_allowed: _,\n-            } => {}\n         }\n     }\n \n@@ -2173,58 +2139,34 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n     ) -> Result<RootPlace<'d, 'tcx>, PlaceRef<'d, 'tcx>> {\n         match place {\n-            PlaceRef { base: PlaceBase::Local(local), projection: [] } => {\n+            PlaceRef { local, projection: [] } => {\n                 let local = &self.body.local_decls[*local];\n                 match local.mutability {\n                     Mutability::Not => match is_local_mutation_allowed {\n                         LocalMutationIsAllowed::Yes => Ok(RootPlace {\n-                            place_base: place.base,\n+                            place_local: place.local,\n                             place_projection: place.projection,\n                             is_local_mutation_allowed: LocalMutationIsAllowed::Yes,\n                         }),\n                         LocalMutationIsAllowed::ExceptUpvars => Ok(RootPlace {\n-                            place_base: place.base,\n+                            place_local: place.local,\n                             place_projection: place.projection,\n                             is_local_mutation_allowed: LocalMutationIsAllowed::ExceptUpvars,\n                         }),\n                         LocalMutationIsAllowed::No => Err(place),\n                     },\n                     Mutability::Mut => Ok(RootPlace {\n-                        place_base: place.base,\n+                        place_local: place.local,\n                         place_projection: place.projection,\n                         is_local_mutation_allowed,\n                     }),\n                 }\n             }\n-            // The rules for promotion are made by `qualify_consts`, there wouldn't even be a\n-            // `Place::Promoted` if the promotion weren't 100% legal. So we just forward this\n-            PlaceRef {\n-                base: PlaceBase::Static(box Static { kind: StaticKind::Promoted(..), .. }),\n-                projection: [],\n-            } => Ok(RootPlace {\n-                place_base: place.base,\n-                place_projection: place.projection,\n-                is_local_mutation_allowed,\n-            }),\n-            PlaceRef {\n-                base: PlaceBase::Static(box Static { kind: StaticKind::Static, def_id, .. }),\n-                projection: [],\n-            } => {\n-                if !self.infcx.tcx.is_mutable_static(*def_id) {\n-                    Err(place)\n-                } else {\n-                    Ok(RootPlace {\n-                        place_base: place.base,\n-                        place_projection: place.projection,\n-                        is_local_mutation_allowed,\n-                    })\n-                }\n-            }\n-            PlaceRef { base: _, projection: [proj_base @ .., elem] } => {\n+            PlaceRef { local: _, projection: [proj_base @ .., elem] } => {\n                 match elem {\n                     ProjectionElem::Deref => {\n                         let base_ty =\n-                            Place::ty_from(place.base, proj_base, self.body(), self.infcx.tcx).ty;\n+                            Place::ty_from(place.local, proj_base, self.body(), self.infcx.tcx).ty;\n \n                         // Check the kind of deref to decide\n                         match base_ty.kind {\n@@ -2243,7 +2185,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                         };\n \n                                         self.is_mutable(\n-                                            PlaceRef { base: place.base, projection: proj_base },\n+                                            PlaceRef { local: place.local, projection: proj_base },\n                                             mode,\n                                         )\n                                     }\n@@ -2256,15 +2198,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     // `*mut` raw pointers are always mutable, regardless of\n                                     // context. The users have to check by themselves.\n                                     hir::Mutability::Mut => Ok(RootPlace {\n-                                        place_base: place.base,\n+                                        place_local: place.local,\n                                         place_projection: place.projection,\n                                         is_local_mutation_allowed,\n                                     }),\n                                 }\n                             }\n                             // `Box<T>` owns its content, so mutable if its location is mutable\n                             _ if base_ty.is_box() => self.is_mutable(\n-                                PlaceRef { base: place.base, projection: proj_base },\n+                                PlaceRef { local: place.local, projection: proj_base },\n                                 is_local_mutation_allowed,\n                             ),\n                             // Deref should only be for reference, pointers or boxes\n@@ -2320,19 +2262,19 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     // }\n                                     // ```\n                                     let _ = self.is_mutable(\n-                                        PlaceRef { base: place.base, projection: proj_base },\n+                                        PlaceRef { local: place.local, projection: proj_base },\n                                         is_local_mutation_allowed,\n                                     )?;\n                                     Ok(RootPlace {\n-                                        place_base: place.base,\n+                                        place_local: place.local,\n                                         place_projection: place.projection,\n                                         is_local_mutation_allowed,\n                                     })\n                                 }\n                             }\n                         } else {\n                             self.is_mutable(\n-                                PlaceRef { base: place.base, projection: proj_base },\n+                                PlaceRef { local: place.local, projection: proj_base },\n                                 is_local_mutation_allowed,\n                             )\n                         }\n@@ -2358,7 +2300,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         match place_projection {\n             [base @ .., ProjectionElem::Field(field, _ty)] => {\n                 let tcx = self.infcx.tcx;\n-                let base_ty = Place::ty_from(place_ref.base, base, self.body(), tcx).ty;\n+                let base_ty = Place::ty_from(place_ref.local, base, self.body(), tcx).ty;\n \n                 if (base_ty.is_closure() || base_ty.is_generator())\n                     && (!by_ref || self.upvars[field.index()].by_ref)\n@@ -2374,11 +2316,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-enum NoMovePathFound {\n-    ReachedStatic,\n-}\n-\n /// The degree of overlap between 2 places for borrow-checking.\n enum Overlap {\n     /// The places might partially overlap - in this case, we give"}, {"sha": "151a2c4c19a7dccee35547793c3c7808c1a6de62", "filename": "src/librustc_mir/borrow_check/nll.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -231,7 +231,6 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n \n     constraint_generation::generate_constraints(\n         infcx,\n-        param_env,\n         &mut liveness_constraints,\n         &mut all_facts,\n         location_table,\n@@ -253,14 +252,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     );\n \n     // Generate various additional constraints.\n-    invalidation::generate_invalidates(\n-        infcx.tcx,\n-        param_env,\n-        &mut all_facts,\n-        location_table,\n-        body,\n-        borrow_set,\n-    );\n+    invalidation::generate_invalidates(infcx.tcx, &mut all_facts, location_table, body, borrow_set);\n \n     // Dump facts if requested.\n     let polonius_output = all_facts.and_then(|all_facts| {"}, {"sha": "deec6f386ffb3d9175795b83a3f37ec5c9265161", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -3,8 +3,8 @@ use crate::borrow_check::places_conflict;\n use crate::borrow_check::AccessDepth;\n use crate::dataflow::indexes::BorrowIndex;\n use rustc::mir::BorrowKind;\n-use rustc::mir::{BasicBlock, Body, Location, Place, PlaceBase};\n-use rustc::ty::{self, TyCtxt};\n+use rustc::mir::{BasicBlock, Body, Location, Place};\n+use rustc::ty::TyCtxt;\n use rustc_data_structures::graph::dominators::Dominators;\n \n /// Returns `true` if the borrow represented by `kind` is\n@@ -25,7 +25,6 @@ pub(super) enum Control {\n pub(super) fn each_borrow_involving_path<'tcx, F, I, S>(\n     s: &mut S,\n     tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n     body: &Body<'tcx>,\n     _location: Location,\n     access_place: (AccessDepth, &Place<'tcx>),\n@@ -48,7 +47,6 @@ pub(super) fn each_borrow_involving_path<'tcx, F, I, S>(\n \n         if places_conflict::borrow_conflicts_with_place(\n             tcx,\n-            param_env,\n             body,\n             &borrowed.borrowed_place,\n             borrowed.kind,\n@@ -133,11 +131,7 @@ pub(super) fn is_active<'tcx>(\n /// Determines if a given borrow is borrowing local data\n /// This is called for all Yield expressions on movable generators\n pub(super) fn borrow_of_local_data(place: &Place<'_>) -> bool {\n-    match place.base {\n-        PlaceBase::Static(_) => false,\n-\n-        // Reborrow of already borrowed data is ignored\n-        // Any errors will be caught on the initial borrow\n-        PlaceBase::Local(_) => !place.is_indirect(),\n-    }\n+    // Reborrow of already borrowed data is ignored\n+    // Any errors will be caught on the initial borrow\n+    !place.is_indirect()\n }"}, {"sha": "ac02da2661586d57c38ec867003b3956259a0ee3", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -1,6 +1,6 @@\n use crate::borrow_check::borrow_set::LocalsStateAtExit;\n use rustc::mir::ProjectionElem;\n-use rustc::mir::{Body, Mutability, Place, PlaceBase};\n+use rustc::mir::{Body, Mutability, Place};\n use rustc::ty::{self, TyCtxt};\n use rustc_hir as hir;\n \n@@ -25,41 +25,35 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n         body: &Body<'tcx>,\n         locals_state_at_exit: &LocalsStateAtExit,\n     ) -> bool {\n-        let local = match self.base {\n-            // If a local variable is immutable, then we only need to track borrows to guard\n-            // against two kinds of errors:\n-            // * The variable being dropped while still borrowed (e.g., because the fn returns\n-            //   a reference to a local variable)\n-            // * The variable being moved while still borrowed\n-            //\n-            // In particular, the variable cannot be mutated -- the \"access checks\" will fail --\n-            // so we don't have to worry about mutation while borrowed.\n-            PlaceBase::Local(local) => match locals_state_at_exit {\n-                LocalsStateAtExit::AllAreInvalidated => local,\n-                LocalsStateAtExit::SomeAreInvalidated { has_storage_dead_or_moved } => {\n-                    let ignore = !has_storage_dead_or_moved.contains(local)\n-                        && body.local_decls[local].mutability == Mutability::Not;\n-                    debug!(\"ignore_borrow: local {:?} => {:?}\", local, ignore);\n-                    if ignore {\n-                        return true;\n-                    } else {\n-                        local\n-                    }\n-                }\n-            },\n-            PlaceBase::Static(_) => return true,\n-        };\n+        // If a local variable is immutable, then we only need to track borrows to guard\n+        // against two kinds of errors:\n+        // * The variable being dropped while still borrowed (e.g., because the fn returns\n+        //   a reference to a local variable)\n+        // * The variable being moved while still borrowed\n+        //\n+        // In particular, the variable cannot be mutated -- the \"access checks\" will fail --\n+        // so we don't have to worry about mutation while borrowed.\n+        if let LocalsStateAtExit::SomeAreInvalidated { has_storage_dead_or_moved } =\n+            locals_state_at_exit\n+        {\n+            let ignore = !has_storage_dead_or_moved.contains(self.local)\n+                && body.local_decls[self.local].mutability == Mutability::Not;\n+            debug!(\"ignore_borrow: local {:?} => {:?}\", self.local, ignore);\n+            if ignore {\n+                return true;\n+            }\n+        }\n \n         for (i, elem) in self.projection.iter().enumerate() {\n             let proj_base = &self.projection[..i];\n \n             if *elem == ProjectionElem::Deref {\n-                let ty = Place::ty_from(&self.base, proj_base, body, tcx).ty;\n+                let ty = Place::ty_from(&self.local, proj_base, body, tcx).ty;\n                 match ty.kind {\n                     ty::Ref(_, _, hir::Mutability::Not) if i == 0 => {\n                         // For references to thread-local statics, we do need\n                         // to track the borrow.\n-                        if body.local_decls[local].is_ref_to_thread_local() {\n+                        if body.local_decls[self.local].is_ref_to_thread_local() {\n                             continue;\n                         }\n                         return true;"}, {"sha": "b95d1af11ad1d1c6fe64c250c83d3c773a79315b", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 18, "deletions": 86, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -1,9 +1,7 @@\n use crate::borrow_check::ArtificialField;\n use crate::borrow_check::Overlap;\n use crate::borrow_check::{AccessDepth, Deep, Shallow};\n-use rustc::mir::{\n-    Body, BorrowKind, Place, PlaceBase, PlaceElem, PlaceRef, ProjectionElem, StaticKind,\n-};\n+use rustc::mir::{Body, BorrowKind, Local, Place, PlaceElem, PlaceRef, ProjectionElem};\n use rustc::ty::{self, TyCtxt};\n use rustc_hir as hir;\n use std::cmp::max;\n@@ -25,15 +23,13 @@ crate enum PlaceConflictBias {\n /// dataflow).\n crate fn places_conflict<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n     body: &Body<'tcx>,\n     borrow_place: &Place<'tcx>,\n     access_place: &Place<'tcx>,\n     bias: PlaceConflictBias,\n ) -> bool {\n     borrow_conflicts_with_place(\n         tcx,\n-        param_env,\n         body,\n         borrow_place,\n         BorrowKind::Mut { allow_two_phase_borrow: true },\n@@ -49,7 +45,6 @@ crate fn places_conflict<'tcx>(\n /// order to make the conservative choice and preserve soundness.\n pub(super) fn borrow_conflicts_with_place<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n     body: &Body<'tcx>,\n     borrow_place: &Place<'tcx>,\n     borrow_kind: BorrowKind,\n@@ -70,21 +65,11 @@ pub(super) fn borrow_conflicts_with_place<'tcx>(\n         }\n     }\n \n-    place_components_conflict(\n-        tcx,\n-        param_env,\n-        body,\n-        borrow_place,\n-        borrow_kind,\n-        access_place,\n-        access,\n-        bias,\n-    )\n+    place_components_conflict(tcx, body, borrow_place, borrow_kind, access_place, access, bias)\n }\n \n fn place_components_conflict<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n     body: &Body<'tcx>,\n     borrow_place: &Place<'tcx>,\n     borrow_kind: BorrowKind,\n@@ -134,10 +119,10 @@ fn place_components_conflict<'tcx>(\n     //    and either equal or disjoint.\n     //  - If we did run out of access, the borrow can access a part of it.\n \n-    let borrow_base = &borrow_place.base;\n-    let access_base = access_place.base;\n+    let borrow_local = &borrow_place.local;\n+    let access_local = access_place.local;\n \n-    match place_base_conflict(tcx, param_env, borrow_base, access_base) {\n+    match place_base_conflict(borrow_local, access_local) {\n         Overlap::Arbitrary => {\n             bug!(\"Two base can't return Arbitrary\");\n         }\n@@ -176,7 +161,7 @@ fn place_components_conflict<'tcx>(\n         match place_projection_conflict(\n             tcx,\n             body,\n-            borrow_base,\n+            borrow_local,\n             borrow_proj_base,\n             borrow_c,\n             access_c,\n@@ -223,7 +208,7 @@ fn place_components_conflict<'tcx>(\n             // access cares about.\n \n             let proj_base = &borrow_place.projection[..access_place.projection.len() + i];\n-            let base_ty = Place::ty_from(borrow_base, proj_base, body, tcx).ty;\n+            let base_ty = Place::ty_from(borrow_local, proj_base, body, tcx).ty;\n \n             match (elem, &base_ty.kind, access) {\n                 (_, _, Shallow(Some(ArtificialField::ArrayLength)))\n@@ -308,68 +293,15 @@ fn place_components_conflict<'tcx>(\n // Given that the bases of `elem1` and `elem2` are always either equal\n // or disjoint (and have the same type!), return the overlap situation\n // between `elem1` and `elem2`.\n-fn place_base_conflict<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    elem1: &PlaceBase<'tcx>,\n-    elem2: &PlaceBase<'tcx>,\n-) -> Overlap {\n-    match (elem1, elem2) {\n-        (PlaceBase::Local(l1), PlaceBase::Local(l2)) => {\n-            if l1 == l2 {\n-                // the same local - base case, equal\n-                debug!(\"place_element_conflict: DISJOINT-OR-EQ-LOCAL\");\n-                Overlap::EqualOrDisjoint\n-            } else {\n-                // different locals - base case, disjoint\n-                debug!(\"place_element_conflict: DISJOINT-LOCAL\");\n-                Overlap::Disjoint\n-            }\n-        }\n-        (PlaceBase::Static(s1), PlaceBase::Static(s2)) => {\n-            match (&s1.kind, &s2.kind) {\n-                (StaticKind::Static, StaticKind::Static) => {\n-                    if s1.def_id != s2.def_id {\n-                        debug!(\"place_element_conflict: DISJOINT-STATIC\");\n-                        Overlap::Disjoint\n-                    } else if tcx.is_mutable_static(s1.def_id) {\n-                        // We ignore mutable statics - they can only be unsafe code.\n-                        debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n-                        Overlap::Disjoint\n-                    } else {\n-                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-STATIC\");\n-                        Overlap::EqualOrDisjoint\n-                    }\n-                }\n-                (StaticKind::Promoted(promoted_1, _), StaticKind::Promoted(promoted_2, _)) => {\n-                    if promoted_1 == promoted_2 {\n-                        if let ty::Array(_, len) = s1.ty.kind {\n-                            if let Some(0) = len.try_eval_usize(tcx, param_env) {\n-                                // Ignore conflicts with promoted [T; 0].\n-                                debug!(\"place_element_conflict: IGNORE-LEN-0-PROMOTED\");\n-                                return Overlap::Disjoint;\n-                            }\n-                        }\n-                        // the same promoted - base case, equal\n-                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-PROMOTED\");\n-                        Overlap::EqualOrDisjoint\n-                    } else {\n-                        // different promoteds - base case, disjoint\n-                        debug!(\"place_element_conflict: DISJOINT-PROMOTED\");\n-                        Overlap::Disjoint\n-                    }\n-                }\n-                (_, _) => {\n-                    debug!(\"place_element_conflict: DISJOINT-STATIC-PROMOTED\");\n-                    Overlap::Disjoint\n-                }\n-            }\n-        }\n-        (PlaceBase::Local(_), PlaceBase::Static(_))\n-        | (PlaceBase::Static(_), PlaceBase::Local(_)) => {\n-            debug!(\"place_element_conflict: DISJOINT-STATIC-LOCAL-PROMOTED\");\n-            Overlap::Disjoint\n-        }\n+fn place_base_conflict(l1: &Local, l2: &Local) -> Overlap {\n+    if l1 == l2 {\n+        // the same local - base case, equal\n+        debug!(\"place_element_conflict: DISJOINT-OR-EQ-LOCAL\");\n+        Overlap::EqualOrDisjoint\n+    } else {\n+        // different locals - base case, disjoint\n+        debug!(\"place_element_conflict: DISJOINT-LOCAL\");\n+        Overlap::Disjoint\n     }\n }\n \n@@ -379,7 +311,7 @@ fn place_base_conflict<'tcx>(\n fn place_projection_conflict<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n-    pi1_base: &PlaceBase<'tcx>,\n+    pi1_local: &Local,\n     pi1_proj_base: &[PlaceElem<'tcx>],\n     pi1_elem: &PlaceElem<'tcx>,\n     pi2_elem: &PlaceElem<'tcx>,\n@@ -397,7 +329,7 @@ fn place_projection_conflict<'tcx>(\n                 debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n                 Overlap::EqualOrDisjoint\n             } else {\n-                let ty = Place::ty_from(pi1_base, pi1_proj_base, body, tcx).ty;\n+                let ty = Place::ty_from(pi1_local, pi1_proj_base, body, tcx).ty;\n                 match ty.kind {\n                     ty::Adt(def, _) if def.is_union() => {\n                         // Different fields of a union, we are basically stuck."}, {"sha": "31bee460fa0113f4a9be55e61c87062f0f4c0aad", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 20, "deletions": 51, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -9,7 +9,7 @@\n \n use super::MirBorrowckCtxt;\n \n-use rustc::mir::{Place, PlaceBase, PlaceRef, ProjectionElem, ReadOnlyBodyAndCache};\n+use rustc::mir::{Place, PlaceRef, ProjectionElem, ReadOnlyBodyAndCache};\n use rustc::ty::{self, TyCtxt};\n use rustc_hir as hir;\n \n@@ -19,7 +19,7 @@ pub trait IsPrefixOf<'cx, 'tcx> {\n \n impl<'cx, 'tcx> IsPrefixOf<'cx, 'tcx> for PlaceRef<'cx, 'tcx> {\n     fn is_prefix_of(&self, other: PlaceRef<'cx, 'tcx>) -> bool {\n-        self.base == other.base\n+        self.local == other.local\n             && self.projection.len() <= other.projection.len()\n             && self.projection == &other.projection[..self.projection.len()]\n     }\n@@ -69,39 +69,23 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n \n         'cursor: loop {\n             match &cursor {\n-                PlaceRef {\n-                    base: PlaceBase::Local(_),\n-                    projection: [],\n-                }\n-                | // search yielded this leaf\n-                PlaceRef {\n-                    base: PlaceBase::Static(_),\n-                    projection: [],\n-                } => {\n+                PlaceRef { local: _, projection: [] } => {\n                     self.next = None;\n                     return Some(cursor);\n                 }\n-                PlaceRef {\n-                    base: _,\n-                    projection: [proj_base @ .., elem],\n-                } => {\n+                PlaceRef { local: _, projection: [proj_base @ .., elem] } => {\n                     match elem {\n                         ProjectionElem::Field(_ /*field*/, _ /*ty*/) => {\n                             // FIXME: add union handling\n-                            self.next = Some(PlaceRef {\n-                                base: cursor.base,\n-                                projection: proj_base,\n-                            });\n+                            self.next =\n+                                Some(PlaceRef { local: cursor.local, projection: proj_base });\n                             return Some(cursor);\n                         }\n-                        ProjectionElem::Downcast(..) |\n-                        ProjectionElem::Subslice { .. } |\n-                        ProjectionElem::ConstantIndex { .. } |\n-                        ProjectionElem::Index(_) => {\n-                            cursor = PlaceRef {\n-                                base: cursor.base,\n-                                projection: proj_base,\n-                            };\n+                        ProjectionElem::Downcast(..)\n+                        | ProjectionElem::Subslice { .. }\n+                        | ProjectionElem::ConstantIndex { .. }\n+                        | ProjectionElem::Index(_) => {\n+                            cursor = PlaceRef { local: cursor.local, projection: proj_base };\n                             continue 'cursor;\n                         }\n                         ProjectionElem::Deref => {\n@@ -122,10 +106,8 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                         PrefixSet::All => {\n                             // All prefixes: just blindly enqueue the base\n                             // of the projection.\n-                            self.next = Some(PlaceRef {\n-                                base: cursor.base,\n-                                projection: proj_base,\n-                            });\n+                            self.next =\n+                                Some(PlaceRef { local: cursor.local, projection: proj_base });\n                             return Some(cursor);\n                         }\n                         PrefixSet::Supporting => {\n@@ -138,37 +120,24 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                     // derefs, except we stop at the deref of a shared\n                     // reference.\n \n-                    let ty = Place::ty_from(cursor.base, proj_base, *self.body, self.tcx).ty;\n+                    let ty = Place::ty_from(cursor.local, proj_base, *self.body, self.tcx).ty;\n                     match ty.kind {\n-                        ty::RawPtr(_) |\n-                        ty::Ref(\n-                            _, /*rgn*/\n-                            _, /*ty*/\n-                            hir::Mutability::Not\n-                            ) => {\n+                        ty::RawPtr(_) | ty::Ref(_ /*rgn*/, _ /*ty*/, hir::Mutability::Not) => {\n                             // don't continue traversing over derefs of raw pointers or shared\n                             // borrows.\n                             self.next = None;\n                             return Some(cursor);\n                         }\n \n-                        ty::Ref(\n-                            _, /*rgn*/\n-                            _, /*ty*/\n-                            hir::Mutability::Mut,\n-                            ) => {\n-                            self.next = Some(PlaceRef {\n-                                base: cursor.base,\n-                                projection: proj_base,\n-                            });\n+                        ty::Ref(_ /*rgn*/, _ /*ty*/, hir::Mutability::Mut) => {\n+                            self.next =\n+                                Some(PlaceRef { local: cursor.local, projection: proj_base });\n                             return Some(cursor);\n                         }\n \n                         ty::Adt(..) if ty.is_box() => {\n-                            self.next = Some(PlaceRef {\n-                                base: cursor.base,\n-                                projection: proj_base,\n-                            });\n+                            self.next =\n+                                Some(PlaceRef { local: cursor.local, projection: proj_base });\n                             return Some(cursor);\n                         }\n "}, {"sha": "947bbef4379f5ab780af9363246c4d620b623af6", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 70, "deletions": 84, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -310,17 +310,54 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                 );\n             }\n         } else {\n-            if let ty::ConstKind::Unevaluated(def_id, substs) = constant.literal.val {\n-                if let Err(terr) = self.cx.fully_perform_op(\n-                    location.to_locations(),\n-                    ConstraintCategory::Boring,\n-                    self.cx.param_env.and(type_op::ascribe_user_type::AscribeUserType::new(\n-                        constant.literal.ty,\n-                        def_id,\n-                        UserSubsts { substs, user_self_ty: None },\n-                    )),\n-                ) {\n-                    span_mirbug!(self, constant, \"bad constant type {:?} ({:?})\", constant, terr);\n+            if let ty::ConstKind::Unevaluated(def_id, substs, promoted) = constant.literal.val {\n+                if let Some(promoted) = promoted {\n+                    let check_err = |verifier: &mut TypeVerifier<'a, 'b, 'tcx>,\n+                                     promoted: &ReadOnlyBodyAndCache<'_, 'tcx>,\n+                                     ty,\n+                                     san_ty| {\n+                        if let Err(terr) = verifier.cx.eq_types(\n+                            san_ty,\n+                            ty,\n+                            location.to_locations(),\n+                            ConstraintCategory::Boring,\n+                        ) {\n+                            span_mirbug!(\n+                                verifier,\n+                                promoted,\n+                                \"bad promoted type ({:?}: {:?}): {:?}\",\n+                                ty,\n+                                san_ty,\n+                                terr\n+                            );\n+                        };\n+                    };\n+\n+                    if !self.errors_reported {\n+                        let promoted_body = self.promoted[promoted];\n+                        self.sanitize_promoted(promoted_body, location);\n+\n+                        let promoted_ty = promoted_body.return_ty();\n+                        check_err(self, &promoted_body, ty, promoted_ty);\n+                    }\n+                } else {\n+                    if let Err(terr) = self.cx.fully_perform_op(\n+                        location.to_locations(),\n+                        ConstraintCategory::Boring,\n+                        self.cx.param_env.and(type_op::ascribe_user_type::AscribeUserType::new(\n+                            constant.literal.ty,\n+                            def_id,\n+                            UserSubsts { substs, user_self_ty: None },\n+                        )),\n+                    ) {\n+                        span_mirbug!(\n+                            self,\n+                            constant,\n+                            \"bad constant type {:?} ({:?})\",\n+                            constant,\n+                            terr\n+                        );\n+                    }\n                 }\n             }\n             if let ty::FnDef(def_id, substs) = constant.literal.ty.kind {\n@@ -428,83 +465,32 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n     ) -> PlaceTy<'tcx> {\n         debug!(\"sanitize_place: {:?}\", place);\n \n-        let mut place_ty = match &place.base {\n-            PlaceBase::Local(index) => PlaceTy::from_ty(self.body.local_decls[*index].ty),\n-            PlaceBase::Static(box Static { kind, ty, def_id }) => {\n-                let san_ty = self.sanitize_type(place, ty);\n-                let check_err =\n-                    |verifier: &mut TypeVerifier<'a, 'b, 'tcx>, place: &Place<'tcx>, ty, san_ty| {\n-                        if let Err(terr) = verifier.cx.eq_types(\n-                            san_ty,\n-                            ty,\n-                            location.to_locations(),\n-                            ConstraintCategory::Boring,\n-                        ) {\n-                            span_mirbug!(\n-                                verifier,\n-                                place,\n-                                \"bad promoted type ({:?}: {:?}): {:?}\",\n-                                ty,\n-                                san_ty,\n-                                terr\n-                            );\n-                        };\n-                    };\n-                match kind {\n-                    StaticKind::Promoted(promoted, _) => {\n-                        if !self.errors_reported {\n-                            let promoted_body_cache = self.promoted[*promoted];\n-                            self.sanitize_promoted(promoted_body_cache, location);\n-\n-                            let promoted_ty = promoted_body_cache.return_ty();\n-                            check_err(self, place, promoted_ty, san_ty);\n-                        }\n-                    }\n-                    StaticKind::Static => {\n-                        let ty = self.tcx().type_of(*def_id);\n-                        let ty = self.cx.normalize(ty, location);\n-\n-                        check_err(self, place, ty, san_ty);\n-                    }\n-                }\n-                PlaceTy::from_ty(san_ty)\n-            }\n-        };\n+        let mut place_ty = PlaceTy::from_ty(self.body.local_decls[place.local].ty);\n \n         if place.projection.is_empty() {\n             if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n-                let is_promoted = match place.as_ref() {\n-                    PlaceRef {\n-                        base: &PlaceBase::Static(box Static { kind: StaticKind::Promoted(..), .. }),\n-                        projection: &[],\n-                    } => true,\n-                    _ => false,\n+                let tcx = self.tcx();\n+                let trait_ref = ty::TraitRef {\n+                    def_id: tcx.lang_items().copy_trait().unwrap(),\n+                    substs: tcx.mk_substs_trait(place_ty.ty, &[]),\n                 };\n \n-                if !is_promoted {\n-                    let tcx = self.tcx();\n-                    let trait_ref = ty::TraitRef {\n-                        def_id: tcx.lang_items().copy_trait().unwrap(),\n-                        substs: tcx.mk_substs_trait(place_ty.ty, &[]),\n-                    };\n-\n-                    // To have a `Copy` operand, the type `T` of the\n-                    // value must be `Copy`. Note that we prove that `T: Copy`,\n-                    // rather than using the `is_copy_modulo_regions`\n-                    // test. This is important because\n-                    // `is_copy_modulo_regions` ignores the resulting region\n-                    // obligations and assumes they pass. This can result in\n-                    // bounds from `Copy` impls being unsoundly ignored (e.g.,\n-                    // #29149). Note that we decide to use `Copy` before knowing\n-                    // whether the bounds fully apply: in effect, the rule is\n-                    // that if a value of some type could implement `Copy`, then\n-                    // it must.\n-                    self.cx.prove_trait_ref(\n-                        trait_ref,\n-                        location.to_locations(),\n-                        ConstraintCategory::CopyBound,\n-                    );\n-                }\n+                // To have a `Copy` operand, the type `T` of the\n+                // value must be `Copy`. Note that we prove that `T: Copy`,\n+                // rather than using the `is_copy_modulo_regions`\n+                // test. This is important because\n+                // `is_copy_modulo_regions` ignores the resulting region\n+                // obligations and assumes they pass. This can result in\n+                // bounds from `Copy` impls being unsoundly ignored (e.g.,\n+                // #29149). Note that we decide to use `Copy` before knowing\n+                // whether the bounds fully apply: in effect, the rule is\n+                // that if a value of some type could implement `Copy`, then\n+                // it must.\n+                self.cx.prove_trait_ref(\n+                    trait_ref,\n+                    location.to_locations(),\n+                    ConstraintCategory::CopyBound,\n+                );\n             }\n         }\n \n@@ -2401,7 +2387,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             match elem {\n                 ProjectionElem::Deref => {\n                     let tcx = self.infcx.tcx;\n-                    let base_ty = Place::ty_from(&borrowed_place.base, proj_base, body, tcx).ty;\n+                    let base_ty = Place::ty_from(&borrowed_place.local, proj_base, body, tcx).ty;\n \n                     debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n                     match base_ty.kind {"}, {"sha": "5e4eebb771f21d8a6cf5e26fac8cbeed481f9e49", "filename": "src/librustc_mir/borrow_check/used_muts.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -1,5 +1,5 @@\n use rustc::mir::visit::{PlaceContext, Visitor};\n-use rustc::mir::{Local, Location, Place, PlaceBase, Statement, StatementKind, TerminatorKind};\n+use rustc::mir::{Local, Location, Place, Statement, StatementKind, TerminatorKind};\n \n use rustc_data_structures::fx::FxHashSet;\n \n@@ -57,9 +57,7 @@ impl GatherUsedMutsVisitor<'_, '_, '_> {\n         // be those that were never initialized - we will consider those as being used as\n         // they will either have been removed by unreachable code optimizations; or linted\n         // as unused variables.\n-        if let PlaceBase::Local(local) = into.base {\n-            let _ = self.never_initialized_mut_locals.remove(&local);\n-        }\n+        self.never_initialized_mut_locals.remove(&into.local);\n     }\n }\n \n@@ -80,13 +78,11 @@ impl<'visit, 'cx, 'tcx> Visitor<'tcx> for GatherUsedMutsVisitor<'visit, 'cx, 'tc\n     fn visit_statement(&mut self, statement: &Statement<'tcx>, _location: Location) {\n         match &statement.kind {\n             StatementKind::Assign(box (into, _)) => {\n-                if let PlaceBase::Local(local) = into.base {\n-                    debug!(\n-                        \"visit_statement: statement={:?} local={:?} \\\n-                         never_initialized_mut_locals={:?}\",\n-                        statement, local, self.never_initialized_mut_locals\n-                    );\n-                }\n+                debug!(\n+                    \"visit_statement: statement={:?} local={:?} \\\n+                    never_initialized_mut_locals={:?}\",\n+                    statement, into.local, self.never_initialized_mut_locals\n+                );\n                 self.remove_never_initialized_mut_locals(into);\n             }\n             _ => {}"}, {"sha": "eb2e87f4a2d419526f89154dfcb9de6e4707b567", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -20,13 +20,13 @@ use rustc_index::vec::Idx;\n /// and `c` can be progressively pushed onto the place builder that is created when converting `a`.\n #[derive(Clone)]\n struct PlaceBuilder<'tcx> {\n-    base: PlaceBase<'tcx>,\n+    local: Local,\n     projection: Vec<PlaceElem<'tcx>>,\n }\n \n impl PlaceBuilder<'tcx> {\n     fn into_place(self, tcx: TyCtxt<'tcx>) -> Place<'tcx> {\n-        Place { base: self.base, projection: tcx.intern_place_elems(&self.projection) }\n+        Place { local: self.local, projection: tcx.intern_place_elems(&self.projection) }\n     }\n \n     fn field(self, f: Field, ty: Ty<'tcx>) -> Self {\n@@ -49,13 +49,7 @@ impl PlaceBuilder<'tcx> {\n \n impl From<Local> for PlaceBuilder<'tcx> {\n     fn from(local: Local) -> Self {\n-        Self { base: local.into(), projection: Vec::new() }\n-    }\n-}\n-\n-impl From<PlaceBase<'tcx>> for PlaceBuilder<'tcx> {\n-    fn from(base: PlaceBase<'tcx>) -> Self {\n-        Self { base, projection: Vec::new() }\n+        Self { local, projection: Vec::new() }\n     }\n }\n \n@@ -370,7 +364,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ) {\n         let tcx = self.hir.tcx();\n         let place_ty =\n-            Place::ty_from(&base_place.base, &base_place.projection, &self.local_decls, tcx);\n+            Place::ty_from(&base_place.local, &base_place.projection, &self.local_decls, tcx);\n         if let ty::Slice(_) = place_ty.ty.kind {\n             // We need to create fake borrows to ensure that the bounds\n             // check that we just did stays valid. Since we can't assign to\n@@ -380,7 +374,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 match elem {\n                     ProjectionElem::Deref => {\n                         let fake_borrow_deref_ty = Place::ty_from(\n-                            &base_place.base,\n+                            &base_place.local,\n                             &base_place.projection[..idx],\n                             &self.local_decls,\n                             tcx,\n@@ -398,14 +392,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             Rvalue::Ref(\n                                 tcx.lifetimes.re_erased,\n                                 BorrowKind::Shallow,\n-                                Place { base: base_place.base.clone(), projection },\n+                                Place { local: base_place.local.clone(), projection },\n                             ),\n                         );\n                         fake_borrow_temps.push(fake_borrow_temp);\n                     }\n                     ProjectionElem::Index(_) => {\n                         let index_ty = Place::ty_from(\n-                            &base_place.base,\n+                            &base_place.local,\n                             &base_place.projection[..idx],\n                             &self.local_decls,\n                             tcx,"}, {"sha": "6f7b7258b5a1acb4e00acb1681b511ddf7c62727", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -393,26 +393,24 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let arg_place = unpack!(block = this.as_place(block, arg));\n \n         let mutability = match arg_place.as_ref() {\n-            PlaceRef { base: &PlaceBase::Local(local), projection: &[] } => {\n-                this.local_decls[local].mutability\n-            }\n-            PlaceRef { base: &PlaceBase::Local(local), projection: &[ProjectionElem::Deref] } => {\n+            PlaceRef { local, projection: &[] } => this.local_decls[*local].mutability,\n+            PlaceRef { local, projection: &[ProjectionElem::Deref] } => {\n                 debug_assert!(\n-                    this.local_decls[local].is_ref_for_guard(),\n+                    this.local_decls[*local].is_ref_for_guard(),\n                     \"Unexpected capture place\",\n                 );\n-                this.local_decls[local].mutability\n+                this.local_decls[*local].mutability\n             }\n             PlaceRef {\n-                ref base,\n+                ref local,\n                 projection: &[ref proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             }\n             | PlaceRef {\n-                ref base,\n+                ref local,\n                 projection:\n                     &[ref proj_base @ .., ProjectionElem::Field(upvar_index, _), ProjectionElem::Deref],\n             } => {\n-                let place = PlaceRef { base, projection: proj_base };\n+                let place = PlaceRef { local, projection: proj_base };\n \n                 // Not projected from the implicit `self` in a closure.\n                 debug_assert!("}, {"sha": "1dcd29d923244b3a5045396380d2600d88e8354e", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -890,7 +890,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     let proj_base = &source.projection[..i];\n \n                     fake_borrows.insert(Place {\n-                        base: source.base.clone(),\n+                        local: source.local.clone(),\n                         projection: self.hir.tcx().intern_place_elems(proj_base),\n                     });\n                 }\n@@ -1241,7 +1241,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     // Insert a shallow borrow after a deref. For other\n                     // projections the borrow of prefix_cursor will\n                     // conflict with any mutation of base.\n-                    all_fake_borrows.push(PlaceRef { base: &place.base, projection: proj_base });\n+                    all_fake_borrows.push(PlaceRef { local: &place.local, projection: proj_base });\n                 }\n             }\n \n@@ -1258,7 +1258,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             .into_iter()\n             .map(|matched_place_ref| {\n                 let matched_place = Place {\n-                    base: matched_place_ref.base.clone(),\n+                    local: matched_place_ref.local.clone(),\n                     projection: tcx.intern_place_elems(matched_place_ref.projection),\n                 };\n                 let fake_borrow_deref_ty = matched_place.ty(&self.local_decls, tcx).ty;"}, {"sha": "d4813d8ab68ca3ba3fe0f1d0c47ea6803ffa49c7", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -834,7 +834,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             span: tcx_hir.span(var_id),\n                         },\n                         place: Place {\n-                            base: closure_env_arg.into(),\n+                            local: closure_env_arg.into(),\n                             projection: tcx.intern_place_elems(&projs),\n                         },\n                     });"}, {"sha": "eb89553b770360531bbd6deed6430452c7a58dd7", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -52,7 +52,7 @@ pub(crate) fn const_caller_location<'tcx>(\n \n     let loc_ty = tcx.caller_location_ty();\n     let loc_place = ecx.alloc_caller_location(file, line, col);\n-    intern_const_alloc_recursive(&mut ecx, None, loc_place).unwrap();\n+    intern_const_alloc_recursive(&mut ecx, None, loc_place, false).unwrap();\n     let loc_const = ty::Const {\n         ty: loc_ty,\n         val: ty::ConstKind::Value(ConstValue::Scalar(loc_place.ptr.into())),"}, {"sha": "d260a6808d120dc37929a59a53e7b1bf750627e0", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -56,7 +56,12 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     ecx.run()?;\n \n     // Intern the result\n-    intern_const_alloc_recursive(ecx, tcx.static_mutability(cid.instance.def_id()), ret)?;\n+    intern_const_alloc_recursive(\n+        ecx,\n+        tcx.static_mutability(cid.instance.def_id()),\n+        ret,\n+        body.ignore_interior_mut_in_const_validation,\n+    )?;\n \n     debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n     Ok(ret)\n@@ -171,9 +176,14 @@ fn validate_and_turn_into_const<'tcx>(\n     let ecx = mk_eval_cx(tcx, tcx.def_span(key.value.instance.def_id()), key.param_env, is_static);\n     let val = (|| {\n         let mplace = ecx.raw_const_to_mplace(constant)?;\n-        let mut ref_tracking = RefTracking::new(mplace);\n-        while let Some((mplace, path)) = ref_tracking.todo.pop() {\n-            ecx.validate_operand(mplace.into(), path, Some(&mut ref_tracking))?;\n+\n+        // FIXME do not validate promoteds until a decision on\n+        // https://github.com/rust-lang/rust/issues/67465 is made\n+        if cid.promoted.is_none() {\n+            let mut ref_tracking = RefTracking::new(mplace);\n+            while let Some((mplace, path)) = ref_tracking.todo.pop() {\n+                ecx.validate_operand(mplace.into(), path, Some(&mut ref_tracking))?;\n+            }\n         }\n         // Now that we validated, turn this into a proper constant.\n         // Statics/promoteds are always `ByRef`, for the rest `op_to_const` decides"}, {"sha": "63834d0ecda00215a26601e183d944a998541ae7", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -86,10 +86,7 @@ struct BorrowedLocalsVisitor<'gk> {\n }\n \n fn find_local(place: &Place<'_>) -> Option<Local> {\n-    match place.base {\n-        PlaceBase::Local(local) if !place.is_indirect() => Some(local),\n-        _ => None,\n-    }\n+    if !place.is_indirect() { Some(place.local) } else { None }\n }\n \n impl<'tcx> Visitor<'tcx> for BorrowedLocalsVisitor<'_> {"}, {"sha": "f94ee67f2bea7c72d2aab2138bd9d8ddea1b33a3", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 27, "deletions": 33, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -1,6 +1,6 @@\n-use rustc::mir::{self, Body, Location, Place, PlaceBase};\n+use rustc::mir::{self, Body, Location, Place};\n use rustc::ty::RegionVid;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::TyCtxt;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::bit_set::BitSet;\n@@ -30,7 +30,6 @@ rustc_index::newtype_index! {\n pub struct Borrows<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n \n     borrow_set: Rc<BorrowSet<'tcx>>,\n     borrows_out_of_scope_at_location: FxHashMap<Location, Vec<BorrowIndex>>,\n@@ -134,7 +133,6 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n     crate fn new(\n         tcx: TyCtxt<'tcx>,\n         body: &'a Body<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n         nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n         borrow_set: &Rc<BorrowSet<'tcx>>,\n     ) -> Self {\n@@ -156,7 +154,6 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n         Borrows {\n             tcx,\n             body,\n-            param_env,\n             borrow_set: borrow_set.clone(),\n             borrows_out_of_scope_at_location,\n             _nonlexical_regioncx: nonlexical_regioncx,\n@@ -198,37 +195,34 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n     fn kill_borrows_on_place(&self, trans: &mut GenKillSet<BorrowIndex>, place: &Place<'tcx>) {\n         debug!(\"kill_borrows_on_place: place={:?}\", place);\n \n-        if let PlaceBase::Local(local) = place.base {\n-            let other_borrows_of_local =\n-                self.borrow_set.local_map.get(&local).into_iter().flat_map(|bs| bs.into_iter());\n+        let other_borrows_of_local =\n+            self.borrow_set.local_map.get(&place.local).into_iter().flat_map(|bs| bs.into_iter());\n \n-            // If the borrowed place is a local with no projections, all other borrows of this\n-            // local must conflict. This is purely an optimization so we don't have to call\n-            // `places_conflict` for every borrow.\n-            if place.projection.is_empty() {\n-                if !self.body.local_decls[local].is_ref_to_static() {\n-                    trans.kill_all(other_borrows_of_local);\n-                }\n-                return;\n+        // If the borrowed place is a local with no projections, all other borrows of this\n+        // local must conflict. This is purely an optimization so we don't have to call\n+        // `places_conflict` for every borrow.\n+        if place.projection.is_empty() {\n+            if !self.body.local_decls[place.local].is_ref_to_static() {\n+                trans.kill_all(other_borrows_of_local);\n             }\n-\n-            // By passing `PlaceConflictBias::NoOverlap`, we conservatively assume that any given\n-            // pair of array indices are unequal, so that when `places_conflict` returns true, we\n-            // will be assured that two places being compared definitely denotes the same sets of\n-            // locations.\n-            let definitely_conflicting_borrows = other_borrows_of_local.filter(|&&i| {\n-                places_conflict(\n-                    self.tcx,\n-                    self.param_env,\n-                    self.body,\n-                    &self.borrow_set.borrows[i].borrowed_place,\n-                    place,\n-                    PlaceConflictBias::NoOverlap,\n-                )\n-            });\n-\n-            trans.kill_all(definitely_conflicting_borrows);\n+            return;\n         }\n+\n+        // By passing `PlaceConflictBias::NoOverlap`, we conservatively assume that any given\n+        // pair of array indices are unequal, so that when `places_conflict` returns true, we\n+        // will be assured that two places being compared definitely denotes the same sets of\n+        // locations.\n+        let definitely_conflicting_borrows = other_borrows_of_local.filter(|&&i| {\n+            places_conflict(\n+                self.tcx,\n+                self.body,\n+                &self.borrow_set.borrows[i].borrowed_place,\n+                place,\n+                PlaceConflictBias::NoOverlap,\n+            )\n+        });\n+\n+        trans.kill_all(definitely_conflicting_borrows);\n     }\n }\n "}, {"sha": "85bf342c8a39a95da5efd20d1367a1656cd88247", "filename": "src/librustc_mir/dataflow/impls/indirect_mutation.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Findirect_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Findirect_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Findirect_mutation.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -111,12 +111,8 @@ impl<'tcx> Visitor<'tcx> for TransferFunction<'_, '_, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &mir::Rvalue<'tcx>, location: Location) {\n         if let mir::Rvalue::Ref(_, kind, ref borrowed_place) = *rvalue {\n             if self.borrow_allows_mutation(kind, borrowed_place) {\n-                match borrowed_place.base {\n-                    mir::PlaceBase::Local(borrowed_local) if !borrowed_place.is_indirect() => {\n-                        self.trans.gen(borrowed_local)\n-                    }\n-\n-                    _ => (),\n+                if !borrowed_place.is_indirect() {\n+                    self.trans.gen(borrowed_place.local);\n                 }\n             }\n         }"}, {"sha": "6a48d1e98032c0d92426e1b7ae2d8e9b3e2c9144", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -116,15 +116,11 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n             StatementKind::StorageDead(l) => sets.kill(l),\n             StatementKind::Assign(box (ref place, _))\n             | StatementKind::SetDiscriminant { box ref place, .. } => {\n-                if let PlaceBase::Local(local) = place.base {\n-                    sets.gen(local);\n-                }\n+                sets.gen(place.local);\n             }\n             StatementKind::InlineAsm(box InlineAsm { ref outputs, .. }) => {\n-                for p in &**outputs {\n-                    if let PlaceBase::Local(local) = p.base {\n-                        sets.gen(local);\n-                    }\n+                for place in &**outputs {\n+                    sets.gen(place.local);\n                 }\n             }\n             _ => (),\n@@ -140,10 +136,8 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n     fn before_terminator_effect(&self, sets: &mut GenKillSet<Local>, loc: Location) {\n         self.check_for_borrow(sets, loc);\n \n-        if let TerminatorKind::Call {\n-            destination: Some((Place { base: PlaceBase::Local(local), .. }, _)),\n-            ..\n-        } = self.body[loc.block].terminator().kind\n+        if let TerminatorKind::Call { destination: Some((Place { local, .. }, _)), .. } =\n+            self.body[loc.block].terminator().kind\n         {\n             sets.gen(local);\n         }\n@@ -171,9 +165,7 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n         _dest_bb: mir::BasicBlock,\n         dest_place: &mir::Place<'tcx>,\n     ) {\n-        if let PlaceBase::Local(local) = dest_place.base {\n-            in_out.insert(local);\n-        }\n+        in_out.insert(dest_place.local);\n     }\n }\n "}, {"sha": "271bcce6ca53c3873c08dbb559b06854432032b3", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -96,12 +96,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n     /// Maybe we should have separate \"borrowck\" and \"moveck\" modes.\n     fn move_path_for(&mut self, place: &Place<'tcx>) -> Result<MovePathIndex, MoveError<'tcx>> {\n         debug!(\"lookup({:?})\", place);\n-        let mut base = match place.base {\n-            PlaceBase::Local(local) => self.builder.data.rev_lookup.locals[local],\n-            PlaceBase::Static(..) => {\n-                return Err(MoveError::cannot_move_out_of(self.loc, Static));\n-            }\n-        };\n+        let mut base = self.builder.data.rev_lookup.locals[place.local];\n \n         // The move path index of the first union that we find. Once this is\n         // some we stop creating child move paths, since moves from unions\n@@ -114,15 +109,15 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             let proj_base = &place.projection[..i];\n             let body = self.builder.body;\n             let tcx = self.builder.tcx;\n-            let place_ty = Place::ty_from(&place.base, proj_base, body, tcx).ty;\n+            let place_ty = Place::ty_from(&place.local, proj_base, body, tcx).ty;\n             match place_ty.kind {\n                 ty::Ref(..) | ty::RawPtr(..) => {\n                     let proj = &place.projection[..i + 1];\n                     return Err(MoveError::cannot_move_out_of(\n                         self.loc,\n                         BorrowedContent {\n                             target_place: Place {\n-                                base: place.base.clone(),\n+                                local: place.local,\n                                 projection: tcx.intern_place_elems(proj),\n                             },\n                         },\n@@ -163,7 +158,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n \n             if union_path.is_none() {\n                 base = self.add_move_path(base, elem, |tcx| Place {\n-                    base: place.base.clone(),\n+                    local: place.local.clone(),\n                     projection: tcx.intern_place_elems(&place.projection[..i + 1]),\n                 });\n             }\n@@ -436,7 +431,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             // `ConstIndex` patterns. This is done to ensure that all move paths\n             // are disjoint, which is expected by drop elaboration.\n             let base_place = Place {\n-                base: place.base.clone(),\n+                local: place.local.clone(),\n                 projection: self.builder.tcx.intern_place_elems(base),\n             };\n             let base_path = match self.move_path_for(&base_place) {\n@@ -497,10 +492,10 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n         // of the union so it is marked as initialized again.\n         if let [proj_base @ .., ProjectionElem::Field(_, _)] = place.projection {\n             if let ty::Adt(def, _) =\n-                Place::ty_from(place.base, proj_base, self.builder.body, self.builder.tcx).ty.kind\n+                Place::ty_from(place.local, proj_base, self.builder.body, self.builder.tcx).ty.kind\n             {\n                 if def.is_union() {\n-                    place = PlaceRef { base: place.base, projection: proj_base }\n+                    place = PlaceRef { local: place.local, projection: proj_base }\n                 }\n             }\n         }"}, {"sha": "a46465ab4937646b5b744f1bc77f016275cc23fd", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -246,10 +246,7 @@ impl MovePathLookup {\n     // unknown place, but will rather return the nearest available\n     // parent.\n     pub fn find(&self, place: PlaceRef<'_, '_>) -> LookupResult {\n-        let mut result = match place.base {\n-            PlaceBase::Local(local) => self.locals[*local],\n-            PlaceBase::Static(..) => return LookupResult::Parent(None),\n-        };\n+        let mut result = self.locals[*place.local];\n \n         for elem in place.projection.iter() {\n             if let Some(&subpath) = self.projections.get(&(result, elem.lift())) {\n@@ -281,9 +278,6 @@ pub struct IllegalMoveOrigin<'tcx> {\n \n #[derive(Debug)]\n pub(crate) enum IllegalMoveOriginKind<'tcx> {\n-    /// Illegal move due to attempt to move from `static` variable.\n-    Static,\n-\n     /// Illegal move due to attempt to move from behind a reference.\n     BorrowedContent {\n         /// The place the reference refers to: if erroneous code was trying to"}, {"sha": "471e09fc03b28ca914c2a19bc12a65caac3d1e0b", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -411,15 +411,18 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n             let def_id = cx.tcx.hir().local_def_id(count.hir_id);\n             let substs = InternalSubsts::identity_for_item(cx.tcx, def_id);\n             let span = cx.tcx.def_span(def_id);\n-            let count = match cx.tcx.const_eval_resolve(cx.param_env, def_id, substs, Some(span)) {\n-                Ok(cv) => cv.eval_usize(cx.tcx, cx.param_env),\n-                Err(ErrorHandled::Reported) => 0,\n-                Err(ErrorHandled::TooGeneric) => {\n-                    let span = cx.tcx.def_span(def_id);\n-                    cx.tcx.sess.span_err(span, \"array lengths can't depend on generic parameters\");\n-                    0\n-                }\n-            };\n+            let count =\n+                match cx.tcx.const_eval_resolve(cx.param_env, def_id, substs, None, Some(span)) {\n+                    Ok(cv) => cv.eval_usize(cx.tcx, cx.param_env),\n+                    Err(ErrorHandled::Reported) => 0,\n+                    Err(ErrorHandled::TooGeneric) => {\n+                        let span = cx.tcx.def_span(def_id);\n+                        cx.tcx\n+                            .sess\n+                            .span_err(span, \"array lengths can't depend on generic parameters\");\n+                        0\n+                    }\n+                };\n \n             ExprKind::Repeat { value: v.to_ref(), count }\n         }\n@@ -523,7 +526,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                             // and not the beginning of discriminants (which is always `0`)\n                             let substs = InternalSubsts::identity_for_item(cx.tcx(), did);\n                             let lhs = mk_const(cx.tcx().mk_const(ty::Const {\n-                                val: ty::ConstKind::Unevaluated(did, substs),\n+                                val: ty::ConstKind::Unevaluated(did, substs, None),\n                                 ty: var_ty,\n                             }));\n                             let bin = ExprKind::Binary { op: BinOp::Add, lhs, rhs: offset };\n@@ -719,7 +722,7 @@ fn convert_path_expr<'a, 'tcx>(\n             debug!(\"convert_path_expr: (const) user_ty={:?}\", user_ty);\n             ExprKind::Literal {\n                 literal: cx.tcx.mk_const(ty::Const {\n-                    val: ty::ConstKind::Unevaluated(def_id, substs),\n+                    val: ty::ConstKind::Unevaluated(def_id, substs, None),\n                     ty: cx.tables().node_type(expr.hir_id),\n                 }),\n                 user_ty,"}, {"sha": "c7e26c6ea4fd42b4830fadec5b90ac4721e57ce8", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -775,6 +775,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                     self.param_env.with_reveal_all(),\n                     def_id,\n                     substs,\n+                    None,\n                     Some(span),\n                 ) {\n                     Ok(value) => {"}, {"sha": "206d3d156735ec758b952e3dc5df5f06e5322511", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -757,13 +757,22 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         gid: GlobalId<'tcx>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        let val = if self.tcx.is_static(gid.instance.def_id()) {\n-            self.tcx.const_eval_poly(gid.instance.def_id())?\n-        } else if let Some(promoted) = gid.promoted {\n-            self.tcx.const_eval_promoted(gid.instance, promoted)?\n+        // For statics we pick `ParamEnv::reveal_all`, because statics don't have generics\n+        // and thus don't care about the parameter environment. While we could just use\n+        // `self.param_env`, that would mean we invoke the query to evaluate the static\n+        // with different parameter environments, thus causing the static to be evaluated\n+        // multiple times.\n+        let param_env = if self.tcx.is_static(gid.instance.def_id()) {\n+            ty::ParamEnv::reveal_all()\n         } else {\n-            self.tcx.const_eval_instance(self.param_env, gid.instance, Some(self.tcx.span))?\n+            self.param_env\n         };\n+        let val = if let Some(promoted) = gid.promoted {\n+            self.tcx.const_eval_promoted(param_env, gid.instance, promoted)?\n+        } else {\n+            self.tcx.const_eval_instance(param_env, gid.instance, Some(self.tcx.span))?\n+        };\n+\n         // Even though `ecx.const_eval` is called from `eval_const_to_op` we can never have a\n         // recursion deeper than one level, because the `tcx.const_eval` above is guaranteed to not\n         // return `ConstValue::Unevaluated`, which is the only way that `eval_const_to_op` will call"}, {"sha": "220761ce28d81db842b5bbb6dacc798d422c14e1", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -41,6 +41,11 @@ struct InternVisitor<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> {\n     /// despite the nested mutable reference!\n     /// The field gets updated when an `UnsafeCell` is encountered.\n     mutability: Mutability,\n+\n+    /// This flag is to avoid triggering UnsafeCells are not allowed behind references in constants\n+    /// for promoteds.\n+    /// It's a copy of `mir::Body`'s ignore_interior_mut_in_const_validation field\n+    ignore_interior_mut_in_const_validation: bool,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Hash, Eq)]\n@@ -164,14 +169,16 @@ impl<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx\n                 // References we encounter inside here are interned as pointing to mutable\n                 // allocations.\n                 let old = std::mem::replace(&mut self.mutability, Mutability::Mut);\n-                assert_ne!(\n-                    self.mode,\n-                    InternMode::Const,\n-                    \"UnsafeCells are not allowed behind references in constants. This should have \\\n-                    been prevented statically by const qualification. If this were allowed one \\\n-                    would be able to change a constant at one use site and other use sites could \\\n-                    observe that mutation.\",\n-                );\n+                if !self.ignore_interior_mut_in_const_validation {\n+                    assert_ne!(\n+                        self.mode,\n+                        InternMode::Const,\n+                        \"UnsafeCells are not allowed behind references in constants. This should \\\n+                        have been prevented statically by const qualification. If this were \\\n+                        allowed one would be able to change a constant at one use site and other \\\n+                        use sites could observe that mutation.\",\n+                    );\n+                }\n                 let walked = self.walk_aggregate(mplace, fields);\n                 self.mutability = old;\n                 return walked;\n@@ -266,6 +273,7 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n     // The `mutability` of the place, ignoring the type.\n     place_mut: Option<hir::Mutability>,\n     ret: MPlaceTy<'tcx>,\n+    ignore_interior_mut_in_const_validation: bool,\n ) -> InterpResult<'tcx> {\n     let tcx = ecx.tcx;\n     let (base_mutability, base_intern_mode) = match place_mut {\n@@ -302,6 +310,7 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n             mode,\n             leftover_allocations,\n             mutability,\n+            ignore_interior_mut_in_const_validation,\n         }\n         .visit_value(mplace);\n         if let Err(error) = interned {"}, {"sha": "3309e9b9b622ae8d33360cd831dcfeef82191dbe", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -212,7 +212,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         frame.locals[local].access()\n     }\n \n-    /// Called before a `StaticKind::Static` value is accessed.\n+    /// Called before a `Static` value is accessed.\n     fn before_access_static(\n         _memory_extra: &Self::MemoryExtra,\n         _allocation: &Allocation,"}, {"sha": "b37eff3f40626a44691236aebd04761982d09822", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -462,19 +462,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         place: &mir::Place<'tcx>,\n         layout: Option<TyLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        use rustc::mir::PlaceBase;\n-\n-        let base_op = match &place.base {\n-            PlaceBase::Local(mir::RETURN_PLACE) => throw_unsup!(ReadFromReturnPointer),\n-            PlaceBase::Local(local) => {\n+        let base_op = match place.local {\n+            mir::RETURN_PLACE => throw_unsup!(ReadFromReturnPointer),\n+            local => {\n                 // Do not use the layout passed in as argument if the base we are looking at\n                 // here is not the entire place.\n-                // FIXME use place_projection.is_empty() when is available\n                 let layout = if place.projection.is_empty() { layout } else { None };\n \n-                self.access_local(self.frame(), *local, layout)?\n+                self.access_local(self.frame(), local, layout)?\n             }\n-            PlaceBase::Static(place_static) => self.eval_static_to_mplace(&place_static)?.into(),\n         };\n \n         let op = place\n@@ -532,17 +528,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Early-return cases.\n         let val_val = match val.val {\n             ty::ConstKind::Param(_) => throw_inval!(TooGeneric),\n-            ty::ConstKind::Unevaluated(def_id, substs) => {\n+            ty::ConstKind::Unevaluated(def_id, substs, promoted) => {\n                 let instance = self.resolve(def_id, substs)?;\n                 // We use `const_eval` here and `const_eval_raw` elsewhere in mir interpretation.\n                 // The reason we use `const_eval_raw` everywhere else is to prevent cycles during\n                 // validation, because validation automatically reads through any references, thus\n                 // potentially requiring the current static to be evaluated again. This is not a\n                 // problem here, because we are building an operand which means an actual read is\n                 // happening.\n-                // FIXME(oli-obk): eliminate all the `const_eval_raw` usages when we get rid of\n-                // `StaticKind` once and for all.\n-                return self.const_eval(GlobalId { instance, promoted: None });\n+                return Ok(OpTy::from(self.const_eval(GlobalId { instance, promoted })?));\n             }\n             ty::ConstKind::Infer(..)\n             | ty::ConstKind::Bound(..)"}, {"sha": "8888e3fd4632a2a3e1549dea0f646c29e537257f", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 8, "deletions": 60, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -10,14 +10,13 @@ use rustc::mir::interpret::truncate;\n use rustc::ty::layout::{\n     self, Align, HasDataLayout, LayoutOf, PrimitiveExt, Size, TyLayout, VariantIdx,\n };\n-use rustc::ty::TypeFoldable;\n use rustc::ty::{self, Ty};\n use rustc_macros::HashStable;\n \n use super::{\n-    AllocId, AllocMap, Allocation, AllocationExtra, GlobalId, ImmTy, Immediate, InterpCx,\n-    InterpResult, LocalValue, Machine, MemoryKind, OpTy, Operand, Pointer, PointerArithmetic,\n-    RawConst, Scalar, ScalarMaybeUndef,\n+    AllocId, AllocMap, Allocation, AllocationExtra, ImmTy, Immediate, InterpCx, InterpResult,\n+    LocalValue, Machine, MemoryKind, OpTy, Operand, Pointer, PointerArithmetic, RawConst, Scalar,\n+    ScalarMaybeUndef,\n };\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n@@ -619,64 +618,14 @@ where\n         })\n     }\n \n-    /// Evaluate statics and promoteds to an `MPlace`. Used to share some code between\n-    /// `eval_place` and `eval_place_to_op`.\n-    pub(super) fn eval_static_to_mplace(\n-        &self,\n-        place_static: &mir::Static<'tcx>,\n-    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n-        use rustc::mir::StaticKind;\n-\n-        Ok(match place_static.kind {\n-            StaticKind::Promoted(promoted, promoted_substs) => {\n-                let substs = self.subst_from_frame_and_normalize_erasing_regions(promoted_substs);\n-                let instance = ty::Instance::new(place_static.def_id, substs);\n-\n-                // Even after getting `substs` from the frame, this instance may still be\n-                // polymorphic because `ConstProp` will try to promote polymorphic MIR.\n-                if instance.needs_subst() {\n-                    throw_inval!(TooGeneric);\n-                }\n-\n-                self.const_eval_raw(GlobalId { instance, promoted: Some(promoted) })?\n-            }\n-\n-            StaticKind::Static => {\n-                let ty = place_static.ty;\n-                assert!(!ty.needs_subst());\n-                let layout = self.layout_of(ty)?;\n-                // Just create a lazy reference, so we can support recursive statics.\n-                // tcx takes care of assigning every static one and only one unique AllocId.\n-                // When the data here is ever actually used, memory will notice,\n-                // and it knows how to deal with alloc_id that are present in the\n-                // global table but not in its local memory: It calls back into tcx through\n-                // a query, triggering the CTFE machinery to actually turn this lazy reference\n-                // into a bunch of bytes.  IOW, statics are evaluated with CTFE even when\n-                // this InterpCx uses another Machine (e.g., in miri).  This is what we\n-                // want!  This way, computing statics works consistently between codegen\n-                // and miri: They use the same query to eventually obtain a `ty::Const`\n-                // and use that for further computation.\n-                //\n-                // Notice that statics have *two* AllocIds: the lazy one, and the resolved\n-                // one.  Here we make sure that the interpreted program never sees the\n-                // resolved ID.  Also see the doc comment of `Memory::get_static_alloc`.\n-                let alloc_id = self.tcx.alloc_map.lock().create_static_alloc(place_static.def_id);\n-                let ptr = self.tag_static_base_pointer(Pointer::from(alloc_id));\n-                MPlaceTy::from_aligned_ptr(ptr, layout)\n-            }\n-        })\n-    }\n-\n     /// Computes a place. You should only use this if you intend to write into this\n     /// place; for reading, a more efficient alternative is `eval_place_for_read`.\n     pub fn eval_place(\n         &mut self,\n         place: &mir::Place<'tcx>,\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n-        use rustc::mir::PlaceBase;\n-\n-        let mut place_ty = match &place.base {\n-            PlaceBase::Local(mir::RETURN_PLACE) => {\n+        let mut place_ty = match place.local {\n+            mir::RETURN_PLACE => {\n                 // `return_place` has the *caller* layout, but we want to use our\n                 // `layout to verify our assumption. The caller will validate\n                 // their layout on return.\n@@ -697,12 +646,11 @@ where\n                     ))?,\n                 }\n             }\n-            PlaceBase::Local(local) => PlaceTy {\n+            local => PlaceTy {\n                 // This works even for dead/uninitialized locals; we check further when writing\n-                place: Place::Local { frame: self.cur_frame(), local: *local },\n-                layout: self.layout_of_local(self.frame(), *local, None)?,\n+                place: Place::Local { frame: self.cur_frame(), local: local },\n+                layout: self.layout_of_local(self.frame(), local, None)?,\n             },\n-            PlaceBase::Static(place_static) => self.eval_static_to_mplace(&place_static)?.into(),\n         };\n \n         for elem in place.projection.iter() {"}, {"sha": "f5f00c9343561dd318954d91df45fe9258fa2be5", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 6, "deletions": 35, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -182,11 +182,11 @@ use rustc::mir::interpret::{AllocId, ConstValue};\n use rustc::mir::interpret::{ErrorHandled, GlobalAlloc, Scalar};\n use rustc::mir::mono::{InstantiationMode, MonoItem};\n use rustc::mir::visit::Visitor as MirVisitor;\n-use rustc::mir::{self, Location, PlaceBase, Static, StaticKind};\n+use rustc::mir::{self, Local, Location};\n use rustc::session::config::EntryFnType;\n use rustc::ty::adjustment::{CustomCoerceUnsized, PointerCast};\n use rustc::ty::print::obsolete::DefPathBasedNames;\n-use rustc::ty::subst::{InternalSubsts, Subst, SubstsRef};\n+use rustc::ty::subst::{InternalSubsts, SubstsRef};\n use rustc::ty::{self, GenericParamDefKind, Instance, Ty, TyCtxt, TypeFoldable};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{par_iter, MTLock, MTRef, ParallelIterator};\n@@ -642,39 +642,10 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n \n     fn visit_place_base(\n         &mut self,\n-        place_base: &mir::PlaceBase<'tcx>,\n+        _place_local: &Local,\n         _context: mir::visit::PlaceContext,\n-        location: Location,\n+        _location: Location,\n     ) {\n-        match place_base {\n-            PlaceBase::Static(box Static { kind: StaticKind::Static, def_id, .. }) => {\n-                debug!(\"visiting static {:?} @ {:?}\", def_id, location);\n-\n-                let tcx = self.tcx;\n-                let instance = Instance::mono(tcx, *def_id);\n-                if should_monomorphize_locally(tcx, &instance) {\n-                    self.output.push(MonoItem::Static(*def_id));\n-                }\n-            }\n-            PlaceBase::Static(box Static {\n-                kind: StaticKind::Promoted(promoted, substs),\n-                def_id,\n-                ..\n-            }) => {\n-                let instance = Instance::new(*def_id, substs.subst(self.tcx, self.param_substs));\n-                match self.tcx.const_eval_promoted(instance, *promoted) {\n-                    Ok(val) => collect_const(self.tcx, val, substs, self.output),\n-                    Err(ErrorHandled::Reported) => {}\n-                    Err(ErrorHandled::TooGeneric) => {\n-                        let span = self.tcx.promoted_mir(*def_id)[*promoted].span;\n-                        span_bug!(span, \"collection encountered polymorphic constant\")\n-                    }\n-                }\n-            }\n-            PlaceBase::Local(_) => {\n-                // Locals have no relevance for collector.\n-            }\n-        }\n     }\n }\n \n@@ -1249,8 +1220,8 @@ fn collect_const<'tcx>(\n                 collect_miri(tcx, id, output);\n             }\n         }\n-        ty::ConstKind::Unevaluated(def_id, substs) => {\n-            match tcx.const_eval_resolve(param_env, def_id, substs, None) {\n+        ty::ConstKind::Unevaluated(def_id, substs, promoted) => {\n+            match tcx.const_eval_resolve(param_env, def_id, substs, promoted, None) {\n                 Ok(val) => collect_const(tcx, val, param_substs, output),\n                 Err(ErrorHandled::Reported) => {}\n                 Err(ErrorHandled::TooGeneric) => {"}, {"sha": "577736f9bd11df64a011adb3f6745890e086d3fc", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -38,12 +38,15 @@ pub trait Qualif {\n         place: PlaceRef<'_, 'tcx>,\n     ) -> bool {\n         if let [proj_base @ .., elem] = place.projection {\n-            let base_qualif =\n-                Self::in_place(cx, per_local, PlaceRef { base: place.base, projection: proj_base });\n+            let base_qualif = Self::in_place(\n+                cx,\n+                per_local,\n+                PlaceRef { local: place.local, projection: proj_base },\n+            );\n             let qualif = base_qualif\n                 && Self::in_any_value_of_ty(\n                     cx,\n-                    Place::ty_from(place.base, proj_base, *cx.body, cx.tcx)\n+                    Place::ty_from(place.local, proj_base, *cx.body, cx.tcx)\n                         .projection_ty(cx.tcx, elem)\n                         .ty,\n                 );\n@@ -75,11 +78,8 @@ pub trait Qualif {\n         place: PlaceRef<'_, 'tcx>,\n     ) -> bool {\n         match place {\n-            PlaceRef { base: PlaceBase::Local(local), projection: [] } => per_local(*local),\n-            PlaceRef { base: PlaceBase::Static(_), projection: [] } => {\n-                bug!(\"qualifying already promoted MIR\")\n-            }\n-            PlaceRef { base: _, projection: [.., _] } => Self::in_projection(cx, per_local, place),\n+            PlaceRef { local, projection: [] } => per_local(*local),\n+            PlaceRef { local: _, projection: [.., _] } => Self::in_projection(cx, per_local, place),\n         }\n     }\n \n@@ -102,7 +102,9 @@ pub trait Qualif {\n                     // Note: this uses `constant.literal.ty` which is a reference or pointer to the\n                     // type of the actual `static` item.\n                     Self::in_any_value_of_ty(cx, constant.literal.ty)\n-                } else if let ty::ConstKind::Unevaluated(def_id, _) = constant.literal.val {\n+                } else if let ty::ConstKind::Unevaluated(def_id, _, promoted) = constant.literal.val\n+                {\n+                    assert!(promoted.is_none());\n                     // Don't peek inside trait associated constants.\n                     if cx.tcx.trait_of_item(def_id).is_some() {\n                         Self::in_any_value_of_ty(cx, constant.literal.ty)\n@@ -147,12 +149,12 @@ pub trait Qualif {\n             Rvalue::Ref(_, _, ref place) | Rvalue::AddressOf(_, ref place) => {\n                 // Special-case reborrows to be more like a copy of the reference.\n                 if let [proj_base @ .., ProjectionElem::Deref] = place.projection.as_ref() {\n-                    let base_ty = Place::ty_from(&place.base, proj_base, *cx.body, cx.tcx).ty;\n+                    let base_ty = Place::ty_from(&place.local, proj_base, *cx.body, cx.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind {\n                         return Self::in_place(\n                             cx,\n                             per_local,\n-                            PlaceRef { base: &place.base, projection: proj_base },\n+                            PlaceRef { local: &place.local, projection: proj_base },\n                         );\n                     }\n                 }"}, {"sha": "c445568dd2a9b4043b5677beebf1cbd19adcb6bf", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -47,15 +47,15 @@ where\n         debug_assert!(!place.is_indirect());\n \n         match (value, place.as_ref()) {\n-            (true, mir::PlaceRef { base: &mir::PlaceBase::Local(local), .. }) => {\n-                self.qualifs_per_local.insert(local);\n+            (true, mir::PlaceRef { local, .. }) => {\n+                self.qualifs_per_local.insert(*local);\n             }\n \n             // For now, we do not clear the qualif if a local is overwritten in full by\n             // an unqualified rvalue (e.g. `y = 5`). This is to be consistent\n             // with aggregates where we overwrite all fields with assignments, which would not\n             // get this feature.\n-            (false, mir::PlaceRef { base: &mir::PlaceBase::Local(_local), projection: &[] }) => {\n+            (false, mir::PlaceRef { local: _, projection: &[] }) => {\n                 // self.qualifs_per_local.remove(*local);\n             }\n "}, {"sha": "10a4b7d92b764a266610c206fcfe978bf6384457", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 18, "deletions": 41, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -304,8 +304,8 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                             PlaceContext::MutatingUse(MutatingUseContext::Borrow)\n                         }\n                     };\n-                    self.visit_place_base(&place.base, ctx, location);\n-                    self.visit_projection(&place.base, reborrowed_proj, ctx, location);\n+                    self.visit_place_base(&place.local, ctx, location);\n+                    self.visit_projection(&place.local, reborrowed_proj, ctx, location);\n                     return;\n                 }\n             }\n@@ -317,8 +317,8 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                         }\n                         Mutability::Mut => PlaceContext::MutatingUse(MutatingUseContext::AddressOf),\n                     };\n-                    self.visit_place_base(&place.base, ctx, location);\n-                    self.visit_projection(&place.base, reborrowed_proj, ctx, location);\n+                    self.visit_place_base(&place.local, ctx, location);\n+                    self.visit_projection(&place.local, reborrowed_proj, ctx, location);\n                     return;\n                 }\n             }\n@@ -369,15 +369,6 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n             Rvalue::AddressOf(Mutability::Mut, _) => self.check_op(ops::MutAddressOf),\n \n-            // At the moment, `PlaceBase::Static` is only used for promoted MIR.\n-            Rvalue::Ref(_, BorrowKind::Shared, ref place)\n-            | Rvalue::Ref(_, BorrowKind::Shallow, ref place)\n-            | Rvalue::AddressOf(Mutability::Not, ref place)\n-                if matches!(place.base, PlaceBase::Static(_)) =>\n-            {\n-                bug!(\"Saw a promoted during const-checking, which must run before promotion\")\n-            }\n-\n             Rvalue::Ref(_, BorrowKind::Shared, ref place)\n             | Rvalue::Ref(_, BorrowKind::Shallow, ref place) => {\n                 self.check_immutable_borrow_like(location, place)\n@@ -421,26 +412,14 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n         }\n     }\n \n-    fn visit_place_base(\n-        &mut self,\n-        place_base: &PlaceBase<'tcx>,\n-        context: PlaceContext,\n-        location: Location,\n-    ) {\n+    fn visit_place_base(&mut self, place_local: &Local, context: PlaceContext, location: Location) {\n         trace!(\n-            \"visit_place_base: place_base={:?} context={:?} location={:?}\",\n-            place_base,\n+            \"visit_place_base: place_local={:?} context={:?} location={:?}\",\n+            place_local,\n             context,\n             location,\n         );\n-        self.super_place_base(place_base, context, location);\n-\n-        match place_base {\n-            PlaceBase::Local(_) => {}\n-            PlaceBase::Static(_) => {\n-                bug!(\"Promotion must be run after const validation\");\n-            }\n-        }\n+        self.super_place_base(place_local, context, location);\n     }\n \n     fn visit_operand(&mut self, op: &Operand<'tcx>, location: Location) {\n@@ -453,30 +432,30 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n     }\n     fn visit_projection_elem(\n         &mut self,\n-        place_base: &PlaceBase<'tcx>,\n+        place_local: &Local,\n         proj_base: &[PlaceElem<'tcx>],\n         elem: &PlaceElem<'tcx>,\n         context: PlaceContext,\n         location: Location,\n     ) {\n         trace!(\n-            \"visit_projection_elem: place_base={:?} proj_base={:?} elem={:?} \\\n+            \"visit_projection_elem: place_local={:?} proj_base={:?} elem={:?} \\\n             context={:?} location={:?}\",\n-            place_base,\n+            place_local,\n             proj_base,\n             elem,\n             context,\n             location,\n         );\n \n-        self.super_projection_elem(place_base, proj_base, elem, context, location);\n+        self.super_projection_elem(place_local, proj_base, elem, context, location);\n \n         match elem {\n             ProjectionElem::Deref => {\n-                let base_ty = Place::ty_from(place_base, proj_base, *self.body, self.tcx).ty;\n+                let base_ty = Place::ty_from(place_local, proj_base, *self.body, self.tcx).ty;\n                 if let ty::RawPtr(_) = base_ty.kind {\n                     if proj_base.is_empty() {\n-                        if let (PlaceBase::Local(local), []) = (place_base, proj_base) {\n+                        if let (local, []) = (place_local, proj_base) {\n                             let decl = &self.body.local_decls[*local];\n                             if let LocalInfo::StaticRef { def_id, .. } = decl.local_info {\n                                 let span = decl.source_info.span;\n@@ -497,7 +476,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             | ProjectionElem::Subslice { .. }\n             | ProjectionElem::Field(..)\n             | ProjectionElem::Index(_) => {\n-                let base_ty = Place::ty_from(place_base, proj_base, *self.body, self.tcx).ty;\n+                let base_ty = Place::ty_from(place_local, proj_base, *self.body, self.tcx).ty;\n                 match base_ty.ty_adt_def() {\n                     Some(def) if def.is_union() => {\n                         self.check_op(ops::UnionAccess);\n@@ -681,17 +660,15 @@ fn place_as_reborrow(\n \n         // A borrow of a `static` also looks like `&(*_1)` in the MIR, but `_1` is a `const`\n         // that points to the allocation for the static. Don't treat these as reborrows.\n-        if let PlaceBase::Local(local) = place.base {\n-            if body.local_decls[local].is_ref_to_static() {\n-                return None;\n-            }\n+        if body.local_decls[place.local].is_ref_to_static() {\n+            return None;\n         }\n \n         // Ensure the type being derefed is a reference and not a raw pointer.\n         //\n         // This is sufficient to prevent an access to a `static mut` from being marked as a\n         // reborrow, even if the check above were to disappear.\n-        let inner_ty = Place::ty_from(&place.base, inner, body, tcx).ty;\n+        let inner_ty = Place::ty_from(&place.local, inner, body, tcx).ty;\n         match inner_ty.kind {\n             ty::Ref(..) => Some(inner),\n             _ => None,"}, {"sha": "934b262c2f9cb689d64458e28785e501b8770dcf", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -190,18 +190,6 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n     }\n \n     fn visit_place(&mut self, place: &Place<'tcx>, context: PlaceContext, _location: Location) {\n-        match place.base {\n-            PlaceBase::Local(..) => {\n-                // Locals are safe.\n-            }\n-            PlaceBase::Static(box Static { kind: StaticKind::Promoted(_, _), .. }) => {\n-                bug!(\"unsafety checking should happen before promotion\");\n-            }\n-            PlaceBase::Static(box Static { kind: StaticKind::Static, .. }) => {\n-                bug!(\"StaticKind::Static should not exist\");\n-            }\n-        }\n-\n         for (i, elem) in place.projection.iter().enumerate() {\n             let proj_base = &place.projection[..i];\n \n@@ -229,7 +217,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 }\n             }\n             let is_borrow_of_interior_mut = context.is_borrow()\n-                && !Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty.is_freeze(\n+                && !Place::ty_from(&place.local, proj_base, self.body, self.tcx).ty.is_freeze(\n                     self.tcx,\n                     self.param_env,\n                     self.source_info.span,\n@@ -244,7 +232,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 self.check_mut_borrowing_layout_constrained_field(place, context.is_mutating_use());\n             }\n             let old_source_info = self.source_info;\n-            if let (PlaceBase::Local(local), []) = (&place.base, proj_base) {\n+            if let (local, []) = (&place.local, proj_base) {\n                 let decl = &self.body.local_decls[*local];\n                 if decl.internal {\n                     // Internal locals are used in the `move_val_init` desugaring.\n@@ -272,7 +260,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     }\n                 }\n             }\n-            let base_ty = Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty;\n+            let base_ty = Place::ty_from(&place.local, proj_base, self.body, self.tcx).ty;\n             match base_ty.kind {\n                 ty::RawPtr(..) => self.require_unsafe(\n                     \"dereference of raw pointer\",\n@@ -426,7 +414,8 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n             match elem {\n                 ProjectionElem::Field(..) => {\n                     let ty =\n-                        Place::ty_from(&place.base, proj_base, &self.body.local_decls, self.tcx).ty;\n+                        Place::ty_from(&place.local, proj_base, &self.body.local_decls, self.tcx)\n+                            .ty;\n                     match ty.kind {\n                         ty::Adt(def, _) => match self.tcx.layout_scalar_valid_range(def.did) {\n                             (Bound::Unbounded, Bound::Unbounded) => {}"}, {"sha": "1d5a643484a73d53b4efa5b72a31eb65b4f35e6e", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -10,15 +10,15 @@ use rustc::mir::visit::{\n };\n use rustc::mir::{\n     read_only, AggregateKind, BasicBlock, BinOp, Body, BodyAndCache, ClearCrossCrate, Constant,\n-    Local, LocalDecl, LocalKind, Location, Operand, Place, PlaceBase, ReadOnlyBodyAndCache, Rvalue,\n+    Local, LocalDecl, LocalKind, Location, Operand, Place, ReadOnlyBodyAndCache, Rvalue,\n     SourceInfo, SourceScope, SourceScopeData, Statement, StatementKind, Terminator, TerminatorKind,\n     UnOp, RETURN_PLACE,\n };\n use rustc::ty::layout::{\n     HasDataLayout, HasTyCtxt, LayoutError, LayoutOf, Size, TargetDataLayout, TyLayout,\n };\n-use rustc::ty::subst::InternalSubsts;\n-use rustc::ty::{self, Instance, ParamEnv, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::subst::{InternalSubsts, Subst};\n+use rustc::ty::{self, ConstKind, Instance, ParamEnv, Ty, TyCtxt, TypeFoldable};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n@@ -33,7 +33,6 @@ use crate::interpret::{\n     LocalState, LocalValue, Memory, MemoryKind, OpTy, Operand as InterpOperand, PlaceTy, Pointer,\n     ScalarMaybeUndef, StackPopCleanup,\n };\n-use crate::rustc::ty::subst::Subst;\n use crate::transform::{MirPass, MirSource};\n \n /// The maximum number of bytes that we'll allocate space for a return value.\n@@ -432,12 +431,25 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         source_info: SourceInfo,\n     ) -> Option<Const<'tcx>> {\n         self.ecx.tcx.span = c.span;\n+\n+        // FIXME we need to revisit this for #67176\n+        if c.needs_subst() {\n+            return None;\n+        }\n+\n         match self.ecx.eval_const_to_op(c.literal, None) {\n             Ok(op) => Some(op),\n             Err(error) => {\n                 let err = error_to_const_error(&self.ecx, error);\n-                match self.lint_root(source_info) {\n-                    Some(lint_root) if c.literal.needs_subst() => {\n+                if let Some(lint_root) = self.lint_root(source_info) {\n+                    let lint_only = match c.literal.val {\n+                        // Promoteds must lint and not error as the user didn't ask for them\n+                        ConstKind::Unevaluated(_, _, Some(_)) => true,\n+                        // Out of backwards compatibility we cannot report hard errors in unused\n+                        // generic functions using associated constants of the generic parameters.\n+                        _ => c.literal.needs_subst(),\n+                    };\n+                    if lint_only {\n                         // Out of backwards compatibility we cannot report hard errors in unused\n                         // generic functions using associated constants of the generic parameters.\n                         err.report_as_lint(\n@@ -446,10 +458,11 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                             lint_root,\n                             Some(c.span),\n                         );\n-                    }\n-                    _ => {\n+                    } else {\n                         err.report_as_error(self.ecx.tcx, \"erroneous constant used\");\n                     }\n+                } else {\n+                    err.report_as_error(self.ecx.tcx, \"erroneous constant used\");\n                 }\n                 None\n             }\n@@ -552,6 +565,11 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             return None;\n         }\n \n+        // FIXME we need to revisit this for #67176\n+        if rvalue.needs_subst() {\n+            return None;\n+        }\n+\n         let overflow_check = self.tcx.sess.overflow_checks();\n \n         // Perform any special handling for specific Rvalue types.\n@@ -708,7 +726,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             )) => l.is_bits() && r.is_bits(),\n             interpret::Operand::Indirect(_) if mir_opt_level >= 2 => {\n                 let mplace = op.assert_mem_place(&self.ecx);\n-                intern_const_alloc_recursive(&mut self.ecx, None, mplace)\n+                intern_const_alloc_recursive(&mut self.ecx, None, mplace, false)\n                     .expect(\"failed to intern alloc\");\n                 true\n             }\n@@ -866,9 +884,7 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                         // doesn't use the invalid value\n                         match cond {\n                             Operand::Move(ref place) | Operand::Copy(ref place) => {\n-                                if let PlaceBase::Local(local) = place.base {\n-                                    self.remove_const(local);\n-                                }\n+                                self.remove_const(place.local);\n                             }\n                             Operand::Constant(_) => {}\n                         }"}, {"sha": "825ac4a28d86925a9e2f5266edd961121a7cd402", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -112,17 +112,17 @@ impl<'tcx> MutVisitor<'tcx> for DerefArgVisitor<'tcx> {\n     }\n \n     fn visit_place(&mut self, place: &mut Place<'tcx>, context: PlaceContext, location: Location) {\n-        if place.base == PlaceBase::Local(self_arg()) {\n+        if place.local == self_arg() {\n             replace_base(\n                 place,\n                 Place {\n-                    base: PlaceBase::Local(self_arg()),\n+                    local: self_arg(),\n                     projection: self.tcx().intern_place_elems(&vec![ProjectionElem::Deref]),\n                 },\n                 self.tcx,\n             );\n         } else {\n-            self.visit_place_base(&mut place.base, context, location);\n+            self.visit_place_base(&mut place.local, context, location);\n \n             for elem in place.projection.iter() {\n                 if let PlaceElem::Index(local) = elem {\n@@ -148,11 +148,11 @@ impl<'tcx> MutVisitor<'tcx> for PinArgVisitor<'tcx> {\n     }\n \n     fn visit_place(&mut self, place: &mut Place<'tcx>, context: PlaceContext, location: Location) {\n-        if place.base == PlaceBase::Local(self_arg()) {\n+        if place.local == self_arg() {\n             replace_base(\n                 place,\n                 Place {\n-                    base: PlaceBase::Local(self_arg()),\n+                    local: self_arg(),\n                     projection: self.tcx().intern_place_elems(&vec![ProjectionElem::Field(\n                         Field::new(0),\n                         self.ref_gen_ty,\n@@ -161,7 +161,7 @@ impl<'tcx> MutVisitor<'tcx> for PinArgVisitor<'tcx> {\n                 self.tcx,\n             );\n         } else {\n-            self.visit_place_base(&mut place.base, context, location);\n+            self.visit_place_base(&mut place.local, context, location);\n \n             for elem in place.projection.iter() {\n                 if let PlaceElem::Index(local) = elem {\n@@ -173,7 +173,7 @@ impl<'tcx> MutVisitor<'tcx> for PinArgVisitor<'tcx> {\n }\n \n fn replace_base<'tcx>(place: &mut Place<'tcx>, new_base: Place<'tcx>, tcx: TyCtxt<'tcx>) {\n-    place.base = new_base.base;\n+    place.local = new_base.local;\n \n     let mut new_projection = new_base.projection.to_vec();\n     new_projection.append(&mut place.projection.to_vec());\n@@ -236,7 +236,7 @@ impl TransformVisitor<'tcx> {\n         let mut projection = base.projection.to_vec();\n         projection.push(ProjectionElem::Field(Field::new(idx), ty));\n \n-        Place { base: base.base, projection: self.tcx.intern_place_elems(&projection) }\n+        Place { local: base.local, projection: self.tcx.intern_place_elems(&projection) }\n     }\n \n     // Create a statement which changes the discriminant\n@@ -275,20 +275,15 @@ impl MutVisitor<'tcx> for TransformVisitor<'tcx> {\n         assert_eq!(self.remap.get(local), None);\n     }\n \n-    fn visit_place(&mut self, place: &mut Place<'tcx>, context: PlaceContext, location: Location) {\n-        if let PlaceBase::Local(l) = place.base {\n-            // Replace an Local in the remap with a generator struct access\n-            if let Some(&(ty, variant_index, idx)) = self.remap.get(&l) {\n-                replace_base(place, self.make_field(variant_index, idx, ty), self.tcx);\n-            }\n-        } else {\n-            self.visit_place_base(&mut place.base, context, location);\n-\n-            for elem in place.projection.iter() {\n-                if let PlaceElem::Index(local) = elem {\n-                    assert_ne!(*local, self_arg());\n-                }\n-            }\n+    fn visit_place(\n+        &mut self,\n+        place: &mut Place<'tcx>,\n+        _context: PlaceContext,\n+        _location: Location,\n+    ) {\n+        // Replace an Local in the remap with a generator struct access\n+        if let Some(&(ty, variant_index, idx)) = self.remap.get(&place.local) {\n+            replace_base(place, self.make_field(variant_index, idx, ty), self.tcx);\n         }\n     }\n "}, {"sha": "2dd00fe2fee195038aef34f998364cc2d06f262c", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 10, "deletions": 23, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -430,12 +430,7 @@ impl Inliner<'tcx> {\n                         }\n                     }\n \n-                    match place.base {\n-                        // Static variables need a borrow because the callee\n-                        // might modify the same static.\n-                        PlaceBase::Static(_) => true,\n-                        _ => false,\n-                    }\n+                    false\n                 }\n \n                 let dest = if dest_needs_borrow(&destination.0) {\n@@ -647,10 +642,7 @@ impl<'a, 'tcx> Integrator<'a, 'tcx> {\n \n     fn make_integrate_local(&self, local: &Local) -> Local {\n         if *local == RETURN_PLACE {\n-            match self.destination.base {\n-                PlaceBase::Local(l) => return l,\n-                PlaceBase::Static(ref s) => bug!(\"Return place is {:?}, not local\", s),\n-            }\n+            return self.destination.local;\n         }\n \n         let idx = local.index() - 1;\n@@ -672,19 +664,14 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n     }\n \n     fn visit_place(&mut self, place: &mut Place<'tcx>, context: PlaceContext, location: Location) {\n-        match &mut place.base {\n-            PlaceBase::Static(_) => {}\n-            PlaceBase::Local(l) => {\n-                // If this is the `RETURN_PLACE`, we need to rebase any projections onto it.\n-                let dest_proj_len = self.destination.projection.len();\n-                if *l == RETURN_PLACE && dest_proj_len > 0 {\n-                    let mut projs = Vec::with_capacity(dest_proj_len + place.projection.len());\n-                    projs.extend(self.destination.projection);\n-                    projs.extend(place.projection);\n-\n-                    place.projection = self.tcx.intern_place_elems(&*projs);\n-                }\n-            }\n+        // If this is the `RETURN_PLACE`, we need to rebase any projections onto it.\n+        let dest_proj_len = self.destination.projection.len();\n+        if place.local == RETURN_PLACE && dest_proj_len > 0 {\n+            let mut projs = Vec::with_capacity(dest_proj_len + place.projection.len());\n+            projs.extend(self.destination.projection);\n+            projs.extend(place.projection);\n+\n+            place.projection = self.tcx.intern_place_elems(&*projs);\n         }\n         // Handles integrating any locals that occur in the base\n         // or projections"}, {"sha": "69eedb1ae1876971a62a8b1fc17afd7c8c0ea998", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -3,7 +3,7 @@\n use crate::transform::{MirPass, MirSource};\n use rustc::mir::visit::{MutVisitor, Visitor};\n use rustc::mir::{\n-    read_only, Body, BodyAndCache, Constant, Local, Location, Operand, Place, PlaceBase, PlaceRef,\n+    read_only, Body, BodyAndCache, Constant, Local, Location, Operand, Place, PlaceRef,\n     ProjectionElem, Rvalue,\n };\n use rustc::ty::{self, TyCtxt};\n@@ -55,7 +55,7 @@ impl<'tcx> MutVisitor<'tcx> for InstCombineVisitor<'tcx> {\n \n                         Place {\n                             // Replace with dummy\n-                            base: mem::replace(&mut place.base, PlaceBase::Local(Local::new(0))),\n+                            local: mem::replace(&mut place.local, Local::new(0)),\n                             projection: self.tcx().intern_place_elems(proj_l),\n                         }\n                     } else {\n@@ -92,10 +92,10 @@ impl OptimizationFinder<'b, 'tcx> {\n impl Visitor<'tcx> for OptimizationFinder<'b, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         if let Rvalue::Ref(_, _, place) = rvalue {\n-            if let PlaceRef { base, projection: &[ref proj_base @ .., ProjectionElem::Deref] } =\n+            if let PlaceRef { local, projection: &[ref proj_base @ .., ProjectionElem::Deref] } =\n                 place.as_ref()\n             {\n-                if Place::ty_from(base, proj_base, self.body, self.tcx).ty.is_region_ptr() {\n+                if Place::ty_from(local, proj_base, self.body, self.tcx).ty.is_region_ptr() {\n                     self.optimizations.and_stars.insert(location);\n                 }\n             }"}, {"sha": "f058ac834ef3457c4b06dac954cfa8ab6e028bc8", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 106, "deletions": 64, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -27,7 +27,7 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc_target::spec::abi::Abi;\n \n use std::cell::Cell;\n-use std::{iter, mem, usize};\n+use std::{cmp, iter, mem, usize};\n \n use crate::const_eval::{is_const_fn, is_unstable_const_fn};\n use crate::transform::check_consts::{is_lang_panic_fn, qualifs, ConstKind, Item};\n@@ -39,7 +39,7 @@ use crate::transform::{MirPass, MirSource};\n /// errors when promotion of `#[rustc_args_required_const]` arguments fails.\n ///\n /// After this pass is run, `promoted_fragments` will hold the MIR body corresponding to each\n-/// newly created `StaticKind::Promoted`.\n+/// newly created `Constant`.\n #[derive(Default)]\n pub struct PromoteTemps<'tcx> {\n     pub promoted_fragments: Cell<IndexVec<Promoted, BodyAndCache<'tcx>>>,\n@@ -308,18 +308,14 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n                         // We can only promote interior borrows of promotable temps (non-temps\n                         // don't get promoted anyway).\n-                        let base = match place.base {\n-                            PlaceBase::Local(local) => local,\n-                            _ => return Err(Unpromotable),\n-                        };\n-                        self.validate_local(base)?;\n+                        self.validate_local(place.local)?;\n \n                         if place.projection.contains(&ProjectionElem::Deref) {\n                             return Err(Unpromotable);\n                         }\n \n                         let mut has_mut_interior =\n-                            self.qualif_local::<qualifs::HasMutInterior>(base);\n+                            self.qualif_local::<qualifs::HasMutInterior>(place.local);\n                         // HACK(eddyb) this should compute the same thing as\n                         // `<HasMutInterior as Qualif>::in_projection` from\n                         // `check_consts::qualifs` but without recursion.\n@@ -333,7 +329,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                                 // FIXME(eddyb) this is probably excessive, with\n                                 // the exception of `union` member accesses.\n                                 let ty =\n-                                    Place::ty_from(&place.base, proj_base, *self.body, self.tcx)\n+                                    Place::ty_from(&place.local, proj_base, *self.body, self.tcx)\n                                         .projection_ty(self.tcx, elem)\n                                         .ty;\n                                 if ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) {\n@@ -349,7 +345,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                         if has_mut_interior {\n                             return Err(Unpromotable);\n                         }\n-                        if self.qualif_local::<qualifs::NeedsDrop>(base) {\n+                        if self.qualif_local::<qualifs::NeedsDrop>(place.local) {\n                             return Err(Unpromotable);\n                         }\n \n@@ -479,13 +475,8 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n     fn validate_place(&self, place: PlaceRef<'_, 'tcx>) -> Result<(), Unpromotable> {\n         match place {\n-            PlaceRef { base: PlaceBase::Local(local), projection: [] } => {\n-                self.validate_local(*local)\n-            }\n-            PlaceRef { base: PlaceBase::Static(_), projection: [] } => {\n-                bug!(\"qualifying already promoted MIR\")\n-            }\n-            PlaceRef { base: _, projection: [proj_base @ .., elem] } => {\n+            PlaceRef { local, projection: [] } => self.validate_local(*local),\n+            PlaceRef { local: _, projection: [proj_base @ .., elem] } => {\n                 match *elem {\n                     ProjectionElem::Deref | ProjectionElem::Downcast(..) => {\n                         return Err(Unpromotable);\n@@ -500,7 +491,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     ProjectionElem::Field(..) => {\n                         if self.const_kind.is_none() {\n                             let base_ty =\n-                                Place::ty_from(place.base, proj_base, *self.body, self.tcx).ty;\n+                                Place::ty_from(place.local, proj_base, *self.body, self.tcx).ty;\n                             if let Some(def) = base_ty.ty_adt_def() {\n                                 // No promotion of union field accesses.\n                                 if def.is_union() {\n@@ -511,7 +502,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     }\n                 }\n \n-                self.validate_place(PlaceRef { base: place.base, projection: proj_base })\n+                self.validate_place(PlaceRef { local: place.local, projection: proj_base })\n             }\n         }\n     }\n@@ -598,10 +589,12 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 // Raw reborrows can come from reference to pointer coercions,\n                 // so are allowed.\n                 if let [proj_base @ .., ProjectionElem::Deref] = place.projection.as_ref() {\n-                    let base_ty = Place::ty_from(&place.base, proj_base, *self.body, self.tcx).ty;\n+                    let base_ty = Place::ty_from(&place.local, proj_base, *self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind {\n-                        return self\n-                            .validate_place(PlaceRef { base: &place.base, projection: proj_base });\n+                        return self.validate_place(PlaceRef {\n+                            local: &place.local,\n+                            projection: proj_base,\n+                        });\n                     }\n                 }\n                 Err(Unpromotable)\n@@ -635,9 +628,9 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 // Special-case reborrows to be more like a copy of the reference.\n                 let mut place = place.as_ref();\n                 if let [proj_base @ .., ProjectionElem::Deref] = &place.projection {\n-                    let base_ty = Place::ty_from(&place.base, proj_base, *self.body, self.tcx).ty;\n+                    let base_ty = Place::ty_from(&place.local, proj_base, *self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind {\n-                        place = PlaceRef { base: &place.base, projection: proj_base };\n+                        place = PlaceRef { local: &place.local, projection: proj_base };\n                     }\n                 }\n \n@@ -646,17 +639,15 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 // HACK(eddyb) this should compute the same thing as\n                 // `<HasMutInterior as Qualif>::in_projection` from\n                 // `check_consts::qualifs` but without recursion.\n-                let mut has_mut_interior = match place.base {\n-                    PlaceBase::Local(local) => self.qualif_local::<qualifs::HasMutInterior>(*local),\n-                    PlaceBase::Static(_) => false,\n-                };\n+                let mut has_mut_interior =\n+                    self.qualif_local::<qualifs::HasMutInterior>(*place.local);\n                 if has_mut_interior {\n                     let mut place_projection = place.projection;\n                     // FIXME(eddyb) use a forward loop instead of a reverse one.\n                     while let [proj_base @ .., elem] = place_projection {\n                         // FIXME(eddyb) this is probably excessive, with\n                         // the exception of `union` member accesses.\n-                        let ty = Place::ty_from(place.base, proj_base, *self.body, self.tcx)\n+                        let ty = Place::ty_from(place.local, proj_base, *self.body, self.tcx)\n                             .projection_ty(self.tcx, elem)\n                             .ty;\n                         if ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) {\n@@ -761,6 +752,7 @@ struct Promoter<'a, 'tcx> {\n     source: &'a mut BodyAndCache<'tcx>,\n     promoted: BodyAndCache<'tcx>,\n     temps: &'a mut IndexVec<Local, TempState>,\n+    extra_statements: &'a mut Vec<(Location, Statement<'tcx>)>,\n \n     /// If true, all nested temps are also kept in the\n     /// source MIR, not moved to the promoted MIR.\n@@ -903,39 +895,76 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         candidate: Candidate,\n         next_promoted_id: usize,\n     ) -> Option<BodyAndCache<'tcx>> {\n-        let mut operand = {\n+        let mut rvalue = {\n             let promoted = &mut self.promoted;\n             let promoted_id = Promoted::new(next_promoted_id);\n             let tcx = self.tcx;\n-            let mut promoted_place = |ty, span| {\n+            let mut promoted_operand = |ty, span| {\n                 promoted.span = span;\n                 promoted.local_decls[RETURN_PLACE] = LocalDecl::new_return_place(ty, span);\n-                Place {\n-                    base: PlaceBase::Static(box Static {\n-                        kind: StaticKind::Promoted(\n-                            promoted_id,\n+\n+                Operand::Constant(Box::new(Constant {\n+                    span,\n+                    user_ty: None,\n+                    literal: tcx.mk_const(ty::Const {\n+                        ty,\n+                        val: ty::ConstKind::Unevaluated(\n+                            def_id,\n                             InternalSubsts::identity_for_item(tcx, def_id),\n+                            Some(promoted_id),\n                         ),\n-                        ty,\n-                        def_id,\n                     }),\n-                    projection: List::empty(),\n-                }\n+                }))\n             };\n             let (blocks, local_decls) = self.source.basic_blocks_and_local_decls_mut();\n             match candidate {\n                 Candidate::Ref(loc) => {\n                     let ref mut statement = blocks[loc.block].statements[loc.statement_index];\n                     match statement.kind {\n-                        StatementKind::Assign(box (_, Rvalue::Ref(_, _, ref mut place))) => {\n+                        StatementKind::Assign(box (\n+                            _,\n+                            Rvalue::Ref(ref mut region, borrow_kind, ref mut place),\n+                        )) => {\n                             // Use the underlying local for this (necessarily interior) borrow.\n-                            let ty = place.base.ty(local_decls).ty;\n+                            let ty = local_decls.local_decls()[place.local].ty;\n                             let span = statement.source_info.span;\n \n-                            Operand::Move(Place {\n-                                base: mem::replace(&mut place.base, promoted_place(ty, span).base),\n-                                projection: List::empty(),\n-                            })\n+                            let ref_ty = tcx.mk_ref(\n+                                tcx.lifetimes.re_erased,\n+                                ty::TypeAndMut { ty, mutbl: borrow_kind.to_mutbl_lossy() },\n+                            );\n+\n+                            *region = tcx.lifetimes.re_erased;\n+\n+                            let mut projection = vec![PlaceElem::Deref];\n+                            projection.extend(place.projection);\n+                            place.projection = tcx.intern_place_elems(&projection);\n+\n+                            // Create a temp to hold the promoted reference.\n+                            // This is because `*r` requires `r` to be a local,\n+                            // otherwise we would use the `promoted` directly.\n+                            let mut promoted_ref = LocalDecl::new_temp(ref_ty, span);\n+                            promoted_ref.source_info = statement.source_info;\n+                            let promoted_ref = local_decls.push(promoted_ref);\n+                            assert_eq!(self.temps.push(TempState::Unpromotable), promoted_ref);\n+\n+                            let promoted_ref_statement = Statement {\n+                                source_info: statement.source_info,\n+                                kind: StatementKind::Assign(Box::new((\n+                                    Place::from(promoted_ref),\n+                                    Rvalue::Use(promoted_operand(ref_ty, span)),\n+                                ))),\n+                            };\n+                            self.extra_statements.push((loc, promoted_ref_statement));\n+\n+                            Rvalue::Ref(\n+                                tcx.lifetimes.re_erased,\n+                                borrow_kind,\n+                                Place {\n+                                    local: mem::replace(&mut place.local, promoted_ref),\n+                                    projection: List::empty(),\n+                                },\n+                            )\n                         }\n                         _ => bug!(),\n                     }\n@@ -946,7 +975,8 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                         StatementKind::Assign(box (_, Rvalue::Repeat(ref mut operand, _))) => {\n                             let ty = operand.ty(local_decls, self.tcx);\n                             let span = statement.source_info.span;\n-                            mem::replace(operand, Operand::Copy(promoted_place(ty, span)))\n+\n+                            Rvalue::Use(mem::replace(operand, promoted_operand(ty, span)))\n                         }\n                         _ => bug!(),\n                     }\n@@ -957,8 +987,8 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                         TerminatorKind::Call { ref mut args, .. } => {\n                             let ty = args[index].ty(local_decls, self.tcx);\n                             let span = terminator.source_info.span;\n-                            let operand = Operand::Copy(promoted_place(ty, span));\n-                            mem::replace(&mut args[index], operand)\n+\n+                            Rvalue::Use(mem::replace(&mut args[index], promoted_operand(ty, span)))\n                         }\n                         // We expected a `TerminatorKind::Call` for which we'd like to promote an\n                         // argument. `qualify_consts` saw a `TerminatorKind::Call` here, but\n@@ -975,13 +1005,13 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         };\n \n         assert_eq!(self.new_block(), START_BLOCK);\n-        self.visit_operand(\n-            &mut operand,\n+        self.visit_rvalue(\n+            &mut rvalue,\n             Location { block: BasicBlock::new(0), statement_index: usize::MAX },\n         );\n \n         let span = self.promoted.span;\n-        self.assign(RETURN_PLACE, Rvalue::Use(operand), span);\n+        self.assign(RETURN_PLACE, rvalue, span);\n         Some(self.promoted)\n     }\n }\n@@ -1020,6 +1050,7 @@ pub fn promote_candidates<'tcx>(\n \n     let mut promotions = IndexVec::new();\n \n+    let mut extra_statements = vec![];\n     for candidate in candidates.into_iter().rev() {\n         match candidate {\n             Candidate::Repeat(Location { block, statement_index })\n@@ -1043,23 +1074,27 @@ pub fn promote_candidates<'tcx>(\n         let initial_locals =\n             iter::once(LocalDecl::new_return_place(tcx.types.never, body.span)).collect();\n \n+        let mut promoted = Body::new(\n+            IndexVec::new(),\n+            // FIXME: maybe try to filter this to avoid blowing up\n+            // memory usage?\n+            body.source_scopes.clone(),\n+            initial_locals,\n+            IndexVec::new(),\n+            0,\n+            vec![],\n+            body.span,\n+            vec![],\n+            body.generator_kind,\n+        );\n+        promoted.ignore_interior_mut_in_const_validation = true;\n+\n         let promoter = Promoter {\n-            promoted: BodyAndCache::new(Body::new(\n-                IndexVec::new(),\n-                // FIXME: maybe try to filter this to avoid blowing up\n-                // memory usage?\n-                body.source_scopes.clone(),\n-                initial_locals,\n-                IndexVec::new(),\n-                0,\n-                vec![],\n-                body.span,\n-                vec![],\n-                body.generator_kind,\n-            )),\n+            promoted: BodyAndCache::new(promoted),\n             tcx,\n             source: body,\n             temps: &mut temps,\n+            extra_statements: &mut extra_statements,\n             keep_original: false,\n         };\n \n@@ -1069,6 +1104,13 @@ pub fn promote_candidates<'tcx>(\n         }\n     }\n \n+    // Insert each of `extra_statements` before its indicated location, which\n+    // has to be done in reverse location order, to not invalidate the rest.\n+    extra_statements.sort_by_key(|&(loc, _)| cmp::Reverse(loc));\n+    for (loc, statement) in extra_statements {\n+        body[loc.block].statements.insert(loc.statement_index, statement);\n+    }\n+\n     // Eliminate assignments to, and drops of promoted temps.\n     let promoted = |index: Local| temps[index] == TempState::PromotedOut;\n     for block in body.basic_blocks_mut() {"}, {"sha": "7034556740849f7a260e3baa5f034117cf0ca043", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -261,7 +261,7 @@ fn check_place(\n             ProjectionElem::Downcast(_symbol, _variant_index) => {}\n \n             ProjectionElem::Field(..) => {\n-                let base_ty = Place::ty_from(&place.base, &proj_base, body, tcx).ty;\n+                let base_ty = Place::ty_from(&place.local, &proj_base, body, tcx).ty;\n                 if let Some(def) = base_ty.ty_adt_def() {\n                     // No union field accesses in `const fn`\n                     if def.is_union() {"}, {"sha": "ddf8d73e5481f82d1ecbccc8f8cb8defc2d2adf1", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -388,13 +388,7 @@ impl<'tcx> MutVisitor<'tcx> for LocalUpdater<'tcx> {\n         // Remove unnecessary StorageLive and StorageDead annotations.\n         data.statements.retain(|stmt| match &stmt.kind {\n             StatementKind::StorageLive(l) | StatementKind::StorageDead(l) => self.map[*l].is_some(),\n-            StatementKind::Assign(box (place, _)) => {\n-                if let PlaceBase::Local(local) = place.base {\n-                    self.map[local].is_some()\n-                } else {\n-                    true\n-                }\n-            }\n+            StatementKind::Assign(box (place, _)) => self.map[place.local].is_some(),\n             _ => true,\n         });\n         self.super_basic_block_data(block, data);"}, {"sha": "e733b0a5b5928dffdd04d888ceb5f591a56d9863", "filename": "src/librustc_mir/transform/simplify_try.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -137,9 +137,9 @@ struct VarField<'tcx> {\n fn match_variant_field_place<'tcx>(place: &Place<'tcx>) -> Option<(Local, VarField<'tcx>)> {\n     match place.as_ref() {\n         PlaceRef {\n-            base: &PlaceBase::Local(local),\n+            local,\n             projection: &[ProjectionElem::Downcast(_, var_idx), ProjectionElem::Field(field, ty)],\n-        } => Some((local, VarField { field, field_ty: ty, var_idx })),\n+        } => Some((*local, VarField { field, field_ty: ty, var_idx })),\n         _ => None,\n     }\n }"}, {"sha": "e17c7a80f1a7617184e26ac3c6768a0dd1ae65bc", "filename": "src/librustc_mir/util/alignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_mir%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Falignment.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -46,7 +46,7 @@ where\n             // encountered a Deref, which is ABI-aligned\n             ProjectionElem::Deref => break,\n             ProjectionElem::Field(..) => {\n-                let ty = Place::ty_from(&place.base, proj_base, local_decls, tcx).ty;\n+                let ty = Place::ty_from(&place.local, proj_base, local_decls, tcx).ty;\n                 match ty.kind {\n                     ty::Adt(def, _) if def.repr.packed() => return true,\n                     _ => {}"}, {"sha": "dae394b8f4bd46deb027ce702939e346082e8033", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -2700,7 +2700,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let def_id = tcx.hir().local_def_id(ast_const.hir_id);\n \n         let mut const_ = ty::Const {\n-            val: ty::ConstKind::Unevaluated(def_id, InternalSubsts::identity_for_item(tcx, def_id)),\n+            val: ty::ConstKind::Unevaluated(\n+                def_id,\n+                InternalSubsts::identity_for_item(tcx, def_id),\n+                None,\n+            ),\n             ty,\n         };\n "}, {"sha": "8058536d60b3194ed199ccce23befe3dd02cbd7d", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -460,12 +460,16 @@ pub fn name_from_pat(p: &hir::Pat) -> String {\n \n pub fn print_const(cx: &DocContext<'_>, n: &ty::Const<'_>) -> String {\n     match n.val {\n-        ty::ConstKind::Unevaluated(def_id, _) => {\n-            if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(def_id) {\n+        ty::ConstKind::Unevaluated(def_id, _, promoted) => {\n+            let mut s = if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(def_id) {\n                 print_const_expr(cx, cx.tcx.hir().body_owned_by(hir_id))\n             } else {\n                 inline::print_inlined_const(cx, def_id)\n+            };\n+            if let Some(promoted) = promoted {\n+                s.push_str(&format!(\"::{:?}\", promoted))\n             }\n+            s\n         }\n         _ => {\n             let mut s = n.to_string();"}, {"sha": "a89ecdfd3a90153f05d20bc01378c8a461d1cd64", "filename": "src/test/codegen/consts.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fcodegen%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fcodegen%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fconsts.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -14,10 +14,9 @@\n \n // This checks the constants from {low,high}_align_const, they share the same\n // constant, but the alignment differs, so the higher one should be used\n-// CHECK: [[LOW_HIGH:@[0-9]+]] = {{.*}}, align 4\n+// CHECK: [[LOW_HIGH:@[0-9]+]] = {{.*}} getelementptr inbounds (<{ [8 x i8] }>, <{ [8 x i8] }>* @2, i32 0, i32 0, i32 0), {{.*}},\n \n #[derive(Copy, Clone)]\n-\n // repr(i16) is required for the {low,high}_align_const test\n #[repr(i16)]\n pub enum E<A, B> {\n@@ -31,7 +30,7 @@ pub static STATIC: E<i16, i32> = E::A(0);\n // CHECK-LABEL: @static_enum_const\n #[no_mangle]\n pub fn static_enum_const() -> E<i16, i32> {\n-   STATIC\n+    STATIC\n }\n \n // CHECK-LABEL: @inline_enum_const\n@@ -43,15 +42,15 @@ pub fn inline_enum_const() -> E<i8, i16> {\n // CHECK-LABEL: @low_align_const\n #[no_mangle]\n pub fn low_align_const() -> E<i16, [i16; 3]> {\n-// Check that low_align_const and high_align_const use the same constant\n-// CHECK: i8* align 2 getelementptr inbounds (<{ [8 x i8] }>, <{ [8 x i8] }>* [[LOW_HIGH]], i32 0, i32 0, i32 0),\n+    // Check that low_align_const and high_align_const use the same constant\n+    // CHECK: load %\"E<i16, [i16; 3]>\"*, %\"E<i16, [i16; 3]>\"** bitcast (<{ i8*, [0 x i8] }>* [[LOW_HIGH]] to %\"E<i16, [i16; 3]>\"**),\n     *&E::A(0)\n }\n \n // CHECK-LABEL: @high_align_const\n #[no_mangle]\n pub fn high_align_const() -> E<i16, i32> {\n-// Check that low_align_const and high_align_const use the same constant\n-// CHECK: i8* align 4 getelementptr inbounds (<{ [8 x i8] }>, <{ [8 x i8] }>* [[LOW_HIGH]], i32 0, i32 0, i32 0),\n+    // Check that low_align_const and high_align_const use the same constant\n+    // CHECK: load %\"E<i16, i32>\"*, %\"E<i16, i32>\"** bitcast (<{ i8*, [0 x i8] }>* [[LOW_HIGH]] to %\"E<i16, i32>\"**),\n     *&E::A(0)\n }"}, {"sha": "3abc90e42e8ca91f5187381184ba68e96b64b68f", "filename": "src/test/mir-opt/const-promotion-extern-static.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -48,7 +48,8 @@ fn main() {}\n // START rustc.BAR.PromoteTemps.after.mir\n // bb0: {\n // ...\n-//     _2 = &(promoted[0]: [&'static i32; 1]);\n+//     _6 = const BAR::promoted[0];\n+//     _2 = &(*_6);\n //     _1 = move _2 as &[&'static i32] (Pointer(Unsize));\n //     _0 = const core::slice::<impl [&'static i32]>::as_ptr(move _1) -> [return: bb2, unwind: bb1];\n // }\n@@ -60,7 +61,8 @@ fn main() {}\n // START rustc.FOO.PromoteTemps.after.mir\n // bb0: {\n // ...\n-//     _2 = &(promoted[0]: [&'static i32; 1]);\n+//     _6 = const FOO::promoted[0];\n+//     _2 = &(*_6);\n //     _1 = move _2 as &[&'static i32] (Pointer(Unsize));\n //     _0 = const core::slice::<impl [&'static i32]>::as_ptr(move _1) -> [return: bb2, unwind: bb1];\n // }"}, {"sha": "8b48296a5d9111f9a2dd7ff9e4b6300899aed84a", "filename": "src/test/mir-opt/const_prop/ref_deref.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -3,18 +3,38 @@ fn main() {\n }\n \n // END RUST SOURCE\n+// START rustc.main.PromoteTemps.before.mir\n+// bb0: {\n+//     ...\n+//     _3 = const 4i32;\n+//     _2 = &_3;\n+//     _1 = (*_2);\n+//     ...\n+//}\n+// END rustc.main.PromoteTemps.before.mir\n+// START rustc.main.PromoteTemps.after.mir\n+// bb0: {\n+//     ...\n+//     _4 = const main::promoted[0];\n+//     _2 = &(*_4);\n+//     _1 = (*_2);\n+//     ...\n+//}\n+// END rustc.main.PromoteTemps.after.mir\n // START rustc.main.ConstProp.before.mir\n // bb0: {\n //     ...\n-//     _2 = &(promoted[0]: i32);\n+//     _4 = const main::promoted[0];\n+//     _2 = _4;\n //     _1 = (*_2);\n //     ...\n //}\n // END rustc.main.ConstProp.before.mir\n // START rustc.main.ConstProp.after.mir\n // bb0: {\n //     ...\n-//     _2 = &(promoted[0]: i32);\n+//     _4 = const main::promoted[0];\n+//     _2 = _4;\n //     _1 = const 4i32;\n //     ...\n // }"}, {"sha": "5808a8be176d4f15ec0a9f3866765b54375b3983", "filename": "src/test/mir-opt/const_prop/ref_deref_project.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref_project.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref_project.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref_project.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -0,0 +1,41 @@\n+fn main() {\n+    *(&(4, 5).1);\n+}\n+\n+// END RUST SOURCE\n+// START rustc.main.PromoteTemps.before.mir\n+// bb0: {\n+//     ...\n+//     _3 = (const 4i32, const 5i32);\n+//     _2 = &(_3.1: i32);\n+//     _1 = (*_2);\n+//     ...\n+//}\n+// END rustc.main.PromoteTemps.before.mir\n+// START rustc.main.PromoteTemps.after.mir\n+// bb0: {\n+//     ...\n+//     _4 = const main::promoted[0];\n+//     _2 = &((*_4).1: i32);\n+//     _1 = (*_2);\n+//     ...\n+//}\n+// END rustc.main.PromoteTemps.after.mir\n+// START rustc.main.ConstProp.before.mir\n+// bb0: {\n+//     ...\n+//     _4 = const main::promoted[0];\n+//     _2 = &((*_4).1: i32);\n+//     _1 = (*_2);\n+//     ...\n+//}\n+// END rustc.main.ConstProp.before.mir\n+// START rustc.main.ConstProp.after.mir\n+// bb0: {\n+//     ...\n+//     _4 = const main::promoted[0];\n+//     _2 = &((*_4).1: i32);\n+//     _1 = const 5i32;\n+//     ...\n+// }\n+// END rustc.main.ConstProp.after.mir"}, {"sha": "43813e43d3681f9f46fb86c328606fcee2680137", "filename": "src/test/mir-opt/const_prop/slice_len.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fslice_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fslice_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fslice_len.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -6,7 +6,8 @@ fn main() {\n // START rustc.main.ConstProp.before.mir\n //  bb0: {\n //      ...\n-//      _4 = &(promoted[0]: [u32; 3]);\n+//      _9 = const main::promoted[0];\n+//      _4 = _9;\n //      _3 = _4;\n //      _2 = move _3 as &[u32] (Pointer(Unsize));\n //      ...\n@@ -24,7 +25,8 @@ fn main() {\n // START rustc.main.ConstProp.after.mir\n //  bb0: {\n //      ...\n-//      _4 = &(promoted[0]: [u32; 3]);\n+//      _9 = const main::promoted[0];\n+//      _4 = _9;\n //      _3 = _4;\n //      _2 = move _3 as &[u32] (Pointer(Unsize));\n //      ..."}, {"sha": "7b78fc339f2c1309d2deb204593d1c8f477a38ed", "filename": "src/test/mir-opt/inline/inline-retag.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fmir-opt%2Finline%2Finline-retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fmir-opt%2Finline%2Finline-retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline-retag.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -25,11 +25,11 @@ fn foo(x: &i32, y: &i32) -> bool {\n //         ...\n //         Retag(_3);\n //         Retag(_6);\n-//         StorageLive(_9);\n-//         _9 = (*_3);\n-//         StorageLive(_10);\n-//         _10 = (*_6);\n-//         _0 = Eq(move _9, move _10);\n+//         StorageLive(_11);\n+//         _11 = (*_3);\n+//         StorageLive(_12);\n+//         _12 = (*_6);\n+//         _0 = Eq(move _11, move _12);\n //         ...\n //         return;\n //     }"}, {"sha": "2c20c35e4a49169f1aece74409fdf1ef2b094f6f", "filename": "src/test/mir-opt/match_false_edges.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -65,7 +65,8 @@ fn main() {\n //  }\n //  bb6: { // binding1 and guard\n //      StorageLive(_6);\n-//      _6 = &(((promoted[0]: std::option::Option<i32>) as Some).0: i32);\n+//      _11 = const full_tested_match::promoted[0];\n+//      _6 = &(((*_11) as Some).0: i32);\n //      _4 = &shallow _2;\n //      StorageLive(_7);\n //      _7 = const guard() -> [return: bb7, unwind: bb1];"}, {"sha": "64aeb46894d169b63303972a07371c471d5498aa", "filename": "src/test/ui/consts/array-literal-index-oob.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Farray-literal-index-oob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Farray-literal-index-oob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Farray-literal-index-oob.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -1,7 +1,10 @@\n-// build-fail\n+// build-pass\n+\n+#![warn(const_err)]\n \n fn main() {\n-    &{[1, 2, 3][4]};\n-    //~^ ERROR index out of bounds\n-    //~| ERROR reaching this expression at runtime will panic or abort\n+    &{ [1, 2, 3][4] };\n+    //~^ WARN index out of bounds\n+    //~| WARN reaching this expression at runtime will panic or abort\n+    //~| WARN erroneous constant used [const_err]\n }"}, {"sha": "50ad8e83e905cc0ad842642cc1986511d0ebb74f", "filename": "src/test/ui/consts/array-literal-index-oob.stderr", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Farray-literal-index-oob.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Farray-literal-index-oob.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Farray-literal-index-oob.stderr?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -1,18 +1,26 @@\n-error: index out of bounds: the len is 3 but the index is 4\n-  --> $DIR/array-literal-index-oob.rs:4:7\n+warning: index out of bounds: the len is 3 but the index is 4\n+  --> $DIR/array-literal-index-oob.rs:6:8\n    |\n-LL |     &{[1, 2, 3][4]};\n-   |       ^^^^^^^^^^^^\n+LL |     &{ [1, 2, 3][4] };\n+   |        ^^^^^^^^^^^^\n    |\n-   = note: `#[deny(const_err)]` on by default\n+note: lint level defined here\n+  --> $DIR/array-literal-index-oob.rs:3:9\n+   |\n+LL | #![warn(const_err)]\n+   |         ^^^^^^^^^\n \n-error: reaching this expression at runtime will panic or abort\n-  --> $DIR/array-literal-index-oob.rs:4:7\n+warning: reaching this expression at runtime will panic or abort\n+  --> $DIR/array-literal-index-oob.rs:6:8\n    |\n-LL |     &{[1, 2, 3][4]};\n-   |     --^^^^^^^^^^^^-\n-   |       |\n-   |       indexing out of bounds: the len is 3 but the index is 4\n+LL |     &{ [1, 2, 3][4] };\n+   |     ---^^^^^^^^^^^^--\n+   |        |\n+   |        indexing out of bounds: the len is 3 but the index is 4\n \n-error: aborting due to 2 previous errors\n+warning: erroneous constant used\n+  --> $DIR/array-literal-index-oob.rs:6:5\n+   |\n+LL |     &{ [1, 2, 3][4] };\n+   |     ^^^^^^^^^^^^^^^^^ referenced constant has errors\n "}, {"sha": "2058d2e218473b925ca224333fcc1effa6beee25", "filename": "src/test/ui/consts/const-eval/conditional_array_execution.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconditional_array_execution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconditional_array_execution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconditional_array_execution.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -10,4 +10,5 @@ const FOO: u32 = [X - Y, Y - X][(X < Y) as usize];\n fn main() {\n     println!(\"{}\", FOO);\n     //~^ ERROR\n+    //~| WARN erroneous constant used [const_err]\n }"}, {"sha": "b5f5f84cf3894ddb57e0fc5b41e041883b1b87ac", "filename": "src/test/ui/consts/const-eval/conditional_array_execution.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconditional_array_execution.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconditional_array_execution.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconditional_array_execution.stderr?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -18,6 +18,12 @@ error[E0080]: evaluation of constant expression failed\n LL |     println!(\"{}\", FOO);\n    |                    ^^^ referenced constant has errors\n \n+warning: erroneous constant used\n+  --> $DIR/conditional_array_execution.rs:11:20\n+   |\n+LL |     println!(\"{}\", FOO);\n+   |                    ^^^ referenced constant has errors\n+\n error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "81f53826d810348c27d247f0b3c4ae2411cca566", "filename": "src/test/ui/consts/const-eval/const_fn_ptr_fail2.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail2.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -4,7 +4,9 @@\n #![feature(const_fn)]\n #![allow(const_err)]\n \n-fn double(x: usize) -> usize { x * 2 }\n+fn double(x: usize) -> usize {\n+    x * 2\n+}\n const X: fn(usize) -> usize = double;\n \n const fn bar(x: fn(usize) -> usize, y: usize) -> usize {"}, {"sha": "f99505c30901d77c814eea77b541f9c962545312", "filename": "src/test/ui/consts/const-eval/const_fn_ptr_fail2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail2.stderr?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -1,11 +1,11 @@\n warning: skipping const checks\n-  --> $DIR/const_fn_ptr_fail2.rs:11:5\n+  --> $DIR/const_fn_ptr_fail2.rs:13:5\n    |\n LL |     x(y)\n    |     ^^^^\n \n error[E0080]: evaluation of constant expression failed\n-  --> $DIR/const_fn_ptr_fail2.rs:18:5\n+  --> $DIR/const_fn_ptr_fail2.rs:20:5\n    |\n LL |     assert_eq!(Y, 4);\n    |     ^^^^^^^^^^^-^^^^^\n@@ -15,7 +15,7 @@ LL |     assert_eq!(Y, 4);\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n error[E0080]: evaluation of constant expression failed\n-  --> $DIR/const_fn_ptr_fail2.rs:20:5\n+  --> $DIR/const_fn_ptr_fail2.rs:22:5\n    |\n LL |     assert_eq!(Z, 4);\n    |     ^^^^^^^^^^^-^^^^^"}, {"sha": "9109307632b595f60de4d1dd7995786809e4516f", "filename": "src/test/ui/consts/const-eval/issue-43197.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-43197.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-43197.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-43197.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -7,11 +7,13 @@ const fn foo(x: u32) -> u32 {\n }\n \n fn main() {\n-    const X: u32 = 0-1;\n+    const X: u32 = 0 - 1;\n     //~^ WARN any use of this value will cause\n-    const Y: u32 = foo(0-1);\n+    const Y: u32 = foo(0 - 1);\n     //~^ WARN any use of this value will cause\n     println!(\"{} {}\", X, Y);\n     //~^ ERROR evaluation of constant expression failed\n     //~| ERROR evaluation of constant expression failed\n+    //~| WARN erroneous constant used [const_err]\n+    //~| WARN erroneous constant used [const_err]\n }"}, {"sha": "23b54d954c65874c0d6e412915d2ac98b4c79c42", "filename": "src/test/ui/consts/const-eval/issue-43197.stderr", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-43197.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-43197.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-43197.stderr?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -1,8 +1,8 @@\n warning: any use of this value will cause an error\n   --> $DIR/issue-43197.rs:10:20\n    |\n-LL |     const X: u32 = 0-1;\n-   |     ---------------^^^-\n+LL |     const X: u32 = 0 - 1;\n+   |     ---------------^^^^^-\n    |                    |\n    |                    attempt to subtract with overflow\n    |\n@@ -15,8 +15,8 @@ LL | #![warn(const_err)]\n warning: any use of this value will cause an error\n   --> $DIR/issue-43197.rs:12:24\n    |\n-LL |     const Y: u32 = foo(0-1);\n-   |     -------------------^^^--\n+LL |     const Y: u32 = foo(0 - 1);\n+   |     -------------------^^^^^--\n    |                        |\n    |                        attempt to subtract with overflow\n \n@@ -26,12 +26,24 @@ error[E0080]: evaluation of constant expression failed\n LL |     println!(\"{} {}\", X, Y);\n    |                       ^ referenced constant has errors\n \n+warning: erroneous constant used\n+  --> $DIR/issue-43197.rs:14:23\n+   |\n+LL |     println!(\"{} {}\", X, Y);\n+   |                       ^ referenced constant has errors\n+\n error[E0080]: evaluation of constant expression failed\n   --> $DIR/issue-43197.rs:14:26\n    |\n LL |     println!(\"{} {}\", X, Y);\n    |                          ^ referenced constant has errors\n \n+warning: erroneous constant used\n+  --> $DIR/issue-43197.rs:14:26\n+   |\n+LL |     println!(\"{} {}\", X, Y);\n+   |                          ^ referenced constant has errors\n+\n error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "f9194709dc0b7c58e2925a5580d5a96d66c7939b", "filename": "src/test/ui/consts/const-eval/issue-44578.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-44578.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-44578.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-44578.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -25,5 +25,5 @@ impl Foo for u16 {\n \n fn main() {\n     println!(\"{}\", <Bar<u16, u8> as Foo>::AMT);\n-    //~^ ERROR E0080\n+    //~^ ERROR evaluation of constant expression failed [E0080]\n }"}, {"sha": "5c3635e4650cd4ee059bf16fb854fc84c73006aa", "filename": "src/test/ui/consts/const-eval/issue-50814.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-50814.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-50814.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-50814.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -12,11 +12,13 @@ impl Unsigned for U8 {\n struct Sum<A,B>(A,B);\n \n impl<A: Unsigned, B: Unsigned> Unsigned for Sum<A,B> {\n-    const MAX: u8 = A::MAX + B::MAX; //~ ERROR any use of this value will cause an error\n+    const MAX: u8 = A::MAX + B::MAX;\n+    //~^ ERROR any use of this value will cause an error [const_err]\n }\n \n fn foo<T>(_: T) -> &'static u8 {\n-    &Sum::<U8,U8>::MAX //~ ERROR E0080\n+    &Sum::<U8,U8>::MAX\n+    //~^ ERROR E0080\n }\n \n fn main() {"}, {"sha": "2e5167a99a2c638abe4d04709be5a72760e3e8d6", "filename": "src/test/ui/consts/const-eval/issue-50814.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-50814.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-50814.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-50814.stderr?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -9,7 +9,7 @@ LL |     const MAX: u8 = A::MAX + B::MAX;\n    = note: `#[deny(const_err)]` on by default\n \n error[E0080]: evaluation of constant expression failed\n-  --> $DIR/issue-50814.rs:19:5\n+  --> $DIR/issue-50814.rs:20:5\n    |\n LL |     &Sum::<U8,U8>::MAX\n    |     ^-----------------"}, {"sha": "fee232185d29a93559f1a59058116a6139c76fc6", "filename": "src/test/ui/consts/const-eval/promoted_errors.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -1,20 +1,22 @@\n-// build-fail\n+// build-pass\n // compile-flags: -O\n \n-#![deny(const_err)]\n+#![warn(const_err)]\n \n fn main() {\n     println!(\"{}\", 0u32 - 1);\n     let _x = 0u32 - 1;\n-    //~^ ERROR const_err\n-    println!(\"{}\", 1/(1-1));\n-    //~^ ERROR attempt to divide by zero [const_err]\n-    //~| ERROR const_err\n-    let _x = 1/(1-1);\n-    //~^ ERROR const_err\n-    println!(\"{}\", 1/(false as u32));\n-    //~^ ERROR attempt to divide by zero [const_err]\n-    //~| ERROR const_err\n-    let _x = 1/(false as u32);\n-    //~^ ERROR const_err\n+    //~^ WARN const_err\n+    println!(\"{}\", 1 / (1 - 1));\n+    //~^ WARN attempt to divide by zero [const_err]\n+    //~| WARN const_err\n+    //~| WARN erroneous constant used [const_err]\n+    let _x = 1 / (1 - 1);\n+    //~^ WARN const_err\n+    println!(\"{}\", 1 / (false as u32));\n+    //~^ WARN attempt to divide by zero [const_err]\n+    //~| WARN const_err\n+    //~| WARN erroneous constant used [const_err]\n+    let _x = 1 / (false as u32);\n+    //~^ WARN const_err\n }"}, {"sha": "4de22fdf4ab1e4627d510fee7687bc45a7baa68d", "filename": "src/test/ui/consts/const-eval/promoted_errors.stderr", "status": "modified", "additions": 35, "deletions": 25, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.stderr?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -1,4 +1,4 @@\n-error: this expression will panic at runtime\n+warning: this expression will panic at runtime\n   --> $DIR/promoted_errors.rs:8:14\n    |\n LL |     let _x = 0u32 - 1;\n@@ -7,44 +7,54 @@ LL |     let _x = 0u32 - 1;\n note: lint level defined here\n   --> $DIR/promoted_errors.rs:4:9\n    |\n-LL | #![deny(const_err)]\n+LL | #![warn(const_err)]\n    |         ^^^^^^^^^\n \n-error: attempt to divide by zero\n+warning: attempt to divide by zero\n   --> $DIR/promoted_errors.rs:10:20\n    |\n-LL |     println!(\"{}\", 1/(1-1));\n-   |                    ^^^^^^^\n+LL |     println!(\"{}\", 1 / (1 - 1));\n+   |                    ^^^^^^^^^^^\n \n-error: reaching this expression at runtime will panic or abort\n+warning: reaching this expression at runtime will panic or abort\n   --> $DIR/promoted_errors.rs:10:20\n    |\n-LL |     println!(\"{}\", 1/(1-1));\n-   |                    ^^^^^^^ dividing by zero\n+LL |     println!(\"{}\", 1 / (1 - 1));\n+   |                    ^^^^^^^^^^^ dividing by zero\n \n-error: attempt to divide by zero\n-  --> $DIR/promoted_errors.rs:13:14\n+warning: erroneous constant used\n+  --> $DIR/promoted_errors.rs:10:20\n+   |\n+LL |     println!(\"{}\", 1 / (1 - 1));\n+   |                    ^^^^^^^^^^^ referenced constant has errors\n+\n+warning: attempt to divide by zero\n+  --> $DIR/promoted_errors.rs:14:14\n    |\n-LL |     let _x = 1/(1-1);\n-   |              ^^^^^^^\n+LL |     let _x = 1 / (1 - 1);\n+   |              ^^^^^^^^^^^\n \n-error: attempt to divide by zero\n-  --> $DIR/promoted_errors.rs:15:20\n+warning: attempt to divide by zero\n+  --> $DIR/promoted_errors.rs:16:20\n    |\n-LL |     println!(\"{}\", 1/(false as u32));\n-   |                    ^^^^^^^^^^^^^^^^\n+LL |     println!(\"{}\", 1 / (false as u32));\n+   |                    ^^^^^^^^^^^^^^^^^^\n \n-error: reaching this expression at runtime will panic or abort\n-  --> $DIR/promoted_errors.rs:15:20\n+warning: reaching this expression at runtime will panic or abort\n+  --> $DIR/promoted_errors.rs:16:20\n    |\n-LL |     println!(\"{}\", 1/(false as u32));\n-   |                    ^^^^^^^^^^^^^^^^ dividing by zero\n+LL |     println!(\"{}\", 1 / (false as u32));\n+   |                    ^^^^^^^^^^^^^^^^^^ dividing by zero\n \n-error: attempt to divide by zero\n-  --> $DIR/promoted_errors.rs:18:14\n+warning: erroneous constant used\n+  --> $DIR/promoted_errors.rs:16:20\n    |\n-LL |     let _x = 1/(false as u32);\n-   |              ^^^^^^^^^^^^^^^^\n+LL |     println!(\"{}\", 1 / (false as u32));\n+   |                    ^^^^^^^^^^^^^^^^^^ referenced constant has errors\n \n-error: aborting due to 7 previous errors\n+warning: attempt to divide by zero\n+  --> $DIR/promoted_errors.rs:20:14\n+   |\n+LL |     let _x = 1 / (false as u32);\n+   |              ^^^^^^^^^^^^^^^^^^\n "}, {"sha": "41a989d91c5d3f13407a9560d34abeaed015e21f", "filename": "src/test/ui/consts/const-eval/promoted_errors2.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors2.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -1,21 +1,23 @@\n-// build-fail\n+// build-pass\n // compile-flags: -C overflow-checks=on -O\n \n-#![deny(const_err)]\n+#![warn(const_err)]\n \n fn main() {\n     println!(\"{}\", 0u32 - 1);\n-    //~^ ERROR attempt to subtract with overflow\n+    //~^ WARN attempt to subtract with overflow\n     let _x = 0u32 - 1;\n-    //~^ ERROR attempt to subtract with overflow\n-    println!(\"{}\", 1/(1-1));\n-    //~^ ERROR attempt to divide by zero [const_err]\n-    //~| ERROR const_err\n-    let _x = 1/(1-1);\n-    //~^ ERROR const_err\n-    println!(\"{}\", 1/(false as u32));\n-    //~^ ERROR attempt to divide by zero [const_err]\n-    //~| ERROR const_err\n-    let _x = 1/(false as u32);\n-    //~^ ERROR const_err\n+    //~^ WARN attempt to subtract with overflow\n+    println!(\"{}\", 1 / (1 - 1));\n+    //~^ WARN attempt to divide by zero [const_err]\n+    //~| WARN const_err\n+    //~| WARN erroneous constant used [const_err]\n+    let _x = 1 / (1 - 1);\n+    //~^ WARN const_err\n+    println!(\"{}\", 1 / (false as u32));\n+    //~^ WARN attempt to divide by zero [const_err]\n+    //~| WARN const_err\n+    //~| WARN erroneous constant used [const_err]\n+    let _x = 1 / (false as u32);\n+    //~^ WARN const_err\n }"}, {"sha": "4f7ba8bf385d3c036d18ee05de861ee988691f25", "filename": "src/test/ui/consts/const-eval/promoted_errors2.stderr", "status": "modified", "additions": 36, "deletions": 26, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors2.stderr?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -1,4 +1,4 @@\n-error: attempt to subtract with overflow\n+warning: attempt to subtract with overflow\n   --> $DIR/promoted_errors2.rs:7:20\n    |\n LL |     println!(\"{}\", 0u32 - 1);\n@@ -7,50 +7,60 @@ LL |     println!(\"{}\", 0u32 - 1);\n note: lint level defined here\n   --> $DIR/promoted_errors2.rs:4:9\n    |\n-LL | #![deny(const_err)]\n+LL | #![warn(const_err)]\n    |         ^^^^^^^^^\n \n-error: attempt to subtract with overflow\n+warning: attempt to subtract with overflow\n   --> $DIR/promoted_errors2.rs:9:14\n    |\n LL |     let _x = 0u32 - 1;\n    |              ^^^^^^^^\n \n-error: attempt to divide by zero\n+warning: attempt to divide by zero\n   --> $DIR/promoted_errors2.rs:11:20\n    |\n-LL |     println!(\"{}\", 1/(1-1));\n-   |                    ^^^^^^^\n+LL |     println!(\"{}\", 1 / (1 - 1));\n+   |                    ^^^^^^^^^^^\n \n-error: reaching this expression at runtime will panic or abort\n+warning: reaching this expression at runtime will panic or abort\n   --> $DIR/promoted_errors2.rs:11:20\n    |\n-LL |     println!(\"{}\", 1/(1-1));\n-   |                    ^^^^^^^ dividing by zero\n+LL |     println!(\"{}\", 1 / (1 - 1));\n+   |                    ^^^^^^^^^^^ dividing by zero\n \n-error: attempt to divide by zero\n-  --> $DIR/promoted_errors2.rs:14:14\n+warning: erroneous constant used\n+  --> $DIR/promoted_errors2.rs:11:20\n+   |\n+LL |     println!(\"{}\", 1 / (1 - 1));\n+   |                    ^^^^^^^^^^^ referenced constant has errors\n+\n+warning: attempt to divide by zero\n+  --> $DIR/promoted_errors2.rs:15:14\n    |\n-LL |     let _x = 1/(1-1);\n-   |              ^^^^^^^\n+LL |     let _x = 1 / (1 - 1);\n+   |              ^^^^^^^^^^^\n \n-error: attempt to divide by zero\n-  --> $DIR/promoted_errors2.rs:16:20\n+warning: attempt to divide by zero\n+  --> $DIR/promoted_errors2.rs:17:20\n    |\n-LL |     println!(\"{}\", 1/(false as u32));\n-   |                    ^^^^^^^^^^^^^^^^\n+LL |     println!(\"{}\", 1 / (false as u32));\n+   |                    ^^^^^^^^^^^^^^^^^^\n \n-error: reaching this expression at runtime will panic or abort\n-  --> $DIR/promoted_errors2.rs:16:20\n+warning: reaching this expression at runtime will panic or abort\n+  --> $DIR/promoted_errors2.rs:17:20\n    |\n-LL |     println!(\"{}\", 1/(false as u32));\n-   |                    ^^^^^^^^^^^^^^^^ dividing by zero\n+LL |     println!(\"{}\", 1 / (false as u32));\n+   |                    ^^^^^^^^^^^^^^^^^^ dividing by zero\n \n-error: attempt to divide by zero\n-  --> $DIR/promoted_errors2.rs:19:14\n+warning: erroneous constant used\n+  --> $DIR/promoted_errors2.rs:17:20\n    |\n-LL |     let _x = 1/(false as u32);\n-   |              ^^^^^^^^^^^^^^^^\n+LL |     println!(\"{}\", 1 / (false as u32));\n+   |                    ^^^^^^^^^^^^^^^^^^ referenced constant has errors\n \n-error: aborting due to 8 previous errors\n+warning: attempt to divide by zero\n+  --> $DIR/promoted_errors2.rs:21:14\n+   |\n+LL |     let _x = 1 / (false as u32);\n+   |              ^^^^^^^^^^^^^^^^^^\n "}, {"sha": "ea9fffa883ea5e83fb739323123e01531bd7d44a", "filename": "src/test/ui/consts/const-eval/ub-nonnull.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -13,7 +13,7 @@ LL | / const OUT_OF_BOUNDS_PTR: NonNull<u8> = { unsafe {\n LL | |     let ptr: &[u8; 256] = mem::transmute(&0u8); // &0 gets promoted so it does not dangle\n LL | |     // Use address-of-element for pointer arithmetic. This could wrap around to NULL!\n LL | |     let out_of_bounds_ptr = &ptr[255];\n-   | |                             ^^^^^^^^^ Memory access failed: pointer must be in-bounds at offset 256, but is outside bounds of allocation 6 which has size 1\n+   | |                             ^^^^^^^^^ Memory access failed: pointer must be in-bounds at offset 256, but is outside bounds of allocation 9 which has size 1\n LL | |     mem::transmute(out_of_bounds_ptr)\n LL | | } };\n    | |____-"}, {"sha": "cfb57d21ceec5ffc10a05f1e9490faa7351285c9", "filename": "src/test/ui/consts/miri_unleashed/non_const_fn.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fnon_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fnon_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fnon_const_fn.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -11,5 +11,7 @@ const C: () = foo(); //~ WARN: skipping const checks\n //~^ WARN any use of this value will cause an error\n \n fn main() {\n-    println!(\"{:?}\", C); //~ ERROR: evaluation of constant expression failed\n+    println!(\"{:?}\", C);\n+    //~^ ERROR: evaluation of constant expression failed\n+    //~| WARN: erroneous constant used [const_err]\n }"}, {"sha": "6a7df858febcf38d863a4e8d2b934e68bfa83571", "filename": "src/test/ui/consts/miri_unleashed/non_const_fn.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fnon_const_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fnon_const_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fnon_const_fn.stderr?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -24,6 +24,12 @@ error[E0080]: evaluation of constant expression failed\n LL |     println!(\"{:?}\", C);\n    |                      ^ referenced constant has errors\n \n+warning: erroneous constant used\n+  --> $DIR/non_const_fn.rs:14:22\n+   |\n+LL |     println!(\"{:?}\", C);\n+   |                      ^ referenced constant has errors\n+\n error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "2a41f708c2b87be80dc709ddd19b0b6050e6a014", "filename": "src/test/ui/consts/zst_no_llvm_alloc.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fzst_no_llvm_alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fconsts%2Fzst_no_llvm_alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fzst_no_llvm_alloc.rs?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -7,13 +7,15 @@ static FOO: Foo = Foo;\n \n fn main() {\n     let x: &'static () = &();\n-    assert_eq!(x as *const () as usize, 1);\n+    assert_ne!(x as *const () as usize, 1);\n     let x: &'static Foo = &Foo;\n-    assert_eq!(x as *const Foo as usize, 4);\n+    assert_ne!(x as *const Foo as usize, 4);\n \n     // statics must have a unique address\n     assert_ne!(&FOO as *const Foo as usize, 4);\n \n-    assert_eq!(<Vec<i32>>::new().as_ptr(), <&[i32]>::default().as_ptr());\n-    assert_eq!(<Box<[i32]>>::default().as_ptr(), (&[]).as_ptr());\n+    // FIXME this two tests should be assert_eq!\n+    // this stopped working since we are promoting to constants instead of statics\n+    assert_ne!(<Vec<i32>>::new().as_ptr(), <&[i32]>::default().as_ptr());\n+    assert_ne!(<Box<[i32]>>::default().as_ptr(), (&[]).as_ptr());\n }"}, {"sha": "5d7664cefb33aa47522be9c7f308db19230c0300", "filename": "src/test/ui/invalid_const_promotion.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Finvalid_const_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Finvalid_const_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid_const_promotion.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -1,61 +0,0 @@\n-// run-pass\n-\n-#![allow(unused_mut)]\n-// ignore-wasm32\n-// ignore-emscripten\n-// ignore-sgx no processes\n-\n-// compile-flags: -C debug_assertions=yes\n-\n-#![stable(feature = \"rustc\", since = \"1.0.0\")]\n-#![feature(const_fn, rustc_private, staged_api, rustc_attrs)]\n-#![allow(const_err)]\n-\n-extern crate libc;\n-\n-use std::env;\n-use std::process::{Command, Stdio};\n-\n-// this will panic in debug mode and overflow in release mode\n-//\n-// NB we give bar an unused argument because otherwise memoization\n-// of the const fn kicks in, causing a different code path in the\n-// compiler to be executed (see PR #66294).\n-#[stable(feature = \"rustc\", since = \"1.0.0\")]\n-#[rustc_const_stable(feature = \"rustc\", since = \"1.0.0\")]\n-#[rustc_promotable]\n-const fn bar(_: bool) -> usize { 0 - 1 }\n-\n-fn foo() {\n-    let _: &'static _ = &bar(true);\n-}\n-\n-#[cfg(unix)]\n-fn check_status(status: std::process::ExitStatus)\n-{\n-    use std::os::unix::process::ExitStatusExt;\n-\n-    assert!(status.signal() == Some(libc::SIGILL)\n-            || status.signal() == Some(libc::SIGTRAP)\n-            || status.signal() == Some(libc::SIGABRT));\n-}\n-\n-#[cfg(not(unix))]\n-fn check_status(status: std::process::ExitStatus)\n-{\n-    assert!(!status.success());\n-}\n-\n-fn main() {\n-    let args: Vec<String> = env::args().collect();\n-    if args.len() > 1 && args[1] == \"test\" {\n-        foo();\n-        return;\n-    }\n-\n-    let mut p = Command::new(&args[0])\n-        .stdout(Stdio::piped())\n-        .stdin(Stdio::piped())\n-        .arg(\"test\").output().unwrap();\n-    check_status(p.status);\n-}"}, {"sha": "affb5537b18564a307344eade4dc84d3fbbaa367", "filename": "src/test/ui/symbol-names/impl1.legacy.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.legacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1389494ac145a84dba025ff65969f7ab150c3f02/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.legacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.legacy.stderr?ref=1389494ac145a84dba025ff65969f7ab150c3f02", "patch": "@@ -46,13 +46,13 @@ error: def-path(bar::<impl foo::Foo>::baz)\n LL |         #[rustc_def_path]\n    |         ^^^^^^^^^^^^^^^^^\n \n-error: symbol-name(_ZN209_$LT$$u5b$$RF$dyn$u20$impl1..Foo$u2b$Assoc$u20$$u3d$$u20$extern$u20$$u22$C$u22$$u20$fn$LP$$RF$u8$C$$u20$...$RP$$u2b$impl1..AutoTrait$u3b$$u20$_$u5d$$u20$as$u20$impl1..main..$u7b$$u7b$closure$u7d$$u7d$..Bar$GT$6method17h92c563325b7ff21aE)\n+error: symbol-name(_ZN209_$LT$$u5b$$RF$dyn$u20$impl1..Foo$u2b$Assoc$u20$$u3d$$u20$extern$u20$$u22$C$u22$$u20$fn$LP$$RF$u8$C$$u20$...$RP$$u2b$impl1..AutoTrait$u3b$$u20$_$u5d$$u20$as$u20$impl1..main..$u7b$$u7b$closure$u7d$$u7d$..Bar$GT$6method17hf07584432cd4d8beE)\n   --> $DIR/impl1.rs:62:13\n    |\n LL |             #[rustc_symbol_name]\n    |             ^^^^^^^^^^^^^^^^^^^^\n \n-error: demangling(<[&dyn impl1::Foo+Assoc = extern \"C\" fn(&u8, ::.)+impl1::AutoTrait; _] as impl1::main::{{closure}}::Bar>::method::h92c563325b7ff21a)\n+error: demangling(<[&dyn impl1::Foo+Assoc = extern \"C\" fn(&u8, ::.)+impl1::AutoTrait; _] as impl1::main::{{closure}}::Bar>::method::hf07584432cd4d8be)\n   --> $DIR/impl1.rs:62:13\n    |\n LL |             #[rustc_symbol_name]"}]}