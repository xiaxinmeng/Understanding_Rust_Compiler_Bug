{"sha": "af995ce1e7fe8c30c8f5da3d04e0e2e89762bde4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmOTk1Y2UxZTdmZThjMzBjOGY1ZGEzZDA0ZTBlMmU4OTc2MmJkZTQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-28T20:44:53Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-30T06:02:55Z"}, "message": "Make missing documentation linting more robust\n\nAdd some more cases for warning about missing documentation, and also add a test\nto make sure it doesn't die in the future.", "tree": {"sha": "ca004c17789f9c55bada330a9dbd5387840a4aac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca004c17789f9c55bada330a9dbd5387840a4aac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af995ce1e7fe8c30c8f5da3d04e0e2e89762bde4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af995ce1e7fe8c30c8f5da3d04e0e2e89762bde4", "html_url": "https://github.com/rust-lang/rust/commit/af995ce1e7fe8c30c8f5da3d04e0e2e89762bde4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af995ce1e7fe8c30c8f5da3d04e0e2e89762bde4/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a3bf8bdef513c889117ab6a90b463fc0b2e2642", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a3bf8bdef513c889117ab6a90b463fc0b2e2642", "html_url": "https://github.com/rust-lang/rust/commit/3a3bf8bdef513c889117ab6a90b463fc0b2e2642"}], "stats": {"total": 252, "additions": 177, "deletions": 75}, "files": [{"sha": "fcb08180a5ea27565ff9f3a854c9981c8df6d866", "filename": "src/librustc/front/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af995ce1e7fe8c30c8f5da3d04e0e2e89762bde4/src%2Flibrustc%2Ffront%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af995ce1e7fe8c30c8f5da3d04e0e2e89762bde4/src%2Flibrustc%2Ffront%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fintrinsic.rs?ref=af995ce1e7fe8c30c8f5da3d04e0e2e89762bde4", "patch": "@@ -12,6 +12,8 @@\n // and injected into each crate the compiler builds. Keep it small.\n \n pub mod intrinsic {\n+    #[allow(missing_doc)];\n+\n     pub use intrinsic::rusti::visit_tydesc;\n \n     // FIXME (#3727): remove this when the interface has settled and the"}, {"sha": "c42c8b8bb84773651297e0afe64cb218312e5d52", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 103, "deletions": 75, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/af995ce1e7fe8c30c8f5da3d04e0e2e89762bde4/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af995ce1e7fe8c30c8f5da3d04e0e2e89762bde4/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=af995ce1e7fe8c30c8f5da3d04e0e2e89762bde4", "patch": "@@ -95,8 +95,7 @@ pub enum lint {\n     unused_mut,\n     unnecessary_allocation,\n \n-    missing_struct_doc,\n-    missing_trait_doc,\n+    missing_doc,\n }\n \n pub fn level_to_str(lv: level) -> &'static str {\n@@ -268,17 +267,10 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n         default: warn\n     }),\n \n-    (\"missing_struct_doc\",\n+    (\"missing_doc\",\n      LintSpec {\n-        lint: missing_struct_doc,\n-        desc: \"detects missing documentation for structs\",\n-        default: allow\n-    }),\n-\n-    (\"missing_trait_doc\",\n-     LintSpec {\n-        lint: missing_trait_doc,\n-        desc: \"detects missing documentation for traits\",\n+        lint: missing_doc,\n+        desc: \"detects missing documentation for public members\",\n         default: allow\n     }),\n ];\n@@ -302,6 +294,9 @@ struct Context {\n     curr: SmallIntMap<(level, LintSource)>,\n     // context we're checking in (used to access fields like sess)\n     tcx: ty::ctxt,\n+    // Just a simple flag if we're currently recursing into a trait\n+    // implementation. This is only used by the lint_missing_doc() pass\n+    in_trait_impl: bool,\n     // When recursing into an attributed node of the ast which modifies lint\n     // levels, this stack keeps track of the previous lint levels of whatever\n     // was modified.\n@@ -311,7 +306,15 @@ struct Context {\n     // Others operate directly on @ast::item structures (or similar). Finally,\n     // others still are added to the Session object via `add_lint`, and these\n     // are all passed with the lint_session visitor.\n-    visitors: ~[visit::vt<@mut Context>],\n+    //\n+    // This is a pair so every visitor can visit every node. When a lint pass is\n+    // registered, another visitor is created which stops at all items which can\n+    // alter the attributes of the ast. This \"item stopping visitor\" is the\n+    // second element of the pair, while the original visitor is the first\n+    // element. This means that when visiting a node, the original recursive\n+    // call can used the original visitor's method, although the recursing\n+    // visitor supplied to the method is the item stopping visitor.\n+    visitors: ~[(visit::vt<@mut Context>, visit::vt<@mut Context>)],\n }\n \n impl Context {\n@@ -429,29 +432,31 @@ impl Context {\n     }\n \n     fn add_lint(&mut self, v: visit::vt<@mut Context>) {\n-        self.visitors.push(item_stopping_visitor(v));\n+        self.visitors.push((v, item_stopping_visitor(v)));\n     }\n \n     fn process(@mut self, n: AttributedNode) {\n+        // see comment of the `visitors` field in the struct for why there's a\n+        // pair instead of just one visitor.\n         match n {\n             Item(it) => {\n-                for self.visitors.each |v| {\n-                    visit::visit_item(it, self, *v);\n+                for self.visitors.each |&(orig, stopping)| {\n+                    (orig.visit_item)(it, self, stopping);\n                 }\n             }\n             Crate(c) => {\n-                for self.visitors.each |v| {\n-                    visit::visit_crate(c, self, *v);\n+                for self.visitors.each |&(_, stopping)| {\n+                    visit::visit_crate(c, self, stopping);\n                 }\n             }\n             // Can't use visit::visit_method_helper because the\n             // item_stopping_visitor has overridden visit_fn(&fk_method(... ))\n             // to be a no-op, so manually invoke visit_fn.\n             Method(m) => {\n                 let fk = visit::fk_method(copy m.ident, &m.generics, m);\n-                for self.visitors.each |v| {\n-                    visit::visit_fn(&fk, &m.decl, &m.body, m.span, m.id,\n-                                    self, *v);\n+                for self.visitors.each |&(orig, stopping)| {\n+                    (orig.visit_fn)(&fk, &m.decl, &m.body, m.span, m.id,\n+                                    self, stopping);\n                 }\n             }\n         }\n@@ -495,16 +500,16 @@ pub fn each_lint(sess: session::Session,\n // This is used to make the simple visitors used for the lint passes\n // not traverse into subitems, since that is handled by the outer\n // lint visitor.\n-fn item_stopping_visitor<E: Copy>(v: visit::vt<E>) -> visit::vt<E> {\n+fn item_stopping_visitor<E: Copy>(outer: visit::vt<E>) -> visit::vt<E> {\n     visit::mk_vt(@visit::Visitor {\n         visit_item: |_i, _e, _v| { },\n         visit_fn: |fk, fd, b, s, id, e, v| {\n             match *fk {\n                 visit::fk_method(*) => {}\n-                _ => visit::visit_fn(fk, fd, b, s, id, e, v)\n+                _ => (outer.visit_fn)(fk, fd, b, s, id, e, v)\n             }\n         },\n-    .. **(ty_stopping_visitor(v))})\n+    .. **(ty_stopping_visitor(outer))})\n }\n \n fn ty_stopping_visitor<E>(v: visit::vt<E>) -> visit::vt<E> {\n@@ -972,68 +977,84 @@ fn lint_unnecessary_allocations() -> visit::vt<@mut Context> {\n     })\n }\n \n-fn lint_missing_struct_doc() -> visit::vt<@mut Context> {\n+fn lint_missing_doc() -> visit::vt<@mut Context> {\n+    fn check_attrs(cx: @mut Context, attrs: &[ast::attribute],\n+                   sp: span, msg: &str) {\n+        if !attrs.any(|a| a.node.is_sugared_doc) {\n+            cx.span_lint(missing_doc, sp, msg);\n+        }\n+    }\n+\n     visit::mk_vt(@visit::Visitor {\n-        visit_struct_field: |field, cx: @mut Context, vt| {\n-            let relevant = match field.node.kind {\n-                ast::named_field(_, vis) => vis != ast::private,\n-                ast::unnamed_field => false,\n-            };\n+        visit_struct_method: |m, cx, vt| {\n+            if m.vis == ast::public {\n+                check_attrs(cx, m.attrs, m.span,\n+                            \"missing documentation for a method\");\n+            }\n+            visit::visit_struct_method(m, cx, vt);\n+        },\n+\n+        visit_ty_method: |m, cx, vt| {\n+            // All ty_method objects are linted about because they're part of a\n+            // trait (no visibility)\n+            check_attrs(cx, m.attrs, m.span,\n+                        \"missing documentation for a method\");\n+            visit::visit_ty_method(m, cx, vt);\n+        },\n \n-            if relevant {\n-                let mut has_doc = false;\n-                for field.node.attrs.each |attr| {\n-                    if attr.node.is_sugared_doc {\n-                        has_doc = true;\n-                        break;\n+        visit_fn: |fk, d, b, sp, id, cx, vt| {\n+            // Only warn about explicitly public methods. Soon implicit\n+            // public-ness will hopefully be going away.\n+            match *fk {\n+                visit::fk_method(_, _, m) if m.vis == ast::public => {\n+                    // If we're in a trait implementation, no need to duplicate\n+                    // documentation\n+                    if !cx.in_trait_impl {\n+                        check_attrs(cx, m.attrs, sp,\n+                                    \"missing documentation for a method\");\n                     }\n                 }\n-                if !has_doc {\n-                    cx.span_lint(missing_struct_doc, field.span, \"missing documentation \\\n-                                                                  for a field.\");\n-                }\n-            }\n \n-            visit::visit_struct_field(field, cx, vt);\n+                _ => {}\n+            }\n+            visit::visit_fn(fk, d, b, sp, id, cx, vt);\n         },\n-        .. *visit::default_visitor()\n-    })\n-}\n \n-fn lint_missing_trait_doc() -> visit::vt<@mut Context> {\n-    visit::mk_vt(@visit::Visitor {\n-        visit_trait_method: |method, cx: @mut Context, vt| {\n-            let mut has_doc = false;\n-            let span = match copy *method {\n-                ast::required(m) => {\n-                    for m.attrs.each |attr| {\n-                        if attr.node.is_sugared_doc {\n-                            has_doc = true;\n-                            break;\n-                        }\n-                    }\n-                    m.span\n-                },\n-                ast::provided(m) => {\n-                    if m.vis == ast::private {\n-                        has_doc = true;\n-                    } else {\n-                        for m.attrs.each |attr| {\n-                            if attr.node.is_sugared_doc {\n-                                has_doc = true;\n-                                break;\n+        visit_item: |it, cx, vt| {\n+            match it.node {\n+                // Go ahead and match the fields here instead of using\n+                // visit_struct_field while we have access to the enclosing\n+                // struct's visibility\n+                ast::item_struct(sdef, _) if it.vis == ast::public => {\n+                    check_attrs(cx, it.attrs, it.span,\n+                                \"missing documentation for a struct\");\n+                    for sdef.fields.each |field| {\n+                        match field.node.kind {\n+                            ast::named_field(_, vis) if vis != ast::private => {\n+                                check_attrs(cx, field.node.attrs, field.span,\n+                                            \"missing documentation for a field\");\n                             }\n+                            ast::unnamed_field | ast::named_field(*) => {}\n                         }\n                     }\n-                    m.span\n                 }\n+\n+                ast::item_trait(*) if it.vis == ast::public => {\n+                    check_attrs(cx, it.attrs, it.span,\n+                                \"missing documentation for a trait\");\n+                }\n+\n+                ast::item_fn(*) if it.vis == ast::public => {\n+                    check_attrs(cx, it.attrs, it.span,\n+                                \"missing documentation for a function\");\n+                }\n+\n+                _ => {}\n             };\n-            if !has_doc {\n-                cx.span_lint(missing_trait_doc, span, \"missing documentation \\\n-                                                       for a method.\");\n-            }\n-            visit::visit_trait_method(method, cx, vt);\n+\n+            visit::visit_item(it, cx, vt);\n         },\n+\n         .. *visit::default_visitor()\n     })\n }\n@@ -1045,6 +1066,7 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n         tcx: tcx,\n         lint_stack: ~[],\n         visitors: ~[],\n+        in_trait_impl: false,\n     };\n \n     // Install defaults.\n@@ -1066,8 +1088,7 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n     cx.add_lint(lint_unused_mut());\n     cx.add_lint(lint_session());\n     cx.add_lint(lint_unnecessary_allocations());\n-    cx.add_lint(lint_missing_struct_doc());\n-    cx.add_lint(lint_missing_trait_doc());\n+    cx.add_lint(lint_missing_doc());\n \n     // Actually perform the lint checks (iterating the ast)\n     do cx.with_lint_attrs(crate.node.attrs) {\n@@ -1076,13 +1097,20 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n         visit::visit_crate(crate, cx, visit::mk_vt(@visit::Visitor {\n             visit_item: |it, cx: @mut Context, vt| {\n                 do cx.with_lint_attrs(it.attrs) {\n+                    match it.node {\n+                        ast::item_impl(_, Some(*), _, _) => {\n+                            cx.in_trait_impl = true;\n+                        }\n+                        _ => {}\n+                    }\n                     check_item_ctypes(cx, it);\n                     check_item_non_camel_case_types(cx, it);\n                     check_item_default_methods(cx, it);\n                     check_item_heap(cx, it);\n \n                     cx.process(Item(it));\n                     visit::visit_item(it, cx, vt);\n+                    cx.in_trait_impl = false;\n                 }\n             },\n             visit_fn: |fk, decl, body, span, id, cx, vt| {"}, {"sha": "fd0b0fb80f8171adc39948de4a47abd20d83d666", "filename": "src/test/compile-fail/lint-missing-doc.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/af995ce1e7fe8c30c8f5da3d04e0e2e89762bde4/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af995ce1e7fe8c30c8f5da3d04e0e2e89762bde4/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs?ref=af995ce1e7fe8c30c8f5da3d04e0e2e89762bde4", "patch": "@@ -0,0 +1,72 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// When denying at the crate level, be sure to not get random warnings from the\n+// injected intrinsics by the compiler.\n+#[deny(missing_doc)];\n+\n+struct Foo {\n+    a: int,\n+    priv b: int,\n+    pub c: int, // doesn't matter, Foo is private\n+}\n+\n+pub struct PubFoo { //~ ERROR: missing documentation\n+    a: int,      //~ ERROR: missing documentation\n+    priv b: int,\n+    pub c: int,  //~ ERROR: missing documentation\n+}\n+\n+#[allow(missing_doc)]\n+pub struct PubFoo2 {\n+    a: int,\n+    pub c: int,\n+}\n+\n+/// dox\n+pub fn foo() {}\n+pub fn foo2() {} //~ ERROR: missing documentation\n+fn foo3() {}\n+#[allow(missing_doc)] pub fn foo4() {}\n+\n+/// dox\n+pub trait A {}\n+trait B {}\n+pub trait C {} //~ ERROR: missing documentation\n+#[allow(missing_doc)] pub trait D {}\n+\n+trait Bar {\n+    /// dox\n+    pub fn foo();\n+    fn foo2(); //~ ERROR: missing documentation\n+    pub fn foo3(); //~ ERROR: missing documentation\n+}\n+\n+impl Foo {\n+    pub fn foo() {} //~ ERROR: missing documentation\n+    /// dox\n+    pub fn foo1() {}\n+    fn foo2() {}\n+    #[allow(missing_doc)] pub fn foo3() {}\n+}\n+\n+#[allow(missing_doc)]\n+trait F {\n+    pub fn a();\n+    fn b(&self);\n+}\n+\n+// should need to redefine documentation for implementations of traits\n+impl F for Foo {\n+    pub fn a() {}\n+    fn b(&self) {}\n+}\n+\n+fn main() {}"}]}