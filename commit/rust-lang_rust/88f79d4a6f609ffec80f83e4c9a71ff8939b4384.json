{"sha": "88f79d4a6f609ffec80f83e4c9a71ff8939b4384", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4Zjc5ZDRhNmY2MDlmZmVjODBmODNlNGM5YTcxZmY4OTM5YjQzODQ=", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-08-07T20:20:20Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-08-07T20:20:20Z"}, "message": "Remove aliases from op trait impls", "tree": {"sha": "4d5eed56499bae2ce37f631a6b2fe1164a016fe6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d5eed56499bae2ce37f631a6b2fe1164a016fe6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88f79d4a6f609ffec80f83e4c9a71ff8939b4384", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88f79d4a6f609ffec80f83e4c9a71ff8939b4384", "html_url": "https://github.com/rust-lang/rust/commit/88f79d4a6f609ffec80f83e4c9a71ff8939b4384", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88f79d4a6f609ffec80f83e4c9a71ff8939b4384/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ed57b4c85a7a9c104b093afbf54d5b7e25069de", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ed57b4c85a7a9c104b093afbf54d5b7e25069de", "html_url": "https://github.com/rust-lang/rust/commit/5ed57b4c85a7a9c104b093afbf54d5b7e25069de"}], "stats": {"total": 627, "additions": 302, "deletions": 325}, "files": [{"sha": "651498817c3874bbcb5ff4d86fe7627951210544", "filename": "crates/core_simd/src/ops.rs", "status": "modified", "additions": 302, "deletions": 325, "changes": 627, "blob_url": "https://github.com/rust-lang/rust/blob/88f79d4a6f609ffec80f83e4c9a71ff8939b4384/crates%2Fcore_simd%2Fsrc%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f79d4a6f609ffec80f83e4c9a71ff8939b4384/crates%2Fcore_simd%2Fsrc%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fops.rs?ref=88f79d4a6f609ffec80f83e4c9a71ff8939b4384", "patch": "@@ -155,40 +155,40 @@ macro_rules! impl_ref_ops {\n \n /// Automatically implements operators over vectors and scalars for a particular vector.\n macro_rules! impl_op {\n-    { impl Add for $type:ident, $scalar:ty } => {\n-        impl_op! { @binary $type, $scalar, Add::add, AddAssign::add_assign, simd_add }\n+    { impl Add for $scalar:ty } => {\n+        impl_op! { @binary $scalar, Add::add, AddAssign::add_assign, simd_add }\n     };\n-    { impl Sub for $type:ident, $scalar:ty } => {\n-        impl_op! { @binary $type, $scalar, Sub::sub, SubAssign::sub_assign, simd_sub }\n+    { impl Sub for $scalar:ty } => {\n+        impl_op! { @binary $scalar, Sub::sub, SubAssign::sub_assign, simd_sub }\n     };\n-    { impl Mul for $type:ident, $scalar:ty } => {\n-        impl_op! { @binary $type, $scalar, Mul::mul, MulAssign::mul_assign, simd_mul }\n+    { impl Mul for $scalar:ty } => {\n+        impl_op! { @binary $scalar, Mul::mul, MulAssign::mul_assign, simd_mul }\n     };\n-    { impl Div for $type:ident, $scalar:ty } => {\n-        impl_op! { @binary $type, $scalar, Div::div, DivAssign::div_assign, simd_div }\n+    { impl Div for $scalar:ty } => {\n+        impl_op! { @binary $scalar, Div::div, DivAssign::div_assign, simd_div }\n     };\n-    { impl Rem for $type:ident, $scalar:ty } => {\n-        impl_op! { @binary $type, $scalar, Rem::rem, RemAssign::rem_assign, simd_rem }\n+    { impl Rem for $scalar:ty } => {\n+        impl_op! { @binary $scalar, Rem::rem, RemAssign::rem_assign, simd_rem }\n     };\n-    { impl Shl for $type:ident, $scalar:ty } => {\n-        impl_op! { @binary $type, $scalar, Shl::shl, ShlAssign::shl_assign, simd_shl }\n+    { impl Shl for $scalar:ty } => {\n+        impl_op! { @binary $scalar, Shl::shl, ShlAssign::shl_assign, simd_shl }\n     };\n-    { impl Shr for $type:ident, $scalar:ty } => {\n-        impl_op! { @binary $type, $scalar, Shr::shr, ShrAssign::shr_assign, simd_shr }\n+    { impl Shr for $scalar:ty } => {\n+        impl_op! { @binary $scalar, Shr::shr, ShrAssign::shr_assign, simd_shr }\n     };\n-    { impl BitAnd for $type:ident, $scalar:ty } => {\n-        impl_op! { @binary $type, $scalar, BitAnd::bitand, BitAndAssign::bitand_assign, simd_and }\n+    { impl BitAnd for $scalar:ty } => {\n+        impl_op! { @binary $scalar, BitAnd::bitand, BitAndAssign::bitand_assign, simd_and }\n     };\n-    { impl BitOr for $type:ident, $scalar:ty } => {\n-        impl_op! { @binary $type, $scalar, BitOr::bitor, BitOrAssign::bitor_assign, simd_or }\n+    { impl BitOr for $scalar:ty } => {\n+        impl_op! { @binary $scalar, BitOr::bitor, BitOrAssign::bitor_assign, simd_or }\n     };\n-    { impl BitXor for $type:ident, $scalar:ty } => {\n-        impl_op! { @binary $type, $scalar, BitXor::bitxor, BitXorAssign::bitxor_assign, simd_xor }\n+    { impl BitXor for $scalar:ty } => {\n+        impl_op! { @binary $scalar, BitXor::bitxor, BitXorAssign::bitxor_assign, simd_xor }\n     };\n \n-    { impl Not for $type:ident, $scalar:ty } => {\n+    { impl Not for $scalar:ty } => {\n         impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::Not for crate::$type<LANES>\n+            impl<const LANES: usize> core::ops::Not for Simd<$scalar, LANES>\n             where\n                 LaneCount<LANES>: SupportedLaneCount,\n             {\n@@ -200,9 +200,9 @@ macro_rules! impl_op {\n         }\n     };\n \n-    { impl Neg for $type:ident, $scalar:ty } => {\n+    { impl Neg for $scalar:ty } => {\n         impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::Neg for crate::$type<LANES>\n+            impl<const LANES: usize> core::ops::Neg for Simd<$scalar, LANES>\n             where\n                 LaneCount<LANES>: SupportedLaneCount,\n             {\n@@ -215,9 +215,9 @@ macro_rules! impl_op {\n     };\n \n     // generic binary op with assignment when output is `Self`\n-    { @binary $type:ident, $scalar:ty, $trait:ident :: $trait_fn:ident, $assign_trait:ident :: $assign_trait_fn:ident, $intrinsic:ident } => {\n+    { @binary $scalar:ty, $trait:ident :: $trait_fn:ident, $assign_trait:ident :: $assign_trait_fn:ident, $intrinsic:ident } => {\n         impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::$trait<Self> for crate::$type<LANES>\n+            impl<const LANES: usize> core::ops::$trait<Self> for Simd<$scalar, LANES>\n             where\n                 LaneCount<LANES>: SupportedLaneCount,\n             {\n@@ -233,7 +233,7 @@ macro_rules! impl_op {\n         }\n \n         impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::$trait<$scalar> for crate::$type<LANES>\n+            impl<const LANES: usize> core::ops::$trait<$scalar> for Simd<$scalar, LANES>\n             where\n                 LaneCount<LANES>: SupportedLaneCount,\n             {\n@@ -247,21 +247,21 @@ macro_rules! impl_op {\n         }\n \n         impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::$trait<crate::$type<LANES>> for $scalar\n+            impl<const LANES: usize> core::ops::$trait<Simd<$scalar, LANES>> for $scalar\n             where\n                 LaneCount<LANES>: SupportedLaneCount,\n             {\n-                type Output = crate::$type<LANES>;\n+                type Output = Simd<$scalar, LANES>;\n \n                 #[inline]\n-                fn $trait_fn(self, rhs: crate::$type<LANES>) -> Self::Output {\n-                    core::ops::$trait::$trait_fn(crate::$type::splat(self), rhs)\n+                fn $trait_fn(self, rhs: Simd<$scalar, LANES>) -> Self::Output {\n+                    core::ops::$trait::$trait_fn(Simd::splat(self), rhs)\n                 }\n             }\n         }\n \n         impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::$assign_trait<Self> for crate::$type<LANES>\n+            impl<const LANES: usize> core::ops::$assign_trait<Self> for Simd<$scalar, LANES>\n             where\n                 LaneCount<LANES>: SupportedLaneCount,\n             {\n@@ -275,7 +275,7 @@ macro_rules! impl_op {\n         }\n \n         impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::$assign_trait<$scalar> for crate::$type<LANES>\n+            impl<const LANES: usize> core::ops::$assign_trait<$scalar> for Simd<$scalar, LANES>\n             where\n                 LaneCount<LANES>: SupportedLaneCount,\n             {\n@@ -290,377 +290,354 @@ macro_rules! impl_op {\n \n /// Implements floating-point operators for the provided types.\n macro_rules! impl_float_ops {\n-    { $($scalar:ty => $($vector:ident),*;)* } => {\n-        $( // scalar\n-            $( // vector\n-                impl_op! { impl Add for $vector, $scalar }\n-                impl_op! { impl Sub for $vector, $scalar }\n-                impl_op! { impl Mul for $vector, $scalar }\n-                impl_op! { impl Div for $vector, $scalar }\n-                impl_op! { impl Rem for $vector, $scalar }\n-                impl_op! { impl Neg for $vector, $scalar }\n-            )*\n+    { $($scalar:ty),* } => {\n+        $(\n+            impl_op! { impl Add for $scalar }\n+            impl_op! { impl Sub for $scalar }\n+            impl_op! { impl Mul for $scalar }\n+            impl_op! { impl Div for $scalar }\n+            impl_op! { impl Rem for $scalar }\n+            impl_op! { impl Neg for $scalar }\n         )*\n     };\n }\n \n /// Implements unsigned integer operators for the provided types.\n macro_rules! impl_unsigned_int_ops {\n-    { $($scalar:ty => $($vector:ident),*;)* } => {\n-        $( // scalar\n-            $( // vector\n-                impl_op! { impl Add for $vector, $scalar }\n-                impl_op! { impl Sub for $vector, $scalar }\n-                impl_op! { impl Mul for $vector, $scalar }\n-                impl_op! { impl BitAnd for $vector, $scalar }\n-                impl_op! { impl BitOr  for $vector, $scalar }\n-                impl_op! { impl BitXor for $vector, $scalar }\n-                impl_op! { impl Not for $vector, $scalar }\n-\n-                // Integers panic on divide by 0\n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::Div<Self> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        type Output = Self;\n-\n-                        #[inline]\n-                        fn div(self, rhs: Self) -> Self::Output {\n-                            if rhs.as_array()\n-                                .iter()\n-                                .any(|x| *x == 0)\n-                            {\n-                                panic!(\"attempt to divide by zero\");\n-                            }\n-\n-                            // Guards for div(MIN, -1),\n-                            // this check only applies to signed ints\n-                            if <$scalar>::MIN != 0 && self.as_array().iter()\n-                                    .zip(rhs.as_array().iter())\n-                                    .any(|(x,y)| *x == <$scalar>::MIN && *y == -1 as _) {\n-                                panic!(\"attempt to divide with overflow\");\n-                            }\n-                            unsafe { crate::intrinsics::simd_div(self, rhs) }\n+    { $($scalar:ty),* } => {\n+        $(\n+            impl_op! { impl Add for $scalar }\n+            impl_op! { impl Sub for $scalar }\n+            impl_op! { impl Mul for $scalar }\n+            impl_op! { impl BitAnd for $scalar }\n+            impl_op! { impl BitOr  for $scalar }\n+            impl_op! { impl BitXor for $scalar }\n+            impl_op! { impl Not for $scalar }\n+\n+            // Integers panic on divide by 0\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Div<Self> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Self;\n+\n+                    #[inline]\n+                    fn div(self, rhs: Self) -> Self::Output {\n+                        if rhs.as_array()\n+                            .iter()\n+                            .any(|x| *x == 0)\n+                        {\n+                            panic!(\"attempt to divide by zero\");\n                         }\n+\n+                        // Guards for div(MIN, -1),\n+                        // this check only applies to signed ints\n+                        if <$scalar>::MIN != 0 && self.as_array().iter()\n+                                .zip(rhs.as_array().iter())\n+                                .any(|(x,y)| *x == <$scalar>::MIN && *y == -1 as _) {\n+                            panic!(\"attempt to divide with overflow\");\n+                        }\n+                        unsafe { crate::intrinsics::simd_div(self, rhs) }\n                     }\n                 }\n+            }\n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::Div<$scalar> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        type Output = Self;\n-\n-                        #[inline]\n-                        fn div(self, rhs: $scalar) -> Self::Output {\n-                            if rhs == 0 {\n-                                panic!(\"attempt to divide by zero\");\n-                            }\n-                            if <$scalar>::MIN != 0 &&\n-                                self.as_array().iter().any(|x| *x == <$scalar>::MIN) &&\n-                                rhs == -1 as _ {\n-                                    panic!(\"attempt to divide with overflow\");\n-                            }\n-                            let rhs = Self::splat(rhs);\n-                            unsafe { crate::intrinsics::simd_div(self, rhs) }\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Div<$scalar> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Self;\n+\n+                    #[inline]\n+                    fn div(self, rhs: $scalar) -> Self::Output {\n+                        if rhs == 0 {\n+                            panic!(\"attempt to divide by zero\");\n                         }\n+                        if <$scalar>::MIN != 0 &&\n+                            self.as_array().iter().any(|x| *x == <$scalar>::MIN) &&\n+                            rhs == -1 as _ {\n+                                panic!(\"attempt to divide with overflow\");\n+                        }\n+                        let rhs = Self::splat(rhs);\n+                        unsafe { crate::intrinsics::simd_div(self, rhs) }\n                     }\n                 }\n+            }\n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::Div<crate::$vector<LANES>> for $scalar\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        type Output = crate::$vector<LANES>;\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Div<Simd<$scalar, LANES>> for $scalar\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Simd<$scalar, LANES>;\n \n-                        #[inline]\n-                        fn div(self, rhs: crate::$vector<LANES>) -> Self::Output {\n-                            crate::$vector::splat(self) / rhs\n-                        }\n+                    #[inline]\n+                    fn div(self, rhs: Simd<$scalar, LANES>) -> Self::Output {\n+                        Simd::splat(self) / rhs\n                     }\n                 }\n+            }\n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::DivAssign<Self> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        #[inline]\n-                        fn div_assign(&mut self, rhs: Self) {\n-                            *self = *self / rhs;\n-                        }\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::DivAssign<Self> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    #[inline]\n+                    fn div_assign(&mut self, rhs: Self) {\n+                        *self = *self / rhs;\n                     }\n                 }\n+            }\n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::DivAssign<$scalar> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        #[inline]\n-                        fn div_assign(&mut self, rhs: $scalar) {\n-                            *self = *self / rhs;\n-                        }\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::DivAssign<$scalar> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    #[inline]\n+                    fn div_assign(&mut self, rhs: $scalar) {\n+                        *self = *self / rhs;\n                     }\n                 }\n+            }\n \n-                // remainder panics on zero divisor\n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::Rem<Self> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        type Output = Self;\n-\n-                        #[inline]\n-                        fn rem(self, rhs: Self) -> Self::Output {\n-                            if rhs.as_array()\n-                                .iter()\n-                                .any(|x| *x == 0)\n-                            {\n-                                panic!(\"attempt to calculate the remainder with a divisor of zero\");\n-                            }\n-\n-                            // Guards for rem(MIN, -1)\n-                            // this branch applies the check only to signed ints\n-                            if <$scalar>::MIN != 0 && self.as_array().iter()\n-                                    .zip(rhs.as_array().iter())\n-                                    .any(|(x,y)| *x == <$scalar>::MIN && *y == -1 as _) {\n-                                panic!(\"attempt to calculate the remainder with overflow\");\n-                            }\n-                            unsafe { crate::intrinsics::simd_rem(self, rhs) }\n+            // remainder panics on zero divisor\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Rem<Self> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Self;\n+\n+                    #[inline]\n+                    fn rem(self, rhs: Self) -> Self::Output {\n+                        if rhs.as_array()\n+                            .iter()\n+                            .any(|x| *x == 0)\n+                        {\n+                            panic!(\"attempt to calculate the remainder with a divisor of zero\");\n+                        }\n+\n+                        // Guards for rem(MIN, -1)\n+                        // this branch applies the check only to signed ints\n+                        if <$scalar>::MIN != 0 && self.as_array().iter()\n+                                .zip(rhs.as_array().iter())\n+                                .any(|(x,y)| *x == <$scalar>::MIN && *y == -1 as _) {\n+                            panic!(\"attempt to calculate the remainder with overflow\");\n                         }\n+                        unsafe { crate::intrinsics::simd_rem(self, rhs) }\n                     }\n                 }\n+            }\n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::Rem<$scalar> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        type Output = Self;\n-\n-                        #[inline]\n-                        fn rem(self, rhs: $scalar) -> Self::Output {\n-                            if rhs == 0 {\n-                                panic!(\"attempt to calculate the remainder with a divisor of zero\");\n-                            }\n-                            if <$scalar>::MIN != 0 &&\n-                                self.as_array().iter().any(|x| *x == <$scalar>::MIN) &&\n-                                rhs == -1 as _ {\n-                                    panic!(\"attempt to calculate the remainder with overflow\");\n-                            }\n-                            let rhs = Self::splat(rhs);\n-                            unsafe { crate::intrinsics::simd_rem(self, rhs) }\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Rem<$scalar> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Self;\n+\n+                    #[inline]\n+                    fn rem(self, rhs: $scalar) -> Self::Output {\n+                        if rhs == 0 {\n+                            panic!(\"attempt to calculate the remainder with a divisor of zero\");\n+                        }\n+                        if <$scalar>::MIN != 0 &&\n+                            self.as_array().iter().any(|x| *x == <$scalar>::MIN) &&\n+                            rhs == -1 as _ {\n+                                panic!(\"attempt to calculate the remainder with overflow\");\n                         }\n+                        let rhs = Self::splat(rhs);\n+                        unsafe { crate::intrinsics::simd_rem(self, rhs) }\n                     }\n                 }\n+            }\n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::Rem<crate::$vector<LANES>> for $scalar\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        type Output = crate::$vector<LANES>;\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Rem<Simd<$scalar, LANES>> for $scalar\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Simd<$scalar, LANES>;\n \n-                        #[inline]\n-                        fn rem(self, rhs: crate::$vector<LANES>) -> Self::Output {\n-                            crate::$vector::splat(self) % rhs\n-                        }\n+                    #[inline]\n+                    fn rem(self, rhs: Simd<$scalar, LANES>) -> Self::Output {\n+                        Simd::splat(self) % rhs\n                     }\n                 }\n+            }\n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::RemAssign<Self> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        #[inline]\n-                        fn rem_assign(&mut self, rhs: Self) {\n-                            *self = *self % rhs;\n-                        }\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::RemAssign<Self> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    #[inline]\n+                    fn rem_assign(&mut self, rhs: Self) {\n+                        *self = *self % rhs;\n                     }\n                 }\n+            }\n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::RemAssign<$scalar> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        #[inline]\n-                        fn rem_assign(&mut self, rhs: $scalar) {\n-                            *self = *self % rhs;\n-                        }\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::RemAssign<$scalar> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    #[inline]\n+                    fn rem_assign(&mut self, rhs: $scalar) {\n+                        *self = *self % rhs;\n                     }\n                 }\n+            }\n \n-                // shifts panic on overflow\n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::Shl<Self> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        type Output = Self;\n-\n-                        #[inline]\n-                        fn shl(self, rhs: Self) -> Self::Output {\n-                            // TODO there is probably a better way of doing this\n-                            if rhs.as_array()\n-                                .iter()\n-                                .copied()\n-                                .any(invalid_shift_rhs)\n-                            {\n-                                panic!(\"attempt to shift left with overflow\");\n-                            }\n-                            unsafe { crate::intrinsics::simd_shl(self, rhs) }\n+            // shifts panic on overflow\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Shl<Self> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Self;\n+\n+                    #[inline]\n+                    fn shl(self, rhs: Self) -> Self::Output {\n+                        // TODO there is probably a better way of doing this\n+                        if rhs.as_array()\n+                            .iter()\n+                            .copied()\n+                            .any(invalid_shift_rhs)\n+                        {\n+                            panic!(\"attempt to shift left with overflow\");\n                         }\n+                        unsafe { crate::intrinsics::simd_shl(self, rhs) }\n                     }\n                 }\n+            }\n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::Shl<$scalar> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        type Output = Self;\n-\n-                        #[inline]\n-                        fn shl(self, rhs: $scalar) -> Self::Output {\n-                            if invalid_shift_rhs(rhs) {\n-                                panic!(\"attempt to shift left with overflow\");\n-                            }\n-                            let rhs = Self::splat(rhs);\n-                            unsafe { crate::intrinsics::simd_shl(self, rhs) }\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Shl<$scalar> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Self;\n+\n+                    #[inline]\n+                    fn shl(self, rhs: $scalar) -> Self::Output {\n+                        if invalid_shift_rhs(rhs) {\n+                            panic!(\"attempt to shift left with overflow\");\n                         }\n+                        let rhs = Self::splat(rhs);\n+                        unsafe { crate::intrinsics::simd_shl(self, rhs) }\n                     }\n                 }\n+            }\n \n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::ShlAssign<Self> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        #[inline]\n-                        fn shl_assign(&mut self, rhs: Self) {\n-                            *self = *self << rhs;\n-                        }\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::ShlAssign<Self> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    #[inline]\n+                    fn shl_assign(&mut self, rhs: Self) {\n+                        *self = *self << rhs;\n                     }\n                 }\n+            }\n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::ShlAssign<$scalar> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        #[inline]\n-                        fn shl_assign(&mut self, rhs: $scalar) {\n-                            *self = *self << rhs;\n-                        }\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::ShlAssign<$scalar> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    #[inline]\n+                    fn shl_assign(&mut self, rhs: $scalar) {\n+                        *self = *self << rhs;\n                     }\n                 }\n+            }\n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::Shr<Self> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        type Output = Self;\n-\n-                        #[inline]\n-                        fn shr(self, rhs: Self) -> Self::Output {\n-                            // TODO there is probably a better way of doing this\n-                            if rhs.as_array()\n-                                .iter()\n-                                .copied()\n-                                .any(invalid_shift_rhs)\n-                            {\n-                                panic!(\"attempt to shift with overflow\");\n-                            }\n-                            unsafe { crate::intrinsics::simd_shr(self, rhs) }\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Shr<Self> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Self;\n+\n+                    #[inline]\n+                    fn shr(self, rhs: Self) -> Self::Output {\n+                        // TODO there is probably a better way of doing this\n+                        if rhs.as_array()\n+                            .iter()\n+                            .copied()\n+                            .any(invalid_shift_rhs)\n+                        {\n+                            panic!(\"attempt to shift with overflow\");\n                         }\n+                        unsafe { crate::intrinsics::simd_shr(self, rhs) }\n                     }\n                 }\n+            }\n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::Shr<$scalar> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        type Output = Self;\n-\n-                        #[inline]\n-                        fn shr(self, rhs: $scalar) -> Self::Output {\n-                            if invalid_shift_rhs(rhs) {\n-                                panic!(\"attempt to shift with overflow\");\n-                            }\n-                            let rhs = Self::splat(rhs);\n-                            unsafe { crate::intrinsics::simd_shr(self, rhs) }\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Shr<$scalar> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Self;\n+\n+                    #[inline]\n+                    fn shr(self, rhs: $scalar) -> Self::Output {\n+                        if invalid_shift_rhs(rhs) {\n+                            panic!(\"attempt to shift with overflow\");\n                         }\n+                        let rhs = Self::splat(rhs);\n+                        unsafe { crate::intrinsics::simd_shr(self, rhs) }\n                     }\n                 }\n+            }\n \n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::ShrAssign<Self> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        #[inline]\n-                        fn shr_assign(&mut self, rhs: Self) {\n-                            *self = *self >> rhs;\n-                        }\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::ShrAssign<Self> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    #[inline]\n+                    fn shr_assign(&mut self, rhs: Self) {\n+                        *self = *self >> rhs;\n                     }\n                 }\n+            }\n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::ShrAssign<$scalar> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        #[inline]\n-                        fn shr_assign(&mut self, rhs: $scalar) {\n-                            *self = *self >> rhs;\n-                        }\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::ShrAssign<$scalar> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    #[inline]\n+                    fn shr_assign(&mut self, rhs: $scalar) {\n+                        *self = *self >> rhs;\n                     }\n                 }\n-            )*\n+            }\n         )*\n     };\n }\n \n /// Implements unsigned integer operators for the provided types.\n macro_rules! impl_signed_int_ops {\n-    { $($scalar:ty => $($vector:ident),*;)* } => {\n-        impl_unsigned_int_ops! { $($scalar => $($vector),*;)* }\n+    { $($scalar:ty),* } => {\n+        impl_unsigned_int_ops! { $($scalar),* }\n         $( // scalar\n-            $( // vector\n-                impl_op! { impl Neg for $vector, $scalar }\n-            )*\n+            impl_op! { impl Neg for $scalar }\n         )*\n     };\n }\n \n-impl_unsigned_int_ops! {\n-    u8 => SimdU8;\n-    u16 => SimdU16;\n-    u32 => SimdU32;\n-    u64 => SimdU64;\n-    usize => SimdUsize;\n-}\n-\n-impl_signed_int_ops! {\n-    i8 => SimdI8;\n-    i16 => SimdI16;\n-    i32 => SimdI32;\n-    i64 => SimdI64;\n-    isize => SimdIsize;\n-}\n-\n-impl_float_ops! {\n-    f32 => SimdF32;\n-    f64 => SimdF64;\n-}\n+impl_unsigned_int_ops! { u8, u16, u32, u64, usize }\n+impl_signed_int_ops! { i8, i16, i32, i64, isize }\n+impl_float_ops! { f32, f64 }"}]}