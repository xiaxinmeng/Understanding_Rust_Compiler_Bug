{"sha": "74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0YzY5ZTEwNTMxODhkOTJiODZiYzhiMjhjYmYxYWY4N2QzMWVhMmQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-14T23:54:13Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-15T21:14:20Z"}, "message": "Convert more core types to camel case", "tree": {"sha": "8c07fc440e572eb59787705a9dd11fcd789430e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c07fc440e572eb59787705a9dd11fcd789430e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "html_url": "https://github.com/rust-lang/rust/commit/74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8be0f665bcda9f5e4077d0be6ebc6aa382e72319", "url": "https://api.github.com/repos/rust-lang/rust/commits/8be0f665bcda9f5e4077d0be6ebc6aa382e72319", "html_url": "https://github.com/rust-lang/rust/commit/8be0f665bcda9f5e4077d0be6ebc6aa382e72319"}], "stats": {"total": 884, "additions": 457, "deletions": 427}, "files": [{"sha": "59ed352e1ee5add166d9bc020580770db775d530", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -15,7 +15,7 @@ export unsafe;\n #[abi = \"cdecl\"]\n extern mod rustrt {\n     fn vec_reserve_shared_actual(++t: *sys::TypeDesc,\n-                                 ++v: **vec::unsafe::vec_repr,\n+                                 ++v: **vec::unsafe::VecRepr,\n                                  ++n: libc::size_t);\n }\n \n@@ -25,13 +25,13 @@ extern mod rusti {\n }\n \n /// A function used to initialize the elements of a vector\n-type init_op<T> = fn(uint) -> T;\n+type InitOp<T> = fn(uint) -> T;\n \n /// Returns the number of elements the vector can hold without reallocating\n #[inline(always)]\n pure fn capacity<T>(&&v: @[const T]) -> uint {\n     unsafe {\n-        let repr: **unsafe::vec_repr =\n+        let repr: **unsafe::VecRepr =\n             ::unsafe::reinterpret_cast(addr_of(v));\n         (**repr).alloc / sys::size_of::<T>()\n     }\n@@ -103,7 +103,7 @@ pure fn map<T, U>(v: &[T], f: fn(T) -> U) -> @[U] {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value returned by the function `op`.\n  */\n-pure fn from_fn<T>(n_elts: uint, op: init_op<T>) -> @[T] {\n+pure fn from_fn<T>(n_elts: uint, op: InitOp<T>) -> @[T] {\n     do build_sized(n_elts) |push| {\n         let mut i: uint = 0u;\n         while i < n_elts { push(op(i)); i += 1u; }\n@@ -133,8 +133,8 @@ impl<T: copy> @[T]: add<&[const T],@[T]> {\n \n \n mod unsafe {\n-    type vec_repr = vec::unsafe::vec_repr;\n-    type slice_repr = vec::unsafe::slice_repr;\n+    type VecRepr = vec::unsafe::VecRepr;\n+    type SliceRepr = vec::unsafe::SliceRepr;\n \n     /**\n      * Sets the length of a vector\n@@ -145,13 +145,13 @@ mod unsafe {\n      */\n     #[inline(always)]\n     unsafe fn set_len<T>(&&v: @[const T], new_len: uint) {\n-        let repr: **vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n+        let repr: **VecRepr = ::unsafe::reinterpret_cast(addr_of(v));\n         (**repr).fill = new_len * sys::size_of::<T>();\n     }\n \n     #[inline(always)]\n     unsafe fn push<T>(&v: @[const T], +initval: T) {\n-        let repr: **vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n+        let repr: **VecRepr = ::unsafe::reinterpret_cast(addr_of(v));\n         let fill = (**repr).fill;\n         if (**repr).alloc > fill {\n             push_fast(v, initval);\n@@ -163,7 +163,7 @@ mod unsafe {\n     // This doesn't bother to make sure we have space.\n     #[inline(always)] // really pretty please\n     unsafe fn push_fast<T>(&v: @[const T], +initval: T) {\n-        let repr: **vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n+        let repr: **VecRepr = ::unsafe::reinterpret_cast(addr_of(v));\n         let fill = (**repr).fill;\n         (**repr).fill += sys::size_of::<T>();\n         let p = ptr::addr_of((**repr).data);\n@@ -190,7 +190,7 @@ mod unsafe {\n     unsafe fn reserve<T>(&v: @[const T], n: uint) {\n         // Only make the (slow) call into the runtime if we have to\n         if capacity(v) < n {\n-            let ptr = addr_of(v) as **vec_repr;\n+            let ptr = addr_of(v) as **VecRepr;\n             rustrt::vec_reserve_shared_actual(sys::get_type_desc::<T>(),\n                                               ptr, n as libc::size_t);\n         }"}, {"sha": "eb19a12c254b09e4f7792ee9878d600b651daba5", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -27,7 +27,7 @@\n  * ~~~\n  */\n \n-import either::either;\n+import either::Either;\n import libc::size_t;\n \n export port;\n@@ -222,7 +222,7 @@ fn peek_(p: *rust_port) -> bool {\n \n /// Receive on one of two ports\n fn select2<A: send, B: send>(p_a: port<A>, p_b: port<B>)\n-    -> either<A, B> {\n+    -> Either<A, B> {\n     let ports = ~[(**p_a).po, (**p_b).po];\n     let yield = 0u, yieldp = ptr::addr_of(yield);\n \n@@ -246,9 +246,9 @@ fn select2<A: send, B: send>(p_a: port<A>, p_b: port<B>)\n     assert resport != ptr::null();\n \n     if resport == (**p_a).po {\n-        either::left(recv(p_a))\n+        either::Left(recv(p_a))\n     } else if resport == (**p_b).po {\n-        either::right(recv(p_b))\n+        either::Right(recv(p_b))\n     } else {\n         fail ~\"unexpected result from rust_port_select\";\n     }\n@@ -355,11 +355,11 @@ fn test_select2_available() {\n \n     send(ch_a, ~\"a\");\n \n-    assert select2(po_a, po_b) == either::left(~\"a\");\n+    assert select2(po_a, po_b) == either::Left(~\"a\");\n \n     send(ch_b, ~\"b\");\n \n-    assert select2(po_a, po_b) == either::right(~\"b\");\n+    assert select2(po_a, po_b) == either::Right(~\"b\");\n }\n \n #[test]\n@@ -375,14 +375,14 @@ fn test_select2_rendezvous() {\n             send(ch_a, ~\"a\");\n         };\n \n-        assert select2(po_a, po_b) == either::left(~\"a\");\n+        assert select2(po_a, po_b) == either::Left(~\"a\");\n \n         do task::spawn {\n             for iter::repeat(10u) { task::yield() }\n             send(ch_b, ~\"b\");\n         };\n \n-        assert select2(po_a, po_b) == either::right(~\"b\");\n+        assert select2(po_a, po_b) == either::Right(~\"b\");\n     }\n }\n \n@@ -413,8 +413,8 @@ fn test_select2_stress() {\n     let mut bs = 0;\n     for iter::repeat(msgs * times * 2u) {\n         match select2(po_a, po_b) {\n-          either::left(~\"a\") => as += 1,\n-          either::right(~\"b\") => bs += 1,\n+          either::Left(~\"a\") => as += 1,\n+          either::Right(~\"b\") => bs += 1,\n           _ => fail ~\"test_select_2_stress failed\"\n         }\n     }"}, {"sha": "3c54e077cc3a87e6645f4e84405f4fa5ec5aa9ee", "filename": "src/libcore/core.rc", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -68,6 +68,7 @@ export priv;\n // Built-in-type support modules\n \n /// Operations and constants for `int`\n+#[warn(non_camel_case_types)]\n #[path = \"int-template\"]\n mod int {\n     import inst::{ hash, pow };\n@@ -77,34 +78,39 @@ mod int {\n }\n \n /// Operations and constants for `i8`\n+#[warn(non_camel_case_types)]\n #[path = \"int-template\"]\n mod i8 {\n     #[path = \"i8.rs\"]\n     mod inst;\n }\n \n /// Operations and constants for `i16`\n+#[warn(non_camel_case_types)]\n #[path = \"int-template\"]\n mod i16 {\n     #[path = \"i16.rs\"]\n     mod inst;\n }\n \n /// Operations and constants for `i32`\n+#[warn(non_camel_case_types)]\n #[path = \"int-template\"]\n mod i32 {\n     #[path = \"i32.rs\"]\n     mod inst;\n }\n \n /// Operations and constants for `i64`\n+#[warn(non_camel_case_types)]\n #[path = \"int-template\"]\n mod i64 {\n     #[path = \"i64.rs\"]\n     mod inst;\n }\n \n /// Operations and constants for `uint`\n+#[warn(non_camel_case_types)]\n #[path = \"uint-template\"]\n mod uint {\n     import inst::{\n@@ -119,6 +125,7 @@ mod uint {\n }\n \n /// Operations and constants for `u8`\n+#[warn(non_camel_case_types)]\n #[path = \"uint-template\"]\n mod u8 {\n     import inst::is_ascii;\n@@ -129,36 +136,49 @@ mod u8 {\n }\n \n /// Operations and constants for `u16`\n+#[warn(non_camel_case_types)]\n #[path = \"uint-template\"]\n mod u16 {\n     #[path = \"u16.rs\"]\n     mod inst;\n }\n \n /// Operations and constants for `u32`\n+#[warn(non_camel_case_types)]\n #[path = \"uint-template\"]\n mod u32 {\n     #[path = \"u32.rs\"]\n     mod inst;\n }\n \n /// Operations and constants for `u64`\n+#[warn(non_camel_case_types)]\n #[path = \"uint-template\"]\n mod u64 {\n     #[path = \"u64.rs\"]\n     mod inst;\n }\n \n \n+#[warn(non_camel_case_types)]\n mod box;\n+#[warn(non_camel_case_types)]\n mod char;\n+#[warn(non_camel_case_types)]\n mod float;\n+#[warn(non_camel_case_types)]\n mod f32;\n+#[warn(non_camel_case_types)]\n mod f64;\n+#[warn(non_camel_case_types)]\n mod str;\n+#[warn(non_camel_case_types)]\n mod ptr;\n+#[warn(non_camel_case_types)]\n mod vec;\n+#[warn(non_camel_case_types)]\n mod at_vec;\n+#[warn(non_camel_case_types)]\n mod bool;\n #[warn(non_camel_case_types)]\n mod tuple;\n@@ -173,7 +193,9 @@ mod cmp;\n mod num;\n #[warn(non_camel_case_types)]\n mod hash;\n+#[warn(non_camel_case_types)]\n mod either;\n+#[warn(non_camel_case_types)]\n mod iter;\n #[warn(non_camel_case_types)]\n mod logging;\n@@ -193,18 +215,23 @@ mod util;\n \n // Data structure modules\n \n+#[warn(non_camel_case_types)]\n mod dvec;\n #[path=\"iter-trait\"]\n+#[warn(non_camel_case_types)]\n mod dvec_iter {\n     #[path = \"dvec.rs\"]\n     mod inst;\n }\n+#[warn(non_camel_case_types)]\n mod dlist;\n #[path=\"iter-trait\"]\n+#[warn(non_camel_case_types)]\n mod dlist_iter {\n     #[path =\"dlist.rs\"]\n     mod inst;\n }\n+#[warn(non_camel_case_types)]\n mod send_map;\n \n // Concurrency"}, {"sha": "1fb831b46fa70d5ecd634714e75d24812a479647", "filename": "src/libcore/core.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -6,25 +6,25 @@ import option::{some, none};\n import option = option::option;\n import Path = path::Path;\n import tuple::{TupleOps, ExtendedTupleOps};\n-import str::{str_slice, unique_str};\n-import vec::{const_vector, copyable_vector, immutable_vector};\n-import vec::{immutable_copyable_vector, iter_trait_extensions};\n-import iter::{base_iter, extended_iter, copyable_iter, times, timesi};\n+import str::{StrSlice, UniqueStr};\n+import vec::{ConstVector, CopyableVector, ImmutableVector};\n+import vec::{ImmutableCopyableVector, IterTraitExtensions};\n+import iter::{BaseIter, ExtendedIter, CopyableIter, Times, TimesIx};\n import num::Num;\n-import ptr::ptr;\n+import ptr::Ptr;\n import to_str::ToStr;\n \n export Path, option, some, none, unreachable;\n export extensions;\n // The following exports are the extension impls for numeric types\n-export Num, times, timesi;\n+export Num, Times, TimesIx;\n // The following exports are the common traits\n-export str_slice, unique_str;\n-export const_vector, copyable_vector, immutable_vector;\n-export immutable_copyable_vector, iter_trait_extensions;\n-export base_iter, copyable_iter, extended_iter;\n+export StrSlice, UniqueStr;\n+export ConstVector, CopyableVector, ImmutableVector;\n+export ImmutableCopyableVector, IterTraitExtensions;\n+export BaseIter, CopyableIter, ExtendedIter;\n export TupleOps, ExtendedTupleOps;\n-export ptr;\n+export Ptr;\n export ToStr;\n \n // The following exports are the core operators and kinds"}, {"sha": "f835344f2d1ec4f0c9a0d3fa2b97d42f2b9e170d", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -8,25 +8,25 @@\n  * Do not use ==, !=, <, etc on doubly-linked lists -- it may not terminate.\n  */\n \n-export dlist, dlist_node;\n+export DList, dlist, dlist_node;\n export new_dlist, from_elem, from_vec, extensions;\n \n-type dlist_link<T> = option<dlist_node<T>>;\n+type DListLink<T> = option<DListNode<T>>;\n \n-enum dlist_node<T> = @{\n+enum DListNode<T> = @{\n     data: T,\n     mut linked: bool, // for assertions\n-    mut prev: dlist_link<T>,\n-    mut next: dlist_link<T>\n+    mut prev: DListLink<T>,\n+    mut next: DListLink<T>\n };\n \n-enum dlist<T> = @{\n+enum DList<T> = @{\n     mut size: uint,\n-    mut hd:   dlist_link<T>,\n-    mut tl:   dlist_link<T>,\n+    mut hd:   DListLink<T>,\n+    mut tl:   DListLink<T>,\n };\n \n-priv impl<T> dlist_node<T> {\n+priv impl<T> DListNode<T> {\n     pure fn assert_links() {\n         match self.next {\n             some(neighbour) => match neighbour.prev {\n@@ -49,26 +49,26 @@ priv impl<T> dlist_node<T> {\n     }\n }\n \n-impl<T> dlist_node<T> {\n+impl<T> DListNode<T> {\n     /// Get the next node in the list, if there is one.\n-    pure fn next_link() -> option<dlist_node<T>> {\n+    pure fn next_link() -> option<DListNode<T>> {\n         self.assert_links();\n         self.next\n     }\n     /// Get the next node in the list, failing if there isn't one.\n-    pure fn next_node() -> dlist_node<T> {\n+    pure fn next_node() -> DListNode<T> {\n         match self.next_link() {\n             some(nobe) => nobe,\n             none       => fail ~\"This dlist node has no next neighbour.\"\n         }\n     }\n     /// Get the previous node in the list, if there is one.\n-    pure fn prev_link() -> option<dlist_node<T>> {\n+    pure fn prev_link() -> option<DListNode<T>> {\n         self.assert_links();\n         self.prev\n     }\n     /// Get the previous node in the list, failing if there isn't one.\n-    pure fn prev_node() -> dlist_node<T> {\n+    pure fn prev_node() -> DListNode<T> {\n         match self.prev_link() {\n             some(nobe) => nobe,\n             none       => fail ~\"This dlist node has no previous neighbour.\"\n@@ -77,24 +77,24 @@ impl<T> dlist_node<T> {\n }\n \n /// Creates a new dlist node with the given data.\n-pure fn new_dlist_node<T>(+data: T) -> dlist_node<T> {\n-    dlist_node(@{data: data, mut linked: false,\n+pure fn new_dlist_node<T>(+data: T) -> DListNode<T> {\n+    DListNode(@{data: data, mut linked: false,\n                  mut prev: none, mut next: none})\n }\n \n /// Creates a new, empty dlist.\n-pure fn new_dlist<T>() -> dlist<T> {\n-    dlist(@{mut size: 0, mut hd: none, mut tl: none})\n+pure fn new_dlist<T>() -> DList<T> {\n+    DList(@{mut size: 0, mut hd: none, mut tl: none})\n }\n \n /// Creates a new dlist with a single element\n-pure fn from_elem<T>(+data: T) -> dlist<T> {\n+pure fn from_elem<T>(+data: T) -> DList<T> {\n     let list = new_dlist();\n     unchecked { list.push(data); }\n     list\n }\n \n-fn from_vec<T: copy>(+vec: &[T]) -> dlist<T> {\n+fn from_vec<T: copy>(+vec: &[T]) -> DList<T> {\n     do vec::foldl(new_dlist(), vec) |list,data| {\n         list.push(data); // Iterating left-to-right -- add newly to the tail.\n         list\n@@ -103,20 +103,20 @@ fn from_vec<T: copy>(+vec: &[T]) -> dlist<T> {\n \n /// Produce a list from a list of lists, leaving no elements behind in the\n /// input. O(number of sub-lists).\n-fn concat<T>(lists: dlist<dlist<T>>) -> dlist<T> {\n+fn concat<T>(lists: DList<DList<T>>) -> DList<T> {\n     let result = new_dlist();\n     while !lists.is_empty() {\n         result.append(lists.pop().get());\n     }\n     result\n }\n \n-priv impl<T> dlist<T> {\n-    pure fn new_link(-data: T) -> dlist_link<T> {\n-        some(dlist_node(@{data: data, mut linked: true,\n+priv impl<T> DList<T> {\n+    pure fn new_link(-data: T) -> DListLink<T> {\n+        some(DListNode(@{data: data, mut linked: true,\n                           mut prev: none, mut next: none}))\n     }\n-    pure fn assert_mine(nobe: dlist_node<T>) {\n+    pure fn assert_mine(nobe: DListNode<T>) {\n         // These asserts could be stronger if we had node-root back-pointers,\n         // but those wouldn't allow for O(1) append.\n         if self.size == 0 {\n@@ -130,7 +130,7 @@ priv impl<T> dlist<T> {\n             fail ~\"That node isn't on this dlist.\"\n         }\n     }\n-    fn make_mine(nobe: dlist_node<T>) {\n+    fn make_mine(nobe: DListNode<T>) {\n         if nobe.prev.is_some() || nobe.next.is_some() || nobe.linked {\n             fail ~\"Cannot insert node that's already on a dlist!\"\n         }\n@@ -139,7 +139,7 @@ priv impl<T> dlist<T> {\n     // Link two nodes together. If either of them are 'none', also sets\n     // the head and/or tail pointers appropriately.\n     #[inline(always)]\n-    fn link(+before: dlist_link<T>, +after: dlist_link<T>) {\n+    fn link(+before: DListLink<T>, +after: DListLink<T>) {\n         match before {\n             some(neighbour) => neighbour.next = after,\n             none            => self.hd        = after\n@@ -150,7 +150,7 @@ priv impl<T> dlist<T> {\n         }\n     }\n     // Remove a node from the list.\n-    fn unlink(nobe: dlist_node<T>) {\n+    fn unlink(nobe: DListNode<T>) {\n         self.assert_mine(nobe);\n         assert self.size > 0;\n         self.link(nobe.prev, nobe.next);\n@@ -160,24 +160,24 @@ priv impl<T> dlist<T> {\n         self.size -= 1;\n     }\n \n-    fn add_head(+nobe: dlist_link<T>) {\n+    fn add_head(+nobe: DListLink<T>) {\n         self.link(nobe, self.hd); // Might set tail too.\n         self.hd = nobe;\n         self.size += 1;\n     }\n-    fn add_tail(+nobe: dlist_link<T>) {\n+    fn add_tail(+nobe: DListLink<T>) {\n         self.link(self.tl, nobe); // Might set head too.\n         self.tl = nobe;\n         self.size += 1;\n     }\n-    fn insert_left(nobe: dlist_link<T>, neighbour: dlist_node<T>) {\n+    fn insert_left(nobe: DListLink<T>, neighbour: DListNode<T>) {\n         self.assert_mine(neighbour);\n         assert self.size > 0;\n         self.link(neighbour.prev, nobe);\n         self.link(nobe, some(neighbour));\n         self.size += 1;\n     }\n-    fn insert_right(neighbour: dlist_node<T>, nobe: dlist_link<T>) {\n+    fn insert_right(neighbour: DListNode<T>, nobe: DListLink<T>) {\n         self.assert_mine(neighbour);\n         assert self.size > 0;\n         self.link(nobe, neighbour.next);\n@@ -186,7 +186,7 @@ priv impl<T> dlist<T> {\n     }\n }\n \n-impl<T> dlist<T> {\n+impl<T> DList<T> {\n     /// Get the size of the list. O(1).\n     pure fn len()          -> uint { self.size }\n     /// Returns true if the list is empty. O(1).\n@@ -202,7 +202,7 @@ impl<T> dlist<T> {\n      * Add data to the head of the list, and get the new containing\n      * node. O(1).\n      */\n-    fn push_head_n(+data: T) -> dlist_node<T> {\n+    fn push_head_n(+data: T) -> DListNode<T> {\n         let mut nobe = self.new_link(data);\n         self.add_head(nobe);\n         option::get(nobe)\n@@ -215,7 +215,7 @@ impl<T> dlist<T> {\n      * Add data to the tail of the list, and get the new containing\n      * node. O(1).\n      */\n-    fn push_n(+data: T) -> dlist_node<T> {\n+    fn push_n(+data: T) -> DListNode<T> {\n         let mut nobe = self.new_link(data);\n         self.add_tail(nobe);\n         option::get(nobe)\n@@ -224,22 +224,22 @@ impl<T> dlist<T> {\n      * Insert data into the middle of the list, left of the given node.\n      * O(1).\n      */\n-    fn insert_before(+data: T, neighbour: dlist_node<T>) {\n+    fn insert_before(+data: T, neighbour: DListNode<T>) {\n         self.insert_left(self.new_link(data), neighbour);\n     }\n     /**\n      * Insert an existing node in the middle of the list, left of the\n      * given node. O(1).\n      */\n-    fn insert_n_before(nobe: dlist_node<T>, neighbour: dlist_node<T>) {\n+    fn insert_n_before(nobe: DListNode<T>, neighbour: DListNode<T>) {\n         self.make_mine(nobe);\n         self.insert_left(some(nobe), neighbour);\n     }\n     /**\n      * Insert data in the middle of the list, left of the given node,\n      * and get its containing node. O(1).\n      */\n-    fn insert_before_n(+data: T, neighbour: dlist_node<T>) -> dlist_node<T> {\n+    fn insert_before_n(+data: T, neighbour: DListNode<T>) -> DListNode<T> {\n         let mut nobe = self.new_link(data);\n         self.insert_left(nobe, neighbour);\n         option::get(nobe)\n@@ -248,67 +248,67 @@ impl<T> dlist<T> {\n      * Insert data into the middle of the list, right of the given node.\n      * O(1).\n      */\n-    fn insert_after(+data: T, neighbour: dlist_node<T>) {\n+    fn insert_after(+data: T, neighbour: DListNode<T>) {\n         self.insert_right(neighbour, self.new_link(data));\n     }\n     /**\n      * Insert an existing node in the middle of the list, right of the\n      * given node. O(1).\n      */\n-    fn insert_n_after(nobe: dlist_node<T>, neighbour: dlist_node<T>) {\n+    fn insert_n_after(nobe: DListNode<T>, neighbour: DListNode<T>) {\n         self.make_mine(nobe);\n         self.insert_right(neighbour, some(nobe));\n     }\n     /**\n      * Insert data in the middle of the list, right of the given node,\n      * and get its containing node. O(1).\n      */\n-    fn insert_after_n(+data: T, neighbour: dlist_node<T>) -> dlist_node<T> {\n+    fn insert_after_n(+data: T, neighbour: DListNode<T>) -> DListNode<T> {\n         let mut nobe = self.new_link(data);\n         self.insert_right(neighbour, nobe);\n         option::get(nobe)\n     }\n \n     /// Remove a node from the head of the list. O(1).\n-    fn pop_n() -> option<dlist_node<T>> {\n+    fn pop_n() -> option<DListNode<T>> {\n         let hd = self.peek_n();\n         hd.map(|nobe| self.unlink(nobe));\n         hd\n     }\n     /// Remove a node from the tail of the list. O(1).\n-    fn pop_tail_n() -> option<dlist_node<T>> {\n+    fn pop_tail_n() -> option<DListNode<T>> {\n         let tl = self.peek_tail_n();\n         tl.map(|nobe| self.unlink(nobe));\n         tl\n     }\n     /// Get the node at the list's head. O(1).\n-    pure fn peek_n() -> option<dlist_node<T>> { self.hd }\n+    pure fn peek_n() -> option<DListNode<T>> { self.hd }\n     /// Get the node at the list's tail. O(1).\n-    pure fn peek_tail_n() -> option<dlist_node<T>> { self.tl }\n+    pure fn peek_tail_n() -> option<DListNode<T>> { self.tl }\n \n     /// Get the node at the list's head, failing if empty. O(1).\n-    pure fn head_n() -> dlist_node<T> {\n+    pure fn head_n() -> DListNode<T> {\n         match self.hd {\n             some(nobe) => nobe,\n             none       => fail ~\"Attempted to get the head of an empty dlist.\"\n         }\n     }\n     /// Get the node at the list's tail, failing if empty. O(1).\n-    pure fn tail_n() -> dlist_node<T> {\n+    pure fn tail_n() -> DListNode<T> {\n         match self.tl {\n             some(nobe) => nobe,\n             none       => fail ~\"Attempted to get the tail of an empty dlist.\"\n         }\n     }\n \n     /// Remove a node from anywhere in the list. O(1).\n-    fn remove(nobe: dlist_node<T>) { self.unlink(nobe); }\n+    fn remove(nobe: DListNode<T>) { self.unlink(nobe); }\n \n     /**\n      * Empty another list onto the end of this list, joining this list's tail\n      * to the other list's head. O(1).\n      */\n-    fn append(them: dlist<T>) {\n+    fn append(them: DList<T>) {\n         if box::ptr_eq(*self, *them) {\n             fail ~\"Cannot append a dlist to itself!\"\n         }\n@@ -325,7 +325,7 @@ impl<T> dlist<T> {\n      * Empty another list onto the start of this list, joining the other\n      * list's tail to this list's head. O(1).\n      */\n-    fn prepend(them: dlist<T>) {\n+    fn prepend(them: DList<T>) {\n         if box::ptr_eq(*self, *them) {\n             fail ~\"Cannot prepend a dlist to itself!\"\n         }\n@@ -363,7 +363,7 @@ impl<T> dlist<T> {\n     }\n \n     /// Iterate over nodes.\n-    pure fn each_node(f: fn(dlist_node<T>) -> bool) {\n+    pure fn each_node(f: fn(DListNode<T>) -> bool) {\n         let mut link = self.peek_n();\n         while link.is_some() {\n             let nobe = link.get();\n@@ -415,7 +415,7 @@ impl<T> dlist<T> {\n     }\n }\n \n-impl<T: copy> dlist<T> {\n+impl<T: copy> DList<T> {\n     /// Remove data from the head of the list. O(1).\n     fn pop()       -> option<T> { self.pop_n().map       (|nobe| nobe.data) }\n     /// Remove data from the tail of the list. O(1)."}, {"sha": "ecbff6f12dfa468852b35b0c7a5f6af8682e6afb", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -12,6 +12,7 @@\n import unsafe::reinterpret_cast;\n import ptr::null;\n \n+export DVec;\n export dvec;\n export from_elem;\n export from_vec;\n@@ -49,36 +50,36 @@ export unwrap;\n  * pointers achieved about 103 million pushes/second.  Using an option\n  * type could only produce 47 million pushes/second.\n  */\n-type dvec_<A> = {\n+type DVec_<A> = {\n     mut data: ~[mut A]\n };\n \n-enum dvec<A> {\n-    dvec_(dvec_<A>)\n+enum DVec<A> {\n+    DVec_(DVec_<A>)\n }\n \n /// Creates a new, empty dvec\n-fn dvec<A>() -> dvec<A> {\n-    dvec_({mut data: ~[mut]})\n+fn dvec<A>() -> DVec<A> {\n+    DVec_({mut data: ~[mut]})\n }\n \n /// Creates a new dvec with a single element\n-fn from_elem<A>(+e: A) -> dvec<A> {\n-    dvec_({mut data: ~[mut e]})\n+fn from_elem<A>(+e: A) -> DVec<A> {\n+    DVec_({mut data: ~[mut e]})\n }\n \n /// Creates a new dvec with the contents of a vector\n-fn from_vec<A>(+v: ~[mut A]) -> dvec<A> {\n-    dvec_({mut data: v})\n+fn from_vec<A>(+v: ~[mut A]) -> DVec<A> {\n+    DVec_({mut data: v})\n }\n \n /// Consumes the vector and returns its contents\n-fn unwrap<A>(+d: dvec<A>) -> ~[mut A] {\n-    let dvec_({data: v}) <- d;\n+fn unwrap<A>(+d: DVec<A>) -> ~[mut A] {\n+    let DVec_({data: v}) <- d;\n     return v;\n }\n \n-priv impl<A> dvec<A> {\n+priv impl<A> DVec<A> {\n     pure fn check_not_borrowed() {\n         unsafe {\n             let data: *() = unsafe::reinterpret_cast(self.data);\n@@ -110,7 +111,7 @@ priv impl<A> dvec<A> {\n // In theory, most everything should work with any A, but in practice\n // almost nothing works without the copy bound due to limitations\n // around closures.\n-impl<A> dvec<A> {\n+impl<A> DVec<A> {\n     /// Reserves space for N elements\n     fn reserve(count: uint) {\n         vec::reserve(self.data, count)\n@@ -191,7 +192,7 @@ impl<A> dvec<A> {\n     }\n }\n \n-impl<A: copy> dvec<A> {\n+impl<A: copy> DVec<A> {\n     /**\n      * Append all elements of a vector to the end of the list\n      *\n@@ -308,7 +309,7 @@ impl<A: copy> dvec<A> {\n     }\n }\n \n-impl<A:copy> dvec<A>: index<uint,A> {\n+impl<A:copy> DVec<A>: index<uint,A> {\n     pure fn index(&&idx: uint) -> A {\n         self.get_elt(idx)\n     }"}, {"sha": "6e2698ce8abdf415ead41afa2c53c23e0153a3e5", "filename": "src/libcore/either.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -7,13 +7,13 @@\n import result::result;\n \n /// The either type\n-enum either<T, U> {\n-    left(T),\n-    right(U)\n+enum Either<T, U> {\n+    Left(T),\n+    Right(U)\n }\n \n fn either<T, U, V>(f_left: fn((&T)) -> V,\n-                   f_right: fn((&U)) -> V, value: &either<T, U>) -> V {\n+                   f_right: fn((&U)) -> V, value: &Either<T, U>) -> V {\n     /*!\n      * Applies a function based on the given either value\n      *\n@@ -23,38 +23,38 @@ fn either<T, U, V>(f_left: fn((&T)) -> V,\n      */\n \n     match *value {\n-      left(ref l) => f_left(l),\n-      right(ref r) => f_right(r)\n+      Left(ref l) => f_left(l),\n+      Right(ref r) => f_right(r)\n     }\n }\n \n-fn lefts<T: copy, U>(eithers: &[either<T, U>]) -> ~[T] {\n+fn lefts<T: copy, U>(eithers: &[Either<T, U>]) -> ~[T] {\n     //! Extracts from a vector of either all the left values\n \n     let mut result: ~[T] = ~[];\n     for vec::each(eithers) |elt| {\n         match elt {\n-          left(l) => vec::push(result, l),\n+          Left(l) => vec::push(result, l),\n           _ => { /* fallthrough */ }\n         }\n     }\n     return result;\n }\n \n-fn rights<T, U: copy>(eithers: &[either<T, U>]) -> ~[U] {\n+fn rights<T, U: copy>(eithers: &[Either<T, U>]) -> ~[U] {\n     //! Extracts from a vector of either all the right values\n \n     let mut result: ~[U] = ~[];\n     for vec::each(eithers) |elt| {\n         match elt {\n-          right(r) => vec::push(result, r),\n+          Right(r) => vec::push(result, r),\n           _ => { /* fallthrough */ }\n         }\n     }\n     return result;\n }\n \n-fn partition<T: copy, U: copy>(eithers: &[either<T, U>])\n+fn partition<T: copy, U: copy>(eithers: &[Either<T, U>])\n     -> {lefts: ~[T], rights: ~[U]} {\n     /*!\n      * Extracts from a vector of either all the left values and right values\n@@ -67,23 +67,23 @@ fn partition<T: copy, U: copy>(eithers: &[either<T, U>])\n     let mut rights: ~[U] = ~[];\n     for vec::each(eithers) |elt| {\n         match elt {\n-          left(l) => vec::push(lefts, l),\n-          right(r) => vec::push(rights, r)\n+          Left(l) => vec::push(lefts, l),\n+          Right(r) => vec::push(rights, r)\n         }\n     }\n     return {lefts: lefts, rights: rights};\n }\n \n-pure fn flip<T: copy, U: copy>(eith: &either<T, U>) -> either<U, T> {\n+pure fn flip<T: copy, U: copy>(eith: &Either<T, U>) -> Either<U, T> {\n     //! Flips between left and right of a given either\n \n     match *eith {\n-      right(r) => left(r),\n-      left(l) => right(l)\n+      Right(r) => Left(r),\n+      Left(l) => Right(l)\n     }\n }\n \n-pure fn to_result<T: copy, U: copy>(eith: &either<T, U>) -> result<U, T> {\n+pure fn to_result<T: copy, U: copy>(eith: &Either<T, U>) -> result<U, T> {\n     /*!\n      * Converts either::t to a result::t\n      *\n@@ -92,84 +92,84 @@ pure fn to_result<T: copy, U: copy>(eith: &either<T, U>) -> result<U, T> {\n      */\n \n     match *eith {\n-      right(r) => result::ok(r),\n-      left(l) => result::err(l)\n+      Right(r) => result::ok(r),\n+      Left(l) => result::err(l)\n     }\n }\n \n-pure fn is_left<T, U>(eith: &either<T, U>) -> bool {\n+pure fn is_left<T, U>(eith: &Either<T, U>) -> bool {\n     //! Checks whether the given value is a left\n \n-    match *eith { left(_) => true, _ => false }\n+    match *eith { Left(_) => true, _ => false }\n }\n \n-pure fn is_right<T, U>(eith: &either<T, U>) -> bool {\n+pure fn is_right<T, U>(eith: &Either<T, U>) -> bool {\n     //! Checks whether the given value is a right\n \n-    match *eith { right(_) => true, _ => false }\n+    match *eith { Right(_) => true, _ => false }\n }\n \n #[test]\n fn test_either_left() {\n-    let val = left(10);\n+    let val = Left(10);\n     fn f_left(x: &int) -> bool { *x == 10 }\n     fn f_right(_x: &uint) -> bool { false }\n     assert (either(f_left, f_right, &val));\n }\n \n #[test]\n fn test_either_right() {\n-    let val = right(10u);\n+    let val = Right(10u);\n     fn f_left(_x: &int) -> bool { false }\n     fn f_right(x: &uint) -> bool { *x == 10u }\n     assert (either(f_left, f_right, &val));\n }\n \n #[test]\n fn test_lefts() {\n-    let input = ~[left(10), right(11), left(12), right(13), left(14)];\n+    let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n     let result = lefts(input);\n     assert (result == ~[10, 12, 14]);\n }\n \n #[test]\n fn test_lefts_none() {\n-    let input: ~[either<int, int>] = ~[right(10), right(10)];\n+    let input: ~[Either<int, int>] = ~[Right(10), Right(10)];\n     let result = lefts(input);\n     assert (vec::len(result) == 0u);\n }\n \n #[test]\n fn test_lefts_empty() {\n-    let input: ~[either<int, int>] = ~[];\n+    let input: ~[Either<int, int>] = ~[];\n     let result = lefts(input);\n     assert (vec::len(result) == 0u);\n }\n \n #[test]\n fn test_rights() {\n-    let input = ~[left(10), right(11), left(12), right(13), left(14)];\n+    let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n     let result = rights(input);\n     assert (result == ~[11, 13]);\n }\n \n #[test]\n fn test_rights_none() {\n-    let input: ~[either<int, int>] = ~[left(10), left(10)];\n+    let input: ~[Either<int, int>] = ~[Left(10), Left(10)];\n     let result = rights(input);\n     assert (vec::len(result) == 0u);\n }\n \n #[test]\n fn test_rights_empty() {\n-    let input: ~[either<int, int>] = ~[];\n+    let input: ~[Either<int, int>] = ~[];\n     let result = rights(input);\n     assert (vec::len(result) == 0u);\n }\n \n #[test]\n fn test_partition() {\n-    let input = ~[left(10), right(11), left(12), right(13), left(14)];\n+    let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n     let result = partition(input);\n     assert (result.lefts[0] == 10);\n     assert (result.lefts[1] == 12);\n@@ -180,23 +180,23 @@ fn test_partition() {\n \n #[test]\n fn test_partition_no_lefts() {\n-    let input: ~[either<int, int>] = ~[right(10), right(11)];\n+    let input: ~[Either<int, int>] = ~[Right(10), Right(11)];\n     let result = partition(input);\n     assert (vec::len(result.lefts) == 0u);\n     assert (vec::len(result.rights) == 2u);\n }\n \n #[test]\n fn test_partition_no_rights() {\n-    let input: ~[either<int, int>] = ~[left(10), left(11)];\n+    let input: ~[Either<int, int>] = ~[Left(10), Left(11)];\n     let result = partition(input);\n     assert (vec::len(result.lefts) == 2u);\n     assert (vec::len(result.rights) == 0u);\n }\n \n #[test]\n fn test_partition_empty() {\n-    let input: ~[either<int, int>] = ~[];\n+    let input: ~[Either<int, int>] = ~[];\n     let result = partition(input);\n     assert (vec::len(result.lefts) == 0u);\n     assert (vec::len(result.rights) == 0u);"}, {"sha": "a935a50ddb6bbd07f4085b97652185d261b3660a", "filename": "src/libcore/future.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -15,7 +15,7 @@\n  * ~~~\n  */\n \n-import either::either;\n+import either::Either;\n import pipes::recv;\n \n export future;\n@@ -32,7 +32,7 @@ export future_pipe;\n \n #[doc = \"The future type\"]\n enum future<A> = {\n-    mut v: either<@A, fn@() -> A>\n+    mut v: Either<@A, fn@() -> A>\n };\n \n /// Methods on the `future` type\n@@ -60,7 +60,7 @@ fn from_value<A>(+val: A) -> future<A> {\n      */\n \n     future({\n-        mut v: either::left(@val)\n+        mut v: either::Left(@val)\n     })\n }\n \n@@ -97,7 +97,7 @@ fn from_fn<A>(f: fn@() -> A) -> future<A> {\n      */\n \n     future({\n-        mut v: either::right(f)\n+        mut v: either::Right(f)\n     })\n }\n \n@@ -124,10 +124,10 @@ fn with<A,B>(future: &future<A>, blk: fn((&A)) -> B) -> B {\n     //! Work with the value without copying it\n \n     let v = match copy future.v {\n-      either::left(v) => v,\n-      either::right(f) => {\n+      either::Left(v) => v,\n+      either::Right(f) => {\n         let v = @f();\n-        future.v = either::left(v);\n+        future.v = either::Left(v);\n         v\n       }\n     };"}, {"sha": "9ebfec47c7c81a129efdf9ad4e6f272cdffc3202", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -88,7 +88,7 @@ impl T: num::Num {\n     static pure fn from_int(n: int) -> T   { return n as T;      }\n }\n \n-impl T: iter::times {\n+impl T: iter::Times {\n     #[inline(always)]\n     #[doc = \"A convenience form for basic iteration. Given a variable `x` \\\n         of any numeric type, the expression `for x.times { /* anything */ }` \\\n@@ -108,7 +108,7 @@ impl T: iter::times {\n     }\n }\n \n-impl T: iter::timesi {\n+impl T: iter::TimesIx {\n     #[inline(always)]\n     /// Like `times`, but provides an index\n     fn timesi(it: fn(uint) -> bool) {\n@@ -255,7 +255,7 @@ fn test_interfaces() {\n \n #[test]\n fn test_times() {\n-    import iter::times;\n+    import iter::Times;\n     let ten = 10 as T;\n     let mut accum = 0;\n     for ten.times { accum += 1; }\n@@ -266,6 +266,6 @@ fn test_times() {\n #[should_fail]\n #[ignore(cfg(windows))]\n fn test_times_negative() {\n-    import iter::times;\n+    import iter::Times;\n     for (-10).times { log(error, ~\"nope!\"); }\n }"}, {"sha": "d85ffb4981d8a222c987507b091d66666a0c8e61", "filename": "src/libcore/io.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -6,7 +6,7 @@ Basic input/output\n \n import result::result;\n \n-import dvec::dvec;\n+import dvec::{DVec, dvec};\n import libc::{c_int, c_long, c_uint, c_void, size_t, ssize_t};\n import libc::consts::os::posix88::*;\n import libc::consts::os::extra::*;\n@@ -657,7 +657,7 @@ fn stderr() -> Writer { fd_writer(libc::STDERR_FILENO as c_int, false) }\n fn print(s: &str) { stdout().write_str(s); }\n fn println(s: &str) { stdout().write_line(s); }\n \n-type MemBuffer = @{buf: dvec<u8>, mut pos: uint};\n+type MemBuffer = @{buf: DVec<u8>, mut pos: uint};\n \n impl MemBuffer: Writer {\n     fn write(v: &[const u8]) {"}, {"sha": "5aeb958f5b22bbdb3ff4f5251f86a1bdb786cdd3", "filename": "src/libcore/iter-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fiter-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fiter-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -5,12 +5,12 @@\n import inst::{IMPL_T, EACH, SIZE_HINT};\n export extensions;\n \n-impl<A> IMPL_T<A>: iter::base_iter<A> {\n+impl<A> IMPL_T<A>: iter::BaseIter<A> {\n     fn each(blk: fn(A) -> bool) { EACH(self, blk) }\n     fn size_hint() -> option<uint> { SIZE_HINT(self) }\n }\n \n-impl<A> IMPL_T<A>: iter::extended_iter<A> {\n+impl<A> IMPL_T<A>: iter::ExtendedIter<A> {\n     fn eachi(blk: fn(uint, A) -> bool) { iter::eachi(self, blk) }\n     fn all(blk: fn(A) -> bool) -> bool { iter::all(self, blk) }\n     fn any(blk: fn(A) -> bool) -> bool { iter::any(self, blk) }\n@@ -24,7 +24,7 @@ impl<A> IMPL_T<A>: iter::extended_iter<A> {\n     }\n }\n \n-impl<A: copy> IMPL_T<A>: iter::copyable_iter<A> {\n+impl<A: copy> IMPL_T<A>: iter::CopyableIter<A> {\n     fn filter_to_vec(pred: fn(A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }"}, {"sha": "91d6ffa765aa01de4e7696f6414e3300131403fb", "filename": "src/libcore/iter-trait/dlist.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdlist.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -1,4 +1,5 @@\n-type IMPL_T<A> = dlist::dlist<A>;\n+#[allow(non_camel_case_types)]\n+type IMPL_T<A> = dlist::DList<A>;\n \n /**\n  * Iterates through the current contents."}, {"sha": "5c02f8b5deab350af55e9799811d87824544ce42", "filename": "src/libcore/iter-trait/dvec.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdvec.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -1,4 +1,5 @@\n-type IMPL_T<A> = dvec::dvec<A>;\n+#[allow(non_camel_case_types)]\n+type IMPL_T<A> = dvec::DVec<A>;\n \n /**\n  * Iterates through the current contents."}, {"sha": "06a1c6c9fba83750821ad26aa71dc8eb397211d3", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -1,9 +1,9 @@\n-trait base_iter<A> {\n+trait BaseIter<A> {\n     fn each(blk: fn(A) -> bool);\n     fn size_hint() -> option<uint>;\n }\n \n-trait extended_iter<A> {\n+trait ExtendedIter<A> {\n     fn eachi(blk: fn(uint, A) -> bool);\n     fn all(blk: fn(A) -> bool) -> bool;\n     fn any(blk: fn(A) -> bool) -> bool;\n@@ -13,14 +13,14 @@ trait extended_iter<A> {\n     fn position(f: fn(A) -> bool) -> option<uint>;\n }\n \n-trait times {\n+trait Times {\n     fn times(it: fn() -> bool);\n }\n-trait timesi{\n+trait TimesIx{\n     fn timesi(it: fn(uint) -> bool);\n }\n \n-trait copyable_iter<A:copy> {\n+trait CopyableIter<A:copy> {\n     fn filter_to_vec(pred: fn(A) -> bool) -> ~[A];\n     fn map_to_vec<B>(op: fn(A) -> B) -> ~[B];\n     fn to_vec() -> ~[A];\n@@ -29,29 +29,29 @@ trait copyable_iter<A:copy> {\n     fn find(p: fn(A) -> bool) -> option<A>;\n }\n \n-fn eachi<A,IA:base_iter<A>>(self: IA, blk: fn(uint, A) -> bool) {\n+fn eachi<A,IA:BaseIter<A>>(self: IA, blk: fn(uint, A) -> bool) {\n     let mut i = 0u;\n     for self.each |a| {\n         if !blk(i, a) { break; }\n         i += 1u;\n     }\n }\n \n-fn all<A,IA:base_iter<A>>(self: IA, blk: fn(A) -> bool) -> bool {\n+fn all<A,IA:BaseIter<A>>(self: IA, blk: fn(A) -> bool) -> bool {\n     for self.each |a| {\n         if !blk(a) { return false; }\n     }\n     return true;\n }\n \n-fn any<A,IA:base_iter<A>>(self: IA, blk: fn(A) -> bool) -> bool {\n+fn any<A,IA:BaseIter<A>>(self: IA, blk: fn(A) -> bool) -> bool {\n     for self.each |a| {\n         if blk(a) { return true; }\n     }\n     return false;\n }\n \n-fn filter_to_vec<A:copy,IA:base_iter<A>>(self: IA,\n+fn filter_to_vec<A:copy,IA:BaseIter<A>>(self: IA,\n                                          prd: fn(A) -> bool) -> ~[A] {\n     let mut result = ~[];\n     self.size_hint().iter(|hint| vec::reserve(result, hint));\n@@ -61,7 +61,7 @@ fn filter_to_vec<A:copy,IA:base_iter<A>>(self: IA,\n     return result;\n }\n \n-fn map_to_vec<A:copy,B,IA:base_iter<A>>(self: IA, op: fn(A) -> B) -> ~[B] {\n+fn map_to_vec<A:copy,B,IA:BaseIter<A>>(self: IA, op: fn(A) -> B) -> ~[B] {\n     let mut result = ~[];\n     self.size_hint().iter(|hint| vec::reserve(result, hint));\n     for self.each |a| {\n@@ -70,7 +70,7 @@ fn map_to_vec<A:copy,B,IA:base_iter<A>>(self: IA, op: fn(A) -> B) -> ~[B] {\n     return result;\n }\n \n-fn flat_map_to_vec<A:copy,B:copy,IA:base_iter<A>,IB:base_iter<B>>(\n+fn flat_map_to_vec<A:copy,B:copy,IA:BaseIter<A>,IB:BaseIter<B>>(\n     self: IA, op: fn(A) -> IB) -> ~[B] {\n \n     let mut result = ~[];\n@@ -82,26 +82,26 @@ fn flat_map_to_vec<A:copy,B:copy,IA:base_iter<A>,IB:base_iter<B>>(\n     return result;\n }\n \n-fn foldl<A,B,IA:base_iter<A>>(self: IA, +b0: B, blk: fn(B, A) -> B) -> B {\n+fn foldl<A,B,IA:BaseIter<A>>(self: IA, +b0: B, blk: fn(B, A) -> B) -> B {\n     let mut b <- b0;\n     for self.each |a| {\n         b = blk(b, a);\n     }\n     return b;\n }\n \n-fn to_vec<A:copy,IA:base_iter<A>>(self: IA) -> ~[A] {\n+fn to_vec<A:copy,IA:BaseIter<A>>(self: IA) -> ~[A] {\n     foldl::<A,~[A],IA>(self, ~[], |r, a| vec::append(r, ~[a]))\n }\n \n-fn contains<A,IA:base_iter<A>>(self: IA, x: A) -> bool {\n+fn contains<A,IA:BaseIter<A>>(self: IA, x: A) -> bool {\n     for self.each |a| {\n         if a == x { return true; }\n     }\n     return false;\n }\n \n-fn count<A,IA:base_iter<A>>(self: IA, x: A) -> uint {\n+fn count<A,IA:BaseIter<A>>(self: IA, x: A) -> uint {\n     do foldl(self, 0u) |count, value| {\n         if value == x {\n             count + 1u\n@@ -111,7 +111,7 @@ fn count<A,IA:base_iter<A>>(self: IA, x: A) -> uint {\n     }\n }\n \n-fn position<A,IA:base_iter<A>>(self: IA, f: fn(A) -> bool)\n+fn position<A,IA:BaseIter<A>>(self: IA, f: fn(A) -> bool)\n         -> option<uint> {\n     let mut i = 0;\n     for self.each |a| {\n@@ -133,7 +133,7 @@ fn repeat(times: uint, blk: fn() -> bool) {\n     }\n }\n \n-fn min<A:copy,IA:base_iter<A>>(self: IA) -> A {\n+fn min<A:copy,IA:BaseIter<A>>(self: IA) -> A {\n     match do foldl::<A,option<A>,IA>(self, none) |a, b| {\n         match a {\n           some(a_) if a_ < b => {\n@@ -149,7 +149,7 @@ fn min<A:copy,IA:base_iter<A>>(self: IA) -> A {\n     }\n }\n \n-fn max<A:copy,IA:base_iter<A>>(self: IA) -> A {\n+fn max<A:copy,IA:BaseIter<A>>(self: IA) -> A {\n     match do foldl::<A,option<A>,IA>(self, none) |a, b| {\n         match a {\n           some(a_) if a_ > b => {"}, {"sha": "7d5e98c08bd84fbe55530839c75bb1d10ed129b1", "filename": "src/libcore/os.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -177,16 +177,16 @@ mod global_env {\n             do priv::weaken_task |weak_po| {\n                 loop {\n                     match comm::select2(msg_po, weak_po) {\n-                      either::left(MsgGetEnv(n, resp_ch)) => {\n+                      either::Left(MsgGetEnv(n, resp_ch)) => {\n                         comm::send(resp_ch, impl::getenv(n))\n                       }\n-                      either::left(MsgSetEnv(n, v, resp_ch)) => {\n+                      either::Left(MsgSetEnv(n, v, resp_ch)) => {\n                         comm::send(resp_ch, impl::setenv(n, v))\n                       }\n-                      either::left(MsgEnv(resp_ch)) => {\n+                      either::Left(MsgEnv(resp_ch)) => {\n                         comm::send(resp_ch, impl::env())\n                       }\n-                      either::right(_) => break\n+                      either::Right(_) => break\n                     }\n                 }\n             }"}, {"sha": "6de2059d2deae178bc87fbca52a6a9e61b626185", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -77,7 +77,7 @@ bounded and unbounded protocols allows for less code duplication.\n #[forbid(deprecated_pattern)];\n \n import unsafe::{forget, reinterpret_cast, transmute};\n-import either::{either, left, right};\n+import either::{Either, Left, Right};\n import option::unwrap;\n \n // Things used by code generated by the pipe compiler.\n@@ -658,15 +658,15 @@ this case, `select2` may return either `left` or `right`.\n fn select2<A: send, Ab: send, B: send, Bb: send>(\n     +a: recv_packet_buffered<A, Ab>,\n     +b: recv_packet_buffered<B, Bb>)\n-    -> either<(option<A>, recv_packet_buffered<B, Bb>),\n+    -> Either<(option<A>, recv_packet_buffered<B, Bb>),\n               (recv_packet_buffered<A, Ab>, option<B>)>\n {\n     let i = wait_many([a.header(), b.header()]/_);\n \n     unsafe {\n         match i {\n-          0 => left((try_recv(a), b)),\n-          1 => right((a, try_recv(b))),\n+          0 => Left((try_recv(a), b)),\n+          1 => Right((a, try_recv(b))),\n           _ => fail ~\"select2 return an invalid packet\"\n         }\n     }\n@@ -687,10 +687,10 @@ fn selecti<T: selectable>(endpoints: &[T]) -> uint {\n }\n \n /// Returns 0 or 1 depending on which endpoint is ready to receive\n-fn select2i<A: selectable, B: selectable>(a: &A, b: &B) -> either<(), ()> {\n+fn select2i<A: selectable, B: selectable>(a: &A, b: &B) -> Either<(), ()> {\n     match wait_many([a.header(), b.header()]/_) {\n-      0 => left(()),\n-      1 => right(()),\n+      0 => Left(()),\n+      1 => Right(()),\n       _ => fail ~\"wait returned unexpected index\"\n     }\n }\n@@ -1117,28 +1117,28 @@ fn shared_chan<T:send>(+c: chan<T>) -> shared_chan<T> {\n /// Receive a message from one of two endpoints.\n trait select2<T: send, U: send> {\n     /// Receive a message or return `none` if a connection closes.\n-    fn try_select() -> either<option<T>, option<U>>;\n+    fn try_select() -> Either<option<T>, option<U>>;\n     /// Receive a message or fail if a connection closes.\n-    fn select() -> either<T, U>;\n+    fn select() -> Either<T, U>;\n }\n \n impl<T: send, U: send, Left: selectable recv<T>, Right: selectable recv<U>>\n     (Left, Right): select2<T, U> {\n \n-    fn select() -> either<T, U> {\n+    fn select() -> Either<T, U> {\n         match self {\n           (lp, rp) => match select2i(&lp, &rp) {\n-            left(()) => left (lp.recv()),\n-            right(()) => right(rp.recv())\n+            Left(()) => Left (lp.recv()),\n+            Right(()) => Right(rp.recv())\n           }\n         }\n     }\n \n-    fn try_select() -> either<option<T>, option<U>> {\n+    fn try_select() -> Either<option<T>, option<U>> {\n         match self {\n           (lp, rp) => match select2i(&lp, &rp) {\n-            left(()) => left (lp.try_recv()),\n-            right(()) => right(rp.try_recv())\n+            Left(()) => Left (lp.try_recv()),\n+            Right(()) => Right(rp.try_recv())\n           }\n         }\n     }\n@@ -1204,7 +1204,7 @@ mod test {\n         c1.send(~\"abc\");\n \n         match (p1, p2).select() {\n-          right(_) => fail,\n+          Right(_) => fail,\n           _ => ()\n         }\n "}, {"sha": "2c3ff0121ba1ad6bec2a470c75ad03bd273899eb", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -16,7 +16,7 @@ export to_uint;\n export ref_eq;\n export buf_len;\n export position;\n-export ptr;\n+export Ptr;\n \n import libc::{c_void, size_t};\n \n@@ -156,13 +156,13 @@ fn ref_eq<T>(thing: &a/T, other: &b/T) -> bool {\n     to_uint(thing) == to_uint(other)\n }\n \n-trait ptr {\n+trait Ptr {\n     pure fn is_null() -> bool;\n     pure fn is_not_null() -> bool;\n }\n \n /// Extension methods for pointers\n-impl<T> *T: ptr {\n+impl<T> *T: Ptr {\n     /// Returns true if the pointer is equal to the null pointer.\n     pure fn is_null() -> bool { is_null(self) }\n "}, {"sha": "341d28e67e81ac90d2aea44f6bc29503d1bf79ab", "filename": "src/libcore/result.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -1,6 +1,6 @@\n //! A type representing either success or failure\n \n-import either::either;\n+import either::Either;\n \n /// The result type\n enum result<T, U> {\n@@ -59,10 +59,10 @@ pure fn is_err<T, U>(res: result<T, U>) -> bool {\n  * `ok` result variants are converted to `either::right` variants, `err`\n  * result variants are converted to `either::left`.\n  */\n-pure fn to_either<T: copy, U: copy>(res: result<U, T>) -> either<T, U> {\n+pure fn to_either<T: copy, U: copy>(res: result<U, T>) -> Either<T, U> {\n     match res {\n-      ok(res) => either::right(res),\n-      err(fail_) => either::left(fail_)\n+      ok(res) => either::Right(res),\n+      err(fail_) => either::Left(fail_)\n     }\n }\n "}, {"sha": "cb8d596cf8806640c957927bffd1b48f21365678", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -10,28 +10,28 @@ Sendable hash maps.  Very much a work in progress.\n  *\n  * The hash should concentrate entropy in the lower bits.\n  */\n-type hashfn<K> = pure fn~(K) -> uint;\n-type eqfn<K> = pure fn~(K, K) -> bool;\n+type HashFn<K> = pure fn~(K) -> uint;\n+type EqFn<K> = pure fn~(K, K) -> bool;\n \n /// Open addressing with linear probing.\n mod linear {\n-    export linear_map, linear_map_with_capacity, public_methods;\n+    export LinearMap, linear_map, linear_map_with_capacity, public_methods;\n \n     const initial_capacity: uint = 32u; // 2^5\n-    type bucket<K,V> = {hash: uint, key: K, value: V};\n-    enum linear_map<K,V> {\n-        linear_map_({\n+    type Bucket<K,V> = {hash: uint, key: K, value: V};\n+    enum LinearMap<K,V> {\n+        LinearMap_({\n             hashfn: pure fn~(x: &K) -> uint,\n             eqfn: pure fn~(x: &K, y: &K) -> bool,\n             resize_at: uint,\n             size: uint,\n-            buckets: ~[option<bucket<K,V>>]})\n+            buckets: ~[option<Bucket<K,V>>]})\n     }\n \n     // FIXME(#2979) -- with #2979 we could rewrite found_entry\n     // to have type option<&bucket<K,V>> which would be nifty\n-    enum search_result {\n-        found_entry(uint), found_hole(uint), table_full\n+    enum SearchResult {\n+        FoundEntry(uint), FoundHole(uint), TableFull\n     }\n \n     fn resize_at(capacity: uint) -> uint {\n@@ -40,17 +40,17 @@ mod linear {\n \n     fn linear_map<K,V>(\n         +hashfn: pure fn~(x: &K) -> uint,\n-        +eqfn: pure fn~(x: &K, y: &K) -> bool) -> linear_map<K,V> {\n+        +eqfn: pure fn~(x: &K, y: &K) -> bool) -> LinearMap<K,V> {\n \n         linear_map_with_capacity(hashfn, eqfn, 32)\n     }\n \n     fn linear_map_with_capacity<K,V>(\n         +hashfn: pure fn~(x: &K) -> uint,\n         +eqfn: pure fn~(x: &K, y: &K) -> bool,\n-        initial_capacity: uint) -> linear_map<K,V> {\n+        initial_capacity: uint) -> LinearMap<K,V> {\n \n-        linear_map_({\n+        LinearMap_({\n             hashfn: hashfn,\n             eqfn: eqfn,\n             resize_at: resize_at(initial_capacity),\n@@ -64,7 +64,7 @@ mod linear {\n         unsafe::reinterpret_cast(p)\n     }\n \n-    priv impl<K, V> &const linear_map<K,V> {\n+    priv impl<K, V> &const LinearMap<K,V> {\n         #[inline(always)]\n         pure fn to_bucket(h: uint) -> uint {\n             // FIXME(#3041) borrow a more sophisticated technique here from\n@@ -101,32 +101,32 @@ mod linear {\n \n         #[inline(always)]\n         pure fn bucket_for_key(\n-            buckets: &[option<bucket<K,V>>],\n-            k: &K) -> search_result {\n+            buckets: &[option<Bucket<K,V>>],\n+            k: &K) -> SearchResult {\n \n             let hash = self.hashfn(k);\n             self.bucket_for_key_with_hash(buckets, hash, k)\n         }\n \n         #[inline(always)]\n         pure fn bucket_for_key_with_hash(\n-            buckets: &[option<bucket<K,V>>],\n+            buckets: &[option<Bucket<K,V>>],\n             hash: uint,\n-            k: &K) -> search_result {\n+            k: &K) -> SearchResult {\n \n             let _ = for self.bucket_sequence(hash) |i| {\n                 match buckets[i] {\n                   some(bkt) => if bkt.hash == hash && self.eqfn(k, &bkt.key) {\n-                    return found_entry(i);\n+                    return FoundEntry(i);\n                   },\n-                  none => return found_hole(i)\n+                  none => return FoundHole(i)\n                 }\n             };\n-            return table_full;\n+            return TableFull;\n         }\n     }\n \n-    priv impl<K,V> &mut linear_map<K,V> {\n+    priv impl<K,V> &mut LinearMap<K,V> {\n         /// Expands the capacity of the array and re-inserts each\n         /// of the existing buckets.\n         fn expand() {\n@@ -146,7 +146,7 @@ mod linear {\n             }\n         }\n \n-        fn insert_bucket(+bucket: option<bucket<K,V>>) {\n+        fn insert_bucket(+bucket: option<Bucket<K,V>>) {\n             let {hash, key, value} <- option::unwrap(bucket);\n             let _ = self.insert_internal(hash, key, value);\n         }\n@@ -157,15 +157,15 @@ mod linear {\n         fn insert_internal(hash: uint, +k: K, +v: V) -> bool {\n             match self.bucket_for_key_with_hash(self.buckets, hash,\n                                               unsafe{borrow(k)}) {\n-              table_full => {fail ~\"Internal logic error\";}\n-              found_hole(idx) => {\n+              TableFull => {fail ~\"Internal logic error\";}\n+              FoundHole(idx) => {\n                 debug!{\"insert fresh (%?->%?) at idx %?, hash %?\",\n                        k, v, idx, hash};\n                 self.buckets[idx] = some({hash: hash, key: k, value: v});\n                 self.size += 1;\n                 return true;\n               }\n-              found_entry(idx) => {\n+              FoundEntry(idx) => {\n                 debug!{\"insert overwrite (%?->%?) at idx %?, hash %?\",\n                        k, v, idx, hash};\n                 self.buckets[idx] = some({hash: hash, key: k, value: v});\n@@ -175,7 +175,7 @@ mod linear {\n         }\n     }\n \n-    impl<K,V> &mut linear_map<K,V> {\n+    impl<K,V> &mut LinearMap<K,V> {\n         fn insert(+k: K, +v: V) -> bool {\n             if self.size >= self.resize_at {\n                 // n.b.: We could also do this after searching, so\n@@ -208,10 +208,10 @@ mod linear {\n             // http://www.maths.lse.ac.uk/Courses/MA407/del-hash.pdf\n \n             let mut idx = match self.bucket_for_key(self.buckets, k) {\n-              table_full | found_hole(_) => {\n+              TableFull | FoundHole(_) => {\n                 return false;\n               }\n-              found_entry(idx) => {\n+              FoundEntry(idx) => {\n                 idx\n               }\n             };\n@@ -230,13 +230,13 @@ mod linear {\n         }\n     }\n \n-    priv impl<K,V> &linear_map<K,V> {\n-        fn search(hash: uint, op: fn(x: &option<bucket<K,V>>) -> bool) {\n+    priv impl<K,V> &LinearMap<K,V> {\n+        fn search(hash: uint, op: fn(x: &option<Bucket<K,V>>) -> bool) {\n             let _ = self.bucket_sequence(hash, |i| op(&self.buckets[i]));\n         }\n     }\n \n-    impl<K,V> &const linear_map<K,V> {\n+    impl<K,V> &const LinearMap<K,V> {\n         pure fn len() -> uint {\n             self.size\n         }\n@@ -247,21 +247,21 @@ mod linear {\n \n         fn contains_key(k: &K) -> bool {\n             match self.bucket_for_key(self.buckets, k) {\n-              found_entry(_) => {true}\n-              table_full | found_hole(_) => {false}\n+              FoundEntry(_) => {true}\n+              TableFull | FoundHole(_) => {false}\n             }\n         }\n     }\n \n-    impl<K,V: copy> &const linear_map<K,V> {\n+    impl<K,V: copy> &const LinearMap<K,V> {\n         fn find(k: &K) -> option<V> {\n             match self.bucket_for_key(self.buckets, k) {\n-              found_entry(idx) => {\n+              FoundEntry(idx) => {\n                 match check self.buckets[idx] {\n                   some(bkt) => {some(copy bkt.value)}\n                 }\n               }\n-              table_full | found_hole(_) => {\n+              TableFull | FoundHole(_) => {\n                 none\n               }\n             }\n@@ -277,7 +277,7 @@ mod linear {\n \n     }\n \n-    impl<K,V> &linear_map<K,V> {\n+    impl<K,V> &LinearMap<K,V> {\n         /*\n         FIXME --- #2979 must be fixed to typecheck this\n         fn find_ptr(k: K) -> option<&V> {\n@@ -306,17 +306,17 @@ mod linear {\n         }\n     }\n \n-    impl<K: copy, V: copy> &linear_map<K,V> {\n+    impl<K: copy, V: copy> &LinearMap<K,V> {\n         fn each(blk: fn(+K,+V) -> bool) {\n             self.each_ref(|k,v| blk(copy *k, copy *v));\n         }\n     }\n-    impl<K: copy, V> &linear_map<K,V> {\n+    impl<K: copy, V> &LinearMap<K,V> {\n         fn each_key(blk: fn(+K) -> bool) {\n             self.each_key_ref(|k| blk(copy *k));\n         }\n     }\n-    impl<K, V: copy> &linear_map<K,V> {\n+    impl<K, V: copy> &LinearMap<K,V> {\n         fn each_value(blk: fn(+V) -> bool) {\n             self.each_value_ref(|v| blk(copy *v));\n         }\n@@ -326,12 +326,12 @@ mod linear {\n #[test]\n mod test {\n \n-    import linear::linear_map;\n+    import linear::{LinearMap, linear_map};\n \n     pure fn uint_hash(x: &uint) -> uint { *x }\n     pure fn uint_eq(x: &uint, y: &uint) -> bool { *x == *y }\n \n-    fn int_linear_map<V>() -> linear_map<uint,V> {\n+    fn int_linear_map<V>() -> LinearMap<uint,V> {\n         return linear_map(uint_hash, uint_eq);\n     }\n "}, {"sha": "d73c71c510ac02b209c9e88f275218121c72b223", "filename": "src/libcore/str.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -108,8 +108,8 @@ export\n \n    unsafe,\n    extensions,\n-   str_slice,\n-   unique_str;\n+   StrSlice,\n+   UniqueStr;\n \n #[abi = \"cdecl\"]\n extern mod rustrt {\n@@ -1877,7 +1877,7 @@ mod unsafe {\n \n     /// Sets the length of the string and adds the null terminator\n     unsafe fn set_len(&v: ~str, new_len: uint) {\n-        let repr: *vec::unsafe::vec_repr = ::unsafe::reinterpret_cast(v);\n+        let repr: *vec::unsafe::VecRepr = ::unsafe::reinterpret_cast(v);\n         (*repr).fill = new_len + 1u;\n         let null = ptr::mut_offset(ptr::mut_addr_of((*repr).data), new_len);\n         *null = 0u8;\n@@ -1895,14 +1895,14 @@ mod unsafe {\n \n }\n \n-trait unique_str {\n+trait UniqueStr {\n     fn trim() -> self;\n     fn trim_left() -> self;\n     fn trim_right() -> self;\n }\n \n /// Extension methods for strings\n-impl ~str: unique_str {\n+impl ~str: UniqueStr {\n     /// Returns a string with leading and trailing whitespace removed\n     #[inline]\n     fn trim() -> ~str { trim(self) }\n@@ -1922,7 +1922,7 @@ impl ~str: add<&str,~str> {\n     }\n }\n \n-trait str_slice {\n+trait StrSlice {\n     fn all(it: fn(char) -> bool) -> bool;\n     fn any(it: fn(char) -> bool) -> bool;\n     fn contains(needle: &a/str) -> bool;\n@@ -1951,7 +1951,7 @@ trait str_slice {\n }\n \n /// Extension methods for strings\n-impl &str: str_slice {\n+impl &str: StrSlice {\n     /**\n      * Return true if a predicate matches all characters or if the string\n      * contains no characters"}, {"sha": "678cda3240430a57442e07405b046134c0301045", "filename": "src/libcore/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -693,7 +693,7 @@ type task_id = int;\n type rust_task = libc::c_void;\n type rust_closure = libc::c_void;\n \n-type taskset = send_map::linear::linear_map<*rust_task,()>;\n+type taskset = send_map::linear::LinearMap<*rust_task,()>;\n \n fn new_taskset() -> taskset {\n     pure fn task_hash(t: &*rust_task) -> uint {\n@@ -1271,7 +1271,7 @@ impl<T: owned> @T: local_data { }\n // heavily in future, this could be made more efficient with a proper map.\n type task_local_element = (*libc::c_void, *libc::c_void, local_data);\n // Has to be a pointer at outermost layer; the foreign call returns void *.\n-type task_local_map = @dvec::dvec<option<task_local_element>>;\n+type task_local_map = @dvec::DVec<option<task_local_element>>;\n \n extern fn cleanup_task_local_map(map_ptr: *libc::c_void) unsafe {\n     assert !map_ptr.is_null();"}, {"sha": "4f27e8cea8f99028522fcfe795c7bd2dd1e423ba", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -80,7 +80,7 @@ impl T: num::Num {\n     static pure fn from_int(n: int) -> T   { return n as T;      }\n }\n \n-impl T: iter::times {\n+impl T: iter::Times {\n     #[inline(always)]\n     #[doc = \"A convenience form for basic iteration. Given a variable `x` \\\n         of any numeric type, the expression `for x.times { /* anything */ }` \\\n@@ -96,7 +96,7 @@ impl T: iter::times {\n     }\n }\n \n-impl T: iter::timesi {\n+impl T: iter::TimesIx {\n     #[inline(always)]\n     /// Like `times`, but with an index, `eachi`-style.\n     fn timesi(it: fn(uint) -> bool) {\n@@ -295,7 +295,7 @@ fn to_str_radix17() {\n \n #[test]\n fn test_times() {\n-    import iter::times;\n+    import iter::Times;\n     let ten = 10 as T;\n     let mut accum = 0;\n     for ten.times { accum += 1; }"}, {"sha": "e53cd1ddccf2ec722c3691ad1252ad2e14dedcbb", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -86,21 +86,21 @@ export as_const_buf;\n export unsafe;\n export u8;\n export extensions;\n-export const_vector;\n-export copyable_vector;\n-export immutable_vector;\n-export immutable_copyable_vector;\n-export iter_trait_extensions;\n+export ConstVector;\n+export CopyableVector;\n+export ImmutableVector;\n+export ImmutableCopyableVector;\n+export IterTraitExtensions;\n export vec_concat;\n \n #[abi = \"cdecl\"]\n extern mod rustrt {\n     fn vec_reserve_shared(++t: *sys::TypeDesc,\n-                          ++v: **unsafe::vec_repr,\n+                          ++v: **unsafe::VecRepr,\n                           ++n: libc::size_t);\n     fn vec_from_buf_shared(++t: *sys::TypeDesc,\n                            ++ptr: *(),\n-                           ++count: libc::size_t) -> *unsafe::vec_repr;\n+                           ++count: libc::size_t) -> *unsafe::VecRepr;\n }\n \n #[abi = \"rust-intrinsic\"]\n@@ -109,7 +109,7 @@ extern mod rusti {\n }\n \n /// A function used to initialize the elements of a vector\n-type init_op/&<T> = fn(uint) -> T;\n+type InitOp/&<T> = fn(uint) -> T;\n \n /// Returns true if a vector contains no elements\n pure fn is_empty<T>(v: &[const T]) -> bool {\n@@ -140,7 +140,7 @@ pure fn same_length<T, U>(xs: &[const T], ys: &[const U]) -> bool {\n fn reserve<T>(&v: ~[const T], n: uint) {\n     // Only make the (slow) call into the runtime if we have to\n     if capacity(v) < n {\n-        let ptr = ptr::addr_of(v) as **unsafe::vec_repr;\n+        let ptr = ptr::addr_of(v) as **unsafe::VecRepr;\n         rustrt::vec_reserve_shared(sys::get_type_desc::<T>(),\n                                    ptr, n as size_t);\n     }\n@@ -169,7 +169,7 @@ fn reserve_at_least<T>(&v: ~[const T], n: uint) {\n #[inline(always)]\n pure fn capacity<T>(&&v: ~[const T]) -> uint {\n     unsafe {\n-        let repr: **unsafe::vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n+        let repr: **unsafe::VecRepr = ::unsafe::reinterpret_cast(addr_of(v));\n         (**repr).alloc / sys::size_of::<T>()\n     }\n }\n@@ -186,7 +186,7 @@ pure fn len<T>(&&v: &[const T]) -> uint {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value returned by the function `op`.\n  */\n-pure fn from_fn<T>(n_elts: uint, op: init_op<T>) -> ~[T] {\n+pure fn from_fn<T>(n_elts: uint, op: InitOp<T>) -> ~[T] {\n     let mut v = ~[];\n     unchecked{reserve(v, n_elts);}\n     let mut i: uint = 0u;\n@@ -523,7 +523,7 @@ fn pop<T>(&v: ~[const T]) -> T {\n #[inline(always)]\n fn push<T>(&v: ~[const T], +initval: T) {\n     unsafe {\n-        let repr: **unsafe::vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n+        let repr: **unsafe::VecRepr = ::unsafe::reinterpret_cast(addr_of(v));\n         let fill = (**repr).fill;\n         if (**repr).alloc > fill {\n             push_fast(v, initval);\n@@ -537,7 +537,7 @@ fn push<T>(&v: ~[const T], +initval: T) {\n // This doesn't bother to make sure we have space.\n #[inline(always)] // really pretty please\n unsafe fn push_fast<T>(&v: ~[const T], +initval: T) {\n-    let repr: **unsafe::vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n+    let repr: **unsafe::VecRepr = ::unsafe::reinterpret_cast(addr_of(v));\n     let fill = (**repr).fill;\n     (**repr).fill += sys::size_of::<T>();\n     let p = ptr::addr_of((**repr).data);\n@@ -640,7 +640,7 @@ fn grow<T: copy>(&v: ~[const T], n: uint, initval: T) {\n  * * init_op - A function to call to retreive each appended element's\n  *             value\n  */\n-fn grow_fn<T>(&v: ~[const T], n: uint, op: init_op<T>) {\n+fn grow_fn<T>(&v: ~[const T], n: uint, op: InitOp<T>) {\n     reserve_at_least(v, len(v) + n);\n     let mut i: uint = 0u;\n     while i < n { push(v, op(i)); i += 1u; }\n@@ -1304,14 +1304,14 @@ impl<T: copy> ~[mut T]: add<&[const T],~[mut T]> {\n     }\n }\n \n-trait const_vector {\n+trait ConstVector {\n     pure fn is_empty() -> bool;\n     pure fn is_not_empty() -> bool;\n     pure fn len() -> uint;\n }\n \n /// Extension methods for vectors\n-impl<T> &[const T]: const_vector {\n+impl<T> &[const T]: ConstVector {\n     /// Returns true if a vector contains no elements\n     #[inline]\n     pure fn is_empty() -> bool { is_empty(self) }\n@@ -1323,7 +1323,7 @@ impl<T> &[const T]: const_vector {\n     pure fn len() -> uint { len(self) }\n }\n \n-trait copyable_vector<T> {\n+trait CopyableVector<T> {\n     pure fn head() -> T;\n     pure fn init() -> ~[T];\n     pure fn last() -> T;\n@@ -1332,7 +1332,7 @@ trait copyable_vector<T> {\n }\n \n /// Extension methods for vectors\n-impl<T: copy> &[const T]: copyable_vector<T> {\n+impl<T: copy> &[const T]: CopyableVector<T> {\n     /// Returns the first element of a vector\n     #[inline]\n     pure fn head() -> T { head(self) }\n@@ -1350,7 +1350,7 @@ impl<T: copy> &[const T]: copyable_vector<T> {\n     pure fn tail() -> ~[T] { tail(self) }\n }\n \n-trait immutable_vector<T> {\n+trait ImmutableVector<T> {\n     pure fn foldr<U: copy>(z: U, p: fn(T, U) -> U) -> U;\n     pure fn iter(f: fn(T));\n     pure fn iteri(f: fn(uint, T));\n@@ -1369,7 +1369,7 @@ trait immutable_vector<T> {\n }\n \n /// Extension methods for vectors\n-impl<T> &[T]: immutable_vector<T> {\n+impl<T> &[T]: ImmutableVector<T> {\n     /// Reduce a vector from right to left\n     #[inline]\n     pure fn foldr<U: copy>(z: U, p: fn(T, U) -> U) -> U { foldr(self, z, p) }\n@@ -1477,14 +1477,14 @@ impl<T> &[T]: immutable_vector<T> {\n     }\n }\n \n-trait immutable_copyable_vector<T> {\n+trait ImmutableCopyableVector<T> {\n     pure fn filter(f: fn(T) -> bool) -> ~[T];\n     pure fn find(f: fn(T) -> bool) -> option<T>;\n     pure fn rfind(f: fn(T) -> bool) -> option<T>;\n }\n \n /// Extension methods for vectors\n-impl<T: copy> &[T]: immutable_copyable_vector<T> {\n+impl<T: copy> &[T]: ImmutableCopyableVector<T> {\n     /**\n      * Construct a new vector from the elements of a vector for which some\n      * predicate holds.\n@@ -1518,14 +1518,14 @@ impl<T: copy> &[T]: immutable_copyable_vector<T> {\n mod unsafe {\n     // FIXME: This should have crate visibility (#1893 blocks that)\n     /// The internal representation of a vector\n-    type vec_repr = {\n+    type VecRepr = {\n         box_header: (uint, uint, uint, uint),\n         mut fill: uint,\n         mut alloc: uint,\n         data: u8\n     };\n \n-    type slice_repr = {\n+    type SliceRepr = {\n         mut data: *u8,\n         mut len: uint\n     };\n@@ -1555,7 +1555,7 @@ mod unsafe {\n      */\n     #[inline(always)]\n     unsafe fn set_len<T>(&&v: ~[const T], new_len: uint) {\n-        let repr: **vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n+        let repr: **VecRepr = ::unsafe::reinterpret_cast(addr_of(v));\n         (**repr).fill = new_len * sys::size_of::<T>();\n     }\n \n@@ -1570,14 +1570,14 @@ mod unsafe {\n      */\n     #[inline(always)]\n     unsafe fn to_ptr<T>(v: ~[const T]) -> *T {\n-        let repr: **vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n+        let repr: **VecRepr = ::unsafe::reinterpret_cast(addr_of(v));\n         return ::unsafe::reinterpret_cast(addr_of((**repr).data));\n     }\n \n \n     #[inline(always)]\n     unsafe fn to_ptr_slice<T>(v: &[const T]) -> *T {\n-        let repr: **slice_repr = ::unsafe::reinterpret_cast(addr_of(v));\n+        let repr: **SliceRepr = ::unsafe::reinterpret_cast(addr_of(v));\n         return ::unsafe::reinterpret_cast(addr_of((**repr).data));\n     }\n \n@@ -1729,12 +1729,12 @@ mod u8 {\n // This cannot be used with iter-trait.rs because of the region pointer\n // required in the slice.\n \n-impl<A> &[A]: iter::base_iter<A> {\n+impl<A> &[A]: iter::BaseIter<A> {\n     fn each(blk: fn(A) -> bool) { each(self, blk) }\n     fn size_hint() -> option<uint> { some(len(self)) }\n }\n \n-impl<A> &[A]: iter::extended_iter<A> {\n+impl<A> &[A]: iter::ExtendedIter<A> {\n     fn eachi(blk: fn(uint, A) -> bool) { iter::eachi(self, blk) }\n     fn all(blk: fn(A) -> bool) -> bool { iter::all(self, blk) }\n     fn any(blk: fn(A) -> bool) -> bool { iter::any(self, blk) }\n@@ -1746,15 +1746,15 @@ impl<A> &[A]: iter::extended_iter<A> {\n     fn position(f: fn(A) -> bool) -> option<uint> { iter::position(self, f) }\n }\n \n-trait iter_trait_extensions<A> {\n+trait IterTraitExtensions<A> {\n     fn filter_to_vec(pred: fn(A) -> bool) -> ~[A];\n     fn map_to_vec<B>(op: fn(A) -> B) -> ~[B];\n     fn to_vec() -> ~[A];\n     fn min() -> A;\n     fn max() -> A;\n }\n \n-impl<A: copy> &[A]: iter_trait_extensions<A> {\n+impl<A: copy> &[A]: IterTraitExtensions<A> {\n     fn filter_to_vec(pred: fn(A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }"}, {"sha": "7b8c0e9fcad43d2aa25fb91fb4816d203e77ea9e", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -1,7 +1,7 @@\n //! A deque. Untested as of yet. Likely buggy\n \n import option::{some, none};\n-import dvec::dvec;\n+import dvec::{DVec, dvec};\n \n trait t<T> {\n     fn size() -> uint;\n@@ -40,14 +40,14 @@ fn create<T: copy>() -> t<T> {\n \n         return rv;\n     }\n-    fn get<T: copy>(elts: dvec<cell<T>>, i: uint) -> T {\n+    fn get<T: copy>(elts: DVec<cell<T>>, i: uint) -> T {\n         match elts.get_elt(i) { some(t) => t, _ => fail }\n     }\n \n     type repr<T> = {mut nelts: uint,\n                     mut lo: uint,\n                     mut hi: uint,\n-                    elts: dvec<cell<T>>};\n+                    elts: DVec<cell<T>>};\n \n     impl <T: copy> repr<T>: t<T> {\n         fn size() -> uint { return self.nelts; }"}, {"sha": "0c8d974a6d7f6e9a83e07f4689fcd953f876d733", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -3,7 +3,7 @@\n import map;\n import map::{hashmap, str_hash};\n import io::Reader;\n-import dvec::dvec;\n+import dvec::{DVec, dvec};\n \n export url, userinfo, query;\n export from_str, to_str;\n@@ -176,7 +176,7 @@ fn encode_plus(s: ~str) -> ~str {\n /**\n  * Encode a hashmap to the 'application/x-www-form-urlencoded' media type.\n  */\n-fn encode_form_urlencoded(m: hashmap<~str, @dvec<@~str>>) -> ~str {\n+fn encode_form_urlencoded(m: hashmap<~str, @DVec<@~str>>) -> ~str {\n     let mut out = ~\"\";\n     let mut first = true;\n \n@@ -203,7 +203,7 @@ fn encode_form_urlencoded(m: hashmap<~str, @dvec<@~str>>) -> ~str {\n  * type into a hashmap.\n  */\n fn decode_form_urlencoded(s: ~[u8]) ->\n-    map::hashmap<~str, @dvec::dvec<@~str>> {\n+    map::hashmap<~str, @dvec::DVec<@~str>> {\n     do io::with_bytes_reader(s) |rdr| {\n         let m = str_hash();\n         let mut key = ~\"\";"}, {"sha": "a7b40bbb0f9fe32052dc81f65a92693f92715265", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -4,12 +4,12 @@\n  */\n import core::option;\n import core::option::{some, none};\n-import dvec::dvec;\n+import dvec::{DVec, dvec};\n import map::map;\n \n // FIXME (#2347): Should not be @; there's a bug somewhere in rustc that\n // requires this to be.\n-type smallintmap_<T: copy> = {v: dvec<option<T>>};\n+type smallintmap_<T: copy> = {v: DVec<option<T>>};\n \n enum smallintmap<T:copy> {\n     smallintmap_(@smallintmap_<T>)"}, {"sha": "6b78fa9b0320f32875df7165f6686eaa7bdae751", "filename": "src/libstd/test.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -5,7 +5,7 @@\n // simplest interface possible for representing and running tests\n // while providing a base that other test frameworks may build off of.\n \n-import either::either;\n+import either::Either;\n import result::{ok, err};\n import io::WriterUtil;\n import libc::size_t;\n@@ -53,16 +53,16 @@ type test_desc = {\n fn test_main(args: ~[~str], tests: ~[test_desc]) {\n     let opts =\n         match parse_opts(args) {\n-          either::left(o) => o,\n-          either::right(m) => fail m\n+          either::Left(o) => o,\n+          either::Right(m) => fail m\n         };\n     if !run_tests_console(opts, tests) { fail ~\"Some tests failed\"; }\n }\n \n type test_opts = {filter: option<~str>, run_ignored: bool,\n                   logfile: option<~str>};\n \n-type opt_res = either<test_opts, ~str>;\n+type opt_res = Either<test_opts, ~str>;\n \n // Parses command line arguments into test options\n fn parse_opts(args: ~[~str]) -> opt_res {\n@@ -71,7 +71,7 @@ fn parse_opts(args: ~[~str]) -> opt_res {\n     let matches =\n         match getopts::getopts(args_, opts) {\n           ok(m) => m,\n-          err(f) => return either::right(getopts::fail_str(f))\n+          err(f) => return either::Right(getopts::fail_str(f))\n         };\n \n     let filter =\n@@ -85,7 +85,7 @@ fn parse_opts(args: ~[~str]) -> opt_res {\n     let test_opts = {filter: filter, run_ignored: run_ignored,\n                      logfile: logfile};\n \n-    return either::left(test_opts);\n+    return either::Left(test_opts);\n }\n \n enum test_result { tr_ok, tr_failed, tr_ignored, }\n@@ -479,7 +479,7 @@ mod tests {\n     fn first_free_arg_should_be_a_filter() {\n         let args = ~[~\"progname\", ~\"filter\"];\n         let opts = match parse_opts(args) {\n-          either::left(o) => o,\n+          either::Left(o) => o,\n           _ => fail ~\"Malformed arg in first_free_arg_should_be_a_filter\"\n         };\n         assert ~\"filter\" == option::get(opts.filter);\n@@ -489,7 +489,7 @@ mod tests {\n     fn parse_ignored_flag() {\n         let args = ~[~\"progname\", ~\"filter\", ~\"--ignored\"];\n         let opts = match parse_opts(args) {\n-          either::left(o) => o,\n+          either::Left(o) => o,\n           _ => fail ~\"Malformed arg in parse_ignored_flag\"\n         };\n         assert (opts.run_ignored);"}, {"sha": "96b7e46dabf4bdeb656cbe992dff7b204c1bdc2d", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -9,7 +9,7 @@ import iotask::{iotask, spawn_iotask};\n import priv::{chan_from_global_ptr, weaken_task};\n import comm::{port, chan, select2, listen};\n import task::task_builder;\n-import either::{left, right};\n+import either::{Left, Right};\n \n extern mod rustrt {\n     fn rust_uv_get_kernel_global_chan_ptr() -> *libc::uintptr_t;\n@@ -58,14 +58,14 @@ fn get_monitor_task_gl() -> iotask unsafe {\n             loop {\n                 debug!{\"in outer_loop...\"};\n                 match select2(weak_exit_po, msg_po) {\n-                  left(weak_exit) => {\n+                  Left(weak_exit) => {\n                     // all normal tasks have ended, tell the\n                     // libuv loop to tear_down, then exit\n                     debug!{\"weak_exit_po recv'd msg: %?\", weak_exit};\n                     iotask::exit(hl_loop);\n                     break;\n                   }\n-                  right(fetch_ch) => {\n+                  Right(fetch_ch) => {\n                     debug!{\"hl_loop req recv'd: %?\", fetch_ch};\n                     fetch_ch.send(hl_loop);\n                   }"}, {"sha": "5b2b4fb05613306d52759cab0b4c1ff31ad56ab8", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -205,8 +205,8 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n       }\n       item_foreign_mod(nm) => {\n         let abi = match attr::foreign_abi(i.attrs) {\n-          either::left(msg) => cx.diag.span_fatal(i.span, msg),\n-          either::right(abi) => abi\n+          either::Left(msg) => cx.diag.span_fatal(i.span, msg),\n+          either::Right(abi) => abi\n         };\n         for nm.items.each |nitem| {\n             cx.map.insert(nitem.id,"}, {"sha": "7c04d6e4570f586671b541358673a0b4bf8a830d", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -2,7 +2,7 @@\n \n import std::map;\n import std::map::hashmap;\n-import either::either;\n+import either::Either;\n import diagnostic::span_handler;\n import ast_util::{spanned, dummy_spanned};\n import parse::comments::{doc_comment_style, strip_doc_comment_decoration};\n@@ -330,22 +330,22 @@ fn find_linkage_metas(attrs: ~[ast::attribute]) -> ~[@ast::meta_item] {\n     }\n }\n \n-fn foreign_abi(attrs: ~[ast::attribute]) -> either<~str, ast::foreign_abi> {\n+fn foreign_abi(attrs: ~[ast::attribute]) -> Either<~str, ast::foreign_abi> {\n     return match attr::first_attr_value_str_by_name(attrs, ~\"abi\") {\n       option::none => {\n-        either::right(ast::foreign_abi_cdecl)\n+        either::Right(ast::foreign_abi_cdecl)\n       }\n       option::some(@~\"rust-intrinsic\") => {\n-        either::right(ast::foreign_abi_rust_intrinsic)\n+        either::Right(ast::foreign_abi_rust_intrinsic)\n       }\n       option::some(@~\"cdecl\") => {\n-        either::right(ast::foreign_abi_cdecl)\n+        either::Right(ast::foreign_abi_cdecl)\n       }\n       option::some(@~\"stdcall\") => {\n-        either::right(ast::foreign_abi_stdcall)\n+        either::Right(ast::foreign_abi_stdcall)\n       }\n       option::some(t) => {\n-        either::left(~\"unsupported abi: \" + *t)\n+        either::Left(~\"unsupported abi: \" + *t)\n       }\n     };\n }"}, {"sha": "e0e93b1eda58b478c5df00fb6a41aa47845b22dd", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -1,4 +1,4 @@\n-import dvec::dvec;\n+import dvec::{DVec, dvec};\n \n export filename;\n export filemap;\n@@ -48,7 +48,7 @@ type filemap =\n     @{name: filename, substr: file_substr, src: @~str,\n       start_pos: file_pos, mut lines: ~[file_pos]};\n \n-type codemap = @{files: dvec<filemap>};\n+type codemap = @{files: DVec<filemap>};\n \n type loc = {file: filemap, line: uint, col: uint};\n "}, {"sha": "100f248a7ad35768ca24b89a399eba89e31946e4", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -1,5 +1,5 @@\n import to_str::ToStr;\n-import dvec::dvec;\n+import dvec::{DVec, dvec};\n \n import ast::{ident};\n \n@@ -62,7 +62,7 @@ enum state {\n         span: span,\n         dir: direction,\n         ty_params: ~[ast::ty_param],\n-        messages: dvec<message>,\n+        messages: DVec<message>,\n         proto: protocol,\n     }),\n }\n@@ -112,7 +112,7 @@ fn protocol(name: ident, +span: span) -> protocol {\n class protocol_ {\n     let name: ident;\n     let span: span;\n-    let states: dvec<state>;\n+    let states: DVec<state>;\n \n     let mut bounded: option<bool>;\n "}, {"sha": "6b5dce312d61fde2d0f88f92bcca9ccd5f5d8e09", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -2,7 +2,7 @@ import ast::{crate, expr_, mac_invoc,\n                      mac_aq, mac_var};\n import parse::parser;\n import parse::parser::parse_from_source_str;\n-import dvec::dvec;\n+import dvec::{DVec, dvec};\n \n import fold::*;\n import visit::*;\n@@ -20,7 +20,7 @@ struct gather_item {\n     constr: ~str;\n }\n \n-type aq_ctxt = @{lo: uint, gather: dvec<gather_item>};\n+type aq_ctxt = @{lo: uint, gather: DVec<gather_item>};\n enum fragment {\n     from_expr(@ast::expr),\n     from_ty(@ast::ty)"}, {"sha": "e8899a2e5414fbc628169f00b93078949b03a5b8", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -1,6 +1,6 @@\n import codemap::span;\n import std::map::{hashmap, str_hash, box_str_hash};\n-import dvec::dvec;\n+import dvec::{DVec, dvec};\n \n import base::*;\n \n@@ -124,7 +124,7 @@ fn compose_sels(s1: selector, s2: selector) -> selector {\n \n type binders =\n     {real_binders: hashmap<ident, selector>,\n-     literal_ast_matchers: dvec<selector>};\n+     literal_ast_matchers: DVec<selector>};\n type bindings = hashmap<ident, arb_depth<matchable>>;\n \n fn acumm_bindings(_cx: ext_ctxt, _b_dest: bindings, _b_src: bindings) { }"}, {"sha": "b6dc1c05a2cc83e6edf0e7db9c7f81022781e2dd", "filename": "src/libsyntax/ext/tt/earley_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -7,7 +7,7 @@ import parse::parser::{parser,SOURCE_FILE};\n //import parse::common::parser_common;\n import parse::common::*; //resolve bug?\n import parse::parse_sess;\n-import dvec::dvec;\n+import dvec::{DVec, dvec};\n import ast::{matcher, match_tok, match_seq, match_nonterminal, ident};\n import ast_util::mk_sp;\n import std::map::{hashmap, box_str_hash};\n@@ -42,7 +42,7 @@ type matcher_pos = ~{\n     sep: option<token>,\n     mut idx: uint,\n     mut up: matcher_pos_up, // mutable for swapping only\n-    matches: ~[dvec<@named_match>],\n+    matches: ~[DVec<@named_match>],\n     match_lo: uint, match_hi: uint,\n     sp_lo: uint,\n };"}, {"sha": "cbb6709d9c8bb73799b63b547aaa483a49ef00f1", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -1,4 +1,4 @@\n-import either::{either, left, right};\n+import either::{Either, Left, Right};\n import ast_util::spanned;\n import common::*; //resolve bug?\n \n@@ -7,7 +7,7 @@ export parser_attr;\n \n // A type to distingush between the parsing of item attributes or syntax\n // extensions, which both begin with token.POUND\n-type attr_or_ext = option<either<~[ast::attribute], @ast::expr>>;\n+type attr_or_ext = option<Either<~[ast::attribute], @ast::expr>>;\n \n trait parser_attr {\n     fn parse_outer_attrs_or_ext(first_item_attrs: ~[ast::attribute])\n@@ -36,18 +36,18 @@ impl parser: parser_attr {\n                 self.bump();\n                 let first_attr =\n                     self.parse_attribute_naked(ast::attr_outer, lo);\n-                return some(left(vec::append(~[first_attr],\n+                return some(Left(vec::append(~[first_attr],\n                                           self.parse_outer_attributes())));\n             } else if !(self.look_ahead(1u) == token::LT\n                         || self.look_ahead(1u) == token::LBRACKET\n                         || self.look_ahead(1u) == token::POUND\n                         || expect_item_next) {\n                 self.bump();\n-                return some(right(self.parse_syntax_ext_naked(lo)));\n+                return some(Right(self.parse_syntax_ext_naked(lo)));\n             } else { return none; }\n         }\n         token::DOC_COMMENT(_) => {\n-          return some(left(self.parse_outer_attributes()));\n+          return some(Left(self.parse_outer_attributes()));\n         }\n         _ => return none\n       }"}, {"sha": "99768d558abc2a1eacb3e5c3cc51cf437f9948e1", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -340,40 +340,40 @@ fn scan_number(c: char, rdr: string_reader) -> token::token {\n     if c == 'u' || c == 'i' {\n         let signed = c == 'i';\n         let mut tp = {\n-            if signed { either::left(ast::ty_i) }\n-            else { either::right(ast::ty_u) }\n+            if signed { either::Left(ast::ty_i) }\n+            else { either::Right(ast::ty_u) }\n         };\n         bump(rdr);\n         c = rdr.curr;\n         if c == '8' {\n             bump(rdr);\n-            tp = if signed { either::left(ast::ty_i8) }\n-                      else { either::right(ast::ty_u8) };\n+            tp = if signed { either::Left(ast::ty_i8) }\n+                      else { either::Right(ast::ty_u8) };\n         }\n         n = nextch(rdr);\n         if c == '1' && n == '6' {\n             bump(rdr);\n             bump(rdr);\n-            tp = if signed { either::left(ast::ty_i16) }\n-                      else { either::right(ast::ty_u16) };\n+            tp = if signed { either::Left(ast::ty_i16) }\n+                      else { either::Right(ast::ty_u16) };\n         } else if c == '3' && n == '2' {\n             bump(rdr);\n             bump(rdr);\n-            tp = if signed { either::left(ast::ty_i32) }\n-                      else { either::right(ast::ty_u32) };\n+            tp = if signed { either::Left(ast::ty_i32) }\n+                      else { either::Right(ast::ty_u32) };\n         } else if c == '6' && n == '4' {\n             bump(rdr);\n             bump(rdr);\n-            tp = if signed { either::left(ast::ty_i64) }\n-                      else { either::right(ast::ty_u64) };\n+            tp = if signed { either::Left(ast::ty_i64) }\n+                      else { either::Right(ast::ty_u64) };\n         }\n         if str::len(num_str) == 0u {\n             rdr.fatal(~\"no valid digits found for number\");\n         }\n         let parsed = option::get(u64::from_str_radix(num_str, base as u64));\n         match tp {\n-          either::left(t) => return token::LIT_INT(parsed as i64, t),\n-          either::right(t) => return token::LIT_UINT(parsed, t)\n+          either::Left(t) => return token::LIT_INT(parsed as i64, t),\n+          either::Right(t) => return token::LIT_UINT(parsed, t)\n         }\n     }\n     let mut is_float = false;"}, {"sha": "f894f6fae82ee034988b4ad568270f282b1dec5b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -1,7 +1,7 @@\n import print::pprust::expr_to_str;\n \n import result::result;\n-import either::{either, left, right};\n+import either::{Either, Left, Right};\n import std::map::{hashmap, str_hash};\n import token::{can_begin_expr, is_ident, is_ident_or_path, is_plain_ident,\n                INTERPOLATED};\n@@ -102,7 +102,7 @@ enum class_contents { ctor_decl(fn_decl, ~[attribute], blk, codemap::span),\n                       dtor_decl(blk, ~[attribute], codemap::span),\n                       members(~[@class_member]) }\n \n-type arg_or_capture_item = either<arg, capture_item>;\n+type arg_or_capture_item = Either<arg, capture_item>;\n type item_info = (ident, item_, option<~[attribute]>);\n \n enum item_or_view_item {\n@@ -557,9 +557,9 @@ class parser {\n         }\n \n         if self.eat_keyword(~\"move\") {\n-            either::right(parse_capture_item(self, true))\n+            either::Right(parse_capture_item(self, true))\n         } else if self.eat_keyword(~\"copy\") {\n-            either::right(parse_capture_item(self, false))\n+            either::Right(parse_capture_item(self, false))\n         } else {\n             parse_arg_fn(self)\n         }\n@@ -570,7 +570,7 @@ class parser {\n         let i = self.parse_value_ident();\n         self.expect(token::COLON);\n         let t = self.parse_ty(false);\n-        either::left({mode: m, ty: t, ident: i, id: self.get_id()})\n+        either::Left({mode: m, ty: t, ident: i, id: self.get_id()})\n     }\n \n     fn parse_arg_or_capture_item() -> arg_or_capture_item {\n@@ -588,7 +588,7 @@ class parser {\n                   node: ty_infer,\n                   span: mk_sp(p.span.lo, p.span.hi)}\n             };\n-            either::left({mode: m, ty: t, ident: i, id: p.get_id()})\n+            either::Left({mode: m, ty: t, ident: i, id: p.get_id()})\n         }\n     }\n \n@@ -2051,8 +2051,8 @@ class parser {\n             let mut item_attrs;\n             match self.parse_outer_attrs_or_ext(first_item_attrs) {\n               none => item_attrs = ~[],\n-              some(left(attrs)) => item_attrs = attrs,\n-              some(right(ext)) => {\n+              some(Left(attrs)) => item_attrs = attrs,\n+              some(Right(ext)) => {\n                 return @spanned(lo, ext.span.hi,\n                                 stmt_expr(ext, self.get_id()));\n               }"}, {"sha": "7282eaafb79454589c49f5847bcebaff1a51dd3f", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -1,5 +1,5 @@\n import io::WriterUtil;\n-import dvec::dvec;\n+import dvec::{DVec, dvec};\n \n /*\n  * This pretty-printer is a direct reimplementation of Philip Karlton's\n@@ -222,7 +222,7 @@ type printer_ = {\n     mut top: uint, // index of top of scan_stack\n     mut bottom: uint, // index of bottom of scan_stack\n     // stack of blocks-in-progress being flushed by print\n-    print_stack: dvec<print_stack_elt>,\n+    print_stack: DVec<print_stack_elt>,\n     // buffered indentation to avoid writing trailing whitespace\n     mut pending_indentation: int,\n     mut token_tree_last_was_ident: bool"}, {"sha": "de1cd2c3df03c1f0720f95fedb5777af77b368fe", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -7,7 +7,7 @@ import pp::{break_offset, word, printer,\n import diagnostic;\n import ast::{required, provided};\n import ast_util::{operator_prec};\n-import dvec::dvec;\n+import dvec::{DVec, dvec};\n import parse::classify::*;\n import util::interner;\n \n@@ -35,7 +35,7 @@ type ps =\n       literals: option<~[comments::lit]>,\n       mut cur_cmnt: uint,\n       mut cur_lit: uint,\n-      boxes: dvec<pp::breaks>,\n+      boxes: DVec<pp::breaks>,\n       ann: pp_ann};\n \n fn ibox(s: ps, u: uint) {"}, {"sha": "9b7398d16c736ef0f019cd5e6438f4f5964a47ce", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -3,11 +3,11 @@\n // type, and vice versa.\n import std::map;\n import std::map::{hashmap, hashfn, eqfn};\n-import dvec::dvec;\n+import dvec::{DVec, dvec};\n \n type hash_interner<T: const> =\n     {map: hashmap<T, uint>,\n-     vect: dvec<T>,\n+     vect: DVec<T>,\n      hasher: hashfn<T>,\n      eqer: eqfn<T>};\n "}, {"sha": "90de6a4335ff6b9f49d5746d4ac4bca4106ca8f2", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -9,7 +9,7 @@ import syntax::codemap::span;\n import driver::session;\n import session::session;\n import syntax::attr;\n-import dvec::dvec;\n+import dvec::{DVec, dvec};\n \n export modify_for_testing;\n \n@@ -22,7 +22,7 @@ type test_ctxt =\n     @{sess: session::session,\n       crate: @ast::crate,\n       mut path: ~[ast::ident],\n-      testfns: dvec<test>};\n+      testfns: DVec<test>};\n \n // Traverse the crate, collecting all the test functions, eliding any\n // existing main functions, and synthesizing a main test harness"}, {"sha": "744ee50da8bdd0ada35bb0e50bf3cca965cad65f", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -9,7 +9,7 @@ import std::map::{hashmap, int_hash};\n import syntax::print::pprust;\n import filesearch::filesearch;\n import common::*;\n-import dvec::dvec;\n+import dvec::{DVec, dvec};\n \n export read_crates;\n \n@@ -42,7 +42,7 @@ type cache_entry = {\n     metas: @~[@ast::meta_item]\n };\n \n-fn dump_crates(crate_cache: dvec<cache_entry>) {\n+fn dump_crates(crate_cache: DVec<cache_entry>) {\n     debug!{\"resolved crates:\"};\n     for crate_cache.each |entry| {\n         debug!{\"cnum: %?\", entry.cnum};\n@@ -67,9 +67,9 @@ fn warn_if_multiple_versions(diag: span_handler,\n             partition(crate_cache.map_to_vec(|entry| {\n                 let othername = loader::crate_name_from_metas(*entry.metas);\n                 if name == othername {\n-                    left(entry)\n+                    Left(entry)\n                 } else {\n-                    right(entry)\n+                    Right(entry)\n                 }\n             }));\n \n@@ -96,7 +96,7 @@ type env = @{diag: span_handler,\n              cstore: cstore::cstore,\n              os: loader::os,\n              static: bool,\n-             crate_cache: dvec<cache_entry>,\n+             crate_cache: DVec<cache_entry>,\n              mut next_crate_num: ast::crate_num};\n \n fn visit_view_item(e: env, i: @ast::view_item) {\n@@ -114,11 +114,11 @@ fn visit_item(e: env, i: @ast::item) {\n     match i.node {\n       ast::item_foreign_mod(m) => {\n         match attr::foreign_abi(i.attrs) {\n-          either::right(abi) => {\n+          either::Right(abi) => {\n             if abi != ast::foreign_abi_cdecl &&\n                abi != ast::foreign_abi_stdcall { return; }\n           }\n-          either::left(msg) => e.diag.span_fatal(i.span, msg)\n+          either::Left(msg) => e.diag.span_fatal(i.span, msg)\n         }\n \n         let cstore = e.cstore;"}, {"sha": "69c76e4041751f6a3c9832b0f91f77186e9bcbf3", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -10,7 +10,7 @@ import syntax::diagnostic::span_handler;\n import syntax::diagnostic::expect;\n import common::*;\n import std::map::hashmap;\n-import dvec::dvec;\n+import dvec::{DVec, dvec};\n \n export class_dtor;\n export get_symbol;\n@@ -144,7 +144,7 @@ fn get_trait_methods(tcx: ty::ctxt, def: ast::def_id) -> @~[ty::method] {\n }\n \n fn get_method_names_if_trait(cstore: cstore::cstore, def: ast::def_id)\n-    -> option<@dvec<(@~str, ast::self_ty_)>> {\n+    -> option<@DVec<(@~str, ast::self_ty_)>> {\n \n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     return decoder::get_method_names_if_trait(cdata, def.node);"}, {"sha": "70754ccdd820a7220a737ec047c287f9871e8b36", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -2,8 +2,8 @@\n \n import std::{ebml, map};\n import std::map::{hashmap, str_hash};\n-import dvec::dvec;\n import io::WriterUtil;\n+import dvec::{DVec, dvec};\n import syntax::{ast, ast_util};\n import syntax::attr;\n import middle::ty;\n@@ -684,7 +684,7 @@ fn get_trait_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n // their self types. Otherwise, returns none. This overlaps in an\n // annoying way with get_trait_methods.\n fn get_method_names_if_trait(cdata: cmd, node_id: ast::node_id)\n-                          -> option<@dvec<(@~str, ast::self_ty_)>> {\n+                          -> option<@DVec<(@~str, ast::self_ty_)>> {\n \n     let item = lookup_item(node_id, cdata.data);\n     if item_family(item) != 'I' {"}, {"sha": "83b8666f7c42739f6d4af694725751734d8ea244", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -229,7 +229,7 @@ import syntax::print::pprust;\n import util::common::indenter;\n import ty::to_str;\n import driver::session::session;\n-import dvec::dvec;\n+import dvec::{DVec, dvec};\n import mem_categorization::*;\n \n export check_crate, root_map, mutbl_map;\n@@ -339,7 +339,7 @@ type loan = {lp: @loan_path, cmt: cmt, mutbl: ast::mutability};\n /// - `pure_map`: map from block/expr that must be pure to the error message\n ///   that should be reported if they are not pure\n type req_maps = {\n-    req_loan_map: hashmap<ast::node_id, @dvec<@dvec<loan>>>,\n+    req_loan_map: hashmap<ast::node_id, @DVec<@DVec<loan>>>,\n     pure_map: hashmap<ast::node_id, bckerr>\n };\n "}, {"sha": "3541ddad62678b8a1b17f41d6cee423b08bb956e", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -393,7 +393,7 @@ impl gather_loan_ctxt {\n         }\n     }\n \n-    fn add_loans(scope_id: ast::node_id, loans: @dvec<loan>) {\n+    fn add_loans(scope_id: ast::node_id, loans: @DVec<loan>) {\n         match self.req_maps.req_loan_map.find(scope_id) {\n           some(l) => {\n             (*l).push(loans);"}, {"sha": "66b786ca791c01b575dccdb3be99c4088b756e25", "filename": "src/rustc/middle/borrowck/loan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -8,7 +8,7 @@ import result::{result, ok, err};\n impl borrowck_ctxt {\n     fn loan(cmt: cmt,\n             scope_region: ty::region,\n-            mutbl: ast::mutability) -> bckres<@dvec<loan>> {\n+            mutbl: ast::mutability) -> bckres<@DVec<loan>> {\n         let lc = loan_ctxt_(@{bccx: self,\n                               scope_region: scope_region,\n                               loans: @dvec()});\n@@ -26,7 +26,7 @@ type loan_ctxt_ = {\n     scope_region: ty::region,\n \n     // accumulated list of loans that will be required\n-    loans: @dvec<loan>\n+    loans: @DVec<loan>\n };\n \n enum loan_ctxt {"}, {"sha": "3dc016e021d15b8e125ec32a7358c50bb172f346", "filename": "src/rustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_const.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -2,7 +2,7 @@ import syntax::ast::*;\n import syntax::{visit, ast_util, ast_map};\n import driver::session::session;\n import std::map::hashmap;\n-import dvec::dvec;\n+import dvec::{DVec, dvec};\n \n fn check_crate(sess: session, crate: @crate, ast_map: ast_map::map,\n                def_map: resolve3::DefMap,\n@@ -150,7 +150,7 @@ fn check_item_recursion(sess: session, ast_map: ast_map::map,\n         sess: session,\n         ast_map: ast_map::map,\n         def_map: resolve3::DefMap,\n-        idstack: @dvec<node_id>,\n+        idstack: @DVec<node_id>,\n     };\n \n     let env = {"}, {"sha": "31bb20a47d0031f51ef026f0a0736ea19a736577", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -415,7 +415,7 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n \n     match it.node {\n       ast::item_foreign_mod(nmod) if attr::foreign_abi(it.attrs) !=\n-      either::right(ast::foreign_abi_rust_intrinsic) => {\n+      either::Right(ast::foreign_abi_rust_intrinsic) => {\n         for nmod.items.each |ni| {\n             match ni.node {\n               ast::foreign_item_fn(decl, tps) => {"}, {"sha": "f8983f2bebb8c7e7f07111359b55937019e27544", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -100,7 +100,7 @@\n  * - `self_var`: a variable representing 'self'\n  */\n \n-import dvec::dvec;\n+import dvec::{DVec, dvec};\n import std::map::{hashmap, int_hash, str_hash, box_str_hash};\n import syntax::{visit, ast_util};\n import syntax::print::pprust::{expr_to_str};\n@@ -122,7 +122,7 @@ export last_use_map;\n //\n // Very subtle (#2633): borrowck will remove entries from this table\n // if it detects an outstanding loan (that is, the addr is taken).\n-type last_use_map = hashmap<node_id, @dvec<node_id>>;\n+type last_use_map = hashmap<node_id, @DVec<node_id>>;\n \n enum variable = uint;\n enum live_node = uint;"}, {"sha": "e226e0ef9c58ab2ceb57cca11e32912a1fce112b", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -14,7 +14,7 @@ import syntax::codemap::span;\n import syntax::print::pprust;\n import syntax::ast_util::new_def_hash;\n import syntax::ast_map;\n-import dvec::dvec;\n+import dvec::{DVec, dvec};\n import metadata::csearch;\n \n import std::list;\n@@ -343,15 +343,15 @@ fn resolve_crate(sess: session, def_map: resolve3::DefMap,\n // dependencies until a fixed point is reached.\n \n type region_paramd_items = hashmap<ast::node_id, ()>;\n-type dep_map = hashmap<ast::node_id, @dvec<ast::node_id>>;\n+type dep_map = hashmap<ast::node_id, @DVec<ast::node_id>>;\n \n type determine_rp_ctxt_ = {\n     sess: session,\n     ast_map: ast_map::map,\n     def_map: resolve3::DefMap,\n     region_paramd_items: region_paramd_items,\n     dep_map: dep_map,\n-    worklist: dvec<ast::node_id>,\n+    worklist: DVec<ast::node_id>,\n \n     // the innermost enclosing item id\n     mut item_id: ast::node_id,"}, {"sha": "a06e6ea1dba48c517cbc4f864cd3c758dfdafce0", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -52,7 +52,7 @@ import syntax::visit::{visit_foreign_item, visit_item, visit_method_helper};\n import syntax::visit::{visit_mod, visit_ty, vt};\n \n import box::ptr_eq;\n-import dvec::dvec;\n+import dvec::{DVec, dvec};\n import option::{get, is_some};\n import str::{connect, split_str};\n import vec::pop;\n@@ -89,7 +89,7 @@ type ImplScopes = @list<ImplScope>;\n type ImplMap = hashmap<node_id,ImplScopes>;\n \n // Trait method resolution\n-type TraitMap = @hashmap<node_id,@dvec<def_id>>;\n+type TraitMap = @hashmap<node_id,@DVec<def_id>>;\n \n // Export mapping\n type Export = { reexp: bool, id: def_id };\n@@ -116,7 +116,7 @@ enum NamespaceResult {\n enum ImplNamespaceResult {\n     UnknownImplResult,\n     UnboundImplResult,\n-    BoundImplResult(@dvec<@Target>)\n+    BoundImplResult(@DVec<@Target>)\n }\n \n enum NameDefinition {\n@@ -250,7 +250,7 @@ fn Atom(n: uint) -> Atom {\n \n class AtomTable {\n     let atoms: hashmap<@~str,Atom>;\n-    let strings: dvec<@~str>;\n+    let strings: DVec<@~str>;\n     let mut atom_count: uint;\n \n     new() {\n@@ -326,11 +326,11 @@ class Rib {\n \n /// One import directive.\n class ImportDirective {\n-    let module_path: @dvec<Atom>;\n+    let module_path: @DVec<Atom>;\n     let subclass: @ImportDirectiveSubclass;\n     let span: span;\n \n-    new(module_path: @dvec<Atom>,\n+    new(module_path: @DVec<Atom>,\n         subclass: @ImportDirectiveSubclass,\n         span: span) {\n \n@@ -363,7 +363,7 @@ class ImportResolution {\n     let mut module_target: option<Target>;\n     let mut value_target: option<Target>;\n     let mut type_target: option<Target>;\n-    let mut impl_target: @dvec<@Target>;\n+    let mut impl_target: @DVec<@Target>;\n \n     let mut used: bool;\n \n@@ -409,7 +409,7 @@ class Module {\n     let mut def_id: option<def_id>;\n \n     let children: hashmap<Atom,@NameBindings>;\n-    let imports: dvec<@ImportDirective>;\n+    let imports: DVec<@ImportDirective>;\n \n     // The anonymous children of this node. Anonymous children are pseudo-\n     // modules that are implicitly created around items contained within\n@@ -677,17 +677,17 @@ class Resolver {\n     // The current set of local scopes, for values.\n     // XXX: Reuse ribs to avoid allocation.\n \n-    let value_ribs: @dvec<@Rib>;\n+    let value_ribs: @DVec<@Rib>;\n \n     // The current set of local scopes, for types.\n-    let type_ribs: @dvec<@Rib>;\n+    let type_ribs: @DVec<@Rib>;\n \n     // Whether the current context is an X-ray context. An X-ray context is\n     // allowed to access private names of any module.\n     let mut xray_context: XrayFlag;\n \n     // The trait that the current context can refer to.\n-    let mut current_trait_refs: option<@dvec<def_id>>;\n+    let mut current_trait_refs: option<@DVec<def_id>>;\n \n     // The atom for the keyword \"self\".\n     let self_atom: Atom;\n@@ -1571,7 +1571,7 @@ class Resolver {\n \n     /// Creates and adds an import directive to the given module.\n     fn build_import_directive(module_: @Module,\n-                              module_path: @dvec<Atom>,\n+                              module_path: @DVec<Atom>,\n                               subclass: @ImportDirectiveSubclass,\n                               span: span) {\n \n@@ -2181,7 +2181,7 @@ class Resolver {\n     }\n \n     fn resolve_module_path_from_root(module_: @Module,\n-                                     module_path: @dvec<Atom>,\n+                                     module_path: @DVec<Atom>,\n                                      index: uint,\n                                      xray: XrayFlag,\n                                      span: span)\n@@ -2238,7 +2238,7 @@ class Resolver {\n      * the given module.\n      */\n     fn resolve_module_path_for_import(module_: @Module,\n-                                      module_path: @dvec<Atom>,\n+                                      module_path: @DVec<Atom>,\n                                       xray: XrayFlag,\n                                       span: span)\n                                    -> ResolveResult<@Module> {\n@@ -2932,7 +2932,7 @@ class Resolver {\n     // Wraps the given definition in the appropriate number of `def_upvar`\n     // wrappers.\n \n-    fn upvarify(ribs: @dvec<@Rib>, rib_index: uint, def_like: def_like,\n+    fn upvarify(ribs: @DVec<@Rib>, rib_index: uint, def_like: def_like,\n                 span: span, allow_capturing_self: AllowCapturingSelfFlag)\n              -> option<def_like> {\n \n@@ -3031,7 +3031,7 @@ class Resolver {\n         return some(dl_def(def));\n     }\n \n-    fn search_ribs(ribs: @dvec<@Rib>, name: Atom, span: span,\n+    fn search_ribs(ribs: @DVec<@Rib>, name: Atom, span: span,\n                    allow_capturing_self: AllowCapturingSelfFlag)\n                 -> option<def_like> {\n \n@@ -4150,7 +4150,7 @@ class Resolver {\n         }\n     }\n \n-    fn intern_module_part_of_path(path: @path) -> @dvec<Atom> {\n+    fn intern_module_part_of_path(path: @path) -> @DVec<Atom> {\n         let module_path_atoms = @dvec();\n         for path.idents.eachi |index, ident| {\n             if index == path.idents.len() - 1u {\n@@ -4508,7 +4508,7 @@ class Resolver {\n         }\n     }\n \n-    fn search_for_traits_containing_method(name: Atom) -> @dvec<def_id> {\n+    fn search_for_traits_containing_method(name: Atom) -> @DVec<def_id> {\n         let found_traits = @dvec();\n         let mut search_module = self.current_module;\n         loop {\n@@ -4577,7 +4577,7 @@ class Resolver {\n         return found_traits;\n     }\n \n-    fn add_trait_info_if_containing_method(found_traits: @dvec<def_id>,\n+    fn add_trait_info_if_containing_method(found_traits: @DVec<def_id>,\n                                            trait_def_id: def_id,\n                                            name: Atom) {\n "}, {"sha": "e12070e265d39a8759237220daadb7c0b11522c8", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -13,7 +13,7 @@ import syntax::print::pprust::pat_to_str;\n import middle::resolve3::DefMap;\n import back::abi;\n import std::map::hashmap;\n-import dvec::dvec;\n+import dvec::{DVec, dvec};\n \n import common::*;\n \n@@ -277,7 +277,7 @@ fn enter_uniq(bcx: block, dm: DefMap, m: match_, col: uint, val: ValueRef)\n }\n \n fn get_options(ccx: @crate_ctxt, m: match_, col: uint) -> ~[opt] {\n-    fn add_to_set(tcx: ty::ctxt, &&set: dvec<opt>, val: opt) {\n+    fn add_to_set(tcx: ty::ctxt, &&set: DVec<opt>, val: opt) {\n         if set.any(|l| opt_eq(tcx, l, val)) {return;}\n         set.push(val);\n     }"}, {"sha": "23f5c69caa1097c4ba46ae3f3154e2eb49309d92", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -5015,8 +5015,8 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n       ast::item_const(_, expr) => consts::trans_const(ccx, expr, item.id),\n       ast::item_foreign_mod(foreign_mod) => {\n         let abi = match attr::foreign_abi(item.attrs) {\n-          either::right(abi_) => abi_,\n-          either::left(msg) => ccx.sess.span_fatal(item.span, msg)\n+          either::Right(abi_) => abi_,\n+          either::Left(msg) => ccx.sess.span_fatal(item.span, msg)\n         };\n         foreign::trans_foreign_mod(ccx, foreign_mod, abi);\n       }"}, {"sha": "fdde26d6718316f6fbaa68ed3b4a1688d294b154", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -1168,8 +1168,8 @@ fn abi_of_foreign_fn(ccx: @crate_ctxt, i: @ast::foreign_item)\n         ast_map::node_foreign_item(_, abi, _) => abi\n       },\n       some(_) => match attr::foreign_abi(i.attrs) {\n-        either::right(abi) => abi,\n-        either::left(msg) => ccx.sess.span_fatal(i.span, msg)\n+        either::Right(abi) => abi,\n+        either::Left(msg) => ccx.sess.span_fatal(i.span, msg)\n       }\n     }\n }"}, {"sha": "78eb527b78500c2bac22ac1b46488017dfde0b3d", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -15,7 +15,7 @@ import syntax::ast_util::{dummy_sp, new_def_hash};\n import syntax::util::interner;\n import util::ppaux::ty_to_str;\n import syntax::codemap::span;\n-import dvec::dvec;\n+import dvec::{DVec, dvec};\n \n import std::map::hashmap;\n import option::is_some;\n@@ -65,7 +65,7 @@ type ctxt =\n     {mut next_tag_id: u16,\n      pad: u16,\n      tag_id_to_index: hashmap<nominal_id, u16>,\n-     tag_order: dvec<enum_data>,\n+     tag_order: DVec<enum_data>,\n      resources: interner::interner<nominal_id>,\n      llshapetablesty: TypeRef,\n      llshapetables: ValueRef};"}, {"sha": "3bc4e578c749972b8f5ad7ec7b405050534a6401", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -501,7 +501,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n       }\n       ast::item_foreign_mod(m) => {\n         if syntax::attr::foreign_abi(it.attrs) ==\n-            either::right(ast::foreign_abi_rust_intrinsic) {\n+            either::Right(ast::foreign_abi_rust_intrinsic) {\n             for m.items.each |item| {\n                 check_intrinsic_type(ccx, item);\n             }"}, {"sha": "9de5aa98e5f82e5cfa86bbf5c6447052915fa636", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -9,7 +9,7 @@ import syntax::ast::{sty_value};\n import syntax::ast_map;\n import syntax::ast_map::node_id_to_str;\n import syntax::ast_util::{dummy_sp, new_def_hash};\n-import dvec::dvec;\n+import dvec::{DVec, dvec};\n \n type candidate = {\n     self_ty: ty::t,          // type of a in a.b()\n@@ -57,7 +57,7 @@ class lookup {\n     let m_name: ast::ident;\n     let mut self_ty: ty::t;\n     let mut derefs: uint;\n-    let candidates: dvec<candidate>;\n+    let candidates: DVec<candidate>;\n     let candidate_impls: hashmap<def_id, ()>;\n     let supplied_tps: ~[ty::t];\n     let include_private: bool;\n@@ -435,7 +435,7 @@ class lookup {\n     }\n \n     fn add_inherent_and_extension_candidates(optional_inherent_methods:\n-                                                option<@dvec<@Impl>>,\n+                                                option<@DVec<@Impl>>,\n                                              use_assignability: bool) {\n \n         // Add inherent methods."}, {"sha": "bc6342dbce1f40237dfe436ab694e88cd728aaa4", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -30,7 +30,7 @@ import syntax::visit::{mk_simple_visitor, mk_vt, visit_crate, visit_item};\n import syntax::visit::{visit_mod};\n import util::ppaux::ty_to_str;\n \n-import dvec::dvec;\n+import dvec::{DVec, dvec};\n import result::ok;\n import std::map::{hashmap, int_hash};\n import uint::range;\n@@ -121,11 +121,11 @@ fn method_to_MethodInfo(ast_method: @method) -> @MethodInfo {\n class CoherenceInfo {\n     // Contains implementations of methods that are inherent to a type.\n     // Methods in these implementations don't need to be exported.\n-    let inherent_methods: hashmap<def_id,@dvec<@Impl>>;\n+    let inherent_methods: hashmap<def_id,@DVec<@Impl>>;\n \n     // Contains implementations of methods associated with a trait. For these,\n     // the associated trait must be imported at the call site.\n-    let extension_methods: hashmap<def_id,@dvec<@Impl>>;\n+    let extension_methods: hashmap<def_id,@DVec<@Impl>>;\n \n     new() {\n         self.inherent_methods = new_def_hash();\n@@ -356,7 +356,7 @@ class CoherenceChecker {\n     }\n \n     fn check_implementation_coherence(_trait_def_id: def_id,\n-                                      implementations: @dvec<@Impl>) {\n+                                      implementations: @DVec<@Impl>) {\n \n         // Unify pairs of polytypes.\n         for range(0, implementations.len()) |i| {\n@@ -540,7 +540,7 @@ class CoherenceChecker {\n         return trait_id;\n     }\n \n-    fn gather_privileged_types(items: ~[@item]) -> @dvec<def_id> {\n+    fn gather_privileged_types(items: ~[@item]) -> @DVec<def_id> {\n         let results = @dvec();\n         for items.each |item| {\n             match item.node {"}, {"sha": "36461b44b754889b85bf021c2861480f5696621f", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -262,7 +262,7 @@ import driver::session::session;\n import util::common::{indent, indenter};\n import ast::{unsafe_fn, impure_fn, pure_fn, extern_fn};\n import ast::{m_const, m_imm, m_mutbl};\n-import dvec::dvec;\n+import dvec::{DVec, dvec};\n \n export infer_ctxt;\n export new_infer_ctxt;\n@@ -402,7 +402,7 @@ enum infer_ctxt = @{\n     ty_var_integral_counter: @mut uint,\n     region_var_counter: @mut uint,\n \n-    borrowings: dvec<{expr_id: ast::node_id,\n+    borrowings: DVec<{expr_id: ast::node_id,\n                       span: span,\n                       scope: ty::region,\n                       mutbl: ast::mutability}>"}, {"sha": "b96745890f928d412a4e59a9dce9545a85f7e6e0", "filename": "src/test/auxiliary/cci_nested_lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -1,7 +1,7 @@\n-import dvec::dvec;\n+import dvec::{DVec, dvec};\n \n type entry<A,B> = {key: A, value: B};\n-type alist<A,B> = { eq_fn: fn@(A,A) -> bool, data: dvec<entry<A,B>> };\n+type alist<A,B> = { eq_fn: fn@(A,A) -> bool, data: DVec<entry<A,B>> };\n \n fn alist_add<A: copy, B: copy>(lst: alist<A,B>, k: A, v: B) {\n     lst.data.push({key:k, value:v});"}, {"sha": "9d69cf15562b32ce084c38727b8a3b0351ec848b", "filename": "src/test/auxiliary/issue-2631-a.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -4,10 +4,10 @@\n use std;\n \n import dvec::*;\n-import dvec::dvec;\n+import dvec::DVec;\n import std::map::hashmap;\n \n-type header_map = hashmap<~str, @dvec<@~str>>;\n+type header_map = hashmap<~str, @DVec<@~str>>;\n \n // the unused ty param is necessary so this gets monomorphized\n fn request<T: copy>(req: header_map) {"}, {"sha": "ffbc7a3018bbbb7df0484c37634132637fa9c627", "filename": "src/test/compile-fail/issue-2590.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -1,7 +1,7 @@\n-import dvec::dvec;\n+import dvec::DVec;\n \n type parser = {\n-    tokens: dvec<int>,\n+    tokens: DVec<int>,\n };\n \n trait parse {"}, {"sha": "08c4286a011ea3a920cedfab7d7ca52064077c5e", "filename": "src/test/compile-fail/regions-glb-free-free.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -2,7 +2,7 @@ mod argparse {\n     use std;\n \n     import std::map;\n-    import either::{either, left, right};\n+    import either::{Either, Left, Right};\n \n     struct Flag {\n         name: &str;"}, {"sha": "209dc515bd04b4f1610261ec3535acea350575c7", "filename": "src/test/run-pass/pipe-select.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-select.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -79,8 +79,8 @@ fn test_select2() {\n     stream::client::send(ac, 42);\n \n     match pipes::select2(ap, bp) {\n-      either::left(*) => { }\n-      either::right(*) => { fail }\n+      either::Left(*) => { }\n+      either::Right(*) => { fail }\n     }\n \n     stream::client::send(bc, ~\"abc\");\n@@ -93,8 +93,8 @@ fn test_select2() {\n     stream::client::send(bc, ~\"abc\");\n \n     match pipes::select2(ap, bp) {\n-      either::left(*) => { fail }\n-      either::right(*) => { }\n+      either::Left(*) => { fail }\n+      either::Right(*) => { }\n     }\n \n     stream::client::send(ac, 42);"}, {"sha": "c221b091acbb73e01123a775568c3e885e29cbef", "filename": "src/test/run-pass/static-method-test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c69e1053188d92b86bc8b28cbf1af87d31ea2d/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs?ref=74c69e1053188d92b86bc8b28cbf1af87d31ea2d", "patch": "@@ -49,7 +49,7 @@ pure fn build<A, B: buildable<A>>(builder: fn(push: pure fn(+A))) -> B {\n }\n \n /// Apply a function to each element of an iterable and return the results\n-fn map<T, IT: base_iter<T>, U, BU: buildable<U>>\n+fn map<T, IT: BaseIter<T>, U, BU: buildable<U>>\n     (v: IT, f: fn(T) -> U) -> BU {\n     do build |push| {\n         for v.each() |elem| {"}]}