{"sha": "766813898f7901736d82bfc103874474177e7aca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2NjgxMzg5OGY3OTAxNzM2ZDgyYmZjMTAzODc0NDc0MTc3ZTdhY2E=", "commit": {"author": {"name": "Andrea Pretto", "email": "eulerdisk@gmail.com", "date": "2019-02-19T21:32:00Z"}, "committer": {"name": "Andrea Pretto", "email": "eulerdisk@gmail.com", "date": "2019-04-21T22:13:00Z"}, "message": "auto_import: make auto import working with target as a list of SmolStr instead of ast::Path", "tree": {"sha": "4923c73160ab0c53c0d777af965cea99ffaaec9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4923c73160ab0c53c0d777af965cea99ffaaec9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/766813898f7901736d82bfc103874474177e7aca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/766813898f7901736d82bfc103874474177e7aca", "html_url": "https://github.com/rust-lang/rust/commit/766813898f7901736d82bfc103874474177e7aca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/766813898f7901736d82bfc103874474177e7aca/comments", "author": {"login": "eulerdisk", "id": 10089822, "node_id": "MDQ6VXNlcjEwMDg5ODIy", "avatar_url": "https://avatars.githubusercontent.com/u/10089822?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eulerdisk", "html_url": "https://github.com/eulerdisk", "followers_url": "https://api.github.com/users/eulerdisk/followers", "following_url": "https://api.github.com/users/eulerdisk/following{/other_user}", "gists_url": "https://api.github.com/users/eulerdisk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eulerdisk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eulerdisk/subscriptions", "organizations_url": "https://api.github.com/users/eulerdisk/orgs", "repos_url": "https://api.github.com/users/eulerdisk/repos", "events_url": "https://api.github.com/users/eulerdisk/events{/privacy}", "received_events_url": "https://api.github.com/users/eulerdisk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eulerdisk", "id": 10089822, "node_id": "MDQ6VXNlcjEwMDg5ODIy", "avatar_url": "https://avatars.githubusercontent.com/u/10089822?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eulerdisk", "html_url": "https://github.com/eulerdisk", "followers_url": "https://api.github.com/users/eulerdisk/followers", "following_url": "https://api.github.com/users/eulerdisk/following{/other_user}", "gists_url": "https://api.github.com/users/eulerdisk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eulerdisk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eulerdisk/subscriptions", "organizations_url": "https://api.github.com/users/eulerdisk/orgs", "repos_url": "https://api.github.com/users/eulerdisk/repos", "events_url": "https://api.github.com/users/eulerdisk/events{/privacy}", "received_events_url": "https://api.github.com/users/eulerdisk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e0ae47b47f80e30fca366e5922c19ff81b0a2e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e0ae47b47f80e30fca366e5922c19ff81b0a2e2", "html_url": "https://github.com/rust-lang/rust/commit/0e0ae47b47f80e30fca366e5922c19ff81b0a2e2"}], "stats": {"total": 132, "additions": 69, "deletions": 63}, "files": [{"sha": "7527d805d05271fe1bd53b3fa8f0d01f2a93aba3", "filename": "crates/ra_assists/src/auto_import.rs", "status": "modified", "additions": 65, "deletions": 63, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/766813898f7901736d82bfc103874474177e7aca/crates%2Fra_assists%2Fsrc%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766813898f7901736d82bfc103874474177e7aca/crates%2Fra_assists%2Fsrc%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fauto_import.rs?ref=766813898f7901736d82bfc103874474177e7aca", "patch": "@@ -1,21 +1,15 @@\n use ra_text_edit::TextEditBuilder;\n-use hir::db::HirDatabase;\n+use hir::{ self, db::HirDatabase};\n \n use ra_syntax::{\n-    ast::{ self, NameOwner }, AstNode, SyntaxNode, Direction, TextRange,\n+    ast::{ self, NameOwner }, AstNode, SyntaxNode, Direction, TextRange, SmolStr,\n     SyntaxKind::{ PATH, PATH_SEGMENT, COLONCOLON, COMMA }\n };\n use crate::{\n     AssistId,\n-    assist_ctx::{AssistCtx, Assist, AssistBuilder},\n+    assist_ctx::{AssistCtx, Assist},\n };\n \n-fn collect_path_segments(path: &ast::Path) -> Option<Vec<&ast::PathSegment>> {\n-    let mut v = Vec::new();\n-    collect_path_segments_raw(&mut v, path)?;\n-    return Some(v);\n-}\n-\n fn collect_path_segments_raw<'a>(\n     segments: &mut Vec<&'a ast::PathSegment>,\n     mut path: &'a ast::Path,\n@@ -46,59 +40,43 @@ fn collect_path_segments_raw<'a>(\n     return Some(segments.len() - oldlen);\n }\n \n-fn fmt_segments(segments: &[&ast::PathSegment]) -> String {\n+fn fmt_segments(segments: &[SmolStr]) -> String {\n     let mut buf = String::new();\n     fmt_segments_raw(segments, &mut buf);\n     return buf;\n }\n \n-fn fmt_segments_raw(segments: &[&ast::PathSegment], buf: &mut String) {\n-    let mut first = true;\n-    for s in segments {\n-        if !first {\n-            buf.push_str(\"::\");\n-        }\n-        match s.kind() {\n-            Some(ast::PathSegmentKind::Name(nameref)) => buf.push_str(nameref.text()),\n-            Some(ast::PathSegmentKind::SelfKw) => buf.push_str(\"self\"),\n-            Some(ast::PathSegmentKind::SuperKw) => buf.push_str(\"super\"),\n-            Some(ast::PathSegmentKind::CrateKw) => buf.push_str(\"crate\"),\n-            None => {}\n-        }\n-        first = false;\n+fn fmt_segments_raw(segments: &[SmolStr], buf: &mut String) {\n+    let mut iter = segments.iter();\n+    if let Some(s) = iter.next() {\n+        buf.push_str(s);\n+    }\n+    for s in iter {\n+        buf.push_str(\"::\");\n+        buf.push_str(s);\n     }\n }\n \n // Returns the numeber of common segments.\n-fn compare_path_segments(left: &[&ast::PathSegment], right: &[&ast::PathSegment]) -> usize {\n+fn compare_path_segments(left: &[SmolStr], right: &[&ast::PathSegment]) -> usize {\n     return left.iter().zip(right).filter(|(l, r)| compare_path_segment(l, r)).count();\n }\n \n-fn compare_path_segment(a: &ast::PathSegment, b: &ast::PathSegment) -> bool {\n-    if let (Some(ka), Some(kb)) = (a.kind(), b.kind()) {\n-        match (ka, kb) {\n-            (ast::PathSegmentKind::Name(nameref_a), ast::PathSegmentKind::Name(nameref_b)) => {\n-                nameref_a.text() == nameref_b.text()\n-            }\n-            (ast::PathSegmentKind::SelfKw, ast::PathSegmentKind::SelfKw) => true,\n-            (ast::PathSegmentKind::SuperKw, ast::PathSegmentKind::SuperKw) => true,\n-            (ast::PathSegmentKind::CrateKw, ast::PathSegmentKind::CrateKw) => true,\n-            (_, _) => false,\n+fn compare_path_segment(a: &SmolStr, b: &ast::PathSegment) -> bool {\n+    if let Some(kb) = b.kind() {\n+        match kb {\n+            ast::PathSegmentKind::Name(nameref_b) => a == nameref_b.text(),\n+            ast::PathSegmentKind::SelfKw => a == \"self\",\n+            ast::PathSegmentKind::SuperKw => a == \"super\",\n+            ast::PathSegmentKind::CrateKw => a == \"crate\",\n         }\n     } else {\n         false\n     }\n }\n \n-fn compare_path_segment_with_name(a: &ast::PathSegment, b: &ast::Name) -> bool {\n-    if let Some(ka) = a.kind() {\n-        return match (ka, b) {\n-            (ast::PathSegmentKind::Name(nameref_a), _) => nameref_a.text() == b.text(),\n-            (_, _) => false,\n-        };\n-    } else {\n-        false\n-    }\n+fn compare_path_segment_with_name(a: &SmolStr, b: &ast::Name) -> bool {\n+    a == b.text()\n }\n \n #[derive(Copy, Clone)]\n@@ -190,7 +168,7 @@ fn walk_use_tree_for_best_action<'a>(\n     current_path_segments: &mut Vec<&'a ast::PathSegment>, // buffer containing path segments\n     current_parent_use_tree_list: Option<&'a ast::UseTreeList>, // will be Some value if we are in a nested import\n     current_use_tree: &'a ast::UseTree, // the use tree we are currently examinating\n-    target: &[&'a ast::PathSegment],    // the path we want to import\n+    target: &[SmolStr],    // the path we want to import\n ) -> ImportAction<'a> {\n     // We save the number of segments in the buffer so we can restore the correct segments\n     // before returning. Recursive call will add segments so we need to delete them.\n@@ -216,7 +194,7 @@ fn walk_use_tree_for_best_action<'a>(\n \n     // This can happen only if current_use_tree is a direct child of a UseItem\n     if let Some(name) = alias.and_then(ast::NameOwner::name) {\n-        if compare_path_segment_with_name(target[0], name) {\n+        if compare_path_segment_with_name(&target[0], name) {\n             return ImportAction::Nothing;\n         }\n     }\n@@ -345,8 +323,8 @@ fn walk_use_tree_for_best_action<'a>(\n \n fn best_action_for_target<'b, 'a: 'b>(\n     container: &'a SyntaxNode,\n-    path: &'a ast::Path,\n-    target: &'b [&'a ast::PathSegment],\n+    anchor: &'a SyntaxNode,\n+    target: &'b [SmolStr],\n ) -> ImportAction<'a> {\n     let mut storage = Vec::with_capacity(16); // this should be the only allocation\n     let best_action = container\n@@ -368,14 +346,14 @@ fn best_action_for_target<'b, 'a: 'b>(\n                 .children()\n                 .find_map(ast::ModuleItem::cast)\n                 .map(AstNode::syntax)\n-                .or(Some(path.syntax()));\n+                .or(Some(anchor));\n \n             return ImportAction::add_new_use(anchor, false);\n         }\n     }\n }\n \n-fn make_assist(action: &ImportAction, target: &[&ast::PathSegment], edit: &mut TextEditBuilder) {\n+fn make_assist(action: &ImportAction, target: &[SmolStr], edit: &mut TextEditBuilder) {\n     match action {\n         ImportAction::AddNewUse { anchor, add_after_anchor } => {\n             make_assist_add_new_use(anchor, *add_after_anchor, target, edit)\n@@ -408,7 +386,7 @@ fn make_assist(action: &ImportAction, target: &[&ast::PathSegment], edit: &mut T\n fn make_assist_add_new_use(\n     anchor: &Option<&SyntaxNode>,\n     after: bool,\n-    target: &[&ast::PathSegment],\n+    target: &[SmolStr],\n     edit: &mut TextEditBuilder,\n ) {\n     if let Some(anchor) = anchor {\n@@ -436,7 +414,7 @@ fn make_assist_add_new_use(\n \n fn make_assist_add_in_tree_list(\n     tree_list: &ast::UseTreeList,\n-    target: &[&ast::PathSegment],\n+    target: &[SmolStr],\n     add_self: bool,\n     edit: &mut TextEditBuilder,\n ) {\n@@ -465,7 +443,7 @@ fn make_assist_add_in_tree_list(\n fn make_assist_add_nested_import(\n     path: &ast::Path,\n     first_segment_to_split: &Option<&ast::PathSegment>,\n-    target: &[&ast::PathSegment],\n+    target: &[SmolStr],\n     add_self: bool,\n     edit: &mut TextEditBuilder,\n ) {\n@@ -496,28 +474,51 @@ fn make_assist_add_nested_import(\n     }\n }\n \n-fn apply_auto_import<'a>(\n+fn apply_auto_import(\n     container: &SyntaxNode,\n     path: &ast::Path,\n-    target: &[&'a ast::PathSegment],\n+    target: &[SmolStr],\n     edit: &mut TextEditBuilder,\n ) {\n-    let action = best_action_for_target(container, path, target);\n+    let action = best_action_for_target(container, path.syntax(), target);\n     make_assist(&action, target, edit);\n-    if let (Some(first), Some(last)) = (target.first(), target.last()) {\n+    if let Some(last) = path.segment() {\n         // Here we are assuming the assist will provide a  correct use statement\n         // so we can delete the path qualifier\n         edit.delete(TextRange::from_to(\n-            first.syntax().range().start(),\n+            path.syntax().range().start(),\n             last.syntax().range().start(),\n         ));\n     }\n }\n \n-pub fn auto_import_text_edit<'a>(\n+#[allow(unused)]\n+pub fn collect_hir_path_segments(path: &hir::Path) -> Vec<SmolStr> {\n+    let mut ps = Vec::<SmolStr>::with_capacity(10);\n+    match path.kind {\n+        hir::PathKind::Abs => ps.push(\"\".into()),\n+        hir::PathKind::Crate => ps.push(\"crate\".into()),\n+        hir::PathKind::Plain => {},\n+        hir::PathKind::Self_ => ps.push(\"self\".into()),\n+        hir::PathKind::Super => ps.push(\"super\".into())\n+    }\n+    for s in path.segments.iter() {\n+        ps.push(s.name.to_smolstr());\n+    }\n+    ps\n+}\n+\n+// This function produces sequence of text edits into edit\n+// to import the target path in the most appropriate scope given\n+// the cursor position\n+#[allow(unused)]\n+pub fn auto_import_text_edit(\n+    // Ideally the position of the cursor, used to \n     position: &SyntaxNode,\n-    path: &ast::Path,\n-    target: &[&'a ast::PathSegment],\n+    // The statement to use as anchor (last resort)\n+    anchor: &SyntaxNode,\n+    // The path to import as a sequence of strings\n+    target: &[SmolStr],\n     edit: &mut TextEditBuilder,\n ) {\n     let container = position.ancestors().find_map(|n| {\n@@ -528,7 +529,7 @@ pub fn auto_import_text_edit<'a>(\n     });\n \n     if let Some(container) = container {\n-        let action = best_action_for_target(container, path, target);\n+        let action = best_action_for_target(container, anchor, target);\n         make_assist(&action, target, edit);\n     }\n }\n@@ -540,7 +541,8 @@ pub(crate) fn auto_import(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist\n         return None;\n     }\n \n-    let segments = collect_path_segments(path)?;\n+    let hir_path = hir::Path::from_ast(path)?;\n+    let segments = collect_hir_path_segments(&hir_path);\n     if segments.len() < 2 {\n         return None;\n     }"}, {"sha": "331da602760abb1dfef73fb16b6eae12da46f1d3", "filename": "crates/ra_hir/src/name.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/766813898f7901736d82bfc103874474177e7aca/crates%2Fra_hir%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766813898f7901736d82bfc103874474177e7aca/crates%2Fra_hir%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fname.rs?ref=766813898f7901736d82bfc103874474177e7aca", "patch": "@@ -46,6 +46,10 @@ impl Name {\n         Name::new(idx.to_string().into())\n     }\n \n+    pub fn to_smolstr(&self) -> SmolStr {\n+        self.text.clone()\n+    }\n+\n     pub(crate) fn as_known_name(&self) -> Option<KnownName> {\n         let name = match self.text.as_str() {\n             \"isize\" => KnownName::Isize,"}]}