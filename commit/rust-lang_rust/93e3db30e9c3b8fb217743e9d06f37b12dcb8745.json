{"sha": "93e3db30e9c3b8fb217743e9d06f37b12dcb8745", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzZTNkYjMwZTljM2I4ZmIyMTc3NDNlOWQwNmYzN2IxMmRjYjg3NDU=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-09-30T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-09-30T00:00:00Z"}, "message": "liveness: Use Option::None to represent absent live nodes\n\nNo functional changes intended.", "tree": {"sha": "97e759afd283f5b362217d9ce5e86124a5da9a0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97e759afd283f5b362217d9ce5e86124a5da9a0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93e3db30e9c3b8fb217743e9d06f37b12dcb8745", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93e3db30e9c3b8fb217743e9d06f37b12dcb8745", "html_url": "https://github.com/rust-lang/rust/commit/93e3db30e9c3b8fb217743e9d06f37b12dcb8745", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93e3db30e9c3b8fb217743e9d06f37b12dcb8745/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "381b445ff5751f9f39ec672b623372dff09c276e", "url": "https://api.github.com/repos/rust-lang/rust/commits/381b445ff5751f9f39ec672b623372dff09c276e", "html_url": "https://github.com/rust-lang/rust/commit/381b445ff5751f9f39ec672b623372dff09c276e"}], "stats": {"total": 76, "additions": 36, "deletions": 40}, "files": [{"sha": "0eb834cbb98165a5aa8459416ae893b38b57e614", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 36, "deletions": 40, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/93e3db30e9c3b8fb217743e9d06f37b12dcb8745/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e3db30e9c3b8fb217743e9d06f37b12dcb8745/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=93e3db30e9c3b8fb217743e9d06f37b12dcb8745", "patch": "@@ -62,13 +62,13 @@\n //! - `reader`: the `LiveNode` ID of some node which will read the value\n //!    that `V` holds on entry to `N`. Formally: a node `M` such\n //!    that there exists a path `P` from `N` to `M` where `P` does not\n-//!    write `V`. If the `reader` is `INVALID_NODE`, then the current\n+//!    write `V`. If the `reader` is `None`, then the current\n //!    value will never be read (the variable is dead, essentially).\n //!\n //! - `writer`: the `LiveNode` ID of some node which will write the\n //!    variable `V` and which is reachable from `N`. Formally: a node `M`\n //!    such that there exists a path `P` from `N` to `M` and `M` writes\n-//!    `V`. If the `writer` is `INVALID_NODE`, then there is no writer\n+//!    `V`. If the `writer` is `None`, then there is no writer\n //!    of `V` that follows `N`.\n //!\n //! - `used`: a boolean value indicating whether `V` is *used*. We\n@@ -114,7 +114,6 @@ rustc_index::newtype_index! {\n rustc_index::newtype_index! {\n     pub struct LiveNode {\n         DEBUG_FORMAT = \"ln({})\",\n-        const INVALID_NODE = LiveNode::MAX_AS_U32,\n     }\n }\n \n@@ -168,12 +167,6 @@ pub fn provide(providers: &mut Providers) {\n // variable must not be assigned if there is some successor\n // assignment.  And so forth.\n \n-impl LiveNode {\n-    fn is_valid(self) -> bool {\n-        self != INVALID_NODE\n-    }\n-}\n-\n struct CaptureInfo {\n     ln: LiveNode,\n     var_hid: HirId,\n@@ -478,8 +471,8 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n \n #[derive(Clone, Copy)]\n struct RWU {\n-    reader: LiveNode,\n-    writer: LiveNode,\n+    reader: Option<LiveNode>,\n+    writer: Option<LiveNode>,\n     used: bool,\n }\n \n@@ -501,10 +494,10 @@ struct RWUTable {\n     unpacked_rwus: Vec<RWU>,\n }\n \n-// A constant representing `RWU { reader: INVALID_NODE; writer: INVALID_NODE; used: false }`.\n+// A constant representing `RWU { reader: None; writer: None; used: false }`.\n const INV_INV_FALSE: u32 = u32::MAX;\n \n-// A constant representing `RWU { reader: INVALID_NODE; writer: INVALID_NODE; used: true }`.\n+// A constant representing `RWU { reader: None; writer: None; used: true }`.\n const INV_INV_TRUE: u32 = u32::MAX - 1;\n \n impl RWUTable {\n@@ -515,24 +508,24 @@ impl RWUTable {\n     fn get(&self, idx: usize) -> RWU {\n         let packed_rwu = self.packed_rwus[idx];\n         match packed_rwu {\n-            INV_INV_FALSE => RWU { reader: INVALID_NODE, writer: INVALID_NODE, used: false },\n-            INV_INV_TRUE => RWU { reader: INVALID_NODE, writer: INVALID_NODE, used: true },\n+            INV_INV_FALSE => RWU { reader: None, writer: None, used: false },\n+            INV_INV_TRUE => RWU { reader: None, writer: None, used: true },\n             _ => self.unpacked_rwus[packed_rwu as usize],\n         }\n     }\n \n-    fn get_reader(&self, idx: usize) -> LiveNode {\n+    fn get_reader(&self, idx: usize) -> Option<LiveNode> {\n         let packed_rwu = self.packed_rwus[idx];\n         match packed_rwu {\n-            INV_INV_FALSE | INV_INV_TRUE => INVALID_NODE,\n+            INV_INV_FALSE | INV_INV_TRUE => None,\n             _ => self.unpacked_rwus[packed_rwu as usize].reader,\n         }\n     }\n \n-    fn get_writer(&self, idx: usize) -> LiveNode {\n+    fn get_writer(&self, idx: usize) -> Option<LiveNode> {\n         let packed_rwu = self.packed_rwus[idx];\n         match packed_rwu {\n-            INV_INV_FALSE | INV_INV_TRUE => INVALID_NODE,\n+            INV_INV_FALSE | INV_INV_TRUE => None,\n             _ => self.unpacked_rwus[packed_rwu as usize].writer,\n         }\n     }\n@@ -552,7 +545,7 @@ impl RWUTable {\n     }\n \n     fn assign_unpacked(&mut self, idx: usize, rwu: RWU) {\n-        if rwu.reader == INVALID_NODE && rwu.writer == INVALID_NODE {\n+        if rwu.reader == None && rwu.writer == None {\n             // When we overwrite an indexing entry in `self.packed_rwus` with\n             // `INV_INV_{TRUE,FALSE}` we don't remove the corresponding entry\n             // from `self.unpacked_rwus`; it's not worth the effort, and we\n@@ -581,7 +574,7 @@ struct Liveness<'a, 'tcx> {\n     typeck_results: &'a ty::TypeckResults<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n-    successors: IndexVec<LiveNode, LiveNode>,\n+    successors: IndexVec<LiveNode, Option<LiveNode>>,\n     rwu_table: RWUTable,\n \n     /// A live node representing a point of execution before closure entry &\n@@ -617,7 +610,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             typeck_results,\n             param_env,\n             upvars,\n-            successors: IndexVec::from_elem_n(INVALID_NODE, num_live_nodes),\n+            successors: IndexVec::from_elem_n(None, num_live_nodes),\n             rwu_table: RWUTable::new(num_live_nodes * num_vars),\n             closure_ln,\n             exit_ln,\n@@ -662,30 +655,33 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn live_on_entry(&self, ln: LiveNode, var: Variable) -> Option<LiveNodeKind> {\n-        assert!(ln.is_valid());\n-        let reader = self.rwu_table.get_reader(self.idx(ln, var));\n-        if reader.is_valid() { Some(self.ir.lnks[reader]) } else { None }\n+        if let Some(reader) = self.rwu_table.get_reader(self.idx(ln, var)) {\n+            Some(self.ir.lnks[reader])\n+        } else {\n+            None\n+        }\n     }\n \n     // Is this variable live on entry to any of its successor nodes?\n     fn live_on_exit(&self, ln: LiveNode, var: Variable) -> Option<LiveNodeKind> {\n-        let successor = self.successors[ln];\n+        let successor = self.successors[ln].unwrap();\n         self.live_on_entry(successor, var)\n     }\n \n     fn used_on_entry(&self, ln: LiveNode, var: Variable) -> bool {\n-        assert!(ln.is_valid());\n         self.rwu_table.get_used(self.idx(ln, var))\n     }\n \n     fn assigned_on_entry(&self, ln: LiveNode, var: Variable) -> Option<LiveNodeKind> {\n-        assert!(ln.is_valid());\n-        let writer = self.rwu_table.get_writer(self.idx(ln, var));\n-        if writer.is_valid() { Some(self.ir.lnks[writer]) } else { None }\n+        if let Some(writer) = self.rwu_table.get_writer(self.idx(ln, var)) {\n+            Some(self.ir.lnks[writer])\n+        } else {\n+            None\n+        }\n     }\n \n     fn assigned_on_exit(&self, ln: LiveNode, var: Variable) -> Option<LiveNodeKind> {\n-        let successor = self.successors[ln];\n+        let successor = self.successors[ln].unwrap();\n         self.assigned_on_entry(successor, var)\n     }\n \n@@ -720,9 +716,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         {\n             let wr = &mut wr as &mut dyn Write;\n             write!(wr, \"[{:?} of kind {:?} reads\", ln, self.ir.lnks[ln]);\n-            self.write_vars(wr, ln, |idx| self.rwu_table.get_reader(idx).is_valid());\n+            self.write_vars(wr, ln, |idx| self.rwu_table.get_reader(idx).is_some());\n             write!(wr, \"  writes\");\n-            self.write_vars(wr, ln, |idx| self.rwu_table.get_writer(idx).is_valid());\n+            self.write_vars(wr, ln, |idx| self.rwu_table.get_writer(idx).is_some());\n             write!(wr, \"  uses\");\n             self.write_vars(wr, ln, |idx| self.rwu_table.get_used(idx));\n \n@@ -746,7 +742,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn init_empty(&mut self, ln: LiveNode, succ_ln: LiveNode) {\n-        self.successors[ln] = succ_ln;\n+        self.successors[ln] = Some(succ_ln);\n \n         // It is not necessary to initialize the RWUs here because they are all\n         // set to INV_INV_FALSE when they are created, and the sets only grow\n@@ -755,7 +751,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn init_from_succ(&mut self, ln: LiveNode, succ_ln: LiveNode) {\n         // more efficient version of init_empty() / merge_from_succ()\n-        self.successors[ln] = succ_ln;\n+        self.successors[ln] = Some(succ_ln);\n \n         self.indices2(ln, succ_ln, |this, idx, succ_idx| {\n             this.rwu_table.copy_packed(idx, succ_idx);\n@@ -779,12 +775,12 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             let mut changed = false;\n             let mut rwu = this.rwu_table.get(idx);\n             let succ_rwu = this.rwu_table.get(succ_idx);\n-            if succ_rwu.reader.is_valid() && !rwu.reader.is_valid() {\n+            if succ_rwu.reader.is_some() && rwu.reader.is_none() {\n                 rwu.reader = succ_rwu.reader;\n                 changed = true\n             }\n \n-            if succ_rwu.writer.is_valid() && !rwu.writer.is_valid() {\n+            if succ_rwu.writer.is_some() && rwu.writer.is_none() {\n                 rwu.writer = succ_rwu.writer;\n                 changed = true\n             }\n@@ -828,14 +824,14 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         let mut rwu = self.rwu_table.get(idx);\n \n         if (acc & ACC_WRITE) != 0 {\n-            rwu.reader = INVALID_NODE;\n-            rwu.writer = ln;\n+            rwu.reader = None;\n+            rwu.writer = Some(ln);\n         }\n \n         // Important: if we both read/write, must do read second\n         // or else the write will override.\n         if (acc & ACC_READ) != 0 {\n-            rwu.reader = ln;\n+            rwu.reader = Some(ln);\n         }\n \n         if (acc & ACC_USE) != 0 {"}]}