{"sha": "2b3117cabfa85a5d799c14ae56aac02b774c5320", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiMzExN2NhYmZhODVhNWQ3OTljMTRhZTU2YWFjMDJiNzc0YzUzMjA=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-11-14T05:14:57Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-11-14T10:04:17Z"}, "message": "Fix diagnostics for calling indirect extern function pointer field\n\nFixes #29043", "tree": {"sha": "a6a892d6793ec37b17059da9b4fdc27b7d7618e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6a892d6793ec37b17059da9b4fdc27b7d7618e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b3117cabfa85a5d799c14ae56aac02b774c5320", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b3117cabfa85a5d799c14ae56aac02b774c5320", "html_url": "https://github.com/rust-lang/rust/commit/2b3117cabfa85a5d799c14ae56aac02b774c5320", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b3117cabfa85a5d799c14ae56aac02b774c5320/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afd4a5420c3a9f6642da655543aa26df15b2ef9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/afd4a5420c3a9f6642da655543aa26df15b2ef9c", "html_url": "https://github.com/rust-lang/rust/commit/afd4a5420c3a9f6642da655543aa26df15b2ef9c"}], "stats": {"total": 77, "additions": 54, "deletions": 23}, "files": [{"sha": "5c0b35e46b13e7b359b27ee0bfdf5cafb59f035b", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/2b3117cabfa85a5d799c14ae56aac02b774c5320/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3117cabfa85a5d799c14ae56aac02b774c5320/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=2b3117cabfa85a5d799c14ae56aac02b774c5320", "patch": "@@ -92,31 +92,39 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n                     // Determine if the field can be used as a function in some way\n                     let field_ty = field.ty(cx, substs);\n-                    if let Ok(fn_once_trait_did) = cx.lang_items.require(FnOnceTraitLangItem) {\n-                        let infcx = fcx.infcx();\n-                        infcx.probe(|_| {\n-                            let fn_once_substs = Substs::new_trait(vec![infcx.next_ty_var()],\n-                                                                   Vec::new(),\n-                                                                   field_ty);\n-                            let trait_ref = ty::TraitRef::new(fn_once_trait_did,\n-                                                              cx.mk_substs(fn_once_substs));\n-                            let poly_trait_ref = trait_ref.to_poly_trait_ref();\n-                            let obligation = Obligation::misc(span,\n-                                                              fcx.body_id,\n-                                                              poly_trait_ref.to_predicate());\n-                            let mut selcx = SelectionContext::new(infcx);\n-\n-                            if selcx.evaluate_obligation(&obligation) {\n-                                span_stored_function();\n+\n+                    match field_ty.sty {\n+                        // Not all of these (e.g. unsafe fns) implement FnOnce\n+                        // so we look for these beforehand\n+                        ty::TyClosure(..) | ty::TyBareFn(..) => span_stored_function(),\n+                        // If it's not a simple function, look for things which implement FnOnce\n+                        _ => {\n+                            if let Ok(fn_once_trait_did) =\n+                                    cx.lang_items.require(FnOnceTraitLangItem) {\n+                                let infcx = fcx.infcx();\n+                                infcx.probe(|_| {\n+                                    let fn_once_substs = Substs::new_trait(vec![\n+                                                                            infcx.next_ty_var()],\n+                                                                           Vec::new(),\n+                                                                           field_ty);\n+                                    let trait_ref = ty::TraitRef::new(fn_once_trait_did,\n+                                                                      cx.mk_substs(fn_once_substs));\n+                                    let poly_trait_ref = trait_ref.to_poly_trait_ref();\n+                                    let obligation = Obligation::misc(span,\n+                                                                      fcx.body_id,\n+                                                                      poly_trait_ref\n+                                                                         .to_predicate());\n+                                    let mut selcx = SelectionContext::new(infcx);\n+\n+                                    if selcx.evaluate_obligation(&obligation) {\n+                                        span_stored_function();\n+                                    } else {\n+                                        span_did_you_mean();\n+                                    }\n+                                });\n                             } else {\n-                                span_did_you_mean();\n+                                span_did_you_mean()\n                             }\n-                        });\n-                    } else {\n-                        match field_ty.sty {\n-                            // fallback to matching a closure or function pointer\n-                            ty::TyClosure(..) | ty::TyBareFn(..) => span_stored_function(),\n-                            _ => span_did_you_mean(),\n                         }\n                     }\n                 }"}, {"sha": "47d50eb9d5379b577d461380eaa7dc0b191d4adb", "filename": "src/test/compile-fail/issue-2392.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2b3117cabfa85a5d799c14ae56aac02b774c5320/src%2Ftest%2Fcompile-fail%2Fissue-2392.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3117cabfa85a5d799c14ae56aac02b774c5320/src%2Ftest%2Fcompile-fail%2Fissue-2392.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2392.rs?ref=2b3117cabfa85a5d799c14ae56aac02b774c5320", "patch": "@@ -11,6 +11,16 @@\n #![feature(core)]\n use std::boxed::FnBox;\n \n+struct FuncContainer {\n+    f1: fn(data: u8),\n+    f2: extern \"C\" fn(data: u8),\n+    f3: unsafe fn(data: u8),\n+}\n+\n+struct FuncContainerOuter {\n+    container: Box<FuncContainer>\n+}\n+\n struct Obj<F> where F: FnOnce() -> u32 {\n     closure: F,\n     not_closure: usize,\n@@ -66,3 +76,16 @@ fn main() {\n     check_expression().closure();//~ ERROR no method named `closure` found\n     //~^ NOTE use `(check_expression().closure)(...)` if you meant to call the function stored\n }\n+\n+impl FuncContainerOuter {\n+    fn run(&self) {\n+        unsafe {\n+            (*self.container).f1(1); //~ ERROR no method named `f1` found\n+            //~^ NOTE use `(*self.container.f1)(...)`\n+            (*self.container).f2(1); //~ ERROR no method named `f2` found\n+            //~^ NOTE use `(*self.container.f2)(...)`\n+            (*self.container).f3(1); //~ ERROR no method named `f3` found\n+            //~^ NOTE use `(*self.container.f3)(...)`\n+        }\n+    }\n+}"}]}