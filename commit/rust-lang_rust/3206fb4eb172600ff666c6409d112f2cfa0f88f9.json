{"sha": "3206fb4eb172600ff666c6409d112f2cfa0f88f9", "node_id": "C_kwDOAAsO6NoAKDMyMDZmYjRlYjE3MjYwMGZmNjY2YzY0MDlkMTEyZjJjZmEwZjg4Zjk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-12T00:38:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-12T00:38:54Z"}, "message": "Auto merge of #9138 - Jarcho:branches_sharing_code_2, r=giraffate\n\nFixes for `branches_sharing_code`\n\nfixes #7198\nfixes #7452\nfixes #7555\nfixes #7589\n\nchangelog: Don't suggest moving modifications to locals used in any of the condition expressions in `branches_sharing_code`\nchangelog: Don't suggest moving anything after a local with a significant drop in `branches_sharing_code`", "tree": {"sha": "6d30dca871fd2d38aeec1c537a660a78132592c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d30dca871fd2d38aeec1c537a660a78132592c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3206fb4eb172600ff666c6409d112f2cfa0f88f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3206fb4eb172600ff666c6409d112f2cfa0f88f9", "html_url": "https://github.com/rust-lang/rust/commit/3206fb4eb172600ff666c6409d112f2cfa0f88f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3206fb4eb172600ff666c6409d112f2cfa0f88f9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a801c7b83c494e00bba3d53ebc668ebe5dc44c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a801c7b83c494e00bba3d53ebc668ebe5dc44c6", "html_url": "https://github.com/rust-lang/rust/commit/8a801c7b83c494e00bba3d53ebc668ebe5dc44c6"}, {"sha": "55563f9ce1cea79a473954d70dea620822514c39", "url": "https://api.github.com/repos/rust-lang/rust/commits/55563f9ce1cea79a473954d70dea620822514c39", "html_url": "https://github.com/rust-lang/rust/commit/55563f9ce1cea79a473954d70dea620822514c39"}], "stats": {"total": 190, "additions": 182, "deletions": 8}, "files": [{"sha": "0e3d9317590f3c80782c517e5c64fc66019dc40d", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 58, "deletions": 6, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3206fb4eb172600ff666c6409d112f2cfa0f88f9/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3206fb4eb172600ff666c6409d112f2cfa0f88f9/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=3206fb4eb172600ff666c6409d112f2cfa0f88f9", "patch": "@@ -1,13 +1,16 @@\n use clippy_utils::diagnostics::{span_lint_and_note, span_lint_and_then};\n use clippy_utils::source::{first_line_of_span, indent_of, reindent_multiline, snippet, snippet_opt};\n+use clippy_utils::ty::needs_ordered_drop;\n+use clippy_utils::visitors::for_each_expr;\n use clippy_utils::{\n-    eq_expr_value, get_enclosing_block, hash_expr, hash_stmt, if_sequence, is_else_clause, is_lint_allowed,\n-    search_same, ContainsName, HirEqInterExpr, SpanlessEq,\n+    capture_local_usage, eq_expr_value, get_enclosing_block, hash_expr, hash_stmt, if_sequence, is_else_clause,\n+    is_lint_allowed, path_to_local, search_same, ContainsName, HirEqInterExpr, SpanlessEq,\n };\n use core::iter;\n+use core::ops::ControlFlow;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit;\n-use rustc_hir::{BinOpKind, Block, Expr, ExprKind, HirId, Stmt, StmtKind};\n+use rustc_hir::{BinOpKind, Block, Expr, ExprKind, HirId, HirIdSet, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::hygiene::walk_chain;\n@@ -214,7 +217,7 @@ fn lint_if_same_then_else(cx: &LateContext<'_>, conds: &[&Expr<'_>], blocks: &[&\n fn lint_branches_sharing_code<'tcx>(\n     cx: &LateContext<'tcx>,\n     conds: &[&'tcx Expr<'_>],\n-    blocks: &[&Block<'tcx>],\n+    blocks: &[&'tcx Block<'_>],\n     expr: &'tcx Expr<'_>,\n ) {\n     // We only lint ifs with multiple blocks\n@@ -340,6 +343,21 @@ fn eq_binding_names(s: &Stmt<'_>, names: &[(HirId, Symbol)]) -> bool {\n     }\n }\n \n+/// Checks if the statement modifies or moves any of the given locals.\n+fn modifies_any_local<'tcx>(cx: &LateContext<'tcx>, s: &'tcx Stmt<'_>, locals: &HirIdSet) -> bool {\n+    for_each_expr(s, |e| {\n+        if let Some(id) = path_to_local(e)\n+            && locals.contains(&id)\n+            && !capture_local_usage(cx, e).is_imm_ref()\n+        {\n+            ControlFlow::Break(())\n+        } else {\n+            ControlFlow::Continue(())\n+        }\n+    })\n+    .is_some()\n+}\n+\n /// Checks if the given statement should be considered equal to the statement in the same position\n /// for each block.\n fn eq_stmts(\n@@ -365,18 +383,52 @@ fn eq_stmts(\n         .all(|b| get_stmt(b).map_or(false, |s| eq.eq_stmt(s, stmt)))\n }\n \n-fn scan_block_for_eq(cx: &LateContext<'_>, _conds: &[&Expr<'_>], block: &Block<'_>, blocks: &[&Block<'_>]) -> BlockEq {\n+#[expect(clippy::too_many_lines)]\n+fn scan_block_for_eq<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    conds: &[&'tcx Expr<'_>],\n+    block: &'tcx Block<'_>,\n+    blocks: &[&'tcx Block<'_>],\n+) -> BlockEq {\n     let mut eq = SpanlessEq::new(cx);\n     let mut eq = eq.inter_expr();\n     let mut moved_locals = Vec::new();\n \n+    let mut cond_locals = HirIdSet::default();\n+    for &cond in conds {\n+        let _: Option<!> = for_each_expr(cond, |e| {\n+            if let Some(id) = path_to_local(e) {\n+                cond_locals.insert(id);\n+            }\n+            ControlFlow::Continue(())\n+        });\n+    }\n+\n+    let mut local_needs_ordered_drop = false;\n     let start_end_eq = block\n         .stmts\n         .iter()\n         .enumerate()\n-        .find(|&(i, stmt)| !eq_stmts(stmt, blocks, |b| b.stmts.get(i), &mut eq, &mut moved_locals))\n+        .find(|&(i, stmt)| {\n+            if let StmtKind::Local(l) = stmt.kind\n+                && needs_ordered_drop(cx, cx.typeck_results().node_type(l.hir_id))\n+            {\n+                local_needs_ordered_drop = true;\n+                return true;\n+            }\n+            modifies_any_local(cx, stmt, &cond_locals)\n+                || !eq_stmts(stmt, blocks, |b| b.stmts.get(i), &mut eq, &mut moved_locals)\n+        })\n         .map_or(block.stmts.len(), |(i, _)| i);\n \n+    if local_needs_ordered_drop {\n+        return BlockEq {\n+            start_end_eq,\n+            end_begin_eq: None,\n+            moved_locals,\n+        };\n+    }\n+\n     // Walk backwards through the final expression/statements so long as their hashes are equal. Note\n     // `SpanlessHash` treats all local references as equal allowing locals declared earlier in the block\n     // to match those in other blocks. e.g. If each block ends with the following the hash value will be"}, {"sha": "fd0c6869929720177690dce1fb2e91866942d0ca", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3206fb4eb172600ff666c6409d112f2cfa0f88f9/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3206fb4eb172600ff666c6409d112f2cfa0f88f9/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=3206fb4eb172600ff666c6409d112f2cfa0f88f9", "patch": "@@ -890,7 +890,7 @@ pub fn capture_local_usage<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>) -> Captur\n             Node::Expr(e) => match e.kind {\n                 ExprKind::AddrOf(_, mutability, _) => return CaptureKind::Ref(mutability),\n                 ExprKind::Index(..) | ExprKind::Unary(UnOp::Deref, _) => capture = CaptureKind::Ref(Mutability::Not),\n-                ExprKind::Assign(lhs, ..) | ExprKind::Assign(_, lhs, _) if lhs.hir_id == child_id => {\n+                ExprKind::Assign(lhs, ..) | ExprKind::AssignOp(_, lhs, _) if lhs.hir_id == child_id => {\n                     return CaptureKind::Ref(Mutability::Mut);\n                 },\n                 ExprKind::Field(..) => {"}, {"sha": "0b9f75238a602ba42c29dce81a7b9c77b045fae8", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/3206fb4eb172600ff666c6409d112f2cfa0f88f9/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3206fb4eb172600ff666c6409d112f2cfa0f88f9/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=3206fb4eb172600ff666c6409d112f2cfa0f88f9", "patch": "@@ -5,14 +5,82 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::intravisit::{self, walk_block, walk_expr, Visitor};\n use rustc_hir::{\n-    Arm, Block, BlockCheckMode, Body, BodyId, Expr, ExprKind, HirId, ItemId, ItemKind, Let, QPath, Stmt, UnOp,\n+    Arm, Block, BlockCheckMode, Body, BodyId, Expr, ExprKind, HirId, ItemId, ItemKind, Let, Pat, QPath, Stmt, UnOp,\n     UnsafeSource, Unsafety,\n };\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::adjustment::Adjust;\n use rustc_middle::ty::{self, Ty, TypeckResults};\n+use rustc_span::Span;\n+\n+mod internal {\n+    /// Trait for visitor functions to control whether or not to descend to child nodes. Implemented\n+    /// for only two types. `()` always descends. `Descend` allows controlled descent.\n+    pub trait Continue {\n+        fn descend(&self) -> bool;\n+    }\n+}\n+use internal::Continue;\n+\n+impl Continue for () {\n+    fn descend(&self) -> bool {\n+        true\n+    }\n+}\n+\n+/// Allows for controlled descent whe using visitor functions. Use `()` instead when always\n+/// descending into child nodes.\n+#[derive(Clone, Copy)]\n+pub enum Descend {\n+    Yes,\n+    No,\n+}\n+impl From<bool> for Descend {\n+    fn from(from: bool) -> Self {\n+        if from { Self::Yes } else { Self::No }\n+    }\n+}\n+impl Continue for Descend {\n+    fn descend(&self) -> bool {\n+        matches!(self, Self::Yes)\n+    }\n+}\n+\n+/// Calls the given function once for each expression contained. This does not enter any bodies or\n+/// nested items.\n+pub fn for_each_expr<'tcx, B, C: Continue>(\n+    node: impl Visitable<'tcx>,\n+    f: impl FnMut(&'tcx Expr<'tcx>) -> ControlFlow<B, C>,\n+) -> Option<B> {\n+    struct V<B, F> {\n+        f: F,\n+        res: Option<B>,\n+    }\n+    impl<'tcx, B, C: Continue, F: FnMut(&'tcx Expr<'tcx>) -> ControlFlow<B, C>> Visitor<'tcx> for V<B, F> {\n+        fn visit_expr(&mut self, e: &'tcx Expr<'tcx>) {\n+            if self.res.is_some() {\n+                return;\n+            }\n+            match (self.f)(e) {\n+                ControlFlow::Continue(c) if c.descend() => walk_expr(self, e),\n+                ControlFlow::Break(b) => self.res = Some(b),\n+                ControlFlow::Continue(_) => (),\n+            }\n+        }\n+\n+        // Avoid unnecessary `walk_*` calls.\n+        fn visit_ty(&mut self, _: &'tcx hir::Ty<'tcx>) {}\n+        fn visit_pat(&mut self, _: &'tcx Pat<'tcx>) {}\n+        fn visit_qpath(&mut self, _: &'tcx QPath<'tcx>, _: HirId, _: Span) {}\n+        // Avoid monomorphising all `visit_*` functions.\n+        fn visit_nested_item(&mut self, _: ItemId) {}\n+    }\n+    let mut v = V { f, res: None };\n+    node.visit(&mut v);\n+    v.res\n+}\n \n /// Convenience method for creating a `Visitor` with just `visit_expr` overridden and nested\n /// bodies (i.e. closures) are visited."}, {"sha": "5e3a1a29693f58ae5e392e222d6fb9b467216ee3", "filename": "tests/ui/branches_sharing_code/false_positives.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3206fb4eb172600ff666c6409d112f2cfa0f88f9/tests%2Fui%2Fbranches_sharing_code%2Ffalse_positives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3206fb4eb172600ff666c6409d112f2cfa0f88f9/tests%2Fui%2Fbranches_sharing_code%2Ffalse_positives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbranches_sharing_code%2Ffalse_positives.rs?ref=3206fb4eb172600ff666c6409d112f2cfa0f88f9", "patch": "@@ -1,6 +1,8 @@\n #![allow(dead_code)]\n #![deny(clippy::if_same_then_else, clippy::branches_sharing_code)]\n \n+use std::sync::Mutex;\n+\n // ##################################\n // # Issue clippy#7369\n // ##################################\n@@ -38,4 +40,56 @@ fn main() {\n         let (y, x) = x;\n         foo(x, y)\n     };\n+\n+    let m = Mutex::new(0u32);\n+    let l = m.lock().unwrap();\n+    let _ = if true {\n+        drop(l);\n+        println!(\"foo\");\n+        m.lock().unwrap();\n+        0\n+    } else if *l == 0 {\n+        drop(l);\n+        println!(\"foo\");\n+        println!(\"bar\");\n+        m.lock().unwrap();\n+        1\n+    } else {\n+        drop(l);\n+        println!(\"foo\");\n+        println!(\"baz\");\n+        m.lock().unwrap();\n+        2\n+    };\n+\n+    if true {\n+        let _guard = m.lock();\n+        println!(\"foo\");\n+    } else {\n+        println!(\"foo\");\n+    }\n+\n+    if true {\n+        let _guard = m.lock();\n+        println!(\"foo\");\n+        println!(\"bar\");\n+    } else {\n+        let _guard = m.lock();\n+        println!(\"foo\");\n+        println!(\"baz\");\n+    }\n+\n+    let mut c = 0;\n+    for _ in 0..5 {\n+        if c == 0 {\n+            c += 1;\n+            println!(\"0\");\n+        } else if c == 1 {\n+            c += 1;\n+            println!(\"1\");\n+        } else {\n+            c += 1;\n+            println!(\"more\");\n+        }\n+    }\n }"}]}