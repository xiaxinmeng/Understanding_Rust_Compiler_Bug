{"sha": "16e8af9e477fd5a6e7dcf668840144a97e3b1410", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2ZThhZjllNDc3ZmQ1YTZlN2RjZjY2ODg0MDE0NGE5N2UzYjE0MTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-16T03:00:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-16T03:00:56Z"}, "message": "auto merge of #5895 : huonw/rust/no-pub-tests, r=thestinger\n\nThis patch is a sledge hammer that moves all tests into `#[cfg(test)] mod test { .. }`, and makes them private, there were several instances of `pub mod tests { #[test] pub fn ... } `.\r\n\r\n(The reason for this is I was playing with using `syntax` to index code ([result so far](http://www.ug.it.usyd.edu.au/~hwil7821/rust-api/)) and it was getting some junk from the tests.)\r\n\r\nThe rustdoc commit is particularly brutal, so it's fine if that one isn't landed.", "tree": {"sha": "0aadb938c2b293f149e4501fb26b5da5e6a818c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0aadb938c2b293f149e4501fb26b5da5e6a818c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16e8af9e477fd5a6e7dcf668840144a97e3b1410", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16e8af9e477fd5a6e7dcf668840144a97e3b1410", "html_url": "https://github.com/rust-lang/rust/commit/16e8af9e477fd5a6e7dcf668840144a97e3b1410", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16e8af9e477fd5a6e7dcf668840144a97e3b1410/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "447caf9bdb8b769581fcd8c337634da431d21954", "url": "https://api.github.com/repos/rust-lang/rust/commits/447caf9bdb8b769581fcd8c337634da431d21954", "html_url": "https://github.com/rust-lang/rust/commit/447caf9bdb8b769581fcd8c337634da431d21954"}, {"sha": "40e3577b0834794b2d44e6c527fda90d1adbc88e", "url": "https://api.github.com/repos/rust-lang/rust/commits/40e3577b0834794b2d44e6c527fda90d1adbc88e", "html_url": "https://github.com/rust-lang/rust/commit/40e3577b0834794b2d44e6c527fda90d1adbc88e"}], "stats": {"total": 5639, "additions": 2836, "deletions": 2803}, "files": [{"sha": "532dcf6157b54f55d59f4241b5c4b81a57153b9f", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 38, "deletions": 34, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -277,45 +277,49 @@ pub mod raw {\n     pub unsafe fn reserve_at_least<T>(v: &mut @[T], n: uint) {\n         reserve(v, uint::next_power_of_two(n));\n     }\n-\n }\n \n-#[test]\n-pub fn test() {\n-    // Some code that could use that, then:\n-    fn seq_range(lo: uint, hi: uint) -> @[uint] {\n-        do build |push| {\n-            for uint::range(lo, hi) |i| {\n-                push(i);\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use prelude::*;\n+\n+    #[test]\n+    fn test() {\n+        // Some code that could use that, then:\n+        fn seq_range(lo: uint, hi: uint) -> @[uint] {\n+            do build |push| {\n+                for uint::range(lo, hi) |i| {\n+                    push(i);\n+                }\n             }\n         }\n-    }\n \n-    assert_eq!(seq_range(10, 15), @[10, 11, 12, 13, 14]);\n-    assert!(from_fn(5, |x| x+1) == @[1, 2, 3, 4, 5]);\n-    assert!(from_elem(5, 3.14) == @[3.14, 3.14, 3.14, 3.14, 3.14]);\n-}\n-\n-#[test]\n-pub fn append_test() {\n-    assert!(@[1,2,3] + @[4,5,6] == @[1,2,3,4,5,6]);\n-}\n+        assert_eq!(seq_range(10, 15), @[10, 11, 12, 13, 14]);\n+        assert!(from_fn(5, |x| x+1) == @[1, 2, 3, 4, 5]);\n+        assert!(from_elem(5, 3.14) == @[3.14, 3.14, 3.14, 3.14, 3.14]);\n+    }\n \n-#[test]\n-pub fn test_from_owned() {\n-    assert!(from_owned::<int>(~[]) == @[]);\n-    assert!(from_owned(~[true]) == @[true]);\n-    assert!(from_owned(~[1, 2, 3, 4, 5]) == @[1, 2, 3, 4, 5]);\n-    assert!(from_owned(~[~\"abc\", ~\"123\"]) == @[~\"abc\", ~\"123\"]);\n-    assert!(from_owned(~[~[42]]) == @[~[42]]);\n-}\n+    #[test]\n+    fn append_test() {\n+        assert!(@[1,2,3] + @[4,5,6] == @[1,2,3,4,5,6]);\n+    }\n \n-#[test]\n-pub fn test_from_slice() {\n-    assert!(from_slice::<int>([]) == @[]);\n-    assert!(from_slice([true]) == @[true]);\n-    assert!(from_slice([1, 2, 3, 4, 5]) == @[1, 2, 3, 4, 5]);\n-    assert!(from_slice([@\"abc\", @\"123\"]) == @[@\"abc\", @\"123\"]);\n-    assert!(from_slice([@[42]]) == @[@[42]]);\n-}\n+    #[test]\n+    fn test_from_owned() {\n+        assert!(from_owned::<int>(~[]) == @[]);\n+        assert!(from_owned(~[true]) == @[true]);\n+        assert!(from_owned(~[1, 2, 3, 4, 5]) == @[1, 2, 3, 4, 5]);\n+        assert!(from_owned(~[~\"abc\", ~\"123\"]) == @[~\"abc\", ~\"123\"]);\n+        assert!(from_owned(~[~[42]]) == @[~[42]]);\n+    }\n \n+    #[test]\n+    fn test_from_slice() {\n+        assert!(from_slice::<int>([]) == @[]);\n+        assert!(from_slice([true]) == @[true]);\n+        assert!(from_slice([1, 2, 3, 4, 5]) == @[1, 2, 3, 4, 5]);\n+        assert!(from_slice([@\"abc\", @\"123\"]) == @[@\"abc\", @\"123\"]);\n+        assert!(from_slice([@[42]]) == @[@[42]]);\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "1d214f402f5ac3594711450c86ed9e5c0e1b7947", "filename": "src/libcore/cast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcast.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -111,16 +111,16 @@ pub unsafe fn copy_lifetime_vec<'a,S,T>(_ptr: &'a [S], ptr: &T) -> &'a T {\n  ****************************************************************************/\n \n #[cfg(test)]\n-pub mod tests {\n+mod tests {\n     use cast::{bump_box_refcount, reinterpret_cast, transmute};\n \n     #[test]\n-    pub fn test_reinterpret_cast() {\n+    fn test_reinterpret_cast() {\n         assert!(1u == unsafe { reinterpret_cast(&1) });\n     }\n \n     #[test]\n-    pub fn test_bump_box_refcount() {\n+    fn test_bump_box_refcount() {\n         unsafe {\n             let box = @~\"box box box\";       // refcount 1\n             bump_box_refcount(box);         // refcount 2\n@@ -135,7 +135,7 @@ pub mod tests {\n     }\n \n     #[test]\n-    pub fn test_transmute() {\n+    fn test_transmute() {\n         use managed::raw::BoxRepr;\n         unsafe {\n             let x = @100u8;\n@@ -146,7 +146,7 @@ pub mod tests {\n     }\n \n     #[test]\n-    pub fn test_transmute2() {\n+    fn test_transmute2() {\n         unsafe {\n             assert!(~[76u8, 0u8] == transmute(~\"L\"));\n         }"}, {"sha": "f8b046e5b8c4f656b0735cbe3398e5730cf0831e", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -426,12 +426,12 @@ pub fn try_send_one<T: Owned>(chan: ChanOne<T>, data: T)\n }\n \n #[cfg(test)]\n-pub mod test {\n+mod test {\n     use either::Right;\n     use super::{Chan, Port, oneshot, recv_one, stream};\n \n     #[test]\n-    pub fn test_select2() {\n+    fn test_select2() {\n         let (p1, c1) = stream();\n         let (p2, c2) = stream();\n \n@@ -446,7 +446,7 @@ pub mod test {\n     }\n \n     #[test]\n-    pub fn test_oneshot() {\n+    fn test_oneshot() {\n         let (c, p) = oneshot::init();\n \n         oneshot::client::send(c, ());"}, {"sha": "ba1f8cebdb01cf5fbf4db13a3e4c27840bae1b89", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 158, "deletions": 152, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -357,170 +357,176 @@ impl Streaming for SipState {\n     }\n }\n \n-#[test]\n-pub fn test_siphash() {\n-    let vecs : [[u8, ..8], ..64] = [\n-        [ 0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72, ],\n-        [ 0xfd, 0x67, 0xdc, 0x93, 0xc5, 0x39, 0xf8, 0x74, ],\n-        [ 0x5a, 0x4f, 0xa9, 0xd9, 0x09, 0x80, 0x6c, 0x0d, ],\n-        [ 0x2d, 0x7e, 0xfb, 0xd7, 0x96, 0x66, 0x67, 0x85, ],\n-        [ 0xb7, 0x87, 0x71, 0x27, 0xe0, 0x94, 0x27, 0xcf, ],\n-        [ 0x8d, 0xa6, 0x99, 0xcd, 0x64, 0x55, 0x76, 0x18, ],\n-        [ 0xce, 0xe3, 0xfe, 0x58, 0x6e, 0x46, 0xc9, 0xcb, ],\n-        [ 0x37, 0xd1, 0x01, 0x8b, 0xf5, 0x00, 0x02, 0xab, ],\n-        [ 0x62, 0x24, 0x93, 0x9a, 0x79, 0xf5, 0xf5, 0x93, ],\n-        [ 0xb0, 0xe4, 0xa9, 0x0b, 0xdf, 0x82, 0x00, 0x9e, ],\n-        [ 0xf3, 0xb9, 0xdd, 0x94, 0xc5, 0xbb, 0x5d, 0x7a, ],\n-        [ 0xa7, 0xad, 0x6b, 0x22, 0x46, 0x2f, 0xb3, 0xf4, ],\n-        [ 0xfb, 0xe5, 0x0e, 0x86, 0xbc, 0x8f, 0x1e, 0x75, ],\n-        [ 0x90, 0x3d, 0x84, 0xc0, 0x27, 0x56, 0xea, 0x14, ],\n-        [ 0xee, 0xf2, 0x7a, 0x8e, 0x90, 0xca, 0x23, 0xf7, ],\n-        [ 0xe5, 0x45, 0xbe, 0x49, 0x61, 0xca, 0x29, 0xa1, ],\n-        [ 0xdb, 0x9b, 0xc2, 0x57, 0x7f, 0xcc, 0x2a, 0x3f, ],\n-        [ 0x94, 0x47, 0xbe, 0x2c, 0xf5, 0xe9, 0x9a, 0x69, ],\n-        [ 0x9c, 0xd3, 0x8d, 0x96, 0xf0, 0xb3, 0xc1, 0x4b, ],\n-        [ 0xbd, 0x61, 0x79, 0xa7, 0x1d, 0xc9, 0x6d, 0xbb, ],\n-        [ 0x98, 0xee, 0xa2, 0x1a, 0xf2, 0x5c, 0xd6, 0xbe, ],\n-        [ 0xc7, 0x67, 0x3b, 0x2e, 0xb0, 0xcb, 0xf2, 0xd0, ],\n-        [ 0x88, 0x3e, 0xa3, 0xe3, 0x95, 0x67, 0x53, 0x93, ],\n-        [ 0xc8, 0xce, 0x5c, 0xcd, 0x8c, 0x03, 0x0c, 0xa8, ],\n-        [ 0x94, 0xaf, 0x49, 0xf6, 0xc6, 0x50, 0xad, 0xb8, ],\n-        [ 0xea, 0xb8, 0x85, 0x8a, 0xde, 0x92, 0xe1, 0xbc, ],\n-        [ 0xf3, 0x15, 0xbb, 0x5b, 0xb8, 0x35, 0xd8, 0x17, ],\n-        [ 0xad, 0xcf, 0x6b, 0x07, 0x63, 0x61, 0x2e, 0x2f, ],\n-        [ 0xa5, 0xc9, 0x1d, 0xa7, 0xac, 0xaa, 0x4d, 0xde, ],\n-        [ 0x71, 0x65, 0x95, 0x87, 0x66, 0x50, 0xa2, 0xa6, ],\n-        [ 0x28, 0xef, 0x49, 0x5c, 0x53, 0xa3, 0x87, 0xad, ],\n-        [ 0x42, 0xc3, 0x41, 0xd8, 0xfa, 0x92, 0xd8, 0x32, ],\n-        [ 0xce, 0x7c, 0xf2, 0x72, 0x2f, 0x51, 0x27, 0x71, ],\n-        [ 0xe3, 0x78, 0x59, 0xf9, 0x46, 0x23, 0xf3, 0xa7, ],\n-        [ 0x38, 0x12, 0x05, 0xbb, 0x1a, 0xb0, 0xe0, 0x12, ],\n-        [ 0xae, 0x97, 0xa1, 0x0f, 0xd4, 0x34, 0xe0, 0x15, ],\n-        [ 0xb4, 0xa3, 0x15, 0x08, 0xbe, 0xff, 0x4d, 0x31, ],\n-        [ 0x81, 0x39, 0x62, 0x29, 0xf0, 0x90, 0x79, 0x02, ],\n-        [ 0x4d, 0x0c, 0xf4, 0x9e, 0xe5, 0xd4, 0xdc, 0xca, ],\n-        [ 0x5c, 0x73, 0x33, 0x6a, 0x76, 0xd8, 0xbf, 0x9a, ],\n-        [ 0xd0, 0xa7, 0x04, 0x53, 0x6b, 0xa9, 0x3e, 0x0e, ],\n-        [ 0x92, 0x59, 0x58, 0xfc, 0xd6, 0x42, 0x0c, 0xad, ],\n-        [ 0xa9, 0x15, 0xc2, 0x9b, 0xc8, 0x06, 0x73, 0x18, ],\n-        [ 0x95, 0x2b, 0x79, 0xf3, 0xbc, 0x0a, 0xa6, 0xd4, ],\n-        [ 0xf2, 0x1d, 0xf2, 0xe4, 0x1d, 0x45, 0x35, 0xf9, ],\n-        [ 0x87, 0x57, 0x75, 0x19, 0x04, 0x8f, 0x53, 0xa9, ],\n-        [ 0x10, 0xa5, 0x6c, 0xf5, 0xdf, 0xcd, 0x9a, 0xdb, ],\n-        [ 0xeb, 0x75, 0x09, 0x5c, 0xcd, 0x98, 0x6c, 0xd0, ],\n-        [ 0x51, 0xa9, 0xcb, 0x9e, 0xcb, 0xa3, 0x12, 0xe6, ],\n-        [ 0x96, 0xaf, 0xad, 0xfc, 0x2c, 0xe6, 0x66, 0xc7, ],\n-        [ 0x72, 0xfe, 0x52, 0x97, 0x5a, 0x43, 0x64, 0xee, ],\n-        [ 0x5a, 0x16, 0x45, 0xb2, 0x76, 0xd5, 0x92, 0xa1, ],\n-        [ 0xb2, 0x74, 0xcb, 0x8e, 0xbf, 0x87, 0x87, 0x0a, ],\n-        [ 0x6f, 0x9b, 0xb4, 0x20, 0x3d, 0xe7, 0xb3, 0x81, ],\n-        [ 0xea, 0xec, 0xb2, 0xa3, 0x0b, 0x22, 0xa8, 0x7f, ],\n-        [ 0x99, 0x24, 0xa4, 0x3c, 0xc1, 0x31, 0x57, 0x24, ],\n-        [ 0xbd, 0x83, 0x8d, 0x3a, 0xaf, 0xbf, 0x8d, 0xb7, ],\n-        [ 0x0b, 0x1a, 0x2a, 0x32, 0x65, 0xd5, 0x1a, 0xea, ],\n-        [ 0x13, 0x50, 0x79, 0xa3, 0x23, 0x1c, 0xe6, 0x60, ],\n-        [ 0x93, 0x2b, 0x28, 0x46, 0xe4, 0xd7, 0x06, 0x66, ],\n-        [ 0xe1, 0x91, 0x5f, 0x5c, 0xb1, 0xec, 0xa4, 0x6c, ],\n-        [ 0xf3, 0x25, 0x96, 0x5c, 0xa1, 0x6d, 0x62, 0x9f, ],\n-        [ 0x57, 0x5f, 0xf2, 0x8e, 0x60, 0x38, 0x1b, 0xe5, ],\n-        [ 0x72, 0x45, 0x06, 0xeb, 0x4c, 0x32, 0x8a, 0x95, ]\n-    ];\n-\n-    let k0 = 0x_07_06_05_04_03_02_01_00_u64;\n-    let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08_u64;\n-    let mut buf : ~[u8] = ~[];\n-    let mut t = 0;\n-    let stream_inc = &State(k0,k1);\n-    let stream_full = &State(k0,k1);\n-\n-    fn to_hex_str(r:  &[u8, ..8]) -> ~str {\n-        let mut s = ~\"\";\n-        for vec::each(*r) |b| {\n-            s += uint::to_str_radix(*b as uint, 16u);\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use prelude::*;\n+\n+    #[test]\n+    fn test_siphash() {\n+        let vecs : [[u8, ..8], ..64] = [\n+            [ 0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72, ],\n+            [ 0xfd, 0x67, 0xdc, 0x93, 0xc5, 0x39, 0xf8, 0x74, ],\n+            [ 0x5a, 0x4f, 0xa9, 0xd9, 0x09, 0x80, 0x6c, 0x0d, ],\n+            [ 0x2d, 0x7e, 0xfb, 0xd7, 0x96, 0x66, 0x67, 0x85, ],\n+            [ 0xb7, 0x87, 0x71, 0x27, 0xe0, 0x94, 0x27, 0xcf, ],\n+            [ 0x8d, 0xa6, 0x99, 0xcd, 0x64, 0x55, 0x76, 0x18, ],\n+            [ 0xce, 0xe3, 0xfe, 0x58, 0x6e, 0x46, 0xc9, 0xcb, ],\n+            [ 0x37, 0xd1, 0x01, 0x8b, 0xf5, 0x00, 0x02, 0xab, ],\n+            [ 0x62, 0x24, 0x93, 0x9a, 0x79, 0xf5, 0xf5, 0x93, ],\n+            [ 0xb0, 0xe4, 0xa9, 0x0b, 0xdf, 0x82, 0x00, 0x9e, ],\n+            [ 0xf3, 0xb9, 0xdd, 0x94, 0xc5, 0xbb, 0x5d, 0x7a, ],\n+            [ 0xa7, 0xad, 0x6b, 0x22, 0x46, 0x2f, 0xb3, 0xf4, ],\n+            [ 0xfb, 0xe5, 0x0e, 0x86, 0xbc, 0x8f, 0x1e, 0x75, ],\n+            [ 0x90, 0x3d, 0x84, 0xc0, 0x27, 0x56, 0xea, 0x14, ],\n+            [ 0xee, 0xf2, 0x7a, 0x8e, 0x90, 0xca, 0x23, 0xf7, ],\n+            [ 0xe5, 0x45, 0xbe, 0x49, 0x61, 0xca, 0x29, 0xa1, ],\n+            [ 0xdb, 0x9b, 0xc2, 0x57, 0x7f, 0xcc, 0x2a, 0x3f, ],\n+            [ 0x94, 0x47, 0xbe, 0x2c, 0xf5, 0xe9, 0x9a, 0x69, ],\n+            [ 0x9c, 0xd3, 0x8d, 0x96, 0xf0, 0xb3, 0xc1, 0x4b, ],\n+            [ 0xbd, 0x61, 0x79, 0xa7, 0x1d, 0xc9, 0x6d, 0xbb, ],\n+            [ 0x98, 0xee, 0xa2, 0x1a, 0xf2, 0x5c, 0xd6, 0xbe, ],\n+            [ 0xc7, 0x67, 0x3b, 0x2e, 0xb0, 0xcb, 0xf2, 0xd0, ],\n+            [ 0x88, 0x3e, 0xa3, 0xe3, 0x95, 0x67, 0x53, 0x93, ],\n+            [ 0xc8, 0xce, 0x5c, 0xcd, 0x8c, 0x03, 0x0c, 0xa8, ],\n+            [ 0x94, 0xaf, 0x49, 0xf6, 0xc6, 0x50, 0xad, 0xb8, ],\n+            [ 0xea, 0xb8, 0x85, 0x8a, 0xde, 0x92, 0xe1, 0xbc, ],\n+            [ 0xf3, 0x15, 0xbb, 0x5b, 0xb8, 0x35, 0xd8, 0x17, ],\n+            [ 0xad, 0xcf, 0x6b, 0x07, 0x63, 0x61, 0x2e, 0x2f, ],\n+            [ 0xa5, 0xc9, 0x1d, 0xa7, 0xac, 0xaa, 0x4d, 0xde, ],\n+            [ 0x71, 0x65, 0x95, 0x87, 0x66, 0x50, 0xa2, 0xa6, ],\n+            [ 0x28, 0xef, 0x49, 0x5c, 0x53, 0xa3, 0x87, 0xad, ],\n+            [ 0x42, 0xc3, 0x41, 0xd8, 0xfa, 0x92, 0xd8, 0x32, ],\n+            [ 0xce, 0x7c, 0xf2, 0x72, 0x2f, 0x51, 0x27, 0x71, ],\n+            [ 0xe3, 0x78, 0x59, 0xf9, 0x46, 0x23, 0xf3, 0xa7, ],\n+            [ 0x38, 0x12, 0x05, 0xbb, 0x1a, 0xb0, 0xe0, 0x12, ],\n+            [ 0xae, 0x97, 0xa1, 0x0f, 0xd4, 0x34, 0xe0, 0x15, ],\n+            [ 0xb4, 0xa3, 0x15, 0x08, 0xbe, 0xff, 0x4d, 0x31, ],\n+            [ 0x81, 0x39, 0x62, 0x29, 0xf0, 0x90, 0x79, 0x02, ],\n+            [ 0x4d, 0x0c, 0xf4, 0x9e, 0xe5, 0xd4, 0xdc, 0xca, ],\n+            [ 0x5c, 0x73, 0x33, 0x6a, 0x76, 0xd8, 0xbf, 0x9a, ],\n+            [ 0xd0, 0xa7, 0x04, 0x53, 0x6b, 0xa9, 0x3e, 0x0e, ],\n+            [ 0x92, 0x59, 0x58, 0xfc, 0xd6, 0x42, 0x0c, 0xad, ],\n+            [ 0xa9, 0x15, 0xc2, 0x9b, 0xc8, 0x06, 0x73, 0x18, ],\n+            [ 0x95, 0x2b, 0x79, 0xf3, 0xbc, 0x0a, 0xa6, 0xd4, ],\n+            [ 0xf2, 0x1d, 0xf2, 0xe4, 0x1d, 0x45, 0x35, 0xf9, ],\n+            [ 0x87, 0x57, 0x75, 0x19, 0x04, 0x8f, 0x53, 0xa9, ],\n+            [ 0x10, 0xa5, 0x6c, 0xf5, 0xdf, 0xcd, 0x9a, 0xdb, ],\n+            [ 0xeb, 0x75, 0x09, 0x5c, 0xcd, 0x98, 0x6c, 0xd0, ],\n+            [ 0x51, 0xa9, 0xcb, 0x9e, 0xcb, 0xa3, 0x12, 0xe6, ],\n+            [ 0x96, 0xaf, 0xad, 0xfc, 0x2c, 0xe6, 0x66, 0xc7, ],\n+            [ 0x72, 0xfe, 0x52, 0x97, 0x5a, 0x43, 0x64, 0xee, ],\n+            [ 0x5a, 0x16, 0x45, 0xb2, 0x76, 0xd5, 0x92, 0xa1, ],\n+            [ 0xb2, 0x74, 0xcb, 0x8e, 0xbf, 0x87, 0x87, 0x0a, ],\n+            [ 0x6f, 0x9b, 0xb4, 0x20, 0x3d, 0xe7, 0xb3, 0x81, ],\n+            [ 0xea, 0xec, 0xb2, 0xa3, 0x0b, 0x22, 0xa8, 0x7f, ],\n+            [ 0x99, 0x24, 0xa4, 0x3c, 0xc1, 0x31, 0x57, 0x24, ],\n+            [ 0xbd, 0x83, 0x8d, 0x3a, 0xaf, 0xbf, 0x8d, 0xb7, ],\n+            [ 0x0b, 0x1a, 0x2a, 0x32, 0x65, 0xd5, 0x1a, 0xea, ],\n+            [ 0x13, 0x50, 0x79, 0xa3, 0x23, 0x1c, 0xe6, 0x60, ],\n+            [ 0x93, 0x2b, 0x28, 0x46, 0xe4, 0xd7, 0x06, 0x66, ],\n+            [ 0xe1, 0x91, 0x5f, 0x5c, 0xb1, 0xec, 0xa4, 0x6c, ],\n+            [ 0xf3, 0x25, 0x96, 0x5c, 0xa1, 0x6d, 0x62, 0x9f, ],\n+            [ 0x57, 0x5f, 0xf2, 0x8e, 0x60, 0x38, 0x1b, 0xe5, ],\n+            [ 0x72, 0x45, 0x06, 0xeb, 0x4c, 0x32, 0x8a, 0x95, ]\n+        ];\n+\n+        let k0 = 0x_07_06_05_04_03_02_01_00_u64;\n+        let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08_u64;\n+        let mut buf : ~[u8] = ~[];\n+        let mut t = 0;\n+        let stream_inc = &State(k0,k1);\n+        let stream_full = &State(k0,k1);\n+\n+        fn to_hex_str(r:  &[u8, ..8]) -> ~str {\n+            let mut s = ~\"\";\n+            for vec::each(*r) |b| {\n+                s += uint::to_str_radix(*b as uint, 16u);\n+            }\n+            s\n         }\n-        s\n-    }\n \n-    while t < 64 {\n-        debug!(\"siphash test %?\", t);\n-        let vec = u8to64_le!(vecs[t], 0);\n-        let out = buf.hash_keyed(k0, k1);\n-        debug!(\"got %?, expected %?\", out, vec);\n-        assert!(vec == out);\n+        while t < 64 {\n+            debug!(\"siphash test %?\", t);\n+            let vec = u8to64_le!(vecs[t], 0);\n+            let out = buf.hash_keyed(k0, k1);\n+            debug!(\"got %?, expected %?\", out, vec);\n+            assert!(vec == out);\n \n-        stream_full.reset();\n-        stream_full.input(buf);\n-        let f = stream_full.result_str();\n-        let i = stream_inc.result_str();\n-        let v = to_hex_str(&vecs[t]);\n-        debug!(\"%d: (%s) => inc=%s full=%s\", t, v, i, f);\n+            stream_full.reset();\n+            stream_full.input(buf);\n+            let f = stream_full.result_str();\n+            let i = stream_inc.result_str();\n+            let v = to_hex_str(&vecs[t]);\n+            debug!(\"%d: (%s) => inc=%s full=%s\", t, v, i, f);\n \n-        assert!(f == i && f == v);\n+            assert!(f == i && f == v);\n \n-        buf += ~[t as u8];\n-        stream_inc.input(~[t as u8]);\n+            buf += ~[t as u8];\n+            stream_inc.input(~[t as u8]);\n \n-        t += 1;\n+            t += 1;\n+        }\n     }\n-}\n \n-#[test] #[cfg(target_arch = \"arm\")]\n-pub fn test_hash_uint() {\n-    let val = 0xdeadbeef_deadbeef_u64;\n-    assert!((val as u64).hash() != (val as uint).hash());\n-    assert!((val as u32).hash() == (val as uint).hash());\n-}\n-#[test] #[cfg(target_arch = \"x86_64\")]\n-pub fn test_hash_uint() {\n-    let val = 0xdeadbeef_deadbeef_u64;\n-    assert!((val as u64).hash() == (val as uint).hash());\n-    assert!((val as u32).hash() != (val as uint).hash());\n-}\n-#[test] #[cfg(target_arch = \"x86\")]\n-pub fn test_hash_uint() {\n-    let val = 0xdeadbeef_deadbeef_u64;\n-    assert!((val as u64).hash() != (val as uint).hash());\n-    assert!((val as u32).hash() == (val as uint).hash());\n-}\n+    #[test] #[cfg(target_arch = \"arm\")]\n+    fn test_hash_uint() {\n+        let val = 0xdeadbeef_deadbeef_u64;\n+        assert!((val as u64).hash() != (val as uint).hash());\n+        assert!((val as u32).hash() == (val as uint).hash());\n+    }\n+    #[test] #[cfg(target_arch = \"x86_64\")]\n+    fn test_hash_uint() {\n+        let val = 0xdeadbeef_deadbeef_u64;\n+        assert!((val as u64).hash() == (val as uint).hash());\n+        assert!((val as u32).hash() != (val as uint).hash());\n+    }\n+    #[test] #[cfg(target_arch = \"x86\")]\n+    fn test_hash_uint() {\n+        let val = 0xdeadbeef_deadbeef_u64;\n+        assert!((val as u64).hash() != (val as uint).hash());\n+        assert!((val as u32).hash() == (val as uint).hash());\n+    }\n \n-#[test]\n-pub fn test_hash_idempotent() {\n-    let val64 = 0xdeadbeef_deadbeef_u64;\n-    val64.hash() == val64.hash();\n-    let val32 = 0xdeadbeef_u32;\n-    val32.hash() == val32.hash();\n-}\n+    #[test]\n+    fn test_hash_idempotent() {\n+        let val64 = 0xdeadbeef_deadbeef_u64;\n+        val64.hash() == val64.hash();\n+        let val32 = 0xdeadbeef_u32;\n+        val32.hash() == val32.hash();\n+    }\n \n-#[test]\n-pub fn test_hash_no_bytes_dropped_64() {\n-    let val = 0xdeadbeef_deadbeef_u64;\n-\n-    assert!(val.hash() != zero_byte(val, 0).hash());\n-    assert!(val.hash() != zero_byte(val, 1).hash());\n-    assert!(val.hash() != zero_byte(val, 2).hash());\n-    assert!(val.hash() != zero_byte(val, 3).hash());\n-    assert!(val.hash() != zero_byte(val, 4).hash());\n-    assert!(val.hash() != zero_byte(val, 5).hash());\n-    assert!(val.hash() != zero_byte(val, 6).hash());\n-    assert!(val.hash() != zero_byte(val, 7).hash());\n-\n-    fn zero_byte(val: u64, byte: uint) -> u64 {\n-        assert!(byte < 8);\n-        val & !(0xff << (byte * 8))\n+    #[test]\n+    fn test_hash_no_bytes_dropped_64() {\n+        let val = 0xdeadbeef_deadbeef_u64;\n+\n+        assert!(val.hash() != zero_byte(val, 0).hash());\n+        assert!(val.hash() != zero_byte(val, 1).hash());\n+        assert!(val.hash() != zero_byte(val, 2).hash());\n+        assert!(val.hash() != zero_byte(val, 3).hash());\n+        assert!(val.hash() != zero_byte(val, 4).hash());\n+        assert!(val.hash() != zero_byte(val, 5).hash());\n+        assert!(val.hash() != zero_byte(val, 6).hash());\n+        assert!(val.hash() != zero_byte(val, 7).hash());\n+\n+        fn zero_byte(val: u64, byte: uint) -> u64 {\n+            assert!(byte < 8);\n+            val & !(0xff << (byte * 8))\n+        }\n     }\n-}\n \n-#[test]\n-pub fn test_hash_no_bytes_dropped_32() {\n-    let val = 0xdeadbeef_u32;\n+    #[test]\n+    fn test_hash_no_bytes_dropped_32() {\n+        let val = 0xdeadbeef_u32;\n \n-    assert!(val.hash() != zero_byte(val, 0).hash());\n-    assert!(val.hash() != zero_byte(val, 1).hash());\n-    assert!(val.hash() != zero_byte(val, 2).hash());\n-    assert!(val.hash() != zero_byte(val, 3).hash());\n+        assert!(val.hash() != zero_byte(val, 0).hash());\n+        assert!(val.hash() != zero_byte(val, 1).hash());\n+        assert!(val.hash() != zero_byte(val, 2).hash());\n+        assert!(val.hash() != zero_byte(val, 3).hash());\n \n-    fn zero_byte(val: u32, byte: uint) -> u32 {\n-        assert!(byte < 4);\n-        val & !(0xff << (byte * 8))\n+        fn zero_byte(val: u32, byte: uint) -> u32 {\n+            assert!(byte < 4);\n+            val & !(0xff << (byte * 8))\n+        }\n     }\n-}\n+}\n\\ No newline at end of file"}, {"sha": "3efe21fc42cdbbf782737ac6434ddee6a5e3500b", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -847,7 +847,7 @@ mod test_map {\n     use uint;\n \n     #[test]\n-    pub fn test_insert() {\n+    fn test_insert() {\n         let mut m = HashMap::new();\n         assert!(m.insert(1, 2));\n         assert!(m.insert(2, 4));\n@@ -869,7 +869,7 @@ mod test_map {\n     }\n \n     #[test]\n-    pub fn test_insert_overwrite() {\n+    fn test_insert_overwrite() {\n         let mut m = HashMap::new();\n         assert!(m.insert(1, 2));\n         assert!(*m.get(&1) == 2);\n@@ -878,7 +878,7 @@ mod test_map {\n     }\n \n     #[test]\n-    pub fn test_insert_conflicts() {\n+    fn test_insert_conflicts() {\n         let mut m = linear_map_with_capacity(4);\n         assert!(m.insert(1, 2));\n         assert!(m.insert(5, 3));\n@@ -889,7 +889,7 @@ mod test_map {\n     }\n \n     #[test]\n-    pub fn test_conflict_remove() {\n+    fn test_conflict_remove() {\n         let mut m = linear_map_with_capacity(4);\n         assert!(m.insert(1, 2));\n         assert!(m.insert(5, 3));\n@@ -900,7 +900,7 @@ mod test_map {\n     }\n \n     #[test]\n-    pub fn test_is_empty() {\n+    fn test_is_empty() {\n         let mut m = linear_map_with_capacity(4);\n         assert!(m.insert(1, 2));\n         assert!(!m.is_empty());\n@@ -909,37 +909,37 @@ mod test_map {\n     }\n \n     #[test]\n-    pub fn test_pop() {\n+    fn test_pop() {\n         let mut m = HashMap::new();\n         m.insert(1, 2);\n         assert!(m.pop(&1) == Some(2));\n         assert!(m.pop(&1) == None);\n     }\n \n     #[test]\n-    pub fn test_swap() {\n+    fn test_swap() {\n         let mut m = HashMap::new();\n         assert!(m.swap(1, 2) == None);\n         assert!(m.swap(1, 3) == Some(2));\n         assert!(m.swap(1, 4) == Some(3));\n     }\n \n     #[test]\n-    pub fn test_find_or_insert() {\n+    fn test_find_or_insert() {\n         let mut m = HashMap::new::<int, int>();\n         assert!(m.find_or_insert(1, 2) == &2);\n         assert!(m.find_or_insert(1, 3) == &2);\n     }\n \n     #[test]\n-    pub fn test_find_or_insert_with() {\n+    fn test_find_or_insert_with() {\n         let mut m = HashMap::new::<int, int>();\n         assert!(m.find_or_insert_with(1, |_| 2) == &2);\n         assert!(m.find_or_insert_with(1, |_| 3) == &2);\n     }\n \n     #[test]\n-    pub fn test_consume() {\n+    fn test_consume() {\n         let mut m = HashMap::new();\n         assert!(m.insert(1, 2));\n         assert!(m.insert(2, 3));\n@@ -954,7 +954,7 @@ mod test_map {\n     }\n \n     #[test]\n-    pub fn test_iterate() {\n+    fn test_iterate() {\n         let mut m = linear_map_with_capacity(4);\n         for uint::range(0, 32) |i| {\n             assert!(m.insert(i, i*2));\n@@ -968,7 +968,7 @@ mod test_map {\n     }\n \n     #[test]\n-    pub fn test_find() {\n+    fn test_find() {\n         let mut m = HashMap::new();\n         assert!(m.find(&1).is_none());\n         m.insert(1, 2);\n@@ -979,7 +979,7 @@ mod test_map {\n     }\n \n     #[test]\n-    pub fn test_eq() {\n+    fn test_eq() {\n         let mut m1 = HashMap::new();\n         m1.insert(1, 2);\n         m1.insert(2, 3);\n@@ -997,7 +997,7 @@ mod test_map {\n     }\n \n     #[test]\n-    pub fn test_expand() {\n+    fn test_expand() {\n         let mut m = HashMap::new();\n \n         assert!(m.len() == 0);"}, {"sha": "488756787b5cd13440b4dbda04ab6f66e7cec80e", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 199, "deletions": 196, "changes": 395, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -29,7 +29,6 @@ use from_str;\n \n #[cfg(notest)] use cmp::{Eq, Ord};\n #[cfg(notest)] use ops;\n-#[cfg(test)] use option::{Some, None};\n \n pub use f64::{add, sub, mul, div, rem, lt, le, eq, ne, ge, gt};\n pub use f64::logarithm;\n@@ -142,7 +141,7 @@ pub fn to_str_radix(num: float, radix: uint) -> ~str {\n     let (r, special) = strconv::to_str_common(\n         &num, radix, true, strconv::SignNeg, strconv::DigAll);\n     if special { fail!(~\"number has a special value, \\\n-                      try to_str_radix_special() if those are expected\") }\n+                         try to_str_radix_special() if those are expected\") }\n     r\n }\n \n@@ -177,12 +176,6 @@ pub fn to_str_exact(num: float, digits: uint) -> ~str {\n     r\n }\n \n-#[test]\n-pub fn test_to_str_exact_do_decimal() {\n-    let s = to_str_exact(5.0, 4u);\n-    assert!(s == ~\"5.0000\");\n-}\n-\n /**\n  * Converts a float to a string with a maximum number of\n  * significant digits\n@@ -474,195 +467,205 @@ impl ops::Neg<float> for float {\n     fn neg(&self) -> float { -*self }\n }\n \n-#[test]\n-pub fn test_from_str() {\n-   assert!(from_str(~\"3\") == Some(3.));\n-   assert!(from_str(~\"3.14\") == Some(3.14));\n-   assert!(from_str(~\"+3.14\") == Some(3.14));\n-   assert!(from_str(~\"-3.14\") == Some(-3.14));\n-   assert!(from_str(~\"2.5E10\") == Some(25000000000.));\n-   assert!(from_str(~\"2.5e10\") == Some(25000000000.));\n-   assert!(from_str(~\"25000000000.E-10\") == Some(2.5));\n-   assert!(from_str(~\".\") == Some(0.));\n-   assert!(from_str(~\".e1\") == Some(0.));\n-   assert!(from_str(~\".e-1\") == Some(0.));\n-   assert!(from_str(~\"5.\") == Some(5.));\n-   assert!(from_str(~\".5\") == Some(0.5));\n-   assert!(from_str(~\"0.5\") == Some(0.5));\n-   assert!(from_str(~\"-.5\") == Some(-0.5));\n-   assert!(from_str(~\"-5\") == Some(-5.));\n-   assert!(from_str(~\"inf\") == Some(infinity));\n-   assert!(from_str(~\"+inf\") == Some(infinity));\n-   assert!(from_str(~\"-inf\") == Some(neg_infinity));\n-   // note: NaN != NaN, hence this slightly complex test\n-   match from_str(~\"NaN\") {\n-       Some(f) => assert!(is_NaN(f)),\n-       None => fail!()\n-   }\n-   // note: -0 == 0, hence these slightly more complex tests\n-   match from_str(~\"-0\") {\n-       Some(v) if is_zero(v) => assert!(is_negative(v)),\n-       _ => fail!()\n-   }\n-   match from_str(~\"0\") {\n-       Some(v) if is_zero(v) => assert!(is_positive(v)),\n-       _ => fail!()\n-   }\n-\n-   assert!(from_str(~\"\").is_none());\n-   assert!(from_str(~\"x\").is_none());\n-   assert!(from_str(~\" \").is_none());\n-   assert!(from_str(~\"   \").is_none());\n-   assert!(from_str(~\"e\").is_none());\n-   assert!(from_str(~\"E\").is_none());\n-   assert!(from_str(~\"E1\").is_none());\n-   assert!(from_str(~\"1e1e1\").is_none());\n-   assert!(from_str(~\"1e1.1\").is_none());\n-   assert!(from_str(~\"1e1-1\").is_none());\n-}\n-\n-#[test]\n-pub fn test_from_str_hex() {\n-   assert!(from_str_hex(~\"a4\") == Some(164.));\n-   assert!(from_str_hex(~\"a4.fe\") == Some(164.9921875));\n-   assert!(from_str_hex(~\"-a4.fe\") == Some(-164.9921875));\n-   assert!(from_str_hex(~\"+a4.fe\") == Some(164.9921875));\n-   assert!(from_str_hex(~\"ff0P4\") == Some(0xff00 as float));\n-   assert!(from_str_hex(~\"ff0p4\") == Some(0xff00 as float));\n-   assert!(from_str_hex(~\"ff0p-4\") == Some(0xff as float));\n-   assert!(from_str_hex(~\".\") == Some(0.));\n-   assert!(from_str_hex(~\".p1\") == Some(0.));\n-   assert!(from_str_hex(~\".p-1\") == Some(0.));\n-   assert!(from_str_hex(~\"f.\") == Some(15.));\n-   assert!(from_str_hex(~\".f\") == Some(0.9375));\n-   assert!(from_str_hex(~\"0.f\") == Some(0.9375));\n-   assert!(from_str_hex(~\"-.f\") == Some(-0.9375));\n-   assert!(from_str_hex(~\"-f\") == Some(-15.));\n-   assert!(from_str_hex(~\"inf\") == Some(infinity));\n-   assert!(from_str_hex(~\"+inf\") == Some(infinity));\n-   assert!(from_str_hex(~\"-inf\") == Some(neg_infinity));\n-   // note: NaN != NaN, hence this slightly complex test\n-   match from_str_hex(~\"NaN\") {\n-       Some(f) => assert!(is_NaN(f)),\n-       None => fail!()\n-   }\n-   // note: -0 == 0, hence these slightly more complex tests\n-   match from_str_hex(~\"-0\") {\n-       Some(v) if is_zero(v) => assert!(is_negative(v)),\n-       _ => fail!()\n-   }\n-   match from_str_hex(~\"0\") {\n-       Some(v) if is_zero(v) => assert!(is_positive(v)),\n-       _ => fail!()\n-   }\n-   assert!(from_str_hex(~\"e\") == Some(14.));\n-   assert!(from_str_hex(~\"E\") == Some(14.));\n-   assert!(from_str_hex(~\"E1\") == Some(225.));\n-   assert!(from_str_hex(~\"1e1e1\") == Some(123361.));\n-   assert!(from_str_hex(~\"1e1.1\") == Some(481.0625));\n-\n-   assert!(from_str_hex(~\"\").is_none());\n-   assert!(from_str_hex(~\"x\").is_none());\n-   assert!(from_str_hex(~\" \").is_none());\n-   assert!(from_str_hex(~\"   \").is_none());\n-   assert!(from_str_hex(~\"p\").is_none());\n-   assert!(from_str_hex(~\"P\").is_none());\n-   assert!(from_str_hex(~\"P1\").is_none());\n-   assert!(from_str_hex(~\"1p1p1\").is_none());\n-   assert!(from_str_hex(~\"1p1.1\").is_none());\n-   assert!(from_str_hex(~\"1p1-1\").is_none());\n-}\n-\n-#[test]\n-pub fn test_to_str_hex() {\n-   assert!(to_str_hex(164.) == ~\"a4\");\n-   assert!(to_str_hex(164.9921875) == ~\"a4.fe\");\n-   assert!(to_str_hex(-164.9921875) == ~\"-a4.fe\");\n-   assert!(to_str_hex(0xff00 as float) == ~\"ff00\");\n-   assert!(to_str_hex(-(0xff00 as float)) == ~\"-ff00\");\n-   assert!(to_str_hex(0.) == ~\"0\");\n-   assert!(to_str_hex(15.) == ~\"f\");\n-   assert!(to_str_hex(-15.) == ~\"-f\");\n-   assert!(to_str_hex(0.9375) == ~\"0.f\");\n-   assert!(to_str_hex(-0.9375) == ~\"-0.f\");\n-   assert!(to_str_hex(infinity) == ~\"inf\");\n-   assert!(to_str_hex(neg_infinity) == ~\"-inf\");\n-   assert!(to_str_hex(NaN) == ~\"NaN\");\n-   assert!(to_str_hex(0.) == ~\"0\");\n-   assert!(to_str_hex(-0.) == ~\"-0\");\n-}\n-\n-#[test]\n-pub fn test_to_str_radix() {\n-   assert!(to_str_radix(36., 36u) == ~\"10\");\n-   assert!(to_str_radix(8.125, 2u) == ~\"1000.001\");\n-}\n-\n-#[test]\n-pub fn test_from_str_radix() {\n-   assert!(from_str_radix(~\"10\", 36u) == Some(36.));\n-   assert!(from_str_radix(~\"1000.001\", 2u) == Some(8.125));\n-}\n-\n-#[test]\n-pub fn test_positive() {\n-  assert!((is_positive(infinity)));\n-  assert!((is_positive(1.)));\n-  assert!((is_positive(0.)));\n-  assert!((!is_positive(-1.)));\n-  assert!((!is_positive(neg_infinity)));\n-  assert!((!is_positive(1./neg_infinity)));\n-  assert!((!is_positive(NaN)));\n-}\n-\n-#[test]\n-pub fn test_negative() {\n-  assert!((!is_negative(infinity)));\n-  assert!((!is_negative(1.)));\n-  assert!((!is_negative(0.)));\n-  assert!((is_negative(-1.)));\n-  assert!((is_negative(neg_infinity)));\n-  assert!((is_negative(1./neg_infinity)));\n-  assert!((!is_negative(NaN)));\n-}\n-\n-#[test]\n-pub fn test_nonpositive() {\n-  assert!((!is_nonpositive(infinity)));\n-  assert!((!is_nonpositive(1.)));\n-  assert!((!is_nonpositive(0.)));\n-  assert!((is_nonpositive(-1.)));\n-  assert!((is_nonpositive(neg_infinity)));\n-  assert!((is_nonpositive(1./neg_infinity)));\n-  assert!((!is_nonpositive(NaN)));\n-}\n-\n-#[test]\n-pub fn test_nonnegative() {\n-  assert!((is_nonnegative(infinity)));\n-  assert!((is_nonnegative(1.)));\n-  assert!((is_nonnegative(0.)));\n-  assert!((!is_nonnegative(-1.)));\n-  assert!((!is_nonnegative(neg_infinity)));\n-  assert!((!is_nonnegative(1./neg_infinity)));\n-  assert!((!is_nonnegative(NaN)));\n-}\n-\n-#[test]\n-pub fn test_to_str_inf() {\n-    assert!(to_str_digits(infinity, 10u) == ~\"inf\");\n-    assert!(to_str_digits(-infinity, 10u) == ~\"-inf\");\n-}\n-\n-#[test]\n-pub fn test_round() {\n-    assert!(round(5.8) == 6.0);\n-    assert!(round(5.2) == 5.0);\n-    assert!(round(3.0) == 3.0);\n-    assert!(round(2.5) == 3.0);\n-    assert!(round(-3.5) == -4.0);\n-}\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use prelude::*;\n+    #[test]\n+    pub fn test_to_str_exact_do_decimal() {\n+        let s = to_str_exact(5.0, 4u);\n+        assert!(s == ~\"5.0000\");\n+    }\n+\n+    #[test]\n+    pub fn test_from_str() {\n+        assert!(from_str(~\"3\") == Some(3.));\n+        assert!(from_str(~\"3.14\") == Some(3.14));\n+        assert!(from_str(~\"+3.14\") == Some(3.14));\n+        assert!(from_str(~\"-3.14\") == Some(-3.14));\n+        assert!(from_str(~\"2.5E10\") == Some(25000000000.));\n+        assert!(from_str(~\"2.5e10\") == Some(25000000000.));\n+        assert!(from_str(~\"25000000000.E-10\") == Some(2.5));\n+        assert!(from_str(~\".\") == Some(0.));\n+        assert!(from_str(~\".e1\") == Some(0.));\n+        assert!(from_str(~\".e-1\") == Some(0.));\n+        assert!(from_str(~\"5.\") == Some(5.));\n+        assert!(from_str(~\".5\") == Some(0.5));\n+        assert!(from_str(~\"0.5\") == Some(0.5));\n+        assert!(from_str(~\"-.5\") == Some(-0.5));\n+        assert!(from_str(~\"-5\") == Some(-5.));\n+        assert!(from_str(~\"inf\") == Some(infinity));\n+        assert!(from_str(~\"+inf\") == Some(infinity));\n+        assert!(from_str(~\"-inf\") == Some(neg_infinity));\n+        // note: NaN != NaN, hence this slightly complex test\n+        match from_str(~\"NaN\") {\n+            Some(f) => assert!(is_NaN(f)),\n+            None => fail!()\n+        }\n+        // note: -0 == 0, hence these slightly more complex tests\n+        match from_str(~\"-0\") {\n+            Some(v) if is_zero(v) => assert!(is_negative(v)),\n+            _ => fail!()\n+        }\n+        match from_str(~\"0\") {\n+            Some(v) if is_zero(v) => assert!(is_positive(v)),\n+            _ => fail!()\n+        }\n+\n+        assert!(from_str(~\"\").is_none());\n+        assert!(from_str(~\"x\").is_none());\n+        assert!(from_str(~\" \").is_none());\n+        assert!(from_str(~\"   \").is_none());\n+        assert!(from_str(~\"e\").is_none());\n+        assert!(from_str(~\"E\").is_none());\n+        assert!(from_str(~\"E1\").is_none());\n+        assert!(from_str(~\"1e1e1\").is_none());\n+        assert!(from_str(~\"1e1.1\").is_none());\n+        assert!(from_str(~\"1e1-1\").is_none());\n+    }\n+\n+    #[test]\n+    pub fn test_from_str_hex() {\n+        assert!(from_str_hex(~\"a4\") == Some(164.));\n+        assert!(from_str_hex(~\"a4.fe\") == Some(164.9921875));\n+        assert!(from_str_hex(~\"-a4.fe\") == Some(-164.9921875));\n+        assert!(from_str_hex(~\"+a4.fe\") == Some(164.9921875));\n+        assert!(from_str_hex(~\"ff0P4\") == Some(0xff00 as float));\n+        assert!(from_str_hex(~\"ff0p4\") == Some(0xff00 as float));\n+        assert!(from_str_hex(~\"ff0p-4\") == Some(0xff as float));\n+        assert!(from_str_hex(~\".\") == Some(0.));\n+        assert!(from_str_hex(~\".p1\") == Some(0.));\n+        assert!(from_str_hex(~\".p-1\") == Some(0.));\n+        assert!(from_str_hex(~\"f.\") == Some(15.));\n+        assert!(from_str_hex(~\".f\") == Some(0.9375));\n+        assert!(from_str_hex(~\"0.f\") == Some(0.9375));\n+        assert!(from_str_hex(~\"-.f\") == Some(-0.9375));\n+        assert!(from_str_hex(~\"-f\") == Some(-15.));\n+        assert!(from_str_hex(~\"inf\") == Some(infinity));\n+        assert!(from_str_hex(~\"+inf\") == Some(infinity));\n+        assert!(from_str_hex(~\"-inf\") == Some(neg_infinity));\n+        // note: NaN != NaN, hence this slightly complex test\n+        match from_str_hex(~\"NaN\") {\n+            Some(f) => assert!(is_NaN(f)),\n+            None => fail!()\n+        }\n+        // note: -0 == 0, hence these slightly more complex tests\n+        match from_str_hex(~\"-0\") {\n+            Some(v) if is_zero(v) => assert!(is_negative(v)),\n+            _ => fail!()\n+        }\n+        match from_str_hex(~\"0\") {\n+            Some(v) if is_zero(v) => assert!(is_positive(v)),\n+            _ => fail!()\n+        }\n+        assert!(from_str_hex(~\"e\") == Some(14.));\n+        assert!(from_str_hex(~\"E\") == Some(14.));\n+        assert!(from_str_hex(~\"E1\") == Some(225.));\n+        assert!(from_str_hex(~\"1e1e1\") == Some(123361.));\n+        assert!(from_str_hex(~\"1e1.1\") == Some(481.0625));\n+\n+        assert!(from_str_hex(~\"\").is_none());\n+        assert!(from_str_hex(~\"x\").is_none());\n+        assert!(from_str_hex(~\" \").is_none());\n+        assert!(from_str_hex(~\"   \").is_none());\n+        assert!(from_str_hex(~\"p\").is_none());\n+        assert!(from_str_hex(~\"P\").is_none());\n+        assert!(from_str_hex(~\"P1\").is_none());\n+        assert!(from_str_hex(~\"1p1p1\").is_none());\n+        assert!(from_str_hex(~\"1p1.1\").is_none());\n+        assert!(from_str_hex(~\"1p1-1\").is_none());\n+    }\n+\n+    #[test]\n+    pub fn test_to_str_hex() {\n+        assert!(to_str_hex(164.) == ~\"a4\");\n+        assert!(to_str_hex(164.9921875) == ~\"a4.fe\");\n+        assert!(to_str_hex(-164.9921875) == ~\"-a4.fe\");\n+        assert!(to_str_hex(0xff00 as float) == ~\"ff00\");\n+        assert!(to_str_hex(-(0xff00 as float)) == ~\"-ff00\");\n+        assert!(to_str_hex(0.) == ~\"0\");\n+        assert!(to_str_hex(15.) == ~\"f\");\n+        assert!(to_str_hex(-15.) == ~\"-f\");\n+        assert!(to_str_hex(0.9375) == ~\"0.f\");\n+        assert!(to_str_hex(-0.9375) == ~\"-0.f\");\n+        assert!(to_str_hex(infinity) == ~\"inf\");\n+        assert!(to_str_hex(neg_infinity) == ~\"-inf\");\n+        assert!(to_str_hex(NaN) == ~\"NaN\");\n+        assert!(to_str_hex(0.) == ~\"0\");\n+        assert!(to_str_hex(-0.) == ~\"-0\");\n+    }\n \n+    #[test]\n+    pub fn test_to_str_radix() {\n+        assert!(to_str_radix(36., 36u) == ~\"10\");\n+        assert!(to_str_radix(8.125, 2u) == ~\"1000.001\");\n+    }\n+\n+    #[test]\n+    pub fn test_from_str_radix() {\n+        assert!(from_str_radix(~\"10\", 36u) == Some(36.));\n+        assert!(from_str_radix(~\"1000.001\", 2u) == Some(8.125));\n+    }\n+\n+    #[test]\n+    pub fn test_positive() {\n+        assert!((is_positive(infinity)));\n+        assert!((is_positive(1.)));\n+        assert!((is_positive(0.)));\n+        assert!((!is_positive(-1.)));\n+        assert!((!is_positive(neg_infinity)));\n+        assert!((!is_positive(1./neg_infinity)));\n+        assert!((!is_positive(NaN)));\n+    }\n+\n+    #[test]\n+    pub fn test_negative() {\n+        assert!((!is_negative(infinity)));\n+        assert!((!is_negative(1.)));\n+        assert!((!is_negative(0.)));\n+        assert!((is_negative(-1.)));\n+        assert!((is_negative(neg_infinity)));\n+        assert!((is_negative(1./neg_infinity)));\n+        assert!((!is_negative(NaN)));\n+    }\n+\n+    #[test]\n+    pub fn test_nonpositive() {\n+        assert!((!is_nonpositive(infinity)));\n+        assert!((!is_nonpositive(1.)));\n+        assert!((!is_nonpositive(0.)));\n+        assert!((is_nonpositive(-1.)));\n+        assert!((is_nonpositive(neg_infinity)));\n+        assert!((is_nonpositive(1./neg_infinity)));\n+        assert!((!is_nonpositive(NaN)));\n+    }\n+\n+    #[test]\n+    pub fn test_nonnegative() {\n+        assert!((is_nonnegative(infinity)));\n+        assert!((is_nonnegative(1.)));\n+        assert!((is_nonnegative(0.)));\n+        assert!((!is_nonnegative(-1.)));\n+        assert!((!is_nonnegative(neg_infinity)));\n+        assert!((!is_nonnegative(1./neg_infinity)));\n+        assert!((!is_nonnegative(NaN)));\n+    }\n+\n+    #[test]\n+    pub fn test_to_str_inf() {\n+        assert!(to_str_digits(infinity, 10u) == ~\"inf\");\n+        assert!(to_str_digits(-infinity, 10u) == ~\"-inf\");\n+    }\n+\n+    #[test]\n+    pub fn test_round() {\n+        assert!(round(5.8) == 6.0);\n+        assert!(round(5.2) == 5.0);\n+        assert!(round(3.0) == 3.0);\n+        assert!(round(2.5) == 3.0);\n+        assert!(round(-3.5) == -4.0);\n+    }\n+}\n \n //\n // Local Variables:"}, {"sha": "b495f9e7088fe34f88c4954693e2b49701400e63", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 162, "deletions": 155, "changes": 317, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -277,181 +277,188 @@ impl ToStrRadix for T {\n     }\n }\n \n-#[test]\n-fn test_from_str() {\n-    assert!(from_str(~\"0\") == Some(0 as T));\n-    assert!(from_str(~\"3\") == Some(3 as T));\n-    assert!(from_str(~\"10\") == Some(10 as T));\n-    assert!(i32::from_str(~\"123456789\") == Some(123456789 as i32));\n-    assert!(from_str(~\"00100\") == Some(100 as T));\n-\n-    assert!(from_str(~\"-1\") == Some(-1 as T));\n-    assert!(from_str(~\"-3\") == Some(-3 as T));\n-    assert!(from_str(~\"-10\") == Some(-10 as T));\n-    assert!(i32::from_str(~\"-123456789\") == Some(-123456789 as i32));\n-    assert!(from_str(~\"-00100\") == Some(-100 as T));\n-\n-    assert!(from_str(~\" \").is_none());\n-    assert!(from_str(~\"x\").is_none());\n-}\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use super::inst::T;\n+    use prelude::*;\n+\n+    #[test]\n+    fn test_from_str() {\n+        assert!(from_str(~\"0\") == Some(0 as T));\n+        assert!(from_str(~\"3\") == Some(3 as T));\n+        assert!(from_str(~\"10\") == Some(10 as T));\n+        assert!(i32::from_str(~\"123456789\") == Some(123456789 as i32));\n+        assert!(from_str(~\"00100\") == Some(100 as T));\n+\n+        assert!(from_str(~\"-1\") == Some(-1 as T));\n+        assert!(from_str(~\"-3\") == Some(-3 as T));\n+        assert!(from_str(~\"-10\") == Some(-10 as T));\n+        assert!(i32::from_str(~\"-123456789\") == Some(-123456789 as i32));\n+        assert!(from_str(~\"-00100\") == Some(-100 as T));\n+\n+        assert!(from_str(~\" \").is_none());\n+        assert!(from_str(~\"x\").is_none());\n+    }\n \n-#[test]\n-fn test_parse_bytes() {\n-    use str::to_bytes;\n-    assert!(parse_bytes(to_bytes(~\"123\"), 10u) == Some(123 as T));\n-    assert!(parse_bytes(to_bytes(~\"1001\"), 2u) == Some(9 as T));\n-    assert!(parse_bytes(to_bytes(~\"123\"), 8u) == Some(83 as T));\n-    assert!(i32::parse_bytes(to_bytes(~\"123\"), 16u) == Some(291 as i32));\n-    assert!(i32::parse_bytes(to_bytes(~\"ffff\"), 16u) ==\n-                 Some(65535 as i32));\n-    assert!(i32::parse_bytes(to_bytes(~\"FFFF\"), 16u) ==\n-                 Some(65535 as i32));\n-    assert!(parse_bytes(to_bytes(~\"z\"), 36u) == Some(35 as T));\n-    assert!(parse_bytes(to_bytes(~\"Z\"), 36u) == Some(35 as T));\n-\n-    assert!(parse_bytes(to_bytes(~\"-123\"), 10u) == Some(-123 as T));\n-    assert!(parse_bytes(to_bytes(~\"-1001\"), 2u) == Some(-9 as T));\n-    assert!(parse_bytes(to_bytes(~\"-123\"), 8u) == Some(-83 as T));\n-    assert!(i32::parse_bytes(to_bytes(~\"-123\"), 16u) ==\n-                 Some(-291 as i32));\n-    assert!(i32::parse_bytes(to_bytes(~\"-ffff\"), 16u) ==\n-                 Some(-65535 as i32));\n-    assert!(i32::parse_bytes(to_bytes(~\"-FFFF\"), 16u) ==\n-                 Some(-65535 as i32));\n-    assert!(parse_bytes(to_bytes(~\"-z\"), 36u) == Some(-35 as T));\n-    assert!(parse_bytes(to_bytes(~\"-Z\"), 36u) == Some(-35 as T));\n-\n-    assert!(parse_bytes(to_bytes(~\"Z\"), 35u).is_none());\n-    assert!(parse_bytes(to_bytes(~\"-9\"), 2u).is_none());\n-}\n+    #[test]\n+    fn test_parse_bytes() {\n+        use str::to_bytes;\n+        assert!(parse_bytes(to_bytes(~\"123\"), 10u) == Some(123 as T));\n+        assert!(parse_bytes(to_bytes(~\"1001\"), 2u) == Some(9 as T));\n+        assert!(parse_bytes(to_bytes(~\"123\"), 8u) == Some(83 as T));\n+        assert!(i32::parse_bytes(to_bytes(~\"123\"), 16u) == Some(291 as i32));\n+        assert!(i32::parse_bytes(to_bytes(~\"ffff\"), 16u) ==\n+                Some(65535 as i32));\n+        assert!(i32::parse_bytes(to_bytes(~\"FFFF\"), 16u) ==\n+                Some(65535 as i32));\n+        assert!(parse_bytes(to_bytes(~\"z\"), 36u) == Some(35 as T));\n+        assert!(parse_bytes(to_bytes(~\"Z\"), 36u) == Some(35 as T));\n+\n+        assert!(parse_bytes(to_bytes(~\"-123\"), 10u) == Some(-123 as T));\n+        assert!(parse_bytes(to_bytes(~\"-1001\"), 2u) == Some(-9 as T));\n+        assert!(parse_bytes(to_bytes(~\"-123\"), 8u) == Some(-83 as T));\n+        assert!(i32::parse_bytes(to_bytes(~\"-123\"), 16u) ==\n+                Some(-291 as i32));\n+        assert!(i32::parse_bytes(to_bytes(~\"-ffff\"), 16u) ==\n+                Some(-65535 as i32));\n+        assert!(i32::parse_bytes(to_bytes(~\"-FFFF\"), 16u) ==\n+                Some(-65535 as i32));\n+        assert!(parse_bytes(to_bytes(~\"-z\"), 36u) == Some(-35 as T));\n+        assert!(parse_bytes(to_bytes(~\"-Z\"), 36u) == Some(-35 as T));\n+\n+        assert!(parse_bytes(to_bytes(~\"Z\"), 35u).is_none());\n+        assert!(parse_bytes(to_bytes(~\"-9\"), 2u).is_none());\n+    }\n \n-#[test]\n-fn test_to_str() {\n-    assert!((to_str_radix(0 as T, 10u) == ~\"0\"));\n-    assert!((to_str_radix(1 as T, 10u) == ~\"1\"));\n-    assert!((to_str_radix(-1 as T, 10u) == ~\"-1\"));\n-    assert!((to_str_radix(127 as T, 16u) == ~\"7f\"));\n-    assert!((to_str_radix(100 as T, 10u) == ~\"100\"));\n+    #[test]\n+    fn test_to_str() {\n+        assert!((to_str_radix(0 as T, 10u) == ~\"0\"));\n+        assert!((to_str_radix(1 as T, 10u) == ~\"1\"));\n+        assert!((to_str_radix(-1 as T, 10u) == ~\"-1\"));\n+        assert!((to_str_radix(127 as T, 16u) == ~\"7f\"));\n+        assert!((to_str_radix(100 as T, 10u) == ~\"100\"));\n \n-}\n+    }\n \n-#[test]\n-fn test_int_to_str_overflow() {\n-    let mut i8_val: i8 = 127_i8;\n-    assert!((i8::to_str(i8_val) == ~\"127\"));\n+    #[test]\n+    fn test_int_to_str_overflow() {\n+        let mut i8_val: i8 = 127_i8;\n+        assert!((i8::to_str(i8_val) == ~\"127\"));\n \n-    i8_val += 1 as i8;\n-    assert!((i8::to_str(i8_val) == ~\"-128\"));\n+        i8_val += 1 as i8;\n+        assert!((i8::to_str(i8_val) == ~\"-128\"));\n \n-    let mut i16_val: i16 = 32_767_i16;\n-    assert!((i16::to_str(i16_val) == ~\"32767\"));\n+        let mut i16_val: i16 = 32_767_i16;\n+        assert!((i16::to_str(i16_val) == ~\"32767\"));\n \n-    i16_val += 1 as i16;\n-    assert!((i16::to_str(i16_val) == ~\"-32768\"));\n+        i16_val += 1 as i16;\n+        assert!((i16::to_str(i16_val) == ~\"-32768\"));\n \n-    let mut i32_val: i32 = 2_147_483_647_i32;\n-    assert!((i32::to_str(i32_val) == ~\"2147483647\"));\n+        let mut i32_val: i32 = 2_147_483_647_i32;\n+        assert!((i32::to_str(i32_val) == ~\"2147483647\"));\n \n-    i32_val += 1 as i32;\n-    assert!((i32::to_str(i32_val) == ~\"-2147483648\"));\n+        i32_val += 1 as i32;\n+        assert!((i32::to_str(i32_val) == ~\"-2147483648\"));\n \n-    let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-    assert!((i64::to_str(i64_val) == ~\"9223372036854775807\"));\n+        let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n+        assert!((i64::to_str(i64_val) == ~\"9223372036854775807\"));\n \n-    i64_val += 1 as i64;\n-    assert!((i64::to_str(i64_val) == ~\"-9223372036854775808\"));\n-}\n+        i64_val += 1 as i64;\n+        assert!((i64::to_str(i64_val) == ~\"-9223372036854775808\"));\n+    }\n \n-#[test]\n-fn test_int_from_str_overflow() {\n-    let mut i8_val: i8 = 127_i8;\n-    assert!((i8::from_str(~\"127\") == Some(i8_val)));\n-    assert!((i8::from_str(~\"128\").is_none()));\n+    #[test]\n+    fn test_int_from_str_overflow() {\n+        let mut i8_val: i8 = 127_i8;\n+        assert!((i8::from_str(~\"127\") == Some(i8_val)));\n+        assert!((i8::from_str(~\"128\").is_none()));\n \n-    i8_val += 1 as i8;\n-    assert!((i8::from_str(~\"-128\") == Some(i8_val)));\n-    assert!((i8::from_str(~\"-129\").is_none()));\n+        i8_val += 1 as i8;\n+        assert!((i8::from_str(~\"-128\") == Some(i8_val)));\n+        assert!((i8::from_str(~\"-129\").is_none()));\n \n-    let mut i16_val: i16 = 32_767_i16;\n-    assert!((i16::from_str(~\"32767\") == Some(i16_val)));\n-    assert!((i16::from_str(~\"32768\").is_none()));\n+        let mut i16_val: i16 = 32_767_i16;\n+        assert!((i16::from_str(~\"32767\") == Some(i16_val)));\n+        assert!((i16::from_str(~\"32768\").is_none()));\n \n-    i16_val += 1 as i16;\n-    assert!((i16::from_str(~\"-32768\") == Some(i16_val)));\n-    assert!((i16::from_str(~\"-32769\").is_none()));\n+        i16_val += 1 as i16;\n+        assert!((i16::from_str(~\"-32768\") == Some(i16_val)));\n+        assert!((i16::from_str(~\"-32769\").is_none()));\n \n-    let mut i32_val: i32 = 2_147_483_647_i32;\n-    assert!((i32::from_str(~\"2147483647\") == Some(i32_val)));\n-    assert!((i32::from_str(~\"2147483648\").is_none()));\n+        let mut i32_val: i32 = 2_147_483_647_i32;\n+        assert!((i32::from_str(~\"2147483647\") == Some(i32_val)));\n+        assert!((i32::from_str(~\"2147483648\").is_none()));\n \n-    i32_val += 1 as i32;\n-    assert!((i32::from_str(~\"-2147483648\") == Some(i32_val)));\n-    assert!((i32::from_str(~\"-2147483649\").is_none()));\n+        i32_val += 1 as i32;\n+        assert!((i32::from_str(~\"-2147483648\") == Some(i32_val)));\n+        assert!((i32::from_str(~\"-2147483649\").is_none()));\n \n-    let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-    assert!((i64::from_str(~\"9223372036854775807\") == Some(i64_val)));\n-    assert!((i64::from_str(~\"9223372036854775808\").is_none()));\n+        let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n+        assert!((i64::from_str(~\"9223372036854775807\") == Some(i64_val)));\n+        assert!((i64::from_str(~\"9223372036854775808\").is_none()));\n \n-    i64_val += 1 as i64;\n-    assert!((i64::from_str(~\"-9223372036854775808\") == Some(i64_val)));\n-    assert!((i64::from_str(~\"-9223372036854775809\").is_none()));\n-}\n+        i64_val += 1 as i64;\n+        assert!((i64::from_str(~\"-9223372036854775808\") == Some(i64_val)));\n+        assert!((i64::from_str(~\"-9223372036854775809\").is_none()));\n+    }\n \n-#[test]\n-pub fn test_ranges() {\n-    let mut l = ~[];\n+    #[test]\n+    fn test_ranges() {\n+        let mut l = ~[];\n \n-    for range(0,3) |i| {\n-        l.push(i);\n-    }\n-    for range_rev(13,10) |i| {\n-        l.push(i);\n-    }\n-    for range_step(20,26,2) |i| {\n-        l.push(i);\n-    }\n-    for range_step(36,30,-2) |i| {\n-        l.push(i);\n-    }\n-    for range_step(max_value - 2, max_value, 2) |i| {\n-        l.push(i);\n-    }\n-    for range_step(max_value - 3, max_value, 2) |i| {\n-        l.push(i);\n-    }\n-    for range_step(min_value + 2, min_value, -2) |i| {\n-        l.push(i);\n-    }\n-    for range_step(min_value + 3, min_value, -2) |i| {\n-        l.push(i);\n-    }\n-    assert_eq!(l, ~[0,1,2,\n-                    13,12,11,\n-                    20,22,24,\n-                    36,34,32,\n-                    max_value-2,\n-                    max_value-3,max_value-1,\n-                    min_value+2,\n-                    min_value+3,min_value+1]);\n-\n-    // None of the `fail`s should execute.\n-    for range(10,0) |_i| {\n-        fail!(~\"unreachable\");\n-    }\n-    for range_rev(0,10) |_i| {\n-        fail!(~\"unreachable\");\n-    }\n-    for range_step(10,0,1) |_i| {\n-        fail!(~\"unreachable\");\n-    }\n-    for range_step(0,10,-1) |_i| {\n-        fail!(~\"unreachable\");\n+        for range(0,3) |i| {\n+            l.push(i);\n+        }\n+        for range_rev(13,10) |i| {\n+            l.push(i);\n+        }\n+        for range_step(20,26,2) |i| {\n+            l.push(i);\n+        }\n+        for range_step(36,30,-2) |i| {\n+            l.push(i);\n+        }\n+        for range_step(max_value - 2, max_value, 2) |i| {\n+            l.push(i);\n+        }\n+        for range_step(max_value - 3, max_value, 2) |i| {\n+            l.push(i);\n+        }\n+        for range_step(min_value + 2, min_value, -2) |i| {\n+            l.push(i);\n+        }\n+        for range_step(min_value + 3, min_value, -2) |i| {\n+            l.push(i);\n+        }\n+        assert_eq!(l, ~[0,1,2,\n+                        13,12,11,\n+                        20,22,24,\n+                        36,34,32,\n+                        max_value-2,\n+                        max_value-3,max_value-1,\n+                        min_value+2,\n+                        min_value+3,min_value+1]);\n+\n+        // None of the `fail`s should execute.\n+        for range(10,0) |_i| {\n+            fail!(~\"unreachable\");\n+        }\n+        for range_rev(0,10) |_i| {\n+            fail!(~\"unreachable\");\n+        }\n+        for range_step(10,0,1) |_i| {\n+            fail!(~\"unreachable\");\n+        }\n+        for range_step(0,10,-1) |_i| {\n+            fail!(~\"unreachable\");\n+        }\n     }\n-}\n \n-#[test]\n-#[should_fail]\n-#[ignore(cfg(windows))]\n-fn test_range_step_zero_step() {\n-    for range_step(0,10,0) |_i| {}\n-}\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn test_range_step_zero_step() {\n+        for range_step(0,10,0) |_i| {}\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "af6557e9881f254718e72ee4875285acb0aeba7e", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 161, "deletions": 155, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -242,184 +242,190 @@ impl ToStrRadix for T {\n     }\n }\n \n-#[test]\n-pub fn test_to_str() {\n-    assert!(to_str_radix(0 as T, 10u) == ~\"0\");\n-    assert!(to_str_radix(1 as T, 10u) == ~\"1\");\n-    assert!(to_str_radix(2 as T, 10u) == ~\"2\");\n-    assert!(to_str_radix(11 as T, 10u) == ~\"11\");\n-    assert!(to_str_radix(11 as T, 16u) == ~\"b\");\n-    assert!(to_str_radix(255 as T, 16u) == ~\"ff\");\n-    assert!(to_str_radix(0xff as T, 10u) == ~\"255\");\n-}\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use super::inst::T;\n+    use prelude::*;\n+    #[test]\n+    pub fn test_to_str() {\n+        assert!(to_str_radix(0 as T, 10u) == ~\"0\");\n+        assert!(to_str_radix(1 as T, 10u) == ~\"1\");\n+        assert!(to_str_radix(2 as T, 10u) == ~\"2\");\n+        assert!(to_str_radix(11 as T, 10u) == ~\"11\");\n+        assert!(to_str_radix(11 as T, 16u) == ~\"b\");\n+        assert!(to_str_radix(255 as T, 16u) == ~\"ff\");\n+        assert!(to_str_radix(0xff as T, 10u) == ~\"255\");\n+    }\n \n-#[test]\n-pub fn test_from_str() {\n-    assert!(from_str(~\"0\") == Some(0u as T));\n-    assert!(from_str(~\"3\") == Some(3u as T));\n-    assert!(from_str(~\"10\") == Some(10u as T));\n-    assert!(u32::from_str(~\"123456789\") == Some(123456789 as u32));\n-    assert!(from_str(~\"00100\") == Some(100u as T));\n-\n-    assert!(from_str(~\"\").is_none());\n-    assert!(from_str(~\" \").is_none());\n-    assert!(from_str(~\"x\").is_none());\n-}\n+    #[test]\n+    pub fn test_from_str() {\n+        assert!(from_str(~\"0\") == Some(0u as T));\n+        assert!(from_str(~\"3\") == Some(3u as T));\n+        assert!(from_str(~\"10\") == Some(10u as T));\n+        assert!(u32::from_str(~\"123456789\") == Some(123456789 as u32));\n+        assert!(from_str(~\"00100\") == Some(100u as T));\n+\n+        assert!(from_str(~\"\").is_none());\n+        assert!(from_str(~\" \").is_none());\n+        assert!(from_str(~\"x\").is_none());\n+    }\n \n-#[test]\n-pub fn test_parse_bytes() {\n-    use str::to_bytes;\n-    assert!(parse_bytes(to_bytes(~\"123\"), 10u) == Some(123u as T));\n-    assert!(parse_bytes(to_bytes(~\"1001\"), 2u) == Some(9u as T));\n-    assert!(parse_bytes(to_bytes(~\"123\"), 8u) == Some(83u as T));\n-    assert!(u16::parse_bytes(to_bytes(~\"123\"), 16u) ==\n-                 Some(291u as u16));\n-    assert!(u16::parse_bytes(to_bytes(~\"ffff\"), 16u) ==\n-                 Some(65535u as u16));\n-    assert!(parse_bytes(to_bytes(~\"z\"), 36u) == Some(35u as T));\n-\n-    assert!(parse_bytes(to_bytes(~\"Z\"), 10u).is_none());\n-    assert!(parse_bytes(to_bytes(~\"_\"), 2u).is_none());\n-}\n+    #[test]\n+    pub fn test_parse_bytes() {\n+        use str::to_bytes;\n+        assert!(parse_bytes(to_bytes(~\"123\"), 10u) == Some(123u as T));\n+        assert!(parse_bytes(to_bytes(~\"1001\"), 2u) == Some(9u as T));\n+        assert!(parse_bytes(to_bytes(~\"123\"), 8u) == Some(83u as T));\n+        assert!(u16::parse_bytes(to_bytes(~\"123\"), 16u) ==\n+                Some(291u as u16));\n+        assert!(u16::parse_bytes(to_bytes(~\"ffff\"), 16u) ==\n+                Some(65535u as u16));\n+        assert!(parse_bytes(to_bytes(~\"z\"), 36u) == Some(35u as T));\n+\n+        assert!(parse_bytes(to_bytes(~\"Z\"), 10u).is_none());\n+        assert!(parse_bytes(to_bytes(~\"_\"), 2u).is_none());\n+    }\n \n-#[test]\n-fn test_uint_to_str_overflow() {\n-    let mut u8_val: u8 = 255_u8;\n-    assert!((u8::to_str(u8_val) == ~\"255\"));\n+    #[test]\n+    fn test_uint_to_str_overflow() {\n+        let mut u8_val: u8 = 255_u8;\n+        assert!((u8::to_str(u8_val) == ~\"255\"));\n \n-    u8_val += 1 as u8;\n-    assert!((u8::to_str(u8_val) == ~\"0\"));\n+        u8_val += 1 as u8;\n+        assert!((u8::to_str(u8_val) == ~\"0\"));\n \n-    let mut u16_val: u16 = 65_535_u16;\n-    assert!((u16::to_str(u16_val) == ~\"65535\"));\n+        let mut u16_val: u16 = 65_535_u16;\n+        assert!((u16::to_str(u16_val) == ~\"65535\"));\n \n-    u16_val += 1 as u16;\n-    assert!((u16::to_str(u16_val) == ~\"0\"));\n+        u16_val += 1 as u16;\n+        assert!((u16::to_str(u16_val) == ~\"0\"));\n \n-    let mut u32_val: u32 = 4_294_967_295_u32;\n-    assert!((u32::to_str(u32_val) == ~\"4294967295\"));\n+        let mut u32_val: u32 = 4_294_967_295_u32;\n+        assert!((u32::to_str(u32_val) == ~\"4294967295\"));\n \n-    u32_val += 1 as u32;\n-    assert!((u32::to_str(u32_val) == ~\"0\"));\n+        u32_val += 1 as u32;\n+        assert!((u32::to_str(u32_val) == ~\"0\"));\n \n-    let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n-    assert!((u64::to_str(u64_val) == ~\"18446744073709551615\"));\n+        let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n+        assert!((u64::to_str(u64_val) == ~\"18446744073709551615\"));\n \n-    u64_val += 1 as u64;\n-    assert!((u64::to_str(u64_val) == ~\"0\"));\n-}\n+        u64_val += 1 as u64;\n+        assert!((u64::to_str(u64_val) == ~\"0\"));\n+    }\n \n-#[test]\n-fn test_uint_from_str_overflow() {\n-    let mut u8_val: u8 = 255_u8;\n-    assert!((u8::from_str(~\"255\") == Some(u8_val)));\n-    assert!((u8::from_str(~\"256\").is_none()));\n+    #[test]\n+    fn test_uint_from_str_overflow() {\n+        let mut u8_val: u8 = 255_u8;\n+        assert!((u8::from_str(~\"255\") == Some(u8_val)));\n+        assert!((u8::from_str(~\"256\").is_none()));\n \n-    u8_val += 1 as u8;\n-    assert!((u8::from_str(~\"0\") == Some(u8_val)));\n-    assert!((u8::from_str(~\"-1\").is_none()));\n+        u8_val += 1 as u8;\n+        assert!((u8::from_str(~\"0\") == Some(u8_val)));\n+        assert!((u8::from_str(~\"-1\").is_none()));\n \n-    let mut u16_val: u16 = 65_535_u16;\n-    assert!((u16::from_str(~\"65535\") == Some(u16_val)));\n-    assert!((u16::from_str(~\"65536\").is_none()));\n+        let mut u16_val: u16 = 65_535_u16;\n+        assert!((u16::from_str(~\"65535\") == Some(u16_val)));\n+        assert!((u16::from_str(~\"65536\").is_none()));\n \n-    u16_val += 1 as u16;\n-    assert!((u16::from_str(~\"0\") == Some(u16_val)));\n-    assert!((u16::from_str(~\"-1\").is_none()));\n+        u16_val += 1 as u16;\n+        assert!((u16::from_str(~\"0\") == Some(u16_val)));\n+        assert!((u16::from_str(~\"-1\").is_none()));\n \n-    let mut u32_val: u32 = 4_294_967_295_u32;\n-    assert!((u32::from_str(~\"4294967295\") == Some(u32_val)));\n-    assert!((u32::from_str(~\"4294967296\").is_none()));\n+        let mut u32_val: u32 = 4_294_967_295_u32;\n+        assert!((u32::from_str(~\"4294967295\") == Some(u32_val)));\n+        assert!((u32::from_str(~\"4294967296\").is_none()));\n \n-    u32_val += 1 as u32;\n-    assert!((u32::from_str(~\"0\") == Some(u32_val)));\n-    assert!((u32::from_str(~\"-1\").is_none()));\n+        u32_val += 1 as u32;\n+        assert!((u32::from_str(~\"0\") == Some(u32_val)));\n+        assert!((u32::from_str(~\"-1\").is_none()));\n \n-    let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n-    assert!((u64::from_str(~\"18446744073709551615\") == Some(u64_val)));\n-    assert!((u64::from_str(~\"18446744073709551616\").is_none()));\n+        let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n+        assert!((u64::from_str(~\"18446744073709551615\") == Some(u64_val)));\n+        assert!((u64::from_str(~\"18446744073709551616\").is_none()));\n \n-    u64_val += 1 as u64;\n-    assert!((u64::from_str(~\"0\") == Some(u64_val)));\n-    assert!((u64::from_str(~\"-1\").is_none()));\n-}\n+        u64_val += 1 as u64;\n+        assert!((u64::from_str(~\"0\") == Some(u64_val)));\n+        assert!((u64::from_str(~\"-1\").is_none()));\n+    }\n \n-#[test]\n-#[should_fail]\n-#[ignore(cfg(windows))]\n-pub fn to_str_radix1() {\n-    uint::to_str_radix(100u, 1u);\n-}\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    pub fn to_str_radix1() {\n+        uint::to_str_radix(100u, 1u);\n+    }\n \n-#[test]\n-#[should_fail]\n-#[ignore(cfg(windows))]\n-pub fn to_str_radix37() {\n-    uint::to_str_radix(100u, 37u);\n-}\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    pub fn to_str_radix37() {\n+        uint::to_str_radix(100u, 37u);\n+    }\n \n-#[test]\n-pub fn test_ranges() {\n-    let mut l = ~[];\n+    #[test]\n+    pub fn test_ranges() {\n+        let mut l = ~[];\n \n-    for range(0,3) |i| {\n-        l.push(i);\n-    }\n-    for range_rev(13,10) |i| {\n-        l.push(i);\n-    }\n-    for range_step(20,26,2) |i| {\n-        l.push(i);\n-    }\n-    for range_step(36,30,-2) |i| {\n-        l.push(i);\n-    }\n-    for range_step(max_value - 2, max_value, 2) |i| {\n-        l.push(i);\n-    }\n-    for range_step(max_value - 3, max_value, 2) |i| {\n-        l.push(i);\n-    }\n-    for range_step(min_value + 2, min_value, -2) |i| {\n-        l.push(i);\n-    }\n-    for range_step(min_value + 3, min_value, -2) |i| {\n-        l.push(i);\n-    }\n+        for range(0,3) |i| {\n+            l.push(i);\n+        }\n+        for range_rev(13,10) |i| {\n+            l.push(i);\n+        }\n+        for range_step(20,26,2) |i| {\n+            l.push(i);\n+        }\n+        for range_step(36,30,-2) |i| {\n+            l.push(i);\n+        }\n+        for range_step(max_value - 2, max_value, 2) |i| {\n+            l.push(i);\n+        }\n+        for range_step(max_value - 3, max_value, 2) |i| {\n+            l.push(i);\n+        }\n+        for range_step(min_value + 2, min_value, -2) |i| {\n+            l.push(i);\n+        }\n+        for range_step(min_value + 3, min_value, -2) |i| {\n+            l.push(i);\n+        }\n \n-    assert_eq!(l, ~[0,1,2,\n-                    13,12,11,\n-                    20,22,24,\n-                    36,34,32,\n-                    max_value-2,\n-                    max_value-3,max_value-1,\n-                    min_value+2,\n-                    min_value+3,min_value+1]);\n-\n-    // None of the `fail`s should execute.\n-    for range(0,0) |_i| {\n-        fail!(~\"unreachable\");\n-    }\n-    for range_rev(0,0) |_i| {\n-        fail!(~\"unreachable\");\n+        assert_eq!(l, ~[0,1,2,\n+                        13,12,11,\n+                        20,22,24,\n+                        36,34,32,\n+                        max_value-2,\n+                        max_value-3,max_value-1,\n+                        min_value+2,\n+                        min_value+3,min_value+1]);\n+\n+        // None of the `fail`s should execute.\n+        for range(0,0) |_i| {\n+            fail!(~\"unreachable\");\n+        }\n+        for range_rev(0,0) |_i| {\n+            fail!(~\"unreachable\");\n+        }\n+        for range_step(10,0,1) |_i| {\n+            fail!(~\"unreachable\");\n+        }\n+        for range_step(0,1,-10) |_i| {\n+            fail!(~\"unreachable\");\n+        }\n     }\n-    for range_step(10,0,1) |_i| {\n-        fail!(~\"unreachable\");\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn test_range_step_zero_step_up() {\n+        for range_step(0,10,0) |_i| {}\n     }\n-    for range_step(0,1,-10) |_i| {\n-        fail!(~\"unreachable\");\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn test_range_step_zero_step_down() {\n+        for range_step(0,-10,0) |_i| {}\n     }\n-}\n-\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(windows))]\n-fn test_range_step_zero_step_up() {\n-    for range_step(0,10,0) |_i| {}\n-}\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(windows))]\n-fn test_range_step_zero_step_down() {\n-    for range_step(0,-10,0) |_i| {}\n-}\n+}\n\\ No newline at end of file"}, {"sha": "fddb2af558709ecbef256b8071ad1bd3e6f6fb1a", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -957,13 +957,13 @@ pub mod rt {\n }\n \n #[cfg(test)]\n-pub mod test {\n+mod test {\n     use either::Right;\n     use comm::{Chan, Port, oneshot, recv_one, stream, Select2,\n                GenericChan, Peekable};\n \n     #[test]\n-    pub fn test_select2() {\n+    fn test_select2() {\n         let (p1, c1) = stream();\n         let (p2, c2) = stream();\n \n@@ -978,7 +978,7 @@ pub mod test {\n     }\n \n     #[test]\n-    pub fn test_oneshot() {\n+    fn test_oneshot() {\n         let (c, p) = oneshot::init();\n \n         oneshot::client::send(c, ());"}, {"sha": "ebde37e77b42fcde6f468ad75a4ab18ac4131026", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 100, "deletions": 102, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -15,8 +15,6 @@ use libc;\n use libc::{c_void, size_t};\n use sys;\n \n-#[cfg(test)] use vec;\n-#[cfg(test)] use str;\n #[cfg(notest)] use cmp::{Eq, Ord};\n use uint;\n \n@@ -341,101 +339,101 @@ impl<'self,T:Ord> Ord for &'self const T {\n     }\n }\n \n-#[test]\n-pub fn test() {\n-    unsafe {\n-        struct Pair {mut fst: int, mut snd: int};\n-        let mut p = Pair {fst: 10, snd: 20};\n-        let pptr: *mut Pair = &mut p;\n-        let iptr: *mut int = cast::reinterpret_cast(&pptr);\n-        assert!((*iptr == 10));;\n-        *iptr = 30;\n-        assert!((*iptr == 30));\n-        assert!((p.fst == 30));;\n-\n-        *pptr = Pair {fst: 50, snd: 60};\n-        assert!((*iptr == 50));\n-        assert!((p.fst == 50));\n-        assert!((p.snd == 60));\n-\n-        let mut v0 = ~[32000u16, 32001u16, 32002u16];\n-        let mut v1 = ~[0u16, 0u16, 0u16];\n-\n-        copy_memory(mut_offset(vec::raw::to_mut_ptr(v1), 1u),\n-                    offset(vec::raw::to_ptr(v0), 1u), 1u);\n-        assert!((v1[0] == 0u16 && v1[1] == 32001u16 && v1[2] == 0u16));\n-        copy_memory(vec::raw::to_mut_ptr(v1),\n-                    offset(vec::raw::to_ptr(v0), 2u), 1u);\n-        assert!((v1[0] == 32002u16 && v1[1] == 32001u16 &&\n-                      v1[2] == 0u16));\n-        copy_memory(mut_offset(vec::raw::to_mut_ptr(v1), 2u),\n-                    vec::raw::to_ptr(v0), 1u);\n-        assert!((v1[0] == 32002u16 && v1[1] == 32001u16 &&\n-                      v1[2] == 32000u16));\n+#[cfg(test)]\n+pub mod ptr_tests {\n+    use super::*;\n+    use prelude::*;\n+\n+    #[test]\n+    fn test() {\n+        unsafe {\n+            struct Pair {mut fst: int, mut snd: int};\n+            let mut p = Pair {fst: 10, snd: 20};\n+            let pptr: *mut Pair = &mut p;\n+            let iptr: *mut int = cast::reinterpret_cast(&pptr);\n+            assert!((*iptr == 10));;\n+            *iptr = 30;\n+            assert!((*iptr == 30));\n+            assert!((p.fst == 30));;\n+\n+            *pptr = Pair {fst: 50, snd: 60};\n+            assert!((*iptr == 50));\n+            assert!((p.fst == 50));\n+            assert!((p.snd == 60));\n+\n+            let mut v0 = ~[32000u16, 32001u16, 32002u16];\n+            let mut v1 = ~[0u16, 0u16, 0u16];\n+\n+            copy_memory(mut_offset(vec::raw::to_mut_ptr(v1), 1u),\n+                        offset(vec::raw::to_ptr(v0), 1u), 1u);\n+            assert!((v1[0] == 0u16 && v1[1] == 32001u16 && v1[2] == 0u16));\n+            copy_memory(vec::raw::to_mut_ptr(v1),\n+                        offset(vec::raw::to_ptr(v0), 2u), 1u);\n+            assert!((v1[0] == 32002u16 && v1[1] == 32001u16 &&\n+                     v1[2] == 0u16));\n+            copy_memory(mut_offset(vec::raw::to_mut_ptr(v1), 2u),\n+                        vec::raw::to_ptr(v0), 1u);\n+            assert!((v1[0] == 32002u16 && v1[1] == 32001u16 &&\n+                     v1[2] == 32000u16));\n+        }\n     }\n-}\n \n-#[test]\n-pub fn test_position() {\n-    use str::as_c_str;\n-    use libc::c_char;\n+    #[test]\n+    fn test_position() {\n+        use str::as_c_str;\n+        use libc::c_char;\n \n-    let s = ~\"hello\";\n-    unsafe {\n-        assert!(2u == as_c_str(s, |p| position(p,\n-            |c| *c == 'l' as c_char)));\n-        assert!(4u == as_c_str(s, |p| position(p,\n-            |c| *c == 'o' as c_char)));\n-        assert!(5u == as_c_str(s, |p| position(p,\n-            |c| *c == 0 as c_char)));\n+        let s = ~\"hello\";\n+        unsafe {\n+            assert!(2u == as_c_str(s, |p| position(p,\n+                                                   |c| *c == 'l' as c_char)));\n+            assert!(4u == as_c_str(s, |p| position(p,\n+                                                   |c| *c == 'o' as c_char)));\n+            assert!(5u == as_c_str(s, |p| position(p,\n+                                                   |c| *c == 0 as c_char)));\n+        }\n     }\n-}\n \n-#[test]\n-pub fn test_buf_len() {\n-    let s0 = ~\"hello\";\n-    let s1 = ~\"there\";\n-    let s2 = ~\"thing\";\n-    do str::as_c_str(s0) |p0| {\n-        do str::as_c_str(s1) |p1| {\n-            do str::as_c_str(s2) |p2| {\n-                let v = ~[p0, p1, p2, null()];\n-                do vec::as_imm_buf(v) |vp, len| {\n-                    assert!(unsafe { buf_len(vp) } == 3u);\n-                    assert!(len == 4u);\n+    #[test]\n+    fn test_buf_len() {\n+        let s0 = ~\"hello\";\n+        let s1 = ~\"there\";\n+        let s2 = ~\"thing\";\n+        do str::as_c_str(s0) |p0| {\n+            do str::as_c_str(s1) |p1| {\n+                do str::as_c_str(s2) |p2| {\n+                    let v = ~[p0, p1, p2, null()];\n+                    do vec::as_imm_buf(v) |vp, len| {\n+                        assert!(unsafe { buf_len(vp) } == 3u);\n+                        assert!(len == 4u);\n+                    }\n                 }\n             }\n         }\n     }\n-}\n-\n-#[test]\n-pub fn test_is_null() {\n-   let p: *int = null();\n-   assert!(p.is_null());\n-   assert!(!p.is_not_null());\n \n-   let q = offset(p, 1u);\n-   assert!(!q.is_null());\n-   assert!(q.is_not_null());\n-\n-   let mp: *mut int = mut_null();\n-   assert!(mp.is_null());\n-   assert!(!mp.is_not_null());\n+    #[test]\n+    fn test_is_null() {\n+        let p: *int = null();\n+        assert!(p.is_null());\n+        assert!(!p.is_not_null());\n+\n+        let q = offset(p, 1u);\n+        assert!(!q.is_null());\n+        assert!(q.is_not_null());\n+\n+        let mp: *mut int = mut_null();\n+        assert!(mp.is_null());\n+        assert!(!mp.is_not_null());\n+\n+        let mq = mp.offset(1u);\n+        assert!(!mq.is_null());\n+        assert!(mq.is_not_null());\n+    }\n \n-   let mq = mp.offset(1u);\n-   assert!(!mq.is_null());\n-   assert!(mq.is_not_null());\n-}\n \n-#[cfg(test)]\n-pub mod ptr_tests {\n-    use ptr;\n-    use str;\n-    use libc;\n-    use vec;\n     #[test]\n-    pub fn test_ptr_array_each_with_len() {\n+    fn test_ptr_array_each_with_len() {\n         unsafe {\n             let one = ~\"oneOne\";\n             let two = ~\"twoTwo\";\n@@ -451,22 +449,22 @@ pub mod ptr_tests {\n             let arr_ptr = &arr[0];\n             let mut ctr = 0;\n             let mut iteration_count = 0;\n-            ptr::array_each_with_len(arr_ptr, vec::len(arr),\n-                |e| {\n-                let actual = str::raw::from_c_str(e);\n-                let expected = copy expected_arr[ctr];\n-                debug!(\n-                    \"test_ptr_array_each e: %s, a: %s\",\n-                         expected, actual);\n-                assert!(actual == expected);\n-                ctr += 1;\n-                iteration_count += 1;\n-            });\n+            array_each_with_len(arr_ptr, vec::len(arr),\n+                                |e| {\n+                                         let actual = str::raw::from_c_str(e);\n+                                         let expected = copy expected_arr[ctr];\n+                                         debug!(\n+                                             \"test_ptr_array_each e: %s, a: %s\",\n+                                             expected, actual);\n+                                         assert!(actual == expected);\n+                                         ctr += 1;\n+                                         iteration_count += 1;\n+                                     });\n             assert!(iteration_count == 3u);\n         }\n     }\n     #[test]\n-    pub fn test_ptr_array_each() {\n+    fn test_ptr_array_each() {\n         unsafe {\n             let one = ~\"oneOne\";\n             let two = ~\"twoTwo\";\n@@ -484,12 +482,12 @@ pub mod ptr_tests {\n             let arr_ptr = &arr[0];\n             let mut ctr = 0;\n             let mut iteration_count = 0;\n-            ptr::array_each(arr_ptr, |e| {\n+            array_each(arr_ptr, |e| {\n                 let actual = str::raw::from_c_str(e);\n                 let expected = copy expected_arr[ctr];\n                 debug!(\n                     \"test_ptr_array_each e: %s, a: %s\",\n-                         expected, actual);\n+                    expected, actual);\n                 assert!(actual == expected);\n                 ctr += 1;\n                 iteration_count += 1;\n@@ -500,19 +498,19 @@ pub mod ptr_tests {\n     #[test]\n     #[should_fail]\n     #[ignore(cfg(windows))]\n-    pub fn test_ptr_array_each_with_len_null_ptr() {\n+    fn test_ptr_array_each_with_len_null_ptr() {\n         unsafe {\n-            ptr::array_each_with_len(0 as **libc::c_char, 1, |e| {\n+            array_each_with_len(0 as **libc::c_char, 1, |e| {\n                 str::raw::from_c_str(e);\n             });\n         }\n     }\n     #[test]\n     #[should_fail]\n     #[ignore(cfg(windows))]\n-    pub fn test_ptr_array_each_null_ptr() {\n+    fn test_ptr_array_each_null_ptr() {\n         unsafe {\n-            ptr::array_each(0 as **libc::c_char, |e| {\n+            array_each(0 as **libc::c_char, |e| {\n                 str::raw::from_c_str(e);\n             });\n         }"}, {"sha": "0a93a651a8572f8c4520fd6ef8f6097b1e3a738f", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -747,20 +747,20 @@ pub fn random() -> uint {\n \n \n #[cfg(test)]\n-pub mod tests {\n+mod tests {\n     use option::{Option, Some};\n     use rand;\n \n     #[test]\n-    pub fn rng_seeded() {\n+    fn rng_seeded() {\n         let seed = rand::seed();\n         let ra = rand::seeded_rng(seed);\n         let rb = rand::seeded_rng(seed);\n         assert!(ra.gen_str(100u) == rb.gen_str(100u));\n     }\n \n     #[test]\n-    pub fn rng_seeded_custom_seed() {\n+    fn rng_seeded_custom_seed() {\n         // much shorter than generated seeds which are 1024 bytes\n         let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n         let ra = rand::seeded_rng(seed);\n@@ -769,7 +769,7 @@ pub mod tests {\n     }\n \n     #[test]\n-    pub fn rng_seeded_custom_seed2() {\n+    fn rng_seeded_custom_seed2() {\n         let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n         let ra = rand::seeded_rng(seed);\n         // Regression test that isaac is actually using the above vector\n@@ -780,7 +780,7 @@ pub mod tests {\n     }\n \n     #[test]\n-    pub fn gen_int_range() {\n+    fn gen_int_range() {\n         let r = rand::Rng();\n         let a = r.gen_int_range(-3, 42);\n         assert!(a >= -3 && a < 42);\n@@ -791,12 +791,12 @@ pub mod tests {\n     #[test]\n     #[should_fail]\n     #[ignore(cfg(windows))]\n-    pub fn gen_int_from_fail() {\n+    fn gen_int_from_fail() {\n         rand::Rng().gen_int_range(5, -2);\n     }\n \n     #[test]\n-    pub fn gen_uint_range() {\n+    fn gen_uint_range() {\n         let r = rand::Rng();\n         let a = r.gen_uint_range(3u, 42u);\n         assert!(a >= 3u && a < 42u);\n@@ -807,27 +807,27 @@ pub mod tests {\n     #[test]\n     #[should_fail]\n     #[ignore(cfg(windows))]\n-    pub fn gen_uint_range_fail() {\n+    fn gen_uint_range_fail() {\n         rand::Rng().gen_uint_range(5u, 2u);\n     }\n \n     #[test]\n-    pub fn gen_float() {\n+    fn gen_float() {\n         let r = rand::Rng();\n         let a = r.gen_float();\n         let b = r.gen_float();\n         debug!((a, b));\n     }\n \n     #[test]\n-    pub fn gen_weighted_bool() {\n+    fn gen_weighted_bool() {\n         let r = rand::Rng();\n         assert!(r.gen_weighted_bool(0u) == true);\n         assert!(r.gen_weighted_bool(1u) == true);\n     }\n \n     #[test]\n-    pub fn gen_str() {\n+    fn gen_str() {\n         let r = rand::Rng();\n         debug!(r.gen_str(10u));\n         debug!(r.gen_str(10u));\n@@ -838,29 +838,29 @@ pub mod tests {\n     }\n \n     #[test]\n-    pub fn gen_bytes() {\n+    fn gen_bytes() {\n         let r = rand::Rng();\n         assert!(r.gen_bytes(0u).len() == 0u);\n         assert!(r.gen_bytes(10u).len() == 10u);\n         assert!(r.gen_bytes(16u).len() == 16u);\n     }\n \n     #[test]\n-    pub fn choose() {\n+    fn choose() {\n         let r = rand::Rng();\n         assert!(r.choose([1, 1, 1]) == 1);\n     }\n \n     #[test]\n-    pub fn choose_option() {\n+    fn choose_option() {\n         let r = rand::Rng();\n         let x: Option<int> = r.choose_option([]);\n         assert!(x.is_none());\n         assert!(r.choose_option([1, 1, 1]) == Some(1));\n     }\n \n     #[test]\n-    pub fn choose_weighted() {\n+    fn choose_weighted() {\n         let r = rand::Rng();\n         assert!(r.choose_weighted(~[\n             rand::Weighted { weight: 1u, item: 42 },\n@@ -872,7 +872,7 @@ pub mod tests {\n     }\n \n     #[test]\n-    pub fn choose_weighted_option() {\n+    fn choose_weighted_option() {\n         let r = rand::Rng();\n         assert!(r.choose_weighted_option(~[\n             rand::Weighted { weight: 1u, item: 42 },\n@@ -886,7 +886,7 @@ pub mod tests {\n     }\n \n     #[test]\n-    pub fn weighted_vec() {\n+    fn weighted_vec() {\n         let r = rand::Rng();\n         let empty: ~[int] = ~[];\n         assert!(r.weighted_vec(~[]) == empty);\n@@ -898,23 +898,23 @@ pub mod tests {\n     }\n \n     #[test]\n-    pub fn shuffle() {\n+    fn shuffle() {\n         let r = rand::Rng();\n         let empty: ~[int] = ~[];\n         assert!(r.shuffle(~[]) == empty);\n         assert!(r.shuffle(~[1, 1, 1]) == ~[1, 1, 1]);\n     }\n \n     #[test]\n-    pub fn task_rng() {\n+    fn task_rng() {\n         let r = rand::task_rng();\n         r.gen_int();\n         assert!(r.shuffle(~[1, 1, 1]) == ~[1, 1, 1]);\n         assert!(r.gen_uint_range(0u, 1u) == 0u);\n     }\n \n     #[test]\n-    pub fn random() {\n+    fn random() {\n         // not sure how to test this aside from just getting a number\n         let _n : uint = rand::random();\n     }"}, {"sha": "8e247a25012f113b08ba9810200311368d81a43e", "filename": "src/libcore/run.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -521,15 +521,15 @@ mod tests {\n \n     // Regression test for memory leaks\n     #[ignore(cfg(windows))] // FIXME (#2626)\n-    pub fn test_leaks() {\n+    fn test_leaks() {\n         run::run_program(\"echo\", []);\n         run::start_program(\"echo\", []);\n         run::program_output(\"echo\", []);\n     }\n \n     #[test]\n     #[allow(non_implicitly_copyable_typarams)]\n-    pub fn test_pipes() {\n+    fn test_pipes() {\n         let pipe_in = os::pipe();\n         let pipe_out = os::pipe();\n         let pipe_err = os::pipe();\n@@ -555,7 +555,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn waitpid() {\n+    fn waitpid() {\n         let pid = run::spawn_process(\"false\", [],\n                                      &None, &None,\n                                      0i32, 0i32, 0i32);\n@@ -564,20 +564,20 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_destroy_once() {\n+    fn test_destroy_once() {\n         let mut p = run::start_program(\"echo\", []);\n         p.destroy(); // this shouldn't crash (and nor should the destructor)\n     }\n \n     #[test]\n-    pub fn test_destroy_twice() {\n+    fn test_destroy_twice() {\n         let mut p = run::start_program(\"echo\", []);\n         p.destroy(); // this shouldnt crash...\n         p.destroy(); // ...and nor should this (and nor should the destructor)\n     }\n \n     #[cfg(unix)] // there is no way to sleep on windows from inside libcore...\n-    pub fn test_destroy_actually_kills(force: bool) {\n+    fn test_destroy_actually_kills(force: bool) {\n         let path = Path(fmt!(\"test/core-run-test-destroy-actually-kills-%?.tmp\", force));\n \n         os::remove_file(&path);\n@@ -598,13 +598,13 @@ mod tests {\n \n     #[test]\n     #[cfg(unix)]\n-    pub fn test_unforced_destroy_actually_kills() {\n+    fn test_unforced_destroy_actually_kills() {\n         test_destroy_actually_kills(false);\n     }\n \n     #[test]\n     #[cfg(unix)]\n-    pub fn test_forced_destroy_actually_kills() {\n+    fn test_forced_destroy_actually_kills() {\n         test_destroy_actually_kills(true);\n     }\n }"}, {"sha": "04f96f5eb229e5fe8b75065e7b5fdf4aecd4deb9", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -160,12 +160,12 @@ pub fn fail_assert(msg: &str, file: &str, line: uint) -> ! {\n }\n \n #[cfg(test)]\n-pub mod tests {\n+mod tests {\n     use cast;\n     use sys::{Closure, pref_align_of, size_of, nonzero_size_of};\n \n     #[test]\n-    pub fn size_of_basic() {\n+    fn size_of_basic() {\n         assert!(size_of::<u8>() == 1u);\n         assert!(size_of::<u16>() == 2u);\n         assert!(size_of::<u32>() == 4u);\n@@ -176,28 +176,28 @@ pub mod tests {\n     #[cfg(target_arch = \"x86\")]\n     #[cfg(target_arch = \"arm\")]\n     #[cfg(target_arch = \"mips\")]\n-    pub fn size_of_32() {\n+    fn size_of_32() {\n         assert!(size_of::<uint>() == 4u);\n         assert!(size_of::<*uint>() == 4u);\n     }\n \n     #[test]\n     #[cfg(target_arch = \"x86_64\")]\n-    pub fn size_of_64() {\n+    fn size_of_64() {\n         assert!(size_of::<uint>() == 8u);\n         assert!(size_of::<*uint>() == 8u);\n     }\n \n     #[test]\n-    pub fn nonzero_size_of_basic() {\n+    fn nonzero_size_of_basic() {\n         type Z = [i8, ..0];\n         assert!(size_of::<Z>() == 0u);\n         assert!(nonzero_size_of::<Z>() == 1u);\n         assert!(nonzero_size_of::<uint>() == size_of::<uint>());\n     }\n \n     #[test]\n-    pub fn align_of_basic() {\n+    fn align_of_basic() {\n         assert!(pref_align_of::<u8>() == 1u);\n         assert!(pref_align_of::<u16>() == 2u);\n         assert!(pref_align_of::<u32>() == 4u);\n@@ -207,20 +207,20 @@ pub mod tests {\n     #[cfg(target_arch = \"x86\")]\n     #[cfg(target_arch = \"arm\")]\n     #[cfg(target_arch = \"mips\")]\n-    pub fn align_of_32() {\n+    fn align_of_32() {\n         assert!(pref_align_of::<uint>() == 4u);\n         assert!(pref_align_of::<*uint>() == 4u);\n     }\n \n     #[test]\n     #[cfg(target_arch = \"x86_64\")]\n-    pub fn align_of_64() {\n+    fn align_of_64() {\n         assert!(pref_align_of::<uint>() == 8u);\n         assert!(pref_align_of::<*uint>() == 8u);\n     }\n \n     #[test]\n-    pub fn synthesize_closure() {\n+    fn synthesize_closure() {\n         unsafe {\n             let x = 10;\n             let f: &fn(int) -> int = |y| x + y;"}, {"sha": "a6c4b6c526862154caa1510cff4613c4ed5ce3ea", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -925,7 +925,7 @@ fn test_spawn_sched_childs_on_default_sched() {\n }\n \n #[cfg(test)]\n-pub mod testrt {\n+mod testrt {\n     use libc;\n \n     #[nolink]"}, {"sha": "c057fce0abd8cfecc2f5cc43fc5330824dfe365f", "filename": "src/libcore/unstable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Funstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibcore%2Funstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -286,14 +286,14 @@ pub impl<T:Owned> Exclusive<T> {\n }\n \n #[cfg(test)]\n-pub mod tests {\n+mod tests {\n     use comm;\n     use super::exclusive;\n     use task;\n     use uint;\n \n     #[test]\n-    pub fn exclusive_arc() {\n+    fn exclusive_arc() {\n         let mut futures = ~[];\n \n         let num_tasks = 10;\n@@ -324,7 +324,7 @@ pub mod tests {\n     }\n \n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn exclusive_poison() {\n+    fn exclusive_poison() {\n         // Tests that if one task fails inside of an exclusive, subsequent\n         // accesses will also fail.\n         let x = exclusive(1);"}, {"sha": "49935eea0e13d7734dbf5b311c72ca1aff886f80", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -212,14 +212,14 @@ mod test {\n     use driver::session;\n \n     #[test]\n-    pub fn test_rpaths_to_flags() {\n+    fn test_rpaths_to_flags() {\n         let flags = rpaths_to_flags(~[Path(\"path1\"),\n                                       Path(\"path2\")]);\n         assert!(flags == ~[~\"-Wl,-rpath,path1\", ~\"-Wl,-rpath,path2\"]);\n     }\n \n     #[test]\n-    pub fn test_prefix_rpath() {\n+    fn test_prefix_rpath() {\n         let res = get_install_prefix_rpath(\"triple\");\n         let d = Path(env!(\"CFG_PREFIX\"))\n             .push_rel(&Path(\"lib/rustc/triple/lib\"));\n@@ -230,21 +230,21 @@ mod test {\n     }\n \n     #[test]\n-    pub fn test_prefix_rpath_abs() {\n+    fn test_prefix_rpath_abs() {\n         let res = get_install_prefix_rpath(\"triple\");\n         assert!(res.is_absolute);\n     }\n \n     #[test]\n-    pub fn test_minimize1() {\n+    fn test_minimize1() {\n         let res = minimize_rpaths([Path(\"rpath1\"),\n                                    Path(\"rpath2\"),\n                                    Path(\"rpath1\")]);\n         assert!(res == ~[Path(\"rpath1\"), Path(\"rpath2\")]);\n     }\n \n     #[test]\n-    pub fn test_minimize2() {\n+    fn test_minimize2() {\n         let res = minimize_rpaths(~[Path(\"1a\"), Path(\"2\"), Path(\"2\"),\n                                     Path(\"1a\"), Path(\"4a\"),Path(\"1a\"),\n                                     Path(\"2\"), Path(\"3\"), Path(\"4a\"),\n@@ -253,63 +253,63 @@ mod test {\n     }\n \n     #[test]\n-    pub fn test_relative_to1() {\n+    fn test_relative_to1() {\n         let p1 = Path(\"/usr/bin/rustc\");\n         let p2 = Path(\"/usr/lib/mylib\");\n         let res = get_relative_to(&p1, &p2);\n         assert!(res == Path(\"../lib\"));\n     }\n \n     #[test]\n-    pub fn test_relative_to2() {\n+    fn test_relative_to2() {\n         let p1 = Path(\"/usr/bin/rustc\");\n         let p2 = Path(\"/usr/bin/../lib/mylib\");\n         let res = get_relative_to(&p1, &p2);\n         assert!(res == Path(\"../lib\"));\n     }\n \n     #[test]\n-    pub fn test_relative_to3() {\n+    fn test_relative_to3() {\n         let p1 = Path(\"/usr/bin/whatever/rustc\");\n         let p2 = Path(\"/usr/lib/whatever/mylib\");\n         let res = get_relative_to(&p1, &p2);\n         assert!(res == Path(\"../../lib/whatever\"));\n     }\n \n     #[test]\n-    pub fn test_relative_to4() {\n+    fn test_relative_to4() {\n         let p1 = Path(\"/usr/bin/whatever/../rustc\");\n         let p2 = Path(\"/usr/lib/whatever/mylib\");\n         let res = get_relative_to(&p1, &p2);\n         assert!(res == Path(\"../lib/whatever\"));\n     }\n \n     #[test]\n-    pub fn test_relative_to5() {\n+    fn test_relative_to5() {\n         let p1 = Path(\"/usr/bin/whatever/../rustc\");\n         let p2 = Path(\"/usr/lib/whatever/../mylib\");\n         let res = get_relative_to(&p1, &p2);\n         assert!(res == Path(\"../lib\"));\n     }\n \n     #[test]\n-    pub fn test_relative_to6() {\n+    fn test_relative_to6() {\n         let p1 = Path(\"/1\");\n         let p2 = Path(\"/2/3\");\n         let res = get_relative_to(&p1, &p2);\n         assert!(res == Path(\"2\"));\n     }\n \n     #[test]\n-    pub fn test_relative_to7() {\n+    fn test_relative_to7() {\n         let p1 = Path(\"/1/2\");\n         let p2 = Path(\"/3\");\n         let res = get_relative_to(&p1, &p2);\n         assert!(res == Path(\"..\"));\n     }\n \n     #[test]\n-    pub fn test_relative_to8() {\n+    fn test_relative_to8() {\n         let p1 = Path(\"/home/brian/Dev/rust/build/\").push_rel(\n             &Path(\"stage2/lib/rustc/i686-unknown-linux-gnu/lib/librustc.so\"));\n         let p2 = Path(\"/home/brian/Dev/rust/build/stage2/bin/..\").push_rel(\n@@ -324,7 +324,7 @@ mod test {\n     #[test]\n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"andorid\")]\n-    pub fn test_rpath_relative() {\n+    fn test_rpath_relative() {\n       let o = session::os_linux;\n       let res = get_rpath_relative_to_output(o,\n             &Path(\"bin/rustc\"), &Path(\"lib/libstd.so\"));\n@@ -333,7 +333,7 @@ mod test {\n \n     #[test]\n     #[cfg(target_os = \"freebsd\")]\n-    pub fn test_rpath_relative() {\n+    fn test_rpath_relative() {\n         let o = session::os_freebsd;\n         let res = get_rpath_relative_to_output(o,\n             &Path(\"bin/rustc\"), &Path(\"lib/libstd.so\"));\n@@ -342,7 +342,7 @@ mod test {\n \n     #[test]\n     #[cfg(target_os = \"macos\")]\n-    pub fn test_rpath_relative() {\n+    fn test_rpath_relative() {\n         // this is why refinements would be nice\n         let o = session::os_macos;\n         let res = get_rpath_relative_to_output(o,\n@@ -352,7 +352,7 @@ mod test {\n     }\n \n     #[test]\n-    pub fn test_get_absolute_rpath() {\n+    fn test_get_absolute_rpath() {\n         let res = get_absolute_rpath(&Path(\"lib/libstd.so\"));\n         debug!(\"test_get_absolute_rpath: %s vs. %s\",\n                res.to_str(),"}, {"sha": "a804469ac651187c422366a5840319ca6d5a87b8", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -876,7 +876,7 @@ pub fn list_metadata(sess: Session, path: &Path, out: @io::Writer) {\n }\n \n #[cfg(test)]\n-pub mod test {\n+mod test {\n     use core::prelude::*;\n \n     use driver::driver::{build_configuration, build_session};\n@@ -890,7 +890,7 @@ pub mod test {\n \n     // When the user supplies --test we should implicitly supply --cfg test\n     #[test]\n-    pub fn test_switch_implies_cfg_test() {\n+    fn test_switch_implies_cfg_test() {\n         let matches =\n             &match getopts(~[~\"--test\"], optgroups()) {\n               Ok(copy m) => m,\n@@ -907,7 +907,7 @@ pub mod test {\n     // When the user supplies --test and --cfg test, don't implicitly add\n     // another --cfg test\n     #[test]\n-    pub fn test_switch_implies_cfg_test_unless_cfg_test() {\n+    fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let matches =\n             &match getopts(~[~\"--test\", ~\"--cfg=test\"], optgroups()) {\n               Ok(copy m) => m,"}, {"sha": "aee5e01e091080fa3df2dd7f69ecac2c4dae258a", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -354,14 +354,14 @@ pub fn sess_os_to_meta_os(os: os) -> metadata::loader::os {\n }\n \n #[cfg(test)]\n-pub mod test {\n+mod test {\n     use driver::session::{bin_crate, building_library, lib_crate};\n     use driver::session::{unknown_crate};\n \n     use syntax::ast;\n     use syntax::codemap;\n \n-    pub fn make_crate_type_attr(+t: ~str) -> ast::attribute {\n+    fn make_crate_type_attr(+t: ~str) -> ast::attribute {\n         codemap::respan(codemap::dummy_sp(), ast::attribute_ {\n             style: ast::attr_outer,\n             value: @codemap::respan(codemap::dummy_sp(),\n@@ -373,7 +373,7 @@ pub mod test {\n         })\n     }\n \n-    pub fn make_crate(with_bin: bool, with_lib: bool) -> @ast::crate {\n+    fn make_crate(with_bin: bool, with_lib: bool) -> @ast::crate {\n         let mut attrs = ~[];\n         if with_bin { attrs += ~[make_crate_type_attr(~\"bin\")]; }\n         if with_lib { attrs += ~[make_crate_type_attr(~\"lib\")]; }\n@@ -385,43 +385,43 @@ pub mod test {\n     }\n \n     #[test]\n-    pub fn bin_crate_type_attr_results_in_bin_output() {\n+    fn bin_crate_type_attr_results_in_bin_output() {\n         let crate = make_crate(true, false);\n         assert!(!building_library(unknown_crate, crate, false));\n     }\n \n     #[test]\n-    pub fn lib_crate_type_attr_results_in_lib_output() {\n+    fn lib_crate_type_attr_results_in_lib_output() {\n         let crate = make_crate(false, true);\n         assert!(building_library(unknown_crate, crate, false));\n     }\n \n     #[test]\n-    pub fn bin_option_overrides_lib_crate_type() {\n+    fn bin_option_overrides_lib_crate_type() {\n         let crate = make_crate(false, true);\n         assert!(!building_library(bin_crate, crate, false));\n     }\n \n     #[test]\n-    pub fn lib_option_overrides_bin_crate_type() {\n+    fn lib_option_overrides_bin_crate_type() {\n         let crate = make_crate(true, false);\n         assert!(building_library(lib_crate, crate, false));\n     }\n \n     #[test]\n-    pub fn bin_crate_type_is_default() {\n+    fn bin_crate_type_is_default() {\n         let crate = make_crate(false, false);\n         assert!(!building_library(unknown_crate, crate, false));\n     }\n \n     #[test]\n-    pub fn test_option_overrides_lib_crate_type() {\n+    fn test_option_overrides_lib_crate_type() {\n         let crate = make_crate(false, true);\n         assert!(!building_library(unknown_crate, crate, true));\n     }\n \n     #[test]\n-    pub fn test_option_does_not_override_requested_lib_type() {\n+    fn test_option_does_not_override_requested_lib_type() {\n         let crate = make_crate(false, false);\n         assert!(building_library(lib_crate, crate, true));\n     }"}, {"sha": "efd061209a50331a0163f842c7f7f27daffe8daf", "filename": "src/librustdoc/attr_parser.rs", "status": "modified", "additions": 88, "deletions": 89, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_parser.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -25,26 +25,6 @@ pub struct CrateAttrs {\n     name: Option<~str>\n }\n \n-#[cfg(test)]\n-mod test {\n-    use syntax::ast;\n-    use syntax;\n-\n-    use core::option::None;\n-\n-    pub fn parse_attributes(source: ~str) -> ~[ast::attribute] {\n-        use syntax::parse;\n-        use syntax::parse::attr::parser_attr;\n-        use syntax::codemap;\n-\n-        let parse_sess = syntax::parse::new_parse_sess(None);\n-        let parser = parse::new_parser_from_source_str(\n-            parse_sess, ~[], ~\"-\", codemap::FssNone, @source);\n-\n-        parser.parse_outer_attributes()\n-    }\n-}\n-\n fn doc_metas(\n     attrs: ~[ast::attribute]\n ) -> ~[@ast::meta_item] {\n@@ -66,30 +46,6 @@ pub fn parse_crate(attrs: ~[ast::attribute]) -> CrateAttrs {\n     }\n }\n \n-#[test]\n-fn should_extract_crate_name_from_link_attribute() {\n-    let source = ~\"#[link(name = \\\"snuggles\\\")]\";\n-    let attrs = test::parse_attributes(source);\n-    let attrs = parse_crate(attrs);\n-    assert!(attrs.name == Some(~\"snuggles\"));\n-}\n-\n-#[test]\n-fn should_not_extract_crate_name_if_no_link_attribute() {\n-    let source = ~\"\";\n-    let attrs = test::parse_attributes(source);\n-    let attrs = parse_crate(attrs);\n-    assert!(attrs.name == None);\n-}\n-\n-#[test]\n-fn should_not_extract_crate_name_if_no_name_value_in_link_attribute() {\n-    let source = ~\"#[link(whatever)]\";\n-    let attrs = test::parse_attributes(source);\n-    let attrs = parse_crate(attrs);\n-    assert!(attrs.name == None);\n-}\n-\n pub fn parse_desc(attrs: ~[ast::attribute]) -> Option<~str> {\n     let doc_strs = do doc_metas(attrs).filter_mapped |meta| {\n         attr::get_meta_item_value_str(*meta).map(|s| copy **s)\n@@ -101,60 +57,103 @@ pub fn parse_desc(attrs: ~[ast::attribute]) -> Option<~str> {\n     }\n }\n \n-#[test]\n-fn parse_desc_should_handle_undocumented_mods() {\n-    let source = ~\"\";\n-    let attrs = test::parse_attributes(source);\n-    let attrs = parse_desc(attrs);\n-    assert!(attrs == None);\n-}\n-\n-#[test]\n-fn parse_desc_should_parse_simple_doc_attributes() {\n-    let source = ~\"#[doc = \\\"basic\\\"]\";\n-    let attrs = test::parse_attributes(source);\n-    let attrs = parse_desc(attrs);\n-    assert!(attrs == Some(~\"basic\"));\n-}\n-\n pub fn parse_hidden(attrs: ~[ast::attribute]) -> bool {\n     do doc_metas(attrs).find |meta| {\n         match attr::get_meta_item_list(*meta) {\n-          Some(metas) => {\n-            let hiddens = attr::find_meta_items_by_name(metas, ~\"hidden\");\n-            !hiddens.is_empty()\n-          }\n-          None => false\n+            Some(metas) => {\n+                let hiddens = attr::find_meta_items_by_name(metas, ~\"hidden\");\n+                !hiddens.is_empty()\n+            }\n+            None => false\n         }\n     }.is_some()\n }\n \n-#[test]\n-fn should_parse_hidden_attribute() {\n-    let source = ~\"#[doc(hidden)]\";\n-    let attrs = test::parse_attributes(source);\n-    assert!(parse_hidden(attrs) == true);\n-}\n+#[cfg(test)]\n+mod test {\n+    use syntax::ast;\n+    use syntax;\n+    use super::{parse_hidden, parse_crate, parse_desc};\n+    use core::prelude::*;\n \n-#[test]\n-fn should_parse_hidden_attribute_with_other_docs() {\n-    let source = ~\"#[doc = \\\"foo\\\"] #[doc(hidden)] #[doc = \\\"foo\\\"]\";\n-    let attrs = test::parse_attributes(source);\n-    assert!(parse_hidden(attrs) == true);\n-}\n+    fn parse_attributes(source: ~str) -> ~[ast::attribute] {\n+        use syntax::parse;\n+        use syntax::parse::attr::parser_attr;\n+        use syntax::codemap;\n \n-#[test]\n-fn should_not_parse_non_hidden_attribute() {\n-    let source = ~\"#[doc = \\\"\\\"]\";\n-    let attrs = test::parse_attributes(source);\n-    assert!(parse_hidden(attrs) == false);\n-}\n+        let parse_sess = syntax::parse::new_parse_sess(None);\n+        let parser = parse::new_parser_from_source_str(\n+            parse_sess, ~[], ~\"-\", codemap::FssNone, @source);\n+\n+        parser.parse_outer_attributes()\n+    }\n \n-#[test]\n-fn should_concatenate_multiple_doc_comments() {\n-    let source = ~\"/// foo\\n/// bar\";\n-    let desc = parse_desc(test::parse_attributes(source));\n-    assert!(desc == Some(~\"foo\\nbar\"));\n-}\n \n+    #[test]\n+    fn should_extract_crate_name_from_link_attribute() {\n+        let source = ~\"#[link(name = \\\"snuggles\\\")]\";\n+        let attrs = parse_attributes(source);\n+        let attrs = parse_crate(attrs);\n+        assert!(attrs.name == Some(~\"snuggles\"));\n+    }\n \n+    #[test]\n+    fn should_not_extract_crate_name_if_no_link_attribute() {\n+        let source = ~\"\";\n+        let attrs = parse_attributes(source);\n+        let attrs = parse_crate(attrs);\n+        assert!(attrs.name == None);\n+    }\n+\n+    #[test]\n+    fn should_not_extract_crate_name_if_no_name_value_in_link_attribute() {\n+        let source = ~\"#[link(whatever)]\";\n+        let attrs = parse_attributes(source);\n+        let attrs = parse_crate(attrs);\n+        assert!(attrs.name == None);\n+    }\n+\n+    #[test]\n+    fn parse_desc_should_handle_undocumented_mods() {\n+        let source = ~\"\";\n+        let attrs = parse_attributes(source);\n+        let attrs = parse_desc(attrs);\n+        assert!(attrs == None);\n+    }\n+\n+    #[test]\n+    fn parse_desc_should_parse_simple_doc_attributes() {\n+        let source = ~\"#[doc = \\\"basic\\\"]\";\n+        let attrs = parse_attributes(source);\n+        let attrs = parse_desc(attrs);\n+        assert!(attrs == Some(~\"basic\"));\n+    }\n+\n+    #[test]\n+    fn should_parse_hidden_attribute() {\n+        let source = ~\"#[doc(hidden)]\";\n+        let attrs = parse_attributes(source);\n+        assert!(parse_hidden(attrs) == true);\n+    }\n+\n+    #[test]\n+    fn should_parse_hidden_attribute_with_other_docs() {\n+        let source = ~\"#[doc = \\\"foo\\\"] #[doc(hidden)] #[doc = \\\"foo\\\"]\";\n+        let attrs = parse_attributes(source);\n+        assert!(parse_hidden(attrs) == true);\n+    }\n+\n+    #[test]\n+    fn should_not_parse_non_hidden_attribute() {\n+        let source = ~\"#[doc = \\\"\\\"]\";\n+        let attrs = parse_attributes(source);\n+        assert!(parse_hidden(attrs) == false);\n+    }\n+\n+    #[test]\n+    fn should_concatenate_multiple_doc_comments() {\n+        let source = ~\"/// foo\\n/// bar\";\n+        let desc = parse_desc(parse_attributes(source));\n+        assert!(desc == Some(~\"foo\\nbar\"));\n+    }\n+}"}, {"sha": "a666bff18c97c7a494b3314888485d81de4fd595", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 107, "deletions": 106, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -78,12 +78,6 @@ fn fold_crate(\n     }\n }\n \n-#[test]\n-fn should_replace_top_module_name_with_crate_name() {\n-    let doc = test::mk_doc(~\"#[link(name = \\\"bond\\\")];\");\n-    assert!(doc.cratemod().name() == ~\"bond\");\n-}\n-\n fn fold_item(\n     fold: &fold::Fold<astsrv::Srv>,\n     doc: doc::ItemDoc\n@@ -113,38 +107,14 @@ fn parse_item_attrs<T:Owned>(\n     parse_attrs: ~fn(a: ~[ast::attribute]) -> T) -> T {\n     do astsrv::exec(srv) |ctxt| {\n         let attrs = match *ctxt.ast_map.get(&id) {\n-          ast_map::node_item(item, _) => copy item.attrs,\n-          ast_map::node_foreign_item(item, _, _, _) => copy item.attrs,\n-          _ => fail!(~\"parse_item_attrs: not an item\")\n+            ast_map::node_item(item, _) => copy item.attrs,\n+            ast_map::node_foreign_item(item, _, _, _) => copy item.attrs,\n+            _ => fail!(~\"parse_item_attrs: not an item\")\n         };\n         parse_attrs(attrs)\n     }\n }\n \n-#[test]\n-fn should_should_extract_mod_attributes() {\n-    let doc = test::mk_doc(~\"#[doc = \\\"test\\\"] mod a { }\");\n-    assert!(doc.cratemod().mods()[0].desc() == Some(~\"test\"));\n-}\n-\n-#[test]\n-fn should_extract_top_mod_attributes() {\n-    let doc = test::mk_doc(~\"#[doc = \\\"test\\\"];\");\n-    assert!(doc.cratemod().desc() == Some(~\"test\"));\n-}\n-\n-#[test]\n-fn should_extract_foreign_fn_attributes() {\n-    let doc = test::mk_doc(~\"extern { #[doc = \\\"test\\\"] fn a(); }\");\n-    assert!(doc.cratemod().nmods()[0].fns[0].desc() == Some(~\"test\"));\n-}\n-\n-#[test]\n-fn should_extract_fn_attributes() {\n-    let doc = test::mk_doc(~\"#[doc = \\\"test\\\"] fn a() -> int { }\");\n-    assert!(doc.cratemod().fns()[0].desc() == Some(~\"test\"));\n-}\n-\n fn fold_enum(\n     fold: &fold::Fold<astsrv::Srv>,\n     doc: doc::EnumDoc\n@@ -174,8 +144,8 @@ fn fold_enum(\n                         }\n                         _ => {\n                             fail!(fmt!(\"Enum variant %s has id that's \\\n-                                       not bound to an enum item\",\n-                                      variant.name))\n+                                        not bound to an enum item\",\n+                                       variant.name))\n                         }\n                     }\n                 }\n@@ -190,19 +160,6 @@ fn fold_enum(\n     }\n }\n \n-#[test]\n-fn should_extract_enum_docs() {\n-    let doc = test::mk_doc(~\"#[doc = \\\"b\\\"]\\\n-                            enum a { v }\");\n-    assert!(doc.cratemod().enums()[0].desc() == Some(~\"b\"));\n-}\n-\n-#[test]\n-fn should_extract_variant_docs() {\n-    let doc = test::mk_doc(~\"enum a { #[doc = \\\"c\\\"] v }\");\n-    assert!(doc.cratemod().enums()[0].variants[0].desc == Some(~\"c\"));\n-}\n-\n fn fold_trait(\n     fold: &fold::Fold<astsrv::Srv>,\n     doc: doc::TraitDoc\n@@ -225,30 +182,30 @@ fn merge_method_attrs(\n     // Create an assoc list from method name to attributes\n     let attrs: ~[(~str, Option<~str>)] = do astsrv::exec(srv) |ctxt| {\n         match *ctxt.ast_map.get(&item_id) {\n-          ast_map::node_item(@ast::item {\n-            node: ast::item_trait(_, _, ref methods), _\n-          }, _) => {\n-            vec::map(*methods, |method| {\n-                match copy *method {\n-                  ast::required(ty_m) => {\n-                    (to_str(ty_m.ident),\n-                     attr_parser::parse_desc(copy ty_m.attrs))\n-                  }\n-                  ast::provided(m) => {\n-                    (to_str(m.ident), attr_parser::parse_desc(copy m.attrs))\n-                  }\n-                }\n-            })\n-          }\n-          ast_map::node_item(@ast::item {\n-            node: ast::item_impl(_, _, _, ref methods), _\n-          }, _) => {\n-            vec::map(*methods, |method| {\n-                (to_str(method.ident),\n-                 attr_parser::parse_desc(copy method.attrs))\n-            })\n-          }\n-          _ => fail!(~\"unexpected item\")\n+            ast_map::node_item(@ast::item {\n+                node: ast::item_trait(_, _, ref methods), _\n+            }, _) => {\n+                vec::map(*methods, |method| {\n+                    match copy *method {\n+                        ast::required(ty_m) => {\n+                            (to_str(ty_m.ident),\n+                             attr_parser::parse_desc(copy ty_m.attrs))\n+                        }\n+                        ast::provided(m) => {\n+                            (to_str(m.ident), attr_parser::parse_desc(copy m.attrs))\n+                        }\n+                    }\n+                })\n+            }\n+            ast_map::node_item(@ast::item {\n+                node: ast::item_impl(_, _, _, ref methods), _\n+            }, _) => {\n+                vec::map(*methods, |method| {\n+                    (to_str(method.ident),\n+                     attr_parser::parse_desc(copy method.attrs))\n+                })\n+            }\n+            _ => fail!(~\"unexpected item\")\n         }\n     };\n \n@@ -263,22 +220,6 @@ fn merge_method_attrs(\n     }\n }\n \n-#[test]\n-fn should_extract_trait_docs() {\n-    let doc = test::mk_doc(~\"#[doc = \\\"whatever\\\"] trait i { fn a(); }\");\n-    assert!(doc.cratemod().traits()[0].desc() == Some(~\"whatever\"));\n-}\n-\n-#[test]\n-fn should_extract_trait_method_docs() {\n-    let doc = test::mk_doc(\n-        ~\"trait i {\\\n-         #[doc = \\\"desc\\\"]\\\n-         fn f(a: bool) -> bool;\\\n-         }\");\n-    assert!(doc.cratemod().traits()[0].methods[0].desc == Some(~\"desc\"));\n-}\n-\n \n fn fold_impl(\n     fold: &fold::Fold<astsrv::Srv>,\n@@ -293,34 +234,94 @@ fn fold_impl(\n     }\n }\n \n-#[test]\n-fn should_extract_impl_docs() {\n-    let doc = test::mk_doc(\n-        ~\"#[doc = \\\"whatever\\\"] impl int { fn a() { } }\");\n-    assert!(doc.cratemod().impls()[0].desc() == Some(~\"whatever\"));\n-}\n-\n-#[test]\n-fn should_extract_impl_method_docs() {\n-    let doc = test::mk_doc(\n-        ~\"impl int {\\\n-         #[doc = \\\"desc\\\"]\\\n-         fn f(a: bool) -> bool { }\\\n-         }\");\n-    assert!(doc.cratemod().impls()[0].methods[0].desc == Some(~\"desc\"));\n-}\n-\n #[cfg(test)]\n mod test {\n     use astsrv;\n     use attr_pass::run;\n     use doc;\n     use extract;\n+    use core::prelude::*;\n \n-    pub fn mk_doc(source: ~str) -> doc::Doc {\n+    fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(copy source) |srv| {\n             let doc = extract::from_srv(srv.clone(), ~\"\");\n             run(srv.clone(), doc)\n         }\n     }\n+\n+    #[test]\n+    fn should_replace_top_module_name_with_crate_name() {\n+        let doc = mk_doc(~\"#[link(name = \\\"bond\\\")];\");\n+        assert!(doc.cratemod().name() == ~\"bond\");\n+    }\n+\n+    #[test]\n+    fn should_should_extract_mod_attributes() {\n+        let doc = mk_doc(~\"#[doc = \\\"test\\\"] mod a { }\");\n+        assert!(doc.cratemod().mods()[0].desc() == Some(~\"test\"));\n+    }\n+\n+    #[test]\n+    fn should_extract_top_mod_attributes() {\n+        let doc = mk_doc(~\"#[doc = \\\"test\\\"];\");\n+        assert!(doc.cratemod().desc() == Some(~\"test\"));\n+    }\n+\n+    #[test]\n+    fn should_extract_foreign_fn_attributes() {\n+        let doc = mk_doc(~\"extern { #[doc = \\\"test\\\"] fn a(); }\");\n+        assert!(doc.cratemod().nmods()[0].fns[0].desc() == Some(~\"test\"));\n+    }\n+\n+    #[test]\n+    fn should_extract_fn_attributes() {\n+        let doc = mk_doc(~\"#[doc = \\\"test\\\"] fn a() -> int { }\");\n+        assert!(doc.cratemod().fns()[0].desc() == Some(~\"test\"));\n+    }\n+\n+    #[test]\n+    fn should_extract_enum_docs() {\n+        let doc = mk_doc(~\"#[doc = \\\"b\\\"]\\\n+                                 enum a { v }\");\n+        assert!(doc.cratemod().enums()[0].desc() == Some(~\"b\"));\n+    }\n+\n+    #[test]\n+    fn should_extract_variant_docs() {\n+        let doc = mk_doc(~\"enum a { #[doc = \\\"c\\\"] v }\");\n+        assert!(doc.cratemod().enums()[0].variants[0].desc == Some(~\"c\"));\n+    }\n+\n+    #[test]\n+    fn should_extract_trait_docs() {\n+        let doc = mk_doc(~\"#[doc = \\\"whatever\\\"] trait i { fn a(); }\");\n+        assert!(doc.cratemod().traits()[0].desc() == Some(~\"whatever\"));\n+    }\n+\n+    #[test]\n+    fn should_extract_trait_method_docs() {\n+        let doc = mk_doc(\n+            ~\"trait i {\\\n+              #[doc = \\\"desc\\\"]\\\n+              fn f(a: bool) -> bool;\\\n+              }\");\n+        assert!(doc.cratemod().traits()[0].methods[0].desc == Some(~\"desc\"));\n+    }\n+\n+    #[test]\n+    fn should_extract_impl_docs() {\n+        let doc = mk_doc(\n+            ~\"#[doc = \\\"whatever\\\"] impl int { fn a() { } }\");\n+        assert!(doc.cratemod().impls()[0].desc() == Some(~\"whatever\"));\n+    }\n+\n+    #[test]\n+    fn should_extract_impl_method_docs() {\n+        let doc = mk_doc(\n+            ~\"impl int {\\\n+              #[doc = \\\"desc\\\"]\\\n+              fn f(a: bool) -> bool { }\\\n+              }\");\n+        assert!(doc.cratemod().impls()[0].methods[0].desc == Some(~\"desc\"));\n+    }\n }"}, {"sha": "ed1a54c49a731ab07f5f0e2afa41d40e37ab92c7", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 119, "deletions": 119, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -209,7 +209,7 @@ fn parse_output_style(output_style: &str) -> Result<OutputStyle, ~str> {\n     }\n }\n \n-fn maybe_find_pandoc(\n+pub fn maybe_find_pandoc(\n     config: &Config,\n     maybe_pandoc_cmd: Option<~str>,\n     program_output: Process\n@@ -243,140 +243,140 @@ fn maybe_find_pandoc(\n     }\n }\n \n-#[test]\n-fn should_find_pandoc() {\n-    let config = Config {\n-        output_format: PandocHtml,\n-        .. default_config(&Path(\"test\"))\n-    };\n-    let mock_program_output: ~fn(&str, &[~str]) -> ProgramOutput = |_, _| {\n-        ProgramOutput { status: 0, out: ~\"pandoc 1.8.2.1\", err: ~\"\" }\n-    };\n-    let result = maybe_find_pandoc(&config, None, mock_program_output);\n-    assert!(result == result::Ok(Some(~\"pandoc\")));\n-}\n-\n-#[test]\n-fn should_error_with_no_pandoc() {\n-    let config = Config {\n-        output_format: PandocHtml,\n-        .. default_config(&Path(\"test\"))\n-    };\n-    let mock_program_output: ~fn(&str, &[~str]) -> ProgramOutput = |_, _| {\n-        ProgramOutput { status: 1, out: ~\"\", err: ~\"\" }\n-    };\n-    let result = maybe_find_pandoc(&config, None, mock_program_output);\n-    assert!(result == result::Err(~\"couldn't find pandoc\"));\n-}\n-\n #[cfg(test)]\n mod test {\n-    use config::{Config, mock_program_output, parse_config_};\n-\n-    use core::result::Result;\n+    use config::*;\n+    use core::prelude::*;\n+    use core::run::ProgramOutput;\n \n-    pub fn parse_config(args: &[~str]) -> Result<Config, ~str> {\n+    fn parse_config(args: &[~str]) -> Result<Config, ~str> {\n         parse_config_(args, mock_program_output)\n     }\n-}\n \n-#[test]\n-fn should_error_with_no_crates() {\n-    let config = test::parse_config(~[~\"rustdoc\"]);\n-    assert!(config.get_err() == ~\"no crates specified\");\n-}\n+    #[test]\n+    fn should_find_pandoc() {\n+        let config = Config {\n+            output_format: PandocHtml,\n+            .. default_config(&Path(\"test\"))\n+        };\n+        let mock_program_output: ~fn(&str, &[~str]) -> ProgramOutput = |_, _| {\n+            ProgramOutput { status: 0, out: ~\"pandoc 1.8.2.1\", err: ~\"\" }\n+        };\n+        let result = maybe_find_pandoc(&config, None, mock_program_output);\n+        assert!(result == result::Ok(Some(~\"pandoc\")));\n+    }\n \n-#[test]\n-fn should_error_with_multiple_crates() {\n-    let config =\n-        test::parse_config(~[~\"rustdoc\", ~\"crate1.rc\", ~\"crate2.rc\"]);\n-    assert!(config.get_err() == ~\"multiple crates specified\");\n-}\n+    #[test]\n+    fn should_error_with_no_pandoc() {\n+        let config = Config {\n+            output_format: PandocHtml,\n+            .. default_config(&Path(\"test\"))\n+        };\n+        let mock_program_output: ~fn(&str, &[~str]) -> ProgramOutput = |_, _| {\n+            ProgramOutput { status: 1, out: ~\"\", err: ~\"\" }\n+        };\n+        let result = maybe_find_pandoc(&config, None, mock_program_output);\n+        assert!(result == result::Err(~\"couldn't find pandoc\"));\n+    }\n \n-#[test]\n-fn should_set_output_dir_to_cwd_if_not_provided() {\n-    let config = test::parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n-    assert!(config.get().output_dir == Path(\".\"));\n-}\n+    #[test]\n+    fn should_error_with_no_crates() {\n+        let config = parse_config(~[~\"rustdoc\"]);\n+        assert!(config.get_err() == ~\"no crates specified\");\n+    }\n \n-#[test]\n-fn should_set_output_dir_if_provided() {\n-    let config = test::parse_config(~[\n-        ~\"rustdoc\", ~\"crate.rc\", ~\"--output-dir\", ~\"snuggles\"\n-    ]);\n-    assert!(config.get().output_dir == Path(\"snuggles\"));\n-}\n+    #[test]\n+    fn should_error_with_multiple_crates() {\n+        let config =\n+            parse_config(~[~\"rustdoc\", ~\"crate1.rc\", ~\"crate2.rc\"]);\n+        assert!(config.get_err() == ~\"multiple crates specified\");\n+    }\n \n-#[test]\n-fn should_set_output_format_to_pandoc_html_if_not_provided() {\n-    let config = test::parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n-    assert!(config.get().output_format == PandocHtml);\n-}\n+    #[test]\n+    fn should_set_output_dir_to_cwd_if_not_provided() {\n+        let config = parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n+        assert!(config.get().output_dir == Path(\".\"));\n+    }\n \n-#[test]\n-fn should_set_output_format_to_markdown_if_requested() {\n-    let config = test::parse_config(~[\n-        ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"markdown\"\n-    ]);\n-    assert!(config.get().output_format == Markdown);\n-}\n+    #[test]\n+    fn should_set_output_dir_if_provided() {\n+        let config = parse_config(~[\n+            ~\"rustdoc\", ~\"crate.rc\", ~\"--output-dir\", ~\"snuggles\"\n+        ]);\n+        assert!(config.get().output_dir == Path(\"snuggles\"));\n+    }\n \n-#[test]\n-fn should_set_output_format_to_pandoc_html_if_requested() {\n-    let config = test::parse_config(~[\n-        ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"html\"\n-    ]);\n-    assert!(config.get().output_format == PandocHtml);\n-}\n+    #[test]\n+    fn should_set_output_format_to_pandoc_html_if_not_provided() {\n+        let config = parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n+        assert!(config.get().output_format == PandocHtml);\n+    }\n \n-#[test]\n-fn should_error_on_bogus_format() {\n-    let config = test::parse_config(~[\n-        ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"bogus\"\n-    ]);\n-    assert!(config.get_err() == ~\"unknown output format 'bogus'\");\n-}\n+    #[test]\n+    fn should_set_output_format_to_markdown_if_requested() {\n+        let config = parse_config(~[\n+            ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"markdown\"\n+        ]);\n+        assert!(config.get().output_format == Markdown);\n+    }\n \n-#[test]\n-fn should_set_output_style_to_doc_per_mod_by_default() {\n-    let config = test::parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n-    assert!(config.get().output_style == DocPerMod);\n-}\n+    #[test]\n+    fn should_set_output_format_to_pandoc_html_if_requested() {\n+        let config = parse_config(~[\n+            ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"html\"\n+        ]);\n+        assert!(config.get().output_format == PandocHtml);\n+    }\n \n-#[test]\n-fn should_set_output_style_to_one_doc_if_requested() {\n-    let config = test::parse_config(~[\n-        ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"doc-per-crate\"\n-    ]);\n-    assert!(config.get().output_style == DocPerCrate);\n-}\n+    #[test]\n+    fn should_error_on_bogus_format() {\n+        let config = parse_config(~[\n+            ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"bogus\"\n+        ]);\n+        assert!(config.get_err() == ~\"unknown output format 'bogus'\");\n+    }\n \n-#[test]\n-fn should_set_output_style_to_doc_per_mod_if_requested() {\n-    let config = test::parse_config(~[\n-        ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"doc-per-mod\"\n-    ]);\n-    assert!(config.get().output_style == DocPerMod);\n-}\n+    #[test]\n+    fn should_set_output_style_to_doc_per_mod_by_default() {\n+        let config = parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n+        assert!(config.get().output_style == DocPerMod);\n+    }\n \n-#[test]\n-fn should_error_on_bogus_output_style() {\n-    let config = test::parse_config(~[\n-        ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"bogus\"\n-    ]);\n-    assert!(config.get_err() == ~\"unknown output style 'bogus'\");\n-}\n+    #[test]\n+    fn should_set_output_style_to_one_doc_if_requested() {\n+        let config = parse_config(~[\n+            ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"doc-per-crate\"\n+        ]);\n+        assert!(config.get().output_style == DocPerCrate);\n+    }\n \n-#[test]\n-fn should_set_pandoc_command_if_requested() {\n-    let config = test::parse_config(~[\n-        ~\"rustdoc\", ~\"crate.rc\", ~\"--pandoc-cmd\", ~\"panda-bear-doc\"\n-    ]);\n-    assert!(config.get().pandoc_cmd == Some(~\"panda-bear-doc\"));\n-}\n+    #[test]\n+    fn should_set_output_style_to_doc_per_mod_if_requested() {\n+        let config = parse_config(~[\n+            ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"doc-per-mod\"\n+        ]);\n+        assert!(config.get().output_style == DocPerMod);\n+    }\n \n-#[test]\n-fn should_set_pandoc_command_when_using_pandoc() {\n-    let config = test::parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n-    assert!(config.get().pandoc_cmd == Some(~\"pandoc\"));\n-}\n+    #[test]\n+    fn should_error_on_bogus_output_style() {\n+        let config = parse_config(~[\n+            ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"bogus\"\n+        ]);\n+        assert!(config.get_err() == ~\"unknown output style 'bogus'\");\n+    }\n+\n+    #[test]\n+    fn should_set_pandoc_command_if_requested() {\n+        let config = parse_config(~[\n+            ~\"rustdoc\", ~\"crate.rc\", ~\"--pandoc-cmd\", ~\"panda-bear-doc\"\n+        ]);\n+        assert!(config.get().pandoc_cmd == Some(~\"panda-bear-doc\"));\n+    }\n+\n+    #[test]\n+    fn should_set_pandoc_command_when_using_pandoc() {\n+        let config = parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n+        assert!(config.get().pandoc_cmd == Some(~\"pandoc\"));\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "5027b24435599b279b684f8a2ed7ffbbe052700a", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 82, "deletions": 81, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -81,44 +81,7 @@ fn fold_impl(fold: &fold::Fold<()>, doc: doc::ImplDoc) -> doc::ImplDoc {\n     }\n }\n \n-#[test]\n-fn should_promote_desc() {\n-    let doc = test::mk_doc(~\"#[doc = \\\"desc\\\"] mod m { }\");\n-    assert!(doc.cratemod().mods()[0].brief() == Some(~\"desc\"));\n-}\n-\n-#[test]\n-fn should_promote_trait_method_desc() {\n-    let doc = test::mk_doc(~\"trait i { #[doc = \\\"desc\\\"] fn a(); }\");\n-    assert!(doc.cratemod().traits()[0].methods[0].brief ==\n-        Some(~\"desc\"));\n-}\n-\n-#[test]\n-fn should_promote_impl_method_desc() {\n-    let doc = test::mk_doc(\n-        ~\"impl int { #[doc = \\\"desc\\\"] fn a() { } }\");\n-    assert!(doc.cratemod().impls()[0].methods[0].brief == Some(~\"desc\"));\n-}\n-\n-#[cfg(test)]\n-pub mod test {\n-    use astsrv;\n-    use attr_pass;\n-    use desc_to_brief_pass::run;\n-    use doc;\n-    use extract;\n-\n-    pub fn mk_doc(source: ~str) -> doc::Doc {\n-        do astsrv::from_str(copy source) |srv| {\n-            let doc = extract::from_srv(srv.clone(), ~\"\");\n-            let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n-            run(srv.clone(), doc)\n-        }\n-    }\n-}\n-\n-fn extract(desc: Option<~str>) -> Option<~str> {\n+pub fn extract(desc: Option<~str>) -> Option<~str> {\n     if desc.is_none() {\n         return None\n     }\n@@ -182,7 +145,7 @@ fn first_sentence_(s: &str) -> ~str {\n     }\n }\n \n-fn paragraphs(s: &str) -> ~[~str] {\n+pub fn paragraphs(s: &str) -> ~[~str] {\n     let mut lines = ~[];\n     for str::each_line_any(s) |line| { lines.push(line.to_owned()); }\n     let mut whitespace_lines = 0;\n@@ -219,80 +182,118 @@ fn paragraphs(s: &str) -> ~[~str] {\n     }\n }\n \n-#[test]\n-fn test_paragraphs_1() {\n-    let paras = paragraphs(~\"1\\n\\n2\");\n-    assert!(paras == ~[~\"1\", ~\"2\"]);\n-}\n+#[cfg(test)]\n+mod test {\n+    use astsrv;\n+    use attr_pass;\n+    use super::{extract, paragraphs, run};\n+    use doc;\n+    use extract;\n+    use core::prelude::*;\n \n-#[test]\n-fn test_paragraphs_2() {\n-    let paras = paragraphs(~\"\\n\\n1\\n1\\n\\n2\\n\\n\");\n-    assert!(paras == ~[~\"1\\n1\", ~\"2\"]);\n-}\n+    fn mk_doc(source: ~str) -> doc::Doc {\n+        do astsrv::from_str(copy source) |srv| {\n+            let doc = extract::from_srv(srv.clone(), ~\"\");\n+            let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n+            run(srv.clone(), doc)\n+        }\n+    }\n \n-#[test]\n-fn should_promote_short_descs() {\n-    let desc = Some(~\"desc\");\n-    let brief = extract(copy desc);\n-    assert!(brief == desc);\n-}\n+    #[test]\n+    fn should_promote_desc() {\n+        let doc = mk_doc(~\"#[doc = \\\"desc\\\"] mod m { }\");\n+        assert!(doc.cratemod().mods()[0].brief() == Some(~\"desc\"));\n+    }\n+\n+    #[test]\n+    fn should_promote_trait_method_desc() {\n+        let doc = mk_doc(~\"trait i { #[doc = \\\"desc\\\"] fn a(); }\");\n+        assert!(doc.cratemod().traits()[0].methods[0].brief ==\n+                Some(~\"desc\"));\n+    }\n+\n+    #[test]\n+    fn should_promote_impl_method_desc() {\n+        let doc = mk_doc(\n+            ~\"impl int { #[doc = \\\"desc\\\"] fn a() { } }\");\n+        assert!(doc.cratemod().impls()[0].methods[0].brief == Some(~\"desc\"));\n+    }\n \n-#[test]\n-fn should_not_promote_long_descs() {\n-    let desc = Some(~\"Warkworth Castle is a ruined medieval building\n+    #[test]\n+    fn test_paragraphs_1() {\n+        let paras = paragraphs(~\"1\\n\\n2\");\n+        assert!(paras == ~[~\"1\", ~\"2\"]);\n+    }\n+\n+    #[test]\n+    fn test_paragraphs_2() {\n+        let paras = paragraphs(~\"\\n\\n1\\n1\\n\\n2\\n\\n\");\n+        assert!(paras == ~[~\"1\\n1\", ~\"2\"]);\n+    }\n+\n+    #[test]\n+    fn should_promote_short_descs() {\n+        let desc = Some(~\"desc\");\n+        let brief = extract(copy desc);\n+        assert!(brief == desc);\n+    }\n+\n+    #[test]\n+    fn should_not_promote_long_descs() {\n+        let desc = Some(~\"Warkworth Castle is a ruined medieval building\n in the town of the same name in the English county of Northumberland,\n and the town and castle occupy a loop of the River Coquet, less than a mile\n from England's north-east coast. When the castle was founded is uncertain,\n but traditionally its construction has been ascribed to Prince Henry of\n Scotland in the mid 12th century, although it may have been built by\n King Henry II of England when he took control of England'snorthern\n counties.\");\n-    let brief = extract(desc);\n-    assert!(brief == None);\n-}\n+        let brief = extract(desc);\n+        assert!(brief == None);\n+    }\n \n-#[test]\n-fn should_promote_first_sentence() {\n-    let desc = Some(~\"Warkworth Castle is a ruined medieval building\n+    #[test]\n+    fn should_promote_first_sentence() {\n+        let desc = Some(~\"Warkworth Castle is a ruined medieval building\n in the town. of the same name in the English county of Northumberland,\n and the town and castle occupy a loop of the River Coquet, less than a mile\n from England's north-east coast. When the castle was founded is uncertain,\n but traditionally its construction has been ascribed to Prince Henry of\n Scotland in the mid 12th century, although it may have been built by\n King Henry II of England when he took control of England'snorthern\n counties.\");\n-    let brief = extract(desc);\n-    assert!(brief == Some(\n-        ~\"Warkworth Castle is a ruined medieval building in the town\"));\n-}\n+        let brief = extract(desc);\n+        assert!(brief == Some(\n+            ~\"Warkworth Castle is a ruined medieval building in the town\"));\n+    }\n \n-#[test]\n-fn should_not_consider_double_period_to_end_sentence() {\n-    let desc = Some(~\"Warkworth..Castle is a ruined medieval building\n+    #[test]\n+    fn should_not_consider_double_period_to_end_sentence() {\n+        let desc = Some(~\"Warkworth..Castle is a ruined medieval building\n in the town. of the same name in the English county of Northumberland,\n and the town and castle occupy a loop of the River Coquet, less than a mile\n from England's north-east coast. When the castle was founded is uncertain,\n but traditionally its construction has been ascribed to Prince Henry of\n Scotland in the mid 12th century, although it may have been built by\n King Henry II of England when he took control of England'snorthern\n counties.\");\n-    let brief = extract(desc);\n-    assert!(brief == Some(\n-        ~\"Warkworth..Castle is a ruined medieval building in the town\"));\n-}\n+        let brief = extract(desc);\n+        assert!(brief == Some(\n+            ~\"Warkworth..Castle is a ruined medieval building in the town\"));\n+    }\n \n-#[test]\n-fn should_not_consider_triple_period_to_end_sentence() {\n-    let desc = Some(~\"Warkworth... Castle is a ruined medieval building\n+    #[test]\n+    fn should_not_consider_triple_period_to_end_sentence() {\n+        let desc = Some(~\"Warkworth... Castle is a ruined medieval building\n in the town. of the same name in the English county of Northumberland,\n and the town and castle occupy a loop of the River Coquet, less than a mile\n from England's north-east coast. When the castle was founded is uncertain,\n but traditionally its construction has been ascribed to Prince Henry of\n Scotland in the mid 12th century, although it may have been built by\n King Henry II of England when he took control of England'snorthern\n counties.\");\n-    let brief = extract(desc);\n-    assert!(brief == Some(\n-        ~\"Warkworth... Castle is a ruined medieval building in the town\"));\n+        let brief = extract(desc);\n+        assert!(brief == Some(\n+            ~\"Warkworth... Castle is a ruined medieval building in the town\"));\n+    }\n }"}, {"sha": "fa3f7d64324899f3875ebff0179190801adf2c5a", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -182,13 +182,6 @@ fn constdoc_from_const(itemdoc: doc::ItemDoc) -> doc::ConstDoc {\n     }\n }\n \n-#[test]\n-fn should_extract_const_name_and_id() {\n-    let doc = test::mk_doc(~\"static a: int = 0;\");\n-    assert!(doc.cratemod().consts()[0].id() != 0);\n-    assert!(doc.cratemod().consts()[0].name() == ~\"a\");\n-}\n-\n fn enumdoc_from_enum(\n     itemdoc: doc::ItemDoc,\n     variants: ~[ast::variant]\n@@ -213,19 +206,6 @@ fn variantdoc_from_variant(variant: &ast::variant) -> doc::VariantDoc {\n     }\n }\n \n-#[test]\n-fn should_extract_enums() {\n-    let doc = test::mk_doc(~\"enum e { v }\");\n-    assert!(doc.cratemod().enums()[0].id() != 0);\n-    assert!(doc.cratemod().enums()[0].name() == ~\"e\");\n-}\n-\n-#[test]\n-fn should_extract_enum_variants() {\n-    let doc = test::mk_doc(~\"enum e { v }\");\n-    assert!(doc.cratemod().enums()[0].variants[0].name == ~\"v\");\n-}\n-\n fn traitdoc_from_trait(\n     itemdoc: doc::ItemDoc,\n     methods: ~[ast::trait_method]\n@@ -259,18 +239,6 @@ fn traitdoc_from_trait(\n     }\n }\n \n-#[test]\n-fn should_extract_traits() {\n-    let doc = test::mk_doc(~\"trait i { fn f(); }\");\n-    assert!(doc.cratemod().traits()[0].name() == ~\"i\");\n-}\n-\n-#[test]\n-fn should_extract_trait_methods() {\n-    let doc = test::mk_doc(~\"trait i { fn f(); }\");\n-    assert!(doc.cratemod().traits()[0].methods[0].name == ~\"f\");\n-}\n-\n fn impldoc_from_impl(\n     itemdoc: doc::ItemDoc,\n     methods: ~[@ast::method]\n@@ -293,12 +261,6 @@ fn impldoc_from_impl(\n     }\n }\n \n-#[test]\n-fn should_extract_impl_methods() {\n-    let doc = test::mk_doc(~\"impl int { fn f() { } }\");\n-    assert!(doc.cratemod().impls()[0].methods[0].name == ~\"f\");\n-}\n-\n fn tydoc_from_ty(\n     itemdoc: doc::ItemDoc\n ) -> doc::TyDoc {\n@@ -308,12 +270,6 @@ fn tydoc_from_ty(\n     }\n }\n \n-#[test]\n-fn should_extract_tys() {\n-    let doc = test::mk_doc(~\"type a = int;\");\n-    assert!(doc.cratemod().types()[0].name() == ~\"a\");\n-}\n-\n fn structdoc_from_struct(\n     itemdoc: doc::ItemDoc,\n     struct_def: @ast::struct_def\n@@ -330,18 +286,6 @@ fn structdoc_from_struct(\n     }\n }\n \n-#[test]\n-fn should_extract_structs() {\n-    let doc = test::mk_doc(~\"struct Foo { field: () }\");\n-    assert!(doc.cratemod().structs()[0].name() == ~\"Foo\");\n-}\n-\n-#[test]\n-fn should_extract_struct_fields() {\n-    let doc = test::mk_doc(~\"struct Foo { field: () }\");\n-    assert!(doc.cratemod().structs()[0].fields[0] == ~\"field\");\n-}\n-\n #[cfg(test)]\n mod test {\n     use astsrv;\n@@ -351,47 +295,47 @@ mod test {\n \n     use core::vec;\n \n-    pub fn mk_doc(source: ~str) -> doc::Doc {\n+    fn mk_doc(source: ~str) -> doc::Doc {\n         let ast = parse::from_str(source);\n         extract(ast, ~\"\")\n     }\n \n     #[test]\n-    pub fn extract_empty_crate() {\n+    fn extract_empty_crate() {\n         let doc = mk_doc(~\"\");\n         assert!(vec::is_empty(doc.cratemod().mods()));\n         assert!(vec::is_empty(doc.cratemod().fns()));\n     }\n \n     #[test]\n-    pub fn extract_mods() {\n+    fn extract_mods() {\n         let doc = mk_doc(~\"mod a { mod b { } mod c { } }\");\n         assert!(doc.cratemod().mods()[0].name() == ~\"a\");\n         assert!(doc.cratemod().mods()[0].mods()[0].name() == ~\"b\");\n         assert!(doc.cratemod().mods()[0].mods()[1].name() == ~\"c\");\n     }\n \n     #[test]\n-    pub fn extract_fns_from_foreign_mods() {\n+    fn extract_fns_from_foreign_mods() {\n         let doc = mk_doc(~\"extern { fn a(); }\");\n         assert!(doc.cratemod().nmods()[0].fns[0].name() == ~\"a\");\n     }\n \n     #[test]\n-    pub fn extract_mods_deep() {\n+    fn extract_mods_deep() {\n         let doc = mk_doc(~\"mod a { mod b { mod c { } } }\");\n         assert!(doc.cratemod().mods()[0].mods()[0].mods()[0].name() ==\n             ~\"c\");\n     }\n \n     #[test]\n-    pub fn extract_should_set_mod_ast_id() {\n+    fn extract_should_set_mod_ast_id() {\n         let doc = mk_doc(~\"mod a { }\");\n         assert!(doc.cratemod().mods()[0].id() != 0);\n     }\n \n     #[test]\n-    pub fn extract_fns() {\n+    fn extract_fns() {\n         let doc = mk_doc(\n             ~\"fn a() { } \\\n               mod b { fn c() {\n@@ -401,25 +345,81 @@ mod test {\n     }\n \n     #[test]\n-    pub fn extract_should_set_fn_ast_id() {\n+    fn extract_should_set_fn_ast_id() {\n         let doc = mk_doc(~\"fn a() { }\");\n         assert!(doc.cratemod().fns()[0].id() != 0);\n     }\n \n     #[test]\n-    pub fn extract_should_use_default_crate_name() {\n+    fn extract_should_use_default_crate_name() {\n         let source = ~\"\";\n         let ast = parse::from_str(source);\n         let doc = extract(ast, ~\"burp\");\n         assert!(doc.cratemod().name() == ~\"burp\");\n     }\n \n     #[test]\n-    pub fn extract_from_seq_srv() {\n+    fn extract_from_seq_srv() {\n         let source = ~\"\";\n         do astsrv::from_str(source) |srv| {\n             let doc = from_srv(srv, ~\"name\");\n             assert!(doc.cratemod().name() == ~\"name\");\n         }\n     }\n+\n+    #[test]\n+    fn should_extract_const_name_and_id() {\n+        let doc = mk_doc(~\"static a: int = 0;\");\n+        assert!(doc.cratemod().consts()[0].id() != 0);\n+        assert!(doc.cratemod().consts()[0].name() == ~\"a\");\n+    }\n+\n+    #[test]\n+    fn should_extract_enums() {\n+        let doc = mk_doc(~\"enum e { v }\");\n+        assert!(doc.cratemod().enums()[0].id() != 0);\n+        assert!(doc.cratemod().enums()[0].name() == ~\"e\");\n+    }\n+\n+    #[test]\n+    fn should_extract_enum_variants() {\n+        let doc = mk_doc(~\"enum e { v }\");\n+        assert!(doc.cratemod().enums()[0].variants[0].name == ~\"v\");\n+    }\n+\n+    #[test]\n+    fn should_extract_traits() {\n+        let doc = mk_doc(~\"trait i { fn f(); }\");\n+        assert!(doc.cratemod().traits()[0].name() == ~\"i\");\n+    }\n+\n+    #[test]\n+    fn should_extract_trait_methods() {\n+        let doc = mk_doc(~\"trait i { fn f(); }\");\n+        assert!(doc.cratemod().traits()[0].methods[0].name == ~\"f\");\n+    }\n+\n+    #[test]\n+    fn should_extract_impl_methods() {\n+        let doc = mk_doc(~\"impl int { fn f() { } }\");\n+        assert!(doc.cratemod().impls()[0].methods[0].name == ~\"f\");\n+    }\n+\n+    #[test]\n+    fn should_extract_tys() {\n+        let doc = mk_doc(~\"type a = int;\");\n+        assert!(doc.cratemod().types()[0].name() == ~\"a\");\n+    }\n+\n+    #[test]\n+    fn should_extract_structs() {\n+        let doc = mk_doc(~\"struct Foo { field: () }\");\n+        assert!(doc.cratemod().structs()[0].name() == ~\"Foo\");\n+    }\n+\n+    #[test]\n+    fn should_extract_struct_fields() {\n+        let doc = mk_doc(~\"struct Foo { field: () }\");\n+        assert!(doc.cratemod().structs()[0].fields[0] == ~\"field\");\n+    }\n }"}, {"sha": "866fbba2be87a9d47186f40302d564c01bbd701d", "filename": "src/librustdoc/markdown_index_pass.rs", "status": "modified", "additions": 108, "deletions": 108, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_index_pass.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -115,7 +115,7 @@ fn item_to_entry(\n     }\n }\n \n-fn pandoc_header_id(header: &str) -> ~str {\n+pub fn pandoc_header_id(header: &str) -> ~str {\n \n     // http://johnmacfarlane.net/pandoc/README.html#headers\n \n@@ -162,110 +162,6 @@ fn pandoc_header_id(header: &str) -> ~str {\n     fn maybe_use_section_id(s: &str) -> ~str { s.to_str() }\n }\n \n-#[test]\n-fn should_remove_punctuation_from_headers() {\n-    assert!(pandoc_header_id(~\"impl foo of bar<A>\") ==\n-        ~\"impl-foo-of-bara\");\n-    assert!(pandoc_header_id(~\"impl of num::num for int\")\n-        == ~\"impl-of-numnum-for-int\");\n-    assert!(pandoc_header_id(~\"impl of num::num for int/&\")\n-        == ~\"impl-of-numnum-for-int\");\n-    assert!(pandoc_header_id(~\"impl of num::num for ^int\")\n-        == ~\"impl-of-numnum-for-int\");\n-    assert!(pandoc_header_id(~\"impl for & condvar\")\n-        == ~\"impl-for-condvar\");\n-    assert!(pandoc_header_id(~\"impl of Select<T, U> for (Left, Right)\")\n-                 == ~\"impl-of-selectt-u-for-left-right\");\n-    assert!(pandoc_header_id(~\"impl of Condition<'self, T, U>\")\n-                 == ~\"impl-of-conditionself-t-u\");\n-    assert!(pandoc_header_id(~\"impl of Condition<T: Copy + Clone>\")\n-                 == ~\"impl-of-conditiont-copy-clone\");\n-}\n-\n-#[test]\n-fn should_trim_whitespace_after_removing_punctuation() {\n-    assert!(pandoc_header_id(\"impl foo for ()\") == ~\"impl-foo-for\");\n-}\n-\n-#[test]\n-fn should_index_mod_contents() {\n-    let doc = test::mk_doc(\n-        config::DocPerCrate,\n-        ~\"mod a { } fn b() { }\"\n-    );\n-    assert!((&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n-        kind: ~\"Module\",\n-        name: ~\"a\",\n-        brief: None,\n-        link: ~\"#module-a\"\n-    });\n-    assert!((&doc.cratemod().index).get().entries[1] == doc::IndexEntry {\n-        kind: ~\"Function\",\n-        name: ~\"b\",\n-        brief: None,\n-        link: ~\"#function-b\"\n-    });\n-}\n-\n-#[test]\n-fn should_index_mod_contents_multi_page() {\n-    let doc = test::mk_doc(\n-        config::DocPerMod,\n-        ~\"mod a { } fn b() { }\"\n-    );\n-    assert!((&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n-        kind: ~\"Module\",\n-        name: ~\"a\",\n-        brief: None,\n-        link: ~\"a.html\"\n-    });\n-    assert!((&doc.cratemod().index).get().entries[1] == doc::IndexEntry {\n-        kind: ~\"Function\",\n-        name: ~\"b\",\n-        brief: None,\n-        link: ~\"#function-b\"\n-    });\n-}\n-\n-#[test]\n-fn should_index_foreign_mod_pages() {\n-    let doc = test::mk_doc(\n-        config::DocPerMod,\n-        ~\"extern mod a { }\"\n-    );\n-    assert!((&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n-        kind: ~\"Foreign module\",\n-        name: ~\"a\",\n-        brief: None,\n-        link: ~\"a.html\"\n-    });\n-}\n-\n-#[test]\n-fn should_add_brief_desc_to_index() {\n-    let doc = test::mk_doc(\n-        config::DocPerMod,\n-        ~\"#[doc = \\\"test\\\"] mod a { }\"\n-    );\n-    assert!((&doc.cratemod().index).get().entries[0].brief\n-        == Some(~\"test\"));\n-}\n-\n-#[test]\n-fn should_index_foreign_mod_contents() {\n-    let doc = test::mk_doc(\n-        config::DocPerCrate,\n-        ~\"extern mod a { fn b(); }\"\n-    );\n-    assert!((&doc.cratemod().nmods()[0].index).get().entries[0]\n-        == doc::IndexEntry {\n-        kind: ~\"Function\",\n-        name: ~\"b\",\n-        brief: None,\n-        link: ~\"#function-b\"\n-    });\n-}\n-\n #[cfg(test)]\n mod test {\n     use astsrv;\n@@ -276,10 +172,10 @@ mod test {\n     use extract;\n     use markdown_index_pass::run;\n     use path_pass;\n+    use super::pandoc_header_id;\n+    use core::prelude::*;\n \n-    use core::path::Path;\n-\n-    pub fn mk_doc(output_style: config::OutputStyle, source: ~str)\n+    fn mk_doc(output_style: config::OutputStyle, source: ~str)\n                -> doc::Doc {\n         do astsrv::from_str(source) |srv| {\n             let config = config::Config {\n@@ -293,4 +189,108 @@ mod test {\n             run(srv.clone(), doc, config)\n         }\n     }\n+\n+    #[test]\n+    fn should_remove_punctuation_from_headers() {\n+        assert!(pandoc_header_id(~\"impl foo of bar<A>\") ==\n+                ~\"impl-foo-of-bara\");\n+        assert!(pandoc_header_id(~\"impl of num::num for int\")\n+                == ~\"impl-of-numnum-for-int\");\n+        assert!(pandoc_header_id(~\"impl of num::num for int/&\")\n+                == ~\"impl-of-numnum-for-int\");\n+        assert!(pandoc_header_id(~\"impl of num::num for ^int\")\n+                == ~\"impl-of-numnum-for-int\");\n+        assert!(pandoc_header_id(~\"impl for & condvar\")\n+                == ~\"impl-for-condvar\");\n+        assert!(pandoc_header_id(~\"impl of Select<T, U> for (Left, Right)\")\n+                == ~\"impl-of-selectt-u-for-left-right\");\n+        assert!(pandoc_header_id(~\"impl of Condition<'self, T, U>\")\n+                == ~\"impl-of-conditionself-t-u\");\n+        assert!(pandoc_header_id(~\"impl of Condition<T: Copy + Clone>\")\n+                == ~\"impl-of-conditiont-copy-clone\");\n+    }\n+\n+    #[test]\n+    fn should_trim_whitespace_after_removing_punctuation() {\n+        assert!(pandoc_header_id(\"impl foo for ()\") == ~\"impl-foo-for\");\n+    }\n+\n+    #[test]\n+    fn should_index_mod_contents() {\n+        let doc = mk_doc(\n+            config::DocPerCrate,\n+            ~\"mod a { } fn b() { }\"\n+        );\n+        assert!((&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n+            kind: ~\"Module\",\n+            name: ~\"a\",\n+            brief: None,\n+            link: ~\"#module-a\"\n+        });\n+        assert!((&doc.cratemod().index).get().entries[1] == doc::IndexEntry {\n+            kind: ~\"Function\",\n+            name: ~\"b\",\n+            brief: None,\n+            link: ~\"#function-b\"\n+        });\n+    }\n+\n+    #[test]\n+    fn should_index_mod_contents_multi_page() {\n+        let doc = mk_doc(\n+            config::DocPerMod,\n+            ~\"mod a { } fn b() { }\"\n+        );\n+        assert!((&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n+            kind: ~\"Module\",\n+            name: ~\"a\",\n+            brief: None,\n+            link: ~\"a.html\"\n+        });\n+        assert!((&doc.cratemod().index).get().entries[1] == doc::IndexEntry {\n+            kind: ~\"Function\",\n+            name: ~\"b\",\n+            brief: None,\n+            link: ~\"#function-b\"\n+        });\n+    }\n+\n+    #[test]\n+    fn should_index_foreign_mod_pages() {\n+        let doc = mk_doc(\n+            config::DocPerMod,\n+            ~\"extern mod a { }\"\n+        );\n+        assert!((&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n+            kind: ~\"Foreign module\",\n+            name: ~\"a\",\n+            brief: None,\n+            link: ~\"a.html\"\n+        });\n+    }\n+\n+    #[test]\n+    fn should_add_brief_desc_to_index() {\n+        let doc = mk_doc(\n+            config::DocPerMod,\n+            ~\"#[doc = \\\"test\\\"] mod a { }\"\n+        );\n+        assert!((&doc.cratemod().index).get().entries[0].brief\n+                == Some(~\"test\"));\n+    }\n+\n+    #[test]\n+    fn should_index_foreign_mod_contents() {\n+        let doc = mk_doc(\n+            config::DocPerCrate,\n+            ~\"extern mod a { fn b(); }\"\n+        );\n+        assert!((&doc.cratemod().nmods()[0].index).get().entries[0]\n+                == doc::IndexEntry {\n+                    kind: ~\"Function\",\n+                    name: ~\"b\",\n+                    brief: None,\n+                    link: ~\"#function-b\"\n+                });\n+    }\n }"}, {"sha": "2dfc04e8ec7097aa6aa42704816ff23d803619a0", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 457, "deletions": 461, "changes": 918, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -22,10 +22,6 @@ use markdown_writer::WriterFactory;\n use pass::Pass;\n use sort_pass;\n \n-#[cfg(test)] use config;\n-#[cfg(test)] use markdown_writer;\n-#[cfg(test)] use page_pass;\n-\n use core::cell::Cell;\n use core::str;\n use core::vec;\n@@ -48,8 +44,8 @@ fn run(\n     fn mods_last(item1: &doc::ItemTag, item2: &doc::ItemTag) -> bool {\n         fn is_mod(item: &doc::ItemTag) -> bool {\n             match *item {\n-              doc::ModTag(_) => true,\n-              _ => false\n+                doc::ModTag(_) => true,\n+                _ => false\n             }\n         }\n \n@@ -69,33 +65,6 @@ fn run(\n     return doc;\n }\n \n-#[test]\n-fn should_write_modules_last() {\n-    /*\n-    Because the markdown pass writes all modules at the same level of\n-    indentation (it doesn't 'nest' them), we need to make sure that we\n-    write all of the modules contained in each module after all other\n-    types of items, or else the header nesting will end up wrong, with\n-    modules appearing to contain items that they do not.\n-    */\n-    let markdown = test::render(\n-        ~\"mod a { }\\\n-         fn b() { }\\\n-         mod c {\n-         }\\\n-         fn d() { }\"\n-    );\n-\n-    let idx_a = str::find_str(markdown, ~\"# Module `a`\").get();\n-    let idx_b = str::find_str(markdown, ~\"## Function `b`\").get();\n-    let idx_c = str::find_str(markdown, ~\"# Module `c`\").get();\n-    let idx_d = str::find_str(markdown, ~\"## Function `d`\").get();\n-\n-    assert!(idx_b < idx_d);\n-    assert!(idx_d < idx_a);\n-    assert!(idx_a < idx_c);\n-}\n-\n struct Ctxt {\n     w: Writer\n }\n@@ -118,72 +87,37 @@ pub fn write_markdown(\n fn write_page(ctxt: &Ctxt, page: &doc::Page) {\n     write_title(ctxt, copy *page);\n     match copy *page {\n-      doc::CratePage(doc) => {\n-        write_crate(ctxt, doc);\n-      }\n-      doc::ItemPage(doc) => {\n-        // We don't write a header for item's pages because their\n-        // header in the html output is created by the page title\n-        write_item_no_header(ctxt, doc);\n-      }\n+        doc::CratePage(doc) => {\n+            write_crate(ctxt, doc);\n+        }\n+        doc::ItemPage(doc) => {\n+            // We don't write a header for item's pages because their\n+            // header in the html output is created by the page title\n+            write_item_no_header(ctxt, doc);\n+        }\n     }\n     ctxt.w.put_done();\n }\n \n-#[test]\n-fn should_request_new_writer_for_each_page() {\n-    // This port will send us a (page, str) pair for every writer\n-    // that was created\n-    let (writer_factory, po) = markdown_writer::future_writer_factory();\n-    let (srv, doc) = test::create_doc_srv(~\"mod a { }\");\n-    // Split the document up into pages\n-    let doc = (page_pass::mk_pass(config::DocPerMod).f)(srv, doc);\n-    write_markdown(doc, writer_factory);\n-    // We expect two pages to have been written\n-    for iter::repeat(2) {\n-        po.recv();\n-    }\n-}\n-\n fn write_title(ctxt: &Ctxt, page: doc::Page) {\n     ctxt.w.put_line(fmt!(\"%% %s\", make_title(page)));\n     ctxt.w.put_line(~\"\");\n }\n \n fn make_title(page: doc::Page) -> ~str {\n     let item = match page {\n-      doc::CratePage(CrateDoc) => {\n-        doc::ModTag(copy CrateDoc.topmod)\n-      }\n-      doc::ItemPage(ItemTag) => {\n-        ItemTag\n-      }\n+        doc::CratePage(CrateDoc) => {\n+            doc::ModTag(copy CrateDoc.topmod)\n+        }\n+        doc::ItemPage(ItemTag) => {\n+            ItemTag\n+        }\n     };\n     let title = markdown_pass::header_text(item);\n     let title = str::replace(title, ~\"`\", ~\"\");\n     return title;\n }\n \n-#[test]\n-fn should_write_title_for_each_page() {\n-    let (writer_factory, po) = markdown_writer::future_writer_factory();\n-    let (srv, doc) = test::create_doc_srv(\n-        ~\"#[link(name = \\\"core\\\")]; mod a { }\");\n-    let doc = (page_pass::mk_pass(config::DocPerMod).f)(srv, doc);\n-    write_markdown(doc, writer_factory);\n-    for iter::repeat(2) {\n-        let (page, markdown) = po.recv();\n-        match page {\n-          doc::CratePage(_) => {\n-            assert!(str::contains(markdown, ~\"% Crate core\"));\n-          }\n-          doc::ItemPage(_) => {\n-            assert!(str::contains(markdown, ~\"% Module a\"));\n-          }\n-        }\n-    }\n-}\n-\n enum Hlvl {\n     H1 = 1,\n     H2 = 2,\n@@ -204,94 +138,94 @@ fn write_header_(ctxt: &Ctxt, lvl: Hlvl, title: ~str) {\n \n pub fn header_kind(doc: doc::ItemTag) -> ~str {\n     match doc {\n-      doc::ModTag(_) => {\n-        if doc.id() == syntax::ast::crate_node_id {\n-            ~\"Crate\"\n-        } else {\n-            ~\"Module\"\n+        doc::ModTag(_) => {\n+            if doc.id() == syntax::ast::crate_node_id {\n+                ~\"Crate\"\n+            } else {\n+                ~\"Module\"\n+            }\n+        }\n+        doc::NmodTag(_) => {\n+            ~\"Foreign module\"\n+        }\n+        doc::FnTag(_) => {\n+            ~\"Function\"\n+        }\n+        doc::ConstTag(_) => {\n+            ~\"Const\"\n+        }\n+        doc::EnumTag(_) => {\n+            ~\"Enum\"\n+        }\n+        doc::TraitTag(_) => {\n+            ~\"Trait\"\n+        }\n+        doc::ImplTag(_) => {\n+            ~\"Implementation\"\n+        }\n+        doc::TyTag(_) => {\n+            ~\"Type\"\n+        }\n+        doc::StructTag(_) => {\n+            ~\"Struct\"\n         }\n-      }\n-      doc::NmodTag(_) => {\n-        ~\"Foreign module\"\n-      }\n-      doc::FnTag(_) => {\n-        ~\"Function\"\n-      }\n-      doc::ConstTag(_) => {\n-        ~\"Const\"\n-      }\n-      doc::EnumTag(_) => {\n-        ~\"Enum\"\n-      }\n-      doc::TraitTag(_) => {\n-        ~\"Trait\"\n-      }\n-      doc::ImplTag(_) => {\n-        ~\"Implementation\"\n-      }\n-      doc::TyTag(_) => {\n-        ~\"Type\"\n-      }\n-      doc::StructTag(_) => {\n-        ~\"Struct\"\n-      }\n     }\n }\n \n pub fn header_name(doc: doc::ItemTag) -> ~str {\n     let fullpath = str::connect(doc.path() + ~[doc.name()], ~\"::\");\n     match &doc {\n-      &doc::ModTag(_) if doc.id() != syntax::ast::crate_node_id => {\n-        fullpath\n-      }\n-      &doc::NmodTag(_) => {\n-        fullpath\n-      }\n-      &doc::ImplTag(ref doc) => {\n-        assert!(doc.self_ty.is_some());\n-          let bounds = if (&doc.bounds_str).is_some() {\n-              fmt!(\" where %s\", (&doc.bounds_str).get())\n-          } else {\n-              ~\"\"\n-          };\n-        let self_ty = (&doc.self_ty).get();\n-        let mut trait_part = ~\"\";\n-        for doc.trait_types.eachi |i, trait_type| {\n-            if i == 0 {\n-                trait_part += ~\" of \";\n+        &doc::ModTag(_) if doc.id() != syntax::ast::crate_node_id => {\n+            fullpath\n+        }\n+        &doc::NmodTag(_) => {\n+            fullpath\n+        }\n+        &doc::ImplTag(ref doc) => {\n+            assert!(doc.self_ty.is_some());\n+            let bounds = if (&doc.bounds_str).is_some() {\n+                fmt!(\" where %s\", (&doc.bounds_str).get())\n             } else {\n-                trait_part += ~\", \";\n+                ~\"\"\n+            };\n+            let self_ty = (&doc.self_ty).get();\n+            let mut trait_part = ~\"\";\n+            for doc.trait_types.eachi |i, trait_type| {\n+                if i == 0 {\n+                    trait_part += ~\" of \";\n+                } else {\n+                    trait_part += ~\", \";\n+                }\n+                trait_part += *trait_type;\n             }\n-            trait_part += *trait_type;\n+            fmt!(\"%s for %s%s\", trait_part, self_ty, bounds)\n+        }\n+        _ => {\n+            doc.name()\n         }\n-        fmt!(\"%s for %s%s\", trait_part, self_ty, bounds)\n-      }\n-      _ => {\n-        doc.name()\n-      }\n     }\n }\n \n pub fn header_text(doc: doc::ItemTag) -> ~str {\n     match &doc {\n-      &doc::ImplTag(ref ImplDoc) => {\n-        let header_kind = header_kind(copy doc);\n-          let bounds = if (&ImplDoc.bounds_str).is_some() {\n-              fmt!(\" where `%s`\", (&ImplDoc.bounds_str).get())\n-          } else {\n-              ~\"\"\n-          };\n-        let desc = if ImplDoc.trait_types.is_empty() {\n-            fmt!(\"for `%s`%s\", (&ImplDoc.self_ty).get(), bounds)\n-        } else {\n-            fmt!(\"of `%s` for `%s`%s\",\n-                 ImplDoc.trait_types[0],\n-                 (&ImplDoc.self_ty).get(),\n-                 bounds)\n-        };\n-        return fmt!(\"%s %s\", header_kind, desc);\n-      }\n-      _ => {}\n+        &doc::ImplTag(ref ImplDoc) => {\n+            let header_kind = header_kind(copy doc);\n+            let bounds = if (&ImplDoc.bounds_str).is_some() {\n+                fmt!(\" where `%s`\", (&ImplDoc.bounds_str).get())\n+            } else {\n+                ~\"\"\n+            };\n+            let desc = if ImplDoc.trait_types.is_empty() {\n+                fmt!(\"for `%s`%s\", (&ImplDoc.self_ty).get(), bounds)\n+            } else {\n+                fmt!(\"of `%s` for `%s`%s\",\n+                     ImplDoc.trait_types[0],\n+                     (&ImplDoc.self_ty).get(),\n+                     bounds)\n+            };\n+            return fmt!(\"%s %s\", header_kind, desc);\n+        }\n+        _ => {}\n     }\n \n     header_text_(header_kind(copy doc),\n@@ -323,12 +257,6 @@ fn write_mod(\n     write_mod_contents(ctxt, ModDoc);\n }\n \n-#[test]\n-fn should_write_full_path_to_mod() {\n-    let markdown = test::render(~\"mod a { mod b { mod c { } } }\");\n-    assert!(str::contains(markdown, ~\"# Module `a::b::c`\"));\n-}\n-\n fn write_common(\n     ctxt: &Ctxt,\n     desc: Option<~str>,\n@@ -363,17 +291,6 @@ fn write_section(ctxt: &Ctxt, section: doc::Section) {\n     ctxt.w.put_line(~\"\");\n }\n \n-#[test]\n-fn should_write_sections() {\n-    let markdown = test::render(\n-        ~\"#[doc = \\\"\\\n-         # Header\\n\\\n-         Body\\\"]\\\n-         mod a {\n-         }\");\n-    assert!(str::contains(markdown, ~\"#### Header\\n\\nBody\\n\\n\"));\n-}\n-\n fn write_mod_contents(\n     ctxt: &Ctxt,\n     doc: doc::ModDoc\n@@ -402,15 +319,15 @@ fn write_item_(ctxt: &Ctxt, doc: doc::ItemTag, write_header: bool) {\n     }\n \n     match doc {\n-      doc::ModTag(ModDoc) => write_mod(ctxt, ModDoc),\n-      doc::NmodTag(nModDoc) => write_nmod(ctxt, nModDoc),\n-      doc::FnTag(FnDoc) => write_fn(ctxt, FnDoc),\n-      doc::ConstTag(ConstDoc) => write_const(ctxt, ConstDoc),\n-      doc::EnumTag(EnumDoc) => write_enum(ctxt, EnumDoc),\n-      doc::TraitTag(TraitDoc) => write_trait(ctxt, TraitDoc),\n-      doc::ImplTag(ImplDoc) => write_impl(ctxt, ImplDoc),\n-      doc::TyTag(TyDoc) => write_type(ctxt, TyDoc),\n-      doc::StructTag(StructDoc) => put_struct(ctxt, StructDoc),\n+        doc::ModTag(ModDoc) => write_mod(ctxt, ModDoc),\n+        doc::NmodTag(nModDoc) => write_nmod(ctxt, nModDoc),\n+        doc::FnTag(FnDoc) => write_fn(ctxt, FnDoc),\n+        doc::ConstTag(ConstDoc) => write_const(ctxt, ConstDoc),\n+        doc::EnumTag(EnumDoc) => write_enum(ctxt, EnumDoc),\n+        doc::TraitTag(TraitDoc) => write_trait(ctxt, TraitDoc),\n+        doc::ImplTag(ImplDoc) => write_impl(ctxt, ImplDoc),\n+        doc::TyTag(TyDoc) => write_type(ctxt, TyDoc),\n+        doc::StructTag(StructDoc) => put_struct(ctxt, StructDoc),\n     }\n }\n \n@@ -420,17 +337,11 @@ fn write_item_header(ctxt: &Ctxt, doc: doc::ItemTag) {\n \n fn item_header_lvl(doc: &doc::ItemTag) -> Hlvl {\n     match doc {\n-      &doc::ModTag(_) | &doc::NmodTag(_) => H1,\n-      _ => H2\n+        &doc::ModTag(_) | &doc::NmodTag(_) => H1,\n+        _ => H2\n     }\n }\n \n-#[test]\n-fn should_write_crate_description() {\n-    let markdown = test::render(~\"#[doc = \\\"this is the crate\\\"];\");\n-    assert!(str::contains(markdown, ~\"this is the crate\"));\n-}\n-\n fn write_index(ctxt: &Ctxt, index: doc::Index) {\n     if vec::is_empty(index.entries) {\n         return;\n@@ -444,7 +355,7 @@ fn write_index(ctxt: &Ctxt, index: doc::Index) {\n         let id = copy entry.link;\n         if entry.brief.is_some() {\n             ctxt.w.put_line(fmt!(\"* [%s](%s) - %s\",\n-                                   header, id, (&entry.brief).get()));\n+                                 header, id, (&entry.brief).get()));\n         } else {\n             ctxt.w.put_line(fmt!(\"* [%s](%s)\", header, id));\n         }\n@@ -454,37 +365,6 @@ fn write_index(ctxt: &Ctxt, index: doc::Index) {\n     ctxt.w.put_line(~\"\");\n }\n \n-#[test]\n-fn should_write_index() {\n-    let markdown = test::render(~\"mod a { } mod b { }\");\n-    assert!(str::contains(\n-        markdown,\n-        ~\"\\n\\n* [Module `a`](#module-a)\\n\\\n-         * [Module `b`](#module-b)\\n\\n\"\n-    ));\n-}\n-\n-#[test]\n-fn should_write_index_brief() {\n-    let markdown = test::render(~\"#[doc = \\\"test\\\"] mod a { }\");\n-    assert!(str::contains(markdown, ~\"(#module-a) - test\\n\"));\n-}\n-\n-#[test]\n-fn should_not_write_index_if_no_entries() {\n-    let markdown = test::render(~\"\");\n-    assert!(!str::contains(markdown, ~\"\\n\\n\\n\"));\n-}\n-\n-#[test]\n-fn should_write_index_for_foreign_mods() {\n-    let markdown = test::render(~\"extern mod a { fn a(); }\");\n-    assert!(str::contains(\n-        markdown,\n-        ~\"\\n\\n* [Function `a`](#function-a)\\n\\n\"\n-    ));\n-}\n-\n fn write_nmod(ctxt: &Ctxt, doc: doc::NmodDoc) {\n     write_common(ctxt, doc.desc(), doc.sections());\n     if doc.index.is_some() {\n@@ -497,27 +377,6 @@ fn write_nmod(ctxt: &Ctxt, doc: doc::NmodDoc) {\n     }\n }\n \n-#[test]\n-fn should_write_foreign_mods() {\n-    let markdown = test::render(~\"#[doc = \\\"test\\\"] extern mod a { }\");\n-    assert!(str::contains(markdown, ~\"Foreign module `a`\"));\n-    assert!(str::contains(markdown, ~\"test\"));\n-}\n-\n-#[test]\n-fn should_write_foreign_fns() {\n-    let markdown = test::render(\n-        ~\"extern mod a { #[doc = \\\"test\\\"] fn a(); }\");\n-    assert!(str::contains(markdown, ~\"test\"));\n-}\n-\n-#[test]\n-fn should_write_foreign_fn_headers() {\n-    let markdown = test::render(\n-        ~\"extern mod a { #[doc = \\\"test\\\"] fn a(); }\");\n-    assert!(str::contains(markdown, ~\"## Function `a`\"));\n-}\n-\n fn write_fn(\n     ctxt: &Ctxt,\n     doc: doc::FnDoc\n@@ -542,11 +401,11 @@ fn write_fnlike(\n \n fn write_sig(ctxt: &Ctxt, sig: Option<~str>) {\n     match sig {\n-      Some(sig) => {\n-        ctxt.w.put_line(code_block_indent(sig));\n-        ctxt.w.put_line(~\"\");\n-      }\n-      None => fail!(~\"unimplemented\")\n+        Some(sig) => {\n+            ctxt.w.put_line(code_block_indent(sig));\n+            ctxt.w.put_line(~\"\");\n+        }\n+        None => fail!(~\"unimplemented\")\n     }\n }\n \n@@ -558,51 +417,6 @@ fn code_block_indent(s: ~str) -> ~str {\n     str::connect(indented, \"\\n\")\n }\n \n-#[test]\n-fn write_markdown_should_write_function_header() {\n-    let markdown = test::render(~\"fn func() { }\");\n-    assert!(str::contains(markdown, ~\"## Function `func`\"));\n-}\n-\n-#[test]\n-fn should_write_the_function_signature() {\n-    let markdown = test::render(~\"#[doc = \\\"f\\\"] fn a() { }\");\n-    assert!(str::contains(markdown, ~\"\\n    fn a()\\n\"));\n-}\n-\n-#[test]\n-fn should_insert_blank_line_after_fn_signature() {\n-    let markdown = test::render(~\"#[doc = \\\"f\\\"] fn a() { }\");\n-    assert!(str::contains(markdown, ~\"fn a()\\n\\n\"));\n-}\n-\n-#[test]\n-fn should_correctly_indent_fn_signature() {\n-    let doc = test::create_doc(~\"fn a() { }\");\n-    let doc = doc::Doc{\n-        pages: ~[\n-            doc::CratePage(doc::CrateDoc{\n-                topmod: doc::ModDoc{\n-                    items: ~[doc::FnTag(doc::SimpleItemDoc{\n-                        sig: Some(~\"line 1\\nline 2\"),\n-                        .. copy doc.cratemod().fns()[0]\n-                    })],\n-                    .. doc.cratemod()\n-                },\n-                .. doc.CrateDoc()\n-            })\n-        ]\n-    };\n-    let markdown = test::write_markdown_str(doc);\n-    assert!(str::contains(markdown, ~\"    line 1\\n    line 2\"));\n-}\n-\n-#[test]\n-fn should_leave_blank_line_between_fn_header_and_sig() {\n-    let markdown = test::render(~\"fn a() { }\");\n-    assert!(str::contains(markdown, ~\"Function `a`\\n\\n    fn a()\"));\n-}\n-\n fn write_const(\n     ctxt: &Ctxt,\n     doc: doc::ConstDoc\n@@ -611,20 +425,6 @@ fn write_const(\n     write_common(ctxt, doc.desc(), doc.sections());\n }\n \n-#[test]\n-fn should_write_const_header() {\n-    let markdown = test::render(~\"static a: bool = true;\");\n-    assert!(str::contains(markdown, ~\"## Const `a`\\n\\n\"));\n-}\n-\n-#[test]\n-fn should_write_const_description() {\n-    let markdown = test::render(\n-        ~\"#[doc = \\\"b\\\"]\\\n-         static a: bool = true;\");\n-    assert!(str::contains(markdown, ~\"\\n\\nb\\n\\n\"));\n-}\n-\n fn write_enum(\n     ctxt: &Ctxt,\n     doc: doc::EnumDoc\n@@ -633,19 +433,6 @@ fn write_enum(\n     write_variants(ctxt, doc.variants);\n }\n \n-#[test]\n-fn should_write_enum_header() {\n-    let markdown = test::render(~\"enum a { b }\");\n-    assert!(str::contains(markdown, ~\"## Enum `a`\\n\\n\"));\n-}\n-\n-#[test]\n-fn should_write_enum_description() {\n-    let markdown = test::render(\n-        ~\"#[doc = \\\"b\\\"] enum a { b }\");\n-    assert!(str::contains(markdown, ~\"\\n\\nb\\n\\n\"));\n-}\n-\n fn write_variants(\n     ctxt: &Ctxt,\n     docs: &[doc::VariantDoc]\n@@ -667,46 +454,13 @@ fn write_variant(ctxt: &Ctxt, doc: doc::VariantDoc) {\n     assert!(doc.sig.is_some());\n     let sig = (&doc.sig).get();\n     match copy doc.desc {\n-      Some(desc) => {\n-        ctxt.w.put_line(fmt!(\"* `%s` - %s\", sig, desc));\n-      }\n-      None => {\n-        ctxt.w.put_line(fmt!(\"* `%s`\", sig));\n-      }\n-    }\n-}\n-\n-#[test]\n-fn should_write_variant_list() {\n-    let markdown = test::render(\n-        ~\"enum a { \\\n-         #[doc = \\\"test\\\"] b, \\\n-         #[doc = \\\"test\\\"] c }\");\n-    assert!(str::contains(\n-        markdown,\n-        ~\"\\n\\n#### Variants\\n\\\n-         \\n* `b` - test\\\n-         \\n* `c` - test\\n\\n\"));\n-}\n-\n-#[test]\n-fn should_write_variant_list_without_descs() {\n-    let markdown = test::render(~\"enum a { b, c }\");\n-    assert!(str::contains(\n-        markdown,\n-        ~\"\\n\\n#### Variants\\n\\\n-         \\n* `b`\\\n-         \\n* `c`\\n\\n\"));\n-}\n-\n-#[test]\n-fn should_write_variant_list_with_signatures() {\n-    let markdown = test::render(~\"enum a { b(int), #[doc = \\\"a\\\"] c(int) }\");\n-    assert!(str::contains(\n-        markdown,\n-        ~\"\\n\\n#### Variants\\n\\\n-         \\n* `b(int)`\\\n-         \\n* `c(int)` - a\\n\\n\"));\n+        Some(desc) => {\n+            ctxt.w.put_line(fmt!(\"* `%s` - %s\", sig, desc));\n+        }\n+        None => {\n+            ctxt.w.put_line(fmt!(\"* `%s`\", sig));\n+        }\n+    }\n }\n \n fn write_trait(ctxt: &Ctxt, doc: doc::TraitDoc) {\n@@ -730,78 +484,11 @@ fn write_method(ctxt: &Ctxt, doc: doc::MethodDoc) {\n     );\n }\n \n-#[test]\n-fn should_write_trait_header() {\n-    let markdown = test::render(~\"trait i { fn a(); }\");\n-    assert!(str::contains(markdown, ~\"## Trait `i`\"));\n-}\n-\n-#[test]\n-fn should_write_trait_desc() {\n-    let markdown = test::render(\n-        ~\"#[doc = \\\"desc\\\"] trait i { fn a(); }\");\n-    assert!(str::contains(markdown, ~\"desc\"));\n-}\n-\n-#[test]\n-fn should_write_trait_method_header() {\n-    let markdown = test::render(\n-        ~\"trait i { fn a(); }\");\n-    assert!(str::contains(markdown, ~\"### Method `a`\"));\n-}\n-\n-#[test]\n-fn should_write_trait_method_signature() {\n-    let markdown = test::render(\n-        ~\"trait i { fn a(&self); }\");\n-    assert!(str::contains(markdown, ~\"\\n    fn a(&self)\"));\n-}\n-\n fn write_impl(ctxt: &Ctxt, doc: doc::ImplDoc) {\n     write_common(ctxt, doc.desc(), doc.sections());\n     write_methods(ctxt, doc.methods);\n }\n \n-#[test]\n-fn should_write_impl_header() {\n-    let markdown = test::render(~\"impl int { fn a() { } }\");\n-    assert!(str::contains(markdown, ~\"## Implementation for `int`\"));\n-}\n-\n-#[test]\n-fn should_write_impl_header_with_bounds() {\n-    let markdown = test::render(~\"impl <T> int<T> { }\");\n-    assert!(str::contains(markdown, ~\"## Implementation for `int<T>` where `<T>`\"));\n-}\n-\n-#[test]\n-fn should_write_impl_header_with_trait() {\n-    let markdown = test::render(~\"impl j for int { fn a() { } }\");\n-    assert!(str::contains(markdown,\n-        ~\"## Implementation of `j` for `int`\"));\n-}\n-\n-#[test]\n-fn should_write_impl_desc() {\n-    let markdown = test::render(\n-        ~\"#[doc = \\\"desc\\\"] impl int { fn a() { } }\");\n-    assert!(str::contains(markdown, ~\"desc\"));\n-}\n-\n-#[test]\n-fn should_write_impl_method_header() {\n-    let markdown = test::render(\n-        ~\"impl int { fn a() { } }\");\n-    assert!(str::contains(markdown, ~\"### Method `a`\"));\n-}\n-\n-#[test]\n-fn should_write_impl_method_signature() {\n-    let markdown = test::render(\n-        ~\"impl int { fn a(&mut self) { } }\");\n-    assert!(str::contains(markdown, ~\"\\n    fn a(&mut self)\"));\n-}\n-\n fn write_type(\n     ctxt: &Ctxt,\n     doc: doc::TyDoc\n@@ -810,25 +497,6 @@ fn write_type(\n     write_common(ctxt, doc.desc(), doc.sections());\n }\n \n-#[test]\n-fn should_write_type_header() {\n-    let markdown = test::render(~\"type t = int;\");\n-    assert!(str::contains(markdown, ~\"## Type `t`\"));\n-}\n-\n-#[test]\n-fn should_write_type_desc() {\n-    let markdown = test::render(\n-        ~\"#[doc = \\\"desc\\\"] type t = int;\");\n-    assert!(str::contains(markdown, ~\"\\n\\ndesc\\n\\n\"));\n-}\n-\n-#[test]\n-fn should_write_type_signature() {\n-    let markdown = test::render(~\"type t = int;\");\n-    assert!(str::contains(markdown, ~\"\\n\\n    type t = int\\n\\n\"));\n-}\n-\n fn put_struct(\n     ctxt: &Ctxt,\n     doc: doc::StructDoc\n@@ -837,12 +505,6 @@ fn put_struct(\n     write_common(ctxt, doc.desc(), doc.sections());\n }\n \n-#[test]\n-fn should_put_struct_header() {\n-    let markdown = test::render(~\"struct S { field: () }\");\n-    assert!(str::contains(markdown, ~\"## Struct `S`\\n\\n\"));\n-}\n-\n #[cfg(test)]\n mod test {\n     use astsrv;\n@@ -855,22 +517,21 @@ mod test {\n     use markdown_pass::{mk_pass, write_markdown};\n     use markdown_writer;\n     use path_pass;\n+    use page_pass;\n     use sectionalize_pass;\n     use trim_pass;\n     use tystr_pass;\n     use unindent_pass;\n+    use core::prelude::*;\n \n-    use core::path::Path;\n-    use core::str;\n-\n-    pub fn render(source: ~str) -> ~str {\n+    fn render(source: ~str) -> ~str {\n         let (srv, doc) = create_doc_srv(source);\n         let markdown = write_markdown_str_srv(srv, doc);\n         debug!(\"markdown: %s\", markdown);\n         markdown\n     }\n \n-    pub fn create_doc_srv(source: ~str) -> (astsrv::Srv, doc::Doc) {\n+    fn create_doc_srv(source: ~str) -> (astsrv::Srv, doc::Doc) {\n         do astsrv::from_str(source) |srv| {\n \n             let config = config::Config {\n@@ -901,20 +562,20 @@ mod test {\n         }\n     }\n \n-    pub fn create_doc(source: ~str) -> doc::Doc {\n+    fn create_doc(source: ~str) -> doc::Doc {\n         let (_, doc) = create_doc_srv(source);\n         doc\n     }\n \n-    pub fn write_markdown_str(\n+    fn write_markdown_str(\n         doc: doc::Doc\n     ) -> ~str {\n         let (writer_factory, po) = markdown_writer::future_writer_factory();\n         write_markdown(doc, writer_factory);\n         return po.recv().second();\n     }\n \n-    pub fn write_markdown_str_srv(\n+    fn write_markdown_str_srv(\n         srv: astsrv::Srv,\n         doc: doc::Doc\n     ) -> ~str {\n@@ -925,14 +586,349 @@ mod test {\n     }\n \n     #[test]\n-    pub fn write_markdown_should_write_mod_headers() {\n+    fn write_markdown_should_write_mod_headers() {\n         let markdown = render(~\"mod moo { }\");\n         assert!(str::contains(markdown, ~\"# Module `moo`\"));\n     }\n \n     #[test]\n-    pub fn should_leave_blank_line_after_header() {\n+    fn should_leave_blank_line_after_header() {\n         let markdown = render(~\"mod morp { }\");\n         assert!(str::contains(markdown, ~\"Module `morp`\\n\\n\"));\n     }\n+\n+    #[test]\n+    fn should_write_modules_last() {\n+        /*\n+        Because the markdown pass writes all modules at the same level of\n+        indentation (it doesn't 'nest' them), we need to make sure that we\n+        write all of the modules contained in each module after all other\n+        types of items, or else the header nesting will end up wrong, with\n+        modules appearing to contain items that they do not.\n+        */\n+        let markdown = render(\n+            ~\"mod a { }\\\n+              fn b() { }\\\n+              mod c {\n+}\\\n+              fn d() { }\"\n+        );\n+\n+        let idx_a = str::find_str(markdown, ~\"# Module `a`\").get();\n+        let idx_b = str::find_str(markdown, ~\"## Function `b`\").get();\n+        let idx_c = str::find_str(markdown, ~\"# Module `c`\").get();\n+        let idx_d = str::find_str(markdown, ~\"## Function `d`\").get();\n+\n+        assert!(idx_b < idx_d);\n+        assert!(idx_d < idx_a);\n+        assert!(idx_a < idx_c);\n+    }\n+\n+    #[test]\n+    fn should_request_new_writer_for_each_page() {\n+        // This port will send us a (page, str) pair for every writer\n+        // that was created\n+        let (writer_factory, po) = markdown_writer::future_writer_factory();\n+        let (srv, doc) = create_doc_srv(~\"mod a { }\");\n+        // Split the document up into pages\n+        let doc = (page_pass::mk_pass(config::DocPerMod).f)(srv, doc);\n+        write_markdown(doc, writer_factory);\n+        // We expect two pages to have been written\n+        for iter::repeat(2) {\n+            po.recv();\n+        }\n+    }\n+\n+    #[test]\n+    fn should_write_title_for_each_page() {\n+        let (writer_factory, po) = markdown_writer::future_writer_factory();\n+        let (srv, doc) = create_doc_srv(\n+            ~\"#[link(name = \\\"core\\\")]; mod a { }\");\n+        let doc = (page_pass::mk_pass(config::DocPerMod).f)(srv, doc);\n+        write_markdown(doc, writer_factory);\n+        for iter::repeat(2) {\n+            let (page, markdown) = po.recv();\n+            match page {\n+                doc::CratePage(_) => {\n+                    assert!(str::contains(markdown, ~\"% Crate core\"));\n+                }\n+                doc::ItemPage(_) => {\n+                    assert!(str::contains(markdown, ~\"% Module a\"));\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn should_write_full_path_to_mod() {\n+        let markdown = render(~\"mod a { mod b { mod c { } } }\");\n+        assert!(str::contains(markdown, ~\"# Module `a::b::c`\"));\n+    }\n+\n+    #[test]\n+    fn should_write_sections() {\n+        let markdown = render(\n+            ~\"#[doc = \\\"\\\n+              # Header\\n\\\n+              Body\\\"]\\\n+              mod a {\n+}\");\n+        assert!(str::contains(markdown, ~\"#### Header\\n\\nBody\\n\\n\"));\n+    }\n+\n+    #[test]\n+    fn should_write_crate_description() {\n+        let markdown = render(~\"#[doc = \\\"this is the crate\\\"];\");\n+        assert!(str::contains(markdown, ~\"this is the crate\"));\n+    }\n+\n+\n+    #[test]\n+    fn should_write_index() {\n+        let markdown = render(~\"mod a { } mod b { }\");\n+        assert!(str::contains(\n+            markdown,\n+            ~\"\\n\\n* [Module `a`](#module-a)\\n\\\n+              * [Module `b`](#module-b)\\n\\n\"\n+        ));\n+    }\n+\n+    #[test]\n+    fn should_write_index_brief() {\n+        let markdown = render(~\"#[doc = \\\"test\\\"] mod a { }\");\n+        assert!(str::contains(markdown, ~\"(#module-a) - test\\n\"));\n+    }\n+\n+    #[test]\n+    fn should_not_write_index_if_no_entries() {\n+        let markdown = render(~\"\");\n+        assert!(!str::contains(markdown, ~\"\\n\\n\\n\"));\n+    }\n+\n+    #[test]\n+    fn should_write_index_for_foreign_mods() {\n+        let markdown = render(~\"extern mod a { fn a(); }\");\n+        assert!(str::contains(\n+            markdown,\n+            ~\"\\n\\n* [Function `a`](#function-a)\\n\\n\"\n+        ));\n+    }\n+\n+    #[test]\n+    fn should_write_foreign_mods() {\n+        let markdown = render(~\"#[doc = \\\"test\\\"] extern mod a { }\");\n+        assert!(str::contains(markdown, ~\"Foreign module `a`\"));\n+        assert!(str::contains(markdown, ~\"test\"));\n+    }\n+\n+    #[test]\n+    fn should_write_foreign_fns() {\n+        let markdown = render(\n+            ~\"extern mod a { #[doc = \\\"test\\\"] fn a(); }\");\n+        assert!(str::contains(markdown, ~\"test\"));\n+    }\n+\n+    #[test]\n+    fn should_write_foreign_fn_headers() {\n+        let markdown = render(\n+            ~\"extern mod a { #[doc = \\\"test\\\"] fn a(); }\");\n+        assert!(str::contains(markdown, ~\"## Function `a`\"));\n+    }\n+\n+    #[test]\n+    fn write_markdown_should_write_function_header() {\n+        let markdown = render(~\"fn func() { }\");\n+        assert!(str::contains(markdown, ~\"## Function `func`\"));\n+    }\n+\n+    #[test]\n+    fn should_write_the_function_signature() {\n+        let markdown = render(~\"#[doc = \\\"f\\\"] fn a() { }\");\n+        assert!(str::contains(markdown, ~\"\\n    fn a()\\n\"));\n+    }\n+\n+    #[test]\n+    fn should_insert_blank_line_after_fn_signature() {\n+        let markdown = render(~\"#[doc = \\\"f\\\"] fn a() { }\");\n+        assert!(str::contains(markdown, ~\"fn a()\\n\\n\"));\n+    }\n+\n+    #[test]\n+    fn should_correctly_indent_fn_signature() {\n+        let doc = create_doc(~\"fn a() { }\");\n+        let doc = doc::Doc{\n+            pages: ~[\n+                doc::CratePage(doc::CrateDoc{\n+                    topmod: doc::ModDoc{\n+                        items: ~[doc::FnTag(doc::SimpleItemDoc{\n+                            sig: Some(~\"line 1\\nline 2\"),\n+                            .. copy doc.cratemod().fns()[0]\n+                        })],\n+                        .. doc.cratemod()\n+                    },\n+                    .. doc.CrateDoc()\n+                })\n+            ]\n+        };\n+        let markdown = write_markdown_str(doc);\n+        assert!(str::contains(markdown, ~\"    line 1\\n    line 2\"));\n+    }\n+\n+    #[test]\n+    fn should_leave_blank_line_between_fn_header_and_sig() {\n+        let markdown = render(~\"fn a() { }\");\n+        assert!(str::contains(markdown, ~\"Function `a`\\n\\n    fn a()\"));\n+    }\n+\n+    #[test]\n+    fn should_write_const_header() {\n+        let markdown = render(~\"static a: bool = true;\");\n+        assert!(str::contains(markdown, ~\"## Const `a`\\n\\n\"));\n+    }\n+\n+    #[test]\n+    fn should_write_const_description() {\n+        let markdown = render(\n+            ~\"#[doc = \\\"b\\\"]\\\n+              static a: bool = true;\");\n+        assert!(str::contains(markdown, ~\"\\n\\nb\\n\\n\"));\n+    }\n+\n+    #[test]\n+    fn should_write_enum_header() {\n+        let markdown = render(~\"enum a { b }\");\n+        assert!(str::contains(markdown, ~\"## Enum `a`\\n\\n\"));\n+    }\n+\n+    #[test]\n+    fn should_write_enum_description() {\n+        let markdown = render(\n+            ~\"#[doc = \\\"b\\\"] enum a { b }\");\n+        assert!(str::contains(markdown, ~\"\\n\\nb\\n\\n\"));\n+    }\n+\n+    #[test]\n+    fn should_write_variant_list() {\n+        let markdown = render(\n+            ~\"enum a { \\\n+              #[doc = \\\"test\\\"] b, \\\n+              #[doc = \\\"test\\\"] c }\");\n+        assert!(str::contains(\n+            markdown,\n+            ~\"\\n\\n#### Variants\\n\\\n+              \\n* `b` - test\\\n+              \\n* `c` - test\\n\\n\"));\n+    }\n+\n+    #[test]\n+    fn should_write_variant_list_without_descs() {\n+        let markdown = render(~\"enum a { b, c }\");\n+        assert!(str::contains(\n+            markdown,\n+            ~\"\\n\\n#### Variants\\n\\\n+              \\n* `b`\\\n+              \\n* `c`\\n\\n\"));\n+    }\n+\n+    #[test]\n+    fn should_write_variant_list_with_signatures() {\n+        let markdown = render(~\"enum a { b(int), #[doc = \\\"a\\\"] c(int) }\");\n+        assert!(str::contains(\n+            markdown,\n+            ~\"\\n\\n#### Variants\\n\\\n+              \\n* `b(int)`\\\n+              \\n* `c(int)` - a\\n\\n\"));\n+    }\n+\n+    #[test]\n+    fn should_write_trait_header() {\n+        let markdown = render(~\"trait i { fn a(); }\");\n+        assert!(str::contains(markdown, ~\"## Trait `i`\"));\n+    }\n+\n+    #[test]\n+    fn should_write_trait_desc() {\n+        let markdown = render(\n+            ~\"#[doc = \\\"desc\\\"] trait i { fn a(); }\");\n+        assert!(str::contains(markdown, ~\"desc\"));\n+    }\n+\n+    #[test]\n+    fn should_write_trait_method_header() {\n+        let markdown = render(\n+            ~\"trait i { fn a(); }\");\n+        assert!(str::contains(markdown, ~\"### Method `a`\"));\n+    }\n+\n+    #[test]\n+    fn should_write_trait_method_signature() {\n+        let markdown = render(\n+            ~\"trait i { fn a(&self); }\");\n+        assert!(str::contains(markdown, ~\"\\n    fn a(&self)\"));\n+    }\n+\n+    #[test]\n+    fn should_write_impl_header() {\n+        let markdown = render(~\"impl int { fn a() { } }\");\n+        assert!(str::contains(markdown, ~\"## Implementation for `int`\"));\n+    }\n+\n+    #[test]\n+    fn should_write_impl_header_with_bounds() {\n+        let markdown = render(~\"impl <T> int<T> { }\");\n+        assert!(str::contains(markdown, ~\"## Implementation for `int<T>` where `<T>`\"));\n+    }\n+\n+    #[test]\n+    fn should_write_impl_header_with_trait() {\n+        let markdown = render(~\"impl j for int { fn a() { } }\");\n+        assert!(str::contains(markdown,\n+                              ~\"## Implementation of `j` for `int`\"));\n+    }\n+\n+    #[test]\n+    fn should_write_impl_desc() {\n+        let markdown = render(\n+            ~\"#[doc = \\\"desc\\\"] impl int { fn a() { } }\");\n+        assert!(str::contains(markdown, ~\"desc\"));\n+    }\n+\n+    #[test]\n+    fn should_write_impl_method_header() {\n+        let markdown = render(\n+            ~\"impl int { fn a() { } }\");\n+        assert!(str::contains(markdown, ~\"### Method `a`\"));\n+    }\n+\n+    #[test]\n+    fn should_write_impl_method_signature() {\n+        let markdown = render(\n+            ~\"impl int { fn a(&mut self) { } }\");\n+        assert!(str::contains(markdown, ~\"\\n    fn a(&mut self)\"));\n+    }\n+\n+    #[test]\n+    fn should_write_type_header() {\n+        let markdown = render(~\"type t = int;\");\n+        assert!(str::contains(markdown, ~\"## Type `t`\"));\n+    }\n+\n+    #[test]\n+    fn should_write_type_desc() {\n+        let markdown = render(\n+            ~\"#[doc = \\\"desc\\\"] type t = int;\");\n+        assert!(str::contains(markdown, ~\"\\n\\ndesc\\n\\n\"));\n+    }\n+\n+    #[test]\n+    fn should_write_type_signature() {\n+        let markdown = render(~\"type t = int;\");\n+        assert!(str::contains(markdown, ~\"\\n\\n    type t = int\\n\\n\"));\n+    }\n+\n+    #[test]\n+    fn should_put_struct_header() {\n+        let markdown = render(~\"struct S { field: () }\");\n+        assert!(str::contains(markdown, ~\"## Struct `S`\\n\\n\"));\n+    }\n }"}, {"sha": "fcf7011cbc309bcefbc1cc6557faef539bb950f6", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 63, "deletions": 60, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -182,7 +182,7 @@ fn generic_writer(process: ~fn(markdown: ~str)) -> Writer {\n     result\n }\n \n-fn make_local_filename(\n+pub fn make_local_filename(\n     config: config::Config,\n     page: doc::Page\n ) -> Path {\n@@ -218,65 +218,6 @@ pub fn make_filename(\n     Path(filename).with_filetype(ext)\n }\n \n-#[test]\n-fn should_use_markdown_file_name_based_off_crate() {\n-    let config = config::Config {\n-        output_dir: Path(\"output/dir\"),\n-        output_format: config::Markdown,\n-        output_style: config::DocPerCrate,\n-        .. config::default_config(&Path(\"input/test.rc\"))\n-    };\n-    let doc = test::mk_doc(~\"test\", ~\"\");\n-    let page = doc::CratePage(doc.CrateDoc());\n-    let filename = make_local_filename(config, page);\n-    assert!(filename.to_str() == ~\"output/dir/test.md\");\n-}\n-\n-#[test]\n-fn should_name_html_crate_file_name_index_html_when_doc_per_mod() {\n-    let config = config::Config {\n-        output_dir: Path(\"output/dir\"),\n-        output_format: config::PandocHtml,\n-        output_style: config::DocPerMod,\n-        .. config::default_config(&Path(\"input/test.rc\"))\n-    };\n-    let doc = test::mk_doc(~\"\", ~\"\");\n-    let page = doc::CratePage(doc.CrateDoc());\n-    let filename = make_local_filename(config, page);\n-    assert!(filename.to_str() == ~\"output/dir/index.html\");\n-}\n-\n-#[test]\n-fn should_name_mod_file_names_by_path() {\n-    let config = config::Config {\n-        output_dir: Path(\"output/dir\"),\n-        output_format: config::PandocHtml,\n-        output_style: config::DocPerMod,\n-        .. config::default_config(&Path(\"input/test.rc\"))\n-    };\n-    let doc = test::mk_doc(~\"\", ~\"mod a { mod b { } }\");\n-    let modb = copy doc.cratemod().mods()[0].mods()[0];\n-    let page = doc::ItemPage(doc::ModTag(modb));\n-    let filename = make_local_filename(config, page);\n-    assert!(filename == Path(\"output/dir/a_b.html\"));\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use astsrv;\n-    use doc;\n-    use extract;\n-    use path_pass;\n-\n-    pub fn mk_doc(name: ~str, source: ~str) -> doc::Doc {\n-        do astsrv::from_str(source) |srv| {\n-            let doc = extract::from_srv(srv.clone(), copy name);\n-            let doc = (path_pass::mk_pass().f)(srv.clone(), doc);\n-            doc\n-        }\n-    }\n-}\n-\n fn write_file(path: &Path, s: ~str) {\n     use core::io::WriterUtil;\n \n@@ -322,3 +263,65 @@ fn future_writer() -> (Writer, future::Future<~str>) {\n     };\n     (writer, future)\n }\n+\n+#[cfg(test)]\n+mod test {\n+    use astsrv;\n+    use doc;\n+    use extract;\n+    use path_pass;\n+    use config;\n+    use super::make_local_filename;\n+    use core::prelude::*;\n+\n+    fn mk_doc(name: ~str, source: ~str) -> doc::Doc {\n+        do astsrv::from_str(source) |srv| {\n+            let doc = extract::from_srv(srv.clone(), copy name);\n+            let doc = (path_pass::mk_pass().f)(srv.clone(), doc);\n+            doc\n+        }\n+    }\n+\n+    #[test]\n+    fn should_use_markdown_file_name_based_off_crate() {\n+        let config = config::Config {\n+            output_dir: Path(\"output/dir\"),\n+            output_format: config::Markdown,\n+            output_style: config::DocPerCrate,\n+            .. config::default_config(&Path(\"input/test.rc\"))\n+        };\n+        let doc = mk_doc(~\"test\", ~\"\");\n+        let page = doc::CratePage(doc.CrateDoc());\n+        let filename = make_local_filename(config, page);\n+        assert!(filename.to_str() == ~\"output/dir/test.md\");\n+    }\n+\n+    #[test]\n+    fn should_name_html_crate_file_name_index_html_when_doc_per_mod() {\n+        let config = config::Config {\n+            output_dir: Path(\"output/dir\"),\n+            output_format: config::PandocHtml,\n+            output_style: config::DocPerMod,\n+            .. config::default_config(&Path(\"input/test.rc\"))\n+        };\n+        let doc = mk_doc(~\"\", ~\"\");\n+        let page = doc::CratePage(doc.CrateDoc());\n+        let filename = make_local_filename(config, page);\n+        assert!(filename.to_str() == ~\"output/dir/index.html\");\n+    }\n+\n+    #[test]\n+    fn should_name_mod_file_names_by_path() {\n+        let config = config::Config {\n+            output_dir: Path(\"output/dir\"),\n+            output_format: config::PandocHtml,\n+            output_style: config::DocPerMod,\n+            .. config::default_config(&Path(\"input/test.rc\"))\n+        };\n+        let doc = mk_doc(~\"\", ~\"mod a { mod b { } }\");\n+        let modb = copy doc.cratemod().mods()[0].mods()[0];\n+        let page = doc::ItemPage(doc::ModTag(modb));\n+        let filename = make_local_filename(config, page);\n+        assert!(filename == Path(\"output/dir/a_b.html\"));\n+    }\n+}"}, {"sha": "c620e20530e66aeff6c869bcc842bd03ebafc444", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -149,36 +149,16 @@ fn fold_nmod(\n     return doc;\n }\n \n-#[test]\n-fn should_not_split_the_doc_into_pages_for_doc_per_crate() {\n-    let doc = test::mk_doc_(\n-        config::DocPerCrate,\n-        ~\"mod a { } mod b { mod c { } }\"\n-    );\n-    assert!(doc.pages.len() == 1u);\n-}\n-\n-#[test]\n-fn should_make_a_page_for_every_mod() {\n-    let doc = test::mk_doc(~\"mod a { }\");\n-    assert!(doc.pages.mods()[0].name() == ~\"a\");\n-}\n-\n-#[test]\n-fn should_remove_mods_from_containing_mods() {\n-    let doc = test::mk_doc(~\"mod a { }\");\n-    assert!(vec::is_empty(doc.cratemod().mods()));\n-}\n-\n #[cfg(test)]\n mod test {\n     use astsrv;\n     use config;\n     use doc;\n     use extract;\n     use page_pass::run;\n+    use core::vec;\n \n-    pub fn mk_doc_(\n+    fn mk_doc_(\n         output_style: config::OutputStyle,\n         source: ~str\n     ) -> doc::Doc {\n@@ -188,7 +168,28 @@ mod test {\n         }\n     }\n \n-    pub fn mk_doc(source: ~str) -> doc::Doc {\n+    fn mk_doc(source: ~str) -> doc::Doc {\n         mk_doc_(config::DocPerMod, copy source)\n     }\n+\n+    #[test]\n+    fn should_not_split_the_doc_into_pages_for_doc_per_crate() {\n+        let doc = mk_doc_(\n+            config::DocPerCrate,\n+            ~\"mod a { } mod b { mod c { } }\"\n+        );\n+        assert!(doc.pages.len() == 1u);\n+    }\n+\n+    #[test]\n+    fn should_make_a_page_for_every_mod() {\n+        let doc = mk_doc(~\"mod a { }\");\n+        assert!(doc.pages.mods()[0].name() == ~\"a\");\n+    }\n+\n+    #[test]\n+    fn should_remove_mods_from_containing_mods() {\n+        let doc = mk_doc(~\"mod a { }\");\n+        assert!(vec::is_empty(doc.cratemod().mods()));\n+    }\n }"}, {"sha": "a50f1f51765f96dcdb12df72547a465b9dde50de", "filename": "src/librustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_hidden_pass.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -61,25 +61,25 @@ fn is_hidden(srv: astsrv::Srv, doc: doc::ItemDoc) -> bool {\n     }\n }\n \n-#[test]\n-fn should_prune_hidden_items() {\n-    use core::vec;\n-\n-    let doc = test::mk_doc(~\"#[doc(hidden)] mod a { }\");\n-    assert!(vec::is_empty(doc.cratemod().mods()))\n-}\n-\n #[cfg(test)]\n-pub mod test {\n+mod test {\n     use astsrv;\n     use doc;\n     use extract;\n     use prune_hidden_pass::run;\n \n-    pub fn mk_doc(source: ~str) -> doc::Doc {\n+    fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(copy source) |srv| {\n             let doc = extract::from_srv(srv.clone(), ~\"\");\n             run(srv.clone(), doc)\n         }\n     }\n+\n+    #[test]\n+    fn should_prune_hidden_items() {\n+        use core::vec;\n+\n+        let doc = mk_doc(~\"#[doc(hidden)] mod a { }\");\n+        assert!(vec::is_empty(doc.cratemod().mods()))\n+    }\n }"}, {"sha": "0578169e257d4e2eaf799bb249792da6b0ea0646", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 88, "deletions": 88, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -154,106 +154,106 @@ fn is_visible(srv: astsrv::Srv, doc: doc::ItemDoc) -> bool {\n     }\n }\n \n-#[test]\n-fn should_prune_items_without_pub_modifier() {\n-    let doc = test::mk_doc(~\"mod a { }\");\n-    assert!(vec::is_empty(doc.cratemod().mods()));\n-}\n-\n-#[test]\n-fn should_not_prune_trait_impls() {\n-    // Impls are more complicated\n-    let doc = test::mk_doc(\n-        ~\" \\\n-          trait Foo { } \\\n-          impl Foo for int { } \\\n-          \");\n-    assert!(!doc.cratemod().impls().is_empty());\n-}\n-\n-#[test]\n-fn should_prune_associated_methods_without_vis_modifier_on_impls_without_vis_modifier() {\n-    let doc = test::mk_doc(\n-        ~\"impl Foo {\\\n-          pub fn bar() { }\\\n-          fn baz() { }\\\n-          }\");\n-    assert!(doc.cratemod().impls()[0].methods.len() == 1);\n-}\n-\n-#[test]\n-fn should_prune_priv_associated_methods_on_impls_without_vis_modifier() {\n-    let doc = test::mk_doc(\n-        ~\"impl Foo {\\\n-          pub fn bar() { }\\\n-          priv fn baz() { }\\\n-          }\");\n-    assert!(doc.cratemod().impls()[0].methods.len() == 1);\n-}\n-\n-#[test]\n-fn should_prune_priv_associated_methods_on_pub_impls() {\n-    let doc = test::mk_doc(\n-        ~\"pub impl Foo {\\\n-          fn bar() { }\\\n-          priv fn baz() { }\\\n-          }\");\n-    assert!(doc.cratemod().impls()[0].methods.len() == 1);\n-}\n-\n-#[test]\n-fn should_prune_associated_methods_without_vis_modifier_on_priv_impls() {\n-    let doc = test::mk_doc(\n-        ~\"priv impl Foo {\\\n-          pub fn bar() { }\\\n-          fn baz() { }\\\n-          }\");\n-    assert!(doc.cratemod().impls()[0].methods.len() == 1);\n-}\n-\n-#[test]\n-fn should_prune_priv_associated_methods_on_priv_impls() {\n-    let doc = test::mk_doc(\n-        ~\"priv impl Foo {\\\n-          pub fn bar() { }\\\n-          priv fn baz() { }\\\n-          }\");\n-    assert!(doc.cratemod().impls()[0].methods.len() == 1);\n-}\n-\n-#[test]\n-fn should_prune_associated_impls_with_no_pub_methods() {\n-    let doc = test::mk_doc(\n-        ~\"priv impl Foo {\\\n-          fn baz() { }\\\n-          }\");\n-    assert!(doc.cratemod().impls().is_empty());\n-}\n-\n-#[test]\n-fn should_not_prune_associated_impls_with_pub_methods() {\n-    let doc = test::mk_doc(\n-        ~\" \\\n-          impl Foo { pub fn bar() { } } \\\n-          \");\n-    assert!(!doc.cratemod().impls().is_empty());\n-}\n-\n \n #[cfg(test)]\n-pub mod test {\n+mod test {\n     use astsrv;\n     use doc;\n     use extract;\n     use tystr_pass;\n     use prune_private_pass::run;\n+    use core::vec;\n \n-    pub fn mk_doc(source: ~str) -> doc::Doc {\n+    fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(copy source) |srv| {\n             let doc = extract::from_srv(srv.clone(), ~\"\");\n             let doc = tystr_pass::run(srv.clone(), doc);\n             run(srv.clone(), doc)\n         }\n     }\n-}\n \n+    #[test]\n+    fn should_prune_items_without_pub_modifier() {\n+        let doc = mk_doc(~\"mod a { }\");\n+        assert!(vec::is_empty(doc.cratemod().mods()));\n+    }\n+\n+    #[test]\n+    fn should_not_prune_trait_impls() {\n+        // Impls are more complicated\n+        let doc = mk_doc(\n+            ~\" \\\n+              trait Foo { } \\\n+              impl Foo for int { } \\\n+              \");\n+        assert!(!doc.cratemod().impls().is_empty());\n+    }\n+\n+    #[test]\n+    fn should_prune_associated_methods_without_vis_modifier_on_impls_without_vis_modifier() {\n+        let doc = mk_doc(\n+            ~\"impl Foo {\\\n+              pub fn bar() { }\\\n+              fn baz() { }\\\n+              }\");\n+        assert!(doc.cratemod().impls()[0].methods.len() == 1);\n+    }\n+\n+    #[test]\n+    fn should_prune_priv_associated_methods_on_impls_without_vis_modifier() {\n+        let doc = mk_doc(\n+            ~\"impl Foo {\\\n+              pub fn bar() { }\\\n+              priv fn baz() { }\\\n+              }\");\n+        assert!(doc.cratemod().impls()[0].methods.len() == 1);\n+    }\n+\n+    #[test]\n+    fn should_prune_priv_associated_methods_on_pub_impls() {\n+        let doc = mk_doc(\n+            ~\"pub impl Foo {\\\n+              fn bar() { }\\\n+              priv fn baz() { }\\\n+              }\");\n+        assert!(doc.cratemod().impls()[0].methods.len() == 1);\n+    }\n+\n+    #[test]\n+    fn should_prune_associated_methods_without_vis_modifier_on_priv_impls() {\n+        let doc = mk_doc(\n+            ~\"priv impl Foo {\\\n+              pub fn bar() { }\\\n+              fn baz() { }\\\n+              }\");\n+        assert!(doc.cratemod().impls()[0].methods.len() == 1);\n+    }\n+\n+    #[test]\n+    fn should_prune_priv_associated_methods_on_priv_impls() {\n+        let doc = mk_doc(\n+            ~\"priv impl Foo {\\\n+              pub fn bar() { }\\\n+              priv fn baz() { }\\\n+              }\");\n+        assert!(doc.cratemod().impls()[0].methods.len() == 1);\n+    }\n+\n+    #[test]\n+    fn should_prune_associated_impls_with_no_pub_methods() {\n+        let doc = mk_doc(\n+            ~\"priv impl Foo {\\\n+              fn baz() { }\\\n+              }\");\n+        assert!(doc.cratemod().impls().is_empty());\n+    }\n+\n+    #[test]\n+    fn should_not_prune_associated_impls_with_pub_methods() {\n+        let doc = mk_doc(\n+            ~\" \\\n+              impl Foo { pub fn bar() { } } \\\n+              \");\n+        assert!(!doc.cratemod().impls().is_empty());\n+    }\n+}"}, {"sha": "1cf43043004cf21dab5e7334d22c7388850fdad1", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 90, "deletions": 87, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -160,106 +160,109 @@ fn parse_header(line: ~str) -> Option<~str> {\n     }\n }\n \n-#[test]\n-fn should_create_section_headers() {\n-    let doc = test::mk_doc(\n-        ~\"#[doc = \\\"\\\n-         # Header\\n\\\n-         Body\\\"]\\\n-         mod a {\n-         }\");\n-    assert!(str::contains(\n-        doc.cratemod().mods()[0].item.sections[0].header,\n-        ~\"Header\"));\n-}\n-\n-#[test]\n-fn should_create_section_bodies() {\n-    let doc = test::mk_doc(\n-        ~\"#[doc = \\\"\\\n-         # Header\\n\\\n-         Body\\\"]\\\n-         mod a {\n-         }\");\n-    assert!(str::contains(\n-        doc.cratemod().mods()[0].item.sections[0].body,\n-        ~\"Body\"));\n-}\n \n-#[test]\n-fn should_not_create_sections_from_indented_headers() {\n-    let doc = test::mk_doc(\n-        ~\"#[doc = \\\"\\n\\\n-         Text\\n             # Header\\n\\\n-         Body\\\"]\\\n-         mod a {\n-         }\");\n-    assert!(vec::is_empty(doc.cratemod().mods()[0].item.sections));\n-}\n-\n-#[test]\n-fn should_remove_section_text_from_main_desc() {\n-    let doc = test::mk_doc(\n-        ~\"#[doc = \\\"\\\n-         Description\\n\\n\\\n-         # Header\\n\\\n-         Body\\\"]\\\n-         mod a {\n-         }\");\n-    assert!(!str::contains(\n-        doc.cratemod().mods()[0].desc().get(),\n-        ~\"Header\"));\n-    assert!(!str::contains(\n-        doc.cratemod().mods()[0].desc().get(),\n-        ~\"Body\"));\n-}\n-\n-#[test]\n-fn should_eliminate_desc_if_it_is_just_whitespace() {\n-    let doc = test::mk_doc(\n-        ~\"#[doc = \\\"\\\n-         # Header\\n\\\n-         Body\\\"]\\\n-         mod a {\n-         }\");\n-    assert!(doc.cratemod().mods()[0].desc() == None);\n-}\n-\n-#[test]\n-fn should_sectionalize_trait_methods() {\n-    let doc = test::mk_doc(\n-        ~\"trait i {\n-         #[doc = \\\"\\\n-         # Header\\n\\\n-         Body\\\"]\\\n-         fn a(); }\");\n-    assert!(doc.cratemod().traits()[0].methods[0].sections.len() == 1u);\n-}\n-\n-#[test]\n-fn should_sectionalize_impl_methods() {\n-    let doc = test::mk_doc(\n-        ~\"impl bool {\n-         #[doc = \\\"\\\n-         # Header\\n\\\n-         Body\\\"]\\\n-         fn a() { } }\");\n-    assert!(doc.cratemod().impls()[0].methods[0].sections.len() == 1u);\n-}\n \n #[cfg(test)]\n-pub mod test {\n+mod test {\n     use astsrv;\n     use attr_pass;\n     use doc;\n     use extract;\n     use sectionalize_pass::run;\n+    use core::prelude::*;\n \n-    pub fn mk_doc(source: ~str) -> doc::Doc {\n+    fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(copy source) |srv| {\n             let doc = extract::from_srv(srv.clone(), ~\"\");\n             let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n             run(srv.clone(), doc)\n         }\n     }\n+\n+    #[test]\n+    fn should_create_section_headers() {\n+        let doc = mk_doc(\n+            ~\"#[doc = \\\"\\\n+              # Header\\n\\\n+              Body\\\"]\\\n+              mod a {\n+}\");\n+        assert!(str::contains(\n+            doc.cratemod().mods()[0].item.sections[0].header,\n+            ~\"Header\"));\n+    }\n+\n+    #[test]\n+    fn should_create_section_bodies() {\n+        let doc = mk_doc(\n+            ~\"#[doc = \\\"\\\n+              # Header\\n\\\n+              Body\\\"]\\\n+              mod a {\n+}\");\n+        assert!(str::contains(\n+            doc.cratemod().mods()[0].item.sections[0].body,\n+            ~\"Body\"));\n+    }\n+\n+    #[test]\n+    fn should_not_create_sections_from_indented_headers() {\n+        let doc = mk_doc(\n+            ~\"#[doc = \\\"\\n\\\n+              Text\\n             # Header\\n\\\n+              Body\\\"]\\\n+              mod a {\n+}\");\n+        assert!(vec::is_empty(doc.cratemod().mods()[0].item.sections));\n+    }\n+\n+    #[test]\n+    fn should_remove_section_text_from_main_desc() {\n+        let doc = mk_doc(\n+            ~\"#[doc = \\\"\\\n+              Description\\n\\n\\\n+              # Header\\n\\\n+              Body\\\"]\\\n+              mod a {\n+}\");\n+        assert!(!str::contains(\n+            doc.cratemod().mods()[0].desc().get(),\n+            ~\"Header\"));\n+        assert!(!str::contains(\n+            doc.cratemod().mods()[0].desc().get(),\n+            ~\"Body\"));\n+    }\n+\n+    #[test]\n+    fn should_eliminate_desc_if_it_is_just_whitespace() {\n+        let doc = mk_doc(\n+            ~\"#[doc = \\\"\\\n+              # Header\\n\\\n+              Body\\\"]\\\n+              mod a {\n+}\");\n+        assert!(doc.cratemod().mods()[0].desc() == None);\n+    }\n+\n+    #[test]\n+    fn should_sectionalize_trait_methods() {\n+        let doc = mk_doc(\n+            ~\"trait i {\n+#[doc = \\\"\\\n+              # Header\\n\\\n+              Body\\\"]\\\n+              fn a(); }\");\n+        assert!(doc.cratemod().traits()[0].methods[0].sections.len() == 1u);\n+    }\n+\n+    #[test]\n+    fn should_sectionalize_impl_methods() {\n+        let doc = mk_doc(\n+            ~\"impl bool {\n+#[doc = \\\"\\\n+              # Header\\n\\\n+              Body\\\"]\\\n+              fn a() { } }\");\n+        assert!(doc.cratemod().impls()[0].methods[0].sections.len() == 1u);\n+    }\n }"}, {"sha": "785428f00775d1796b55dca83117b87323464f1b", "filename": "src/librustdoc/text_pass.rs", "status": "modified", "additions": 155, "deletions": 155, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftext_pass.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -137,181 +137,181 @@ fn fold_impl(\n     }\n }\n \n-#[test]\n-fn should_execute_op_on_enum_brief() {\n-    let doc = test::mk_doc(~\"#[doc = \\\" a \\\"] enum a { b }\");\n-    assert!(doc.cratemod().enums()[0].brief() == Some(~\"a\"));\n-}\n+#[cfg(test)]\n+mod test {\n+    use astsrv;\n+    use attr_pass;\n+    use desc_to_brief_pass;\n+    use doc;\n+    use extract;\n+    use sectionalize_pass;\n+    use text_pass::mk_pass;\n \n-#[test]\n-fn should_execute_op_on_enum_desc() {\n-    let doc = test::mk_doc(~\"#[doc = \\\" a \\\"] enum a { b }\");\n-    assert!(doc.cratemod().enums()[0].desc() == Some(~\"a\"));\n-}\n+    use core::prelude::*;\n \n-#[test]\n-fn should_execute_op_on_variant_desc() {\n-    let doc = test::mk_doc(~\"enum a { #[doc = \\\" a \\\"] b }\");\n-    assert!(doc.cratemod().enums()[0].variants[0].desc == Some(~\"a\"));\n-}\n+    fn mk_doc(source: ~str) -> doc::Doc {\n+        do astsrv::from_str(copy source) |srv| {\n+            let doc = extract::from_srv(srv.clone(), ~\"\");\n+            let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n+            let doc = (desc_to_brief_pass::mk_pass().f)(srv.clone(), doc);\n+            let doc = (sectionalize_pass::mk_pass().f)(srv.clone(), doc);\n+            (mk_pass(~\"\", |s| str::trim(s).to_owned() ).f)(srv.clone(), doc)\n+        }\n+    }\n \n-#[test]\n-fn should_execute_op_on_trait_brief() {\n-    let doc = test::mk_doc(\n-        ~\"#[doc = \\\" a \\\"] trait i { fn a(); }\");\n-    assert!(doc.cratemod().traits()[0].brief() == Some(~\"a\"));\n-}\n+    #[test]\n+    fn should_execute_op_on_enum_brief() {\n+        let doc = mk_doc(~\"#[doc = \\\" a \\\"] enum a { b }\");\n+        assert!(doc.cratemod().enums()[0].brief() == Some(~\"a\"));\n+    }\n \n-#[test]\n-fn should_execute_op_on_trait_desc() {\n-    let doc = test::mk_doc(\n-        ~\"#[doc = \\\" a \\\"] trait i { fn a(); }\");\n-    assert!(doc.cratemod().traits()[0].desc() == Some(~\"a\"));\n-}\n+    #[test]\n+    fn should_execute_op_on_enum_desc() {\n+        let doc = mk_doc(~\"#[doc = \\\" a \\\"] enum a { b }\");\n+        assert!(doc.cratemod().enums()[0].desc() == Some(~\"a\"));\n+    }\n \n-#[test]\n-fn should_execute_op_on_trait_method_brief() {\n-    let doc = test::mk_doc(\n-        ~\"trait i { #[doc = \\\" a \\\"] fn a(); }\");\n-    assert!(doc.cratemod().traits()[0].methods[0].brief == Some(~\"a\"));\n-}\n+    #[test]\n+    fn should_execute_op_on_variant_desc() {\n+        let doc = mk_doc(~\"enum a { #[doc = \\\" a \\\"] b }\");\n+        assert!(doc.cratemod().enums()[0].variants[0].desc == Some(~\"a\"));\n+    }\n \n-#[test]\n-fn should_execute_op_on_trait_method_desc() {\n-    let doc = test::mk_doc(\n-        ~\"trait i { #[doc = \\\" a \\\"] fn a(); }\");\n-    assert!(doc.cratemod().traits()[0].methods[0].desc == Some(~\"a\"));\n-}\n+    #[test]\n+    fn should_execute_op_on_trait_brief() {\n+        let doc = mk_doc(\n+            ~\"#[doc = \\\" a \\\"] trait i { fn a(); }\");\n+        assert!(doc.cratemod().traits()[0].brief() == Some(~\"a\"));\n+    }\n \n-#[test]\n-fn should_execute_op_on_impl_brief() {\n-    let doc = test::mk_doc(\n-        ~\"#[doc = \\\" a \\\"] impl int { fn a() { } }\");\n-    assert!(doc.cratemod().impls()[0].brief() == Some(~\"a\"));\n-}\n+    #[test]\n+    fn should_execute_op_on_trait_desc() {\n+        let doc = mk_doc(\n+            ~\"#[doc = \\\" a \\\"] trait i { fn a(); }\");\n+        assert!(doc.cratemod().traits()[0].desc() == Some(~\"a\"));\n+    }\n \n-#[test]\n-fn should_execute_op_on_impl_desc() {\n-    let doc = test::mk_doc(\n-        ~\"#[doc = \\\" a \\\"] impl int { fn a() { } }\");\n-    assert!(doc.cratemod().impls()[0].desc() == Some(~\"a\"));\n-}\n+    #[test]\n+    fn should_execute_op_on_trait_method_brief() {\n+        let doc = mk_doc(\n+            ~\"trait i { #[doc = \\\" a \\\"] fn a(); }\");\n+        assert!(doc.cratemod().traits()[0].methods[0].brief == Some(~\"a\"));\n+    }\n \n-#[test]\n-fn should_execute_op_on_impl_method_brief() {\n-    let doc = test::mk_doc(\n-        ~\"impl int { #[doc = \\\" a \\\"] fn a() { } }\");\n-    assert!(doc.cratemod().impls()[0].methods[0].brief == Some(~\"a\"));\n-}\n+    #[test]\n+    fn should_execute_op_on_trait_method_desc() {\n+        let doc = mk_doc(\n+            ~\"trait i { #[doc = \\\" a \\\"] fn a(); }\");\n+        assert!(doc.cratemod().traits()[0].methods[0].desc == Some(~\"a\"));\n+    }\n \n-#[test]\n-fn should_execute_op_on_impl_method_desc() {\n-    let doc = test::mk_doc(\n-        ~\"impl int { #[doc = \\\" a \\\"] fn a() { } }\");\n-    assert!(doc.cratemod().impls()[0].methods[0].desc == Some(~\"a\"));\n-}\n+    #[test]\n+    fn should_execute_op_on_impl_brief() {\n+        let doc = mk_doc(\n+            ~\"#[doc = \\\" a \\\"] impl int { fn a() { } }\");\n+        assert!(doc.cratemod().impls()[0].brief() == Some(~\"a\"));\n+    }\n \n-#[test]\n-fn should_execute_op_on_type_brief() {\n-    let doc = test::mk_doc(\n-        ~\"#[doc = \\\" a \\\"] type t = int;\");\n-    assert!(doc.cratemod().types()[0].brief() == Some(~\"a\"));\n-}\n+    #[test]\n+    fn should_execute_op_on_impl_desc() {\n+        let doc = mk_doc(\n+            ~\"#[doc = \\\" a \\\"] impl int { fn a() { } }\");\n+        assert!(doc.cratemod().impls()[0].desc() == Some(~\"a\"));\n+    }\n \n-#[test]\n-fn should_execute_op_on_type_desc() {\n-    let doc = test::mk_doc(\n-        ~\"#[doc = \\\" a \\\"] type t = int;\");\n-    assert!(doc.cratemod().types()[0].desc() == Some(~\"a\"));\n-}\n+    #[test]\n+    fn should_execute_op_on_impl_method_brief() {\n+        let doc = mk_doc(\n+            ~\"impl int { #[doc = \\\" a \\\"] fn a() { } }\");\n+        assert!(doc.cratemod().impls()[0].methods[0].brief == Some(~\"a\"));\n+    }\n \n-#[test]\n-fn should_execute_on_item_section_headers() {\n-    let doc = test::mk_doc(\n-        ~\"#[doc = \\\"\\\n-         #    Header    \\n\\\n-         Body\\\"]\\\n-         fn a() { }\");\n-    assert!(doc.cratemod().fns()[0].sections()[0].header == ~\"Header\");\n-}\n+    #[test]\n+    fn should_execute_op_on_impl_method_desc() {\n+        let doc = mk_doc(\n+            ~\"impl int { #[doc = \\\" a \\\"] fn a() { } }\");\n+        assert!(doc.cratemod().impls()[0].methods[0].desc == Some(~\"a\"));\n+    }\n \n-#[test]\n-fn should_execute_on_item_section_bodies() {\n-    let doc = test::mk_doc(\n-        ~\"#[doc = \\\"\\\n-         # Header\\n\\\n-         Body      \\\"]\\\n-         fn a() { }\");\n-    assert!(doc.cratemod().fns()[0].sections()[0].body == ~\"Body\");\n-}\n+    #[test]\n+    fn should_execute_op_on_type_brief() {\n+        let doc = mk_doc(\n+            ~\"#[doc = \\\" a \\\"] type t = int;\");\n+        assert!(doc.cratemod().types()[0].brief() == Some(~\"a\"));\n+    }\n \n-#[test]\n-fn should_execute_on_trait_method_section_headers() {\n-    let doc = test::mk_doc(\n-        ~\"trait i {\n-         #[doc = \\\"\\\n-         # Header    \\n\\\n-         Body\\\"]\\\n-         fn a(); }\");\n-    assert!(doc.cratemod().traits()[0].methods[0].sections[0].header\n-        == ~\"Header\");\n-}\n+    #[test]\n+    fn should_execute_op_on_type_desc() {\n+        let doc = mk_doc(\n+            ~\"#[doc = \\\" a \\\"] type t = int;\");\n+        assert!(doc.cratemod().types()[0].desc() == Some(~\"a\"));\n+    }\n \n-#[test]\n-fn should_execute_on_trait_method_section_bodies() {\n-    let doc = test::mk_doc(\n-        ~\"trait i {\n-         #[doc = \\\"\\\n-         # Header\\n\\\n-         Body     \\\"]\\\n-         fn a(); }\");\n-    assert!(doc.cratemod().traits()[0].methods[0].sections[0].body ==\n-        ~\"Body\");\n-}\n+    #[test]\n+    fn should_execute_on_item_section_headers() {\n+        let doc = mk_doc(\n+            ~\"#[doc = \\\"\\\n+              #    Header    \\n\\\n+              Body\\\"]\\\n+              fn a() { }\");\n+        assert!(doc.cratemod().fns()[0].sections()[0].header == ~\"Header\");\n+    }\n \n-#[test]\n-fn should_execute_on_impl_method_section_headers() {\n-    let doc = test::mk_doc(\n-        ~\"impl bool {\n-         #[doc = \\\"\\\n-         # Header   \\n\\\n-         Body\\\"]\\\n-         fn a() { } }\");\n-    assert!(doc.cratemod().impls()[0].methods[0].sections[0].header\n-        == ~\"Header\");\n-}\n+    #[test]\n+    fn should_execute_on_item_section_bodies() {\n+        let doc = mk_doc(\n+            ~\"#[doc = \\\"\\\n+              # Header\\n\\\n+              Body      \\\"]\\\n+              fn a() { }\");\n+        assert!(doc.cratemod().fns()[0].sections()[0].body == ~\"Body\");\n+    }\n \n-#[test]\n-fn should_execute_on_impl_method_section_bodies() {\n-    let doc = test::mk_doc(\n-        ~\"impl bool {\n-         #[doc = \\\"\\\n-         # Header\\n\\\n-         Body    \\\"]\\\n-         fn a() { } }\");\n-    assert!(doc.cratemod().impls()[0].methods[0].sections[0].body ==\n-        ~\"Body\");\n-}\n+    #[test]\n+    fn should_execute_on_trait_method_section_headers() {\n+        let doc = mk_doc(\n+            ~\"trait i {\n+#[doc = \\\"\\\n+              # Header    \\n\\\n+              Body\\\"]\\\n+              fn a(); }\");\n+        assert!(doc.cratemod().traits()[0].methods[0].sections[0].header\n+                == ~\"Header\");\n+    }\n \n-#[cfg(test)]\n-mod test {\n-    use astsrv;\n-    use attr_pass;\n-    use desc_to_brief_pass;\n-    use doc;\n-    use extract;\n-    use sectionalize_pass;\n-    use text_pass::mk_pass;\n+    #[test]\n+    fn should_execute_on_trait_method_section_bodies() {\n+        let doc = mk_doc(\n+            ~\"trait i {\n+#[doc = \\\"\\\n+              # Header\\n\\\n+              Body     \\\"]\\\n+              fn a(); }\");\n+        assert!(doc.cratemod().traits()[0].methods[0].sections[0].body ==\n+                ~\"Body\");\n+    }\n \n-    use core::str;\n+    #[test]\n+    fn should_execute_on_impl_method_section_headers() {\n+        let doc = mk_doc(\n+            ~\"impl bool {\n+#[doc = \\\"\\\n+              # Header   \\n\\\n+              Body\\\"]\\\n+              fn a() { } }\");\n+        assert!(doc.cratemod().impls()[0].methods[0].sections[0].header\n+                == ~\"Header\");\n+    }\n \n-    pub fn mk_doc(source: ~str) -> doc::Doc {\n-        do astsrv::from_str(copy source) |srv| {\n-            let doc = extract::from_srv(srv.clone(), ~\"\");\n-            let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n-            let doc = (desc_to_brief_pass::mk_pass().f)(srv.clone(), doc);\n-            let doc = (sectionalize_pass::mk_pass().f)(srv.clone(), doc);\n-            (mk_pass(~\"\", |s| str::trim(s).to_owned() ).f)(srv.clone(), doc)\n-        }\n+    #[test]\n+    fn should_execute_on_impl_method_section_bodies() {\n+        let doc = mk_doc(\n+            ~\"impl bool {\n+#[doc = \\\"\\\n+              # Header\\n\\\n+              Body    \\\"]\\\n+              fn a() { } }\");\n+        assert!(doc.cratemod().impls()[0].methods[0].sections[0].body ==\n+                ~\"Body\");\n     }\n }"}, {"sha": "e56a5f18ac6f7fc0b42e2ae7289e0103fc84e732", "filename": "src/librustdoc/trim_pass.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Ftrim_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Ftrim_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftrim_pass.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -22,16 +22,6 @@ pub fn mk_pass() -> Pass {\n     text_pass::mk_pass(~\"trim\", |s| s.trim().to_owned() )\n }\n \n-#[test]\n-fn should_trim_text() {\n-    use core::option::Some;\n-\n-    let doc = test::mk_doc(~\"#[doc = \\\" desc \\\"] \\\n-                            mod m {\n-                            }\");\n-    assert!(doc.cratemod().mods()[0].desc() == Some(~\"desc\"));\n-}\n-\n #[cfg(test)]\n mod test {\n     use astsrv;\n@@ -40,11 +30,21 @@ mod test {\n     use extract;\n     use trim_pass::mk_pass;\n \n-    pub fn mk_doc(source: ~str) -> doc::Doc {\n+    fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(copy source) |srv| {\n             let doc = extract::from_srv(srv.clone(), ~\"\");\n             let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n             (mk_pass().f)(srv.clone(), doc)\n         }\n     }\n+\n+    #[test]\n+    fn should_trim_text() {\n+        use core::option::Some;\n+\n+        let doc = mk_doc(~\"#[doc = \\\" desc \\\"] \\\n+                                 mod m {\n+}\");\n+        assert!(doc.cratemod().mods()[0].desc() == Some(~\"desc\"));\n+    }\n }"}, {"sha": "c0562d306398a53d980dff449754fae6655a9e59", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 156, "deletions": 155, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -67,35 +67,22 @@ fn fold_fn(\n fn get_fn_sig(srv: astsrv::Srv, fn_id: doc::AstId) -> Option<~str> {\n     do astsrv::exec(srv) |ctxt| {\n         match *ctxt.ast_map.get(&fn_id) {\n-          ast_map::node_item(@ast::item {\n-            ident: ident,\n-            node: ast::item_fn(ref decl, purity, _, ref tys, _), _\n-          }, _) |\n-          ast_map::node_foreign_item(@ast::foreign_item {\n-            ident: ident,\n-            node: ast::foreign_item_fn(ref decl, purity, ref tys), _\n-          }, _, _, _) => {\n-            Some(pprust::fun_to_str(decl, purity, ident, None, tys,\n-                                    extract::interner()))\n-          }\n-          _ => fail!(~\"get_fn_sig: fn_id not bound to a fn item\")\n+            ast_map::node_item(@ast::item {\n+                ident: ident,\n+                node: ast::item_fn(ref decl, purity, _, ref tys, _), _\n+            }, _) |\n+            ast_map::node_foreign_item(@ast::foreign_item {\n+                ident: ident,\n+                node: ast::foreign_item_fn(ref decl, purity, ref tys), _\n+            }, _, _, _) => {\n+                Some(pprust::fun_to_str(decl, purity, ident, None, tys,\n+                                        extract::interner()))\n+            }\n+            _ => fail!(~\"get_fn_sig: fn_id not bound to a fn item\")\n         }\n     }\n }\n \n-#[test]\n-fn should_add_fn_sig() {\n-    let doc = test::mk_doc(~\"fn a<T>() -> int { }\");\n-    assert!(doc.cratemod().fns()[0].sig == Some(~\"fn a<T>() -> int\"));\n-}\n-\n-#[test]\n-fn should_add_foreign_fn_sig() {\n-    let doc = test::mk_doc(~\"extern mod a { fn a<T>() -> int; }\");\n-    assert!(doc.cratemod().nmods()[0].fns[0].sig ==\n-        Some(~\"fn a<T>() -> int\"));\n-}\n-\n fn fold_const(\n     fold: &fold::Fold<astsrv::Srv>,\n     doc: doc::ConstDoc\n@@ -119,12 +106,6 @@ fn fold_const(\n     }\n }\n \n-#[test]\n-fn should_add_const_types() {\n-    let doc = test::mk_doc(~\"static a: bool = true;\");\n-    assert!(doc.cratemod().consts()[0].sig == Some(~\"bool\"));\n-}\n-\n fn fold_enum(\n     fold: &fold::Fold<astsrv::Srv>,\n     doc: doc::EnumDoc\n@@ -163,13 +144,6 @@ fn fold_enum(\n     }\n }\n \n-#[test]\n-fn should_add_variant_sigs() {\n-    let doc = test::mk_doc(~\"enum a { b(int) }\");\n-    assert!(doc.cratemod().enums()[0].variants[0].sig ==\n-        Some(~\"b(int)\"));\n-}\n-\n fn fold_trait(\n     fold: &fold::Fold<astsrv::Srv>,\n     doc: doc::TraitDoc\n@@ -200,73 +174,66 @@ fn get_method_sig(\n ) -> Option<~str> {\n     do astsrv::exec(srv) |ctxt| {\n         match *ctxt.ast_map.get(&item_id) {\n-          ast_map::node_item(@ast::item {\n-            node: ast::item_trait(_, _, ref methods), _\n-          }, _) => {\n-            match vec::find(*methods, |method| {\n-                match copy *method {\n-                  ast::required(ty_m) => to_str(ty_m.ident) == method_name,\n-                  ast::provided(m) => to_str(m.ident) == method_name,\n-                }\n-            }) {\n-                Some(method) => {\n-                  match method {\n-                    ast::required(ty_m) => {\n-                      Some(pprust::fun_to_str(\n-                          &ty_m.decl,\n-                          ty_m.purity,\n-                          ty_m.ident,\n-                          Some(ty_m.self_ty.node),\n-                          &ty_m.generics,\n-                          extract::interner()\n-                      ))\n+            ast_map::node_item(@ast::item {\n+                node: ast::item_trait(_, _, ref methods), _\n+            }, _) => {\n+                match vec::find(*methods, |method| {\n+                    match copy *method {\n+                        ast::required(ty_m) => to_str(ty_m.ident) == method_name,\n+                        ast::provided(m) => to_str(m.ident) == method_name,\n                     }\n-                    ast::provided(m) => {\n-                      Some(pprust::fun_to_str(\n-                          &m.decl,\n-                          m.purity,\n-                          m.ident,\n-                          Some(m.self_ty.node),\n-                          &m.generics,\n-                          extract::interner()\n-                      ))\n+                }) {\n+                    Some(method) => {\n+                        match method {\n+                            ast::required(ty_m) => {\n+                                Some(pprust::fun_to_str(\n+                                    &ty_m.decl,\n+                                    ty_m.purity,\n+                                    ty_m.ident,\n+                                    Some(ty_m.self_ty.node),\n+                                    &ty_m.generics,\n+                                    extract::interner()\n+                                ))\n+                            }\n+                            ast::provided(m) => {\n+                                Some(pprust::fun_to_str(\n+                                    &m.decl,\n+                                    m.purity,\n+                                    m.ident,\n+                                    Some(m.self_ty.node),\n+                                    &m.generics,\n+                                    extract::interner()\n+                                ))\n+                            }\n+                        }\n                     }\n-                  }\n+                    _ => fail!(~\"method not found\")\n                 }\n-                _ => fail!(~\"method not found\")\n             }\n-          }\n-          ast_map::node_item(@ast::item {\n-            node: ast::item_impl(_, _, _, ref methods), _\n-          }, _) => {\n-            match vec::find(*methods, |method| {\n-                to_str(method.ident) == method_name\n-            }) {\n-                Some(method) => {\n-                    Some(pprust::fun_to_str(\n-                        &method.decl,\n-                        method.purity,\n-                        method.ident,\n-                        Some(method.self_ty.node),\n-                        &method.generics,\n-                        extract::interner()\n-                    ))\n+            ast_map::node_item(@ast::item {\n+                node: ast::item_impl(_, _, _, ref methods), _\n+            }, _) => {\n+                match vec::find(*methods, |method| {\n+                    to_str(method.ident) == method_name\n+                }) {\n+                    Some(method) => {\n+                        Some(pprust::fun_to_str(\n+                            &method.decl,\n+                            method.purity,\n+                            method.ident,\n+                            Some(method.self_ty.node),\n+                            &method.generics,\n+                            extract::interner()\n+                        ))\n+                    }\n+                    None => fail!(~\"method not found\")\n                 }\n-                None => fail!(~\"method not found\")\n             }\n-          }\n-          _ => fail!(~\"get_method_sig: item ID not bound to trait or impl\")\n+            _ => fail!(~\"get_method_sig: item ID not bound to trait or impl\")\n         }\n     }\n }\n \n-#[test]\n-fn should_add_trait_method_sigs() {\n-    let doc = test::mk_doc(~\"trait i { fn a<T>(&mut self) -> int; }\");\n-    assert!(doc.cratemod().traits()[0].methods[0].sig\n-        == Some(~\"fn a<T>(&mut self) -> int\"));\n-}\n-\n fn fold_impl(\n     fold: &fold::Fold<astsrv::Srv>,\n     doc: doc::ImplDoc\n@@ -305,37 +272,6 @@ fn fold_impl(\n     }\n }\n \n-#[test]\n-fn should_add_impl_bounds() {\n-    let doc = test::mk_doc(~\"impl<T, U: Copy, V: Copy + Clone> Option<T, U, V> { }\");\n-    assert!(doc.cratemod().impls()[0].bounds_str == Some(~\"<T, U: Copy, V: Copy + Clone>\"));\n-}\n-\n-#[test]\n-fn should_add_impl_trait_types() {\n-    let doc = test::mk_doc(~\"impl j for int { fn a<T>() { } }\");\n-    assert!(doc.cratemod().impls()[0].trait_types[0] == ~\"j\");\n-}\n-\n-#[test]\n-fn should_not_add_impl_trait_types_if_none() {\n-    let doc = test::mk_doc(~\"impl int { fn a() { } }\");\n-    assert!(vec::len(doc.cratemod().impls()[0].trait_types) == 0);\n-}\n-\n-#[test]\n-fn should_add_impl_self_ty() {\n-    let doc = test::mk_doc(~\"impl int { fn a() { } }\");\n-    assert!(doc.cratemod().impls()[0].self_ty == Some(~\"int\"));\n-}\n-\n-#[test]\n-fn should_add_impl_method_sigs() {\n-    let doc = test::mk_doc(~\"impl int { fn a<T>(&self) -> int { fail!() } }\");\n-    assert!(doc.cratemod().impls()[0].methods[0].sig\n-        == Some(~\"fn a<T>(&self) -> int\"));\n-}\n-\n fn fold_type(\n     fold: &fold::Fold<astsrv::Srv>,\n     doc: doc::TyDoc\n@@ -369,12 +305,6 @@ fn fold_type(\n     }\n }\n \n-#[test]\n-fn should_add_type_signatures() {\n-    let doc = test::mk_doc(~\"type t<T> = int;\");\n-    assert!(doc.cratemod().types()[0].sig == Some(~\"type t<T> = int\"));\n-}\n-\n fn fold_struct(\n     fold: &fold::Fold<astsrv::Srv>,\n     doc: doc::StructDoc\n@@ -422,38 +352,109 @@ fn strip_struct_extra_stuff(item: @ast::item) -> @ast::item {\n     }\n }\n \n-#[test]\n-fn should_add_struct_defs() {\n-    let doc = test::mk_doc(~\"struct S { field: () }\");\n-    assert!((&doc.cratemod().structs()[0].sig).get().contains(\n-        \"struct S {\"));\n-}\n-\n-#[test]\n-fn should_not_serialize_struct_drop_blocks() {\n-    // All we care about are the fields\n-    let doc = test::mk_doc(~\"struct S { field: (), drop { } }\");\n-    assert!(!(&doc.cratemod().structs()[0].sig).get().contains(\"drop\"));\n-}\n-\n-#[test]\n-fn should_not_serialize_struct_attrs() {\n-    // All we care about are the fields\n-    let doc = test::mk_doc(~\"#[wut] struct S { field: () }\");\n-    assert!(!(&doc.cratemod().structs()[0].sig).get().contains(\"wut\"));\n-}\n-\n #[cfg(test)]\n-pub mod test {\n+mod test {\n     use astsrv;\n     use doc;\n     use extract;\n     use tystr_pass::run;\n+    use core::prelude::*;\n \n-    pub fn mk_doc(source: ~str) -> doc::Doc {\n+    fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(copy source) |srv| {\n             let doc = extract::from_srv(srv.clone(), ~\"\");\n             run(srv.clone(), doc)\n         }\n     }\n+\n+    #[test]\n+    fn should_add_fn_sig() {\n+        let doc = mk_doc(~\"fn a<T>() -> int { }\");\n+        assert!(doc.cratemod().fns()[0].sig == Some(~\"fn a<T>() -> int\"));\n+    }\n+\n+    #[test]\n+    fn should_add_foreign_fn_sig() {\n+        let doc = mk_doc(~\"extern mod a { fn a<T>() -> int; }\");\n+        assert!(doc.cratemod().nmods()[0].fns[0].sig ==\n+                Some(~\"fn a<T>() -> int\"));\n+    }\n+\n+    #[test]\n+    fn should_add_const_types() {\n+        let doc = mk_doc(~\"static a: bool = true;\");\n+        assert!(doc.cratemod().consts()[0].sig == Some(~\"bool\"));\n+    }\n+\n+    #[test]\n+    fn should_add_variant_sigs() {\n+        let doc = mk_doc(~\"enum a { b(int) }\");\n+        assert!(doc.cratemod().enums()[0].variants[0].sig ==\n+                Some(~\"b(int)\"));\n+    }\n+\n+    #[test]\n+    fn should_add_trait_method_sigs() {\n+        let doc = mk_doc(~\"trait i { fn a<T>(&mut self) -> int; }\");\n+        assert!(doc.cratemod().traits()[0].methods[0].sig\n+                == Some(~\"fn a<T>(&mut self) -> int\"));\n+    }\n+\n+    #[test]\n+    fn should_add_impl_bounds() {\n+        let doc = mk_doc(~\"impl<T, U: Copy, V: Copy + Clone> Option<T, U, V> { }\");\n+        assert!(doc.cratemod().impls()[0].bounds_str == Some(~\"<T, U: Copy, V: Copy + Clone>\"));\n+    }\n+\n+    #[test]\n+    fn should_add_impl_trait_types() {\n+        let doc = mk_doc(~\"impl j for int { fn a<T>() { } }\");\n+        assert!(doc.cratemod().impls()[0].trait_types[0] == ~\"j\");\n+    }\n+\n+    #[test]\n+    fn should_not_add_impl_trait_types_if_none() {\n+        let doc = mk_doc(~\"impl int { fn a() { } }\");\n+        assert!(vec::len(doc.cratemod().impls()[0].trait_types) == 0);\n+    }\n+\n+    #[test]\n+    fn should_add_impl_self_ty() {\n+        let doc = mk_doc(~\"impl int { fn a() { } }\");\n+        assert!(doc.cratemod().impls()[0].self_ty == Some(~\"int\"));\n+    }\n+\n+    #[test]\n+    fn should_add_impl_method_sigs() {\n+        let doc = mk_doc(~\"impl int { fn a<T>(&self) -> int { fail!() } }\");\n+        assert!(doc.cratemod().impls()[0].methods[0].sig\n+                == Some(~\"fn a<T>(&self) -> int\"));\n+    }\n+\n+    #[test]\n+    fn should_add_type_signatures() {\n+        let doc = mk_doc(~\"type t<T> = int;\");\n+        assert!(doc.cratemod().types()[0].sig == Some(~\"type t<T> = int\"));\n+    }\n+\n+    #[test]\n+    fn should_add_struct_defs() {\n+        let doc = mk_doc(~\"struct S { field: () }\");\n+        assert!((&doc.cratemod().structs()[0].sig).get().contains(\n+            \"struct S {\"));\n+    }\n+\n+    #[test]\n+    fn should_not_serialize_struct_drop_blocks() {\n+        // All we care about are the fields\n+        let doc = mk_doc(~\"struct S { field: (), drop { } }\");\n+        assert!(!(&doc.cratemod().structs()[0].sig).get().contains(\"drop\"));\n+    }\n+\n+    #[test]\n+    fn should_not_serialize_struct_attrs() {\n+        // All we care about are the fields\n+        let doc = mk_doc(~\"#[wut] struct S { field: () }\");\n+        assert!(!(&doc.cratemod().structs()[0].sig).get().contains(\"wut\"));\n+    }\n }"}, {"sha": "da1e4688939cc8ac44c9260121277cdde49b8e71", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -492,7 +492,7 @@ mod tests {\n     use core::vec;\n \n     #[test]\n-    pub fn manually_share_arc() {\n+    fn manually_share_arc() {\n         let v = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n         let arc_v = arc::ARC(v);\n \n@@ -517,7 +517,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_mutex_arc_condvar() {\n+    fn test_mutex_arc_condvar() {\n         let arc = ~MutexARC(false);\n         let arc2 = ~arc.clone();\n         let (p,c) = comm::oneshot();\n@@ -539,7 +539,7 @@ mod tests {\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn test_arc_condvar_poison() {\n+    fn test_arc_condvar_poison() {\n         let arc = ~MutexARC(1);\n         let arc2 = ~arc.clone();\n         let (p, c) = comm::stream();\n@@ -561,7 +561,7 @@ mod tests {\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn test_mutex_arc_poison() {\n+    fn test_mutex_arc_poison() {\n         let arc = ~MutexARC(1);\n         let arc2 = ~arc.clone();\n         do task::try || {\n@@ -574,7 +574,7 @@ mod tests {\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn test_rw_arc_poison_wr() {\n+    fn test_rw_arc_poison_wr() {\n         let arc = ~RWARC(1);\n         let arc2 = (*arc).clone();\n         do task::try || {\n@@ -587,7 +587,7 @@ mod tests {\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn test_rw_arc_poison_ww() {\n+    fn test_rw_arc_poison_ww() {\n         let arc = ~RWARC(1);\n         let arc2 = (*arc).clone();\n         do task::try || {\n@@ -600,7 +600,7 @@ mod tests {\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn test_rw_arc_poison_dw() {\n+    fn test_rw_arc_poison_dw() {\n         let arc = ~RWARC(1);\n         let arc2 = (*arc).clone();\n         do task::try || {\n@@ -615,7 +615,7 @@ mod tests {\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n-    pub fn test_rw_arc_no_poison_rr() {\n+    fn test_rw_arc_no_poison_rr() {\n         let arc = ~RWARC(1);\n         let arc2 = (*arc).clone();\n         do task::try || {\n@@ -628,7 +628,7 @@ mod tests {\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n-    pub fn test_rw_arc_no_poison_rw() {\n+    fn test_rw_arc_no_poison_rw() {\n         let arc = ~RWARC(1);\n         let arc2 = (*arc).clone();\n         do task::try || {\n@@ -641,7 +641,7 @@ mod tests {\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n-    pub fn test_rw_arc_no_poison_dr() {\n+    fn test_rw_arc_no_poison_dr() {\n         let arc = ~RWARC(1);\n         let arc2 = (*arc).clone();\n         do task::try || {\n@@ -657,7 +657,7 @@ mod tests {\n         }\n     }\n     #[test]\n-    pub fn test_rw_arc() {\n+    fn test_rw_arc() {\n         let arc = ~RWARC(0);\n         let arc2 = (*arc).clone();\n         let (p,c) = comm::stream();\n@@ -694,7 +694,7 @@ mod tests {\n         do arc.read |num| { assert!(*num == 10); }\n     }\n     #[test]\n-    pub fn test_rw_downgrade() {\n+    fn test_rw_downgrade() {\n         // (1) A downgrader gets in write mode and does cond.wait.\n         // (2) A writer gets in write mode, sets state to 42, and does signal.\n         // (3) Downgrader wakes, sets state to 31337."}, {"sha": "e90f0fb3c81d4216e9e12f4d1fa63fe8fbbdba29", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -232,7 +232,7 @@ mod tests {\n     use core::str;\n \n     #[test]\n-    pub fn test_to_base64() {\n+    fn test_to_base64() {\n         assert!((~\"\").to_base64()       == ~\"\");\n         assert!((~\"f\").to_base64()      == ~\"Zg==\");\n         assert!((~\"fo\").to_base64()     == ~\"Zm8=\");\n@@ -243,7 +243,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_from_base64() {\n+    fn test_from_base64() {\n         assert!((~\"\").from_base64() == str::to_bytes(~\"\"));\n         assert!((~\"Zg==\").from_base64() == str::to_bytes(~\"f\"));\n         assert!((~\"Zm8=\").from_base64() == str::to_bytes(~\"fo\"));"}, {"sha": "d89ce4232b175963cb71e39bac0df00210c44985", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -880,7 +880,7 @@ mod tests {\n     static bench_bits : uint = 1 << 14;\n \n     #[test]\n-    pub fn test_to_str() {\n+    fn test_to_str() {\n         let zerolen = Bitv::new(0u, false);\n         assert!(zerolen.to_str() == ~\"\");\n \n@@ -889,7 +889,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_0_elements() {\n+    fn test_0_elements() {\n         let mut act;\n         let mut exp;\n         act = Bitv::new(0u, false);\n@@ -898,7 +898,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_1_element() {\n+    fn test_1_element() {\n         let mut act;\n         act = Bitv::new(1u, false);\n         assert!(act.eq_vec(~[0u]));\n@@ -907,15 +907,15 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_2_elements() {\n+    fn test_2_elements() {\n         let mut b = bitv::Bitv::new(2, false);\n         b.set(0, true);\n         b.set(1, false);\n         assert!(b.to_str() == ~\"10\");\n     }\n \n     #[test]\n-    pub fn test_10_elements() {\n+    fn test_10_elements() {\n         let mut act;\n         // all 0\n \n@@ -954,7 +954,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_31_elements() {\n+    fn test_31_elements() {\n         let mut act;\n         // all 0\n \n@@ -1027,7 +1027,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_32_elements() {\n+    fn test_32_elements() {\n         let mut act;\n         // all 0\n \n@@ -1102,7 +1102,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_33_elements() {\n+    fn test_33_elements() {\n         let mut act;\n         // all 0\n \n@@ -1178,21 +1178,21 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_equal_differing_sizes() {\n+    fn test_equal_differing_sizes() {\n         let v0 = Bitv::new(10u, false);\n         let v1 = Bitv::new(11u, false);\n         assert!(!v0.equal(&v1));\n     }\n \n     #[test]\n-    pub fn test_equal_greatly_differing_sizes() {\n+    fn test_equal_greatly_differing_sizes() {\n         let v0 = Bitv::new(10u, false);\n         let v1 = Bitv::new(110u, false);\n         assert!(!v0.equal(&v1));\n     }\n \n     #[test]\n-    pub fn test_equal_sneaky_small() {\n+    fn test_equal_sneaky_small() {\n         let mut a = bitv::Bitv::new(1, false);\n         a.set(0, true);\n \n@@ -1203,7 +1203,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_equal_sneaky_big() {\n+    fn test_equal_sneaky_big() {\n         let mut a = bitv::Bitv::new(100, false);\n         for uint::range(0, 100) |i| {\n             a.set(i, true);\n@@ -1218,14 +1218,14 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_from_bytes() {\n+    fn test_from_bytes() {\n         let bitv = from_bytes([0b10110110, 0b00000000, 0b11111111]);\n         let str = ~\"10110110\" + ~\"00000000\" + ~\"11111111\";\n         assert!(bitv.to_str() == str);\n     }\n \n     #[test]\n-    pub fn test_to_bytes() {\n+    fn test_to_bytes() {\n         let mut bv = Bitv::new(3, true);\n         bv.set(1, false);\n         assert!(bv.to_bytes() == ~[0b10100000]);\n@@ -1237,19 +1237,19 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_from_bools() {\n+    fn test_from_bools() {\n         assert!(from_bools([true, false, true, true]).to_str() ==\n             ~\"1011\");\n     }\n \n     #[test]\n-    pub fn test_to_bools() {\n+    fn test_to_bools() {\n         let bools = ~[false, false, true, false, false, true, true, false];\n         assert!(from_bytes([0b00100110]).to_bools() == bools);\n     }\n \n     #[test]\n-    pub fn test_small_difference() {\n+    fn test_small_difference() {\n         let mut b1 = Bitv::new(3, false);\n         let mut b2 = Bitv::new(3, false);\n         b1.set(0, true);\n@@ -1263,7 +1263,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_big_difference() {\n+    fn test_big_difference() {\n         let mut b1 = Bitv::new(100, false);\n         let mut b2 = Bitv::new(100, false);\n         b1.set(0, true);\n@@ -1277,7 +1277,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_small_clear() {\n+    fn test_small_clear() {\n         let mut b = Bitv::new(14, true);\n         b.clear();\n         for b.ones |i| {\n@@ -1286,7 +1286,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_big_clear() {\n+    fn test_big_clear() {\n         let mut b = Bitv::new(140, true);\n         b.clear();\n         for b.ones |i| {\n@@ -1295,7 +1295,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_bitv_set_basic() {\n+    fn test_bitv_set_basic() {\n         let mut b = BitvSet::new();\n         assert!(b.insert(3));\n         assert!(!b.insert(3));\n@@ -1382,7 +1382,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_bitv_set_union() {\n+    fn test_bitv_set_union() {\n         let mut a = BitvSet::new();\n         let mut b = BitvSet::new();\n         assert!(a.insert(1));\n@@ -1410,7 +1410,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_bitv_remove() {\n+    fn test_bitv_remove() {\n         let mut a = BitvSet::new();\n \n         assert!(a.insert(1));\n@@ -1430,7 +1430,7 @@ mod tests {\n     }\n \n     #[bench]\n-    pub fn bench_uint_small(b: &mut BenchHarness) {\n+    fn bench_uint_small(b: &mut BenchHarness) {\n         let r = rng();\n         let mut bitv = 0 as uint;\n         do b.iter {\n@@ -1439,7 +1439,7 @@ mod tests {\n     }\n \n     #[bench]\n-    pub fn bench_small_bitv_small(b: &mut BenchHarness) {\n+    fn bench_small_bitv_small(b: &mut BenchHarness) {\n         let r = rng();\n         let mut bitv = SmallBitv::new(uint::bits);\n         do b.iter {\n@@ -1448,7 +1448,7 @@ mod tests {\n     }\n \n     #[bench]\n-    pub fn bench_big_bitv_small(b: &mut BenchHarness) {\n+    fn bench_big_bitv_small(b: &mut BenchHarness) {\n         let r = rng();\n         let mut bitv = BigBitv::new(~[0]);\n         do b.iter {\n@@ -1457,7 +1457,7 @@ mod tests {\n     }\n \n     #[bench]\n-    pub fn bench_big_bitv_big(b: &mut BenchHarness) {\n+    fn bench_big_bitv_big(b: &mut BenchHarness) {\n         let r = rng();\n         let mut storage = ~[];\n         storage.grow(bench_bits / uint::bits, &0);\n@@ -1468,7 +1468,7 @@ mod tests {\n     }\n \n     #[bench]\n-    pub fn bench_bitv_big(b: &mut BenchHarness) {\n+    fn bench_bitv_big(b: &mut BenchHarness) {\n         let r = rng();\n         let mut bitv = Bitv::new(bench_bits, false);\n         do b.iter {\n@@ -1477,7 +1477,7 @@ mod tests {\n     }\n \n     #[bench]\n-    pub fn bench_bitv_small(b: &mut BenchHarness) {\n+    fn bench_bitv_small(b: &mut BenchHarness) {\n         let r = rng();\n         let mut bitv = Bitv::new(uint::bits, false);\n         do b.iter {\n@@ -1486,7 +1486,7 @@ mod tests {\n     }\n \n     #[bench]\n-    pub fn bench_bitv_set_small(b: &mut BenchHarness) {\n+    fn bench_bitv_set_small(b: &mut BenchHarness) {\n         let r = rng();\n         let mut bitv = BitvSet::new();\n         do b.iter {\n@@ -1495,7 +1495,7 @@ mod tests {\n     }\n \n     #[bench]\n-    pub fn bench_bitv_set_big(b: &mut BenchHarness) {\n+    fn bench_bitv_set_big(b: &mut BenchHarness) {\n         let r = rng();\n         let mut bitv = BitvSet::new();\n         do b.iter {\n@@ -1504,7 +1504,7 @@ mod tests {\n     }\n \n     #[bench]\n-    pub fn bench_bitv_big_union(b: &mut BenchHarness) {\n+    fn bench_bitv_big_union(b: &mut BenchHarness) {\n         let mut b1 = Bitv::new(bench_bits, false);\n         let mut b2 = Bitv::new(bench_bits, false);\n         do b.iter {"}, {"sha": "f9de2e0f58ad0ca3d509c08856b67be4b2a501ec", "filename": "src/libstd/dlist.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdlist.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -537,7 +537,7 @@ mod tests {\n     use core::prelude::*;\n \n     #[test]\n-    pub fn test_dlist_concat() {\n+    fn test_dlist_concat() {\n         let a = from_vec(~[1,2]);\n         let b = from_vec(~[3,4]);\n         let c = from_vec(~[5,6]);\n@@ -557,7 +557,7 @@ mod tests {\n         abcd.assert_consistent(); assert!(abcd.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_append() {\n+    fn test_dlist_append() {\n         let a = from_vec(~[1,2,3]);\n         let b = from_vec(~[4,5,6]);\n         a.append(b);\n@@ -573,7 +573,7 @@ mod tests {\n         a.assert_consistent(); assert!(a.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_append_empty() {\n+    fn test_dlist_append_empty() {\n         let a = from_vec(~[1,2,3]);\n         let b = DList::<int>();\n         a.append(b);\n@@ -586,7 +586,7 @@ mod tests {\n         a.assert_consistent(); assert!(a.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_append_to_empty() {\n+    fn test_dlist_append_to_empty() {\n         let a = DList::<int>();\n         let b = from_vec(~[4,5,6]);\n         a.append(b);\n@@ -599,7 +599,7 @@ mod tests {\n         a.assert_consistent(); assert!(a.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_append_two_empty() {\n+    fn test_dlist_append_two_empty() {\n         let a = DList::<int>();\n         let b = DList::<int>();\n         a.append(b);\n@@ -611,19 +611,19 @@ mod tests {\n     #[test]\n     #[ignore(cfg(windows))]\n     #[should_fail]\n-    pub fn test_dlist_append_self() {\n+    fn test_dlist_append_self() {\n         let a = DList::<int>();\n         a.append(a);\n     }\n     #[test]\n     #[ignore(cfg(windows))]\n     #[should_fail]\n-    pub fn test_dlist_prepend_self() {\n+    fn test_dlist_prepend_self() {\n         let a = DList::<int>();\n         a.prepend(a);\n     }\n     #[test]\n-    pub fn test_dlist_prepend() {\n+    fn test_dlist_prepend() {\n         let a = from_vec(~[1,2,3]);\n         let b = from_vec(~[4,5,6]);\n         b.prepend(a);\n@@ -639,7 +639,7 @@ mod tests {\n         b.assert_consistent(); assert!(b.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_reverse() {\n+    fn test_dlist_reverse() {\n         let a = from_vec(~[5,4,3,2,1]);\n         a.reverse();\n         assert_eq!(a.len(), 5);\n@@ -651,14 +651,14 @@ mod tests {\n         a.assert_consistent(); assert!(a.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_reverse_empty() {\n+    fn test_dlist_reverse_empty() {\n         let a = DList::<int>();\n         a.reverse();\n         assert_eq!(a.len(), 0);\n         a.assert_consistent();\n     }\n     #[test]\n-    pub fn test_dlist_each_node() {\n+    fn test_dlist_each_node() {\n         let a = from_vec(~[1,2,4,5]);\n         for a.each_node |nobe| {\n             if nobe.data > 3 {\n@@ -675,28 +675,28 @@ mod tests {\n         a.assert_consistent(); assert!(a.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_clear() {\n+    fn test_dlist_clear() {\n         let a = from_vec(~[5,4,3,2,1]);\n         a.clear();\n         assert_eq!(a.len(), 0);\n         a.assert_consistent();\n     }\n     #[test]\n-    pub fn test_dlist_is_empty() {\n+    fn test_dlist_is_empty() {\n         let empty = DList::<int>();\n         let full1 = from_vec(~[1,2,3]);\n         assert!(empty.is_empty());\n         assert!(!full1.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_head_tail() {\n+    fn test_dlist_head_tail() {\n         let l = from_vec(~[1,2,3]);\n         assert_eq!(l.head(), 1);\n         assert_eq!(l.tail(), 3);\n         assert_eq!(l.len(), 3);\n     }\n     #[test]\n-    pub fn test_dlist_pop() {\n+    fn test_dlist_pop() {\n         let l = from_vec(~[1,2,3]);\n         assert_eq!(l.pop().get(), 1);\n         assert_eq!(l.tail(), 3);\n@@ -709,7 +709,7 @@ mod tests {\n         assert!(l.pop().is_none());\n     }\n     #[test]\n-    pub fn test_dlist_pop_tail() {\n+    fn test_dlist_pop_tail() {\n         let l = from_vec(~[1,2,3]);\n         assert_eq!(l.pop_tail().get(), 3);\n         assert_eq!(l.tail(), 2);\n@@ -722,7 +722,7 @@ mod tests {\n         assert!(l.pop_tail().is_none());\n     }\n     #[test]\n-    pub fn test_dlist_push() {\n+    fn test_dlist_push() {\n         let l = DList::<int>();\n         l.push(1);\n         assert_eq!(l.head(), 1);\n@@ -736,7 +736,7 @@ mod tests {\n         assert_eq!(l.len(), 3);\n     }\n     #[test]\n-    pub fn test_dlist_push_head() {\n+    fn test_dlist_push_head() {\n         let l = DList::<int>();\n         l.push_head(3);\n         assert_eq!(l.head(), 3);\n@@ -750,12 +750,12 @@ mod tests {\n         assert_eq!(l.len(), 3);\n     }\n     #[test]\n-    pub fn test_dlist_foldl() {\n+    fn test_dlist_foldl() {\n         let l = from_vec(vec::from_fn(101, |x|x));\n         assert_eq!(iter::foldl(&l, 0, |accum,elem| *accum+*elem), 5050);\n     }\n     #[test]\n-    pub fn test_dlist_break_early() {\n+    fn test_dlist_break_early() {\n         let l = from_vec(~[1,2,3,4,5]);\n         let mut x = 0;\n         for l.each |i| {\n@@ -765,7 +765,7 @@ mod tests {\n         assert_eq!(x, 3);\n     }\n     #[test]\n-    pub fn test_dlist_remove_head() {\n+    fn test_dlist_remove_head() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n@@ -780,7 +780,7 @@ mod tests {\n         l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_remove_mid() {\n+    fn test_dlist_remove_mid() {\n         let l = DList::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n@@ -795,7 +795,7 @@ mod tests {\n         l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_remove_tail() {\n+    fn test_dlist_remove_tail() {\n         let l = DList::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n@@ -810,7 +810,7 @@ mod tests {\n         l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_remove_one_two() {\n+    fn test_dlist_remove_one_two() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n@@ -826,7 +826,7 @@ mod tests {\n         l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_remove_one_three() {\n+    fn test_dlist_remove_one_three() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n@@ -841,7 +841,7 @@ mod tests {\n         l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_remove_two_three() {\n+    fn test_dlist_remove_two_three() {\n         let l = DList::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n@@ -856,7 +856,7 @@ mod tests {\n         l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_remove_all() {\n+    fn test_dlist_remove_all() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n@@ -869,7 +869,7 @@ mod tests {\n         l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_insert_n_before() {\n+    fn test_dlist_insert_n_before() {\n         let l = DList::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n@@ -885,7 +885,7 @@ mod tests {\n         l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_insert_n_after() {\n+    fn test_dlist_insert_n_after() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n@@ -901,7 +901,7 @@ mod tests {\n         l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_insert_before_head() {\n+    fn test_dlist_insert_before_head() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n@@ -916,7 +916,7 @@ mod tests {\n         l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_insert_after_tail() {\n+    fn test_dlist_insert_after_tail() {\n         let l = DList::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n@@ -931,15 +931,15 @@ mod tests {\n         l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn test_dlist_asymmetric_link() {\n+    fn test_dlist_asymmetric_link() {\n         let l = DList::<int>();\n         let _one = l.push_n(1);\n         let two = l.push_n(2);\n         two.prev = None;\n         l.assert_consistent();\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn test_dlist_cyclic_list() {\n+    fn test_dlist_cyclic_list() {\n         let l = DList::<int>();\n         let one = l.push_n(1);\n         let _two = l.push_n(2);\n@@ -949,32 +949,32 @@ mod tests {\n         l.assert_consistent();\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn test_dlist_headless() {\n+    fn test_dlist_headless() {\n         DList::<int>().head();\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn test_dlist_insert_already_present_before() {\n+    fn test_dlist_insert_already_present_before() {\n         let l = DList::<int>();\n         let one = l.push_n(1);\n         let two = l.push_n(2);\n         l.insert_n_before(two, one);\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn test_dlist_insert_already_present_after() {\n+    fn test_dlist_insert_already_present_after() {\n         let l = DList::<int>();\n         let one = l.push_n(1);\n         let two = l.push_n(2);\n         l.insert_n_after(one, two);\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn test_dlist_insert_before_orphan() {\n+    fn test_dlist_insert_before_orphan() {\n         let l = DList::<int>();\n         let one = new_dlist_node(1);\n         let two = new_dlist_node(2);\n         l.insert_n_before(one, two);\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn test_dlist_insert_after_orphan() {\n+    fn test_dlist_insert_after_orphan() {\n         let l = DList::<int>();\n         let one = new_dlist_node(1);\n         let two = new_dlist_node(2);"}, {"sha": "a36f67fc95a006d890d54959ea69d105cddd95c4", "filename": "src/libstd/future.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -172,7 +172,7 @@ pub fn spawn<A:Owned>(blk: ~fn() -> A) -> Future<A> {\n \n #[allow(non_implicitly_copyable_typarams)]\n #[cfg(test)]\n-pub mod test {\n+mod test {\n     use core::prelude::*;\n \n     use future::*;\n@@ -181,53 +181,53 @@ pub mod test {\n     use core::task;\n \n     #[test]\n-    pub fn test_from_value() {\n+    fn test_from_value() {\n         let f = from_value(~\"snail\");\n         assert!(f.get() == ~\"snail\");\n     }\n \n     #[test]\n-    pub fn test_from_port() {\n+    fn test_from_port() {\n         let (ch, po) = oneshot::init();\n         send_one(ch, ~\"whale\");\n         let f = from_port(po);\n         assert!(f.get() == ~\"whale\");\n     }\n \n     #[test]\n-    pub fn test_from_fn() {\n+    fn test_from_fn() {\n         let f = from_fn(|| ~\"brail\");\n         assert!(f.get() == ~\"brail\");\n     }\n \n     #[test]\n-    pub fn test_interface_get() {\n+    fn test_interface_get() {\n         let f = from_value(~\"fail\");\n         assert!(f.get() == ~\"fail\");\n     }\n \n     #[test]\n-    pub fn test_get_ref_method() {\n+    fn test_get_ref_method() {\n         let f = from_value(22);\n         assert!(*f.get_ref() == 22);\n     }\n \n     #[test]\n-    pub fn test_spawn() {\n+    fn test_spawn() {\n         let f = spawn(|| ~\"bale\");\n         assert!(f.get() == ~\"bale\");\n     }\n \n     #[test]\n     #[should_fail]\n     #[ignore(cfg(target_os = \"win32\"))]\n-    pub fn test_futurefail() {\n+    fn test_futurefail() {\n         let f = spawn(|| fail!());\n         let _x: ~str = f.get();\n     }\n \n     #[test]\n-    pub fn test_sendable_future() {\n+    fn test_sendable_future() {\n         let expected = ~\"schlorf\";\n         let f = do spawn { copy expected };\n         do task::spawn || {"}, {"sha": "d710a7b873548127d4ef462d1230aa0c02f66675", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -662,7 +662,7 @@ mod tests {\n     use core::result::{Err, Ok};\n     use core::result;\n \n-    pub fn check_fail_type(f: Fail_, ft: FailType) {\n+    fn check_fail_type(f: Fail_, ft: FailType) {\n         match f {\n           ArgumentMissing(_) => assert!(ft == ArgumentMissing_),\n           UnrecognizedOption(_) => assert!(ft == UnrecognizedOption_),\n@@ -675,7 +675,7 @@ mod tests {\n \n     // Tests for reqopt\n     #[test]\n-    pub fn test_reqopt_long() {\n+    fn test_reqopt_long() {\n         let args = ~[~\"--test=20\"];\n         let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -689,7 +689,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_reqopt_long_missing() {\n+    fn test_reqopt_long_missing() {\n         let args = ~[~\"blah\"];\n         let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -700,7 +700,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_reqopt_long_no_arg() {\n+    fn test_reqopt_long_no_arg() {\n         let args = ~[~\"--test\"];\n         let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -711,7 +711,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_reqopt_long_multi() {\n+    fn test_reqopt_long_multi() {\n         let args = ~[~\"--test=20\", ~\"--test=30\"];\n         let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -722,7 +722,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_reqopt_short() {\n+    fn test_reqopt_short() {\n         let args = ~[~\"-t\", ~\"20\"];\n         let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -736,7 +736,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_reqopt_short_missing() {\n+    fn test_reqopt_short_missing() {\n         let args = ~[~\"blah\"];\n         let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -747,7 +747,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_reqopt_short_no_arg() {\n+    fn test_reqopt_short_no_arg() {\n         let args = ~[~\"-t\"];\n         let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -758,7 +758,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_reqopt_short_multi() {\n+    fn test_reqopt_short_multi() {\n         let args = ~[~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n         let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -771,7 +771,7 @@ mod tests {\n \n     // Tests for optopt\n     #[test]\n-    pub fn test_optopt_long() {\n+    fn test_optopt_long() {\n         let args = ~[~\"--test=20\"];\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -785,7 +785,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optopt_long_missing() {\n+    fn test_optopt_long_missing() {\n         let args = ~[~\"blah\"];\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -796,7 +796,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optopt_long_no_arg() {\n+    fn test_optopt_long_no_arg() {\n         let args = ~[~\"--test\"];\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -807,7 +807,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optopt_long_multi() {\n+    fn test_optopt_long_multi() {\n         let args = ~[~\"--test=20\", ~\"--test=30\"];\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -818,7 +818,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optopt_short() {\n+    fn test_optopt_short() {\n         let args = ~[~\"-t\", ~\"20\"];\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -832,7 +832,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optopt_short_missing() {\n+    fn test_optopt_short_missing() {\n         let args = ~[~\"blah\"];\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -843,7 +843,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optopt_short_no_arg() {\n+    fn test_optopt_short_no_arg() {\n         let args = ~[~\"-t\"];\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -854,7 +854,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optopt_short_multi() {\n+    fn test_optopt_short_multi() {\n         let args = ~[~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -867,7 +867,7 @@ mod tests {\n \n     // Tests for optflag\n     #[test]\n-    pub fn test_optflag_long() {\n+    fn test_optflag_long() {\n         let args = ~[~\"--test\"];\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -878,7 +878,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optflag_long_missing() {\n+    fn test_optflag_long_missing() {\n         let args = ~[~\"blah\"];\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -889,7 +889,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optflag_long_arg() {\n+    fn test_optflag_long_arg() {\n         let args = ~[~\"--test=20\"];\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -903,7 +903,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optflag_long_multi() {\n+    fn test_optflag_long_multi() {\n         let args = ~[~\"--test\", ~\"--test\"];\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -914,7 +914,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optflag_short() {\n+    fn test_optflag_short() {\n         let args = ~[~\"-t\"];\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -925,7 +925,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optflag_short_missing() {\n+    fn test_optflag_short_missing() {\n         let args = ~[~\"blah\"];\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -936,7 +936,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optflag_short_arg() {\n+    fn test_optflag_short_arg() {\n         let args = ~[~\"-t\", ~\"20\"];\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -951,7 +951,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optflag_short_multi() {\n+    fn test_optflag_short_multi() {\n         let args = ~[~\"-t\", ~\"-t\"];\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -963,7 +963,7 @@ mod tests {\n \n     // Tests for optflagmulti\n     #[test]\n-    pub fn test_optflagmulti_short1() {\n+    fn test_optflagmulti_short1() {\n         let args = ~[~\"-v\"];\n         let opts = ~[optflagmulti(~\"v\")];\n         let rs = getopts(args, opts);\n@@ -976,7 +976,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optflagmulti_short2a() {\n+    fn test_optflagmulti_short2a() {\n         let args = ~[~\"-v\", ~\"-v\"];\n         let opts = ~[optflagmulti(~\"v\")];\n         let rs = getopts(args, opts);\n@@ -989,7 +989,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optflagmulti_short2b() {\n+    fn test_optflagmulti_short2b() {\n         let args = ~[~\"-vv\"];\n         let opts = ~[optflagmulti(~\"v\")];\n         let rs = getopts(args, opts);\n@@ -1002,7 +1002,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optflagmulti_long1() {\n+    fn test_optflagmulti_long1() {\n         let args = ~[~\"--verbose\"];\n         let opts = ~[optflagmulti(~\"verbose\")];\n         let rs = getopts(args, opts);\n@@ -1015,7 +1015,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optflagmulti_long2() {\n+    fn test_optflagmulti_long2() {\n         let args = ~[~\"--verbose\", ~\"--verbose\"];\n         let opts = ~[optflagmulti(~\"verbose\")];\n         let rs = getopts(args, opts);\n@@ -1029,7 +1029,7 @@ mod tests {\n \n     // Tests for optmulti\n     #[test]\n-    pub fn test_optmulti_long() {\n+    fn test_optmulti_long() {\n         let args = ~[~\"--test=20\"];\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -1043,7 +1043,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optmulti_long_missing() {\n+    fn test_optmulti_long_missing() {\n         let args = ~[~\"blah\"];\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -1054,7 +1054,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optmulti_long_no_arg() {\n+    fn test_optmulti_long_no_arg() {\n         let args = ~[~\"--test\"];\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -1065,7 +1065,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optmulti_long_multi() {\n+    fn test_optmulti_long_multi() {\n         let args = ~[~\"--test=20\", ~\"--test=30\"];\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -1082,7 +1082,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optmulti_short() {\n+    fn test_optmulti_short() {\n         let args = ~[~\"-t\", ~\"20\"];\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -1096,7 +1096,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optmulti_short_missing() {\n+    fn test_optmulti_short_missing() {\n         let args = ~[~\"blah\"];\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -1107,7 +1107,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optmulti_short_no_arg() {\n+    fn test_optmulti_short_no_arg() {\n         let args = ~[~\"-t\"];\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -1118,7 +1118,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optmulti_short_multi() {\n+    fn test_optmulti_short_multi() {\n         let args = ~[~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -1135,7 +1135,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_unrecognized_option_long() {\n+    fn test_unrecognized_option_long() {\n         let args = ~[~\"--untest\"];\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -1146,7 +1146,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_unrecognized_option_short() {\n+    fn test_unrecognized_option_short() {\n         let args = ~[~\"-t\"];\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -1157,7 +1157,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_combined() {\n+    fn test_combined() {\n         let args =\n             ~[~\"prog\", ~\"free1\", ~\"-s\", ~\"20\", ~\"free2\",\n               ~\"--flag\", ~\"--long=30\", ~\"-f\", ~\"-m\", ~\"40\",\n@@ -1189,7 +1189,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_multi() {\n+    fn test_multi() {\n         let args = ~[~\"-e\", ~\"foo\", ~\"--encrypt\", ~\"foo\"];\n         let opts = ~[optopt(~\"e\"), optopt(~\"encrypt\"), optopt(~\"f\")];\n         let matches = &match getopts(args, opts) {\n@@ -1211,7 +1211,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_nospace() {\n+    fn test_nospace() {\n         let args = ~[~\"-Lfoo\", ~\"-M.\"];\n         let opts = ~[optmulti(~\"L\"), optmulti(~\"M\")];\n         let matches = &match getopts(args, opts) {\n@@ -1226,7 +1226,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_groups_reqopt() {\n+    fn test_groups_reqopt() {\n         let opt = groups::reqopt(~\"b\", ~\"banana\", ~\"some bananas\", ~\"VAL\");\n         assert!(opt == OptGroup { short_name: ~\"b\",\n                         long_name: ~\"banana\",\n@@ -1237,7 +1237,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_groups_optopt() {\n+    fn test_groups_optopt() {\n         let opt = groups::optopt(~\"a\", ~\"apple\", ~\"some apples\", ~\"VAL\");\n         assert!(opt == OptGroup { short_name: ~\"a\",\n                         long_name: ~\"apple\",\n@@ -1248,7 +1248,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_groups_optflag() {\n+    fn test_groups_optflag() {\n         let opt = groups::optflag(~\"k\", ~\"kiwi\", ~\"some kiwis\");\n         assert!(opt == OptGroup { short_name: ~\"k\",\n                         long_name: ~\"kiwi\",\n@@ -1259,7 +1259,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_groups_optflagopt() {\n+    fn test_groups_optflagopt() {\n         let opt = groups::optflagopt(~\"p\", ~\"pineapple\",\n                                        ~\"some pineapples\", ~\"VAL\");\n         assert!(opt == OptGroup { short_name: ~\"p\",\n@@ -1271,7 +1271,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_groups_optmulti() {\n+    fn test_groups_optmulti() {\n         let opt = groups::optmulti(~\"l\", ~\"lime\",\n                                      ~\"some limes\", ~\"VAL\");\n         assert!(opt == OptGroup { short_name: ~\"l\",\n@@ -1283,7 +1283,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_groups_long_to_short() {\n+    fn test_groups_long_to_short() {\n         let short = ~[reqopt(~\"b\"), reqopt(~\"banana\")];\n         let verbose = groups::reqopt(~\"b\", ~\"banana\",\n                                        ~\"some bananas\", ~\"VAL\");\n@@ -1292,7 +1292,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_groups_getopts() {\n+    fn test_groups_getopts() {\n         let short = ~[\n             reqopt(~\"b\"), reqopt(~\"banana\"),\n             optopt(~\"a\"), optopt(~\"apple\"),\n@@ -1318,7 +1318,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_groups_usage() {\n+    fn test_groups_usage() {\n         let optgroups = ~[\n             groups::reqopt(~\"b\", ~\"banana\", ~\"Desc\", ~\"VAL\"),\n             groups::optopt(~\"a\", ~\"012345678901234567890123456789\",\n@@ -1349,7 +1349,7 @@ Options:\n     }\n \n     #[test]\n-    pub fn test_groups_usage_description_wrapping() {\n+    fn test_groups_usage_description_wrapping() {\n         // indentation should be 24 spaces\n         // lines wrap after 78: or rather descriptions wrap after 54\n "}, {"sha": "8e173ff8a9c6a34b5b6dd7a36bc5046ba9e3531d", "filename": "src/libstd/list.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -160,7 +160,7 @@ mod tests {\n     use core::option;\n \n     #[test]\n-    pub fn test_is_empty() {\n+    fn test_is_empty() {\n         let empty : @list::List<int> = from_vec(~[]);\n         let full1 = from_vec(~[1]);\n         let full2 = from_vec(~['r', 'u']);\n@@ -171,7 +171,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_from_vec() {\n+    fn test_from_vec() {\n         let l = from_vec(~[0, 1, 2]);\n \n         assert!((head(l) == 0));\n@@ -184,13 +184,13 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_from_vec_empty() {\n+    fn test_from_vec_empty() {\n         let empty : @list::List<int> = from_vec(~[]);\n         assert!((empty == @list::Nil::<int>));\n     }\n \n     #[test]\n-    pub fn test_foldl() {\n+    fn test_foldl() {\n         fn add(a: &uint, b: &int) -> uint { return *a + (*b as uint); }\n         let l = from_vec(~[0, 1, 2, 3, 4]);\n         let empty = @list::Nil::<int>;\n@@ -199,7 +199,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_foldl2() {\n+    fn test_foldl2() {\n         fn sub(a: &int, b: &int) -> int {\n             *a - *b\n         }\n@@ -208,14 +208,14 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_find_success() {\n+    fn test_find_success() {\n         fn match_(i: &int) -> bool { return *i == 2; }\n         let l = from_vec(~[0, 1, 2]);\n         assert!((list::find(l, match_) == option::Some(2)));\n     }\n \n     #[test]\n-    pub fn test_find_fail() {\n+    fn test_find_fail() {\n         fn match_(_i: &int) -> bool { return false; }\n         let l = from_vec(~[0, 1, 2]);\n         let empty = @list::Nil::<int>;\n@@ -224,7 +224,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_has() {\n+    fn test_has() {\n         let l = from_vec(~[5, 8, 6]);\n         let empty = @list::Nil::<int>;\n         assert!((list::has(l, 5)));\n@@ -234,15 +234,15 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_len() {\n+    fn test_len() {\n         let l = from_vec(~[0, 1, 2]);\n         let empty = @list::Nil::<int>;\n         assert!((list::len(l) == 3u));\n         assert!((list::len(empty) == 0u));\n     }\n \n     #[test]\n-    pub fn test_append() {\n+    fn test_append() {\n         assert!(from_vec(~[1,2,3,4])\n             == list::append(list::from_vec(~[1,2]), list::from_vec(~[3,4])));\n     }"}, {"sha": "b32df75063d97941bf3bc796283bd4db418cf5e8", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -1426,7 +1426,7 @@ struct TcpBufferedSocketData {\n }\n \n #[cfg(test)]\n-pub mod test {\n+mod test {\n     use net::ip;\n     use net::tcp::{GenericListenErr, TcpConnectErrData, TcpListenErrData};\n     use net::tcp::{connect, accept, read, listen, TcpSocket, socket_buf};\n@@ -1447,9 +1447,9 @@ pub mod test {\n     #[cfg(target_os=\"darwin\")]\n     #[cfg(target_os=\"linux\")]\n     #[cfg(target_os=\"android\")]\n-    pub mod tcp_ipv4_server_and_client_test {\n+    mod tcp_ipv4_server_and_client_test {\n         #[cfg(target_arch=\"x86_64\")]\n-        pub mod impl64 {\n+        mod impl64 {\n             use net::tcp::test::*;\n \n             #[test]\n@@ -1497,7 +1497,7 @@ pub mod test {\n         #[cfg(target_arch=\"x86\")]\n         #[cfg(target_arch=\"arm\")]\n         #[cfg(target_arch=\"mips\")]\n-        pub mod impl32 {\n+        mod impl32 {\n             use net::tcp::test::*;\n \n             #[test]"}, {"sha": "4cb9a98036b19dca251aa0625c89dd96e75c4666", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -810,7 +810,7 @@ mod tests {\n     use core::hashmap::HashMap;\n \n     #[test]\n-    pub fn test_url_parse() {\n+    fn test_url_parse() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?s=v#something\";\n \n         let up = from_str(url);\n@@ -826,109 +826,109 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_url_parse_host_slash() {\n+    fn test_url_parse_host_slash() {\n         let urlstr = ~\"http://0.42.42.42/\";\n         let url = from_str(urlstr).unwrap();\n         assert!(url.host == ~\"0.42.42.42\");\n         assert!(url.path == ~\"/\");\n     }\n \n     #[test]\n-    pub fn test_url_with_underscores() {\n+    fn test_url_with_underscores() {\n         let urlstr = ~\"http://dotcom.com/file_name.html\";\n         let url = from_str(urlstr).unwrap();\n         assert!(url.path == ~\"/file_name.html\");\n     }\n \n     #[test]\n-    pub fn test_url_with_dashes() {\n+    fn test_url_with_dashes() {\n         let urlstr = ~\"http://dotcom.com/file-name.html\";\n         let url = from_str(urlstr).unwrap();\n         assert!(url.path == ~\"/file-name.html\");\n     }\n \n     #[test]\n-    pub fn test_no_scheme() {\n+    fn test_no_scheme() {\n         assert!(get_scheme(\"noschemehere.html\").is_err());\n     }\n \n     #[test]\n-    pub fn test_invalid_scheme_errors() {\n+    fn test_invalid_scheme_errors() {\n         assert!(from_str(\"99://something\").is_err());\n         assert!(from_str(\"://something\").is_err());\n     }\n \n     #[test]\n-    pub fn test_full_url_parse_and_format() {\n+    fn test_full_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?s=v#something\";\n         assert!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n-    pub fn test_userless_url_parse_and_format() {\n+    fn test_userless_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org/doc?s=v#something\";\n         assert!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n-    pub fn test_queryless_url_parse_and_format() {\n+    fn test_queryless_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc#something\";\n         assert!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n-    pub fn test_empty_query_url_parse_and_format() {\n+    fn test_empty_query_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?#something\";\n         let should_be = ~\"http://user:pass@rust-lang.org/doc#something\";\n         assert!(from_str(url).unwrap().to_str() == should_be);\n     }\n \n     #[test]\n-    pub fn test_fragmentless_url_parse_and_format() {\n+    fn test_fragmentless_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?q=v\";\n         assert!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n-    pub fn test_minimal_url_parse_and_format() {\n+    fn test_minimal_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org/doc\";\n         assert!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n-    pub fn test_scheme_host_only_url_parse_and_format() {\n+    fn test_scheme_host_only_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org\";\n         assert!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n-    pub fn test_pathless_url_parse_and_format() {\n+    fn test_pathless_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org?q=v#something\";\n         assert!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n-    pub fn test_scheme_host_fragment_only_url_parse_and_format() {\n+    fn test_scheme_host_fragment_only_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org#something\";\n         assert!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n-    pub fn test_url_component_encoding() {\n+    fn test_url_component_encoding() {\n         let url = ~\"http://rust-lang.org/doc%20uments?ba%25d%20=%23%26%2B\";\n         let u = from_str(url).unwrap();\n         assert!(u.path == ~\"/doc uments\");\n         assert!(u.query == ~[(~\"ba%d \", ~\"#&+\")]);\n     }\n \n     #[test]\n-    pub fn test_url_without_authority() {\n+    fn test_url_without_authority() {\n         let url = ~\"mailto:test@email.com\";\n         assert!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n-    pub fn test_encode() {\n+    fn test_encode() {\n         assert!(encode(\"\") == ~\"\");\n         assert!(encode(\"http://example.com\") == ~\"http://example.com\");\n         assert!(encode(\"foo bar% baz\") == ~\"foo%20bar%25%20baz\");\n@@ -956,7 +956,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_encode_component() {\n+    fn test_encode_component() {\n         assert!(encode_component(\"\") == ~\"\");\n         assert!(encode_component(\"http://example.com\") ==\n             ~\"http%3A%2F%2Fexample.com\");\n@@ -985,7 +985,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_decode() {\n+    fn test_decode() {\n         assert!(decode(\"\") == ~\"\");\n         assert!(decode(\"abc/def 123\") == ~\"abc/def 123\");\n         assert!(decode(\"abc%2Fdef%20123\") == ~\"abc%2Fdef 123\");\n@@ -1013,7 +1013,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_decode_component() {\n+    fn test_decode_component() {\n         assert!(decode_component(\"\") == ~\"\");\n         assert!(decode_component(\"abc/def 123\") == ~\"abc/def 123\");\n         assert!(decode_component(\"abc%2Fdef%20123\") == ~\"abc/def 123\");\n@@ -1041,7 +1041,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_encode_form_urlencoded() {\n+    fn test_encode_form_urlencoded() {\n         let mut m = HashMap::new();\n         assert!(encode_form_urlencoded(&m) == ~\"\");\n \n@@ -1060,7 +1060,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_decode_form_urlencoded() {\n+    fn test_decode_form_urlencoded() {\n         // FIXME #4449: Commented out because this causes an ICE, but only\n         // on FreeBSD\n         /*"}, {"sha": "6aa4d1c54bc9e8e949558ca405cbe1d780b3a4ec", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -282,7 +282,7 @@ mod tests {\n     use core::vec;\n \n     #[test]\n-    pub fn test() {\n+    fn test() {\n         struct Test {\n             input: ~str,\n             output: ~[u8],"}, {"sha": "72a888fcc917be74b0fce4e07f773e5251562d02", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -733,7 +733,7 @@ mod test_qsort3 {\n \n     use core::vec;\n \n-    pub fn check_sort(v1: &mut [int], v2: &mut [int]) {\n+    fn check_sort(v1: &mut [int], v2: &mut [int]) {\n         let len = vec::len::<int>(v1);\n         quick_sort3::<int>(v1);\n         let mut i = 0;\n@@ -745,7 +745,7 @@ mod test_qsort3 {\n     }\n \n     #[test]\n-    pub fn test() {\n+    fn test() {\n         {\n             let mut v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n             let mut v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n@@ -777,7 +777,7 @@ mod test_qsort {\n     use core::int;\n     use core::vec;\n \n-    pub fn check_sort(v1: &mut [int], v2: &mut [int]) {\n+    fn check_sort(v1: &mut [int], v2: &mut [int]) {\n         let len = vec::len::<int>(v1);\n         fn leual(a: &int, b: &int) -> bool { *a <= *b }\n         quick_sort::<int>(v1, leual);\n@@ -790,7 +790,7 @@ mod test_qsort {\n     }\n \n     #[test]\n-    pub fn test() {\n+    fn test() {\n         {\n             let mut v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n             let mut v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n@@ -816,7 +816,7 @@ mod test_qsort {\n \n     // Regression test for #750\n     #[test]\n-    pub fn test_simple() {\n+    fn test_simple() {\n         let mut names = ~[2, 1, 3];\n \n         let expected = ~[1, 2, 3];\n@@ -842,7 +842,7 @@ mod tests {\n \n     use core::vec;\n \n-    pub fn check_sort(v1: &[int], v2: &[int]) {\n+    fn check_sort(v1: &[int], v2: &[int]) {\n         let len = vec::len::<int>(v1);\n         pub fn le(a: &int, b: &int) -> bool { *a <= *b }\n         let f = le;\n@@ -856,7 +856,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test() {\n+    fn test() {\n         {\n             let v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n             let v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n@@ -873,15 +873,15 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_merge_sort_mutable() {\n+    fn test_merge_sort_mutable() {\n         pub fn le(a: &int, b: &int) -> bool { *a <= *b }\n         let mut v1 = ~[3, 2, 1];\n         let v2 = merge_sort(v1, le);\n         assert!(v2 == ~[1, 2, 3]);\n     }\n \n     #[test]\n-    pub fn test_merge_sort_stability() {\n+    fn test_merge_sort_stability() {\n         // tjc: funny that we have to use parens\n         fn ile(x: &(&'static str), y: &(&'static str)) -> bool\n         {"}, {"sha": "971bb51f7e9f4b5e6679a06e8d52a2a994d459f4", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -728,19 +728,19 @@ mod tests {\n      * Semaphore tests\n      ************************************************************************/\n     #[test]\n-    pub fn test_sem_acquire_release() {\n+    fn test_sem_acquire_release() {\n         let s = ~semaphore(1);\n         s.acquire();\n         s.release();\n         s.acquire();\n     }\n     #[test]\n-    pub fn test_sem_basic() {\n+    fn test_sem_basic() {\n         let s = ~semaphore(1);\n         do s.access { }\n     }\n     #[test]\n-    pub fn test_sem_as_mutex() {\n+    fn test_sem_as_mutex() {\n         let s = ~semaphore(1);\n         let s2 = ~s.clone();\n         do task::spawn || {\n@@ -753,7 +753,7 @@ mod tests {\n         }\n     }\n     #[test]\n-    pub fn test_sem_as_cvar() {\n+    fn test_sem_as_cvar() {\n         /* Child waits and parent signals */\n         let (p,c) = comm::stream();\n         let s = ~semaphore(0);\n@@ -779,7 +779,7 @@ mod tests {\n         c.send(());\n     }\n     #[test]\n-    pub fn test_sem_multi_resource() {\n+    fn test_sem_multi_resource() {\n         // Parent and child both get in the critical section at the same\n         // time, and shake hands.\n         let s = ~semaphore(2);\n@@ -798,7 +798,7 @@ mod tests {\n         }\n     }\n     #[test]\n-    pub fn test_sem_runtime_friendly_blocking() {\n+    fn test_sem_runtime_friendly_blocking() {\n         // Force the runtime to schedule two threads on the same sched_loop.\n         // When one blocks, it should schedule the other one.\n         do task::spawn_sched(task::ManualThreads(1)) {\n@@ -823,7 +823,7 @@ mod tests {\n      * Mutex tests\n      ************************************************************************/\n     #[test]\n-    pub fn test_mutex_lock() {\n+    fn test_mutex_lock() {\n         // Unsafely achieve shared state, and do the textbook\n         // \"load tmp = move ptr; inc tmp; store ptr <- tmp\" dance.\n         let (p,c) = comm::stream();\n@@ -854,7 +854,7 @@ mod tests {\n         }\n     }\n     #[test]\n-    pub fn test_mutex_cond_wait() {\n+    fn test_mutex_cond_wait() {\n         let m = ~Mutex();\n \n         // Child wakes up parent\n@@ -886,7 +886,7 @@ mod tests {\n         let _ = port.recv(); // Wait until child wakes up\n     }\n     #[cfg(test)]\n-    pub fn test_mutex_cond_broadcast_helper(num_waiters: uint) {\n+    fn test_mutex_cond_broadcast_helper(num_waiters: uint) {\n         let m = ~Mutex();\n         let mut ports = ~[];\n \n@@ -913,15 +913,15 @@ mod tests {\n         for ports.each |port| { let _ = port.recv(); }\n     }\n     #[test]\n-    pub fn test_mutex_cond_broadcast() {\n+    fn test_mutex_cond_broadcast() {\n         test_mutex_cond_broadcast_helper(12);\n     }\n     #[test]\n-    pub fn test_mutex_cond_broadcast_none() {\n+    fn test_mutex_cond_broadcast_none() {\n         test_mutex_cond_broadcast_helper(0);\n     }\n     #[test]\n-    pub fn test_mutex_cond_no_waiter() {\n+    fn test_mutex_cond_no_waiter() {\n         let m = ~Mutex();\n         let m2 = ~m.clone();\n         do task::try || {\n@@ -932,7 +932,7 @@ mod tests {\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n-    pub fn test_mutex_killed_simple() {\n+    fn test_mutex_killed_simple() {\n         // Mutex must get automatically unlocked if failed/killed within.\n         let m = ~Mutex();\n         let m2 = ~m.clone();\n@@ -947,7 +947,7 @@ mod tests {\n         do m.lock { }\n     }\n     #[test] #[ignore(cfg(windows))]\n-    pub fn test_mutex_killed_cond() {\n+    fn test_mutex_killed_cond() {\n         // Getting killed during cond wait must not corrupt the mutex while\n         // unwinding (e.g. double unlock).\n         let m = ~Mutex();\n@@ -973,7 +973,7 @@ mod tests {\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n-    pub fn test_mutex_killed_broadcast() {\n+    fn test_mutex_killed_broadcast() {\n         let m = ~Mutex();\n         let m2 = ~m.clone();\n         let (p,c) = comm::stream();\n@@ -1026,7 +1026,7 @@ mod tests {\n         }\n     }\n     #[test]\n-    pub fn test_mutex_cond_signal_on_0() {\n+    fn test_mutex_cond_signal_on_0() {\n         // Tests that signal_on(0) is equivalent to signal().\n         let m = ~Mutex();\n         do m.lock_cond |cond| {\n@@ -1040,7 +1040,7 @@ mod tests {\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n-    pub fn test_mutex_different_conds() {\n+    fn test_mutex_different_conds() {\n         let result = do task::try {\n             let m = ~mutex_with_condvars(2);\n             let m2 = ~m.clone();\n@@ -1061,7 +1061,7 @@ mod tests {\n         assert!(result.is_err());\n     }\n     #[test] #[ignore(cfg(windows))]\n-    pub fn test_mutex_no_condvars() {\n+    fn test_mutex_no_condvars() {\n         let result = do task::try {\n             let m = ~mutex_with_condvars(0);\n             do m.lock_cond |cond| { cond.wait(); }\n@@ -1084,7 +1084,7 @@ mod tests {\n     #[cfg(test)]\n     pub enum RWlockMode { Read, Write, Downgrade, DowngradeRead }\n     #[cfg(test)]\n-    pub fn lock_rwlock_in_mode(x: &RWlock, mode: RWlockMode, blk: &fn()) {\n+    fn lock_rwlock_in_mode(x: &RWlock, mode: RWlockMode, blk: &fn()) {\n         match mode {\n             Read => x.read(blk),\n             Write => x.write(blk),\n@@ -1100,7 +1100,7 @@ mod tests {\n         }\n     }\n     #[cfg(test)]\n-    pub fn test_rwlock_exclusion(x: ~RWlock,\n+    fn test_rwlock_exclusion(x: ~RWlock,\n                                  mode1: RWlockMode,\n                                  mode2: RWlockMode) {\n         // Test mutual exclusion between readers and writers. Just like the\n@@ -1132,21 +1132,21 @@ mod tests {\n         }\n     }\n     #[test]\n-    pub fn test_rwlock_readers_wont_modify_the_data() {\n+    fn test_rwlock_readers_wont_modify_the_data() {\n         test_rwlock_exclusion(~RWlock(), Read, Write);\n         test_rwlock_exclusion(~RWlock(), Write, Read);\n         test_rwlock_exclusion(~RWlock(), Read, Downgrade);\n         test_rwlock_exclusion(~RWlock(), Downgrade, Read);\n     }\n     #[test]\n-    pub fn test_rwlock_writers_and_writers() {\n+    fn test_rwlock_writers_and_writers() {\n         test_rwlock_exclusion(~RWlock(), Write, Write);\n         test_rwlock_exclusion(~RWlock(), Write, Downgrade);\n         test_rwlock_exclusion(~RWlock(), Downgrade, Write);\n         test_rwlock_exclusion(~RWlock(), Downgrade, Downgrade);\n     }\n     #[cfg(test)]\n-    pub fn test_rwlock_handshake(x: ~RWlock,\n+    fn test_rwlock_handshake(x: ~RWlock,\n                                  mode1: RWlockMode,\n                                  mode2: RWlockMode,\n                                  make_mode2_go_first: bool) {\n@@ -1178,7 +1178,7 @@ mod tests {\n         }\n     }\n     #[test]\n-    pub fn test_rwlock_readers_and_readers() {\n+    fn test_rwlock_readers_and_readers() {\n         test_rwlock_handshake(~RWlock(), Read, Read, false);\n         // The downgrader needs to get in before the reader gets in, otherwise\n         // they cannot end up reading at the same time.\n@@ -1187,7 +1187,7 @@ mod tests {\n         // Two downgrade_reads can never both end up reading at the same time.\n     }\n     #[test]\n-    pub fn test_rwlock_downgrade_unlock() {\n+    fn test_rwlock_downgrade_unlock() {\n         // Tests that downgrade can unlock the lock in both modes\n         let x = ~RWlock();\n         do lock_rwlock_in_mode(x, Downgrade) { }\n@@ -1197,12 +1197,12 @@ mod tests {\n         test_rwlock_exclusion(y, Write, Write);\n     }\n     #[test]\n-    pub fn test_rwlock_read_recursive() {\n+    fn test_rwlock_read_recursive() {\n         let x = ~RWlock();\n         do x.read { do x.read { } }\n     }\n     #[test]\n-    pub fn test_rwlock_cond_wait() {\n+    fn test_rwlock_cond_wait() {\n         // As test_mutex_cond_wait above.\n         let x = ~RWlock();\n \n@@ -1237,7 +1237,7 @@ mod tests {\n         do x.read { } // Just for good measure\n     }\n     #[cfg(test)]\n-    pub fn test_rwlock_cond_broadcast_helper(num_waiters: uint,\n+    fn test_rwlock_cond_broadcast_helper(num_waiters: uint,\n                                              dg1: bool,\n                                              dg2: bool) {\n         // Much like the mutex broadcast test. Downgrade-enabled.\n@@ -1276,7 +1276,7 @@ mod tests {\n         for ports.each |port| { let _ = port.recv(); }\n     }\n     #[test]\n-    pub fn test_rwlock_cond_broadcast() {\n+    fn test_rwlock_cond_broadcast() {\n         test_rwlock_cond_broadcast_helper(0, true, true);\n         test_rwlock_cond_broadcast_helper(0, true, false);\n         test_rwlock_cond_broadcast_helper(0, false, true);\n@@ -1287,7 +1287,7 @@ mod tests {\n         test_rwlock_cond_broadcast_helper(12, false, false);\n     }\n     #[cfg(test)] #[ignore(cfg(windows))]\n-    pub fn rwlock_kill_helper(mode1: RWlockMode, mode2: RWlockMode) {\n+    fn rwlock_kill_helper(mode1: RWlockMode, mode2: RWlockMode) {\n         // Mutex must get automatically unlocked if failed/killed within.\n         let x = ~RWlock();\n         let x2 = (*x).clone();\n@@ -1302,23 +1302,23 @@ mod tests {\n         do lock_rwlock_in_mode(x, mode2) { }\n     }\n     #[test] #[ignore(cfg(windows))]\n-    pub fn test_rwlock_reader_killed_writer() {\n+    fn test_rwlock_reader_killed_writer() {\n         rwlock_kill_helper(Read, Write);\n     }\n     #[test] #[ignore(cfg(windows))]\n-    pub fn test_rwlock_writer_killed_reader() {\n+    fn test_rwlock_writer_killed_reader() {\n         rwlock_kill_helper(Write,Read );\n     }\n     #[test] #[ignore(cfg(windows))]\n-    pub fn test_rwlock_reader_killed_reader() {\n+    fn test_rwlock_reader_killed_reader() {\n         rwlock_kill_helper(Read, Read );\n     }\n     #[test] #[ignore(cfg(windows))]\n-    pub fn test_rwlock_writer_killed_writer() {\n+    fn test_rwlock_writer_killed_writer() {\n         rwlock_kill_helper(Write,Write);\n     }\n     #[test] #[ignore(cfg(windows))]\n-    pub fn test_rwlock_kill_downgrader() {\n+    fn test_rwlock_kill_downgrader() {\n         rwlock_kill_helper(Downgrade, Read);\n         rwlock_kill_helper(Read, Downgrade);\n         rwlock_kill_helper(Downgrade, Write);\n@@ -1333,7 +1333,7 @@ mod tests {\n         rwlock_kill_helper(Downgrade, DowngradeRead);\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn test_rwlock_downgrade_cant_swap() {\n+    fn test_rwlock_downgrade_cant_swap() {\n         // Tests that you can't downgrade with a different rwlock's token.\n         let x = ~RWlock();\n         let y = ~RWlock();"}, {"sha": "ee83a0c9bd65250b9ac7d7e23cda59b737c9e292", "filename": "src/libstd/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -823,7 +823,7 @@ mod tests {\n \n     #[test]\n     #[ignore(cfg(windows))]\n-    pub fn test_should_fail() {\n+    fn test_should_fail() {\n         fn f() { fail!(); }\n         let desc = TestDescAndFn {\n             desc: TestDesc {\n@@ -841,7 +841,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_should_fail_but_succeeds() {\n+    fn test_should_fail_but_succeeds() {\n         fn f() { }\n         let desc = TestDescAndFn {\n             desc: TestDesc {\n@@ -859,7 +859,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn first_free_arg_should_be_a_filter() {\n+    fn first_free_arg_should_be_a_filter() {\n         let args = ~[~\"progname\", ~\"filter\"];\n         let opts = match parse_opts(args) {\n           either::Left(copy o) => o,\n@@ -869,7 +869,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn parse_ignored_flag() {\n+    fn parse_ignored_flag() {\n         let args = ~[~\"progname\", ~\"filter\", ~\"--ignored\"];\n         let opts = match parse_opts(args) {\n           either::Left(copy o) => o,"}, {"sha": "70dc4d8cfebbf033e97172bf38878b3e4621d0be", "filename": "src/libstd/time.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -872,7 +872,7 @@ mod tests {\n     use core::str;\n     use core::vec;\n \n-    pub fn test_get_time() {\n+    fn test_get_time() {\n         static some_recent_date: i64 = 1325376000i64; // 2012-01-01T00:00:00Z\n         static some_future_date: i64 = 1577836800i64; // 2020-01-01T00:00:00Z\n \n@@ -893,7 +893,7 @@ mod tests {\n         }\n     }\n \n-    pub fn test_precise_time() {\n+    fn test_precise_time() {\n         let s0 = precise_time_s();\n         let ns1 = precise_time_ns();\n \n@@ -910,7 +910,7 @@ mod tests {\n         assert!(ns2 >= ns1);\n     }\n \n-    pub fn test_at_utc() {\n+    fn test_at_utc() {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n@@ -931,7 +931,7 @@ mod tests {\n         assert!(utc.tm_nsec == 54321_i32);\n     }\n \n-    pub fn test_at() {\n+    fn test_at() {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n@@ -959,7 +959,7 @@ mod tests {\n         assert!(local.tm_nsec == 54321_i32);\n     }\n \n-    pub fn test_to_timespec() {\n+    fn test_to_timespec() {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n@@ -970,7 +970,7 @@ mod tests {\n         assert!(utc.to_local().to_timespec() == time);\n     }\n \n-    pub fn test_conversions() {\n+    fn test_conversions() {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n@@ -986,7 +986,7 @@ mod tests {\n         assert!(utc.to_local().to_utc() == utc);\n     }\n \n-    pub fn test_strptime() {\n+    fn test_strptime() {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n@@ -1144,7 +1144,7 @@ mod tests {\n         assert!(test(~\"%\", ~\"%%\"));\n     }\n \n-    pub fn test_ctime() {\n+    fn test_ctime() {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n@@ -1158,7 +1158,7 @@ mod tests {\n         assert!(local.ctime() == ~\"Fri Feb 13 15:31:30 2009\");\n     }\n \n-    pub fn test_strftime() {\n+    fn test_strftime() {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n@@ -1231,7 +1231,7 @@ mod tests {\n         assert!(utc.rfc3339() == ~\"2009-02-13T23:31:30Z\");\n     }\n \n-    pub fn test_timespec_eq_ord() {\n+    fn test_timespec_eq_ord() {\n         use core::cmp::{eq, ge, gt, le, lt, ne};\n \n         let a = &Timespec::new(-2, 1);\n@@ -1265,7 +1265,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn run_tests() {\n+    fn run_tests() {\n         // The tests race on tzset. So instead of having many independent\n         // tests, we will just call the functions now.\n         test_get_time();"}, {"sha": "c229e72ae5d4a40ee6566b331172dbd6aabeb06e", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -183,21 +183,21 @@ mod test {\n     use core::pipes::{stream, SharedChan};\n \n     #[test]\n-    pub fn test_gl_timer_simple_sleep_test() {\n+    fn test_gl_timer_simple_sleep_test() {\n         let hl_loop = &uv::global_loop::get();\n         sleep(hl_loop, 1u);\n     }\n \n     #[test]\n-    pub fn test_gl_timer_sleep_stress1() {\n+    fn test_gl_timer_sleep_stress1() {\n         let hl_loop = &uv::global_loop::get();\n         for iter::repeat(50u) {\n             sleep(hl_loop, 1u);\n         }\n     }\n \n     #[test]\n-    pub fn test_gl_timer_sleep_stress2() {\n+    fn test_gl_timer_sleep_stress2() {\n         let (po, ch) = stream();\n         let ch = SharedChan(ch);\n         let hl_loop = &uv::global_loop::get();\n@@ -241,7 +241,7 @@ mod test {\n \n     #[test]\n     #[cfg(ignore)]\n-    pub fn test_gl_timer_recv_timeout_before_time_passes() {\n+    fn test_gl_timer_recv_timeout_before_time_passes() {\n         let times = 100;\n         let mut successes = 0;\n         let mut failures = 0;\n@@ -270,7 +270,7 @@ mod test {\n     }\n \n     #[test]\n-    pub fn test_gl_timer_recv_timeout_after_time_passes() {\n+    fn test_gl_timer_recv_timeout_after_time_passes() {\n         let times = 100;\n         let mut successes = 0;\n         let mut failures = 0;"}, {"sha": "740ecec001f832805e5957dfe7ea24f9ddf55cdf", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -1225,7 +1225,7 @@ pub unsafe fn addrinfo_as_sockaddr_in6(input: *addrinfo) -> *sockaddr_in6 {\n }\n \n #[cfg(test)]\n-pub mod test {\n+mod test {\n     use core::prelude::*;\n     use core::comm::{SharedChan, stream, GenericChan, GenericPort};\n     use super::*;\n@@ -1759,11 +1759,11 @@ pub mod test {\n     #[cfg(target_os=\"darwin\")]\n     #[cfg(target_os=\"linux\")]\n     #[cfg(target_os=\"android\")]\n-    pub mod tcp_and_server_client_test {\n+    mod tcp_and_server_client_test {\n         #[cfg(target_arch=\"x86_64\")]\n-        pub mod impl64 {\n+        mod impl64 {\n             #[test]\n-            pub fn test_uv_ll_tcp_server_and_request() {\n+            fn test_uv_ll_tcp_server_and_request() {\n                 unsafe {\n                     super::super::impl_uv_tcp_server_and_request();\n                 }\n@@ -1772,10 +1772,10 @@ pub mod test {\n         #[cfg(target_arch=\"x86\")]\n         #[cfg(target_arch=\"arm\")]\n         #[cfg(target_arch=\"mips\")]\n-        pub mod impl32 {\n+        mod impl32 {\n             #[test]\n             #[ignore(cfg(target_os = \"linux\"))]\n-            pub fn test_uv_ll_tcp_server_and_request() {\n+            fn test_uv_ll_tcp_server_and_request() {\n                 unsafe {\n                     super::super::impl_uv_tcp_server_and_request();\n                 }"}, {"sha": "bc930515a5d89886fc1586eeddb464a9c7aa4ccb", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -781,7 +781,7 @@ fn consume_whitespace(rdr: @mut StringReader) {\n }\n \n #[cfg(test)]\n-pub mod test {\n+mod test {\n     use super::*;\n \n     use ast;"}, {"sha": "88ecabe28f526928cbc28a552b81cfdc1a5a3059", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -2248,7 +2248,7 @@ pub fn print_onceness(s: @ps, o: ast::Onceness) {\n }\n \n #[cfg(test)]\n-pub mod test {\n+mod test {\n     use super::*;\n \n     use ast;"}, {"sha": "1133fd850d84b4026e3573b4d42e96e6f64aadb2", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 42, "deletions": 38, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e8af9e477fd5a6e7dcf668840144a97e3b1410/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=16e8af9e477fd5a6e7dcf668840144a97e3b1410", "patch": "@@ -66,43 +66,47 @@ pub impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n     fn len(&self) -> uint { let vect = &*self.vect; vect.len() }\n }\n \n-#[test]\n-#[should_fail]\n-pub fn i1 () {\n-    let i : Interner<@~str> = Interner::new();\n-    i.get(13);\n-}\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    #[test]\n+    #[should_fail]\n+    fn i1 () {\n+        let i : Interner<@~str> = Interner::new();\n+        i.get(13);\n+    }\n \n-#[test]\n-pub fn i2 () {\n-    let i : Interner<@~str> = Interner::new();\n-    // first one is zero:\n-    assert_eq!(i.intern (@~\"dog\"), 0);\n-    // re-use gets the same entry:\n-    assert_eq!(i.intern (@~\"dog\"), 0);\n-    // different string gets a different #:\n-    assert_eq!(i.intern (@~\"cat\"), 1);\n-    assert_eq!(i.intern (@~\"cat\"), 1);\n-    // dog is still at zero\n-    assert_eq!(i.intern (@~\"dog\"), 0);\n-    // gensym gets 3\n-    assert_eq!(i.gensym (@~\"zebra\" ), 2);\n-    // gensym of same string gets new number :\n-    assert_eq!(i.gensym (@~\"zebra\" ), 3);\n-    // gensym of *existing* string gets new number:\n-    assert_eq!(i.gensym (@~\"dog\"), 4);\n-    assert_eq!(i.get(0), @~\"dog\");\n-    assert_eq!(i.get(1), @~\"cat\");\n-    assert_eq!(i.get(2), @~\"zebra\");\n-    assert_eq!(i.get(3), @~\"zebra\");\n-    assert_eq!(i.get(4), @~\"dog\");\n-}\n+    #[test]\n+    fn i2 () {\n+        let i : Interner<@~str> = Interner::new();\n+        // first one is zero:\n+        assert_eq!(i.intern (@~\"dog\"), 0);\n+        // re-use gets the same entry:\n+        assert_eq!(i.intern (@~\"dog\"), 0);\n+        // different string gets a different #:\n+        assert_eq!(i.intern (@~\"cat\"), 1);\n+        assert_eq!(i.intern (@~\"cat\"), 1);\n+        // dog is still at zero\n+        assert_eq!(i.intern (@~\"dog\"), 0);\n+        // gensym gets 3\n+        assert_eq!(i.gensym (@~\"zebra\" ), 2);\n+        // gensym of same string gets new number :\n+        assert_eq!(i.gensym (@~\"zebra\" ), 3);\n+        // gensym of *existing* string gets new number:\n+        assert_eq!(i.gensym (@~\"dog\"), 4);\n+        assert_eq!(i.get(0), @~\"dog\");\n+        assert_eq!(i.get(1), @~\"cat\");\n+        assert_eq!(i.get(2), @~\"zebra\");\n+        assert_eq!(i.get(3), @~\"zebra\");\n+        assert_eq!(i.get(4), @~\"dog\");\n+    }\n \n-#[test]\n-pub fn i3 () {\n-    let i : Interner<@~str> = Interner::prefill([@~\"Alan\",@~\"Bob\",@~\"Carol\"]);\n-    assert_eq!(i.get(0), @~\"Alan\");\n-    assert_eq!(i.get(1), @~\"Bob\");\n-    assert_eq!(i.get(2), @~\"Carol\");\n-    assert_eq!(i.intern(@~\"Bob\"), 1);\n-}\n+    #[test]\n+    fn i3 () {\n+        let i : Interner<@~str> = Interner::prefill([@~\"Alan\",@~\"Bob\",@~\"Carol\"]);\n+        assert_eq!(i.get(0), @~\"Alan\");\n+        assert_eq!(i.get(1), @~\"Bob\");\n+        assert_eq!(i.get(2), @~\"Carol\");\n+        assert_eq!(i.intern(@~\"Bob\"), 1);\n+    }\n+}\n\\ No newline at end of file"}]}