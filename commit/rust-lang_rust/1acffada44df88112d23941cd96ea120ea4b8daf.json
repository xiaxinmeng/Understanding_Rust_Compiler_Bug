{"sha": "1acffada44df88112d23941cd96ea120ea4b8daf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhY2ZmYWRhNDRkZjg4MTEyZDIzOTQxY2Q5NmVhMTIwZWE0YjhkYWY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-12T18:33:50Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-26T14:59:40Z"}, "message": "introduce `canonicalize_hr_query_hack`\n\nAs the comment explains, this is needed to prevent subtype from going\nawry in higher-ranked cases, due to #33684. The proper fix here is\nintroducing universes (#48536).", "tree": {"sha": "3360a580e1ba51e594cd057d092c32f0f358fe59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3360a580e1ba51e594cd057d092c32f0f358fe59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1acffada44df88112d23941cd96ea120ea4b8daf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1acffada44df88112d23941cd96ea120ea4b8daf", "html_url": "https://github.com/rust-lang/rust/commit/1acffada44df88112d23941cd96ea120ea4b8daf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1acffada44df88112d23941cd96ea120ea4b8daf/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "265552258048b2008975d98de75c7e536bc4f894", "url": "https://api.github.com/repos/rust-lang/rust/commits/265552258048b2008975d98de75c7e536bc4f894", "html_url": "https://github.com/rust-lang/rust/commit/265552258048b2008975d98de75c7e536bc4f894"}], "stats": {"total": 85, "additions": 74, "deletions": 11}, "files": [{"sha": "8b67f04e0201c04d488224aa7b99c066dba09a19", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 69, "deletions": 10, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/1acffada44df88112d23941cd96ea120ea4b8daf/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acffada44df88112d23941cd96ea120ea4b8daf/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=1acffada44df88112d23941cd96ea120ea4b8daf", "patch": "@@ -61,7 +61,10 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n             value,\n             Some(self),\n             self.tcx,\n-            CanonicalizeAllFreeRegions(true),\n+            CanonicalizeRegionMode {\n+                static_region: true,\n+                other_free_regions: true,\n+            },\n         )\n     }\n \n@@ -101,7 +104,43 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n             value,\n             Some(self),\n             self.tcx,\n-            CanonicalizeAllFreeRegions(false),\n+            CanonicalizeRegionMode {\n+                static_region: false,\n+                other_free_regions: false,\n+            },\n+        )\n+    }\n+\n+    /// A hacky variant of `canonicalize_query` that does not\n+    /// canonicalize `'static`.  Unfortunately, the existing leak\n+    /// check treaks `'static` differently in some cases (see also\n+    /// #33684), so if we are performing an operation that may need to\n+    /// prove \"leak-check\" related things, we leave `'static`\n+    /// alone.\n+    ///\n+    /// FIXME(#48536) -- once we have universes, we can remove this and just use\n+    /// `canonicalize_query`.\n+    pub fn canonicalize_hr_query_hack<V>(\n+        &self,\n+        value: &V,\n+    ) -> (Canonicalized<'gcx, V>, CanonicalVarValues<'tcx>)\n+    where\n+        V: TypeFoldable<'tcx> + Lift<'gcx>,\n+    {\n+        self.tcx\n+            .sess\n+            .perf_stats\n+            .queries_canonicalized\n+            .fetch_add(1, Ordering::Relaxed);\n+\n+        Canonicalizer::canonicalize(\n+            value,\n+            Some(self),\n+            self.tcx,\n+            CanonicalizeRegionMode {\n+                static_region: false,\n+                other_free_regions: true,\n+            },\n         )\n     }\n }\n@@ -110,15 +149,24 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n /// a canonical var. This is used to make queries as generic as\n /// possible. For example, the query `F: Foo<'static>` would be\n /// canonicalized to `F: Foo<'0>`.\n-struct CanonicalizeAllFreeRegions(pub bool);\n+struct CanonicalizeRegionMode {\n+    static_region: bool,\n+    other_free_regions: bool,\n+}\n+\n+impl CanonicalizeRegionMode {\n+    fn any(&self) -> bool {\n+        self.static_region || self.other_free_regions\n+    }\n+}\n \n struct Canonicalizer<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     infcx: Option<&'cx InferCtxt<'cx, 'gcx, 'tcx>>,\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     variables: IndexVec<CanonicalVar, CanonicalVarInfo>,\n     indices: FxHashMap<Kind<'tcx>, CanonicalVar>,\n     var_values: IndexVec<CanonicalVar, Kind<'tcx>>,\n-    canonicalize_all_free_regions: CanonicalizeAllFreeRegions,\n+    canonicalize_region_mode: CanonicalizeRegionMode,\n     needs_canonical_flags: TypeFlags,\n }\n \n@@ -152,14 +200,25 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx>\n                 self.tcx().mk_region(ty::ReCanonical(cvar))\n             }\n \n-            ty::ReStatic\n-            | ty::ReEarlyBound(..)\n+            ty::ReStatic => {\n+                if self.canonicalize_region_mode.static_region {\n+                    let info = CanonicalVarInfo {\n+                        kind: CanonicalVarKind::Region,\n+                    };\n+                    let cvar = self.canonical_var(info, r.into());\n+                    self.tcx().mk_region(ty::ReCanonical(cvar))\n+                } else {\n+                    r\n+                }\n+            }\n+\n+            ty::ReEarlyBound(..)\n             | ty::ReFree(_)\n             | ty::ReScope(_)\n             | ty::ReSkolemized(..)\n             | ty::ReEmpty\n             | ty::ReErased => {\n-                if self.canonicalize_all_free_regions.0 {\n+                if self.canonicalize_region_mode.other_free_regions {\n                     let info = CanonicalVarInfo {\n                         kind: CanonicalVarKind::Region,\n                     };\n@@ -235,7 +294,7 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n         value: &V,\n         infcx: Option<&'cx InferCtxt<'cx, 'gcx, 'tcx>>,\n         tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-        canonicalize_all_free_regions: CanonicalizeAllFreeRegions,\n+        canonicalize_region_mode: CanonicalizeRegionMode,\n     ) -> (Canonicalized<'gcx, V>, CanonicalVarValues<'tcx>)\n     where\n         V: TypeFoldable<'tcx> + Lift<'gcx>,\n@@ -246,7 +305,7 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n             value,\n         );\n \n-        let needs_canonical_flags = if canonicalize_all_free_regions.0 {\n+        let needs_canonical_flags = if canonicalize_region_mode.any() {\n             TypeFlags::HAS_FREE_REGIONS | TypeFlags::KEEP_IN_LOCAL_TCX\n         } else {\n             TypeFlags::KEEP_IN_LOCAL_TCX\n@@ -270,7 +329,7 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n         let mut canonicalizer = Canonicalizer {\n             infcx,\n             tcx,\n-            canonicalize_all_free_regions,\n+            canonicalize_region_mode,\n             needs_canonical_flags,\n             variables: IndexVec::default(),\n             indices: FxHashMap::default(),"}, {"sha": "6436e75158ea343289afe959f8b189aef4184afb", "filename": "src/librustc/traits/query/type_op/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1acffada44df88112d23941cd96ea120ea4b8daf/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acffada44df88112d23941cd96ea120ea4b8daf/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=1acffada44df88112d23941cd96ea120ea4b8daf", "patch": "@@ -132,7 +132,11 @@ where\n     fn perform(self, infcx: &InferCtxt<'_, 'gcx, 'tcx>) -> InferResult<'tcx, Self::Output> {\n         let param_env = self.param_env();\n \n-        let (canonical_self, canonical_var_values) = infcx.canonicalize_query(&self);\n+        // FIXME(#33684) -- We need to use\n+        // `canonicalize_hr_query_hack` here because of things like\n+        // the subtype query, which go awry around `'static`\n+        // otherwise.\n+        let (canonical_self, canonical_var_values) = infcx.canonicalize_hr_query_hack(&self);\n         let canonical_result = Q::perform_query(infcx.tcx, canonical_self);\n \n         // FIXME: This is not the most efficient setup. The"}]}