{"sha": "69b8ef806b3742ba7d41a77cd216713c84f36254", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5YjhlZjgwNmIzNzQyYmE3ZDQxYTc3Y2QyMTY3MTNjODRmMzYyNTQ=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-03-07T03:31:41Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-03-09T08:29:49Z"}, "message": "rustdoc: run on plain Markdown files.\n\nThis theoretically gives rustdoc the ability to render our guides,\ntutorial and manual (not in practice, since the files themselves need to\nbe adjusted slightly to use Sundown-compatible functionality).\n\nFixes #11392.", "tree": {"sha": "c6f77a4163f4a091839f065a8008aa3b160c1965", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6f77a4163f4a091839f065a8008aa3b160c1965"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69b8ef806b3742ba7d41a77cd216713c84f36254", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69b8ef806b3742ba7d41a77cd216713c84f36254", "html_url": "https://github.com/rust-lang/rust/commit/69b8ef806b3742ba7d41a77cd216713c84f36254", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69b8ef806b3742ba7d41a77cd216713c84f36254/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e959c8794b80ffad3abd50f773e5a613e13ff7b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e959c8794b80ffad3abd50f773e5a613e13ff7b2", "html_url": "https://github.com/rust-lang/rust/commit/e959c8794b80ffad3abd50f773e5a613e13ff7b2"}], "stats": {"total": 320, "additions": 292, "deletions": 28}, "files": [{"sha": "415db46be5b109382c1084290caaa8a387df446d", "filename": "src/doc/rustdoc.md", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/69b8ef806b3742ba7d41a77cd216713c84f36254/src%2Fdoc%2Frustdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/69b8ef806b3742ba7d41a77cd216713c84f36254/src%2Fdoc%2Frustdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc.md?ref=69b8ef806b3742ba7d41a77cd216713c84f36254", "patch": "@@ -181,3 +181,28 @@ rustdoc will implicitly add `extern crate <crate>;` where `<crate>` is the name\n the crate being tested to the top of each code example. This means that rustdoc\n must be able to find a compiled version of the library crate being tested. Extra\n search paths may be added via the `-L` flag to `rustdoc`.\n+\n+# Standalone Markdown files\n+\n+As well as Rust crates, rustdoc supports rendering pure Markdown files\n+into HTML and testing the code snippets from them. A Markdown file is\n+detected by a `.md` or `.markdown` extension.\n+\n+There are 4 options to modify the output that Rustdoc creates.\n+- `--markdown-css PATH`: adds a `<link rel=\"stylesheet\">` tag pointing to `PATH`.\n+- `--markdown-in-header FILE`: includes the contents of `FILE` at the\n+  end of the `<head>...</head>` section.\n+- `--markdown-before-content FILE`: includes the contents of `FILE`\n+  directly after `<body>`, before the rendered content (including the\n+  title).\n+- `--markdown-after-content FILE`: includes the contents of `FILE`\n+  directly before `</body>`, after all the rendered content.\n+\n+All of these can be specified multiple times, and they are output in\n+the order in which they are specified. The first line of the file must\n+be the title, prefixed with `%` (e.g. this page has `% Rust\n+Documentation` on the first line).\n+\n+Like with a Rust crate, the `--test` argument will run the code\n+examples to check they compile, and obeys any `--test-args` flags. The\n+tests are named after the last `#` heading."}, {"sha": "30040a1846c3866c28909a0376fd6b5e972f4e2b", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/69b8ef806b3742ba7d41a77cd216713c84f36254/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b8ef806b3742ba7d41a77cd216713c84f36254/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=69b8ef806b3742ba7d41a77cd216713c84f36254", "patch": "@@ -28,7 +28,6 @@\n \n use std::cast;\n use std::fmt;\n-use std::intrinsics;\n use std::io;\n use std::libc;\n use std::local_data;\n@@ -258,14 +257,27 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n             };\n             if ignore { return }\n             vec::raw::buf_as_slice((*text).data, (*text).size as uint, |text| {\n-                let tests: &mut ::test::Collector = intrinsics::transmute(opaque);\n+                let tests = &mut *(opaque as *mut ::test::Collector);\n                 let text = str::from_utf8(text).unwrap();\n                 let mut lines = text.lines().map(|l| stripped_filtered_line(l).unwrap_or(l));\n                 let text = lines.to_owned_vec().connect(\"\\n\");\n                 tests.add_test(text, should_fail, no_run);\n             })\n         }\n     }\n+    extern fn header(_ob: *buf, text: *buf, level: libc::c_int, opaque: *libc::c_void) {\n+        unsafe {\n+            let tests = &mut *(opaque as *mut ::test::Collector);\n+            if text.is_null() {\n+                tests.register_header(\"\", level as u32);\n+            } else {\n+                vec::raw::buf_as_slice((*text).data, (*text).size as uint, |text| {\n+                    let text = str::from_utf8(text).unwrap();\n+                    tests.register_header(text, level as u32);\n+                })\n+            }\n+        }\n+    }\n \n     unsafe {\n         let ob = bufnew(OUTPUT_UNIT);\n@@ -276,7 +288,7 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n             blockcode: Some(block),\n             blockquote: None,\n             blockhtml: None,\n-            header: None,\n+            header: Some(header),\n             other: mem::init()\n         };\n "}, {"sha": "94bc5ed2526630f4757d10e6295df5bdab363ca0", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/69b8ef806b3742ba7d41a77cd216713c84f36254/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b8ef806b3742ba7d41a77cd216713c84f36254/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=69b8ef806b3742ba7d41a77cd216713c84f36254", "patch": "@@ -14,7 +14,7 @@\n #[crate_type = \"dylib\"];\n #[crate_type = \"rlib\"];\n \n-#[feature(globs, struct_variant, managed_boxes)];\n+#[feature(globs, struct_variant, managed_boxes, macro_rules)];\n \n extern crate syntax;\n extern crate rustc;\n@@ -26,6 +26,7 @@ extern crate collections;\n extern crate testing = \"test\";\n extern crate time;\n \n+use std::cell::RefCell;\n use std::local_data;\n use std::io;\n use std::io::{File, MemWriter};\n@@ -44,6 +45,7 @@ pub mod html {\n     pub mod markdown;\n     pub mod render;\n }\n+pub mod markdown;\n pub mod passes;\n pub mod plugins;\n pub mod visit_ast;\n@@ -105,6 +107,19 @@ pub fn opts() -> ~[getopts::OptGroup] {\n         optflag(\"\", \"test\", \"run code examples as tests\"),\n         optmulti(\"\", \"test-args\", \"arguments to pass to the test runner\",\n                  \"ARGS\"),\n+        optmulti(\"\", \"markdown-css\", \"CSS files to include via <link> in a rendered Markdown file\",\n+                 \"FILES\"),\n+        optmulti(\"\", \"markdown-in-header\",\n+                 \"files to include inline in the <head> section of a rendered Markdown file\",\n+                 \"FILES\"),\n+        optmulti(\"\", \"markdown-before-content\",\n+                 \"files to include inline between <body> and the content of a rendered \\\n+                 Markdown file\",\n+                 \"FILES\"),\n+        optmulti(\"\", \"markdown-after-content\",\n+                 \"files to include inline between the content and </body> of a rendered \\\n+                 Markdown file\",\n+                 \"FILES\"),\n     ]\n }\n \n@@ -137,8 +152,24 @@ pub fn main_args(args: &[~str]) -> int {\n     }\n     let input = matches.free[0].as_slice();\n \n-    if matches.opt_present(\"test\") {\n-        return test::run(input, &matches);\n+    let libs = matches.opt_strs(\"L\").map(|s| Path::new(s.as_slice()));\n+    let libs = @RefCell::new(libs.move_iter().collect());\n+\n+    let test_args = matches.opt_strs(\"test-args\");\n+    let test_args = test_args.iter().flat_map(|s| s.words()).map(|s| s.to_owned()).to_owned_vec();\n+\n+    let should_test = matches.opt_present(\"test\");\n+    let markdown_input = input.ends_with(\".md\") || input.ends_with(\".markdown\");\n+\n+    let output = matches.opt_str(\"o\").map(|s| Path::new(s));\n+\n+    match (should_test, markdown_input) {\n+        (true, true) => return markdown::test(input, libs, test_args),\n+        (true, false) => return test::run(input, libs, test_args),\n+\n+        (false, true) => return markdown::render(input, output.unwrap_or(Path::new(\"doc\")),\n+                                                 &matches),\n+        (false, false) => {}\n     }\n \n     if matches.opt_strs(\"passes\") == ~[~\"list\"] {\n@@ -163,7 +194,6 @@ pub fn main_args(args: &[~str]) -> int {\n \n     info!(\"going to format\");\n     let started = time::precise_time_ns();\n-    let output = matches.opt_str(\"o\").map(|s| Path::new(s));\n     match matches.opt_str(\"w\") {\n         Some(~\"html\") | None => {\n             match html::render::run(krate, output.unwrap_or(Path::new(\"doc\"))) {"}, {"sha": "a998e3d69944f797e7a02fcc186ac6fe0da578c8", "filename": "src/librustdoc/markdown.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/69b8ef806b3742ba7d41a77cd216713c84f36254/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b8ef806b3742ba7d41a77cd216713c84f36254/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=69b8ef806b3742ba7d41a77cd216713c84f36254", "patch": "@@ -0,0 +1,171 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::{str, io};\n+use std::cell::RefCell;\n+use std::vec_ng::Vec;\n+\n+use collections::HashSet;\n+\n+use getopts;\n+use testing;\n+\n+use html::escape::Escape;\n+use html::markdown::{Markdown, find_testable_code, reset_headers};\n+use test::Collector;\n+\n+fn load_string(input: &Path) -> io::IoResult<Option<~str>> {\n+    let mut f = try!(io::File::open(input));\n+    let d = try!(f.read_to_end());\n+    Ok(str::from_utf8_owned(d))\n+}\n+macro_rules! load_or_return {\n+    ($input: expr, $cant_read: expr, $not_utf8: expr) => {\n+        {\n+            let input = Path::new($input);\n+            match load_string(&input) {\n+                Err(e) => {\n+                    let _ = writeln!(&mut io::stderr(),\n+                                     \"error reading `{}`: {}\", input.display(), e);\n+                    return $cant_read;\n+                }\n+                Ok(None) => {\n+                    let _ = writeln!(&mut io::stderr(),\n+                                     \"error reading `{}`: not UTF-8\", input.display());\n+                    return $not_utf8;\n+                }\n+                Ok(Some(s)) => s\n+            }\n+        }\n+    }\n+}\n+\n+/// Separate any lines at the start of the file that begin with `%`.\n+fn extract_leading_metadata<'a>(s: &'a str) -> (Vec<&'a str>, &'a str) {\n+    let mut metadata = Vec::new();\n+    for line in s.lines() {\n+        if line.starts_with(\"%\") {\n+            // remove %<whitespace>\n+            metadata.push(line.slice_from(1).trim_left())\n+        } else {\n+            let line_start_byte = s.subslice_offset(line);\n+            return (metadata, s.slice_from(line_start_byte));\n+        }\n+    }\n+    // if we're here, then all lines were metadata % lines.\n+    (metadata, \"\")\n+}\n+\n+fn load_external_files(names: &[~str]) -> Option<~str> {\n+    let mut out = ~\"\";\n+    for name in names.iter() {\n+        out.push_str(load_or_return!(name.as_slice(), None, None));\n+        out.push_char('\\n');\n+    }\n+    Some(out)\n+}\n+\n+/// Render `input` (e.g. \"foo.md\") into an HTML file in `output`\n+/// (e.g. output = \"bar\" => \"bar/foo.html\").\n+pub fn render(input: &str, mut output: Path, matches: &getopts::Matches) -> int {\n+    let input_p = Path::new(input);\n+    output.push(input_p.filestem().unwrap());\n+    output.set_extension(\"html\");\n+\n+    let mut css = ~\"\";\n+    for name in matches.opt_strs(\"markdown-css\").iter() {\n+        let s = format!(\"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{}\\\">\\n\", name);\n+        css.push_str(s)\n+    }\n+\n+    let input_str = load_or_return!(input, 1, 2);\n+\n+    let (in_header, before_content, after_content) =\n+        match (load_external_files(matches.opt_strs(\"markdown-in-header\")),\n+               load_external_files(matches.opt_strs(\"markdown-before-content\")),\n+               load_external_files(matches.opt_strs(\"markdown-after-content\"))) {\n+        (Some(a), Some(b), Some(c)) => (a,b,c),\n+        _ => return 3\n+    };\n+\n+    let mut out = match io::File::create(&output) {\n+        Err(e) => {\n+            let _ = writeln!(&mut io::stderr(),\n+                             \"error opening `{}` for writing: {}\",\n+                             output.display(), e);\n+            return 4;\n+        }\n+        Ok(f) => f\n+    };\n+\n+    let (metadata, text) = extract_leading_metadata(input_str);\n+    if metadata.len() == 0 {\n+        let _ = writeln!(&mut io::stderr(),\n+                         \"invalid markdown file: expecting initial line with `% ...TITLE...`\");\n+        return 5;\n+    }\n+    let title = metadata.get(0).as_slice();\n+\n+    reset_headers();\n+\n+    let err = write!(\n+        &mut out,\n+        r#\"<!doctype html>\n+<html lang=\"en\">\n+<head>\n+    <meta charset=\"utf-8\">\n+    <meta name=\"generator\" content=\"rustdoc\">\n+    <title>{title}</title>\n+\n+    {css}\n+    {in_header}\n+</head>\n+<body>\n+    <!--[if lte IE 8]>\n+    <div class=\"warning\">\n+        This old browser is unsupported and will most likely display funky\n+        things.\n+    </div>\n+    <![endif]-->\n+\n+    {before_content}\n+    <h1 class=\"title\">{title}</h1>\n+    {text}\n+    {after_content}\n+</body>\n+</html>\"#,\n+        title = Escape(title),\n+        css = css,\n+        in_header = in_header,\n+        before_content = before_content,\n+        text = Markdown(text),\n+        after_content = after_content);\n+\n+    match err {\n+        Err(e) => {\n+            let _ = writeln!(&mut io::stderr(),\n+                             \"error writing to `{}`: {}\",\n+                             output.display(), e);\n+            6\n+        }\n+        Ok(_) => 0\n+    }\n+}\n+\n+/// Run any tests/code examples in the markdown file `input`.\n+pub fn test(input: &str, libs: @RefCell<HashSet<Path>>, mut test_args: ~[~str]) -> int {\n+    let input_str = load_or_return!(input, 1, 2);\n+\n+    let mut collector = Collector::new(input.to_owned(), libs, true);\n+    find_testable_code(input_str, &mut collector);\n+    test_args.unshift(~\"rustdoctest\");\n+    testing::test_main(test_args, collector.tests);\n+    0\n+}"}, {"sha": "640a3304094a88f72ed7831654b172e360db59fb", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 47, "deletions": 21, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/69b8ef806b3742ba7d41a77cd216713c84f36254/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b8ef806b3742ba7d41a77cd216713c84f36254/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=69b8ef806b3742ba7d41a77cd216713c84f36254", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::cell::RefCell;\n+use std::char;\n use std::io;\n use std::io::Process;\n use std::local_data;\n@@ -22,7 +23,6 @@ use rustc::back::link;\n use rustc::driver::driver;\n use rustc::driver::session;\n use rustc::metadata::creader::Loader;\n-use getopts;\n use syntax::diagnostic;\n use syntax::parse;\n use syntax::codemap::CodeMap;\n@@ -35,11 +35,9 @@ use html::markdown;\n use passes;\n use visit_ast::RustdocVisitor;\n \n-pub fn run(input: &str, matches: &getopts::Matches) -> int {\n+pub fn run(input: &str, libs: @RefCell<HashSet<Path>>, mut test_args: ~[~str]) -> int {\n     let input_path = Path::new(input);\n     let input = driver::FileInput(input_path.clone());\n-    let libs = matches.opt_strs(\"L\").map(|s| Path::new(s.as_slice()));\n-    let libs = @RefCell::new(libs.move_iter().collect());\n \n     let sessopts = @session::Options {\n         maybe_sysroot: Some(@os::self_exe_path().unwrap().dir_path()),\n@@ -79,21 +77,12 @@ pub fn run(input: &str, matches: &getopts::Matches) -> int {\n     let (krate, _) = passes::unindent_comments(krate);\n     let (krate, _) = passes::collapse_docs(krate);\n \n-    let mut collector = Collector {\n-        tests: ~[],\n-        names: ~[],\n-        cnt: 0,\n-        libs: libs,\n-        cratename: krate.name.to_owned(),\n-    };\n+    let mut collector = Collector::new(krate.name.to_owned(), libs, false);\n     collector.fold_crate(krate);\n \n-    let args = matches.opt_strs(\"test-args\");\n-    let mut args = args.iter().flat_map(|s| s.words()).map(|s| s.to_owned());\n-    let mut args = args.to_owned_vec();\n-    args.unshift(~\"rustdoctest\");\n+    test_args.unshift(~\"rustdoctest\");\n \n-    testing::test_main(args, collector.tests);\n+    testing::test_main(test_args, collector.tests);\n \n     0\n }\n@@ -198,17 +187,35 @@ fn maketest(s: &str, cratename: &str) -> ~str {\n }\n \n pub struct Collector {\n-    priv tests: ~[testing::TestDescAndFn],\n+    tests: ~[testing::TestDescAndFn],\n     priv names: ~[~str],\n     priv libs: @RefCell<HashSet<Path>>,\n     priv cnt: uint,\n+    priv use_headers: bool,\n+    priv current_header: Option<~str>,\n     priv cratename: ~str,\n }\n \n impl Collector {\n-    pub fn add_test(&mut self, test: &str, should_fail: bool, no_run: bool) {\n-        let test = test.to_owned();\n-        let name = format!(\"{}_{}\", self.names.connect(\"::\"), self.cnt);\n+    pub fn new(cratename: ~str, libs: @RefCell<HashSet<Path>>, use_headers: bool) -> Collector {\n+        Collector {\n+            tests: ~[],\n+            names: ~[],\n+            libs: libs,\n+            cnt: 0,\n+            use_headers: use_headers,\n+            current_header: None,\n+            cratename: cratename\n+        }\n+    }\n+\n+    pub fn add_test(&mut self, test: ~str, should_fail: bool, no_run: bool) {\n+        let name = if self.use_headers {\n+            let s = self.current_header.as_ref().map(|s| s.as_slice()).unwrap_or(\"\");\n+            format!(\"{}_{}\", s, self.cnt)\n+        } else {\n+            format!(\"{}_{}\", self.names.connect(\"::\"), self.cnt)\n+        };\n         self.cnt += 1;\n         let libs = self.libs.borrow();\n         let libs = (*libs.get()).clone();\n@@ -225,6 +232,25 @@ impl Collector {\n             }),\n         });\n     }\n+\n+    pub fn register_header(&mut self, name: &str, level: u32) {\n+        if self.use_headers && level == 1 {\n+            // we use these headings as test names, so it's good if\n+            // they're valid identifiers.\n+            let name = name.chars().enumerate().map(|(i, c)| {\n+                    if (i == 0 && char::is_XID_start(c)) ||\n+                        (i != 0 && char::is_XID_continue(c)) {\n+                        c\n+                    } else {\n+                        '_'\n+                    }\n+                }).collect::<~str>();\n+\n+            // new header => reset count.\n+            self.cnt = 0;\n+            self.current_header = Some(name);\n+        }\n+    }\n }\n \n impl DocFolder for Collector {\n@@ -237,7 +263,7 @@ impl DocFolder for Collector {\n         match item.doc_value() {\n             Some(doc) => {\n                 self.cnt = 0;\n-                markdown::find_testable_code(doc, self);\n+                markdown::find_testable_code(doc, &mut *self);\n             }\n             None => {}\n         }"}]}