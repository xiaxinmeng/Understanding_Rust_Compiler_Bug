{"sha": "f3b479d5569fa013020db1d940aeb38dadc9060b", "node_id": "C_kwDOAAsO6NoAKGYzYjQ3OWQ1NTY5ZmEwMTMwMjBkYjFkOTQwYWViMzhkYWRjOTA2MGI", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-07-02T23:44:55Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-07-02T23:44:55Z"}, "message": "Explain cache behavior a bit better, clean up diff", "tree": {"sha": "e8802edb42fb9ea1af97aea7333e509b082a7765", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8802edb42fb9ea1af97aea7333e509b082a7765"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3b479d5569fa013020db1d940aeb38dadc9060b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3b479d5569fa013020db1d940aeb38dadc9060b", "html_url": "https://github.com/rust-lang/rust/commit/f3b479d5569fa013020db1d940aeb38dadc9060b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3b479d5569fa013020db1d940aeb38dadc9060b/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cdbf98f57ed767342f8f9d192f21cfd75ef2a75", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cdbf98f57ed767342f8f9d192f21cfd75ef2a75", "html_url": "https://github.com/rust-lang/rust/commit/7cdbf98f57ed767342f8f9d192f21cfd75ef2a75"}], "stats": {"total": 37, "additions": 21, "deletions": 16}, "files": [{"sha": "f612e7a3e9e50d58df1baef9ffc4c86cebc52b4f", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f3b479d5569fa013020db1d940aeb38dadc9060b/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f3b479d5569fa013020db1d940aeb38dadc9060b/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=f3b479d5569fa013020db1d940aeb38dadc9060b", "patch": "@@ -53,5 +53,6 @@ harness = false\n \n [features]\n default = [\"stack-cache\"]\n+# Will be enabled on CI via `--all-features`.\n expensive-debug-assertions = []\n stack-cache = []"}, {"sha": "269980ede37963dc74418f7db61e1877d6233555", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3b479d5569fa013020db1d940aeb38dadc9060b/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3b479d5569fa013020db1d940aeb38dadc9060b/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=f3b479d5569fa013020db1d940aeb38dadc9060b", "patch": "@@ -90,8 +90,8 @@ pub use crate::mono_hash_map::MonoHashMap;\n pub use crate::operator::EvalContextExt as OperatorEvalContextExt;\n pub use crate::range_map::RangeMap;\n pub use crate::stacked_borrows::{\n-    stack::Stack, CallId, EvalContextExt as StackedBorEvalContextExt, Item, Permission, PtrId,\n-    SbTag, SbTagExtra, Stacks,\n+    stack::Stack, CallId, EvalContextExt as StackedBorEvalContextExt, Item, Permission, SbTag,\n+    SbTagExtra, Stacks,\n };\n pub use crate::sync::{CondvarId, EvalContextExt as SyncEvalContextExt, MutexId, RwLockId};\n pub use crate::thread::{"}, {"sha": "01d67fcf59e0bb971f70f6609ba2cdcd7197e799", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f3b479d5569fa013020db1d940aeb38dadc9060b/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3b479d5569fa013020db1d940aeb38dadc9060b/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=f3b479d5569fa013020db1d940aeb38dadc9060b", "patch": "@@ -26,7 +26,6 @@ use diagnostics::{AllocHistory, TagHistory};\n pub mod stack;\n use stack::Stack;\n \n-pub type PtrId = NonZeroU64;\n pub type CallId = NonZeroU64;\n \n // Even reading memory can have effects on the stack, so we need a `RefCell` here.\n@@ -479,7 +478,7 @@ impl<'tcx> Stack {\n             )\n         })?;\n \n-        // Step 2: Remove all items.  Also checks for protectors.\n+        // Step 2: Consider all items removed. This checks for protectors.\n         for idx in (0..self.len()).rev() {\n             let item = self.get(idx).unwrap();\n             Stack::item_popped(&item, None, global, alloc_history)?;\n@@ -579,8 +578,8 @@ impl<'tcx> Stacks {\n     /// Creates new stack with initial tag.\n     fn new(size: Size, perm: Permission, tag: SbTag) -> Self {\n         let item = Item { perm, tag, protector: None };\n-\n         let stack = Stack::new(item);\n+\n         Stacks {\n             stacks: RangeMap::new(size, stack),\n             history: AllocHistory::new(),\n@@ -826,14 +825,11 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // We have to use shared references to alloc/memory_extra here since\n                 // `visit_freeze_sensitive` needs to access the global state.\n                 let extra = this.get_alloc_extra(alloc_id)?;\n-\n                 let mut stacked_borrows = extra\n                     .stacked_borrows\n                     .as_ref()\n                     .expect(\"we should have Stacked Borrows data\")\n                     .borrow_mut();\n-                let mut current_span = this.machine.current_span();\n-\n                 this.visit_freeze_sensitive(place, size, |mut range, frozen| {\n                     // Adjust range.\n                     range.start += base_offset;\n@@ -858,7 +854,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                             item,\n                             (alloc_id, range, offset),\n                             &mut global,\n-                            &mut current_span,\n+                            current_span,\n                             history,\n                             exposed_tags,\n                         )"}, {"sha": "1c3ee0fd573aaad78647c142910c0f1666a8c5aa", "filename": "src/stacked_borrows/stack.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f3b479d5569fa013020db1d940aeb38dadc9060b/src%2Fstacked_borrows%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3b479d5569fa013020db1d940aeb38dadc9060b/src%2Fstacked_borrows%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fstack.rs?ref=f3b479d5569fa013020db1d940aeb38dadc9060b", "patch": "@@ -27,8 +27,7 @@ pub struct Stack {\n     /// we never have the unknown-to-known boundary in an SRW group.\n     unknown_bottom: Option<SbTag>,\n \n-    /// A small LRU cache of searches of the borrow stack. This only caches accesses of `Tagged`,\n-    /// because those are unique in the stack.\n+    /// A small LRU cache of searches of the borrow stack.\n     #[cfg(feature = \"stack-cache\")]\n     cache: StackCache,\n     /// On a read, we need to disable all `Unique` above the granting item. We can avoid most of\n@@ -42,6 +41,11 @@ pub struct Stack {\n /// probably-cold random access into the borrow stack to figure out what `Permission` an\n /// `SbTag` grants. We could avoid this by also storing the `Permission` in the cache, but\n /// most lookups into the cache are immediately followed by access of the full borrow stack anyway.\n+///\n+/// It may seem like maintaining this cache is a waste for small stacks, but\n+/// (a) iterating over small fixed-size arrays is super fast, and (b) empirically this helps *a lot*,\n+/// probably because runtime is dominated by large stacks.\n+/// arrays is super fast\n #[cfg(feature = \"stack-cache\")]\n #[derive(Clone, Debug)]\n struct StackCache {\n@@ -81,7 +85,9 @@ impl<'tcx> Stack {\n     /// - There are no Unique tags outside of first_unique..last_unique\n     #[cfg(feature = \"expensive-debug-assertions\")]\n     fn verify_cache_consistency(&self) {\n-        if self.borrows.len() > CACHE_LEN {\n+        // Only a full cache needs to be valid. Also see the comments in find_granting_cache\n+        // and set_unknown_bottom.\n+        if self.borrows.len() >= CACHE_LEN {\n             for (tag, stack_idx) in self.cache.tags.iter().zip(self.cache.idx.iter()) {\n                 assert_eq!(self.borrows[*stack_idx].tag, *tag);\n             }\n@@ -154,7 +160,7 @@ impl<'tcx> Stack {\n         }\n \n         // If we didn't find the tag in the cache, fall back to a linear search of the\n-        // whole stack, and add the tag to the stack.\n+        // whole stack, and add the tag to the cache.\n         for (stack_idx, item) in self.borrows.iter().enumerate().rev() {\n             if tag == item.tag && item.perm.grants(access) {\n                 #[cfg(feature = \"stack-cache\")]\n@@ -185,8 +191,11 @@ impl<'tcx> Stack {\n         // If we found the tag, look up its position in the stack to see if it grants\n         // the required permission\n         if self.borrows[stack_idx].perm.grants(access) {\n-            // If it does, and it's not already in the most-recently-used position, move it there.\n-            // Except if the tag is in position 1, this is equivalent to just a swap, so do that.\n+            // If it does, and it's not already in the most-recently-used position, re-insert it at\n+            // the most-recently-used position. This technically reduces the efficiency of the\n+            // cache by duplicating elements, but current benchmarks do not seem to benefit from\n+            // avoiding this duplication.\n+            // But if the tag is in position 1, avoiding the duplicating add is trivial.\n             if cache_idx == 1 {\n                 self.cache.tags.swap(0, 1);\n                 self.cache.idx.swap(0, 1);\n@@ -287,7 +296,6 @@ impl<'tcx> Stack {\n         let unique_range = 0..self.len();\n \n         if disable_start <= unique_range.end {\n-            // add 1 so we don't disable the granting item\n             let lower = unique_range.start.max(disable_start);\n             let upper = (unique_range.end + 1).min(self.borrows.len());\n             for item in &mut self.borrows[lower..upper] {"}]}