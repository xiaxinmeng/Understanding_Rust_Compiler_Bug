{"sha": "150322f86d441752874a8bed603d71119f190b8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1MDMyMmY4NmQ0NDE3NTI4NzRhOGJlZDYwM2Q3MTExOWYxOTBiOGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-29T00:56:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-29T00:56:47Z"}, "message": "Auto merge of #70518 - Dylan-DPC:rollup-n2gkh3a, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #69937 (ASCII methods on OsStr)\n - #70235 (Validate git setup before accessing functionality)\n - #70503 (rename Scalar::{ptr_null -> null_ptr} and add \"machine_\" prefix like elsewhere)\n - #70508 (Miri: use more specialized Scalar::from_ constructors where appropriate)\n - #70510 (fix TryEnterCriticalSection return type)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "54c8b39ae7352cc7096ca57402d0094876df6c6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54c8b39ae7352cc7096ca57402d0094876df6c6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/150322f86d441752874a8bed603d71119f190b8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/150322f86d441752874a8bed603d71119f190b8b", "html_url": "https://github.com/rust-lang/rust/commit/150322f86d441752874a8bed603d71119f190b8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/150322f86d441752874a8bed603d71119f190b8b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77621317d643cc5d13da60b26ab68b057668e688", "url": "https://api.github.com/repos/rust-lang/rust/commits/77621317d643cc5d13da60b26ab68b057668e688", "html_url": "https://github.com/rust-lang/rust/commit/77621317d643cc5d13da60b26ab68b057668e688"}, {"sha": "be8d896a4e7a7f87d7a4f418bfb4a8fb2d8d1abe", "url": "https://api.github.com/repos/rust-lang/rust/commits/be8d896a4e7a7f87d7a4f418bfb4a8fb2d8d1abe", "html_url": "https://github.com/rust-lang/rust/commit/be8d896a4e7a7f87d7a4f418bfb4a8fb2d8d1abe"}], "stats": {"total": 344, "additions": 298, "deletions": 46}, "files": [{"sha": "6653c505bf538118cec97bb0b1233b5ef52cc1ca", "filename": "src/bootstrap/format.rs", "status": "modified", "additions": 43, "deletions": 11, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/150322f86d441752874a8bed603d71119f190b8b/src%2Fbootstrap%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150322f86d441752874a8bed603d71119f190b8b/src%2Fbootstrap%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fformat.rs?ref=150322f86d441752874a8bed603d71119f190b8b", "patch": "@@ -4,7 +4,7 @@ use crate::Build;\n use build_helper::{output, t};\n use ignore::WalkBuilder;\n use std::path::Path;\n-use std::process::Command;\n+use std::process::{Command, Stdio};\n \n fn rustfmt(src: &Path, rustfmt: &Path, path: &Path, check: bool) {\n     let mut cmd = Command::new(&rustfmt);\n@@ -56,16 +56,48 @@ pub fn format(build: &Build, check: bool) {\n     for ignore in rustfmt_config.ignore {\n         ignore_fmt.add(&format!(\"!{}\", ignore)).expect(&ignore);\n     }\n-    let untracked_paths_output = output(\n-        Command::new(\"git\").arg(\"status\").arg(\"--porcelain\").arg(\"--untracked-files=normal\"),\n-    );\n-    let untracked_paths = untracked_paths_output\n-        .lines()\n-        .filter(|entry| entry.starts_with(\"??\"))\n-        .map(|entry| entry.split(\" \").nth(1).expect(\"every git status entry should list a path\"));\n-    for untracked_path in untracked_paths {\n-        eprintln!(\"skip untracked path {} during rustfmt invocations\", untracked_path);\n-        ignore_fmt.add(&format!(\"!{}\", untracked_path)).expect(&untracked_path);\n+    let git_available = match Command::new(\"git\")\n+        .arg(\"--version\")\n+        .stdout(Stdio::null())\n+        .stderr(Stdio::null())\n+        .status()\n+    {\n+        Ok(status) => status.success(),\n+        Err(_) => false,\n+    };\n+    if git_available {\n+        let in_working_tree = match Command::new(\"git\")\n+            .arg(\"rev-parse\")\n+            .arg(\"--is-inside-work-tree\")\n+            .stdout(Stdio::null())\n+            .stderr(Stdio::null())\n+            .status()\n+        {\n+            Ok(status) => status.success(),\n+            Err(_) => false,\n+        };\n+        if in_working_tree {\n+            let untracked_paths_output = output(\n+                Command::new(\"git\")\n+                    .arg(\"status\")\n+                    .arg(\"--porcelain\")\n+                    .arg(\"--untracked-files=normal\"),\n+            );\n+            let untracked_paths = untracked_paths_output\n+                .lines()\n+                .filter(|entry| entry.starts_with(\"??\"))\n+                .map(|entry| {\n+                    entry.split(\" \").nth(1).expect(\"every git status entry should list a path\")\n+                });\n+            for untracked_path in untracked_paths {\n+                eprintln!(\"skip untracked path {} during rustfmt invocations\", untracked_path);\n+                ignore_fmt.add(&format!(\"!{}\", untracked_path)).expect(&untracked_path);\n+            }\n+        } else {\n+            eprintln!(\"Not in git tree. Skipping git-aware format checks\");\n+        }\n+    } else {\n+        eprintln!(\"Could not find usable git. Skipping git-aware format checks\");\n     }\n     let ignore_fmt = ignore_fmt.build().unwrap();\n "}, {"sha": "d22207bd81651bdd0b481f345040a905f2dab4ba", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/150322f86d441752874a8bed603d71119f190b8b/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150322f86d441752874a8bed603d71119f190b8b/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=150322f86d441752874a8bed603d71119f190b8b", "patch": "@@ -46,13 +46,13 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n     }\n \n     #[inline]\n-    fn usize_max(&self) -> u64 {\n+    fn machine_usize_max(&self) -> u64 {\n         let max_usize_plus_1 = 1u128 << self.pointer_size().bits();\n         u64::try_from(max_usize_plus_1 - 1).unwrap()\n     }\n \n     #[inline]\n-    fn isize_max(&self) -> i64 {\n+    fn machine_isize_max(&self) -> i64 {\n         let max_isize_plus_1 = 1u128 << (self.pointer_size().bits() - 1);\n         i64::try_from(max_isize_plus_1 - 1).unwrap()\n     }"}, {"sha": "bf4ee8488238f2c0e1173041cd7d3058ea7c772f", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/150322f86d441752874a8bed603d71119f190b8b/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150322f86d441752874a8bed603d71119f190b8b/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=150322f86d441752874a8bed603d71119f190b8b", "patch": "@@ -192,7 +192,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n     }\n \n     #[inline]\n-    pub fn ptr_null(cx: &impl HasDataLayout) -> Self {\n+    pub fn null_ptr(cx: &impl HasDataLayout) -> Self {\n         Scalar::Raw { data: 0, size: cx.data_layout().pointer_size.bytes() as u8 }\n     }\n "}, {"sha": "6fe97bcb1183b5b839ccbdd282eab252e2b1fd41", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/150322f86d441752874a8bed603d71119f190b8b/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150322f86d441752874a8bed603d71119f190b8b/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=150322f86d441752874a8bed603d71119f190b8b", "patch": "@@ -208,7 +208,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Char => {\n                 // `u8` to `char` cast\n-                Ok(Scalar::from_uint(u8::try_from(v).unwrap(), Size::from_bytes(4)))\n+                Ok(Scalar::from_u32(u8::try_from(v).unwrap().into()))\n             }\n \n             // Casts to bool are not permitted by rustc, no need to handle them here."}, {"sha": "46f8e98ef34a34c21cb5dfaef26493a37b385482", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/150322f86d441752874a8bed603d71119f190b8b/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150322f86d441752874a8bed603d71119f190b8b/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=150322f86d441752874a8bed603d71119f190b8b", "patch": "@@ -2,6 +2,8 @@\n //! looking at their MIR. Intrinsics/functions supported here are shared by CTFE\n //! and miri.\n \n+use std::convert::TryFrom;\n+\n use rustc::mir::{\n     self,\n     interpret::{ConstValue, GlobalId, InterpResult, Scalar},\n@@ -220,7 +222,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             sym::discriminant_value => {\n                 let place = self.deref_operand(args[0])?;\n                 let discr_val = self.read_discriminant(place.into())?.0;\n-                self.write_scalar(Scalar::from_uint(discr_val, dest.layout.size), dest)?;\n+                self.write_scalar(Scalar::from_u64(u64::try_from(discr_val).unwrap()), dest)?;\n             }\n             sym::unchecked_shl\n             | sym::unchecked_shr\n@@ -275,7 +277,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             sym::ptr_offset_from => {\n-                let isize_layout = self.layout_of(self.tcx.types.isize)?;\n                 let a = self.read_immediate(args[0])?.to_scalar()?;\n                 let b = self.read_immediate(args[1])?.to_scalar()?;\n \n@@ -292,7 +293,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     let a = a.to_machine_usize(self)?;\n                     let b = b.to_machine_usize(self)?;\n                     if a == b && a != 0 {\n-                        self.write_scalar(Scalar::from_int(0, isize_layout.size), dest)?;\n+                        self.write_scalar(Scalar::from_machine_isize(0, self), dest)?;\n                         true\n                     } else {\n                         false\n@@ -312,6 +313,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         );\n                     }\n                     let usize_layout = self.layout_of(self.tcx.types.usize)?;\n+                    let isize_layout = self.layout_of(self.tcx.types.isize)?;\n                     let a_offset = ImmTy::from_uint(a.offset.bytes(), usize_layout);\n                     let b_offset = ImmTy::from_uint(b.offset.bytes(), usize_layout);\n                     let (val, _overflowed, _ty) ="}, {"sha": "1ffe6a873023c3079eb2adcc8333eb72215bc729", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/150322f86d441752874a8bed603d71119f190b8b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150322f86d441752874a8bed603d71119f190b8b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=150322f86d441752874a8bed603d71119f190b8b", "patch": "@@ -54,10 +54,7 @@ impl<Tag> From<Pointer<Tag>> for Immediate<Tag> {\n \n impl<'tcx, Tag> Immediate<Tag> {\n     pub fn new_slice(val: Scalar<Tag>, len: u64, cx: &impl HasDataLayout) -> Self {\n-        Immediate::ScalarPair(\n-            val.into(),\n-            Scalar::from_uint(len, cx.data_layout().pointer_size).into(),\n-        )\n+        Immediate::ScalarPair(val.into(), Scalar::from_machine_usize(len, cx).into())\n     }\n \n     pub fn new_dyn_trait(val: Scalar<Tag>, vtable: Pointer<Tag>) -> Self {\n@@ -621,7 +618,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let real_discr = if discr_val.layout.abi.is_signed() {\n                     // going from layout tag type to typeck discriminant type\n                     // requires first sign extending with the discriminant layout\n-                    let sexted = sign_extend(bits_discr, discr_val.layout.size) as i128;\n+                    let sexted = sign_extend(bits_discr, discr_val.layout.size);\n                     // and then zeroing with the typeck discriminant type\n                     let discr_ty = rval\n                         .layout\n@@ -631,8 +628,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         .repr\n                         .discr_type();\n                     let size = layout::Integer::from_attr(self, discr_ty).size();\n-                    let truncatee = sexted as u128;\n-                    truncate(truncatee, size)\n+                    truncate(sexted, size)\n                 } else {\n                     bits_discr\n                 };"}, {"sha": "915cffa3321456e9fd400338b0791db8a18f6559", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/150322f86d441752874a8bed603d71119f190b8b/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150322f86d441752874a8bed603d71119f190b8b/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=150322f86d441752874a8bed603d71119f190b8b", "patch": "@@ -139,7 +139,7 @@ impl<Tag> MemPlace<Tag> {\n     /// Produces a Place that will error if attempted to be read from or written to\n     #[inline(always)]\n     fn null(cx: &impl HasDataLayout) -> Self {\n-        Self::from_scalar_ptr(Scalar::ptr_null(cx), Align::from_bytes(1).unwrap())\n+        Self::from_scalar_ptr(Scalar::null_ptr(cx), Align::from_bytes(1).unwrap())\n     }\n \n     #[inline(always)]\n@@ -180,7 +180,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     #[inline]\n     pub fn dangling(layout: TyLayout<'tcx>, cx: &impl HasDataLayout) -> Self {\n         let align = layout.align.abi;\n-        let ptr = Scalar::from_uint(align.bytes(), cx.pointer_size());\n+        let ptr = Scalar::from_machine_usize(align.bytes(), cx);\n         // `Poison` this to make sure that the pointer value `ptr` is never observable by the program.\n         MPlaceTy { mplace: MemPlace { ptr, align, meta: MemPlaceMeta::Poison }, layout }\n     }\n@@ -504,7 +504,7 @@ where\n             // implement this.\n             ty::Array(inner, _) => (MemPlaceMeta::None, self.tcx.mk_array(inner, inner_len)),\n             ty::Slice(..) => {\n-                let len = Scalar::from_uint(inner_len, self.pointer_size());\n+                let len = Scalar::from_machine_usize(inner_len, self);\n                 (MemPlaceMeta::Meta(len), base.layout.ty)\n             }\n             _ => bug!(\"cannot subslice non-array type: `{:?}`\", base.layout.ty),\n@@ -1044,7 +1044,7 @@ where\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> MPlaceTy<'tcx, M::PointerTag> {\n         let ptr = self.memory.allocate_bytes(str.as_bytes(), kind);\n-        let meta = Scalar::from_uint(u128::try_from(str.len()).unwrap(), self.pointer_size());\n+        let meta = Scalar::from_machine_usize(u64::try_from(str.len()).unwrap(), self);\n         let mplace = MemPlace {\n             ptr: ptr.into(),\n             align: Align::from_bytes(1).unwrap(),"}, {"sha": "764edea2fc5c6c14aaf3472436e25aa3457dbb72", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/150322f86d441752874a8bed603d71119f190b8b/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150322f86d441752874a8bed603d71119f190b8b/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=150322f86d441752874a8bed603d71119f190b8b", "patch": "@@ -3,7 +3,7 @@\n //! The main entry point is the `step` method.\n \n use rustc::mir;\n-use rustc::mir::interpret::{InterpResult, PointerArithmetic, Scalar};\n+use rustc::mir::interpret::{InterpResult, Scalar};\n use rustc::ty::layout::LayoutOf;\n \n use super::{InterpCx, Machine};\n@@ -229,8 +229,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let src = self.eval_place(place)?;\n                 let mplace = self.force_allocation(src)?;\n                 let len = mplace.len(self)?;\n-                let size = self.pointer_size();\n-                self.write_scalar(Scalar::from_uint(len, size), dest)?;\n+                self.write_scalar(Scalar::from_machine_usize(len, self), dest)?;\n             }\n \n             AddressOf(_, ref place) | Ref(_, _, ref place) => {\n@@ -254,8 +253,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     !layout.is_unsized(),\n                     \"SizeOf nullary MIR operator called for unsized type\"\n                 );\n-                let size = self.pointer_size();\n-                self.write_scalar(Scalar::from_uint(layout.size.bytes(), size), dest)?;\n+                self.write_scalar(Scalar::from_machine_usize(layout.size.bytes(), self), dest)?;\n             }\n \n             Cast(kind, ref operand, _) => {"}, {"sha": "5e686946f8e9a609bbda671c303e45d5b0af8ed2", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/150322f86d441752874a8bed603d71119f190b8b/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150322f86d441752874a8bed603d71119f190b8b/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=150322f86d441752874a8bed603d71119f190b8b", "patch": "@@ -698,6 +698,147 @@ impl OsStr {\n     fn bytes(&self) -> &[u8] {\n         unsafe { &*(&self.inner as *const _ as *const [u8]) }\n     }\n+\n+    /// Converts this string to its ASCII lower case equivalent in-place.\n+    ///\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new lowercased value without modifying the existing one, use\n+    /// [`to_ascii_lowercase`].\n+    ///\n+    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(osstring_ascii)]\n+    /// use std::ffi::OsString;\n+    ///\n+    /// let mut s = OsString::from(\"GR\u00dc\u00dfE, J\u00dcRGEN \u2764\");\n+    ///\n+    /// s.make_ascii_lowercase();\n+    ///\n+    /// assert_eq!(\"gr\u00dc\u00dfe, j\u00dcrgen \u2764\", s);\n+    /// ```\n+    #[unstable(feature = \"osstring_ascii\", issue = \"70516\")]\n+    pub fn make_ascii_lowercase(&mut self) {\n+        self.inner.make_ascii_lowercase()\n+    }\n+\n+    /// Converts this string to its ASCII upper case equivalent in-place.\n+    ///\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new uppercased value without modifying the existing one, use\n+    /// [`to_ascii_uppercase`].\n+    ///\n+    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(osstring_ascii)]\n+    /// use std::ffi::OsString;\n+    ///\n+    /// let mut s = OsString::from(\"Gr\u00fc\u00dfe, J\u00fcrgen \u2764\");\n+    ///\n+    /// s.make_ascii_uppercase();\n+    ///\n+    /// assert_eq!(\"GR\u00fc\u00dfE, J\u00fcRGEN \u2764\", s);\n+    /// ```\n+    #[unstable(feature = \"osstring_ascii\", issue = \"70516\")]\n+    pub fn make_ascii_uppercase(&mut self) {\n+        self.inner.make_ascii_uppercase()\n+    }\n+\n+    /// Returns a copy of this string where each character is mapped to its\n+    /// ASCII lower case equivalent.\n+    ///\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n+    ///\n+    /// [`make_ascii_lowercase`]: #method.make_ascii_lowercase\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(osstring_ascii)]\n+    /// use std::ffi::OsString;\n+    /// let s = OsString::from(\"Gr\u00fc\u00dfe, J\u00fcrgen \u2764\");\n+    ///\n+    /// assert_eq!(\"gr\u00fc\u00dfe, j\u00fcrgen \u2764\", s.to_ascii_lowercase());\n+    /// ```\n+    #[unstable(feature = \"osstring_ascii\", issue = \"70516\")]\n+    pub fn to_ascii_lowercase(&self) -> OsString {\n+        OsString::from_inner(self.inner.to_ascii_lowercase())\n+    }\n+\n+    /// Returns a copy of this string where each character is mapped to its\n+    /// ASCII upper case equivalent.\n+    ///\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n+    ///\n+    /// [`make_ascii_uppercase`]: #method.make_ascii_uppercase\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(osstring_ascii)]\n+    /// use std::ffi::OsString;\n+    /// let s = OsString::from(\"Gr\u00fc\u00dfe, J\u00fcrgen \u2764\");\n+    ///\n+    /// assert_eq!(\"GR\u00fc\u00dfE, J\u00fcRGEN \u2764\", s.to_ascii_uppercase());\n+    /// ```\n+    #[unstable(feature = \"osstring_ascii\", issue = \"70516\")]\n+    pub fn to_ascii_uppercase(&self) -> OsString {\n+        OsString::from_inner(self.inner.to_ascii_uppercase())\n+    }\n+\n+    /// Checks if all characters in this string are within the ASCII range.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(osstring_ascii)]\n+    /// use std::ffi::OsString;\n+    ///\n+    /// let ascii = OsString::from(\"hello!\\n\");\n+    /// let non_ascii = OsString::from(\"Gr\u00fc\u00dfe, J\u00fcrgen \u2764\");\n+    ///\n+    /// assert!(ascii.is_ascii());\n+    /// assert!(!non_ascii.is_ascii());\n+    /// ```\n+    #[unstable(feature = \"osstring_ascii\", issue = \"70516\")]\n+    pub fn is_ascii(&self) -> bool {\n+        self.inner.is_ascii()\n+    }\n+\n+    /// Checks that two strings are an ASCII case-insensitive match.\n+    ///\n+    /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n+    /// but without allocating and copying temporaries.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(osstring_ascii)]\n+    /// use std::ffi::OsString;\n+    ///\n+    /// assert!(OsString::from(\"Ferris\").eq_ignore_ascii_case(\"FERRIS\"));\n+    /// assert!(OsString::from(\"Ferr\u00f6s\").eq_ignore_ascii_case(\"FERR\u00f6S\"));\n+    /// assert!(!OsString::from(\"Ferr\u00f6s\").eq_ignore_ascii_case(\"FERR\u00d6S\"));\n+    /// ```\n+    #[unstable(feature = \"osstring_ascii\", issue = \"70516\")]\n+    pub fn eq_ignore_ascii_case<S: ?Sized + AsRef<OsStr>>(&self, other: &S) -> bool {\n+        self.inner.eq_ignore_ascii_case(&other.as_ref().inner)\n+    }\n }\n \n #[stable(feature = \"box_from_os_str\", since = \"1.17.0\")]"}, {"sha": "134f508dfab09cbcd920bc7b037b9c2088837042", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/150322f86d441752874a8bed603d71119f190b8b/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150322f86d441752874a8bed603d71119f190b8b/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=150322f86d441752874a8bed603d71119f190b8b", "patch": "@@ -778,7 +778,7 @@ extern \"system\" {\n     pub fn ioctlsocket(s: SOCKET, cmd: c_long, argp: *mut c_ulong) -> c_int;\n     pub fn InitializeCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n     pub fn EnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n-    pub fn TryEnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION) -> BOOLEAN;\n+    pub fn TryEnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION) -> BOOL;\n     pub fn LeaveCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n     pub fn DeleteCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n "}, {"sha": "6aab028873e07442d7c3ed778bc3542bd2f0e608", "filename": "src/libstd/sys/windows/os_str.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/150322f86d441752874a8bed603d71119f190b8b/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150322f86d441752874a8bed603d71119f190b8b/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs?ref=150322f86d441752874a8bed603d71119f190b8b", "patch": "@@ -179,4 +179,34 @@ impl Slice {\n         let rc = self.inner.into_rc();\n         unsafe { Rc::from_raw(Rc::into_raw(rc) as *const Slice) }\n     }\n+\n+    #[inline]\n+    pub fn make_ascii_lowercase(&mut self) {\n+        self.inner.make_ascii_lowercase()\n+    }\n+\n+    #[inline]\n+    pub fn make_ascii_uppercase(&mut self) {\n+        self.inner.make_ascii_uppercase()\n+    }\n+\n+    #[inline]\n+    pub fn to_ascii_lowercase(&self) -> Buf {\n+        Buf { inner: self.inner.to_ascii_lowercase() }\n+    }\n+\n+    #[inline]\n+    pub fn to_ascii_uppercase(&self) -> Buf {\n+        Buf { inner: self.inner.to_ascii_uppercase() }\n+    }\n+\n+    #[inline]\n+    pub fn is_ascii(&self) -> bool {\n+        self.inner.is_ascii()\n+    }\n+\n+    #[inline]\n+    pub fn eq_ignore_ascii_case(&self, other: &Self) -> bool {\n+        self.inner.eq_ignore_ascii_case(&other.inner)\n+    }\n }"}, {"sha": "77f9a5c9dc7b9c9378c292c50c6e713cdb3c4d66", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/150322f86d441752874a8bed603d71119f190b8b/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150322f86d441752874a8bed603d71119f190b8b/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=150322f86d441752874a8bed603d71119f190b8b", "patch": "@@ -20,7 +20,7 @@ use crate::sys::mutex::Mutex;\n use crate::sys::pipe::{self, AnonPipe};\n use crate::sys::stdio;\n use crate::sys_common::process::CommandEnv;\n-use crate::sys_common::{AsInner, FromInner, IntoInner};\n+use crate::sys_common::AsInner;\n \n use libc::{c_void, EXIT_FAILURE, EXIT_SUCCESS};\n \n@@ -33,10 +33,9 @@ use libc::{c_void, EXIT_FAILURE, EXIT_SUCCESS};\n pub struct EnvKey(OsString);\n \n impl From<OsString> for EnvKey {\n-    fn from(k: OsString) -> Self {\n-        let mut buf = k.into_inner().into_inner();\n-        buf.make_ascii_uppercase();\n-        EnvKey(FromInner::from_inner(FromInner::from_inner(buf)))\n+    fn from(mut k: OsString) -> Self {\n+        k.make_ascii_uppercase();\n+        EnvKey(k)\n     }\n }\n "}, {"sha": "aa6cc33d831e0f8870a1956388ef457118f0ecd2", "filename": "src/libstd/sys_common/os_str_bytes.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/150322f86d441752874a8bed603d71119f190b8b/src%2Flibstd%2Fsys_common%2Fos_str_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150322f86d441752874a8bed603d71119f190b8b/src%2Flibstd%2Fsys_common%2Fos_str_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fos_str_bytes.rs?ref=150322f86d441752874a8bed603d71119f190b8b", "patch": "@@ -195,6 +195,36 @@ impl Slice {\n         let rc: Rc<[u8]> = Rc::from(&self.inner);\n         unsafe { Rc::from_raw(Rc::into_raw(rc) as *const Slice) }\n     }\n+\n+    #[inline]\n+    pub fn make_ascii_lowercase(&mut self) {\n+        self.inner.make_ascii_lowercase()\n+    }\n+\n+    #[inline]\n+    pub fn make_ascii_uppercase(&mut self) {\n+        self.inner.make_ascii_uppercase()\n+    }\n+\n+    #[inline]\n+    pub fn to_ascii_lowercase(&self) -> Buf {\n+        Buf { inner: self.inner.to_ascii_lowercase() }\n+    }\n+\n+    #[inline]\n+    pub fn to_ascii_uppercase(&self) -> Buf {\n+        Buf { inner: self.inner.to_ascii_uppercase() }\n+    }\n+\n+    #[inline]\n+    pub fn is_ascii(&self) -> bool {\n+        self.inner.is_ascii()\n+    }\n+\n+    #[inline]\n+    pub fn eq_ignore_ascii_case(&self, other: &Self) -> bool {\n+        self.inner.eq_ignore_ascii_case(&other.inner)\n+    }\n }\n \n /// Platform-specific extensions to [`OsString`]."}, {"sha": "fc6614552a92da11e9cad1f4adabc592e463e6cd", "filename": "src/libstd/sys_common/wtf8.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/150322f86d441752874a8bed603d71119f190b8b/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150322f86d441752874a8bed603d71119f190b8b/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fwtf8.rs?ref=150322f86d441752874a8bed603d71119f190b8b", "patch": "@@ -637,6 +637,36 @@ impl Wtf8 {\n         let rc: Rc<[u8]> = Rc::from(&self.bytes);\n         unsafe { Rc::from_raw(Rc::into_raw(rc) as *const Wtf8) }\n     }\n+\n+    #[inline]\n+    pub fn make_ascii_lowercase(&mut self) {\n+        self.bytes.make_ascii_lowercase()\n+    }\n+\n+    #[inline]\n+    pub fn make_ascii_uppercase(&mut self) {\n+        self.bytes.make_ascii_uppercase()\n+    }\n+\n+    #[inline]\n+    pub fn to_ascii_lowercase(&self) -> Wtf8Buf {\n+        Wtf8Buf { bytes: self.bytes.to_ascii_lowercase() }\n+    }\n+\n+    #[inline]\n+    pub fn to_ascii_uppercase(&self) -> Wtf8Buf {\n+        Wtf8Buf { bytes: self.bytes.to_ascii_uppercase() }\n+    }\n+\n+    #[inline]\n+    pub fn is_ascii(&self) -> bool {\n+        self.bytes.is_ascii()\n+    }\n+\n+    #[inline]\n+    pub fn eq_ignore_ascii_case(&self, other: &Self) -> bool {\n+        self.bytes.eq_ignore_ascii_case(&other.bytes)\n+    }\n }\n \n /// Returns a slice of the given string for the byte range [`begin`..`end`).\n@@ -837,12 +867,6 @@ impl Hash for Wtf8 {\n     }\n }\n \n-impl Wtf8 {\n-    pub fn make_ascii_uppercase(&mut self) {\n-        self.bytes.make_ascii_uppercase()\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use super::*;"}]}