{"sha": "94e1413f60a1725b994f986a607a6f370bb230b4", "node_id": "C_kwDOAAsO6NoAKDk0ZTE0MTNmNjBhMTcyNWI5OTRmOTg2YTYwN2E2ZjM3MGJiMjMwYjQ", "commit": {"author": {"name": "Alexander", "email": "alex.m.vlasov@gmail.com", "date": "2021-10-06T15:31:35Z"}, "committer": {"name": "Alexander", "email": "alex.m.vlasov@gmail.com", "date": "2021-10-06T15:31:35Z"}, "message": "reset and cleanup", "tree": {"sha": "dc25710cba692958d0d609ce1fec09d59f1de26b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc25710cba692958d0d609ce1fec09d59f1de26b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94e1413f60a1725b994f986a607a6f370bb230b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94e1413f60a1725b994f986a607a6f370bb230b4", "html_url": "https://github.com/rust-lang/rust/commit/94e1413f60a1725b994f986a607a6f370bb230b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94e1413f60a1725b994f986a607a6f370bb230b4/comments", "author": {"login": "shamatar", "id": 6467575, "node_id": "MDQ6VXNlcjY0Njc1NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6467575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shamatar", "html_url": "https://github.com/shamatar", "followers_url": "https://api.github.com/users/shamatar/followers", "following_url": "https://api.github.com/users/shamatar/following{/other_user}", "gists_url": "https://api.github.com/users/shamatar/gists{/gist_id}", "starred_url": "https://api.github.com/users/shamatar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shamatar/subscriptions", "organizations_url": "https://api.github.com/users/shamatar/orgs", "repos_url": "https://api.github.com/users/shamatar/repos", "events_url": "https://api.github.com/users/shamatar/events{/privacy}", "received_events_url": "https://api.github.com/users/shamatar/received_events", "type": "User", "site_admin": false}, "committer": {"login": "shamatar", "id": 6467575, "node_id": "MDQ6VXNlcjY0Njc1NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6467575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shamatar", "html_url": "https://github.com/shamatar", "followers_url": "https://api.github.com/users/shamatar/followers", "following_url": "https://api.github.com/users/shamatar/following{/other_user}", "gists_url": "https://api.github.com/users/shamatar/gists{/gist_id}", "starred_url": "https://api.github.com/users/shamatar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shamatar/subscriptions", "organizations_url": "https://api.github.com/users/shamatar/orgs", "repos_url": "https://api.github.com/users/shamatar/repos", "events_url": "https://api.github.com/users/shamatar/events{/privacy}", "received_events_url": "https://api.github.com/users/shamatar/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7539a6af09e5889ed9bcb8b49571b7a59c32e65", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7539a6af09e5889ed9bcb8b49571b7a59c32e65", "html_url": "https://github.com/rust-lang/rust/commit/d7539a6af09e5889ed9bcb8b49571b7a59c32e65"}], "stats": {"total": 339, "additions": 339, "deletions": 0}, "files": [{"sha": "9b11c8f0b24c0836fb96b3d31f82236d26e10b85", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94e1413f60a1725b994f986a607a6f370bb230b4/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94e1413f60a1725b994f986a607a6f370bb230b4/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=94e1413f60a1725b994f986a607a6f370bb230b4", "patch": "@@ -58,6 +58,7 @@ mod lower_intrinsics;\n mod lower_slice_len;\n mod match_branches;\n mod multiple_return_terminators;\n+mod normalize_array_len;\n mod nrvo;\n mod remove_noop_landing_pads;\n mod remove_storage_markers;\n@@ -488,6 +489,7 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     // machine than on MIR with async primitives.\n     let optimizations_with_generators: &[&dyn MirPass<'tcx>] = &[\n         &lower_slice_len::LowerSliceLenCalls, // has to be done before inlining, otherwise actual call will be almost always inlined. Also simple, so can just do first\n+        &normalize_array_len::NormalizeArrayLen, // has to run after `slice::len` lowering\n         &unreachable_prop::UnreachablePropagation,\n         &uninhabited_enum_branching::UninhabitedEnumBranching,\n         &simplify::SimplifyCfg::new(\"after-uninhabited-enum-branching\"),"}, {"sha": "e6ec7171a4740d0cf0cad8c636f84b6603a7643b", "filename": "compiler/rustc_mir_transform/src/normalize_array_len.rs", "status": "added", "additions": 287, "deletions": 0, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/94e1413f60a1725b994f986a607a6f370bb230b4/compiler%2Frustc_mir_transform%2Fsrc%2Fnormalize_array_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94e1413f60a1725b994f986a607a6f370bb230b4/compiler%2Frustc_mir_transform%2Fsrc%2Fnormalize_array_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fnormalize_array_len.rs?ref=94e1413f60a1725b994f986a607a6f370bb230b4", "patch": "@@ -0,0 +1,287 @@\n+//! This pass eliminates casting of arrays into slices when their length\n+//! is taken using `.len()` method. Handy to preserve information in MIR for const prop\n+\n+use crate::transform::MirPass;\n+use rustc_data_structures::fx::FxIndexMap;\n+use rustc_index::bit_set::BitSet;\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::mir::*;\n+use rustc_middle::ty::{self, TyCtxt};\n+\n+const MAX_NUM_BLOCKS: usize = 800;\n+const MAX_NUM_LOCALS: usize = 3000;\n+\n+pub struct NormalizeArrayLen;\n+\n+impl<'tcx> MirPass<'tcx> for NormalizeArrayLen {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        // if tcx.sess.mir_opt_level() < 3 {\n+        //     return;\n+        // }\n+\n+        // early returns for edge cases of highly unrolled functions\n+        if body.basic_blocks().len() > MAX_NUM_BLOCKS {\n+            return;\n+        }\n+        if body.local_decls().len() > MAX_NUM_LOCALS {\n+            return;\n+        }\n+        normalize_array_len_calls(tcx, body)\n+    }\n+}\n+\n+pub fn normalize_array_len_calls<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+    let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n+\n+    // do a preliminary analysis to see if we ever have locals of type `[T;N]` or `&[T;N]`\n+    let mut interesting_locals = BitSet::new_empty(local_decls.len());\n+    for (local, decl) in local_decls.iter_enumerated() {\n+        match decl.ty.kind() {\n+            ty::Array(..) => {\n+                interesting_locals.insert(local);\n+            }\n+            ty::Ref(.., ty, Mutability::Not) => match ty.kind() {\n+                ty::Array(..) => {\n+                    interesting_locals.insert(local);\n+                }\n+                _ => {}\n+            },\n+            _ => {}\n+        }\n+    }\n+    if interesting_locals.is_empty() {\n+        // we have found nothing to analyze\n+        return;\n+    }\n+    let num_intesting_locals = interesting_locals.count();\n+    let mut state = FxIndexMap::with_capacity_and_hasher(num_intesting_locals, Default::default());\n+    let mut patches_scratchpad =\n+        FxIndexMap::with_capacity_and_hasher(num_intesting_locals, Default::default());\n+    let mut replacements_scratchpad =\n+        FxIndexMap::with_capacity_and_hasher(num_intesting_locals, Default::default());\n+    for block in basic_blocks {\n+        // make length calls for arrays [T; N] not to decay into length calls for &[T]\n+        // that forbids constant propagation\n+        normalize_array_len_call(\n+            tcx,\n+            block,\n+            local_decls,\n+            &interesting_locals,\n+            &mut state,\n+            &mut patches_scratchpad,\n+            &mut replacements_scratchpad,\n+        );\n+        state.clear();\n+        patches_scratchpad.clear();\n+        replacements_scratchpad.clear();\n+    }\n+}\n+\n+struct Patcher<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    patches_scratchpad: &'a FxIndexMap<usize, usize>,\n+    replacements_scratchpad: &'a mut FxIndexMap<usize, Local>,\n+    local_decls: &'a mut IndexVec<Local, LocalDecl<'tcx>>,\n+    statement_idx: usize,\n+}\n+\n+impl<'a, 'tcx> Patcher<'a, 'tcx> {\n+    fn patch_expand_statement(\n+        &mut self,\n+        statement: &mut Statement<'tcx>,\n+    ) -> Option<std::vec::IntoIter<Statement<'tcx>>> {\n+        let idx = self.statement_idx;\n+        if let Some(len_statemnt_idx) = self.patches_scratchpad.get(&idx).copied() {\n+            let mut statements = Vec::with_capacity(2);\n+\n+            // we are at statement that performs a cast. The only sound way is\n+            // to create another local that performs a similar copy without a cast and then\n+            // use this copy in the Len operation\n+\n+            match &statement.kind {\n+                StatementKind::Assign(box (\n+                    ..,\n+                    Rvalue::Cast(\n+                        CastKind::Pointer(ty::adjustment::PointerCast::Unsize),\n+                        operand,\n+                        _,\n+                    ),\n+                )) => {\n+                    match operand {\n+                        Operand::Copy(place) | Operand::Move(place) => {\n+                            // create new local\n+                            let ty = operand.ty(self.local_decls, self.tcx);\n+                            let local_decl =\n+                                LocalDecl::with_source_info(ty, statement.source_info.clone());\n+                            let local = self.local_decls.push(local_decl);\n+                            // make it live\n+                            let mut make_live_statement = statement.clone();\n+                            make_live_statement.kind = StatementKind::StorageLive(local);\n+                            statements.push(make_live_statement);\n+                            // copy into it\n+\n+                            let operand = Operand::Copy(*place);\n+                            let mut make_copy_statement = statement.clone();\n+                            let assign_to = Place::from(local);\n+                            let rvalue = Rvalue::Use(operand);\n+                            make_copy_statement.kind =\n+                                StatementKind::Assign(box (assign_to, rvalue));\n+                            statements.push(make_copy_statement);\n+\n+                            // to reorder we have to copy and make NOP\n+                            statements.push(statement.clone());\n+                            statement.make_nop();\n+\n+                            self.replacements_scratchpad.insert(len_statemnt_idx, local);\n+                        }\n+                        _ => {\n+                            unreachable!(\"it's a bug in the implementation\")\n+                        }\n+                    }\n+                }\n+                _ => {\n+                    unreachable!(\"it's a bug in the implementation\")\n+                }\n+            }\n+\n+            self.statement_idx += 1;\n+\n+            Some(statements.into_iter())\n+        } else if let Some(local) = self.replacements_scratchpad.get(&idx).copied() {\n+            let mut statements = Vec::with_capacity(2);\n+\n+            match &statement.kind {\n+                StatementKind::Assign(box (into, Rvalue::Len(place))) => {\n+                    let add_deref = if let Some(..) = place.as_local() {\n+                        false\n+                    } else if let Some(..) = place.local_or_deref_local() {\n+                        true\n+                    } else {\n+                        unreachable!(\"it's a bug in the implementation\")\n+                    };\n+                    // replace len statement\n+                    let mut len_statement = statement.clone();\n+                    let mut place = Place::from(local);\n+                    if add_deref {\n+                        place = self.tcx.mk_place_deref(place);\n+                    }\n+                    len_statement.kind = StatementKind::Assign(box (*into, Rvalue::Len(place)));\n+                    statements.push(len_statement);\n+\n+                    // make temporary dead\n+                    let mut make_dead_statement = statement.clone();\n+                    make_dead_statement.kind = StatementKind::StorageDead(local);\n+                    statements.push(make_dead_statement);\n+\n+                    // make original statement NOP\n+                    statement.make_nop();\n+                }\n+                _ => {\n+                    unreachable!(\"it's a bug in the implementation\")\n+                }\n+            }\n+\n+            self.statement_idx += 1;\n+\n+            Some(statements.into_iter())\n+        } else {\n+            self.statement_idx += 1;\n+            None\n+        }\n+    }\n+}\n+\n+fn normalize_array_len_call<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    block: &mut BasicBlockData<'tcx>,\n+    local_decls: &mut IndexVec<Local, LocalDecl<'tcx>>,\n+    interesting_locals: &BitSet<Local>,\n+    state: &mut FxIndexMap<Local, usize>,\n+    patches_scratchpad: &mut FxIndexMap<usize, usize>,\n+    replacements_scratchpad: &mut FxIndexMap<usize, Local>,\n+) {\n+    for (statement_idx, statement) in block.statements.iter_mut().enumerate() {\n+        match &mut statement.kind {\n+            StatementKind::Assign(box (place, rvalue)) => {\n+                match rvalue {\n+                    Rvalue::Cast(\n+                        CastKind::Pointer(ty::adjustment::PointerCast::Unsize),\n+                        operand,\n+                        cast_ty,\n+                    ) => {\n+                        let local = if let Some(local) = place.as_local() { local } else { return };\n+                        match operand {\n+                            Operand::Copy(place) | Operand::Move(place) => {\n+                                let operand_local =\n+                                    if let Some(local) = place.local_or_deref_local() {\n+                                        local\n+                                    } else {\n+                                        return;\n+                                    };\n+                                if !interesting_locals.contains(operand_local) {\n+                                    return;\n+                                }\n+                                let operand_ty = local_decls[operand_local].ty;\n+                                match (operand_ty.kind(), cast_ty.kind()) {\n+                                    (ty::Array(of_ty_src, ..), ty::Slice(of_ty_dst)) => {\n+                                        if of_ty_src == of_ty_dst {\n+                                            // this is a cast from [T; N] into [T], so we are good\n+                                            state.insert(local, statement_idx);\n+                                        }\n+                                    }\n+                                    // current way of patching doesn't allow to work with `mut`\n+                                    (\n+                                        ty::Ref(\n+                                            ty::RegionKind::ReErased,\n+                                            operand_ty,\n+                                            Mutability::Not,\n+                                        ),\n+                                        ty::Ref(ty::RegionKind::ReErased, cast_ty, Mutability::Not),\n+                                    ) => {\n+                                        match (operand_ty.kind(), cast_ty.kind()) {\n+                                            // current way of patching doesn't allow to work with `mut`\n+                                            (ty::Array(of_ty_src, ..), ty::Slice(of_ty_dst)) => {\n+                                                if of_ty_src == of_ty_dst {\n+                                                    // this is a cast from [T; N] into [T], so we are good\n+                                                    state.insert(local, statement_idx);\n+                                                }\n+                                            }\n+                                            _ => {}\n+                                        }\n+                                    }\n+                                    _ => {}\n+                                }\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n+                    Rvalue::Len(place) => {\n+                        let local = if let Some(local) = place.local_or_deref_local() {\n+                            local\n+                        } else {\n+                            return;\n+                        };\n+                        if let Some(cast_statement_idx) = state.get(&local).copied() {\n+                            patches_scratchpad.insert(cast_statement_idx, statement_idx);\n+                        }\n+                    }\n+                    _ => {\n+                        // invalidate\n+                        state.remove(&place.local);\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    let mut patcher = Patcher {\n+        tcx,\n+        patches_scratchpad: &*patches_scratchpad,\n+        replacements_scratchpad,\n+        local_decls,\n+        statement_idx: 0,\n+    };\n+\n+    block.expand_statements(|st| patcher.patch_expand_statement(st));\n+}"}, {"sha": "2b4845bc151daaf622d260851c2377b0443bb289", "filename": "src/test/mir-opt/lower_array_len.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/94e1413f60a1725b994f986a607a6f370bb230b4/src%2Ftest%2Fmir-opt%2Flower_array_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94e1413f60a1725b994f986a607a6f370bb230b4/src%2Ftest%2Fmir-opt%2Flower_array_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Flower_array_len.rs?ref=94e1413f60a1725b994f986a607a6f370bb230b4", "patch": "@@ -0,0 +1,50 @@\n+\n+Viewed\n+@@ -0,0 +1,47 @@\n+// compile-flags: -Z mir-opt-level=3\n+\n+// EMIT_MIR lower_array_len.array_bound.NormalizeArrayLen.diff\n+// EMIT_MIR lower_array_len.array_bound.SimplifyLocals.diff\n+// EMIT_MIR lower_array_len.array_bound.InstCombine.diff\n+pub fn array_bound<const N: usize>(index: usize, slice: &[u8; N]) -> u8 {\n+    if index < slice.len() {\n+        slice[index]\n+    } else {\n+        42\n+    }\n+}\n+\n+// EMIT_MIR lower_array_len.array_bound_mut.NormalizeArrayLen.diff\n+// EMIT_MIR lower_array_len.array_bound_mut.SimplifyLocals.diff\n+// EMIT_MIR lower_array_len.array_bound_mut.InstCombine.diff\n+pub fn array_bound_mut<const N: usize>(index: usize, slice: &mut [u8; N]) -> u8 {\n+    if index < slice.len() {\n+        slice[index]\n+    } else {\n+        slice[0] = 42;\n+\n+        42\n+    }\n+}\n+\n+// EMIT_MIR lower_array_len.array_len.NormalizeArrayLen.diff\n+// EMIT_MIR lower_array_len.array_len.SimplifyLocals.diff\n+// EMIT_MIR lower_array_len.array_len.InstCombine.diff\n+pub fn array_len<const N: usize>(arr: &[u8; N]) -> usize {\n+    arr.len()\n+}\n+\n+// EMIT_MIR lower_array_len.array_len_by_value.NormalizeArrayLen.diff\n+// EMIT_MIR lower_array_len.array_len_by_value.SimplifyLocals.diff\n+// EMIT_MIR lower_array_len.array_len_by_value.InstCombine.diff\n+pub fn array_len_by_value<const N: usize>(arr: [u8; N]) -> usize {\n+    arr.len()\n+}\n+\n+fn main() {\n+    let _ = array_bound(3, &[0, 1, 2, 3]);\n+    let mut tmp = [0, 1, 2, 3, 4];\n+    let _ = array_bound_mut(3, &mut [0, 1, 2, 3]);\n+    let _ = array_len(&[0]);\n+    let _ = array_len_by_value([0, 2]);\n+}\n\\ No newline at end of file"}]}