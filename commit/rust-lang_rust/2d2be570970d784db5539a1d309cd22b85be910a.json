{"sha": "2d2be570970d784db5539a1d309cd22b85be910a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkMmJlNTcwOTcwZDc4NGRiNTUzOWExZDMwOWNkMjJiODViZTkxMGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-12T16:25:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-12T16:25:13Z"}, "message": "Auto merge of #69094 - Dylan-DPC:rollup-4qe7uv1, r=Dylan-DPC\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #67585 (Improve `char::is_ascii_*` codegen)\n - #68914 (Speed up `SipHasher128`.)\n - #68994 (rustbuild: include channel in sanitizers installed name)\n - #69032 (ICE in nightly-2020-02-08: handle TerminatorKind::Yield in librustc_mir::transform::promote_consts::Validator method)\n - #69034 (parser: Remove `Parser::prev_token_kind`)\n - #69042 (Remove backtrace header text)\n - #69059 (Remove a few unused objects)\n - #69089 (Properly use the darwin archive format on Apple targets)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "52c9407b54a2b5c06af608699528a311406a4e78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52c9407b54a2b5c06af608699528a311406a4e78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d2be570970d784db5539a1d309cd22b85be910a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d2be570970d784db5539a1d309cd22b85be910a", "html_url": "https://github.com/rust-lang/rust/commit/2d2be570970d784db5539a1d309cd22b85be910a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d2be570970d784db5539a1d309cd22b85be910a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ed25f069768c046464e68fd382c867ddb04a1e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ed25f069768c046464e68fd382c867ddb04a1e3", "html_url": "https://github.com/rust-lang/rust/commit/2ed25f069768c046464e68fd382c867ddb04a1e3"}, {"sha": "d9982f1f817e67149316b60fbacb0425e7179365", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9982f1f817e67149316b60fbacb0425e7179365", "html_url": "https://github.com/rust-lang/rust/commit/d9982f1f817e67149316b60fbacb0425e7179365"}], "stats": {"total": 365, "additions": 199, "deletions": 166}, "files": [{"sha": "1679cf320182a726a24197557d7bffc47ab8bcf6", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d2be570970d784db5539a1d309cd22b85be910a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2d2be570970d784db5539a1d309cd22b85be910a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=2d2be570970d784db5539a1d309cd22b85be910a", "patch": "@@ -121,9 +121,9 @@ checksum = \"1d49d90015b3c36167a20fe2810c5cd875ad504b39cff3d4eae7977e6b7c1cb2\"\n \n [[package]]\n name = \"backtrace\"\n-version = \"0.3.40\"\n+version = \"0.3.44\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"924c76597f0d9ca25d762c25a4d369d51267536465dc5064bdf0eb073ed477ea\"\n+checksum = \"e4036b9bf40f3cf16aba72a3d65e8a520fc4bafcdc7079aea8f848c58c5b5536\"\n dependencies = [\n  \"backtrace-sys\",\n  \"cfg-if\","}, {"sha": "5790f236cc8fd947f2cb6011fe4da88770cee265", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2d2be570970d784db5539a1d309cd22b85be910a/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d2be570970d784db5539a1d309cd22b85be910a/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=2d2be570970d784db5539a1d309cd22b85be910a", "patch": "@@ -571,7 +571,7 @@ impl Step for Sanitizers {\n         }\n \n         let out_dir = builder.native_dir(self.target).join(\"sanitizers\");\n-        let runtimes = supported_sanitizers(&out_dir, self.target);\n+        let runtimes = supported_sanitizers(&out_dir, self.target, &builder.config.channel);\n         if runtimes.is_empty() {\n             return runtimes;\n         }\n@@ -635,7 +635,11 @@ pub struct SanitizerRuntime {\n }\n \n /// Returns sanitizers available on a given target.\n-fn supported_sanitizers(out_dir: &Path, target: Interned<String>) -> Vec<SanitizerRuntime> {\n+fn supported_sanitizers(\n+    out_dir: &Path,\n+    target: Interned<String>,\n+    channel: &str,\n+) -> Vec<SanitizerRuntime> {\n     let mut result = Vec::new();\n     match &*target {\n         \"x86_64-apple-darwin\" => {\n@@ -644,7 +648,7 @@ fn supported_sanitizers(out_dir: &Path, target: Interned<String>) -> Vec<Sanitiz\n                     cmake_target: format!(\"clang_rt.{}_osx_dynamic\", s),\n                     path: out_dir\n                         .join(&format!(\"build/lib/darwin/libclang_rt.{}_osx_dynamic.dylib\", s)),\n-                    name: format!(\"librustc_rt.{}.dylib\", s),\n+                    name: format!(\"librustc-{}_rt.{}.dylib\", channel, s),\n                 });\n             }\n         }\n@@ -653,7 +657,7 @@ fn supported_sanitizers(out_dir: &Path, target: Interned<String>) -> Vec<Sanitiz\n                 result.push(SanitizerRuntime {\n                     cmake_target: format!(\"clang_rt.{}-x86_64\", s),\n                     path: out_dir.join(&format!(\"build/lib/linux/libclang_rt.{}-x86_64.a\", s)),\n-                    name: format!(\"librustc_rt.{}.a\", s),\n+                    name: format!(\"librustc-{}_rt.{}.a\", channel, s),\n                 });\n             }\n         }\n@@ -662,7 +666,7 @@ fn supported_sanitizers(out_dir: &Path, target: Interned<String>) -> Vec<Sanitiz\n                 result.push(SanitizerRuntime {\n                     cmake_target: format!(\"clang_rt.{}-x86_64\", s),\n                     path: out_dir.join(&format!(\"build/lib/fuchsia/libclang_rt.{}-x86_64.a\", s)),\n-                    name: format!(\"librustc_rt.{}.a\", s),\n+                    name: format!(\"librustc-{}_rt.{}.a\", channel, s),\n                 });\n             }\n         }\n@@ -671,7 +675,7 @@ fn supported_sanitizers(out_dir: &Path, target: Interned<String>) -> Vec<Sanitiz\n                 result.push(SanitizerRuntime {\n                     cmake_target: format!(\"clang_rt.{}-aarch64\", s),\n                     path: out_dir.join(&format!(\"build/lib/fuchsia/libclang_rt.{}-aarch64.a\", s)),\n-                    name: format!(\"librustc_rt.{}.a\", s),\n+                    name: format!(\"librustc-{}_rt.{}.a\", channel, s),\n                 });\n             }\n         }"}, {"sha": "302400744e25df541fbda73dcfbdb17dc240997f", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=2d2be570970d784db5539a1d309cd22b85be910a", "patch": "@@ -1075,7 +1075,10 @@ impl char {\n     #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n     pub const fn is_ascii_alphabetic(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_alphabetic()\n+        match *self {\n+            'A'..='Z' | 'a'..='z' => true,\n+            _ => false,\n+        }\n     }\n \n     /// Checks if the value is an ASCII uppercase character:\n@@ -1108,7 +1111,10 @@ impl char {\n     #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n     pub const fn is_ascii_uppercase(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_uppercase()\n+        match *self {\n+            'A'..='Z' => true,\n+            _ => false,\n+        }\n     }\n \n     /// Checks if the value is an ASCII lowercase character:\n@@ -1141,7 +1147,10 @@ impl char {\n     #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n     pub const fn is_ascii_lowercase(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_lowercase()\n+        match *self {\n+            'a'..='z' => true,\n+            _ => false,\n+        }\n     }\n \n     /// Checks if the value is an ASCII alphanumeric character:\n@@ -1177,7 +1186,10 @@ impl char {\n     #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n     pub const fn is_ascii_alphanumeric(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_alphanumeric()\n+        match *self {\n+            '0'..='9' | 'A'..='Z' | 'a'..='z' => true,\n+            _ => false,\n+        }\n     }\n \n     /// Checks if the value is an ASCII decimal digit:\n@@ -1210,7 +1222,10 @@ impl char {\n     #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n     pub const fn is_ascii_digit(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_digit()\n+        match *self {\n+            '0'..='9' => true,\n+            _ => false,\n+        }\n     }\n \n     /// Checks if the value is an ASCII hexadecimal digit:\n@@ -1246,7 +1261,10 @@ impl char {\n     #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n     pub const fn is_ascii_hexdigit(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_hexdigit()\n+        match *self {\n+            '0'..='9' | 'A'..='F' | 'a'..='f' => true,\n+            _ => false,\n+        }\n     }\n \n     /// Checks if the value is an ASCII punctuation character:\n@@ -1283,7 +1301,10 @@ impl char {\n     #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n     pub const fn is_ascii_punctuation(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_punctuation()\n+        match *self {\n+            '!'..='/' | ':'..='@' | '['..='`' | '{'..='~' => true,\n+            _ => false,\n+        }\n     }\n \n     /// Checks if the value is an ASCII graphic character:\n@@ -1316,7 +1337,10 @@ impl char {\n     #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n     pub const fn is_ascii_graphic(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_graphic()\n+        match *self {\n+            '!'..='~' => true,\n+            _ => false,\n+        }\n     }\n \n     /// Checks if the value is an ASCII whitespace character:\n@@ -1366,7 +1390,10 @@ impl char {\n     #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n     pub const fn is_ascii_whitespace(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_whitespace()\n+        match *self {\n+            '\\t' | '\\n' | '\\x0C' | '\\r' | ' ' => true,\n+            _ => false,\n+        }\n     }\n \n     /// Checks if the value is an ASCII control character:\n@@ -1401,6 +1428,9 @@ impl char {\n     #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n     pub const fn is_ascii_control(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_control()\n+        match *self {\n+            '\\0'..='\\x1F' | '\\x7F' => true,\n+            _ => false,\n+        }\n     }\n }"}, {"sha": "8379a73bb9ebb3c8adea89df7d2521a3e0200e84", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=2d2be570970d784db5539a1d309cd22b85be910a", "patch": "@@ -339,8 +339,6 @@ impl TaintDirections {\n     }\n }\n \n-pub struct ConstraintInfo {}\n-\n impl<'tcx> RegionConstraintCollector<'tcx> {\n     pub fn new() -> Self {\n         Self::default()"}, {"sha": "fca4b1c598c37eecc660fffc16407551ad379978", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=2d2be570970d784db5539a1d309cd22b85be910a", "patch": "@@ -459,6 +459,7 @@ pub enum ArchiveKind {\n     Other,\n     K_GNU,\n     K_BSD,\n+    K_DARWIN,\n     K_COFF,\n }\n "}, {"sha": "96014cbee5da1cdc0b288b14b756dfcfaa64a4a3", "filename": "src/librustc_codegen_llvm/llvm/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs?ref=2d2be570970d784db5539a1d309cd22b85be910a", "patch": "@@ -69,6 +69,7 @@ impl FromStr for ArchiveKind {\n         match s {\n             \"gnu\" => Ok(ArchiveKind::K_GNU),\n             \"bsd\" => Ok(ArchiveKind::K_BSD),\n+            \"darwin\" => Ok(ArchiveKind::K_DARWIN),\n             \"coff\" => Ok(ArchiveKind::K_COFF),\n             _ => Err(()),\n         }"}, {"sha": "aaa4448fc19337eec4f2fcdb1fa712baecba68c2", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=2d2be570970d784db5539a1d309cd22b85be910a", "patch": "@@ -765,20 +765,23 @@ fn link_sanitizer_runtime(sess: &Session, crate_type: config::CrateType, linker:\n     let default_sysroot = filesearch::get_or_default_sysroot();\n     let default_tlib =\n         filesearch::make_target_lib_path(&default_sysroot, sess.opts.target_triple.triple());\n+    let channel = option_env!(\"CFG_RELEASE_CHANNEL\")\n+        .map(|channel| format!(\"-{}\", channel))\n+        .unwrap_or_default();\n \n     match sess.opts.target_triple.triple() {\n         \"x86_64-apple-darwin\" => {\n             // On Apple platforms, the sanitizer is always built as a dylib, and\n             // LLVM will link to `@rpath/*.dylib`, so we need to specify an\n             // rpath to the library as well (the rpath should be absolute, see\n             // PR #41352 for details).\n-            let libname = format!(\"rustc_rt.{}\", name);\n+            let libname = format!(\"rustc{}_rt.{}\", channel, name);\n             let rpath = default_tlib.to_str().expect(\"non-utf8 component in path\");\n             linker.args(&[\"-Wl,-rpath\".into(), \"-Xlinker\".into(), rpath.into()]);\n             linker.link_dylib(Symbol::intern(&libname));\n         }\n         \"x86_64-unknown-linux-gnu\" | \"x86_64-fuchsia\" | \"aarch64-fuchsia\" => {\n-            let filename = format!(\"librustc_rt.{}.a\", name);\n+            let filename = format!(\"librustc{}_rt.{}.a\", channel, name);\n             let path = default_tlib.join(&filename);\n             linker.link_whole_rlib(&path);\n         }"}, {"sha": "ea2af6e192e7c1d0c927393717dcab497c453240", "filename": "src/librustc_codegen_ssa/build.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibrustc_codegen_ssa%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibrustc_codegen_ssa%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbuild.rs?ref=2d2be570970d784db5539a1d309cd22b85be910a", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    println!(\"cargo:rerun-if-changed=build.rs\");\n+    println!(\"cargo:rerun-if-env-changed=CFG_RELEASE_CHANNEL\");\n+}"}, {"sha": "430f2f40caa9b7c889f5d5813ded32b923feffa8", "filename": "src/librustc_data_structures/sip128.rs", "status": "modified", "additions": 84, "deletions": 80, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibrustc_data_structures%2Fsip128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibrustc_data_structures%2Fsip128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsip128.rs?ref=2d2be570970d784db5539a1d309cd22b85be910a", "patch": "@@ -4,7 +4,6 @@ use std::cmp;\n use std::hash::Hasher;\n use std::mem;\n use std::ptr;\n-use std::slice;\n \n #[cfg(test)]\n mod tests;\n@@ -52,46 +51,17 @@ macro_rules! compress {\n     }};\n }\n \n-/// Loads an integer of the desired type from a byte stream, in LE order. Uses\n-/// `copy_nonoverlapping` to let the compiler generate the most efficient way\n-/// to load it from a possibly unaligned address.\n-///\n-/// Unsafe because: unchecked indexing at i..i+size_of(int_ty)\n-macro_rules! load_int_le {\n-    ($buf:expr, $i:expr, $int_ty:ident) => {{\n-        debug_assert!($i + mem::size_of::<$int_ty>() <= $buf.len());\n-        let mut data = 0 as $int_ty;\n-        ptr::copy_nonoverlapping(\n-            $buf.get_unchecked($i),\n-            &mut data as *mut _ as *mut u8,\n-            mem::size_of::<$int_ty>(),\n-        );\n-        data.to_le()\n-    }};\n-}\n-\n-/// Loads an u64 using up to 7 bytes of a byte slice.\n-///\n-/// Unsafe because: unchecked indexing at start..start+len\n+/// Loads up to 8 bytes from a byte-slice into a little-endian u64.\n #[inline]\n-unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n-    debug_assert!(len < 8);\n-    let mut i = 0; // current byte index (from LSB) in the output u64\n-    let mut out = 0;\n-    if i + 3 < len {\n-        out = u64::from(load_int_le!(buf, start + i, u32));\n-        i += 4;\n-    }\n-    if i + 1 < len {\n-        out |= u64::from(load_int_le!(buf, start + i, u16)) << (i * 8);\n-        i += 2\n-    }\n-    if i < len {\n-        out |= u64::from(*buf.get_unchecked(start + i)) << (i * 8);\n-        i += 1;\n+fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n+    assert!(len <= 8 && start + len <= buf.len());\n+\n+    let mut out = 0u64;\n+    unsafe {\n+        let out_ptr = &mut out as *mut _ as *mut u8;\n+        ptr::copy_nonoverlapping(buf.as_ptr().offset(start as isize), out_ptr, len);\n     }\n-    debug_assert_eq!(i, len);\n-    out\n+    out.to_le()\n }\n \n impl SipHasher128 {\n@@ -122,42 +92,76 @@ impl SipHasher128 {\n         self.state.v1 ^= 0xee;\n     }\n \n-    // Specialized write function that is only valid for buffers with len <= 8.\n-    // It's used to force inlining of write_u8 and write_usize, those would normally be inlined\n-    // except for composite types (that includes slices and str hashing because of delimiter).\n-    // Without this extra push the compiler is very reluctant to inline delimiter writes,\n-    // degrading performance substantially for the most common use cases.\n+    // A specialized write function for values with size <= 8.\n+    //\n+    // The hashing of multi-byte integers depends on endianness. E.g.:\n+    // - little-endian: `write_u32(0xDDCCBBAA)` == `write([0xAA, 0xBB, 0xCC, 0xDD])`\n+    // - big-endian:    `write_u32(0xDDCCBBAA)` == `write([0xDD, 0xCC, 0xBB, 0xAA])`\n+    //\n+    // This function does the right thing for little-endian hardware. On\n+    // big-endian hardware `x` must be byte-swapped first to give the right\n+    // behaviour. After any byte-swapping, the input must be zero-extended to\n+    // 64-bits. The caller is responsible for the byte-swapping and\n+    // zero-extension.\n     #[inline]\n-    fn short_write(&mut self, msg: &[u8]) {\n-        debug_assert!(msg.len() <= 8);\n-        let length = msg.len();\n-        self.length += length;\n+    fn short_write<T>(&mut self, _x: T, x: u64) {\n+        let size = mem::size_of::<T>();\n+        self.length += size;\n+\n+        // The original number must be zero-extended, not sign-extended.\n+        debug_assert!(if size < 8 { x >> (8 * size) == 0 } else { true });\n \n+        // The number of bytes needed to fill `self.tail`.\n         let needed = 8 - self.ntail;\n-        let fill = cmp::min(length, needed);\n-        if fill == 8 {\n-            self.tail = unsafe { load_int_le!(msg, 0, u64) };\n-        } else {\n-            self.tail |= unsafe { u8to64_le(msg, 0, fill) } << (8 * self.ntail);\n-            if length < needed {\n-                self.ntail += length;\n-                return;\n-            }\n+\n+        // SipHash parses the input stream as 8-byte little-endian integers.\n+        // Inputs are put into `self.tail` until 8 bytes of data have been\n+        // collected, and then that word is processed.\n+        //\n+        // For example, imagine that `self.tail` is 0x0000_00EE_DDCC_BBAA,\n+        // `self.ntail` is 5 (because 5 bytes have been put into `self.tail`),\n+        // and `needed` is therefore 3.\n+        //\n+        // - Scenario 1, `self.write_u8(0xFF)`: we have already zero-extended\n+        //   the input to 0x0000_0000_0000_00FF. We now left-shift it five\n+        //   bytes, giving 0x0000_FF00_0000_0000. We then bitwise-OR that value\n+        //   into `self.tail`, resulting in 0x0000_FFEE_DDCC_BBAA.\n+        //   (Zero-extension of the original input is critical in this scenario\n+        //   because we don't want the high two bytes of `self.tail` to be\n+        //   touched by the bitwise-OR.) `self.tail` is not yet full, so we\n+        //   return early, after updating `self.ntail` to 6.\n+        //\n+        // - Scenario 2, `self.write_u32(0xIIHH_GGFF)`: we have already\n+        //   zero-extended the input to 0x0000_0000_IIHH_GGFF. We now\n+        //   left-shift it five bytes, giving 0xHHGG_FF00_0000_0000. We then\n+        //   bitwise-OR that value into `self.tail`, resulting in\n+        //   0xHHGG_FFEE_DDCC_BBAA. `self.tail` is now full, and we can use it\n+        //   to update `self.state`. (As mentioned above, this assumes a\n+        //   little-endian machine; on a big-endian machine we would have\n+        //   byte-swapped 0xIIHH_GGFF in the caller, giving 0xFFGG_HHII, and we\n+        //   would then end up bitwise-ORing 0xGGHH_II00_0000_0000 into\n+        //   `self.tail`).\n+        //\n+        self.tail |= x << (8 * self.ntail);\n+        if size < needed {\n+            self.ntail += size;\n+            return;\n         }\n+\n+        // `self.tail` is full, process it.\n         self.state.v3 ^= self.tail;\n         Sip24Rounds::c_rounds(&mut self.state);\n         self.state.v0 ^= self.tail;\n \n-        // Buffered tail is now flushed, process new input.\n-        self.ntail = length - needed;\n-        self.tail = unsafe { u8to64_le(msg, needed, self.ntail) };\n-    }\n-\n-    #[inline(always)]\n-    fn short_write_gen<T>(&mut self, x: T) {\n-        let bytes =\n-            unsafe { slice::from_raw_parts(&x as *const T as *const u8, mem::size_of::<T>()) };\n-        self.short_write(bytes);\n+        // Continuing scenario 2: we have one byte left over from the input. We\n+        // set `self.ntail` to 1 and `self.tail` to `0x0000_0000_IIHH_GGFF >>\n+        // 8*3`, which is 0x0000_0000_0000_00II. (Or on a big-endian machine\n+        // the prior byte-swapping would leave us with 0x0000_0000_0000_00FF.)\n+        //\n+        // The `if` is needed to avoid shifting by 64 bits, which Rust\n+        // complains about.\n+        self.ntail = size - needed;\n+        self.tail = if needed < 8 { x >> (8 * needed) } else { 0 };\n     }\n \n     #[inline]\n@@ -182,52 +186,52 @@ impl SipHasher128 {\n impl Hasher for SipHasher128 {\n     #[inline]\n     fn write_u8(&mut self, i: u8) {\n-        self.short_write_gen(i);\n+        self.short_write(i, i as u64);\n     }\n \n     #[inline]\n     fn write_u16(&mut self, i: u16) {\n-        self.short_write_gen(i);\n+        self.short_write(i, i.to_le() as u64);\n     }\n \n     #[inline]\n     fn write_u32(&mut self, i: u32) {\n-        self.short_write_gen(i);\n+        self.short_write(i, i.to_le() as u64);\n     }\n \n     #[inline]\n     fn write_u64(&mut self, i: u64) {\n-        self.short_write_gen(i);\n+        self.short_write(i, i.to_le() as u64);\n     }\n \n     #[inline]\n     fn write_usize(&mut self, i: usize) {\n-        self.short_write_gen(i);\n+        self.short_write(i, i.to_le() as u64);\n     }\n \n     #[inline]\n     fn write_i8(&mut self, i: i8) {\n-        self.short_write_gen(i);\n+        self.short_write(i, i as u8 as u64);\n     }\n \n     #[inline]\n     fn write_i16(&mut self, i: i16) {\n-        self.short_write_gen(i);\n+        self.short_write(i, (i as u16).to_le() as u64);\n     }\n \n     #[inline]\n     fn write_i32(&mut self, i: i32) {\n-        self.short_write_gen(i);\n+        self.short_write(i, (i as u32).to_le() as u64);\n     }\n \n     #[inline]\n     fn write_i64(&mut self, i: i64) {\n-        self.short_write_gen(i);\n+        self.short_write(i, (i as u64).to_le() as u64);\n     }\n \n     #[inline]\n     fn write_isize(&mut self, i: isize) {\n-        self.short_write_gen(i);\n+        self.short_write(i, (i as usize).to_le() as u64);\n     }\n \n     #[inline]\n@@ -239,7 +243,7 @@ impl Hasher for SipHasher128 {\n \n         if self.ntail != 0 {\n             needed = 8 - self.ntail;\n-            self.tail |= unsafe { u8to64_le(msg, 0, cmp::min(length, needed)) } << (8 * self.ntail);\n+            self.tail |= u8to64_le(msg, 0, cmp::min(length, needed)) << (8 * self.ntail);\n             if length < needed {\n                 self.ntail += length;\n                 return;\n@@ -257,7 +261,7 @@ impl Hasher for SipHasher128 {\n \n         let mut i = needed;\n         while i < len - left {\n-            let mi = unsafe { load_int_le!(msg, i, u64) };\n+            let mi = u8to64_le(msg, i, 8);\n \n             self.state.v3 ^= mi;\n             Sip24Rounds::c_rounds(&mut self.state);\n@@ -266,7 +270,7 @@ impl Hasher for SipHasher128 {\n             i += 8;\n         }\n \n-        self.tail = unsafe { u8to64_le(msg, i, left) };\n+        self.tail = u8to64_le(msg, i, left);\n         self.ntail = left;\n     }\n "}, {"sha": "f68ea7e0770324bb9fb3fc2c4e4c94769b43f723", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=2d2be570970d784db5539a1d309cd22b85be910a", "patch": "@@ -120,10 +120,6 @@ pub trait Callbacks {\n     }\n }\n \n-pub struct DefaultCallbacks;\n-\n-impl Callbacks for DefaultCallbacks {}\n-\n #[derive(Default)]\n pub struct TimePassesCallbacks {\n     time_passes: bool,"}, {"sha": "a5d59860c3d16c6e7708994674f511ae34862ef8", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=2d2be570970d784db5539a1d309cd22b85be910a", "patch": "@@ -463,6 +463,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 let terminator = self.body[loc.block].terminator();\n                 match &terminator.kind {\n                     TerminatorKind::Call { func, args, .. } => self.validate_call(func, args),\n+                    TerminatorKind::Yield { .. } => Err(Unpromotable),\n                     kind => {\n                         span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);\n                     }"}, {"sha": "c8c0ba4c66ee25af9ca919f9bbfecdcc11ef0f95", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=2d2be570970d784db5539a1d309cd22b85be910a", "patch": "@@ -1,6 +1,6 @@\n use super::pat::{GateOr, PARAM_EXPECTED};\n use super::ty::{AllowPlus, RecoverQPath};\n-use super::{BlockMode, Parser, PathStyle, PrevTokenKind, Restrictions, TokenType};\n+use super::{BlockMode, Parser, PathStyle, Restrictions, TokenType};\n use super::{SemiColonMode, SeqSep, TokenExpectType};\n use crate::maybe_recover_from_interpolated_ty_qpath;\n \n@@ -166,17 +166,10 @@ impl<'a> Parser<'a> {\n \n         self.expected_tokens.push(TokenType::Operator);\n         while let Some(op) = self.check_assoc_op() {\n-            // Adjust the span for interpolated LHS to point to the `$lhs` token and not to what\n-            // it refers to. Interpolated identifiers are unwrapped early and never show up here\n-            // as `PrevTokenKind::Interpolated` so if LHS is a single identifier we always process\n-            // it as \"interpolated\", it doesn't change the answer for non-interpolated idents.\n-            let lhs_span = match (self.prev_token_kind, &lhs.kind) {\n-                (PrevTokenKind::Interpolated, _) => self.prev_span,\n-                (PrevTokenKind::Ident, &ExprKind::Path(None, ref path))\n-                    if path.segments.len() == 1 =>\n-                {\n-                    self.prev_span\n-                }\n+            // Adjust the span for interpolated LHS to point to the `$lhs` token\n+            // and not to what it refers to.\n+            let lhs_span = match self.unnormalized_prev_token().kind {\n+                TokenKind::Interpolated(..) => self.prev_span,\n                 _ => lhs.span,\n             };\n \n@@ -535,11 +528,13 @@ impl<'a> Parser<'a> {\n         expr: PResult<'a, P<Expr>>,\n     ) -> PResult<'a, (Span, P<Expr>)> {\n         expr.map(|e| {\n-            if self.prev_token_kind == PrevTokenKind::Interpolated {\n-                (self.prev_span, e)\n-            } else {\n-                (e.span, e)\n-            }\n+            (\n+                match self.unnormalized_prev_token().kind {\n+                    TokenKind::Interpolated(..) => self.prev_span,\n+                    _ => e.span,\n+                },\n+                e,\n+            )\n         })\n     }\n "}, {"sha": "37b03cf32f49cce19191a1db510585f6f5480c0b", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 6, "deletions": 32, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=2d2be570970d784db5539a1d309cd22b85be910a", "patch": "@@ -83,18 +83,6 @@ macro_rules! maybe_recover_from_interpolated_ty_qpath {\n     };\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq)]\n-enum PrevTokenKind {\n-    DocComment,\n-    Comma,\n-    Plus,\n-    Interpolated,\n-    Eof,\n-    Ident,\n-    BitOr,\n-    Other,\n-}\n-\n #[derive(Clone)]\n pub struct Parser<'a> {\n     pub sess: &'a ParseSess,\n@@ -115,9 +103,6 @@ pub struct Parser<'a> {\n     /// Preferable use is through the `unnormalized_prev_token()` getter.\n     /// Use span from this token if you need to concatenate it with some neighbouring spans.\n     unnormalized_prev_token: Option<Token>,\n-    /// Equivalent to `prev_token.kind` in simplified form.\n-    /// FIXME: Remove in favor of `(unnormalized_)prev_token().kind`.\n-    prev_token_kind: PrevTokenKind,\n     /// Equivalent to `unnormalized_prev_token().span`.\n     /// FIXME: Remove in favor of `(unnormalized_)prev_token().span`.\n     pub prev_span: Span,\n@@ -396,7 +381,6 @@ impl<'a> Parser<'a> {\n             unnormalized_token: None,\n             prev_token: Token::dummy(),\n             unnormalized_prev_token: None,\n-            prev_token_kind: PrevTokenKind::Other,\n             prev_span: DUMMY_SP,\n             restrictions: Restrictions::empty(),\n             recurse_into_file_modules,\n@@ -523,10 +507,11 @@ impl<'a> Parser<'a> {\n                 self.bump();\n                 Ok(Ident::new(name, span))\n             }\n-            _ => Err(if self.prev_token_kind == PrevTokenKind::DocComment {\n-                self.span_fatal_err(self.prev_span, Error::UselessDocComment)\n-            } else {\n-                self.expected_ident_found()\n+            _ => Err(match self.prev_token.kind {\n+                TokenKind::DocComment(..) => {\n+                    self.span_fatal_err(self.prev_span, Error::UselessDocComment)\n+                }\n+                _ => self.expected_ident_found(),\n             }),\n         }\n     }\n@@ -908,7 +893,7 @@ impl<'a> Parser<'a> {\n \n     /// Advance the parser by one token.\n     pub fn bump(&mut self) {\n-        if self.prev_token_kind == PrevTokenKind::Eof {\n+        if self.prev_token.kind == TokenKind::Eof {\n             // Bumping after EOF is a bad sign, usually an infinite loop.\n             let msg = \"attempted to bump the parser past EOF (may be stuck in a loop)\";\n             self.span_bug(self.token.span, msg);\n@@ -920,16 +905,6 @@ impl<'a> Parser<'a> {\n         self.unnormalized_prev_token = self.unnormalized_token.take();\n \n         // Update fields derived from the previous token.\n-        self.prev_token_kind = match self.prev_token.kind {\n-            token::DocComment(..) => PrevTokenKind::DocComment,\n-            token::Comma => PrevTokenKind::Comma,\n-            token::BinOp(token::Plus) => PrevTokenKind::Plus,\n-            token::BinOp(token::Or) => PrevTokenKind::BitOr,\n-            token::Interpolated(..) => PrevTokenKind::Interpolated,\n-            token::Eof => PrevTokenKind::Eof,\n-            token::Ident(..) => PrevTokenKind::Ident,\n-            _ => PrevTokenKind::Other,\n-        };\n         self.prev_span = self.unnormalized_prev_token().span;\n \n         self.expected_tokens.clear();\n@@ -949,7 +924,6 @@ impl<'a> Parser<'a> {\n         self.unnormalized_prev_token = self.unnormalized_token.take();\n \n         // Update fields derived from the previous token.\n-        self.prev_token_kind = PrevTokenKind::Other;\n         self.prev_span = self.unnormalized_prev_token().span.with_hi(span.lo());\n \n         self.expected_tokens.clear();"}, {"sha": "e11cdd5dadb7241d97e0c07a8ce6b3a53ecfec7a", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=2d2be570970d784db5539a1d309cd22b85be910a", "patch": "@@ -2,7 +2,7 @@ use super::diagnostics::Error;\n use super::expr::LhsExpr;\n use super::pat::GateOr;\n use super::path::PathStyle;\n-use super::{BlockMode, Parser, PrevTokenKind, Restrictions, SemiColonMode};\n+use super::{BlockMode, Parser, Restrictions, SemiColonMode};\n use crate::maybe_whole;\n use crate::DirectoryOwnership;\n \n@@ -190,7 +190,7 @@ impl<'a> Parser<'a> {\n     /// Also error if the previous token was a doc comment.\n     fn error_outer_attrs(&self, attrs: &[Attribute]) {\n         if !attrs.is_empty() {\n-            if self.prev_token_kind == PrevTokenKind::DocComment {\n+            if matches!(self.prev_token.kind, TokenKind::DocComment(..)) {\n                 self.span_fatal_err(self.prev_span, Error::UselessDocComment).emit();\n             } else if attrs.iter().any(|a| a.style == AttrStyle::Outer) {\n                 self.struct_span_err(self.token.span, \"expected statement after outer attribute\")"}, {"sha": "e74ce622947bfe330d7ec14f472f048ac06e6c9c", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=2d2be570970d784db5539a1d309cd22b85be910a", "patch": "@@ -1,5 +1,5 @@\n use super::item::ParamCfg;\n-use super::{Parser, PathStyle, PrevTokenKind, TokenType};\n+use super::{Parser, PathStyle, TokenType};\n \n use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n \n@@ -14,7 +14,7 @@ use syntax::ast::{\n };\n use syntax::ast::{Mac, Mutability};\n use syntax::ptr::P;\n-use syntax::token::{self, Token};\n+use syntax::token::{self, Token, TokenKind};\n \n /// Any `?` or `?const` modifiers that appear at the start of a bound.\n struct BoundModifiers {\n@@ -196,7 +196,7 @@ impl<'a> Parser<'a> {\n         let mut trailing_plus = false;\n         let (ts, trailing) = self.parse_paren_comma_seq(|p| {\n             let ty = p.parse_ty()?;\n-            trailing_plus = p.prev_token_kind == PrevTokenKind::Plus;\n+            trailing_plus = p.prev_token.kind == TokenKind::BinOp(token::Plus);\n             Ok(ty)\n         })?;\n \n@@ -320,7 +320,7 @@ impl<'a> Parser<'a> {\n     fn parse_impl_ty(&mut self, impl_dyn_multi: &mut bool) -> PResult<'a, TyKind> {\n         // Always parse bounds greedily for better error recovery.\n         let bounds = self.parse_generic_bounds(None)?;\n-        *impl_dyn_multi = bounds.len() > 1 || self.prev_token_kind == PrevTokenKind::Plus;\n+        *impl_dyn_multi = bounds.len() > 1 || self.prev_token.kind == TokenKind::BinOp(token::Plus);\n         Ok(TyKind::ImplTrait(ast::DUMMY_NODE_ID, bounds))\n     }\n \n@@ -340,7 +340,7 @@ impl<'a> Parser<'a> {\n         self.bump(); // `dyn`\n         // Always parse bounds greedily for better error recovery.\n         let bounds = self.parse_generic_bounds(None)?;\n-        *impl_dyn_multi = bounds.len() > 1 || self.prev_token_kind == PrevTokenKind::Plus;\n+        *impl_dyn_multi = bounds.len() > 1 || self.prev_token.kind == TokenKind::BinOp(token::Plus);\n         Ok(TyKind::TraitObject(bounds, TraitObjectSyntax::Dyn))\n     }\n "}, {"sha": "d116ddf952aaae3efbd5fa9e83e915efec83fca2", "filename": "src/librustc_target/spec/apple_base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibrustc_target%2Fspec%2Fapple_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibrustc_target%2Fspec%2Fapple_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fapple_base.rs?ref=2d2be570970d784db5539a1d309cd22b85be910a", "patch": "@@ -26,7 +26,7 @@ pub fn opts() -> TargetOptions {\n         has_rpath: true,\n         dll_prefix: \"lib\".to_string(),\n         dll_suffix: \".dylib\".to_string(),\n-        archive_format: \"bsd\".to_string(),\n+        archive_format: \"darwin\".to_string(),\n         pre_link_args: LinkArgs::new(),\n         has_elf_tls: version >= (10, 7),\n         abi_return_struct_as_int: true,"}, {"sha": "b147aa55b2a6135617904eb213011d8f86169c08", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=2d2be570970d784db5539a1d309cd22b85be910a", "patch": "@@ -27,7 +27,7 @@ hashbrown = { version = \"0.6.2\", default-features = false, features = ['rustc-de\n \n [dependencies.backtrace_rs]\n package = \"backtrace\"\n-version = \"0.3.37\"\n+version = \"0.3.44\"\n default-features = false # without the libstd `backtrace` feature, stub out everything\n features = [ \"rustc-dep-of-std\" ] # enable build support for integrating into libstd\n "}, {"sha": "289ee07babfcf297480fd7d3fdd1c863689fc6b2", "filename": "src/libstd/sys_common/backtrace.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d2be570970d784db5539a1d309cd22b85be910a/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fbacktrace.rs?ref=2d2be570970d784db5539a1d309cd22b85be910a", "patch": "@@ -70,6 +70,7 @@ unsafe fn _print_fmt(fmt: &mut fmt::Formatter<'_>, print_fmt: PrintFmt) -> fmt::\n     let mut print_path = move |fmt: &mut fmt::Formatter<'_>, bows: BytesOrWideString<'_>| {\n         output_filename(fmt, bows, print_fmt, cwd.as_ref())\n     };\n+    write!(fmt, \"stack backtrace:\\n\")?;\n     let mut bt_fmt = BacktraceFmt::new(fmt, print_fmt, &mut print_path);\n     bt_fmt.add_context()?;\n     let mut idx = 0;"}, {"sha": "93704638f8351661a99ee2a4a2a821d81af83fa6", "filename": "src/rustllvm/ArchiveWrapper.cpp", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d2be570970d784db5539a1d309cd22b85be910a/src%2Frustllvm%2FArchiveWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/2d2be570970d784db5539a1d309cd22b85be910a/src%2Frustllvm%2FArchiveWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FArchiveWrapper.cpp?ref=2d2be570970d784db5539a1d309cd22b85be910a", "patch": "@@ -38,6 +38,7 @@ enum class LLVMRustArchiveKind {\n   Other,\n   GNU,\n   BSD,\n+  DARWIN,\n   COFF,\n };\n \n@@ -47,6 +48,8 @@ static Archive::Kind fromRust(LLVMRustArchiveKind Kind) {\n     return Archive::K_GNU;\n   case LLVMRustArchiveKind::BSD:\n     return Archive::K_BSD;\n+  case LLVMRustArchiveKind::DARWIN:\n+    return Archive::K_DARWIN;\n   case LLVMRustArchiveKind::COFF:\n     return Archive::K_COFF;\n   default:"}, {"sha": "511deb60e45533b73d72412a98411fdaf2f69d5e", "filename": "src/test/ui/generator/issue-69017.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2d2be570970d784db5539a1d309cd22b85be910a/src%2Ftest%2Fui%2Fgenerator%2Fissue-69017.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d2be570970d784db5539a1d309cd22b85be910a/src%2Ftest%2Fui%2Fgenerator%2Fissue-69017.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-69017.rs?ref=2d2be570970d784db5539a1d309cd22b85be910a", "patch": "@@ -0,0 +1,18 @@\n+// This issue reproduces an ICE on compile\n+// Fails on 2020-02-08 nightly\n+// regressed commit: https://github.com/rust-lang/rust/commit/f8fd4624474a68bd26694eff3536b9f3a127b2d3\n+//\n+// check-pass\n+\n+#![feature(generator_trait)]\n+#![feature(generators)]\n+\n+use std::ops::Generator;\n+\n+fn gen() -> impl Generator<usize> {\n+    |_: usize| {\n+        println!(\"-> {}\", yield);\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "902a2b6f5a0e96aa330e51701c6387f33ee4a088", "filename": "src/test/ui/std-backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d2be570970d784db5539a1d309cd22b85be910a/src%2Ftest%2Fui%2Fstd-backtrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d2be570970d784db5539a1d309cd22b85be910a/src%2Ftest%2Fui%2Fstd-backtrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstd-backtrace.rs?ref=2d2be570970d784db5539a1d309cd22b85be910a", "patch": "@@ -16,9 +16,9 @@ use std::str;\n fn main() {\n     let args: Vec<String> = env::args().collect();\n     if args.len() >= 2 && args[1] == \"force\" {\n-        println!(\"{}\", std::backtrace::Backtrace::force_capture());\n+        println!(\"stack backtrace:\\n{}\", std::backtrace::Backtrace::force_capture());\n     } else if args.len() >= 2 {\n-        println!(\"{}\", std::backtrace::Backtrace::capture());\n+        println!(\"stack backtrace:\\n{}\", std::backtrace::Backtrace::capture());\n     } else {\n         runtest(&args[0]);\n         println!(\"test ok\");"}]}