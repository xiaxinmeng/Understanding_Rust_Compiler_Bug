{"sha": "1f33145ae91cbe095616c92ace63c93b61e5b4e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmMzMxNDVhZTkxY2JlMDk1NjE2YzkyYWNlNjNjOTNiNjFlNWI0ZTk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-12T10:04:26Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-04T13:51:12Z"}, "message": "make `no_late_bound_regions` a method on `Binder<T>`", "tree": {"sha": "3fd22cfd17b5f0fae6b92f850fe80f17ea446dbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fd22cfd17b5f0fae6b92f850fe80f17ea446dbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f33145ae91cbe095616c92ace63c93b61e5b4e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f33145ae91cbe095616c92ace63c93b61e5b4e9", "html_url": "https://github.com/rust-lang/rust/commit/1f33145ae91cbe095616c92ace63c93b61e5b4e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f33145ae91cbe095616c92ace63c93b61e5b4e9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5562663a6cb010a3c155c873b2325c29033713f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5562663a6cb010a3c155c873b2325c29033713f7", "html_url": "https://github.com/rust-lang/rust/commit/5562663a6cb010a3c155c873b2325c29033713f7"}], "stats": {"total": 56, "additions": 33, "deletions": 23}, "files": [{"sha": "452ceddd7d6e9d1295c740b88c3d4a44f239dff0", "filename": "src/librustc/infer/outlives/implied_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f33145ae91cbe095616c92ace63c93b61e5b4e9/src%2Flibrustc%2Finfer%2Foutlives%2Fimplied_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f33145ae91cbe095616c92ace63c93b61e5b4e9/src%2Flibrustc%2Finfer%2Foutlives%2Fimplied_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fimplied_bounds.rs?ref=1f33145ae91cbe095616c92ace63c93b61e5b4e9", "patch": "@@ -126,7 +126,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                     }\n \n                     ty::Predicate::RegionOutlives(ref data) => {\n-                        match tcx.no_late_bound_regions(data) {\n+                        match data.no_late_bound_regions() {\n                             None => vec![],\n                             Some(ty::OutlivesPredicate(r_a, r_b)) => {\n                                 vec![ImpliedBound::RegionSubRegion(r_b, r_a)]\n@@ -135,7 +135,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                     }\n \n                     ty::Predicate::TypeOutlives(ref data) => {\n-                        match tcx.no_late_bound_regions(data) {\n+                        match data.no_late_bound_regions() {\n                             None => vec![],\n                             Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n                                 let ty_a = self.resolve_type_vars_if_possible(&ty_a);"}, {"sha": "07eacde0aab883239308208e7ace5b3c790e9ddc", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f33145ae91cbe095616c92ace63c93b61e5b4e9/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f33145ae91cbe095616c92ace63c93b61e5b4e9/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=1f33145ae91cbe095616c92ace63c93b61e5b4e9", "patch": "@@ -604,7 +604,7 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n         predicates\n             .into_iter()\n             .filter_map(|p| p.as_ref().to_opt_type_outlives())\n-            .filter_map(|p| self.tcx().no_late_bound_regions(&p))\n+            .filter_map(|p| p.no_late_bound_regions())\n             .filter(|p| p.0 == ty)\n             .map(|p| p.1)\n             .collect()"}, {"sha": "93e33836818ce9d9f75559694b9fe7a6175db078", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f33145ae91cbe095616c92ace63c93b61e5b4e9/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f33145ae91cbe095616c92ace63c93b61e5b4e9/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=1f33145ae91cbe095616c92ace63c93b61e5b4e9", "patch": "@@ -400,14 +400,14 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n \n         ty::Predicate::TypeOutlives(ref binder) => {\n             // Check if there are higher-ranked regions.\n-            match selcx.tcx().no_late_bound_regions(binder) {\n+            match binder.no_late_bound_regions() {\n                 // If there are, inspect the underlying type further.\n                 None => {\n                     // Convert from `Binder<OutlivesPredicate<Ty, Region>>` to `Binder<Ty>`.\n                     let binder = binder.map_bound_ref(|pred| pred.0);\n \n                     // Check if the type has any bound regions.\n-                    match selcx.tcx().no_late_bound_regions(&binder) {\n+                    match binder.no_late_bound_regions() {\n                         // If so, this obligation is an error (for now). Eventually we should be\n                         // able to support additional cases here, like `for<'a> &'a str: 'a`.\n                         None => {"}, {"sha": "429771cca9844c831f787868ee0e9a1618f2ad7e", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f33145ae91cbe095616c92ace63c93b61e5b4e9/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f33145ae91cbe095616c92ace63c93b61e5b4e9/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=1f33145ae91cbe095616c92ace63c93b61e5b4e9", "patch": "@@ -1559,7 +1559,7 @@ impl<'cx, 'gcx, 'tcx> ProjectionCacheKey<'tcx> {\n         let infcx = selcx.infcx();\n         // We don't do cross-snapshot caching of obligations with escaping regions,\n         // so there's no cache key to use\n-        infcx.tcx.no_late_bound_regions(&predicate)\n+        predicate.no_late_bound_regions()\n             .map(|predicate| ProjectionCacheKey {\n                 // We don't attempt to match up with a specific type-variable state\n                 // from a specific call to `opt_normalize_projection_type` - if"}, {"sha": "91e6c4270b32a24b0b504d4060b0bc68a4d51424", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f33145ae91cbe095616c92ace63c93b61e5b4e9/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f33145ae91cbe095616c92ace63c93b61e5b4e9/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=1f33145ae91cbe095616c92ace63c93b61e5b4e9", "patch": "@@ -1834,7 +1834,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         //     T: Trait\n         // so it seems ok if we (conservatively) fail to accept that `Unsize`\n         // obligation above. Should be possible to extend this in the future.\n-        let source = match self.tcx().no_late_bound_regions(&obligation.self_ty()) {\n+        let source = match obligation.self_ty().no_late_bound_regions() {\n             Some(t) => t,\n             None => {\n                 // Don't add any candidates if there are bound regions.\n@@ -2784,7 +2784,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // assemble_candidates_for_unsizing should ensure there are no late bound\n         // regions here. See the comment there for more details.\n         let source = self.infcx.shallow_resolve(\n-            tcx.no_late_bound_regions(&obligation.self_ty()).unwrap());\n+            obligation.self_ty().no_late_bound_regions().unwrap());\n         let target = obligation.predicate.skip_binder().trait_ref.substs.type_at(1);\n         let target = self.infcx.shallow_resolve(target);\n "}, {"sha": "658596031832e1cabed4683377c811f9688ffb1e", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1f33145ae91cbe095616c92ace63c93b61e5b4e9/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f33145ae91cbe095616c92ace63c93b61e5b4e9/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=1f33145ae91cbe095616c92ace63c93b61e5b4e9", "patch": "@@ -364,16 +364,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         Binder(value)\n     }\n \n-    pub fn no_late_bound_regions<T>(self, value: &Binder<T>) -> Option<T>\n-        where T : TypeFoldable<'tcx>\n-    {\n-        if value.0.has_escaping_regions() {\n-            None\n-        } else {\n-            Some(value.0.clone())\n-        }\n-    }\n-\n     /// Returns a set of all late-bound regions that are constrained\n     /// by `value`, meaning that if we instantiate those LBR with\n     /// variables and equate `value` with something else, those"}, {"sha": "c115b573a1c062390edfd224421bf9990f6261ab", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1f33145ae91cbe095616c92ace63c93b61e5b4e9/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f33145ae91cbe095616c92ace63c93b61e5b4e9/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=1f33145ae91cbe095616c92ace63c93b61e5b4e9", "patch": "@@ -680,6 +680,26 @@ impl<T> Binder<T> {\n     {\n         ty::Binder(f(self.0))\n     }\n+\n+    /// Unwraps and returns the value within, but only if it contains\n+    /// no bound regions at all. (In other words, if this binder --\n+    /// and indeed any enclosing binder -- doesn't bind anything at\n+    /// all.) Otherwise, returns `None`.\n+    ///\n+    /// (One could imagine having a method that just unwraps a single\n+    /// binder, but permits late-bound regions bound by enclosing\n+    /// binders, but that would require adjusting the debruijn\n+    /// indices, and given the shallow binding structure we often use,\n+    /// would not be that useful.)\n+    pub fn no_late_bound_regions<'tcx>(self) -> Option<T>\n+        where T : TypeFoldable<'tcx>\n+    {\n+        if self.skip_binder().has_escaping_regions() {\n+            None\n+        } else {\n+            Some(self.skip_binder().clone())\n+        }\n+    }\n }\n \n /// Represents the projection of an associated type. In explicit UFCS"}, {"sha": "46193dedf8968055b62a2e7ac04b4929f5eb1e6c", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f33145ae91cbe095616c92ace63c93b61e5b4e9/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f33145ae91cbe095616c92ace63c93b61e5b4e9/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=1f33145ae91cbe095616c92ace63c93b61e5b4e9", "patch": "@@ -833,7 +833,7 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n     let tcx = infcx.tcx;\n     let gcx = tcx.global_tcx();\n     let def_id = tcx.hir.local_def_id(ctor_id);\n-    let sig = gcx.no_late_bound_regions(&gcx.fn_sig(def_id))\n+    let sig = gcx.fn_sig(def_id).no_late_bound_regions()\n         .expect(\"LBR in ADT constructor signature\");\n     let sig = gcx.erase_regions(&sig);\n     let param_env = gcx.param_env(def_id);"}, {"sha": "f8c45dd3d2570942843b6233ef0fccfa5b8a5636", "filename": "src/librustc_mir/transform/lower_128bit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f33145ae91cbe095616c92ace63c93b61e5b4e9/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f33145ae91cbe095616c92ace63c93b61e5b4e9/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs?ref=1f33145ae91cbe095616c92ace63c93b61e5b4e9", "patch": "@@ -144,7 +144,7 @@ fn check_lang_item_type<'a, 'tcx, D>(\n {\n     let did = tcx.require_lang_item(lang_item);\n     let poly_sig = tcx.fn_sig(did);\n-    let sig = tcx.no_late_bound_regions(&poly_sig).unwrap();\n+    let sig = poly_sig.no_late_bound_regions().unwrap();\n     let lhs_ty = lhs.ty(local_decls, tcx);\n     let rhs_ty = rhs.ty(local_decls, tcx);\n     let place_ty = place.ty(local_decls, tcx).to_ty(tcx);"}, {"sha": "d5e4aa69c5b4e54d1bc60d7fea73ccbc761558f4", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f33145ae91cbe095616c92ace63c93b61e5b4e9/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f33145ae91cbe095616c92ace63c93b61e5b4e9/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=1f33145ae91cbe095616c92ace63c93b61e5b4e9", "patch": "@@ -800,7 +800,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let pat_ty = self.instantiate_value_path(segments, opt_ty, def, pat.span, pat.id);\n         // Replace constructor type with constructed type for tuple struct patterns.\n         let pat_ty = pat_ty.fn_sig(tcx).output();\n-        let pat_ty = tcx.no_late_bound_regions(&pat_ty).expect(\"expected fn type\");\n+        let pat_ty = pat_ty.no_late_bound_regions().expect(\"expected fn type\");\n \n         self.demand_eqtype(pat.span, expected, pat_ty);\n "}, {"sha": "23243c3ad66c0e49422b242e732bdcb33e37132e", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f33145ae91cbe095616c92ace63c93b61e5b4e9/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f33145ae91cbe095616c92ace63c93b61e5b4e9/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=1f33145ae91cbe095616c92ace63c93b61e5b4e9", "patch": "@@ -389,7 +389,7 @@ pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     let mut structural_to_nomimal = FxHashMap();\n \n                     let sig = tcx.fn_sig(def_id);\n-                    let sig = tcx.no_late_bound_regions(&sig).unwrap();\n+                    let sig = sig.no_late_bound_regions().unwrap();\n                     if intr.inputs.len() != sig.inputs().len() {\n                         span_err!(tcx.sess, it.span, E0444,\n                                   \"platform-specific intrinsic has invalid number of \\"}, {"sha": "b754c981b2101ce8b96be5da95901e98df99b700", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f33145ae91cbe095616c92ace63c93b61e5b4e9/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f33145ae91cbe095616c92ace63c93b61e5b4e9/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=1f33145ae91cbe095616c92ace63c93b61e5b4e9", "patch": "@@ -202,7 +202,7 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n                                         poly_trait_ref: ty::PolyTraitRef<'tcx>)\n                                         -> Ty<'tcx>\n     {\n-        if let Some(trait_ref) = self.tcx().no_late_bound_regions(&poly_trait_ref) {\n+        if let Some(trait_ref) = poly_trait_ref.no_late_bound_regions() {\n             self.tcx().mk_projection(item_def_id, trait_ref.substs)\n         } else {\n             // no late-bound regions, we can just ignore the binder"}]}