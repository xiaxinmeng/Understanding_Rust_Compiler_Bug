{"sha": "f697a06da43374c94a20bbc9e60ed45c4bda6fd4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2OTdhMDZkYTQzMzc0Yzk0YTIwYmJjOWU2MGVkNDVjNGJkYTZmZDQ=", "commit": {"author": {"name": "Richo Healey", "email": "richo@psych0tik.net", "date": "2015-01-27T08:12:06Z"}, "committer": {"name": "Richo Healey", "email": "richo@psych0tik.net", "date": "2015-01-27T09:25:54Z"}, "message": "Fix PEP8 in lldb_batchmode.py", "tree": {"sha": "cfc25f92a610ef68db652f31c3a9c469945a3e3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfc25f92a610ef68db652f31c3a9c469945a3e3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f697a06da43374c94a20bbc9e60ed45c4bda6fd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f697a06da43374c94a20bbc9e60ed45c4bda6fd4", "html_url": "https://github.com/rust-lang/rust/commit/f697a06da43374c94a20bbc9e60ed45c4bda6fd4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f697a06da43374c94a20bbc9e60ed45c4bda6fd4/comments", "author": {"login": "richo", "id": 476418, "node_id": "MDQ6VXNlcjQ3NjQxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/476418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richo", "html_url": "https://github.com/richo", "followers_url": "https://api.github.com/users/richo/followers", "following_url": "https://api.github.com/users/richo/following{/other_user}", "gists_url": "https://api.github.com/users/richo/gists{/gist_id}", "starred_url": "https://api.github.com/users/richo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richo/subscriptions", "organizations_url": "https://api.github.com/users/richo/orgs", "repos_url": "https://api.github.com/users/richo/repos", "events_url": "https://api.github.com/users/richo/events{/privacy}", "received_events_url": "https://api.github.com/users/richo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richo", "id": 476418, "node_id": "MDQ6VXNlcjQ3NjQxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/476418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richo", "html_url": "https://github.com/richo", "followers_url": "https://api.github.com/users/richo/followers", "following_url": "https://api.github.com/users/richo/following{/other_user}", "gists_url": "https://api.github.com/users/richo/gists{/gist_id}", "starred_url": "https://api.github.com/users/richo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richo/subscriptions", "organizations_url": "https://api.github.com/users/richo/orgs", "repos_url": "https://api.github.com/users/richo/repos", "events_url": "https://api.github.com/users/richo/events{/privacy}", "received_events_url": "https://api.github.com/users/richo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "958dea1745b9000becaeed728f78daec3b9c13ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/958dea1745b9000becaeed728f78daec3b9c13ba", "html_url": "https://github.com/rust-lang/rust/commit/958dea1745b9000becaeed728f78daec3b9c13ba"}], "stats": {"total": 218, "additions": 112, "deletions": 106}, "files": [{"sha": "b1506285b3ac1a9e47fc44b7a794d11183fb9d50", "filename": "src/etc/lldb_batchmode.py", "status": "modified", "additions": 112, "deletions": 106, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/f697a06da43374c94a20bbc9e60ed45c4bda6fd4/src%2Fetc%2Flldb_batchmode.py", "raw_url": "https://github.com/rust-lang/rust/raw/f697a06da43374c94a20bbc9e60ed45c4bda6fd4/src%2Fetc%2Flldb_batchmode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_batchmode.py?ref=f697a06da43374c94a20bbc9e60ed45c4bda6fd4", "patch": "@@ -30,36 +30,35 @@\n import threading\n import thread\n import re\n-import atexit\n import time\n \n # Set this to True for additional output\n DEBUG_OUTPUT = False\n \n+\n def print_debug(s):\n-  \"Print something if DEBUG_OUTPUT is True\"\n-  global DEBUG_OUTPUT\n-  if DEBUG_OUTPUT:\n-    print(\"DEBUG: \" + str(s))\n+    \"Print something if DEBUG_OUTPUT is True\"\n+    global DEBUG_OUTPUT\n+    if DEBUG_OUTPUT:\n+        print(\"DEBUG: \" + str(s))\n \n \n def normalize_whitespace(s):\n-  \"Replace newlines, tabs, multiple spaces, etc with exactly one space\"\n-  return re.sub(\"\\s+\", \" \", s)\n+    \"Replace newlines, tabs, multiple spaces, etc with exactly one space\"\n+    return re.sub(\"\\s+\", \" \", s)\n \n \n-# This callback is registered with every breakpoint and makes sure that the frame containing the\n-# breakpoint location is selected\n def breakpoint_callback(frame, bp_loc, dict):\n-  \"Called whenever a breakpoint is hit\"\n-  print(\"Hit breakpoint \" + str(bp_loc))\n+    \"\"\"This callback is registered with every breakpoint and makes sure that the\n+    frame containing the breakpoint location is selected\"\"\"\n+    print(\"Hit breakpoint \" + str(bp_loc))\n \n-  # Select the frame and the thread containing it\n-  frame.thread.process.SetSelectedThread(frame.thread)\n-  frame.thread.SetSelectedFrame(frame.idx)\n+    # Select the frame and the thread containing it\n+    frame.thread.process.SetSelectedThread(frame.thread)\n+    frame.thread.SetSelectedFrame(frame.idx)\n \n-  # Returning True means that we actually want to stop at this breakpoint\n-  return True\n+    # Returning True means that we actually want to stop at this breakpoint\n+    return True\n \n \n # This is a list of breakpoints that are not registered with the breakpoint callback. The list is\n@@ -70,91 +69,99 @@ def breakpoint_callback(frame, bp_loc, dict):\n # used to avoid hooking callbacks into breakpoints more than once\n registered_breakpoints = set()\n \n+\n def execute_command(command_interpreter, command):\n-  \"Executes a single CLI command\"\n-  global new_breakpoints\n-  global registered_breakpoints\n-\n-  res = lldb.SBCommandReturnObject()\n-  print(command)\n-  command_interpreter.HandleCommand(command, res)\n-\n-  if res.Succeeded():\n-      if res.HasResult():\n-          print(normalize_whitespace(res.GetOutput()), end = '\\n')\n-\n-      # If the command introduced any breakpoints, make sure to register them with the breakpoint\n-      # callback\n-      while len(new_breakpoints) > 0:\n-        res.Clear()\n-        breakpoint_id = new_breakpoints.pop()\n-\n-        if breakpoint_id in registered_breakpoints:\n-          print_debug(\"breakpoint with id %s is already registered. Ignoring.\" % str(breakpoint_id))\n-        else:\n-          print_debug(\"registering breakpoint callback, id = \" + str(breakpoint_id))\n-          callback_command = \"breakpoint command add -F breakpoint_callback \" + str(breakpoint_id)\n-          command_interpreter.HandleCommand(callback_command, res)\n-          if res.Succeeded():\n-            print_debug(\"successfully registered breakpoint callback, id = \" + str(breakpoint_id))\n-            registered_breakpoints.add(breakpoint_id)\n-          else:\n-            print(\"Error while trying to register breakpoint callback, id = \" + str(breakpoint_id))\n-  else:\n-      print(res.GetError())\n+    \"Executes a single CLI command\"\n+    global new_breakpoints\n+    global registered_breakpoints\n+\n+    res = lldb.SBCommandReturnObject()\n+    print(command)\n+    command_interpreter.HandleCommand(command, res)\n+\n+    if res.Succeeded():\n+        if res.HasResult():\n+            print(normalize_whitespace(res.GetOutput()), end='\\n')\n+\n+        # If the command introduced any breakpoints, make sure to register\n+        # them with the breakpoint\n+        # callback\n+        while len(new_breakpoints) > 0:\n+            res.Clear()\n+            breakpoint_id = new_breakpoints.pop()\n+\n+            if breakpoint_id in registered_breakpoints:\n+                print_debug(\"breakpoint with id %s is already registered. Ignoring.\" %\n+                            str(breakpoint_id))\n+            else:\n+                print_debug(\"registering breakpoint callback, id = \" + str(breakpoint_id))\n+                callback_command = (\"breakpoint command add -F breakpoint_callback \" +\n+                                    str(breakpoint_id))\n+                command_interpreter.HandleCommand(callback_command, res)\n+                if res.Succeeded():\n+                    print_debug(\"successfully registered breakpoint callback, id = \" +\n+                                str(breakpoint_id))\n+                    registered_breakpoints.add(breakpoint_id)\n+                else:\n+                    print(\"Error while trying to register breakpoint callback, id = \" +\n+                          str(breakpoint_id))\n+    else:\n+        print(res.GetError())\n \n \n def start_breakpoint_listener(target):\n-  \"Listens for breakpoints being added and adds new ones to the callback registration list\"\n-  listener = lldb.SBListener(\"breakpoint listener\")\n-\n-  def listen():\n-    event = lldb.SBEvent()\n-    try:\n-      while True:\n-        if listener.WaitForEvent(120, event):\n-          if lldb.SBBreakpoint.EventIsBreakpointEvent(event) and \\\n-             lldb.SBBreakpoint.GetBreakpointEventTypeFromEvent(event) == \\\n-             lldb.eBreakpointEventTypeAdded:\n-            global new_breakpoints\n-            breakpoint = lldb.SBBreakpoint.GetBreakpointFromEvent(event)\n-            print_debug(\"breakpoint added, id = \" + str(breakpoint.id))\n-            new_breakpoints.append(breakpoint.id)\n-    except:\n-      print_debug(\"breakpoint listener shutting down\")\n-\n-  # Start the listener and let it run as a daemon\n-  listener_thread = threading.Thread(target = listen)\n-  listener_thread.daemon = True\n-  listener_thread.start()\n-\n-  # Register the listener with the target\n-  target.GetBroadcaster().AddListener(listener, lldb.SBTarget.eBroadcastBitBreakpointChanged)\n+    \"\"\"Listens for breakpoints being added and adds new ones to the callback\n+    registration list\"\"\"\n+    listener = lldb.SBListener(\"breakpoint listener\")\n+\n+    def listen():\n+        event = lldb.SBEvent()\n+        try:\n+            while True:\n+                if listener.WaitForEvent(120, event):\n+                    if lldb.SBBreakpoint.EventIsBreakpointEvent(event) and \\\n+                            lldb.SBBreakpoint.GetBreakpointEventTypeFromEvent(event) == \\\n+                            lldb.eBreakpointEventTypeAdded:\n+                        global new_breakpoints\n+                        breakpoint = lldb.SBBreakpoint.GetBreakpointFromEvent(event)\n+                        print_debug(\"breakpoint added, id = \" + str(breakpoint.id))\n+                        new_breakpoints.append(breakpoint.id)\n+        except:\n+            print_debug(\"breakpoint listener shutting down\")\n+\n+    # Start the listener and let it run as a daemon\n+    listener_thread = threading.Thread(target=listen)\n+    listener_thread.daemon = True\n+    listener_thread.start()\n+\n+    # Register the listener with the target\n+    target.GetBroadcaster().AddListener(listener, lldb.SBTarget.eBroadcastBitBreakpointChanged)\n \n \n def start_watchdog():\n-  \"Starts a watchdog thread that will terminate the process after a certain period of time\"\n-  watchdog_start_time = time.clock()\n-  watchdog_max_time = watchdog_start_time + 30\n-\n-  def watchdog():\n-    while time.clock() < watchdog_max_time:\n-      time.sleep(1)\n-    print(\"TIMEOUT: lldb_batchmode.py has been running for too long. Aborting!\")\n-    thread.interrupt_main()\n-\n-  # Start the listener and let it run as a daemon\n-  watchdog_thread = threading.Thread(target = watchdog)\n-  watchdog_thread.daemon = True\n-  watchdog_thread.start()\n+    \"\"\"Starts a watchdog thread that will terminate the process after a certain\n+    period of time\"\"\"\n+    watchdog_start_time = time.clock()\n+    watchdog_max_time = watchdog_start_time + 30\n+\n+    def watchdog():\n+        while time.clock() < watchdog_max_time:\n+            time.sleep(1)\n+        print(\"TIMEOUT: lldb_batchmode.py has been running for too long. Aborting!\")\n+        thread.interrupt_main()\n+\n+    # Start the listener and let it run as a daemon\n+    watchdog_thread = threading.Thread(target=watchdog)\n+    watchdog_thread.daemon = True\n+    watchdog_thread.start()\n \n ####################################################################################################\n # ~main\n ####################################################################################################\n \n if len(sys.argv) != 3:\n-  print(\"usage: python lldb_batchmode.py target-path script-path\")\n-  sys.exit(1)\n+    print(\"usage: python lldb_batchmode.py target-path script-path\")\n+    sys.exit(1)\n \n target_path = sys.argv[1]\n script_path = sys.argv[2]\n@@ -181,9 +188,9 @@ def watchdog():\n target = debugger.CreateTarget(target_path, None, None, True, target_error)\n \n if not target:\n-  print(\"Could not create debugging target '\" + target_path + \"': \" + str(target_error) +\n-        \". Aborting.\", file=sys.stderr)\n-  sys.exit(1)\n+    print(\"Could not create debugging target '\" + target_path + \"': \" +\n+          str(target_error) + \". Aborting.\", file=sys.stderr)\n+    sys.exit(1)\n \n \n # Register the breakpoint callback for every breakpoint\n@@ -192,22 +199,21 @@ def watchdog():\n command_interpreter = debugger.GetCommandInterpreter()\n \n try:\n-  script_file = open(script_path, 'r')\n+    script_file = open(script_path, 'r')\n \n-  for line in script_file:\n-    command = line.strip()\n-    if command == \"run\" or command == \"r\" or re.match(\"^process\\s+launch.*\", command):\n-      # Before starting to run the program, let the thread sleep a bit, so all\n-      # breakpoint added events can be processed\n-      time.sleep(0.5)\n-    if command != '':\n-      execute_command(command_interpreter, command)\n+    for line in script_file:\n+        command = line.strip()\n+        if command == \"run\" or command == \"r\" or re.match(\"^process\\s+launch.*\", command):\n+            # Before starting to run the program, let the thread sleep a bit, so all\n+            # breakpoint added events can be processed\n+            time.sleep(0.5)\n+        if command != '':\n+            execute_command(command_interpreter, command)\n \n except IOError as e:\n-  print(\"Could not read debugging script '%s'.\" % script_path, file = sys.stderr)\n-  print(e, file = sys.stderr)\n-  print(\"Aborting.\", file = sys.stderr)\n-  sys.exit(1)\n+    print(\"Could not read debugging script '%s'.\" % script_path, file=sys.stderr)\n+    print(e, file=sys.stderr)\n+    print(\"Aborting.\", file=sys.stderr)\n+    sys.exit(1)\n finally:\n-  script_file.close()\n-\n+    script_file.close()"}]}