{"sha": "b3d50fc2c015cc8a335855b82ab458a15a7413d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzZDUwZmMyYzAxNWNjOGEzMzU4NTViODJhYjQ1OGExNWE3NDEzZDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-07T23:10:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-07T23:10:58Z"}, "message": "auto merge of #9015 : MicahChalmer/rust/emacs-fixes-round-2, r=nikomatsakis\n\nHere are fixes for more problems mentioned in #8787.  I think I've addressed everything mentioned there except for @nikomatsakis's comment about match/patterns now.  (This also fixes the bug in struct alignment that @pnkfelix mentioned from my earlier pull request #8872.)\r\n\r\nThe biggest change here is to make fill-paragraph (M-q) and auto-fill-mode work inside different variations of multi-line and doc comments.  Because of the way emacs paragraph fills work (callbacks interacting with global regexp variables that are used in odd ways) there were quite a few edge cases that I had to work around.\r\n\r\nThe only way I was able to keep it all straight was to create some regression tests.  They use the emacs lisp regression testing tool ERT, and are included as the last commit here.  I added a few tests for indentation as well.  I have not attempted to integrate the tests into the overall rust compiler build process, since I can't imagine anyone would want the compiler build to have a dependency on emacs.  Maybe at some point tools like this get their own repositories?  Just a thought.\r\n\r\nOne other thought related to the tests: should there be a place to put these types of style samples that isn't specific to one text editor?  Maybe as part of an official rust style guide, but in a form that would allow tools like this to pull out the samples and use them for tests?", "tree": {"sha": "f4a2322fbc592c46dbf7b3d30be115774014e6b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4a2322fbc592c46dbf7b3d30be115774014e6b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3d50fc2c015cc8a335855b82ab458a15a7413d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3d50fc2c015cc8a335855b82ab458a15a7413d9", "html_url": "https://github.com/rust-lang/rust/commit/b3d50fc2c015cc8a335855b82ab458a15a7413d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3d50fc2c015cc8a335855b82ab458a15a7413d9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6b36c676e6b31313a8fd2b31e804bd3d6a4af73", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6b36c676e6b31313a8fd2b31e804bd3d6a4af73", "html_url": "https://github.com/rust-lang/rust/commit/f6b36c676e6b31313a8fd2b31e804bd3d6a4af73"}, {"sha": "a4697342f70bad619eae49d42c41743a67513be3", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4697342f70bad619eae49d42c41743a67513be3", "html_url": "https://github.com/rust-lang/rust/commit/a4697342f70bad619eae49d42c41743a67513be3"}], "stats": {"total": 603, "additions": 568, "deletions": 35}, "files": [{"sha": "63fbe1f681cb2deec059b41da34725823c533604", "filename": "src/etc/emacs/README.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3d50fc2c015cc8a335855b82ab458a15a7413d9/src%2Fetc%2Femacs%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3d50fc2c015cc8a335855b82ab458a15a7413d9/src%2Fetc%2Femacs%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2FREADME.md?ref=b3d50fc2c015cc8a335855b82ab458a15a7413d9", "patch": "@@ -68,6 +68,12 @@ marking, press x, and ELPA will install the packages for you (under\n \n * or using <kbd>M-x package-install rust-mode\n \n+### Tests via ERT\n+\n+The file `rust-mode-tests.el` contains tests that can be run via ERT.  You can\n+use `run_rust_emacs_tests.sh` to run them in batch mode, if emacs is somewhere\n+in your `$PATH`.\n+\n ### Known bugs\n \n * Combining `global-whitespace-mode` and `rust-mode` is generally glitchy."}, {"sha": "afb98fde7b047282d80a8c3f679bf323bd809f66", "filename": "src/etc/emacs/run_rust_emacs_tests.sh", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3d50fc2c015cc8a335855b82ab458a15a7413d9/src%2Fetc%2Femacs%2Frun_rust_emacs_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/b3d50fc2c015cc8a335855b82ab458a15a7413d9/src%2Fetc%2Femacs%2Frun_rust_emacs_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frun_rust_emacs_tests.sh?ref=b3d50fc2c015cc8a335855b82ab458a15a7413d9", "patch": "@@ -0,0 +1,3 @@\n+# This runs the test for emacs rust-mode.\n+# It must be possible to find emacs via PATH.\n+emacs -batch -l rust-mode.el -l rust-mode-tests.el -f ert-run-tests-batch-and-exit"}, {"sha": "4bfdee50c6b968d93d8886fde40c3a26780953a8", "filename": "src/etc/emacs/rust-mode-tests.el", "status": "added", "additions": 397, "deletions": 0, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/b3d50fc2c015cc8a335855b82ab458a15a7413d9/src%2Fetc%2Femacs%2Frust-mode-tests.el", "raw_url": "https://github.com/rust-lang/rust/raw/b3d50fc2c015cc8a335855b82ab458a15a7413d9/src%2Fetc%2Femacs%2Frust-mode-tests.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode-tests.el?ref=b3d50fc2c015cc8a335855b82ab458a15a7413d9", "patch": "@@ -0,0 +1,397 @@\n+;;; rust-mode-tests.el --- ERT tests for rust-mode.el\n+\n+(require 'rust-mode)\n+(require 'ert)\n+(require 'cl)\n+\n+(setq rust-test-fill-column 32)\n+\n+(defun rust-compare-code-after-manip (original point-pos manip-func expected got)\n+  (equal expected got))\n+\n+(defun rust-test-explain-bad-manip (original point-pos manip-func expected got)\n+  (if (equal expected got)\n+      nil\n+    (list \n+     ;; The (goto-char) and (insert) business here is just for\n+     ;; convenience--after an error, you can copy-paste that into emacs eval to\n+     ;; insert the bare strings into a buffer\n+     \"Rust code was manipulated wrong after:\"\n+     `(insert ,original)\n+     `(goto-char ,point-pos)\n+     'expected `(insert ,expected)\n+     'got `(insert ,got)\n+     (loop for i from 0 to (max (length original) (length expected))\n+           for oi = (if (< i (length got)) (elt got i))\n+           for ei = (if (< i (length expected)) (elt expected i))\n+           while (equal oi ei)\n+           finally return `(first-difference-at\n+                            (goto-char ,(+ 1 i))\n+                            expected ,(char-to-string ei)\n+                            got ,(char-to-string oi))))))\n+(put 'rust-compare-code-after-manip 'ert-explainer\n+     'rust-test-explain-bad-manip)\n+\n+(defun rust-test-manip-code (original point-pos manip-func expected)\n+  (with-temp-buffer\n+    (rust-mode)\n+    (insert original)\n+    (goto-char point-pos)\n+    (funcall manip-func)\n+    (should (rust-compare-code-after-manip\n+             original point-pos manip-func expected (buffer-string)))))\n+\n+(defun test-fill-paragraph (unfilled expected &optional start-pos end-pos)\n+  \"We're going to run through many scenarios here--the point should be able to be anywhere from the start-pos (defaults to 1) through end-pos (defaults to the length of what was passed in) and (fill-paragraph) should return the same result.\n+\n+Also, the result should be the same regardless of whether the code is at the beginning or end of the file.  (If you're not careful, that can make a difference.)  So we test each position given above with the passed code at the beginning, the end, neither and both.  So we do this a total of (end-pos - start-pos)*4 times.  Oy.\"\n+  (let* ((start-pos (or start-pos 1))\n+         (end-pos (or end-pos (length unfilled)))\n+         (padding \"\\n     \\n\")\n+         (padding-len (length padding)))\n+    (loop\n+     for pad-at-beginning from 0 to 1\n+     do (loop for pad-at-end from 0 to 1\n+           with padding-beginning = (if (= 0 pad-at-beginning) \"\" padding)\n+           with padding-end = (if (= 0 pad-at-end) \"\" padding)\n+           with padding-adjust = (* padding-len pad-at-beginning)\n+           with padding-beginning = (if (= 0 pad-at-beginning) \"\" padding)\n+           with padding-end = (if (= 0 pad-at-end) \"\" padding)\n+           ;; If we're adding space to the beginning, and our start position\n+           ;; is at the very beginning, we want to test within the added space.\n+           ;; Otherwise adjust the start and end for the beginning padding.\n+           with start-pos = (if (= 1 start-pos) 1 (+ padding-adjust start-pos))\n+           with end-pos = (+ end-pos padding-adjust)\n+           do (loop for pos from start-pos to end-pos\n+                 do (rust-test-manip-code\n+                     (concat padding-beginning unfilled padding-end)\n+                     pos\n+                     (lambda () \n+                       (let ((fill-column rust-test-fill-column))\n+                         (fill-paragraph)))\n+                     (concat padding-beginning expected padding-end)))))))\n+\n+(ert-deftest fill-paragraph-top-level-multi-line-style-doc-comment-second-line ()\n+  (test-fill-paragraph \n+   \"/**\n+ * This is a very very very very very very very long string\n+ */\"\n+   \"/**\n+ * This is a very very very very\n+ * very very very long string\n+ */\"))\n+\n+\n+(ert-deftest fill-paragraph-top-level-multi-line-style-doc-comment-first-line ()\n+  (test-fill-paragraph\n+   \"/** This is a very very very very very very very long string\n+ */\"\n+   \"/** This is a very very very\n+ * very very very very long\n+ * string\n+ */\"))\n+\n+(ert-deftest fill-paragraph-multi-paragraph-multi-line-style-doc-comment ()\n+  (let\n+      ((multi-paragraph-unfilled\n+        \"/**\n+ * This is the first really really really really really really really long paragraph\n+ *\n+ * This is the second really really really really really really long paragraph\n+ */\"))\n+    (test-fill-paragraph\n+     multi-paragraph-unfilled\n+     \"/**\n+ * This is the first really\n+ * really really really really\n+ * really really long paragraph\n+ *\n+ * This is the second really really really really really really long paragraph\n+ */\"\n+     1 89)\n+    (test-fill-paragraph\n+     multi-paragraph-unfilled\n+     \"/**\n+ * This is the first really really really really really really really long paragraph\n+ *\n+ * This is the second really\n+ * really really really really\n+ * really long paragraph\n+ */\"\n+     90)))\n+\n+(ert-deftest fill-paragraph-multi-paragraph-single-line-style-doc-comment ()\n+  (let\n+      ((multi-paragraph-unfilled\n+        \"/// This is the first really really really really really really really long paragraph\n+///\n+/// This is the second really really really really really really long paragraph\"))\n+    (test-fill-paragraph\n+     multi-paragraph-unfilled\n+     \"/// This is the first really\n+/// really really really really\n+/// really really long paragraph\n+///\n+/// This is the second really really really really really really long paragraph\"\n+     1 86)\n+    (test-fill-paragraph\n+     multi-paragraph-unfilled\n+     \"/// This is the first really really really really really really really long paragraph\n+///\n+/// This is the second really\n+/// really really really really\n+/// really long paragraph\"\n+     87)))\n+\n+(ert-deftest fill-paragraph-multi-paragraph-single-line-style-indented ()\n+  (test-fill-paragraph\n+   \"     // This is the first really really really really really really really long paragraph\n+     //\n+     // This is the second really really really really really really long paragraph\"\n+   \"     // This is the first really\n+     // really really really\n+     // really really really\n+     // long paragraph\n+     //\n+     // This is the second really really really really really really long paragraph\" 1 89))\n+\n+(ert-deftest fill-paragraph-multi-line-style-inner-doc-comment ()\n+  (test-fill-paragraph\n+   \"/*! This is a very very very very very very very long string\n+ */\"\n+   \"/*! This is a very very very\n+ * very very very very long\n+ * string\n+ */\"))\n+\n+(ert-deftest fill-paragraph-single-line-style-inner-doc-comment ()\n+  (test-fill-paragraph\n+   \"//! This is a very very very very very very very long string\"\n+   \"//! This is a very very very\n+//! very very very very long\n+//! string\"))\n+\n+(ert-deftest fill-paragraph-prefixless-multi-line-doc-comment ()\n+  (test-fill-paragraph\n+   \"/**\n+This is my summary. Blah blah blah blah blah. Dilly dally dilly dally dilly dally doo.\n+\n+This is some more text.  Fee fie fo fum.  Humpty dumpty sat on a wall.\n+*/\"\n+   \"/**\n+This is my summary. Blah blah\n+blah blah blah. Dilly dally\n+dilly dally dilly dally doo.\n+\n+This is some more text.  Fee fie fo fum.  Humpty dumpty sat on a wall.\n+*/\" 4 90))\n+\n+(ert-deftest fill-paragraph-with-no-space-after-star-prefix ()\n+  (test-fill-paragraph\n+   \"/** \n+ *This is a very very very very very very very long string\n+ */\"\n+   \"/** \n+ *This is a very very very very\n+ *very very very long string\n+ */\"))\n+\n+(defun test-auto-fill (initial position inserted expected)\n+  (rust-test-manip-code \n+   initial\n+   position\n+   (lambda ()\n+     (unwind-protect\n+         (progn\n+           (let ((fill-column rust-test-fill-column))\n+             (auto-fill-mode)\n+             (goto-char position)\n+             (insert inserted)\n+             (syntax-ppss-flush-cache 1)\n+             (funcall auto-fill-function)))\n+       (auto-fill-mode t)))\n+   expected))\n+\n+(ert-deftest auto-fill-multi-line-doc-comment ()\n+  (test-auto-fill\n+   \"/**\n+ * \n+ */\"\n+   8\n+   \"This is a very very very very very very very long string\"\n+   \"/**\n+ * This is a very very very very\n+ * very very very long string\n+ */\"))\n+\n+(ert-deftest auto-fill-single-line-doc-comment ()\n+  (test-auto-fill\n+   \"/// This is the first really\n+/// really really really really\n+/// really really long paragraph\n+///\n+/// \"\n+   103\n+   \"This is the second really really really really really really long paragraph\"\n+    \"/// This is the first really\n+/// really really really really\n+/// really really long paragraph\n+///\n+/// This is the second really\n+/// really really really really\n+/// really long paragraph\"\n+    ))\n+\n+(ert-deftest auto-fill-multi-line-prefixless ()\n+  (test-auto-fill\n+   \"/*\n+\n+ */\"\n+   4\n+   \"This is a very very very very very very very long string\"\n+   \"/*\n+This is a very very very very\n+very very very long string\n+ */\"\n+   ))\n+\n+(defun test-indent (indented)\n+  (let ((deindented (replace-regexp-in-string \"^[[:blank:]]*\" \"      \" indented)))\n+    (rust-test-manip-code\n+     deindented\n+     1\n+     (lambda () (indent-region 1 (buffer-size)))\n+     indented)))\n+\n+\n+(ert-deftest indent-struct-fields-aligned ()\n+  (test-indent\n+\"\n+struct Foo { bar: int,\n+             baz: int }\n+\n+struct Blah {x:int,\n+             y:int,\n+             z:~str}\"))\n+\n+(ert-deftest indent-doc-comments ()\n+  (test-indent\n+\"\n+/**\n+ * This is a doc comment\n+ *\n+ */\n+\n+/// So is this\n+\n+fn foo() {\n+    /*!\n+     * this is a nested doc comment\n+     */\n+    \n+    //! And so is this\n+}\"))\n+\n+(ert-deftest indent-inside-braces ()\n+  (test-indent\n+   \"\n+// struct fields out one level:\n+struct foo {\n+    a:int,\n+    // comments too\n+    b:char\n+}\n+\n+fn bar(x:~int) {   // comment here should not affect the next indent\n+    bla();\n+    bla();\n+}\"))\n+\n+(ert-deftest indent-top-level ()\n+  (test-indent\n+   \"\n+// Everything here is at the top level and should not be indented\n+#[attrib]\n+mod foo;\n+\n+pub static bar = Quux{a: b()}\n+\n+use foo::bar::baz;\n+\n+fn foo() { }\n+\"))\n+\n+(ert-deftest indent-params-no-align ()\n+  (test-indent\n+   \"\n+// Indent out one level because no params appear on the first line\n+fn xyzzy(\n+    a:int,\n+    b:char) { }\n+\n+fn abcdef(\n+    a:int,\n+    b:char)\n+    -> char\n+{ }\"))\n+\n+(ert-deftest indent-params-align ()\n+  (test-indent\n+   \"\n+// Align the second line of params to the first\n+fn foo(a:int,\n+       b:char) { }\n+\n+fn bar(   a:int,\n+          b:char)\n+          -> int\n+{ }\n+\n+fn baz(   a:int,  // shoudl work with a comment here\n+          b:char)\n+          -> int\n+{ }\n+\"))\n+\n+(ert-deftest indent-square-bracket-alignment ()\n+  (test-indent\n+   \"\n+fn args_on_the_next_line( // with a comment\n+    a:int,\n+    b:~str) {\n+    let aaaaaa = [\n+        1,\n+        2,\n+        3];\n+    let bbbbbbb = [1, 2, 3,\n+                   4, 5, 6];\n+    let ccc = [   10, 9, 8,\n+                  7, 6, 5];\n+}\n+\"))\n+\n+(ert-deftest indent-nested-fns ()\n+  (test-indent\n+   \"\n+fn nexted_fns(a: fn(b:int,\n+                    c:char)\n+                    -> int,\n+              d: int)\n+              -> uint\n+{\n+    0\n+}\n+\"\n+))\n+\n+(ert-deftest indent-multi-line-expr ()\n+  (test-indent\n+   \"\n+fn foo()\n+{\n+    x();\n+    let a =\n+        b();\n+}\n+\"\n+))"}, {"sha": "a61d916f46fa76bfb2c269bf0a479b02cef3696b", "filename": "src/etc/emacs/rust-mode.el", "status": "modified", "additions": 162, "deletions": 35, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/b3d50fc2c015cc8a335855b82ab458a15a7413d9/src%2Fetc%2Femacs%2Frust-mode.el", "raw_url": "https://github.com/rust-lang/rust/raw/b3d50fc2c015cc8a335855b82ab458a15a7413d9/src%2Fetc%2Femacs%2Frust-mode.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode.el?ref=b3d50fc2c015cc8a335855b82ab458a15a7413d9", "patch": "@@ -30,8 +30,11 @@\n \n     table))\n \n+(defgroup rust-mode nil \"Support for Rust code.\")\n+\n (defcustom rust-indent-offset 4\n-  \"*Indent Rust code by this number of spaces.\")\n+  \"*Indent Rust code by this number of spaces.\"\n+  :group 'rust-mode)\n \n (defun rust-paren-level () (nth 0 (syntax-ppss)))\n (defun rust-in-str-or-cmnt () (nth 8 (syntax-ppss)))\n@@ -45,20 +48,33 @@\n     (if (/= starting (point))\n         (rust-rewind-irrelevant))))\n \n+(defun rust-align-to-expr-after-brace ()\n+  (save-excursion\n+    (forward-char)\n+    ;; We don't want to indent out to the open bracket if the\n+    ;; open bracket ends the line\n+    (when (not (looking-at \"[[:blank:]]*\\\\(?://.*\\\\)?$\"))\n+      (when (looking-at \"[[:space:]]\") (forward-to-word 1))\n+      (current-column))))\n+\n (defun rust-mode-indent-line ()\n   (interactive)\n   (let ((indent\n          (save-excursion\n            (back-to-indentation)\n            (let ((level (rust-paren-level)))\n              (cond\n-              ;; A function return type is 1 level indented\n-              ((looking-at \"->\") (* rust-indent-offset (+ level 1)))\n+              ;; A function return type is indented to the corresponding function arguments\n+              ((looking-at \"->\")\n+               (save-excursion\n+                 (backward-list)\n+                 (or (rust-align-to-expr-after-brace)\n+                     (* rust-indent-offset (+ 1 level)))))\n \n               ;; A closing brace is 1 level unindended\n               ((looking-at \"}\") (* rust-indent-offset (- level 1)))\n \n-              ; Doc comments in /** style with leading * indent to line up the *s\n+              ;; Doc comments in /** style with leading * indent to line up the *s\n               ((and (nth 4 (syntax-ppss)) (looking-at \"*\"))\n                (+ 1 (* rust-indent-offset level)))\n \n@@ -75,37 +91,25 @@\n                (let ((pt (point)))\n                  (rust-rewind-irrelevant)\n                  (backward-up-list)\n-                 (cond \n-                  ((and\n-                      (looking-at \"[[(]\")\n-                      ; We don't want to indent out to the open bracket if the\n-                      ; open bracket ends the line\n-                      (save-excursion \n-                        (forward-char)\n-                        (not (looking-at \"[[:space:]]*\\\\(?://.*\\\\)?$\"))))\n-                   (+ 1 (current-column)))\n-                  ;; Check for fields on the same line as the open curly brace:\n-                  ((looking-at \"{[[:blank:]]*[^}\\n]*,[[:space:]]*$\")\n-                   (progn\n-                    (forward-char)\n-                    (forward-to-word 1)\n-                    (current-column)))\n-                  (t (progn\n-                     (goto-char pt)\n-                     (back-to-indentation)\n-                     (if (looking-at \"\\\\<else\\\\>\")\n-                         (* rust-indent-offset (+ 1 level))\n-                       (progn\n-                         (goto-char pt)\n-                         (beginning-of-line)\n-                         (rust-rewind-irrelevant)\n-                         (end-of-line)\n-                         (if (looking-back \"[,;{}(][[:space:]]*\\\\(?://.*\\\\)?\")\n-                             (* rust-indent-offset level)\n-                           (back-to-indentation)\n-                           (if (looking-at \"#\")\n+                 (or (and (looking-at \"[[({]\")\n+                          (rust-align-to-expr-after-brace))\n+                     (progn\n+                       (goto-char pt)\n+                       (back-to-indentation)\n+                       (if (looking-at \"\\\\<else\\\\>\")\n+                           (* rust-indent-offset (+ 1 level))\n+                         (progn\n+                           (goto-char pt)\n+                           (beginning-of-line)\n+                           (rust-rewind-irrelevant)\n+                           (end-of-line)\n+                           (if (looking-back\n+                                \"[[,;{}(][[:space:]]*\\\\(?://.*\\\\)?\")\n                                (* rust-indent-offset level)\n-                             (* rust-indent-offset (+ 1 level)))))))))))\n+                             (back-to-indentation)\n+                             (if (looking-at \"#\")\n+                                 (* rust-indent-offset level)\n+                               (* rust-indent-offset (+ 1 level))))))))))\n \n               ;; Otherwise we're in a column-zero definition\n               (t 0))))))\n@@ -206,6 +210,114 @@\n \n          collect `(,(rust-re-item-def item) 1 ,face))))\n \n+(defun rust-fill-prefix-for-comment-start (line-start)\n+  \"Determine what to use for `fill-prefix' based on what is at the beginning of a line.\"\n+  (let ((result \n+         ;; Replace /* with same number of spaces\n+         (replace-regexp-in-string\n+          \"\\\\(?:/\\\\*+\\\\)[!*]\" \n+          (lambda (s)\n+            ;; We want the * to line up with the first * of the comment start\n+            (concat (make-string (- (length s) 2) ?\\x20) \"*\"))\n+          line-start)))\n+       ;; Make sure we've got at least one space at the end\n+    (if (not (= (aref result (- (length result) 1)) ?\\x20))\n+        (setq result (concat result \" \")))\n+    result))\n+\n+(defun rust-in-comment-paragraph (body)\n+  ;; We might move the point to fill the next comment, but we don't want it\n+  ;; seeming to jump around on the user\n+  (save-excursion\n+    ;; If we're outside of a comment, with only whitespace and then a comment\n+    ;; in front, jump to the comment and prepare to fill it.\n+    (when (not (nth 4 (syntax-ppss)))\n+      (beginning-of-line)\n+      (when (looking-at (concat \"[[:space:]\\n]*\" comment-start-skip))\n+        (goto-char (match-end 0))))\n+\n+    ;; We need this when we're moving the point around and then checking syntax\n+    ;; while doing paragraph fills, because the cache it uses isn't always\n+    ;; invalidated during this.\n+    (syntax-ppss-flush-cache 1)\n+    ;; If we're at the beginning of a comment paragraph with nothing but\n+    ;; whitespace til the next line, jump to the next line so that we use the\n+    ;; existing prefix to figure out what the new prefix should be, rather than\n+    ;; inferring it from the comment start.\n+    (let ((next-bol (line-beginning-position 2)))\n+      (while (save-excursion\n+              (end-of-line)\n+              (syntax-ppss-flush-cache 1)\n+              (and (nth 4 (syntax-ppss))\n+                   (save-excursion \n+                     (beginning-of-line)\n+                     (looking-at paragraph-start))\n+                   (looking-at \"[[:space:]]*$\")\n+                   (nth 4 (syntax-ppss next-bol))))\n+        (goto-char next-bol)))\n+\n+    (syntax-ppss-flush-cache 1)\n+    ;; If we're on the last line of a multiline-style comment that started\n+    ;; above, back up one line so we don't mistake the * of the */ that ends\n+    ;; the comment for a prefix.\n+    (when (save-excursion\n+            (and (nth 4 (syntax-ppss (line-beginning-position 1)))\n+                 (looking-at \"[[:space:]]*\\\\*/\")))\n+      (goto-char (line-end-position 0)))\n+    (funcall body)))\n+\n+(defun rust-with-comment-fill-prefix (body)\n+  (let*\n+      ((line-string (buffer-substring-no-properties \n+                     (line-beginning-position) (line-end-position)))\n+       (line-comment-start\n+        (when (nth 4 (syntax-ppss)) \n+          (cond\n+           ;; If we're inside the comment and see a * prefix, use it\n+           ((string-match \"^\\\\([[:space:]]*\\\\*+[[:space:]]*\\\\)\"\n+                          line-string)\n+            (match-string 1 line-string))\n+           ;; If we're at the start of a comment, figure out what prefix\n+           ;; to use for the subsequent lines after it\n+           ((string-match (concat \"[[:space:]]*\" comment-start-skip) line-string)\n+            (rust-fill-prefix-for-comment-start \n+             (match-string 0 line-string))))))\n+       (fill-prefix \n+        (or line-comment-start\n+            fill-prefix)))\n+    (funcall body)))\n+\n+(defun rust-find-fill-prefix ()\n+  (rust-with-comment-fill-prefix (lambda () fill-prefix)))\n+\n+(defun rust-fill-paragraph (&rest args)\n+  \"Special wrapping for `fill-paragraph' to handle multi-line comments with a * prefix on each line.\"\n+  (rust-in-comment-paragraph\n+   (lambda () \n+     (rust-with-comment-fill-prefix\n+      (lambda ()\n+        (let\n+            ((fill-paragraph-function\n+              (if (not (eq fill-paragraph-function 'rust-fill-paragraph))\n+                  fill-paragraph-function)))\n+          (apply 'fill-paragraph args)\n+          t))))))\n+\n+(defun rust-do-auto-fill (&rest args)\n+  \"Special wrapping for `do-auto-fill' to handle multi-line comments with a * prefix on each line.\"\n+  (rust-with-comment-fill-prefix\n+   (lambda ()\n+     (apply 'do-auto-fill args)\n+     t)))\n+\n+(defun rust-fill-forward-paragraph (arg)\n+  ;; This is to work around some funny behavior when a paragraph separator is\n+  ;; at the very top of the file and there is a fill prefix.\n+  (let ((fill-prefix nil)) (forward-paragraph arg)))\n+\n+(defun rust-comment-indent-new-line (&optional arg)\n+  (rust-with-comment-fill-prefix\n+   (lambda () (comment-indent-new-line arg))))\n \n ;; For compatibility with Emacs < 24, derive conditionally\n (defalias 'rust-parent-mode\n@@ -215,6 +327,7 @@\n ;;;###autoload\n (define-derived-mode rust-mode rust-parent-mode \"Rust\"\n   \"Major mode for Rust code.\"\n+  :group 'rust-mode\n \n   ;; Basic syntax\n   (set-syntax-table rust-mode-syntax-table)\n@@ -230,7 +343,21 @@\n   ;; Misc\n   (set (make-local-variable 'comment-start) \"// \")\n   (set (make-local-variable 'comment-end)   \"\")\n-  (set (make-local-variable 'indent-tabs-mode) nil))\n+  (set (make-local-variable 'indent-tabs-mode) nil)\n+\n+  ;; Allow paragraph fills for comments\n+  (set (make-local-variable 'comment-start-skip) \n+       \"\\\\(?://[/!]*\\\\|/\\\\*[*!]?\\\\)[[:space:]]*\")\n+  (set (make-local-variable 'paragraph-start)\n+       (concat \"[[:space:]]*\\\\(?:\" comment-start-skip \"\\\\|\\\\*/?[[:space:]]*\\\\|\\\\)$\"))\n+  (set (make-local-variable 'paragraph-separate) paragraph-start)\n+  (set (make-local-variable 'normal-auto-fill-function) 'rust-do-auto-fill)\n+  (set (make-local-variable 'fill-paragraph-function) 'rust-fill-paragraph)\n+  (set (make-local-variable 'fill-forward-paragraph-function) 'rust-fill-forward-paragraph)\n+  (set (make-local-variable 'adaptive-fill-function) 'rust-find-fill-prefix)\n+  (set (make-local-variable 'comment-multi-line) t)\n+  (set (make-local-variable 'comment-line-break-function) 'rust-comment-indent-new-line)\n+  )\n \n \n ;;;###autoload"}]}