{"sha": "c96cd359f532bb37865ef91d0935655a0af7e7f4", "node_id": "C_kwDOAAsO6NoAKGM5NmNkMzU5ZjUzMmJiMzc4NjVlZjkxZDA5MzU2NTVhMGFmN2U3ZjQ", "commit": {"author": {"name": "Serial", "email": "69764315+Serial-ATA@users.noreply.github.com", "date": "2021-10-29T01:39:41Z"}, "committer": {"name": "Serial", "email": "squared@disroot.org", "date": "2021-11-06T07:08:14Z"}, "message": "Extend author lint", "tree": {"sha": "afb337670483ce79c080f0cb1cc43ad9e0838719", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afb337670483ce79c080f0cb1cc43ad9e0838719"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c96cd359f532bb37865ef91d0935655a0af7e7f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c96cd359f532bb37865ef91d0935655a0af7e7f4", "html_url": "https://github.com/rust-lang/rust/commit/c96cd359f532bb37865ef91d0935655a0af7e7f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c96cd359f532bb37865ef91d0935655a0af7e7f4/comments", "author": {"login": "Serial-ATA", "id": 69764315, "node_id": "MDQ6VXNlcjY5NzY0MzE1", "avatar_url": "https://avatars.githubusercontent.com/u/69764315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Serial-ATA", "html_url": "https://github.com/Serial-ATA", "followers_url": "https://api.github.com/users/Serial-ATA/followers", "following_url": "https://api.github.com/users/Serial-ATA/following{/other_user}", "gists_url": "https://api.github.com/users/Serial-ATA/gists{/gist_id}", "starred_url": "https://api.github.com/users/Serial-ATA/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Serial-ATA/subscriptions", "organizations_url": "https://api.github.com/users/Serial-ATA/orgs", "repos_url": "https://api.github.com/users/Serial-ATA/repos", "events_url": "https://api.github.com/users/Serial-ATA/events{/privacy}", "received_events_url": "https://api.github.com/users/Serial-ATA/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Serial-ATA", "id": 69764315, "node_id": "MDQ6VXNlcjY5NzY0MzE1", "avatar_url": "https://avatars.githubusercontent.com/u/69764315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Serial-ATA", "html_url": "https://github.com/Serial-ATA", "followers_url": "https://api.github.com/users/Serial-ATA/followers", "following_url": "https://api.github.com/users/Serial-ATA/following{/other_user}", "gists_url": "https://api.github.com/users/Serial-ATA/gists{/gist_id}", "starred_url": "https://api.github.com/users/Serial-ATA/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Serial-ATA/subscriptions", "organizations_url": "https://api.github.com/users/Serial-ATA/orgs", "repos_url": "https://api.github.com/users/Serial-ATA/repos", "events_url": "https://api.github.com/users/Serial-ATA/events{/privacy}", "received_events_url": "https://api.github.com/users/Serial-ATA/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "445c83f8f36d78895c92f7f8145542b6ea6b59a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/445c83f8f36d78895c92f7f8145542b6ea6b59a8", "html_url": "https://github.com/rust-lang/rust/commit/445c83f8f36d78895c92f7f8145542b6ea6b59a8"}], "stats": {"total": 1057, "additions": 827, "deletions": 230}, "files": [{"sha": "38157cc16ef19575c1e6fb1766bb00b2a792aeed", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 480, "deletions": 131, "changes": 611, "blob_url": "https://github.com/rust-lang/rust/blob/c96cd359f532bb37865ef91d0935655a0af7e7f4/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c96cd359f532bb37865ef91d0935655a0af7e7f4/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=c96cd359f532bb37865ef91d0935655a0af7e7f4", "patch": "@@ -1,13 +1,13 @@\n //! A group of attributes that can be attached to Rust code in order\n //! to generate a clippy lint detecting said code automatically.\n \n-use clippy_utils::get_attr;\n+use clippy_utils::{get_attr, higher};\n use rustc_ast::ast::{LitFloatType, LitKind};\n-use rustc_ast::walk_list;\n+use rustc_ast::{walk_list, Label, LitIntType};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n-use rustc_hir::{Block, Expr, ExprKind, Pat, PatKind, QPath, Stmt, StmtKind, TyKind};\n+use rustc_hir::{Arm, Block, Expr, ExprKind, FnRetTy, Lit, MatchSource, Pat, PatKind, QPath, Stmt, StmtKind, TyKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -70,7 +70,7 @@ impl<'tcx> LateLintPass<'tcx> for Author {\n             return;\n         }\n         prelude();\n-        PrintVisitor::new(\"item\").visit_item(item);\n+        PrintVisitor::new(\"item\", cx).visit_item(item);\n         done();\n     }\n \n@@ -79,7 +79,7 @@ impl<'tcx> LateLintPass<'tcx> for Author {\n             return;\n         }\n         prelude();\n-        PrintVisitor::new(\"item\").visit_impl_item(item);\n+        PrintVisitor::new(\"item\", cx).visit_impl_item(item);\n         done();\n     }\n \n@@ -88,7 +88,7 @@ impl<'tcx> LateLintPass<'tcx> for Author {\n             return;\n         }\n         prelude();\n-        PrintVisitor::new(\"item\").visit_trait_item(item);\n+        PrintVisitor::new(\"item\", cx).visit_trait_item(item);\n         done();\n     }\n \n@@ -98,7 +98,7 @@ impl<'tcx> LateLintPass<'tcx> for Author {\n         }\n         prelude();\n         let parent_hir_id = cx.tcx.hir().get_parent_node(var.id);\n-        PrintVisitor::new(\"var\").visit_variant(var, &hir::Generics::empty(), parent_hir_id);\n+        PrintVisitor::new(\"var\", cx).visit_variant(var, &hir::Generics::empty(), parent_hir_id);\n         done();\n     }\n \n@@ -107,7 +107,7 @@ impl<'tcx> LateLintPass<'tcx> for Author {\n             return;\n         }\n         prelude();\n-        PrintVisitor::new(\"field\").visit_field_def(field);\n+        PrintVisitor::new(\"field\", cx).visit_field_def(field);\n         done();\n     }\n \n@@ -116,7 +116,7 @@ impl<'tcx> LateLintPass<'tcx> for Author {\n             return;\n         }\n         prelude();\n-        PrintVisitor::new(\"expr\").visit_expr(expr);\n+        PrintVisitor::new(\"expr\", cx).visit_expr(expr);\n         done();\n     }\n \n@@ -125,7 +125,7 @@ impl<'tcx> LateLintPass<'tcx> for Author {\n             return;\n         }\n         prelude();\n-        PrintVisitor::new(\"arm\").visit_arm(arm);\n+        PrintVisitor::new(\"arm\", cx).visit_arm(arm);\n         done();\n     }\n \n@@ -138,7 +138,7 @@ impl<'tcx> LateLintPass<'tcx> for Author {\n             _ => {},\n         }\n         prelude();\n-        PrintVisitor::new(\"stmt\").visit_stmt(stmt);\n+        PrintVisitor::new(\"stmt\", cx).visit_stmt(stmt);\n         done();\n     }\n \n@@ -147,17 +147,18 @@ impl<'tcx> LateLintPass<'tcx> for Author {\n             return;\n         }\n         prelude();\n-        PrintVisitor::new(\"item\").visit_foreign_item(item);\n+        PrintVisitor::new(\"item\", cx).visit_foreign_item(item);\n         done();\n     }\n }\n \n-impl PrintVisitor {\n+impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n     #[must_use]\n-    fn new(s: &'static str) -> Self {\n+    fn new(s: &'static str, cx: &'a LateContext<'tcx>) -> Self {\n         Self {\n             ids: FxHashMap::default(),\n             current: s.to_owned(),\n+            cx,\n         }\n     }\n \n@@ -190,43 +191,299 @@ impl PrintVisitor {\n             println!(\"]);\");\n         }\n     }\n+\n+    fn print_label(&mut self, label: Option<Label>) {\n+        if let Some(label) = label {\n+            let label_bind = self.next(\"label\");\n+\n+            println!(\"    if let Some(ref {}) = {}\", label_bind, self.current);\n+\n+            let label_name_bind = self.next(\"label_name\");\n+            let label_name = label.ident.name;\n+\n+            println!(\n+                \"    if {}.ident.name.as_str() == {:?};\",\n+                label_name_bind,\n+                label_name.as_str()\n+            );\n+        }\n+    }\n+\n+    fn print_lit_expr(&mut self, lit: &Lit, current: &str) {\n+        let lit_pat = self.next(\"lit\");\n+\n+        println!(\"Lit(ref {}) = {};\", lit_pat, current);\n+\n+        match lit.node {\n+            LitKind::Bool(val) => println!(\"    if let LitKind::Bool({:?}) = {}.node;\", val, lit_pat),\n+            LitKind::Char(c) => println!(\"    if let LitKind::Char({:?}) = {}.node;\", c, lit_pat),\n+            LitKind::Err(val) => println!(\"    if let LitKind::Err({}) = {}.node;\", val, lit_pat),\n+            LitKind::Byte(b) => println!(\"    if let LitKind::Byte({}) = {}.node;\", b, lit_pat),\n+            LitKind::Int(i, suffix) => {\n+                let int_ty = match suffix {\n+                    LitIntType::Signed(int_ty) => format!(\"LitIntType::Signed(IntTy::{:?})\", int_ty),\n+                    LitIntType::Unsigned(uint_ty) => format!(\"LitIntType::Unsigned(UintTy::{:?})\", uint_ty),\n+                    LitIntType::Unsuffixed => String::from(\"LitIntType::Unsuffixed\"),\n+                };\n+\n+                println!(\"    if let LitKind::Int({}, {}) = {}.node;\", i, int_ty, lit_pat);\n+            },\n+            LitKind::Float(_, suffix) => {\n+                let float_ty = match suffix {\n+                    LitFloatType::Suffixed(suffix_ty) => format!(\"LitFloatType::Suffixed(FloatTy::{:?})\", suffix_ty),\n+                    LitFloatType::Unsuffixed => String::from(\"LitFloatType::Unsuffixed\"),\n+                };\n+\n+                println!(\"    if let LitKind::Float(_, {}) = {}.node;\", float_ty, lit_pat);\n+            },\n+            LitKind::ByteStr(ref vec) => {\n+                let vec_pat = self.next(\"vec\");\n+\n+                println!(\"    if let LitKind::ByteStr(ref {}) = {}.node;\", vec_pat, lit_pat);\n+                println!(\"    if let [{:?}] = **{};\", vec, vec_pat);\n+            },\n+            LitKind::Str(ref text, _) => {\n+                let str_pat = self.next(\"s\");\n+\n+                println!(\"    if let LitKind::Str(ref {}, _) = {}.node;\", str_pat, lit_pat);\n+                println!(\"    if {}.as_str() == {:?}\", str_pat, &*text.as_str());\n+            },\n+        }\n+    }\n+\n+    fn print_match_expr(&mut self, expr: &Expr<'_>, arms: &[Arm<'_>], des: MatchSource, current: &str) {\n+        let expr_pat = self.next(\"expr\");\n+        let arms_pat = self.next(\"arms\");\n+\n+        println!(\n+            \"Match(ref {}, ref {}, MatchSource::{:?}) = {};\",\n+            expr_pat, arms_pat, des, current\n+        );\n+\n+        self.current = expr_pat;\n+        self.visit_expr(expr);\n+\n+        println!(\"    if {}.len() == {};\", arms_pat, arms.len());\n+\n+        for (i, arm) in arms.iter().enumerate() {\n+            self.current = format!(\"{}[{}].body\", arms_pat, i);\n+            self.visit_expr(arm.body);\n+\n+            if let Some(ref guard) = arm.guard {\n+                let guard_pat = self.next(\"guard\");\n+\n+                println!(\"    if let Some(ref {}) = {}[{}].guard;\", guard_pat, arms_pat, i);\n+\n+                match guard {\n+                    hir::Guard::If(if_expr) => {\n+                        let if_expr_pat = self.next(\"expr\");\n+\n+                        println!(\"    if let Guard::If(ref {}) = {};\", if_expr_pat, guard_pat);\n+\n+                        self.current = if_expr_pat;\n+                        self.visit_expr(if_expr);\n+                    },\n+                    hir::Guard::IfLet(if_let_pat, if_let_expr) => {\n+                        let if_let_pat_pat = self.next(\"pat\");\n+                        let if_let_expr_pat = self.next(\"expr\");\n+\n+                        println!(\n+                            \"    if let Guard::IfLet(ref {}, ref {}) = {};\",\n+                            if_let_pat_pat, if_let_expr_pat, guard_pat\n+                        );\n+\n+                        self.current = if_let_expr_pat;\n+                        self.visit_expr(if_let_expr);\n+\n+                        self.current = if_let_pat_pat;\n+                        self.visit_pat(if_let_pat);\n+                    },\n+                }\n+            }\n+            self.current = format!(\"{}[{}].pat\", arms_pat, i);\n+            self.visit_pat(arm.pat);\n+        }\n+    }\n+\n+    fn check_higher(&mut self, expr: &Expr<'_>) -> bool {\n+        if let Some(higher::While { condition, body }) = higher::While::hir(expr) {\n+            let condition_pat = self.next(\"condition\");\n+            let body_pat = self.next(\"body\");\n+\n+            println!(\n+                \"    if let Some(higher::While {{ condition: {}, body: {} }}) = higher::While::hir({})\",\n+                condition_pat, body_pat, self.current\n+            );\n+\n+            self.current = condition_pat;\n+            self.visit_expr(condition);\n+\n+            self.current = body_pat;\n+            self.visit_expr(body);\n+\n+            return true;\n+        }\n+\n+        if let Some(higher::WhileLet {\n+            let_pat,\n+            let_expr,\n+            if_then,\n+        }) = higher::WhileLet::hir(expr)\n+        {\n+            let let_pat_ = self.next(\"let_pat\");\n+            let let_expr_pat = self.next(\"let_expr\");\n+            let if_then_pat = self.next(\"if_then\");\n+\n+            println!(\n+                \"    if let Some(higher::WhileLet {{ let_pat: {}, let_expr: {}, if_then: {} }}) = higher::WhileLet::hir({})\",\n+                let_pat_, let_expr_pat, if_then_pat, self.current\n+            );\n+\n+            self.current = let_pat_;\n+            self.visit_pat(let_pat);\n+\n+            self.current = let_expr_pat;\n+            self.visit_expr(let_expr);\n+\n+            self.current = if_then_pat;\n+            self.visit_expr(if_then);\n+\n+            return true;\n+        }\n+\n+        if let Some(higher::IfLet {\n+            let_pat,\n+            let_expr,\n+            if_then,\n+            if_else,\n+        }) = higher::IfLet::hir(self.cx, expr)\n+        {\n+            let let_pat_ = self.next(\"let_pat\");\n+            let let_expr_pat = self.next(\"let_expr\");\n+            let if_then_pat = self.next(\"if_then\");\n+            let else_pat = self.next(\"else_expr\");\n+\n+            println!(\n+                \"    if let Some(higher::IfLet {{ let_pat: {}, let_expr: {}, if_then: {}, if_else: {}}}) = higher::IfLet::hir({})\",\n+                let_pat_, let_expr_pat, if_then_pat, else_pat, self.current\n+            );\n+\n+            self.current = let_pat_;\n+            self.visit_pat(let_pat);\n+\n+            self.current = let_expr_pat;\n+            self.visit_expr(let_expr);\n+\n+            self.current = if_then_pat;\n+            self.visit_expr(if_then);\n+\n+            if let Some(else_expr) = if_else {\n+                self.current = else_pat;\n+                self.visit_expr(else_expr);\n+            }\n+\n+            return true;\n+        }\n+\n+        if let Some(higher::If { cond, then, r#else }) = higher::If::hir(expr) {\n+            let cond_pat = self.next(\"cond\");\n+            let then_pat = self.next(\"then\");\n+            let else_pat = self.next(\"else_expr\");\n+\n+            println!(\n+                \"    if let Some(higher::If {{ cond: {}, then: {}, r#else: {}}}) = higher::If::hir({})\",\n+                cond_pat, then_pat, else_pat, self.current\n+            );\n+\n+            self.current = cond_pat;\n+            self.visit_expr(cond);\n+\n+            self.current = then_pat;\n+            self.visit_expr(then);\n+\n+            if let Some(else_expr) = r#else {\n+                self.current = else_pat;\n+                self.visit_expr(else_expr);\n+            }\n+\n+            return true;\n+        }\n+\n+        if let Some(higher::ForLoop { pat, arg, body, .. }) = higher::ForLoop::hir(expr) {\n+            let pat_ = self.next(\"pat\");\n+            let arg_pat = self.next(\"arg\");\n+            let body_pat = self.next(\"body\");\n+\n+            println!(\n+                \"    if let Some(higher::ForLoop {{ pat: {}, arg: {}, body: {}, ..}}) = higher::ForLoop::hir({})\",\n+                pat_, arg_pat, body_pat, self.current\n+            );\n+\n+            self.current = pat_;\n+            self.visit_pat(pat);\n+\n+            self.current = arg_pat;\n+            self.visit_expr(arg);\n+\n+            self.current = body_pat;\n+            self.visit_expr(body);\n+\n+            return true;\n+        }\n+\n+        false\n+    }\n }\n \n-struct PrintVisitor {\n+struct PrintVisitor<'a, 'tcx> {\n     /// Fields are the current index that needs to be appended to pattern\n     /// binding names\n     ids: FxHashMap<&'static str, usize>,\n     /// the name that needs to be destructured\n     current: String,\n+    cx: &'a LateContext<'tcx>,\n }\n \n-impl<'tcx> Visitor<'tcx> for PrintVisitor {\n+impl<'a, 'tcx> Visitor<'tcx> for PrintVisitor<'a, '_> {\n     type Map = Map<'tcx>;\n \n     #[allow(clippy::too_many_lines)]\n     fn visit_expr(&mut self, expr: &Expr<'_>) {\n+        if self.check_higher(expr) {\n+            return;\n+        }\n+\n         print!(\"    if let ExprKind::\");\n         let current = format!(\"{}.kind\", self.current);\n+\n         match expr.kind {\n             ExprKind::Let(pat, expr, _) => {\n                 let let_pat = self.next(\"pat\");\n                 let let_expr = self.next(\"expr\");\n-                println!(\"    Let(ref {}, ref {}, _) = {};\", let_pat, let_expr, current);\n+\n+                println!(\"Let(ref {}, ref {}, _) = {};\", let_pat, let_expr, current);\n+\n                 self.current = let_expr;\n                 self.visit_expr(expr);\n+\n                 self.current = let_pat;\n                 self.visit_pat(pat);\n             },\n             ExprKind::Box(inner) => {\n                 let inner_pat = self.next(\"inner\");\n+\n                 println!(\"Box(ref {}) = {};\", inner_pat, current);\n+\n                 self.current = inner_pat;\n                 self.visit_expr(inner);\n             },\n             ExprKind::Array(elements) => {\n                 let elements_pat = self.next(\"elements\");\n+\n                 println!(\"Array(ref {}) = {};\", elements_pat, current);\n+\n                 println!(\"    if {}.len() == {};\", elements_pat, elements.len());\n+\n                 for (i, element) in elements.iter().enumerate() {\n                     self.current = format!(\"{}[{}]\", elements_pat, i);\n                     self.visit_expr(element);\n@@ -235,26 +492,48 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n             ExprKind::Call(func, args) => {\n                 let func_pat = self.next(\"func\");\n                 let args_pat = self.next(\"args\");\n+\n                 println!(\"Call(ref {}, ref {}) = {};\", func_pat, args_pat, current);\n+\n                 self.current = func_pat;\n                 self.visit_expr(func);\n+\n                 println!(\"    if {}.len() == {};\", args_pat, args.len());\n+\n                 for (i, arg) in args.iter().enumerate() {\n                     self.current = format!(\"{}[{}]\", args_pat, i);\n                     self.visit_expr(arg);\n                 }\n             },\n-            ExprKind::MethodCall(_method_name, ref _generics, _args, ref _fn_span) => {\n+            ExprKind::MethodCall(method_name, _, args, _) => {\n+                let method_name_pat = self.next(\"method_name\");\n+                let args_pat = self.next(\"args\");\n+\n                 println!(\n-                    \"MethodCall(ref method_name, ref generics, ref args, ref fn_span) = {};\",\n-                    current\n+                    \"MethodCall(ref {}, ref {}, _) = {};\",\n+                    method_name_pat, args_pat, current\n                 );\n-                println!(\"    // unimplemented: `ExprKind::MethodCall` is not further destructured at the moment\");\n+\n+                println!(\n+                    \"    if {}.ident.name.as_str() == {};\",\n+                    method_name_pat,\n+                    method_name.ident.name.as_str()\n+                );\n+\n+                println!(\"    if {}.len() == {};\", args_pat, args.len());\n+\n+                for (i, arg) in args.iter().enumerate() {\n+                    self.current = format!(\"{}[{}]\", args_pat, i);\n+                    self.visit_expr(arg);\n+                }\n             },\n             ExprKind::Tup(elements) => {\n                 let elements_pat = self.next(\"elements\");\n+\n                 println!(\"Tup(ref {}) = {};\", elements_pat, current);\n+\n                 println!(\"    if {}.len() == {};\", elements_pat, elements.len());\n+\n                 for (i, element) in elements.iter().enumerate() {\n                     self.current = format!(\"{}[{}]\", elements_pat, i);\n                     self.visit_expr(element);\n@@ -264,237 +543,228 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 let op_pat = self.next(\"op\");\n                 let left_pat = self.next(\"left\");\n                 let right_pat = self.next(\"right\");\n+\n                 println!(\n                     \"Binary(ref {}, ref {}, ref {}) = {};\",\n                     op_pat, left_pat, right_pat, current\n                 );\n+\n                 println!(\"    if BinOpKind::{:?} == {}.node;\", op.node, op_pat);\n+\n                 self.current = left_pat;\n                 self.visit_expr(left);\n+\n                 self.current = right_pat;\n                 self.visit_expr(right);\n             },\n             ExprKind::Unary(ref op, inner) => {\n                 let inner_pat = self.next(\"inner\");\n+\n                 println!(\"Unary(UnOp::{:?}, ref {}) = {};\", op, inner_pat, current);\n+\n                 self.current = inner_pat;\n                 self.visit_expr(inner);\n             },\n-            ExprKind::Lit(ref lit) => {\n-                let lit_pat = self.next(\"lit\");\n-                println!(\"Lit(ref {}) = {};\", lit_pat, current);\n-                match lit.node {\n-                    LitKind::Bool(val) => println!(\"    if let LitKind::Bool({:?}) = {}.node;\", val, lit_pat),\n-                    LitKind::Char(c) => println!(\"    if let LitKind::Char({:?}) = {}.node;\", c, lit_pat),\n-                    LitKind::Err(val) => println!(\"    if let LitKind::Err({}) = {}.node;\", val, lit_pat),\n-                    LitKind::Byte(b) => println!(\"    if let LitKind::Byte({}) = {}.node;\", b, lit_pat),\n-                    // FIXME: also check int type\n-                    LitKind::Int(i, _) => println!(\"    if let LitKind::Int({}, _) = {}.node;\", i, lit_pat),\n-                    LitKind::Float(_, LitFloatType::Suffixed(_)) => println!(\n-                        \"    if let LitKind::Float(_, LitFloatType::Suffixed(_)) = {}.node;\",\n-                        lit_pat\n-                    ),\n-                    LitKind::Float(_, LitFloatType::Unsuffixed) => println!(\n-                        \"    if let LitKind::Float(_, LitFloatType::Unsuffixed) = {}.node;\",\n-                        lit_pat\n-                    ),\n-                    LitKind::ByteStr(ref vec) => {\n-                        let vec_pat = self.next(\"vec\");\n-                        println!(\"    if let LitKind::ByteStr(ref {}) = {}.node;\", vec_pat, lit_pat);\n-                        println!(\"    if let [{:?}] = **{};\", vec, vec_pat);\n-                    },\n-                    LitKind::Str(ref text, _) => {\n-                        let str_pat = self.next(\"s\");\n-                        println!(\"    if let LitKind::Str(ref {}, _) = {}.node;\", str_pat, lit_pat);\n-                        println!(\"    if {}.as_str() == {:?}\", str_pat, &*text.as_str());\n-                    },\n-                }\n-            },\n+            ExprKind::Lit(ref lit) => self.print_lit_expr(lit, &current),\n             ExprKind::Cast(expr, ty) => {\n                 let cast_pat = self.next(\"expr\");\n                 let cast_ty = self.next(\"cast_ty\");\n                 let qp_label = self.next(\"qp\");\n \n                 println!(\"Cast(ref {}, ref {}) = {};\", cast_pat, cast_ty, current);\n+\n                 if let TyKind::Path(ref qp) = ty.kind {\n                     println!(\"    if let TyKind::Path(ref {}) = {}.kind;\", qp_label, cast_ty);\n+\n                     self.current = qp_label;\n                     self.print_qpath(qp);\n                 }\n+\n                 self.current = cast_pat;\n                 self.visit_expr(expr);\n             },\n             ExprKind::Type(expr, _ty) => {\n                 let cast_pat = self.next(\"expr\");\n+\n                 println!(\"Type(ref {}, _) = {};\", cast_pat, current);\n+\n                 self.current = cast_pat;\n                 self.visit_expr(expr);\n             },\n-            ExprKind::Loop(body, _, des, _) => {\n+            ExprKind::Loop(body, label, des, _) => {\n                 let body_pat = self.next(\"body\");\n                 let label_pat = self.next(\"label\");\n+\n                 println!(\n                     \"Loop(ref {}, ref {}, LoopSource::{:?}) = {};\",\n                     body_pat, label_pat, des, current\n                 );\n+\n                 self.current = body_pat;\n                 self.visit_block(body);\n+\n+                self.current = label_pat;\n+                self.print_label(label);\n             },\n-            ExprKind::If(cond, then, ref opt_else) => {\n-                let cond_pat = self.next(\"cond\");\n-                let then_pat = self.next(\"then\");\n-                if let Some(else_) = *opt_else {\n-                    let else_pat = self.next(\"else_\");\n-                    println!(\n-                        \"If(ref {}, ref {}, Some(ref {})) = {};\",\n-                        cond_pat, then_pat, else_pat, current\n-                    );\n-                    self.current = else_pat;\n-                    self.visit_expr(else_);\n+            ExprKind::If(_, _, _) => {}, // Covered by check_higher\n+            ExprKind::Match(match_expr, arms, des) => self.print_match_expr(match_expr, arms, des, &current),\n+            ExprKind::Closure(capture_clause, fn_decl, body_id, _, movability) => {\n+                let capture_by = format!(\"CaptureBy::{:?}\", capture_clause);\n+\n+                let movability = if let Some(movability) = movability {\n+                    format!(\"Some(Movability::{:?})\", movability)\n                 } else {\n-                    println!(\"If(ref {}, ref {}, None) = {};\", cond_pat, then_pat, current);\n-                }\n-                self.current = cond_pat;\n-                self.visit_expr(cond);\n-                self.current = then_pat;\n-                self.visit_expr(then);\n-            },\n-            ExprKind::Match(expr, arms, des) => {\n-                let expr_pat = self.next(\"expr\");\n-                let arms_pat = self.next(\"arms\");\n+                    String::from(\"None\")\n+                };\n+\n+                let ret_ty = match fn_decl.output {\n+                    FnRetTy::DefaultReturn(_) => \"FnRetTy::DefaultReturn(_)\",\n+                    FnRetTy::Return(_) => \"FnRetTy::Return(_ty)\",\n+                };\n+\n+                let fn_decl_pat = self.next(\"fn_decl\");\n+                let body_id_pat = self.next(\"body_id\");\n+\n                 println!(\n-                    \"Match(ref {}, ref {}, MatchSource::{:?}) = {};\",\n-                    expr_pat, arms_pat, des, current\n+                    \"Closure({}, ref {}, ref {}, _, {}) = {}\",\n+                    capture_by, fn_decl_pat, body_id_pat, movability, current\n                 );\n-                self.current = expr_pat;\n-                self.visit_expr(expr);\n-                println!(\"    if {}.len() == {};\", arms_pat, arms.len());\n-                for (i, arm) in arms.iter().enumerate() {\n-                    self.current = format!(\"{}[{}].body\", arms_pat, i);\n-                    self.visit_expr(arm.body);\n-                    if let Some(ref guard) = arm.guard {\n-                        let guard_pat = self.next(\"guard\");\n-                        println!(\"    if let Some(ref {}) = {}[{}].guard;\", guard_pat, arms_pat, i);\n-                        match guard {\n-                            hir::Guard::If(if_expr) => {\n-                                let if_expr_pat = self.next(\"expr\");\n-                                println!(\"    if let Guard::If(ref {}) = {};\", if_expr_pat, guard_pat);\n-                                self.current = if_expr_pat;\n-                                self.visit_expr(if_expr);\n-                            },\n-                            hir::Guard::IfLet(if_let_pat, if_let_expr) => {\n-                                let if_let_pat_pat = self.next(\"pat\");\n-                                let if_let_expr_pat = self.next(\"expr\");\n-                                println!(\n-                                    \"    if let Guard::IfLet(ref {}, ref {}) = {};\",\n-                                    if_let_pat_pat, if_let_expr_pat, guard_pat\n-                                );\n-                                self.current = if_let_expr_pat;\n-                                self.visit_expr(if_let_expr);\n-                                self.current = if_let_pat_pat;\n-                                self.visit_pat(if_let_pat);\n-                            },\n-                        }\n-                    }\n-                    self.current = format!(\"{}[{}].pat\", arms_pat, i);\n-                    self.visit_pat(arm.pat);\n-                }\n-            },\n-            ExprKind::Closure(ref _capture_clause, _func, _, _, _) => {\n-                println!(\"Closure(ref capture_clause, ref func, _, _, _) = {};\", current);\n-                println!(\"    // unimplemented: `ExprKind::Closure` is not further destructured at the moment\");\n+                println!(\"    if let {} = {}.output\", ret_ty, fn_decl_pat);\n+\n+                let hir = self.cx.tcx.hir();\n+                let body = hir.body(body_id);\n+\n+                let body_pat = self.next(\"body\");\n+\n+                println!(\"    let {} = cx.tcx.hir().body({});\", body_pat, body_id_pat);\n+\n+                self.current = format!(\"{}.value\", body_pat);\n+                self.visit_expr(&body.value);\n             },\n-            ExprKind::Yield(sub, _) => {\n+            ExprKind::Yield(sub, source) => {\n                 let sub_pat = self.next(\"sub\");\n-                println!(\"Yield(ref sub) = {};\", current);\n+\n+                println!(\"Yield(ref sub, YieldSource::{:?}) = {};\", source, current);\n+\n                 self.current = sub_pat;\n                 self.visit_expr(sub);\n             },\n-            ExprKind::Block(block, _) => {\n+            ExprKind::Block(block, label) => {\n                 let block_pat = self.next(\"block\");\n-                println!(\"Block(ref {}) = {};\", block_pat, current);\n+                let label_pat = self.next(\"label\");\n+\n+                println!(\"Block(ref {}, ref {}) = {};\", block_pat, label_pat, current);\n+\n                 self.current = block_pat;\n                 self.visit_block(block);\n+\n+                self.current = label_pat;\n+                self.print_label(label);\n             },\n             ExprKind::Assign(target, value, _) => {\n                 let target_pat = self.next(\"target\");\n                 let value_pat = self.next(\"value\");\n+\n                 println!(\n                     \"Assign(ref {}, ref {}, ref _span) = {};\",\n                     target_pat, value_pat, current\n                 );\n+\n                 self.current = target_pat;\n                 self.visit_expr(target);\n+\n                 self.current = value_pat;\n                 self.visit_expr(value);\n             },\n             ExprKind::AssignOp(ref op, target, value) => {\n                 let op_pat = self.next(\"op\");\n                 let target_pat = self.next(\"target\");\n                 let value_pat = self.next(\"value\");\n+\n                 println!(\n                     \"AssignOp(ref {}, ref {}, ref {}) = {};\",\n                     op_pat, target_pat, value_pat, current\n                 );\n+\n                 println!(\"    if BinOpKind::{:?} == {}.node;\", op.node, op_pat);\n+\n                 self.current = target_pat;\n                 self.visit_expr(target);\n+\n                 self.current = value_pat;\n                 self.visit_expr(value);\n             },\n             ExprKind::Field(object, ref field_ident) => {\n                 let obj_pat = self.next(\"object\");\n                 let field_name_pat = self.next(\"field_name\");\n+\n                 println!(\"Field(ref {}, ref {}) = {};\", obj_pat, field_name_pat, current);\n                 println!(\"    if {}.as_str() == {:?}\", field_name_pat, field_ident.as_str());\n+\n                 self.current = obj_pat;\n                 self.visit_expr(object);\n             },\n             ExprKind::Index(object, index) => {\n                 let object_pat = self.next(\"object\");\n                 let index_pat = self.next(\"index\");\n+\n                 println!(\"Index(ref {}, ref {}) = {};\", object_pat, index_pat, current);\n+\n                 self.current = object_pat;\n                 self.visit_expr(object);\n+\n                 self.current = index_pat;\n                 self.visit_expr(index);\n             },\n             ExprKind::Path(ref path) => {\n                 let path_pat = self.next(\"path\");\n+\n                 println!(\"Path(ref {}) = {};\", path_pat, current);\n+\n                 self.current = path_pat;\n                 self.print_qpath(path);\n             },\n             ExprKind::AddrOf(kind, mutability, inner) => {\n                 let inner_pat = self.next(\"inner\");\n+\n                 println!(\n                     \"AddrOf(BorrowKind::{:?}, Mutability::{:?}, ref {}) = {};\",\n                     kind, mutability, inner_pat, current\n                 );\n+\n                 self.current = inner_pat;\n                 self.visit_expr(inner);\n             },\n-            ExprKind::Break(ref _destination, ref opt_value) => {\n+            ExprKind::Break(ref destination, ref opt_value) => {\n                 let destination_pat = self.next(\"destination\");\n+\n                 if let Some(value) = *opt_value {\n                     let value_pat = self.next(\"value\");\n+\n                     println!(\"Break(ref {}, Some(ref {})) = {};\", destination_pat, value_pat, current);\n+\n                     self.current = value_pat;\n                     self.visit_expr(value);\n                 } else {\n                     println!(\"Break(ref {}, None) = {};\", destination_pat, current);\n                 }\n-                // FIXME: implement label printing\n+\n+                self.current = format!(\"{}.label\", destination_pat);\n+                self.print_label(destination.label);\n             },\n-            ExprKind::Continue(ref _destination) => {\n+            ExprKind::Continue(ref destination) => {\n                 let destination_pat = self.next(\"destination\");\n-                println!(\"Again(ref {}) = {};\", destination_pat, current);\n-                // FIXME: implement label printing\n+                println!(\"Continue(ref {}) = {};\", destination_pat, current);\n+\n+                self.current = format!(\"{}.label\", destination_pat);\n+                self.print_label(destination.label);\n             },\n             ExprKind::Ret(ref opt_value) => {\n                 if let Some(value) = *opt_value {\n                     let value_pat = self.next(\"value\");\n+\n                     println!(\"Ret(Some(ref {})) = {};\", value_pat, current);\n+\n                     self.current = value_pat;\n                     self.visit_expr(value);\n                 } else {\n@@ -512,41 +782,66 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n             ExprKind::Struct(path, fields, ref opt_base) => {\n                 let path_pat = self.next(\"path\");\n                 let fields_pat = self.next(\"fields\");\n+\n                 if let Some(base) = *opt_base {\n                     let base_pat = self.next(\"base\");\n+\n                     println!(\n                         \"Struct(ref {}, ref {}, Some(ref {})) = {};\",\n                         path_pat, fields_pat, base_pat, current\n                     );\n+\n                     self.current = base_pat;\n                     self.visit_expr(base);\n                 } else {\n                     println!(\"Struct(ref {}, ref {}, None) = {};\", path_pat, fields_pat, current);\n                 }\n+\n                 self.current = path_pat;\n                 self.print_qpath(path);\n+\n                 println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n-                println!(\"    // unimplemented: field checks\");\n+\n+                for (i, field) in fields.iter().enumerate() {\n+                    println!(\n+                        \"    if {}[{}].ident.name.as_str() == {:?}\",\n+                        fields_pat,\n+                        i,\n+                        &*field.ident.name.as_str()\n+                    );\n+\n+                    self.current = format!(\"{}[{}]\", fields_pat, i);\n+                    self.visit_expr(field.expr);\n+                }\n             },\n             ExprKind::ConstBlock(_) => {\n                 let value_pat = self.next(\"value\");\n-                println!(\"Const({})\", value_pat);\n+                println!(\"Const({}) = {}\", value_pat, current);\n                 self.current = value_pat;\n             },\n-            // FIXME: compute length (needs type info)\n-            ExprKind::Repeat(value, _) => {\n+            ExprKind::Repeat(value, length) => {\n                 let value_pat = self.next(\"value\");\n-                println!(\"Repeat(ref {}, _) = {};\", value_pat, current);\n-                println!(\"// unimplemented: repeat count check\");\n+                let length_pat = self.next(\"length\");\n+\n+                println!(\"Repeat(ref {}, ref {}) = {};\", value_pat, length_pat, current);\n+\n                 self.current = value_pat;\n                 self.visit_expr(value);\n+\n+                let hir = self.cx.tcx.hir();\n+                let body = hir.body(length.body);\n+\n+                self.current = format!(\"{}.value\", length_pat);\n+                self.visit_expr(&body.value);\n             },\n             ExprKind::Err => {\n                 println!(\"Err = {}\", current);\n             },\n             ExprKind::DropTemps(expr) => {\n                 let expr_pat = self.next(\"expr\");\n+\n                 println!(\"DropTemps(ref {}) = {};\", expr_pat, current);\n+\n                 self.current = expr_pat;\n                 self.visit_expr(expr);\n             },\n@@ -555,11 +850,14 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n \n     fn visit_block(&mut self, block: &Block<'_>) {\n         println!(\"    if {}.stmts.len() == {};\", self.current, block.stmts.len());\n+\n         let block_name = self.current.clone();\n+\n         for (i, stmt) in block.stmts.iter().enumerate() {\n             self.current = format!(\"{}.stmts[{}]\", block_name, i);\n             self.visit_stmt(stmt);\n         }\n+\n         if let Some(expr) = block.expr {\n             self.current = self.next(\"trailing_expr\");\n             println!(\"    if let Some({}) = &{}.expr;\", self.current, block_name);\n@@ -573,22 +871,27 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n     fn visit_pat(&mut self, pat: &Pat<'_>) {\n         print!(\"    if let PatKind::\");\n         let current = format!(\"{}.kind\", self.current);\n+\n         match pat.kind {\n             PatKind::Wild => println!(\"Wild = {};\", current),\n             PatKind::Binding(anno, .., ident, ref sub) => {\n                 let anno_pat = &format!(\"BindingAnnotation::{:?}\", anno);\n                 let name_pat = self.next(\"name\");\n+\n                 if let Some(sub) = *sub {\n                     let sub_pat = self.next(\"sub\");\n+\n                     println!(\n                         \"Binding({}, _, {}, Some(ref {})) = {};\",\n                         anno_pat, name_pat, sub_pat, current\n                     );\n+\n                     self.current = sub_pat;\n                     self.visit_pat(sub);\n                 } else {\n                     println!(\"Binding({}, _, {}, None) = {};\", anno_pat, name_pat, current);\n                 }\n+\n                 println!(\"    if {}.as_str() == \\\"{}\\\";\", name_pat, ident.as_str());\n             },\n             PatKind::Struct(ref path, fields, ignore) => {\n@@ -598,74 +901,110 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     \"Struct(ref {}, ref {}, {}) = {};\",\n                     path_pat, fields_pat, ignore, current\n                 );\n+\n                 self.current = path_pat;\n                 self.print_qpath(path);\n+\n                 println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n-                println!(\"    // unimplemented: field checks\");\n+\n+                for (i, field) in fields.iter().enumerate() {\n+                    println!(\n+                        \"    if {}[{}].ident.name.as_str() == {:?}\",\n+                        fields_pat,\n+                        i,\n+                        &*field.ident.name.as_str()\n+                    );\n+\n+                    self.current = format!(\"{}[{}]\", fields_pat, i);\n+                    self.visit_pat(field.pat);\n+                }\n             },\n             PatKind::Or(fields) => {\n                 let fields_pat = self.next(\"fields\");\n                 println!(\"Or(ref {}) = {};\", fields_pat, current);\n                 println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n-                println!(\"    // unimplemented: field checks\");\n+\n+                for (i, field) in fields.iter().enumerate() {\n+                    self.current = format!(\"{}[{}]\", fields_pat, i);\n+                    self.visit_pat(field);\n+                }\n             },\n             PatKind::TupleStruct(ref path, fields, skip_pos) => {\n                 let path_pat = self.next(\"path\");\n                 let fields_pat = self.next(\"fields\");\n+\n                 println!(\n                     \"TupleStruct(ref {}, ref {}, {:?}) = {};\",\n                     path_pat, fields_pat, skip_pos, current\n                 );\n+\n                 self.current = path_pat;\n                 self.print_qpath(path);\n+\n                 println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n-                println!(\"    // unimplemented: field checks\");\n+\n+                for (i, field) in fields.iter().enumerate() {\n+                    self.current = format!(\"{}[{}]\", fields_pat, i);\n+                    self.visit_pat(field);\n+                }\n             },\n             PatKind::Path(ref path) => {\n                 let path_pat = self.next(\"path\");\n                 println!(\"Path(ref {}) = {};\", path_pat, current);\n+\n                 self.current = path_pat;\n                 self.print_qpath(path);\n             },\n             PatKind::Tuple(fields, skip_pos) => {\n                 let fields_pat = self.next(\"fields\");\n                 println!(\"Tuple(ref {}, {:?}) = {};\", fields_pat, skip_pos, current);\n                 println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n-                println!(\"    // unimplemented: field checks\");\n+\n+                for (i, field) in fields.iter().enumerate() {\n+                    self.current = format!(\"{}[{}]\", fields_pat, i);\n+                    self.visit_pat(field);\n+                }\n             },\n             PatKind::Box(pat) => {\n                 let pat_pat = self.next(\"pat\");\n                 println!(\"Box(ref {}) = {};\", pat_pat, current);\n+\n                 self.current = pat_pat;\n                 self.visit_pat(pat);\n             },\n             PatKind::Ref(pat, muta) => {\n                 let pat_pat = self.next(\"pat\");\n                 println!(\"Ref(ref {}, Mutability::{:?}) = {};\", pat_pat, muta, current);\n+\n                 self.current = pat_pat;\n                 self.visit_pat(pat);\n             },\n             PatKind::Lit(lit_expr) => {\n                 let lit_expr_pat = self.next(\"lit_expr\");\n                 println!(\"Lit(ref {}) = {}\", lit_expr_pat, current);\n+\n                 self.current = lit_expr_pat;\n                 self.visit_expr(lit_expr);\n             },\n             PatKind::Range(ref start, ref end, end_kind) => {\n                 let start_pat = self.next(\"start\");\n                 let end_pat = self.next(\"end\");\n+\n                 println!(\n                     \"Range(ref {}, ref {}, RangeEnd::{:?}) = {};\",\n                     start_pat, end_pat, end_kind, current\n                 );\n+\n                 self.current = start_pat;\n                 walk_list!(self, visit_expr, start);\n+\n                 self.current = end_pat;\n                 walk_list!(self, visit_expr, end);\n             },\n             PatKind::Slice(start, ref middle, end) => {\n                 let start_pat = self.next(\"start\");\n                 let end_pat = self.next(\"end\");\n+\n                 if let Some(middle) = middle {\n                     let middle_pat = self.next(\"middle\");\n                     println!(\n@@ -677,12 +1016,16 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 } else {\n                     println!(\"Slice(ref {}, None, ref {}) = {};\", start_pat, end_pat, current);\n                 }\n+\n                 println!(\"    if {}.len() == {};\", start_pat, start.len());\n+\n                 for (i, pat) in start.iter().enumerate() {\n                     self.current = format!(\"{}[{}]\", start_pat, i);\n                     self.visit_pat(pat);\n                 }\n+\n                 println!(\"    if {}.len() == {};\", end_pat, end.len());\n+\n                 for (i, pat) in end.iter().enumerate() {\n                     self.current = format!(\"{}[{}]\", end_pat, i);\n                     self.visit_pat(pat);\n@@ -694,17 +1037,21 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n     fn visit_stmt(&mut self, s: &Stmt<'_>) {\n         print!(\"    if let StmtKind::\");\n         let current = format!(\"{}.kind\", self.current);\n+\n         match s.kind {\n             // A local (let) binding:\n             StmtKind::Local(local) => {\n                 let local_pat = self.next(\"local\");\n                 println!(\"Local(ref {}) = {};\", local_pat, current);\n+\n                 if let Some(init) = local.init {\n                     let init_pat = self.next(\"init\");\n                     println!(\"    if let Some(ref {}) = {}.init;\", init_pat, local_pat);\n+\n                     self.current = init_pat;\n                     self.visit_expr(init);\n                 }\n+\n                 self.current = format!(\"{}.pat\", local_pat);\n                 self.visit_pat(local.pat);\n             },\n@@ -717,6 +1064,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n             StmtKind::Expr(e) => {\n                 let e_pat = self.next(\"e\");\n                 println!(\"Expr(ref {}, _) = {}\", e_pat, current);\n+\n                 self.current = e_pat;\n                 self.visit_expr(e);\n             },\n@@ -725,6 +1073,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n             StmtKind::Semi(e) => {\n                 let e_pat = self.next(\"e\");\n                 println!(\"Semi(ref {}, _) = {}\", e_pat, current);\n+\n                 self.current = e_pat;\n                 self.visit_expr(e);\n             },"}, {"sha": "313597bf53425446e3dcac1a9ac2cd35968a27b8", "filename": "tests/ui/author.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c96cd359f532bb37865ef91d0935655a0af7e7f4/tests%2Fui%2Fauthor.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/c96cd359f532bb37865ef91d0935655a0af7e7f4/tests%2Fui%2Fauthor.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor.stdout?ref=c96cd359f532bb37865ef91d0935655a0af7e7f4", "patch": "@@ -5,7 +5,7 @@ if_chain! {\n     if let TyKind::Path(ref qp) = cast_ty.kind;\n     if match_qpath(qp, &[\"char\"]);\n     if let ExprKind::Lit(ref lit) = expr.kind;\n-    if let LitKind::Int(69, _) = lit.node;\n+    if let LitKind::Int(69, LitIntType::Unsuffixed) = lit.node;\n     if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local.pat.kind;\n     if name.as_str() == \"x\";\n     then {"}, {"sha": "a7335c01baa39447fc78dee031e852ed7b7f256c", "filename": "tests/ui/author/blocks.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c96cd359f532bb37865ef91d0935655a0af7e7f4/tests%2Fui%2Fauthor%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c96cd359f532bb37865ef91d0935655a0af7e7f4/tests%2Fui%2Fauthor%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fblocks.rs?ref=c96cd359f532bb37865ef91d0935655a0af7e7f4", "patch": "@@ -1,15 +1,24 @@\n+// edition:2018\n+\n #![allow(redundant_semicolons, clippy::no_effect)]\n+#![feature(stmt_expr_attributes)]\n+#![feature(async_closure)]\n \n #[rustfmt::skip]\n fn main() {\n     #[clippy::author]\n     {\n         let x = 42i32;\n+        let _t = 1f32;\n+\n         -x;\n     };\n     #[clippy::author]\n     {\n         let expr = String::new();\n         drop(expr)\n     };\n+\n+    #[clippy::author]\n+    async move || {};\n }"}, {"sha": "31c7fced7f7124e5bfecfa31bbc997f782f45556", "filename": "tests/ui/author/blocks.stdout", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c96cd359f532bb37865ef91d0935655a0af7e7f4/tests%2Fui%2Fauthor%2Fblocks.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/c96cd359f532bb37865ef91d0935655a0af7e7f4/tests%2Fui%2Fauthor%2Fblocks.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fblocks.stdout?ref=c96cd359f532bb37865ef91d0935655a0af7e7f4", "patch": "@@ -1,13 +1,19 @@\n if_chain! {\n-    if let ExprKind::Block(ref block) = expr.kind;\n-    if block.stmts.len() == 2;\n+    if let ExprKind::Block(ref block, ref label) = expr.kind;\n+    if block.stmts.len() == 3;\n     if let StmtKind::Local(ref local) = block.stmts[0].kind;\n     if let Some(ref init) = local.init;\n     if let ExprKind::Lit(ref lit) = init.kind;\n-    if let LitKind::Int(42, _) = lit.node;\n+    if let LitKind::Int(42, LitIntType::Signed(IntTy::I32)) = lit.node;\n     if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local.pat.kind;\n     if name.as_str() == \"x\";\n-    if let StmtKind::Semi(ref e, _) = block.stmts[1].kind\n+    if let StmtKind::Local(ref local1) = block.stmts[1].kind;\n+    if let Some(ref init1) = local1.init;\n+    if let ExprKind::Lit(ref lit1) = init1.kind;\n+    if let LitKind::Float(_, LitFloatType::Suffixed(FloatTy::F32)) = lit1.node;\n+    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name1, None) = local1.pat.kind;\n+    if name1.as_str() == \"_t\";\n+    if let StmtKind::Semi(ref e, _) = block.stmts[2].kind\n     if let ExprKind::Unary(UnOp::Neg, ref inner) = e.kind;\n     if let ExprKind::Path(ref path) = inner.kind;\n     if match_qpath(path, &[\"x\"]);\n@@ -17,7 +23,7 @@ if_chain! {\n     }\n }\n if_chain! {\n-    if let ExprKind::Block(ref block) = expr.kind;\n+    if let ExprKind::Block(ref block, ref label) = expr.kind;\n     if block.stmts.len() == 1;\n     if let StmtKind::Local(ref local) = block.stmts[0].kind;\n     if let Some(ref init) = local.init;\n@@ -38,3 +44,21 @@ if_chain! {\n         // report your lint here\n     }\n }\n+if_chain! {\n+    if let ExprKind::Closure(CaptureBy::Value, ref fn_decl, ref body_id, _, None) = expr.kind\n+    if let FnRetTy::DefaultReturn(_) = fn_decl.output\n+    let body = cx.tcx.hir().body(body_id);\n+    if let ExprKind::Call(ref func, ref args) = body.value.kind;\n+    if let ExprKind::Path(ref path) = func.kind;\n+    if matches!(path, QPath::LangItem(LangItem::FromGenerator, _));\n+    if args.len() == 1;\n+    if let ExprKind::Closure(CaptureBy::Value, ref fn_decl1, ref body_id1, _, Some(Movability::Static)) = args[0].kind\n+    if let FnRetTy::DefaultReturn(_) = fn_decl1.output\n+    let body1 = cx.tcx.hir().body(body_id1);\n+    if let ExprKind::Block(ref block, ref label) = body1.value.kind;\n+    if block.stmts.len() == 0;\n+    if block.expr.is_none();\n+    then {\n+        // report your lint here\n+    }\n+}"}, {"sha": "07958dbc356fceedf808f756cc89a936c2f1b305", "filename": "tests/ui/author/call.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c96cd359f532bb37865ef91d0935655a0af7e7f4/tests%2Fui%2Fauthor%2Fcall.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/c96cd359f532bb37865ef91d0935655a0af7e7f4/tests%2Fui%2Fauthor%2Fcall.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fcall.stdout?ref=c96cd359f532bb37865ef91d0935655a0af7e7f4", "patch": "@@ -6,9 +6,9 @@ if_chain! {\n     if match_qpath(path, &[\"{{root}}\", \"std\", \"cmp\", \"min\"]);\n     if args.len() == 2;\n     if let ExprKind::Lit(ref lit) = args[0].kind;\n-    if let LitKind::Int(3, _) = lit.node;\n+    if let LitKind::Int(3, LitIntType::Unsuffixed) = lit.node;\n     if let ExprKind::Lit(ref lit1) = args[1].kind;\n-    if let LitKind::Int(4, _) = lit1.node;\n+    if let LitKind::Int(4, LitIntType::Unsuffixed) = lit1.node;\n     if let PatKind::Wild = local.pat.kind;\n     then {\n         // report your lint here"}, {"sha": "b3dec876535c5e5e374f39baa5d6d89ba9535fad", "filename": "tests/ui/author/for_loop.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/445c83f8f36d78895c92f7f8145542b6ea6b59a8/tests%2Fui%2Fauthor%2Ffor_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/445c83f8f36d78895c92f7f8145542b6ea6b59a8/tests%2Fui%2Fauthor%2Ffor_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Ffor_loop.rs?ref=445c83f8f36d78895c92f7f8145542b6ea6b59a8", "patch": "@@ -1,8 +0,0 @@\n-#![feature(stmt_expr_attributes)]\n-\n-fn main() {\n-    #[clippy::author]\n-    for y in 0..10 {\n-        let z = y;\n-    }\n-}"}, {"sha": "f1b4d4e096ec5e18b412f04bebc8320b779e3161", "filename": "tests/ui/author/for_loop.stdout", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/445c83f8f36d78895c92f7f8145542b6ea6b59a8/tests%2Fui%2Fauthor%2Ffor_loop.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/445c83f8f36d78895c92f7f8145542b6ea6b59a8/tests%2Fui%2Fauthor%2Ffor_loop.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Ffor_loop.stdout?ref=445c83f8f36d78895c92f7f8145542b6ea6b59a8", "patch": "@@ -1,64 +0,0 @@\n-if_chain! {\n-    if let ExprKind::DropTemps(ref expr) = expr.kind;\n-    if let ExprKind::Match(ref expr1, ref arms, MatchSource::ForLoopDesugar) = expr.kind;\n-    if let ExprKind::Call(ref func, ref args) = expr1.kind;\n-    if let ExprKind::Path(ref path) = func.kind;\n-    if matches!(path, QPath::LangItem(LangItem::IntoIterIntoIter, _));\n-    if args.len() == 1;\n-    if let ExprKind::Struct(ref path1, ref fields, None) = args[0].kind;\n-    if matches!(path1, QPath::LangItem(LangItem::Range, _));\n-    if fields.len() == 2;\n-    // unimplemented: field checks\n-    if arms.len() == 1;\n-    if let ExprKind::Loop(ref body, ref label, LoopSource::ForLoop) = arms[0].body.kind;\n-    if body.stmts.len() == 4;\n-    if let StmtKind::Local(ref local) = body.stmts[0].kind;\n-    if let PatKind::Binding(BindingAnnotation::Mutable, _, name, None) = local.pat.kind;\n-    if name.as_str() == \"__next\";\n-    if let StmtKind::Expr(ref e, _) = body.stmts[1].kind\n-    if let ExprKind::Match(ref expr2, ref arms1, MatchSource::ForLoopDesugar) = e.kind;\n-    if let ExprKind::Call(ref func1, ref args1) = expr2.kind;\n-    if let ExprKind::Path(ref path2) = func1.kind;\n-    if matches!(path2, QPath::LangItem(LangItem::IteratorNext, _));\n-    if args1.len() == 1;\n-    if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Mut, ref inner) = args1[0].kind;\n-    if let ExprKind::Path(ref path3) = inner.kind;\n-    if match_qpath(path3, &[\"iter\"]);\n-    if arms1.len() == 2;\n-    if let ExprKind::Assign(ref target, ref value, ref _span) = arms1[0].body.kind;\n-    if let ExprKind::Path(ref path4) = target.kind;\n-    if match_qpath(path4, &[\"__next\"]);\n-    if let ExprKind::Path(ref path5) = value.kind;\n-    if match_qpath(path5, &[\"val\"]);\n-    if let PatKind::Struct(ref path6, ref fields1, false) = arms1[0].pat.kind;\n-    if matches!(path6, QPath::LangItem(LangItem::OptionSome, _));\n-    if fields1.len() == 1;\n-    // unimplemented: field checks\n-    if let ExprKind::Break(ref destination, None) = arms1[1].body.kind;\n-    if let PatKind::Struct(ref path7, ref fields2, false) = arms1[1].pat.kind;\n-    if matches!(path7, QPath::LangItem(LangItem::OptionNone, _));\n-    if fields2.len() == 0;\n-    // unimplemented: field checks\n-    if let StmtKind::Local(ref local1) = body.stmts[2].kind;\n-    if let Some(ref init) = local1.init;\n-    if let ExprKind::Path(ref path8) = init.kind;\n-    if match_qpath(path8, &[\"__next\"]);\n-    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name1, None) = local1.pat.kind;\n-    if name1.as_str() == \"y\";\n-    if let StmtKind::Expr(ref e1, _) = body.stmts[3].kind\n-    if let ExprKind::Block(ref block) = e1.kind;\n-    if block.stmts.len() == 1;\n-    if let StmtKind::Local(ref local2) = block.stmts[0].kind;\n-    if let Some(ref init1) = local2.init;\n-    if let ExprKind::Path(ref path9) = init1.kind;\n-    if match_qpath(path9, &[\"y\"]);\n-    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name2, None) = local2.pat.kind;\n-    if name2.as_str() == \"z\";\n-    if block.expr.is_none();\n-    if body.expr.is_none();\n-    if let PatKind::Binding(BindingAnnotation::Mutable, _, name3, None) = arms[0].pat.kind;\n-    if name3.as_str() == \"iter\";\n-    then {\n-        // report your lint here\n-    }\n-}"}, {"sha": "946088ab34619667e9c6e676f47b5839fd0e2944", "filename": "tests/ui/author/if.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c96cd359f532bb37865ef91d0935655a0af7e7f4/tests%2Fui%2Fauthor%2Fif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c96cd359f532bb37865ef91d0935655a0af7e7f4/tests%2Fui%2Fauthor%2Fif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fif.rs?ref=c96cd359f532bb37865ef91d0935655a0af7e7f4", "patch": "@@ -7,4 +7,11 @@ fn main() {\n     } else {\n         2 == 2;\n     };\n+\n+    let a = true;\n+\n+    #[clippy::author]\n+    if let true = a {\n+    } else {\n+    };\n }"}, {"sha": "7e72a5480115163c4fa2f4eb395e8e699aeaa294", "filename": "tests/ui/author/if.stdout", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c96cd359f532bb37865ef91d0935655a0af7e7f4/tests%2Fui%2Fauthor%2Fif.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/c96cd359f532bb37865ef91d0935655a0af7e7f4/tests%2Fui%2Fauthor%2Fif.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fif.stdout?ref=c96cd359f532bb37865ef91d0935655a0af7e7f4", "patch": "@@ -1,32 +1,48 @@\n if_chain! {\n     if let StmtKind::Local(ref local) = stmt.kind;\n     if let Some(ref init) = local.init;\n-    if let ExprKind::If(ref cond, ref then, Some(ref else_)) = init.kind;\n-    if let ExprKind::Block(ref block) = else_.kind;\n+    if let Some(higher::If { cond: cond, then: then, r#else: else_expr}) = higher::If::hir(init)\n+    if let ExprKind::Lit(ref lit) = cond.kind;\n+    if let LitKind::Bool(true) = lit.node;\n+    if let ExprKind::Block(ref block, ref label) = then.kind;\n     if block.stmts.len() == 1;\n     if let StmtKind::Semi(ref e, _) = block.stmts[0].kind\n     if let ExprKind::Binary(ref op, ref left, ref right) = e.kind;\n     if BinOpKind::Eq == op.node;\n-    if let ExprKind::Lit(ref lit) = left.kind;\n-    if let LitKind::Int(2, _) = lit.node;\n-    if let ExprKind::Lit(ref lit1) = right.kind;\n-    if let LitKind::Int(2, _) = lit1.node;\n+    if let ExprKind::Lit(ref lit1) = left.kind;\n+    if let LitKind::Int(1, LitIntType::Unsuffixed) = lit1.node;\n+    if let ExprKind::Lit(ref lit2) = right.kind;\n+    if let LitKind::Int(1, LitIntType::Unsuffixed) = lit2.node;\n     if block.expr.is_none();\n-    if let ExprKind::DropTemps(ref expr) = cond.kind;\n-    if let ExprKind::Lit(ref lit2) = expr.kind;\n-    if let LitKind::Bool(true) = lit2.node;\n-    if let ExprKind::Block(ref block1) = then.kind;\n+    if let ExprKind::Block(ref block1, ref label1) = else_expr.kind;\n     if block1.stmts.len() == 1;\n     if let StmtKind::Semi(ref e1, _) = block1.stmts[0].kind\n     if let ExprKind::Binary(ref op1, ref left1, ref right1) = e1.kind;\n     if BinOpKind::Eq == op1.node;\n     if let ExprKind::Lit(ref lit3) = left1.kind;\n-    if let LitKind::Int(1, _) = lit3.node;\n+    if let LitKind::Int(2, LitIntType::Unsuffixed) = lit3.node;\n     if let ExprKind::Lit(ref lit4) = right1.kind;\n-    if let LitKind::Int(1, _) = lit4.node;\n+    if let LitKind::Int(2, LitIntType::Unsuffixed) = lit4.node;\n     if block1.expr.is_none();\n     if let PatKind::Wild = local.pat.kind;\n     then {\n         // report your lint here\n     }\n }\n+if_chain! {\n+    if let Some(higher::IfLet { let_pat: let_pat, let_expr: let_expr, if_then: if_then, if_else: else_expr}) = higher::IfLet::hir(expr)\n+    if let PatKind::Lit(ref lit_expr) = let_pat.kind\n+    if let ExprKind::Lit(ref lit) = lit_expr.kind;\n+    if let LitKind::Bool(true) = lit.node;\n+    if let ExprKind::Path(ref path) = let_expr.kind;\n+    if match_qpath(path, &[\"a\"]);\n+    if let ExprKind::Block(ref block, ref label) = if_then.kind;\n+    if block.stmts.len() == 0;\n+    if block.expr.is_none();\n+    if let ExprKind::Block(ref block1, ref label1) = else_expr.kind;\n+    if block1.stmts.len() == 0;\n+    if block1.expr.is_none();\n+    then {\n+        // report your lint here\n+    }\n+}"}, {"sha": "d6de21631e2bae64b9eff6c0d8ca57ac50942a71", "filename": "tests/ui/author/loop.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c96cd359f532bb37865ef91d0935655a0af7e7f4/tests%2Fui%2Fauthor%2Floop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c96cd359f532bb37865ef91d0935655a0af7e7f4/tests%2Fui%2Fauthor%2Floop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Floop.rs?ref=c96cd359f532bb37865ef91d0935655a0af7e7f4", "patch": "@@ -0,0 +1,36 @@\n+#![feature(stmt_expr_attributes)]\n+#![allow(clippy::never_loop, clippy::while_immutable_condition)]\n+\n+fn main() {\n+    #[clippy::author]\n+    for y in 0..10 {\n+        let z = y;\n+    }\n+\n+    #[clippy::author]\n+    for _ in 0..10 {\n+        break;\n+    }\n+\n+    #[clippy::author]\n+    'label: for _ in 0..10 {\n+        break 'label;\n+    }\n+\n+    let a = true;\n+\n+    #[clippy::author]\n+    while a {\n+        break;\n+    }\n+\n+    #[clippy::author]\n+    while let true = a {\n+        break;\n+    }\n+\n+    #[clippy::author]\n+    loop {\n+        break;\n+    }\n+}"}, {"sha": "fa146f034952076c5c0c302661329dffbfc3c87a", "filename": "tests/ui/author/loop.stdout", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/c96cd359f532bb37865ef91d0935655a0af7e7f4/tests%2Fui%2Fauthor%2Floop.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/c96cd359f532bb37865ef91d0935655a0af7e7f4/tests%2Fui%2Fauthor%2Floop.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Floop.stdout?ref=c96cd359f532bb37865ef91d0935655a0af7e7f4", "patch": "@@ -0,0 +1,112 @@\n+if_chain! {\n+    if let ExprKind::DropTemps(ref expr) = expr.kind;\n+    if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, ..}) = higher::ForLoop::hir(expr)\n+    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = pat.kind;\n+    if name.as_str() == \"y\";\n+    if let ExprKind::Struct(ref path, ref fields, None) = arg.kind;\n+    if matches!(path, QPath::LangItem(LangItem::Range, _));\n+    if fields.len() == 2;\n+    if fields[0].ident.name.as_str() == \"start\"\n+    if let ExprKind::Lit(ref lit) = fields[0].kind;\n+    if let LitKind::Int(0, LitIntType::Unsuffixed) = lit.node;\n+    if fields[1].ident.name.as_str() == \"end\"\n+    if let ExprKind::Lit(ref lit1) = fields[1].kind;\n+    if let LitKind::Int(10, LitIntType::Unsuffixed) = lit1.node;\n+    if let ExprKind::Block(ref block, ref label) = body.kind;\n+    if block.stmts.len() == 1;\n+    if let StmtKind::Local(ref local) = block.stmts[0].kind;\n+    if let Some(ref init) = local.init;\n+    if let ExprKind::Path(ref path1) = init.kind;\n+    if match_qpath(path1, &[\"y\"]);\n+    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name1, None) = local.pat.kind;\n+    if name1.as_str() == \"z\";\n+    if block.expr.is_none();\n+    then {\n+        // report your lint here\n+    }\n+}\n+if_chain! {\n+    if let ExprKind::DropTemps(ref expr) = expr.kind;\n+    if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, ..}) = higher::ForLoop::hir(expr)\n+    if let PatKind::Wild = pat.kind;\n+    if let ExprKind::Struct(ref path, ref fields, None) = arg.kind;\n+    if matches!(path, QPath::LangItem(LangItem::Range, _));\n+    if fields.len() == 2;\n+    if fields[0].ident.name.as_str() == \"start\"\n+    if let ExprKind::Lit(ref lit) = fields[0].kind;\n+    if let LitKind::Int(0, LitIntType::Unsuffixed) = lit.node;\n+    if fields[1].ident.name.as_str() == \"end\"\n+    if let ExprKind::Lit(ref lit1) = fields[1].kind;\n+    if let LitKind::Int(10, LitIntType::Unsuffixed) = lit1.node;\n+    if let ExprKind::Block(ref block, ref label) = body.kind;\n+    if block.stmts.len() == 1;\n+    if let StmtKind::Semi(ref e, _) = block.stmts[0].kind\n+    if let ExprKind::Break(ref destination, None) = e.kind;\n+    if block.expr.is_none();\n+    then {\n+        // report your lint here\n+    }\n+}\n+if_chain! {\n+    if let ExprKind::DropTemps(ref expr) = expr.kind;\n+    if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, ..}) = higher::ForLoop::hir(expr)\n+    if let PatKind::Wild = pat.kind;\n+    if let ExprKind::Struct(ref path, ref fields, None) = arg.kind;\n+    if matches!(path, QPath::LangItem(LangItem::Range, _));\n+    if fields.len() == 2;\n+    if fields[0].ident.name.as_str() == \"start\"\n+    if let ExprKind::Lit(ref lit) = fields[0].kind;\n+    if let LitKind::Int(0, LitIntType::Unsuffixed) = lit.node;\n+    if fields[1].ident.name.as_str() == \"end\"\n+    if let ExprKind::Lit(ref lit1) = fields[1].kind;\n+    if let LitKind::Int(10, LitIntType::Unsuffixed) = lit1.node;\n+    if let ExprKind::Block(ref block, ref label) = body.kind;\n+    if block.stmts.len() == 1;\n+    if let StmtKind::Semi(ref e, _) = block.stmts[0].kind\n+    if let ExprKind::Break(ref destination, None) = e.kind;\n+    if let Some(ref label1) = destination.label\n+    if label_name.ident.name.as_str() == \"'label\";\n+    if block.expr.is_none();\n+    then {\n+        // report your lint here\n+    }\n+}\n+if_chain! {\n+    if let Some(higher::While { condition: condition, body: body }) = higher::While::hir(expr)\n+    if let ExprKind::Path(ref path) = condition.kind;\n+    if match_qpath(path, &[\"a\"]);\n+    if let ExprKind::Block(ref block, ref label) = body.kind;\n+    if block.stmts.len() == 1;\n+    if let StmtKind::Semi(ref e, _) = block.stmts[0].kind\n+    if let ExprKind::Break(ref destination, None) = e.kind;\n+    if block.expr.is_none();\n+    then {\n+        // report your lint here\n+    }\n+}\n+if_chain! {\n+    if let Some(higher::WhileLet { let_pat: let_pat, let_expr: let_expr, if_then: if_then }) = higher::WhileLet::hir(expr)\n+    if let PatKind::Lit(ref lit_expr) = let_pat.kind\n+    if let ExprKind::Lit(ref lit) = lit_expr.kind;\n+    if let LitKind::Bool(true) = lit.node;\n+    if let ExprKind::Path(ref path) = let_expr.kind;\n+    if match_qpath(path, &[\"a\"]);\n+    if let ExprKind::Block(ref block, ref label) = if_then.kind;\n+    if block.stmts.len() == 1;\n+    if let StmtKind::Semi(ref e, _) = block.stmts[0].kind\n+    if let ExprKind::Break(ref destination, None) = e.kind;\n+    if block.expr.is_none();\n+    then {\n+        // report your lint here\n+    }\n+}\n+if_chain! {\n+    if let ExprKind::Loop(ref body, ref label, LoopSource::Loop) = expr.kind;\n+    if body.stmts.len() == 1;\n+    if let StmtKind::Semi(ref e, _) = body.stmts[0].kind\n+    if let ExprKind::Break(ref destination, None) = e.kind;\n+    if body.expr.is_none();\n+    then {\n+        // report your lint here\n+    }\n+}"}, {"sha": "3be61fe3772b7eabd9ec2640e396f573b2e767e7", "filename": "tests/ui/author/matches.stdout", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c96cd359f532bb37865ef91d0935655a0af7e7f4/tests%2Fui%2Fauthor%2Fmatches.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/c96cd359f532bb37865ef91d0935655a0af7e7f4/tests%2Fui%2Fauthor%2Fmatches.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fmatches.stdout?ref=c96cd359f532bb37865ef91d0935655a0af7e7f4", "patch": "@@ -3,29 +3,29 @@ if_chain! {\n     if let Some(ref init) = local.init;\n     if let ExprKind::Match(ref expr, ref arms, MatchSource::Normal) = init.kind;\n     if let ExprKind::Lit(ref lit) = expr.kind;\n-    if let LitKind::Int(42, _) = lit.node;\n+    if let LitKind::Int(42, LitIntType::Unsuffixed) = lit.node;\n     if arms.len() == 3;\n     if let ExprKind::Lit(ref lit1) = arms[0].body.kind;\n-    if let LitKind::Int(5, _) = lit1.node;\n+    if let LitKind::Int(5, LitIntType::Unsuffixed) = lit1.node;\n     if let PatKind::Lit(ref lit_expr) = arms[0].pat.kind\n     if let ExprKind::Lit(ref lit2) = lit_expr.kind;\n-    if let LitKind::Int(16, _) = lit2.node;\n-    if let ExprKind::Block(ref block) = arms[1].body.kind;\n+    if let LitKind::Int(16, LitIntType::Unsuffixed) = lit2.node;\n+    if let ExprKind::Block(ref block, ref label) = arms[1].body.kind;\n     if block.stmts.len() == 1;\n     if let StmtKind::Local(ref local1) = block.stmts[0].kind;\n     if let Some(ref init1) = local1.init;\n     if let ExprKind::Lit(ref lit3) = init1.kind;\n-    if let LitKind::Int(3, _) = lit3.node;\n+    if let LitKind::Int(3, LitIntType::Unsuffixed) = lit3.node;\n     if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local1.pat.kind;\n     if name.as_str() == \"x\";\n     if let Some(trailing_expr) = &block.expr;\n     if let ExprKind::Path(ref path) = trailing_expr.kind;\n     if match_qpath(path, &[\"x\"]);\n     if let PatKind::Lit(ref lit_expr1) = arms[1].pat.kind\n     if let ExprKind::Lit(ref lit4) = lit_expr1.kind;\n-    if let LitKind::Int(17, _) = lit4.node;\n+    if let LitKind::Int(17, LitIntType::Unsuffixed) = lit4.node;\n     if let ExprKind::Lit(ref lit5) = arms[2].body.kind;\n-    if let LitKind::Int(1, _) = lit5.node;\n+    if let LitKind::Int(1, LitIntType::Unsuffixed) = lit5.node;\n     if let PatKind::Wild = arms[2].pat.kind;\n     if let PatKind::Binding(BindingAnnotation::Unannotated, _, name1, None) = local.pat.kind;\n     if name1.as_str() == \"a\";"}, {"sha": "d8e9d589e689e4f305cdedd186c2053594b97e4b", "filename": "tests/ui/author/repeat.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c96cd359f532bb37865ef91d0935655a0af7e7f4/tests%2Fui%2Fauthor%2Frepeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c96cd359f532bb37865ef91d0935655a0af7e7f4/tests%2Fui%2Fauthor%2Frepeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Frepeat.rs?ref=c96cd359f532bb37865ef91d0935655a0af7e7f4", "patch": "@@ -0,0 +1,5 @@\n+#[allow(clippy::no_effect)]\n+fn main() {\n+    #[clippy::author]\n+    [1_u8; 5];\n+}"}, {"sha": "9ff376373e63a5c4fdb6cdb0bc8e1b3940981292", "filename": "tests/ui/author/repeat.stdout", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c96cd359f532bb37865ef91d0935655a0af7e7f4/tests%2Fui%2Fauthor%2Frepeat.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/c96cd359f532bb37865ef91d0935655a0af7e7f4/tests%2Fui%2Fauthor%2Frepeat.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Frepeat.stdout?ref=c96cd359f532bb37865ef91d0935655a0af7e7f4", "patch": "@@ -0,0 +1,10 @@\n+if_chain! {\n+    if let ExprKind::Repeat(ref value, ref length) = expr.kind;\n+    if let ExprKind::Lit(ref lit) = value.kind;\n+    if let LitKind::Int(1, LitIntType::Unsigned(UintTy::U8)) = lit.node;\n+    if let ExprKind::Lit(ref lit1) = length.value.kind;\n+    if let LitKind::Int(5, LitIntType::Unsuffixed) = lit1.node;\n+    then {\n+        // report your lint here\n+    }\n+}"}, {"sha": "5fdf3433a3702de7b324580e6fd4b8f386403914", "filename": "tests/ui/author/struct.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c96cd359f532bb37865ef91d0935655a0af7e7f4/tests%2Fui%2Fauthor%2Fstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c96cd359f532bb37865ef91d0935655a0af7e7f4/tests%2Fui%2Fauthor%2Fstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fstruct.rs?ref=c96cd359f532bb37865ef91d0935655a0af7e7f4", "patch": "@@ -0,0 +1,40 @@\n+#[allow(clippy::unnecessary_operation, clippy::single_match)]\n+fn main() {\n+    struct Test {\n+        field: u32,\n+    }\n+\n+    #[clippy::author]\n+    Test {\n+        field: if true { 1 } else { 0 },\n+    };\n+\n+    let test = Test { field: 1 };\n+\n+    match test {\n+        #[clippy::author]\n+        Test { field: 1 } => {},\n+        _ => {},\n+    }\n+\n+    struct TestTuple(u32);\n+\n+    let test_tuple = TestTuple(1);\n+\n+    match test_tuple {\n+        #[clippy::author]\n+        TestTuple(1) => {},\n+        _ => {},\n+    }\n+\n+    struct TestMethodCall(u32);\n+\n+    impl TestMethodCall {\n+        fn test(&self) {}\n+    }\n+\n+    let test_method_call = TestMethodCall(1);\n+\n+    #[clippy::author]\n+    test_method_call.test();\n+}"}, {"sha": "98055d73779c0b4f04dddfbf611ab2cef5a2b758", "filename": "tests/ui/author/struct.stdout", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c96cd359f532bb37865ef91d0935655a0af7e7f4/tests%2Fui%2Fauthor%2Fstruct.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/c96cd359f532bb37865ef91d0935655a0af7e7f4/tests%2Fui%2Fauthor%2Fstruct.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fstruct.stdout?ref=c96cd359f532bb37865ef91d0935655a0af7e7f4", "patch": "@@ -0,0 +1,61 @@\n+if_chain! {\n+    if let ExprKind::Struct(ref path, ref fields, None) = expr.kind;\n+    if match_qpath(path, &[\"Test\"]);\n+    if fields.len() == 1;\n+    if fields[0].ident.name.as_str() == \"field\"\n+    if let Some(higher::If { cond: cond, then: then, r#else: else_expr}) = higher::If::hir(fields[0])\n+    if let ExprKind::Lit(ref lit) = cond.kind;\n+    if let LitKind::Bool(true) = lit.node;\n+    if let ExprKind::Block(ref block, ref label) = then.kind;\n+    if block.stmts.len() == 0;\n+    if let Some(trailing_expr) = &block.expr;\n+    if let ExprKind::Lit(ref lit1) = trailing_expr.kind;\n+    if let LitKind::Int(1, LitIntType::Unsuffixed) = lit1.node;\n+    if let ExprKind::Block(ref block1, ref label1) = else_expr.kind;\n+    if block1.stmts.len() == 0;\n+    if let Some(trailing_expr1) = &block1.expr;\n+    if let ExprKind::Lit(ref lit2) = trailing_expr1.kind;\n+    if let LitKind::Int(0, LitIntType::Unsuffixed) = lit2.node;\n+    then {\n+        // report your lint here\n+    }\n+}\n+if_chain! {\n+    if let PatKind::Struct(ref path, ref fields, false) = arm.kind;\n+    if match_qpath(path, &[\"Test\"]);\n+    if fields.len() == 1;\n+    if fields[0].ident.name.as_str() == \"field\"\n+    if let PatKind::Lit(ref lit_expr) = fields[0].kind\n+    if let ExprKind::Lit(ref lit) = lit_expr.kind;\n+    if let LitKind::Int(1, LitIntType::Unsuffixed) = lit.node;\n+    if let ExprKind::Block(ref block, ref label) = lit_expr.kind;\n+    if block.stmts.len() == 0;\n+    if block.expr.is_none();\n+    then {\n+        // report your lint here\n+    }\n+}\n+if_chain! {\n+    if let PatKind::TupleStruct(ref path, ref fields, None) = arm.kind;\n+    if match_qpath(path, &[\"TestTuple\"]);\n+    if fields.len() == 1;\n+    if let PatKind::Lit(ref lit_expr) = fields[0].kind\n+    if let ExprKind::Lit(ref lit) = lit_expr.kind;\n+    if let LitKind::Int(1, LitIntType::Unsuffixed) = lit.node;\n+    if let ExprKind::Block(ref block, ref label) = lit_expr.kind;\n+    if block.stmts.len() == 0;\n+    if block.expr.is_none();\n+    then {\n+        // report your lint here\n+    }\n+}\n+if_chain! {\n+    if let ExprKind::MethodCall(ref method_name, ref args, _) = expr.kind;\n+    if method_name.ident.name.as_str() == test;\n+    if args.len() == 1;\n+    if let ExprKind::Path(ref path) = args[0].kind;\n+    if match_qpath(path, &[\"test_method_call\"]);\n+    then {\n+        // report your lint here\n+    }\n+}"}]}