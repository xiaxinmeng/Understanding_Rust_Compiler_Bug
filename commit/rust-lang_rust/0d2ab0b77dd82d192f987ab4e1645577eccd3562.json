{"sha": "0d2ab0b77dd82d192f987ab4e1645577eccd3562", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkMmFiMGI3N2RkODJkMTkyZjk4N2FiNGUxNjQ1NTc3ZWNjZDM1NjI=", "commit": {"author": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2019-02-06T16:58:45Z"}, "committer": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2019-02-06T17:54:55Z"}, "message": "SGX target: simplify usercall internals\n\nThis moves logic from assembly to Rust and removes the special\ncase for exit/panic handling, merging it with regular usercall\nhandling.\n\nAlso, this fixes a bug in the exit usercall introduced in a75ae00.\nThe bug would make regular exits look like panics with high\nprobability. It would also with some probability leak information\nthrough uncleared registers.", "tree": {"sha": "a774b680b8d2e703eee44c2af9ba6de634c180af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a774b680b8d2e703eee44c2af9ba6de634c180af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d2ab0b77dd82d192f987ab4e1645577eccd3562", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d2ab0b77dd82d192f987ab4e1645577eccd3562", "html_url": "https://github.com/rust-lang/rust/commit/0d2ab0b77dd82d192f987ab4e1645577eccd3562", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d2ab0b77dd82d192f987ab4e1645577eccd3562/comments", "author": null, "committer": null, "parents": [{"sha": "4b1e39b7b36d677803e40130ea29ee6d300abf6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b1e39b7b36d677803e40130ea29ee6d300abf6e", "html_url": "https://github.com/rust-lang/rust/commit/4b1e39b7b36d677803e40130ea29ee6d300abf6e"}], "stats": {"total": 143, "additions": 59, "deletions": 84}, "files": [{"sha": "d1cf087c35563963a9446d31a763a46c8975832e", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d2ab0b77dd82d192f987ab4e1645577eccd3562/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d2ab0b77dd82d192f987ab4e1645577eccd3562/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=0d2ab0b77dd82d192f987ab4e1645577eccd3562", "patch": "@@ -343,9 +343,6 @@ extern crate backtrace_sys;\n #[cfg(test)] extern crate std as realstd;\n \n #[cfg(all(target_vendor = \"fortanix\", target_env = \"sgx\"))]\n-#[macro_use]\n-#[allow(unused_imports)] // FIXME: without `#[macro_use]`, get error: \u201ccannot\n-                         // determine resolution for the macro `usercalls_asm`\u201d\n extern crate fortanix_sgx_abi;\n \n // The standard macros that are not built-in to the compiler."}, {"sha": "c03e3869aa3c87a09db7b761bd643ea926c0ffcf", "filename": "src/libstd/sys/sgx/abi/entry.S", "status": "modified", "additions": 17, "deletions": 38, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/0d2ab0b77dd82d192f987ab4e1645577eccd3562/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fentry.S", "raw_url": "https://github.com/rust-lang/rust/raw/0d2ab0b77dd82d192f987ab4e1645577eccd3562/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fentry.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fentry.S?ref=0d2ab0b77dd82d192f987ab4e1645577eccd3562", "patch": "@@ -69,10 +69,6 @@ IMAGE_BASE:\n     .asciz \"Re-entered aborted enclave!\"\n .Lreentry_panic_msg_end:\n \n-.Lusercall_panic_msg:\n-    .asciz \"Invalid usercall#!\"\n-.Lusercall_panic_msg_end:\n-\n .org .Lxsave_clear+512\n .Lxsave_header:\n     .int 0, 0 /*  XSTATE_BV */\n@@ -219,13 +215,21 @@ sgx_entry:\n     orq $8,%rsp\n     jmp panic_msg\n \n-.Lusercall_panic:\n-    lea .Lusercall_panic_msg(%rip),%rdi\n-    mov $.Lusercall_panic_msg_end-.Lusercall_panic_msg,%esi\n-    orq $8,%rsp\n-    jmp panic_msg\n-\n-.macro push_callee_saved_registers\n+/*  This *MUST* be called with 6 parameters, otherwise register information */\n+/*  might leak! */\n+.global usercall\n+usercall:\n+    test %rcx,%rcx            /* check `abort` function argument */\n+    jnz .Lusercall_abort      /* abort is set, jump to abort code (unlikely forward conditional) */\n+    jmp .Lusercall_save_state /* non-aborting usercall */\n+.Lusercall_abort:\n+/* set aborted bit */\n+    movb $1,.Laborted(%rip)\n+/* save registers in DEBUG mode, so that debugger can reconstruct the stack */\n+    testb $0xff,DEBUG(%rip)\n+    jz .Lusercall_noreturn\n+.Lusercall_save_state:\n+/*  save callee-saved state */\n     push %r15\n     push %r14\n     push %r13\n@@ -235,33 +239,8 @@ sgx_entry:\n     sub $8, %rsp\n     fstcw 4(%rsp)\n     stmxcsr (%rsp)\n-.endm\n-\n-.global usercall_exit\n-usercall_exit:\n-/* save registers in DEBUG mode, so that debugger can reconstruct the stack */\n-    testb $0xff,DEBUG(%rip)\n-    jz .Lskip_save_registers\n-    push_callee_saved_registers\n-    movq %rsp,%gs:tcsls_panic_last_rsp\n-.Lskip_save_registers:\n-/* set aborted bit */\n-    movb $1,.Laborted(%rip)\n-/* call usercall exit(true) */\n-    /* NOP: mov %rsi,%rsi */ /*  RSI = usercall() argument: panic */\n-    xor %rdx,%rdx /*  RDX cleared */\n-    movq $usercall_nr_exit,%rdi /*  RDI = usercall exit */\n-    jmp .Lexit\n-\n-/*  This *MUST* be called with 6 parameters, otherwise register information */\n-/*  might leak! */\n-.global usercall\n-usercall:\n-    test %rdi,%rdi\n-    jle .Lusercall_panic\n-/*  save callee-saved state */\n-    push_callee_saved_registers\n     movq %rsp,%gs:tcsls_last_rsp\n+.Lusercall_noreturn:\n /*  clear general purpose register state */\n     /*  RAX overwritten by ENCLU */\n     /*  RBX set by sgx_exit */\n@@ -281,7 +260,7 @@ usercall:\n     jmp .Lsgx_exit\n .Lusercall_ret:\n     movq $0,%gs:tcsls_last_rsp\n-/*  restore callee-saved state, cf. push_callee_saved_registers */\n+/*  restore callee-saved state, cf. \"save\" above */\n     mov %r11,%rsp\n     ldmxcsr (%rsp)\n     fldcw 4(%rsp)"}, {"sha": "509a1990d978b46ba7f533c649f958f268f99049", "filename": "src/libstd/sys/sgx/abi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d2ab0b77dd82d192f987ab4e1645577eccd3562/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d2ab0b77dd82d192f987ab4e1645577eccd3562/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs?ref=0d2ab0b77dd82d192f987ab4e1645577eccd3562", "patch": "@@ -12,7 +12,7 @@ pub mod tls;\n #[macro_use]\n pub mod usercalls;\n \n-global_asm!(concat!(usercalls_asm!(), include_str!(\"entry.S\")));\n+global_asm!(include_str!(\"entry.S\"));\n \n #[no_mangle]\n unsafe extern \"C\" fn tcs_init(secondary: bool) {"}, {"sha": "b2afacc70b82e504a5925675d12d1473eff03a57", "filename": "src/libstd/sys/sgx/abi/panic.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d2ab0b77dd82d192f987ab4e1645577eccd3562/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d2ab0b77dd82d192f987ab4e1645577eccd3562/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fpanic.rs?ref=0d2ab0b77dd82d192f987ab4e1645577eccd3562", "patch": "@@ -1,4 +1,4 @@\n-use super::usercalls::alloc::UserRef;\n+use super::usercalls::{alloc::UserRef, self};\n use cmp;\n use io::{self, Write};\n use mem;\n@@ -52,7 +52,5 @@ impl Write for SgxPanicOutput {\n #[no_mangle]\n pub extern \"C\" fn panic_msg(msg: &str) -> ! {\n     let _ = SgxPanicOutput::new().map(|mut out| out.write(msg.as_bytes()));\n-    unsafe { usercall_exit(true); }\n+    usercalls::exit(true)\n }\n-\n-extern \"C\" { pub fn usercall_exit(panic: bool) -> !; }"}, {"sha": "511d6e9e9273ab870cfbf9ca839438b49c9830a4", "filename": "src/libstd/sys/sgx/abi/usercalls/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d2ab0b77dd82d192f987ab4e1645577eccd3562/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d2ab0b77dd82d192f987ab4e1645577eccd3562/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs?ref=0d2ab0b77dd82d192f987ab4e1645577eccd3562", "patch": "@@ -120,7 +120,7 @@ pub unsafe fn launch_thread() -> IoResult<()> {\n /// Usercall `exit`. See the ABI documentation for more information.\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn exit(panic: bool) -> ! {\n-    unsafe { super::panic::usercall_exit(panic) }\n+    unsafe { raw::exit(panic) }\n }\n \n /// Usercall `wait`. See the ABI documentation for more information."}, {"sha": "0776382d3c16bca1bdf1cdffd56a713188746194", "filename": "src/libstd/sys/sgx/abi/usercalls/raw.rs", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/0d2ab0b77dd82d192f987ab4e1645577eccd3562/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d2ab0b77dd82d192f987ab4e1645577eccd3562/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs?ref=0d2ab0b77dd82d192f987ab4e1645577eccd3562", "patch": "@@ -4,12 +4,13 @@\n pub use fortanix_sgx_abi::*;\n \n use ptr::NonNull;\n+use num::NonZeroU64;\n \n #[repr(C)]\n struct UsercallReturn(u64, u64);\n \n extern \"C\" {\n-    fn usercall(nr: u64, p1: u64, p2: u64, _ignore: u64, p3: u64, p4: u64) -> UsercallReturn;\n+    fn usercall(nr: NonZeroU64, p1: u64, p2: u64, abort: u64, p3: u64, p4: u64) -> UsercallReturn;\n }\n \n /// Perform the raw usercall operation as defined in the ABI calling convention.\n@@ -21,9 +22,11 @@ extern \"C\" {\n /// # Panics\n /// Panics if `nr` is 0.\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n-pub unsafe fn do_usercall(nr: u64, p1: u64, p2: u64, p3: u64, p4: u64) -> (u64, u64) {\n-    if nr==0 { panic!(\"Invalid usercall number {}\",nr) }\n-    let UsercallReturn(a, b) = usercall(nr,p1,p2,0,p3,p4);\n+#[inline]\n+pub unsafe fn do_usercall(nr: NonZeroU64, p1: u64, p2: u64, p3: u64, p4: u64, abort: bool)\n+    -> (u64, u64)\n+{\n+    let UsercallReturn(a, b) = usercall(nr, p1, p2, abort as _, p3, p4);\n     (a, b)\n }\n \n@@ -39,7 +42,6 @@ trait ReturnValue {\n }\n \n macro_rules! define_usercalls {\n-    // Using `$r:tt` because `$r:ty` doesn't match ! in `clobber_diverging`\n     ($(fn $f:ident($($n:ident: $t:ty),*) $(-> $r:tt)*; )*) => {\n         /// Usercall numbers as per the ABI.\n         #[repr(u64)]\n@@ -57,22 +59,6 @@ macro_rules! define_usercalls {\n     };\n }\n \n-macro_rules! define_usercalls_asm {\n-    ($(fn $f:ident($($n:ident: $t:ty),*) $(-> $r:ty)*; )*) => {\n-        macro_rules! usercalls_asm {\n-            () => {\n-                concat!(\n-                    \".equ usercall_nr_LAST, 0\\n\",\n-                    $(\n-                    \".equ usercall_nr_\", stringify!($f), \", usercall_nr_LAST+1\\n\",\n-                    \".equ usercall_nr_LAST, usercall_nr_\", stringify!($f), \"\\n\"\n-                    ),*\n-                )\n-            }\n-        }\n-    };\n-}\n-\n macro_rules! define_ra {\n     (< $i:ident > $t:ty) => {\n         impl<$i> RegisterArgument for $t {\n@@ -171,74 +157,90 @@ impl<T: RegisterArgument, U: RegisterArgument> ReturnValue for (T, U) {\n     }\n }\n \n+macro_rules! return_type_is_abort {\n+    (!) => { true };\n+    ($r:ty) => { false };\n+}\n+\n+// In this macro: using `$r:tt` because `$r:ty` doesn't match ! in `return_type_is_abort`\n macro_rules! enclave_usercalls_internal_define_usercalls {\n     (def fn $f:ident($n1:ident: $t1:ty, $n2:ident: $t2:ty,\n-                     $n3:ident: $t3:ty, $n4:ident: $t4:ty) -> $r:ty) => (\n+                     $n3:ident: $t3:ty, $n4:ident: $t4:ty) -> $r:tt) => (\n         /// This is the raw function definition, see the ABI documentation for\n         /// more information.\n         #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n         #[inline(always)]\n         pub unsafe fn $f($n1: $t1, $n2: $t2, $n3: $t3, $n4: $t4) -> $r {\n             ReturnValue::from_registers(stringify!($f), do_usercall(\n-                Usercalls::$f as Register,\n+                NonZeroU64::new(Usercalls::$f as Register)\n+                    .expect(\"Usercall number must be non-zero\"),\n                 RegisterArgument::into_register($n1),\n                 RegisterArgument::into_register($n2),\n                 RegisterArgument::into_register($n3),\n                 RegisterArgument::into_register($n4),\n+                return_type_is_abort!($r)\n             ))\n         }\n     );\n-    (def fn $f:ident($n1:ident: $t1:ty, $n2:ident: $t2:ty, $n3:ident: $t3:ty) -> $r:ty) => (\n+    (def fn $f:ident($n1:ident: $t1:ty, $n2:ident: $t2:ty, $n3:ident: $t3:ty) -> $r:tt) => (\n         /// This is the raw function definition, see the ABI documentation for\n         /// more information.\n         #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n         #[inline(always)]\n         pub unsafe fn $f($n1: $t1, $n2: $t2, $n3: $t3) -> $r {\n             ReturnValue::from_registers(stringify!($f), do_usercall(\n-                Usercalls::$f as Register,\n+                NonZeroU64::new(Usercalls::$f as Register)\n+                    .expect(\"Usercall number must be non-zero\"),\n                 RegisterArgument::into_register($n1),\n                 RegisterArgument::into_register($n2),\n                 RegisterArgument::into_register($n3),\n-                0\n+                0,\n+                return_type_is_abort!($r)\n             ))\n         }\n     );\n-    (def fn $f:ident($n1:ident: $t1:ty, $n2:ident: $t2:ty) -> $r:ty) => (\n+    (def fn $f:ident($n1:ident: $t1:ty, $n2:ident: $t2:ty) -> $r:tt) => (\n         /// This is the raw function definition, see the ABI documentation for\n         /// more information.\n         #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n         #[inline(always)]\n         pub unsafe fn $f($n1: $t1, $n2: $t2) -> $r {\n             ReturnValue::from_registers(stringify!($f), do_usercall(\n-                Usercalls::$f as Register,\n+                NonZeroU64::new(Usercalls::$f as Register)\n+                    .expect(\"Usercall number must be non-zero\"),\n                 RegisterArgument::into_register($n1),\n                 RegisterArgument::into_register($n2),\n-                0,0\n+                0,0,\n+                return_type_is_abort!($r)\n             ))\n         }\n     );\n-    (def fn $f:ident($n1:ident: $t1:ty) -> $r:ty) => (\n+    (def fn $f:ident($n1:ident: $t1:ty) -> $r:tt) => (\n         /// This is the raw function definition, see the ABI documentation for\n         /// more information.\n         #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n         #[inline(always)]\n         pub unsafe fn $f($n1: $t1) -> $r {\n             ReturnValue::from_registers(stringify!($f), do_usercall(\n-                Usercalls::$f as Register,\n+                NonZeroU64::new(Usercalls::$f as Register)\n+                    .expect(\"Usercall number must be non-zero\"),\n                 RegisterArgument::into_register($n1),\n-                0,0,0\n+                0,0,0,\n+                return_type_is_abort!($r)\n             ))\n         }\n     );\n-    (def fn $f:ident() -> $r:ty) => (\n+    (def fn $f:ident() -> $r:tt) => (\n         /// This is the raw function definition, see the ABI documentation for\n         /// more information.\n         #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n         #[inline(always)]\n         pub unsafe fn $f() -> $r {\n             ReturnValue::from_registers(stringify!($f), do_usercall(\n-                Usercalls::$f as Register,\n-                0,0,0,0\n+                NonZeroU64::new(Usercalls::$f as Register)\n+                    .expect(\"Usercall number must be non-zero\"),\n+                0,0,0,0,\n+                return_type_is_abort!($r)\n             ))\n         }\n     );\n@@ -248,4 +250,3 @@ macro_rules! enclave_usercalls_internal_define_usercalls {\n }\n \n invoke_with_usercalls!(define_usercalls);\n-invoke_with_usercalls!(define_usercalls_asm);"}, {"sha": "4225ecbb206510d49f55c84a5dc1c876ccf0a928", "filename": "src/libstd/sys/sgx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d2ab0b77dd82d192f987ab4e1645577eccd3562/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d2ab0b77dd82d192f987ab4e1645577eccd3562/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs?ref=0d2ab0b77dd82d192f987ab4e1645577eccd3562", "patch": "@@ -125,7 +125,7 @@ pub unsafe fn strlen(mut s: *const c_char) -> usize {\n }\n \n pub unsafe fn abort_internal() -> ! {\n-    abi::panic::usercall_exit(true)\n+    abi::usercalls::exit(true)\n }\n \n pub fn hashmap_random_keys() -> (u64, u64) {"}]}