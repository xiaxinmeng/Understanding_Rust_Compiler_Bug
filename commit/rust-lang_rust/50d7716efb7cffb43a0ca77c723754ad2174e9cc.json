{"sha": "50d7716efb7cffb43a0ca77c723754ad2174e9cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwZDc3MTZlZmI3Y2ZmYjQzYTBjYTc3YzcyMzc1NGFkMjE3NGU5Y2M=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-11-02T05:14:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-02T05:14:41Z"}, "message": "Rollup merge of #78637 - mystor:atomic_ptr_bool, r=m-ou-se\n\nAdd fetch_update methods to AtomicBool and AtomicPtr\n\nThese methods were stabilized for the integer atomics in #71843, but the methods were not added for the non-integer atomics `AtomicBool` and `AtomicPtr`.", "tree": {"sha": "fb4025d80c6ac46243796e06755e877ba2b6f4dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb4025d80c6ac46243796e06755e877ba2b6f4dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50d7716efb7cffb43a0ca77c723754ad2174e9cc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfn5XBCRBK7hj4Ov3rIwAAdHIIAATo6czKRblbhbUoGuQALuMl\ntbAmvZv8ufB6sHidQihF0hjVh3cVTJALd1Yuxk6fsMVt3CzOetAizy8Kohvbgjxm\nOAaiyorjoAKdF/uJma5jwapQLMwyZXYlgDJy93dN1+mowgOn5XhjiMr7mh26PNZa\nNjWEzuNsM8X5vvlkzIhoNERcsTPMSPnctUe2z0TfQ29ram8pLULw/1CMIHS+K4Xe\nHzmldsYCppLqZ3mh3in86HPp24nTZFrEK3vb5oTM+dZmXe5a8s2zxrdxt6MDhlso\nke/no4fToNTl9xE+4ZyBELbF3EFPlNCb65aT9yN0qRcTQ1gUB7nvWazj0qYcjgE=\n=jjnS\n-----END PGP SIGNATURE-----\n", "payload": "tree fb4025d80c6ac46243796e06755e877ba2b6f4dc\nparent fb7948e7c1aa0ff6ce4cbde45cde2384d1d1ba10\nparent 00f32e6631cb5603d072b24e0c1db2104fc63a26\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1604294081 +0900\ncommitter GitHub <noreply@github.com> 1604294081 +0900\n\nRollup merge of #78637 - mystor:atomic_ptr_bool, r=m-ou-se\n\nAdd fetch_update methods to AtomicBool and AtomicPtr\n\nThese methods were stabilized for the integer atomics in #71843, but the methods were not added for the non-integer atomics `AtomicBool` and `AtomicPtr`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50d7716efb7cffb43a0ca77c723754ad2174e9cc", "html_url": "https://github.com/rust-lang/rust/commit/50d7716efb7cffb43a0ca77c723754ad2174e9cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50d7716efb7cffb43a0ca77c723754ad2174e9cc/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb7948e7c1aa0ff6ce4cbde45cde2384d1d1ba10", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb7948e7c1aa0ff6ce4cbde45cde2384d1d1ba10", "html_url": "https://github.com/rust-lang/rust/commit/fb7948e7c1aa0ff6ce4cbde45cde2384d1d1ba10"}, {"sha": "00f32e6631cb5603d072b24e0c1db2104fc63a26", "url": "https://api.github.com/repos/rust-lang/rust/commits/00f32e6631cb5603d072b24e0c1db2104fc63a26", "html_url": "https://github.com/rust-lang/rust/commit/00f32e6631cb5603d072b24e0c1db2104fc63a26"}], "stats": {"total": 125, "additions": 125, "deletions": 0}, "files": [{"sha": "0c53b6ed54a849e8fb2c85088e661c57990127cc", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/50d7716efb7cffb43a0ca77c723754ad2174e9cc/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50d7716efb7cffb43a0ca77c723754ad2174e9cc/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=50d7716efb7cffb43a0ca77c723754ad2174e9cc", "patch": "@@ -801,6 +801,64 @@ impl AtomicBool {\n     pub fn as_mut_ptr(&self) -> *mut bool {\n         self.v.get() as *mut bool\n     }\n+\n+    /// Fetches the value, and applies a function to it that returns an optional\n+    /// new value. Returns a `Result` of `Ok(previous_value)` if the function\n+    /// returned `Some(_)`, else `Err(previous_value)`.\n+    ///\n+    /// Note: This may call the function multiple times if the value has been\n+    /// changed from other threads in the meantime, as long as the function\n+    /// returns `Some(_)`, but the function will have been applied only once to\n+    /// the stored value.\n+    ///\n+    /// `fetch_update` takes two [`Ordering`] arguments to describe the memory\n+    /// ordering of this operation. The first describes the required ordering for\n+    /// when the operation finally succeeds while the second describes the\n+    /// required ordering for loads. These correspond to the success and failure\n+    /// orderings of [`AtomicBool::compare_exchange`] respectively.\n+    ///\n+    /// Using [`Acquire`] as success ordering makes the store part of this\n+    /// operation [`Relaxed`], and using [`Release`] makes the final successful\n+    /// load [`Relaxed`]. The (failed) load ordering can only be [`SeqCst`],\n+    /// [`Acquire`] or [`Relaxed`] and must be equivalent to or weaker than the\n+    /// success ordering.\n+    ///\n+    /// **Note:** This method is only available on platforms that support atomic\n+    /// operations on `u8`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(atomic_fetch_update)]\n+    /// use std::sync::atomic::{AtomicBool, Ordering};\n+    ///\n+    /// let x = AtomicBool::new(false);\n+    /// assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |_| None), Err(false));\n+    /// assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(!x)), Ok(false));\n+    /// assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(!x)), Ok(true));\n+    /// assert_eq!(x.load(Ordering::SeqCst), false);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"atomic_fetch_update\", reason = \"recently added\", issue = \"78639\")]\n+    #[cfg(target_has_atomic = \"8\")]\n+    pub fn fetch_update<F>(\n+        &self,\n+        set_order: Ordering,\n+        fetch_order: Ordering,\n+        mut f: F,\n+    ) -> Result<bool, bool>\n+    where\n+        F: FnMut(bool) -> Option<bool>,\n+    {\n+        let mut prev = self.load(fetch_order);\n+        while let Some(next) = f(prev) {\n+            match self.compare_exchange_weak(prev, next, set_order, fetch_order) {\n+                x @ Ok(_) => return x,\n+                Err(next_prev) => prev = next_prev,\n+            }\n+        }\n+        Err(prev)\n+    }\n }\n \n #[cfg(target_has_atomic_load_store = \"ptr\")]\n@@ -1123,6 +1181,73 @@ impl<T> AtomicPtr<T> {\n             }\n         }\n     }\n+\n+    /// Fetches the value, and applies a function to it that returns an optional\n+    /// new value. Returns a `Result` of `Ok(previous_value)` if the function\n+    /// returned `Some(_)`, else `Err(previous_value)`.\n+    ///\n+    /// Note: This may call the function multiple times if the value has been\n+    /// changed from other threads in the meantime, as long as the function\n+    /// returns `Some(_)`, but the function will have been applied only once to\n+    /// the stored value.\n+    ///\n+    /// `fetch_update` takes two [`Ordering`] arguments to describe the memory\n+    /// ordering of this operation. The first describes the required ordering for\n+    /// when the operation finally succeeds while the second describes the\n+    /// required ordering for loads. These correspond to the success and failure\n+    /// orderings of [`AtomicPtr::compare_exchange`] respectively.\n+    ///\n+    /// Using [`Acquire`] as success ordering makes the store part of this\n+    /// operation [`Relaxed`], and using [`Release`] makes the final successful\n+    /// load [`Relaxed`]. The (failed) load ordering can only be [`SeqCst`],\n+    /// [`Acquire`] or [`Relaxed`] and must be equivalent to or weaker than the\n+    /// success ordering.\n+    ///\n+    /// **Note:** This method is only available on platforms that support atomic\n+    /// operations on pointers.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(atomic_fetch_update)]\n+    /// use std::sync::atomic::{AtomicPtr, Ordering};\n+    ///\n+    /// let ptr: *mut _ = &mut 5;\n+    /// let some_ptr = AtomicPtr::new(ptr);\n+    ///\n+    /// let new: *mut _ = &mut 10;\n+    /// assert_eq!(some_ptr.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |_| None), Err(ptr));\n+    /// let result = some_ptr.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| {\n+    ///     if x == ptr {\n+    ///         Some(new)\n+    ///     } else {\n+    ///         None\n+    ///     }\n+    /// });\n+    /// assert_eq!(result, Ok(ptr));\n+    /// assert_eq!(some_ptr.load(Ordering::SeqCst), new);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"atomic_fetch_update\", reason = \"recently added\", issue = \"78639\")]\n+    #[cfg(target_has_atomic = \"ptr\")]\n+    pub fn fetch_update<F>(\n+        &self,\n+        set_order: Ordering,\n+        fetch_order: Ordering,\n+        mut f: F,\n+    ) -> Result<*mut T, *mut T>\n+    where\n+        F: FnMut(*mut T) -> Option<*mut T>,\n+    {\n+        let mut prev = self.load(fetch_order);\n+        while let Some(next) = f(prev) {\n+            match self.compare_exchange_weak(prev, next, set_order, fetch_order) {\n+                x @ Ok(_) => return x,\n+                Err(next_prev) => prev = next_prev,\n+            }\n+        }\n+        Err(prev)\n+    }\n }\n \n #[cfg(target_has_atomic_load_store = \"8\")]"}]}