{"sha": "cf35cb365a4efee53f6372095aaff4798544bf94", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmMzVjYjM2NWE0ZWZlZTUzZjYzNzIwOTVhYWZmNDc5ODU0NGJmOTQ=", "commit": {"author": {"name": "Stuart Pernsteiner", "email": "spernsteiner@mozilla.com", "date": "2014-09-05T16:18:53Z"}, "committer": {"name": "Stuart Pernsteiner", "email": "spernsteiner@mozilla.com", "date": "2014-09-05T16:18:53Z"}, "message": "make CrateContext fields private", "tree": {"sha": "a2612e9390879c981f2bdab83d9aceb1715f21b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2612e9390879c981f2bdab83d9aceb1715f21b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf35cb365a4efee53f6372095aaff4798544bf94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf35cb365a4efee53f6372095aaff4798544bf94", "html_url": "https://github.com/rust-lang/rust/commit/cf35cb365a4efee53f6372095aaff4798544bf94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf35cb365a4efee53f6372095aaff4798544bf94/comments", "author": {"login": "spernsteiner", "id": 3031136, "node_id": "MDQ6VXNlcjMwMzExMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/3031136?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spernsteiner", "html_url": "https://github.com/spernsteiner", "followers_url": "https://api.github.com/users/spernsteiner/followers", "following_url": "https://api.github.com/users/spernsteiner/following{/other_user}", "gists_url": "https://api.github.com/users/spernsteiner/gists{/gist_id}", "starred_url": "https://api.github.com/users/spernsteiner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spernsteiner/subscriptions", "organizations_url": "https://api.github.com/users/spernsteiner/orgs", "repos_url": "https://api.github.com/users/spernsteiner/repos", "events_url": "https://api.github.com/users/spernsteiner/events{/privacy}", "received_events_url": "https://api.github.com/users/spernsteiner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spernsteiner", "id": 3031136, "node_id": "MDQ6VXNlcjMwMzExMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/3031136?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spernsteiner", "html_url": "https://github.com/spernsteiner", "followers_url": "https://api.github.com/users/spernsteiner/followers", "following_url": "https://api.github.com/users/spernsteiner/following{/other_user}", "gists_url": "https://api.github.com/users/spernsteiner/gists{/gist_id}", "starred_url": "https://api.github.com/users/spernsteiner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spernsteiner/subscriptions", "organizations_url": "https://api.github.com/users/spernsteiner/orgs", "repos_url": "https://api.github.com/users/spernsteiner/repos", "events_url": "https://api.github.com/users/spernsteiner/events{/privacy}", "received_events_url": "https://api.github.com/users/spernsteiner/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67b97ab6d2b7de9b69fd97dc171fcf8feec932ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/67b97ab6d2b7de9b69fd97dc171fcf8feec932ff", "html_url": "https://github.com/rust-lang/rust/commit/67b97ab6d2b7de9b69fd97dc171fcf8feec932ff"}], "stats": {"total": 921, "additions": 544, "deletions": 377}, "files": [{"sha": "d9c05f9a76da9c84b58a33e49c6d98c70ef691f5", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=cf35cb365a4efee53f6372095aaff4798544bf94", "patch": "@@ -715,14 +715,14 @@ fn symbol_hash(tcx: &ty::ctxt,\n }\n \n fn get_symbol_hash(ccx: &CrateContext, t: ty::t) -> String {\n-    match ccx.type_hashcodes.borrow().find(&t) {\n+    match ccx.type_hashcodes().borrow().find(&t) {\n         Some(h) => return h.to_string(),\n         None => {}\n     }\n \n-    let mut symbol_hasher = ccx.symbol_hasher.borrow_mut();\n-    let hash = symbol_hash(ccx.tcx(), &mut *symbol_hasher, t, &ccx.link_meta);\n-    ccx.type_hashcodes.borrow_mut().insert(t, hash.clone());\n+    let mut symbol_hasher = ccx.symbol_hasher().borrow_mut();\n+    let hash = symbol_hash(ccx.tcx(), &mut *symbol_hasher, t, ccx.link_meta());\n+    ccx.type_hashcodes().borrow_mut().insert(t, hash.clone());\n     hash\n }\n "}, {"sha": "1b93e1974419cf75998be04a729075e5fce77a71", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=cf35cb365a4efee53f6372095aaff4798544bf94", "patch": "@@ -563,7 +563,7 @@ fn get_branches<'a>(bcx: &'a Block, m: &[Match], col: uint) -> Vec<Opt<'a>> {\n             }\n             ast::PatIdent(..) | ast::PatEnum(..) | ast::PatStruct(..) => {\n                 // This is either an enum variant or a variable binding.\n-                let opt_def = ccx.tcx.def_map.borrow().find_copy(&cur.id);\n+                let opt_def = ccx.tcx().def_map.borrow().find_copy(&cur.id);\n                 match opt_def {\n                     Some(def::DefVariant(enum_id, var_id, _)) => {\n                         let variant = ty::enum_variant_with_id(ccx.tcx(), enum_id, var_id);"}, {"sha": "21673a67ea8ac487343927de74e59912717f22e6", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=cf35cb365a4efee53f6372095aaff4798544bf94", "patch": "@@ -150,14 +150,14 @@ pub fn represent_node(bcx: &Block, node: ast::NodeId) -> Rc<Repr> {\n /// Decides how to represent a given type.\n pub fn represent_type(cx: &CrateContext, t: ty::t) -> Rc<Repr> {\n     debug!(\"Representing: {}\", ty_to_string(cx.tcx(), t));\n-    match cx.adt_reprs.borrow().find(&t) {\n+    match cx.adt_reprs().borrow().find(&t) {\n         Some(repr) => return repr.clone(),\n         None => {}\n     }\n \n     let repr = Rc::new(represent_type_uncached(cx, t));\n     debug!(\"Represented as: {:?}\", repr)\n-    cx.adt_reprs.borrow_mut().insert(t, repr.clone());\n+    cx.adt_reprs().borrow_mut().insert(t, repr.clone());\n     repr\n }\n \n@@ -423,7 +423,7 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n             attempts = choose_shortest;\n         },\n         attr::ReprPacked => {\n-            cx.tcx.sess.bug(\"range_to_inttype: found ReprPacked on an enum\");\n+            cx.tcx().sess.bug(\"range_to_inttype: found ReprPacked on an enum\");\n         }\n     }\n     for &ity in attempts.iter() {"}, {"sha": "78488654c510ccc112ac332de135d1cab3332caa", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 86, "deletions": 86, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=cf35cb365a4efee53f6372095aaff4798544bf94", "patch": "@@ -149,7 +149,7 @@ impl<'a> StatRecorder<'a> {\n         } else {\n             0\n         };\n-        let istart = ccx.stats.n_llvm_insns.get();\n+        let istart = ccx.stats().n_llvm_insns.get();\n         StatRecorder {\n             ccx: ccx,\n             name: Some(name),\n@@ -165,13 +165,13 @@ impl<'a> Drop for StatRecorder<'a> {\n         if self.ccx.sess().trans_stats() {\n             let end = time::precise_time_ns();\n             let elapsed = ((end - self.start) / 1_000_000) as uint;\n-            let iend = self.ccx.stats.n_llvm_insns.get();\n-            self.ccx.stats.fn_stats.borrow_mut().push((self.name.take().unwrap(),\n+            let iend = self.ccx.stats().n_llvm_insns.get();\n+            self.ccx.stats().fn_stats.borrow_mut().push((self.name.take().unwrap(),\n                                                        elapsed,\n                                                        iend - self.istart));\n-            self.ccx.stats.n_fns.set(self.ccx.stats.n_fns.get() + 1);\n+            self.ccx.stats().n_fns.set(self.ccx.stats().n_fns.get() + 1);\n             // Reset LLVM insn count to avoid compound costs.\n-            self.ccx.stats.n_llvm_insns.set(self.istart);\n+            self.ccx.stats().n_llvm_insns.set(self.istart);\n         }\n     }\n }\n@@ -182,7 +182,7 @@ pub fn decl_fn(ccx: &CrateContext, name: &str, cc: llvm::CallConv,\n \n     let llfn: ValueRef = name.with_c_str(|buf| {\n         unsafe {\n-            llvm::LLVMGetOrInsertFunction(ccx.llmod, buf, ty.to_ref())\n+            llvm::LLVMGetOrInsertFunction(ccx.llmod(), buf, ty.to_ref())\n         }\n     });\n \n@@ -198,7 +198,7 @@ pub fn decl_fn(ccx: &CrateContext, name: &str, cc: llvm::CallConv,\n         _ => {}\n     }\n \n-    if ccx.tcx.sess.opts.cg.no_redzone {\n+    if ccx.tcx().sess.opts.cg.no_redzone {\n         unsafe {\n             llvm::LLVMAddFunctionAttribute(llfn,\n                                            llvm::FunctionIndex as c_uint,\n@@ -243,7 +243,7 @@ pub fn get_extern_fn(ccx: &CrateContext,\n }\n \n fn get_extern_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str, did: ast::DefId) -> ValueRef {\n-    match ccx.externs.borrow().find_equiv(&name) {\n+    match ccx.externs().borrow().find_equiv(&name) {\n         Some(n) => return *n,\n         None => ()\n     }\n@@ -254,7 +254,7 @@ fn get_extern_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str, did: ast::De\n         set_llvm_fn_attrs(attrs.as_slice(), f)\n     });\n \n-    ccx.externs.borrow_mut().insert(name.to_string(), f);\n+    ccx.externs().borrow_mut().insert(name.to_string(), f);\n     f\n }\n \n@@ -264,22 +264,22 @@ pub fn self_type_for_unboxed_closure(ccx: &CrateContext,\n     let unboxed_closure_type = ty::mk_unboxed_closure(ccx.tcx(),\n                                                       closure_id,\n                                                       ty::ReStatic);\n-    let unboxed_closures = ccx.tcx.unboxed_closures.borrow();\n+    let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n     let unboxed_closure = unboxed_closures.get(&closure_id);\n     match unboxed_closure.kind {\n         ty::FnUnboxedClosureKind => {\n-            ty::mk_imm_rptr(&ccx.tcx, ty::ReStatic, unboxed_closure_type)\n+            ty::mk_imm_rptr(ccx.tcx(), ty::ReStatic, unboxed_closure_type)\n         }\n         ty::FnMutUnboxedClosureKind => {\n-            ty::mk_mut_rptr(&ccx.tcx, ty::ReStatic, unboxed_closure_type)\n+            ty::mk_mut_rptr(ccx.tcx(), ty::ReStatic, unboxed_closure_type)\n         }\n         ty::FnOnceUnboxedClosureKind => unboxed_closure_type,\n     }\n }\n \n pub fn kind_for_unboxed_closure(ccx: &CrateContext, closure_id: ast::DefId)\n                                 -> ty::UnboxedClosureKind {\n-    let unboxed_closures = ccx.tcx.unboxed_closures.borrow();\n+    let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n     unboxed_closures.get(&closure_id).kind\n }\n \n@@ -292,7 +292,7 @@ pub fn decl_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> ValueRef {\n             (f.sig.inputs.clone(), f.sig.output, f.abi, Some(Type::i8p(ccx)))\n         }\n         ty::ty_unboxed_closure(closure_did, _) => {\n-            let unboxed_closures = ccx.tcx.unboxed_closures.borrow();\n+            let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n             let unboxed_closure = unboxed_closures.get(&closure_did);\n             let function_type = unboxed_closure.closure_type.clone();\n             let self_type = self_type_for_unboxed_closure(ccx, closure_did);\n@@ -308,7 +308,7 @@ pub fn decl_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> ValueRef {\n     let llfty = type_of_rust_fn(ccx, env, inputs.as_slice(), output, abi);\n     debug!(\"decl_rust_fn(input count={},type={})\",\n            inputs.len(),\n-           ccx.tn.type_to_string(llfty));\n+           ccx.tn().type_to_string(llfty));\n \n     let llfn = decl_fn(ccx, name, llvm::CCallConv, llfty, output);\n     let attrs = get_fn_llvm_attributes(ccx, fn_ty);\n@@ -413,15 +413,15 @@ pub fn malloc_raw_dyn_managed<'a>(\n // Type descriptor and type glue stuff\n \n pub fn get_tydesc(ccx: &CrateContext, t: ty::t) -> Rc<tydesc_info> {\n-    match ccx.tydescs.borrow().find(&t) {\n+    match ccx.tydescs().borrow().find(&t) {\n         Some(inf) => return inf.clone(),\n         _ => { }\n     }\n \n-    ccx.stats.n_static_tydescs.set(ccx.stats.n_static_tydescs.get() + 1u);\n+    ccx.stats().n_static_tydescs.set(ccx.stats().n_static_tydescs.get() + 1u);\n     let inf = Rc::new(glue::declare_tydesc(ccx, t));\n \n-    ccx.tydescs.borrow_mut().insert(t, inf.clone());\n+    ccx.tydescs().borrow_mut().insert(t, inf.clone());\n     inf\n }\n \n@@ -492,10 +492,10 @@ pub fn unset_split_stack(f: ValueRef) {\n // Double-check that we never ask LLVM to declare the same symbol twice. It\n // silently mangles such symbols, breaking our linkage model.\n pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: String) {\n-    if ccx.all_llvm_symbols.borrow().contains(&sym) {\n+    if ccx.all_llvm_symbols().borrow().contains(&sym) {\n         ccx.sess().bug(format!(\"duplicate LLVM symbol: {}\", sym).as_slice());\n     }\n-    ccx.all_llvm_symbols.borrow_mut().insert(sym);\n+    ccx.all_llvm_symbols().borrow_mut().insert(sym);\n }\n \n \n@@ -532,7 +532,7 @@ pub fn get_res_dtor(ccx: &CrateContext,\n         let dtor_ty = ty::mk_ctor_fn(ccx.tcx(), ast::DUMMY_NODE_ID,\n                                      [glue::get_drop_glue_type(ccx, t)], ty::mk_nil());\n         get_extern_fn(ccx,\n-                      &mut *ccx.externs.borrow_mut(),\n+                      &mut *ccx.externs().borrow_mut(),\n                       name.as_slice(),\n                       llvm::CCallConv,\n                       llty,\n@@ -961,8 +961,8 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> Val\n         }\n         _ => {\n             let llty = type_of(ccx, t);\n-            get_extern_const(&mut *ccx.externs.borrow_mut(),\n-                             ccx.llmod,\n+            get_extern_const(&mut *ccx.externs().borrow_mut(),\n+                             ccx.llmod(),\n                              name.as_slice(),\n                              llty)\n         }\n@@ -1165,7 +1165,7 @@ pub fn call_memcpy(cx: &Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef,\n     let memcpy = ccx.get_intrinsic(&key);\n     let src_ptr = PointerCast(cx, src, Type::i8p(ccx));\n     let dst_ptr = PointerCast(cx, dst, Type::i8p(ccx));\n-    let size = IntCast(cx, n_bytes, ccx.int_type);\n+    let size = IntCast(cx, n_bytes, ccx.int_type());\n     let align = C_i32(ccx, align as i32);\n     let volatile = C_bool(ccx, false);\n     Call(cx, memcpy, [dst_ptr, src_ptr, size, align, volatile], None);\n@@ -1426,7 +1426,7 @@ pub fn new_fn_ctxt<'a>(ccx: &'a CrateContext,\n            if id == -1 {\n                \"\".to_string()\n            } else {\n-               ccx.tcx.map.path_to_string(id).to_string()\n+               ccx.tcx().map.path_to_string(id).to_string()\n            },\n            id, param_substs.repr(ccx.tcx()));\n \n@@ -1786,7 +1786,7 @@ pub fn trans_closure(ccx: &CrateContext,\n                      is_unboxed_closure: IsUnboxedClosureFlag,\n                      maybe_load_env: <'a>|&'a Block<'a>, ScopeId|\n                                          -> &'a Block<'a>) {\n-    ccx.stats.n_closures.set(ccx.stats.n_closures.get() + 1);\n+    ccx.stats().n_closures.set(ccx.stats().n_closures.get() + 1);\n \n     let _icx = push_ctxt(\"trans_closure\");\n     set_uwtable(llfndecl);\n@@ -1820,7 +1820,7 @@ pub fn trans_closure(ccx: &CrateContext,\n                ty_to_string(ccx.tcx(), *monomorphized_arg_type));\n     }\n     debug!(\"trans_closure: function lltype: {}\",\n-           bcx.fcx.ccx.tn.val_to_string(bcx.fcx.llfn));\n+           bcx.fcx.ccx.tn().val_to_string(bcx.fcx.llfn));\n \n     let arg_datums = if abi != RustCall {\n         create_datums_for_fn_args(&fcx,\n@@ -1912,7 +1912,7 @@ pub fn trans_fn(ccx: &CrateContext,\n                 param_substs: &param_substs,\n                 id: ast::NodeId,\n                 attrs: &[ast::Attribute]) {\n-    let _s = StatRecorder::new(ccx, ccx.tcx.map.path_to_string(id).to_string());\n+    let _s = StatRecorder::new(ccx, ccx.tcx().map.path_to_string(id).to_string());\n     debug!(\"trans_fn(param_substs={})\", param_substs.repr(ccx.tcx()));\n     let _icx = push_ctxt(\"trans_fn\");\n     let fn_ty = ty::node_id_to_type(ccx.tcx(), id);\n@@ -1958,7 +1958,7 @@ pub fn trans_named_tuple_constructor<'a>(mut bcx: &'a Block<'a>,\n                                          dest: expr::Dest) -> Result<'a> {\n \n     let ccx = bcx.fcx.ccx;\n-    let tcx = &ccx.tcx;\n+    let tcx = ccx.tcx();\n \n     let result_ty = match ty::get(ctor_ty).sty {\n         ty::ty_bare_fn(ref bft) => bft.sig.output,\n@@ -2064,7 +2064,7 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span, id: ast::NodeId) {\n     let mut sizes = Vec::new(); // does no allocation if no pushes, thankfully\n \n-    let levels = ccx.tcx.node_lint_levels.borrow();\n+    let levels = ccx.tcx().node_lint_levels.borrow();\n     let lint_id = lint::LintId::of(lint::builtin::VARIANT_SIZE_DIFFERENCE);\n     let lvlsrc = match levels.find(&(id, lint_id)) {\n         None | Some(&(lint::Allow, _)) => return,\n@@ -2181,7 +2181,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                                          static\");\n               }\n \n-              let v = ccx.const_values.borrow().get_copy(&item.id);\n+              let v = ccx.const_values().borrow().get_copy(&item.id);\n               unsafe {\n                   if !(llvm::LLVMConstIntGetZExtValue(v) != 0) {\n                       ccx.sess().span_fatal(expr.span, \"static assertion failed\");\n@@ -2218,21 +2218,21 @@ pub fn trans_mod(ccx: &CrateContext, m: &ast::Mod) {\n \n fn finish_register_fn(ccx: &CrateContext, sp: Span, sym: String, node_id: ast::NodeId,\n                       llfn: ValueRef) {\n-    ccx.item_symbols.borrow_mut().insert(node_id, sym);\n+    ccx.item_symbols().borrow_mut().insert(node_id, sym);\n \n-    if !ccx.reachable.contains(&node_id) {\n+    if !ccx.reachable().contains(&node_id) {\n         llvm::SetLinkage(llfn, llvm::InternalLinkage);\n     }\n \n     // The stack exhaustion lang item shouldn't have a split stack because\n     // otherwise it would continue to be exhausted (bad), and both it and the\n     // eh_personality functions need to be externally linkable.\n     let def = ast_util::local_def(node_id);\n-    if ccx.tcx.lang_items.stack_exhausted() == Some(def) {\n+    if ccx.tcx().lang_items.stack_exhausted() == Some(def) {\n         unset_split_stack(llfn);\n         llvm::SetLinkage(llfn, llvm::ExternalLinkage);\n     }\n-    if ccx.tcx.lang_items.eh_personality() == Some(def) {\n+    if ccx.tcx().lang_items.eh_personality() == Some(def) {\n         llvm::SetLinkage(llfn, llvm::ExternalLinkage);\n     }\n \n@@ -2268,7 +2268,7 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n         ty::ty_closure(ref f) => (f.sig.clone(), f.abi, true),\n         ty::ty_bare_fn(ref f) => (f.sig.clone(), f.abi, false),\n         ty::ty_unboxed_closure(closure_did, _) => {\n-            let unboxed_closures = ccx.tcx.unboxed_closures.borrow();\n+            let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n             let ref function_type = unboxed_closures.get(&closure_did)\n                                                     .closure_type;\n \n@@ -2485,8 +2485,8 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n     fn create_entry_fn(ccx: &CrateContext,\n                        rust_main: ValueRef,\n                        use_start_lang_item: bool) {\n-        let llfty = Type::func([ccx.int_type, Type::i8p(ccx).ptr_to()],\n-                               &ccx.int_type);\n+        let llfty = Type::func([ccx.int_type(), Type::i8p(ccx).ptr_to()],\n+                               &ccx.int_type());\n \n         let llfn = decl_cdecl_fn(ccx, \"main\", llfty, ty::mk_nil());\n \n@@ -2498,15 +2498,15 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n \n         let llbb = \"top\".with_c_str(|buf| {\n             unsafe {\n-                llvm::LLVMAppendBasicBlockInContext(ccx.llcx, llfn, buf)\n+                llvm::LLVMAppendBasicBlockInContext(ccx.llcx(), llfn, buf)\n             }\n         });\n-        let bld = ccx.builder.b;\n+        let bld = ccx.raw_builder();\n         unsafe {\n             llvm::LLVMPositionBuilderAtEnd(bld, llbb);\n \n             let (start_fn, args) = if use_start_lang_item {\n-                let start_def_id = match ccx.tcx.lang_items.require(StartFnLangItem) {\n+                let start_def_id = match ccx.tcx().lang_items.require(StartFnLangItem) {\n                     Ok(id) => id,\n                     Err(s) => { ccx.sess().fatal(s.as_slice()); }\n                 };\n@@ -2557,7 +2557,7 @@ fn exported_name(ccx: &CrateContext, id: ast::NodeId,\n         // Use provided name\n         Some(name) => name.get().to_string(),\n \n-        _ => ccx.tcx.map.with_path(id, |mut path| {\n+        _ => ccx.tcx().map.with_path(id, |mut path| {\n             if attr::contains_name(attrs, \"no_mangle\") {\n                 // Don't mangle\n                 path.last().unwrap().to_string()\n@@ -2577,13 +2577,13 @@ fn exported_name(ccx: &CrateContext, id: ast::NodeId,\n pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n     debug!(\"get_item_val(id=`{:?}`)\", id);\n \n-    match ccx.item_vals.borrow().find_copy(&id) {\n+    match ccx.item_vals().borrow().find_copy(&id) {\n         Some(v) => return v,\n         None => {}\n     }\n \n     let mut foreign = false;\n-    let item = ccx.tcx.map.get(id);\n+    let item = ccx.tcx().map.get(id);\n     let val = match item {\n         ast_map::NodeItem(i) => {\n             let ty = ty::node_id_to_type(ccx.tcx(), i.id);\n@@ -2597,7 +2597,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     // information in the hash of the symbol\n                     debug!(\"making {}\", sym);\n                     let (sym, is_local) = {\n-                        match ccx.external_srcs.borrow().find(&i.id) {\n+                        match ccx.external_srcs().borrow().find(&i.id) {\n                             Some(&did) => {\n                                 debug!(\"but found in other crate...\");\n                                 (csearch::get_symbol(&ccx.sess().cstore,\n@@ -2610,16 +2610,16 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     // We need the translated value here, because for enums the\n                     // LLVM type is not fully determined by the Rust type.\n                     let (v, inlineable, _) = consts::const_expr(ccx, &**expr, is_local);\n-                    ccx.const_values.borrow_mut().insert(id, v);\n+                    ccx.const_values().borrow_mut().insert(id, v);\n                     let mut inlineable = inlineable;\n \n                     unsafe {\n                         let llty = llvm::LLVMTypeOf(v);\n                         let g = sym.as_slice().with_c_str(|buf| {\n-                            llvm::LLVMAddGlobal(ccx.llmod, llty, buf)\n+                            llvm::LLVMAddGlobal(ccx.llmod(), llty, buf)\n                         });\n \n-                        if !ccx.reachable.contains(&id) {\n+                        if !ccx.reachable().contains(&id) {\n                             llvm::SetLinkage(g, llvm::InternalLinkage);\n                         }\n \n@@ -2655,11 +2655,11 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n \n                         if !inlineable {\n                             debug!(\"{} not inlined\", sym);\n-                            ccx.non_inlineable_statics.borrow_mut()\n+                            ccx.non_inlineable_statics().borrow_mut()\n                                                       .insert(id);\n                         }\n \n-                        ccx.item_symbols.borrow_mut().insert(i.id, sym);\n+                        ccx.item_symbols().borrow_mut().insert(i.id, sym);\n                         g\n                     }\n                 }\n@@ -2717,7 +2717,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n \n             match ni.node {\n                 ast::ForeignItemFn(..) => {\n-                    let abi = ccx.tcx.map.get_foreign_abi(id);\n+                    let abi = ccx.tcx().map.get_foreign_abi(id);\n                     let ty = ty::node_id_to_type(ccx.tcx(), ni.id);\n                     let name = foreign::link_name(&*ni);\n                     foreign::register_foreign_item_fn(ccx, abi, ty,\n@@ -2740,8 +2740,8 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             };\n             assert!(args.len() != 0u);\n             let ty = ty::node_id_to_type(ccx.tcx(), id);\n-            let parent = ccx.tcx.map.get_parent(id);\n-            let enm = ccx.tcx.map.expect_item(parent);\n+            let parent = ccx.tcx().map.get_parent(id);\n+            let enm = ccx.tcx().map.expect_item(parent);\n             let sym = exported_name(ccx,\n                                     id,\n                                     ty,\n@@ -2766,8 +2766,8 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                 }\n                 Some(ctor_id) => ctor_id,\n             };\n-            let parent = ccx.tcx.map.get_parent(id);\n-            let struct_item = ccx.tcx.map.expect_item(parent);\n+            let parent = ccx.tcx().map.get_parent(id);\n+            let struct_item = ccx.tcx().map.expect_item(parent);\n             let ty = ty::node_id_to_type(ccx.tcx(), ctor_id);\n             let sym = exported_name(ccx,\n                                     id,\n@@ -2789,11 +2789,11 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n     // foreign items (extern fns and extern statics) don't have internal\n     // linkage b/c that doesn't quite make sense. Otherwise items can\n     // have internal linkage if they're not reachable.\n-    if !foreign && !ccx.reachable.contains(&id) {\n+    if !foreign && !ccx.reachable().contains(&id) {\n         llvm::SetLinkage(val, llvm::InternalLinkage);\n     }\n \n-    ccx.item_vals.borrow_mut().insert(id, val);\n+    ccx.item_vals().borrow_mut().insert(id, val);\n     val\n }\n \n@@ -2810,7 +2810,7 @@ fn register_method(ccx: &CrateContext, id: ast::NodeId,\n \n pub fn p2i(ccx: &CrateContext, v: ValueRef) -> ValueRef {\n     unsafe {\n-        return llvm::LLVMConstPtrToInt(v, ccx.int_type.to_ref());\n+        return llvm::LLVMConstPtrToInt(v, ccx.int_type().to_ref());\n     }\n }\n \n@@ -2819,13 +2819,13 @@ pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::EncodeI\n         encoder::EncodeParams {\n             diag: cx.sess().diagnostic(),\n             tcx: cx.tcx(),\n-            reexports2: &cx.exp_map2,\n-            item_symbols: &cx.item_symbols,\n-            non_inlineable_statics: &cx.non_inlineable_statics,\n-            link_meta: &cx.link_meta,\n+            reexports2: cx.exp_map2(),\n+            item_symbols: cx.item_symbols(),\n+            non_inlineable_statics: cx.non_inlineable_statics(),\n+            link_meta: cx.link_meta(),\n             cstore: &cx.sess().cstore,\n             encode_inlined_item: ie,\n-            reachable: &cx.reachable,\n+            reachable: cx.reachable(),\n         }\n }\n \n@@ -2854,11 +2854,11 @@ pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> Vec<u8> {\n     let llmeta = C_bytes(cx, compressed.as_slice());\n     let llconst = C_struct(cx, [llmeta], false);\n     let name = format!(\"rust_metadata_{}_{}\",\n-                       cx.link_meta.crate_name,\n-                       cx.link_meta.crate_hash);\n+                       cx.link_meta().crate_name,\n+                       cx.link_meta().crate_hash);\n     let llglobal = name.with_c_str(|buf| {\n         unsafe {\n-            llvm::LLVMAddGlobal(cx.metadata_llmod, val_ty(llconst).to_ref(), buf)\n+            llvm::LLVMAddGlobal(cx.metadata_llmod(), val_ty(llconst).to_ref(), buf)\n         }\n     });\n     unsafe {\n@@ -2927,20 +2927,20 @@ pub fn trans_crate(krate: ast::Crate,\n     let metadata = write_metadata(&ccx, &krate);\n     if ccx.sess().trans_stats() {\n         println!(\"--- trans stats ---\");\n-        println!(\"n_static_tydescs: {}\", ccx.stats.n_static_tydescs.get());\n-        println!(\"n_glues_created: {}\", ccx.stats.n_glues_created.get());\n-        println!(\"n_null_glues: {}\", ccx.stats.n_null_glues.get());\n-        println!(\"n_real_glues: {}\", ccx.stats.n_real_glues.get());\n-\n-        println!(\"n_fns: {}\", ccx.stats.n_fns.get());\n-        println!(\"n_monos: {}\", ccx.stats.n_monos.get());\n-        println!(\"n_inlines: {}\", ccx.stats.n_inlines.get());\n-        println!(\"n_closures: {}\", ccx.stats.n_closures.get());\n+        println!(\"n_static_tydescs: {}\", ccx.stats().n_static_tydescs.get());\n+        println!(\"n_glues_created: {}\", ccx.stats().n_glues_created.get());\n+        println!(\"n_null_glues: {}\", ccx.stats().n_null_glues.get());\n+        println!(\"n_real_glues: {}\", ccx.stats().n_real_glues.get());\n+\n+        println!(\"n_fns: {}\", ccx.stats().n_fns.get());\n+        println!(\"n_monos: {}\", ccx.stats().n_monos.get());\n+        println!(\"n_inlines: {}\", ccx.stats().n_inlines.get());\n+        println!(\"n_closures: {}\", ccx.stats().n_closures.get());\n         println!(\"fn stats:\");\n-        ccx.stats.fn_stats.borrow_mut().sort_by(|&(_, _, insns_a), &(_, _, insns_b)| {\n+        ccx.stats().fn_stats.borrow_mut().sort_by(|&(_, _, insns_a), &(_, _, insns_b)| {\n             insns_b.cmp(&insns_a)\n         });\n-        for tuple in ccx.stats.fn_stats.borrow().iter() {\n+        for tuple in ccx.stats().fn_stats.borrow().iter() {\n             match *tuple {\n                 (ref name, ms, insns) => {\n                     println!(\"{} insns, {} ms, {}\", insns, ms, *name);\n@@ -2949,17 +2949,17 @@ pub fn trans_crate(krate: ast::Crate,\n         }\n     }\n     if ccx.sess().count_llvm_insns() {\n-        for (k, v) in ccx.stats.llvm_insns.borrow().iter() {\n+        for (k, v) in ccx.stats().llvm_insns.borrow().iter() {\n             println!(\"{:7u} {}\", *v, *k);\n         }\n     }\n \n-    let llcx = ccx.llcx;\n-    let link_meta = ccx.link_meta.clone();\n-    let llmod = ccx.llmod;\n+    let llcx = ccx.llcx();\n+    let link_meta = ccx.link_meta().clone();\n+    let llmod = ccx.llmod();\n \n-    let mut reachable: Vec<String> = ccx.reachable.iter().filter_map(|id| {\n-        ccx.item_symbols.borrow().find(id).map(|s| s.to_string())\n+    let mut reachable: Vec<String> = ccx.reachable().iter().filter_map(|id| {\n+        ccx.item_symbols().borrow().find(id).map(|s| s.to_string())\n     }).collect();\n \n     // For the purposes of LTO, we add to the reachable set all of the upstream\n@@ -2986,11 +2986,11 @@ pub fn trans_crate(krate: ast::Crate,\n     // referenced from rt/rust_try.ll\n     reachable.push(\"rust_eh_personality_catch\".to_string());\n \n-    let metadata_module = ccx.metadata_llmod;\n-    let formats = ccx.tcx.dependency_formats.borrow().clone();\n+    let metadata_module = ccx.metadata_llmod();\n+    let formats = ccx.tcx().dependency_formats.borrow().clone();\n     let no_builtins = attr::contains_name(krate.attrs.as_slice(), \"no_builtins\");\n \n-    (ccx.tcx, CrateTranslation {\n+    (ccx.take_tcx(), CrateTranslation {\n         context: llcx,\n         module: llmod,\n         link: link_meta,"}, {"sha": "fd988eb7fc1370f4fbdf892e812cb60cfe7988e2", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=cf35cb365a4efee53f6372095aaff4798544bf94", "patch": "@@ -352,7 +352,7 @@ pub fn Load(cx: &Block, pointer_val: ValueRef) -> ValueRef {\n             let eltty = if ty.kind() == llvm::Array {\n                 ty.element_type()\n             } else {\n-                ccx.int_type\n+                ccx.int_type()\n             };\n             return llvm::LLVMGetUndef(eltty.to_ref());\n         }\n@@ -373,7 +373,7 @@ pub fn AtomicLoad(cx: &Block, pointer_val: ValueRef, order: AtomicOrdering) -> V\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable.get() {\n-            return llvm::LLVMGetUndef(ccx.int_type.to_ref());\n+            return llvm::LLVMGetUndef(ccx.int_type().to_ref());\n         }\n         B(cx).atomic_load(pointer_val, order)\n     }\n@@ -388,7 +388,7 @@ pub fn LoadRangeAssert(cx: &Block, pointer_val: ValueRef, lo: c_ulonglong,\n         let eltty = if ty.kind() == llvm::Array {\n             ty.element_type()\n         } else {\n-            ccx.int_type\n+            ccx.int_type()\n         };\n         unsafe {\n             llvm::LLVMGetUndef(eltty.to_ref())\n@@ -658,7 +658,7 @@ pub fn _UndefReturn(cx: &Block, fn_: ValueRef) -> ValueRef {\n         let retty = if ty.kind() == llvm::Integer {\n             ty.return_type()\n         } else {\n-            ccx.int_type\n+            ccx.int_type()\n         };\n         B(cx).count_insn(\"ret_undef\");\n         llvm::LLVMGetUndef(retty.to_ref())\n@@ -786,7 +786,7 @@ pub fn IsNotNull(cx: &Block, val: ValueRef) -> ValueRef {\n pub fn PtrDiff(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(ccx.int_type.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(ccx.int_type().to_ref()); }\n         B(cx).ptrdiff(lhs, rhs)\n     }\n }"}, {"sha": "29c7b93a3691fc409f54877098c3470e1ba19f81", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=cf35cb365a4efee53f6372095aaff4798544bf94", "patch": "@@ -38,21 +38,21 @@ pub fn noname() -> *const c_char {\n impl<'a> Builder<'a> {\n     pub fn new(ccx: &'a CrateContext) -> Builder<'a> {\n         Builder {\n-            llbuilder: ccx.builder.b,\n+            llbuilder: ccx.raw_builder(),\n             ccx: ccx,\n         }\n     }\n \n     pub fn count_insn(&self, category: &str) {\n         if self.ccx.sess().trans_stats() {\n-            self.ccx.stats.n_llvm_insns.set(self.ccx\n-                                                .stats\n+            self.ccx.stats().n_llvm_insns.set(self.ccx\n+                                                .stats()\n                                                 .n_llvm_insns\n                                                 .get() + 1);\n         }\n         if self.ccx.sess().count_llvm_insns() {\n             base::with_insn_ctxt(|v| {\n-                let mut h = self.ccx.stats.llvm_insns.borrow_mut();\n+                let mut h = self.ccx.stats().llvm_insns.borrow_mut();\n \n                 // Build version of path with cycles removed.\n \n@@ -160,9 +160,9 @@ impl<'a> Builder<'a> {\n         self.count_insn(\"invoke\");\n \n         debug!(\"Invoke {} with args ({})\",\n-               self.ccx.tn.val_to_string(llfn),\n+               self.ccx.tn().val_to_string(llfn),\n                args.iter()\n-                   .map(|&v| self.ccx.tn.val_to_string(v))\n+                   .map(|&v| self.ccx.tn().val_to_string(v))\n                    .collect::<Vec<String>>()\n                    .connect(\", \"));\n \n@@ -488,7 +488,7 @@ impl<'a> Builder<'a> {\n             let v = [min, max];\n \n             llvm::LLVMSetMetadata(value, llvm::MD_range as c_uint,\n-                                  llvm::LLVMMDNodeInContext(self.ccx.llcx,\n+                                  llvm::LLVMMDNodeInContext(self.ccx.llcx(),\n                                                             v.as_ptr(), v.len() as c_uint));\n         }\n \n@@ -497,8 +497,8 @@ impl<'a> Builder<'a> {\n \n     pub fn store(&self, val: ValueRef, ptr: ValueRef) {\n         debug!(\"Store {} -> {}\",\n-               self.ccx.tn.val_to_string(val),\n-               self.ccx.tn.val_to_string(ptr));\n+               self.ccx.tn().val_to_string(val),\n+               self.ccx.tn().val_to_string(ptr));\n         assert!(self.llbuilder.is_not_null());\n         self.count_insn(\"store\");\n         unsafe {\n@@ -508,8 +508,8 @@ impl<'a> Builder<'a> {\n \n     pub fn volatile_store(&self, val: ValueRef, ptr: ValueRef) {\n         debug!(\"Store {} -> {}\",\n-               self.ccx.tn.val_to_string(val),\n-               self.ccx.tn.val_to_string(ptr));\n+               self.ccx.tn().val_to_string(val),\n+               self.ccx.tn().val_to_string(ptr));\n         assert!(self.llbuilder.is_not_null());\n         self.count_insn(\"store.volatile\");\n         unsafe {\n@@ -520,8 +520,8 @@ impl<'a> Builder<'a> {\n \n     pub fn atomic_store(&self, val: ValueRef, ptr: ValueRef, order: AtomicOrdering) {\n         debug!(\"Store {} -> {}\",\n-               self.ccx.tn.val_to_string(val),\n-               self.ccx.tn.val_to_string(ptr));\n+               self.ccx.tn().val_to_string(val),\n+               self.ccx.tn().val_to_string(ptr));\n         self.count_insn(\"store.atomic\");\n         unsafe {\n             let ty = Type::from_ref(llvm::LLVMTypeOf(ptr));\n@@ -794,11 +794,11 @@ impl<'a> Builder<'a> {\n                          else          { llvm::False };\n \n         let argtys = inputs.iter().map(|v| {\n-            debug!(\"Asm Input Type: {:?}\", self.ccx.tn.val_to_string(*v));\n+            debug!(\"Asm Input Type: {:?}\", self.ccx.tn().val_to_string(*v));\n             val_ty(*v)\n         }).collect::<Vec<_>>();\n \n-        debug!(\"Asm Output Type: {:?}\", self.ccx.tn.type_to_string(output));\n+        debug!(\"Asm Output Type: {:?}\", self.ccx.tn().type_to_string(output));\n         let fty = Type::func(argtys.as_slice(), &output);\n         unsafe {\n             let v = llvm::LLVMInlineAsm(\n@@ -812,9 +812,9 @@ impl<'a> Builder<'a> {\n         self.count_insn(\"call\");\n \n         debug!(\"Call {} with args ({})\",\n-               self.ccx.tn.val_to_string(llfn),\n+               self.ccx.tn().val_to_string(llfn),\n                args.iter()\n-                   .map(|&v| self.ccx.tn.val_to_string(v))\n+                   .map(|&v| self.ccx.tn().val_to_string(v))\n                    .collect::<Vec<String>>()\n                    .connect(\", \"));\n "}, {"sha": "90bd1521705f029bc0e5e7ad967a395e3fbb367d", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=cf35cb365a4efee53f6372095aaff4798544bf94", "patch": "@@ -146,7 +146,7 @@ fn coerce_to_int(ccx: &CrateContext, size: uint) -> Vec<Type> {\n     let r = size % 32;\n     if r > 0 {\n         unsafe {\n-            args.push(Type::from_ref(llvm::LLVMIntTypeInContext(ccx.llcx, r as c_uint)));\n+            args.push(Type::from_ref(llvm::LLVMIntTypeInContext(ccx.llcx(), r as c_uint)));\n         }\n     }\n "}, {"sha": "15d296ac723716188ea898cefe6788406ba792cd", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=cf35cb365a4efee53f6372095aaff4798544bf94", "patch": "@@ -87,7 +87,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n          */\n \n         debug!(\"push_ast_cleanup_scope({})\",\n-               self.ccx.tcx.map.node_to_string(id));\n+               self.ccx.tcx().map.node_to_string(id));\n \n         // FIXME(#2202) -- currently closure bodies have a parent\n         // region, which messes up the assertion below, since there\n@@ -101,7 +101,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n         // this new AST scope had better be its immediate child.\n         let top_scope = self.top_ast_scope();\n         if top_scope.is_some() {\n-            assert_eq!(self.ccx.tcx.region_maps.opt_encl_scope(id), top_scope);\n+            assert_eq!(self.ccx.tcx().region_maps.opt_encl_scope(id), top_scope);\n         }\n \n         self.push_scope(CleanupScope::new(AstScopeKind(id)));\n@@ -111,7 +111,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n                                id: ast::NodeId,\n                                exits: [&'a Block<'a>, ..EXIT_MAX]) {\n         debug!(\"push_loop_cleanup_scope({})\",\n-               self.ccx.tcx.map.node_to_string(id));\n+               self.ccx.tcx().map.node_to_string(id));\n         assert_eq!(Some(id), self.top_ast_scope());\n \n         self.push_scope(CleanupScope::new(LoopScopeKind(id, exits)));\n@@ -135,7 +135,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n          */\n \n         debug!(\"pop_and_trans_ast_cleanup_scope({})\",\n-               self.ccx.tcx.map.node_to_string(cleanup_scope));\n+               self.ccx.tcx().map.node_to_string(cleanup_scope));\n \n         assert!(self.top_scope(|s| s.kind.is_ast_with_id(cleanup_scope)));\n \n@@ -154,7 +154,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n          */\n \n         debug!(\"pop_loop_cleanup_scope({})\",\n-               self.ccx.tcx.map.node_to_string(cleanup_scope));\n+               self.ccx.tcx().map.node_to_string(cleanup_scope));\n \n         assert!(self.top_scope(|s| s.kind.is_loop_with_id(cleanup_scope)));\n \n@@ -237,7 +237,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n \n         debug!(\"schedule_lifetime_end({:?}, val={})\",\n                cleanup_scope,\n-               self.ccx.tn.val_to_string(val));\n+               self.ccx.tn().val_to_string(val));\n \n         self.schedule_clean(cleanup_scope, drop as CleanupObj);\n     }\n@@ -262,7 +262,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n \n         debug!(\"schedule_drop_mem({:?}, val={}, ty={})\",\n                cleanup_scope,\n-               self.ccx.tn.val_to_string(val),\n+               self.ccx.tn().val_to_string(val),\n                ty.repr(self.ccx.tcx()));\n \n         self.schedule_clean(cleanup_scope, drop as CleanupObj);\n@@ -288,7 +288,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n \n         debug!(\"schedule_drop_and_zero_mem({:?}, val={}, ty={}, zero={})\",\n                cleanup_scope,\n-               self.ccx.tn.val_to_string(val),\n+               self.ccx.tn().val_to_string(val),\n                ty.repr(self.ccx.tcx()),\n                true);\n \n@@ -314,7 +314,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n \n         debug!(\"schedule_drop_immediate({:?}, val={}, ty={})\",\n                cleanup_scope,\n-               self.ccx.tn.val_to_string(val),\n+               self.ccx.tn().val_to_string(val),\n                ty.repr(self.ccx.tcx()));\n \n         self.schedule_clean(cleanup_scope, drop as CleanupObj);\n@@ -334,7 +334,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n \n         debug!(\"schedule_free_value({:?}, val={}, heap={:?})\",\n                cleanup_scope,\n-               self.ccx.tn.val_to_string(val),\n+               self.ccx.tn().val_to_string(val),\n                heap);\n \n         self.schedule_clean(cleanup_scope, drop as CleanupObj);\n@@ -374,7 +374,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n \n         self.ccx.sess().bug(\n             format!(\"no cleanup scope {} found\",\n-                    self.ccx.tcx.map.node_to_string(cleanup_scope)).as_slice());\n+                    self.ccx.tcx().map.node_to_string(cleanup_scope)).as_slice());\n     }\n \n     fn schedule_clean_in_custom_scope(&self,\n@@ -720,7 +720,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n         let llpersonality = match pad_bcx.tcx().lang_items.eh_personality() {\n             Some(def_id) => callee::trans_fn_ref(pad_bcx, def_id, ExprId(0)),\n             None => {\n-                let mut personality = self.ccx.eh_personality.borrow_mut();\n+                let mut personality = self.ccx.eh_personality().borrow_mut();\n                 match *personality {\n                     Some(llpersonality) => llpersonality,\n                     None => {"}, {"sha": "4e9431f262911bb686dd47168399240e0f925cab", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=cf35cb365a4efee53f6372095aaff4798544bf94", "patch": "@@ -427,12 +427,12 @@ pub fn trans_expr_fn<'a>(\n pub fn get_or_create_declaration_if_unboxed_closure(ccx: &CrateContext,\n                                                     closure_id: ast::DefId)\n                                                     -> Option<ValueRef> {\n-    if !ccx.tcx.unboxed_closures.borrow().contains_key(&closure_id) {\n+    if !ccx.tcx().unboxed_closures.borrow().contains_key(&closure_id) {\n         // Not an unboxed closure.\n         return None\n     }\n \n-    match ccx.unboxed_closure_vals.borrow().find(&closure_id) {\n+    match ccx.unboxed_closure_vals().borrow().find(&closure_id) {\n         Some(llfn) => {\n             debug!(\"get_or_create_declaration_if_unboxed_closure(): found \\\n                     closure\");\n@@ -441,10 +441,10 @@ pub fn get_or_create_declaration_if_unboxed_closure(ccx: &CrateContext,\n         None => {}\n     }\n \n-    let function_type = ty::mk_unboxed_closure(&ccx.tcx,\n+    let function_type = ty::mk_unboxed_closure(ccx.tcx(),\n                                                closure_id,\n                                                ty::ReStatic);\n-    let symbol = ccx.tcx.map.with_path(closure_id.node, |path| {\n+    let symbol = ccx.tcx().map.with_path(closure_id.node, |path| {\n         mangle_internal_name_by_path_and_seq(path, \"unboxed_closure\")\n     });\n \n@@ -456,8 +456,8 @@ pub fn get_or_create_declaration_if_unboxed_closure(ccx: &CrateContext,\n     debug!(\"get_or_create_declaration_if_unboxed_closure(): inserting new \\\n             closure {} (type {})\",\n            closure_id,\n-           ccx.tn.type_to_string(val_ty(llfn)));\n-    ccx.unboxed_closure_vals.borrow_mut().insert(closure_id, llfn);\n+           ccx.tn().type_to_string(val_ty(llfn)));\n+    ccx.unboxed_closure_vals().borrow_mut().insert(closure_id, llfn);\n \n     Some(llfn)\n }\n@@ -554,7 +554,7 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n         }\n     };\n \n-    match ccx.closure_bare_wrapper_cache.borrow().find(&fn_ptr) {\n+    match ccx.closure_bare_wrapper_cache().borrow().find(&fn_ptr) {\n         Some(&llval) => return llval,\n         None => {}\n     }\n@@ -581,7 +581,7 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n         decl_rust_fn(ccx, closure_ty, name.as_slice())\n     };\n \n-    ccx.closure_bare_wrapper_cache.borrow_mut().insert(fn_ptr, llfn);\n+    ccx.closure_bare_wrapper_cache().borrow_mut().insert(fn_ptr, llfn);\n \n     // This is only used by statics inlined from a different crate.\n     if !is_local {"}, {"sha": "f0014827cc780e9eef9c0599932517dc715b8040", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=cf35cb365a4efee53f6372095aaff4798544bf94", "patch": "@@ -82,7 +82,7 @@ pub fn type_is_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n         ty::ty_struct(..) | ty::ty_enum(..) | ty::ty_tup(..) |\n         ty::ty_unboxed_closure(..) => {\n             let llty = sizing_type_of(ccx, ty);\n-            llsize_of_alloc(ccx, llty) <= llsize_of_alloc(ccx, ccx.int_type)\n+            llsize_of_alloc(ccx, llty) <= llsize_of_alloc(ccx, ccx.int_type())\n         }\n         _ => type_is_zero_size(ccx, ty)\n     }\n@@ -342,7 +342,7 @@ impl<'a> FunctionContext<'a> {\n \n             self.llreturn.set(Some(unsafe {\n                 \"return\".with_c_str(|buf| {\n-                    llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx, self.llfn, buf)\n+                    llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(), self.llfn, buf)\n                 })\n             }))\n         }\n@@ -365,7 +365,7 @@ impl<'a> FunctionContext<'a> {\n                      -> &'a Block<'a> {\n         unsafe {\n             let llbb = name.with_c_str(|buf| {\n-                    llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx,\n+                    llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(),\n                                                         self.llfn,\n                                                         buf)\n                 });\n@@ -451,7 +451,7 @@ impl<'a> Block<'a> {\n \n     pub fn ccx(&self) -> &'a CrateContext { self.fcx.ccx }\n     pub fn tcx(&self) -> &'a ty::ctxt {\n-        &self.fcx.ccx.tcx\n+        self.fcx.ccx.tcx()\n     }\n     pub fn sess(&self) -> &'a Session { self.fcx.ccx.sess() }\n \n@@ -478,11 +478,11 @@ impl<'a> Block<'a> {\n     }\n \n     pub fn val_to_string(&self, val: ValueRef) -> String {\n-        self.ccx().tn.val_to_string(val)\n+        self.ccx().tn().val_to_string(val)\n     }\n \n     pub fn llty_str(&self, ty: Type) -> String {\n-        self.ccx().tn.type_to_string(ty)\n+        self.ccx().tn().type_to_string(ty)\n     }\n \n     pub fn ty_to_string(&self, t: ty::t) -> String {\n@@ -601,11 +601,11 @@ pub fn C_u64(ccx: &CrateContext, i: u64) -> ValueRef {\n }\n \n pub fn C_int(ccx: &CrateContext, i: int) -> ValueRef {\n-    C_integral(ccx.int_type, i as u64, true)\n+    C_integral(ccx.int_type(), i as u64, true)\n }\n \n pub fn C_uint(ccx: &CrateContext, i: uint) -> ValueRef {\n-    C_integral(ccx.int_type, i as u64, false)\n+    C_integral(ccx.int_type(), i as u64, false)\n }\n \n pub fn C_u8(ccx: &CrateContext, i: uint) -> ValueRef {\n@@ -617,25 +617,25 @@ pub fn C_u8(ccx: &CrateContext, i: uint) -> ValueRef {\n // our boxed-and-length-annotated strings.\n pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> ValueRef {\n     unsafe {\n-        match cx.const_cstr_cache.borrow().find(&s) {\n+        match cx.const_cstr_cache().borrow().find(&s) {\n             Some(&llval) => return llval,\n             None => ()\n         }\n \n-        let sc = llvm::LLVMConstStringInContext(cx.llcx,\n+        let sc = llvm::LLVMConstStringInContext(cx.llcx(),\n                                                 s.get().as_ptr() as *const c_char,\n                                                 s.get().len() as c_uint,\n                                                 !null_terminated as Bool);\n \n         let gsym = token::gensym(\"str\");\n         let g = format!(\"str{}\", gsym.uint()).with_c_str(|buf| {\n-            llvm::LLVMAddGlobal(cx.llmod, val_ty(sc).to_ref(), buf)\n+            llvm::LLVMAddGlobal(cx.llmod(), val_ty(sc).to_ref(), buf)\n         });\n         llvm::LLVMSetInitializer(g, sc);\n         llvm::LLVMSetGlobalConstant(g, True);\n         llvm::SetLinkage(g, llvm::InternalLinkage);\n \n-        cx.const_cstr_cache.borrow_mut().insert(s, g);\n+        cx.const_cstr_cache().borrow_mut().insert(s, g);\n         g\n     }\n }\n@@ -647,7 +647,7 @@ pub fn C_str_slice(cx: &CrateContext, s: InternedString) -> ValueRef {\n         let len = s.get().len();\n         let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s, false),\n                                             Type::i8p(cx).to_ref());\n-        C_named_struct(cx.tn.find_type(\"str_slice\").unwrap(), [cs, C_uint(cx, len)])\n+        C_named_struct(cx.tn().find_type(\"str_slice\").unwrap(), [cs, C_uint(cx, len)])\n     }\n }\n \n@@ -658,7 +658,7 @@ pub fn C_binary_slice(cx: &CrateContext, data: &[u8]) -> ValueRef {\n \n         let gsym = token::gensym(\"binary\");\n         let g = format!(\"binary{}\", gsym.uint()).with_c_str(|buf| {\n-            llvm::LLVMAddGlobal(cx.llmod, val_ty(lldata).to_ref(), buf)\n+            llvm::LLVMAddGlobal(cx.llmod(), val_ty(lldata).to_ref(), buf)\n         });\n         llvm::LLVMSetInitializer(g, lldata);\n         llvm::LLVMSetGlobalConstant(g, True);\n@@ -671,7 +671,7 @@ pub fn C_binary_slice(cx: &CrateContext, data: &[u8]) -> ValueRef {\n \n pub fn C_struct(ccx: &CrateContext, elts: &[ValueRef], packed: bool) -> ValueRef {\n     unsafe {\n-        llvm::LLVMConstStructInContext(ccx.llcx,\n+        llvm::LLVMConstStructInContext(ccx.llcx(),\n                                        elts.as_ptr(), elts.len() as c_uint,\n                                        packed as Bool)\n     }\n@@ -692,7 +692,7 @@ pub fn C_array(ty: Type, elts: &[ValueRef]) -> ValueRef {\n pub fn C_bytes(ccx: &CrateContext, bytes: &[u8]) -> ValueRef {\n     unsafe {\n         let ptr = bytes.as_ptr() as *const c_char;\n-        return llvm::LLVMConstStringInContext(ccx.llcx, ptr, bytes.len() as c_uint, True);\n+        return llvm::LLVMConstStringInContext(ccx.llcx(), ptr, bytes.len() as c_uint, True);\n     }\n }\n \n@@ -702,7 +702,7 @@ pub fn const_get_elt(cx: &CrateContext, v: ValueRef, us: &[c_uint])\n         let r = llvm::LLVMConstExtractValue(v, us.as_ptr(), us.len() as c_uint);\n \n         debug!(\"const_get_elt(v={}, us={:?}, r={})\",\n-               cx.tn.val_to_string(v), us, cx.tn.val_to_string(r));\n+               cx.tn().val_to_string(v), us, cx.tn().val_to_string(r));\n \n         return r;\n     }"}, {"sha": "2571ae1fe72e1bd65fd2a9e14530fa7babc968f4", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=cf35cb365a4efee53f6372095aaff4798544bf94", "patch": "@@ -91,7 +91,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::Lit)\n pub fn const_ptrcast(cx: &CrateContext, a: ValueRef, t: Type) -> ValueRef {\n     unsafe {\n         let b = llvm::LLVMConstPointerCast(a, t.ptr_to().to_ref());\n-        assert!(cx.const_globals.borrow_mut().insert(b as int, a));\n+        assert!(cx.const_globals().borrow_mut().insert(b as int, a));\n         b\n     }\n }\n@@ -119,7 +119,7 @@ fn const_vec(cx: &CrateContext, e: &ast::Expr,\n pub fn const_addr_of(cx: &CrateContext, cv: ValueRef, mutbl: ast::Mutability) -> ValueRef {\n     unsafe {\n         let gv = \"const\".with_c_str(|name| {\n-            llvm::LLVMAddGlobal(cx.llmod, val_ty(cv).to_ref(), name)\n+            llvm::LLVMAddGlobal(cx.llmod(), val_ty(cv).to_ref(), name)\n         });\n         llvm::LLVMSetInitializer(gv, cv);\n         llvm::LLVMSetGlobalConstant(gv,\n@@ -130,7 +130,7 @@ pub fn const_addr_of(cx: &CrateContext, cv: ValueRef, mutbl: ast::Mutability) ->\n }\n \n fn const_deref_ptr(cx: &CrateContext, v: ValueRef) -> ValueRef {\n-    let v = match cx.const_globals.borrow().find(&(v as int)) {\n+    let v = match cx.const_globals().borrow().find(&(v as int)) {\n         Some(&v) => v,\n         None => v\n     };\n@@ -178,22 +178,22 @@ fn const_deref(cx: &CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n \n pub fn get_const_val(cx: &CrateContext,\n                      mut def_id: ast::DefId) -> (ValueRef, bool) {\n-    let contains_key = cx.const_values.borrow().contains_key(&def_id.node);\n+    let contains_key = cx.const_values().borrow().contains_key(&def_id.node);\n     if !ast_util::is_local(def_id) || !contains_key {\n         if !ast_util::is_local(def_id) {\n             def_id = inline::maybe_instantiate_inline(cx, def_id);\n         }\n \n-        match cx.tcx.map.expect_item(def_id.node).node {\n+        match cx.tcx().map.expect_item(def_id.node).node {\n             ast::ItemStatic(_, ast::MutImmutable, _) => {\n                 trans_const(cx, ast::MutImmutable, def_id.node);\n             }\n             _ => {}\n         }\n     }\n \n-    (cx.const_values.borrow().get_copy(&def_id.node),\n-     !cx.non_inlineable_statics.borrow().contains(&def_id.node))\n+    (cx.const_values().borrow().get_copy(&def_id.node),\n+     !cx.non_inlineable_statics().borrow().contains(&def_id.node))\n }\n \n pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef, bool, ty::t) {\n@@ -202,7 +202,7 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n     let mut inlineable = inlineable;\n     let ety = ty::expr_ty(cx.tcx(), e);\n     let mut ety_adjusted = ty::expr_ty_adjusted(cx.tcx(), e);\n-    let opt_adj = cx.tcx.adjustments.borrow().find_copy(&e.id);\n+    let opt_adj = cx.tcx().adjustments.borrow().find_copy(&e.id);\n     match opt_adj {\n         None => { }\n         Some(adj) => {\n@@ -523,7 +523,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               (expr::cast_enum, expr::cast_integral) => {\n                 let repr = adt::represent_type(cx, basety);\n                 let discr = adt::const_get_discrim(cx, &*repr, v);\n-                let iv = C_integral(cx.int_type, discr, false);\n+                let iv = C_integral(cx.int_type(), discr, false);\n                 let ety_cast = expr::cast_type_kind(cx.tcx(), ety);\n                 match ety_cast {\n                     expr::cast_integral => {\n@@ -690,7 +690,7 @@ pub fn trans_const(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) {\n         let g = base::get_item_val(ccx, id);\n         // At this point, get_item_val has already translated the\n         // constant's initializer to determine its LLVM type.\n-        let v = ccx.const_values.borrow().get_copy(&id);\n+        let v = ccx.const_values().borrow().get_copy(&id);\n         llvm::LLVMSetInitializer(g, v);\n         if m != ast::MutMutable {\n             llvm::LLVMSetGlobalConstant(g, True);"}, {"sha": "d3538afa972f339dead38bc7dc722812c36af403", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 214, "deletions": 48, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=cf35cb365a4efee53f6372095aaff4798544bf94", "patch": "@@ -11,7 +11,7 @@\n use driver::config::NoDebugInfo;\n use driver::session::Session;\n use llvm;\n-use llvm::{ContextRef, ModuleRef, ValueRef};\n+use llvm::{ContextRef, ModuleRef, ValueRef, BuilderRef};\n use llvm::{TargetData};\n use llvm::mk_target_data;\n use metadata::common::LinkMeta;\n@@ -52,38 +52,38 @@ pub struct Stats {\n }\n \n pub struct CrateContext {\n-    pub llmod: ModuleRef,\n-    pub llcx: ContextRef,\n-    pub metadata_llmod: ModuleRef,\n-    pub td: TargetData,\n-    pub tn: TypeNames,\n-    pub externs: RefCell<ExternMap>,\n-    pub item_vals: RefCell<NodeMap<ValueRef>>,\n-    pub exp_map2: resolve::ExportMap2,\n-    pub reachable: NodeSet,\n-    pub item_symbols: RefCell<NodeMap<String>>,\n-    pub link_meta: LinkMeta,\n-    pub drop_glues: RefCell<HashMap<ty::t, ValueRef>>,\n-    pub tydescs: RefCell<HashMap<ty::t, Rc<tydesc_info>>>,\n+    llmod: ModuleRef,\n+    llcx: ContextRef,\n+    metadata_llmod: ModuleRef,\n+    td: TargetData,\n+    tn: TypeNames,\n+    externs: RefCell<ExternMap>,\n+    item_vals: RefCell<NodeMap<ValueRef>>,\n+    exp_map2: resolve::ExportMap2,\n+    reachable: NodeSet,\n+    item_symbols: RefCell<NodeMap<String>>,\n+    link_meta: LinkMeta,\n+    drop_glues: RefCell<HashMap<ty::t, ValueRef>>,\n+    tydescs: RefCell<HashMap<ty::t, Rc<tydesc_info>>>,\n     /// Set when running emit_tydescs to enforce that no more tydescs are\n     /// created.\n-    pub finished_tydescs: Cell<bool>,\n+    finished_tydescs: Cell<bool>,\n     /// Track mapping of external ids to local items imported for inlining\n-    pub external: RefCell<DefIdMap<Option<ast::NodeId>>>,\n+    external: RefCell<DefIdMap<Option<ast::NodeId>>>,\n     /// Backwards version of the `external` map (inlined items to where they\n     /// came from)\n-    pub external_srcs: RefCell<NodeMap<ast::DefId>>,\n+    external_srcs: RefCell<NodeMap<ast::DefId>>,\n     /// A set of static items which cannot be inlined into other crates. This\n     /// will prevent in IIItem() structures from being encoded into the metadata\n     /// that is generated\n-    pub non_inlineable_statics: RefCell<NodeSet>,\n+    non_inlineable_statics: RefCell<NodeSet>,\n     /// Cache instances of monomorphized functions\n-    pub monomorphized: RefCell<HashMap<MonoId, ValueRef>>,\n-    pub monomorphizing: RefCell<DefIdMap<uint>>,\n+    monomorphized: RefCell<HashMap<MonoId, ValueRef>>,\n+    monomorphizing: RefCell<DefIdMap<uint>>,\n     /// Cache generated vtables\n-    pub vtables: RefCell<HashMap<(ty::t, MonoId), ValueRef>>,\n+    vtables: RefCell<HashMap<(ty::t, MonoId), ValueRef>>,\n     /// Cache of constant strings,\n-    pub const_cstr_cache: RefCell<HashMap<InternedString, ValueRef>>,\n+    const_cstr_cache: RefCell<HashMap<InternedString, ValueRef>>,\n \n     /// Reverse-direction for const ptrs cast from globals.\n     /// Key is an int, cast from a ValueRef holding a *T,\n@@ -93,37 +93,37 @@ pub struct CrateContext {\n     /// when we ptrcast, and we have to ptrcast during translation\n     /// of a [T] const because we form a slice, a [*T,int] pair, not\n     /// a pointer to an LLVM array type.\n-    pub const_globals: RefCell<HashMap<int, ValueRef>>,\n+    const_globals: RefCell<HashMap<int, ValueRef>>,\n \n     /// Cache of emitted const values\n-    pub const_values: RefCell<NodeMap<ValueRef>>,\n+    const_values: RefCell<NodeMap<ValueRef>>,\n \n     /// Cache of external const values\n-    pub extern_const_values: RefCell<DefIdMap<ValueRef>>,\n+    extern_const_values: RefCell<DefIdMap<ValueRef>>,\n \n-    pub impl_method_cache: RefCell<HashMap<(ast::DefId, ast::Name), ast::DefId>>,\n+    impl_method_cache: RefCell<HashMap<(ast::DefId, ast::Name), ast::DefId>>,\n \n     /// Cache of closure wrappers for bare fn's.\n-    pub closure_bare_wrapper_cache: RefCell<HashMap<ValueRef, ValueRef>>,\n-\n-    pub lltypes: RefCell<HashMap<ty::t, Type>>,\n-    pub llsizingtypes: RefCell<HashMap<ty::t, Type>>,\n-    pub adt_reprs: RefCell<HashMap<ty::t, Rc<adt::Repr>>>,\n-    pub symbol_hasher: RefCell<Sha256>,\n-    pub type_hashcodes: RefCell<HashMap<ty::t, String>>,\n-    pub all_llvm_symbols: RefCell<HashSet<String>>,\n-    pub tcx: ty::ctxt,\n-    pub stats: Stats,\n-    pub int_type: Type,\n-    pub opaque_vec_type: Type,\n-    pub builder: BuilderRef_res,\n+    closure_bare_wrapper_cache: RefCell<HashMap<ValueRef, ValueRef>>,\n+\n+    lltypes: RefCell<HashMap<ty::t, Type>>,\n+    llsizingtypes: RefCell<HashMap<ty::t, Type>>,\n+    adt_reprs: RefCell<HashMap<ty::t, Rc<adt::Repr>>>,\n+    symbol_hasher: RefCell<Sha256>,\n+    type_hashcodes: RefCell<HashMap<ty::t, String>>,\n+    all_llvm_symbols: RefCell<HashSet<String>>,\n+    tcx: ty::ctxt,\n+    stats: Stats,\n+    int_type: Type,\n+    opaque_vec_type: Type,\n+    builder: BuilderRef_res,\n \n     /// Holds the LLVM values for closure IDs.\n-    pub unboxed_closure_vals: RefCell<DefIdMap<ValueRef>>,\n+    unboxed_closure_vals: RefCell<DefIdMap<ValueRef>>,\n \n-    pub dbg_cx: Option<debuginfo::CrateDebugContext>,\n+    dbg_cx: Option<debuginfo::CrateDebugContext>,\n \n-    pub eh_personality: RefCell<Option<ValueRef>>,\n+    eh_personality: RefCell<Option<ValueRef>>,\n \n     intrinsics: RefCell<HashMap<&'static str, ValueRef>>,\n }\n@@ -235,10 +235,10 @@ impl CrateContext {\n             ccx.opaque_vec_type = Type::opaque_vec(&ccx);\n \n             let mut str_slice_ty = Type::named_struct(&ccx, \"str_slice\");\n-            str_slice_ty.set_struct_body([Type::i8p(&ccx), ccx.int_type], false);\n-            ccx.tn.associate_type(\"str_slice\", &str_slice_ty);\n+            str_slice_ty.set_struct_body([Type::i8p(&ccx), ccx.int_type()], false);\n+            ccx.tn().associate_type(\"str_slice\", &str_slice_ty);\n \n-            ccx.tn.associate_type(\"tydesc\", &Type::tydesc(&ccx, str_slice_ty));\n+            ccx.tn().associate_type(\"tydesc\", &Type::tydesc(&ccx, str_slice_ty));\n \n             if ccx.sess().count_llvm_insns() {\n                 base::init_insn_ctxt()\n@@ -252,6 +252,10 @@ impl CrateContext {\n         &self.tcx\n     }\n \n+    pub fn take_tcx(self) -> ty::ctxt {\n+        self.tcx\n+    }\n+\n     pub fn sess<'a>(&'a self) -> &'a Session {\n         &self.tcx.sess\n     }\n@@ -260,6 +264,10 @@ impl CrateContext {\n         Builder::new(self)\n     }\n \n+    pub fn raw_builder<'a>(&'a self) -> BuilderRef {\n+        self.builder.b\n+    }\n+\n     pub fn tydesc_type(&self) -> Type {\n         self.tn.find_type(\"tydesc\").unwrap()\n     }\n@@ -286,22 +294,180 @@ impl CrateContext {\n         let ref cfg = self.sess().targ_cfg;\n         cfg.os != abi::OsiOS || cfg.arch != abi::Arm\n     }\n+\n+\n+    pub fn llmod(&self) -> ModuleRef {\n+        self.llmod\n+    }\n+\n+    pub fn llcx(&self) -> ContextRef {\n+        self.llcx\n+    }\n+\n+    pub fn metadata_llmod(&self) -> ModuleRef {\n+        self.metadata_llmod\n+    }\n+\n+    pub fn td<'a>(&'a self) -> &'a TargetData {\n+        &self.td\n+    }\n+\n+    pub fn tn<'a>(&'a self) -> &'a TypeNames {\n+        &self.tn\n+    }\n+\n+    pub fn externs<'a>(&'a self) -> &'a RefCell<ExternMap> {\n+        &self.externs\n+    }\n+\n+    pub fn item_vals<'a>(&'a self) -> &'a RefCell<NodeMap<ValueRef>> {\n+        &self.item_vals\n+    }\n+\n+    pub fn exp_map2<'a>(&'a self) -> &'a resolve::ExportMap2 {\n+        &self.exp_map2\n+    }\n+\n+    pub fn reachable<'a>(&'a self) -> &'a NodeSet {\n+        &self.reachable\n+    }\n+\n+    pub fn item_symbols<'a>(&'a self) -> &'a RefCell<NodeMap<String>> {\n+        &self.item_symbols\n+    }\n+\n+    pub fn link_meta<'a>(&'a self) -> &'a LinkMeta {\n+        &self.link_meta\n+    }\n+\n+    pub fn drop_glues<'a>(&'a self) -> &'a RefCell<HashMap<ty::t, ValueRef>> {\n+        &self.drop_glues\n+    }\n+\n+    pub fn tydescs<'a>(&'a self) -> &'a RefCell<HashMap<ty::t, Rc<tydesc_info>>> {\n+        &self.tydescs\n+    }\n+\n+    pub fn finished_tydescs<'a>(&'a self) -> &'a Cell<bool> {\n+        &self.finished_tydescs\n+    }\n+\n+    pub fn external<'a>(&'a self) -> &'a RefCell<DefIdMap<Option<ast::NodeId>>> {\n+        &self.external\n+    }\n+\n+    pub fn external_srcs<'a>(&'a self) -> &'a RefCell<NodeMap<ast::DefId>> {\n+        &self.external_srcs\n+    }\n+\n+    pub fn non_inlineable_statics<'a>(&'a self) -> &'a RefCell<NodeSet> {\n+        &self.non_inlineable_statics\n+    }\n+\n+    pub fn monomorphized<'a>(&'a self) -> &'a RefCell<HashMap<MonoId, ValueRef>> {\n+        &self.monomorphized\n+    }\n+\n+    pub fn monomorphizing<'a>(&'a self) -> &'a RefCell<DefIdMap<uint>> {\n+        &self.monomorphizing\n+    }\n+\n+    pub fn vtables<'a>(&'a self) -> &'a RefCell<HashMap<(ty::t, MonoId), ValueRef>> {\n+        &self.vtables\n+    }\n+\n+    pub fn const_cstr_cache<'a>(&'a self) -> &'a RefCell<HashMap<InternedString, ValueRef>> {\n+        &self.const_cstr_cache\n+    }\n+\n+    pub fn const_globals<'a>(&'a self) -> &'a RefCell<HashMap<int, ValueRef>> {\n+        &self.const_globals\n+    }\n+\n+    pub fn const_values<'a>(&'a self) -> &'a RefCell<NodeMap<ValueRef>> {\n+        &self.const_values\n+    }\n+\n+    pub fn extern_const_values<'a>(&'a self) -> &'a RefCell<DefIdMap<ValueRef>> {\n+        &self.extern_const_values\n+    }\n+\n+    pub fn impl_method_cache<'a>(&'a self)\n+            -> &'a RefCell<HashMap<(ast::DefId, ast::Name), ast::DefId>> {\n+        &self.impl_method_cache\n+    }\n+\n+    pub fn closure_bare_wrapper_cache<'a>(&'a self) -> &'a RefCell<HashMap<ValueRef, ValueRef>> {\n+        &self.closure_bare_wrapper_cache\n+    }\n+\n+    pub fn lltypes<'a>(&'a self) -> &'a RefCell<HashMap<ty::t, Type>> {\n+        &self.lltypes\n+    }\n+\n+    pub fn llsizingtypes<'a>(&'a self) -> &'a RefCell<HashMap<ty::t, Type>> {\n+        &self.llsizingtypes\n+    }\n+\n+    pub fn adt_reprs<'a>(&'a self) -> &'a RefCell<HashMap<ty::t, Rc<adt::Repr>>> {\n+        &self.adt_reprs\n+    }\n+\n+    pub fn symbol_hasher<'a>(&'a self) -> &'a RefCell<Sha256> {\n+        &self.symbol_hasher\n+    }\n+\n+    pub fn type_hashcodes<'a>(&'a self) -> &'a RefCell<HashMap<ty::t, String>> {\n+        &self.type_hashcodes\n+    }\n+\n+    pub fn all_llvm_symbols<'a>(&'a self) -> &'a RefCell<HashSet<String>> {\n+        &self.all_llvm_symbols\n+    }\n+\n+    pub fn stats<'a>(&'a self) -> &'a Stats {\n+        &self.stats\n+    }\n+\n+    pub fn int_type(&self) -> Type {\n+        self.int_type\n+    }\n+\n+    pub fn opaque_vec_type(&self) -> Type {\n+        self.opaque_vec_type\n+    }\n+\n+    pub fn unboxed_closure_vals<'a>(&'a self) -> &'a RefCell<DefIdMap<ValueRef>> {\n+        &self.unboxed_closure_vals\n+    }\n+\n+    pub fn dbg_cx<'a>(&'a self) -> &'a Option<debuginfo::CrateDebugContext> {\n+        &self.dbg_cx\n+    }\n+\n+    pub fn eh_personality<'a>(&'a self) -> &'a RefCell<Option<ValueRef>> {\n+        &self.eh_personality\n+    }\n+\n+    fn intrinsics<'a>(&'a self) -> &'a RefCell<HashMap<&'static str, ValueRef>> {\n+        &self.intrinsics\n+    }\n }\n \n fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef> {\n     macro_rules! ifn (\n         ($name:expr fn() -> $ret:expr) => (\n             if *key == $name {\n                 let f = base::decl_cdecl_fn(ccx, $name, Type::func([], &$ret), ty::mk_nil());\n-                ccx.intrinsics.borrow_mut().insert($name, f.clone());\n+                ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr fn($($arg:expr),*) -> $ret:expr) => (\n             if *key == $name {\n                 let f = base::decl_cdecl_fn(ccx, $name,\n                                   Type::func([$($arg),*], &$ret), ty::mk_nil());\n-                ccx.intrinsics.borrow_mut().insert($name, f.clone());\n+                ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         )\n@@ -437,7 +603,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n                 let f = base::decl_cdecl_fn(ccx, stringify!($cname),\n                                       Type::func([$($arg),*], &$ret),\n                                       ty::mk_nil());\n-                ccx.intrinsics.borrow_mut().insert($name, f.clone());\n+                ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         )"}, {"sha": "008af804a60ba4e59f52f67afca2426d504dc23d", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=cf35cb365a4efee53f6372095aaff4798544bf94", "patch": "@@ -627,7 +627,7 @@ impl<K:KindOps> Datum<K> {\n     #[allow(dead_code)] // useful for debugging\n     pub fn to_string(&self, ccx: &CrateContext) -> String {\n         format!(\"Datum({}, {}, {:?})\",\n-                ccx.tn.val_to_string(self.val),\n+                ccx.tn().val_to_string(self.val),\n                 ty_to_string(ccx.tcx(), self.ty),\n                 self.kind)\n     }"}, {"sha": "01633bea9565ca6803c83a417a44835c94928704", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=cf35cb365a4efee53f6372095aaff4798544bf94", "patch": "@@ -538,7 +538,7 @@ impl TypeMap {\n             // First, find out the 'real' def_id of the type. Items inlined from\n             // other crates have to be mapped back to their source.\n             let source_def_id = if def_id.krate == ast::LOCAL_CRATE {\n-                match cx.external_srcs.borrow().find_copy(&def_id.node) {\n+                match cx.external_srcs().borrow().find_copy(&def_id.node) {\n                     Some(source_def_id) => {\n                         // The given def_id identifies the inlined copy of a\n                         // type definition, let's take the source of the copy.\n@@ -552,7 +552,7 @@ impl TypeMap {\n \n             // Get the crate hash as first part of the identifier.\n             let crate_hash = if source_def_id.krate == ast::LOCAL_CRATE {\n-                cx.link_meta.crate_hash.clone()\n+                cx.link_meta().crate_hash.clone()\n             } else {\n                 cx.sess().cstore.get_crate_hash(source_def_id.krate)\n             };\n@@ -721,7 +721,7 @@ enum VariableKind {\n \n /// Create any deferred debug metadata nodes\n pub fn finalize(cx: &CrateContext) {\n-    if cx.dbg_cx.is_none() {\n+    if cx.dbg_cx().is_none() {\n         return;\n     }\n \n@@ -738,18 +738,18 @@ pub fn finalize(cx: &CrateContext) {\n         if cx.sess().targ_cfg.os == abi::OsMacos ||\n             cx.sess().targ_cfg.os == abi::OsiOS {\n             \"Dwarf Version\".with_c_str(\n-                |s| llvm::LLVMRustAddModuleFlag(cx.llmod, s, 2));\n+                |s| llvm::LLVMRustAddModuleFlag(cx.llmod(), s, 2));\n         } else {\n             // FIXME(#13611) this is a kludge fix because the Linux bots have\n             //               gdb 7.4 which doesn't understand dwarf4, we should\n             //               do something more graceful here.\n             \"Dwarf Version\".with_c_str(\n-                |s| llvm::LLVMRustAddModuleFlag(cx.llmod, s, 3));\n+                |s| llvm::LLVMRustAddModuleFlag(cx.llmod(), s, 3));\n         }\n \n         // Prevent bitcode readers from deleting the debug info.\n         \"Debug Info Version\".with_c_str(\n-            |s| llvm::LLVMRustAddModuleFlag(cx.llmod, s,\n+            |s| llvm::LLVMRustAddModuleFlag(cx.llmod(), s,\n                                             llvm::LLVMRustDebugMetadataVersion));\n     };\n }\n@@ -760,19 +760,19 @@ pub fn finalize(cx: &CrateContext) {\n pub fn create_global_var_metadata(cx: &CrateContext,\n                                   node_id: ast::NodeId,\n                                   global: ValueRef) {\n-    if cx.dbg_cx.is_none() {\n+    if cx.dbg_cx().is_none() {\n         return;\n     }\n \n     // Don't create debuginfo for globals inlined from other crates. The other\n     // crate should already contain debuginfo for it. More importantly, the\n     // global might not even exist in un-inlined form anywhere which would lead\n     // to a linker errors.\n-    if cx.external_srcs.borrow().contains_key(&node_id) {\n+    if cx.external_srcs().borrow().contains_key(&node_id) {\n         return;\n     }\n \n-    let var_item = cx.tcx.map.get(node_id);\n+    let var_item = cx.tcx().map.get(node_id);\n \n     let (ident, span) = match var_item {\n         ast_map::NodeItem(item) => {\n@@ -838,7 +838,7 @@ pub fn create_local_var_metadata(bcx: &Block, local: &ast::Local) {\n     }\n \n     let cx = bcx.ccx();\n-    let def_map = &cx.tcx.def_map;\n+    let def_map = &cx.tcx().def_map;\n \n     pat_util::pat_bindings(def_map, &*local.pat, |_, node_id, span, path1| {\n         let var_ident = path1.node;\n@@ -880,7 +880,7 @@ pub fn create_captured_var_metadata(bcx: &Block,\n \n     let cx = bcx.ccx();\n \n-    let ast_item = cx.tcx.map.find(node_id);\n+    let ast_item = cx.tcx().map.find(node_id);\n \n     let variable_ident = match ast_item {\n         None => {\n@@ -963,7 +963,7 @@ pub fn create_match_binding_metadata(bcx: &Block,\n \n     let scope_metadata = scope_metadata(bcx.fcx, binding.id, binding.span);\n     let aops = unsafe {\n-        [llvm::LLVMDIBuilderCreateOpDeref(bcx.ccx().int_type.to_ref())]\n+        [llvm::LLVMDIBuilderCreateOpDeref(bcx.ccx().int_type().to_ref())]\n     };\n     // Regardless of the actual type (`T`) we're always passed the stack slot (alloca)\n     // for the binding. For ByRef bindings that's a `T*` but for ByMove bindings we\n@@ -1002,7 +1002,7 @@ pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n     let fcx = bcx.fcx;\n     let cx = fcx.ccx;\n \n-    let def_map = &cx.tcx.def_map;\n+    let def_map = &cx.tcx().def_map;\n     let scope_metadata = bcx.fcx.debug_context.get_ref(cx, arg.pat.span).fn_metadata;\n \n     pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, path1| {\n@@ -1120,7 +1120,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n \n     let empty_generics = ast_util::empty_generics();\n \n-    let fnitem = cx.tcx.map.get(fn_ast_id);\n+    let fnitem = cx.tcx().map.get(fn_ast_id);\n \n     let (ident, fn_decl, generics, top_level_block, span, has_path) = match fnitem {\n         ast_map::NodeItem(ref item) => {\n@@ -1447,7 +1447,7 @@ fn is_node_local_to_unit(cx: &CrateContext, node_id: ast::NodeId) -> bool\n     // externally visible or by being inlined into something externally visible).\n     // It might better to use the `exported_items` set from `driver::CrateAnalysis`\n     // in the future, but (atm) this set is not available in the translation pass.\n-    !cx.reachable.contains(&node_id)\n+    !cx.reachable().contains(&node_id)\n }\n \n #[allow(non_snake_case)]\n@@ -1514,7 +1514,7 @@ fn compile_unit_metadata(cx: &CrateContext) {\n     });\n \n     fn fallback_path(cx: &CrateContext) -> CString {\n-        cx.link_meta.crate_name.as_slice().to_c_str()\n+        cx.link_meta().crate_name.as_slice().to_c_str()\n     }\n }\n \n@@ -1643,7 +1643,7 @@ fn scope_metadata(fcx: &FunctionContext,\n     match scope_map.borrow().find_copy(&node_id) {\n         Some(scope_metadata) => scope_metadata,\n         None => {\n-            let node = fcx.ccx.tcx.map.get(node_id);\n+            let node = fcx.ccx.tcx().map.get(node_id);\n \n             fcx.ccx.sess().span_bug(span,\n                 format!(\"debuginfo: Could not find scope info for node {:?}\",\n@@ -2440,9 +2440,9 @@ fn prepare_enum_metadata(cx: &CrateContext,\n                                   def_id: ast::DefId)\n                                   -> token::InternedString {\n         let name = if def_id.krate == ast::LOCAL_CRATE {\n-            cx.tcx.map.get_path_elem(def_id.node).name()\n+            cx.tcx().map.get_path_elem(def_id.node).name()\n         } else {\n-            csearch::get_item_path(&cx.tcx, def_id).last().unwrap().name()\n+            csearch::get_item_path(cx.tcx(), def_id).last().unwrap().name()\n         };\n \n         token::get_name(name)\n@@ -2685,7 +2685,7 @@ fn at_box_metadata(cx: &CrateContext,\n                              content_llvm_type: Type)\n                           -> bool {\n         member_llvm_types.len() == 5 &&\n-        member_llvm_types[0] == cx.int_type &&\n+        member_llvm_types[0] == cx.int_type() &&\n         member_llvm_types[1] == Type::generic_glue_fn(cx).ptr_to() &&\n         member_llvm_types[2] == Type::i8(cx).ptr_to() &&\n         member_llvm_types[3] == Type::i8(cx).ptr_to() &&\n@@ -2787,7 +2787,7 @@ fn vec_slice_metadata(cx: &CrateContext,\n                             -> bool {\n         member_llvm_types.len() == 2 &&\n         member_llvm_types[0] == type_of::type_of(cx, element_type).ptr_to() &&\n-        member_llvm_types[1] == cx.int_type\n+        member_llvm_types[1] == cx.int_type()\n     }\n }\n \n@@ -3090,7 +3090,7 @@ fn set_debug_location(cx: &CrateContext, debug_location: DebugLocation) {\n     };\n \n     unsafe {\n-        llvm::LLVMSetCurrentDebugLocation(cx.builder.b, metadata_node);\n+        llvm::LLVMSetCurrentDebugLocation(cx.raw_builder(), metadata_node);\n     }\n \n     debug_context(cx).current_debug_location.set(debug_location);\n@@ -3125,14 +3125,14 @@ fn bytes_to_bits(bytes: u64) -> c_ulonglong {\n \n #[inline]\n fn debug_context<'a>(cx: &'a CrateContext) -> &'a CrateDebugContext {\n-    let debug_context: &'a CrateDebugContext = cx.dbg_cx.get_ref();\n+    let debug_context: &'a CrateDebugContext = cx.dbg_cx().get_ref();\n     debug_context\n }\n \n #[inline]\n #[allow(non_snake_case)]\n fn DIB(cx: &CrateContext) -> DIBuilderRef {\n-    cx.dbg_cx.get_ref().builder\n+    cx.dbg_cx().get_ref().builder\n }\n \n fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n@@ -3143,7 +3143,7 @@ fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n }\n \n fn assert_type_for_node_id(cx: &CrateContext, node_id: ast::NodeId, error_span: Span) {\n-    if !cx.tcx.node_types.borrow().contains_key(&(node_id as uint)) {\n+    if !cx.tcx().node_types.borrow().contains_key(&(node_id as uint)) {\n         cx.sess().span_bug(error_span, \"debuginfo: Could not find type for node id!\");\n     }\n }\n@@ -3152,7 +3152,7 @@ fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: ast::DefId)\n                                    -> (DIScope, Span) {\n     let containing_scope = namespace_for_item(cx, def_id).scope;\n     let definition_span = if def_id.krate == ast::LOCAL_CRATE {\n-        cx.tcx.map.span(def_id.node)\n+        cx.tcx().map.span(def_id.node)\n     } else {\n         // For external items there is no span information\n         codemap::DUMMY_SP\n@@ -3173,7 +3173,7 @@ fn populate_scope_map(cx: &CrateContext,\n                       fn_entry_block: &ast::Block,\n                       fn_metadata: DISubprogram,\n                       scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n-    let def_map = &cx.tcx.def_map;\n+    let def_map = &cx.tcx().def_map;\n \n     struct ScopeStackEntry {\n         scope_metadata: DIScope,\n@@ -3290,7 +3290,7 @@ fn populate_scope_map(cx: &CrateContext,\n                     scope_stack: &mut Vec<ScopeStackEntry> ,\n                     scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n \n-        let def_map = &cx.tcx.def_map;\n+        let def_map = &cx.tcx().def_map;\n \n         // Unfortunately, we cannot just use pat_util::pat_bindings() or\n         // ast_util::walk_pat() here because we have to visit *all* nodes in\n@@ -3942,7 +3942,7 @@ impl NamespaceTreeNode {\n }\n \n fn crate_root_namespace<'a>(cx: &'a CrateContext) -> &'a str {\n-    cx.link_meta.crate_name.as_slice()\n+    cx.link_meta().crate_name.as_slice()\n }\n \n fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTreeNode> {"}, {"sha": "fcb0ac9d9306f2b98a2814cabe62378aadc80677", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=cf35cb365a4efee53f6372095aaff4798544bf94", "patch": "@@ -94,7 +94,7 @@ pub enum Dest {\n impl Dest {\n     pub fn to_string(&self, ccx: &CrateContext) -> String {\n         match *self {\n-            SaveIn(v) => format!(\"SaveIn({})\", ccx.tn.val_to_string(v)),\n+            SaveIn(v) => format!(\"SaveIn({})\", ccx.tn().val_to_string(v)),\n             Ignore => \"Ignore\".to_string()\n         }\n     }\n@@ -711,7 +711,7 @@ fn trans_index<'a>(bcx: &'a Block<'a>,\n     let mut bcx = bcx;\n \n     // Check for overloaded index.\n-    let method_ty = ccx.tcx\n+    let method_ty = ccx.tcx()\n                        .method_map\n                        .borrow()\n                        .find(&method_call)\n@@ -758,14 +758,14 @@ fn trans_index<'a>(bcx: &'a Block<'a>,\n             let ix_size = machine::llbitsize_of_real(bcx.ccx(),\n                                                      val_ty(ix_val));\n             let int_size = machine::llbitsize_of_real(bcx.ccx(),\n-                                                      ccx.int_type);\n+                                                      ccx.int_type());\n             let ix_val = {\n                 if ix_size < int_size {\n                     if ty::type_is_signed(expr_ty(bcx, idx)) {\n-                        SExt(bcx, ix_val, ccx.int_type)\n-                    } else { ZExt(bcx, ix_val, ccx.int_type) }\n+                        SExt(bcx, ix_val, ccx.int_type())\n+                    } else { ZExt(bcx, ix_val, ccx.int_type()) }\n                 } else if ix_size > int_size {\n-                    Trunc(bcx, ix_val, ccx.int_type)\n+                    Trunc(bcx, ix_val, ccx.int_type())\n                 } else {\n                     ix_val\n                 }\n@@ -839,7 +839,7 @@ fn trans_def<'a>(bcx: &'a Block<'a>,\n                     let pty = type_of::type_of(bcx.ccx(), const_ty).ptr_to();\n                     PointerCast(bcx, val, pty)\n                 } else {\n-                    match bcx.ccx().extern_const_values.borrow().find(&did) {\n+                    match bcx.ccx().extern_const_values().borrow().find(&did) {\n                         None => {}  // Continue.\n                         Some(llval) => {\n                             return *llval;\n@@ -852,11 +852,11 @@ fn trans_def<'a>(bcx: &'a Block<'a>,\n                             &bcx.ccx().sess().cstore,\n                             did);\n                         let llval = symbol.as_slice().with_c_str(|buf| {\n-                                llvm::LLVMAddGlobal(bcx.ccx().llmod,\n+                                llvm::LLVMAddGlobal(bcx.ccx().llmod(),\n                                                     llty.to_ref(),\n                                                     buf)\n                             });\n-                        bcx.ccx().extern_const_values.borrow_mut()\n+                        bcx.ccx().extern_const_values().borrow_mut()\n                            .insert(did, llval);\n                         llval\n                     }\n@@ -1439,7 +1439,7 @@ fn trans_unary<'a>(bcx: &'a Block<'a>,\n     // Otherwise, we should be in the RvalueDpsExpr path.\n     assert!(\n         op == ast::UnDeref ||\n-        !ccx.tcx.method_map.borrow().contains_key(&method_call));\n+        !ccx.tcx().method_map.borrow().contains_key(&method_call));\n \n     let un_ty = expr_ty(bcx, expr);\n \n@@ -1706,7 +1706,7 @@ fn trans_binary<'a>(bcx: &'a Block<'a>,\n     let ccx = bcx.ccx();\n \n     // if overloaded, would be RvalueDpsExpr\n-    assert!(!ccx.tcx.method_map.borrow().contains_key(&MethodCall::expr(expr.id)));\n+    assert!(!ccx.tcx().method_map.borrow().contains_key(&MethodCall::expr(expr.id)));\n \n     match op {\n         ast::BiAnd => {\n@@ -2050,7 +2050,7 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n     let mut bcx = bcx;\n \n     // Check for overloaded deref.\n-    let method_ty = ccx.tcx.method_map.borrow()\n+    let method_ty = ccx.tcx().method_map.borrow()\n                        .find(&method_call).map(|method| method.ty);\n     let datum = match method_ty {\n         Some(method_ty) => {"}, {"sha": "240c109e17bd32ee49d0226721c6f1297a8e1008", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=cf35cb365a4efee53f6372095aaff4798544bf94", "patch": "@@ -160,14 +160,14 @@ pub fn register_static(ccx: &CrateContext,\n             };\n             unsafe {\n                 let g1 = ident.get().with_c_str(|buf| {\n-                    llvm::LLVMAddGlobal(ccx.llmod, llty2.to_ref(), buf)\n+                    llvm::LLVMAddGlobal(ccx.llmod(), llty2.to_ref(), buf)\n                 });\n                 llvm::SetLinkage(g1, linkage);\n \n                 let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n                 real_name.push_str(ident.get());\n                 let g2 = real_name.with_c_str(|buf| {\n-                    llvm::LLVMAddGlobal(ccx.llmod, llty.to_ref(), buf)\n+                    llvm::LLVMAddGlobal(ccx.llmod(), llty.to_ref(), buf)\n                 });\n                 llvm::SetLinkage(g2, llvm::InternalLinkage);\n                 llvm::LLVMSetInitializer(g2, g1);\n@@ -176,7 +176,7 @@ pub fn register_static(ccx: &CrateContext,\n         }\n         None => unsafe {\n             ident.get().with_c_str(|buf| {\n-                llvm::LLVMAddGlobal(ccx.llmod, llty.to_ref(), buf)\n+                llvm::LLVMAddGlobal(ccx.llmod(), llty.to_ref(), buf)\n             })\n         }\n     }\n@@ -229,7 +229,7 @@ pub fn register_foreign_item_fn(ccx: &CrateContext, abi: Abi, fty: ty::t,\n     let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n \n     let llfn = base::get_extern_fn(ccx,\n-                                   &mut *ccx.externs.borrow_mut(),\n+                                   &mut *ccx.externs().borrow_mut(),\n                                    name,\n                                    cc,\n                                    llfn_ty,\n@@ -271,8 +271,8 @@ pub fn trans_native_call<'a>(\n             llfn={}, \\\n             llretptr={})\",\n            callee_ty.repr(tcx),\n-           ccx.tn.val_to_string(llfn),\n-           ccx.tn.val_to_string(llretptr));\n+           ccx.tn().val_to_string(llfn),\n+           ccx.tn().val_to_string(llretptr));\n \n     let (fn_abi, fn_sig) = match ty::get(callee_ty).sty {\n         ty::ty_bare_fn(ref fn_ty) => (fn_ty.abi, fn_ty.sig.clone()),\n@@ -319,9 +319,9 @@ pub fn trans_native_call<'a>(\n \n         debug!(\"argument {}, llarg_rust={}, rust_indirect={}, arg_ty={}\",\n                i,\n-               ccx.tn.val_to_string(llarg_rust),\n+               ccx.tn().val_to_string(llarg_rust),\n                rust_indirect,\n-               ccx.tn.type_to_string(arg_tys[i].ty));\n+               ccx.tn().type_to_string(arg_tys[i].ty));\n \n         // Ensure that we always have the Rust value indirectly,\n         // because it makes bitcasting easier.\n@@ -335,7 +335,7 @@ pub fn trans_native_call<'a>(\n         }\n \n         debug!(\"llarg_rust={} (after indirection)\",\n-               ccx.tn.val_to_string(llarg_rust));\n+               ccx.tn().val_to_string(llarg_rust));\n \n         // Check whether we need to do any casting\n         match arg_tys[i].cast {\n@@ -344,7 +344,7 @@ pub fn trans_native_call<'a>(\n         }\n \n         debug!(\"llarg_rust={} (after casting)\",\n-               ccx.tn.val_to_string(llarg_rust));\n+               ccx.tn().val_to_string(llarg_rust));\n \n         // Finally, load the value if needed for the foreign ABI\n         let foreign_indirect = arg_tys[i].is_indirect();\n@@ -360,7 +360,7 @@ pub fn trans_native_call<'a>(\n         };\n \n         debug!(\"argument {}, llarg_foreign={}\",\n-               i, ccx.tn.val_to_string(llarg_foreign));\n+               i, ccx.tn().val_to_string(llarg_foreign));\n \n         // fill padding with undef value\n         match arg_tys[i].pad {\n@@ -438,10 +438,10 @@ pub fn trans_native_call<'a>(\n             None => fn_type.ret_ty.ty\n         };\n \n-        debug!(\"llretptr={}\", ccx.tn.val_to_string(llretptr));\n-        debug!(\"llforeign_retval={}\", ccx.tn.val_to_string(llforeign_retval));\n-        debug!(\"llrust_ret_ty={}\", ccx.tn.type_to_string(llrust_ret_ty));\n-        debug!(\"llforeign_ret_ty={}\", ccx.tn.type_to_string(llforeign_ret_ty));\n+        debug!(\"llretptr={}\", ccx.tn().val_to_string(llretptr));\n+        debug!(\"llforeign_retval={}\", ccx.tn().val_to_string(llforeign_retval));\n+        debug!(\"llrust_ret_ty={}\", ccx.tn().type_to_string(llrust_ret_ty));\n+        debug!(\"llforeign_ret_ty={}\", ccx.tn().type_to_string(llforeign_ret_ty));\n \n         if llrust_ret_ty == llforeign_ret_ty {\n             base::store_ty(bcx, llforeign_retval, llretptr, fn_sig.output)\n@@ -496,7 +496,7 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n             _ => {}\n         }\n \n-        ccx.item_symbols.borrow_mut().insert(foreign_item.id,\n+        ccx.item_symbols().borrow_mut().insert(foreign_item.id,\n                                              lname.get().to_string());\n     }\n }\n@@ -542,7 +542,7 @@ pub fn decl_rust_fn_with_foreign_abi(ccx: &CrateContext,\n     let llfn = base::decl_fn(ccx, name, cconv, llfn_ty, ty::mk_nil());\n     add_argument_attributes(&tys, llfn);\n     debug!(\"decl_rust_fn_with_foreign_abi(llfn_ty={}, llfn={})\",\n-           ccx.tn.type_to_string(llfn_ty), ccx.tn.val_to_string(llfn));\n+           ccx.tn().type_to_string(llfn_ty), ccx.tn().val_to_string(llfn));\n     llfn\n }\n \n@@ -566,7 +566,7 @@ pub fn register_rust_fn_with_foreign_abi(ccx: &CrateContext,\n     let llfn = base::register_fn_llvmty(ccx, sp, sym, node_id, cconv, llfn_ty);\n     add_argument_attributes(&tys, llfn);\n     debug!(\"register_rust_fn_with_foreign_abi(node_id={:?}, llfn_ty={}, llfn={})\",\n-           node_id, ccx.tn.type_to_string(llfn_ty), ccx.tn.val_to_string(llfn));\n+           node_id, ccx.tn().type_to_string(llfn_ty), ccx.tn().val_to_string(llfn));\n     llfn\n }\n \n@@ -605,7 +605,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n         let t = ty::node_id_to_type(tcx, id).subst(\n             ccx.tcx(), &param_substs.substs);\n \n-        let ps = ccx.tcx.map.with_path(id, |path| {\n+        let ps = ccx.tcx().map.with_path(id, |path| {\n             let abi = Some(ast_map::PathName(special_idents::clownshoe_abi.name));\n             link::mangle(path.chain(abi.move_iter()), hash)\n         });\n@@ -619,13 +619,13 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n             _ => {\n                 ccx.sess().bug(format!(\"build_rust_fn: extern fn {} has ty {}, \\\n                                         expected a bare fn ty\",\n-                                       ccx.tcx.map.path_to_string(id),\n+                                       ccx.tcx().map.path_to_string(id),\n                                        t.repr(tcx)).as_slice());\n             }\n         };\n \n         debug!(\"build_rust_fn: path={} id={} t={}\",\n-               ccx.tcx.map.path_to_string(id),\n+               ccx.tcx().map.path_to_string(id),\n                id, t.repr(tcx));\n \n         let llfn = base::decl_internal_rust_fn(ccx, t, ps.as_slice());\n@@ -644,8 +644,8 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n         let tcx = ccx.tcx();\n \n         debug!(\"build_wrap_fn(llrustfn={}, llwrapfn={}, t={})\",\n-               ccx.tn.val_to_string(llrustfn),\n-               ccx.tn.val_to_string(llwrapfn),\n+               ccx.tn().val_to_string(llrustfn),\n+               ccx.tn().val_to_string(llwrapfn),\n                t.repr(ccx.tcx()));\n \n         // Avoid all the Rust generation stuff and just generate raw\n@@ -661,7 +661,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n \n         let the_block =\n             \"the block\".with_c_str(\n-                |s| llvm::LLVMAppendBasicBlockInContext(ccx.llcx, llwrapfn, s));\n+                |s| llvm::LLVMAppendBasicBlockInContext(ccx.llcx(), llwrapfn, s));\n \n         let builder = ccx.builder();\n         builder.position_at_end(the_block);\n@@ -702,11 +702,11 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n             match foreign_outptr {\n                 Some(llforeign_outptr) => {\n                     debug!(\"out pointer, foreign={}\",\n-                           ccx.tn.val_to_string(llforeign_outptr));\n+                           ccx.tn().val_to_string(llforeign_outptr));\n                     let llrust_retptr =\n                         builder.bitcast(llforeign_outptr, llrust_ret_ty.ptr_to());\n                     debug!(\"out pointer, foreign={} (casted)\",\n-                           ccx.tn.val_to_string(llrust_retptr));\n+                           ccx.tn().val_to_string(llrust_retptr));\n                     llrust_args.push(llrust_retptr);\n                     return_alloca = None;\n                 }\n@@ -717,8 +717,8 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n                             allocad={}, \\\n                             llrust_ret_ty={}, \\\n                             return_ty={}\",\n-                           ccx.tn.val_to_string(slot),\n-                           ccx.tn.type_to_string(llrust_ret_ty),\n+                           ccx.tn().val_to_string(slot),\n+                           ccx.tn().type_to_string(llrust_ret_ty),\n                            tys.fn_sig.output.repr(tcx));\n                     llrust_args.push(slot);\n                     return_alloca = Some(slot);\n@@ -752,7 +752,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n             let mut llforeign_arg = get_param(llwrapfn, foreign_index);\n \n             debug!(\"llforeign_arg {}{}: {}\", \"#\",\n-                   i, ccx.tn.val_to_string(llforeign_arg));\n+                   i, ccx.tn().val_to_string(llforeign_arg));\n             debug!(\"rust_indirect = {}, foreign_indirect = {}\",\n                    rust_indirect, foreign_indirect);\n \n@@ -791,12 +791,13 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n             };\n \n             debug!(\"llrust_arg {}{}: {}\", \"#\",\n-                   i, ccx.tn.val_to_string(llrust_arg));\n+                   i, ccx.tn().val_to_string(llrust_arg));\n             llrust_args.push(llrust_arg);\n         }\n \n         // Perform the call itself\n-        debug!(\"calling llrustfn = {}, t = {}\", ccx.tn.val_to_string(llrustfn), t.repr(ccx.tcx()));\n+        debug!(\"calling llrustfn = {}, t = {}\",\n+               ccx.tn().val_to_string(llrustfn), t.repr(ccx.tcx()));\n         let attributes = base::get_fn_llvm_attributes(ccx, t);\n         let llrust_ret_val = builder.call(llrustfn, llrust_args.as_slice(), Some(attributes));\n \n@@ -915,10 +916,10 @@ fn foreign_types_for_fn_ty(ccx: &CrateContext,\n            fn_ty={} -> {}, \\\n            ret_def={}\",\n            ty.repr(ccx.tcx()),\n-           ccx.tn.types_to_str(llsig.llarg_tys.as_slice()),\n-           ccx.tn.type_to_string(llsig.llret_ty),\n-           ccx.tn.types_to_str(fn_ty.arg_tys.iter().map(|t| t.ty).collect::<Vec<_>>().as_slice()),\n-           ccx.tn.type_to_string(fn_ty.ret_ty.ty),\n+           ccx.tn().types_to_str(llsig.llarg_tys.as_slice()),\n+           ccx.tn().type_to_string(llsig.llret_ty),\n+           ccx.tn().types_to_str(fn_ty.arg_tys.iter().map(|t| t.ty).collect::<Vec<_>>().as_slice()),\n+           ccx.tn().type_to_string(fn_ty.ret_ty.ty),\n            ret_def);\n \n     ForeignTypes {"}, {"sha": "915c171b31816e8a385f5800308e9d3f3ab1096b", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=cf35cb365a4efee53f6372095aaff4798544bf94", "patch": "@@ -159,7 +159,7 @@ pub fn get_drop_glue(ccx: &CrateContext, t: ty::t) -> ValueRef {\n     debug!(\"make drop glue for {}\", ppaux::ty_to_string(ccx.tcx(), t));\n     let t = get_drop_glue_type(ccx, t);\n     debug!(\"drop glue type {}\", ppaux::ty_to_string(ccx.tcx(), t));\n-    match ccx.drop_glues.borrow().find(&t) {\n+    match ccx.drop_glues().borrow().find(&t) {\n         Some(&glue) => return glue,\n         _ => { }\n     }\n@@ -173,7 +173,7 @@ pub fn get_drop_glue(ccx: &CrateContext, t: ty::t) -> ValueRef {\n     let llfnty = Type::glue_fn(ccx, llty);\n     let glue = declare_generic_glue(ccx, t, llfnty, \"drop\");\n \n-    ccx.drop_glues.borrow_mut().insert(t, glue);\n+    ccx.drop_glues().borrow_mut().insert(t, glue);\n \n     make_generic_glue(ccx, t, glue, make_drop_glue, \"drop\");\n \n@@ -566,7 +566,7 @@ fn incr_refcnt_of_boxed<'a>(bcx: &'a Block<'a>,\n pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> tydesc_info {\n     // If emit_tydescs already ran, then we shouldn't be creating any new\n     // tydescs.\n-    assert!(!ccx.finished_tydescs.get());\n+    assert!(!ccx.finished_tydescs().get());\n \n     let llty = type_of(ccx, t);\n \n@@ -581,7 +581,7 @@ pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> tydesc_info {\n     debug!(\"+++ declare_tydesc {} {}\", ppaux::ty_to_string(ccx.tcx(), t), name);\n     let gvar = name.as_slice().with_c_str(|buf| {\n         unsafe {\n-            llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type().to_ref(), buf)\n+            llvm::LLVMAddGlobal(ccx.llmod(), ccx.tydesc_type().to_ref(), buf)\n         }\n     });\n     note_unique_llvm_symbol(ccx, name);\n@@ -632,7 +632,7 @@ fn make_generic_glue(ccx: &CrateContext,\n     let bcx = init_function(&fcx, false, ty::mk_nil());\n \n     llvm::SetLinkage(llfn, llvm::InternalLinkage);\n-    ccx.stats.n_glues_created.set(ccx.stats.n_glues_created.get() + 1u);\n+    ccx.stats().n_glues_created.set(ccx.stats().n_glues_created.get() + 1u);\n     // All glue functions take values passed *by alias*; this is a\n     // requirement since in many contexts glue is invoked indirectly and\n     // the caller has no idea if it's dealing with something that can be\n@@ -651,27 +651,27 @@ fn make_generic_glue(ccx: &CrateContext,\n pub fn emit_tydescs(ccx: &CrateContext) {\n     let _icx = push_ctxt(\"emit_tydescs\");\n     // As of this point, allow no more tydescs to be created.\n-    ccx.finished_tydescs.set(true);\n+    ccx.finished_tydescs().set(true);\n     let glue_fn_ty = Type::generic_glue_fn(ccx).ptr_to();\n-    for (_, ti) in ccx.tydescs.borrow().iter() {\n+    for (_, ti) in ccx.tydescs().borrow().iter() {\n         // Each of the glue functions needs to be cast to a generic type\n         // before being put into the tydesc because we only have a singleton\n         // tydesc type. Then we'll recast each function to its real type when\n         // calling it.\n         let drop_glue = unsafe {\n             llvm::LLVMConstPointerCast(get_drop_glue(ccx, ti.ty), glue_fn_ty.to_ref())\n         };\n-        ccx.stats.n_real_glues.set(ccx.stats.n_real_glues.get() + 1);\n+        ccx.stats().n_real_glues.set(ccx.stats().n_real_glues.get() + 1);\n         let visit_glue =\n             match ti.visit_glue.get() {\n               None => {\n-                  ccx.stats.n_null_glues.set(ccx.stats.n_null_glues.get() +\n+                  ccx.stats().n_null_glues.set(ccx.stats().n_null_glues.get() +\n                                              1u);\n                   C_null(glue_fn_ty)\n               }\n               Some(v) => {\n                 unsafe {\n-                    ccx.stats.n_real_glues.set(ccx.stats.n_real_glues.get() +\n+                    ccx.stats().n_real_glues.set(ccx.stats().n_real_glues.get() +\n                                                1);\n                     llvm::LLVMConstPointerCast(v, glue_fn_ty.to_ref())\n                 }"}, {"sha": "e8a56f4a9265d29ee3494aa670d1b658f20e9d2e", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=cf35cb365a4efee53f6372095aaff4798544bf94", "patch": "@@ -22,7 +22,7 @@ use syntax::ast_util;\n pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n     -> ast::DefId {\n     let _icx = push_ctxt(\"maybe_instantiate_inline\");\n-    match ccx.external.borrow().find(&fn_id) {\n+    match ccx.external().borrow().find(&fn_id) {\n         Some(&Some(node_id)) => {\n             // Already inline\n             debug!(\"maybe_instantiate_inline({}): already inline as node id {}\",\n@@ -43,14 +43,14 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             |a,b,c,d| astencode::decode_inlined_item(a, b, c, d));\n     return match csearch_result {\n         csearch::not_found => {\n-            ccx.external.borrow_mut().insert(fn_id, None);\n+            ccx.external().borrow_mut().insert(fn_id, None);\n             fn_id\n         }\n         csearch::found(ast::IIItem(item)) => {\n-            ccx.external.borrow_mut().insert(fn_id, Some(item.id));\n-            ccx.external_srcs.borrow_mut().insert(item.id, fn_id);\n+            ccx.external().borrow_mut().insert(fn_id, Some(item.id));\n+            ccx.external_srcs().borrow_mut().insert(item.id, fn_id);\n \n-            ccx.stats.n_inlines.set(ccx.stats.n_inlines.get() + 1);\n+            ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n             trans_item(ccx, &*item);\n \n             // We're bringing an external global into this crate, but we don't\n@@ -78,13 +78,13 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             local_def(item.id)\n         }\n         csearch::found(ast::IIForeign(item)) => {\n-            ccx.external.borrow_mut().insert(fn_id, Some(item.id));\n-            ccx.external_srcs.borrow_mut().insert(item.id, fn_id);\n+            ccx.external().borrow_mut().insert(fn_id, Some(item.id));\n+            ccx.external_srcs().borrow_mut().insert(item.id, fn_id);\n             local_def(item.id)\n         }\n         csearch::found_parent(parent_id, ast::IIItem(item)) => {\n-            ccx.external.borrow_mut().insert(parent_id, Some(item.id));\n-            ccx.external_srcs.borrow_mut().insert(item.id, parent_id);\n+            ccx.external().borrow_mut().insert(parent_id, Some(item.id));\n+            ccx.external_srcs().borrow_mut().insert(item.id, parent_id);\n \n           let mut my_id = 0;\n           match item.node {\n@@ -93,14 +93,14 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n               let vs_there = ty::enum_variants(ccx.tcx(), parent_id);\n               for (here, there) in vs_here.iter().zip(vs_there.iter()) {\n                   if there.id == fn_id { my_id = here.id.node; }\n-                  ccx.external.borrow_mut().insert(there.id, Some(here.id.node));\n+                  ccx.external().borrow_mut().insert(there.id, Some(here.id.node));\n               }\n             }\n             ast::ItemStruct(ref struct_def, _) => {\n               match struct_def.ctor_id {\n                 None => {}\n                 Some(ctor_id) => {\n-                    ccx.external.borrow_mut().insert(fn_id, Some(ctor_id));\n+                    ccx.external().borrow_mut().insert(fn_id, Some(ctor_id));\n                     my_id = ctor_id;\n                 }\n               }\n@@ -119,10 +119,10 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             match impl_item {\n                 ast::ProvidedInlinedTraitItem(mth) |\n                 ast::RequiredInlinedTraitItem(mth) => {\n-                    ccx.external.borrow_mut().insert(fn_id, Some(mth.id));\n-                    ccx.external_srcs.borrow_mut().insert(mth.id, fn_id);\n+                    ccx.external().borrow_mut().insert(fn_id, Some(mth.id));\n+                    ccx.external_srcs().borrow_mut().insert(mth.id, fn_id);\n \n-                    ccx.stats.n_inlines.set(ccx.stats.n_inlines.get() + 1);\n+                    ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n                 }\n             }\n "}, {"sha": "f10df00ca9184a875b2a779ceec2949012374b4d", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=cf35cb365a4efee53f6372095aaff4798544bf94", "patch": "@@ -89,7 +89,7 @@ pub fn get_simple_intrinsic(ccx: &CrateContext, item: &ast::ForeignItem) -> Opti\n /// Performs late verification that intrinsics are used correctly. At present,\n /// the only intrinsic that needs such verification is `transmute`.\n pub fn check_intrinsics(ccx: &CrateContext) {\n-    for transmute_restriction in ccx.tcx\n+    for transmute_restriction in ccx.tcx()\n                                     .transmute_restrictions\n                                     .borrow()\n                                     .iter() {\n@@ -276,7 +276,7 @@ pub fn trans_intrinsic_call<'a>(mut bcx: &'a Block<'a>, node: ast::NodeId,\n             let hash = ty::hash_crate_independent(\n                 ccx.tcx(),\n                 *substs.types.get(FnSpace, 0),\n-                &ccx.link_meta.crate_hash);\n+                &ccx.link_meta().crate_hash);\n             // NB: This needs to be kept in lockstep with the TypeId struct in\n             //     the intrinsic module\n             C_named_struct(llret_ty, [C_u64(ccx, hash)])\n@@ -554,7 +554,7 @@ fn copy_intrinsic(bcx: &Block, allow_overlap: bool, volatile: bool,\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n     let align = C_i32(ccx, type_of::align_of(ccx, tp_ty) as i32);\n     let size = machine::llsize_of(ccx, lltp_ty);\n-    let int_size = machine::llbitsize_of_real(ccx, ccx.int_type);\n+    let int_size = machine::llbitsize_of_real(ccx, ccx.int_type());\n     let name = if allow_overlap {\n         if int_size == 32 {\n             \"llvm.memmove.p0i8.p0i8.i32\"\n@@ -583,7 +583,7 @@ fn memset_intrinsic(bcx: &Block, volatile: bool, tp_ty: ty::t,\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n     let align = C_i32(ccx, type_of::align_of(ccx, tp_ty) as i32);\n     let size = machine::llsize_of(ccx, lltp_ty);\n-    let name = if machine::llbitsize_of_real(ccx, ccx.int_type) == 32 {\n+    let name = if machine::llbitsize_of_real(ccx, ccx.int_type()) == 32 {\n         \"llvm.memset.p0i8.i32\"\n     } else {\n         \"llvm.memset.p0i8.i64\""}, {"sha": "5aec1cfbf268a3001751b0d8e393f7ed0e8ab944", "filename": "src/librustc/middle/trans/llrepr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs?ref=cf35cb365a4efee53f6372095aaff4798544bf94", "patch": "@@ -25,13 +25,13 @@ impl<'a, T:LlvmRepr> LlvmRepr for &'a [T] {\n \n impl LlvmRepr for Type {\n     fn llrepr(&self, ccx: &CrateContext) -> String {\n-        ccx.tn.type_to_string(*self)\n+        ccx.tn().type_to_string(*self)\n     }\n }\n \n impl LlvmRepr for ValueRef {\n     fn llrepr(&self, ccx: &CrateContext) -> String {\n-        ccx.tn.val_to_string(*self)\n+        ccx.tn().val_to_string(*self)\n     }\n }\n "}, {"sha": "938cbc21764687bedb5f79eff17bc59a14104e37", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=cf35cb365a4efee53f6372095aaff4798544bf94", "patch": "@@ -23,15 +23,15 @@ use middle::trans::type_::Type;\n // Returns the number of bytes clobbered by a Store to this type.\n pub fn llsize_of_store(cx: &CrateContext, ty: Type) -> u64 {\n     unsafe {\n-        return llvm::LLVMStoreSizeOfType(cx.td.lltd, ty.to_ref()) as u64;\n+        return llvm::LLVMStoreSizeOfType(cx.td().lltd, ty.to_ref()) as u64;\n     }\n }\n \n // Returns the number of bytes between successive elements of type T in an\n // array of T. This is the \"ABI\" size. It includes any ABI-mandated padding.\n pub fn llsize_of_alloc(cx: &CrateContext, ty: Type) -> u64 {\n     unsafe {\n-        return llvm::LLVMABISizeOfType(cx.td.lltd, ty.to_ref()) as u64;\n+        return llvm::LLVMABISizeOfType(cx.td().lltd, ty.to_ref()) as u64;\n     }\n }\n \n@@ -45,7 +45,7 @@ pub fn llsize_of_alloc(cx: &CrateContext, ty: Type) -> u64 {\n // below.\n pub fn llsize_of_real(cx: &CrateContext, ty: Type) -> u64 {\n     unsafe {\n-        let nbits = llvm::LLVMSizeOfTypeInBits(cx.td.lltd, ty.to_ref()) as u64;\n+        let nbits = llvm::LLVMSizeOfTypeInBits(cx.td().lltd, ty.to_ref()) as u64;\n         if nbits & 7 != 0 {\n             // Not an even number of bytes, spills into \"next\" byte.\n             1 + (nbits >> 3)\n@@ -58,7 +58,7 @@ pub fn llsize_of_real(cx: &CrateContext, ty: Type) -> u64 {\n /// Returns the \"real\" size of the type in bits.\n pub fn llbitsize_of_real(cx: &CrateContext, ty: Type) -> u64 {\n     unsafe {\n-        llvm::LLVMSizeOfTypeInBits(cx.td.lltd, ty.to_ref()) as u64\n+        llvm::LLVMSizeOfTypeInBits(cx.td().lltd, ty.to_ref()) as u64\n     }\n }\n \n@@ -79,7 +79,7 @@ pub fn llsize_of(cx: &CrateContext, ty: Type) -> ValueRef {\n // space to be consumed.\n pub fn nonzero_llsize_of(cx: &CrateContext, ty: Type) -> ValueRef {\n     if llbitsize_of_real(cx, ty) == 0 {\n-        unsafe { llvm::LLVMConstInt(cx.int_type.to_ref(), 1, False) }\n+        unsafe { llvm::LLVMConstInt(cx.int_type().to_ref(), 1, False) }\n     } else {\n         llsize_of(cx, ty)\n     }\n@@ -91,7 +91,7 @@ pub fn nonzero_llsize_of(cx: &CrateContext, ty: Type) -> ValueRef {\n // allocations inside a stack frame, which LLVM has a free hand in.\n pub fn llalign_of_pref(cx: &CrateContext, ty: Type) -> u64 {\n     unsafe {\n-        return llvm::LLVMPreferredAlignmentOfType(cx.td.lltd, ty.to_ref()) as u64;\n+        return llvm::LLVMPreferredAlignmentOfType(cx.td().lltd, ty.to_ref()) as u64;\n     }\n }\n \n@@ -100,7 +100,7 @@ pub fn llalign_of_pref(cx: &CrateContext, ty: Type) -> u64 {\n // and similar ABI-mandated things.\n pub fn llalign_of_min(cx: &CrateContext, ty: Type) -> u64 {\n     unsafe {\n-        return llvm::LLVMABIAlignmentOfType(cx.td.lltd, ty.to_ref()) as u64;\n+        return llvm::LLVMABIAlignmentOfType(cx.td().lltd, ty.to_ref()) as u64;\n     }\n }\n \n@@ -110,12 +110,12 @@ pub fn llalign_of_min(cx: &CrateContext, ty: Type) -> u64 {\n pub fn llalign_of(cx: &CrateContext, ty: Type) -> ValueRef {\n     unsafe {\n         return llvm::LLVMConstIntCast(\n-            llvm::LLVMAlignOf(ty.to_ref()), cx.int_type.to_ref(), False);\n+            llvm::LLVMAlignOf(ty.to_ref()), cx.int_type().to_ref(), False);\n     }\n }\n \n pub fn llelement_offset(cx: &CrateContext, struct_ty: Type, element: uint) -> u64 {\n     unsafe {\n-        return llvm::LLVMOffsetOfElement(cx.td.lltd, struct_ty.to_ref(), element as u32) as u64;\n+        return llvm::LLVMOffsetOfElement(cx.td().lltd, struct_ty.to_ref(), element as u32) as u64;\n     }\n }"}, {"sha": "9c587d08f01c1a1b62d2cdefe2beebb573c3be9b", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=cf35cb365a4efee53f6372095aaff4798544bf94", "patch": "@@ -196,7 +196,7 @@ pub fn trans_static_method_callee(bcx: &Block,\n     let vtable_key = MethodCall::expr(expr_id);\n     let vtbls = resolve_vtables_in_fn_ctxt(\n         bcx.fcx,\n-        ccx.tcx.vtable_map.borrow().get(&vtable_key));\n+        ccx.tcx().vtable_map.borrow().get(&vtable_key));\n \n     match *vtbls.get_self().unwrap().get(0) {\n         typeck::vtable_static(impl_did, ref rcvr_substs, ref rcvr_origins) => {\n@@ -228,20 +228,20 @@ pub fn trans_static_method_callee(bcx: &Block,\n \n fn method_with_name(ccx: &CrateContext, impl_id: ast::DefId, name: ast::Name)\n                     -> ast::DefId {\n-    match ccx.impl_method_cache.borrow().find_copy(&(impl_id, name)) {\n+    match ccx.impl_method_cache().borrow().find_copy(&(impl_id, name)) {\n         Some(m) => return m,\n         None => {}\n     }\n \n-    let impl_items = ccx.tcx.impl_items.borrow();\n+    let impl_items = ccx.tcx().impl_items.borrow();\n     let impl_items =\n         impl_items.find(&impl_id)\n                   .expect(\"could not find impl while translating\");\n     let meth_did = impl_items.iter()\n                              .find(|&did| {\n                                 match *did {\n                                     ty::MethodTraitItemId(did) => {\n-                                        ty::impl_or_trait_item(&ccx.tcx,\n+                                        ty::impl_or_trait_item(ccx.tcx(),\n                                                                did).ident()\n                                                                    .name ==\n                                             name\n@@ -250,7 +250,7 @@ fn method_with_name(ccx: &CrateContext, impl_id: ast::DefId, name: ast::Name)\n                              }).expect(\"could not find method while \\\n                                         translating\");\n \n-    ccx.impl_method_cache.borrow_mut().insert((impl_id, name),\n+    ccx.impl_method_cache().borrow_mut().insert((impl_id, name),\n                                               meth_did.def_id());\n     meth_did.def_id()\n }\n@@ -502,7 +502,7 @@ fn get_vtable(bcx: &Block,\n \n     // Check the cache.\n     let hash_id = (self_ty, monomorphize::make_vtable_id(ccx, origins.get(0)));\n-    match ccx.vtables.borrow().find(&hash_id) {\n+    match ccx.vtables().borrow().find(&hash_id) {\n         Some(&val) => { return val }\n         None => { }\n     }\n@@ -594,7 +594,7 @@ fn get_vtable(bcx: &Block,\n     let drop_glue = glue::get_drop_glue(ccx, self_ty);\n     let vtable = make_vtable(ccx, drop_glue, ll_size, ll_align, methods);\n \n-    ccx.vtables.borrow_mut().insert(hash_id, vtable);\n+    ccx.vtables().borrow_mut().insert(hash_id, vtable);\n     vtable\n }\n \n@@ -614,7 +614,7 @@ pub fn make_vtable<I: Iterator<ValueRef>>(ccx: &CrateContext,\n         let tbl = C_struct(ccx, components.as_slice(), false);\n         let sym = token::gensym(\"vtable\");\n         let vt_gvar = format!(\"vtable{}\", sym.uint()).with_c_str(|buf| {\n-            llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl).to_ref(), buf)\n+            llvm::LLVMAddGlobal(ccx.llmod(), val_ty(tbl).to_ref(), buf)\n         });\n         llvm::LLVMSetInitializer(vt_gvar, tbl);\n         llvm::LLVMSetGlobalConstant(vt_gvar, llvm::True);\n@@ -684,9 +684,9 @@ pub fn vtable_ptr<'a>(bcx: &'a Block<'a>,\n                       self_ty: ty::t) -> ValueRef {\n     let ccx = bcx.ccx();\n     let origins = {\n-        let vtable_map = ccx.tcx.vtable_map.borrow();\n+        let vtable_map = ccx.tcx().vtable_map.borrow();\n         // This trait cast might be because of implicit coercion\n-        let adjs = ccx.tcx.adjustments.borrow();\n+        let adjs = ccx.tcx().adjustments.borrow();\n         let adjust = adjs.find(&id);\n         let method_call = if adjust.is_some() && ty::adjust_is_object(adjust.unwrap()) {\n             MethodCall::autoobject(id)"}, {"sha": "16d1ad810b7757f1b5cc0956be4ff7764deb20e1", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=cf35cb365a4efee53f6372095aaff4798544bf94", "patch": "@@ -56,7 +56,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         params: real_substs.types.clone()\n     };\n \n-    match ccx.monomorphized.borrow().find(&hash_id) {\n+    match ccx.monomorphized().borrow().find(&hash_id) {\n         Some(&val) => {\n             debug!(\"leaving monomorphic fn {}\",\n             ty::item_path_str(ccx.tcx(), fn_id));\n@@ -83,7 +83,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n \n     let map_node = session::expect(\n         ccx.sess(),\n-        ccx.tcx.map.find(fn_id.node),\n+        ccx.tcx().map.find(fn_id.node),\n         || {\n             format!(\"while monomorphizing {:?}, couldn't find it in \\\n                      the item map (may have attempted to monomorphize \\\n@@ -93,7 +93,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n \n     match map_node {\n         ast_map::NodeForeignItem(_) => {\n-            if ccx.tcx.map.get_foreign_abi(fn_id.node) != abi::RustIntrinsic {\n+            if ccx.tcx().map.get_foreign_abi(fn_id.node) != abi::RustIntrinsic {\n                 // Foreign externs don't have to be monomorphized.\n                 return (get_item_val(ccx, fn_id.node), true);\n             }\n@@ -104,11 +104,11 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n     debug!(\"monomorphic_fn about to subst into {}\", llitem_ty.repr(ccx.tcx()));\n     let mono_ty = llitem_ty.subst(ccx.tcx(), real_substs);\n \n-    ccx.stats.n_monos.set(ccx.stats.n_monos.get() + 1);\n+    ccx.stats().n_monos.set(ccx.stats().n_monos.get() + 1);\n \n     let depth;\n     {\n-        let mut monomorphizing = ccx.monomorphizing.borrow_mut();\n+        let mut monomorphizing = ccx.monomorphizing().borrow_mut();\n         depth = match monomorphizing.find(&fn_id) {\n             Some(&d) => d, None => 0\n         };\n@@ -117,7 +117,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         // recursively more than thirty times can probably safely be assumed\n         // to be causing an infinite expansion.\n         if depth > ccx.sess().recursion_limit.get() {\n-            ccx.sess().span_fatal(ccx.tcx.map.span(fn_id.node),\n+            ccx.sess().span_fatal(ccx.tcx().map.span(fn_id.node),\n                 \"reached the recursion limit during monomorphization\");\n         }\n \n@@ -131,7 +131,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         mono_ty.hash(&mut state);\n \n         hash = format!(\"h{}\", state.result());\n-        ccx.tcx.map.with_path(fn_id.node, |path| {\n+        ccx.tcx().map.with_path(fn_id.node, |path| {\n             exported_name(path, hash.as_slice())\n         })\n     };\n@@ -147,7 +147,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n             decl_internal_rust_fn(ccx, mono_ty, s.as_slice())\n         };\n \n-        ccx.monomorphized.borrow_mut().insert(hash_id.take().unwrap(), lldecl);\n+        ccx.monomorphized().borrow_mut().insert(hash_id.take().unwrap(), lldecl);\n         lldecl\n     };\n \n@@ -177,7 +177,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n             }\n         }\n         ast_map::NodeVariant(v) => {\n-            let parent = ccx.tcx.map.get_parent(fn_id.node);\n+            let parent = ccx.tcx().map.get_parent(fn_id.node);\n             let tvs = ty::enum_variants(ccx.tcx(), local_def(parent));\n             let this_tv = tvs.iter().find(|tv| { tv.id.node == fn_id.node}).unwrap();\n             let d = mk_lldecl(abi::Rust);\n@@ -254,7 +254,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         }\n     };\n \n-    ccx.monomorphizing.borrow_mut().insert(fn_id, depth);\n+    ccx.monomorphizing().borrow_mut().insert(fn_id, depth);\n \n     debug!(\"leaving monomorphic fn {}\", ty::item_path_str(ccx.tcx(), fn_id));\n     (lldecl, true)"}, {"sha": "1fcf4c189129b0b3cd7d82ad5b33787d62479953", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=cf35cb365a4efee53f6372095aaff4798544bf94", "patch": "@@ -335,7 +335,7 @@ impl<'a, 'b> Reflector<'a, 'b> {\n                 let sym = mangle_internal_name_by_path_and_seq(\n                     ast_map::Values([].iter()).chain(None), \"get_disr\");\n \n-                let fn_ty = ty::mk_ctor_fn(&ccx.tcx, ast::DUMMY_NODE_ID,\n+                let fn_ty = ty::mk_ctor_fn(ccx.tcx(), ast::DUMMY_NODE_ID,\n                                            [opaqueptrty], ty::mk_u64());\n                 let llfdecl = decl_internal_rust_fn(ccx,\n                                                     fn_ty,"}, {"sha": "3701d83d6a122e87910e16e9a237b5bbf902090c", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=cf35cb365a4efee53f6372095aaff4798544bf94", "patch": "@@ -94,8 +94,8 @@ impl VecTypes {\n         format!(\"VecTypes {{unit_ty={}, llunit_ty={}, \\\n                  llunit_size={}, llunit_alloc_size={}}}\",\n                 ty_to_string(ccx.tcx(), self.unit_ty),\n-                ccx.tn.type_to_string(self.llunit_ty),\n-                ccx.tn.val_to_string(self.llunit_size),\n+                ccx.tn().type_to_string(self.llunit_ty),\n+                ccx.tn().val_to_string(self.llunit_size),\n                 self.llunit_alloc_size)\n     }\n }\n@@ -546,7 +546,7 @@ pub fn iter_vec_loop<'r,\n \n     let loop_counter = {\n         // i = 0\n-        let i = alloca(loop_bcx, bcx.ccx().int_type, \"__i\");\n+        let i = alloca(loop_bcx, bcx.ccx().int_type(), \"__i\");\n         Store(loop_bcx, C_uint(bcx.ccx(), 0), i);\n \n         Br(loop_bcx, cond_bcx.llbb);"}, {"sha": "3df1ce32fc7d751fcba880fcfd77e235b07f8d1f", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=cf35cb365a4efee53f6372095aaff4798544bf94", "patch": "@@ -53,43 +53,43 @@ impl Type {\n     }\n \n     pub fn void(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMVoidTypeInContext(ccx.llcx))\n+        ty!(llvm::LLVMVoidTypeInContext(ccx.llcx()))\n     }\n \n     pub fn nil(ccx: &CrateContext) -> Type {\n         Type::empty_struct(ccx)\n     }\n \n     pub fn metadata(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMMetadataTypeInContext(ccx.llcx))\n+        ty!(llvm::LLVMMetadataTypeInContext(ccx.llcx()))\n     }\n \n     pub fn i1(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMInt1TypeInContext(ccx.llcx))\n+        ty!(llvm::LLVMInt1TypeInContext(ccx.llcx()))\n     }\n \n     pub fn i8(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMInt8TypeInContext(ccx.llcx))\n+        ty!(llvm::LLVMInt8TypeInContext(ccx.llcx()))\n     }\n \n     pub fn i16(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMInt16TypeInContext(ccx.llcx))\n+        ty!(llvm::LLVMInt16TypeInContext(ccx.llcx()))\n     }\n \n     pub fn i32(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMInt32TypeInContext(ccx.llcx))\n+        ty!(llvm::LLVMInt32TypeInContext(ccx.llcx()))\n     }\n \n     pub fn i64(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMInt64TypeInContext(ccx.llcx))\n+        ty!(llvm::LLVMInt64TypeInContext(ccx.llcx()))\n     }\n \n     pub fn f32(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMFloatTypeInContext(ccx.llcx))\n+        ty!(llvm::LLVMFloatTypeInContext(ccx.llcx()))\n     }\n \n     pub fn f64(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMDoubleTypeInContext(ccx.llcx))\n+        ty!(llvm::LLVMDoubleTypeInContext(ccx.llcx()))\n     }\n \n     pub fn bool(ccx: &CrateContext) -> Type {\n@@ -105,15 +105,15 @@ impl Type {\n     }\n \n     pub fn int(ccx: &CrateContext) -> Type {\n-        match ccx.tcx.sess.targ_cfg.arch {\n+        match ccx.tcx().sess.targ_cfg.arch {\n             X86 | Arm | Mips | Mipsel => Type::i32(ccx),\n             X86_64 => Type::i64(ccx)\n         }\n     }\n \n     pub fn int_from_ty(ccx: &CrateContext, t: ast::IntTy) -> Type {\n         match t {\n-            ast::TyI => ccx.int_type,\n+            ast::TyI => ccx.int_type(),\n             ast::TyI8 => Type::i8(ccx),\n             ast::TyI16 => Type::i16(ccx),\n             ast::TyI32 => Type::i32(ccx),\n@@ -123,7 +123,7 @@ impl Type {\n \n     pub fn uint_from_ty(ccx: &CrateContext, t: ast::UintTy) -> Type {\n         match t {\n-            ast::TyU => ccx.int_type,\n+            ast::TyU => ccx.int_type(),\n             ast::TyU8 => Type::i8(ccx),\n             ast::TyU16 => Type::i16(ccx),\n             ast::TyU32 => Type::i32(ccx),\n@@ -152,13 +152,13 @@ impl Type {\n \n     pub fn struct_(ccx: &CrateContext, els: &[Type], packed: bool) -> Type {\n         let els : &[TypeRef] = unsafe { mem::transmute(els) };\n-        ty!(llvm::LLVMStructTypeInContext(ccx.llcx, els.as_ptr(),\n+        ty!(llvm::LLVMStructTypeInContext(ccx.llcx(), els.as_ptr(),\n                                           els.len() as c_uint,\n                                           packed as Bool))\n     }\n \n     pub fn named_struct(ccx: &CrateContext, name: &str) -> Type {\n-        ty!(name.with_c_str(|s| llvm::LLVMStructCreateNamed(ccx.llcx, s)))\n+        ty!(name.with_c_str(|s| llvm::LLVMStructCreateNamed(ccx.llcx(), s)))\n     }\n \n     pub fn empty_struct(ccx: &CrateContext) -> Type {\n@@ -170,13 +170,13 @@ impl Type {\n     }\n \n     pub fn generic_glue_fn(cx: &CrateContext) -> Type {\n-        match cx.tn.find_type(\"glue_fn\") {\n+        match cx.tn().find_type(\"glue_fn\") {\n             Some(ty) => return ty,\n             None => ()\n         }\n \n         let ty = Type::glue_fn(cx, Type::i8p(cx));\n-        cx.tn.associate_type(\"glue_fn\", &ty);\n+        cx.tn().associate_type(\"glue_fn\", &ty);\n \n         ty\n     }\n@@ -226,7 +226,7 @@ impl Type {\n     // The box pointed to by @T.\n     pub fn at_box(ccx: &CrateContext, ty: Type) -> Type {\n         Type::struct_(ccx, [\n-            ccx.int_type, Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to(),\n+            ccx.int_type(), Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to(),\n             Type::i8p(ccx), Type::i8p(ccx), ty\n         ], false)\n     }"}, {"sha": "54f24516867f06438108fd9915522bdf8e93ca2e", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf35cb365a4efee53f6372095aaff4798544bf94/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=cf35cb365a4efee53f6372095aaff4798544bf94", "patch": "@@ -156,7 +156,7 @@ pub fn type_of_fn_from_ty(cx: &CrateContext, fty: ty::t) -> Type {\n //     recursive types. For example, enum types rely on this behavior.\n \n pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n-    match cx.llsizingtypes.borrow().find_copy(&t) {\n+    match cx.llsizingtypes().borrow().find_copy(&t) {\n         Some(t) => return t,\n         None => ()\n     }\n@@ -217,7 +217,7 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n         ty::ty_vec(_, None) | ty::ty_trait(..) | ty::ty_str => fail!(\"unreachable\")\n     };\n \n-    cx.llsizingtypes.borrow_mut().insert(t, llsizingty);\n+    cx.llsizingtypes().borrow_mut().insert(t, llsizingty);\n     llsizingty\n }\n \n@@ -249,7 +249,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n     }\n \n     // Check the cache.\n-    match cx.lltypes.borrow().find(&t) {\n+    match cx.lltypes().borrow().find(&t) {\n         Some(&llty) => return llty,\n         None => ()\n     }\n@@ -270,8 +270,8 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n                 t,\n                 t_norm.repr(cx.tcx()),\n                 t_norm,\n-                cx.tn.type_to_string(llty));\n-        cx.lltypes.borrow_mut().insert(t, llty);\n+                cx.tn().type_to_string(llty));\n+        cx.lltypes().borrow_mut().insert(t, llty);\n         return llty;\n     }\n \n@@ -308,7 +308,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n               ty::ty_str => {\n                   // This means we get a nicer name in the output (str is always\n                   // unsized).\n-                  cx.tn.find_type(\"str_slice\").unwrap()\n+                  cx.tn().find_type(\"str_slice\").unwrap()\n               }\n               ty::ty_trait(..) => Type::opaque_trait(cx),\n               _ if !ty::type_is_sized(cx.tcx(), ty) => {\n@@ -385,9 +385,9 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n     debug!(\"--> mapped t={} {:?} to llty={}\",\n             t.repr(cx.tcx()),\n             t,\n-            cx.tn.type_to_string(llty));\n+            cx.tn().type_to_string(llty));\n \n-    cx.lltypes.borrow_mut().insert(t, llty);\n+    cx.lltypes().borrow_mut().insert(t, llty);\n \n     // If this was an enum or struct, fill in the type now.\n     match ty::get(t).sty {"}]}