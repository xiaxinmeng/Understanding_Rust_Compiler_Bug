{"sha": "1a4ad2bb9fe3216010f33b47c6b05debaef7d604", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhNGFkMmJiOWZlMzIxNjAxMGYzM2I0N2M2YjA1ZGViYWVmN2Q2MDQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-23T17:28:48Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-24T14:45:08Z"}, "message": "update for miri engine: new function handling, new static handling, fixed leaks", "tree": {"sha": "1c32f55a15f6b29056805443bdb6ea95894d2707", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c32f55a15f6b29056805443bdb6ea95894d2707"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a4ad2bb9fe3216010f33b47c6b05debaef7d604", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a4ad2bb9fe3216010f33b47c6b05debaef7d604", "html_url": "https://github.com/rust-lang/rust/commit/1a4ad2bb9fe3216010f33b47c6b05debaef7d604", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a4ad2bb9fe3216010f33b47c6b05debaef7d604/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68194180a835f30b4fec5fd04b754c4a38107167", "url": "https://api.github.com/repos/rust-lang/rust/commits/68194180a835f30b4fec5fd04b754c4a38107167", "html_url": "https://github.com/rust-lang/rust/commit/68194180a835f30b4fec5fd04b754c4a38107167"}], "stats": {"total": 519, "additions": 149, "deletions": 370}, "files": [{"sha": "6e3fcf7d4489b0c4668958f72518dbf241b3864c", "filename": "src/fn_call.rs", "status": "modified", "additions": 88, "deletions": 91, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/1a4ad2bb9fe3216010f33b47c6b05debaef7d604/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4ad2bb9fe3216010f33b47c6b05debaef7d604/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=1a4ad2bb9fe3216010f33b47c6b05debaef7d604", "patch": "@@ -3,7 +3,6 @@ use rustc::ty::layout::{Align, LayoutOf, Size};\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc::mir;\n use syntax::attr;\n-use syntax::source_map::Span;\n \n use std::mem;\n \n@@ -13,122 +12,138 @@ use tls::MemoryExt;\n \n use super::memory::MemoryKind;\n \n-pub trait EvalContextExt<'tcx> {\n-    fn call_foreign_item(\n+pub trait EvalContextExt<'tcx, 'mir> {\n+    /// Emulate calling a foreign item, fail if the item is not supported.\n+    /// This function will handle `goto_block` if needed.\n+    fn emulate_foreign_item(\n         &mut self,\n         def_id: DefId,\n         args: &[OpTy<'tcx>],\n         dest: PlaceTy<'tcx>,\n-        dest_block: mir::BasicBlock,\n+        ret: mir::BasicBlock,\n     ) -> EvalResult<'tcx>;\n \n     fn resolve_path(&self, path: &[&str]) -> EvalResult<'tcx, ty::Instance<'tcx>>;\n \n-    fn call_missing_fn(\n+    /// Emulate a function that should have MIR but does not.\n+    /// This is solely to support execution without full MIR.\n+    /// Fail if emulating this function is not supported.\n+    /// This function will handle `goto_block` if needed.\n+    fn emulate_missing_fn(\n         &mut self,\n-        instance: ty::Instance<'tcx>,\n-        destination: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n-        args: &[OpTy<'tcx>],\n         path: String,\n+        args: &[OpTy<'tcx>],\n+        dest: Option<PlaceTy<'tcx>>,\n+        ret: Option<mir::BasicBlock>,\n     ) -> EvalResult<'tcx>;\n \n-    fn eval_fn_call(\n+    fn find_fn(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n         args: &[OpTy<'tcx>],\n-        span: Span,\n-    ) -> EvalResult<'tcx, bool>;\n+        dest: Option<PlaceTy<'tcx>>,\n+        ret: Option<mir::BasicBlock>,\n+    ) -> EvalResult<'tcx, Option<&'mir mir::Mir<'tcx>>>;\n \n     fn write_null(&mut self, dest: PlaceTy<'tcx>) -> EvalResult<'tcx>;\n }\n \n-impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super::Evaluator<'tcx>> {\n-    fn eval_fn_call(\n+impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, 'mir, 'tcx, super::Evaluator<'tcx>> {\n+    fn find_fn(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n         args: &[OpTy<'tcx>],\n-        span: Span,\n-    ) -> EvalResult<'tcx, bool> {\n-        trace!(\"eval_fn_call: {:#?}, {:?}\", instance, destination.map(|(place, bb)| (*place, bb)));\n+        dest: Option<PlaceTy<'tcx>>,\n+        ret: Option<mir::BasicBlock>,\n+    ) -> EvalResult<'tcx, Option<&'mir mir::Mir<'tcx>>> {\n+        trace!(\"eval_fn_call: {:#?}, {:?}\", instance, dest.map(|place| *place));\n+\n+        // first run the common hooks also supported by CTFE\n+        if self.hook_fn(instance, args, dest)? {\n+            self.goto_block(ret)?;\n+            return Ok(None);\n+        }\n+        // there are some more lang items we want to hook that CTFE does not hook (yet)\n+        if self.tcx.lang_items().align_offset_fn() == Some(instance.def.def_id()) {\n+            // FIXME: return a real value in case the target allocation has an\n+            // alignment bigger than the one requested\n+            let n = u128::max_value();\n+            let dest = dest.unwrap();\n+            let n = self.truncate(n, dest.layout);\n+            self.write_scalar(Scalar::from_uint(n, dest.layout.size), dest)?;\n+            self.goto_block(ret)?;\n+            return Ok(None);\n+        }\n \n+        // FIXME: Why are these hooked here, not in `emulate_missing_fn` or so?\n         let def_id = instance.def_id();\n         let item_path = self.tcx.absolute_item_path_str(def_id);\n         match &*item_path {\n             \"std::sys::unix::thread::guard::init\" | \"std::sys::unix::thread::guard::current\" => {\n                 // Return None, as it doesn't make sense to return Some, because miri detects stack overflow itself.\n-                let (return_place, return_to_block) = destination.unwrap();\n-                match return_place.layout.ty.sty {\n+                let dest = dest.unwrap();\n+                match dest.layout.ty.sty {\n                     ty::Adt(ref adt_def, _) => {\n                         assert!(adt_def.is_enum(), \"Unexpected return type for {}\", item_path);\n                         let none_variant_index = adt_def.variants.iter().position(|def| {\n                             def.name.as_str() == \"None\"\n                         }).expect(\"No None variant\");\n \n-                        self.write_discriminant_value(none_variant_index, return_place)?;\n-                        self.goto_block(return_to_block);\n-                        return Ok(true);\n+                        self.write_discriminant_value(none_variant_index, dest)?;\n+                        self.goto_block(ret)?;\n+                        return Ok(None);\n                     }\n                     _ => panic!(\"Unexpected return type for {}\", item_path)\n                 }\n             }\n             \"std::sys::unix::fast_thread_local::register_dtor\" => {\n                 // TODO: register the dtor\n-                let (_return_place, return_to_block) = destination.unwrap();\n-                self.goto_block(return_to_block);\n-                return Ok(true);\n+                self.goto_block(ret)?;\n+                return Ok(None);\n             }\n             _ => {}\n         }\n \n-        if self.tcx.lang_items().align_offset_fn() == Some(instance.def.def_id()) {\n-            // FIXME: return a real value in case the target allocation has an\n-            // alignment bigger than the one requested\n-            let n = u128::max_value();\n-            let (dest, return_to_block) = destination.unwrap();\n-            let n = self.truncate(n, dest.layout);\n-            self.write_scalar(Scalar::from_uint(n, dest.layout.size), dest)?;\n-            self.goto_block(return_to_block);\n-            return Ok(true);\n+        // Try to see if we can do something about foreign items\n+        if self.tcx.is_foreign_item(instance.def_id()) {\n+            // An external function that we cannot find MIR for, but we can still run enough\n+            // of them to make miri viable.\n+            self.emulate_foreign_item(\n+                instance.def_id(),\n+                args,\n+                dest.unwrap(),\n+                ret.unwrap(),\n+            )?;\n+            // `goto_block` already handled\n+            return Ok(None);\n         }\n \n+        // Otherwise we really want to see the MIR -- but if we do not have it, maybe we can\n+        // emulate something. This is a HACK to support running without a full-MIR libstd.\n         let mir = match self.load_mir(instance.def) {\n             Ok(mir) => mir,\n             Err(EvalError { kind: EvalErrorKind::NoMirFor(path), .. }) => {\n-                self.call_missing_fn(\n-                    instance,\n-                    destination,\n-                    args,\n+                self.emulate_missing_fn(\n                     path,\n+                    args,\n+                    dest,\n+                    ret,\n                 )?;\n-                return Ok(true);\n+                // `goto_block` already handled\n+                return Ok(None);\n             }\n             Err(other) => return Err(other),\n         };\n \n-        let (return_place, return_to_block) = match destination {\n-            Some((place, block)) => (*place, StackPopCleanup::Goto(block)),\n-            None => (Place::null(&self), StackPopCleanup::None),\n-        };\n-\n-        self.push_stack_frame(\n-            instance,\n-            span,\n-            mir,\n-            return_place,\n-            return_to_block,\n-        )?;\n-\n-        Ok(false)\n+        Ok(Some(mir))\n     }\n \n-    fn call_foreign_item(\n+    fn emulate_foreign_item(\n         &mut self,\n         def_id: DefId,\n         args: &[OpTy<'tcx>],\n         dest: PlaceTy<'tcx>,\n-        dest_block: mir::BasicBlock,\n+        ret: mir::BasicBlock,\n     ) -> EvalResult<'tcx> {\n         let attrs = self.tcx.get_attrs(def_id);\n         let link_name = match attr::first_attr_value_str_by_name(&attrs, \"link_name\") {\n@@ -269,13 +284,13 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 // Now we make a function call.  TODO: Consider making this re-usable?  EvalContext::step does sth. similar for the TLS dtors,\n                 // and of course eval_main.\n                 let mir = self.load_mir(f_instance.def)?;\n-                let ret = Place::null(&self);\n+                let closure_dest = Place::null(&self);\n                 self.push_stack_frame(\n                     f_instance,\n                     mir.span,\n                     mir,\n-                    ret,\n-                    StackPopCleanup::Goto(dest_block),\n+                    closure_dest,\n+                    StackPopCleanup::Goto(Some(ret)), // directly return to caller\n                 )?;\n                 let mut args = self.frame().mir.args_iter();\n \n@@ -290,16 +305,15 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n \n                 assert!(args.next().is_none(), \"__rust_maybe_catch_panic argument has more arguments than expected\");\n \n-                // We ourselves return 0\n+                // We ourselves will return 0, eventually (because we will not return if we paniced)\n                 self.write_null(dest)?;\n \n-                // Don't fall through\n+                // Don't fall through, we do NOT want to `goto_block`!\n                 return Ok(());\n             }\n \n-            \"__rust_start_panic\" => {\n-                return err!(Panic);\n-            }\n+            \"__rust_start_panic\" =>\n+                return err!(MachineError(\"the evaluated program panicked\".to_string())),\n \n             \"memcmp\" => {\n                 let left = self.read_scalar(args[0])?.not_undef()?;\n@@ -624,11 +638,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             }\n         }\n \n-        // Since we pushed no stack frame, the main loop will act\n-        // as if the call just completed and it's returning to the\n-        // current frame.\n+        self.goto_block(Some(ret))?;\n         self.dump_place(*dest);\n-        self.goto_block(dest_block);\n         Ok(())\n     }\n \n@@ -666,38 +677,27 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             })\n     }\n \n-    fn call_missing_fn(\n+    fn emulate_missing_fn(\n         &mut self,\n-        instance: ty::Instance<'tcx>,\n-        destination: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n-        args: &[OpTy<'tcx>],\n         path: String,\n+        _args: &[OpTy<'tcx>],\n+        dest: Option<PlaceTy<'tcx>>,\n+        ret: Option<mir::BasicBlock>,\n     ) -> EvalResult<'tcx> {\n         // In some cases in non-MIR libstd-mode, not having a destination is legit.  Handle these early.\n         match &path[..] {\n             \"std::panicking::rust_panic_with_hook\" |\n             \"core::panicking::panic_fmt::::panic_impl\" |\n-            \"std::rt::begin_panic_fmt\" => return err!(Panic),\n+            \"std::rt::begin_panic_fmt\" =>\n+                return err!(MachineError(\"the evaluated program panicked\".to_string())),\n             _ => {}\n         }\n \n-        let (dest, dest_block) = destination.ok_or_else(\n+        let dest = dest.ok_or_else(\n+            // Must be some function we do not support\n             || EvalErrorKind::NoMirFor(path.clone()),\n         )?;\n \n-        if self.tcx.is_foreign_item(instance.def_id()) {\n-            // An external function\n-            // TODO: That functions actually has a similar preamble to what follows here.  May make sense to\n-            // unify these two mechanisms for \"hooking into missing functions\".\n-            self.call_foreign_item(\n-                instance.def_id(),\n-                args,\n-                dest,\n-                dest_block,\n-            )?;\n-            return Ok(());\n-        }\n-\n         match &path[..] {\n             // A Rust function is missing, which means we are running with MIR missing for libstd (or other dependencies).\n             // Still, we can make many things mostly work by \"emulating\" or ignoring some functions.\n@@ -724,11 +724,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             _ => return err!(NoMirFor(path)),\n         }\n \n-        // Since we pushed no stack frame, the main loop will act\n-        // as if the call just completed and it's returning to the\n-        // current frame.\n+        self.goto_block(ret)?;\n         self.dump_place(*dest);\n-        self.goto_block(dest_block);\n         Ok(())\n     }\n "}, {"sha": "24285fa4a6e8f7cc0ed7738f4b7641fa416bbbaf", "filename": "src/helpers.rs", "status": "modified", "additions": 1, "deletions": 51, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/1a4ad2bb9fe3216010f33b47c6b05debaef7d604/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4ad2bb9fe3216010f33b47c6b05debaef7d604/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=1a4ad2bb9fe3216010f33b47c6b05debaef7d604", "patch": "@@ -1,5 +1,4 @@\n-use rustc::ty::layout::{Size, HasDataLayout};\n-use rustc::mir::interpret::sign_extend;\n+use rustc::ty::layout::Size;\n \n use super::{Scalar, ScalarMaybeUndef, EvalResult};\n \n@@ -14,11 +13,6 @@ pub trait ScalarExt {\n }\n \n pub trait FalibleScalarExt {\n-    fn to_usize(self, cx: impl HasDataLayout) -> EvalResult<'static, u64>;\n-    fn to_isize(self, cx: impl HasDataLayout) -> EvalResult<'static, i64>;\n-    fn to_i32(self) -> EvalResult<'static, i32>;\n-    fn to_u8(self) -> EvalResult<'static, u8>;\n-\n     /// HACK: this function just extracts all bits if `defined != 0`\n     /// Mainly used for args of C-functions and we should totally correctly fetch the size\n     /// of their arguments\n@@ -59,34 +53,6 @@ impl ScalarExt for Scalar {\n }\n \n impl FalibleScalarExt for Scalar {\n-    fn to_usize(self, cx: impl HasDataLayout) -> EvalResult<'static, u64> {\n-        let b = self.to_bits(cx.data_layout().pointer_size)?;\n-        assert_eq!(b as u64 as u128, b);\n-        Ok(b as u64)\n-    }\n-\n-    fn to_u8(self) -> EvalResult<'static, u8> {\n-        let sz = Size::from_bits(8);\n-        let b = self.to_bits(sz)?;\n-        assert_eq!(b as u8 as u128, b);\n-        Ok(b as u8)\n-    }\n-\n-    fn to_isize(self, cx: impl HasDataLayout) -> EvalResult<'static, i64> {\n-        let b = self.to_bits(cx.data_layout().pointer_size)?;\n-        let b = sign_extend(b, cx.data_layout().pointer_size) as i128;\n-        assert_eq!(b as i64 as i128, b);\n-        Ok(b as i64)\n-    }\n-\n-    fn to_i32(self) -> EvalResult<'static, i32> {\n-        let sz = Size::from_bits(32);\n-        let b = self.to_bits(sz)?;\n-        let b = sign_extend(b, sz) as i128;\n-        assert_eq!(b as i32 as i128, b);\n-        Ok(b as i32)\n-    }\n-\n     fn to_bytes(self) -> EvalResult<'static, u128> {\n         match self {\n             Scalar::Bits { bits, size } => {\n@@ -99,22 +65,6 @@ impl FalibleScalarExt for Scalar {\n }\n \n impl FalibleScalarExt for ScalarMaybeUndef {\n-    fn to_usize(self, cx: impl HasDataLayout) -> EvalResult<'static, u64> {\n-        self.not_undef()?.to_usize(cx)\n-    }\n-\n-    fn to_u8(self) -> EvalResult<'static, u8> {\n-        self.not_undef()?.to_u8()\n-    }\n-\n-    fn to_isize(self, cx: impl HasDataLayout) -> EvalResult<'static, i64> {\n-        self.not_undef()?.to_isize(cx)\n-    }\n-\n-    fn to_i32(self) -> EvalResult<'static, i32> {\n-        self.not_undef()?.to_i32()\n-    }\n-\n     fn to_bytes(self) -> EvalResult<'static, u128> {\n         self.not_undef()?.to_bytes()\n     }"}, {"sha": "62a1938d0fc1fba9a4a0943c343f55af04cd4418", "filename": "src/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 82, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/1a4ad2bb9fe3216010f33b47c6b05debaef7d604/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4ad2bb9fe3216010f33b47c6b05debaef7d604/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=1a4ad2bb9fe3216010f33b47c6b05debaef7d604", "patch": "@@ -1,5 +1,5 @@\n use rustc::mir;\n-use rustc::ty::layout::{self, LayoutOf, Size, Primitive, Integer::*};\n+use rustc::ty::layout::{self, LayoutOf, Size};\n use rustc::ty;\n \n use rustc::mir::interpret::{EvalResult, Scalar, ScalarMaybeUndef};\n@@ -15,7 +15,6 @@ pub trait EvalContextExt<'tcx> {\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         dest: PlaceTy<'tcx>,\n-        target: mir::BasicBlock,\n     ) -> EvalResult<'tcx>;\n }\n \n@@ -25,8 +24,11 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         dest: PlaceTy<'tcx>,\n-        target: mir::BasicBlock,\n     ) -> EvalResult<'tcx> {\n+        if self.emulate_intrinsic(instance, args, dest)? {\n+            return Ok(());\n+        }\n+\n         let substs = instance.substs;\n \n         let intrinsic_name = &self.tcx.item_name(instance.def_id()).as_str()[..];\n@@ -194,24 +196,6 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 }\n             }\n \n-            \"ctpop\" | \"cttz\" | \"cttz_nonzero\" | \"ctlz\" | \"ctlz_nonzero\" | \"bswap\" => {\n-                let ty = substs.type_at(0);\n-                let num = self.read_scalar(args[0])?.to_bytes()?;\n-                let kind = match self.layout_of(ty)?.abi {\n-                    ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n-                    _ => Err(::rustc::mir::interpret::EvalErrorKind::TypeNotPrimitive(ty))?,\n-                };\n-                let num = if intrinsic_name.ends_with(\"_nonzero\") {\n-                    if num == 0 {\n-                        return err!(Intrinsic(format!(\"{} called on 0\", intrinsic_name)));\n-                    }\n-                    numeric_intrinsic(intrinsic_name.trim_right_matches(\"_nonzero\"), num, kind)?\n-                } else {\n-                    numeric_intrinsic(intrinsic_name, num, kind)?\n-                };\n-                self.write_scalar(num, dest)?;\n-            }\n-\n             \"discriminant_value\" => {\n                 let place = self.ref_to_mplace(self.read_value(args[0])?)?;\n                 let discr_val = self.read_discriminant_value(place.into())?;\n@@ -316,14 +300,6 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 }\n             }\n \n-            \"min_align_of\" => {\n-                let elem_ty = substs.type_at(0);\n-                let elem_align = self.layout_of(elem_ty)?.align.abi();\n-                let ptr_size = self.memory.pointer_size();\n-                let align_val = Scalar::from_uint(elem_align as u128, ptr_size);\n-                self.write_scalar(align_val, dest)?;\n-            }\n-\n             \"pref_align_of\" => {\n                 let ty = substs.type_at(0);\n                 let layout = self.layout_of(ty)?;\n@@ -456,13 +432,6 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 )?;\n             }\n \n-            \"size_of\" => {\n-                let ty = substs.type_at(0);\n-                let size = self.layout_of(ty)?.size.bytes();\n-                let ptr_size = self.memory.pointer_size();\n-                self.write_scalar(Scalar::from_uint(size, ptr_size), dest)?;\n-            }\n-\n             \"size_of_val\" => {\n                 let mplace = self.ref_to_mplace(self.read_value(args[0])?)?;\n                 let (size, _) = self.size_and_align_of_mplace(mplace)?;\n@@ -490,11 +459,6 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 let value = self.str_to_value(&ty_name)?;\n                 self.write_value(value, dest)?;\n             }\n-            \"type_id\" => {\n-                let ty = substs.type_at(0);\n-                let n = self.tcx.type_id_hash(ty);\n-                self.write_scalar(Scalar::Bits { bits: n as u128, size: 8 }, dest)?;\n-            }\n \n             \"transmute\" => {\n                 // Go through an allocation, to make sure the completely different layouts\n@@ -610,47 +574,6 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             name => return err!(Unimplemented(format!(\"unimplemented intrinsic: {}\", name))),\n         }\n \n-        self.goto_block(target);\n-\n-        // Since we pushed no stack frame, the main loop will act\n-        // as if the call just completed and it's returning to the\n-        // current frame.\n         Ok(())\n     }\n }\n-\n-fn numeric_intrinsic<'tcx>(\n-    name: &str,\n-    bytes: u128,\n-    kind: Primitive,\n-) -> EvalResult<'tcx, Scalar> {\n-    macro_rules! integer_intrinsic {\n-        ($method:ident) => ({\n-            let (result_bytes, size) = match kind {\n-                Primitive::Int(I8, true) => ((bytes as i8).$method() as u128, 1),\n-                Primitive::Int(I8, false) => ((bytes as u8).$method() as u128, 1),\n-                Primitive::Int(I16, true) => ((bytes as i16).$method() as u128, 2),\n-                Primitive::Int(I16, false) => ((bytes as u16).$method() as u128, 2),\n-                Primitive::Int(I32, true) => ((bytes as i32).$method() as u128, 4),\n-                Primitive::Int(I32, false) => ((bytes as u32).$method() as u128, 4),\n-                Primitive::Int(I64, true) => ((bytes as i64).$method() as u128, 8),\n-                Primitive::Int(I64, false) => ((bytes as u64).$method() as u128, 8),\n-                Primitive::Int(I128, true) => ((bytes as i128).$method() as u128, 16),\n-                Primitive::Int(I128, false) => (bytes.$method() as u128, 16),\n-                _ => bug!(\"invalid `{}` argument: {:?}\", name, bytes),\n-            };\n-\n-            Scalar::from_uint(result_bytes, Size::from_bytes(size))\n-        });\n-    }\n-\n-    let result_val = match name {\n-        \"bswap\" => integer_intrinsic!(swap_bytes),\n-        \"ctlz\" => integer_intrinsic!(leading_zeros),\n-        \"ctpop\" => integer_intrinsic!(count_ones),\n-        \"cttz\" => integer_intrinsic!(trailing_zeros),\n-        _ => bug!(\"not a numeric intrinsic: {}\", name),\n-    };\n-\n-    Ok(result_val)\n-}"}, {"sha": "81cee6fbe42ebb429240523472689111cef9b847", "filename": "src/lib.rs", "status": "modified", "additions": 25, "deletions": 138, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/1a4ad2bb9fe3216010f33b47c6b05debaef7d604/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4ad2bb9fe3216010f33b47c6b05debaef7d604/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=1a4ad2bb9fe3216010f33b47c6b05debaef7d604", "patch": "@@ -18,14 +18,12 @@ extern crate syntax;\n \n use rustc::ty::{self, TyCtxt};\n use rustc::ty::layout::{TyLayout, LayoutOf, Size};\n-use rustc::ty::subst::Subst;\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n \n use rustc_data_structures::fx::FxHasher;\n \n use syntax::ast::Mutability;\n-use syntax::source_map::Span;\n \n use std::marker::PhantomData;\n use std::collections::{HashMap, BTreeMap};\n@@ -47,6 +45,7 @@ use fn_call::EvalContextExt as MissingFnsEvalContextExt;\n use operator::EvalContextExt as OperatorEvalContextExt;\n use intrinsic::EvalContextExt as IntrinsicEvalContextExt;\n use tls::EvalContextExt as TlsEvalContextExt;\n+use memory::MemoryKind as MiriMemoryKind;\n use locks::LockInfo;\n use range_map::RangeMap;\n use helpers::{ScalarExt, FalibleScalarExt};\n@@ -55,7 +54,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     main_id: DefId,\n     start_wrapper: Option<DefId>,\n-) -> EvalResult<'tcx, (EvalContext<'a, 'mir, 'tcx, Evaluator<'tcx>>, Option<Pointer>)> {\n+) -> EvalResult<'tcx, EvalContext<'a, 'mir, 'tcx, Evaluator<'tcx>>> {\n     let mut ecx = EvalContext::new(\n         tcx.at(syntax::source_map::DUMMY_SP),\n         ty::ParamEnv::reveal_all(),\n@@ -65,7 +64,6 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n \n     let main_instance = ty::Instance::mono(ecx.tcx.tcx, main_id);\n     let main_mir = ecx.load_mir(main_instance.def)?;\n-    let mut cleanup_ptr = None; // Scalar to be deallocated when we are done\n \n     if !main_mir.return_ty().is_nil() || main_mir.arg_count != 0 {\n         return err!(Unimplemented(\n@@ -94,11 +92,10 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n             )));\n         }\n \n-        // Return value\n+        // Return value (in static memory so that it does not count as leak)\n         let size = ecx.tcx.data_layout.pointer_size;\n         let align = ecx.tcx.data_layout.pointer_align;\n-        let ret_ptr = ecx.memory_mut().allocate(size, align, MemoryKind::Stack)?;\n-        cleanup_ptr = Some(ret_ptr);\n+        let ret_ptr = ecx.memory_mut().allocate(size, align, MiriMemoryKind::MutStatic.into())?;\n \n         // Push our stack frame\n         ecx.push_stack_frame(\n@@ -123,12 +120,12 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n         // FIXME: extract main source file path\n         // Third argument (argv): &[b\"foo\"]\n         let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n-        let foo = ecx.memory.allocate_bytes(b\"foo\\0\");\n+        let foo = ecx.memory.allocate_static_bytes(b\"foo\\0\");\n         let foo_ty = ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8);\n         let foo_layout = ecx.layout_of(foo_ty)?;\n-        let foo_place = ecx.allocate(foo_layout, MemoryKind::Stack)?;\n+        let foo_place = ecx.allocate(foo_layout, MemoryKind::Stack)?; // will be marked as static in just a second\n         ecx.write_scalar(Scalar::Ptr(foo), foo_place.into())?;\n-        ecx.memory.mark_static_initialized(foo_place.to_ptr()?.alloc_id, Mutability::Immutable)?;\n+        ecx.memory.mark_static_initialized(foo_place.to_ptr()?.alloc_id, Mutability::Immutable)?; // marked as static\n         ecx.write_scalar(foo_place.ptr, dest)?;\n \n         assert!(args.next().is_none(), \"start lang item has more arguments than expected\");\n@@ -146,34 +143,26 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n         assert!(args.next().is_none(), \"main function must not have arguments\");\n     }\n \n-    Ok((ecx, cleanup_ptr))\n+    Ok(ecx)\n }\n \n pub fn eval_main<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     main_id: DefId,\n     start_wrapper: Option<DefId>,\n ) {\n-    let (mut ecx, cleanup_ptr) = create_ecx(tcx, main_id, start_wrapper).expect(\"Couldn't create ecx\");\n+    let mut ecx = create_ecx(tcx, main_id, start_wrapper).expect(\"Couldn't create ecx\");\n \n     let res: EvalResult = do catch {\n-        while ecx.step()? {}\n+        ecx.run()?;\n         ecx.run_tls_dtors()?;\n-        if let Some(cleanup_ptr) = cleanup_ptr {\n-            ecx.memory_mut().deallocate(\n-                cleanup_ptr,\n-                None,\n-                MemoryKind::Stack,\n-            )?;\n-        }\n     };\n \n     match res {\n         Ok(()) => {\n             let leaks = ecx.memory().leak_report();\n             if leaks != 0 {\n-                // TODO: Prevent leaks which aren't supposed to be there\n-                //tcx.sess.err(\"the evaluated program leaked memory\");\n+                tcx.sess.err(\"the evaluated program leaked memory\");\n             }\n         }\n         Err(e) => {\n@@ -198,6 +187,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n                 ecx.tcx.sess.err(&e.to_string());\n             }\n \n+            /* Nice try, but with MIRI_BACKTRACE this shows 100s of backtraces.\n             for (i, frame) in ecx.stack().iter().enumerate() {\n                 trace!(\"-------------------\");\n                 trace!(\"Frame {}\", i);\n@@ -207,7 +197,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n                         trace!(\"    local {}: {:?}\", i, local);\n                     }\n                 }\n-            }\n+            }*/\n         }\n     }\n }\n@@ -262,8 +252,6 @@ pub struct MemoryData<'tcx> {\n     /// Only mutable (static mut, heap, stack) allocations have an entry in this map.\n     /// The entry is created when allocating the memory and deleted after deallocation.\n     locks: HashMap<AllocId, RangeMap<LockInfo<'tcx>>>,\n-\n-    statics: HashMap<GlobalId<'tcx>, AllocId>,\n }\n \n impl<'tcx> MemoryData<'tcx> {\n@@ -272,7 +260,6 @@ impl<'tcx> MemoryData<'tcx> {\n             next_thread_local: 1, // start with 1 as we must not use 0 on Windows\n             thread_local: BTreeMap::new(),\n             locks: HashMap::new(),\n-            statics: HashMap::new(),\n         }\n     }\n }\n@@ -283,7 +270,6 @@ impl<'tcx> Hash for MemoryData<'tcx> {\n             next_thread_local: _,\n             thread_local,\n             locks: _,\n-            statics: _,\n         } = self;\n \n         thread_local.hash(state);\n@@ -295,24 +281,23 @@ impl<'mir, 'tcx: 'mir> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     type MemoryKinds = memory::MemoryKind;\n \n     /// Returns Ok() when the function was handled, fail otherwise\n-    fn eval_fn_call<'a>(\n+    fn find_fn<'a>(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n         args: &[OpTy<'tcx>],\n-        span: Span,\n-    ) -> EvalResult<'tcx, bool> {\n-        ecx.eval_fn_call(instance, destination, args, span)\n+        dest: Option<PlaceTy<'tcx>>,\n+        ret: Option<mir::BasicBlock>,\n+    ) -> EvalResult<'tcx, Option<&'mir mir::Mir<'tcx>>> {\n+        ecx.find_fn(instance, args, dest, ret)\n     }\n \n     fn call_intrinsic<'a>(\n         ecx: &mut rustc_mir::interpret::EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         dest: PlaceTy<'tcx>,\n-        target: mir::BasicBlock,\n     ) -> EvalResult<'tcx> {\n-        ecx.call_intrinsic(instance, args, dest, target)\n+        ecx.call_intrinsic(instance, args, dest)\n     }\n \n     fn try_ptr_op<'a>(\n@@ -326,82 +311,13 @@ impl<'mir, 'tcx: 'mir> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         ecx.ptr_op(bin_op, left, left_layout, right, right_layout)\n     }\n \n-    fn mark_static_initialized<'a>(\n-        mem: &mut Memory<'a, 'mir, 'tcx, Self>,\n+    fn access_static_mut<'a, 'm>(\n+        mem: &'m mut Memory<'a, 'mir, 'tcx, Self>,\n         id: AllocId,\n-        _mutability: Mutability,\n-    ) -> EvalResult<'tcx, bool> {\n-        use memory::MemoryKind::*;\n-        match mem.get_alloc_kind(id) {\n-            // FIXME: This could be allowed, but not for env vars set during miri execution\n-            Some(MemoryKind::Machine(Env)) => err!(Unimplemented(\"statics can't refer to env vars\".to_owned())),\n-            _ => Ok(false), // TODO: What does the bool mean?\n-        }\n-    }\n-\n-    fn init_static<'a>(\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        cid: GlobalId<'tcx>,\n-    ) -> EvalResult<'tcx, AllocId> {\n-        // Step 1: If the static has already been evaluated return the cached version\n-        if let Some(alloc_id) = ecx.memory.data.statics.get(&cid) {\n-            return Ok(*alloc_id);\n-        }\n-\n-        let tcx = ecx.tcx.tcx;\n-\n-        // Step 2: Load mir\n-        let mut mir = ecx.load_mir(cid.instance.def)?;\n-        if let Some(index) = cid.promoted {\n-            mir = &mir.promoted[index];\n-        }\n-        assert!(mir.arg_count == 0);\n-\n-        // Step 3: Allocate storage\n-        let layout = ecx.layout_of(mir.return_ty().subst(tcx, cid.instance.substs))?;\n-        assert!(!layout.is_unsized());\n-        let ptr = ecx.memory.allocate(\n-            layout.size,\n-            layout.align,\n-            MemoryKind::Stack,\n-        )?;\n-\n-        // Step 4: Cache allocation id for recursive statics\n-        assert!(ecx.memory.data.statics.insert(cid, ptr.alloc_id).is_none());\n-\n-        // Step 5: Push stackframe to evaluate static\n-        let cleanup = StackPopCleanup::None;\n-        ecx.push_stack_frame(\n-            cid.instance,\n-            mir.span,\n-            mir,\n-            Place::from_ptr(ptr, layout.align),\n-            cleanup,\n-        )?;\n-\n-        // Step 6: Step until static has been initialized\n-        let call_stackframe = ecx.stack().len();\n-        while ecx.step()? && ecx.stack().len() >= call_stackframe {\n-            if ecx.stack().len() == call_stackframe {\n-                let cleanup = {\n-                    let frame = ecx.frame();\n-                    let bb = &frame.mir.basic_blocks()[frame.block];\n-                    bb.statements.len() == frame.stmt && !bb.is_cleanup &&\n-                        if let ::rustc::mir::TerminatorKind::Return = bb.terminator().kind { true } else { false }\n-                };\n-                if cleanup {\n-                    for (local, _local_decl) in mir.local_decls.iter_enumerated().skip(1) {\n-                        // Don't deallocate locals, because the return value might reference them\n-                        ecx.storage_dead(local);\n-                    }\n-                }\n-            }\n-        }\n-\n-        // TODO: Freeze immutable statics without copying them to the global static cache\n-\n-        // Step 7: Return the alloc\n-        Ok(ptr.alloc_id)\n+    ) -> EvalResult<'tcx, &'m mut Allocation> {\n+        // Make a copy, use that.\n+        mem.deep_copy_static(id, MiriMemoryKind::MutStatic.into())?;\n+        mem.get_mut(id) // this is recursive, but now we know that `id` is in `alloc_map`\n     }\n \n     fn box_alloc<'a>(\n@@ -451,35 +367,6 @@ impl<'mir, 'tcx: 'mir> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         panic!(\"remove this function from rustc\");\n     }\n \n-    fn check_locks<'a>(\n-        _mem: &Memory<'a, 'mir, 'tcx, Self>,\n-        _ptr: Pointer,\n-        _size: Size,\n-        _access: AccessKind,\n-    ) -> EvalResult<'tcx> {\n-        Ok(())\n-    }\n-\n-    fn add_lock<'a>(\n-        _mem: &mut Memory<'a, 'mir, 'tcx, Self>,\n-        _id: AllocId,\n-    ) { }\n-\n-    fn free_lock<'a>(\n-        _mem: &mut Memory<'a, 'mir, 'tcx, Self>,\n-        _id: AllocId,\n-        _len: u64,\n-    ) -> EvalResult<'tcx> {\n-        Ok(())\n-    }\n-\n-    fn end_region<'a>(\n-        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        _reg: Option<::rustc::middle::region::Scope>,\n-    ) -> EvalResult<'tcx> {\n-        Ok(())\n-    }\n-\n     fn validation_op<'a>(\n         _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         _op: ::rustc::mir::ValidationOp,"}, {"sha": "bc4c5b70ece35770e845a8ffdf5661df0594a272", "filename": "src/memory.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1a4ad2bb9fe3216010f33b47c6b05debaef7d604/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4ad2bb9fe3216010f33b47c6b05debaef7d604/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=1a4ad2bb9fe3216010f33b47c6b05debaef7d604", "patch": "@@ -1,12 +1,24 @@\n+use rustc_mir::interpret::IsStatic;\n \n-#[derive(Debug, PartialEq, Copy, Clone)]\n+#[derive(Debug, PartialEq, Copy, Clone, Hash, Eq)]\n pub enum MemoryKind {\n-    /// Error if deallocated any other way than `rust_deallocate`\n+    /// `__rust_alloc` memory\n     Rust,\n-    /// Error if deallocated any other way than `free`\n+    /// `malloc` memory\n     C,\n     /// Part of env var emulation\n     Env,\n+    // mutable statics\n+    MutStatic,\n+}\n+\n+impl IsStatic for MemoryKind {\n+    fn is_static(self) -> bool {\n+        match self {\n+            MemoryKind::MutStatic => true,\n+            _ => false,\n+        }\n+    }\n }\n \n impl Into<::rustc_mir::interpret::MemoryKind<MemoryKind>> for MemoryKind {"}, {"sha": "955ecb225685d1b8dd4e43a1473ef99bc918ee8f", "filename": "src/tls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a4ad2bb9fe3216010f33b47c6b05debaef7d604/src%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4ad2bb9fe3216010f33b47c6b05debaef7d604/src%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftls.rs?ref=1a4ad2bb9fe3216010f33b47c6b05debaef7d604", "patch": "@@ -134,7 +134,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             self.write_scalar(ptr, dest)?;\n \n             // step until out of stackframes\n-            while self.step()? {}\n+            self.run()?;\n \n             dtor = match self.memory.fetch_tls_dtor(Some(key)) {\n                 dtor @ Some(_) => dtor,"}, {"sha": "71b4e2f442f31db02b4d710d3ede9917c51f9dcc", "filename": "tests/compile-fail/memleak.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a4ad2bb9fe3216010f33b47c6b05debaef7d604/tests%2Fcompile-fail%2Fmemleak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4ad2bb9fe3216010f33b47c6b05debaef7d604/tests%2Fcompile-fail%2Fmemleak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmemleak.rs?ref=1a4ad2bb9fe3216010f33b47c6b05debaef7d604", "patch": "@@ -1,4 +1,3 @@\n-// ignore-test FIXME: leak detection is disabled\n //error-pattern: the evaluated program leaked memory\n \n fn main() {"}, {"sha": "b2bc6722afb04fd22c6a0bc4b546ecab3fe1e5ac", "filename": "tests/compile-fail/memleak_rc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a4ad2bb9fe3216010f33b47c6b05debaef7d604/tests%2Fcompile-fail%2Fmemleak_rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4ad2bb9fe3216010f33b47c6b05debaef7d604/tests%2Fcompile-fail%2Fmemleak_rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmemleak_rc.rs?ref=1a4ad2bb9fe3216010f33b47c6b05debaef7d604", "patch": "@@ -1,4 +1,3 @@\n-// ignore-test FIXME: leak detection is disabled\n //error-pattern: the evaluated program leaked memory\n \n use std::rc::Rc;"}, {"sha": "ba46651f58ee4f25e90a2c9a2820d157a45fa142", "filename": "tests/compile-fail/modifying_constants.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a4ad2bb9fe3216010f33b47c6b05debaef7d604/tests%2Fcompile-fail%2Fmodifying_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4ad2bb9fe3216010f33b47c6b05debaef7d604/tests%2Fcompile-fail%2Fmodifying_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmodifying_constants.rs?ref=1a4ad2bb9fe3216010f33b47c6b05debaef7d604", "patch": "@@ -1,4 +1,3 @@\n-// ignore-test FIXME: we are not making these statics read-only any more?\n \n fn main() {\n     let x = &1; // the `&1` is promoted to a constant, but it used to be that only the pointer is marked static, not the pointee"}, {"sha": "9e39c2c01c2b20cfdc674424c343de86ada771f7", "filename": "tests/compile-fail/static_memory_modification.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a4ad2bb9fe3216010f33b47c6b05debaef7d604/tests%2Fcompile-fail%2Fstatic_memory_modification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4ad2bb9fe3216010f33b47c6b05debaef7d604/tests%2Fcompile-fail%2Fstatic_memory_modification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstatic_memory_modification.rs?ref=1a4ad2bb9fe3216010f33b47c6b05debaef7d604", "patch": "@@ -1,4 +1,3 @@\n-// ignore-test FIXME: we are not making these statics read-only any more?\n static X: usize = 5;\n \n #[allow(mutable_transmutes)]"}, {"sha": "ec7e082a5d5f09482853636455d8a6ee0451e6c0", "filename": "tests/run-pass/pthreads.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1a4ad2bb9fe3216010f33b47c6b05debaef7d604/tests%2Frun-pass%2Fpthreads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4ad2bb9fe3216010f33b47c6b05debaef7d604/tests%2Frun-pass%2Fpthreads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpthreads.rs?ref=1a4ad2bb9fe3216010f33b47c6b05debaef7d604", "patch": "@@ -0,0 +1,14 @@\n+// Just instantiate some data structures to make sure we got all their foreign items covered\n+\n+use std::sync;\n+\n+fn main() {\n+    let m = sync::Mutex::new(0);\n+    let _ = m.lock();\n+    drop(m);\n+\n+    let rw = sync::RwLock::new(0);\n+    let _ = rw.read();\n+    let _ = rw.write();\n+    drop(rw);\n+}"}]}