{"sha": "71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxZWU4MmE4YWEwYzAyZmMyYzczZTg0ZjQwYmRiNTU1MTJkMTA5Mzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-30T07:36:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-30T07:36:19Z"}, "message": "Auto merge of #36066 - jseyfried:rollup, r=Manishearth\n\nBatch up libsyntax breaking changes\n\nBatch of the following syntax-[breaking-change] changes:\n - #35591: Add a field `span: Span` to `ast::Generics`.\n - #35618: Remove variant `Mod` of `ast::PathListItemKind` and refactor the remaining variant `ast::PathListKind::Ident` to a struct `ast::PathListKind_`.\n - #35480: Change uses of `Constness` in the AST to `Spanned<Constness>`.\n  - c.f. `MethodSig`, `ItemKind`\n - #35728: Refactor `cx.pat_enum()` into `cx.pat_tuple_struct()` and `cx.pat_path()`.\n - #35850: Generalize the elements of lists in attributes from `MetaItem` to a new type `NestedMetaItem` that can represent a `MetaItem` or a literal.\n - #35917: Remove traits `AttrMetaMethods`, `AttributeMethods`, and `AttrNestedMetaItemMethods`.\n  - Besides removing imports of these traits, this won't cause fallout.\n - Add a variant `Union` to `ItemKind` to future proof for `union` (c.f. #36016).\n - Remove inherent methods `attrs` and `fold_attrs` of `Annotatable`.\n  - Use methods `attrs` and `map_attrs` of `HasAttrs` instead.\n\nr? @Manishearth", "tree": {"sha": "e2ead4306f12a3f92170850edc1176667765a9d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2ead4306f12a3f92170850edc1176667765a9d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "html_url": "https://github.com/rust-lang/rust/commit/71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "addb7537620feb228d6c9fe149b9c069d3686199", "url": "https://api.github.com/repos/rust-lang/rust/commits/addb7537620feb228d6c9fe149b9c069d3686199", "html_url": "https://github.com/rust-lang/rust/commit/addb7537620feb228d6c9fe149b9c069d3686199"}, {"sha": "02f081c0b53cad0bcfe1d20ebb892f06ffa996ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/02f081c0b53cad0bcfe1d20ebb892f06ffa996ff", "html_url": "https://github.com/rust-lang/rust/commit/02f081c0b53cad0bcfe1d20ebb892f06ffa996ff"}], "stats": {"total": 2152, "additions": 1297, "deletions": 855}, "files": [{"sha": "21143f93a7da84011a128e852fb3d7b71e484857", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -11,7 +11,6 @@\n use session::Session;\n \n use syntax::ast;\n-use syntax::attr::AttrMetaMethods;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n@@ -52,18 +51,22 @@ impl<'a> CheckAttrVisitor<'a> {\n                 return;\n             }\n         };\n+\n         for word in words {\n-            let word: &str = &word.name();\n-            let message = match word {\n+            let name = match word.name() {\n+                Some(word) => word,\n+                None => continue,\n+            };\n+\n+            let message = match &*name {\n                 \"C\" => {\n                     if target != Target::Struct && target != Target::Enum {\n-                            \"attribute should be applied to struct or enum\"\n+                        \"attribute should be applied to struct or enum\"\n                     } else {\n                         continue\n                     }\n                 }\n-                \"packed\" |\n-                \"simd\" => {\n+                \"packed\" | \"simd\" => {\n                     if target != Target::Struct {\n                         \"attribute should be applied to struct\"\n                     } else {\n@@ -74,13 +77,14 @@ impl<'a> CheckAttrVisitor<'a> {\n                 \"i32\" | \"u32\" | \"i64\" | \"u64\" |\n                 \"isize\" | \"usize\" => {\n                     if target != Target::Enum {\n-                            \"attribute should be applied to enum\"\n+                        \"attribute should be applied to enum\"\n                     } else {\n                         continue\n                     }\n                 }\n                 _ => continue,\n             };\n+\n             span_err!(self.sess, attr.span, E0517, \"{}\", message);\n         }\n     }"}, {"sha": "12bc49c10dabc77bd5b57f38204ffbd037844e98", "filename": "src/librustc/hir/fold.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fhir%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fhir%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Ffold.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -12,8 +12,8 @@\n //! and returns a piece of the same type.\n \n use hir::*;\n-use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, Attribute, Attribute_, MetaItem};\n-use syntax::ast::MetaItemKind;\n+use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, Attribute, Attribute_};\n+use syntax::ast::{NestedMetaItem, NestedMetaItemKind, MetaItem, MetaItemKind};\n use hir;\n use syntax_pos::Span;\n use syntax::codemap::{respan, Spanned};\n@@ -38,6 +38,10 @@ pub trait Folder : Sized {\n         noop_fold_meta_items(meta_items, self)\n     }\n \n+    fn fold_meta_list_item(&mut self, list_item: NestedMetaItem) -> NestedMetaItem {\n+        noop_fold_meta_list_item(list_item, self)\n+    }\n+\n     fn fold_meta_item(&mut self, meta_item: P<MetaItem>) -> P<MetaItem> {\n         noop_fold_meta_item(meta_item, self)\n     }\n@@ -271,16 +275,10 @@ pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<\n                     ViewPathList(fld.fold_path(path),\n                                  path_list_idents.move_map(|path_list_ident| {\n                                      Spanned {\n-                                         node: match path_list_ident.node {\n-                                             PathListIdent { id, name, rename } => PathListIdent {\n-                                                 id: fld.new_id(id),\n-                                                 name: name,\n-                                                 rename: rename,\n-                                             },\n-                                             PathListMod { id, rename } => PathListMod {\n-                                                 id: fld.new_id(id),\n-                                                 rename: rename,\n-                                             },\n+                                         node: PathListItem_ {\n+                                             id: fld.new_id(path_list_ident.node.id),\n+                                             name: path_list_ident.node.name,\n+                                             rename: path_list_ident.node.rename,\n                                          },\n                                          span: fld.new_span(path_list_ident.span),\n                                      }\n@@ -486,13 +484,26 @@ pub fn noop_fold_attribute<T: Folder>(at: Attribute, fld: &mut T) -> Option<Attr\n     })\n }\n \n+pub fn noop_fold_meta_list_item<T: Folder>(li: NestedMetaItem, fld: &mut T)\n+    -> NestedMetaItem {\n+    Spanned {\n+        node: match li.node {\n+            NestedMetaItemKind::MetaItem(mi) =>  {\n+                NestedMetaItemKind::MetaItem(fld.fold_meta_item(mi))\n+            },\n+            NestedMetaItemKind::Literal(lit) => NestedMetaItemKind::Literal(lit)\n+        },\n+        span: fld.new_span(li.span)\n+    }\n+}\n+\n pub fn noop_fold_meta_item<T: Folder>(mi: P<MetaItem>, fld: &mut T) -> P<MetaItem> {\n     mi.map(|Spanned { node, span }| {\n         Spanned {\n             node: match node {\n                 MetaItemKind::Word(id) => MetaItemKind::Word(id),\n                 MetaItemKind::List(id, mis) => {\n-                    MetaItemKind::List(id, mis.move_map(|e| fld.fold_meta_item(e)))\n+                    MetaItemKind::List(id, mis.move_map(|e| fld.fold_meta_list_item(e)))\n                 }\n                 MetaItemKind::NameValue(id, s) => MetaItemKind::NameValue(id, s),\n             },\n@@ -577,13 +588,14 @@ pub fn noop_fold_opt_lifetime<T: Folder>(o_lt: Option<Lifetime>, fld: &mut T) ->\n     o_lt.map(|lt| fld.fold_lifetime(lt))\n }\n \n-pub fn noop_fold_generics<T: Folder>(Generics { ty_params, lifetimes, where_clause }: Generics,\n+pub fn noop_fold_generics<T: Folder>(Generics {ty_params, lifetimes, where_clause, span}: Generics,\n                                      fld: &mut T)\n                                      -> Generics {\n     Generics {\n         ty_params: fld.fold_ty_params(ty_params),\n         lifetimes: fld.fold_lifetime_defs(lifetimes),\n         where_clause: fld.fold_where_clause(where_clause),\n+        span: fld.new_span(span),\n     }\n }\n "}, {"sha": "bc1dff7c6fc312e27e08d3fa10b2792ebc110e8d", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -444,12 +444,12 @@ pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n     }\n }\n \n-pub fn walk_path_list_item<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                               _prefix: &'v Path,\n-                                               item: &'v PathListItem) {\n-    visitor.visit_id(item.node.id());\n-    walk_opt_name(visitor, item.span, item.node.name());\n-    walk_opt_name(visitor, item.span, item.node.rename());\n+pub fn walk_path_list_item<'v, V>(visitor: &mut V, _prefix: &'v Path, item: &'v PathListItem)\n+    where V: Visitor<'v>,\n+{\n+    visitor.visit_id(item.node.id);\n+    visitor.visit_name(item.span, item.node.name);\n+    walk_opt_name(visitor, item.span, item.node.rename);\n }\n \n pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V,"}, {"sha": "6739d3f662ac6f69dbe664be258138cde9a7f8e0", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -218,16 +218,10 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_path_list_item(&mut self, path_list_ident: &PathListItem) -> hir::PathListItem {\n         Spanned {\n-            node: match path_list_ident.node {\n-                PathListItemKind::Ident { id, name, rename } => hir::PathListIdent {\n-                    id: id,\n-                    name: name.name,\n-                    rename: rename.map(|x| x.name),\n-                },\n-                PathListItemKind::Mod { id, rename } => hir::PathListMod {\n-                    id: id,\n-                    rename: rename.map(|x| x.name),\n-                },\n+            node: hir::PathListItem_ {\n+                id: path_list_ident.node.id,\n+                name: path_list_ident.node.name.name,\n+                rename: path_list_ident.node.rename.map(|rename| rename.name),\n             },\n             span: path_list_ident.span,\n         }\n@@ -466,6 +460,7 @@ impl<'a> LoweringContext<'a> {\n             ty_params: self.lower_ty_params(&g.ty_params),\n             lifetimes: self.lower_lifetime_defs(&g.lifetimes),\n             where_clause: self.lower_where_clause(&g.where_clause),\n+            span: g.span,\n         }\n     }\n \n@@ -643,6 +638,7 @@ impl<'a> LoweringContext<'a> {\n                 let struct_def = self.lower_variant_data(struct_def);\n                 hir::ItemStruct(struct_def, self.lower_generics(generics))\n             }\n+            ItemKind::Union(..) => panic!(\"`union` is not yet implemented\"),\n             ItemKind::DefaultImpl(unsafety, ref trait_ref) => {\n                 hir::ItemDefaultImpl(self.lower_unsafety(unsafety),\n                                      self.lower_trait_ref(trait_ref))\n@@ -809,8 +805,8 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_constness(&mut self, c: Constness) -> hir::Constness {\n-        match c {\n+    fn lower_constness(&mut self, c: Spanned<Constness>) -> hir::Constness {\n+        match c.node {\n             Constness::Const => hir::Constness::Const,\n             Constness::NotConst => hir::Constness::NotConst,\n         }"}, {"sha": "4487234885692f05f34e205b58c4d0fedcbfa1a1", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -23,13 +23,13 @@\n \n pub use self::Code::*;\n \n+use hir as ast;\n use hir::map::{self, Node};\n-use syntax::abi;\n use hir::{Block, FnDecl};\n+use hir::intravisit::FnKind;\n+use syntax::abi;\n use syntax::ast::{Attribute, Name, NodeId};\n-use hir as ast;\n use syntax_pos::Span;\n-use hir::intravisit::FnKind;\n \n /// An FnLikeNode is a Node that is like a fn, in that it has a decl\n /// and a body (as well as a NodeId, a span, etc)."}, {"sha": "280c0f304856990810b38169af7f76a4d43b7848", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -120,7 +120,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n                     match view_path.node {\n                         ViewPathList(_, ref paths) => {\n                             for path in paths {\n-                                this.insert(path.node.id(), NodeItem(i));\n+                                this.insert(path.node.id, NodeItem(i));\n                             }\n                         }\n                         _ => ()"}, {"sha": "77567fc7a46031ff29d07e3dfd978715d9d06cf8", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -133,7 +133,7 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n         let def_data = match i.node {\n             ItemKind::DefaultImpl(..) | ItemKind::Impl(..) =>\n                 DefPathData::Impl,\n-            ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Trait(..) |\n+            ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Union(..) | ItemKind::Trait(..) |\n             ItemKind::ExternCrate(..) | ItemKind::ForeignMod(..) | ItemKind::Ty(..) =>\n                 DefPathData::TypeNs(i.ident.name.as_str()),\n             ItemKind::Mod(..) => DefPathData::Module(i.ident.name.as_str()),\n@@ -164,7 +164,7 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n                         });\n                     }\n                 }\n-                ItemKind::Struct(ref struct_def, _) => {\n+                ItemKind::Struct(ref struct_def, _) | ItemKind::Union(ref struct_def, _) => {\n                     // If this is a tuple-like struct, register the constructor.\n                     if !struct_def.is_struct() {\n                         this.create_def(struct_def.id(),"}, {"sha": "295a49d26d0fed82b8a3046d7bfe276557e3d014", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 8, "deletions": 67, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -20,7 +20,6 @@ pub use self::FunctionRetTy::*;\n pub use self::ForeignItem_::*;\n pub use self::Item_::*;\n pub use self::Mutability::*;\n-pub use self::PathListItem_::*;\n pub use self::PrimTy::*;\n pub use self::Stmt_::*;\n pub use self::TraitItem_::*;\n@@ -36,7 +35,7 @@ use hir::def::Def;\n use hir::def_id::DefId;\n use util::nodemap::{NodeMap, FnvHashSet};\n \n-use syntax_pos::{BytePos, mk_sp, Span, ExpnId};\n+use syntax_pos::{mk_sp, Span, ExpnId, DUMMY_SP};\n use syntax::codemap::{self, respan, Spanned};\n use syntax::abi::Abi;\n use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n@@ -301,6 +300,7 @@ pub struct Generics {\n     pub lifetimes: HirVec<LifetimeDef>,\n     pub ty_params: HirVec<TyParam>,\n     pub where_clause: WhereClause,\n+    pub span: Span,\n }\n \n impl Generics {\n@@ -312,6 +312,7 @@ impl Generics {\n                 id: DUMMY_NODE_ID,\n                 predicates: HirVec::new(),\n             },\n+            span: DUMMY_SP,\n         }\n     }\n \n@@ -326,38 +327,6 @@ impl Generics {\n     pub fn is_parameterized(&self) -> bool {\n         self.is_lt_parameterized() || self.is_type_parameterized()\n     }\n-\n-    // Does return a span which includes lifetimes and type parameters,\n-    // not where clause.\n-    pub fn span(&self) -> Option<Span> {\n-        if !self.is_parameterized() {\n-            None\n-        } else {\n-            let mut span: Option<Span> = None;\n-            for lifetime in self.lifetimes.iter() {\n-                if let Some(ref mut span) = span {\n-                    let life_span = lifetime.lifetime.span;\n-                    span.hi = if span.hi > life_span.hi { span.hi } else { life_span.hi };\n-                    span.lo = if span.lo < life_span.lo { span.lo } else { life_span.lo };\n-                } else {\n-                    span = Some(lifetime.lifetime.span.clone());\n-                }\n-            }\n-            for ty_param in self.ty_params.iter() {\n-                if let Some(ref mut span) = span {\n-                    span.lo = if span.lo < ty_param.span.lo { span.lo } else { ty_param.span.lo };\n-                    span.hi = if span.hi > ty_param.span.hi { span.hi } else { ty_param.span.hi };\n-                } else {\n-                    span = Some(ty_param.span.clone());\n-                }\n-            }\n-            if let Some(ref mut span) = span {\n-                span.lo = span.lo - BytePos(1);\n-                span.hi = span.hi + BytePos(1);\n-            }\n-            span\n-        }\n-    }\n }\n \n /// A `where` clause in a definition\n@@ -1337,39 +1306,11 @@ pub struct Variant_ {\n pub type Variant = Spanned<Variant_>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n-pub enum PathListItem_ {\n-    PathListIdent {\n-        name: Name,\n-        /// renamed in list, eg `use foo::{bar as baz};`\n-        rename: Option<Name>,\n-        id: NodeId,\n-    },\n-    PathListMod {\n-        /// renamed in list, eg `use foo::{self as baz};`\n-        rename: Option<Name>,\n-        id: NodeId,\n-    },\n-}\n-\n-impl PathListItem_ {\n-    pub fn id(&self) -> NodeId {\n-        match *self {\n-            PathListIdent { id, .. } | PathListMod { id, .. } => id,\n-        }\n-    }\n-\n-    pub fn name(&self) -> Option<Name> {\n-        match *self {\n-            PathListIdent { name, .. } => Some(name),\n-            PathListMod { .. } => None,\n-        }\n-    }\n-\n-    pub fn rename(&self) -> Option<Name> {\n-        match *self {\n-            PathListIdent { rename, .. } | PathListMod { rename, .. } => rename,\n-        }\n-    }\n+pub struct PathListItem_ {\n+    pub name: Name,\n+    /// renamed in list, eg `use foo::{bar as baz};`\n+    pub rename: Option<Name>,\n+    pub id: NodeId,\n }\n \n pub type PathListItem = Spanned<PathListItem_>;"}, {"sha": "893d6708ead4b4993582017fb347a3e0150b88c7", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -523,6 +523,7 @@ impl<'a> State<'a> {\n                         id: ast::DUMMY_NODE_ID,\n                         predicates: hir::HirVec::new(),\n                     },\n+                    span: syntax_pos::DUMMY_SP,\n                 };\n                 self.print_ty_fn(f.abi, f.unsafety, &f.decl, None, &generics)?;\n             }\n@@ -2133,16 +2134,7 @@ impl<'a> State<'a> {\n                     self.print_path(path, false, 0)?;\n                     word(&mut self.s, \"::{\")?;\n                 }\n-                self.commasep(Inconsistent, &segments[..], |s, w| {\n-                    match w.node {\n-                        hir::PathListIdent { name, .. } => {\n-                            s.print_name(name)\n-                        }\n-                        hir::PathListMod { .. } => {\n-                            word(&mut s.s, \"self\")\n-                        }\n-                    }\n-                })?;\n+                self.commasep(Inconsistent, &segments[..], |s, w| s.print_name(w.node.name))?;\n                 word(&mut self.s, \"}\")\n             }\n         }\n@@ -2224,6 +2216,7 @@ impl<'a> State<'a> {\n                 id: ast::DUMMY_NODE_ID,\n                 predicates: hir::HirVec::new(),\n             },\n+            span: syntax_pos::DUMMY_SP,\n         };\n         self.print_fn(decl,\n                       unsafety,"}, {"sha": "0cd39882b7cded58095b89aaf1db114ce6d2a0f8", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -1030,7 +1030,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                     = node_inner.expect(\"expect item fn\");\n         let rebuilder = Rebuilder::new(self.tcx, fn_decl, generics, same_regions, &life_giver);\n         let (fn_decl, generics) = rebuilder.rebuild();\n-        self.give_expl_lifetime_param(err, &fn_decl, unsafety, constness, name, &generics, span);\n+        self.give_expl_lifetime_param(\n+            err, &fn_decl, unsafety, constness, name, &generics, span);\n     }\n \n     pub fn issue_32330_warnings(&self, span: Span, issue32330s: &[ty::Issue32330]) {\n@@ -1297,6 +1298,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n             lifetimes: lifetimes.into(),\n             ty_params: ty_params,\n             where_clause: where_clause,\n+            span: generics.span,\n         }\n     }\n "}, {"sha": "81d3d440b566f8f3edccac5da6a20d3a65b1931a", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -38,7 +38,7 @@ use util::nodemap::FnvHashMap;\n use std::cmp;\n use std::default::Default as StdDefault;\n use std::mem;\n-use syntax::attr::{self, AttrMetaMethods};\n+use syntax::attr;\n use syntax::parse::token::InternedString;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -372,12 +372,10 @@ pub fn gather_attr(attr: &ast::Attribute)\n         return out;\n     };\n \n-    for meta in metas {\n-        out.push(if meta.is_word() {\n-            Ok((meta.name().clone(), level, meta.span))\n-        } else {\n-            Err(meta.span)\n-        });\n+    for li in metas {\n+        out.push(li.word().map_or(Err(li.span), |word| {\n+            Ok((word.name().clone(), level, word.span))\n+        }));\n     }\n \n     out"}, {"sha": "824383b11afcb5a4a0c560a42ab59445ccd3dbd0", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -294,7 +294,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn visit_path_list_item(&mut self, path: &hir::Path, item: &hir::PathListItem) {\n-        self.lookup_and_handle_definition(item.node.id());\n+        self.lookup_and_handle_definition(item.node.id);\n         intravisit::walk_path_list_item(self, path, item);\n     }\n }"}, {"sha": "d1769d5cbc51bd90011c529b4ba845840014d704", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -30,7 +30,6 @@ use middle::weak_lang_items;\n use util::nodemap::FnvHashMap;\n \n use syntax::ast;\n-use syntax::attr::AttrMetaMethods;\n use syntax::parse::token::InternedString;\n use hir::intravisit::Visitor;\n use hir;"}, {"sha": "0764e817f4307be588e51c8da31f67864b288cf4", "filename": "src/librustc/middle/recursion_limit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -17,7 +17,6 @@\n \n use session::Session;\n use syntax::ast;\n-use syntax::attr::AttrMetaMethods;\n \n pub fn update_recursion_limit(sess: &Session, krate: &ast::Crate) {\n     for attr in &krate.attrs {"}, {"sha": "c20fcc3fe1dc6205631eaf8b460f2208a6b84221", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -27,7 +27,7 @@ use syntax_pos::{Span, DUMMY_SP};\n use syntax::ast;\n use syntax::ast::{NodeId, Attribute};\n use syntax::feature_gate::{GateIssue, emit_feature_err, find_lang_feature_accepted_version};\n-use syntax::attr::{self, Stability, Deprecation, AttrMetaMethods};\n+use syntax::attr::{self, Stability, Deprecation};\n use util::nodemap::{DefIdMap, FnvHashSet, FnvHashMap};\n \n use hir;\n@@ -631,7 +631,7 @@ pub fn check_path_list_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       cb: &mut FnMut(DefId, Span,\n                                                      &Option<&Stability>,\n                                                      &Option<DeprecationEntry>)) {\n-    match tcx.expect_def(item.node.id()) {\n+    match tcx.expect_def(item.node.id) {\n         Def::PrimTy(..) => {}\n         def => {\n             maybe_do_stability_check(tcx, def.def_id(), item.span, cb);"}, {"sha": "562dce6a1b129d9403f7552b24a9c9b08718725b", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -25,7 +25,6 @@ use middle::cstore;\n \n use syntax::ast::{self, IntTy, UintTy};\n use syntax::attr;\n-use syntax::attr::AttrMetaMethods;\n use syntax::parse;\n use syntax::parse::token::InternedString;\n use syntax::feature_gate::UnstableFeatures;\n@@ -1773,8 +1772,9 @@ mod tests {\n     use std::path::PathBuf;\n     use std::rc::Rc;\n     use super::{OutputType, OutputTypes, Externs, PanicStrategy};\n-    use syntax::attr;\n-    use syntax::attr::AttrMetaMethods;\n+    use syntax::{ast, attr};\n+    use syntax::parse::token::InternedString;\n+    use syntax::codemap::dummy_spanned;\n \n     fn optgroups() -> Vec<OptGroup> {\n         super::rustc_optgroups().into_iter()\n@@ -1803,7 +1803,9 @@ mod tests {\n         let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n         let sess = build_session(sessopts, &dep_graph, None, registry, Rc::new(DummyCrateStore));\n         let cfg = build_configuration(&sess, cfg);\n-        assert!((attr::contains_name(&cfg[..], \"test\")));\n+        assert!(attr::contains(&cfg, &dummy_spanned(ast::MetaItemKind::Word({\n+            InternedString::new(\"test\")\n+        }))));\n     }\n \n     // When the user supplies --test and --cfg test, don't implicitly add"}, {"sha": "8318a29de1c54e1dd3124a334522815396a46c3e", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -37,7 +37,6 @@ use util::nodemap::{FnvHashMap, FnvHashSet};\n use std::cmp;\n use std::fmt;\n use syntax::ast;\n-use syntax::attr::{AttributeMethods, AttrMetaMethods};\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n "}, {"sha": "1ea82a9c639d8a845d2a068a9b1afaf321602009", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -43,7 +43,7 @@ use std::rc::Rc;\n use std::slice;\n use std::vec::IntoIter;\n use syntax::ast::{self, CrateNum, Name, NodeId};\n-use syntax::attr::{self, AttrMetaMethods};\n+use syntax::attr;\n use syntax::parse::token::InternedString;\n use syntax_pos::{DUMMY_SP, Span};\n "}, {"sha": "a8993724e670630ca2a5fdbacc1fbb012116152a", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -27,7 +27,6 @@ use rustc::middle::mem_categorization as mc;\n use std::mem;\n use std::rc::Rc;\n use syntax::ast;\n-use syntax::attr::AttrMetaMethods;\n use syntax_pos::{Span, DUMMY_SP};\n \n #[derive(PartialEq, Eq, PartialOrd, Ord)]"}, {"sha": "887c7deb86be0804d9164c942927139fa9ae417b", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -11,7 +11,6 @@\n use borrowck::BorrowckCtxt;\n \n use syntax::ast::{self, MetaItem};\n-use syntax::attr::AttrMetaMethods;\n use syntax::ptr::P;\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -43,8 +42,9 @@ fn has_rustc_mir_with(attrs: &[ast::Attribute], name: &str) -> Option<P<MetaItem\n         if attr.check_name(\"rustc_mir\") {\n             let items = attr.meta_item_list();\n             for item in items.iter().flat_map(|l| l.iter()) {\n-                if item.check_name(name) {\n-                    return Some(item.clone())\n+                match item.meta_item() {\n+                    Some(mi) if mi.check_name(name) => return Some(mi.clone()),\n+                    _ => continue\n                 }\n             }\n         }\n@@ -126,8 +126,6 @@ fn do_dataflow<'a, 'tcx, BD>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              bd: BD) -> DataflowResults<BD>\n     where BD: BitDenotation<Idx=MovePathIndex, Ctxt=MoveDataParamEnv<'tcx>> + DataflowOperator\n {\n-    use syntax::attr::AttrMetaMethods;\n-\n     let name_found = |sess: &Session, attrs: &[ast::Attribute], name| -> Option<String> {\n         if let Some(item) = has_rustc_mir_with(attrs, name) {\n             if let Some(s) = item.value_str() {"}, {"sha": "07faeee10f1c483c276ea8a1cdd62eb22bd9e5f9", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -43,7 +43,6 @@ use std::mem;\n use std::rc::Rc;\n use std::hash::{Hash, Hasher};\n use syntax::ast;\n-use syntax::attr::AttrMetaMethods;\n use syntax_pos::{MultiSpan, Span};\n use errors::DiagnosticBuilder;\n "}, {"sha": "c6ab4578f0632c69d10661b96743fd9bdeb65963", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -49,7 +49,7 @@ use std::fs;\n use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n use syntax::{ast, diagnostics, visit};\n-use syntax::attr::{self, AttrMetaMethods};\n+use syntax::attr;\n use syntax::parse::{self, PResult, token};\n use syntax::util::node_count::NodeCounter;\n use syntax;"}, {"sha": "efadf1ff488dfbee24919b4a0504c3246129d893", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -95,7 +95,6 @@ use std::thread;\n use rustc::session::early_error;\n \n use syntax::{ast, json};\n-use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{CodeMap, FileLoader, RealFileLoader};\n use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n use syntax::parse::{self, PResult};\n@@ -655,17 +654,19 @@ impl RustcDefaultCalls {\n                         if !allow_unstable_cfg && GatedCfg::gate(&*cfg).is_some() {\n                             continue;\n                         }\n+\n                         if cfg.is_word() {\n                             println!(\"{}\", cfg.name());\n-                        } else if cfg.is_value_str() {\n-                            if let Some(s) = cfg.value_str() {\n-                                println!(\"{}=\\\"{}\\\"\", cfg.name(), s);\n-                            }\n+                        } else if let Some(s) = cfg.value_str() {\n+                            println!(\"{}=\\\"{}\\\"\", cfg.name(), s);\n                         } else if cfg.is_meta_item_list() {\n                             // Right now there are not and should not be any\n                             // MetaItemKind::List items in the configuration returned by\n                             // `build_configuration`.\n-                            panic!(\"MetaItemKind::List encountered in default cfg\")\n+                            panic!(\"Found an unexpected list in cfg attribute '{}'!\", cfg.name())\n+                        } else {\n+                            // There also shouldn't be literals.\n+                            panic!(\"Found an unexpected literal in cfg attribute '{}'!\", cfg.name())\n                         }\n                     }\n                 }"}, {"sha": "8df8f5003711883aa5b906c1a3c25140ae84c058", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -56,7 +56,6 @@ use std::env;\n use std::fs::File;\n use std::io::Write;\n use syntax::ast;\n-use syntax::attr::AttrMetaMethods;\n use syntax::parse::token::InternedString;\n use syntax_pos::Span;\n \n@@ -116,31 +115,40 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n         for attr in self.tcx.get_attrs(def_id).iter() {\n             if attr.check_name(IF_THIS_CHANGED) {\n                 let mut id = None;\n-                for meta_item in attr.meta_item_list().unwrap_or_default() {\n-                    if meta_item.is_word() && id.is_none() {\n-                        id = Some(meta_item.name().clone());\n-                    } else {\n-                        // FIXME better-encapsulate meta_item (don't directly access `node`)\n-                        span_bug!(meta_item.span(), \"unexpected meta-item {:?}\", meta_item.node)\n+                for list_item in attr.meta_item_list().unwrap_or_default() {\n+                    match list_item.word() {\n+                        Some(word) if id.is_none() => {\n+                            id = Some(word.name().clone())\n+                        },\n+                        _ => {\n+                            // FIXME better-encapsulate meta_item (don't directly access `node`)\n+                            span_bug!(list_item.span(), \"unexpected list-item {:?}\", list_item.node)\n+                        }\n                     }\n                 }\n+\n                 let id = id.unwrap_or(InternedString::new(ID));\n                 self.if_this_changed.entry(id)\n                                     .or_insert(FnvHashSet())\n                                     .insert((attr.span, def_id, DepNode::Hir(def_id)));\n             } else if attr.check_name(THEN_THIS_WOULD_NEED) {\n                 let mut dep_node_interned = None;\n                 let mut id = None;\n-                for meta_item in attr.meta_item_list().unwrap_or_default() {\n-                    if meta_item.is_word() && dep_node_interned.is_none() {\n-                        dep_node_interned = Some(meta_item.name().clone());\n-                    } else if meta_item.is_word() && id.is_none() {\n-                        id = Some(meta_item.name().clone());\n-                    } else {\n-                        // FIXME better-encapsulate meta_item (don't directly access `node`)\n-                        span_bug!(meta_item.span(), \"unexpected meta-item {:?}\", meta_item.node)\n+                for list_item in attr.meta_item_list().unwrap_or_default() {\n+                    match list_item.word() {\n+                        Some(word) if dep_node_interned.is_none() => {\n+                            dep_node_interned = Some(word.name().clone());\n+                        },\n+                        Some(word) if id.is_none() => {\n+                            id = Some(word.name().clone())\n+                        },\n+                        _ => {\n+                            // FIXME better-encapsulate meta_item (don't directly access `node`)\n+                            span_bug!(list_item.span(), \"unexpected meta-item {:?}\", list_item.node)\n+                        }\n                     }\n                 }\n+\n                 let dep_node = match dep_node_interned {\n                     Some(ref n) => {\n                         match DepNode::from_label_string(&n[..], def_id) {"}, {"sha": "b14c20ae8d46e84b54ebc54a19778b01031a373e", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -28,7 +28,6 @@\n //! at the beginning.\n \n use syntax::ast;\n-use syntax::attr::AttributeMethods;\n use std::hash::{Hash, SipHasher, Hasher};\n use rustc::dep_graph::DepNode;\n use rustc::hir;"}, {"sha": "fda7ef207a3447a434a97edd5f85f7197fd0944a", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -31,8 +31,7 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::Visitor;\n use rustc_data_structures::fnv::FnvHashSet;\n-use syntax::ast::{self, Attribute, MetaItem};\n-use syntax::attr::AttrMetaMethods;\n+use syntax::ast::{self, Attribute, NestedMetaItem};\n use syntax::parse::token::InternedString;\n use rustc::ty::TyCtxt;\n \n@@ -71,13 +70,17 @@ pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n }\n \n impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n-    fn expect_associated_value(&self, item: &MetaItem) -> InternedString {\n+    fn expect_associated_value(&self, item: &NestedMetaItem) -> InternedString {\n         if let Some(value) = item.value_str() {\n             value\n         } else {\n-            self.tcx.sess.span_fatal(\n-                item.span,\n-                &format!(\"associated value expected for `{}`\", item.name()));\n+            let msg = if let Some(name) = item.name() {\n+                format!(\"associated value expected for `{}`\", name)\n+            } else {\n+                \"expected an associated value\".to_string()\n+            };\n+\n+            self.tcx.sess.span_fatal(item.span, &msg);\n         }\n     }\n "}, {"sha": "0e130c3bb66bfb823c88f127a214b54722f04a3c", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -14,7 +14,7 @@ use lint::{LateContext, LintContext, LintArray};\n use lint::{LintPass, LateLintPass};\n \n use syntax::ast;\n-use syntax::attr::{self, AttrMetaMethods};\n+use syntax::attr;\n use syntax_pos::Span;\n \n use rustc::hir::{self, PatKind};"}, {"sha": "a103386e2c9809c89c8853fda70d6d832540f476", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -44,8 +44,8 @@ use lint::{LintPass, LateLintPass};\n use std::collections::HashSet;\n \n use syntax::{ast};\n-use syntax::attr::{self, AttrMetaMethods, AttributeMethods};\n-use syntax_pos::Span;\n+use syntax::attr;\n+use syntax_pos::{Span};\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::intravisit::FnKind;\n@@ -317,7 +317,7 @@ impl LateLintPass for MissingDoc {\n         let doc_hidden = self.doc_hidden() || attrs.iter().any(|attr| {\n             attr.check_name(\"doc\") && match attr.meta_item_list() {\n                 None => false,\n-                Some(l) => attr::contains_name(&l[..], \"hidden\"),\n+                Some(l) => attr::list_contains_name(&l[..], \"hidden\"),\n             }\n         });\n         self.doc_hidden_stack.push(doc_hidden);\n@@ -1145,7 +1145,7 @@ impl LintPass for UnstableFeatures {\n \n impl LateLintPass for UnstableFeatures {\n     fn check_attribute(&mut self, ctx: &LateContext, attr: &ast::Attribute) {\n-        if attr::contains_name(&[attr.meta().clone()], \"feature\") {\n+        if attr.meta().check_name(\"feature\") {\n             if let Some(items) = attr.meta().meta_item_list() {\n                 for item in items {\n                     ctx.span_lint(UNSTABLE_FEATURES, item.span(), \"unstable feature\");"}, {"sha": "924b768958d69433ea1867930a0ea8189a2ada43", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -18,8 +18,9 @@ use lint::{LintPass, EarlyLintPass, LateLintPass};\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n \n use syntax::ast;\n-use syntax::attr::{self, AttrMetaMethods};\n+use syntax::attr;\n use syntax::feature_gate::{KNOWN_ATTRIBUTES, AttributeType};\n+use syntax::parse::token::keywords;\n use syntax::ptr::P;\n use syntax_pos::Span;\n \n@@ -234,10 +235,13 @@ impl LintPass for UnusedAttributes {\n \n impl LateLintPass for UnusedAttributes {\n     fn check_attribute(&mut self, cx: &LateContext, attr: &ast::Attribute) {\n+        debug!(\"checking attribute: {:?}\", attr);\n+\n         // Note that check_name() marks the attribute as used if it matches.\n         for &(ref name, ty, _) in KNOWN_ATTRIBUTES {\n             match ty {\n                 AttributeType::Whitelisted if attr.check_name(name) => {\n+                    debug!(\"{:?} is Whitelisted\", name);\n                     break;\n                 },\n                 _ => ()\n@@ -247,11 +251,13 @@ impl LateLintPass for UnusedAttributes {\n         let plugin_attributes = cx.sess().plugin_attributes.borrow_mut();\n         for &(ref name, ty) in plugin_attributes.iter() {\n             if ty == AttributeType::Whitelisted && attr.check_name(&name) {\n+                debug!(\"{:?} (plugin attr) is whitelisted with ty {:?}\", name, ty);\n                 break;\n             }\n         }\n \n         if !attr::is_used(attr) {\n+            debug!(\"Emitting warning for: {:?}\", attr);\n             cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");\n             // Is it a builtin attribute that must be used at the crate level?\n             let known_crate = KNOWN_ATTRIBUTES.iter().find(|&&(name, ty, _)| {\n@@ -275,6 +281,8 @@ impl LateLintPass for UnusedAttributes {\n                 };\n                 cx.span_lint(UNUSED_ATTRIBUTES, attr.span, msg);\n             }\n+        } else {\n+            debug!(\"Attr was used: {:?}\", attr);\n         }\n     }\n }\n@@ -392,13 +400,9 @@ impl LateLintPass for UnusedImportBraces {\n     fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n         if let hir::ItemUse(ref view_path) = item.node {\n             if let hir::ViewPathList(_, ref items) = view_path.node {\n-                if items.len() == 1 {\n-                    if let hir::PathListIdent {ref name, ..} = items[0].node {\n-                        let m = format!(\"braces around {} is unnecessary\",\n-                                        name);\n-                        cx.span_lint(UNUSED_IMPORT_BRACES, item.span,\n-                                     &m[..]);\n-                    }\n+                if items.len() == 1 && items[0].node.name != keywords::SelfValue.name() {\n+                    let msg = format!(\"braces around {} is unnecessary\", items[0].node.name);\n+                    cx.span_lint(UNUSED_IMPORT_BRACES, item.span, &msg);\n                 }\n             }\n         }"}, {"sha": "85cf41e42a2737194e583093c55dd389970e0561", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -45,26 +45,13 @@ pub const tag_items_closure_kind: usize = 0x2a;\n pub const tag_items_closure_ty: usize = 0x2b;\n pub const tag_def_key: usize = 0x2c;\n \n-// GAP 0x2d 0x2e\n+// GAP 0x2d 0x34\n \n pub const tag_index: usize = 0x110; // top-level only\n pub const tag_xref_index: usize = 0x111; // top-level only\n pub const tag_xref_data: usize = 0x112; // top-level only\n-\n-pub const tag_meta_item_name_value: usize = 0x2f;\n-\n-pub const tag_meta_item_name: usize = 0x30;\n-\n-pub const tag_meta_item_value: usize = 0x31;\n-\n pub const tag_attributes: usize = 0x101; // top-level only\n \n-pub const tag_attribute: usize = 0x32;\n-\n-pub const tag_meta_item_word: usize = 0x33;\n-\n-pub const tag_meta_item_list: usize = 0x34;\n-\n // The list of crates that this crate depends on\n pub const tag_crate_deps: usize = 0x102; // top-level only\n "}, {"sha": "7e1f3ea618c979f597a3f17128ad4aabfd565e74", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -36,7 +36,6 @@ use syntax::abi::Abi;\n use syntax::codemap;\n use syntax::parse;\n use syntax::attr;\n-use syntax::attr::AttrMetaMethods;\n use syntax::parse::token::InternedString;\n use syntax::visit;\n use syntax_pos::{self, Span, mk_sp, Pos};"}, {"sha": "7117cdb731cf37ead26f56676ac61bd8854d43a0", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 13, "deletions": 38, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -57,7 +57,6 @@ use syntax::parse::token;\n use syntax::ast;\n use syntax::codemap;\n use syntax::print::pprust;\n-use syntax::ptr::P;\n use syntax_pos::{self, Span, BytePos, NO_EXPANSION};\n \n pub type Cmd<'a> = &'a CrateMetadata;\n@@ -1113,44 +1112,20 @@ pub fn get_struct_field_names(cdata: Cmd, id: DefIndex) -> Vec<ast::Name> {\n     })).collect()\n }\n \n-fn get_meta_items(md: rbml::Doc) -> Vec<P<ast::MetaItem>> {\n-    reader::tagged_docs(md, tag_meta_item_word).map(|meta_item_doc| {\n-        let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = token::intern_and_get_ident(nd.as_str());\n-        attr::mk_word_item(n)\n-    }).chain(reader::tagged_docs(md, tag_meta_item_name_value).map(|meta_item_doc| {\n-        let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n-        let vd = reader::get_doc(meta_item_doc, tag_meta_item_value);\n-        let n = token::intern_and_get_ident(nd.as_str());\n-        let v = token::intern_and_get_ident(vd.as_str());\n-        // FIXME (#623): Should be able to decode MetaItemKind::NameValue variants,\n-        // but currently the encoder just drops them\n-        attr::mk_name_value_item_str(n, v)\n-    })).chain(reader::tagged_docs(md, tag_meta_item_list).map(|meta_item_doc| {\n-        let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = token::intern_and_get_ident(nd.as_str());\n-        let subitems = get_meta_items(meta_item_doc);\n-        attr::mk_list_item(n, subitems)\n-    })).collect()\n-}\n-\n fn get_attributes(md: rbml::Doc) -> Vec<ast::Attribute> {\n-    match reader::maybe_get_doc(md, tag_attributes) {\n-        Some(attrs_d) => {\n-            reader::tagged_docs(attrs_d, tag_attribute).map(|attr_doc| {\n-                let is_sugared_doc = reader::doc_as_u8(\n-                    reader::get_doc(attr_doc, tag_attribute_is_sugared_doc)\n-                ) == 1;\n-                let meta_items = get_meta_items(attr_doc);\n-                // Currently it's only possible to have a single meta item on\n-                // an attribute\n-                assert_eq!(meta_items.len(), 1);\n-                let meta_item = meta_items.into_iter().nth(0).unwrap();\n-                attr::mk_doc_attr_outer(attr::mk_attr_id(), meta_item, is_sugared_doc)\n-            }).collect()\n-        },\n-        None => vec![],\n-    }\n+    reader::maybe_get_doc(md, tag_attributes).map_or(vec![], |attrs_doc| {\n+        let mut decoder = reader::Decoder::new(attrs_doc);\n+        let mut attrs: Vec<ast::Attribute> = decoder.read_opaque(|opaque_decoder, _| {\n+            Decodable::decode(opaque_decoder)\n+        }).unwrap();\n+\n+        // Need new unique IDs: old thread-local IDs won't map to new threads.\n+        for attr in attrs.iter_mut() {\n+            attr.node.id = attr::mk_attr_id();\n+        }\n+\n+        attrs\n+    })\n }\n \n fn list_crate_attributes(md: rbml::Doc, hash: &Svh,"}, {"sha": "b3ac678d7120d276eddbaf6a68f9ede0799c8420", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 33, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -41,7 +41,7 @@ use std::io::{Cursor, SeekFrom};\n use std::rc::Rc;\n use std::u32;\n use syntax::ast::{self, NodeId, Name, CRATE_NODE_ID, CrateNum};\n-use syntax::attr::{self,AttrMetaMethods,AttributeMethods};\n+use syntax::attr;\n use errors::Handler;\n use syntax;\n use syntax_pos::BytePos;\n@@ -1417,40 +1417,11 @@ fn encode_item_index(rbml_w: &mut Encoder, index: IndexData) {\n     rbml_w.end_tag();\n }\n \n-fn encode_meta_item(rbml_w: &mut Encoder, mi: &ast::MetaItem) {\n-    if mi.is_word() {\n-        let name = mi.name();\n-        rbml_w.start_tag(tag_meta_item_word);\n-        rbml_w.wr_tagged_str(tag_meta_item_name, &name);\n-        rbml_w.end_tag();\n-    } else if mi.is_value_str() {\n-        let name = mi.name();\n-        /* FIXME (#623): support other literal kinds */\n-        let value = mi.value_str().unwrap();\n-        rbml_w.start_tag(tag_meta_item_name_value);\n-        rbml_w.wr_tagged_str(tag_meta_item_name, &name);\n-        rbml_w.wr_tagged_str(tag_meta_item_value, &value);\n-        rbml_w.end_tag();\n-    } else { // it must be a list\n-        let name = mi.name();\n-        let items = mi.meta_item_list().unwrap();\n-        rbml_w.start_tag(tag_meta_item_list);\n-        rbml_w.wr_tagged_str(tag_meta_item_name, &name);\n-        for inner_item in items {\n-            encode_meta_item(rbml_w, &inner_item);\n-        }\n-        rbml_w.end_tag();\n-    }\n-}\n-\n fn encode_attributes(rbml_w: &mut Encoder, attrs: &[ast::Attribute]) {\n     rbml_w.start_tag(tag_attributes);\n-    for attr in attrs {\n-        rbml_w.start_tag(tag_attribute);\n-        rbml_w.wr_tagged_u8(tag_attribute_is_sugared_doc, attr.node.is_sugared_doc as u8);\n-        encode_meta_item(rbml_w, attr.meta());\n-        rbml_w.end_tag();\n-    }\n+    rbml_w.emit_opaque(|opaque_encoder| {\n+        attrs.encode(opaque_encoder)\n+    }).unwrap();\n     rbml_w.end_tag();\n }\n "}, {"sha": "fa31b6f4c7224e0ae7e899b41ea422dfe59d7296", "filename": "src/librustc_metadata/macro_import.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_metadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_metadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacro_import.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -19,7 +19,6 @@ use rustc::util::nodemap::{FnvHashSet, FnvHashMap};\n use syntax::parse::token;\n use syntax::ast;\n use syntax::attr;\n-use syntax::attr::AttrMetaMethods;\n use syntax::ext;\n use syntax_pos::Span;\n \n@@ -64,8 +63,8 @@ impl<'a> ext::base::MacroLoader for MacroLoader<'a> {\n                     }\n                     if let (Some(sel), Some(names)) = (import.as_mut(), names) {\n                         for attr in names {\n-                            if attr.is_word() {\n-                                sel.insert(attr.name().clone(), attr.span());\n+                            if let Some(word) = attr.word() {\n+                                sel.insert(word.name().clone(), attr.span());\n                             } else {\n                                 span_err!(self.sess, attr.span(), E0466, \"bad macro import\");\n                             }\n@@ -82,8 +81,8 @@ impl<'a> ext::base::MacroLoader for MacroLoader<'a> {\n                     };\n \n                     for attr in names {\n-                        if attr.is_word() {\n-                            reexport.insert(attr.name().clone(), attr.span());\n+                        if let Some(word) = attr.word() {\n+                            reexport.insert(word.name().clone(), attr.span());\n                         } else {\n                             call_bad_macro_reexport(self.sess, attr.span());\n                         }"}, {"sha": "1767630b81b1a14b897ac59b227637b4be9fbf58", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -32,7 +32,6 @@ use rustc::ty::{self, Ty, TyCtxt};\n use syntax::parse::token;\n use rustc::hir;\n use rustc_const_math::{ConstInt, ConstUsize};\n-use syntax::attr::AttrMetaMethods;\n \n #[derive(Copy, Clone)]\n pub struct Cx<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {"}, {"sha": "dde1a4a759563dffd179aa7ede1cfe538cfb911f", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -20,6 +20,7 @@ use rustc::lint;\n use rustc::session::Session;\n use syntax::ast::*;\n use syntax::attr;\n+use syntax::codemap::Spanned;\n use syntax::parse::token::{self, keywords};\n use syntax::visit::{self, Visitor};\n use syntax_pos::Span;\n@@ -69,6 +70,18 @@ impl<'a> AstValidator<'a> {\n             }\n         }\n     }\n+\n+    fn check_trait_fn_not_const(&self, constness: Spanned<Constness>) {\n+        match constness.node {\n+            Constness::Const => {\n+                struct_span_err!(self.session, constness.span, E0379,\n+                                 \"trait fns cannot be declared const\")\n+                    .span_label(constness.span, &format!(\"trait fns cannot be const\"))\n+                    .emit();\n+            }\n+            _ => {}\n+        }\n+    }\n }\n \n impl<'a> Visitor for AstValidator<'a> {\n@@ -146,6 +159,9 @@ impl<'a> Visitor for AstValidator<'a> {\n                 self.invalid_visibility(&item.vis, item.span, None);\n                 for impl_item in impl_items {\n                     self.invalid_visibility(&impl_item.vis, impl_item.span, None);\n+                    if let ImplItemKind::Method(ref sig, _) = impl_item.node {\n+                        self.check_trait_fn_not_const(sig.constness);\n+                    }\n                 }\n             }\n             ItemKind::Impl(_, _, _, None, _, _) => {\n@@ -169,6 +185,13 @@ impl<'a> Visitor for AstValidator<'a> {\n                     }\n                 }\n             }\n+            ItemKind::Trait(_, _, _, ref trait_items) => {\n+                for trait_item in trait_items {\n+                    if let TraitItemKind::Method(ref sig, _) = trait_item.node {\n+                        self.check_trait_fn_not_const(sig.constness);\n+                    }\n+                }\n+            }\n             ItemKind::Mod(_) => {\n                 // Ensure that `path` attributes on modules are recorded as used (c.f. #35584).\n                 attr::first_attr_value_str_by_name(&item.attrs, \"path\");"}, {"sha": "2d1b6e1315f8bc810722d68e637a4eae3247afb1", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -147,7 +147,8 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n         }\n \n         let mode = match fk {\n-            FnKind::ItemFn(_, _, _, hir::Constness::Const, _, _, _) => Mode::ConstFn,\n+            FnKind::ItemFn(_, _, _, hir::Constness::Const, _, _, _)\n+                => Mode::ConstFn,\n             FnKind::Method(_, m, _, _) => {\n                 if m.constness == hir::Constness::Const {\n                     Mode::ConstFn"}, {"sha": "89b8aa81411b381ed7b1de79470440acb81e2be0", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -176,6 +176,13 @@ fn some_func() {\n ```\n \"##,\n \n+E0379: r##\"\n+Trait methods cannot be declared `const` by design. For more information, see\n+[RFC 911].\n+\n+[RFC 911]: https://github.com/rust-lang/rfcs/pull/911\n+\"##,\n+\n E0449: r##\"\n A visibility qualifier was used when it was unnecessary. Erroneous code\n examples:"}, {"sha": "9e56397bc99e9ff6bb8031cd0d4f1f047cf0c4e4", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -20,8 +20,6 @@ use std::env;\n use std::mem;\n use std::path::PathBuf;\n use syntax::ast;\n-use syntax::ptr::P;\n-use syntax::attr::AttrMetaMethods;\n use syntax_pos::{Span, COMMAND_LINE_SP};\n \n /// Pointer to a registrar function.\n@@ -30,7 +28,7 @@ pub type PluginRegistrarFun =\n \n pub struct PluginRegistrar {\n     pub fun: PluginRegistrarFun,\n-    pub args: Vec<P<ast::MetaItem>>,\n+    pub args: Vec<ast::NestedMetaItem>,\n }\n \n struct PluginLoader<'a> {\n@@ -69,13 +67,14 @@ pub fn load_plugins(sess: &Session,\n             };\n \n             for plugin in plugins {\n-                if plugin.value_str().is_some() {\n-                    call_malformed_plugin_attribute(sess, attr.span);\n-                    continue;\n+                // plugins must have a name and can't be key = value\n+                match plugin.name() {\n+                    Some(ref name) if !plugin.is_value_str() => {\n+                        let args = plugin.meta_item_list().map(ToOwned::to_owned);\n+                        loader.load_plugin(plugin.span, name, args.unwrap_or_default());\n+                    },\n+                    _ => call_malformed_plugin_attribute(sess, attr.span),\n                 }\n-\n-                let args = plugin.meta_item_list().map(ToOwned::to_owned).unwrap_or_default();\n-                loader.load_plugin(plugin.span, &plugin.name(), args);\n             }\n         }\n     }\n@@ -102,7 +101,7 @@ impl<'a> PluginLoader<'a> {\n         }\n     }\n \n-    fn load_plugin(&mut self, span: Span, name: &str, args: Vec<P<ast::MetaItem>>) {\n+    fn load_plugin(&mut self, span: Span, name: &str, args: Vec<ast::NestedMetaItem>) {\n         let registrar = self.reader.find_plugin_registrar(span, name);\n \n         if let Some((lib, svh, index)) = registrar {"}, {"sha": "5ae6584aed4259ed204fd71bf96a67fa6a1a103c", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -19,7 +19,6 @@ use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension, NormalTT};\n use syntax::ext::base::{IdentTT, MultiModifier, MultiDecorator};\n use syntax::ext::base::{MacroExpanderFn, MacroRulesTT};\n use syntax::parse::token;\n-use syntax::ptr::P;\n use syntax::ast;\n use syntax::feature_gate::AttributeType;\n use syntax_pos::Span;\n@@ -41,7 +40,7 @@ pub struct Registry<'a> {\n     pub sess: &'a Session,\n \n     #[doc(hidden)]\n-    pub args_hidden: Option<Vec<P<ast::MetaItem>>>,\n+    pub args_hidden: Option<Vec<ast::NestedMetaItem>>,\n \n     #[doc(hidden)]\n     pub krate_span: Span,\n@@ -95,7 +94,7 @@ impl<'a> Registry<'a> {\n     ///\n     /// Returns empty slice in case the plugin was loaded\n     /// with `--extra-plugins`\n-    pub fn args<'b>(&'b self) -> &'b [P<ast::MetaItem>] {\n+    pub fn args<'b>(&'b self) -> &'b [ast::NestedMetaItem] {\n         self.args_hidden.as_ref().map(|v| &v[..]).unwrap_or(&[])\n     }\n "}, {"sha": "71b00218e7cc17a8f907fa974b9a22e26e7c9323", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -32,9 +32,9 @@ use syntax::parse::token;\n \n use syntax::ast::{Block, Crate};\n use syntax::ast::{ForeignItem, ForeignItemKind, Item, ItemKind};\n-use syntax::ast::{Mutability, PathListItemKind};\n-use syntax::ast::{StmtKind, TraitItemKind};\n+use syntax::ast::{Mutability, StmtKind, TraitItemKind};\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n+use syntax::parse::token::keywords;\n use syntax::visit::{self, Visitor};\n \n use syntax_pos::{Span, DUMMY_SP};\n@@ -130,9 +130,10 @@ impl<'b> Resolver<'b> {\n                     ViewPathList(_, ref source_items) => {\n                         // Make sure there's at most one `mod` import in the list.\n                         let mod_spans = source_items.iter().filter_map(|item| {\n-                            match item.node {\n-                                PathListItemKind::Mod { .. } => Some(item.span),\n-                                _ => None,\n+                            if item.node.name.name == keywords::SelfValue.name() {\n+                                Some(item.span)\n+                            } else {\n+                                None\n                             }\n                         }).collect::<Vec<Span>>();\n \n@@ -147,10 +148,12 @@ impl<'b> Resolver<'b> {\n                         }\n \n                         for source_item in source_items {\n-                            let (module_path, name, rename) = match source_item.node {\n-                                PathListItemKind::Ident { name, rename, .. } =>\n-                                    (module_path.clone(), name.name, rename.unwrap_or(name).name),\n-                                PathListItemKind::Mod { rename, .. } => {\n+                            let node = source_item.node;\n+                            let (module_path, name, rename) = {\n+                                if node.name.name != keywords::SelfValue.name() {\n+                                    let rename = node.rename.unwrap_or(node.name).name;\n+                                    (module_path.clone(), node.name.name, rename)\n+                                } else {\n                                     let name = match module_path.last() {\n                                         Some(name) => *name,\n                                         None => {\n@@ -164,12 +167,12 @@ impl<'b> Resolver<'b> {\n                                         }\n                                     };\n                                     let module_path = module_path.split_last().unwrap().1;\n-                                    let rename = rename.map(|i| i.name).unwrap_or(name);\n+                                    let rename = node.rename.map(|i| i.name).unwrap_or(name);\n                                     (module_path.to_vec(), name, rename)\n                                 }\n                             };\n                             let subclass = ImportDirectiveSubclass::single(rename, name);\n-                            let (span, id) = (source_item.span, source_item.node.id());\n+                            let (span, id) = (source_item.span, source_item.node.id);\n                             self.add_import_directive(module_path, subclass, span, id, vis);\n                         }\n                     }\n@@ -272,6 +275,8 @@ impl<'b> Resolver<'b> {\n                 self.structs.insert(item_def_id, field_names);\n             }\n \n+            ItemKind::Union(..) => panic!(\"`union` is not yet implemented\"),\n+\n             ItemKind::DefaultImpl(_, _) | ItemKind::Impl(..) => {}\n \n             ItemKind::Trait(_, _, _, ref items) => {"}, {"sha": "bc923ba29ca475356bae86488580d516c736ecdc", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -101,7 +101,7 @@ impl<'a, 'b> Visitor for UnusedImportCheckVisitor<'a, 'b> {\n \n                     ViewPathList(_, ref list) => {\n                         for i in list {\n-                            self.check_import(i.node.id(), i.span);\n+                            self.check_import(i.node.id, i.span);\n                         }\n                     }\n                     ViewPathGlob(_) => {"}, {"sha": "bd97df764a789cee537f476a2b1afeb42d19d120", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -1618,6 +1618,7 @@ impl<'a> Resolver<'a> {\n             ItemKind::Enum(_, ref generics) |\n             ItemKind::Ty(_, ref generics) |\n             ItemKind::Struct(_, ref generics) |\n+            ItemKind::Union(_, ref generics) |\n             ItemKind::Fn(_, _, _, _, ref generics, _) => {\n                 self.with_type_parameter_rib(HasTypeParameters(generics, ItemRibKind),\n                                              |this| visit::walk_item(this, item));"}, {"sha": "dbe956f021e4c3a90edc04d41231bd4fe28829ce", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -1102,18 +1102,11 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                     }\n                     ast::ViewPathList(ref path, ref list) => {\n                         for plid in list {\n-                            match plid.node {\n-                                ast::PathListItemKind::Ident { id, .. } => {\n-                                    let scope = self.cur_scope;\n-                                    if let Some(def_id) = self.lookup_type_ref(id) {\n-                                        self.process_def_kind(id,\n-                                                              plid.span,\n-                                                              Some(plid.span),\n-                                                              def_id,\n-                                                              scope);\n-                                    }\n-                                }\n-                                ast::PathListItemKind::Mod { .. } => (),\n+                            let scope = self.cur_scope;\n+                            let id = plid.node.id;\n+                            if let Some(def_id) = self.lookup_type_ref(id) {\n+                                let span = plid.span;\n+                                self.process_def_kind(id, span, Some(span), def_id, scope);\n                             }\n                         }\n "}, {"sha": "7fe6d2bbfe24eeb640555c2f2d81cc6862ddcd13", "filename": "src/librustc_trans/assert_module_sources.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_trans%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_trans%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fassert_module_sources.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -29,7 +29,6 @@\n \n use rustc::ty::TyCtxt;\n use syntax::ast;\n-use syntax::attr::AttrMetaMethods;\n use syntax::parse::token::InternedString;\n \n use {ModuleSource, ModuleTranslation};"}, {"sha": "b21785c27dae5e50967ec55912ece1c227af1118", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -42,7 +42,6 @@ use std::process::Command;\n use std::str;\n use flate;\n use syntax::ast;\n-use syntax::attr::AttrMetaMethods;\n use syntax_pos::Span;\n \n // RLIB LLVM-BYTECODE OBJECT LAYOUT"}, {"sha": "fa10adf6c118ed9fd46e61b2b395939a4f8bef79", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -92,7 +92,6 @@ use std::rc::Rc;\n use std::str;\n use std::i32;\n use syntax_pos::{Span, DUMMY_SP};\n-use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n use rustc::hir;\n use syntax::ast;"}, {"sha": "2b6e2a23261bdf21c073c45f6f7d047c22f05616", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -29,7 +29,7 @@ use rustc::hir;\n \n use std::ffi::{CStr, CString};\n use syntax::ast;\n-use syntax::attr::{self, AttrMetaMethods};\n+use syntax::attr;\n use syntax::parse::token;\n \n pub fn ptrcast(val: ValueRef, ty: Type) -> ValueRef {"}, {"sha": "25c30151ad45dbcac159cae4a97b0a49698a7a4a", "filename": "src/librustc_trans/symbol_names_test.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_names_test.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -17,7 +17,6 @@\n use rustc::hir;\n use rustc::hir::intravisit::{self, Visitor};\n use syntax::ast;\n-use syntax::attr::AttrMetaMethods;\n \n use common::SharedCrateContext;\n use monomorphize::Instance;"}, {"sha": "bde7f20f5e6e6e385a3155db980451f5bae52430", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -52,7 +52,7 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let i_n_tps = i_ty.generics.types.len();\n     if i_n_tps != n_tps {\n         let span = match it.node {\n-            hir::ForeignItemFn(_, ref generics) => generics.span().unwrap_or(it.span),\n+            hir::ForeignItemFn(_, ref generics) => generics.span,\n             hir::ForeignItemStatic(_, _) => it.span\n         };\n "}, {"sha": "8f2dc42726696e462759f6a1ec84ebab91039df8", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -112,7 +112,6 @@ use std::ops::Deref;\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n-use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{self, Spanned};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::parse::token::{self, InternedString, keywords};\n@@ -835,13 +834,9 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n                     check_const(ccx, &expr, trait_item.id)\n                 }\n                 hir::MethodTraitItem(ref sig, Some(ref body)) => {\n-                    check_trait_fn_not_const(ccx, trait_item.span, sig.constness);\n-\n                     check_bare_fn(ccx, &sig.decl, body, trait_item.id);\n                 }\n-                hir::MethodTraitItem(ref sig, None) => {\n-                    check_trait_fn_not_const(ccx, trait_item.span, sig.constness);\n-                }\n+                hir::MethodTraitItem(_, None) |\n                 hir::ConstTraitItem(_, None) |\n                 hir::TypeTraitItem(..) => {\n                     // Nothing to do.\n@@ -853,22 +848,6 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n     }\n }\n \n-fn check_trait_fn_not_const<'a,'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                     span: Span,\n-                                     constness: hir::Constness)\n-{\n-    match constness {\n-        hir::Constness::NotConst => {\n-            // good\n-        }\n-        hir::Constness::Const => {\n-            struct_span_err!(ccx.tcx.sess, span, E0379, \"trait fns cannot be declared const\")\n-                .span_label(span, &format!(\"trait fns cannot be const\"))\n-                .emit()\n-        }\n-    }\n-}\n-\n fn check_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     def_id: DefId,\n                                     item: &hir::Item) {\n@@ -1026,9 +1005,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                          err.emit()\n                     }\n                 }\n-                hir::ImplItemKind::Method(ref sig, ref body) => {\n-                    check_trait_fn_not_const(ccx, impl_item.span, sig.constness);\n-\n+                hir::ImplItemKind::Method(_, ref body) => {\n                     let impl_method = match ty_impl_item {\n                         ty::MethodTraitItem(ref mti) => mti,\n                         _ => span_bug!(impl_item.span, \"non-method impl-item for method\")"}, {"sha": "f66f15b238e73fd8eba05395546d54cad68b8cd3", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -49,7 +49,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for UnusedTraitImportVisitor<'a, 'tcx> {\n                 }\n                 hir::ViewPathList(_, ref path_list) => {\n                     for path_item in path_list {\n-                        self.check_import(path_item.node.id(), path_item.span);\n+                        self.check_import(path_item.node.id, path_item.span);\n                     }\n                 }\n             }"}, {"sha": "3f1374db36936093418193e6b326429b41a4e6b8", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -3422,13 +3422,6 @@ containing the unsized type is the last and only unsized type field in the\n struct.\n \"##,\n \n-E0379: r##\"\n-Trait methods cannot be declared `const` by design. For more information, see\n-[RFC 911].\n-\n-[RFC 911]: https://github.com/rust-lang/rfcs/pull/911\n-\"##,\n-\n E0380: r##\"\n Default impls are only allowed for traits with no methods or associated items.\n For more information see the [opt-in builtin traits RFC](https://github.com/rust"}, {"sha": "a5445b18e77f849108a9f2947a6fc4a1bf41c9ab", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -216,10 +216,10 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 Some(hir_map::NodeItem(it)) => {\n                     match it.node {\n                         hir::ItemFn(_, _, _, _, ref generics, _) => {\n-                            if let Some(gen_span) = generics.span() {\n-                                struct_span_err!(ccx.tcx.sess, gen_span, E0131,\n+                            if generics.is_parameterized() {\n+                                struct_span_err!(ccx.tcx.sess, generics.span, E0131,\n                                          \"main function is not allowed to have type parameters\")\n-                                    .span_label(gen_span,\n+                                    .span_label(generics.span,\n                                                 &format!(\"main cannot have type parameters\"))\n                                     .emit();\n                                 return;\n@@ -269,10 +269,9 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                     match it.node {\n                         hir::ItemFn(_,_,_,_,ref ps,_)\n                         if ps.is_parameterized() => {\n-                            let sp = if let Some(sp) = ps.span() { sp } else { start_span };\n-                            struct_span_err!(tcx.sess, sp, E0132,\n+                            struct_span_err!(tcx.sess, ps.span, E0132,\n                                 \"start function is not allowed to have type parameters\")\n-                                .span_label(sp,\n+                                .span_label(ps.span,\n                                             &format!(\"start function cannot have type parameters\"))\n                                 .emit();\n                             return;"}, {"sha": "0af3973f78d21f4b1f45104b9982a07cd53111f0", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 23, "deletions": 61, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -26,10 +26,10 @@ pub use self::Visibility::*;\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n-use syntax::attr::{AttributeMethods, AttrMetaMethods};\n use syntax::codemap::Spanned;\n-use syntax::parse::token::{self, InternedString, keywords};\n+use syntax::parse::token::keywords;\n use syntax::ptr::P;\n+use syntax::print::pprust as syntax_pprust;\n use syntax_pos::{self, DUMMY_SP, Pos};\n \n use rustc_trans::back::link;\n@@ -501,11 +501,24 @@ impl Attributes for [Attribute] {\n     }\n }\n \n+/// This is a flattened version of the AST's Attribute + MetaItem.\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub enum Attribute {\n     Word(String),\n     List(String, Vec<Attribute>),\n-    NameValue(String, String)\n+    NameValue(String, String),\n+    Literal(String),\n+}\n+\n+impl Clean<Attribute> for ast::NestedMetaItem {\n+    fn clean(&self, cx: &DocContext) -> Attribute {\n+        if let Some(mi) = self.meta_item() {\n+            mi.clean(cx)\n+        } else { // must be a literal\n+            let lit = self.literal().unwrap();\n+            Literal(syntax_pprust::lit_to_string(lit))\n+        }\n+    }\n }\n \n impl Clean<Attribute> for ast::MetaItem {\n@@ -527,50 +540,6 @@ impl Clean<Attribute> for ast::Attribute {\n     }\n }\n \n-// This is a rough approximation that gets us what we want.\n-impl attr::AttrMetaMethods for Attribute {\n-    fn name(&self) -> InternedString {\n-        match *self {\n-            Word(ref n) | List(ref n, _) | NameValue(ref n, _) => {\n-                token::intern_and_get_ident(n)\n-            }\n-        }\n-    }\n-\n-    fn value_str(&self) -> Option<InternedString> {\n-        match *self {\n-            NameValue(_, ref v) => {\n-                Some(token::intern_and_get_ident(v))\n-            }\n-            _ => None,\n-        }\n-    }\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<ast::MetaItem>]> { None }\n-\n-    fn is_word(&self) -> bool {\n-      match *self {\n-        Word(_) => true,\n-        _ => false,\n-      }\n-    }\n-\n-    fn is_value_str(&self) -> bool {\n-      match *self {\n-        NameValue(..) => true,\n-        _ => false,\n-      }\n-    }\n-\n-    fn is_meta_item_list(&self) -> bool {\n-      match *self {\n-        List(..) => true,\n-        _ => false,\n-      }\n-    }\n-\n-    fn span(&self) -> syntax_pos::Span { unimplemented!() }\n-}\n-\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub struct TyParam {\n     pub name: String,\n@@ -2534,8 +2503,8 @@ impl Clean<Vec<Item>> for doctree::Import {\n         // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n         let denied = self.vis != hir::Public || self.attrs.iter().any(|a| {\n             &a.name()[..] == \"doc\" && match a.meta_item_list() {\n-                Some(l) => attr::contains_name(l, \"no_inline\") ||\n-                           attr::contains_name(l, \"hidden\"),\n+                Some(l) => attr::list_contains_name(l, \"no_inline\") ||\n+                           attr::list_contains_name(l, \"hidden\"),\n                 None => false,\n             }\n         });\n@@ -2551,7 +2520,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n                 let remaining = if !denied {\n                     let mut remaining = vec![];\n                     for path in list {\n-                        match inline::try_inline(cx, path.node.id(), path.node.rename()) {\n+                        match inline::try_inline(cx, path.node.id, path.node.rename) {\n                             Some(items) => {\n                                 ret.extend(items);\n                             }\n@@ -2619,17 +2588,10 @@ pub struct ViewListIdent {\n \n impl Clean<ViewListIdent> for hir::PathListItem {\n     fn clean(&self, cx: &DocContext) -> ViewListIdent {\n-        match self.node {\n-            hir::PathListIdent { id, name, rename } => ViewListIdent {\n-                name: name.clean(cx),\n-                rename: rename.map(|r| r.clean(cx)),\n-                source: resolve_def(cx, id)\n-            },\n-            hir::PathListMod { id, rename } => ViewListIdent {\n-                name: \"self\".to_string(),\n-                rename: rename.map(|r| r.clean(cx)),\n-                source: resolve_def(cx, id)\n-            }\n+        ViewListIdent {\n+            name: self.node.name.clean(cx),\n+            rename: self.node.rename.map(|r| r.clean(cx)),\n+            source: resolve_def(cx, self.node.id)\n         }\n     }\n }"}, {"sha": "beed1dc9f9e71d14104018e47d97b11563a87291", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -140,7 +140,6 @@ pub fn run(input: &str,\n \n // Look for #![doc(test(no_crate_inject))], used by crates in the std facade\n fn scrape_test_config(krate: &::rustc::hir::Crate) -> TestOptions {\n-    use syntax::attr::AttrMetaMethods;\n     use syntax::print::pprust;\n \n     let mut opts = TestOptions {\n@@ -162,7 +161,7 @@ fn scrape_test_config(krate: &::rustc::hir::Crate) -> TestOptions {\n         if attr.check_name(\"attr\") {\n             if let Some(l) = attr.meta_item_list() {\n                 for item in l {\n-                    opts.attrs.push(pprust::meta_item_to_string(item));\n+                    opts.attrs.push(pprust::meta_list_item_to_string(item));\n                 }\n             }\n         }"}, {"sha": "6af36e24d815632885c808bcb4620bd9283c18b1", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -16,7 +16,6 @@ use std::mem;\n use syntax::abi;\n use syntax::ast;\n use syntax::attr;\n-use syntax::attr::AttrMetaMethods;\n use syntax_pos::Span;\n \n use rustc::hir::map as hir_map;\n@@ -189,7 +188,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             }\n             hir::ViewPathList(p, paths) => {\n                 let mine = paths.into_iter().filter(|path| {\n-                    !self.maybe_inline_local(path.node.id(), path.node.rename(),\n+                    !self.maybe_inline_local(path.node.id, path.node.rename,\n                                              false, om, please_inline)\n                 }).collect::<hir::HirVec<hir::PathListItem>>();\n \n@@ -333,8 +332,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 let node = if item.vis == hir::Public {\n                     let please_inline = item.attrs.iter().any(|item| {\n                         match item.meta_item_list() {\n-                            Some(list) if &item.name()[..] == \"doc\" => {\n-                                list.iter().any(|i| &i.name()[..] == \"inline\")\n+                            Some(list) if item.check_name(\"doc\") => {\n+                                list.iter().any(|i| i.check_name(\"inline\"))\n                             }\n                             _ => false,\n                         }"}, {"sha": "fcb99444957c4aaddf75cbd5fb930b1c641e7b97", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 67, "deletions": 46, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -336,7 +336,7 @@ pub struct TyParam {\n     pub id: NodeId,\n     pub bounds: TyParamBounds,\n     pub default: Option<P<Ty>>,\n-    pub span: Span\n+    pub span: Span,\n }\n \n /// Represents lifetimes and type parameters attached to a declaration\n@@ -346,6 +346,7 @@ pub struct Generics {\n     pub lifetimes: Vec<LifetimeDef>,\n     pub ty_params: P<[TyParam]>,\n     pub where_clause: WhereClause,\n+    pub span: Span,\n }\n \n impl Generics {\n@@ -368,7 +369,8 @@ impl Default for Generics {\n             where_clause: WhereClause {\n                 id: DUMMY_NODE_ID,\n                 predicates: Vec::new(),\n-            }\n+            },\n+            span: DUMMY_SP,\n         }\n     }\n }\n@@ -439,6 +441,22 @@ pub struct Crate {\n     pub exported_macros: Vec<MacroDef>,\n }\n \n+/// A spanned compile-time attribute list item.\n+pub type NestedMetaItem = Spanned<NestedMetaItemKind>;\n+\n+/// Possible values inside of compile-time attribute lists.\n+///\n+/// E.g. the '..' in `#[name(..)]`.\n+#[derive(Clone, Eq, RustcEncodable, RustcDecodable, Hash, Debug, PartialEq)]\n+pub enum NestedMetaItemKind {\n+    /// A full MetaItem, for recursive meta items.\n+    MetaItem(P<MetaItem>),\n+    /// A literal.\n+    ///\n+    /// E.g. \"foo\", 64, true\n+    Literal(Lit),\n+}\n+\n /// A spanned compile-time attribute item.\n ///\n /// E.g. `#[test]`, `#[derive(..)]` or `#[feature = \"foo\"]`\n@@ -456,7 +474,7 @@ pub enum MetaItemKind {\n     /// List meta item.\n     ///\n     /// E.g. `derive(..)` as in `#[derive(..)]`\n-    List(InternedString, Vec<P<MetaItem>>),\n+    List(InternedString, Vec<NestedMetaItem>),\n     /// Name value meta item.\n     ///\n     /// E.g. `feature = \"foo\"` as in `#[feature = \"foo\"]`\n@@ -472,19 +490,21 @@ impl PartialEq for MetaItemKind {\n                 Word(ref no) => (*ns) == (*no),\n                 _ => false\n             },\n+            List(ref ns, ref miss) => match *other {\n+                List(ref no, ref miso) => {\n+                    ns == no &&\n+                        miss.iter().all(|mi| {\n+                            miso.iter().any(|x| x.node == mi.node)\n+                        })\n+                }\n+                _ => false\n+            },\n             NameValue(ref ns, ref vs) => match *other {\n                 NameValue(ref no, ref vo) => {\n                     (*ns) == (*no) && vs.node == vo.node\n                 }\n                 _ => false\n             },\n-            List(ref ns, ref miss) => match *other {\n-                List(ref no, ref miso) => {\n-                    ns == no &&\n-                        miss.iter().all(|mi| miso.iter().any(|x| x.node == mi.node))\n-                }\n-                _ => false\n-            }\n         }\n     }\n }\n@@ -1105,6 +1125,30 @@ impl LitKind {\n             _ => false,\n         }\n     }\n+\n+    /// Returns true if this literal has no suffix. Note: this will return true\n+    /// for literals with prefixes such as raw strings and byte strings.\n+    pub fn is_unsuffixed(&self) -> bool {\n+        match *self {\n+            // unsuffixed variants\n+            LitKind::Str(..) => true,\n+            LitKind::ByteStr(..) => true,\n+            LitKind::Byte(..) => true,\n+            LitKind::Char(..) => true,\n+            LitKind::Int(_, LitIntType::Unsuffixed) => true,\n+            LitKind::FloatUnsuffixed(..) => true,\n+            LitKind::Bool(..) => true,\n+            // suffixed variants\n+            LitKind::Int(_, LitIntType::Signed(..)) => false,\n+            LitKind::Int(_, LitIntType::Unsigned(..)) => false,\n+            LitKind::Float(..) => false,\n+        }\n+    }\n+\n+    /// Returns true if this literal has a suffix.\n+    pub fn is_suffixed(&self) -> bool {\n+        !self.is_unsuffixed()\n+    }\n }\n \n // NB: If you change this, you'll probably want to change the corresponding\n@@ -1120,7 +1164,7 @@ pub struct MutTy {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct MethodSig {\n     pub unsafety: Unsafety,\n-    pub constness: Constness,\n+    pub constness: Spanned<Constness>,\n     pub abi: Abi,\n     pub decl: P<FnDecl>,\n     pub generics: Generics,\n@@ -1624,42 +1668,14 @@ pub struct Variant_ {\n pub type Variant = Spanned<Variant_>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n-pub enum PathListItemKind {\n-    Ident {\n-        name: Ident,\n-        /// renamed in list, e.g. `use foo::{bar as baz};`\n-        rename: Option<Ident>,\n-        id: NodeId\n-    },\n-    Mod {\n-        /// renamed in list, e.g. `use foo::{self as baz};`\n-        rename: Option<Ident>,\n-        id: NodeId\n-    }\n-}\n-\n-impl PathListItemKind {\n-    pub fn id(&self) -> NodeId {\n-        match *self {\n-            PathListItemKind::Ident { id, .. } | PathListItemKind::Mod { id, .. } => id\n-        }\n-    }\n-\n-    pub fn name(&self) -> Option<Ident> {\n-        match *self {\n-            PathListItemKind::Ident { name, .. } => Some(name),\n-            PathListItemKind::Mod { .. } => None,\n-        }\n-    }\n-\n-    pub fn rename(&self) -> Option<Ident> {\n-        match *self {\n-            PathListItemKind::Ident { rename, .. } | PathListItemKind::Mod { rename, .. } => rename\n-        }\n-    }\n+pub struct PathListItem_ {\n+    pub name: Ident,\n+    /// renamed in list, e.g. `use foo::{bar as baz};`\n+    pub rename: Option<Ident>,\n+    pub id: NodeId,\n }\n \n-pub type PathListItem = Spanned<PathListItemKind>;\n+pub type PathListItem = Spanned<PathListItem_>;\n \n pub type ViewPath = Spanned<ViewPath_>;\n \n@@ -1846,7 +1862,7 @@ pub enum ItemKind {\n     /// A function declaration (`fn` or `pub fn`).\n     ///\n     /// E.g. `fn foo(bar: usize) -> usize { .. }`\n-    Fn(P<FnDecl>, Unsafety, Constness, Abi, Generics, P<Block>),\n+    Fn(P<FnDecl>, Unsafety, Spanned<Constness>, Abi, Generics, P<Block>),\n     /// A module declaration (`mod` or `pub mod`).\n     ///\n     /// E.g. `mod foo;` or `mod foo { .. }`\n@@ -1867,6 +1883,10 @@ pub enum ItemKind {\n     ///\n     /// E.g. `struct Foo<A> { x: A }`\n     Struct(VariantData, Generics),\n+    /// A union definition (`union` or `pub union`).\n+    ///\n+    /// E.g. `union Foo<A, B> { x: A, y: B }`\n+    Union(VariantData, Generics), // FIXME: not yet implemented\n     /// A Trait declaration (`trait` or `pub trait`).\n     ///\n     /// E.g. `trait Foo { .. }` or `trait Foo<T> { .. }`\n@@ -1903,6 +1923,7 @@ impl ItemKind {\n             ItemKind::Ty(..) => \"type alias\",\n             ItemKind::Enum(..) => \"enum\",\n             ItemKind::Struct(..) => \"struct\",\n+            ItemKind::Union(..) => \"union\",\n             ItemKind::Trait(..) => \"trait\",\n             ItemKind::Mac(..) |\n             ItemKind::Impl(..) |"}, {"sha": "6060ff529f2155bbe01d47ae3275e2e2b525bfa2", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 238, "deletions": 149, "changes": 387, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -15,9 +15,10 @@ pub use self::ReprAttr::*;\n pub use self::IntType::*;\n \n use ast;\n-use ast::{AttrId, Attribute, Attribute_, MetaItem, MetaItemKind};\n-use ast::{Expr, Item, Local, Stmt, StmtKind};\n-use codemap::{respan, spanned, dummy_spanned, Spanned};\n+use ast::{AttrId, Attribute, Attribute_};\n+use ast::{MetaItem, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n+use ast::{Lit, Expr, Item, Local, Stmt, StmtKind};\n+use codemap::{respan, spanned, dummy_spanned};\n use syntax_pos::{Span, BytePos, DUMMY_SP};\n use errors::Handler;\n use feature_gate::{Features, GatedCfg};\n@@ -40,6 +41,7 @@ enum AttrError {\n     MissingSince,\n     MissingFeature,\n     MultipleStabilityLevels,\n+    UnsupportedLiteral\n }\n \n fn handle_errors(diag: &Handler, span: Span, error: AttrError) {\n@@ -52,10 +54,12 @@ fn handle_errors(diag: &Handler, span: Span, error: AttrError) {\n         AttrError::MissingFeature => span_err!(diag, span, E0546, \"missing 'feature'\"),\n         AttrError::MultipleStabilityLevels => span_err!(diag, span, E0544,\n                                                         \"multiple stability levels\"),\n+        AttrError::UnsupportedLiteral => span_err!(diag, span, E0565, \"unsupported literal\"),\n     }\n }\n \n pub fn mark_used(attr: &Attribute) {\n+    debug!(\"Marking {:?} as used.\", attr);\n     let AttrId(id) = attr.node.id;\n     USED_ATTRS.with(|slot| {\n         let idx = (id / 64) as usize;\n@@ -77,68 +81,128 @@ pub fn is_used(attr: &Attribute) -> bool {\n     })\n }\n \n-pub trait AttrMetaMethods {\n-    fn check_name(&self, name: &str) -> bool {\n-        name == &self.name()[..]\n+impl NestedMetaItem {\n+    /// Returns the MetaItem if self is a NestedMetaItemKind::MetaItem.\n+    pub fn meta_item(&self) -> Option<&P<MetaItem>> {\n+        match self.node {\n+            NestedMetaItemKind::MetaItem(ref item) => Some(&item),\n+            _ => None\n+        }\n+    }\n+\n+    /// Returns the Lit if self is a NestedMetaItemKind::Literal.\n+    pub fn literal(&self) -> Option<&Lit> {\n+        match self.node {\n+            NestedMetaItemKind::Literal(ref lit) => Some(&lit),\n+            _ => None\n+        }\n     }\n \n-    /// Retrieve the name of the meta item, e.g. `foo` in `#[foo]`,\n-    /// `#[foo=\"bar\"]` and `#[foo(bar)]`\n-    fn name(&self) -> InternedString;\n+    /// Returns the Span for `self`.\n+    pub fn span(&self) -> Span {\n+        self.span\n+    }\n+\n+    /// Returns true if this list item is a MetaItem with a name of `name`.\n+    pub fn check_name(&self, name: &str) -> bool {\n+        self.meta_item().map_or(false, |meta_item| meta_item.check_name(name))\n+    }\n+\n+    /// Returns the name of the meta item, e.g. `foo` in `#[foo]`,\n+    /// `#[foo=\"bar\"]` and `#[foo(bar)]`, if self is a MetaItem\n+    pub fn name(&self) -> Option<InternedString> {\n+        self.meta_item().and_then(|meta_item| Some(meta_item.name()))\n+    }\n+\n+    /// Gets the string value if self is a MetaItem and the MetaItem is a\n+    /// MetaItemKind::NameValue variant containing a string, otherwise None.\n+    pub fn value_str(&self) -> Option<InternedString> {\n+        self.meta_item().and_then(|meta_item| meta_item.value_str())\n+    }\n+\n+    /// Returns a MetaItem if self is a MetaItem with Kind Word.\n+    pub fn word(&self) -> Option<&P<MetaItem>> {\n+        self.meta_item().and_then(|meta_item| if meta_item.is_word() {\n+            Some(meta_item)\n+        } else {\n+            None\n+        })\n+    }\n \n-    /// Gets the string value if self is a MetaItemKind::NameValue variant\n-    /// containing a string, otherwise None.\n-    fn value_str(&self) -> Option<InternedString>;\n     /// Gets a list of inner meta items from a list MetaItem type.\n-    fn meta_item_list(&self) -> Option<&[P<MetaItem>]>;\n+    pub fn meta_item_list(&self) -> Option<&[NestedMetaItem]> {\n+        self.meta_item().and_then(|meta_item| meta_item.meta_item_list())\n+    }\n \n-    /// Indicates if the attribute is a Word.\n-    fn is_word(&self) -> bool;\n+    /// Returns `true` if the variant is MetaItem.\n+    pub fn is_meta_item(&self) -> bool {\n+        self.meta_item().is_some()\n+    }\n \n-    /// Indicates if the attribute is a Value String.\n-    fn is_value_str(&self) -> bool {\n+    /// Returns `true` if the variant is Literal.\n+    pub fn is_literal(&self) -> bool {\n+        self.literal().is_some()\n+    }\n+\n+    /// Returns `true` if self is a MetaItem and the meta item is a word.\n+    pub fn is_word(&self) -> bool {\n+        self.word().is_some()\n+    }\n+\n+    /// Returns `true` if self is a MetaItem and the meta item is a ValueString.\n+    pub fn is_value_str(&self) -> bool {\n         self.value_str().is_some()\n     }\n \n-    /// Indicates if the attribute is a Meta-Item List.\n-    fn is_meta_item_list(&self) -> bool {\n+    /// Returns `true` if self is a MetaItem and the meta item is a list.\n+    pub fn is_meta_item_list(&self) -> bool {\n         self.meta_item_list().is_some()\n     }\n-\n-    fn span(&self) -> Span;\n }\n \n-impl AttrMetaMethods for Attribute {\n-    fn check_name(&self, name: &str) -> bool {\n+impl Attribute {\n+    pub fn check_name(&self, name: &str) -> bool {\n         let matches = name == &self.name()[..];\n         if matches {\n             mark_used(self);\n         }\n         matches\n     }\n-    fn name(&self) -> InternedString { self.meta().name() }\n-    fn value_str(&self) -> Option<InternedString> {\n+\n+    pub fn name(&self) -> InternedString { self.meta().name() }\n+\n+    pub fn value_str(&self) -> Option<InternedString> {\n         self.meta().value_str()\n     }\n-    fn meta_item_list(&self) -> Option<&[P<MetaItem>]> {\n+\n+    pub fn meta_item_list(&self) -> Option<&[NestedMetaItem]> {\n         self.meta().meta_item_list()\n     }\n \n-    fn is_word(&self) -> bool { self.meta().is_word() }\n+    pub fn is_word(&self) -> bool { self.meta().is_word() }\n+\n+    pub fn span(&self) -> Span { self.meta().span }\n+\n+    pub fn is_meta_item_list(&self) -> bool {\n+        self.meta_item_list().is_some()\n+    }\n \n-    fn span(&self) -> Span { self.meta().span }\n+    /// Indicates if the attribute is a Value String.\n+    pub fn is_value_str(&self) -> bool {\n+        self.value_str().is_some()\n+    }\n }\n \n-impl AttrMetaMethods for MetaItem {\n-    fn name(&self) -> InternedString {\n+impl MetaItem {\n+    pub fn name(&self) -> InternedString {\n         match self.node {\n             MetaItemKind::Word(ref n) => (*n).clone(),\n             MetaItemKind::NameValue(ref n, _) => (*n).clone(),\n             MetaItemKind::List(ref n, _) => (*n).clone(),\n         }\n     }\n \n-    fn value_str(&self) -> Option<InternedString> {\n+    pub fn value_str(&self) -> Option<InternedString> {\n         match self.node {\n             MetaItemKind::NameValue(_, ref v) => {\n                 match v.node {\n@@ -150,53 +214,45 @@ impl AttrMetaMethods for MetaItem {\n         }\n     }\n \n-    fn meta_item_list(&self) -> Option<&[P<MetaItem>]> {\n+    pub fn meta_item_list(&self) -> Option<&[NestedMetaItem]> {\n         match self.node {\n             MetaItemKind::List(_, ref l) => Some(&l[..]),\n             _ => None\n         }\n     }\n \n-    fn is_word(&self) -> bool {\n+    pub fn is_word(&self) -> bool {\n         match self.node {\n             MetaItemKind::Word(_) => true,\n             _ => false,\n         }\n     }\n \n-    fn span(&self) -> Span { self.span }\n-}\n+    pub fn span(&self) -> Span { self.span }\n \n-// Annoying, but required to get test_cfg to work\n-impl AttrMetaMethods for P<MetaItem> {\n-    fn name(&self) -> InternedString { (**self).name() }\n-    fn value_str(&self) -> Option<InternedString> { (**self).value_str() }\n-    fn meta_item_list(&self) -> Option<&[P<MetaItem>]> {\n-        (**self).meta_item_list()\n+    pub fn check_name(&self, name: &str) -> bool {\n+        name == &self.name()[..]\n     }\n-    fn is_word(&self) -> bool { (**self).is_word() }\n-    fn is_value_str(&self) -> bool { (**self).is_value_str() }\n-    fn is_meta_item_list(&self) -> bool { (**self).is_meta_item_list() }\n-    fn span(&self) -> Span { (**self).span() }\n-}\n \n+    pub fn is_value_str(&self) -> bool {\n+        self.value_str().is_some()\n+    }\n \n-pub trait AttributeMethods {\n-    fn meta(&self) -> &MetaItem;\n-    fn with_desugared_doc<T, F>(&self, f: F) -> T where\n-        F: FnOnce(&Attribute) -> T;\n+    pub fn is_meta_item_list(&self) -> bool {\n+        self.meta_item_list().is_some()\n+    }\n }\n \n-impl AttributeMethods for Attribute {\n+impl Attribute {\n     /// Extract the MetaItem from inside this Attribute.\n-    fn meta(&self) -> &MetaItem {\n+    pub fn meta(&self) -> &MetaItem {\n         &self.node.value\n     }\n \n     /// Convert self to a normal #[doc=\"foo\"] comment, if it is a\n     /// comment like `///` or `/** */`. (Returns self unchanged for\n     /// non-sugared doc attributes.)\n-    fn with_desugared_doc<T, F>(&self, f: F) -> T where\n+    pub fn with_desugared_doc<T, F>(&self, f: F) -> T where\n         F: FnOnce(&Attribute) -> T,\n     {\n         if self.node.is_sugared_doc {\n@@ -229,10 +285,14 @@ pub fn mk_name_value_item(name: InternedString, value: ast::Lit)\n     mk_spanned_name_value_item(DUMMY_SP, name, value)\n }\n \n-pub fn mk_list_item(name: InternedString, items: Vec<P<MetaItem>>) -> P<MetaItem> {\n+pub fn mk_list_item(name: InternedString, items: Vec<NestedMetaItem>) -> P<MetaItem> {\n     mk_spanned_list_item(DUMMY_SP, name, items)\n }\n \n+pub fn mk_list_word_item(name: InternedString) -> ast::NestedMetaItem {\n+    dummy_spanned(NestedMetaItemKind::MetaItem(mk_spanned_word_item(DUMMY_SP, name)))\n+}\n+\n pub fn mk_word_item(name: InternedString) -> P<MetaItem> {\n     mk_spanned_word_item(DUMMY_SP, name)\n }\n@@ -242,7 +302,7 @@ pub fn mk_spanned_name_value_item(sp: Span, name: InternedString, value: ast::Li\n     P(respan(sp, MetaItemKind::NameValue(name, value)))\n }\n \n-pub fn mk_spanned_list_item(sp: Span, name: InternedString, items: Vec<P<MetaItem>>)\n+pub fn mk_spanned_list_item(sp: Span, name: InternedString, items: Vec<NestedMetaItem>)\n                             -> P<MetaItem> {\n     P(respan(sp, MetaItemKind::List(name, items)))\n }\n@@ -332,9 +392,17 @@ pub fn contains(haystack: &[P<MetaItem>], needle: &MetaItem) -> bool {\n     })\n }\n \n-pub fn contains_name<AM: AttrMetaMethods>(metas: &[AM], name: &str) -> bool {\n+pub fn list_contains_name(items: &[NestedMetaItem], name: &str) -> bool {\n+    debug!(\"attr::list_contains_name (name={})\", name);\n+    items.iter().any(|item| {\n+        debug!(\"  testing: {:?}\", item.name());\n+        item.check_name(name)\n+    })\n+}\n+\n+pub fn contains_name(attrs: &[Attribute], name: &str) -> bool {\n     debug!(\"attr::contains_name (name={})\", name);\n-    metas.iter().any(|item| {\n+    attrs.iter().any(|item| {\n         debug!(\"  testing: {}\", item.name());\n         item.check_name(name)\n     })\n@@ -357,27 +425,6 @@ pub fn last_meta_item_value_str_by_name(items: &[P<MetaItem>], name: &str)\n \n /* Higher-level applications */\n \n-pub fn sort_meta_items(items: Vec<P<MetaItem>>) -> Vec<P<MetaItem>> {\n-    // This is sort of stupid here, but we need to sort by\n-    // human-readable strings.\n-    let mut v = items.into_iter()\n-        .map(|mi| (mi.name(), mi))\n-        .collect::<Vec<(InternedString, P<MetaItem>)>>();\n-\n-    v.sort_by(|&(ref a, _), &(ref b, _)| a.cmp(b));\n-\n-    // There doesn't seem to be a more optimal way to do this\n-    v.into_iter().map(|(_, m)| m.map(|Spanned {node, span}| {\n-        Spanned {\n-            node: match node {\n-                MetaItemKind::List(n, mis) => MetaItemKind::List(n, sort_meta_items(mis)),\n-                _ => node\n-            },\n-            span: span\n-        }\n-    })).collect()\n-}\n-\n pub fn find_crate_name(attrs: &[Attribute]) -> Option<InternedString> {\n     first_attr_value_str_by_name(attrs, \"crate_name\")\n }\n@@ -427,14 +474,15 @@ pub fn find_inline_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> In\n                 if items.len() != 1 {\n                     diagnostic.map(|d|{ span_err!(d, attr.span, E0534, \"expected one argument\"); });\n                     InlineAttr::None\n-                } else if contains_name(&items[..], \"always\") {\n+                } else if list_contains_name(&items[..], \"always\") {\n                     InlineAttr::Always\n-                } else if contains_name(&items[..], \"never\") {\n+                } else if list_contains_name(&items[..], \"never\") {\n                     InlineAttr::Never\n                 } else {\n                     diagnostic.map(|d| {\n-                        span_err!(d, (*items[0]).span, E0535, \"invalid argument\");\n+                        span_err!(d, items[0].span, E0535, \"invalid argument\");\n                     });\n+\n                     InlineAttr::None\n                 }\n             }\n@@ -453,27 +501,44 @@ pub fn requests_inline(attrs: &[Attribute]) -> bool {\n \n /// Tests if a cfg-pattern matches the cfg set\n pub fn cfg_matches(cfgs: &[P<MetaItem>], cfg: &ast::MetaItem,\n-                   sess: &ParseSess, features: Option<&Features>)\n+                   sess: &ParseSess,\n+                   features: Option<&Features>)\n                    -> bool {\n     match cfg.node {\n-        ast::MetaItemKind::List(ref pred, ref mis) if &pred[..] == \"any\" =>\n-            mis.iter().any(|mi| cfg_matches(cfgs, &mi, sess, features)),\n-        ast::MetaItemKind::List(ref pred, ref mis) if &pred[..] == \"all\" =>\n-            mis.iter().all(|mi| cfg_matches(cfgs, &mi, sess, features)),\n-        ast::MetaItemKind::List(ref pred, ref mis) if &pred[..] == \"not\" => {\n-            if mis.len() != 1 {\n-                span_err!(sess.span_diagnostic, cfg.span, E0536, \"expected 1 cfg-pattern\");\n-                return false;\n+        ast::MetaItemKind::List(ref pred, ref mis) => {\n+            for mi in mis.iter() {\n+                if !mi.is_meta_item() {\n+                    handle_errors(&sess.span_diagnostic, mi.span, AttrError::UnsupportedLiteral);\n+                    return false;\n+                }\n+            }\n+\n+            // The unwraps below may look dangerous, but we've already asserted\n+            // that they won't fail with the loop above.\n+            match &pred[..] {\n+                \"any\" => mis.iter().any(|mi| {\n+                    cfg_matches(cfgs, mi.meta_item().unwrap(), sess, features)\n+                }),\n+                \"all\" => mis.iter().all(|mi| {\n+                    cfg_matches(cfgs, mi.meta_item().unwrap(), sess, features)\n+                }),\n+                \"not\" => {\n+                    if mis.len() != 1 {\n+                        span_err!(sess.span_diagnostic, cfg.span, E0536, \"expected 1 cfg-pattern\");\n+                        return false;\n+                    }\n+\n+                    !cfg_matches(cfgs, mis[0].meta_item().unwrap(), sess, features)\n+                },\n+                p => {\n+                    span_err!(sess.span_diagnostic, cfg.span, E0537, \"invalid predicate `{}`\", p);\n+                    false\n+                }\n             }\n-            !cfg_matches(cfgs, &mis[0], sess, features)\n-        }\n-        ast::MetaItemKind::List(ref pred, _) => {\n-            span_err!(sess.span_diagnostic, cfg.span, E0537, \"invalid predicate `{}`\", pred);\n-            false\n         },\n         ast::MetaItemKind::Word(_) | ast::MetaItemKind::NameValue(..) => {\n-            if let (Some(features), Some(gated_cfg)) = (features, GatedCfg::gate(cfg)) {\n-                gated_cfg.check_and_emit(sess, features);\n+            if let (Some(feats), Some(gated_cfg)) = (features, GatedCfg::gate(cfg)) {\n+                gated_cfg.check_and_emit(sess, feats);\n             }\n             contains(cfgs, cfg)\n         }\n@@ -557,14 +622,19 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     let mut since = None;\n                     let mut reason = None;\n                     for meta in metas {\n-                        match &*meta.name() {\n-                            \"since\" => if !get(meta, &mut since) { continue 'outer },\n-                            \"reason\" => if !get(meta, &mut reason) { continue 'outer },\n-                            _ => {\n-                                handle_errors(diagnostic, meta.span,\n-                                              AttrError::UnknownMetaItem(meta.name()));\n-                                continue 'outer\n+                        if let Some(mi) = meta.meta_item() {\n+                            match &*mi.name() {\n+                                \"since\" => if !get(mi, &mut since) { continue 'outer },\n+                                \"reason\" => if !get(mi, &mut reason) { continue 'outer },\n+                                _ => {\n+                                    handle_errors(diagnostic, mi.span,\n+                                                  AttrError::UnknownMetaItem(mi.name()));\n+                                    continue 'outer\n+                                }\n                             }\n+                        } else {\n+                            handle_errors(diagnostic, meta.span, AttrError::UnsupportedLiteral);\n+                            continue 'outer\n                         }\n                     }\n \n@@ -595,15 +665,20 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     let mut reason = None;\n                     let mut issue = None;\n                     for meta in metas {\n-                        match &*meta.name() {\n-                            \"feature\" => if !get(meta, &mut feature) { continue 'outer },\n-                            \"reason\" => if !get(meta, &mut reason) { continue 'outer },\n-                            \"issue\" => if !get(meta, &mut issue) { continue 'outer },\n-                            _ => {\n-                                handle_errors(diagnostic, meta.span,\n-                                              AttrError::UnknownMetaItem(meta.name()));\n-                                continue 'outer\n+                        if let Some(mi) = meta.meta_item() {\n+                            match &*mi.name() {\n+                                \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n+                                \"reason\" => if !get(mi, &mut reason) { continue 'outer },\n+                                \"issue\" => if !get(mi, &mut issue) { continue 'outer },\n+                                _ => {\n+                                    handle_errors(diagnostic, meta.span,\n+                                                  AttrError::UnknownMetaItem(mi.name()));\n+                                    continue 'outer\n+                                }\n                             }\n+                        } else {\n+                            handle_errors(diagnostic, meta.span, AttrError::UnsupportedLiteral);\n+                            continue 'outer\n                         }\n                     }\n \n@@ -645,14 +720,19 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     let mut feature = None;\n                     let mut since = None;\n                     for meta in metas {\n-                        match &*meta.name() {\n-                            \"feature\" => if !get(meta, &mut feature) { continue 'outer },\n-                            \"since\" => if !get(meta, &mut since) { continue 'outer },\n-                            _ => {\n-                                handle_errors(diagnostic, meta.span,\n-                                              AttrError::UnknownMetaItem(meta.name()));\n-                                continue 'outer\n+                        if let NestedMetaItemKind::MetaItem(ref mi) = meta.node {\n+                            match &*mi.name() {\n+                                \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n+                                \"since\" => if !get(mi, &mut since) { continue 'outer },\n+                                _ => {\n+                                    handle_errors(diagnostic, meta.span,\n+                                                  AttrError::UnknownMetaItem(mi.name()));\n+                                    continue 'outer\n+                                }\n                             }\n+                        } else {\n+                            handle_errors(diagnostic, meta.span, AttrError::UnsupportedLiteral);\n+                            continue 'outer\n                         }\n                     }\n \n@@ -739,14 +819,19 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n             let mut since = None;\n             let mut note = None;\n             for meta in metas {\n-                match &*meta.name() {\n-                    \"since\" => if !get(meta, &mut since) { continue 'outer },\n-                    \"note\" => if !get(meta, &mut note) { continue 'outer },\n-                    _ => {\n-                        handle_errors(diagnostic, meta.span,\n-                                      AttrError::UnknownMetaItem(meta.name()));\n-                        continue 'outer\n+                if let NestedMetaItemKind::MetaItem(ref mi) = meta.node {\n+                    match &*mi.name() {\n+                        \"since\" => if !get(mi, &mut since) { continue 'outer },\n+                        \"note\" => if !get(mi, &mut note) { continue 'outer },\n+                        _ => {\n+                            handle_errors(diagnostic, meta.span,\n+                                          AttrError::UnknownMetaItem(mi.name()));\n+                            continue 'outer\n+                        }\n                     }\n+                } else {\n+                    handle_errors(diagnostic, meta.span, AttrError::UnsupportedLiteral);\n+                    continue 'outer\n                 }\n             }\n \n@@ -796,32 +881,36 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n         ast::MetaItemKind::List(ref s, ref items) if s == \"repr\" => {\n             mark_used(attr);\n             for item in items {\n-                match item.node {\n-                    ast::MetaItemKind::Word(ref word) => {\n-                        let hint = match &word[..] {\n-                            // Can't use \"extern\" because it's not a lexical identifier.\n-                            \"C\" => Some(ReprExtern),\n-                            \"packed\" => Some(ReprPacked),\n-                            \"simd\" => Some(ReprSimd),\n-                            _ => match int_type_of_word(&word) {\n-                                Some(ity) => Some(ReprInt(item.span, ity)),\n-                                None => {\n-                                    // Not a word we recognize\n-                                    span_err!(diagnostic, item.span, E0552,\n-                                              \"unrecognized representation hint\");\n-                                    None\n-                                }\n-                            }\n-                        };\n+                if !item.is_meta_item() {\n+                    handle_errors(diagnostic, item.span, AttrError::UnsupportedLiteral);\n+                    continue\n+                }\n \n-                        match hint {\n-                            Some(h) => acc.push(h),\n-                            None => { }\n+                if let Some(mi) = item.word() {\n+                    let word = &*mi.name();\n+                    let hint = match word {\n+                        // Can't use \"extern\" because it's not a lexical identifier.\n+                        \"C\" => Some(ReprExtern),\n+                        \"packed\" => Some(ReprPacked),\n+                        \"simd\" => Some(ReprSimd),\n+                        _ => match int_type_of_word(word) {\n+                            Some(ity) => Some(ReprInt(item.span, ity)),\n+                            None => {\n+                                // Not a word we recognize\n+                                span_err!(diagnostic, item.span, E0552,\n+                                          \"unrecognized representation hint\");\n+                                None\n+                            }\n                         }\n+                    };\n+\n+                    match hint {\n+                        Some(h) => acc.push(h),\n+                        None => { }\n                     }\n-                    // Not a word:\n-                    _ => span_err!(diagnostic, item.span, E0553,\n-                                   \"unrecognized enum representation hint\"),\n+                } else {\n+                    span_err!(diagnostic, item.span, E0553,\n+                              \"unrecognized enum representation hint\");\n                 }\n             }\n         }"}, {"sha": "69a979176521b47d8f38b3e1841b34da99880aa5", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use attr::{AttrMetaMethods, HasAttrs};\n+use attr::HasAttrs;\n use feature_gate::{emit_feature_err, EXPLAIN_STMT_ATTR_SYNTAX, Features, get_features, GateIssue};\n use fold::Folder;\n use {fold, attr};\n@@ -52,6 +52,7 @@ impl<'a> StripUnconfigured<'a> {\n                 return None;\n             }\n         };\n+\n         let (cfg, mi) = match (attr_list.len(), attr_list.get(0), attr_list.get(1)) {\n             (2, Some(cfg), Some(mi)) => (cfg, mi),\n             _ => {\n@@ -61,15 +62,24 @@ impl<'a> StripUnconfigured<'a> {\n             }\n         };\n \n-        if attr::cfg_matches(self.config, &cfg, self.sess, self.features) {\n-            self.process_cfg_attr(respan(mi.span, ast::Attribute_ {\n-                id: attr::mk_attr_id(),\n-                style: attr.node.style,\n-                value: mi.clone(),\n-                is_sugared_doc: false,\n-            }))\n-        } else {\n-            None\n+        use attr::cfg_matches;\n+        match (cfg.meta_item(), mi.meta_item()) {\n+            (Some(cfg), Some(mi)) =>\n+                if cfg_matches(self.config, &cfg, self.sess, self.features) {\n+                    self.process_cfg_attr(respan(mi.span, ast::Attribute_ {\n+                        id: attr::mk_attr_id(),\n+                        style: attr.node.style,\n+                        value: mi.clone(),\n+                        is_sugared_doc: false,\n+                    }))\n+                } else {\n+                    None\n+                },\n+            _ => {\n+                let msg = \"unexpected literal(s) in `#[cfg_attr(<cfg pattern>, <attr>)]`\";\n+                self.sess.span_diagnostic.span_err(attr.span, msg);\n+                None\n+            }\n         }\n     }\n \n@@ -91,7 +101,12 @@ impl<'a> StripUnconfigured<'a> {\n                 return true;\n             }\n \n-            attr::cfg_matches(self.config, &mis[0], self.sess, self.features)\n+            if !mis[0].is_meta_item() {\n+                self.sess.span_diagnostic.span_err(mis[0].span, \"unexpected literal\");\n+                return true;\n+            }\n+\n+            attr::cfg_matches(self.config, mis[0].meta_item().unwrap(), self.sess, self.features)\n         })\n     }\n \n@@ -165,6 +180,9 @@ impl<'a> fold::Folder for StripUnconfigured<'a> {\n             ast::ItemKind::Struct(def, generics) => {\n                 ast::ItemKind::Struct(fold_struct(self, def), generics)\n             }\n+            ast::ItemKind::Union(def, generics) => {\n+                ast::ItemKind::Union(fold_struct(self, def), generics)\n+            }\n             ast::ItemKind::Enum(def, generics) => {\n                 let variants = def.variants.into_iter().filter_map(|v| {\n                     self.configure(v).map(|v| {"}, {"sha": "9110e989a8a1491f6d1f884a78d79e06790c1241", "filename": "src/libsyntax/diagnostic_list.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Fdiagnostic_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Fdiagnostic_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic_list.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -161,6 +161,24 @@ fn main() {}\n ```\n \"##,\n \n+E0565: r##\"\n+A literal was used in an attribute that doesn't support literals.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0565\n+#[inline(\"always\")] // error: unsupported literal\n+pub fn something() {}\n+```\n+\n+Literals in attributes are new and largely unsupported. Work to support literals\n+where appropriate is ongoing. Try using an unquoted name instead:\n+\n+```\n+#[inline(always)]\n+pub fn something() {}\n+```\n+\"##,\n }\n \n register_diagnostics! {"}, {"sha": "43e190f5deb813d26cfcb13f2c11ec919df40fc1", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -60,13 +60,6 @@ impl HasAttrs for Annotatable {\n }\n \n impl Annotatable {\n-    pub fn attrs(&self) -> &[ast::Attribute] {\n-        HasAttrs::attrs(self)\n-    }\n-    pub fn fold_attrs(self, attrs: Vec<ast::Attribute>) -> Annotatable {\n-        self.map_attrs(|_| attrs)\n-    }\n-\n     pub fn expect_item(self) -> P<ast::Item> {\n         match self {\n             Annotatable::Item(i) => i,"}, {"sha": "3dcdbc890962790de746e2fe145d5e987d75547a", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 34, "deletions": 25, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -12,7 +12,7 @@ use abi::Abi;\n use ast::{self, Ident, Generics, Expr, BlockCheckMode, UnOp, PatKind};\n use attr;\n use syntax_pos::{Span, DUMMY_SP, Pos};\n-use codemap::{respan, Spanned};\n+use codemap::{dummy_spanned, respan, Spanned};\n use ext::base::ExtCtxt;\n use parse::token::{self, keywords, InternedString};\n use ptr::P;\n@@ -171,9 +171,11 @@ pub trait AstBuilder {\n                               span: Span,\n                               ident: ast::Ident,\n                               bm: ast::BindingMode) -> P<ast::Pat>;\n-    fn pat_enum(&self, span: Span, path: ast::Path, subpats: Vec<P<ast::Pat>> ) -> P<ast::Pat>;\n-    fn pat_struct(&self, span: Span,\n-                  path: ast::Path, field_pats: Vec<Spanned<ast::FieldPat>> ) -> P<ast::Pat>;\n+    fn pat_path(&self, span: Span, path: ast::Path) -> P<ast::Pat>;\n+    fn pat_tuple_struct(&self, span: Span, path: ast::Path,\n+                        subpats: Vec<P<ast::Pat>>) -> P<ast::Pat>;\n+    fn pat_struct(&self, span: Span, path: ast::Path,\n+                  field_pats: Vec<Spanned<ast::FieldPat>>) -> P<ast::Pat>;\n     fn pat_tuple(&self, span: Span, pats: Vec<P<ast::Pat>>) -> P<ast::Pat>;\n \n     fn pat_some(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat>;\n@@ -277,10 +279,13 @@ pub trait AstBuilder {\n     fn attribute(&self, sp: Span, mi: P<ast::MetaItem>) -> ast::Attribute;\n \n     fn meta_word(&self, sp: Span, w: InternedString) -> P<ast::MetaItem>;\n+\n+    fn meta_list_item_word(&self, sp: Span, w: InternedString) -> ast::NestedMetaItem;\n+\n     fn meta_list(&self,\n                  sp: Span,\n                  name: InternedString,\n-                 mis: Vec<P<ast::MetaItem>> )\n+                 mis: Vec<ast::NestedMetaItem> )\n                  -> P<ast::MetaItem>;\n     fn meta_name_value(&self,\n                        sp: Span,\n@@ -802,10 +807,10 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let binding_expr = self.expr_ident(sp, binding_variable);\n \n         // Ok(__try_var) pattern\n-        let ok_pat = self.pat_enum(sp, ok_path, vec!(binding_pat.clone()));\n+        let ok_pat = self.pat_tuple_struct(sp, ok_path, vec![binding_pat.clone()]);\n \n         // Err(__try_var)  (pattern and expression resp.)\n-        let err_pat = self.pat_enum(sp, err_path.clone(), vec!(binding_pat));\n+        let err_pat = self.pat_tuple_struct(sp, err_path.clone(), vec![binding_pat]);\n         let err_inner_expr = self.expr_call(sp, self.expr_path(err_path),\n                                             vec!(binding_expr.clone()));\n         // return Err(__try_var)\n@@ -842,18 +847,16 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let pat = PatKind::Ident(bm, Spanned{span: span, node: ident}, None);\n         self.pat(span, pat)\n     }\n-    fn pat_enum(&self, span: Span, path: ast::Path, subpats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n-        let pat = if subpats.is_empty() {\n-            PatKind::Path(None, path)\n-        } else {\n-            PatKind::TupleStruct(path, subpats, None)\n-        };\n-        self.pat(span, pat)\n+    fn pat_path(&self, span: Span, path: ast::Path) -> P<ast::Pat> {\n+        self.pat(span, PatKind::Path(None, path))\n     }\n-    fn pat_struct(&self, span: Span,\n-                  path: ast::Path, field_pats: Vec<Spanned<ast::FieldPat>>) -> P<ast::Pat> {\n-        let pat = PatKind::Struct(path, field_pats, false);\n-        self.pat(span, pat)\n+    fn pat_tuple_struct(&self, span: Span, path: ast::Path,\n+                        subpats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n+        self.pat(span, PatKind::TupleStruct(path, subpats, None))\n+    }\n+    fn pat_struct(&self, span: Span, path: ast::Path,\n+                  field_pats: Vec<Spanned<ast::FieldPat>>) -> P<ast::Pat> {\n+        self.pat(span, PatKind::Struct(path, field_pats, false))\n     }\n     fn pat_tuple(&self, span: Span, pats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n         self.pat(span, PatKind::Tuple(pats, None))\n@@ -862,25 +865,25 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn pat_some(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n         let some = self.std_path(&[\"option\", \"Option\", \"Some\"]);\n         let path = self.path_global(span, some);\n-        self.pat_enum(span, path, vec!(pat))\n+        self.pat_tuple_struct(span, path, vec![pat])\n     }\n \n     fn pat_none(&self, span: Span) -> P<ast::Pat> {\n         let some = self.std_path(&[\"option\", \"Option\", \"None\"]);\n         let path = self.path_global(span, some);\n-        self.pat_enum(span, path, vec!())\n+        self.pat_path(span, path)\n     }\n \n     fn pat_ok(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n         let some = self.std_path(&[\"result\", \"Result\", \"Ok\"]);\n         let path = self.path_global(span, some);\n-        self.pat_enum(span, path, vec!(pat))\n+        self.pat_tuple_struct(span, path, vec![pat])\n     }\n \n     fn pat_err(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n         let some = self.std_path(&[\"result\", \"Result\", \"Err\"]);\n         let path = self.path_global(span, some);\n-        self.pat_enum(span, path, vec!(pat))\n+        self.pat_tuple_struct(span, path, vec![pat])\n     }\n \n     fn arm(&self, _span: Span, pats: Vec<P<ast::Pat>>, expr: P<ast::Expr>) -> ast::Arm {\n@@ -1016,7 +1019,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                   Vec::new(),\n                   ast::ItemKind::Fn(self.fn_decl(inputs, output),\n                               ast::Unsafety::Normal,\n-                              ast::Constness::NotConst,\n+                              dummy_spanned(ast::Constness::NotConst),\n                               Abi::Rust,\n                               generics,\n                               body))\n@@ -1141,10 +1144,16 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn meta_word(&self, sp: Span, w: InternedString) -> P<ast::MetaItem> {\n         attr::mk_spanned_word_item(sp, w)\n     }\n-    fn meta_list(&self, sp: Span, name: InternedString, mis: Vec<P<ast::MetaItem>>)\n+\n+    fn meta_list_item_word(&self, sp: Span, w: InternedString) -> ast::NestedMetaItem {\n+        respan(sp, ast::NestedMetaItemKind::MetaItem(attr::mk_spanned_word_item(sp, w)))\n+    }\n+\n+    fn meta_list(&self, sp: Span, name: InternedString, mis: Vec<ast::NestedMetaItem>)\n                  -> P<ast::MetaItem> {\n         attr::mk_spanned_list_item(sp, name, mis)\n     }\n+\n     fn meta_name_value(&self, sp: Span, name: InternedString, value: ast::LitKind)\n                        -> P<ast::MetaItem> {\n         attr::mk_spanned_name_value_item(sp, name, respan(sp, value))\n@@ -1178,7 +1187,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn item_use_list(&self, sp: Span, vis: ast::Visibility,\n                      path: Vec<ast::Ident>, imports: &[ast::Ident]) -> P<ast::Item> {\n         let imports = imports.iter().map(|id| {\n-            let item = ast::PathListItemKind::Ident {\n+            let item = ast::PathListItem_ {\n                 name: *id,\n                 rename: None,\n                 id: ast::DUMMY_NODE_ID,"}, {"sha": "15ebf95d6239370e76ce470dae113680613dbfd4", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -13,7 +13,6 @@ use ast::{MacStmtStyle, Stmt, StmtKind, ItemKind};\n use ast;\n use ext::hygiene::Mark;\n use attr::{self, HasAttrs};\n-use attr::AttrMetaMethods;\n use codemap::{dummy_spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use syntax_pos::{self, Span, ExpnId};\n use config::StripUnconfigured;"}, {"sha": "1e15c1563561cbd0d30656d36b1ed96258517137", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 41, "deletions": 16, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -26,11 +26,9 @@ use self::AttributeType::*;\n use self::AttributeGate::*;\n \n use abi::Abi;\n-use ast::{NodeId, PatKind};\n-use ast;\n+use ast::{self, NodeId, PatKind};\n use attr;\n-use attr::AttrMetaMethods;\n-use codemap::CodeMap;\n+use codemap::{CodeMap, Spanned};\n use syntax_pos::Span;\n use errors::Handler;\n use visit::{self, FnKind, Visitor};\n@@ -280,7 +278,10 @@ declare_features! (\n     (active, relaxed_adts, \"1.12.0\", Some(35626)),\n \n     // The `!` type\n-    (active, never_type, \"1.13.0\", Some(35121))\n+    (active, never_type, \"1.13.0\", Some(35121)),\n+\n+    // Allows all literals in attribute lists and values of key-value pairs.\n+    (active, attr_literals, \"1.13.0\", Some(34981))\n );\n \n declare_features! (\n@@ -830,11 +831,34 @@ impl<'a> PostExpansionVisitor<'a> {\n     }\n }\n \n+fn contains_novel_literal(item: &ast::MetaItem) -> bool {\n+    use ast::MetaItemKind::*;\n+    use ast::NestedMetaItemKind::*;\n+\n+    match item.node {\n+        Word(..) => false,\n+        NameValue(_, ref lit) => !lit.node.is_str(),\n+        List(_, ref list) => list.iter().any(|li| {\n+            match li.node {\n+                MetaItem(ref mi) => contains_novel_literal(&**mi),\n+                Literal(_) => true,\n+            }\n+        }),\n+    }\n+}\n+\n impl<'a> Visitor for PostExpansionVisitor<'a> {\n     fn visit_attribute(&mut self, attr: &ast::Attribute) {\n         if !self.context.cm.span_allows_unstable(attr.span) {\n+            // check for gated attributes\n             self.context.check_attribute(attr, false);\n         }\n+\n+        if contains_novel_literal(&*(attr.node.value)) {\n+            gate_feature_post!(&self, attr_literals, attr.span,\n+                               \"non-string literals in attributes, or string \\\n+                               literals in top-level positions, are experimental\");\n+        }\n     }\n \n     fn visit_name(&mut self, sp: Span, name: ast::Name) {\n@@ -894,7 +918,7 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n                 for attr in &i.attrs {\n                     if attr.name() == \"repr\" {\n                         for item in attr.meta_item_list().unwrap_or(&[]) {\n-                            if item.name() == \"simd\" {\n+                            if item.check_name(\"simd\") {\n                                 gate_feature_post!(&self, repr_simd, i.span,\n                                                    \"SIMD types are experimental \\\n                                                     and possibly buggy\");\n@@ -1046,7 +1070,7 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n                 _node_id: NodeId) {\n         // check for const fn declarations\n         match fn_kind {\n-            FnKind::ItemFn(_, _, _, ast::Constness::Const, _, _) => {\n+            FnKind::ItemFn(_, _, _, Spanned { node: ast::Constness::Const, .. }, _, _) => {\n                 gate_feature_post!(&self, const_fn, span, \"const fn is unstable\");\n             }\n             _ => {\n@@ -1078,7 +1102,7 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n                 if block.is_none() {\n                     self.check_abi(sig.abi, ti.span);\n                 }\n-                if sig.constness == ast::Constness::Const {\n+                if sig.constness.node == ast::Constness::Const {\n                     gate_feature_post!(&self, const_fn, ti.span, \"const fn is unstable\");\n                 }\n             }\n@@ -1105,7 +1129,7 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n                                   \"associated constants are experimental\")\n             }\n             ast::ImplItemKind::Method(ref sig, _) => {\n-                if sig.constness == ast::Constness::Const {\n+                if sig.constness.node == ast::Constness::Const {\n                     gate_feature_post!(&self, const_fn, ii.span, \"const fn is unstable\");\n                 }\n             }\n@@ -1154,13 +1178,14 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute]) -> F\n             }\n             Some(list) => {\n                 for mi in list {\n-                    let name = if mi.is_word() {\n-                                   mi.name()\n-                               } else {\n-                                   span_err!(span_handler, mi.span, E0556,\n-                                             \"malformed feature, expected just one word\");\n-                                   continue\n-                               };\n+                    let name = if let Some(word) = mi.word() {\n+                        word.name()\n+                    } else {\n+                        span_err!(span_handler, mi.span, E0556,\n+                                  \"malformed feature, expected just one word\");\n+                        continue\n+                    };\n+\n                     if let Some(&(_, _, _, setter)) = ACTIVE_FEATURES.iter()\n                         .find(|& &(n, _, _, _)| name == n) {\n                         *(setter(&mut features)) = true;"}, {"sha": "7500bfe9caa8035af34db43799ce035458d9ead7", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -47,6 +47,10 @@ pub trait Folder : Sized {\n         noop_fold_meta_items(meta_items, self)\n     }\n \n+    fn fold_meta_list_item(&mut self, list_item: NestedMetaItem) -> NestedMetaItem {\n+        noop_fold_meta_list_item(list_item, self)\n+    }\n+\n     fn fold_meta_item(&mut self, meta_item: P<MetaItem>) -> P<MetaItem> {\n         noop_fold_meta_item(meta_item, self)\n     }\n@@ -307,18 +311,10 @@ pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<\n                 ViewPathList(fld.fold_path(path),\n                              path_list_idents.move_map(|path_list_ident| {\n                                 Spanned {\n-                                    node: match path_list_ident.node {\n-                                        PathListItemKind::Ident { id, name, rename } =>\n-                                            PathListItemKind::Ident {\n-                                                id: fld.new_id(id),\n-                                                rename: rename,\n-                                                name: name\n-                                            },\n-                                        PathListItemKind::Mod { id, rename } =>\n-                                            PathListItemKind::Mod {\n-                                                id: fld.new_id(id),\n-                                                rename: rename\n-                                            }\n+                                    node: PathListItem_ {\n+                                        id: fld.new_id(path_list_ident.node.id),\n+                                        rename: path_list_ident.node.rename,\n+                                        name: path_list_ident.node.name,\n                                     },\n                                     span: fld.new_span(path_list_ident.span)\n                                 }\n@@ -513,12 +509,25 @@ pub fn noop_fold_mac<T: Folder>(Spanned {node, span}: Mac, fld: &mut T) -> Mac {\n     }\n }\n \n+pub fn noop_fold_meta_list_item<T: Folder>(li: NestedMetaItem, fld: &mut T)\n+    -> NestedMetaItem {\n+    Spanned {\n+        node: match li.node {\n+            NestedMetaItemKind::MetaItem(mi) =>  {\n+                NestedMetaItemKind::MetaItem(fld.fold_meta_item(mi))\n+            },\n+            NestedMetaItemKind::Literal(lit) => NestedMetaItemKind::Literal(lit)\n+        },\n+        span: fld.new_span(li.span)\n+    }\n+}\n+\n pub fn noop_fold_meta_item<T: Folder>(mi: P<MetaItem>, fld: &mut T) -> P<MetaItem> {\n     mi.map(|Spanned {node, span}| Spanned {\n         node: match node {\n             MetaItemKind::Word(id) => MetaItemKind::Word(id),\n             MetaItemKind::List(id, mis) => {\n-                MetaItemKind::List(id, mis.move_map(|e| fld.fold_meta_item(e)))\n+                MetaItemKind::List(id, mis.move_map(|e| fld.fold_meta_list_item(e)))\n             }\n             MetaItemKind::NameValue(id, s) => MetaItemKind::NameValue(id, s)\n         },\n@@ -698,12 +707,13 @@ pub fn noop_fold_opt_lifetime<T: Folder>(o_lt: Option<Lifetime>, fld: &mut T)\n     o_lt.map(|lt| fld.fold_lifetime(lt))\n }\n \n-pub fn noop_fold_generics<T: Folder>(Generics {ty_params, lifetimes, where_clause}: Generics,\n+pub fn noop_fold_generics<T: Folder>(Generics {ty_params, lifetimes, where_clause, span}: Generics,\n                                      fld: &mut T) -> Generics {\n     Generics {\n         ty_params: fld.fold_ty_params(ty_params),\n         lifetimes: fld.fold_lifetime_defs(lifetimes),\n         where_clause: fld.fold_where_clause(where_clause),\n+        span: fld.new_span(span),\n     }\n }\n \n@@ -875,6 +885,10 @@ pub fn noop_fold_item_kind<T: Folder>(i: ItemKind, folder: &mut T) -> ItemKind {\n             let struct_def = folder.fold_variant_data(struct_def);\n             ItemKind::Struct(struct_def, folder.fold_generics(generics))\n         }\n+        ItemKind::Union(struct_def, generics) => {\n+            let struct_def = folder.fold_variant_data(struct_def);\n+            ItemKind::Union(struct_def, folder.fold_generics(generics))\n+        }\n         ItemKind::DefaultImpl(unsafety, ref trait_ref) => {\n             ItemKind::DefaultImpl(unsafety, folder.fold_trait_ref((*trait_ref).clone()))\n         }"}, {"sha": "27dd055cd3ae7431ce46e5651c26cf9e98e24d04", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 48, "deletions": 16, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -193,9 +193,26 @@ impl<'a> Parser<'a> {\n         Ok(attrs)\n     }\n \n-    /// matches meta_item = IDENT\n-    /// | IDENT = lit\n-    /// | IDENT meta_seq\n+    fn parse_unsuffixed_lit(&mut self) -> PResult<'a, ast::Lit> {\n+        let lit = self.parse_lit()?;\n+        debug!(\"Checking if {:?} is unusuffixed.\", lit);\n+\n+        if !lit.node.is_unsuffixed() {\n+            let msg = \"suffixed literals are not allowed in attributes\";\n+            self.diagnostic().struct_span_err(lit.span, msg)\n+                             .help(\"instead of using a suffixed literal \\\n+                                    (1u8, 1.0f32, etc.), use an unsuffixed version \\\n+                                    (1, 1.0, etc.).\")\n+                             .emit()\n+        }\n+\n+        Ok(lit)\n+    }\n+\n+    /// Per RFC#1559, matches the following grammar:\n+    ///\n+    /// meta_item : IDENT ( '=' UNSUFFIXED_LIT | '(' meta_item_inner? ')' )? ;\n+    /// meta_item_inner : (meta_item | UNSUFFIXED_LIT) (',' meta_item_inner)? ;\n     pub fn parse_meta_item(&mut self) -> PResult<'a, P<ast::MetaItem>> {\n         let nt_meta = match self.token {\n             token::Interpolated(token::NtMeta(ref e)) => Some(e.clone()),\n@@ -213,16 +230,7 @@ impl<'a> Parser<'a> {\n         match self.token {\n             token::Eq => {\n                 self.bump();\n-                let lit = self.parse_lit()?;\n-                // FIXME #623 Non-string meta items are not serialized correctly;\n-                // just forbid them for now\n-                match lit.node {\n-                    ast::LitKind::Str(..) => {}\n-                    _ => {\n-                        self.span_err(lit.span,\n-                                      \"non-string literals are not allowed in meta-items\");\n-                    }\n-                }\n+                let lit = self.parse_unsuffixed_lit()?;\n                 let hi = self.span.hi;\n                 Ok(P(spanned(lo, hi, ast::MetaItemKind::NameValue(name, lit))))\n             }\n@@ -238,11 +246,35 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// matches meta_seq = ( COMMASEP(meta_item) )\n-    fn parse_meta_seq(&mut self) -> PResult<'a, Vec<P<ast::MetaItem>>> {\n+    /// matches meta_item_inner : (meta_item | UNSUFFIXED_LIT) ;\n+    fn parse_meta_item_inner(&mut self) -> PResult<'a, ast::NestedMetaItem> {\n+        let sp = self.span;\n+        let lo = self.span.lo;\n+\n+        match self.parse_unsuffixed_lit() {\n+            Ok(lit) => {\n+                return Ok(spanned(lo, self.span.hi, ast::NestedMetaItemKind::Literal(lit)))\n+            }\n+            Err(ref mut err) => self.diagnostic().cancel(err)\n+        }\n+\n+        match self.parse_meta_item() {\n+            Ok(mi) => {\n+                return Ok(spanned(lo, self.span.hi, ast::NestedMetaItemKind::MetaItem(mi)))\n+            }\n+            Err(ref mut err) => self.diagnostic().cancel(err)\n+        }\n+\n+        let found = self.this_token_to_string();\n+        let msg = format!(\"expected unsuffixed literal or identifier, found {}\", found);\n+        Err(self.diagnostic().struct_span_err(sp, &msg))\n+    }\n+\n+    /// matches meta_seq = ( COMMASEP(meta_item_inner) )\n+    fn parse_meta_seq(&mut self) -> PResult<'a, Vec<ast::NestedMetaItem>> {\n         self.parse_unspanned_seq(&token::OpenDelim(token::Paren),\n                                  &token::CloseDelim(token::Paren),\n                                  SeqSep::trailing_allowed(token::Comma),\n-                                 |p: &mut Parser<'a>| p.parse_meta_item())\n+                                 |p: &mut Parser<'a>| p.parse_meta_item_inner())\n     }\n }"}, {"sha": "af95e44a567bab9245e182d726026e9f55ecd280", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -674,11 +674,11 @@ pub fn integer_lit(s: &str,\n mod tests {\n     use super::*;\n     use std::rc::Rc;\n-    use syntax_pos::{Span, BytePos, Pos, NO_EXPANSION};\n+    use syntax_pos::{self, Span, BytePos, Pos, NO_EXPANSION};\n     use codemap::Spanned;\n     use ast::{self, PatKind};\n     use abi::Abi;\n-    use attr::{first_attr_value_str_by_name, AttrMetaMethods};\n+    use attr::first_attr_value_str_by_name;\n     use parse;\n     use parse::parser::Parser;\n     use parse::token::{str_to_ident};\n@@ -937,15 +937,19 @@ mod tests {\n                                 variadic: false\n                             }),\n                                     ast::Unsafety::Normal,\n-                                    ast::Constness::NotConst,\n+                                    Spanned {\n+                                        span: sp(0,2),\n+                                        node: ast::Constness::NotConst,\n+                                    },\n                                     Abi::Rust,\n                                     ast::Generics{ // no idea on either of these:\n                                         lifetimes: Vec::new(),\n                                         ty_params: P::new(),\n                                         where_clause: ast::WhereClause {\n                                             id: ast::DUMMY_NODE_ID,\n                                             predicates: Vec::new(),\n-                                        }\n+                                        },\n+                                        span: syntax_pos::DUMMY_SP,\n                                     },\n                                     P(ast::Block {\n                                         stmts: vec!(ast::Stmt {"}, {"sha": "92ec0fdb3de3160cfd90caa9686dffe109897f38", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 38, "deletions": 18, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -39,7 +39,7 @@ use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause};\n use ast::{BinOpKind, UnOp};\n use ast;\n-use codemap::{self, CodeMap, Spanned, spanned};\n+use codemap::{self, CodeMap, Spanned, spanned, respan};\n use syntax_pos::{self, Span, BytePos, mk_sp};\n use errors::{self, DiagnosticBuilder};\n use ext::tt::macro_parser;\n@@ -725,8 +725,8 @@ impl<'a> Parser<'a> {\n                 let gt_str = Parser::token_to_string(&token::Gt);\n                 let this_token_str = self.this_token_to_string();\n                 Err(self.fatal(&format!(\"expected `{}`, found `{}`\",\n-                                   gt_str,\n-                                   this_token_str)))\n+                                        gt_str,\n+                                        this_token_str)))\n             }\n         }\n     }\n@@ -4293,6 +4293,7 @@ impl<'a> Parser<'a> {\n     /// where   typaramseq = ( typaram ) | ( typaram , typaramseq )\n     pub fn parse_generics(&mut self) -> PResult<'a, ast::Generics> {\n         maybe_whole!(self, NtGenerics);\n+        let span_lo = self.span.lo;\n \n         if self.eat(&token::Lt) {\n             let lifetime_defs = self.parse_lifetime_defs()?;\n@@ -4315,7 +4316,8 @@ impl<'a> Parser<'a> {\n                 where_clause: WhereClause {\n                     id: ast::DUMMY_NODE_ID,\n                     predicates: Vec::new(),\n-                }\n+                },\n+                span: mk_sp(span_lo, self.last_span.hi),\n             })\n         } else {\n             Ok(ast::Generics::default())\n@@ -4768,7 +4770,7 @@ impl<'a> Parser<'a> {\n     /// Parse an item-position function declaration.\n     fn parse_item_fn(&mut self,\n                      unsafety: Unsafety,\n-                     constness: Constness,\n+                     constness: Spanned<Constness>,\n                      abi: abi::Abi)\n                      -> PResult<'a, ItemInfo> {\n         let (ident, mut generics) = self.parse_fn_header()?;\n@@ -4794,18 +4796,21 @@ impl<'a> Parser<'a> {\n     /// - `extern fn`\n     /// - etc\n     pub fn parse_fn_front_matter(&mut self)\n-                                 -> PResult<'a, (ast::Constness, ast::Unsafety, abi::Abi)> {\n+                                 -> PResult<'a, (Spanned<ast::Constness>,\n+                                                ast::Unsafety,\n+                                                abi::Abi)> {\n         let is_const_fn = self.eat_keyword(keywords::Const);\n+        let const_span = self.last_span;\n         let unsafety = self.parse_unsafety()?;\n         let (constness, unsafety, abi) = if is_const_fn {\n-            (Constness::Const, unsafety, Abi::Rust)\n+            (respan(const_span, Constness::Const), unsafety, Abi::Rust)\n         } else {\n             let abi = if self.eat_keyword(keywords::Extern) {\n                 self.parse_opt_abi()?.unwrap_or(Abi::C)\n             } else {\n                 Abi::Rust\n             };\n-            (Constness::NotConst, unsafety, abi)\n+            (respan(self.last_span, Constness::NotConst), unsafety, abi)\n         };\n         self.expect_keyword(keywords::Fn)?;\n         Ok((constness, unsafety, abi))\n@@ -5704,9 +5709,12 @@ impl<'a> Parser<'a> {\n \n             if self.eat_keyword(keywords::Fn) {\n                 // EXTERN FUNCTION ITEM\n+                let fn_span = self.last_span;\n                 let abi = opt_abi.unwrap_or(Abi::C);\n                 let (ident, item_, extra_attrs) =\n-                    self.parse_item_fn(Unsafety::Normal, Constness::NotConst, abi)?;\n+                    self.parse_item_fn(Unsafety::Normal,\n+                                       respan(fn_span, Constness::NotConst),\n+                                       abi)?;\n                 let last_span = self.last_span;\n                 let item = self.mk_item(lo,\n                                         last_span.hi,\n@@ -5740,6 +5748,7 @@ impl<'a> Parser<'a> {\n             return Ok(Some(item));\n         }\n         if self.eat_keyword(keywords::Const) {\n+            let const_span = self.last_span;\n             if self.check_keyword(keywords::Fn)\n                 || (self.check_keyword(keywords::Unsafe)\n                     && self.look_ahead(1, |t| t.is_keyword(keywords::Fn))) {\n@@ -5751,7 +5760,9 @@ impl<'a> Parser<'a> {\n                 };\n                 self.bump();\n                 let (ident, item_, extra_attrs) =\n-                    self.parse_item_fn(unsafety, Constness::Const, Abi::Rust)?;\n+                    self.parse_item_fn(unsafety,\n+                                       respan(const_span, Constness::Const),\n+                                       Abi::Rust)?;\n                 let last_span = self.last_span;\n                 let item = self.mk_item(lo,\n                                         last_span.hi,\n@@ -5815,8 +5826,11 @@ impl<'a> Parser<'a> {\n         if self.check_keyword(keywords::Fn) {\n             // FUNCTION ITEM\n             self.bump();\n+            let fn_span = self.last_span;\n             let (ident, item_, extra_attrs) =\n-                self.parse_item_fn(Unsafety::Normal, Constness::NotConst, Abi::Rust)?;\n+                self.parse_item_fn(Unsafety::Normal,\n+                                   respan(fn_span, Constness::NotConst),\n+                                   Abi::Rust)?;\n             let last_span = self.last_span;\n             let item = self.mk_item(lo,\n                                     last_span.hi,\n@@ -5836,8 +5850,11 @@ impl<'a> Parser<'a> {\n                 Abi::Rust\n             };\n             self.expect_keyword(keywords::Fn)?;\n+            let fn_span = self.last_span;\n             let (ident, item_, extra_attrs) =\n-                self.parse_item_fn(Unsafety::Unsafe, Constness::NotConst, abi)?;\n+                self.parse_item_fn(Unsafety::Unsafe,\n+                                   respan(fn_span, Constness::NotConst),\n+                                   abi)?;\n             let last_span = self.last_span;\n             let item = self.mk_item(lo,\n                                     last_span.hi,\n@@ -6038,13 +6055,16 @@ impl<'a> Parser<'a> {\n                                  &token::CloseDelim(token::Brace),\n                                  SeqSep::trailing_allowed(token::Comma), |this| {\n             let lo = this.span.lo;\n-            let node = if this.eat_keyword(keywords::SelfValue) {\n-                let rename = this.parse_rename()?;\n-                ast::PathListItemKind::Mod { id: ast::DUMMY_NODE_ID, rename: rename }\n+            let ident = if this.eat_keyword(keywords::SelfValue) {\n+                keywords::SelfValue.ident()\n             } else {\n-                let ident = this.parse_ident()?;\n-                let rename = this.parse_rename()?;\n-                ast::PathListItemKind::Ident { name: ident, rename: rename, id: ast::DUMMY_NODE_ID }\n+                this.parse_ident()?\n+            };\n+            let rename = this.parse_rename()?;\n+            let node = ast::PathListItem_ {\n+                name: ident,\n+                rename: rename,\n+                id: ast::DUMMY_NODE_ID\n             };\n             let hi = this.last_span.hi;\n             Ok(spanned(lo, hi, node))"}, {"sha": "8563d27908db61428405892616fa437fc5948e77", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -16,7 +16,6 @@ use ast::{SelfKind, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast::Attribute;\n use util::parser::AssocOp;\n use attr;\n-use attr::{AttrMetaMethods, AttributeMethods};\n use codemap::{self, CodeMap};\n use syntax_pos::{self, BytePos};\n use errors;\n@@ -120,7 +119,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n         // of the feature gate, so we fake them up here.\n \n         // #![feature(prelude_import)]\n-        let prelude_import_meta = attr::mk_word_item(InternedString::new(\"prelude_import\"));\n+        let prelude_import_meta = attr::mk_list_word_item(InternedString::new(\"prelude_import\"));\n         let list = attr::mk_list_item(InternedString::new(\"feature\"),\n                                       vec![prelude_import_meta]);\n         let fake_attr = attr::mk_attr_inner(attr::mk_attr_id(), list);\n@@ -406,6 +405,10 @@ pub fn block_to_string(blk: &ast::Block) -> String {\n     })\n }\n \n+pub fn meta_list_item_to_string(li: &ast::NestedMetaItem) -> String {\n+    to_string(|s| s.print_meta_list_item(li))\n+}\n+\n pub fn meta_item_to_string(mi: &ast::MetaItem) -> String {\n     to_string(|s| s.print_meta_item(mi))\n }\n@@ -764,6 +767,17 @@ pub trait PrintState<'a> {\n         }\n     }\n \n+    fn print_meta_list_item(&mut self, item: &ast::NestedMetaItem) -> io::Result<()> {\n+        match item.node {\n+            ast::NestedMetaItemKind::MetaItem(ref mi) => {\n+                self.print_meta_item(mi)\n+            },\n+            ast::NestedMetaItemKind::Literal(ref lit) => {\n+                self.print_literal(lit)\n+            }\n+        }\n+    }\n+\n     fn print_meta_item(&mut self, item: &ast::MetaItem) -> io::Result<()> {\n         try!(self.ibox(INDENT_UNIT));\n         match item.node {\n@@ -780,7 +794,7 @@ pub trait PrintState<'a> {\n                 try!(self.popen());\n                 try!(self.commasep(Consistent,\n                               &items[..],\n-                              |s, i| s.print_meta_item(&i)));\n+                              |s, i| s.print_meta_list_item(&i)));\n                 try!(self.pclose());\n             }\n         }\n@@ -1001,6 +1015,7 @@ impl<'a> State<'a> {\n                         id: ast::DUMMY_NODE_ID,\n                         predicates: Vec::new(),\n                     },\n+                    span: syntax_pos::DUMMY_SP,\n                 };\n                 try!(self.print_ty_fn(f.abi,\n                                  f.unsafety,\n@@ -1184,7 +1199,7 @@ impl<'a> State<'a> {\n                 try!(self.print_fn(\n                     decl,\n                     unsafety,\n-                    constness,\n+                    constness.node,\n                     abi,\n                     Some(item.ident),\n                     typarams,\n@@ -1236,7 +1251,10 @@ impl<'a> State<'a> {\n                 try!(self.head(&visibility_qualified(&item.vis, \"struct\")));\n                 try!(self.print_struct(&struct_def, generics, item.ident, item.span, true));\n             }\n-\n+            ast::ItemKind::Union(ref struct_def, ref generics) => {\n+                try!(self.head(&visibility_qualified(&item.vis, \"union\")));\n+                try!(self.print_struct(&struct_def, generics, item.ident, item.span, true));\n+            }\n             ast::ItemKind::DefaultImpl(unsafety, ref trait_ref) => {\n                 try!(self.head(\"\"));\n                 try!(self.print_visibility(&item.vis));\n@@ -1518,7 +1536,7 @@ impl<'a> State<'a> {\n                             -> io::Result<()> {\n         self.print_fn(&m.decl,\n                       m.unsafety,\n-                      m.constness,\n+                      m.constness.node,\n                       m.abi,\n                       Some(ident),\n                       &m.generics,\n@@ -2878,26 +2896,13 @@ impl<'a> State<'a> {\n                     try!(word(&mut self.s, \"::{\"));\n                 }\n                 try!(self.commasep(Inconsistent, &idents[..], |s, w| {\n-                    match w.node {\n-                        ast::PathListItemKind::Ident { name, rename, .. } => {\n-                            try!(s.print_ident(name));\n-                            if let Some(ident) = rename {\n-                                try!(space(&mut s.s));\n-                                try!(s.word_space(\"as\"));\n-                                try!(s.print_ident(ident));\n-                            }\n-                            Ok(())\n-                        },\n-                        ast::PathListItemKind::Mod { rename, .. } => {\n-                            try!(word(&mut s.s, \"self\"));\n-                            if let Some(ident) = rename {\n-                                try!(space(&mut s.s));\n-                                try!(s.word_space(\"as\"));\n-                                try!(s.print_ident(ident));\n-                            }\n-                            Ok(())\n-                        }\n+                    try!(s.print_ident(w.node.name));\n+                    if let Some(ident) = w.node.rename {\n+                        try!(space(&mut s.s));\n+                        try!(s.word_space(\"as\"));\n+                        try!(s.print_ident(ident));\n                     }\n+                    Ok(())\n                 }));\n                 word(&mut self.s, \"}\")\n             }\n@@ -2982,6 +2987,7 @@ impl<'a> State<'a> {\n                 id: ast::DUMMY_NODE_ID,\n                 predicates: Vec::new(),\n             },\n+            span: syntax_pos::DUMMY_SP,\n         };\n         try!(self.print_fn(decl,\n                       unsafety,"}, {"sha": "6155ad729a2893d5ebcf976411947bda8741ccbc", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -19,12 +19,11 @@ use std::iter;\n use std::slice;\n use std::mem;\n use std::vec;\n-use attr::AttrMetaMethods;\n use attr;\n use syntax_pos::{self, DUMMY_SP, NO_EXPANSION, Span, FileMap, BytePos};\n use std::rc::Rc;\n \n-use codemap::{self, CodeMap, ExpnInfo, NameAndSpan, MacroAttribute};\n+use codemap::{self, CodeMap, ExpnInfo, NameAndSpan, MacroAttribute, dummy_spanned};\n use errors;\n use errors::snippet::{SnippetData};\n use config;\n@@ -210,9 +209,8 @@ impl fold::Folder for EntryPointCleaner {\n                 folded.map(|ast::Item {id, ident, attrs, node, vis, span}| {\n                     let allow_str = InternedString::new(\"allow\");\n                     let dead_code_str = InternedString::new(\"dead_code\");\n-                    let allow_dead_code_item =\n-                        attr::mk_list_item(allow_str,\n-                                           vec![attr::mk_word_item(dead_code_str)]);\n+                    let word_vec = vec![attr::mk_list_word_item(dead_code_str)];\n+                    let allow_dead_code_item = attr::mk_list_item(allow_str, word_vec);\n                     let allow_dead_code = attr::mk_attr_outer(attr::mk_attr_id(),\n                                                               allow_dead_code_item);\n \n@@ -413,6 +411,7 @@ fn should_panic(i: &ast::Item) -> ShouldPanic {\n         Some(attr) => {\n             let msg = attr.meta_item_list()\n                 .and_then(|list| list.iter().find(|mi| mi.check_name(\"expected\")))\n+                .and_then(|li| li.meta_item())\n                 .and_then(|mi| mi.value_str());\n             ShouldPanic::Yes(msg)\n         }\n@@ -485,7 +484,7 @@ fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n     let main_body = ecx.block(sp, vec![call_test_main]);\n     let main = ast::ItemKind::Fn(ecx.fn_decl(vec![], main_ret_ty),\n                            ast::Unsafety::Normal,\n-                           ast::Constness::NotConst,\n+                           dummy_spanned(ast::Constness::NotConst),\n                            ::abi::Abi::Rust, ast::Generics::default(), main_body);\n     let main = P(ast::Item {\n         ident: token::str_to_ident(\"main\"),"}, {"sha": "efd9b027504f0a5fa0acf8ae4079f31c210b4e60", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -31,7 +31,7 @@ use codemap::Spanned;\n #[derive(Copy, Clone, PartialEq, Eq)]\n pub enum FnKind<'a> {\n     /// fn foo() or extern \"Abi\" fn foo()\n-    ItemFn(Ident, &'a Generics, Unsafety, Constness, Abi, &'a Visibility),\n+    ItemFn(Ident, &'a Generics, Unsafety, Spanned<Constness>, Abi, &'a Visibility),\n \n     /// fn foo(&self)\n     Method(Ident, &'a MethodSig, Option<&'a Visibility>),\n@@ -278,7 +278,8 @@ pub fn walk_item<V: Visitor>(visitor: &mut V, item: &Item) {\n             visitor.visit_ty(typ);\n             walk_list!(visitor, visit_impl_item, impl_items);\n         }\n-        ItemKind::Struct(ref struct_definition, ref generics) => {\n+        ItemKind::Struct(ref struct_definition, ref generics) |\n+        ItemKind::Union(ref struct_definition, ref generics) => {\n             visitor.visit_generics(generics);\n             visitor.visit_variant_data(struct_definition, item.ident,\n                                      generics, item.id, item.span);\n@@ -367,8 +368,8 @@ pub fn walk_path<V: Visitor>(visitor: &mut V, path: &Path) {\n }\n \n pub fn walk_path_list_item<V: Visitor>(visitor: &mut V, _prefix: &Path, item: &PathListItem) {\n-    walk_opt_ident(visitor, item.span, item.node.name());\n-    walk_opt_ident(visitor, item.span, item.node.rename());\n+    visitor.visit_ident(item.span, item.node.name);\n+    walk_opt_ident(visitor, item.span, item.node.rename);\n }\n \n pub fn walk_path_segment<V: Visitor>(visitor: &mut V, path_span: Span, segment: &PathSegment) {"}, {"sha": "efb2fe5eb3b0feb5b627c1ac991f02979e03b116", "filename": "src/libsyntax_ext/deriving/bounds.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax_ext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax_ext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fbounds.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -40,6 +40,7 @@ pub fn expand_deriving_copy(cx: &mut ExtCtxt,\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n+        supports_unions: true,\n         methods: Vec::new(),\n         associated_types: Vec::new(),\n     };"}, {"sha": "f1a3a1f41b14ee37cb4b7ed025700f99112ca1e1", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -80,6 +80,7 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n         additional_bounds: bounds,\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n+        supports_unions: false,\n         methods: vec![MethodDef {\n                           name: \"clone\",\n                           generics: LifetimeBounds::empty(),"}, {"sha": "425a47a991bc4dc552eb5f56f0fa579bd44050f8", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -40,7 +40,7 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n     }\n \n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n-    let hidden = cx.meta_word(span, InternedString::new(\"hidden\"));\n+    let hidden = cx.meta_list_item_word(span, InternedString::new(\"hidden\"));\n     let doc = cx.meta_list(span, InternedString::new(\"doc\"), vec![hidden]);\n     let attrs = vec![cx.attribute(span, inline), cx.attribute(span, doc)];\n     let trait_def = TraitDef {\n@@ -50,6 +50,7 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n+        supports_unions: false,\n         methods: vec![MethodDef {\n                           name: \"assert_receiver_is_total_eq\",\n                           generics: LifetimeBounds::empty(),"}, {"sha": "6b2e36e63b65708d5152098d517405b075de9cea", "filename": "src/libsyntax_ext/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -32,6 +32,7 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n+        supports_unions: false,\n         methods: vec![MethodDef {\n                           name: \"cmp\",\n                           generics: LifetimeBounds::empty(),\n@@ -104,7 +105,7 @@ pub fn cs_cmp(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n         };\n \n         let eq_arm = cx.arm(span,\n-                            vec![cx.pat_enum(span, equals_path.clone(), vec![])],\n+                            vec![cx.pat_path(span, equals_path.clone())],\n                             old);\n         let neq_arm = cx.arm(span,\n                              vec![cx.pat_ident(span, test_id)],"}, {"sha": "64b8829dad7b1e5eb9f248a450c821580ee40a36", "filename": "src/libsyntax_ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -97,6 +97,7 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n+        supports_unions: false,\n         methods: methods,\n         associated_types: Vec::new(),\n     };"}, {"sha": "99d60c43c5457deec8b75c111a56a83acb0d5233", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -88,6 +88,7 @@ pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n         additional_bounds: vec![],\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n+        supports_unions: false,\n         methods: methods,\n         associated_types: Vec::new(),\n     };\n@@ -165,7 +166,7 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<\n         };\n \n         let eq_arm = cx.arm(span,\n-                            vec![cx.pat_some(span, cx.pat_enum(span, ordering.clone(), vec![]))],\n+                            vec![cx.pat_some(span, cx.pat_path(span, ordering.clone()))],\n                             old);\n         let neq_arm = cx.arm(span,\n                              vec![cx.pat_ident(span, test_id)],"}, {"sha": "b974699003b974b3dfec586fc4863b5a53b18518", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -35,6 +35,7 @@ pub fn expand_deriving_debug(cx: &mut ExtCtxt,\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n+        supports_unions: false,\n         methods: vec![MethodDef {\n                           name: \"fmt\",\n                           generics: LifetimeBounds::empty(),"}, {"sha": "22b9eb8e754453ea44d56f3669c8fbf1371e8c71", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -62,6 +62,7 @@ fn expand_deriving_decodable_imp(cx: &mut ExtCtxt,\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n+        supports_unions: false,\n         methods: vec![MethodDef {\n                           name: \"decode\",\n                           generics: LifetimeBounds {\n@@ -110,7 +111,7 @@ fn decodable_substructure(cx: &mut ExtCtxt,\n     return match *substr.fields {\n         StaticStruct(_, ref summary) => {\n             let nfields = match *summary {\n-                Unnamed(ref fields) => fields.len(),\n+                Unnamed(ref fields, _) => fields.len(),\n                 Named(ref fields) => fields.len(),\n             };\n             let read_struct_field = cx.ident_of(\"read_struct_field\");\n@@ -193,9 +194,9 @@ fn decode_static_fields<F>(cx: &mut ExtCtxt,\n     where F: FnMut(&mut ExtCtxt, Span, InternedString, usize) -> P<Expr>\n {\n     match *fields {\n-        Unnamed(ref fields) => {\n+        Unnamed(ref fields, is_tuple) => {\n             let path_expr = cx.expr_path(outer_pat_path);\n-            if fields.is_empty() {\n+            if !is_tuple {\n                 path_expr\n             } else {\n                 let fields = fields.iter()"}, {"sha": "b15fd2b49a65547c241ed463f0c5a55767754f71", "filename": "src/libsyntax_ext/deriving/default.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -32,6 +32,7 @@ pub fn expand_deriving_default(cx: &mut ExtCtxt,\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n+        supports_unions: false,\n         methods: vec![MethodDef {\n                           name: \"default\",\n                           generics: LifetimeBounds::empty(),\n@@ -57,8 +58,8 @@ fn default_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructur\n     return match *substr.fields {\n         StaticStruct(_, ref summary) => {\n             match *summary {\n-                Unnamed(ref fields) => {\n-                    if fields.is_empty() {\n+                Unnamed(ref fields, is_tuple) => {\n+                    if !is_tuple {\n                         cx.expr_ident(trait_span, substr.type_ident)\n                     } else {\n                         let exprs = fields.iter().map(|sp| default_call(*sp)).collect();"}, {"sha": "a4074184b6e81ce7275f1af8a5367b2787712f03", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -138,6 +138,7 @@ fn expand_deriving_encodable_imp(cx: &mut ExtCtxt,\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n+        supports_unions: false,\n         methods: vec!(\n             MethodDef {\n                 name: \"encode\","}, {"sha": "5c636d43a71421c7a7d188f5ddcf14e4c9b08757", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 38, "deletions": 28, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -194,10 +194,9 @@ use std::vec;\n use syntax::abi::Abi;\n use syntax::ast::{self, BinOpKind, EnumDef, Expr, Generics, Ident, PatKind, VariantData};\n use syntax::attr;\n-use syntax::attr::AttrMetaMethods;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::codemap::{self, respan};\n+use syntax::codemap::{self, dummy_spanned, respan};\n use syntax::util::move_map::MoveMap;\n use syntax::parse::token::{InternedString, keywords};\n use syntax::ptr::P;\n@@ -229,6 +228,9 @@ pub struct TraitDef<'a> {\n     /// Is it an `unsafe` trait?\n     pub is_unsafe: bool,\n \n+    /// Can this trait be derived for unions?\n+    pub supports_unions: bool,\n+\n     pub methods: Vec<MethodDef<'a>>,\n \n     pub associated_types: Vec<(ast::Ident, Ty<'a>)>,\n@@ -294,8 +296,8 @@ pub struct FieldInfo<'a> {\n \n /// Fields for a static method\n pub enum StaticFields {\n-    /// Tuple structs/enum variants like this.\n-    Unnamed(Vec<Span>),\n+    /// Tuple and unit structs/enum variants like this.\n+    Unnamed(Vec<Span>, bool /*is tuple*/),\n     /// Normal structs/struct variants.\n     Named(Vec<(Ident, Span)>),\n }\n@@ -488,7 +490,7 @@ impl<'a> TraitDef<'a> {\n             }\n         });\n \n-        let Generics { mut lifetimes, ty_params, mut where_clause } = self.generics\n+        let Generics { mut lifetimes, ty_params, mut where_clause, span } = self.generics\n             .to_generics(cx, self.span, type_ident, generics);\n         let mut ty_params = ty_params.into_vec();\n \n@@ -590,6 +592,7 @@ impl<'a> TraitDef<'a> {\n             lifetimes: lifetimes,\n             ty_params: P::from_vec(ty_params),\n             where_clause: where_clause,\n+            span: span,\n         };\n \n         // Create the reference to the trait.\n@@ -623,7 +626,7 @@ impl<'a> TraitDef<'a> {\n         let unused_qual = cx.attribute(self.span,\n                                        cx.meta_list(self.span,\n                                                     InternedString::new(\"allow\"),\n-                                                    vec![cx.meta_word(self.span,\n+                                                    vec![cx.meta_list_item_word(self.span,\n                                            InternedString::new(\"unused_qualifications\"))]));\n         let mut a = vec![attr, unused_qual];\n         a.extend(self.attributes.iter().cloned());\n@@ -901,7 +904,8 @@ impl<'a> MethodDef<'a> {\n                                                 generics: fn_generics,\n                                                 abi: abi,\n                                                 unsafety: unsafety,\n-                                                constness: ast::Constness::NotConst,\n+                                                constness:\n+                                                    dummy_spanned(ast::Constness::NotConst),\n                                                 decl: fn_decl,\n                                             },\n                                             body_block),\n@@ -1470,7 +1474,7 @@ impl<'a> TraitDef<'a> {\n             (_, false) => Named(named_idents),\n             // empty structs\n             _ if struct_def.is_struct() => Named(named_idents),\n-            _ => Unnamed(just_spans),\n+            _ => Unnamed(just_spans, struct_def.is_tuple()),\n         }\n     }\n \n@@ -1510,26 +1514,32 @@ impl<'a> TraitDef<'a> {\n         }\n \n         let subpats = self.create_subpatterns(cx, paths, mutbl);\n-        let pattern = if struct_def.is_struct() {\n-            let field_pats = subpats.into_iter()\n-                .zip(&ident_exprs)\n-                .map(|(pat, &(sp, ident, _, _))| {\n-                    if ident.is_none() {\n-                        cx.span_bug(sp, \"a braced struct with unnamed fields in `derive`\");\n-                    }\n-                    codemap::Spanned {\n-                        span: pat.span,\n-                        node: ast::FieldPat {\n-                            ident: ident.unwrap(),\n-                            pat: pat,\n-                            is_shorthand: false,\n-                        },\n-                    }\n-                })\n-                .collect();\n-            cx.pat_struct(self.span, struct_path, field_pats)\n-        } else {\n-            cx.pat_enum(self.span, struct_path, subpats)\n+        let pattern = match *struct_def {\n+            VariantData::Struct(..) => {\n+                let field_pats = subpats.into_iter()\n+                    .zip(&ident_exprs)\n+                    .map(|(pat, &(sp, ident, _, _))| {\n+                        if ident.is_none() {\n+                            cx.span_bug(sp, \"a braced struct with unnamed fields in `derive`\");\n+                        }\n+                        codemap::Spanned {\n+                            span: pat.span,\n+                            node: ast::FieldPat {\n+                                ident: ident.unwrap(),\n+                                pat: pat,\n+                                is_shorthand: false,\n+                            },\n+                        }\n+                    })\n+                    .collect();\n+                cx.pat_struct(self.span, struct_path, field_pats)\n+            }\n+            VariantData::Tuple(..) => {\n+                cx.pat_tuple_struct(self.span, struct_path, subpats)\n+            }\n+            VariantData::Unit(..) => {\n+                cx.pat_path(self.span, struct_path)\n+            }\n         };\n \n         (pattern, ident_exprs)"}, {"sha": "210878b7c9f0e09d3d62d1052cc967514bcece27", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -207,14 +207,16 @@ fn mk_ty_param(cx: &ExtCtxt,\n     cx.typaram(span, cx.ident_of(name), bounds, None)\n }\n \n-fn mk_generics(lifetimes: Vec<ast::LifetimeDef>, ty_params: Vec<ast::TyParam>) -> Generics {\n+fn mk_generics(lifetimes: Vec<ast::LifetimeDef>, ty_params: Vec<ast::TyParam>, span: Span)\n+               -> Generics {\n     Generics {\n         lifetimes: lifetimes,\n         ty_params: P::from_vec(ty_params),\n         where_clause: ast::WhereClause {\n             id: ast::DUMMY_NODE_ID,\n             predicates: Vec::new(),\n         },\n+        span: span,\n     }\n }\n \n@@ -257,7 +259,7 @@ impl<'a> LifetimeBounds<'a> {\n                 }\n             })\n             .collect();\n-        mk_generics(lifetimes, ty_params)\n+        mk_generics(lifetimes, ty_params, span)\n     }\n }\n "}, {"sha": "0941ebca868e3207e340ff03d6e6cb9ac7a80aa9", "filename": "src/libsyntax_ext/deriving/hash.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -36,6 +36,7 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n+        supports_unions: false,\n         methods: vec![MethodDef {\n                           name: \"hash\",\n                           generics: LifetimeBounds {"}, {"sha": "81085122e875bf47ce8799d51e6478ac171f93aa", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -11,7 +11,6 @@\n //! The compiler code necessary to implement the `#[derive]` extensions.\n \n use syntax::ast::{self, MetaItem};\n-use syntax::attr::AttrMetaMethods;\n use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxEnv};\n use syntax::ext::base::{MultiDecorator, MultiItemDecorator, MultiModifier};\n use syntax::ext::build::AstBuilder;\n@@ -98,8 +97,8 @@ fn expand_derive(cx: &mut ExtCtxt,\n             let mut eq_span = None;\n \n             for titem in traits.iter().rev() {\n-                let tname = if titem.is_word() {\n-                    titem.name()\n+                let tname = if let Some(word) = titem.word() {\n+                    word.name()\n                 } else {\n                     cx.span_err(titem.span, \"malformed `derive` entry\");\n                     continue;"}, {"sha": "5a3412b7ed9f9f496ff8a9bcff665a88d1914c31", "filename": "src/test/compile-fail-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -17,7 +17,7 @@ extern crate syntax_pos;\n extern crate rustc;\n extern crate rustc_plugin;\n \n-use syntax::ast::{self, Item, MetaItem, ImplItem, TraitItem, ItemKind};\n+use syntax::ast::{self, Item, MetaItem, ItemKind};\n use syntax::ext::base::*;\n use syntax::parse::{self, token};\n use syntax::ptr::P;\n@@ -62,8 +62,8 @@ fn expand_identity(cx: &mut ExtCtxt, _span: Span, tts: &[TokenTree])\n }\n \n fn expand_into_foo_multi(cx: &mut ExtCtxt,\n-                         sp: Span,\n-                         attr: &MetaItem,\n+                         _sp: Span,\n+                         _attr: &MetaItem,\n                          it: Annotatable) -> Annotatable {\n     match it {\n         Annotatable::Item(it) => {\n@@ -72,7 +72,7 @@ fn expand_into_foo_multi(cx: &mut ExtCtxt,\n                 ..(*quote_item!(cx, enum Foo2 { Bar2, Baz2 }).unwrap()).clone()\n             }))\n         }\n-        Annotatable::ImplItem(it) => {\n+        Annotatable::ImplItem(_) => {\n             quote_item!(cx, impl X { fn foo(&self) -> i32 { 42 } }).unwrap().and_then(|i| {\n                 match i.node {\n                     ItemKind::Impl(_, _, _, _, _, mut items) => {\n@@ -82,7 +82,7 @@ fn expand_into_foo_multi(cx: &mut ExtCtxt,\n                 }\n             })\n         }\n-        Annotatable::TraitItem(it) => {\n+        Annotatable::TraitItem(_) => {\n             quote_item!(cx, trait X { fn foo(&self) -> i32 { 0 } }).unwrap().and_then(|i| {\n                 match i.node {\n                     ItemKind::Trait(_, _, _, mut items) => {\n@@ -97,15 +97,15 @@ fn expand_into_foo_multi(cx: &mut ExtCtxt,\n \n // Create a duplicate of the annotatable, based on the MetaItem\n fn expand_duplicate(cx: &mut ExtCtxt,\n-                    sp: Span,\n+                    _sp: Span,\n                     mi: &MetaItem,\n                     it: &Annotatable,\n                     push: &mut FnMut(Annotatable))\n {\n     let copy_name = match mi.node {\n         ast::MetaItemKind::List(_, ref xs) => {\n-            if let ast::MetaItemKind::Word(ref w) = xs[0].node {\n-                token::str_to_ident(&w)\n+            if let Some(word) = xs[0].word() {\n+                token::str_to_ident(&word.name())\n             } else {\n                 cx.span_err(mi.span, \"Expected word\");\n                 return;"}, {"sha": "91ff6b85a42ce071efb3077f2e3a3bb46eb87ec7", "filename": "src/test/compile-fail/E0132.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Fcompile-fail%2FE0132.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Fcompile-fail%2FE0132.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0132.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -11,7 +11,7 @@\n #![feature(start)]\n \n #[start]\n-fn f<T>() {} //~ ERROR E0132\n+fn f< T >() {} //~ ERROR E0132\n              //~| NOTE start function cannot have type parameters\n \n fn main() {"}, {"sha": "d3e68c7c0daf8613f3c8cd95f184106d4f743654", "filename": "src/test/compile-fail/E0565-1.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Fcompile-fail%2FE0565-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Fcompile-fail%2FE0565-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0565-1.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(attr_literals)]\n+\n+// deprecated doesn't currently support literals\n+#[deprecated(\"since\")] //~ ERROR E0565\n+fn f() {  }\n+\n+fn main() {  }"}, {"sha": "b2d369223e7dac02cc76e6871dc5a9d2a999f2a7", "filename": "src/test/compile-fail/E0565.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Fcompile-fail%2FE0565.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Fcompile-fail%2FE0565.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0565.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(attr_literals)]\n+\n+// repr currently doesn't support literals\n+#[repr(\"C\")] //~ ERROR E0565\n+struct A {  }\n+\n+fn main() {  }"}, {"sha": "b54288035175d33c9a477d8279841fe374ad1c62", "filename": "src/test/compile-fail/attr-literals.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Fcompile-fail%2Fattr-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Fcompile-fail%2Fattr-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-literals.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that literals in attributes parse just fine.\n+\n+#![feature(rustc_attrs, attr_literals)]\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+\n+#[fake_attr] //~ ERROR attribute `fake_attr` is currently unknown\n+#[fake_attr(100)] //~ ERROR attribute `fake_attr` is currently unknown\n+#[fake_attr(1, 2, 3)] //~ ERROR attribute `fake_attr` is currently unknown\n+#[fake_attr(\"hello\")] //~ ERROR attribute `fake_attr` is currently unknown\n+#[fake_attr(name = \"hello\")] //~ ERROR attribute `fake_attr` is currently unknown\n+#[fake_attr(1, \"hi\", key = 12, true, false)] //~ ERROR attribute `fake_attr` is currently unknown\n+#[fake_attr(key = \"hello\", val = 10)] //~ ERROR attribute `fake_attr` is currently unknown\n+#[fake_attr(key(\"hello\"), val(10))] //~ ERROR attribute `fake_attr` is currently unknown\n+#[fake_attr(enabled = true, disabled = false)] //~ ERROR attribute `fake_attr` is currently unknown\n+#[fake_attr(true)] //~ ERROR attribute `fake_attr` is currently unknown\n+#[fake_attr(pi = 3.14159)] //~ ERROR attribute `fake_attr` is currently unknown\n+#[fake_attr(b\"hi\")] //~ ERROR attribute `fake_attr` is currently unknown\n+#[fake_doc(r\"doc\")] //~ ERROR attribute `fake_doc` is currently unknown\n+struct Q {  }\n+\n+#[rustc_error]\n+fn main() { }"}, {"sha": "7ea72e23779ec5f40871851c233fc0a401aff4c8", "filename": "src/test/compile-fail/const-fn-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Fcompile-fail%2Fconst-fn-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Fcompile-fail%2Fconst-fn-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-fn-mismatch.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -21,7 +21,7 @@ trait Foo {\n \n impl Foo for u32 {\n     const fn f() -> u32 { 22 }\n-    //~^ ERROR E0379\n+    //~^ ERROR trait fns cannot be declared const\n     //~| NOTE trait fns cannot be const\n }\n "}, {"sha": "257d4d5ee99210fbe514ba571378836f23fa51a4", "filename": "src/test/compile-fail/const-fn-not-in-trait.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Fcompile-fail%2Fconst-fn-not-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Fcompile-fail%2Fconst-fn-not-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-fn-not-in-trait.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -14,8 +14,12 @@\n #![feature(const_fn)]\n \n trait Foo {\n-    const fn f() -> u32; //~ ERROR trait fns cannot be declared const\n-    const fn g() -> u32 { 0 } //~ ERROR trait fns cannot be declared const\n+    const fn f() -> u32;\n+    //~^ ERROR trait fns cannot be declared const\n+    //~| NOTE trait fns cannot be const\n+    const fn g() -> u32 { 0 }\n+    //~^ ERROR trait fns cannot be declared const\n+    //~| NOTE trait fns cannot be const\n }\n \n fn main() { }"}, {"sha": "f3132d5593e621d57048b95c70c3473aa96c7a99", "filename": "src/test/compile-fail/gated-attr-literals.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Fcompile-fail%2Fgated-attr-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Fcompile-fail%2Fgated-attr-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgated-attr-literals.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that literals in attributes don't parse without the feature gate.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+\n+#[fake_attr] //~ ERROR attribute `fake_attr` is currently unknown\n+#[fake_attr(100)] //~ ERROR attribute `fake_attr` is currently unknown\n+    //~^ ERROR non-string literals in attributes\n+#[fake_attr(1, 2, 3)] //~ ERROR attribute `fake_attr` is currently unknown\n+    //~^ ERROR non-string literals in attributes\n+#[fake_attr(\"hello\")] //~ ERROR attribute `fake_attr` is currently unknown\n+    //~^ ERROR string literals in top-level positions, are experimental\n+#[fake_attr(name = \"hello\")] //~ ERROR attribute `fake_attr` is currently unknown\n+#[fake_attr(1, \"hi\", key = 12, true, false)] //~ ERROR attribute `fake_attr` is currently unknown\n+    //~^ ERROR non-string literals in attributes, or string literals in top-level positions\n+#[fake_attr(key = \"hello\", val = 10)] //~ ERROR attribute `fake_attr` is currently unknown\n+    //~^ ERROR non-string literals in attributes\n+#[fake_attr(key(\"hello\"), val(10))] //~ ERROR attribute `fake_attr` is currently unknown\n+    //~^ ERROR non-string literals in attributes, or string literals in top-level positions\n+#[fake_attr(enabled = true, disabled = false)] //~ ERROR attribute `fake_attr` is currently unknown\n+    //~^ ERROR non-string literals in attributes\n+#[fake_attr(true)] //~ ERROR attribute `fake_attr` is currently unknown\n+    //~^ ERROR non-string literals in attributes\n+#[fake_attr(pi = 3.14159)] //~ ERROR attribute `fake_attr` is currently unknown\n+    //~^ ERROR non-string literals in attributes\n+#[fake_attr(b\"hi\")] //~ ERROR attribute `fake_attr` is currently unknown\n+    //~^ ERROR string literals in top-level positions, are experimental\n+#[fake_doc(r\"doc\")] //~ ERROR attribute `fake_doc` is currently unknown\n+    //~^ ERROR string literals in top-level positions, are experimental\n+struct Q {  }\n+\n+#[rustc_error]\n+fn main() { }"}, {"sha": "0e2840c69d3643eee7e58f2f646b59b1448a1e2f", "filename": "src/test/parse-fail/suffixed-literal-meta.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Fparse-fail%2Fsuffixed-literal-meta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Fparse-fail%2Fsuffixed-literal-meta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fsuffixed-literal-meta.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+#[foo = 1usize] //~ ERROR: suffixed literals are not allowed in attributes\n+#[foo = 1u8] //~ ERROR: suffixed literals are not allowed in attributes\n+#[foo = 1u16] //~ ERROR: suffixed literals are not allowed in attributes\n+#[foo = 1u32] //~ ERROR: suffixed literals are not allowed in attributes\n+#[foo = 1u64] //~ ERROR: suffixed literals are not allowed in attributes\n+#[foo = 1isize] //~ ERROR: suffixed literals are not allowed in attributes\n+#[foo = 1i8] //~ ERROR: suffixed literals are not allowed in attributes\n+#[foo = 1i16] //~ ERROR: suffixed literals are not allowed in attributes\n+#[foo = 1i32] //~ ERROR: suffixed literals are not allowed in attributes\n+#[foo = 1i64] //~ ERROR: suffixed literals are not allowed in attributes\n+#[foo = 1.0f32] //~ ERROR: suffixed literals are not allowed in attributes\n+#[foo = 1.0f64] //~ ERROR: suffixed literals are not allowed in attributes\n+fn main() { }"}, {"sha": "ba8c580cb0a01d1f5753ad737663b3aafb49ad72", "filename": "src/test/pretty/attr-literals.rs", "status": "renamed", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Fpretty%2Fattr-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Fpretty%2Fattr-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fattr-literals.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -8,10 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n+// pp-exact\n+// Tests literals in attributes.\n \n-// Issue #623 - non-string meta items are not serialized correctly;\n-// for now just forbid them\n+#![feature(custom_attribute, attr_literals)]\n \n-#[foo = 1] //~ ERROR: non-string literals are not allowed in meta-items\n-fn main() { }\n+fn main() {\n+    #![hello(\"hi\", 1, 2, 1.012, pi = 3.14, bye, name(\"John\"))]\n+    #[align = 8]\n+    fn f() { }\n+\n+    #[vec(1, 2, 3)]\n+    fn g() { }\n+}", "previous_filename": "src/test/parse-fail/non-str-meta.rs"}, {"sha": "6b688b006bd4a675c8478cb5c64b3bcc0be103f2", "filename": "src/test/run-pass-fulldeps/auxiliary/custom_derive_plugin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -24,7 +24,6 @@ use syntax::ast;\n use syntax::ext::base::{MultiDecorator, ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token;\n-use syntax::ptr::P;\n use syntax_ext::deriving::generic::{cs_fold, TraitDef, MethodDef, combine_substructure};\n use syntax_ext::deriving::generic::ty::{Literal, LifetimeBounds, Path, borrowed_explicit_self};\n use syntax_pos::Span;\n@@ -50,6 +49,7 @@ fn expand(cx: &mut ExtCtxt,\n         generics: LifetimeBounds::empty(),\n         associated_types: vec![],\n         is_unsafe: false,\n+        supports_unions: false,\n         methods: vec![\n             MethodDef {\n                 name: \"total_sum\","}, {"sha": "c6174745bfc0626574ab13d210fb39f0879190ed", "filename": "src/test/run-pass-fulldeps/auxiliary/custom_derive_plugin_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin_attr.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -21,12 +21,11 @@ extern crate rustc;\n extern crate rustc_plugin;\n \n use syntax::ast;\n-use syntax::attr::AttrMetaMethods;\n use syntax::ext::base::{MultiDecorator, ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token;\n use syntax::ptr::P;\n-use syntax_ext::deriving::generic::{cs_fold, TraitDef, MethodDef, combine_substructure};\n+use syntax_ext::deriving::generic::{TraitDef, MethodDef, combine_substructure};\n use syntax_ext::deriving::generic::{Substructure, Struct, EnumMatching};\n use syntax_ext::deriving::generic::ty::{Literal, LifetimeBounds, Path, borrowed_explicit_self};\n use syntax_pos::Span;\n@@ -52,6 +51,7 @@ fn expand(cx: &mut ExtCtxt,\n         generics: LifetimeBounds::empty(),\n         associated_types: vec![],\n         is_unsafe: false,\n+        supports_unions: false,\n         methods: vec![\n             MethodDef {\n                 name: \"total_sum\","}, {"sha": "46fdf911258456e685643c9c2ec0ead5d2536986", "filename": "src/test/run-pass-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 85, "deletions": 17, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -17,8 +17,10 @@ extern crate rustc;\n extern crate rustc_plugin;\n extern crate syntax_pos;\n \n-use syntax::ast::{self, Item, MetaItem, ImplItem, TraitItem, ItemKind};\n+use syntax::ast::{self, Item, MetaItem, ItemKind};\n+use syntax::codemap::DUMMY_SP;\n use syntax::ext::base::*;\n+use syntax::ext::quote::rt::ToTokens;\n use syntax::parse::{self, token};\n use syntax::ptr::P;\n use syntax::tokenstream::TokenTree;\n@@ -41,30 +43,32 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         token::intern(\"duplicate\"),\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n         MultiDecorator(Box::new(expand_duplicate)));\n+    reg.register_syntax_extension(\n+        token::intern(\"caller\"),\n+        // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n+        MultiDecorator(Box::new(expand_caller)));\n }\n \n-fn expand_make_a_1(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree])\n-                   -> Box<MacResult+'static> {\n+fn expand_make_a_1(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree]) -> Box<MacResult + 'static> {\n     if !tts.is_empty() {\n         cx.span_fatal(sp, \"make_a_1 takes no arguments\");\n     }\n     MacEager::expr(quote_expr!(cx, 1))\n }\n \n // See Issue #15750\n-fn expand_identity(cx: &mut ExtCtxt, _span: Span, tts: &[TokenTree])\n-                   -> Box<MacResult+'static> {\n+fn expand_identity(cx: &mut ExtCtxt, _span: Span, tts: &[TokenTree]) -> Box<MacResult + 'static> {\n     // Parse an expression and emit it unchanged.\n-    let mut parser = parse::new_parser_from_tts(cx.parse_sess(),\n-        cx.cfg(), tts.to_vec());\n+    let mut parser = parse::new_parser_from_tts(cx.parse_sess(), cx.cfg(), tts.to_vec());\n     let expr = parser.parse_expr().unwrap();\n     MacEager::expr(quote_expr!(&mut *cx, $expr))\n }\n \n fn expand_into_foo_multi(cx: &mut ExtCtxt,\n-                         sp: Span,\n-                         attr: &MetaItem,\n-                         it: Annotatable) -> Vec<Annotatable> {\n+                         _sp: Span,\n+                         _attr: &MetaItem,\n+                         it: Annotatable)\n+                         -> Vec<Annotatable> {\n     match it {\n         Annotatable::Item(it) => vec![\n             Annotatable::Item(P(Item {\n@@ -74,7 +78,7 @@ fn expand_into_foo_multi(cx: &mut ExtCtxt,\n             Annotatable::Item(quote_item!(cx, enum Foo3 { Bar }).unwrap()),\n             Annotatable::Item(quote_item!(cx, #[cfg(any())] fn foo2() {}).unwrap()),\n         ],\n-        Annotatable::ImplItem(it) => vec![\n+        Annotatable::ImplItem(_it) => vec![\n             quote_item!(cx, impl X { fn foo(&self) -> i32 { 42 } }).unwrap().and_then(|i| {\n                 match i.node {\n                     ItemKind::Impl(_, _, _, _, _, mut items) => {\n@@ -84,7 +88,7 @@ fn expand_into_foo_multi(cx: &mut ExtCtxt,\n                 }\n             })\n         ],\n-        Annotatable::TraitItem(it) => vec![\n+        Annotatable::TraitItem(_it) => vec![\n             quote_item!(cx, trait X { fn foo(&self) -> i32 { 0 } }).unwrap().and_then(|i| {\n                 match i.node {\n                     ItemKind::Trait(_, _, _, mut items) => {\n@@ -99,15 +103,14 @@ fn expand_into_foo_multi(cx: &mut ExtCtxt,\n \n // Create a duplicate of the annotatable, based on the MetaItem\n fn expand_duplicate(cx: &mut ExtCtxt,\n-                    sp: Span,\n+                    _sp: Span,\n                     mi: &MetaItem,\n                     it: &Annotatable,\n-                    push: &mut FnMut(Annotatable))\n-{\n+                    push: &mut FnMut(Annotatable)) {\n     let copy_name = match mi.node {\n         ast::MetaItemKind::List(_, ref xs) => {\n-            if let ast::MetaItemKind::Word(ref w) = xs[0].node {\n-                token::str_to_ident(&w)\n+            if let Some(word) = xs[0].word() {\n+                token::str_to_ident(&word.name())\n             } else {\n                 cx.span_err(mi.span, \"Expected word\");\n                 return;\n@@ -142,4 +145,69 @@ fn expand_duplicate(cx: &mut ExtCtxt,\n     }\n }\n \n+pub fn token_separate<T: ToTokens>(ecx: &ExtCtxt, things: &[T],\n+                                   token: token::Token) -> Vec<TokenTree> {\n+    let mut output: Vec<TokenTree> = vec![];\n+    for (i, thing) in things.iter().enumerate() {\n+        output.extend(thing.to_tokens(ecx));\n+        if i < things.len() - 1 {\n+            output.push(TokenTree::Token(DUMMY_SP, token.clone()));\n+        }\n+    }\n+\n+    output\n+}\n+\n+fn expand_caller(cx: &mut ExtCtxt,\n+                 sp: Span,\n+                 mi: &MetaItem,\n+                 it: &Annotatable,\n+                 push: &mut FnMut(Annotatable)) {\n+    let (orig_fn_name, ret_type) = match *it {\n+        Annotatable::Item(ref item) => match item.node {\n+            ItemKind::Fn(ref decl, _, _, _, _, _) => {\n+                (item.ident, &decl.output)\n+            }\n+            _ => cx.span_fatal(item.span, \"Only functions with return types can be annotated.\")\n+        },\n+        _ => cx.span_fatal(sp, \"Only functions can be annotated.\")\n+    };\n+\n+    let (caller_name, arguments) = if let Some(list) = mi.meta_item_list() {\n+        if list.len() < 2 {\n+            cx.span_fatal(mi.span(), \"Need a function name and at least one parameter.\");\n+        }\n+\n+        let fn_name = match list[0].name() {\n+            Some(name) => token::str_to_ident(&name),\n+            None => cx.span_fatal(list[0].span(), \"First parameter must be an ident.\")\n+        };\n+\n+        (fn_name, &list[1..])\n+    } else {\n+        cx.span_fatal(mi.span, \"Expected list.\");\n+    };\n+\n+    let literals: Vec<ast::Lit> = arguments.iter().map(|arg| {\n+        if let Some(lit) = arg.literal() {\n+            lit.clone()\n+        } else {\n+            cx.span_fatal(arg.span(), \"Expected literal.\");\n+        }\n+    }).collect();\n+\n+    let arguments = token_separate(cx, literals.as_slice(), token::Comma);\n+    if let ast::FunctionRetTy::Ty(ref rt) = *ret_type {\n+        push(Annotatable::Item(quote_item!(cx,\n+                                           fn $caller_name() -> $rt {\n+                                               $orig_fn_name($arguments)\n+                                           }).unwrap()))\n+    } else {\n+        push(Annotatable::Item(quote_item!(cx,\n+                                           fn $caller_name() {\n+                                               $orig_fn_name($arguments)\n+                                           }).unwrap()))\n+    }\n+}\n+\n pub fn foo() {}"}, {"sha": "f21c914a76c9c7406bee608dda9d53a7f7a1b5ef", "filename": "src/test/run-pass-fulldeps/auxiliary/plugin_args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin_args.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -30,15 +30,15 @@ use syntax::tokenstream;\n use rustc_plugin::Registry;\n \n struct Expander {\n-    args: Vec<P<ast::MetaItem>>,\n+    args: Vec<ast::NestedMetaItem>,\n }\n \n impl TTMacroExpander for Expander {\n     fn expand<'cx>(&self,\n                    ecx: &'cx mut ExtCtxt,\n                    sp: Span,\n                    _: &[tokenstream::TokenTree]) -> Box<MacResult+'cx> {\n-        let args = self.args.iter().map(|i| pprust::meta_item_to_string(&*i))\n+        let args = self.args.iter().map(|i| pprust::meta_list_item_to_string(i))\n             .collect::<Vec<_>>().join(\", \");\n         let interned = token::intern_and_get_ident(&args[..]);\n         MacEager::expr(ecx.expr_str(sp, interned))"}, {"sha": "66ffff94333e9fe19ed869c3739e105f6852c96f", "filename": "src/test/run-pass-fulldeps/empty-struct-braces-derive.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Frun-pass-fulldeps%2Fempty-struct-braces-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Frun-pass-fulldeps%2Fempty-struct-braces-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fempty-struct-braces-derive.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// `#[derive(Trait)]` works for empty structs/variants with braces\n+// `#[derive(Trait)]` works for empty structs/variants with braces or parens.\n \n+#![feature(relaxed_adts)]\n #![feature(rustc_private)]\n \n extern crate serialize as rustc_serialize;\n@@ -18,11 +19,16 @@ extern crate serialize as rustc_serialize;\n          Default, Debug, RustcEncodable, RustcDecodable)]\n struct S {}\n \n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash,\n+         Default, Debug, RustcEncodable, RustcDecodable)]\n+struct Z();\n+\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash,\n          Debug, RustcEncodable, RustcDecodable)]\n enum E {\n     V {},\n     U,\n+    W(),\n }\n \n fn main() {\n@@ -34,11 +40,27 @@ fn main() {\n     assert!(!(s < s1));\n     assert_eq!(format!(\"{:?}\", s), \"S\");\n \n+    let z = Z();\n+    let z1 = z;\n+    let z2 = z.clone();\n+    assert_eq!(z, z1);\n+    assert_eq!(z, z2);\n+    assert!(!(z < z1));\n+    assert_eq!(format!(\"{:?}\", z), \"Z\");\n+\n     let e = E::V {};\n     let e1 = e;\n     let e2 = e.clone();\n     assert_eq!(e, e1);\n     assert_eq!(e, e2);\n     assert!(!(e < e1));\n     assert_eq!(format!(\"{:?}\", e), \"V\");\n+\n+    let e = E::W();\n+    let e1 = e;\n+    let e2 = e.clone();\n+    assert_eq!(e, e1);\n+    assert_eq!(e, e2);\n+    assert!(!(e < e1));\n+    assert_eq!(format!(\"{:?}\", e), \"W\");\n }"}, {"sha": "6dc651bb653a31d9aed137d89d39c69fb42d0ca4", "filename": "src/test/run-pass-fulldeps/macro-crate-multi-decorator-literals.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-multi-decorator-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-multi-decorator-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-multi-decorator-literals.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro_crate_test.rs\n+// ignore-stage1\n+\n+#![feature(plugin, custom_attribute, attr_literals)]\n+#![plugin(macro_crate_test)]\n+\n+#[macro_use]\n+#[no_link]\n+extern crate macro_crate_test;\n+\n+// The `caller(name, args...)` attribute emits a new nullary function named\n+// `name` that calls the annotated function with `args`. As an example, consider\n+// the following:\n+//\n+//     #[caller(simple, 1, \"hello\", 3.14)]\n+//     fn f(num: isize, string: &'static str, float: f32) -> (isize, &'static str, float) {\n+//         (num, string, float)\n+//     }\n+//\n+// This results in a function named `simple` that calls `f(1, \"hello\", 3.14)`.\n+// As a result, the expression `simple()` evaluates to `(1, \"helllo\", 3.14)`.\n+\n+#[caller(simple, 1, \"hello\", 3.14)]\n+#[caller(simple1, 2, \"bye\", 6.28)]\n+#[caller(simple2, 3, \"hi\", 1.01)]\n+fn f(num: isize, string: &'static str, float: f32) -> (isize, &'static str, f32) {\n+    (num, string, float)\n+}\n+\n+#[caller(complex, true, 10)]\n+#[caller(complex1, false, 15)]\n+#[caller(complex2, true, 20)]\n+fn g(emit: bool, num: i32) -> Option<i32> {\n+    match emit {\n+        true => Some(num),\n+        false => None\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(simple(), (1, \"hello\", 3.14));\n+    assert_eq!(simple1(), (2, \"bye\", 6.28));\n+    assert_eq!(simple2(), (3, \"hi\", 1.01));\n+\n+    assert_eq!(complex(), Some(10));\n+    assert_eq!(complex1(), None);\n+    assert_eq!(complex2(), Some(20));\n+}"}, {"sha": "5e44030eab71acad7f13b17652fc5b50c82adcbf", "filename": "src/test/ui/mismatched_types/const-fn-in-trait.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Fui%2Fmismatched_types%2Fconst-fn-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Fui%2Fmismatched_types%2Fconst-fn-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fconst-fn-in-trait.rs?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustc-env:RUST_NEW_ERROR_FORMAT\n+\n+#![feature(const_fn)]\n+\n+trait Foo {\n+    fn f() -> u32;\n+    const fn g();\n+}\n+\n+impl Foo for u32 {\n+    const fn f() -> u32 { 22 }\n+    fn g() {}\n+}\n+\n+fn main() { }"}, {"sha": "f7b7635e41aecfec70ad91f99b95fac6a0d944f2", "filename": "src/test/ui/mismatched_types/const-fn-in-trait.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Fui%2Fmismatched_types%2Fconst-fn-in-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/71ee82a8aa0c02fc2c73e84f40bdb55512d10938/src%2Ftest%2Fui%2Fmismatched_types%2Fconst-fn-in-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fconst-fn-in-trait.stderr?ref=71ee82a8aa0c02fc2c73e84f40bdb55512d10938", "patch": "@@ -0,0 +1,14 @@\n+error[E0379]: trait fns cannot be declared const\n+  --> $DIR/const-fn-in-trait.rs:17:5\n+   |\n+17 |     const fn g();\n+   |     ^^^^^ trait fns cannot be const\n+\n+error[E0379]: trait fns cannot be declared const\n+  --> $DIR/const-fn-in-trait.rs:21:5\n+   |\n+21 |     const fn f() -> u32 { 22 }\n+   |     ^^^^^ trait fns cannot be const\n+\n+error: aborting due to 2 previous errors\n+"}]}