{"sha": "d565c7488749fd0e998d6be21efeb20354e4696d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1NjVjNzQ4ODc0OWZkMGU5OThkNmJlMjFlZmViMjAzNTRlNDY5NmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-15T22:27:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-15T22:27:09Z"}, "message": "Auto merge of #81858 - ijackson:fork-no-unwind, r=m-ou-se\n\nDo not allocate or unwind after fork\n\n### Objective scenarios\n\n * Make (simple) panics safe in `Command::pre_exec_hook`, including most `panic!` calls, `Option::unwrap`, and array bounds check failures.\n * Make it possible to `libc::fork` and then safely panic in the child (needed for the above, but this requirement means exposing the new raw hook API which the `Command` implementation needs).\n * In singlethreaded programs, where panic in `pre_exec_hook` is already memory-safe, prevent the double-unwinding malfunction #79740.\n\nI think we want to make panic after fork safe even though the post-fork child environment is only experienced by users of `unsafe`, beause the subset of Rust in which any panic is UB is really far too hazardous and unnatural.\n\n#### Approach\n\n * Provide a way for a program to, at runtime, switch to having panics abort.  This makes it possible to panic without making *any* heap allocations, which is needed because on some platforms malloc is UB in a child forked from a multithreaded program (see https://github.com/rust-lang/rust/pull/80263#issuecomment-774272370, and maybe also the SuS [spec](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fork.html)).\n * Make that change in the child spawned by `Command`.\n * Document the rules comprehensively enough that a programmer has a fighting chance of writing correct code.\n * Test that this all works as expected (and in particular, that there aren't any heap allocations we missed)\n\nFixes #79740\n\n#### Rejected (or previously attempted) approaches\n\n * Change the panic machinery to be able to unwind without allocating, at least when the payload and message are both `'static`.  This seems like it would be even more subtle.  Also that is a potentially-hot path which I don't want to mess with.\n * Change the existing panic hook mechanism to not convert the message to a `String` before calling the hook.  This would be a surprising change for existing code and would not be detected by the type system.\n * Provide a `raw_panic_hook` function to intercept panics in a way that doesn't allocate.  (That was an earlier version of this MR.)\n\n### History\n\nThis MR could be considered a v2 of #80263.  Thanks to everyone who commented there.  In particular, thanks to `@m-ou-se,` `@Mark-Simulacrum` and `@hyd-dev.`  (Tagging you since I think you might be interested in this new MR.)  Compared to #80263, this MR has very substantial changes and additions.\n\nAdditionally, I have recently (2021-04-20) completely revised this series following very helpful comments from `@m-ou-se.`\n\nr? `@m-ou-se`", "tree": {"sha": "0737eae74f62313ce2a265bdf314ba1d8f9d8645", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0737eae74f62313ce2a265bdf314ba1d8f9d8645"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d565c7488749fd0e998d6be21efeb20354e4696d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d565c7488749fd0e998d6be21efeb20354e4696d", "html_url": "https://github.com/rust-lang/rust/commit/d565c7488749fd0e998d6be21efeb20354e4696d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d565c7488749fd0e998d6be21efeb20354e4696d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8cf990c9b5c59f25c806fad9f4466f9d6509bbea", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cf990c9b5c59f25c806fad9f4466f9d6509bbea", "html_url": "https://github.com/rust-lang/rust/commit/8cf990c9b5c59f25c806fad9f4466f9d6509bbea"}, {"sha": "88ccaa77f17a74ec8597efa5c86f0f789028d1b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/88ccaa77f17a74ec8597efa5c86f0f789028d1b4", "html_url": "https://github.com/rust-lang/rust/commit/88ccaa77f17a74ec8597efa5c86f0f789028d1b4"}], "stats": {"total": 374, "additions": 334, "deletions": 40}, "files": [{"sha": "f014a3d7b253995aa36cc7aa551b5cdc14c30993", "filename": "library/std/src/os/unix/process.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d565c7488749fd0e998d6be21efeb20354e4696d/library%2Fstd%2Fsrc%2Fos%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d565c7488749fd0e998d6be21efeb20354e4696d/library%2Fstd%2Fsrc%2Fos%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fprocess.rs?ref=d565c7488749fd0e998d6be21efeb20354e4696d", "patch": "@@ -75,6 +75,12 @@ pub trait CommandExt: Sealed {\n     /// sure that the closure does not violate library invariants by making\n     /// invalid use of these duplicates.\n     ///\n+    /// Panicking in the closure is safe only if all the format arguments for the\n+    /// panic message can be safely formatted; this is because although\n+    /// `Command` calls [`std::panic::always_abort`](crate::panic::always_abort)\n+    /// before calling the pre_exec hook, panic will still try to format the\n+    /// panic message.\n+    ///\n     /// When this closure is run, aspects such as the stdio file descriptors and\n     /// working directory have successfully been changed, so output to these\n     /// locations may not appear where intended."}, {"sha": "b10dde424821d1e2298cc6a1bda32c0d1513e950", "filename": "library/std/src/panic.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d565c7488749fd0e998d6be21efeb20354e4696d/library%2Fstd%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d565c7488749fd0e998d6be21efeb20354e4696d/library%2Fstd%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanic.rs?ref=d565c7488749fd0e998d6be21efeb20354e4696d", "patch": "@@ -463,5 +463,41 @@ pub fn resume_unwind(payload: Box<dyn Any + Send>) -> ! {\n     panicking::rust_panic_without_hook(payload)\n }\n \n+/// Make all future panics abort directly without running the panic hook or unwinding.\n+///\n+/// There is no way to undo this; the effect lasts until the process exits or\n+/// execs (or the equivalent).\n+///\n+/// # Use after fork\n+///\n+/// This function is particularly useful for calling after `libc::fork`.  After `fork`, in a\n+/// multithreaded program it is (on many platforms) not safe to call the allocator.  It is also\n+/// generally highly undesirable for an unwind to unwind past the `fork`, because that results in\n+/// the unwind propagating to code that was only ever expecting to run in the parent.\n+///\n+/// `panic::always_abort()` helps avoid both of these.  It directly avoids any further unwinding,\n+/// and if there is a panic, the abort will occur without allocating provided that the arguments to\n+/// panic can be formatted without allocating.\n+///\n+/// Examples\n+///\n+/// ```no_run\n+/// #![feature(panic_always_abort)]\n+/// use std::panic;\n+///\n+/// panic::always_abort();\n+///\n+/// let _ = panic::catch_unwind(|| {\n+///     panic!(\"inside the catch\");\n+/// });\n+///\n+/// // We will have aborted already, due to the panic.\n+/// unreachable!();\n+/// ```\n+#[unstable(feature = \"panic_always_abort\", issue = \"84438\")]\n+pub fn always_abort() {\n+    crate::panicking::panic_count::set_always_abort();\n+}\n+\n #[cfg(test)]\n mod tests;"}, {"sha": "a8410bea7342b1f198c412d2e9e5403bca9bf480", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 51, "deletions": 17, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d565c7488749fd0e998d6be21efeb20354e4696d/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d565c7488749fd0e998d6be21efeb20354e4696d/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=d565c7488749fd0e998d6be21efeb20354e4696d", "patch": "@@ -180,7 +180,7 @@ pub fn take_hook() -> Box<dyn Fn(&PanicInfo<'_>) + 'static + Sync + Send> {\n fn default_hook(info: &PanicInfo<'_>) {\n     // If this is a double panic, make sure that we print a backtrace\n     // for this panic. Otherwise only print it if logging is enabled.\n-    let backtrace_env = if panic_count::get() >= 2 {\n+    let backtrace_env = if panic_count::get_count() >= 2 {\n         RustBacktrace::Print(crate::backtrace_rs::PrintFmt::Full)\n     } else {\n         backtrace::rust_backtrace_env()\n@@ -233,6 +233,8 @@ pub mod panic_count {\n     use crate::cell::Cell;\n     use crate::sync::atomic::{AtomicUsize, Ordering};\n \n+    pub const ALWAYS_ABORT_FLAG: usize = 1 << (usize::BITS - 1);\n+\n     // Panic count for the current thread.\n     thread_local! { static LOCAL_PANIC_COUNT: Cell<usize> = Cell::new(0) }\n \n@@ -241,33 +243,53 @@ pub mod panic_count {\n     // thread, if that thread currently views `GLOBAL_PANIC_COUNT` as being zero,\n     // then `LOCAL_PANIC_COUNT` in that thread is zero. This invariant holds before\n     // and after increase and decrease, but not necessarily during their execution.\n+    //\n+    // Additionally, the top bit of GLOBAL_PANIC_COUNT (GLOBAL_ALWAYS_ABORT_FLAG)\n+    // records whether panic::always_abort() has been called.  This can only be\n+    // set, never cleared.\n+    //\n+    // This could be viewed as a struct containing a single bit and an n-1-bit\n+    // value, but if we wrote it like that it would be more than a single word,\n+    // and even a newtype around usize would be clumsy because we need atomics.\n+    // But we use such a tuple for the return type of increase().\n+    //\n+    // Stealing a bit is fine because it just amounts to assuming that each\n+    // panicking thread consumes at least 2 bytes of address space.\n     static GLOBAL_PANIC_COUNT: AtomicUsize = AtomicUsize::new(0);\n \n-    pub fn increase() -> usize {\n-        GLOBAL_PANIC_COUNT.fetch_add(1, Ordering::Relaxed);\n-        LOCAL_PANIC_COUNT.with(|c| {\n-            let next = c.get() + 1;\n-            c.set(next);\n-            next\n-        })\n+    pub fn increase() -> (bool, usize) {\n+        (\n+            GLOBAL_PANIC_COUNT.fetch_add(1, Ordering::Relaxed) & ALWAYS_ABORT_FLAG != 0,\n+            LOCAL_PANIC_COUNT.with(|c| {\n+                let next = c.get() + 1;\n+                c.set(next);\n+                next\n+            }),\n+        )\n     }\n \n-    pub fn decrease() -> usize {\n+    pub fn decrease() {\n         GLOBAL_PANIC_COUNT.fetch_sub(1, Ordering::Relaxed);\n         LOCAL_PANIC_COUNT.with(|c| {\n             let next = c.get() - 1;\n             c.set(next);\n             next\n-        })\n+        });\n+    }\n+\n+    pub fn set_always_abort() {\n+        GLOBAL_PANIC_COUNT.fetch_or(ALWAYS_ABORT_FLAG, Ordering::Relaxed);\n     }\n \n-    pub fn get() -> usize {\n+    // Disregards ALWAYS_ABORT_FLAG\n+    pub fn get_count() -> usize {\n         LOCAL_PANIC_COUNT.with(|c| c.get())\n     }\n \n+    // Disregards ALWAYS_ABORT_FLAG\n     #[inline]\n-    pub fn is_zero() -> bool {\n-        if GLOBAL_PANIC_COUNT.load(Ordering::Relaxed) == 0 {\n+    pub fn count_is_zero() -> bool {\n+        if GLOBAL_PANIC_COUNT.load(Ordering::Relaxed) & !ALWAYS_ABORT_FLAG == 0 {\n             // Fast path: if `GLOBAL_PANIC_COUNT` is zero, all threads\n             // (including the current one) will have `LOCAL_PANIC_COUNT`\n             // equal to zero, so TLS access can be avoided.\n@@ -410,7 +432,7 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n /// Determines whether the current thread is unwinding because of panic.\n #[inline]\n pub fn panicking() -> bool {\n-    !panic_count::is_zero()\n+    !panic_count::count_is_zero()\n }\n \n /// The entry point for panicking with a formatted message.\n@@ -563,15 +585,27 @@ fn rust_panic_with_hook(\n     message: Option<&fmt::Arguments<'_>>,\n     location: &Location<'_>,\n ) -> ! {\n-    let panics = panic_count::increase();\n+    let (must_abort, panics) = panic_count::increase();\n \n     // If this is the third nested call (e.g., panics == 2, this is 0-indexed),\n     // the panic hook probably triggered the last panic, otherwise the\n     // double-panic check would have aborted the process. In this case abort the\n     // process real quickly as we don't want to try calling it again as it'll\n     // probably just panic again.\n-    if panics > 2 {\n-        util::dumb_print(format_args!(\"thread panicked while processing panic. aborting.\\n\"));\n+    if must_abort || panics > 2 {\n+        if panics > 2 {\n+            // Don't try to print the message in this case\n+            // - perhaps that is causing the recursive panics.\n+            util::dumb_print(format_args!(\"thread panicked while processing panic. aborting.\\n\"));\n+        } else {\n+            // Unfortunately, this does not print a backtrace, because creating\n+            // a `Backtrace` will allocate, which we must to avoid here.\n+            let panicinfo = PanicInfo::internal_constructor(message, location);\n+            util::dumb_print(format_args!(\n+                \"{}\\npanicked after panic::always_abort(), aborting.\\n\",\n+                panicinfo\n+            ));\n+        }\n         intrinsics::abort()\n     }\n "}, {"sha": "08b500b9c825a32d810c7d708c0ffae59e79130f", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d565c7488749fd0e998d6be21efeb20354e4696d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d565c7488749fd0e998d6be21efeb20354e4696d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=d565c7488749fd0e998d6be21efeb20354e4696d", "patch": "@@ -54,6 +54,7 @@ impl Command {\n         let (env_lock, pid) = unsafe { (sys::os::env_read_lock(), cvt(libc::fork())?) };\n \n         if pid == 0 {\n+            crate::panic::always_abort();\n             mem::forget(env_lock);\n             drop(input);\n             let Err(err) = unsafe { self.do_exec(theirs, envp.as_ref()) };"}, {"sha": "157debf2d257b5a1a9e4bcc9b8fbd44bb8052257", "filename": "library/std/src/sys/unix/process/process_unix/tests.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d565c7488749fd0e998d6be21efeb20354e4696d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d565c7488749fd0e998d6be21efeb20354e4696d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix%2Ftests.rs?ref=d565c7488749fd0e998d6be21efeb20354e4696d", "patch": "@@ -1,3 +1,10 @@\n+use crate::os::unix::process::{CommandExt, ExitStatusExt};\n+use crate::panic::catch_unwind;\n+use crate::process::Command;\n+\n+// Many of the other aspects of this situation, including heap alloc concurrency\n+// safety etc., are tested in src/test/ui/process/process-panic-after-fork.rs\n+\n #[test]\n fn exitstatus_display_tests() {\n     // In practice this is the same on every Unix.\n@@ -28,3 +35,23 @@ fn exitstatus_display_tests() {\n         t(0x000ff, \"unrecognised wait status: 255 0xff\");\n     }\n }\n+\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)]\n+fn test_command_fork_no_unwind() {\n+    let got = catch_unwind(|| {\n+        let mut c = Command::new(\"echo\");\n+        c.arg(\"hi\");\n+        unsafe {\n+            c.pre_exec(|| panic!(\"{}\", \"crash now!\"));\n+        }\n+        let st = c.status().expect(\"failed to get command status\");\n+        dbg!(st);\n+        st\n+    });\n+    dbg!(&got);\n+    let status = got.expect(\"panic unexpectedly propagated\");\n+    dbg!(status);\n+    let signal = status.signal().expect(\"expected child process to die of signal\");\n+    assert!(signal == libc::SIGABRT || signal == libc::SIGILL || signal == libc::SIGTRAP);\n+}"}, {"sha": "2aea607e95489d9a6a9e2b46783e7623d0f134ba", "filename": "src/test/ui/panics/abort-on-panic.rs", "status": "modified", "additions": 62, "deletions": 23, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/d565c7488749fd0e998d6be21efeb20354e4696d/src%2Ftest%2Fui%2Fpanics%2Fabort-on-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d565c7488749fd0e998d6be21efeb20354e4696d/src%2Ftest%2Fui%2Fpanics%2Fabort-on-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanics%2Fabort-on-panic.rs?ref=d565c7488749fd0e998d6be21efeb20354e4696d", "patch": "@@ -2,6 +2,7 @@\n \n #![allow(unused_must_use)]\n #![feature(unwind_attributes)]\n+#![feature(panic_always_abort)]\n // Since we mark some ABIs as \"nounwind\" to LLVM, we must make sure that\n // we never unwind through them.\n \n@@ -11,7 +12,9 @@\n use std::{env, panic};\n use std::io::prelude::*;\n use std::io;\n-use std::process::{Command, Stdio};\n+use std::process::{exit, Command, Stdio};\n+use std::sync::{Arc, Barrier};\n+use std::thread;\n \n #[unwind(aborts)] // FIXME(#58794) should work even without the attribute\n extern \"C\" fn panic_in_ffi() {\n@@ -23,41 +26,77 @@ extern \"Rust\" fn panic_in_rust_abi() {\n     panic!(\"TestRust\");\n }\n \n-fn test() {\n-    let _ = panic::catch_unwind(|| { panic_in_ffi(); });\n-    // The process should have aborted by now.\n+fn should_have_aborted() {\n     io::stdout().write(b\"This should never be printed.\\n\");\n     let _ = io::stdout().flush();\n }\n \n+fn bomb_out_but_not_abort(msg: &str) {\n+    eprintln!(\"bombing out: {}\", msg);\n+    exit(1);\n+}\n+\n+fn test() {\n+    let _ = panic::catch_unwind(|| { panic_in_ffi(); });\n+    should_have_aborted();\n+}\n+\n fn testrust() {\n     let _ = panic::catch_unwind(|| { panic_in_rust_abi(); });\n-    // The process should have aborted by now.\n-    io::stdout().write(b\"This should never be printed.\\n\");\n-    let _ = io::stdout().flush();\n+    should_have_aborted();\n+}\n+\n+fn test_always_abort() {\n+    panic::always_abort();\n+    let _ = panic::catch_unwind(|| { panic!(); });\n+    should_have_aborted();\n+}\n+\n+fn test_always_abort_thread() {\n+    let barrier = Arc::new(Barrier::new(2));\n+    let thr = {\n+        let barrier = barrier.clone();\n+        thread::spawn(move ||{\n+            barrier.wait();\n+            panic!(\"in thread\");\n+        })\n+    };\n+    panic::always_abort();\n+    barrier.wait();\n+    let _ = thr.join();\n+    bomb_out_but_not_abort(\"joined - but we were supposed to panic!\");\n }\n \n fn main() {\n+    let tests: &[(_, fn())] = &[\n+        (\"test\", test),\n+        (\"testrust\", testrust),\n+        (\"test_always_abort\", test_always_abort),\n+        (\"test_always_abort_thread\", test_always_abort_thread),\n+    ];\n+\n     let args: Vec<String> = env::args().collect();\n     if args.len() > 1 {\n         // This is inside the self-executed command.\n-        match &*args[1] {\n-            \"test\" => return test(),\n-            \"testrust\" => return testrust(),\n-            _ => panic!(\"bad test\"),\n+        for (a,f) in tests {\n+            if &args[1] == a { return f() }\n         }\n+        bomb_out_but_not_abort(\"bad test\");\n     }\n \n-    // These end up calling the self-execution branches above.\n-    let mut p = Command::new(&args[0])\n-                        .stdout(Stdio::piped())\n-                        .stdin(Stdio::piped())\n-                        .arg(\"test\").spawn().unwrap();\n-    assert!(!p.wait().unwrap().success());\n-\n-    let mut p = Command::new(&args[0])\n-                        .stdout(Stdio::piped())\n-                        .stdin(Stdio::piped())\n-                        .arg(\"testrust\").spawn().unwrap();\n-    assert!(!p.wait().unwrap().success());\n+    let execute_self_expecting_abort = |arg| {\n+        let mut p = Command::new(&args[0])\n+                            .stdout(Stdio::piped())\n+                            .stdin(Stdio::piped())\n+                            .arg(arg).spawn().unwrap();\n+        let status = p.wait().unwrap();\n+        assert!(!status.success());\n+        // Any reasonable platform can distinguish a process which\n+        // called exit(1) from one which panicked.\n+        assert_ne!(status.code(), Some(1));\n+    };\n+\n+    for (a,_f) in tests {\n+        execute_self_expecting_abort(a);\n+    }\n }"}, {"sha": "1ccf6bb051c20593c0e4d6f90f04669fbe8673e3", "filename": "src/test/ui/process/process-panic-after-fork.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/d565c7488749fd0e998d6be21efeb20354e4696d/src%2Ftest%2Fui%2Fprocess%2Fprocess-panic-after-fork.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d565c7488749fd0e998d6be21efeb20354e4696d/src%2Ftest%2Fui%2Fprocess%2Fprocess-panic-after-fork.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprocess%2Fprocess-panic-after-fork.rs?ref=d565c7488749fd0e998d6be21efeb20354e4696d", "patch": "@@ -0,0 +1,151 @@\n+// run-pass\n+// no-prefer-dynamic\n+// ignore-wasm32-bare no libc\n+// ignore-windows\n+// ignore-sgx no libc\n+// ignore-emscripten no processes\n+// ignore-sgx no processes\n+// ignore-android: FIXME(#85261)\n+\n+#![feature(bench_black_box)]\n+#![feature(rustc_private)]\n+#![feature(never_type)]\n+#![feature(panic_always_abort)]\n+\n+extern crate libc;\n+\n+use std::alloc::{GlobalAlloc, Layout};\n+use std::fmt;\n+use std::panic::{self, panic_any};\n+use std::os::unix::process::{CommandExt, ExitStatusExt};\n+use std::process::{self, Command, ExitStatus};\n+use std::sync::atomic::{AtomicU32, Ordering};\n+\n+use libc::c_int;\n+\n+/// This stunt allocator allows us to spot heap allocations in the child.\n+struct PidChecking<A> {\n+    parent: A,\n+    require_pid: AtomicU32,\n+}\n+\n+#[global_allocator]\n+static ALLOCATOR: PidChecking<std::alloc::System> = PidChecking {\n+    parent: std::alloc::System,\n+    require_pid: AtomicU32::new(0),\n+};\n+\n+impl<A> PidChecking<A> {\n+    fn engage(&self) {\n+        let parent_pid = process::id();\n+        eprintln!(\"engaging allocator trap, parent pid={}\", parent_pid);\n+        self.require_pid.store(parent_pid, Ordering::Release);\n+    }\n+    fn check(&self) {\n+        let require_pid = self.require_pid.load(Ordering::Acquire);\n+        if require_pid != 0 {\n+            let actual_pid = process::id();\n+            if require_pid != actual_pid {\n+                unsafe {\n+                    libc::raise(libc::SIGUSR1);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+unsafe impl<A:GlobalAlloc> GlobalAlloc for PidChecking<A> {\n+    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+        self.check();\n+        self.parent.alloc(layout)\n+    }\n+\n+    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+        self.check();\n+        self.parent.dealloc(ptr, layout)\n+    }\n+\n+    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+        self.check();\n+        self.parent.alloc_zeroed(layout)\n+    }\n+\n+    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+        self.check();\n+        self.parent.realloc(ptr, layout, new_size)\n+    }\n+}\n+\n+fn expect_aborted(status: ExitStatus) {\n+    dbg!(status);\n+    let signal = status.signal().expect(\"expected child process to die of signal\");\n+    assert!(signal == libc::SIGABRT || signal == libc::SIGILL || signal == libc::SIGTRAP);\n+}\n+\n+fn main() {\n+    ALLOCATOR.engage();\n+\n+    fn run(do_panic: &dyn Fn()) -> ExitStatus {\n+        let child = unsafe { libc::fork() };\n+        assert!(child >= 0);\n+        if child == 0 {\n+            panic::always_abort();\n+            do_panic();\n+            process::exit(0);\n+        }\n+        let mut status: c_int = 0;\n+        let got = unsafe { libc::waitpid(child, &mut status, 0) };\n+        assert_eq!(got, child);\n+        let status = ExitStatus::from_raw(status.into());\n+        status\n+    }\n+\n+    fn one(do_panic: &dyn Fn()) {\n+        let status = run(do_panic);\n+        expect_aborted(status);\n+    }\n+\n+    one(&|| panic!());\n+    one(&|| panic!(\"some message\"));\n+    one(&|| panic!(\"message with argument: {}\", 42));\n+\n+    #[derive(Debug)]\n+    struct Wotsit { }\n+    one(&|| panic_any(Wotsit { }));\n+\n+    let mut c = Command::new(\"echo\");\n+    unsafe {\n+        c.pre_exec(|| panic!(\"{}\", \"crash now!\"));\n+    }\n+    let st = c.status().expect(\"failed to get command status\");\n+    expect_aborted(st);\n+\n+    struct DisplayWithHeap;\n+    impl fmt::Display for DisplayWithHeap {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n+            let s = vec![0; 100];\n+            let s = std::hint::black_box(s);\n+            write!(f, \"{:?}\", s)\n+        }\n+    }\n+\n+    // Some panics in the stdlib that we want not to allocate, as\n+    // otherwise these facilities become impossible to use in the\n+    // child after fork, which is really quite awkward.\n+\n+    one(&|| { None::<DisplayWithHeap>.unwrap(); });\n+    one(&|| { None::<DisplayWithHeap>.expect(\"unwrapped a none\"); });\n+    one(&|| { std::str::from_utf8(b\"\\xff\").unwrap(); });\n+    one(&|| {\n+        let x = [0, 1, 2, 3];\n+        let y = x[std::hint::black_box(4)];\n+        let _z = std::hint::black_box(y);\n+    });\n+\n+    // Finally, check that our stunt allocator can actually catch an allocation after fork.\n+    // ie, that our test is effective.\n+\n+    let status = run(&|| panic!(\"allocating to display... {}\", DisplayWithHeap));\n+    dbg!(status);\n+    assert_eq!(status.signal(), Some(libc::SIGUSR1));\n+}"}]}