{"sha": "9b5ebe726c1f9dc83b11fb3b77dd24f201d7b777", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliNWViZTcyNmMxZjlkYzgzYjExZmIzYjc3ZGQyNGYyMDFkN2I3Nzc=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-15T19:01:28Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-15T19:39:27Z"}, "message": "Implement checking of alias safety in tail calls.", "tree": {"sha": "4e2e9469b79997c1ca0b94a54205b79f98cb066a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e2e9469b79997c1ca0b94a54205b79f98cb066a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b5ebe726c1f9dc83b11fb3b77dd24f201d7b777", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b5ebe726c1f9dc83b11fb3b77dd24f201d7b777", "html_url": "https://github.com/rust-lang/rust/commit/9b5ebe726c1f9dc83b11fb3b77dd24f201d7b777", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b5ebe726c1f9dc83b11fb3b77dd24f201d7b777/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2b8002fd325aa5a6f79d0306f508b4c17cd90af", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2b8002fd325aa5a6f79d0306f508b4c17cd90af", "html_url": "https://github.com/rust-lang/rust/commit/b2b8002fd325aa5a6f79d0306f508b4c17cd90af"}], "stats": {"total": 105, "additions": 75, "deletions": 30}, "files": [{"sha": "d684c3cb4ab823de9641df6eed8324f361f82209", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 75, "deletions": 30, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/9b5ebe726c1f9dc83b11fb3b77dd24f201d7b777/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5ebe726c1f9dc83b11fb3b77dd24f201d7b777/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=9b5ebe726c1f9dc83b11fb3b77dd24f201d7b777", "patch": "@@ -77,12 +77,18 @@ fn visit_item(@ctx cx, &@ast::item i, &scope sc, &vt[scope] v) {\n }\n \n fn visit_expr(@ctx cx, &@ast::expr ex, &scope sc, &vt[scope] v) {\n-    auto handled = false;\n+    auto handled = true;\n     alt (ex.node) {\n-        case (ast::expr_call(?f, ?args, _)) { check_call(*cx, f, args, sc); }\n+        case (ast::expr_call(?f, ?args, _)) {\n+            check_call(*cx, f, args, sc);\n+            handled = false;\n+        }\n+        case (ast::expr_be(?cl, _)) {\n+            check_tail_call(*cx, cl);\n+            visit::visit_expr(cl, sc, v);\n+        }\n         case (ast::expr_alt(?input, ?arms, _)) {\n             check_alt(*cx, input, arms, sc, v);\n-            handled = true;\n         }\n         case (ast::expr_put(?val, _)) {\n             alt (val) {\n@@ -97,44 +103,36 @@ fn visit_expr(@ctx cx, &@ast::expr ex, &scope sc, &vt[scope] v) {\n                 }\n                 case (_) { }\n             }\n-            handled = true;\n         }\n         case (ast::expr_for_each(?decl, ?call, ?block, _)) {\n             check_for_each(*cx, decl, call, block, sc, v);\n-            handled = true;\n         }\n         case (ast::expr_for(?decl, ?seq, ?block, _)) {\n             check_for(*cx, decl, seq, block, sc, v);\n-            handled = true;\n         }\n         case (ast::expr_path(?pt, ?ann)) {\n             check_var(*cx, ex, pt, ann, false, sc);\n+            handled = false;\n         }\n         case (ast::expr_move(?dest, ?src, _)) {\n             check_assign(cx, dest, src, sc, v);\n-            handled = true;\n         }\n         case (ast::expr_assign(?dest, ?src, _)) {\n             check_assign(cx, dest, src, sc, v);\n-            handled = true;\n         }\n         case (ast::expr_assign_op(_, ?dest, ?src, _)) {\n             check_assign(cx, dest, src, sc, v);\n-            handled = true;\n         }\n-        case (_) { }\n+        case (_) { handled = false; }\n     }\n     if (!handled) { visit::visit_expr(ex, sc, v); }\n }\n \n fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc) ->\n    rec(vec[def_num] root_vars, vec[ty::t] unsafe_ts) {\n     auto fty = ty::expr_ty(*cx.tcx, f);\n-    auto arg_ts =\n-        alt (ty::struct(*cx.tcx, fty)) {\n-            case (ty::ty_fn(_, ?args, _, _, _)) { args }\n-            case (ty::ty_native_fn(_, ?args, _)) { args }\n-        };\n+    auto arg_ts = fty_args(cx, fty);\n+\n     let vec[def_num] roots = [];\n     let vec[tup(uint, def_num)] mut_roots = [];\n     let vec[ty::t] unsafe_ts = [];\n@@ -175,11 +173,11 @@ fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc) ->\n     if (vec::len(unsafe_ts) > 0u) {\n         alt (f.node) {\n             case (ast::expr_path(_, ?ann)) {\n-                if (def_is_local(cx.dm.get(ann.id))) {\n-                    cx.tcx.sess.span_err(f.span,\n-                                         #fmt(\"function may alias with \\\n-                         argument %u, which is not immutably rooted\",\n-                                              unsafe_t_offsets.(0)));\n+                if (def_is_local(cx.dm.get(ann.id), true)) {\n+                    cx.tcx.sess.span_err\n+                        (f.span, #fmt(\"function may alias with argument \\\n+                         %u, which is not immutably rooted\",\n+                         unsafe_t_offsets.(0)));\n                 }\n             }\n             case (_) { }\n@@ -221,8 +219,47 @@ fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc) ->\n     ret rec(root_vars=roots, unsafe_ts=unsafe_ts);\n }\n \n-fn check_alt(&ctx cx, &@ast::expr input, &vec[ast::arm] arms, &scope sc,\n-             &vt[scope] v) {\n+fn check_tail_call(&ctx cx, &@ast::expr call) {\n+    auto args;\n+    auto f = alt (call.node) {\n+        case (ast::expr_call(?f, ?args_, _)) { args = args_; f }\n+    };\n+    auto i = 0u;\n+    for (ty::arg arg_t in fty_args(cx, ty::expr_ty(*cx.tcx, f))) {\n+        if (arg_t.mode != ty::mo_val) {\n+            auto mut_a = arg_t.mode == ty::mo_alias(true);\n+            auto ok = true;\n+            alt (args.(i).node) {\n+                case (ast::expr_path(_, ?ann)) {\n+                    auto def = cx.dm.get(ann.id);\n+                    auto dnum = ast::def_id_of_def(def)._1;\n+                    alt (cx.local_map.find(dnum)) {\n+                        case (some(arg(ast::alias(?mut)))) {\n+                            if (mut_a && !mut) {\n+                                cx.tcx.sess.span_warn\n+                                    (args.(i).span, \"passing an immutable \\\n+                                     alias by mutable alias\");\n+                            }\n+                        }\n+                        case (_) {\n+                            ok = !def_is_local(def, false);\n+                        }\n+                    }\n+                }\n+                case (_) { ok = false; }\n+            }\n+            if (!ok) {\n+                cx.tcx.sess.span_warn\n+                    (args.(i).span, \"can not pass a local value by alias to \\\n+                                     a tail call\");\n+            }\n+        }\n+        i += 1u;\n+    }\n+}\n+\n+fn check_alt(&ctx cx, &@ast::expr input, &vec[ast::arm] arms,\n+             &scope sc, &vt[scope] v) {\n     visit::visit_expr(input, sc, v);\n     auto root = expr_root(cx, input, true);\n     auto roots =\n@@ -317,7 +354,7 @@ fn check_for(&ctx cx, &@ast::local local, &@ast::expr seq, &ast::block block,\n fn check_var(&ctx cx, &@ast::expr ex, &ast::path p, ast::ann ann, bool assign,\n              &scope sc) {\n     auto def = cx.dm.get(ann.id);\n-    if (!def_is_local(def)) { ret; }\n+    if (!def_is_local(def, true)) { ret; }\n     auto my_defnum = ast::def_id_of_def(def)._1;\n     auto var_t = ty::expr_ty(*cx.tcx, ex);\n     for (restrict r in sc) {\n@@ -594,15 +631,23 @@ fn ty_can_unsafely_include(&ctx cx, ty::t needle, ty::t haystack, bool mut) ->\n     ret helper(*cx.tcx, needle, haystack, mut);\n }\n \n-fn def_is_local(&ast::def d) -> bool {\n+fn def_is_local(&ast::def d, bool objfields_count) -> bool {\n     ret alt (d) {\n-            case (ast::def_local(_)) { true }\n-            case (ast::def_arg(_)) { true }\n-            case (ast::def_obj_field(_)) { true }\n-            case (ast::def_binding(_)) { true }\n-            case (_) { false }\n-        };\n+        case (ast::def_local(_)) { true }\n+        case (ast::def_arg(_)) { true }\n+        case (ast::def_obj_field(_)) { objfields_count }\n+        case (ast::def_binding(_)) { true }\n+        case (_) { false }\n+    };\n }\n+\n+fn fty_args(&ctx cx, ty::t fty) -> vec[ty::arg] {\n+    ret alt (ty::struct(*cx.tcx, fty)) {\n+        case (ty::ty_fn(_, ?args, _, _, _)) { args }\n+        case (ty::ty_native_fn(_, ?args, _)) { args }\n+    };\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}]}