{"sha": "00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "node_id": "C_kwDOAAsO6NoAKDAwZWJlYjg3YWM4N2E0OTJiZDU5YWNlNmJkNDNkNmFkMTYyOWNhNGU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-28T13:46:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-28T13:46:43Z"}, "message": "Auto merge of #98612 - Dylan-DPC:rollup-7tasikc, r=Dylan-DPC\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #97346 (Remove a back-compat hack on lazy TAIT)\n - #98261 (Remove `MAX_SUGGESTION_HIGHLIGHT_LINES`)\n - #98337 ([RFC 2011] Optimize non-consuming operators)\n - #98384 (Fix RSS reporting on macOS)\n - #98420 (translation: lint fix + more migration)\n - #98430 (Refactor iter adapters with less macros)\n - #98555 (Hermit: Fix initializing lazy locks)\n - #98595 (Implement `Send` and `Sync` for `ThinBox<T>`)\n - #98597 (Remove unstable CStr/CString change from 1.62 release note)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "08462526fb5f69acea449b972d435d0ebed03906", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08462526fb5f69acea449b972d435d0ebed03906"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "html_url": "https://github.com/rust-lang/rust/commit/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "baf382e63c023259fa1f9042f8f479f183ca6ed3", "url": "https://api.github.com/repos/rust-lang/rust/commits/baf382e63c023259fa1f9042f8f479f183ca6ed3", "html_url": "https://github.com/rust-lang/rust/commit/baf382e63c023259fa1f9042f8f479f183ca6ed3"}, {"sha": "66b806084ec50917ab6cb87c3774facfdf3038fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/66b806084ec50917ab6cb87c3774facfdf3038fa", "html_url": "https://github.com/rust-lang/rust/commit/66b806084ec50917ab6cb87c3774facfdf3038fa"}], "stats": {"total": 1096, "additions": 651, "deletions": 445}, "files": [{"sha": "96d9449db57c076c5db7f44fa8c9dc92c12a479d", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -4280,6 +4280,7 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\","}, {"sha": "7479735012cc9dfca34b858d5fb720b93e4b5eb3", "filename": "RELEASES.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -29,7 +29,6 @@ Compiler\n Libraries\n ---------\n \n-- [Move `CStr` to libcore, and `CString` to liballoc][94079]\n - [Windows: Use a pipe relay for chaining pipes][95841]\n - [Replace Linux Mutex and Condvar with futex based ones.][95035]\n - [Replace RwLock by a futex based one on Linux][95801]\n@@ -90,7 +89,6 @@ and related tools.\n \n [93313]: https://github.com/rust-lang/rust/pull/93313/\n [93969]: https://github.com/rust-lang/rust/pull/93969/\n-[94079]: https://github.com/rust-lang/rust/pull/94079/\n [94206]: https://github.com/rust-lang/rust/pull/94206/\n [94457]: https://github.com/rust-lang/rust/pull/94457/\n [94775]: https://github.com/rust-lang/rust/pull/94775/"}, {"sha": "708fe8719a1ebc84d3f0bb5b51f2dc434960831f", "filename": "compiler/rustc_borrowck/src/borrowck_errors.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -1,4 +1,6 @@\n-use rustc_errors::{struct_span_err, DiagnosticBuilder, DiagnosticId, ErrorGuaranteed, MultiSpan};\n+use rustc_errors::{\n+    struct_span_err, DiagnosticBuilder, DiagnosticId, DiagnosticMessage, ErrorGuaranteed, MultiSpan,\n+};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::Span;\n \n@@ -476,10 +478,11 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         struct_span_err!(self, span, E0716, \"temporary value dropped while borrowed\",)\n     }\n \n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     fn struct_span_err_with_code<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         code: DiagnosticId,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         self.infcx.tcx.sess.struct_span_err_with_code(sp, msg, code)"}, {"sha": "a2df072aa31195f63964f71d9d45bc4e4dfdb08c", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -6,6 +6,7 @@\n #![feature(let_else)]\n #![feature(min_specialization)]\n #![feature(never_type)]\n+#![feature(rustc_attrs)]\n #![feature(stmt_expr_attributes)]\n #![feature(trusted_step)]\n #![feature(try_blocks)]"}, {"sha": "9e50d33486cf2f51dca7e3c8d9ceafdc6f81d5de", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 81, "deletions": 15, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -1,11 +1,10 @@\n-use crate::assert::expr_if_not;\n use rustc_ast::{\n     attr,\n     ptr::P,\n     token,\n     tokenstream::{DelimSpan, TokenStream, TokenTree},\n-    BorrowKind, Expr, ExprKind, ItemKind, MacArgs, MacCall, MacDelimiter, Mutability, Path,\n-    PathSegment, Stmt, StructRest, UseTree, UseTreeKind, DUMMY_NODE_ID,\n+    BinOpKind, BorrowKind, Expr, ExprKind, ItemKind, MacArgs, MacCall, MacDelimiter, Mutability,\n+    Path, PathSegment, Stmt, StructRest, UnOp, UseTree, UseTreeKind, DUMMY_NODE_ID,\n };\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n@@ -16,11 +15,19 @@ use rustc_span::{\n };\n \n pub(super) struct Context<'cx, 'a> {\n+    // An optimization.\n+    //\n+    // Elements that aren't consumed (PartialEq, PartialOrd, ...) can be copied **after** the\n+    // `assert!` expression fails rather than copied on-the-fly.\n+    best_case_captures: Vec<Stmt>,\n     // Top-level `let captureN = Capture::new()` statements\n     capture_decls: Vec<Capture>,\n     cx: &'cx ExtCtxt<'a>,\n     // Formatting string used for debugging\n     fmt_string: String,\n+    // If the current expression being visited consumes itself. Used to construct\n+    // `best_case_captures`.\n+    is_consumed: bool,\n     // Top-level `let __local_bindN = &expr` statements\n     local_bind_decls: Vec<Stmt>,\n     // Used to avoid capturing duplicated paths\n@@ -36,9 +43,11 @@ pub(super) struct Context<'cx, 'a> {\n impl<'cx, 'a> Context<'cx, 'a> {\n     pub(super) fn new(cx: &'cx ExtCtxt<'a>, span: Span) -> Self {\n         Self {\n+            best_case_captures: <_>::default(),\n             capture_decls: <_>::default(),\n             cx,\n             fmt_string: <_>::default(),\n+            is_consumed: true,\n             local_bind_decls: <_>::default(),\n             paths: <_>::default(),\n             span,\n@@ -69,14 +78,22 @@ impl<'cx, 'a> Context<'cx, 'a> {\n         self.manage_cond_expr(&mut cond_expr);\n         let initial_imports = self.build_initial_imports();\n         let panic = self.build_panic(&expr_str, panic_path);\n+        let cond_expr_with_unlikely = self.build_unlikely(cond_expr);\n+\n+        let Self { best_case_captures, capture_decls, cx, local_bind_decls, span, .. } = self;\n \n-        let Self { capture_decls, cx, local_bind_decls, span, .. } = self;\n+        let mut assert_then_stmts = Vec::with_capacity(2);\n+        assert_then_stmts.extend(best_case_captures);\n+        assert_then_stmts.push(self.cx.stmt_expr(panic));\n+        let assert_then = self.cx.block(span, assert_then_stmts);\n \n         let mut stmts = Vec::with_capacity(4);\n         stmts.push(initial_imports);\n         stmts.extend(capture_decls.into_iter().map(|c| c.decl));\n         stmts.extend(local_bind_decls);\n-        stmts.push(cx.stmt_expr(expr_if_not(cx, span, cond_expr, panic, None)));\n+        stmts.push(\n+            cx.stmt_expr(cx.expr(span, ExprKind::If(cond_expr_with_unlikely, assert_then, None))),\n+        );\n         cx.expr_block(cx.block(span, stmts))\n     }\n \n@@ -115,6 +132,16 @@ impl<'cx, 'a> Context<'cx, 'a> {\n         )\n     }\n \n+    /// Takes the conditional expression of `assert!` and then wraps it inside `unlikely`\n+    fn build_unlikely(&self, cond_expr: P<Expr>) -> P<Expr> {\n+        let unlikely_path = self.cx.std_path(&[sym::intrinsics, sym::unlikely]);\n+        self.cx.expr_call(\n+            self.span,\n+            self.cx.expr_path(self.cx.path(self.span, unlikely_path)),\n+            vec![self.cx.expr(self.span, ExprKind::Unary(UnOp::Not, cond_expr))],\n+        )\n+    }\n+\n     /// The necessary custom `panic!(...)` expression.\n     ///\n     /// panic!(\n@@ -167,17 +194,39 @@ impl<'cx, 'a> Context<'cx, 'a> {\n     /// See [Self::manage_initial_capture] and [Self::manage_try_capture]\n     fn manage_cond_expr(&mut self, expr: &mut P<Expr>) {\n         match (*expr).kind {\n-            ExprKind::AddrOf(_, _, ref mut local_expr) => {\n-                self.manage_cond_expr(local_expr);\n+            ExprKind::AddrOf(_, mutability, ref mut local_expr) => {\n+                self.with_is_consumed_management(\n+                    matches!(mutability, Mutability::Mut),\n+                    |this| this.manage_cond_expr(local_expr)\n+                );\n             }\n             ExprKind::Array(ref mut local_exprs) => {\n                 for local_expr in local_exprs {\n                     self.manage_cond_expr(local_expr);\n                 }\n             }\n-            ExprKind::Binary(_, ref mut lhs, ref mut rhs) => {\n-                self.manage_cond_expr(lhs);\n-                self.manage_cond_expr(rhs);\n+            ExprKind::Binary(ref op, ref mut lhs, ref mut rhs) => {\n+                self.with_is_consumed_management(\n+                    matches!(\n+                        op.node,\n+                        BinOpKind::Add\n+                            | BinOpKind::And\n+                            | BinOpKind::BitAnd\n+                            | BinOpKind::BitOr\n+                            | BinOpKind::BitXor\n+                            | BinOpKind::Div\n+                            | BinOpKind::Mul\n+                            | BinOpKind::Or\n+                            | BinOpKind::Rem\n+                            | BinOpKind::Shl\n+                            | BinOpKind::Shr\n+                            | BinOpKind::Sub\n+                    ),\n+                    |this| {\n+                        this.manage_cond_expr(lhs);\n+                        this.manage_cond_expr(rhs);\n+                    }\n+                );\n             }\n             ExprKind::Call(_, ref mut local_exprs) => {\n                 for local_expr in local_exprs {\n@@ -228,8 +277,11 @@ impl<'cx, 'a> Context<'cx, 'a> {\n                     self.manage_cond_expr(local_expr);\n                 }\n             }\n-            ExprKind::Unary(_, ref mut local_expr) => {\n-                self.manage_cond_expr(local_expr);\n+            ExprKind::Unary(un_op, ref mut local_expr) => {\n+                self.with_is_consumed_management(\n+                    matches!(un_op, UnOp::Neg | UnOp::Not),\n+                    |this| this.manage_cond_expr(local_expr)\n+                );\n             }\n             // Expressions that are not worth or can not be captured.\n             //\n@@ -337,9 +389,23 @@ impl<'cx, 'a> Context<'cx, 'a> {\n             ))\n             .add_trailing_semicolon();\n         let local_bind_path = self.cx.expr_path(Path::from_ident(local_bind));\n-        let ret = self.cx.stmt_expr(local_bind_path);\n-        let block = self.cx.expr_block(self.cx.block(self.span, vec![try_capture_call, ret]));\n-        *expr = self.cx.expr_deref(self.span, block);\n+        let rslt = if self.is_consumed {\n+            let ret = self.cx.stmt_expr(local_bind_path);\n+            self.cx.expr_block(self.cx.block(self.span, vec![try_capture_call, ret]))\n+        } else {\n+            self.best_case_captures.push(try_capture_call);\n+            local_bind_path\n+        };\n+        *expr = self.cx.expr_deref(self.span, rslt);\n+    }\n+\n+    // Calls `f` with the internal `is_consumed` set to `curr_is_consumed` and then\n+    // sets the internal `is_consumed` back to its original value.\n+    fn with_is_consumed_management(&mut self, curr_is_consumed: bool, f: impl FnOnce(&mut Self)) {\n+        let prev_is_consumed = self.is_consumed;\n+        self.is_consumed = curr_is_consumed;\n+        f(self);\n+        self.is_consumed = prev_is_consumed;\n     }\n }\n "}, {"sha": "d8b26f9840b63e9ed9891b7f524f51aa782efd20", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -826,6 +826,24 @@ cfg_if! {\n                 }\n             }\n         }\n+    } else if #[cfg(target_os = \"macos\")] {\n+        pub fn get_resident_set_size() -> Option<usize> {\n+            use libc::{c_int, c_void, getpid, proc_pidinfo, proc_taskinfo, PROC_PIDTASKINFO};\n+            use std::mem;\n+            const PROC_TASKINFO_SIZE: c_int = mem::size_of::<proc_taskinfo>() as c_int;\n+\n+            unsafe {\n+                let mut info: proc_taskinfo = mem::zeroed();\n+                let info_ptr = &mut info as *mut proc_taskinfo as *mut c_void;\n+                let pid = getpid() as c_int;\n+                let ret = proc_pidinfo(pid, PROC_PIDTASKINFO, 0, info_ptr, PROC_TASKINFO_SIZE);\n+                if ret == PROC_TASKINFO_SIZE {\n+                    Some(info.pti_resident_size as usize)\n+                } else {\n+                    None\n+                }\n+            }\n+        }\n     } else if #[cfg(unix)] {\n         pub fn get_resident_set_size() -> Option<usize> {\n             let field = 1;"}, {"sha": "2b0778f48caeeeae8843b697b25c856191feceb7", "filename": "compiler/rustc_error_messages/locales/en-US/privacy.ftl", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fprivacy.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fprivacy.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fprivacy.ftl?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -0,0 +1,12 @@\n+privacy-field-is-private = field `{$field_name}` of {$variant_descr} `{$def_path_str}` is private\n+privacy-field-is-private-is-update-syntax-label = field `{$field_name}` is private\n+privacy-field-is-private-label = private field\n+\n+privacy-item-is-private = {$kind} `{$descr}` is private\n+    .label = private {$kind}\n+privacy-unnamed-item-is-private = {$kind} is private\n+    .label = private {$kind}\n+\n+privacy-in-public-interface = {$vis_descr} {$kind} `{$descr}` in public interface\n+    .label = can't leak {$vis_descr} {$kind}\n+    .visibility-label = `{$descr}` declared as {$vis_descr}"}, {"sha": "90eb5ef54462d87181a41f1d0549746d9ca37360", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -32,6 +32,7 @@ pub use unic_langid::{langid, LanguageIdentifier};\n // Generates `DEFAULT_LOCALE_RESOURCES` static and `fluent_generated` module.\n fluent_messages! {\n     parser => \"../locales/en-US/parser.ftl\",\n+    privacy => \"../locales/en-US/privacy.ftl\",\n     typeck => \"../locales/en-US/typeck.ftl\",\n     builtin_macros => \"../locales/en-US/builtin_macros.ftl\",\n }"}, {"sha": "8b2a995f1c58ebf974d0d1f903f934565af8016b", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -656,11 +656,6 @@ impl Emitter for SilentEmitter {\n     }\n }\n \n-/// Maximum number of lines we will print for a multiline suggestion; arbitrary.\n-///\n-/// This should be replaced with a more involved mechanism to output multiline suggestions that\n-/// more closely mimics the regular diagnostic output, where irrelevant code lines are elided.\n-pub const MAX_SUGGESTION_HIGHLIGHT_LINES: usize = 6;\n /// Maximum number of suggestions to be shown\n ///\n /// Arbitrary, but taken from trait import suggestion limit"}, {"sha": "1e57d66dd9f5619dd8558574b74a3900cea5771f", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -1077,6 +1077,7 @@ impl<'a> ExtCtxt<'a> {\n         self.current_expansion.id.expansion_cause()\n     }\n \n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     pub fn struct_span_err<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -1101,9 +1102,11 @@ impl<'a> ExtCtxt<'a> {\n     ///\n     /// Compilation will be stopped in the near future (at the end of\n     /// the macro expansion phase).\n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.sess.parse_sess.span_diagnostic.span_err(sp, msg);\n     }\n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.sess.parse_sess.span_diagnostic.span_warn(sp, msg);\n     }"}, {"sha": "c18147592dc7022b449379f876b88237dc3bb67f", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -9,6 +9,7 @@\n #![feature(proc_macro_diagnostic)]\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_span)]\n+#![feature(rustc_attrs)]\n #![feature(try_blocks)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "ebb8d4434215fef29a0c9928c12a144262b3ce84", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -39,21 +39,19 @@ pub struct OpaqueTypeDecl<'tcx> {\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    /// This is a backwards compatibility hack to prevent breaking changes from\n-    /// lazy TAIT around RPIT handling.\n-    pub fn replace_opaque_types_with_inference_vars<T: TypeFoldable<'tcx>>(\n+    pub fn replace_opaque_types_with_inference_vars(\n         &self,\n-        value: T,\n+        ty: Ty<'tcx>,\n         body_id: HirId,\n         span: Span,\n         code: ObligationCauseCode<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-    ) -> InferOk<'tcx, T> {\n-        if !value.has_opaque_types() {\n-            return InferOk { value, obligations: vec![] };\n+    ) -> InferOk<'tcx, Ty<'tcx>> {\n+        if !ty.has_opaque_types() {\n+            return InferOk { value: ty, obligations: vec![] };\n         }\n         let mut obligations = vec![];\n-        let value = value.fold_with(&mut ty::fold::BottomUpFolder {\n+        let value = ty.fold_with(&mut ty::fold::BottomUpFolder {\n             tcx: self.tcx,\n             lt_op: |lt| lt,\n             ct_op: |ct| ct,"}, {"sha": "56c8635a189e1be10e7d1562d680eab630cb81ce", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -406,9 +406,12 @@ impl LateLintPass<'_> for Diagnostics {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         let Some((span, def_id, substs)) = typeck_results_of_method_fn(cx, expr) else { return };\n         debug!(?span, ?def_id, ?substs);\n-        if let Ok(Some(instance)) = ty::Instance::resolve(cx.tcx, cx.param_env, def_id, substs) &&\n-            !cx.tcx.has_attr(instance.def_id(), sym::rustc_lint_diagnostics)\n-        {\n+        let has_attr = ty::Instance::resolve(cx.tcx, cx.param_env, def_id, substs)\n+            .ok()\n+            .and_then(|inst| inst)\n+            .map(|inst| cx.tcx.has_attr(inst.def_id(), sym::rustc_lint_diagnostics))\n+            .unwrap_or(false);\n+        if !has_attr {\n             return;\n         }\n "}, {"sha": "113af328a91fa39bbcdedb97885d0f55f0caaee6", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -6,6 +6,7 @@\n #![feature(let_chains)]\n #![feature(let_else)]\n #![feature(never_type)]\n+#![feature(rustc_attrs)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "0869ed65ad2f3db915f7bbe8c4fb56895f55993c", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -357,6 +357,7 @@ impl<'a> DerefMut for SnapshotParser<'a> {\n }\n \n impl<'a> Parser<'a> {\n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     pub(super) fn span_err<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -365,6 +366,7 @@ impl<'a> Parser<'a> {\n         err.span_err(sp, self.diagnostic())\n     }\n \n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     pub fn struct_span_err<S: Into<MultiSpan>>(\n         &self,\n         sp: S,"}, {"sha": "5785921fb1eda3b14f6d517700aa05c9ab01daa8", "filename": "compiler/rustc_privacy/Cargo.toml", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_privacy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_privacy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2FCargo.toml?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -4,14 +4,15 @@ version = \"0.0.0\"\n edition = \"2021\"\n \n [dependencies]\n-rustc_middle = { path = \"../rustc_middle\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_attr = { path = \"../rustc_attr\" }\n+rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_hir = { path = \"../rustc_hir\" }\n-rustc_typeck = { path = \"../rustc_typeck\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n+rustc_middle = { path = \"../rustc_middle\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n-rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n+rustc_typeck = { path = \"../rustc_typeck\" }\n tracing = \"0.1\""}, {"sha": "482721d373ab7ee0857b72b97924de9d9ad426d9", "filename": "compiler/rustc_privacy/src/errors.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_privacy%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_privacy%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Ferrors.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -0,0 +1,75 @@\n+use rustc_macros::{SessionDiagnostic, SessionSubdiagnostic};\n+use rustc_span::{Span, Symbol};\n+\n+#[derive(SessionDiagnostic)]\n+#[error(privacy::field_is_private, code = \"E0451\")]\n+pub struct FieldIsPrivate {\n+    #[primary_span]\n+    pub span: Span,\n+    pub field_name: Symbol,\n+    pub variant_descr: &'static str,\n+    pub def_path_str: String,\n+    #[subdiagnostic]\n+    pub label: FieldIsPrivateLabel,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum FieldIsPrivateLabel {\n+    #[label(privacy::field_is_private_is_update_syntax_label)]\n+    IsUpdateSyntax {\n+        #[primary_span]\n+        span: Span,\n+        field_name: Symbol,\n+    },\n+    #[label(privacy::field_is_private_label)]\n+    Other {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(privacy::item_is_private)]\n+pub struct ItemIsPrivate<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub kind: &'a str,\n+    pub descr: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(privacy::unnamed_item_is_private)]\n+pub struct UnnamedItemIsPrivate {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: &'static str,\n+}\n+\n+// Duplicate of `InPublicInterface` but with a different error code, shares the same slug.\n+#[derive(SessionDiagnostic)]\n+#[error(privacy::in_public_interface, code = \"E0445\")]\n+pub struct InPublicInterfaceTraits<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub vis_descr: &'static str,\n+    pub kind: &'a str,\n+    pub descr: String,\n+    #[label(privacy::visibility_label)]\n+    pub vis_span: Span,\n+}\n+\n+// Duplicate of `InPublicInterfaceTraits` but with a different error code, shares the same slug.\n+#[derive(SessionDiagnostic)]\n+#[error(privacy::in_public_interface, code = \"E0446\")]\n+pub struct InPublicInterface<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub vis_descr: &'static str,\n+    pub kind: &'a str,\n+    pub descr: String,\n+    #[label(privacy::visibility_label)]\n+    pub vis_span: Span,\n+}"}, {"sha": "238c917bbc33f63fc989f6e7df632d076f7c3d3b", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 53, "deletions": 39, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -1,15 +1,19 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+#![feature(associated_type_defaults)]\n #![feature(control_flow_enum)]\n+#![feature(rustc_private)]\n #![feature(try_blocks)]\n-#![feature(associated_type_defaults)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n+#![cfg_attr(not(bootstrap), deny(rustc::untranslatable_diagnostic))]\n+#![cfg_attr(not(bootstrap), deny(rustc::diagnostic_outside_of_impl))]\n+\n+mod errors;\n \n use rustc_ast::MacroDef;\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::intern::Interned;\n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId, LocalDefIdSet, CRATE_DEF_ID};\n@@ -34,6 +38,11 @@ use std::marker::PhantomData;\n use std::ops::ControlFlow;\n use std::{cmp, fmt, mem};\n \n+use errors::{\n+    FieldIsPrivate, FieldIsPrivateLabel, InPublicInterface, InPublicInterfaceTraits, ItemIsPrivate,\n+    UnnamedItemIsPrivate,\n+};\n+\n ////////////////////////////////////////////////////////////////////////////////\n /// Generic infrastructure used to implement specific visitors below.\n ////////////////////////////////////////////////////////////////////////////////\n@@ -935,23 +944,17 @@ impl<'tcx> NamePrivacyVisitor<'tcx> {\n         let hir_id = self.tcx.hir().local_def_id_to_hir_id(self.current_item);\n         let def_id = self.tcx.adjust_ident_and_get_scope(ident, def.did(), hir_id).1;\n         if !field.vis.is_accessible_from(def_id, self.tcx) {\n-            let label = if in_update_syntax {\n-                format!(\"field `{}` is private\", field.name)\n-            } else {\n-                \"private field\".to_string()\n-            };\n-\n-            struct_span_err!(\n-                self.tcx.sess,\n+            self.tcx.sess.emit_err(FieldIsPrivate {\n                 span,\n-                E0451,\n-                \"field `{}` of {} `{}` is private\",\n-                field.name,\n-                def.variant_descr(),\n-                self.tcx.def_path_str(def.did())\n-            )\n-            .span_label(span, label)\n-            .emit();\n+                field_name: field.name,\n+                variant_descr: def.variant_descr(),\n+                def_path_str: self.tcx.def_path_str(def.did()),\n+                label: if in_update_syntax {\n+                    FieldIsPrivateLabel::IsUpdateSyntax { span, field_name: field.name }\n+                } else {\n+                    FieldIsPrivateLabel::Other { span }\n+                },\n+            });\n         }\n     }\n }\n@@ -1075,11 +1078,11 @@ impl<'tcx> TypePrivacyVisitor<'tcx> {\n     fn check_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool {\n         let is_error = !self.item_is_accessible(def_id);\n         if is_error {\n-            self.tcx\n-                .sess\n-                .struct_span_err(self.span, &format!(\"{} `{}` is private\", kind, descr))\n-                .span_label(self.span, &format!(\"private {}\", kind))\n-                .emit();\n+            self.tcx.sess.emit_err(ItemIsPrivate {\n+                span: self.span,\n+                kind,\n+                descr: descr.to_string(),\n+            });\n         }\n         is_error\n     }\n@@ -1250,13 +1253,10 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n                     hir::QPath::TypeRelative(_, segment) => Some(segment.ident.to_string()),\n                 };\n                 let kind = kind.descr(def_id);\n-                let msg = match name {\n-                    Some(name) => format!(\"{} `{}` is private\", kind, name),\n-                    None => format!(\"{} is private\", kind),\n+                let _ = match name {\n+                    Some(name) => sess.emit_err(ItemIsPrivate { span, kind, descr: name }),\n+                    None => sess.emit_err(UnnamedItemIsPrivate { span, kind }),\n                 };\n-                sess.struct_span_err(span, &msg)\n-                    .span_label(span, &format!(\"private {}\", kind))\n-                    .emit();\n                 return;\n             }\n         }\n@@ -1753,30 +1753,44 @@ impl SearchInterfaceForPrivateItemsVisitor<'_> {\n                     }\n                 }\n             };\n-            let make_msg = || format!(\"{} {} `{}` in public interface\", vis_descr, kind, descr);\n             let span = self.tcx.def_span(self.item_def_id.to_def_id());\n             if self.has_old_errors\n                 || self.in_assoc_ty\n                 || self.tcx.resolutions(()).has_pub_restricted\n             {\n-                let mut err = if kind == \"trait\" {\n-                    struct_span_err!(self.tcx.sess, span, E0445, \"{}\", make_msg())\n-                } else {\n-                    struct_span_err!(self.tcx.sess, span, E0446, \"{}\", make_msg())\n-                };\n+                let descr = descr.to_string();\n                 let vis_span =\n                     self.tcx.sess.source_map().guess_head_span(self.tcx.def_span(def_id));\n-                err.span_label(span, format!(\"can't leak {} {}\", vis_descr, kind));\n-                err.span_label(vis_span, format!(\"`{}` declared as {}\", descr, vis_descr));\n-                err.emit();\n+                if kind == \"trait\" {\n+                    self.tcx.sess.emit_err(InPublicInterfaceTraits {\n+                        span,\n+                        vis_descr,\n+                        kind,\n+                        descr,\n+                        vis_span,\n+                    });\n+                } else {\n+                    self.tcx.sess.emit_err(InPublicInterface {\n+                        span,\n+                        vis_descr,\n+                        kind,\n+                        descr,\n+                        vis_span,\n+                    });\n+                }\n             } else {\n                 let err_code = if kind == \"trait\" { \"E0445\" } else { \"E0446\" };\n                 self.tcx.struct_span_lint_hir(\n                     lint::builtin::PRIVATE_IN_PUBLIC,\n                     hir_id,\n                     span,\n                     |lint| {\n-                        lint.build(&format!(\"{} (error {})\", make_msg(), err_code)).emit();\n+                        lint.build(&format!(\n+                            \"{} (error {})\",\n+                            format!(\"{} {} `{}` in public interface\", vis_descr, kind, descr),\n+                            err_code\n+                        ))\n+                        .emit();\n                     },\n                 );\n             }"}, {"sha": "b5058fd699aca0c900847c7a414081ff973c8ab1", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -280,13 +280,15 @@ impl Session {\n         self.crate_types.set(crate_types).expect(\"`crate_types` was initialized twice\")\n     }\n \n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     pub fn struct_span_warn<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n         msg: impl Into<DiagnosticMessage>,\n     ) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_span_warn(sp, msg)\n     }\n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     pub fn struct_span_warn_with_expectation<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -295,6 +297,7 @@ impl Session {\n     ) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_span_warn_with_expectation(sp, msg, id)\n     }\n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     pub fn struct_span_warn_with_code<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -303,40 +306,47 @@ impl Session {\n     ) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_span_warn_with_code(sp, msg, code)\n     }\n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     pub fn struct_warn(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_warn(msg)\n     }\n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     pub fn struct_warn_with_expectation(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n         id: lint::LintExpectationId,\n     ) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_warn_with_expectation(msg, id)\n     }\n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     pub fn struct_span_allow<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n         msg: impl Into<DiagnosticMessage>,\n     ) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_span_allow(sp, msg)\n     }\n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     pub fn struct_allow(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_allow(msg)\n     }\n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     pub fn struct_expect(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n         id: lint::LintExpectationId,\n     ) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_expect(msg, id)\n     }\n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     pub fn struct_span_err<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n         msg: impl Into<DiagnosticMessage>,\n     ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n         self.diagnostic().struct_span_err(sp, msg)\n     }\n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     pub fn struct_span_err_with_code<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -346,33 +356,38 @@ impl Session {\n         self.diagnostic().struct_span_err_with_code(sp, msg, code)\n     }\n     // FIXME: This method should be removed (every error should have an associated error code).\n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     pub fn struct_err(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n     ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n         self.parse_sess.struct_err(msg)\n     }\n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     pub fn struct_err_with_code(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n         code: DiagnosticId,\n     ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n         self.diagnostic().struct_err_with_code(msg, code)\n     }\n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     pub fn struct_warn_with_code(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n         code: DiagnosticId,\n     ) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_warn_with_code(msg, code)\n     }\n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     pub fn struct_span_fatal<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n         msg: impl Into<DiagnosticMessage>,\n     ) -> DiagnosticBuilder<'_, !> {\n         self.diagnostic().struct_span_fatal(sp, msg)\n     }\n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     pub fn struct_span_fatal_with_code<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -381,13 +396,16 @@ impl Session {\n     ) -> DiagnosticBuilder<'_, !> {\n         self.diagnostic().struct_span_fatal_with_code(sp, msg, code)\n     }\n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     pub fn struct_fatal(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, !> {\n         self.diagnostic().struct_fatal(msg)\n     }\n \n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: impl Into<DiagnosticMessage>) -> ! {\n         self.diagnostic().span_fatal(sp, msg)\n     }\n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     pub fn span_fatal_with_code<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -396,9 +414,11 @@ impl Session {\n     ) -> ! {\n         self.diagnostic().span_fatal_with_code(sp, msg, code)\n     }\n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     pub fn fatal(&self, msg: impl Into<DiagnosticMessage>) -> ! {\n         self.diagnostic().fatal(msg).raise()\n     }\n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     pub fn span_err_or_warn<S: Into<MultiSpan>>(\n         &self,\n         is_warning: bool,\n@@ -411,13 +431,15 @@ impl Session {\n             self.span_err(sp, msg);\n         }\n     }\n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     pub fn span_err<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n         msg: impl Into<DiagnosticMessage>,\n     ) -> ErrorGuaranteed {\n         self.diagnostic().span_err(sp, msg)\n     }\n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     pub fn span_err_with_code<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -426,6 +448,7 @@ impl Session {\n     ) {\n         self.diagnostic().span_err_with_code(sp, msg, code)\n     }\n+    #[cfg_attr(not(bootstrap), rustc_lint_diagnostics)]\n     pub fn err(&self, msg: impl Into<DiagnosticMessage>) -> ErrorGuaranteed {\n         self.diagnostic().err(msg)\n     }"}, {"sha": "aba4f144d4bcc7db0871fb19216c7b3e3dea4bf9", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -28,7 +28,6 @@ use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_infer::infer::resolve::OpportunisticRegionResolver;\n-use rustc_infer::traits::ObligationCauseCode;\n use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::fold::{MaxUniverse, TypeFoldable, TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::subst::Subst;\n@@ -252,22 +251,10 @@ fn project_and_unify_type<'cx, 'tcx>(\n         Err(InProgress) => return ProjectAndUnifyResult::Recursive,\n     };\n     debug!(?normalized, ?obligations, \"project_and_unify_type result\");\n-    let actual = obligation.predicate.term;\n-    // HACK: lazy TAIT would regress src/test/ui/impl-trait/nested-return-type2.rs, so we add\n-    // a back-compat hack hat converts the RPITs into inference vars, just like they were before\n-    // lazy TAIT.\n-    // This does not affect TAITs in general, as tested in the nested-return-type-tait* tests.\n-    let InferOk { value: actual, obligations: new } =\n-        selcx.infcx().replace_opaque_types_with_inference_vars(\n-            actual,\n-            obligation.cause.body_id,\n-            obligation.cause.span,\n-            ObligationCauseCode::MiscObligation,\n-            obligation.param_env,\n-        );\n-    obligations.extend(new);\n-\n-    match infcx.at(&obligation.cause, obligation.param_env).eq(normalized, actual) {\n+    match infcx\n+        .at(&obligation.cause, obligation.param_env)\n+        .eq(normalized, obligation.predicate.term)\n+    {\n         Ok(InferOk { obligations: inferred_obligations, value: () }) => {\n             obligations.extend(inferred_obligations);\n             ProjectAndUnifyResult::Holds(obligations)"}, {"sha": "203e5dff0c77fad78eac07b673ab97306098f550", "filename": "library/alloc/src/boxed/thin.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/library%2Falloc%2Fsrc%2Fboxed%2Fthin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/library%2Falloc%2Fsrc%2Fboxed%2Fthin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed%2Fthin.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -33,6 +33,14 @@ pub struct ThinBox<T: ?Sized> {\n     _marker: PhantomData<T>,\n }\n \n+/// `ThinBox<T>` is `Send` if `T` is `Send` because the data is owned.\n+#[unstable(feature = \"thin_box\", issue = \"92791\")]\n+unsafe impl<T: ?Sized + Send> Send for ThinBox<T> {}\n+\n+/// `ThinBox<T>` is `Sync` if `T` is `Sync` because the data is owned.\n+#[unstable(feature = \"thin_box\", issue = \"92791\")]\n+unsafe impl<T: ?Sized + Sync> Sync for ThinBox<T> {}\n+\n #[unstable(feature = \"thin_box\", issue = \"92791\")]\n impl<T> ThinBox<T> {\n     /// Moves a type to the heap with its `Metadata` stored in the heap allocation instead of on"}, {"sha": "60eb3a6da3a4bf93147a7a5cd103ed380eef6954", "filename": "library/core/src/iter/adapters/chain.rs", "status": "modified", "additions": 19, "deletions": 53, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fchain.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -37,33 +37,6 @@ impl<A, B> Chain<A, B> {\n     }\n }\n \n-/// Fuse the iterator if the expression is `None`.\n-macro_rules! fuse {\n-    ($self:ident . $iter:ident . $($call:tt)+) => {\n-        match $self.$iter {\n-            Some(ref mut iter) => match iter.$($call)+ {\n-                None => {\n-                    $self.$iter = None;\n-                    None\n-                }\n-                item => item,\n-            },\n-            None => None,\n-        }\n-    };\n-}\n-\n-/// Try an iterator method without fusing,\n-/// like an inline `.as_mut().and_then(...)`\n-macro_rules! maybe {\n-    ($self:ident . $iter:ident . $($call:tt)+) => {\n-        match $self.$iter {\n-            Some(ref mut iter) => iter.$($call)+,\n-            None => None,\n-        }\n-    };\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B> Iterator for Chain<A, B>\n where\n@@ -74,10 +47,7 @@ where\n \n     #[inline]\n     fn next(&mut self) -> Option<A::Item> {\n-        match fuse!(self.a.next()) {\n-            None => maybe!(self.b.next()),\n-            item => item,\n-        }\n+        and_then_or_clear(&mut self.a, Iterator::next).or_else(|| self.b.as_mut()?.next())\n     }\n \n     #[inline]\n@@ -161,31 +131,23 @@ where\n             self.a = None;\n         }\n \n-        maybe!(self.b.nth(n))\n+        self.b.as_mut()?.nth(n)\n     }\n \n     #[inline]\n     fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n     where\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        match fuse!(self.a.find(&mut predicate)) {\n-            None => maybe!(self.b.find(predicate)),\n-            item => item,\n-        }\n+        and_then_or_clear(&mut self.a, |a| a.find(&mut predicate))\n+            .or_else(|| self.b.as_mut()?.find(predicate))\n     }\n \n     #[inline]\n     fn last(self) -> Option<A::Item> {\n         // Must exhaust a before b.\n-        let a_last = match self.a {\n-            Some(a) => a.last(),\n-            None => None,\n-        };\n-        let b_last = match self.b {\n-            Some(b) => b.last(),\n-            None => None,\n-        };\n+        let a_last = self.a.and_then(Iterator::last);\n+        let b_last = self.b.and_then(Iterator::last);\n         b_last.or(a_last)\n     }\n \n@@ -220,10 +182,7 @@ where\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<A::Item> {\n-        match fuse!(self.b.next_back()) {\n-            None => maybe!(self.a.next_back()),\n-            item => item,\n-        }\n+        and_then_or_clear(&mut self.b, |b| b.next_back()).or_else(|| self.a.as_mut()?.next_back())\n     }\n \n     #[inline]\n@@ -263,18 +222,16 @@ where\n             self.b = None;\n         }\n \n-        maybe!(self.a.nth_back(n))\n+        self.a.as_mut()?.nth_back(n)\n     }\n \n     #[inline]\n     fn rfind<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n     where\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        match fuse!(self.b.rfind(&mut predicate)) {\n-            None => maybe!(self.a.rfind(predicate)),\n-            item => item,\n-        }\n+        and_then_or_clear(&mut self.b, |b| b.rfind(&mut predicate))\n+            .or_else(|| self.a.as_mut()?.rfind(predicate))\n     }\n \n     fn try_rfold<Acc, F, R>(&mut self, mut acc: Acc, mut f: F) -> R\n@@ -324,3 +281,12 @@ where\n     B: TrustedLen<Item = A::Item>,\n {\n }\n+\n+#[inline]\n+fn and_then_or_clear<T, U>(opt: &mut Option<T>, f: impl FnOnce(&mut T) -> Option<U>) -> Option<U> {\n+    let x = f(opt.as_mut()?);\n+    if x.is_none() {\n+        *opt = None;\n+    }\n+    x\n+}"}, {"sha": "15a120e35a2fa16c75562b84eaed6e60ed79045e", "filename": "library/core/src/iter/adapters/flatten.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -290,20 +290,11 @@ where\n     #[inline]\n     fn next(&mut self) -> Option<U::Item> {\n         loop {\n-            if let Some(ref mut inner) = self.frontiter {\n-                match inner.next() {\n-                    None => self.frontiter = None,\n-                    elt @ Some(_) => return elt,\n-                }\n+            if let elt @ Some(_) = and_then_or_clear(&mut self.frontiter, Iterator::next) {\n+                return elt;\n             }\n             match self.iter.next() {\n-                None => match self.backiter.as_mut()?.next() {\n-                    None => {\n-                        self.backiter = None;\n-                        return None;\n-                    }\n-                    elt @ Some(_) => return elt,\n-                },\n+                None => return and_then_or_clear(&mut self.backiter, Iterator::next),\n                 Some(inner) => self.frontiter = Some(inner.into_iter()),\n             }\n         }\n@@ -436,21 +427,12 @@ where\n     #[inline]\n     fn next_back(&mut self) -> Option<U::Item> {\n         loop {\n-            if let Some(ref mut inner) = self.backiter {\n-                match inner.next_back() {\n-                    None => self.backiter = None,\n-                    elt @ Some(_) => return elt,\n-                }\n+            if let elt @ Some(_) = and_then_or_clear(&mut self.backiter, |b| b.next_back()) {\n+                return elt;\n             }\n             match self.iter.next_back() {\n-                None => match self.frontiter.as_mut()?.next_back() {\n-                    None => {\n-                        self.frontiter = None;\n-                        return None;\n-                    }\n-                    elt @ Some(_) => return elt,\n-                },\n-                next => self.backiter = next.map(IntoIterator::into_iter),\n+                None => return and_then_or_clear(&mut self.frontiter, |f| f.next_back()),\n+                Some(inner) => self.backiter = Some(inner.into_iter()),\n             }\n         }\n     }\n@@ -606,3 +588,12 @@ unsafe impl<T, const N: usize> TrustedConstSize for [T; N] {}\n unsafe impl<T, const N: usize> TrustedConstSize for &'_ [T; N] {}\n #[unstable(feature = \"std_internals\", issue = \"none\")]\n unsafe impl<T, const N: usize> TrustedConstSize for &'_ mut [T; N] {}\n+\n+#[inline]\n+fn and_then_or_clear<T, U>(opt: &mut Option<T>, f: impl FnOnce(&mut T) -> Option<U>) -> Option<U> {\n+    let x = f(opt.as_mut()?);\n+    if x.is_none() {\n+        *opt = None;\n+    }\n+    x\n+}"}, {"sha": "c931445420342bf16c9585ab145d1ca73ab0c910", "filename": "library/core/src/iter/adapters/fuse.rs", "status": "modified", "additions": 21, "deletions": 39, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -29,33 +29,6 @@ impl<I> Fuse<I> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I> FusedIterator for Fuse<I> where I: Iterator {}\n \n-/// Fuse the iterator if the expression is `None`.\n-macro_rules! fuse {\n-    ($self:ident . iter . $($call:tt)+) => {\n-        match $self.iter {\n-            Some(ref mut iter) => match iter.$($call)+ {\n-                None => {\n-                    $self.iter = None;\n-                    None\n-                }\n-                item => item,\n-            },\n-            None => None,\n-        }\n-    };\n-}\n-\n-/// Specialized macro that doesn't check if the expression is `None`.\n-/// (We trust that a `FusedIterator` will fuse itself.)\n-macro_rules! spec {\n-    ($self:ident . iter . $($call:tt)+) => {\n-        match $self.iter {\n-            Some(ref mut iter) => iter.$($call)+,\n-            None => None,\n-        }\n-    };\n-}\n-\n // Any specialized implementation here is made internal\n // to avoid exposing default fns outside this trait.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -281,12 +254,12 @@ where\n \n     #[inline]\n     default fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        fuse!(self.iter.next())\n+        and_then_or_clear(&mut self.iter, Iterator::next)\n     }\n \n     #[inline]\n     default fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        fuse!(self.iter.nth(n))\n+        and_then_or_clear(&mut self.iter, |iter| iter.nth(n))\n     }\n \n     #[inline]\n@@ -308,23 +281,23 @@ where\n     where\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        fuse!(self.iter.find(predicate))\n+        and_then_or_clear(&mut self.iter, |iter| iter.find(predicate))\n     }\n \n     #[inline]\n     default fn next_back(&mut self) -> Option<<I as Iterator>::Item>\n     where\n         I: DoubleEndedIterator,\n     {\n-        fuse!(self.iter.next_back())\n+        and_then_or_clear(&mut self.iter, |iter| iter.next_back())\n     }\n \n     #[inline]\n     default fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item>\n     where\n         I: DoubleEndedIterator,\n     {\n-        fuse!(self.iter.nth_back(n))\n+        and_then_or_clear(&mut self.iter, |iter| iter.nth_back(n))\n     }\n \n     #[inline]\n@@ -348,7 +321,7 @@ where\n         P: FnMut(&Self::Item) -> bool,\n         I: DoubleEndedIterator,\n     {\n-        fuse!(self.iter.rfind(predicate))\n+        and_then_or_clear(&mut self.iter, |iter| iter.rfind(predicate))\n     }\n }\n \n@@ -361,12 +334,12 @@ where\n {\n     #[inline]\n     fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        spec!(self.iter.next())\n+        self.iter.as_mut()?.next()\n     }\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        spec!(self.iter.nth(n))\n+        self.iter.as_mut()?.nth(n)\n     }\n \n     #[inline]\n@@ -387,23 +360,23 @@ where\n     where\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        spec!(self.iter.find(predicate))\n+        self.iter.as_mut()?.find(predicate)\n     }\n \n     #[inline]\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item>\n     where\n         I: DoubleEndedIterator,\n     {\n-        spec!(self.iter.next_back())\n+        self.iter.as_mut()?.next_back()\n     }\n \n     #[inline]\n     fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item>\n     where\n         I: DoubleEndedIterator,\n     {\n-        spec!(self.iter.nth_back(n))\n+        self.iter.as_mut()?.nth_back(n)\n     }\n \n     #[inline]\n@@ -426,6 +399,15 @@ where\n         P: FnMut(&Self::Item) -> bool,\n         I: DoubleEndedIterator,\n     {\n-        spec!(self.iter.rfind(predicate))\n+        self.iter.as_mut()?.rfind(predicate)\n+    }\n+}\n+\n+#[inline]\n+fn and_then_or_clear<T, U>(opt: &mut Option<T>, f: impl FnOnce(&mut T) -> Option<U>) -> Option<U> {\n+    let x = f(opt.as_mut()?);\n+    if x.is_none() {\n+        *opt = None;\n     }\n+    x\n }"}, {"sha": "22059ca0dbe107ec24b6f64c3bf5c6f60f6d1bec", "filename": "library/std/src/sys/hermit/condvar.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fcondvar.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -3,6 +3,7 @@ use crate::ptr;\n use crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n use crate::sys::hermit::abi;\n use crate::sys::locks::Mutex;\n+use crate::sys_common::lazy_box::{LazyBox, LazyInit};\n use crate::time::Duration;\n \n // The implementation is inspired by Andrew D. Birrell's paper\n@@ -14,14 +15,26 @@ pub struct Condvar {\n     sem2: *const c_void,\n }\n \n-pub type MovableCondvar = Condvar;\n+pub(crate) type MovableCondvar = LazyBox<Condvar>;\n+\n+impl LazyInit for Condvar {\n+    fn init() -> Box<Self> {\n+        Box::new(Self::new())\n+    }\n+}\n \n unsafe impl Send for Condvar {}\n unsafe impl Sync for Condvar {}\n \n impl Condvar {\n-    pub const fn new() -> Condvar {\n-        Condvar { counter: AtomicUsize::new(0), sem1: ptr::null(), sem2: ptr::null() }\n+    pub fn new() -> Self {\n+        let mut condvar =\n+            Self { counter: AtomicUsize::new(0), sem1: ptr::null(), sem2: ptr::null() };\n+        unsafe {\n+            let _ = abi::sem_init(&mut condvar.sem1, 0);\n+            let _ = abi::sem_init(&mut condvar.sem2, 0);\n+        }\n+        condvar\n     }\n \n     pub unsafe fn notify_one(&self) {"}, {"sha": "eb15a04ffcffbf7056c77d5db09effab82eac595", "filename": "library/std/src/sys/hermit/mutex.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -175,9 +175,7 @@ impl Mutex {\n     }\n \n     #[inline]\n-    pub unsafe fn init(&mut self) {\n-        self.inner = Spinlock::new(MutexInner::new());\n-    }\n+    pub unsafe fn init(&mut self) {}\n \n     #[inline]\n     pub unsafe fn lock(&self) {"}, {"sha": "9701bab1f660be75a09848c0d4117567d4f649a6", "filename": "library/std/src/sys/hermit/rwlock.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Frwlock.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -1,9 +1,10 @@\n use crate::cell::UnsafeCell;\n-use crate::sys::locks::{Condvar, Mutex};\n+use crate::sys::locks::{MovableCondvar, Mutex};\n+use crate::sys_common::lazy_box::{LazyBox, LazyInit};\n \n pub struct RwLock {\n     lock: Mutex,\n-    cond: Condvar,\n+    cond: MovableCondvar,\n     state: UnsafeCell<State>,\n }\n \n@@ -28,7 +29,11 @@ unsafe impl Sync for RwLock {}\n \n impl RwLock {\n     pub const fn new() -> RwLock {\n-        RwLock { lock: Mutex::new(), cond: Condvar::new(), state: UnsafeCell::new(State::Unlocked) }\n+        RwLock {\n+            lock: Mutex::new(),\n+            cond: MovableCondvar::new(),\n+            state: UnsafeCell::new(State::Unlocked),\n+        }\n     }\n \n     #[inline]"}, {"sha": "279641a46c3d0fd32402b7d9576d7247bf05c151", "filename": "src/test/ui/impl-trait/nested-return-type2.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -1,5 +1,3 @@\n-// check-pass\n-\n trait Duh {}\n \n impl Duh for i32 {}\n@@ -20,11 +18,9 @@ impl<R: Duh, F: FnMut() -> R> Trait for F {\n // the hidden type. We already have obligations registered on the inference\n // var to make it uphold the `: Duh` bound on `Trait::Assoc`. The opaque\n // type does not implement `Duh`, even if its hidden type does.\n-// Lazy TAIT would error out, but we inserted a hack to make it work again,\n-// keeping backwards compatibility.\n fn foo() -> impl Trait<Assoc = impl Send> {\n+    //~^ ERROR `impl Send: Duh` is not satisfied\n     || 42\n }\n \n-fn main() {\n-}\n+fn main() {}"}, {"sha": "f996e99de074208a67bca89e474f2b6f0b4b974a", "filename": "src/test/ui/impl-trait/nested-return-type2.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2.stderr?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -0,0 +1,16 @@\n+error[E0277]: the trait bound `impl Send: Duh` is not satisfied\n+  --> $DIR/nested-return-type2.rs:21:13\n+   |\n+LL | fn foo() -> impl Trait<Assoc = impl Send> {\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Duh` is not implemented for `impl Send`\n+   |\n+   = help: the trait `Duh` is implemented for `i32`\n+note: required because of the requirements on the impl of `Trait` for `[closure@$DIR/nested-return-type2.rs:23:5: 23:10]`\n+  --> $DIR/nested-return-type2.rs:12:31\n+   |\n+LL | impl<R: Duh, F: FnMut() -> R> Trait for F {\n+   |                               ^^^^^     ^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "1db9d33c72aeea1cf4c36ff2eba323f3a254805f", "filename": "src/test/ui/macros/rfc-2011-nicer-assert-messages/codegen.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/baf382e63c023259fa1f9042f8f479f183ca6ed3/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baf382e63c023259fa1f9042f8f479f183ca6ed3/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fcodegen.rs?ref=baf382e63c023259fa1f9042f8f479f183ca6ed3", "patch": "@@ -1,9 +0,0 @@\n-// check-pass\n-// compile-flags: -Z unpretty=expanded\n-\n-#![feature(core_intrinsics, generic_assert, generic_assert_internals)]\n-\n-fn main() {\n-    let elem = 1i32;\n-    assert!(elem == 1);\n-}"}, {"sha": "a590eb3223254be489a166eabbf58545857b2e8c", "filename": "src/test/ui/macros/rfc-2011-nicer-assert-messages/codegen.stdout", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/baf382e63c023259fa1f9042f8f479f183ca6ed3/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fcodegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/baf382e63c023259fa1f9042f8f479f183ca6ed3/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fcodegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fcodegen.stdout?ref=baf382e63c023259fa1f9042f8f479f183ca6ed3", "patch": "@@ -1,29 +0,0 @@\n-#![feature(prelude_import)]\n-#![no_std]\n-// check-pass\n-// compile-flags: -Z unpretty=expanded\n-\n-#![feature(core_intrinsics, generic_assert, generic_assert_internals)]\n-#[prelude_import]\n-use ::std::prelude::rust_2015::*;\n-#[macro_use]\n-extern crate std;\n-\n-fn main() {\n-    let elem = 1i32;\n-    {\n-        #[allow(unused_imports)]\n-        use ::core::asserting::{TryCaptureGeneric, TryCapturePrintable};\n-        let mut __capture0 = ::core::asserting::Capture::new();\n-        let __local_bind0 = &elem;\n-        if !(*{\n-                                (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n-                                __local_bind0\n-                            } == 1) {\n-                {\n-                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: elem == 1\\nWith captures:\\n  elem = \",\n-                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n-                }\n-            }\n-    };\n-}"}, {"sha": "5ec84b08ff80809d4c5d0ab98379bfaa1ae71c96", "filename": "src/test/ui/macros/rfc-2011-nicer-assert-messages/non-consuming-methods-have-optimized-codegen.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fnon-consuming-methods-have-optimized-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fnon-consuming-methods-have-optimized-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fnon-consuming-methods-have-optimized-codegen.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -0,0 +1,32 @@\n+// check-pass\n+// compile-flags: -Z unpretty=expanded\n+\n+#![feature(core_intrinsics, generic_assert, generic_assert_internals)]\n+\n+fn arbitrary_consuming_method_for_demonstration_purposes() {\n+    let elem = 1i32;\n+    assert!(elem as usize);\n+}\n+\n+fn addr_of() {\n+    let elem = 1i32;\n+    assert!(&elem);\n+}\n+\n+fn binary() {\n+    let elem = 1i32;\n+    assert!(elem == 1);\n+    assert!(elem >= 1);\n+    assert!(elem > 0);\n+    assert!(elem < 3);\n+    assert!(elem <= 3);\n+    assert!(elem != 3);\n+}\n+\n+fn unary() {\n+    let elem = &1i32;\n+    assert!(*elem);\n+}\n+\n+fn main() {\n+}"}, {"sha": "90f858f80e6b5ffe340dcf0aa222b962d56b32e1", "filename": "src/test/ui/macros/rfc-2011-nicer-assert-messages/non-consuming-methods-have-optimized-codegen.stdout", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fnon-consuming-methods-have-optimized-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fnon-consuming-methods-have-optimized-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fnon-consuming-methods-have-optimized-codegen.stdout?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -0,0 +1,147 @@\n+#![feature(prelude_import)]\n+#![no_std]\n+// check-pass\n+// compile-flags: -Z unpretty=expanded\n+\n+#![feature(core_intrinsics, generic_assert, generic_assert_internals)]\n+#[prelude_import]\n+use ::std::prelude::rust_2015::*;\n+#[macro_use]\n+extern crate std;\n+\n+fn arbitrary_consuming_method_for_demonstration_purposes() {\n+    let elem = 1i32;\n+    {\n+        #[allow(unused_imports)]\n+        use ::core::asserting::{TryCaptureGeneric, TryCapturePrintable};\n+        let mut __capture0 = ::core::asserting::Capture::new();\n+        let __local_bind0 = &elem;\n+        if ::core::intrinsics::unlikely(!(*{\n+                                    (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n+                                    __local_bind0\n+                                } as usize)) {\n+\n+\n+\n+\n+                {\n+                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: elem as usize\\nWith captures:\\n  elem = \",\n+                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n+                }\n+            }\n+    };\n+}\n+fn addr_of() {\n+    let elem = 1i32;\n+    {\n+        #[allow(unused_imports)]\n+        use ::core::asserting::{TryCaptureGeneric, TryCapturePrintable};\n+        let mut __capture0 = ::core::asserting::Capture::new();\n+        let __local_bind0 = &elem;\n+        if ::core::intrinsics::unlikely(!&*__local_bind0) {\n+                (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n+                {\n+                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: &elem\\nWith captures:\\n  elem = \",\n+                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n+                }\n+            }\n+    };\n+}\n+fn binary() {\n+    let elem = 1i32;\n+    {\n+        #[allow(unused_imports)]\n+        use ::core::asserting::{TryCaptureGeneric, TryCapturePrintable};\n+        let mut __capture0 = ::core::asserting::Capture::new();\n+        let __local_bind0 = &elem;\n+        if ::core::intrinsics::unlikely(!(*__local_bind0 == 1)) {\n+                (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n+                {\n+                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: elem == 1\\nWith captures:\\n  elem = \",\n+                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n+                }\n+            }\n+    };\n+    {\n+        #[allow(unused_imports)]\n+        use ::core::asserting::{TryCaptureGeneric, TryCapturePrintable};\n+        let mut __capture0 = ::core::asserting::Capture::new();\n+        let __local_bind0 = &elem;\n+        if ::core::intrinsics::unlikely(!(*__local_bind0 >= 1)) {\n+                (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n+                {\n+                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: elem >= 1\\nWith captures:\\n  elem = \",\n+                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n+                }\n+            }\n+    };\n+    {\n+        #[allow(unused_imports)]\n+        use ::core::asserting::{TryCaptureGeneric, TryCapturePrintable};\n+        let mut __capture0 = ::core::asserting::Capture::new();\n+        let __local_bind0 = &elem;\n+        if ::core::intrinsics::unlikely(!(*__local_bind0 > 0)) {\n+                (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n+                {\n+                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: elem > 0\\nWith captures:\\n  elem = \",\n+                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n+                }\n+            }\n+    };\n+    {\n+        #[allow(unused_imports)]\n+        use ::core::asserting::{TryCaptureGeneric, TryCapturePrintable};\n+        let mut __capture0 = ::core::asserting::Capture::new();\n+        let __local_bind0 = &elem;\n+        if ::core::intrinsics::unlikely(!(*__local_bind0 < 3)) {\n+                (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n+                {\n+                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: elem < 3\\nWith captures:\\n  elem = \",\n+                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n+                }\n+            }\n+    };\n+    {\n+        #[allow(unused_imports)]\n+        use ::core::asserting::{TryCaptureGeneric, TryCapturePrintable};\n+        let mut __capture0 = ::core::asserting::Capture::new();\n+        let __local_bind0 = &elem;\n+        if ::core::intrinsics::unlikely(!(*__local_bind0 <= 3)) {\n+                (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n+                {\n+                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: elem <= 3\\nWith captures:\\n  elem = \",\n+                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n+                }\n+            }\n+    };\n+    {\n+        #[allow(unused_imports)]\n+        use ::core::asserting::{TryCaptureGeneric, TryCapturePrintable};\n+        let mut __capture0 = ::core::asserting::Capture::new();\n+        let __local_bind0 = &elem;\n+        if ::core::intrinsics::unlikely(!(*__local_bind0 != 3)) {\n+                (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n+                {\n+                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: elem != 3\\nWith captures:\\n  elem = \",\n+                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n+                }\n+            }\n+    };\n+}\n+fn unary() {\n+    let elem = &1i32;\n+    {\n+        #[allow(unused_imports)]\n+        use ::core::asserting::{TryCaptureGeneric, TryCapturePrintable};\n+        let mut __capture0 = ::core::asserting::Capture::new();\n+        let __local_bind0 = &elem;\n+        if ::core::intrinsics::unlikely(!**__local_bind0) {\n+                (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n+                {\n+                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: *elem\\nWith captures:\\n  elem = \",\n+                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n+                }\n+            }\n+    };\n+}\n+fn main() {}"}, {"sha": "8ae84dbb3dcf432b056e9c9649db60c5a543bfb7", "filename": "src/tools/clippy/clippy_lints/src/methods/map_flatten.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg_for_edges;\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::is_trait_method;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n@@ -14,17 +14,14 @@ use super::MAP_FLATTEN;\n pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, map_arg: &Expr<'_>, map_span: Span) {\n     if let Some((caller_ty_name, method_to_use)) = try_get_caller_ty_name_and_method_name(cx, expr, recv, map_arg) {\n         let mut applicability = Applicability::MachineApplicable;\n-        let help_msgs = [\n-            &format!(\"try replacing `map` with `{}`\", method_to_use),\n-            \"and remove the `.flatten()`\",\n-        ];\n+        \n         let closure_snippet = snippet_with_applicability(cx, map_arg.span, \"..\", &mut applicability);\n-        span_lint_and_sugg_for_edges(\n+        span_lint_and_sugg(\n             cx,\n             MAP_FLATTEN,\n             expr.span.with_lo(map_span.lo()),\n             &format!(\"called `map(..).flatten()` on `{}`\", caller_ty_name),\n-            &help_msgs,\n+            &format!(\"try replacing `map` with `{}` and remove the `.flatten()`\", method_to_use),\n             format!(\"{}({})\", method_to_use, closure_snippet),\n             applicability,\n         );"}, {"sha": "3d1208824fa34c10e187f873322b462746105104", "filename": "src/tools/clippy/clippy_lints/src/methods/or_fun_call.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -4,7 +4,6 @@ use clippy_utils::source::{snippet, snippet_with_applicability, snippet_with_mac\n use clippy_utils::ty::{implements_trait, match_type};\n use clippy_utils::{contains_return, is_trait_item, last_path_segment, paths};\n use if_chain::if_chain;\n-use rustc_errors::emitter::MAX_SUGGESTION_HIGHLIGHT_LINES;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n@@ -33,7 +32,6 @@ pub(super) fn check<'tcx>(\n         arg: &hir::Expr<'_>,\n         or_has_args: bool,\n         span: Span,\n-        method_span: Span,\n     ) -> bool {\n         let is_default_default = || is_trait_item(cx, fun, sym::Default);\n \n@@ -56,19 +54,14 @@ pub(super) fn check<'tcx>(\n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let hint = \"unwrap_or_default()\";\n-                let mut sugg_span = span;\n+                let sugg_span = span;\n \n-                let mut sugg: String = format!(\n+                let sugg: String = format!(\n                     \"{}.{}\",\n                     snippet_with_applicability(cx, self_expr.span, \"..\", &mut applicability),\n                     hint\n                 );\n \n-                if sugg.lines().count() > MAX_SUGGESTION_HIGHLIGHT_LINES {\n-                    sugg_span = method_span.with_hi(span.hi());\n-                    sugg = hint.to_string();\n-                }\n-\n                 span_lint_and_sugg(\n                     cx,\n                     OR_FUN_CALL,\n@@ -178,7 +171,7 @@ pub(super) fn check<'tcx>(\n         match inner_arg.kind {\n             hir::ExprKind::Call(fun, or_args) => {\n                 let or_has_args = !or_args.is_empty();\n-                if !check_unwrap_or_default(cx, name, fun, self_arg, arg, or_has_args, expr.span, method_span) {\n+                if !check_unwrap_or_default(cx, name, fun, self_arg, arg, or_has_args, expr.span) {\n                     let fun_span = if or_has_args { None } else { Some(fun.span) };\n                     check_general_case(cx, name, method_span, self_arg, arg, expr.span, fun_span);\n                 }"}, {"sha": "2564099f4dbcac56a0d6e78859b255ce531968e7", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -112,7 +112,6 @@ const LINT_EMISSION_FUNCTIONS: [&[&str]; 8] = [\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_sugg\"],\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_then\"],\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint_hir_and_then\"],\n-    &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_sugg_for_edges\"],\n ];\n const SUGGESTION_DIAGNOSTIC_BUILDER_METHODS: [(&str, bool); 9] = [\n     (\"span_suggestion\", false),"}, {"sha": "7f55db3b31f7070cdfd74801d2608ec4d6f00f6e", "filename": "src/tools/clippy/clippy_utils/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 90, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -8,7 +8,7 @@\n //! Thank you!\n //! ~The `INTERNAL_METADATA_COLLECTOR` lint\n \n-use rustc_errors::{emitter::MAX_SUGGESTION_HIGHLIGHT_LINES, Applicability, Diagnostic, MultiSpan};\n+use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n use rustc_hir::HirId;\n use rustc_lint::{LateContext, Lint, LintContext};\n use rustc_span::source_map::Span;\n@@ -219,95 +219,6 @@ pub fn span_lint_and_sugg<'a, T: LintContext>(\n     });\n }\n \n-/// Like [`span_lint_and_sugg`] with a focus on the edges. The output will either\n-/// emit single span or multispan suggestion depending on the number of its lines.\n-///\n-/// If the given suggestion string has more lines than the maximum display length defined by\n-/// [`MAX_SUGGESTION_HIGHLIGHT_LINES`][`rustc_errors::emitter::MAX_SUGGESTION_HIGHLIGHT_LINES`],\n-/// this function will split the suggestion and span to showcase the change for the top and\n-/// bottom edge of the code. For normal suggestions, in one display window, the help message\n-/// will be combined with a colon.\n-///\n-/// Multipart suggestions like the one being created here currently cannot be\n-/// applied by rustfix (See [rustfix#141](https://github.com/rust-lang/rustfix/issues/141)).\n-/// Testing rustfix with this lint emission function might require a file with\n-/// suggestions that can be fixed and those that can't. See\n-/// [clippy#8520](https://github.com/rust-lang/rust-clippy/pull/8520/files) for\n-/// an example and of this.\n-///\n-/// # Example for a long suggestion\n-///\n-/// ```text\n-/// error: called `map(..).flatten()` on `Option`\n-///   --> $DIR/map_flatten.rs:8:10\n-///    |\n-/// LL |           .map(|x| {\n-///    |  __________^\n-/// LL | |             if x <= 5 {\n-/// LL | |                 Some(x)\n-/// LL | |             } else {\n-/// ...  |\n-/// LL | |         })\n-/// LL | |         .flatten();\n-///    | |__________________^\n-///    |\n-///   = note: `-D clippy::map-flatten` implied by `-D warnings`\n-/// help: try replacing `map` with `and_then`\n-///    |\n-/// LL ~         .and_then(|x| {\n-/// LL +             if x <= 5 {\n-/// LL +                 Some(x)\n-///    |\n-/// help: and remove the `.flatten()`\n-///    |\n-/// LL +                 None\n-/// LL +             }\n-/// LL ~         });\n-///    |\n-/// ```\n-pub fn span_lint_and_sugg_for_edges(\n-    cx: &LateContext<'_>,\n-    lint: &'static Lint,\n-    sp: Span,\n-    msg: &str,\n-    helps: &[&str; 2],\n-    sugg: String,\n-    applicability: Applicability,\n-) {\n-    span_lint_and_then(cx, lint, sp, msg, |diag| {\n-        let sugg_lines_count = sugg.lines().count();\n-        if sugg_lines_count > MAX_SUGGESTION_HIGHLIGHT_LINES {\n-            let sm = cx.sess().source_map();\n-            if let (Ok(line_upper), Ok(line_bottom)) =\n-                (sm.lookup_line(sp.lo()), sm.lookup_line(sp.hi()))\n-            {\n-                let split_idx = MAX_SUGGESTION_HIGHLIGHT_LINES / 2;\n-                let span_upper = sm.span_until_char(\n-                    sp.with_hi(line_upper.sf.lines(|lines| lines[line_upper.line + split_idx])),\n-                    '\\n',\n-                );\n-                let span_bottom = sp.with_lo(line_bottom.sf.lines(|lines| lines[line_bottom.line - split_idx]));\n-\n-                let sugg_lines_vec = sugg.lines().collect::<Vec<&str>>();\n-                let sugg_upper = sugg_lines_vec[..split_idx].join(\"\\n\");\n-                let sugg_bottom = sugg_lines_vec[sugg_lines_count - split_idx..].join(\"\\n\");\n-\n-                diag.span_suggestion(span_upper, helps[0], sugg_upper, applicability);\n-                diag.span_suggestion(span_bottom, helps[1], sugg_bottom, applicability);\n-\n-                return;\n-            }\n-        }\n-        diag.span_suggestion_with_style(\n-            sp,\n-            &helps.join(\", \"),\n-            sugg,\n-            applicability,\n-            rustc_errors::SuggestionStyle::ShowAlways,\n-        );\n-    });\n-}\n-\n /// Create a suggestion made from several `span \u2192 replacement`.\n ///\n /// Note: in the JSON format (used by `compiletest_rs`), the help message will"}, {"sha": "4b2630d6858479b2bafe70e637f53f3ff18ef638", "filename": "src/tools/clippy/tests/ui/map_flatten.stderr", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten.stderr?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -12,14 +12,12 @@ LL | |         .flatten();\n    | |__________________^\n    |\n    = note: `-D clippy::map-flatten` implied by `-D warnings`\n-help: try replacing `map` with `and_then`\n+help: try replacing `map` with `and_then` and remove the `.flatten()`\n    |\n LL ~         .and_then(|x| {\n LL +             if x <= 5 {\n LL +                 Some(x)\n-   |\n-help: and remove the `.flatten()`\n-   |\n+LL +             } else {\n LL +                 None\n LL +             }\n LL ~         });\n@@ -38,14 +36,12 @@ LL | |         })\n LL | |         .flatten();\n    | |__________________^\n    |\n-help: try replacing `map` with `and_then`\n+help: try replacing `map` with `and_then` and remove the `.flatten()`\n    |\n LL ~         .and_then(|x| {\n LL +             if x == 1 {\n LL +                 Ok(x)\n-   |\n-help: and remove the `.flatten()`\n-   |\n+LL +             } else {\n LL +                 Err(0)\n LL +             }\n LL ~         });\n@@ -64,14 +60,13 @@ LL | |         })\n LL | |         .flatten();\n    | |__________________^\n    |\n-help: try replacing `map` with `and_then`\n+help: try replacing `map` with `and_then` and remove the `.flatten()`\n    |\n LL ~         .and_then(|res| {\n LL +             if res > 0 {\n LL +                 do_something();\n-   |\n-help: and remove the `.flatten()`\n-   |\n+LL +                 Ok(res)\n+LL +             } else {\n LL +                 Err(0)\n LL +             }\n LL ~         });\n@@ -90,14 +85,12 @@ LL | |         })\n LL | |         .flatten()\n    | |__________________^\n    |\n-help: try replacing `map` with `filter_map`\n+help: try replacing `map` with `filter_map` and remove the `.flatten()`\n    |\n LL ~         .filter_map(|some_value| {\n LL +             if some_value > 3 {\n LL +                 Some(some_value)\n-   |\n-help: and remove the `.flatten()`\n-   |\n+LL +             } else {\n LL +                 None\n LL +             }\n LL +         })"}, {"sha": "e9b41354c58fa50599e93f2b39a5dc015f61646d", "filename": "src/tools/clippy/tests/ui/map_flatten_fixable.fixed", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten_fixable.fixed?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -59,8 +59,6 @@ fn issue8878() {\n         .and_then(|_| {\n // we need some newlines\n // so that the span is big enough\n-// we need some newlines\n-// so that the span is big enough\n // for a splitted output of the diagnostic\n             Some(\"\")\n  // whitespace beforehand is important as well"}, {"sha": "f3b82ad08d0fc3c61c31cb53e46c035c06789440", "filename": "src/tools/clippy/tests/ui/map_flatten_fixable.stderr", "status": "modified", "additions": 9, "deletions": 45, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten_fixable.stderr?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -2,79 +2,45 @@ error: called `map(..).flatten()` on `Iterator`\n   --> $DIR/map_flatten_fixable.rs:18:47\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id).flatten().collect();\n-   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^ help: try replacing `map` with `filter_map` and remove the `.flatten()`: `filter_map(option_id)`\n    |\n    = note: `-D clippy::map-flatten` implied by `-D warnings`\n-help: try replacing `map` with `filter_map`, and remove the `.flatten()`\n-   |\n-LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().filter_map(option_id).collect();\n-   |                                               ~~~~~~~~~~~~~~~~~~~~~\n \n error: called `map(..).flatten()` on `Iterator`\n   --> $DIR/map_flatten_fixable.rs:19:47\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id_ref).flatten().collect();\n-   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: try replacing `map` with `filter_map`, and remove the `.flatten()`\n-   |\n-LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().filter_map(option_id_ref).collect();\n-   |                                               ~~~~~~~~~~~~~~~~~~~~~~~~~\n+   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try replacing `map` with `filter_map` and remove the `.flatten()`: `filter_map(option_id_ref)`\n \n error: called `map(..).flatten()` on `Iterator`\n   --> $DIR/map_flatten_fixable.rs:20:47\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id_closure).flatten().collect();\n-   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: try replacing `map` with `filter_map`, and remove the `.flatten()`\n-   |\n-LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().filter_map(option_id_closure).collect();\n-   |                                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try replacing `map` with `filter_map` and remove the `.flatten()`: `filter_map(option_id_closure)`\n \n error: called `map(..).flatten()` on `Iterator`\n   --> $DIR/map_flatten_fixable.rs:21:47\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| x.checked_add(1)).flatten().collect();\n-   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: try replacing `map` with `filter_map`, and remove the `.flatten()`\n-   |\n-LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().filter_map(|x| x.checked_add(1)).collect();\n-   |                                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try replacing `map` with `filter_map` and remove the `.flatten()`: `filter_map(|x| x.checked_add(1))`\n \n error: called `map(..).flatten()` on `Iterator`\n   --> $DIR/map_flatten_fixable.rs:24:47\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| 0..x).flatten().collect();\n-   |                                               ^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: try replacing `map` with `flat_map`, and remove the `.flatten()`\n-   |\n-LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().flat_map(|x| 0..x).collect();\n-   |                                               ~~~~~~~~~~~~~~~~~~\n+   |                                               ^^^^^^^^^^^^^^^^^^^^^^^ help: try replacing `map` with `flat_map` and remove the `.flatten()`: `flat_map(|x| 0..x)`\n \n error: called `map(..).flatten()` on `Option`\n   --> $DIR/map_flatten_fixable.rs:27:40\n    |\n LL |     let _: Option<_> = (Some(Some(1))).map(|x| x).flatten();\n-   |                                        ^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: try replacing `map` with `and_then`, and remove the `.flatten()`\n-   |\n-LL |     let _: Option<_> = (Some(Some(1))).and_then(|x| x);\n-   |                                        ~~~~~~~~~~~~~~~\n+   |                                        ^^^^^^^^^^^^^^^^^^^^ help: try replacing `map` with `and_then` and remove the `.flatten()`: `and_then(|x| x)`\n \n error: called `map(..).flatten()` on `Result`\n   --> $DIR/map_flatten_fixable.rs:30:42\n    |\n LL |     let _: Result<_, &str> = (Ok(Ok(1))).map(|x| x).flatten();\n-   |                                          ^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: try replacing `map` with `and_then`, and remove the `.flatten()`\n-   |\n-LL |     let _: Result<_, &str> = (Ok(Ok(1))).and_then(|x| x);\n-   |                                          ~~~~~~~~~~~~~~~\n+   |                                          ^^^^^^^^^^^^^^^^^^^^ help: try replacing `map` with `and_then` and remove the `.flatten()`: `and_then(|x| x)`\n \n error: called `map(..).flatten()` on `Option`\n   --> $DIR/map_flatten_fixable.rs:59:10\n@@ -89,14 +55,12 @@ LL | |         })\n LL | |         .flatten();\n    | |__________________^\n    |\n-help: try replacing `map` with `and_then`\n+help: try replacing `map` with `and_then` and remove the `.flatten()`\n    |\n LL ~         .and_then(|_| {\n LL + // we need some newlines\n LL + // so that the span is big enough\n-   |\n-help: and remove the `.flatten()`\n-   |\n+LL + // for a splitted output of the diagnostic\n LL +             Some(\"\")\n LL +  // whitespace beforehand is important as well\n LL ~         });"}, {"sha": "123aed40251e2a639a63a6b630fc6a084944e02c", "filename": "src/tools/clippy/tests/ui/or_fun_call.fixed", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_fun_call.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_fun_call.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_fun_call.fixed?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -185,8 +185,7 @@ mod issue8239 {\n             .reduce(|mut acc, f| {\n                 acc.push_str(&f);\n                 acc\n-            })\n-            .unwrap_or_default();\n+            }).unwrap_or_default();\n     }\n \n     fn more_to_max_suggestion_highest_lines_1() {\n@@ -198,8 +197,7 @@ mod issue8239 {\n                 let _ = \"\";\n                 acc.push_str(&f);\n                 acc\n-            })\n-            .unwrap_or_default();\n+            }).unwrap_or_default();\n     }\n \n     fn equal_to_max_suggestion_highest_lines() {"}, {"sha": "dfe15654bc32c05db6992bfde425b6ba40915883", "filename": "src/tools/clippy/tests/ui/or_fun_call.stderr", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_fun_call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_fun_call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_fun_call.stderr?ref=00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "patch": "@@ -109,16 +109,50 @@ LL |         None.unwrap_or( unsafe { ptr_to_ref(s) }    );\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| unsafe { ptr_to_ref(s) })`\n \n error: use of `unwrap_or` followed by a call to `new`\n-  --> $DIR/or_fun_call.rs:189:14\n+  --> $DIR/or_fun_call.rs:182:9\n+   |\n+LL | /         frames\n+LL | |             .iter()\n+LL | |             .map(|f: &String| f.to_lowercase())\n+LL | |             .reduce(|mut acc, f| {\n+...  |\n+LL | |             })\n+LL | |             .unwrap_or(String::new());\n+   | |_____________________________________^\n+   |\n+help: try this\n+   |\n+LL ~         frames\n+LL +             .iter()\n+LL +             .map(|f: &String| f.to_lowercase())\n+LL +             .reduce(|mut acc, f| {\n+LL +                 acc.push_str(&f);\n+LL +                 acc\n+LL ~             }).unwrap_or_default();\n    |\n-LL |             .unwrap_or(String::new());\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a call to `new`\n-  --> $DIR/or_fun_call.rs:202:14\n+  --> $DIR/or_fun_call.rs:195:9\n+   |\n+LL | /         iter.map(|f: &String| f.to_lowercase())\n+LL | |             .reduce(|mut acc, f| {\n+LL | |                 let _ = \"\";\n+LL | |                 let _ = \"\";\n+...  |\n+LL | |             })\n+LL | |             .unwrap_or(String::new());\n+   | |_____________________________________^\n+   |\n+help: try this\n+   |\n+LL ~         iter.map(|f: &String| f.to_lowercase())\n+LL +             .reduce(|mut acc, f| {\n+LL +                 let _ = \"\";\n+LL +                 let _ = \"\";\n+LL +                 acc.push_str(&f);\n+LL +                 acc\n+LL ~             }).unwrap_or_default();\n    |\n-LL |             .unwrap_or(String::new());\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a call to `new`\n   --> $DIR/or_fun_call.rs:208:9"}]}