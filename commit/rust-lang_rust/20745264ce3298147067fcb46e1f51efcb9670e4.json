{"sha": "20745264ce3298147067fcb46e1f51efcb9670e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwNzQ1MjY0Y2UzMjk4MTQ3MDY3ZmNiNDZlMWY1MWVmY2I5NjcwZTQ=", "commit": {"author": {"name": "Ed Schouten", "email": "ed@nuxi.nl", "date": "2018-01-08T09:51:25Z"}, "committer": {"name": "Ed Schouten", "email": "ed@nuxi.nl", "date": "2018-01-11T10:21:54Z"}, "message": "Implement libstd for CloudABI.\n\nThough CloudABI is strongly inspired by POSIX, its absence of features\nthat don't work well with capability-based sandboxing makes it different\nenough that adding bits to sys/unix will make things a mess. This change\ntherefore adds CloudABI specific platform code under sys/cloudabi and\nborrows parts from sys/unix that can be used without changes.\n\nOne of the goals of this implementation is to build as much as possible\ndirectly on top of CloudABI's system call layer, as opposed to using the\nC library. This is preferred, as the system call layer is supposed to be\nstable, whereas the C library ABI technically is not. An advantage of\nthis approach is that it allows us to implement certain interfaces, such\nas mutexes and condition variables more optimally. They can be lighter\nthan the ones provided by pthreads.\n\nThis change disables some modules that cannot realistically be\nimplemented right now. For example, libstd's pathname abstraction is not\ndesigned with POSIX *at() (e.g., openat()) in mind. The *at() functions\nare the only set of file system APIs available on CloudABI. There is no\nglobal file system namespace, nor a process working directory.\nDiscussions on how to port these modules over are outside the scope of\nthis change.\n\nApart from this change, there are still some other minor fixups that\nneed to be made to platform independent code to make things build. These\nwill be sent out separately, so they can be reviewed more thoroughly.", "tree": {"sha": "e7bf3742e2a7c55be12a58e88f81313cbae71102", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7bf3742e2a7c55be12a58e88f81313cbae71102"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20745264ce3298147067fcb46e1f51efcb9670e4", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20745264ce3298147067fcb46e1f51efcb9670e4", "html_url": "https://github.com/rust-lang/rust/commit/20745264ce3298147067fcb46e1f51efcb9670e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20745264ce3298147067fcb46e1f51efcb9670e4/comments", "author": {"login": "EdSchouten", "id": 736085, "node_id": "MDQ6VXNlcjczNjA4NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/736085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/EdSchouten", "html_url": "https://github.com/EdSchouten", "followers_url": "https://api.github.com/users/EdSchouten/followers", "following_url": "https://api.github.com/users/EdSchouten/following{/other_user}", "gists_url": "https://api.github.com/users/EdSchouten/gists{/gist_id}", "starred_url": "https://api.github.com/users/EdSchouten/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/EdSchouten/subscriptions", "organizations_url": "https://api.github.com/users/EdSchouten/orgs", "repos_url": "https://api.github.com/users/EdSchouten/repos", "events_url": "https://api.github.com/users/EdSchouten/events{/privacy}", "received_events_url": "https://api.github.com/users/EdSchouten/received_events", "type": "User", "site_admin": false}, "committer": {"login": "EdSchouten", "id": 736085, "node_id": "MDQ6VXNlcjczNjA4NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/736085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/EdSchouten", "html_url": "https://github.com/EdSchouten", "followers_url": "https://api.github.com/users/EdSchouten/followers", "following_url": "https://api.github.com/users/EdSchouten/following{/other_user}", "gists_url": "https://api.github.com/users/EdSchouten/gists{/gist_id}", "starred_url": "https://api.github.com/users/EdSchouten/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/EdSchouten/subscriptions", "organizations_url": "https://api.github.com/users/EdSchouten/orgs", "repos_url": "https://api.github.com/users/EdSchouten/repos", "events_url": "https://api.github.com/users/EdSchouten/events{/privacy}", "received_events_url": "https://api.github.com/users/EdSchouten/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "795e173a7640b02677e45f0bee9fd25f05c13d29", "url": "https://api.github.com/repos/rust-lang/rust/commits/795e173a7640b02677e45f0bee9fd25f05c13d29", "html_url": "https://github.com/rust-lang/rust/commit/795e173a7640b02677e45f0bee9fd25f05c13d29"}], "stats": {"total": 1165, "additions": 1165, "deletions": 0}, "files": [{"sha": "606ba488b6fb7b1d7b4fdf1834f61bf53cf8d042", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=20745264ce3298147067fcb46e1f51efcb9670e4", "patch": "@@ -473,16 +473,21 @@ pub mod f64;\n pub mod thread;\n pub mod ascii;\n pub mod collections;\n+#[cfg(not(target_os = \"cloudabi\"))]\n pub mod env;\n pub mod error;\n pub mod ffi;\n+#[cfg(not(target_os = \"cloudabi\"))]\n pub mod fs;\n pub mod io;\n+#[cfg(not(target_os = \"cloudabi\"))]\n pub mod net;\n pub mod num;\n pub mod os;\n pub mod panic;\n+#[cfg(not(target_os = \"cloudabi\"))]\n pub mod path;\n+#[cfg(not(target_os = \"cloudabi\"))]\n pub mod process;\n pub mod sync;\n pub mod time;"}, {"sha": "81a4d29342301cf54938459787b2c2f627519a60", "filename": "src/libstd/sys/cloudabi/abi/mod.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fmod.rs?ref=20745264ce3298147067fcb46e1f51efcb9670e4", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[allow(warnings)]\n+mod cloudabi;\n+pub use self::cloudabi::*;"}, {"sha": "f076ab51897016c071ec9901be6eda818a5ee39e", "filename": "src/libstd/sys/cloudabi/args.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Fsys%2Fcloudabi%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Fsys%2Fcloudabi%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fargs.rs?ref=20745264ce3298147067fcb46e1f51efcb9670e4", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[allow(dead_code)]\n+pub fn init(_: isize, _: *const *const u8) {}\n+\n+#[allow(dead_code)]\n+pub fn cleanup() {}"}, {"sha": "33d931792375d4270dd9966da933eeb7985d82a1", "filename": "src/libstd/sys/cloudabi/backtrace.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Fsys%2Fcloudabi%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Fsys%2Fcloudabi%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fbacktrace.rs?ref=20745264ce3298147067fcb46e1f51efcb9670e4", "patch": "@@ -0,0 +1,121 @@\n+// Copyright 2014-2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use error::Error;\n+use ffi::CStr;\n+use intrinsics;\n+use io;\n+use libc;\n+use sys_common::backtrace::Frame;\n+use unwind as uw;\n+\n+pub struct BacktraceContext;\n+\n+struct Context<'a> {\n+    idx: usize,\n+    frames: &'a mut [Frame],\n+}\n+\n+#[derive(Debug)]\n+struct UnwindError(uw::_Unwind_Reason_Code);\n+\n+impl Error for UnwindError {\n+    fn description(&self) -> &'static str {\n+        \"unexpected return value while unwinding\"\n+    }\n+}\n+\n+impl ::fmt::Display for UnwindError {\n+    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+        write!(f, \"{}: {:?}\", self.description(), self.0)\n+    }\n+}\n+\n+#[inline(never)] // if we know this is a function call, we can skip it when\n+                 // tracing\n+pub fn unwind_backtrace(frames: &mut [Frame]) -> io::Result<(usize, BacktraceContext)> {\n+    let mut cx = Context { idx: 0, frames };\n+    let result_unwind =\n+        unsafe { uw::_Unwind_Backtrace(trace_fn, &mut cx as *mut Context as *mut libc::c_void) };\n+    // See libunwind:src/unwind/Backtrace.c for the return values.\n+    // No, there is no doc.\n+    match result_unwind {\n+        // These return codes seem to be benign and need to be ignored for backtraces\n+        // to show up properly on all tested platforms.\n+        uw::_URC_END_OF_STACK | uw::_URC_FATAL_PHASE1_ERROR | uw::_URC_FAILURE => {\n+            Ok((cx.idx, BacktraceContext))\n+        }\n+        _ => Err(io::Error::new(\n+            io::ErrorKind::Other,\n+            UnwindError(result_unwind),\n+        )),\n+    }\n+}\n+\n+extern \"C\" fn trace_fn(\n+    ctx: *mut uw::_Unwind_Context,\n+    arg: *mut libc::c_void,\n+) -> uw::_Unwind_Reason_Code {\n+    let cx = unsafe { &mut *(arg as *mut Context) };\n+    let mut ip_before_insn = 0;\n+    let mut ip = unsafe { uw::_Unwind_GetIPInfo(ctx, &mut ip_before_insn) as *mut libc::c_void };\n+    if !ip.is_null() && ip_before_insn == 0 {\n+        // this is a non-signaling frame, so `ip` refers to the address\n+        // after the calling instruction. account for that.\n+        ip = (ip as usize - 1) as *mut _;\n+    }\n+\n+    let symaddr = unsafe { uw::_Unwind_FindEnclosingFunction(ip) };\n+    if cx.idx < cx.frames.len() {\n+        cx.frames[cx.idx] = Frame {\n+            symbol_addr: symaddr as *mut u8,\n+            exact_position: ip as *mut u8,\n+        };\n+        cx.idx += 1;\n+    }\n+\n+    uw::_URC_NO_REASON\n+}\n+\n+pub fn foreach_symbol_fileline<F>(_: Frame, _: F, _: &BacktraceContext) -> io::Result<bool>\n+where\n+    F: FnMut(&[u8], u32) -> io::Result<()>,\n+{\n+    // No way to obtain this information on CloudABI.\n+    Ok(false)\n+}\n+\n+pub fn resolve_symname<F>(frame: Frame, callback: F, _: &BacktraceContext) -> io::Result<()>\n+where\n+    F: FnOnce(Option<&str>) -> io::Result<()>,\n+{\n+    unsafe {\n+        let mut info: Dl_info = intrinsics::init();\n+        let symname =\n+            if dladdr(frame.exact_position as *mut _, &mut info) == 0 || info.dli_sname.is_null() {\n+                None\n+            } else {\n+                CStr::from_ptr(info.dli_sname).to_str().ok()\n+            };\n+        callback(symname)\n+    }\n+}\n+\n+#[repr(C)]\n+struct Dl_info {\n+    dli_fname: *const libc::c_char,\n+    dli_fbase: *mut libc::c_void,\n+    dli_sname: *const libc::c_char,\n+    dli_saddr: *mut libc::c_void,\n+}\n+\n+extern \"C\" {\n+    fn dladdr(addr: *const libc::c_void, info: *mut Dl_info) -> libc::c_int;\n+}"}, {"sha": "c05c837ade27498fef4e2d144e8a378535aa789b", "filename": "src/libstd/sys/cloudabi/condvar.rs", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Fsys%2Fcloudabi%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Fsys%2Fcloudabi%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fcondvar.rs?ref=20745264ce3298147067fcb46e1f51efcb9670e4", "patch": "@@ -0,0 +1,169 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cell::UnsafeCell;\n+use mem;\n+use sync::atomic::{AtomicU32, Ordering};\n+use sys::cloudabi::abi;\n+use sys::mutex::{self, Mutex};\n+use sys::time::dur2intervals;\n+use time::Duration;\n+\n+extern \"C\" {\n+    #[thread_local]\n+    static __pthread_thread_id: abi::tid;\n+}\n+\n+pub struct Condvar {\n+    condvar: UnsafeCell<AtomicU32>,\n+}\n+\n+unsafe impl Send for Condvar {}\n+unsafe impl Sync for Condvar {}\n+\n+impl Condvar {\n+    pub const fn new() -> Condvar {\n+        Condvar {\n+            condvar: UnsafeCell::new(AtomicU32::new(abi::CONDVAR_HAS_NO_WAITERS.0)),\n+        }\n+    }\n+\n+    pub unsafe fn init(&mut self) {}\n+\n+    pub unsafe fn notify_one(&self) {\n+        let condvar = self.condvar.get();\n+        if (*condvar).load(Ordering::Relaxed) != abi::CONDVAR_HAS_NO_WAITERS.0 {\n+            let ret = abi::condvar_signal(condvar as *mut abi::condvar, abi::scope::PRIVATE, 1);\n+            assert_eq!(\n+                ret,\n+                abi::errno::SUCCESS,\n+                \"Failed to signal on condition variable\"\n+            );\n+        }\n+    }\n+\n+    pub unsafe fn notify_all(&self) {\n+        let condvar = self.condvar.get();\n+        if (*condvar).load(Ordering::Relaxed) != abi::CONDVAR_HAS_NO_WAITERS.0 {\n+            let ret = abi::condvar_signal(\n+                condvar as *mut abi::condvar,\n+                abi::scope::PRIVATE,\n+                abi::nthreads::max_value(),\n+            );\n+            assert_eq!(\n+                ret,\n+                abi::errno::SUCCESS,\n+                \"Failed to broadcast on condition variable\"\n+            );\n+        }\n+    }\n+\n+    pub unsafe fn wait(&self, mutex: &Mutex) {\n+        let mutex = mutex::raw(mutex);\n+        assert_eq!(\n+            (*mutex).load(Ordering::Relaxed) & !abi::LOCK_KERNEL_MANAGED.0,\n+            __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n+            \"This lock is not write-locked by this thread\"\n+        );\n+\n+        // Call into the kernel to wait on the condition variable.\n+        let condvar = self.condvar.get();\n+        let subscription = abi::subscription {\n+            type_: abi::eventtype::CONDVAR,\n+            union: abi::subscription_union {\n+                condvar: abi::subscription_condvar {\n+                    condvar: condvar as *mut abi::condvar,\n+                    condvar_scope: abi::scope::PRIVATE,\n+                    lock: mutex as *mut abi::lock,\n+                    lock_scope: abi::scope::PRIVATE,\n+                },\n+            },\n+            ..mem::zeroed()\n+        };\n+        let mut event: abi::event = mem::uninitialized();\n+        let mut nevents: usize = mem::uninitialized();\n+        let ret = abi::poll(&subscription, &mut event, 1, &mut nevents);\n+        assert_eq!(\n+            ret,\n+            abi::errno::SUCCESS,\n+            \"Failed to wait on condition variable\"\n+        );\n+        assert_eq!(\n+            event.error,\n+            abi::errno::SUCCESS,\n+            \"Failed to wait on condition variable\"\n+        );\n+    }\n+\n+    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n+        let mutex = mutex::raw(mutex);\n+        assert_eq!(\n+            (*mutex).load(Ordering::Relaxed) & !abi::LOCK_KERNEL_MANAGED.0,\n+            __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n+            \"This lock is not write-locked by this thread\"\n+        );\n+\n+        // Call into the kernel to wait on the condition variable.\n+        let condvar = self.condvar.get();\n+        let subscriptions = [\n+            abi::subscription {\n+                type_: abi::eventtype::CONDVAR,\n+                union: abi::subscription_union {\n+                    condvar: abi::subscription_condvar {\n+                        condvar: condvar as *mut abi::condvar,\n+                        condvar_scope: abi::scope::PRIVATE,\n+                        lock: mutex as *mut abi::lock,\n+                        lock_scope: abi::scope::PRIVATE,\n+                    },\n+                },\n+                ..mem::zeroed()\n+            },\n+            abi::subscription {\n+                type_: abi::eventtype::CLOCK,\n+                union: abi::subscription_union {\n+                    clock: abi::subscription_clock {\n+                        clock_id: abi::clockid::MONOTONIC,\n+                        timeout: dur2intervals(&dur),\n+                        ..mem::zeroed()\n+                    },\n+                },\n+                ..mem::zeroed()\n+            },\n+        ];\n+        let mut events: [abi::event; 2] = mem::uninitialized();\n+        let mut nevents: usize = mem::uninitialized();\n+        let ret = abi::poll(subscriptions.as_ptr(), events.as_mut_ptr(), 2, &mut nevents);\n+        assert_eq!(\n+            ret,\n+            abi::errno::SUCCESS,\n+            \"Failed to wait on condition variable\"\n+        );\n+        for i in 0..nevents {\n+            assert_eq!(\n+                events[i].error,\n+                abi::errno::SUCCESS,\n+                \"Failed to wait on condition variable\"\n+            );\n+            if events[i].type_ == abi::eventtype::CONDVAR {\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+\n+    pub unsafe fn destroy(&self) {\n+        let condvar = self.condvar.get();\n+        assert_eq!(\n+            (*condvar).load(Ordering::Relaxed),\n+            abi::CONDVAR_HAS_NO_WAITERS.0,\n+            \"Attempted to destroy a condition variable with blocked threads\"\n+        );\n+    }\n+}"}, {"sha": "06f45fafde7805de79555192bb4b7e2e98fa8a77", "filename": "src/libstd/sys/cloudabi/mod.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs?ref=20745264ce3298147067fcb46e1f51efcb9670e4", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+use libc;\n+use mem;\n+\n+pub mod args;\n+#[cfg(feature = \"backtrace\")]\n+pub mod backtrace;\n+#[path = \"../unix/cmath.rs\"]\n+pub mod cmath;\n+pub mod condvar;\n+#[path = \"../unix/memchr.rs\"]\n+pub mod memchr;\n+pub mod mutex;\n+pub mod os;\n+#[path = \"../unix/os_str.rs\"]\n+pub mod os_str;\n+pub mod rwlock;\n+pub mod stack_overflow;\n+pub mod stdio;\n+pub mod thread;\n+#[path = \"../unix/thread_local.rs\"]\n+pub mod thread_local;\n+pub mod time;\n+\n+mod abi;\n+\n+#[allow(dead_code)]\n+pub fn init() {}\n+\n+pub fn decode_error_kind(errno: i32) -> io::ErrorKind {\n+    match errno {\n+        x if x == abi::errno::ACCES as i32 => io::ErrorKind::PermissionDenied,\n+        x if x == abi::errno::ADDRINUSE as i32 => io::ErrorKind::AddrInUse,\n+        x if x == abi::errno::ADDRNOTAVAIL as i32 => io::ErrorKind::AddrNotAvailable,\n+        x if x == abi::errno::AGAIN as i32 => io::ErrorKind::WouldBlock,\n+        x if x == abi::errno::CONNABORTED as i32 => io::ErrorKind::ConnectionAborted,\n+        x if x == abi::errno::CONNREFUSED as i32 => io::ErrorKind::ConnectionRefused,\n+        x if x == abi::errno::CONNRESET as i32 => io::ErrorKind::ConnectionReset,\n+        x if x == abi::errno::EXIST as i32 => io::ErrorKind::AlreadyExists,\n+        x if x == abi::errno::INTR as i32 => io::ErrorKind::Interrupted,\n+        x if x == abi::errno::INVAL as i32 => io::ErrorKind::InvalidInput,\n+        x if x == abi::errno::NOENT as i32 => io::ErrorKind::NotFound,\n+        x if x == abi::errno::NOTCONN as i32 => io::ErrorKind::NotConnected,\n+        x if x == abi::errno::PERM as i32 => io::ErrorKind::PermissionDenied,\n+        x if x == abi::errno::PIPE as i32 => io::ErrorKind::BrokenPipe,\n+        x if x == abi::errno::TIMEDOUT as i32 => io::ErrorKind::TimedOut,\n+        _ => io::ErrorKind::Other,\n+    }\n+}\n+\n+pub unsafe fn abort_internal() -> ! {\n+    ::core::intrinsics::abort();\n+}\n+\n+pub use libc::strlen;\n+\n+pub fn hashmap_random_keys() -> (u64, u64) {\n+    unsafe {\n+        let mut v = mem::uninitialized();\n+        libc::arc4random_buf(&mut v as *mut _ as *mut libc::c_void, mem::size_of_val(&v));\n+        v\n+    }\n+}"}, {"sha": "d4ba6bcfc806262eeccfc4cec5916babfb62cbe0", "filename": "src/libstd/sys/cloudabi/mutex.rs", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Fsys%2Fcloudabi%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Fsys%2Fcloudabi%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fmutex.rs?ref=20745264ce3298147067fcb46e1f51efcb9670e4", "patch": "@@ -0,0 +1,158 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cell::UnsafeCell;\n+use mem;\n+use sync::atomic::{AtomicU32, Ordering};\n+use sys::cloudabi::abi;\n+use sys::rwlock::{self, RWLock};\n+\n+extern \"C\" {\n+    #[thread_local]\n+    static __pthread_thread_id: abi::tid;\n+}\n+\n+// Implement Mutex using an RWLock. This doesn't introduce any\n+// performance overhead in this environment, as the operations would be\n+// implemented identically.\n+pub struct Mutex(RWLock);\n+\n+pub unsafe fn raw(m: &Mutex) -> *mut AtomicU32 {\n+    rwlock::raw(&m.0)\n+}\n+\n+impl Mutex {\n+    pub const fn new() -> Mutex {\n+        Mutex(RWLock::new())\n+    }\n+\n+    pub unsafe fn init(&mut self) {\n+        // This function should normally reinitialize the mutex after\n+        // moving it to a different memory address. This implementation\n+        // does not require adjustments after moving.\n+    }\n+\n+    pub unsafe fn try_lock(&self) -> bool {\n+        self.0.try_write()\n+    }\n+\n+    pub unsafe fn lock(&self) {\n+        self.0.write()\n+    }\n+\n+    pub unsafe fn unlock(&self) {\n+        self.0.write_unlock()\n+    }\n+\n+    pub unsafe fn destroy(&self) {\n+        self.0.destroy()\n+    }\n+}\n+\n+pub struct ReentrantMutex {\n+    lock: UnsafeCell<AtomicU32>,\n+    recursion: UnsafeCell<u32>,\n+}\n+\n+impl ReentrantMutex {\n+    pub unsafe fn uninitialized() -> ReentrantMutex {\n+        mem::uninitialized()\n+    }\n+\n+    pub unsafe fn init(&mut self) {\n+        self.lock = UnsafeCell::new(AtomicU32::new(abi::LOCK_UNLOCKED.0));\n+        self.recursion = UnsafeCell::new(0);\n+    }\n+\n+    pub unsafe fn try_lock(&self) -> bool {\n+        // Attempt to acquire the lock.\n+        let lock = self.lock.get();\n+        let recursion = self.recursion.get();\n+        if let Err(old) = (*lock).compare_exchange(\n+            abi::LOCK_UNLOCKED.0,\n+            __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n+            Ordering::Acquire,\n+            Ordering::Relaxed,\n+        ) {\n+            // If we fail to acquire the lock, it may be the case\n+            // that we've already acquired it and may need to recurse.\n+            if old & !abi::LOCK_KERNEL_MANAGED.0 == __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0 {\n+                *recursion += 1;\n+                true\n+            } else {\n+                false\n+            }\n+        } else {\n+            // Success.\n+            assert_eq!(*recursion, 0, \"Mutex has invalid recursion count\");\n+            true\n+        }\n+    }\n+\n+    pub unsafe fn lock(&self) {\n+        if !self.try_lock() {\n+            // Call into the kernel to acquire a write lock.\n+            let lock = self.lock.get();\n+            let subscription = abi::subscription {\n+                type_: abi::eventtype::LOCK_WRLOCK,\n+                union: abi::subscription_union {\n+                    lock: abi::subscription_lock {\n+                        lock: lock as *mut abi::lock,\n+                        lock_scope: abi::scope::PRIVATE,\n+                    },\n+                },\n+                ..mem::zeroed()\n+            };\n+            let mut event: abi::event = mem::uninitialized();\n+            let mut nevents: usize = mem::uninitialized();\n+            let ret = abi::poll(&subscription, &mut event, 1, &mut nevents);\n+            assert_eq!(ret, abi::errno::SUCCESS, \"Failed to acquire mutex\");\n+            assert_eq!(event.error, abi::errno::SUCCESS, \"Failed to acquire mutex\");\n+        }\n+    }\n+\n+    pub unsafe fn unlock(&self) {\n+        let lock = self.lock.get();\n+        let recursion = self.recursion.get();\n+        assert_eq!(\n+            (*lock).load(Ordering::Relaxed) & !abi::LOCK_KERNEL_MANAGED.0,\n+            __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n+            \"This mutex is locked by a different thread\"\n+        );\n+\n+        if *recursion > 0 {\n+            *recursion -= 1;\n+        } else if !(*lock)\n+            .compare_exchange(\n+                __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n+                abi::LOCK_UNLOCKED.0,\n+                Ordering::Release,\n+                Ordering::Relaxed,\n+            )\n+            .is_ok()\n+        {\n+            // Lock is managed by kernelspace. Call into the kernel\n+            // to unblock waiting threads.\n+            let ret = abi::lock_unlock(lock as *mut abi::lock, abi::scope::PRIVATE);\n+            assert_eq!(ret, abi::errno::SUCCESS, \"Failed to unlock a mutex\");\n+        }\n+    }\n+\n+    pub unsafe fn destroy(&self) {\n+        let lock = self.lock.get();\n+        let recursion = self.recursion.get();\n+        assert_eq!(\n+            (*lock).load(Ordering::Relaxed),\n+            abi::LOCK_UNLOCKED.0,\n+            \"Attempted to destroy locked mutex\"\n+        );\n+        assert_eq!(*recursion, 0, \"Recursion counter invalid\");\n+    }\n+}"}, {"sha": "93f816196457240ef7ab4354616dcc2c609392a8", "filename": "src/libstd/sys/cloudabi/os.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Fsys%2Fcloudabi%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Fsys%2Fcloudabi%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fos.rs?ref=20745264ce3298147067fcb46e1f51efcb9670e4", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ffi::CStr;\n+use libc::{self, c_int};\n+use str;\n+\n+pub fn errno() -> i32 {\n+    extern \"C\" {\n+        #[thread_local]\n+        static errno: c_int;\n+    }\n+\n+    unsafe { errno as i32 }\n+}\n+\n+/// Gets a detailed string description for the given error number.\n+pub fn error_string(errno: i32) -> String {\n+    // cloudlibc's strerror() is guaranteed to be thread-safe. There is\n+    // thus no need to use strerror_r().\n+    str::from_utf8(unsafe { CStr::from_ptr(libc::strerror(errno)) }.to_bytes())\n+        .unwrap()\n+        .to_owned()\n+}"}, {"sha": "8539aec5e2c07a1cb5ae8427701abb35b7ce0115", "filename": "src/libstd/sys/cloudabi/rwlock.rs", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Fsys%2Fcloudabi%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Fsys%2Fcloudabi%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Frwlock.rs?ref=20745264ce3298147067fcb46e1f51efcb9670e4", "patch": "@@ -0,0 +1,237 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cell::UnsafeCell;\n+use mem;\n+use sync::atomic::{AtomicU32, Ordering};\n+use sys::cloudabi::abi;\n+\n+extern \"C\" {\n+    #[thread_local]\n+    static __pthread_thread_id: abi::tid;\n+}\n+\n+#[thread_local]\n+static mut RDLOCKS_ACQUIRED: u32 = 0;\n+\n+pub struct RWLock {\n+    lock: UnsafeCell<AtomicU32>,\n+}\n+\n+pub unsafe fn raw(r: &RWLock) -> *mut AtomicU32 {\n+    r.lock.get()\n+}\n+\n+unsafe impl Send for RWLock {}\n+unsafe impl Sync for RWLock {}\n+\n+impl RWLock {\n+    pub const fn new() -> RWLock {\n+        RWLock {\n+            lock: UnsafeCell::new(AtomicU32::new(abi::LOCK_UNLOCKED.0)),\n+        }\n+    }\n+\n+    pub unsafe fn try_read(&self) -> bool {\n+        let lock = self.lock.get();\n+        let mut old = abi::LOCK_UNLOCKED.0;\n+        while let Err(cur) =\n+            (*lock).compare_exchange_weak(old, old + 1, Ordering::Acquire, Ordering::Relaxed)\n+        {\n+            if (cur & abi::LOCK_WRLOCKED.0) != 0 {\n+                // Another thread already has a write lock.\n+                assert_ne!(\n+                    old & !abi::LOCK_KERNEL_MANAGED.0,\n+                    __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n+                    \"Attempted to acquire a read lock while holding a write lock\"\n+                );\n+                return false;\n+            } else if (old & abi::LOCK_KERNEL_MANAGED.0) != 0 && RDLOCKS_ACQUIRED == 0 {\n+                // Lock has threads waiting for the lock. Only acquire\n+                // the lock if we have already acquired read locks. In\n+                // that case, it is justified to acquire this lock to\n+                // prevent a deadlock.\n+                return false;\n+            }\n+            old = cur;\n+        }\n+\n+        RDLOCKS_ACQUIRED += 1;\n+        true\n+    }\n+\n+    pub unsafe fn read(&self) {\n+        if !self.try_read() {\n+            // Call into the kernel to acquire a read lock.\n+            let lock = self.lock.get();\n+            let subscription = abi::subscription {\n+                type_: abi::eventtype::LOCK_RDLOCK,\n+                union: abi::subscription_union {\n+                    lock: abi::subscription_lock {\n+                        lock: lock as *mut abi::lock,\n+                        lock_scope: abi::scope::PRIVATE,\n+                    },\n+                },\n+                ..mem::zeroed()\n+            };\n+            let mut event: abi::event = mem::uninitialized();\n+            let mut nevents: usize = mem::uninitialized();\n+            let ret = abi::poll(&subscription, &mut event, 1, &mut nevents);\n+            assert_eq!(ret, abi::errno::SUCCESS, \"Failed to acquire read lock\");\n+            assert_eq!(\n+                event.error,\n+                abi::errno::SUCCESS,\n+                \"Failed to acquire read lock\"\n+            );\n+\n+            RDLOCKS_ACQUIRED += 1;\n+        }\n+    }\n+\n+    pub unsafe fn read_unlock(&self) {\n+        // Perform a read unlock. We can do this in userspace, except when\n+        // other threads are blocked and we are performing the last unlock.\n+        // In that case, call into the kernel.\n+        //\n+        // Other threads may attempt to increment the read lock count,\n+        // meaning that the call into the kernel could be spurious. To\n+        // prevent this from happening, upgrade to a write lock first. This\n+        // allows us to call into the kernel, having the guarantee that the\n+        // lock value will not change in the meantime.\n+        assert!(RDLOCKS_ACQUIRED > 0, \"Bad lock count\");\n+        let mut old = 1;\n+        loop {\n+            let lock = self.lock.get();\n+            if old == 1 | abi::LOCK_KERNEL_MANAGED.0 {\n+                // Last read lock while threads are waiting. Attempt to upgrade\n+                // to a write lock before calling into the kernel to unlock.\n+                if let Err(cur) = (*lock).compare_exchange_weak(\n+                    old,\n+                    __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0 | abi::LOCK_KERNEL_MANAGED.0,\n+                    Ordering::Acquire,\n+                    Ordering::Relaxed,\n+                ) {\n+                    old = cur;\n+                } else {\n+                    // Call into the kernel to unlock.\n+                    let ret = abi::lock_unlock(lock as *mut abi::lock, abi::scope::PRIVATE);\n+                    assert_eq!(ret, abi::errno::SUCCESS, \"Failed to write unlock a rwlock\");\n+                    break;\n+                }\n+            } else {\n+                // No threads waiting or not the last read lock. Just decrement\n+                // the read lock count.\n+                assert_ne!(\n+                    old & !abi::LOCK_KERNEL_MANAGED.0,\n+                    0,\n+                    \"This rwlock is not locked\"\n+                );\n+                assert_eq!(\n+                    old & abi::LOCK_WRLOCKED.0,\n+                    0,\n+                    \"Attempted to read-unlock a write-locked rwlock\"\n+                );\n+                if let Err(cur) = (*lock).compare_exchange_weak(\n+                    old,\n+                    old - 1,\n+                    Ordering::Acquire,\n+                    Ordering::Relaxed,\n+                ) {\n+                    old = cur;\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        RDLOCKS_ACQUIRED -= 1;\n+    }\n+\n+    pub unsafe fn try_write(&self) -> bool {\n+        // Attempt to acquire the lock.\n+        let lock = self.lock.get();\n+        if let Err(old) = (*lock).compare_exchange(\n+            abi::LOCK_UNLOCKED.0,\n+            __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n+            Ordering::Acquire,\n+            Ordering::Relaxed,\n+        ) {\n+            // Failure. Crash upon recursive acquisition.\n+            assert_ne!(\n+                old & !abi::LOCK_KERNEL_MANAGED.0,\n+                __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n+                \"Attempted to recursive write-lock a rwlock\",\n+            );\n+            false\n+        } else {\n+            // Success.\n+            true\n+        }\n+    }\n+\n+    pub unsafe fn write(&self) {\n+        if !self.try_write() {\n+            // Call into the kernel to acquire a write lock.\n+            let lock = self.lock.get();\n+            let subscription = abi::subscription {\n+                type_: abi::eventtype::LOCK_WRLOCK,\n+                union: abi::subscription_union {\n+                    lock: abi::subscription_lock {\n+                        lock: lock as *mut abi::lock,\n+                        lock_scope: abi::scope::PRIVATE,\n+                    },\n+                },\n+                ..mem::zeroed()\n+            };\n+            let mut event: abi::event = mem::uninitialized();\n+            let mut nevents: usize = mem::uninitialized();\n+            let ret = abi::poll(&subscription, &mut event, 1, &mut nevents);\n+            assert_eq!(ret, abi::errno::SUCCESS, \"Failed to acquire write lock\");\n+            assert_eq!(\n+                event.error,\n+                abi::errno::SUCCESS,\n+                \"Failed to acquire write lock\"\n+            );\n+        }\n+    }\n+\n+    pub unsafe fn write_unlock(&self) {\n+        let lock = self.lock.get();\n+        assert_eq!(\n+            (*lock).load(Ordering::Relaxed) & !abi::LOCK_KERNEL_MANAGED.0,\n+            __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n+            \"This rwlock is not write-locked by this thread\"\n+        );\n+\n+        if !(*lock)\n+            .compare_exchange(\n+                __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n+                abi::LOCK_UNLOCKED.0,\n+                Ordering::Release,\n+                Ordering::Relaxed,\n+            )\n+            .is_ok()\n+        {\n+            // Lock is managed by kernelspace. Call into the kernel\n+            // to unblock waiting threads.\n+            let ret = abi::lock_unlock(lock as *mut abi::lock, abi::scope::PRIVATE);\n+            assert_eq!(ret, abi::errno::SUCCESS, \"Failed to write unlock a rwlock\");\n+        }\n+    }\n+\n+    pub unsafe fn destroy(&self) {\n+        let lock = self.lock.get();\n+        assert_eq!(\n+            (*lock).load(Ordering::Relaxed),\n+            abi::LOCK_UNLOCKED.0,\n+            \"Attempted to destroy locked rwlock\"\n+        );\n+    }\n+}"}, {"sha": "5c0b1e5671e1b8d3d2ee855c3d68589ca8ec7dca", "filename": "src/libstd/sys/cloudabi/stack_overflow.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Fsys%2Fcloudabi%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Fsys%2Fcloudabi%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fstack_overflow.rs?ref=20745264ce3298147067fcb46e1f51efcb9670e4", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![cfg_attr(test, allow(dead_code))]\n+\n+pub struct Handler;\n+\n+impl Handler {\n+    pub unsafe fn new() -> Handler {\n+        Handler\n+    }\n+}\n+\n+pub unsafe fn init() {}\n+\n+pub unsafe fn cleanup() {}"}, {"sha": "9519a926471085f92e64217c60a6bb21c5b977e9", "filename": "src/libstd/sys/cloudabi/stdio.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Fsys%2Fcloudabi%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Fsys%2Fcloudabi%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fstdio.rs?ref=20745264ce3298147067fcb46e1f51efcb9670e4", "patch": "@@ -0,0 +1,79 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+use sys::cloudabi::abi;\n+\n+pub struct Stdin(());\n+pub struct Stdout(());\n+pub struct Stderr(());\n+\n+impl Stdin {\n+    pub fn new() -> io::Result<Stdin> {\n+        Ok(Stdin(()))\n+    }\n+\n+    pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {\n+        Ok(0)\n+    }\n+}\n+\n+impl Stdout {\n+    pub fn new() -> io::Result<Stdout> {\n+        Ok(Stdout(()))\n+    }\n+\n+    pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n+        Err(io::Error::new(\n+            io::ErrorKind::BrokenPipe,\n+            \"Stdout is not connected to any output in this environment\",\n+        ))\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+impl Stderr {\n+    pub fn new() -> io::Result<Stderr> {\n+        Ok(Stderr(()))\n+    }\n+\n+    pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n+        Err(io::Error::new(\n+            io::ErrorKind::BrokenPipe,\n+            \"Stderr is not connected to any output in this environment\",\n+        ))\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+// FIXME: right now this raw stderr handle is used in a few places because\n+//        std::io::stderr_raw isn't exposed, but once that's exposed this impl\n+//        should go away\n+impl io::Write for Stderr {\n+    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+        Stderr::write(self, data)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        Stderr::flush(self)\n+    }\n+}\n+\n+pub fn is_ebadf(err: &io::Error) -> bool {\n+    err.raw_os_error() == Some(abi::errno::BADF as i32)\n+}\n+\n+pub const STDIN_BUF_SIZE: usize = ::sys_common::io::DEFAULT_BUF_SIZE;"}, {"sha": "c980ae75261caad971960e712a5259ba0da5cb96", "filename": "src/libstd/sys/cloudabi/thread.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs?ref=20745264ce3298147067fcb46e1f51efcb9670e4", "patch": "@@ -0,0 +1,124 @@\n+// Copyright 2014-2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use alloc::boxed::FnBox;\n+use cmp;\n+use ffi::CStr;\n+use io;\n+use libc;\n+use mem;\n+use ptr;\n+use sys::cloudabi::abi;\n+use sys::time::dur2intervals;\n+use sys_common::thread::*;\n+use time::Duration;\n+\n+pub const DEFAULT_MIN_STACK_SIZE: usize = 2 * 1024 * 1024;\n+\n+pub struct Thread {\n+    id: libc::pthread_t,\n+}\n+\n+// CloudABI has pthread_t as a pointer in which case we still want\n+// a thread to be Send/Sync\n+unsafe impl Send for Thread {}\n+unsafe impl Sync for Thread {}\n+\n+impl Thread {\n+    pub unsafe fn new<'a>(stack: usize, p: Box<FnBox() + 'a>) -> io::Result<Thread> {\n+        let p = box p;\n+        let mut native: libc::pthread_t = mem::zeroed();\n+        let mut attr: libc::pthread_attr_t = mem::zeroed();\n+        assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n+\n+        let stack_size = cmp::max(stack, min_stack_size(&attr));\n+        assert_eq!(libc::pthread_attr_setstacksize(&mut attr, stack_size), 0);\n+\n+        let ret = libc::pthread_create(&mut native, &attr, thread_start, &*p as *const _ as *mut _);\n+        assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n+\n+        return if ret != 0 {\n+            Err(io::Error::from_raw_os_error(ret))\n+        } else {\n+            mem::forget(p); // ownership passed to pthread_create\n+            Ok(Thread { id: native })\n+        };\n+\n+        extern \"C\" fn thread_start(main: *mut libc::c_void) -> *mut libc::c_void {\n+            unsafe {\n+                start_thread(main as *mut u8);\n+            }\n+            ptr::null_mut()\n+        }\n+    }\n+\n+    pub fn yield_now() {\n+        let ret = unsafe { abi::thread_yield() };\n+        debug_assert_eq!(ret, abi::errno::SUCCESS);\n+    }\n+\n+    pub fn set_name(_name: &CStr) {\n+        // CloudABI has no way to set a thread name.\n+    }\n+\n+    pub fn sleep(dur: Duration) {\n+        unsafe {\n+            let subscription = abi::subscription {\n+                type_: abi::eventtype::CLOCK,\n+                union: abi::subscription_union {\n+                    clock: abi::subscription_clock {\n+                        clock_id: abi::clockid::MONOTONIC,\n+                        timeout: dur2intervals(&dur),\n+                        ..mem::zeroed()\n+                    },\n+                },\n+                ..mem::zeroed()\n+            };\n+            let mut event: abi::event = mem::uninitialized();\n+            let mut nevents: usize = mem::uninitialized();\n+            let ret = abi::poll(&subscription, &mut event, 1, &mut nevents);\n+            assert_eq!(ret, abi::errno::SUCCESS);\n+            assert_eq!(event.error, abi::errno::SUCCESS);\n+        }\n+    }\n+\n+    pub fn join(self) {\n+        unsafe {\n+            let ret = libc::pthread_join(self.id, ptr::null_mut());\n+            mem::forget(self);\n+            assert!(\n+                ret == 0,\n+                \"failed to join thread: {}\",\n+                io::Error::from_raw_os_error(ret)\n+            );\n+        }\n+    }\n+}\n+\n+impl Drop for Thread {\n+    fn drop(&mut self) {\n+        let ret = unsafe { libc::pthread_detach(self.id) };\n+        debug_assert_eq!(ret, 0);\n+    }\n+}\n+\n+#[cfg_attr(test, allow(dead_code))]\n+pub mod guard {\n+    pub unsafe fn current() -> Option<usize> {\n+        None\n+    }\n+    pub unsafe fn init() -> Option<usize> {\n+        None\n+    }\n+}\n+\n+fn min_stack_size(_: *const libc::pthread_attr_t) -> usize {\n+    libc::PTHREAD_STACK_MIN\n+}"}, {"sha": "ee12731619aac3bfbae63a38a796ba8984a7ec4d", "filename": "src/libstd/sys/cloudabi/time.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Fsys%2Fcloudabi%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Fsys%2Fcloudabi%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Ftime.rs?ref=20745264ce3298147067fcb46e1f51efcb9670e4", "patch": "@@ -0,0 +1,111 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use mem;\n+use sys::cloudabi::abi;\n+use time::Duration;\n+\n+const NSEC_PER_SEC: abi::timestamp = 1_000_000_000;\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+pub struct Instant {\n+    t: abi::timestamp,\n+}\n+\n+pub fn dur2intervals(dur: &Duration) -> abi::timestamp {\n+    dur.as_secs()\n+        .checked_mul(NSEC_PER_SEC)\n+        .and_then(|nanos| nanos.checked_add(dur.subsec_nanos() as abi::timestamp))\n+        .expect(\"overflow converting duration to nanoseconds\")\n+}\n+\n+impl Instant {\n+    pub fn now() -> Instant {\n+        unsafe {\n+            let mut t = mem::uninitialized();\n+            let ret = abi::clock_time_get(abi::clockid::MONOTONIC, 0, &mut t);\n+            assert_eq!(ret, abi::errno::SUCCESS);\n+            Instant { t: t }\n+        }\n+    }\n+\n+    pub fn sub_instant(&self, other: &Instant) -> Duration {\n+        let diff = self.t\n+            .checked_sub(other.t)\n+            .expect(\"second instant is later than self\");\n+        Duration::new(diff / NSEC_PER_SEC, (diff % NSEC_PER_SEC) as u32)\n+    }\n+\n+    pub fn add_duration(&self, other: &Duration) -> Instant {\n+        Instant {\n+            t: self.t\n+                .checked_add(dur2intervals(other))\n+                .expect(\"overflow when adding duration to instant\"),\n+        }\n+    }\n+\n+    pub fn sub_duration(&self, other: &Duration) -> Instant {\n+        Instant {\n+            t: self.t\n+                .checked_sub(dur2intervals(other))\n+                .expect(\"overflow when subtracting duration from instant\"),\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+pub struct SystemTime {\n+    t: abi::timestamp,\n+}\n+\n+impl SystemTime {\n+    pub fn now() -> SystemTime {\n+        unsafe {\n+            let mut t = mem::uninitialized();\n+            let ret = abi::clock_time_get(abi::clockid::REALTIME, 0, &mut t);\n+            assert_eq!(ret, abi::errno::SUCCESS);\n+            SystemTime { t: t }\n+        }\n+    }\n+\n+    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n+        if self.t >= other.t {\n+            let diff = self.t - other.t;\n+            Ok(Duration::new(\n+                diff / NSEC_PER_SEC,\n+                (diff % NSEC_PER_SEC) as u32,\n+            ))\n+        } else {\n+            let diff = other.t - self.t;\n+            Err(Duration::new(\n+                diff / NSEC_PER_SEC,\n+                (diff % NSEC_PER_SEC) as u32,\n+            ))\n+        }\n+    }\n+\n+    pub fn add_duration(&self, other: &Duration) -> SystemTime {\n+        SystemTime {\n+            t: self.t\n+                .checked_add(dur2intervals(other))\n+                .expect(\"overflow when adding duration to instant\"),\n+        }\n+    }\n+\n+    pub fn sub_duration(&self, other: &Duration) -> SystemTime {\n+        SystemTime {\n+            t: self.t\n+                .checked_sub(dur2intervals(other))\n+                .expect(\"overflow when subtracting duration from instant\"),\n+        }\n+    }\n+}\n+\n+pub const UNIX_EPOCH: SystemTime = SystemTime { t: 0 };"}, {"sha": "a853d8ea69dc75aec7382a3df73c19bb4aea95db", "filename": "src/libstd/sys/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fmod.rs?ref=20745264ce3298147067fcb46e1f51efcb9670e4", "patch": "@@ -39,6 +39,9 @@ cfg_if! {\n     } else if #[cfg(windows)] {\n         mod windows;\n         pub use self::windows::*;\n+    } else if #[cfg(target_os = \"cloudabi\")] {\n+        mod cloudabi;\n+        pub use self::cloudabi::*;\n     } else if #[cfg(target_os = \"redox\")] {\n         mod redox;\n         pub use self::redox::*;"}, {"sha": "ee71e62e4ca123ca3945d1b7b6404296e8399e94", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20745264ce3298147067fcb46e1f51efcb9670e4/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=20745264ce3298147067fcb46e1f51efcb9670e4", "patch": "@@ -43,13 +43,16 @@ pub mod thread_local;\n pub mod util;\n pub mod wtf8;\n pub mod bytestring;\n+#[cfg(not(target_os = \"cloudabi\"))]\n pub mod process;\n \n cfg_if! {\n     if #[cfg(any(target_os = \"redox\", target_os = \"l4re\"))] {\n         pub use sys::net;\n     } else if #[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))] {\n         pub use sys::net;\n+    } else if #[cfg(target_os = \"cloudabi\")] {\n+        // No networking support on CloudABI (yet).\n     } else {\n         pub mod net;\n     }"}]}