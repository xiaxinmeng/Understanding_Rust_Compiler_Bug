{"sha": "dd01870657fa415bb5f1fa1b66dc7d7b1aa3e08c", "node_id": "C_kwDOAAsO6NoAKGRkMDE4NzA2NTdmYTQxNWJiNWYxZmExYjY2ZGM3ZDdiMWFhM2UwOGM", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-23T21:36:42Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-23T21:36:42Z"}, "message": "cargo-miri: use '--config target.runner' rather than the TARGET_RUNNER env vars", "tree": {"sha": "34ee5b863394bda9effe06c6cdea41df7f5a9b70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34ee5b863394bda9effe06c6cdea41df7f5a9b70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd01870657fa415bb5f1fa1b66dc7d7b1aa3e08c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd01870657fa415bb5f1fa1b66dc7d7b1aa3e08c", "html_url": "https://github.com/rust-lang/rust/commit/dd01870657fa415bb5f1fa1b66dc7d7b1aa3e08c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd01870657fa415bb5f1fa1b66dc7d7b1aa3e08c/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2418e82d3375c5c49b097d01bea97e06239918d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2418e82d3375c5c49b097d01bea97e06239918d", "html_url": "https://github.com/rust-lang/rust/commit/b2418e82d3375c5c49b097d01bea97e06239918d"}], "stats": {"total": 91, "additions": 46, "deletions": 45}, "files": [{"sha": "202ac890fabd280a8b333fbde35f7693e64d0ef9", "filename": "cargo-miri/bin.rs", "status": "modified", "additions": 46, "deletions": 45, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/dd01870657fa415bb5f1fa1b66dc7d7b1aa3e08c/cargo-miri%2Fbin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd01870657fa415bb5f1fa1b66dc7d7b1aa3e08c/cargo-miri%2Fbin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fbin.rs?ref=dd01870657fa415bb5f1fa1b66dc7d7b1aa3e08c", "patch": "@@ -9,7 +9,7 @@ use std::ffi::{OsStr, OsString};\n use std::fmt::Write as _;\n use std::fs::{self, File};\n use std::io::{self, BufRead, BufReader, BufWriter, Read, Write};\n-use std::iter::TakeWhile;\n+use std::iter::{self, TakeWhile};\n use std::ops::Not;\n use std::path::{Path, PathBuf};\n use std::process::{self, Command};\n@@ -206,6 +206,14 @@ fn forward_miri_sysroot(cmd: &mut Command) {\n     cmd.arg(sysroot);\n }\n \n+/// Escapes `s` in a way that is suitable for using it as a string literal in TOML syntax.\n+fn escape_for_toml(s: &str) -> String {\n+    // We want to surround this string in quotes `\"`. So we first escape all quotes,\n+    // and also all backslashes (that are used to escape quotes).\n+    let s = s.replace('\\\\', r#\"\\\\\"#).replace('\"', r#\"\\\"\"#);\n+    format!(\"\\\"{}\\\"\", s)\n+}\n+\n /// Returns the path to the `miri` binary\n fn find_miri() -> PathBuf {\n     if let Some(path) = env::var_os(\"MIRI\") {\n@@ -669,7 +677,11 @@ fn phase_cargo_miri(mut args: impl Iterator<Item = String>) {\n     // <https://github.com/rust-lang/miri/pull/1540#issuecomment-693553191> describes an alternative\n     // approach that uses `cargo check`, making that part easier but target and binary handling\n     // harder.\n-    let cargo_miri_path = std::env::current_exe().expect(\"current executable path invalid\");\n+    let cargo_miri_path = std::env::current_exe()\n+        .expect(\"current executable path invalid\")\n+        .into_os_string()\n+        .into_string()\n+        .expect(\"current executable path is not valid UTF-8\");\n     let cargo_cmd = match subcommand {\n         MiriCommand::Forward(s) => s,\n         MiriCommand::Setup => return, // `cargo miri setup` stops here.\n@@ -699,8 +711,8 @@ fn phase_cargo_miri(mut args: impl Iterator<Item = String>) {\n     target_dir.push(\"miri\");\n     cmd.arg(\"--target-dir\").arg(target_dir);\n \n-    // Make sure we know the build target, and cargo does, too.\n-    // This is needed to make the `CARGO_TARGET_*_RUNNER` env var do something,\n+    // Make sure the build target is explicitly set.\n+    // This is needed to make the `target.runner` settings do something,\n     // and it later helps us detect which crates are proc-macro/build-script\n     // (host crates) and which crates are needed for the program itself.\n     let host = version_info().host;\n@@ -714,6 +726,18 @@ fn phase_cargo_miri(mut args: impl Iterator<Item = String>) {\n         &host\n     };\n \n+    let cargo_miri_path_for_toml = escape_for_toml(&cargo_miri_path);\n+    cmd.arg(\"--config\")\n+        .arg(format!(\"target.{target}.runner=[{cargo_miri_path_for_toml}, 'runner']\",));\n+    if &host != target {\n+        // Set ourselves as runner for host and target. (Unit tests of `proc-macro` crates are run on\n+        // the host, so we set the host runner to us in order to skip them.)\n+        // But only do that if host and target are different; setting this command twice otherwise\n+        // makes cargo concatenate the two arrays.\n+        cmd.arg(\"--config\")\n+            .arg(format!(\"target.{host}.runner=[{cargo_miri_path_for_toml}, 'runner']\",));\n+    }\n+\n     // Forward all further arguments after `--` to cargo.\n     cmd.arg(\"--\").args(args);\n \n@@ -743,16 +767,6 @@ fn phase_cargo_miri(mut args: impl Iterator<Item = String>) {\n     // bootstrap `rustc` thing in our way! Instead, we have MIRI_HOST_SYSROOT to use for host builds.\n     cmd.env(\"RUSTC\", &fs::canonicalize(find_miri()).unwrap());\n \n-    let runner_env_name =\n-        |triple: &str| format!(\"CARGO_TARGET_{}_RUNNER\", triple.to_uppercase().replace('-', \"_\"));\n-    let host_runner_env_name = runner_env_name(&host);\n-    let target_runner_env_name = runner_env_name(target);\n-    // Set the target runner to us, so we can interpret the binaries.\n-    cmd.env(&target_runner_env_name, &cargo_miri_path);\n-    // Unit tests of `proc-macro` crates are run on the host, so we set the host runner to\n-    // us in order to skip them.\n-    cmd.env(&host_runner_env_name, &cargo_miri_path);\n-\n     // Set rustdoc to us as well, so we can run doctests.\n     cmd.env(\"RUSTDOC\", &cargo_miri_path);\n \n@@ -1194,38 +1208,25 @@ fn main() {\n         return;\n     }\n \n-    let mut args = args.peekable();\n-    if args.next_if(|a| a == \"miri\").is_some() {\n-        phase_cargo_miri(args);\n-    } else if let Some(arg) = args.peek().cloned() {\n-        // Cargo calls us for everything it does. We could be invoked as rustc, rustdoc, or the runner.\n-\n-        // If the first arg is equal to the RUSTC variable (which should be set at this point),\n-        // then we need to behave as rustc. This is the somewhat counter-intuitive behavior of\n-        // having both RUSTC and RUSTC_WRAPPER set (see\n-        // https://github.com/rust-lang/cargo/issues/10886).\n-        if arg == env::var(\"RUSTC\").unwrap() {\n-            args.next().unwrap(); // consume wrapped RUSTC command.\n-            return phase_rustc(args, RustcPhase::Build);\n-        }\n-        // We have to distinguish the \"runner\" and \"rustdoc\" cases.\n-        // As runner, the first argument is the binary (a file that should exist, with an absolute path);\n-        // as rustdoc, the first argument is a flag (`--something`).\n-        let binary = Path::new(&arg);\n-        if binary.exists() {\n-            assert!(!arg.starts_with(\"--\")); // not a flag\n-            phase_runner(args, RunnerPhase::Cargo);\n-        } else if arg.starts_with(\"--\") {\n-            phase_rustdoc(args);\n-        } else {\n-            show_error(format!(\n-                \"`cargo-miri` called with unexpected first argument `{}`; please only invoke this binary through `cargo miri`\",\n-                arg\n-            ));\n-        }\n-    } else {\n+    let Some(first) = args.next() else {\n         show_error(format!(\n             \"`cargo-miri` called without first argument; please only invoke this binary through `cargo miri`\"\n-        ));\n+        ))\n+    };\n+    match first.as_str() {\n+        \"miri\" => phase_cargo_miri(args),\n+        \"runner\" => phase_runner(args, RunnerPhase::Cargo),\n+        arg if arg == env::var(\"RUSTC\").unwrap() => {\n+            // If the first arg is equal to the RUSTC env ariable (which should be set at this\n+            // point), then we need to behave as rustc. This is the somewhat counter-intuitive\n+            // behavior of having both RUSTC and RUSTC_WRAPPER set\n+            // (see https://github.com/rust-lang/cargo/issues/10886).\n+            phase_rustc(args, RustcPhase::Build)\n+        }\n+        _ => {\n+            // Everything else must be rustdoc. But we need to get `first` \"back onto the iterator\",\n+            // it is some part of the rustdoc invocation.\n+            phase_rustdoc(iter::once(first).chain(args));\n+        }\n     }\n }"}]}