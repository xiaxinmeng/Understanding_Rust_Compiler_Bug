{"sha": "73c1839579a6b5f302f5497189d69c9a61760a6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczYzE4Mzk1NzlhNmI1ZjMwMmY1NDk3MTg5ZDY5YzlhNjE3NjBhNmM=", "commit": {"author": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2013-06-20T01:12:40Z"}, "committer": {"name": "James Miller", "email": "james@aatch.net", "date": "2013-06-20T02:34:22Z"}, "message": "libsyntax: Remove `drop` as a keyword.", "tree": {"sha": "fed8633d718205c7697569e4dec0ed27ae659c5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fed8633d718205c7697569e4dec0ed27ae659c5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73c1839579a6b5f302f5497189d69c9a61760a6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73c1839579a6b5f302f5497189d69c9a61760a6c", "html_url": "https://github.com/rust-lang/rust/commit/73c1839579a6b5f302f5497189d69c9a61760a6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73c1839579a6b5f302f5497189d69c9a61760a6c/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7a69198992fceb7b2c6affb5e0a7ed862ebc090", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7a69198992fceb7b2c6affb5e0a7ed862ebc090", "html_url": "https://github.com/rust-lang/rust/commit/b7a69198992fceb7b2c6affb5e0a7ed862ebc090"}], "stats": {"total": 237, "additions": 202, "deletions": 35}, "files": [{"sha": "fc6f07288f27cc4a308b17ccfbd00ea1da6a6b01", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 202, "deletions": 35, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/73c1839579a6b5f302f5497189d69c9a61760a6c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c1839579a6b5f302f5497189d69c9a61760a6c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=73c1839579a6b5f302f5497189d69c9a61760a6c", "patch": "@@ -400,7 +400,9 @@ impl ident_interner {\n     }\n }\n \n+\n // return a fresh interner, preloaded with special identifiers.\n+#[cfg(stage0)]\n fn mk_fresh_ident_interner() -> @ident_interner {\n     // the indices here must correspond to the numbers in\n     // special_idents.\n@@ -486,6 +488,92 @@ fn mk_fresh_ident_interner() -> @ident_interner {\n     }\n }\n \n+// return a fresh interner, preloaded with special identifiers.\n+#[cfg(not(stage0))]\n+fn mk_fresh_ident_interner() -> @ident_interner {\n+    // the indices here must correspond to the numbers in\n+    // special_idents.\n+    let init_vec = ~[\n+        \"_\",                  // 0\n+        \"anon\",               // 1\n+        \"\",                   // 2\n+        \"unary\",              // 3\n+        \"!\",                  // 4\n+        \"[]\",                 // 5\n+        \"unary-\",             // 6\n+        \"__extensions__\",     // 7\n+        \"self\",               // 8\n+        \"item\",               // 9\n+        \"block\",              // 10\n+        \"stmt\",               // 11\n+        \"pat\",                // 12\n+        \"expr\",               // 13\n+        \"ty\",                 // 14\n+        \"ident\",              // 15\n+        \"path\",               // 16\n+        \"tt\",                 // 17\n+        \"matchers\",           // 18\n+        \"str\",                // 19\n+        \"TyVisitor\",          // 20\n+        \"arg\",                // 21\n+        \"descrim\",            // 22\n+        \"__rust_abi\",         // 23\n+        \"__rust_stack_shim\",  // 24\n+        \"TyDesc\",             // 25\n+        \"main\",               // 26\n+        \"<opaque>\",           // 27\n+        \"blk\",                // 28\n+        \"static\",             // 29\n+        \"intrinsic\",          // 30\n+        \"__foreign_mod__\",    // 31\n+        \"__field__\",          // 32\n+        \"C\",                  // 33\n+        \"Self\",               // 34\n+\n+        \"as\",                 // 35\n+        \"break\",              // 36\n+        \"const\",              // 37\n+        \"copy\",               // 38\n+        \"do\",                 // 39\n+        \"else\",               // 40\n+        \"enum\",               // 41\n+        \"extern\",             // 42\n+        \"false\",              // 43\n+        \"fn\",                 // 44\n+        \"for\",                // 45\n+        \"if\",                 // 46\n+        \"impl\",               // 47\n+        \"let\",                // 48\n+        \"__log\",              // 49\n+        \"loop\",               // 50\n+        \"match\",              // 51\n+        \"mod\",                // 52\n+        \"mut\",                // 53\n+        \"once\",               // 54\n+        \"priv\",               // 55\n+        \"pub\",                // 56\n+        \"pure\",               // 57\n+        \"ref\",                // 58\n+        \"return\",             // 59\n+        \"static\",             // 29 -- also a special ident\n+        \"self\",               //  8 -- also a special ident\n+        \"struct\",             // 60\n+        \"super\",              // 61\n+        \"true\",               // 62\n+        \"trait\",              // 63\n+        \"type\",               // 64\n+        \"unsafe\",             // 65\n+        \"use\",                // 66\n+        \"while\",              // 67\n+\n+        \"be\",                 // 68\n+    ];\n+\n+    @ident_interner {\n+        interner: interner::StrInterner::prefill(init_vec)\n+    }\n+}\n+\n // if an interner exists in TLS, return it. Otherwise, prepare a\n // fresh one.\n pub fn get_ident_interner() -> @ident_interner {\n@@ -612,44 +700,86 @@ pub mod keywords {\n     }\n \n     impl Keyword {\n+        #[cfg(stage0)]\n         pub fn to_ident(&self) -> ident {\n             match *self {\n                 As => ident { name: 35, ctxt: 0 },\n-                   Break => ident { name: 36, ctxt: 0 },\n-                   Const => ident { name: 37, ctxt: 0 },\n-                   Copy => ident { name: 38, ctxt: 0 },\n-                   Do => ident { name: 39, ctxt: 0 },\n-                   Else => ident { name: 41, ctxt: 0 },\n-                   Enum => ident { name: 42, ctxt: 0 },\n-                   Extern => ident { name: 43, ctxt: 0 },\n-                   False => ident { name: 44, ctxt: 0 },\n-                   Fn => ident { name: 45, ctxt: 0 },\n-                   For => ident { name: 46, ctxt: 0 },\n-                   If => ident { name: 47, ctxt: 0 },\n-                   Impl => ident { name: 48, ctxt: 0 },\n-                   Let => ident { name: 49, ctxt: 0 },\n-                   __Log => ident { name: 50, ctxt: 0 },\n-                   Loop => ident { name: 51, ctxt: 0 },\n-                   Match => ident { name: 52, ctxt: 0 },\n-                   Mod => ident { name: 53, ctxt: 0 },\n-                   Mut => ident { name: 54, ctxt: 0 },\n-                   Once => ident { name: 55, ctxt: 0 },\n-                   Priv => ident { name: 56, ctxt: 0 },\n-                   Pub => ident { name: 57, ctxt: 0 },\n-                   Pure => ident { name: 58, ctxt: 0 },\n-                   Ref => ident { name: 59, ctxt: 0 },\n-                   Return => ident { name: 60, ctxt: 0 },\n-                   Static => ident { name: 29, ctxt: 0 },\n-                   Self => ident { name: 8, ctxt: 0 },\n-                   Struct => ident { name: 61, ctxt: 0 },\n-                   Super => ident { name: 62, ctxt: 0 },\n-                   True => ident { name: 63, ctxt: 0 },\n-                   Trait => ident { name: 64, ctxt: 0 },\n-                   Type => ident { name: 65, ctxt: 0 },\n-                   Unsafe => ident { name: 66, ctxt: 0 },\n-                   Use => ident { name: 67, ctxt: 0 },\n-                   While => ident { name: 68, ctxt: 0 },\n-                   Be => ident { name: 69, ctxt: 0 },\n+                Break => ident { name: 36, ctxt: 0 },\n+                Const => ident { name: 37, ctxt: 0 },\n+                Copy => ident { name: 38, ctxt: 0 },\n+                Do => ident { name: 39, ctxt: 0 },\n+                Else => ident { name: 41, ctxt: 0 },\n+                Enum => ident { name: 42, ctxt: 0 },\n+                Extern => ident { name: 43, ctxt: 0 },\n+                False => ident { name: 44, ctxt: 0 },\n+                Fn => ident { name: 45, ctxt: 0 },\n+                For => ident { name: 46, ctxt: 0 },\n+                If => ident { name: 47, ctxt: 0 },\n+                Impl => ident { name: 48, ctxt: 0 },\n+                Let => ident { name: 49, ctxt: 0 },\n+                __Log => ident { name: 50, ctxt: 0 },\n+                Loop => ident { name: 51, ctxt: 0 },\n+                Match => ident { name: 52, ctxt: 0 },\n+                Mod => ident { name: 53, ctxt: 0 },\n+                Mut => ident { name: 54, ctxt: 0 },\n+                Once => ident { name: 55, ctxt: 0 },\n+                Priv => ident { name: 56, ctxt: 0 },\n+                Pub => ident { name: 57, ctxt: 0 },\n+                Pure => ident { name: 58, ctxt: 0 },\n+                Ref => ident { name: 59, ctxt: 0 },\n+                Return => ident { name: 60, ctxt: 0 },\n+                Static => ident { name: 29, ctxt: 0 },\n+                Self => ident { name: 8, ctxt: 0 },\n+                Struct => ident { name: 61, ctxt: 0 },\n+                Super => ident { name: 62, ctxt: 0 },\n+                True => ident { name: 63, ctxt: 0 },\n+                Trait => ident { name: 64, ctxt: 0 },\n+                Type => ident { name: 65, ctxt: 0 },\n+                Unsafe => ident { name: 66, ctxt: 0 },\n+                Use => ident { name: 67, ctxt: 0 },\n+                While => ident { name: 68, ctxt: 0 },\n+                Be => ident { name: 69, ctxt: 0 },\n+            }\n+        }\n+        #[cfg(not(stage0))]\n+        pub fn to_ident(&self) -> ident {\n+            match *self {\n+                As => ident { name: 35, ctxt: 0 },\n+                Break => ident { name: 36, ctxt: 0 },\n+                Const => ident { name: 37, ctxt: 0 },\n+                Copy => ident { name: 38, ctxt: 0 },\n+                Do => ident { name: 39, ctxt: 0 },\n+                Else => ident { name: 40, ctxt: 0 },\n+                Enum => ident { name: 41, ctxt: 0 },\n+                Extern => ident { name: 42, ctxt: 0 },\n+                False => ident { name: 43, ctxt: 0 },\n+                Fn => ident { name: 44, ctxt: 0 },\n+                For => ident { name: 45, ctxt: 0 },\n+                If => ident { name: 46, ctxt: 0 },\n+                Impl => ident { name: 47, ctxt: 0 },\n+                Let => ident { name: 48, ctxt: 0 },\n+                __Log => ident { name: 49, ctxt: 0 },\n+                Loop => ident { name: 50, ctxt: 0 },\n+                Match => ident { name: 51, ctxt: 0 },\n+                Mod => ident { name: 52, ctxt: 0 },\n+                Mut => ident { name: 53, ctxt: 0 },\n+                Once => ident { name: 54, ctxt: 0 },\n+                Priv => ident { name: 55, ctxt: 0 },\n+                Pub => ident { name: 56, ctxt: 0 },\n+                Pure => ident { name: 57, ctxt: 0 },\n+                Ref => ident { name: 58, ctxt: 0 },\n+                Return => ident { name: 59, ctxt: 0 },\n+                Static => ident { name: 29, ctxt: 0 },\n+                Self => ident { name: 8, ctxt: 0 },\n+                Struct => ident { name: 60, ctxt: 0 },\n+                Super => ident { name: 61, ctxt: 0 },\n+                True => ident { name: 62, ctxt: 0 },\n+                Trait => ident { name: 63, ctxt: 0 },\n+                Type => ident { name: 64, ctxt: 0 },\n+                Unsafe => ident { name: 65, ctxt: 0 },\n+                Use => ident { name: 66, ctxt: 0 },\n+                While => ident { name: 67, ctxt: 0 },\n+                Be => ident { name: 68, ctxt: 0 },\n             }\n         }\n     }\n@@ -662,6 +792,7 @@ pub fn is_keyword(kw: keywords::Keyword, tok: &Token) -> bool {\n     }\n }\n \n+#[cfg(stage0)]\n pub fn is_any_keyword(tok: &Token) -> bool {\n     match *tok {\n         token::IDENT(sid, false) => match sid.name {\n@@ -672,6 +803,18 @@ pub fn is_any_keyword(tok: &Token) -> bool {\n     }\n }\n \n+#[cfg(not(stage0))]\n+pub fn is_any_keyword(tok: &Token) -> bool {\n+    match *tok {\n+        token::IDENT(sid, false) => match sid.name {\n+            8 | 29 | 35 .. 68 => true,\n+            _ => false,\n+        },\n+        _ => false\n+    }\n+}\n+\n+#[cfg(stage0)]\n pub fn is_strict_keyword(tok: &Token) -> bool {\n     match *tok {\n         token::IDENT(sid, false) => match sid.name {\n@@ -682,6 +825,18 @@ pub fn is_strict_keyword(tok: &Token) -> bool {\n     }\n }\n \n+#[cfg(not(stage0))]\n+pub fn is_strict_keyword(tok: &Token) -> bool {\n+    match *tok {\n+        token::IDENT(sid, false) => match sid.name {\n+            8 | 29 | 35 .. 67 => true,\n+            _ => false,\n+        },\n+        _ => false,\n+    }\n+}\n+\n+#[cfg(stage0)]\n pub fn is_reserved_keyword(tok: &Token) -> bool {\n     match *tok {\n         token::IDENT(sid, false) => match sid.name {\n@@ -692,6 +847,18 @@ pub fn is_reserved_keyword(tok: &Token) -> bool {\n     }\n }\n \n+#[cfg(not(stage0))]\n+pub fn is_reserved_keyword(tok: &Token) -> bool {\n+    match *tok {\n+        token::IDENT(sid, false) => match sid.name {\n+            68 => true,\n+            _ => false,\n+        },\n+        _ => false,\n+    }\n+}\n+\n+\n #[cfg(test)]\n mod test {\n     use super::*;"}]}