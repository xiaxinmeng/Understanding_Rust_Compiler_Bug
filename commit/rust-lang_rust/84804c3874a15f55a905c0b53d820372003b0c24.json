{"sha": "84804c3874a15f55a905c0b53d820372003b0c24", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0ODA0YzM4NzRhMTVmNTVhOTA1YzBiNTNkODIwMzcyMDAzYjBjMjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-26T21:09:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-26T21:09:52Z"}, "message": "Auto merge of #51814 - MajorBreakfast:local-task-obj, r=cramertj\n\nAdd `LocalTaskObj` to `core::task`\n\n- Splits `libcore/task.rs` into submodules\n- Adds `LocalTaskObj` and `SpawnLocalObjError` (-> [Commit for this](https://github.com/rust-lang/rust/commit/433e6b31a75eea5ce45493acc63eae462d740338))\n\nNote: To make reviewing easy, both actions have their own commit\n\nr? @cramertj", "tree": {"sha": "d154389d90ec40f29ea4633d6be6c1add3c9ee6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d154389d90ec40f29ea4633d6be6c1add3c9ee6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84804c3874a15f55a905c0b53d820372003b0c24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84804c3874a15f55a905c0b53d820372003b0c24", "html_url": "https://github.com/rust-lang/rust/commit/84804c3874a15f55a905c0b53d820372003b0c24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84804c3874a15f55a905c0b53d820372003b0c24/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cc3d44b935fb97f19fed4395861cbc8d6bba0e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cc3d44b935fb97f19fed4395861cbc8d6bba0e4", "html_url": "https://github.com/rust-lang/rust/commit/9cc3d44b935fb97f19fed4395861cbc8d6bba0e4"}, {"sha": "b39ea1d18f19f9cee3ad271a802b3157f9827f51", "url": "https://api.github.com/repos/rust-lang/rust/commits/b39ea1d18f19f9cee3ad271a802b3157f9827f51", "html_url": "https://github.com/rust-lang/rust/commit/b39ea1d18f19f9cee3ad271a802b3157f9827f51"}], "stats": {"total": 751, "additions": 455, "deletions": 296}, "files": [{"sha": "6a05ef680889aeb4d12ba634a4234e164f6a2523", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/84804c3874a15f55a905c0b53d820372003b0c24/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84804c3874a15f55a905c0b53d820372003b0c24/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=84804c3874a15f55a905c0b53d820372003b0c24", "patch": "@@ -66,7 +66,7 @@ use core::marker::{Unpin, Unsize};\n use core::mem::{self, PinMut};\n use core::ops::{CoerceUnsized, Deref, DerefMut, Generator, GeneratorState};\n use core::ptr::{self, NonNull, Unique};\n-use core::task::{Context, Poll, UnsafeTask, TaskObj};\n+use core::task::{Context, Poll, UnsafeTask, TaskObj, LocalTaskObj};\n use core::convert::From;\n \n use raw_vec::RawVec;\n@@ -933,7 +933,7 @@ impl<'a, F: ?Sized + Future> Future for PinBox<F> {\n }\n \n #[unstable(feature = \"futures_api\", issue = \"50547\")]\n-unsafe impl<F: Future<Output = ()> + Send + 'static> UnsafeTask for PinBox<F> {\n+unsafe impl<F: Future<Output = ()> + 'static> UnsafeTask for PinBox<F> {\n     fn into_raw(self) -> *mut () {\n         PinBox::into_raw(self) as *mut ()\n     }\n@@ -962,3 +962,17 @@ impl<F: Future<Output = ()> + Send + 'static> From<Box<F>> for TaskObj {\n         TaskObj::new(PinBox::from(boxed))\n     }\n }\n+\n+#[unstable(feature = \"futures_api\", issue = \"50547\")]\n+impl<F: Future<Output = ()> + 'static> From<PinBox<F>> for LocalTaskObj {\n+    fn from(boxed: PinBox<F>) -> Self {\n+        LocalTaskObj::new(boxed)\n+    }\n+}\n+\n+#[unstable(feature = \"futures_api\", issue = \"50547\")]\n+impl<F: Future<Output = ()> + 'static> From<Box<F>> for LocalTaskObj {\n+    fn from(boxed: Box<F>) -> Self {\n+        LocalTaskObj::new(PinBox::from(boxed))\n+    }\n+}"}, {"sha": "c69d45248a597c09ea434208292f5ec40a23900d", "filename": "src/libcore/task/context.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/84804c3874a15f55a905c0b53d820372003b0c24/src%2Flibcore%2Ftask%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84804c3874a15f55a905c0b53d820372003b0c24/src%2Flibcore%2Ftask%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fcontext.rs?ref=84804c3874a15f55a905c0b53d820372003b0c24", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![unstable(feature = \"futures_api\",\n+            reason = \"futures in libcore are unstable\",\n+            issue = \"50547\")]\n+\n+use fmt;\n+use super::{Executor, Waker, LocalWaker};\n+\n+/// Information about the currently-running task.\n+///\n+/// Contexts are always tied to the stack, since they are set up specifically\n+/// when performing a single `poll` step on a task.\n+pub struct Context<'a> {\n+    local_waker: &'a LocalWaker,\n+    executor: &'a mut Executor,\n+}\n+\n+impl<'a> fmt::Debug for Context<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Context\")\n+            .finish()\n+    }\n+}\n+\n+impl<'a> Context<'a> {\n+    /// Create a new task `Context` with the provided `local_waker`, `waker`, and `executor`.\n+    #[inline]\n+    pub fn new(local_waker: &'a LocalWaker, executor: &'a mut Executor) -> Context<'a> {\n+        Context {\n+            local_waker,\n+            executor,\n+        }\n+    }\n+\n+    /// Get the `LocalWaker` associated with the current task.\n+    #[inline]\n+    pub fn local_waker(&self) -> &'a LocalWaker {\n+        self.local_waker\n+    }\n+\n+    /// Get the `Waker` associated with the current task.\n+    #[inline]\n+    pub fn waker(&self) -> &'a Waker {\n+        unsafe { &*(self.local_waker as *const LocalWaker as *const Waker) }\n+    }\n+\n+    /// Get the default executor associated with this task.\n+    ///\n+    /// This method is useful primarily if you want to explicitly handle\n+    /// spawn failures.\n+    #[inline]\n+    pub fn executor(&mut self) -> &mut Executor {\n+        self.executor\n+    }\n+\n+    /// Produce a context like the current one, but using the given waker instead.\n+    ///\n+    /// This advanced method is primarily used when building \"internal\n+    /// schedulers\" within a task, where you want to provide some customized\n+    /// wakeup logic.\n+    #[inline]\n+    pub fn with_waker<'b>(&'b mut self, local_waker: &'b LocalWaker) -> Context<'b> {\n+        Context {\n+            local_waker,\n+            executor: self.executor,\n+        }\n+    }\n+\n+    /// Produce a context like the current one, but using the given executor\n+    /// instead.\n+    ///\n+    /// This advanced method is primarily used when building \"internal\n+    /// schedulers\" within a task.\n+    #[inline]\n+    pub fn with_executor<'b, E>(&'b mut self, executor: &'b mut E) -> Context<'b>\n+        where E: Executor\n+    {\n+        Context {\n+            local_waker: self.local_waker,\n+            executor: executor,\n+        }\n+    }\n+}"}, {"sha": "73bf80d2f9997782ab3c5324f77d82685d8eed10", "filename": "src/libcore/task/executor.rs", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/84804c3874a15f55a905c0b53d820372003b0c24/src%2Flibcore%2Ftask%2Fexecutor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84804c3874a15f55a905c0b53d820372003b0c24/src%2Flibcore%2Ftask%2Fexecutor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fexecutor.rs?ref=84804c3874a15f55a905c0b53d820372003b0c24", "patch": "@@ -0,0 +1,90 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![unstable(feature = \"futures_api\",\n+            reason = \"futures in libcore are unstable\",\n+            issue = \"50547\")]\n+\n+use fmt;\n+use super::{TaskObj, LocalTaskObj};\n+\n+/// A task executor.\n+///\n+/// A *task* is a `()`-producing async value that runs at the top level, and will\n+/// be `poll`ed until completion. It's also the unit at which wake-up\n+/// notifications occur. Executors, such as thread pools, allow tasks to be\n+/// spawned and are responsible for putting tasks onto ready queues when\n+/// they are woken up, and polling them when they are ready.\n+pub trait Executor {\n+    /// Spawn the given task, polling it until completion.\n+    ///\n+    /// # Errors\n+    ///\n+    /// The executor may be unable to spawn tasks, either because it has\n+    /// been shut down or is resource-constrained.\n+    fn spawn_obj(&mut self, task: TaskObj) -> Result<(), SpawnObjError>;\n+\n+    /// Determine whether the executor is able to spawn new tasks.\n+    ///\n+    /// # Returns\n+    ///\n+    /// An `Ok` return means the executor is *likely* (but not guaranteed)\n+    /// to accept a subsequent spawn attempt. Likewise, an `Err` return\n+    /// means that `spawn` is likely, but not guaranteed, to yield an error.\n+    #[inline]\n+    fn status(&self) -> Result<(), SpawnErrorKind> {\n+        Ok(())\n+    }\n+}\n+\n+/// Provides the reason that an executor was unable to spawn.\n+pub struct SpawnErrorKind {\n+    _hidden: (),\n+}\n+\n+impl fmt::Debug for SpawnErrorKind {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_tuple(\"SpawnErrorKind\")\n+            .field(&\"shutdown\")\n+            .finish()\n+    }\n+}\n+\n+impl SpawnErrorKind {\n+    /// Spawning is failing because the executor has been shut down.\n+    pub fn shutdown() -> SpawnErrorKind {\n+        SpawnErrorKind { _hidden: () }\n+    }\n+\n+    /// Check whether this error is the `shutdown` error.\n+    pub fn is_shutdown(&self) -> bool {\n+        true\n+    }\n+}\n+\n+/// The result of a failed spawn\n+#[derive(Debug)]\n+pub struct SpawnObjError {\n+    /// The kind of error\n+    pub kind: SpawnErrorKind,\n+\n+    /// The task for which spawning was attempted\n+    pub task: TaskObj,\n+}\n+\n+/// The result of a failed spawn\n+#[derive(Debug)]\n+pub struct SpawnLocalObjError {\n+    /// The kind of error\n+    pub kind: SpawnErrorKind,\n+\n+    /// The task for which spawning was attempted\n+    pub task: LocalTaskObj,\n+}"}, {"sha": "d167a37410553081101572465c41fc625583d1ec", "filename": "src/libcore/task/mod.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/84804c3874a15f55a905c0b53d820372003b0c24/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84804c3874a15f55a905c0b53d820372003b0c24/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=84804c3874a15f55a905c0b53d820372003b0c24", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![unstable(feature = \"futures_api\",\n+            reason = \"futures in libcore are unstable\",\n+            issue = \"50547\")]\n+\n+//! Types and Traits for working with asynchronous tasks.\n+\n+mod context;\n+pub use self::context::Context;\n+\n+mod executor;\n+pub use self::executor::{\n+  Executor, SpawnErrorKind, SpawnObjError, SpawnLocalObjError\n+};\n+\n+mod poll;\n+pub use self::poll::Poll;\n+\n+mod task;\n+pub use self::task::{TaskObj, LocalTaskObj, UnsafeTask};\n+\n+mod wake;\n+pub use self::wake::{Waker, LocalWaker, UnsafeWake};"}, {"sha": "10c954f0e80ecc83080202a9959e3fdbf73d53ec", "filename": "src/libcore/task/poll.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/84804c3874a15f55a905c0b53d820372003b0c24/src%2Flibcore%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84804c3874a15f55a905c0b53d820372003b0c24/src%2Flibcore%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fpoll.rs?ref=84804c3874a15f55a905c0b53d820372003b0c24", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![unstable(feature = \"futures_api\",\n+            reason = \"futures in libcore are unstable\",\n+            issue = \"50547\")]\n+\n+/// Indicates whether a value is available or if the current task has been\n+/// scheduled to receive a wakeup instead.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n+pub enum Poll<T> {\n+    /// Represents that a value is immediately ready.\n+    Ready(T),\n+\n+    /// Represents that a value is not ready yet.\n+    ///\n+    /// When a function returns `Pending`, the function *must* also\n+    /// ensure that the current task is scheduled to be awoken when\n+    /// progress can be made.\n+    Pending,\n+}\n+\n+impl<T> Poll<T> {\n+    /// Change the ready value of this `Poll` with the closure provided\n+    pub fn map<U, F>(self, f: F) -> Poll<U>\n+        where F: FnOnce(T) -> U\n+    {\n+        match self {\n+            Poll::Ready(t) => Poll::Ready(f(t)),\n+            Poll::Pending => Poll::Pending,\n+        }\n+    }\n+\n+    /// Returns whether this is `Poll::Ready`\n+    pub fn is_ready(&self) -> bool {\n+        match *self {\n+            Poll::Ready(_) => true,\n+            Poll::Pending => false,\n+        }\n+    }\n+\n+    /// Returns whether this is `Poll::Pending`\n+    pub fn is_pending(&self) -> bool {\n+        !self.is_ready()\n+    }\n+}\n+\n+impl<T, E> Poll<Result<T, E>> {\n+    /// Change the success value of this `Poll` with the closure provided\n+    pub fn map_ok<U, F>(self, f: F) -> Poll<Result<U, E>>\n+        where F: FnOnce(T) -> U\n+    {\n+        match self {\n+            Poll::Ready(Ok(t)) => Poll::Ready(Ok(f(t))),\n+            Poll::Ready(Err(e)) => Poll::Ready(Err(e)),\n+            Poll::Pending => Poll::Pending,\n+        }\n+    }\n+\n+    /// Change the error value of this `Poll` with the closure provided\n+    pub fn map_err<U, F>(self, f: F) -> Poll<Result<T, U>>\n+        where F: FnOnce(E) -> U\n+    {\n+        match self {\n+            Poll::Ready(Ok(t)) => Poll::Ready(Ok(t)),\n+            Poll::Ready(Err(e)) => Poll::Ready(Err(f(e))),\n+            Poll::Pending => Poll::Pending,\n+        }\n+    }\n+}\n+\n+impl<T> From<T> for Poll<T> {\n+    fn from(t: T) -> Poll<T> {\n+        Poll::Ready(t)\n+    }\n+}"}, {"sha": "c5a41873db42725fbaccfa588996cf0a4ebab68d", "filename": "src/libcore/task/task.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/84804c3874a15f55a905c0b53d820372003b0c24/src%2Flibcore%2Ftask%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84804c3874a15f55a905c0b53d820372003b0c24/src%2Flibcore%2Ftask%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Ftask.rs?ref=84804c3874a15f55a905c0b53d820372003b0c24", "patch": "@@ -0,0 +1,142 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![unstable(feature = \"futures_api\",\n+            reason = \"futures in libcore are unstable\",\n+            issue = \"50547\")]\n+\n+use fmt;\n+use future::Future;\n+use mem::PinMut;\n+use super::{Context, Poll};\n+\n+/// A custom trait object for polling tasks, roughly akin to\n+/// `Box<Future<Output = ()>>`.\n+/// Contrary to `TaskObj`, `LocalTaskObj` does not have a `Send` bound.\n+pub struct LocalTaskObj {\n+    ptr: *mut (),\n+    poll_fn: unsafe fn(*mut (), &mut Context) -> Poll<()>,\n+    drop_fn: unsafe fn(*mut ()),\n+}\n+\n+impl LocalTaskObj {\n+    /// Create a `LocalTaskObj` from a custom trait object representation.\n+    #[inline]\n+    pub fn new<T: UnsafeTask>(t: T) -> LocalTaskObj {\n+        LocalTaskObj {\n+            ptr: t.into_raw(),\n+            poll_fn: T::poll,\n+            drop_fn: T::drop,\n+        }\n+    }\n+\n+    /// Converts the `LocalTaskObj` into a `TaskObj`\n+    /// To make this operation safe one has to ensure that the `UnsafeTask`\n+    /// instance from which this `LocalTaskObj` was created actually implements\n+    /// `Send`.\n+    pub unsafe fn as_task_obj(self) -> TaskObj {\n+        TaskObj(self)\n+    }\n+}\n+\n+impl fmt::Debug for LocalTaskObj {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"LocalTaskObj\")\n+            .finish()\n+    }\n+}\n+\n+impl From<TaskObj> for LocalTaskObj {\n+    fn from(task: TaskObj) -> LocalTaskObj {\n+        task.0\n+    }\n+}\n+\n+impl Future for LocalTaskObj {\n+    type Output = ();\n+\n+    #[inline]\n+    fn poll(self: PinMut<Self>, cx: &mut Context) -> Poll<()> {\n+        unsafe {\n+            (self.poll_fn)(self.ptr, cx)\n+        }\n+    }\n+}\n+\n+impl Drop for LocalTaskObj {\n+    fn drop(&mut self) {\n+        unsafe {\n+            (self.drop_fn)(self.ptr)\n+        }\n+    }\n+}\n+\n+/// A custom trait object for polling tasks, roughly akin to\n+/// `Box<Future<Output = ()> + Send>`.\n+pub struct TaskObj(LocalTaskObj);\n+\n+unsafe impl Send for TaskObj {}\n+\n+impl TaskObj {\n+    /// Create a `TaskObj` from a custom trait object representation.\n+    #[inline]\n+    pub fn new<T: UnsafeTask + Send>(t: T) -> TaskObj {\n+        TaskObj(LocalTaskObj::new(t))\n+    }\n+}\n+\n+impl fmt::Debug for TaskObj {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"TaskObj\")\n+            .finish()\n+    }\n+}\n+\n+impl Future for TaskObj {\n+    type Output = ();\n+\n+    #[inline]\n+    fn poll(self: PinMut<Self>, cx: &mut Context) -> Poll<()> {\n+        let pinned_field = unsafe { PinMut::map_unchecked(self, |x| &mut x.0) };\n+        pinned_field.poll(cx)\n+    }\n+}\n+\n+/// A custom implementation of a task trait object for `TaskObj`, providing\n+/// a hand-rolled vtable.\n+///\n+/// This custom representation is typically used only in `no_std` contexts,\n+/// where the default `Box`-based implementation is not available.\n+///\n+/// The implementor must guarantee that it is safe to call `poll` repeatedly (in\n+/// a non-concurrent fashion) with the result of `into_raw` until `drop` is\n+/// called.\n+pub unsafe trait UnsafeTask: 'static {\n+    /// Convert a owned instance into a (conceptually owned) void pointer.\n+    fn into_raw(self) -> *mut ();\n+\n+    /// Poll the task represented by the given void pointer.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The trait implementor must guarantee that it is safe to repeatedly call\n+    /// `poll` with the result of `into_raw` until `drop` is called; such calls\n+    /// are not, however, allowed to race with each other or with calls to `drop`.\n+    unsafe fn poll(task: *mut (), cx: &mut Context) -> Poll<()>;\n+\n+    /// Drops the task represented by the given void pointer.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The trait implementor must guarantee that it is safe to call this\n+    /// function once per `into_raw` invocation; that call cannot race with\n+    /// other calls to `drop` or `poll`.\n+    unsafe fn drop(task: *mut ());\n+}"}, {"sha": "4fd45be56fbfb8d092102732da0347fbe26f2bef", "filename": "src/libcore/task/wake.rs", "status": "renamed", "additions": 0, "deletions": 294, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/84804c3874a15f55a905c0b53d820372003b0c24/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84804c3874a15f55a905c0b53d820372003b0c24/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=84804c3874a15f55a905c0b53d820372003b0c24", "patch": "@@ -12,82 +12,8 @@\n             reason = \"futures in libcore are unstable\",\n             issue = \"50547\")]\n \n-//! Types and Traits for working with asynchronous tasks.\n-\n use fmt;\n use ptr::NonNull;\n-use future::Future;\n-use mem::PinMut;\n-\n-/// Indicates whether a value is available or if the current task has been\n-/// scheduled to receive a wakeup instead.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n-pub enum Poll<T> {\n-    /// Represents that a value is immediately ready.\n-    Ready(T),\n-\n-    /// Represents that a value is not ready yet.\n-    ///\n-    /// When a function returns `Pending`, the function *must* also\n-    /// ensure that the current task is scheduled to be awoken when\n-    /// progress can be made.\n-    Pending,\n-}\n-\n-impl<T> Poll<T> {\n-    /// Change the ready value of this `Poll` with the closure provided\n-    pub fn map<U, F>(self, f: F) -> Poll<U>\n-        where F: FnOnce(T) -> U\n-    {\n-        match self {\n-            Poll::Ready(t) => Poll::Ready(f(t)),\n-            Poll::Pending => Poll::Pending,\n-        }\n-    }\n-\n-    /// Returns whether this is `Poll::Ready`\n-    pub fn is_ready(&self) -> bool {\n-        match *self {\n-            Poll::Ready(_) => true,\n-            Poll::Pending => false,\n-        }\n-    }\n-\n-    /// Returns whether this is `Poll::Pending`\n-    pub fn is_pending(&self) -> bool {\n-        !self.is_ready()\n-    }\n-}\n-\n-impl<T, E> Poll<Result<T, E>> {\n-    /// Change the success value of this `Poll` with the closure provided\n-    pub fn map_ok<U, F>(self, f: F) -> Poll<Result<U, E>>\n-        where F: FnOnce(T) -> U\n-    {\n-        match self {\n-            Poll::Ready(Ok(t)) => Poll::Ready(Ok(f(t))),\n-            Poll::Ready(Err(e)) => Poll::Ready(Err(e)),\n-            Poll::Pending => Poll::Pending,\n-        }\n-    }\n-\n-    /// Change the error value of this `Poll` with the closure provided\n-    pub fn map_err<U, F>(self, f: F) -> Poll<Result<T, U>>\n-        where F: FnOnce(E) -> U\n-    {\n-        match self {\n-            Poll::Ready(Ok(t)) => Poll::Ready(Ok(t)),\n-            Poll::Ready(Err(e)) => Poll::Ready(Err(f(e))),\n-            Poll::Pending => Poll::Pending,\n-        }\n-    }\n-}\n-\n-impl<T> From<T> for Poll<T> {\n-    fn from(t: T) -> Poll<T> {\n-        Poll::Ready(t)\n-    }\n-}\n \n /// A `Waker` is a handle for waking up a task by notifying its executor that it\n /// is ready to be run.\n@@ -347,223 +273,3 @@ pub unsafe trait UnsafeWake: Send + Sync {\n         self.wake()\n     }\n }\n-\n-/// Information about the currently-running task.\n-///\n-/// Contexts are always tied to the stack, since they are set up specifically\n-/// when performing a single `poll` step on a task.\n-pub struct Context<'a> {\n-    local_waker: &'a LocalWaker,\n-    executor: &'a mut Executor,\n-}\n-\n-impl<'a> fmt::Debug for Context<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Context\")\n-            .finish()\n-    }\n-}\n-\n-impl<'a> Context<'a> {\n-    /// Create a new task `Context` with the provided `local_waker`, `waker`, and `executor`.\n-    #[inline]\n-    pub fn new(local_waker: &'a LocalWaker, executor: &'a mut Executor) -> Context<'a> {\n-        Context {\n-            local_waker,\n-            executor,\n-        }\n-    }\n-\n-    /// Get the `LocalWaker` associated with the current task.\n-    #[inline]\n-    pub fn local_waker(&self) -> &'a LocalWaker {\n-        self.local_waker\n-    }\n-\n-    /// Get the `Waker` associated with the current task.\n-    #[inline]\n-    pub fn waker(&self) -> &'a Waker {\n-        unsafe { &*(self.local_waker as *const LocalWaker as *const Waker) }\n-    }\n-\n-    /// Get the default executor associated with this task.\n-    ///\n-    /// This method is useful primarily if you want to explicitly handle\n-    /// spawn failures.\n-    #[inline]\n-    pub fn executor(&mut self) -> &mut Executor {\n-        self.executor\n-    }\n-\n-    /// Produce a context like the current one, but using the given waker instead.\n-    ///\n-    /// This advanced method is primarily used when building \"internal\n-    /// schedulers\" within a task, where you want to provide some customized\n-    /// wakeup logic.\n-    #[inline]\n-    pub fn with_waker<'b>(&'b mut self, local_waker: &'b LocalWaker) -> Context<'b> {\n-        Context {\n-            local_waker,\n-            executor: self.executor,\n-        }\n-    }\n-\n-    /// Produce a context like the current one, but using the given executor\n-    /// instead.\n-    ///\n-    /// This advanced method is primarily used when building \"internal\n-    /// schedulers\" within a task.\n-    #[inline]\n-    pub fn with_executor<'b, E>(&'b mut self, executor: &'b mut E) -> Context<'b>\n-        where E: Executor\n-    {\n-        Context {\n-            local_waker: self.local_waker,\n-            executor: executor,\n-        }\n-    }\n-}\n-\n-/// A task executor.\n-///\n-/// A *task* is a `()`-producing async value that runs at the top level, and will\n-/// be `poll`ed until completion. It's also the unit at which wake-up\n-/// notifications occur. Executors, such as thread pools, allow tasks to be\n-/// spawned and are responsible for putting tasks onto ready queues when\n-/// they are woken up, and polling them when they are ready.\n-pub trait Executor {\n-    /// Spawn the given task, polling it until completion.\n-    ///\n-    /// # Errors\n-    ///\n-    /// The executor may be unable to spawn tasks, either because it has\n-    /// been shut down or is resource-constrained.\n-    fn spawn_obj(&mut self, task: TaskObj) -> Result<(), SpawnObjError>;\n-\n-    /// Determine whether the executor is able to spawn new tasks.\n-    ///\n-    /// # Returns\n-    ///\n-    /// An `Ok` return means the executor is *likely* (but not guaranteed)\n-    /// to accept a subsequent spawn attempt. Likewise, an `Err` return\n-    /// means that `spawn` is likely, but not guaranteed, to yield an error.\n-    #[inline]\n-    fn status(&self) -> Result<(), SpawnErrorKind> {\n-        Ok(())\n-    }\n-}\n-\n-/// A custom trait object for polling tasks, roughly akin to\n-/// `Box<Future<Output = ()> + Send>`.\n-pub struct TaskObj {\n-    ptr: *mut (),\n-    poll_fn: unsafe fn(*mut (), &mut Context) -> Poll<()>,\n-    drop_fn: unsafe fn(*mut ()),\n-}\n-\n-impl fmt::Debug for TaskObj {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"TaskObj\")\n-            .finish()\n-    }\n-}\n-\n-unsafe impl Send for TaskObj {}\n-\n-/// A custom implementation of a task trait object for `TaskObj`, providing\n-/// a hand-rolled vtable.\n-///\n-/// This custom representation is typically used only in `no_std` contexts,\n-/// where the default `Box`-based implementation is not available.\n-///\n-/// The implementor must guarantee that it is safe to call `poll` repeatedly (in\n-/// a non-concurrent fashion) with the result of `into_raw` until `drop` is\n-/// called.\n-pub unsafe trait UnsafeTask: Send + 'static {\n-    /// Convert a owned instance into a (conceptually owned) void pointer.\n-    fn into_raw(self) -> *mut ();\n-\n-    /// Poll the task represented by the given void pointer.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The trait implementor must guarantee that it is safe to repeatedly call\n-    /// `poll` with the result of `into_raw` until `drop` is called; such calls\n-    /// are not, however, allowed to race with each other or with calls to `drop`.\n-    unsafe fn poll(task: *mut (), cx: &mut Context) -> Poll<()>;\n-\n-    /// Drops the task represented by the given void pointer.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The trait implementor must guarantee that it is safe to call this\n-    /// function once per `into_raw` invocation; that call cannot race with\n-    /// other calls to `drop` or `poll`.\n-    unsafe fn drop(task: *mut ());\n-}\n-\n-impl TaskObj {\n-    /// Create a `TaskObj` from a custom trait object representation.\n-    #[inline]\n-    pub fn new<T: UnsafeTask>(t: T) -> TaskObj {\n-        TaskObj {\n-            ptr: t.into_raw(),\n-            poll_fn: T::poll,\n-            drop_fn: T::drop,\n-        }\n-    }\n-}\n-\n-impl Future for TaskObj {\n-    type Output = ();\n-\n-    #[inline]\n-    fn poll(self: PinMut<Self>, cx: &mut Context) -> Poll<()> {\n-        unsafe {\n-            (self.poll_fn)(self.ptr, cx)\n-        }\n-    }\n-}\n-\n-impl Drop for TaskObj {\n-    fn drop(&mut self) {\n-        unsafe {\n-            (self.drop_fn)(self.ptr)\n-        }\n-    }\n-}\n-\n-/// Provides the reason that an executor was unable to spawn.\n-pub struct SpawnErrorKind {\n-    _hidden: (),\n-}\n-\n-impl fmt::Debug for SpawnErrorKind {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_tuple(\"SpawnErrorKind\")\n-            .field(&\"shutdown\")\n-            .finish()\n-    }\n-}\n-\n-impl SpawnErrorKind {\n-    /// Spawning is failing because the executor has been shut down.\n-    pub fn shutdown() -> SpawnErrorKind {\n-        SpawnErrorKind { _hidden: () }\n-    }\n-\n-    /// Check whether this error is the `shutdown` error.\n-    pub fn is_shutdown(&self) -> bool {\n-        true\n-    }\n-}\n-\n-/// The result of a failed spawn\n-#[derive(Debug)]\n-pub struct SpawnObjError {\n-    /// The kind of error\n-    pub kind: SpawnErrorKind,\n-\n-    /// The task for which spawning was attempted\n-    pub task: TaskObj,\n-}", "previous_filename": "src/libcore/task.rs"}]}