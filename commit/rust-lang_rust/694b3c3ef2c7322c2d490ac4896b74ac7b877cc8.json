{"sha": "694b3c3ef2c7322c2d490ac4896b74ac7b877cc8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5NGIzYzNlZjJjNzMyMmMyZDQ5MGFjNDg5NmI3NGFjN2I4NzdjYzg=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-09T08:03:30Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-28T04:53:38Z"}, "message": "Adjust lowering of Slice patterns.\n- Make sure extra `x @ ..` do not cause ICEs.", "tree": {"sha": "eda300c73d93e8710c0ea562a5a12c215f731485", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eda300c73d93e8710c0ea562a5a12c215f731485"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/694b3c3ef2c7322c2d490ac4896b74ac7b877cc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/694b3c3ef2c7322c2d490ac4896b74ac7b877cc8", "html_url": "https://github.com/rust-lang/rust/commit/694b3c3ef2c7322c2d490ac4896b74ac7b877cc8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/694b3c3ef2c7322c2d490ac4896b74ac7b877cc8/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5df1e0b0f99e7dad81c573cc2beb03d3023d433", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5df1e0b0f99e7dad81c573cc2beb03d3023d433", "html_url": "https://github.com/rust-lang/rust/commit/d5df1e0b0f99e7dad81c573cc2beb03d3023d433"}], "stats": {"total": 134, "additions": 100, "deletions": 34}, "files": [{"sha": "094a509a18d6937517d0dfeb0469177b74a93214", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 100, "deletions": 34, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/694b3c3ef2c7322c2d490ac4896b74ac7b877cc8/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/694b3c3ef2c7322c2d490ac4896b74ac7b877cc8/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=694b3c3ef2c7322c2d490ac4896b74ac7b877cc8", "patch": "@@ -4173,30 +4173,8 @@ impl<'a> LoweringContext<'a> {\n         let node = match p.node {\n             PatKind::Wild => hir::PatKind::Wild,\n             PatKind::Ident(ref binding_mode, ident, ref sub) => {\n-                match self.resolver.get_partial_res(p.id).map(|d| d.base_res()) {\n-                    // `None` can occur in body-less function signatures\n-                    res @ None | res @ Some(Res::Local(_)) => {\n-                        let canonical_id = match res {\n-                            Some(Res::Local(id)) => id,\n-                            _ => p.id,\n-                        };\n-\n-                        hir::PatKind::Binding(\n-                            self.lower_binding_mode(binding_mode),\n-                            self.lower_node_id(canonical_id),\n-                            ident,\n-                            sub.as_ref().map(|x| self.lower_pat(x)),\n-                        )\n-                    }\n-                    Some(res) => hir::PatKind::Path(hir::QPath::Resolved(\n-                        None,\n-                        P(hir::Path {\n-                            span: ident.span,\n-                            res: self.lower_res(res),\n-                            segments: hir_vec![hir::PathSegment::from_ident(ident)],\n-                        }),\n-                    )),\n-                }\n+                let lower_sub = |this: &mut Self| sub.as_ref().map(|x| this.lower_pat(x));\n+                self.lower_pat_ident(p, binding_mode, ident, lower_sub)\n             }\n             PatKind::Lit(ref e) => hir::PatKind::Lit(P(self.lower_expr(e))),\n             PatKind::TupleStruct(ref path, ref pats) => {\n@@ -4258,11 +4236,7 @@ impl<'a> LoweringContext<'a> {\n                 P(self.lower_expr(e2)),\n                 self.lower_range_end(end),\n             ),\n-            PatKind::Slice(ref before, ref slice, ref after) => hir::PatKind::Slice(\n-                before.iter().map(|x| self.lower_pat(x)).collect(),\n-                slice.as_ref().map(|x| self.lower_pat(x)),\n-                after.iter().map(|x| self.lower_pat(x)).collect(),\n-            ),\n+            PatKind::Slice(ref pats) => self.lower_pat_slice(pats),\n             PatKind::Rest => {\n                 // If we reach here the `..` pattern is not semantically allowed.\n                 self.ban_illegal_rest_pat(p.span)\n@@ -4271,11 +4245,7 @@ impl<'a> LoweringContext<'a> {\n             PatKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n         };\n \n-        P(hir::Pat {\n-            hir_id: self.lower_node_id(p.id),\n-            node,\n-            span: p.span,\n-        })\n+        self.pat_bound(p, node)\n     }\n \n     fn lower_pat_tuple(\n@@ -4309,6 +4279,102 @@ impl<'a> LoweringContext<'a> {\n         (elems.into(), rest.map(|(ddpos, _)| ddpos))\n     }\n \n+    fn lower_pat_slice(&mut self, pats: &[AstP<Pat>]) -> hir::PatKind {\n+        let mut before = Vec::new();\n+        let mut after = Vec::new();\n+        let mut slice = None;\n+        let mut prev_rest_span = None;\n+\n+        let mut iter = pats.iter();\n+        while let Some(pat) = iter.next() {\n+            // Interpret the first `((ref mut?)? x @)? ..` pattern as a subslice pattern.\n+            match pat.node {\n+                PatKind::Rest => {\n+                    prev_rest_span = Some(pat.span);\n+                    slice = Some(self.pat_bound_wild(pat));\n+                    break;\n+                },\n+                PatKind::Ident(ref bm, ident, Some(ref sub)) if sub.is_rest() => {\n+                    prev_rest_span = Some(sub.span);\n+                    let lower_sub = |this: &mut Self| Some(this.pat_bound_wild(sub));\n+                    let node = self.lower_pat_ident(pat, bm, ident, lower_sub);\n+                    slice = Some(self.pat_bound(pat, node));\n+                    break;\n+                },\n+                _ => {}\n+            }\n+\n+            // It was not a subslice pattern so lower it normally.\n+            before.push(self.lower_pat(pat));\n+        }\n+\n+        while let Some(pat) = iter.next() {\n+            // There was a previous subslice pattern; make sure we don't allow more.\n+            let rest_span = match pat.node {\n+                PatKind::Rest => Some(pat.span),\n+                PatKind::Ident(.., Some(ref sub)) if sub.is_rest() => {\n+                    // The `HirValidator` is merciless; add a `_` pattern to avoid ICEs.\n+                    after.push(self.pat_bound_wild(pat));\n+                    Some(sub.span)\n+                },\n+                _ => None,\n+            };\n+            if let Some(rest_span) = rest_span {\n+                self.ban_extra_rest_pat(rest_span, prev_rest_span.unwrap(), \"slice\");\n+            } else {\n+                after.push(self.lower_pat(pat));\n+            }\n+        }\n+\n+        hir::PatKind::Slice(before.into(), slice, after.into())\n+    }\n+\n+    fn lower_pat_ident(\n+        &mut self,\n+        p: &Pat,\n+        binding_mode: &BindingMode,\n+        ident: Ident,\n+        lower_sub: impl FnOnce(&mut Self) -> Option<P<hir::Pat>>,\n+    ) -> hir::PatKind {\n+        match self.resolver.get_partial_res(p.id).map(|d| d.base_res()) {\n+            // `None` can occur in body-less function signatures\n+            res @ None | res @ Some(Res::Local(_)) => {\n+                let canonical_id = match res {\n+                    Some(Res::Local(id)) => id,\n+                    _ => p.id,\n+                };\n+\n+                hir::PatKind::Binding(\n+                    self.lower_binding_mode(binding_mode),\n+                    self.lower_node_id(canonical_id),\n+                    ident,\n+                    lower_sub(self),\n+                )\n+            }\n+            Some(res) => hir::PatKind::Path(hir::QPath::Resolved(\n+                None,\n+                P(hir::Path {\n+                    span: ident.span,\n+                    res: self.lower_res(res),\n+                    segments: hir_vec![hir::PathSegment::from_ident(ident)],\n+                }),\n+            )),\n+        }\n+    }\n+\n+    fn pat_bound_wild(&mut self, p: &Pat) -> P<hir::Pat> {\n+        self.pat_bound(p, hir::PatKind::Wild)\n+    }\n+\n+    /// Construct a `Pat` with the `HirId` of `p.id` lowered.\n+    fn pat_bound(&mut self, p: &Pat, node: hir::PatKind) -> P<hir::Pat> {\n+        P(hir::Pat {\n+            hir_id: self.lower_node_id(p.id),\n+            node,\n+            span: p.span,\n+        })\n+    }\n+\n     /// Emit a friendly error for extra `..` patterns in a tuple/tuple struct/slice pattern.\n     fn ban_extra_rest_pat(&self, sp: Span, prev_sp: Span, ctx: &str) {\n         self.diagnostic()"}]}