{"sha": "ebd219ab8e7be56020436f9c6d6a44c6d4f4a5cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViZDIxOWFiOGU3YmU1NjAyMDQzNmY5YzZkNmE0NGM2ZDRmNGE1Y2Y=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-11-23T21:21:56Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-11-25T20:57:59Z"}, "message": "comments", "tree": {"sha": "74cb1787931331958c1225d14ac31ce8f0ed1f1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74cb1787931331958c1225d14ac31ce8f0ed1f1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebd219ab8e7be56020436f9c6d6a44c6d4f4a5cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebd219ab8e7be56020436f9c6d6a44c6d4f4a5cf", "html_url": "https://github.com/rust-lang/rust/commit/ebd219ab8e7be56020436f9c6d6a44c6d4f4a5cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebd219ab8e7be56020436f9c6d6a44c6d4f4a5cf/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3", "url": "https://api.github.com/repos/rust-lang/rust/commits/d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3", "html_url": "https://github.com/rust-lang/rust/commit/d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3"}], "stats": {"total": 54, "additions": 31, "deletions": 23}, "files": [{"sha": "3c3aba372fbd0132a9e3d56ba16023ce0b0dde72", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ebd219ab8e7be56020436f9c6d6a44c6d4f4a5cf/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebd219ab8e7be56020436f9c6d6a44c6d4f4a5cf/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=ebd219ab8e7be56020436f9c6d6a44c6d4f4a5cf", "patch": "@@ -181,18 +181,6 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n             TypeOutlives::new(self, region_bound_pairs, implicit_region_bound, param_env);\n         outlives.type_must_outlive(origin, ty, region);\n     }\n-\n-    /// Ignore the region obligations, not bothering to prove\n-    /// them. This function should not really exist; it is used to\n-    /// accommodate some older code for the time being.\n-    pub fn ignore_region_obligations(&self) {\n-        assert!(\n-            !self.in_snapshot.get(),\n-            \"cannot ignore registered region obligations in a snapshot\"\n-        );\n-\n-        self.region_obligations.borrow_mut().clear();\n-    }\n }\n \n #[must_use] // you ought to invoke `into_accrued_obligations` when you are done =)"}, {"sha": "a3a5c26ec186a6613da9bf69e565874d52710ae7", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ebd219ab8e7be56020436f9c6d6a44c6d4f4a5cf/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebd219ab8e7be56020436f9c6d6a44c6d4f4a5cf/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=ebd219ab8e7be56020436f9c6d6a44c6d4f4a5cf", "patch": "@@ -431,6 +431,9 @@ pub fn type_known_to_meet_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx\n         // this function's result remains infallible, we must confirm\n         // that guess. While imperfect, I believe this is sound.\n \n+        // The handling of regions in this area of the code is terrible,\n+        // see issue #29149. We should be able to improve on this with\n+        // NLL.\n         let mut fulfill_cx = FulfillmentContext::new_ignoring_regions();\n \n         // We can use a dummy node-id here because we won't pay any mind\n@@ -511,8 +514,24 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            unnormalized_env.reveal);\n \n     tcx.infer_ctxt().enter(|infcx| {\n-        let predicates = match fully_normalize(\n+        // FIXME. We should really... do something with these region\n+        // obligations. But this call just continues the older\n+        // behavior (i.e., doesn't cause any new bugs), and it would\n+        // take some further refactoring to actually solve them. In\n+        // particular, we would have to handle implied bounds\n+        // properly, and that code is currently largely confined to\n+        // regionck (though I made some efforts to extract it\n+        // out). -nmatsakis\n+        //\n+        // @arielby: In any case, these obligations are checked\n+        // by wfcheck anyway, so I'm not sure we have to check\n+        // them here too, and we will remove this function when\n+        // we move over to lazy normalization *anyway*.\n+        let fulfill_cx = FulfillmentContext::new_ignoring_regions();\n+\n+        let predicates = match fully_normalize_with_fulfillcx(\n             &infcx,\n+            fulfill_cx,\n             cause,\n             elaborated_env,\n             // You would really want to pass infcx.param_env.caller_bounds here,\n@@ -537,16 +556,6 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let region_scope_tree = region::ScopeTree::default();\n         let free_regions = FreeRegionMap::new();\n \n-        // FIXME. We should really... do something with these region\n-        // obligations. But this call just continues the older\n-        // behavior (i.e., doesn't cause any new bugs), and it would\n-        // take some further refactoring to actually solve them. In\n-        // particular, we would have to handle implied bounds\n-        // properly, and that code is currently largely confined to\n-        // regionck (though I made some efforts to extract it\n-        // out). -nmatsakis\n-        let _ = infcx.ignore_region_obligations();\n-\n         infcx.resolve_regions_and_report_errors(region_context, &region_scope_tree, &free_regions);\n         let predicates = match infcx.fully_resolve(&predicates) {\n             Ok(predicates) => predicates,"}, {"sha": "1b5b0d35ba3903c7a7782683cf390c9e145348f5", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ebd219ab8e7be56020436f9c6d6a44c6d4f4a5cf/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebd219ab8e7be56020436f9c6d6a44c6d4f4a5cf/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=ebd219ab8e7be56020436f9c6d6a44c6d4f4a5cf", "patch": "@@ -241,6 +241,17 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     // (which are packed up in penv)\n \n     infcx.save_and_restore_in_snapshot_flag(|infcx| {\n+        // If we came from `translate_substs`, we already know that the\n+        // predicates for our impl hold (after all, we know that a more\n+        // specialized impl holds, so our impl must hold too), and\n+        // we only want to process the projections to determine the\n+        // the types in our substs using RFC 447, so we can safely\n+        // ignore region obligations, which allows us to avoid threading\n+        // a node-id to assign them with.\n+        //\n+        // If we came from specialization graph construction, then\n+        // we already make a mockery out of the region system, so\n+        // why not ignore them a bit earlier?\n         let mut fulfill_cx = FulfillmentContext::new_ignoring_regions();\n         for oblig in obligations.into_iter() {\n             fulfill_cx.register_predicate_obligation(&infcx, oblig);"}]}