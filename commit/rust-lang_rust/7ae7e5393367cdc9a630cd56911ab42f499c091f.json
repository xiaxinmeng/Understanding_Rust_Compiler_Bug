{"sha": "7ae7e5393367cdc9a630cd56911ab42f499c091f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhZTdlNTM5MzM2N2NkYzlhNjMwY2Q1NjkxMWFiNDJmNDk5YzA5MWY=", "commit": {"author": {"name": "Martin Hoffmann", "email": "hn@nvnc.de", "date": "2018-02-08T10:07:05Z"}, "committer": {"name": "Martin Hoffmann", "email": "hn@nvnc.de", "date": "2018-02-08T10:07:05Z"}, "message": "New introduction and revised hash map explanation.", "tree": {"sha": "84330af7980393d5439dd2729b1f3ad8f6b73f43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84330af7980393d5439dd2729b1f3ad8f6b73f43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ae7e5393367cdc9a630cd56911ab42f499c091f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ae7e5393367cdc9a630cd56911ab42f499c091f", "html_url": "https://github.com/rust-lang/rust/commit/7ae7e5393367cdc9a630cd56911ab42f499c091f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ae7e5393367cdc9a630cd56911ab42f499c091f/comments", "author": {"login": "partim", "id": 1318494, "node_id": "MDQ6VXNlcjEzMTg0OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1318494?v=4", "gravatar_id": "", "url": "https://api.github.com/users/partim", "html_url": "https://github.com/partim", "followers_url": "https://api.github.com/users/partim/followers", "following_url": "https://api.github.com/users/partim/following{/other_user}", "gists_url": "https://api.github.com/users/partim/gists{/gist_id}", "starred_url": "https://api.github.com/users/partim/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/partim/subscriptions", "organizations_url": "https://api.github.com/users/partim/orgs", "repos_url": "https://api.github.com/users/partim/repos", "events_url": "https://api.github.com/users/partim/events{/privacy}", "received_events_url": "https://api.github.com/users/partim/received_events", "type": "User", "site_admin": false}, "committer": {"login": "partim", "id": 1318494, "node_id": "MDQ6VXNlcjEzMTg0OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1318494?v=4", "gravatar_id": "", "url": "https://api.github.com/users/partim", "html_url": "https://github.com/partim", "followers_url": "https://api.github.com/users/partim/followers", "following_url": "https://api.github.com/users/partim/following{/other_user}", "gists_url": "https://api.github.com/users/partim/gists{/gist_id}", "starred_url": "https://api.github.com/users/partim/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/partim/subscriptions", "organizations_url": "https://api.github.com/users/partim/orgs", "repos_url": "https://api.github.com/users/partim/repos", "events_url": "https://api.github.com/users/partim/events{/privacy}", "received_events_url": "https://api.github.com/users/partim/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc6c6383f6999d87c92be3dfd5f09c357be41135", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc6c6383f6999d87c92be3dfd5f09c357be41135", "html_url": "https://github.com/rust-lang/rust/commit/fc6c6383f6999d87c92be3dfd5f09c357be41135"}], "stats": {"total": 74, "additions": 44, "deletions": 30}, "files": [{"sha": "1f692d019c3de4472d652671877d4dfc2558ab6d", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 44, "deletions": 30, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/7ae7e5393367cdc9a630cd56911ab42f499c091f/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae7e5393367cdc9a630cd56911ab42f499c091f/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=7ae7e5393367cdc9a630cd56911ab42f499c091f", "patch": "@@ -14,19 +14,28 @@\n \n /// A trait identifying how borrowed data behaves.\n ///\n-/// If a type implements this trait, it signals that a reference to it behaves\n-/// exactly like a reference to `Borrowed`. As a consequence, if a trait is\n-/// implemented both by `Self` and `Borrowed`, all trait methods that\n-/// take a `&self` argument must produce the same result in both\n-/// implementations.\n-///\n-/// As a consequence, this trait should only be implemented for types managing\n-/// a value of another type without modifying its behavior. Examples are\n-/// smart pointers such as [`Box<T>`] or [`Rc<T>`] as well the owned version\n-/// of slices such as [`Vec<T>`].\n-///\n-/// A relaxed version that allows converting a reference to some other type\n-/// without any further promises is available through [`AsRef`].\n+/// In Rust, it is common to provide different representations of a type for\n+/// different use cases. For instance, storage location and management for a\n+/// value can be specifically chosen as appropriate for a particular use via\n+/// pointer types such as [`Box<T>`] or [`Rc<T>`] or one can opt into\n+/// concurrency via synchronization types such as [`Mutex<T>`], avoiding the\n+/// associated cost when in parallel doesn\u2019t happen. Beyond these generic\n+/// wrappers that can be used with any type, some types provide optional\n+/// facets providing potentially costly functionality. An example for such a\n+/// type is [`String`] which adds the ability to extend a string to the basic\n+/// [`str`]. This requires keeping additional information unnecessary for a\n+/// simple, imutable string.\n+///\n+/// These types signal that they are a specialized representation of a basic\n+/// type `T` by implementing `Borrow<T>`. The method `borrow` provides a way\n+/// to convert a reference to the type into a reference to the underlying\n+/// basic type.\n+///\n+/// If a type implementing `Borrow<T>` implements other traits also\n+/// implemented by `T`, these implementations behave identically if the trait\n+/// is concerned with the data rather than its representation. For instance,\n+/// the comparison traits such as `PartialEq` or `PartialOrd` must behave\n+/// identical for `T` and any type implemeting `Borrow<T>`.\n ///\n /// When writing generic code, a use of `Borrow` should always be justified\n /// by additional trait bounds, making it clear that the two types need to\n@@ -37,11 +46,13 @@\n /// The companion trait [`BorrowMut`] provides the same guarantees for\n /// mutable references.\n ///\n-/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n-/// [`Rc<T>`]: ../../std/rc/struct.Rc.html\n-/// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n /// [`AsRef`]: ../../std/convert/trait.AsRef.html\n /// [`BorrowMut`]: trait.BorrowMut.html\n+/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n+/// [`Mutex<T>`]: ../../std/sync/struct.Mutex.html\n+/// [`Rc<T>`]: ../../std/rc/struct.Rc.html\n+/// [`str`]: ../../std/primitive.str.html\n+/// [`String`]: ../../std/string/struct.String.html\n ///\n /// # Examples\n ///\n@@ -85,30 +96,34 @@\n /// ```\n ///\n /// The entire hash map is generic over a key type `K`. Because these keys\n-/// are stored by with the hash map, this type as to own the key\u2019s data.\n+/// are stored with the hash map, this type has to own the key\u2019s data.\n /// When inserting a key-value pair, the map is given such a `K` and needs\n /// to find the correct hash bucket and check if the key is already present\n /// based on that `K`. It therefore requires `K: Hash + Eq`.\n ///\n-/// In order to search for a value based on the key\u2019s data, the `get` method\n-/// is generic over some type `Q`. Technically, it needs to convert that `Q`\n-/// into a `K` in order to use `K`\u2019s [`Hash`] implementation to be able to\n-/// arrive at the same hash value as during insertion in order to look into\n-/// the right hash bucket. Since `K` is some kind of owned value, this likely\n-/// would involve cloning and isn\u2019t really practical.\n+/// When searching for a value in the map, however, having to provide a\n+/// reference to a `K` as the key to search for would require to always\n+/// create such an owned value. For string keys, this would mean a `String`\n+/// value needs to be created just for the search for cases where only a\n+/// `str` is available.\n ///\n-/// Instead, `get` relies on `Q`\u2019s implementation of `Hash` and uses `Borrow`\n-/// to indicate that `K`\u2019s implementation of `Hash` must produce the same\n-/// result as `Q`\u2019s by demanding that `K: Borrow<Q>`.\n+/// Instead, the `get` method is generic over the type of the underlying key\n+/// data, called `Q` in the method signature above. It states that `K` is a\n+/// representation of `Q` by requiring that `K: Borrow<Q>`. By additionally\n+/// requiring `Q: Hash + Eq`, it demands that `K` and `Q` have\n+/// implementations of the `Hash` and `Eq` traits that procude identical\n+/// results.\n+///\n+/// The implementation of `get` relies in particular on identical\n+/// implementations of `Hash` by determining the key\u2019s hash bucket by calling\n+/// `Hash::hash` on the `Q` value even though it inserted the key based on\n+/// the hash value calculated from the `K` value.\n ///\n /// As a consequence, the hash map breaks if a `K` wrapping a `Q` value\n /// produces a different hash than `Q`. For instance, imagine you have a\n /// type that wraps a string but compares ASCII letters ignoring their case:\n ///\n /// ```\n-/// # #[allow(unused_imports)]\n-/// use std::ascii::AsciiExt;\n-///\n /// pub struct CIString(String);\n ///\n /// impl PartialEq for CIString {\n@@ -124,7 +139,6 @@\n /// implementation of `Hash` needs to reflect that, too:\n ///\n /// ```\n-/// # #[allow(unused_imports)] use std::ascii::AsciiExt;\n /// # use std::hash::{Hash, Hasher};\n /// # pub struct CIString(String);\n /// impl Hash for CIString {"}]}