{"sha": "efdbc0ec7e9bd8d2dadbe78b003fd7facf2a7aae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmZGJjMGVjN2U5YmQ4ZDJkYWRiZTc4YjAwM2ZkN2ZhY2YyYTdhYWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-04T22:55:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-04T22:55:31Z"}, "message": "Auto merge of #27351 - pnkfelix:dst-size-and-align-issue-27023, r=nikomatsakis\n\nChange the behavior of the glue code emitted for `size_and_align_of_dst`.\r\n\r\nThis thus changes the behavior of `std::mem::size_of_val` and `std::mem::align_of_val`.  It tries to move us towards a world where the following property holds:\r\n\r\nGiven type `T` implements `Trait` and a value `b: Box<T>`, where `std::mem::size_of::<T>()` returns `k`, then:\r\n\r\n * `std::mem::size_of_val(b)` returns `k`\r\n * `std::mem::size_of_val(b as Box<Trait>)` returns `k`\r\n\r\nNote that one might legitimately question whether the above property *should* hold.  The property certainly does not hold today, as illustrated by #27023.\r\n\r\n(A follow-up task is to make various tests that check that the above property holds for a wide variety of types ... I chose not to invest effort in writing such a test before we actually determine that the above property is desirable.)\r\n\r\nnmatsakis and pnkfelix agree that this PR does not require an RFC.  cc @rust-lang/lang (since others may disagree).\r\n\r\n(It also *might* break code, though it is hard for me to imagine that it could break code that wasn't already going to assert-fail when run in e.g. debug builds...)\r\n\r\nFix issue #27023\r\n\r\nAlso, this (or something like it) is a prerequisite for *fixing`make check` on `--enable-optimize --enable-debug` builds*", "tree": {"sha": "e695c4896a1505db71cf37d181d4e58a8962df26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e695c4896a1505db71cf37d181d4e58a8962df26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efdbc0ec7e9bd8d2dadbe78b003fd7facf2a7aae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efdbc0ec7e9bd8d2dadbe78b003fd7facf2a7aae", "html_url": "https://github.com/rust-lang/rust/commit/efdbc0ec7e9bd8d2dadbe78b003fd7facf2a7aae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efdbc0ec7e9bd8d2dadbe78b003fd7facf2a7aae/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6afb8f58d18311109081cfaff2fa5a02948989c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6afb8f58d18311109081cfaff2fa5a02948989c3", "html_url": "https://github.com/rust-lang/rust/commit/6afb8f58d18311109081cfaff2fa5a02948989c3"}, {"sha": "21be09448b21c25570f28ddd597f3d30ccc6fabf", "url": "https://api.github.com/repos/rust-lang/rust/commits/21be09448b21c25570f28ddd597f3d30ccc6fabf", "html_url": "https://github.com/rust-lang/rust/commit/21be09448b21c25570f28ddd597f3d30ccc6fabf"}], "stats": {"total": 182, "additions": 154, "deletions": 28}, "files": [{"sha": "1a5eebfa77ae4ed0f4148e51cb295abd63f2b49f", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 94, "deletions": 17, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/efdbc0ec7e9bd8d2dadbe78b003fd7facf2a7aae/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efdbc0ec7e9bd8d2dadbe78b003fd7facf2a7aae/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=efdbc0ec7e9bd8d2dadbe78b003fd7facf2a7aae", "patch": "@@ -67,6 +67,31 @@ use trans::type_of;\n \n type Hint = attr::ReprAttr;\n \n+// Representation of the context surrounding an unsized type. I want\n+// to be able to track the drop flags that are injected by trans.\n+#[derive(Clone, Copy, PartialEq, Debug)]\n+pub struct TypeContext {\n+    prefix: Type,\n+    needs_drop_flag: bool,\n+}\n+\n+impl TypeContext {\n+    pub fn prefix(&self) -> Type { self.prefix }\n+    pub fn needs_drop_flag(&self) -> bool { self.needs_drop_flag }\n+\n+    fn direct(t: Type) -> TypeContext {\n+        TypeContext { prefix: t, needs_drop_flag: false }\n+    }\n+    fn may_need_drop_flag(t: Type, needs_drop_flag: bool) -> TypeContext {\n+        TypeContext { prefix: t, needs_drop_flag: needs_drop_flag }\n+    }\n+    pub fn to_string(self) -> String {\n+        let TypeContext { prefix, needs_drop_flag } = self;\n+        format!(\"TypeContext {{ prefix: {}, needs_drop_flag: {} }}\",\n+                prefix.to_string(), needs_drop_flag)\n+    }\n+}\n+\n /// Representations.\n #[derive(Eq, PartialEq, Debug)]\n pub enum Repr<'tcx> {\n@@ -125,7 +150,7 @@ pub struct Struct<'tcx> {\n     pub align: u32,\n     pub sized: bool,\n     pub packed: bool,\n-    pub fields: Vec<Ty<'tcx>>\n+    pub fields: Vec<Ty<'tcx>>,\n }\n \n /// Convenience for `represent_type`.  There should probably be more or\n@@ -681,18 +706,30 @@ fn ensure_enum_fits_in_address_space<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n /// and fill in the actual contents in a second pass to prevent\n /// unbounded recursion; see also the comments in `trans::type_of`.\n pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>) -> Type {\n-    generic_type_of(cx, r, None, false, false)\n+    let c = generic_type_of(cx, r, None, false, false, false);\n+    assert!(!c.needs_drop_flag);\n+    c.prefix\n }\n+\n+\n // Pass dst=true if the type you are passing is a DST. Yes, we could figure\n // this out, but if you call this on an unsized type without realising it, you\n // are going to get the wrong type (it will not include the unsized parts of it).\n pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                 r: &Repr<'tcx>, dst: bool) -> Type {\n-    generic_type_of(cx, r, None, true, dst)\n+    let c = generic_type_of(cx, r, None, true, dst, false);\n+    assert!(!c.needs_drop_flag);\n+    c.prefix\n+}\n+pub fn sizing_type_context_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                        r: &Repr<'tcx>, dst: bool) -> TypeContext {\n+    generic_type_of(cx, r, None, true, dst, true)\n }\n pub fn incomplete_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                     r: &Repr<'tcx>, name: &str) -> Type {\n-    generic_type_of(cx, r, Some(name), false, false)\n+    let c = generic_type_of(cx, r, Some(name), false, false, false);\n+    assert!(!c.needs_drop_flag);\n+    c.prefix\n }\n pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                 r: &Repr<'tcx>, llty: &mut Type) {\n@@ -708,20 +745,50 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                              r: &Repr<'tcx>,\n                              name: Option<&str>,\n                              sizing: bool,\n-                             dst: bool) -> Type {\n+                             dst: bool,\n+                             delay_drop_flag: bool) -> TypeContext {\n+    debug!(\"adt::generic_type_of r: {:?} name: {:?} sizing: {} dst: {} delay_drop_flag: {}\",\n+           r, name, sizing, dst, delay_drop_flag);\n     match *r {\n-        CEnum(ity, _, _) => ll_inttype(cx, ity),\n-        RawNullablePointer { nnty, .. } => type_of::sizing_type_of(cx, nnty),\n-        Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } => {\n+        CEnum(ity, _, _) => TypeContext::direct(ll_inttype(cx, ity)),\n+        RawNullablePointer { nnty, .. } =>\n+            TypeContext::direct(type_of::sizing_type_of(cx, nnty)),\n+        StructWrappedNullablePointer { nonnull: ref st, .. } => {\n+            match name {\n+                None => {\n+                    TypeContext::direct(\n+                        Type::struct_(cx, &struct_llfields(cx, st, sizing, dst),\n+                                      st.packed))\n+                }\n+                Some(name) => {\n+                    assert_eq!(sizing, false);\n+                    TypeContext::direct(Type::named_struct(cx, name))\n+                }\n+            }\n+        }\n+        Univariant(ref st, dtor_needed) => {\n+            let dtor_needed = dtor_needed != 0;\n             match name {\n                 None => {\n-                    Type::struct_(cx, &struct_llfields(cx, st, sizing, dst),\n-                                  st.packed)\n+                    let mut fields = struct_llfields(cx, st, sizing, dst);\n+                    if delay_drop_flag && dtor_needed {\n+                        fields.pop();\n+                    }\n+                    TypeContext::may_need_drop_flag(\n+                        Type::struct_(cx, &fields,\n+                                      st.packed),\n+                        delay_drop_flag && dtor_needed)\n+                }\n+                Some(name) => {\n+                    // Hypothesis: named_struct's can never need a\n+                    // drop flag. (... needs validation.)\n+                    assert_eq!(sizing, false);\n+                    TypeContext::direct(Type::named_struct(cx, name))\n                 }\n-                Some(name) => { assert_eq!(sizing, false); Type::named_struct(cx, name) }\n             }\n         }\n-        General(ity, ref sts, _) => {\n+        General(ity, ref sts, dtor_needed) => {\n+            let dtor_needed = dtor_needed != 0;\n             // We need a representation that has:\n             // * The alignment of the most-aligned field\n             // * The size of the largest variant (rounded up to that alignment)\n@@ -753,15 +820,25 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             };\n             assert_eq!(machine::llalign_of_min(cx, fill_ty), align);\n             assert_eq!(align_s % discr_size, 0);\n-            let fields = [discr_ty,\n-                          Type::array(&discr_ty, align_s / discr_size - 1),\n-                          fill_ty];\n+            let mut fields: Vec<Type> =\n+                [discr_ty,\n+                 Type::array(&discr_ty, align_s / discr_size - 1),\n+                 fill_ty].iter().cloned().collect();\n+            if delay_drop_flag && dtor_needed {\n+                fields.pop();\n+            }\n             match name {\n-                None => Type::struct_(cx, &fields[..], false),\n+                None => {\n+                    TypeContext::may_need_drop_flag(\n+                        Type::struct_(cx, &fields[..], false),\n+                        delay_drop_flag && dtor_needed)\n+                }\n                 Some(name) => {\n                     let mut llty = Type::named_struct(cx, name);\n                     llty.set_struct_body(&fields[..], false);\n-                    llty\n+                    TypeContext::may_need_drop_flag(\n+                        llty,\n+                        delay_drop_flag && dtor_needed)\n                 }\n             }\n         }"}, {"sha": "18fedda49193cfcabbf8bd28384dc360c7c59128", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 53, "deletions": 8, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/efdbc0ec7e9bd8d2dadbe78b003fd7facf2a7aae/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efdbc0ec7e9bd8d2dadbe78b003fd7facf2a7aae/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=efdbc0ec7e9bd8d2dadbe78b003fd7facf2a7aae", "patch": "@@ -406,8 +406,12 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n            t, bcx.val_to_string(info));\n     if type_is_sized(bcx.tcx(), t) {\n         let sizing_type = sizing_type_of(bcx.ccx(), t);\n-        let size = C_uint(bcx.ccx(), llsize_of_alloc(bcx.ccx(), sizing_type));\n-        let align = C_uint(bcx.ccx(), align_of(bcx.ccx(), t));\n+        let size = llsize_of_alloc(bcx.ccx(), sizing_type);\n+        let align = align_of(bcx.ccx(), t);\n+        debug!(\"size_and_align_of_dst t={} info={} size: {} align: {}\",\n+               t, bcx.val_to_string(info), size, align);\n+        let size = C_uint(bcx.ccx(), size);\n+        let align = C_uint(bcx.ccx(), align);\n         return (size, align);\n     }\n     match t.sty {\n@@ -417,9 +421,14 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n             // Don't use type_of::sizing_type_of because that expects t to be sized.\n             assert!(!t.is_simd(bcx.tcx()));\n             let repr = adt::represent_type(ccx, t);\n-            let sizing_type = adt::sizing_type_of(ccx, &*repr, true);\n-            let sized_size = C_uint(ccx, llsize_of_alloc(ccx, sizing_type));\n-            let sized_align = C_uint(ccx, llalign_of_min(ccx, sizing_type));\n+            let sizing_type = adt::sizing_type_context_of(ccx, &*repr, true);\n+            debug!(\"DST {} sizing_type: {}\", t, sizing_type.to_string());\n+            let sized_size = llsize_of_alloc(ccx, sizing_type.prefix());\n+            let sized_align = llalign_of_min(ccx, sizing_type.prefix());\n+            debug!(\"DST {} statically sized prefix size: {} align: {}\",\n+                   t, sized_size, sized_align);\n+            let sized_size = C_uint(ccx, sized_size);\n+            let sized_align = C_uint(ccx, sized_align);\n \n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n@@ -428,16 +437,52 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n             let field_ty = last_field.mt.ty;\n             let (unsized_size, unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n \n+            let dbloc = DebugLoc::None;\n+\n+            // FIXME (#26403, #27023): We should be adding padding\n+            // to `sized_size` (to accommodate the `unsized_align`\n+            // required of the unsized field that follows) before\n+            // summing it with `sized_size`. (Note that since #26403\n+            // is unfixed, we do not yet add the necessary padding\n+            // here. But this is where the add would go.)\n+\n             // Return the sum of sizes and max of aligns.\n-            let size = Add(bcx, sized_size, unsized_size, DebugLoc::None);\n+            let mut size = Add(bcx, sized_size, unsized_size, dbloc);\n+\n+            // Issue #27023: If there is a drop flag, *now* we add 1\n+            // to the size.  (We can do this without adding any\n+            // padding because drop flags do not have any alignment\n+            // constraints.)\n+            if sizing_type.needs_drop_flag() {\n+                size = Add(bcx, size, C_uint(bcx.ccx(), 1_u64), dbloc);\n+            }\n+\n+            // Choose max of two known alignments (combined value must\n+            // be aligned according to more restrictive of the two).\n             let align = Select(bcx,\n                                ICmp(bcx,\n-                                    llvm::IntULT,\n+                                    llvm::IntUGT,\n                                     sized_align,\n                                     unsized_align,\n-                                    DebugLoc::None),\n+                                    dbloc),\n                                sized_align,\n                                unsized_align);\n+\n+            // Issue #27023: must add any necessary padding to `size`\n+            // (to make it a multiple of `align`) before returning it.\n+            //\n+            // Namely, the returned size should be, in C notation:\n+            //\n+            //   `size + ((size & (align-1)) ? align : 0)`\n+            //\n+            // emulated via the semi-standard fast bit trick:\n+            //\n+            //   `(size + (align-1)) & !align`\n+\n+            let addend = Sub(bcx, align, C_uint(bcx.ccx(), 1_u64), dbloc);\n+            let size = And(\n+                bcx, Add(bcx, size, addend, dbloc), Neg(bcx, align, dbloc), dbloc);\n+\n             (size, align)\n         }\n         ty::TyTrait(..) => {"}, {"sha": "699115a07098640a15beeb89af252fb603c2e5d3", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/efdbc0ec7e9bd8d2dadbe78b003fd7facf2a7aae/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efdbc0ec7e9bd8d2dadbe78b003fd7facf2a7aae/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=efdbc0ec7e9bd8d2dadbe78b003fd7facf2a7aae", "patch": "@@ -50,6 +50,12 @@ impl Type {\n         self.rf\n     }\n \n+    pub fn to_string(self: Type) -> String {\n+        llvm::build_string(|s| unsafe {\n+            llvm::LLVMWriteTypeToString(self.to_ref(), s);\n+        }).expect(\"non-UTF8 type description from LLVM\")\n+    }\n+\n     pub fn void(ccx: &CrateContext) -> Type {\n         ty!(llvm::LLVMVoidTypeInContext(ccx.llcx()))\n     }\n@@ -315,9 +321,7 @@ impl TypeNames {\n     }\n \n     pub fn type_to_string(&self, ty: Type) -> String {\n-        llvm::build_string(|s| unsafe {\n-                llvm::LLVMWriteTypeToString(ty.to_ref(), s);\n-            }).expect(\"non-UTF8 type description from LLVM\")\n+        ty.to_string()\n     }\n \n     pub fn types_to_str(&self, tys: &[Type]) -> String {"}]}