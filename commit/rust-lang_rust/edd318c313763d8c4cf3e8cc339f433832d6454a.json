{"sha": "edd318c313763d8c4cf3e8cc339f433832d6454a", "node_id": "C_kwDOAAsO6NoAKGVkZDMxOGMzMTM3NjNkOGM0Y2YzZThjYzMzOWY0MzM4MzJkNjQ1NGE", "commit": {"author": {"name": "ltdk", "email": "usr@ltdk.xyz", "date": "2021-06-20T20:24:10Z"}, "committer": {"name": "ltdk", "email": "usr@ltdk.xyz", "date": "2022-02-07T18:34:08Z"}, "message": "Add {floor,ceil}_char_boundary methods to str", "tree": {"sha": "0463e1bc15848013c6247cff458ebc7475eef216", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0463e1bc15848013c6247cff458ebc7475eef216"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edd318c313763d8c4cf3e8cc339f433832d6454a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edd318c313763d8c4cf3e8cc339f433832d6454a", "html_url": "https://github.com/rust-lang/rust/commit/edd318c313763d8c4cf3e8cc339f433832d6454a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edd318c313763d8c4cf3e8cc339f433832d6454a/comments", "author": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5e414843ebfe25674d8e18a5369d6249fdee741", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5e414843ebfe25674d8e18a5369d6249fdee741", "html_url": "https://github.com/rust-lang/rust/commit/c5e414843ebfe25674d8e18a5369d6249fdee741"}], "stats": {"total": 199, "additions": 176, "deletions": 23}, "files": [{"sha": "cbb86265233b0bdcc4578ffb210396b135d1f405", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/edd318c313763d8c4cf3e8cc339f433832d6454a/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edd318c313763d8c4cf3e8cc339f433832d6454a/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=edd318c313763d8c4cf3e8cc339f433832d6454a", "patch": "@@ -29,6 +29,7 @@\n #![feature(binary_heap_as_slice)]\n #![feature(inplace_iteration)]\n #![feature(iter_advance_by)]\n+#![feature(round_char_boundary)]\n #![feature(slice_group_by)]\n #![feature(slice_partition_dedup)]\n #![feature(string_remove_matches)]"}, {"sha": "6b8be2506b64e5bc8d179eaae03798c003ce42f9", "filename": "library/alloc/tests/str.rs", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/edd318c313763d8c4cf3e8cc339f433832d6454a/library%2Falloc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edd318c313763d8c4cf3e8cc339f433832d6454a/library%2Falloc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstr.rs?ref=edd318c313763d8c4cf3e8cc339f433832d6454a", "patch": "@@ -2272,3 +2272,95 @@ fn utf8_char_counts() {\n         }\n     }\n }\n+\n+#[test]\n+fn floor_char_boundary() {\n+    fn check_many(s: &str, arg: impl IntoIterator<Item = usize>, ret: usize) {\n+        for idx in arg {\n+            assert_eq!(\n+                s.floor_char_boundary(idx),\n+                ret,\n+                \"{:?}.floor_char_boundary({:?}) != {:?}\",\n+                s,\n+                idx,\n+                ret\n+            );\n+        }\n+    }\n+\n+    // edge case\n+    check_many(\"\", [0, 1, isize::MAX as usize, usize::MAX], 0);\n+\n+    // basic check\n+    check_many(\"x\", [0], 0);\n+    check_many(\"x\", [1, isize::MAX as usize, usize::MAX], 1);\n+\n+    // 1-byte chars\n+    check_many(\"jp\", [0], 0);\n+    check_many(\"jp\", [1], 1);\n+    check_many(\"jp\", 2..4, 2);\n+\n+    // 2-byte chars\n+    check_many(\"\u0135\u01a5\", 0..2, 0);\n+    check_many(\"\u0135\u01a5\", 2..4, 2);\n+    check_many(\"\u0135\u01a5\", 4..6, 4);\n+\n+    // 3-byte chars\n+    check_many(\"\u65e5\u672c\", 0..3, 0);\n+    check_many(\"\u65e5\u672c\", 3..6, 3);\n+    check_many(\"\u65e5\u672c\", 6..8, 6);\n+\n+    // 4-byte chars\n+    check_many(\"\ud83c\uddef\ud83c\uddf5\", 0..4, 0);\n+    check_many(\"\ud83c\uddef\ud83c\uddf5\", 4..8, 4);\n+    check_many(\"\ud83c\uddef\ud83c\uddf5\", 8..10, 8);\n+}\n+\n+#[test]\n+fn ceil_char_boundary() {\n+    fn check_many(s: &str, arg: impl IntoIterator<Item = usize>, ret: usize) {\n+        for idx in arg {\n+            assert_eq!(\n+                s.ceil_char_boundary(idx),\n+                ret,\n+                \"{:?}.ceil_char_boundary({:?}) != {:?}\",\n+                s,\n+                idx,\n+                ret\n+            );\n+        }\n+    }\n+\n+    // edge case\n+    check_many(\"\", [0], 0);\n+\n+    // basic check\n+    check_many(\"x\", [0], 0);\n+    check_many(\"x\", [1], 1);\n+\n+    // 1-byte chars\n+    check_many(\"jp\", [0], 0);\n+    check_many(\"jp\", [1], 1);\n+    check_many(\"jp\", [2], 2);\n+\n+    // 2-byte chars\n+    check_many(\"\u0135\u01a5\", 0..=0, 0);\n+    check_many(\"\u0135\u01a5\", 1..=2, 2);\n+    check_many(\"\u0135\u01a5\", 3..=4, 4);\n+\n+    // 3-byte chars\n+    check_many(\"\u65e5\u672c\", 0..=0, 0);\n+    check_many(\"\u65e5\u672c\", 1..=3, 3);\n+    check_many(\"\u65e5\u672c\", 4..=6, 6);\n+\n+    // 4-byte chars\n+    check_many(\"\ud83c\uddef\ud83c\uddf5\", 0..=0, 0);\n+    check_many(\"\ud83c\uddef\ud83c\uddf5\", 1..=4, 4);\n+    check_many(\"\ud83c\uddef\ud83c\uddf5\", 5..=8, 8);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn ceil_char_boundary_above_len_panic() {\n+    let _ = \"x\".ceil_char_boundary(2);\n+}"}, {"sha": "864a253299f6e28b00a58691006b3ccc2f84ada4", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/edd318c313763d8c4cf3e8cc339f433832d6454a/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edd318c313763d8c4cf3e8cc339f433832d6454a/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=edd318c313763d8c4cf3e8cc339f433832d6454a", "patch": "@@ -809,6 +809,11 @@ impl u8 {\n     pub fn escape_ascii(&self) -> ascii::EscapeDefault {\n         ascii::escape_default(*self)\n     }\n+\n+    pub(crate) fn is_utf8_char_boundary(self) -> bool {\n+        // This is bit magic equivalent to: b < 128 || b >= 192\n+        (self as i8) >= -0x40\n+    }\n }\n \n #[lang = \"u16\"]"}, {"sha": "09709dc3cf6dfbd187f2ecfe020ad0a6a07fbe33", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 78, "deletions": 10, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/edd318c313763d8c4cf3e8cc339f433832d6454a/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edd318c313763d8c4cf3e8cc339f433832d6454a/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=edd318c313763d8c4cf3e8cc339f433832d6454a", "patch": "@@ -76,15 +76,14 @@ use iter::MatchIndicesInternal;\n use iter::SplitInternal;\n use iter::{MatchesInternal, SplitNInternal};\n \n-use validations::truncate_to_char_boundary;\n-\n #[inline(never)]\n #[cold]\n #[track_caller]\n fn slice_error_fail(s: &str, begin: usize, end: usize) -> ! {\n     const MAX_DISPLAY_LENGTH: usize = 256;\n-    let (truncated, s_trunc) = truncate_to_char_boundary(s, MAX_DISPLAY_LENGTH);\n-    let ellipsis = if truncated { \"[...]\" } else { \"\" };\n+    let trunc_len = s.floor_char_boundary(MAX_DISPLAY_LENGTH);\n+    let s_trunc = &s[..trunc_len];\n+    let ellipsis = if trunc_len < s.len() { \"[...]\" } else { \"\" };\n \n     // 1. out of bounds\n     if begin > s.len() || end > s.len() {\n@@ -105,10 +104,7 @@ fn slice_error_fail(s: &str, begin: usize, end: usize) -> ! {\n     // 3. character boundary\n     let index = if !s.is_char_boundary(begin) { begin } else { end };\n     // find the character\n-    let mut char_start = index;\n-    while !s.is_char_boundary(char_start) {\n-        char_start -= 1;\n-    }\n+    let char_start = s.floor_char_boundary(index);\n     // `char_start` must be less than len and a char boundary\n     let ch = s[char_start..].chars().next().unwrap();\n     let char_range = char_start..char_start + ch.len_utf8();\n@@ -215,8 +211,80 @@ impl str {\n             // code on higher opt-levels. See PR #84751 for more details.\n             None => index == self.len(),\n \n-            // This is bit magic equivalent to: b < 128 || b >= 192\n-            Some(&b) => (b as i8) >= -0x40,\n+            Some(&b) => b.is_utf8_char_boundary(),\n+        }\n+    }\n+\n+    /// Finds the closest `x` not exceeding `index` where `is_char_boundary(x)` is `true`.\n+    ///\n+    /// This method can help you truncate a string so that it's still valid UTF-8, but doesn't\n+    /// exceed a given number of bytes. Note that this is done purely at the character level\n+    /// and can still visually split graphemes, even though the underlying characters aren't\n+    /// split. For example, the emoji \ud83e\uddd1\u200d\ud83d\udd2c (scientist) could be split so that the string only\n+    /// includes \ud83e\uddd1 (person) instead.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(round_char_boundary)]\n+    /// let s = \"\u2764\ufe0f\ud83e\udde1\ud83d\udc9b\ud83d\udc9a\ud83d\udc99\ud83d\udc9c\";\n+    /// assert_eq!(s.len(), 26);\n+    /// assert!(!s.is_char_boundary(13));\n+    ///\n+    /// let closest = s.floor_char_boundary(13);\n+    /// assert_eq!(closest, 10);\n+    /// assert_eq!(&s[..closest], \"\u2764\ufe0f\ud83e\udde1\");\n+    /// ```\n+    #[unstable(feature = \"round_char_boundary\", issue = \"93743\")]\n+    #[inline]\n+    pub fn floor_char_boundary(&self, index: usize) -> usize {\n+        if index >= self.len() {\n+            self.len()\n+        } else {\n+            let lower_bound = index.saturating_sub(3);\n+            let new_index = self.as_bytes()[lower_bound..=index]\n+                .iter()\n+                .rposition(|b| b.is_utf8_char_boundary());\n+\n+            // SAFETY: we know that the character boundary will be within four bytes\n+            unsafe { lower_bound + new_index.unwrap_unchecked() }\n+        }\n+    }\n+\n+    /// Finds the closest `x` not below `index` where `is_char_boundary(x)` is `true`.\n+    ///\n+    /// This method is the natural complement to [`floor_char_boundary`]. See that method\n+    /// for more details.\n+    ///\n+    /// [`floor_char_boundary`]: str::floor_char_boundary\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index > self.len()`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(round_char_boundary)]\n+    /// let s = \"\u2764\ufe0f\ud83e\udde1\ud83d\udc9b\ud83d\udc9a\ud83d\udc99\ud83d\udc9c\";\n+    /// assert_eq!(s.len(), 26);\n+    /// assert!(!s.is_char_boundary(13));\n+    ///\n+    /// let closest = s.ceil_char_boundary(13);\n+    /// assert_eq!(closest, 14);\n+    /// assert_eq!(&s[..closest], \"\u2764\ufe0f\ud83e\udde1\ud83d\udc9b\");\n+    /// ```\n+    #[unstable(feature = \"round_char_boundary\", issue = \"93743\")]\n+    #[inline]\n+    pub fn ceil_char_boundary(&self, index: usize) -> usize {\n+        if index > self.len() {\n+            slice_error_fail(self, index, index)\n+        } else {\n+            let upper_bound = Ord::min(index + 4, self.len());\n+            self.as_bytes()[index..upper_bound]\n+                .iter()\n+                .position(|b| b.is_utf8_char_boundary())\n+                .map_or(upper_bound, |pos| pos + index)\n         }\n     }\n "}, {"sha": "0d3dc856be577c44669176a29cb182c6cdc95316", "filename": "library/core/src/str/validations.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/edd318c313763d8c4cf3e8cc339f433832d6454a/library%2Fcore%2Fsrc%2Fstr%2Fvalidations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edd318c313763d8c4cf3e8cc339f433832d6454a/library%2Fcore%2Fsrc%2Fstr%2Fvalidations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fvalidations.rs?ref=edd318c313763d8c4cf3e8cc339f433832d6454a", "patch": "@@ -273,16 +273,3 @@ pub const fn utf8_char_width(b: u8) -> usize {\n \n /// Mask of the value bits of a continuation byte.\n const CONT_MASK: u8 = 0b0011_1111;\n-\n-// truncate `&str` to length at most equal to `max`\n-// return `true` if it were truncated, and the new str.\n-pub(super) fn truncate_to_char_boundary(s: &str, mut max: usize) -> (bool, &str) {\n-    if max >= s.len() {\n-        (false, s)\n-    } else {\n-        while !s.is_char_boundary(max) {\n-            max -= 1;\n-        }\n-        (true, &s[..max])\n-    }\n-}"}]}