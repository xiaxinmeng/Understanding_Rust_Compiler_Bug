{"sha": "742ebc17ff4d033f6b5c6348ddb1c94d730c56b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0MmViYzE3ZmY0ZDAzM2Y2YjVjNjM0OGRkYjFjOTRkNzMwYzU2Yjg=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-05-15T13:09:30Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-05-15T13:28:28Z"}, "message": "Share lists of blanket impls in results of relevant_impls_for() query.", "tree": {"sha": "69abfbc78d52531fcfd393330ff75f7fed5cee67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69abfbc78d52531fcfd393330ff75f7fed5cee67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/742ebc17ff4d033f6b5c6348ddb1c94d730c56b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/742ebc17ff4d033f6b5c6348ddb1c94d730c56b8", "html_url": "https://github.com/rust-lang/rust/commit/742ebc17ff4d033f6b5c6348ddb1c94d730c56b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/742ebc17ff4d033f6b5c6348ddb1c94d730c56b8/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40a6734ae1a1ec9ad96b8f5b58a64d10d0cdbe76", "url": "https://api.github.com/repos/rust-lang/rust/commits/40a6734ae1a1ec9ad96b8f5b58a64d10d0cdbe76", "html_url": "https://github.com/rust-lang/rust/commit/40a6734ae1a1ec9ad96b8f5b58a64d10d0cdbe76"}], "stats": {"total": 135, "additions": 108, "deletions": 27}, "files": [{"sha": "0e5779f9d17935b291fc1d72aec74fd879166c0f", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/742ebc17ff4d033f6b5c6348ddb1c94d730c56b8/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/742ebc17ff4d033f6b5c6348ddb1c94d730c56b8/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=742ebc17ff4d033f6b5c6348ddb1c94d730c56b8", "patch": "@@ -293,7 +293,19 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n                                                       -> Rc<specialization_graph::Graph> {\n     let mut sg = specialization_graph::Graph::new();\n \n-    for &impl_def_id in tcx.trait_impls_of(trait_id).iter() {\n+    let mut trait_impls: Vec<DefId> = tcx.trait_impls_of(trait_id).iter().collect();\n+\n+    // The coherence checking implementation seems to rely on impls being\n+    // iterated over (roughly) in definition order, so we are sorting by\n+    // negated CrateNum (so remote definitions are visited first) and then\n+    // by a flattend version of the DefIndex.\n+    trait_impls.sort_unstable_by_key(|def_id| {\n+        (-(def_id.krate.as_u32() as i64),\n+         def_id.index.address_space().index(),\n+         def_id.index.as_array_index())\n+    });\n+\n+    for impl_def_id in trait_impls {\n         if impl_def_id.is_local() {\n             // This is where impl overlap checking happens:\n             let insert_result = sg.insert(tcx, impl_def_id);"}, {"sha": "0926da2005d6f29c3a5fdb8560812360786a91ea", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/742ebc17ff4d033f6b5c6348ddb1c94d730c56b8/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/742ebc17ff4d033f6b5c6348ddb1c94d730c56b8/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=742ebc17ff4d033f6b5c6348ddb1c94d730c56b8", "patch": "@@ -850,10 +850,10 @@ define_maps! { <'tcx>\n     [] const_is_rvalue_promotable_to_static: ConstIsRvaluePromotableToStatic(DefId) -> bool,\n     [] is_mir_available: IsMirAvailable(DefId) -> bool,\n \n-    [] trait_impls_of: TraitImpls(DefId) -> Rc<Vec<DefId>>,\n+    [] trait_impls_of: TraitImpls(DefId) -> ty::trait_def::TraitImpls,\n     // Note that TraitDef::for_each_relevant_impl() will do type simplication for you.\n     [] relevant_trait_impls_for: relevant_trait_impls_for((DefId, SimplifiedType))\n-        -> Rc<Vec<DefId>>,\n+        -> ty::trait_def::TraitImpls,\n     [] specialization_graph_of: SpecializationGraph(DefId) -> Rc<specialization_graph::Graph>,\n     [] is_object_safe: ObjectSafety(DefId) -> bool,\n }"}, {"sha": "eb60f9d101073f03fbb56c370f725b019d9470f5", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 93, "deletions": 24, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/742ebc17ff4d033f6b5c6348ddb1c94d730c56b8/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/742ebc17ff4d033f6b5c6348ddb1c94d730c56b8/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=742ebc17ff4d033f6b5c6348ddb1c94d730c56b8", "patch": "@@ -35,6 +35,60 @@ pub struct TraitDef {\n     pub def_path_hash: u64,\n }\n \n+// We don't store the list of impls in a flat list because each cached list of\n+// `relevant_impls_for` we would then duplicate all blanket impls. By keeping\n+// blanket and non-blanket impls separate, we can share the list of blanket\n+// impls.\n+#[derive(Clone)]\n+pub struct TraitImpls {\n+    blanket_impls: Rc<Vec<DefId>>,\n+    non_blanket_impls: Rc<Vec<DefId>>,\n+}\n+\n+impl TraitImpls {\n+    pub fn iter(&self) -> TraitImplsIter {\n+        TraitImplsIter {\n+            blanket_impls: self.blanket_impls.clone(),\n+            non_blanket_impls: self.non_blanket_impls.clone(),\n+            index: 0\n+        }\n+    }\n+}\n+\n+#[derive(Clone)]\n+pub struct TraitImplsIter {\n+    blanket_impls: Rc<Vec<DefId>>,\n+    non_blanket_impls: Rc<Vec<DefId>>,\n+    index: usize,\n+}\n+\n+impl Iterator for TraitImplsIter {\n+    type Item = DefId;\n+\n+    fn next(&mut self) -> Option<DefId> {\n+        if self.index < self.blanket_impls.len() {\n+            let bi_index = self.index;\n+            self.index += 1;\n+            Some(self.blanket_impls[bi_index])\n+        } else {\n+            let nbi_index = self.index - self.blanket_impls.len();\n+            if nbi_index < self.non_blanket_impls.len() {\n+                self.index += 1;\n+                Some(self.non_blanket_impls[nbi_index])\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let items_left = (self.blanket_impls.len() + self.non_blanket_impls.len()) - self.index;\n+        (items_left, Some(items_left))\n+    }\n+}\n+\n+impl ExactSizeIterator for TraitImplsIter {}\n+\n impl<'a, 'gcx, 'tcx> TraitDef {\n     pub fn new(def_id: DefId,\n                unsafety: hir::Unsafety,\n@@ -58,7 +112,7 @@ impl<'a, 'gcx, 'tcx> TraitDef {\n     }\n \n     pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, mut f: F) {\n-        for &impl_def_id in tcx.trait_impls_of(self.def_id).iter() {\n+        for impl_def_id in tcx.trait_impls_of(self.def_id).iter() {\n             f(impl_def_id);\n         }\n     }\n@@ -89,7 +143,7 @@ impl<'a, 'gcx, 'tcx> TraitDef {\n             tcx.trait_impls_of(self.def_id)\n         };\n \n-        for &impl_def_id in relevant_impls.iter() {\n+        for impl_def_id in relevant_impls.iter() {\n             f(impl_def_id);\n         }\n     }\n@@ -98,55 +152,70 @@ impl<'a, 'gcx, 'tcx> TraitDef {\n // Query provider for `trait_impls_of`.\n pub(super) fn trait_impls_of_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 trait_id: DefId)\n-                                                -> Rc<Vec<DefId>> {\n-    let mut impls = if trait_id.is_local() {\n+                                                -> TraitImpls {\n+    let remote_impls = if trait_id.is_local() {\n         // Traits defined in the current crate can't have impls in upstream\n         // crates, so we don't bother querying the cstore.\n         Vec::new()\n     } else {\n         tcx.sess.cstore.implementations_of_trait(Some(trait_id))\n     };\n \n-    impls.extend(tcx.hir\n-                    .trait_impls(trait_id)\n-                    .iter()\n-                    .map(|&node_id| tcx.hir.local_def_id(node_id))\n-                    .filter(|&impl_def_id| {\n-                        let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n-                        !trait_ref.references_error()\n-                    }));\n-    Rc::new(impls)\n+    let mut blanket_impls = Vec::new();\n+    let mut non_blanket_impls = Vec::new();\n+\n+    let local_impls = tcx.hir\n+                         .trait_impls(trait_id)\n+                         .into_iter()\n+                         .map(|&node_id| tcx.hir.local_def_id(node_id));\n+\n+     for impl_def_id in local_impls.chain(remote_impls.into_iter()) {\n+        let impl_trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+        if impl_def_id.is_local() && impl_trait_ref.references_error() {\n+            continue\n+        }\n+\n+        if fast_reject::simplify_type(tcx, impl_trait_ref.self_ty(), false).is_some() {\n+            non_blanket_impls.push(impl_def_id);\n+        } else {\n+            blanket_impls.push(impl_def_id);\n+        }\n+    }\n+\n+    TraitImpls {\n+        blanket_impls: Rc::new(blanket_impls),\n+        non_blanket_impls: Rc::new(non_blanket_impls),\n+    }\n }\n \n // Query provider for `relevant_trait_impls_for`.\n pub(super) fn relevant_trait_impls_provider<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     (trait_id, self_ty): (DefId, fast_reject::SimplifiedType))\n-    -> Rc<Vec<DefId>>\n+    -> TraitImpls\n {\n     let all_trait_impls = tcx.trait_impls_of(trait_id);\n \n     let relevant: Vec<DefId> = all_trait_impls\n+        .non_blanket_impls\n         .iter()\n-        .map(|&impl_def_id| impl_def_id)\n+        .cloned()\n         .filter(|&impl_def_id| {\n             let impl_trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n             let impl_simple_self_ty = fast_reject::simplify_type(tcx,\n                                                                  impl_trait_ref.self_ty(),\n-                                                                 false);\n-            if let Some(impl_simple_self_ty) = impl_simple_self_ty {\n-                impl_simple_self_ty == self_ty\n-            } else {\n-                // blanket impl (?)\n-                true\n-            }\n+                                                                 false).unwrap();\n+            impl_simple_self_ty == self_ty\n         })\n         .collect();\n \n-    if all_trait_impls.len() == relevant.len() {\n+    if all_trait_impls.non_blanket_impls.len() == relevant.len() {\n         // If we didn't filter anything out, re-use the existing vec.\n         all_trait_impls\n     } else {\n-        Rc::new(relevant)\n+        TraitImpls {\n+            blanket_impls: all_trait_impls.blanket_impls.clone(),\n+            non_blanket_impls: Rc::new(relevant),\n+        }\n     }\n }"}]}