{"sha": "91c5e7cbb6f136b2f2529cb9da1421ccac874fee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxYzVlN2NiYjZmMTM2YjJmMjUyOWNiOWRhMTQyMWNjYWM4NzRmZWU=", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2021-09-19T08:31:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-19T08:31:32Z"}, "message": "Rollup merge of #89017 - the8472:fix-u64-time-monotonizer, r=kennytm\n\nfix potential race in AtomicU64 time monotonizer\n\nThe AtomicU64-based monotonizer introduced in #83093 is incorrect because several threads could try to update the value concurrently and a thread which doesn't have the newest value among all the updates could win.\n\nThat bug probably has little real world impact since it doesn't make observed time worse than hardware clocks. The worst case would probably be a thread which has a clock that is behind by several cycles observing several inconsistent fixups, which should be similar to observing the unfiltered backslide in the first place.\n\nNew benchmarks, they don't look as good as the original PR but still an improvement compared to the mutex.\nI don't know why the contended mutex case is faster now than in the previous benchmarks.\n\n```\nactually_monotonic() == true:\ntest time::tests::instant_contention_01_threads                   ... bench:          44 ns/iter (+/- 0)\ntest time::tests::instant_contention_02_threads                   ... bench:          45 ns/iter (+/- 0)\ntest time::tests::instant_contention_04_threads                   ... bench:          45 ns/iter (+/- 0)\ntest time::tests::instant_contention_08_threads                   ... bench:          45 ns/iter (+/- 0)\ntest time::tests::instant_contention_16_threads                   ... bench:          46 ns/iter (+/- 0)\n\natomic u64:\ntest time::tests::instant_contention_01_threads                   ... bench:          66 ns/iter (+/- 0)\ntest time::tests::instant_contention_02_threads                   ... bench:         287 ns/iter (+/- 14)\ntest time::tests::instant_contention_04_threads                   ... bench:         296 ns/iter (+/- 43)\ntest time::tests::instant_contention_08_threads                   ... bench:         604 ns/iter (+/- 163)\ntest time::tests::instant_contention_16_threads                   ... bench:       1,147 ns/iter (+/- 29)\n\nmutex:\ntest time::tests::instant_contention_01_threads                   ... bench:          78 ns/iter (+/- 0)\ntest time::tests::instant_contention_02_threads                   ... bench:         652 ns/iter (+/- 275)\ntest time::tests::instant_contention_04_threads                   ... bench:         900 ns/iter (+/- 32)\ntest time::tests::instant_contention_08_threads                   ... bench:       1,927 ns/iter (+/- 62)\ntest time::tests::instant_contention_16_threads                   ... bench:       3,748 ns/iter (+/- 146)\n```", "tree": {"sha": "1d03c9e8c0a8887bcf4539f2e5ae2f456161f0fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d03c9e8c0a8887bcf4539f2e5ae2f456161f0fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91c5e7cbb6f136b2f2529cb9da1421ccac874fee", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhRvVkCRBK7hj4Ov3rIwAAq1IIAFhLpX06v/Hm7ZNcUQwx4qZd\nAEAJqM63JUfx8xEO55qpW+LKS8lE+C7JRBoqtQHcabO+Zg+oSfUkO7oIkmQnjGx/\nwT8h50eRgAmRvdBoyv60JilYdlhD3AbM/TRFnjtAmrRnrR4o/HkaF0fSDvM+NmYW\ne2BZv4Ja3dm4CNixtQ6YDyRRvxdIWhPFpsnEWTTLhPtwa+uGEEdnrFXBR1c0ONEx\nZF+fegk1OWlflqrB2sTihpeL3wGsLBD47uPdlaUGn+iRIkFaj3nEcFbcNktyZfTK\nE0C28tYZMnKegR+FIMVjo+c/osQt39W0A5qcRd5obkqn2P2kPGxb3J4fTzFBLwI=\n=VJO7\n-----END PGP SIGNATURE-----\n", "payload": "tree 1d03c9e8c0a8887bcf4539f2e5ae2f456161f0fa\nparent 1c3fce01dfb63da3a88161d5744389f827ffe0d8\nparent 57465d9c1bb979a64c6e7c5220b4ab20291547aa\nauthor Yuki Okushi <jtitor@2k36.org> 1632040292 +0900\ncommitter GitHub <noreply@github.com> 1632040292 +0900\n\nRollup merge of #89017 - the8472:fix-u64-time-monotonizer, r=kennytm\n\nfix potential race in AtomicU64 time monotonizer\n\nThe AtomicU64-based monotonizer introduced in #83093 is incorrect because several threads could try to update the value concurrently and a thread which doesn't have the newest value among all the updates could win.\n\nThat bug probably has little real world impact since it doesn't make observed time worse than hardware clocks. The worst case would probably be a thread which has a clock that is behind by several cycles observing several inconsistent fixups, which should be similar to observing the unfiltered backslide in the first place.\n\nNew benchmarks, they don't look as good as the original PR but still an improvement compared to the mutex.\nI don't know why the contended mutex case is faster now than in the previous benchmarks.\n\n```\nactually_monotonic() == true:\ntest time::tests::instant_contention_01_threads                   ... bench:          44 ns/iter (+/- 0)\ntest time::tests::instant_contention_02_threads                   ... bench:          45 ns/iter (+/- 0)\ntest time::tests::instant_contention_04_threads                   ... bench:          45 ns/iter (+/- 0)\ntest time::tests::instant_contention_08_threads                   ... bench:          45 ns/iter (+/- 0)\ntest time::tests::instant_contention_16_threads                   ... bench:          46 ns/iter (+/- 0)\n\natomic u64:\ntest time::tests::instant_contention_01_threads                   ... bench:          66 ns/iter (+/- 0)\ntest time::tests::instant_contention_02_threads                   ... bench:         287 ns/iter (+/- 14)\ntest time::tests::instant_contention_04_threads                   ... bench:         296 ns/iter (+/- 43)\ntest time::tests::instant_contention_08_threads                   ... bench:         604 ns/iter (+/- 163)\ntest time::tests::instant_contention_16_threads                   ... bench:       1,147 ns/iter (+/- 29)\n\nmutex:\ntest time::tests::instant_contention_01_threads                   ... bench:          78 ns/iter (+/- 0)\ntest time::tests::instant_contention_02_threads                   ... bench:         652 ns/iter (+/- 275)\ntest time::tests::instant_contention_04_threads                   ... bench:         900 ns/iter (+/- 32)\ntest time::tests::instant_contention_08_threads                   ... bench:       1,927 ns/iter (+/- 62)\ntest time::tests::instant_contention_16_threads                   ... bench:       3,748 ns/iter (+/- 146)\n```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91c5e7cbb6f136b2f2529cb9da1421ccac874fee", "html_url": "https://github.com/rust-lang/rust/commit/91c5e7cbb6f136b2f2529cb9da1421ccac874fee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91c5e7cbb6f136b2f2529cb9da1421ccac874fee/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c3fce01dfb63da3a88161d5744389f827ffe0d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c3fce01dfb63da3a88161d5744389f827ffe0d8", "html_url": "https://github.com/rust-lang/rust/commit/1c3fce01dfb63da3a88161d5744389f827ffe0d8"}, {"sha": "57465d9c1bb979a64c6e7c5220b4ab20291547aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/57465d9c1bb979a64c6e7c5220b4ab20291547aa", "html_url": "https://github.com/rust-lang/rust/commit/57465d9c1bb979a64c6e7c5220b4ab20291547aa"}], "stats": {"total": 58, "additions": 30, "deletions": 28}, "files": [{"sha": "f69baba9e733f748d140972e08d0e2269904f2b7", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91c5e7cbb6f136b2f2529cb9da1421ccac874fee/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91c5e7cbb6f136b2f2529cb9da1421ccac874fee/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=91c5e7cbb6f136b2f2529cb9da1421ccac874fee", "patch": "@@ -234,6 +234,7 @@\n #![feature(atomic_mut_ptr)]\n #![feature(auto_traits)]\n #![feature(bench_black_box)]\n+#![feature(bool_to_option)]\n #![feature(box_syntax)]\n #![feature(c_unwind)]\n #![feature(c_variadic)]"}, {"sha": "198ae739b55674d990396cfe6128a45c807dc3a9", "filename": "library/std/src/time/monotonic.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/91c5e7cbb6f136b2f2529cb9da1421ccac874fee/library%2Fstd%2Fsrc%2Ftime%2Fmonotonic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91c5e7cbb6f136b2f2529cb9da1421ccac874fee/library%2Fstd%2Fsrc%2Ftime%2Fmonotonic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime%2Fmonotonic.rs?ref=91c5e7cbb6f136b2f2529cb9da1421ccac874fee", "patch": "@@ -37,35 +37,36 @@ pub mod inner {\n         // This could be a problem for programs that call instants at intervals greater\n         // than 68 years. Interstellar probes may want to ensure that actually_monotonic() is true.\n         let packed = (secs << 32) | nanos;\n-        let old = mono.load(Relaxed);\n-\n-        if old == UNINITIALIZED || packed.wrapping_sub(old) < u64::MAX / 2 {\n-            mono.store(packed, Relaxed);\n-            raw\n-        } else {\n-            // Backslide occurred. We reconstruct monotonized time from the upper 32 bit of the\n-            // passed in value and the 64bits loaded from the atomic\n-            let seconds_lower = old >> 32;\n-            let mut seconds_upper = secs & 0xffff_ffff_0000_0000;\n-            if secs & 0xffff_ffff > seconds_lower {\n-                // Backslide caused the lower 32bit of the seconds part to wrap.\n-                // This must be the case because the seconds part is larger even though\n-                // we are in the backslide branch, i.e. the seconds count should be smaller or equal.\n-                //\n-                // We assume that backslides are smaller than 2^32 seconds\n-                // which means we need to add 1 to the upper half to restore it.\n-                //\n-                // Example:\n-                // most recent observed time: 0xA1_0000_0000_0000_0000u128\n-                // bits stored in AtomicU64:     0x0000_0000_0000_0000u64\n-                // backslide by 1s\n-                // caller time is             0xA0_ffff_ffff_0000_0000u128\n-                // -> we can fix up the upper half time by adding 1 << 32\n-                seconds_upper = seconds_upper.wrapping_add(0x1_0000_0000);\n+        let updated = mono.fetch_update(Relaxed, Relaxed, |old| {\n+            (old == UNINITIALIZED || packed.wrapping_sub(old) < u64::MAX / 2).then_some(packed)\n+        });\n+        match updated {\n+            Ok(_) => raw,\n+            Err(newer) => {\n+                // Backslide occurred. We reconstruct monotonized time from the upper 32 bit of the\n+                // passed in value and the 64bits loaded from the atomic\n+                let seconds_lower = newer >> 32;\n+                let mut seconds_upper = secs & 0xffff_ffff_0000_0000;\n+                if secs & 0xffff_ffff > seconds_lower {\n+                    // Backslide caused the lower 32bit of the seconds part to wrap.\n+                    // This must be the case because the seconds part is larger even though\n+                    // we are in the backslide branch, i.e. the seconds count should be smaller or equal.\n+                    //\n+                    // We assume that backslides are smaller than 2^32 seconds\n+                    // which means we need to add 1 to the upper half to restore it.\n+                    //\n+                    // Example:\n+                    // most recent observed time: 0xA1_0000_0000_0000_0000u128\n+                    // bits stored in AtomicU64:     0x0000_0000_0000_0000u64\n+                    // backslide by 1s\n+                    // caller time is             0xA0_ffff_ffff_0000_0000u128\n+                    // -> we can fix up the upper half time by adding 1 << 32\n+                    seconds_upper = seconds_upper.wrapping_add(0x1_0000_0000);\n+                }\n+                let secs = seconds_upper | seconds_lower;\n+                let nanos = newer as u32;\n+                ZERO.checked_add_duration(&Duration::new(secs, nanos)).unwrap()\n             }\n-            let secs = seconds_upper | seconds_lower;\n-            let nanos = old as u32;\n-            ZERO.checked_add_duration(&Duration::new(secs, nanos)).unwrap()\n         }\n     }\n }"}]}