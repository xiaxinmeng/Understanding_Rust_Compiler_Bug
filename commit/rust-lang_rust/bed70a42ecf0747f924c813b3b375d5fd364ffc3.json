{"sha": "bed70a42ecf0747f924c813b3b375d5fd364ffc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlZDcwYTQyZWNmMDc0N2Y5MjRjODEzYjNiMzc1ZDVmZDM2NGZmYzM=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-04-18T03:49:37Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-04-19T00:44:08Z"}, "message": "Have floating point functions take their parameters by value.\n\nMake all of the methods in `std::num::Float` take `self` and their other parameters by value.\n\nSome of the `Float` methods took their parameters by value, and others took them by reference. This standardises them to one convention. The `Float` trait is intended for the built in IEEE 754 numbers only so we don't have to worry about the trait serving types of larger sizes.\n\n[breaking-change]", "tree": {"sha": "e11c369051a4cc265995b2657aac14443e697eec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e11c369051a4cc265995b2657aac14443e697eec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bed70a42ecf0747f924c813b3b375d5fd364ffc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bed70a42ecf0747f924c813b3b375d5fd364ffc3", "html_url": "https://github.com/rust-lang/rust/commit/bed70a42ecf0747f924c813b3b375d5fd364ffc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bed70a42ecf0747f924c813b3b375d5fd364ffc3/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe472020347d8eeb727f3a31e9cdc7268bb579f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe472020347d8eeb727f3a31e9cdc7268bb579f6", "html_url": "https://github.com/rust-lang/rust/commit/fe472020347d8eeb727f3a31e9cdc7268bb579f6"}], "stats": {"total": 334, "additions": 167, "deletions": 167}, "files": [{"sha": "f9483fb4d6b91f9a9af8abd74d490872b7bb7400", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bed70a42ecf0747f924c813b3b375d5fd364ffc3/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/bed70a42ecf0747f924c813b3b375d5fd364ffc3/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=bed70a42ecf0747f924c813b3b375d5fd364ffc3", "patch": "@@ -306,7 +306,7 @@ be distributed on the available cores.\n fn partial_sum(start: uint) -> f64 {\n     let mut local_sum = 0f64;\n     for num in range(start*100000, (start+1)*100000) {\n-        local_sum += (num as f64 + 1.0).powf(&-2.0);\n+        local_sum += (num as f64 + 1.0).powf(-2.0);\n     }\n     local_sum\n }\n@@ -343,7 +343,7 @@ extern crate sync;\n use sync::Arc;\n \n fn pnorm(nums: &[f64], p: uint) -> f64 {\n-    nums.iter().fold(0.0, |a,b| a+(*b).powf(&(p as f64)) ).powf(&(1.0 / (p as f64)))\n+    nums.iter().fold(0.0, |a, b| a + b.powf(p as f64)).powf(1.0 / (p as f64))\n }\n \n fn main() {"}, {"sha": "e0fdc8a363df524989b900456635a7daab9da0c7", "filename": "src/libnum/complex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bed70a42ecf0747f924c813b3b375d5fd364ffc3/src%2Flibnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed70a42ecf0747f924c813b3b375d5fd364ffc3/src%2Flibnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fcomplex.rs?ref=bed70a42ecf0747f924c813b3b375d5fd364ffc3", "patch": "@@ -82,15 +82,15 @@ impl<T: Clone + Float> Cmplx<T> {\n     /// Calculate |self|\n     #[inline]\n     pub fn norm(&self) -> T {\n-        self.re.hypot(&self.im)\n+        self.re.hypot(self.im)\n     }\n }\n \n impl<T: Clone + Float> Cmplx<T> {\n     /// Calculate the principal Arg of self.\n     #[inline]\n     pub fn arg(&self) -> T {\n-        self.im.atan2(&self.re)\n+        self.im.atan2(self.re)\n     }\n     /// Convert to polar form (r, theta), such that `self = r * exp(i\n     /// * theta)`"}, {"sha": "cff1fb30b567a63674b6951524f2e5b74d9923f5", "filename": "src/libnum/rational.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bed70a42ecf0747f924c813b3b375d5fd364ffc3/src%2Flibnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed70a42ecf0747f924c813b3b375d5fd364ffc3/src%2Flibnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Frational.rs?ref=bed70a42ecf0747f924c813b3b375d5fd364ffc3", "patch": "@@ -631,19 +631,19 @@ mod test {\n \n         // f32\n         test(3.14159265359f32, (\"13176795\", \"4194304\"));\n-        test(2f32.powf(&100.), (\"1267650600228229401496703205376\", \"1\"));\n-        test(-2f32.powf(&100.), (\"-1267650600228229401496703205376\", \"1\"));\n-        test(1.0 / 2f32.powf(&100.), (\"1\", \"1267650600228229401496703205376\"));\n+        test(2f32.powf(100.), (\"1267650600228229401496703205376\", \"1\"));\n+        test(-2f32.powf(100.), (\"-1267650600228229401496703205376\", \"1\"));\n+        test(1.0 / 2f32.powf(100.), (\"1\", \"1267650600228229401496703205376\"));\n         test(684729.48391f32, (\"1369459\", \"2\"));\n         test(-8573.5918555f32, (\"-4389679\", \"512\"));\n \n         // f64\n         test(3.14159265359f64, (\"3537118876014453\", \"1125899906842624\"));\n-        test(2f64.powf(&100.), (\"1267650600228229401496703205376\", \"1\"));\n-        test(-2f64.powf(&100.), (\"-1267650600228229401496703205376\", \"1\"));\n+        test(2f64.powf(100.), (\"1267650600228229401496703205376\", \"1\"));\n+        test(-2f64.powf(100.), (\"-1267650600228229401496703205376\", \"1\"));\n         test(684729.48391f64, (\"367611342500051\", \"536870912\"));\n         test(-8573.5918555, (\"-4713381968463931\", \"549755813888\"));\n-        test(1.0 / 2f64.powf(&100.), (\"1\", \"1267650600228229401496703205376\"));\n+        test(1.0 / 2f64.powf(100.), (\"1\", \"1267650600228229401496703205376\"));\n     }\n \n     #[test]"}, {"sha": "1bb2c35bce206bd05ba6be5913f540fca6e4c188", "filename": "src/librand/distributions/gamma.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bed70a42ecf0747f924c813b3b375d5fd364ffc3/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed70a42ecf0747f924c813b3b375d5fd364ffc3/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=bed70a42ecf0747f924c813b3b375d5fd364ffc3", "patch": "@@ -147,7 +147,7 @@ impl IndependentSample<f64> for GammaSmallShape {\n     fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n         let Open01(u) = rng.gen::<Open01<f64>>();\n \n-        self.large_shape.ind_sample(rng) * u.powf(&self.inv_shape)\n+        self.large_shape.ind_sample(rng) * u.powf(self.inv_shape)\n     }\n }\n impl IndependentSample<f64> for GammaLargeShape {"}, {"sha": "2436ed1e95e978057805cb967f87e086e4263a3a", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/bed70a42ecf0747f924c813b3b375d5fd364ffc3/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed70a42ecf0747f924c813b3b375d5fd364ffc3/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=bed70a42ecf0747f924c813b3b375d5fd364ffc3", "patch": "@@ -250,7 +250,7 @@ impl Bounded for f32 {\n impl Primitive for f32 {}\n \n impl Float for f32 {\n-    fn powi(&self, n: i32) -> f32 { unsafe{intrinsics::powif32(*self, n)} }\n+    fn powi(self, n: i32) -> f32 { unsafe{intrinsics::powif32(self, n)} }\n \n     #[inline]\n     fn max(self, other: f32) -> f32 {\n@@ -276,33 +276,33 @@ impl Float for f32 {\n \n     /// Returns `true` if the number is NaN\n     #[inline]\n-    fn is_nan(&self) -> bool { *self != *self }\n+    fn is_nan(self) -> bool { self != self }\n \n     /// Returns `true` if the number is infinite\n     #[inline]\n-    fn is_infinite(&self) -> bool {\n-        *self == Float::infinity() || *self == Float::neg_infinity()\n+    fn is_infinite(self) -> bool {\n+        self == Float::infinity() || self == Float::neg_infinity()\n     }\n \n     /// Returns `true` if the number is neither infinite or NaN\n     #[inline]\n-    fn is_finite(&self) -> bool {\n+    fn is_finite(self) -> bool {\n         !(self.is_nan() || self.is_infinite())\n     }\n \n     /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n     #[inline]\n-    fn is_normal(&self) -> bool {\n+    fn is_normal(self) -> bool {\n         self.classify() == FPNormal\n     }\n \n     /// Returns the floating point category of the number. If only one property is going to\n     /// be tested, it is generally faster to use the specific predicate instead.\n-    fn classify(&self) -> FPCategory {\n+    fn classify(self) -> FPCategory {\n         static EXP_MASK: u32 = 0x7f800000;\n         static MAN_MASK: u32 = 0x007fffff;\n \n-        let bits: u32 = unsafe {::cast::transmute(*self)};\n+        let bits: u32 = unsafe {::cast::transmute(self)};\n         match (bits & MAN_MASK, bits & EXP_MASK) {\n             (0, 0)        => FPZero,\n             (_, 0)        => FPSubnormal,\n@@ -342,38 +342,38 @@ impl Float for f32 {\n     /// - `self = x * pow(2, exp)`\n     /// - `0.5 <= abs(x) < 1.0`\n     #[inline]\n-    fn frexp(&self) -> (f32, int) {\n+    fn frexp(self) -> (f32, int) {\n         unsafe {\n             let mut exp = 0;\n-            let x = cmath::frexpf(*self, &mut exp);\n+            let x = cmath::frexpf(self, &mut exp);\n             (x, exp as int)\n         }\n     }\n \n     /// Returns the exponential of the number, minus `1`, in a way that is accurate\n     /// even if the number is close to zero\n     #[inline]\n-    fn exp_m1(&self) -> f32 { unsafe{cmath::expm1f(*self)} }\n+    fn exp_m1(self) -> f32 { unsafe{cmath::expm1f(self)} }\n \n     /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more accurately\n     /// than if the operations were performed separately\n     #[inline]\n-    fn ln_1p(&self) -> f32 { unsafe{cmath::log1pf(*self)} }\n+    fn ln_1p(self) -> f32 { unsafe{cmath::log1pf(self)} }\n \n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n     /// produces a more accurate result with better performance than a separate multiplication\n     /// operation followed by an add.\n     #[inline]\n-    fn mul_add(&self, a: f32, b: f32) -> f32 { unsafe{intrinsics::fmaf32(*self, a, b)} }\n+    fn mul_add(self, a: f32, b: f32) -> f32 { unsafe{intrinsics::fmaf32(self, a, b)} }\n \n     /// Returns the next representable floating-point value in the direction of `other`\n     #[inline]\n-    fn next_after(&self, other: f32) -> f32 { unsafe{cmath::nextafterf(*self, other)} }\n+    fn next_after(self, other: f32) -> f32 { unsafe{cmath::nextafterf(self, other)} }\n \n     /// Returns the mantissa, exponent and sign as integers.\n-    fn integer_decode(&self) -> (u64, i16, i8) {\n+    fn integer_decode(self) -> (u64, i16, i8) {\n         let bits: u32 = unsafe {\n-            ::cast::transmute(*self)\n+            ::cast::transmute(self)\n         };\n         let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };\n         let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;\n@@ -389,19 +389,19 @@ impl Float for f32 {\n \n     /// Round half-way cases toward `NEG_INFINITY`\n     #[inline]\n-    fn floor(&self) -> f32 { unsafe{intrinsics::floorf32(*self)} }\n+    fn floor(self) -> f32 { unsafe{intrinsics::floorf32(self)} }\n \n     /// Round half-way cases toward `INFINITY`\n     #[inline]\n-    fn ceil(&self) -> f32 { unsafe{intrinsics::ceilf32(*self)} }\n+    fn ceil(self) -> f32 { unsafe{intrinsics::ceilf32(self)} }\n \n     /// Round half-way cases away from `0.0`\n     #[inline]\n-    fn round(&self) -> f32 { unsafe{intrinsics::roundf32(*self)} }\n+    fn round(self) -> f32 { unsafe{intrinsics::roundf32(self)} }\n \n     /// The integer part of the number (rounds towards `0.0`)\n     #[inline]\n-    fn trunc(&self) -> f32 { unsafe{intrinsics::truncf32(*self)} }\n+    fn trunc(self) -> f32 { unsafe{intrinsics::truncf32(self)} }\n \n     /// The fractional part of the number, satisfying:\n     ///\n@@ -410,7 +410,7 @@ impl Float for f32 {\n     /// assert!(x == x.trunc() + x.fract())\n     /// ```\n     #[inline]\n-    fn fract(&self) -> f32 { *self - self.trunc() }\n+    fn fract(self) -> f32 { self - self.trunc() }\n \n     /// Archimedes' constant\n     #[inline]\n@@ -482,82 +482,82 @@ impl Float for f32 {\n \n     /// The reciprocal (multiplicative inverse) of the number\n     #[inline]\n-    fn recip(&self) -> f32 { 1.0 / *self }\n+    fn recip(self) -> f32 { 1.0 / self }\n \n     #[inline]\n-    fn powf(&self, n: &f32) -> f32 { unsafe{intrinsics::powf32(*self, *n)} }\n+    fn powf(self, n: f32) -> f32 { unsafe{intrinsics::powf32(self, n)} }\n \n     #[inline]\n-    fn sqrt(&self) -> f32 { unsafe{intrinsics::sqrtf32(*self)} }\n+    fn sqrt(self) -> f32 { unsafe{intrinsics::sqrtf32(self)} }\n \n     #[inline]\n-    fn rsqrt(&self) -> f32 { self.sqrt().recip() }\n+    fn rsqrt(self) -> f32 { self.sqrt().recip() }\n \n     #[inline]\n-    fn cbrt(&self) -> f32 { unsafe{cmath::cbrtf(*self)} }\n+    fn cbrt(self) -> f32 { unsafe{cmath::cbrtf(self)} }\n \n     #[inline]\n-    fn hypot(&self, other: &f32) -> f32 { unsafe{cmath::hypotf(*self, *other)} }\n+    fn hypot(self, other: f32) -> f32 { unsafe{cmath::hypotf(self, other)} }\n \n     #[inline]\n-    fn sin(&self) -> f32 { unsafe{intrinsics::sinf32(*self)} }\n+    fn sin(self) -> f32 { unsafe{intrinsics::sinf32(self)} }\n \n     #[inline]\n-    fn cos(&self) -> f32 { unsafe{intrinsics::cosf32(*self)} }\n+    fn cos(self) -> f32 { unsafe{intrinsics::cosf32(self)} }\n \n     #[inline]\n-    fn tan(&self) -> f32 { unsafe{cmath::tanf(*self)} }\n+    fn tan(self) -> f32 { unsafe{cmath::tanf(self)} }\n \n     #[inline]\n-    fn asin(&self) -> f32 { unsafe{cmath::asinf(*self)} }\n+    fn asin(self) -> f32 { unsafe{cmath::asinf(self)} }\n \n     #[inline]\n-    fn acos(&self) -> f32 { unsafe{cmath::acosf(*self)} }\n+    fn acos(self) -> f32 { unsafe{cmath::acosf(self)} }\n \n     #[inline]\n-    fn atan(&self) -> f32 { unsafe{cmath::atanf(*self)} }\n+    fn atan(self) -> f32 { unsafe{cmath::atanf(self)} }\n \n     #[inline]\n-    fn atan2(&self, other: &f32) -> f32 { unsafe{cmath::atan2f(*self, *other)} }\n+    fn atan2(self, other: f32) -> f32 { unsafe{cmath::atan2f(self, other)} }\n \n     /// Simultaneously computes the sine and cosine of the number\n     #[inline]\n-    fn sin_cos(&self) -> (f32, f32) {\n+    fn sin_cos(self) -> (f32, f32) {\n         (self.sin(), self.cos())\n     }\n \n     /// Returns the exponential of the number\n     #[inline]\n-    fn exp(&self) -> f32 { unsafe{intrinsics::expf32(*self)} }\n+    fn exp(self) -> f32 { unsafe{intrinsics::expf32(self)} }\n \n     /// Returns 2 raised to the power of the number\n     #[inline]\n-    fn exp2(&self) -> f32 { unsafe{intrinsics::exp2f32(*self)} }\n+    fn exp2(self) -> f32 { unsafe{intrinsics::exp2f32(self)} }\n \n     /// Returns the natural logarithm of the number\n     #[inline]\n-    fn ln(&self) -> f32 { unsafe{intrinsics::logf32(*self)} }\n+    fn ln(self) -> f32 { unsafe{intrinsics::logf32(self)} }\n \n     /// Returns the logarithm of the number with respect to an arbitrary base\n     #[inline]\n-    fn log(&self, base: &f32) -> f32 { self.ln() / base.ln() }\n+    fn log(self, base: f32) -> f32 { self.ln() / base.ln() }\n \n     /// Returns the base 2 logarithm of the number\n     #[inline]\n-    fn log2(&self) -> f32 { unsafe{intrinsics::log2f32(*self)} }\n+    fn log2(self) -> f32 { unsafe{intrinsics::log2f32(self)} }\n \n     /// Returns the base 10 logarithm of the number\n     #[inline]\n-    fn log10(&self) -> f32 { unsafe{intrinsics::log10f32(*self)} }\n+    fn log10(self) -> f32 { unsafe{intrinsics::log10f32(self)} }\n \n     #[inline]\n-    fn sinh(&self) -> f32 { unsafe{cmath::sinhf(*self)} }\n+    fn sinh(self) -> f32 { unsafe{cmath::sinhf(self)} }\n \n     #[inline]\n-    fn cosh(&self) -> f32 { unsafe{cmath::coshf(*self)} }\n+    fn cosh(self) -> f32 { unsafe{cmath::coshf(self)} }\n \n     #[inline]\n-    fn tanh(&self) -> f32 { unsafe{cmath::tanhf(*self)} }\n+    fn tanh(self) -> f32 { unsafe{cmath::tanhf(self)} }\n \n     /// Inverse hyperbolic sine\n     ///\n@@ -567,8 +567,8 @@ impl Float for f32 {\n     /// - `self` if `self` is `0.0`, `-0.0`, `INFINITY`, or `NEG_INFINITY`\n     /// - `NAN` if `self` is `NAN`\n     #[inline]\n-    fn asinh(&self) -> f32 {\n-        match *self {\n+    fn asinh(self) -> f32 {\n+        match self {\n             NEG_INFINITY => NEG_INFINITY,\n             x => (x + ((x * x) + 1.0).sqrt()).ln(),\n         }\n@@ -582,8 +582,8 @@ impl Float for f32 {\n     /// - `INFINITY` if `self` is `INFINITY`\n     /// - `NAN` if `self` is `NAN` or `self < 1.0` (including `NEG_INFINITY`)\n     #[inline]\n-    fn acosh(&self) -> f32 {\n-        match *self {\n+    fn acosh(self) -> f32 {\n+        match self {\n             x if x < 1.0 => Float::nan(),\n             x => (x + ((x * x) - 1.0).sqrt()).ln(),\n         }\n@@ -600,19 +600,19 @@ impl Float for f32 {\n     /// - `NAN` if the `self` is `NAN` or outside the domain of `-1.0 <= self <= 1.0`\n     ///   (including `INFINITY` and `NEG_INFINITY`)\n     #[inline]\n-    fn atanh(&self) -> f32 {\n-        0.5 * ((2.0 * *self) / (1.0 - *self)).ln_1p()\n+    fn atanh(self) -> f32 {\n+        0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n     }\n \n     /// Converts to degrees, assuming the number is in radians\n     #[inline]\n-    fn to_degrees(&self) -> f32 { *self * (180.0f32 / Float::pi()) }\n+    fn to_degrees(self) -> f32 { self * (180.0f32 / Float::pi()) }\n \n     /// Converts to radians, assuming the number is in degrees\n     #[inline]\n-    fn to_radians(&self) -> f32 {\n+    fn to_radians(self) -> f32 {\n         let value: f32 = Float::pi();\n-        *self * (value / 180.0f32)\n+        self * (value / 180.0f32)\n     }\n }\n \n@@ -1162,7 +1162,7 @@ mod tests {\n     fn test_integer_decode() {\n         assert_eq!(3.14159265359f32.integer_decode(), (13176795u64, -22i16, 1i8));\n         assert_eq!((-8573.5918555f32).integer_decode(), (8779358u64, -10i16, -1i8));\n-        assert_eq!(2f32.powf(&100.0).integer_decode(), (8388608u64, 77i16, 1i8));\n+        assert_eq!(2f32.powf(100.0).integer_decode(), (8388608u64, 77i16, 1i8));\n         assert_eq!(0f32.integer_decode(), (0u64, -150i16, 1i8));\n         assert_eq!((-0f32).integer_decode(), (0u64, -150i16, -1i8));\n         assert_eq!(INFINITY.integer_decode(), (8388608u64, 105i16, 1i8));"}, {"sha": "3fb5d793db04e4a5b725deb4c8f0d55b6534c254", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/bed70a42ecf0747f924c813b3b375d5fd364ffc3/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed70a42ecf0747f924c813b3b375d5fd364ffc3/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=bed70a42ecf0747f924c813b3b375d5fd364ffc3", "patch": "@@ -282,33 +282,33 @@ impl Float for f64 {\n \n     /// Returns `true` if the number is NaN\n     #[inline]\n-    fn is_nan(&self) -> bool { *self != *self }\n+    fn is_nan(self) -> bool { self != self }\n \n     /// Returns `true` if the number is infinite\n     #[inline]\n-    fn is_infinite(&self) -> bool {\n-        *self == Float::infinity() || *self == Float::neg_infinity()\n+    fn is_infinite(self) -> bool {\n+        self == Float::infinity() || self == Float::neg_infinity()\n     }\n \n     /// Returns `true` if the number is neither infinite or NaN\n     #[inline]\n-    fn is_finite(&self) -> bool {\n+    fn is_finite(self) -> bool {\n         !(self.is_nan() || self.is_infinite())\n     }\n \n     /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n     #[inline]\n-    fn is_normal(&self) -> bool {\n+    fn is_normal(self) -> bool {\n         self.classify() == FPNormal\n     }\n \n     /// Returns the floating point category of the number. If only one property is going to\n     /// be tested, it is generally faster to use the specific predicate instead.\n-    fn classify(&self) -> FPCategory {\n+    fn classify(self) -> FPCategory {\n         static EXP_MASK: u64 = 0x7ff0000000000000;\n         static MAN_MASK: u64 = 0x000fffffffffffff;\n \n-        let bits: u64 = unsafe {::cast::transmute(*self)};\n+        let bits: u64 = unsafe {::cast::transmute(self)};\n         match (bits & MAN_MASK, bits & EXP_MASK) {\n             (0, 0)        => FPZero,\n             (_, 0)        => FPSubnormal,\n@@ -348,38 +348,38 @@ impl Float for f64 {\n     /// - `self = x * pow(2, exp)`\n     /// - `0.5 <= abs(x) < 1.0`\n     #[inline]\n-    fn frexp(&self) -> (f64, int) {\n+    fn frexp(self) -> (f64, int) {\n         unsafe {\n             let mut exp = 0;\n-            let x = cmath::frexp(*self, &mut exp);\n+            let x = cmath::frexp(self, &mut exp);\n             (x, exp as int)\n         }\n     }\n \n     /// Returns the exponential of the number, minus `1`, in a way that is accurate\n     /// even if the number is close to zero\n     #[inline]\n-    fn exp_m1(&self) -> f64 { unsafe{cmath::expm1(*self)} }\n+    fn exp_m1(self) -> f64 { unsafe{cmath::expm1(self)} }\n \n     /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more accurately\n     /// than if the operations were performed separately\n     #[inline]\n-    fn ln_1p(&self) -> f64 { unsafe{cmath::log1p(*self)} }\n+    fn ln_1p(self) -> f64 { unsafe{cmath::log1p(self)} }\n \n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n     /// produces a more accurate result with better performance than a separate multiplication\n     /// operation followed by an add.\n     #[inline]\n-    fn mul_add(&self, a: f64, b: f64) -> f64 { unsafe{intrinsics::fmaf64(*self, a, b)} }\n+    fn mul_add(self, a: f64, b: f64) -> f64 { unsafe{intrinsics::fmaf64(self, a, b)} }\n \n     /// Returns the next representable floating-point value in the direction of `other`\n     #[inline]\n-    fn next_after(&self, other: f64) -> f64 { unsafe{cmath::nextafter(*self, other)} }\n+    fn next_after(self, other: f64) -> f64 { unsafe{cmath::nextafter(self, other)} }\n \n     /// Returns the mantissa, exponent and sign as integers.\n-    fn integer_decode(&self) -> (u64, i16, i8) {\n+    fn integer_decode(self) -> (u64, i16, i8) {\n         let bits: u64 = unsafe {\n-            ::cast::transmute(*self)\n+            ::cast::transmute(self)\n         };\n         let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };\n         let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;\n@@ -395,19 +395,19 @@ impl Float for f64 {\n \n     /// Round half-way cases toward `NEG_INFINITY`\n     #[inline]\n-    fn floor(&self) -> f64 { unsafe{intrinsics::floorf64(*self)} }\n+    fn floor(self) -> f64 { unsafe{intrinsics::floorf64(self)} }\n \n     /// Round half-way cases toward `INFINITY`\n     #[inline]\n-    fn ceil(&self) -> f64 { unsafe{intrinsics::ceilf64(*self)} }\n+    fn ceil(self) -> f64 { unsafe{intrinsics::ceilf64(self)} }\n \n     /// Round half-way cases away from `0.0`\n     #[inline]\n-    fn round(&self) -> f64 { unsafe{intrinsics::roundf64(*self)} }\n+    fn round(self) -> f64 { unsafe{intrinsics::roundf64(self)} }\n \n     /// The integer part of the number (rounds towards `0.0`)\n     #[inline]\n-    fn trunc(&self) -> f64 { unsafe{intrinsics::truncf64(*self)} }\n+    fn trunc(self) -> f64 { unsafe{intrinsics::truncf64(self)} }\n \n     /// The fractional part of the number, satisfying:\n     ///\n@@ -416,7 +416,7 @@ impl Float for f64 {\n     /// assert!(x == x.trunc() + x.fract())\n     /// ```\n     #[inline]\n-    fn fract(&self) -> f64 { *self - self.trunc() }\n+    fn fract(self) -> f64 { self - self.trunc() }\n \n     /// Archimedes' constant\n     #[inline]\n@@ -488,85 +488,85 @@ impl Float for f64 {\n \n     /// The reciprocal (multiplicative inverse) of the number\n     #[inline]\n-    fn recip(&self) -> f64 { 1.0 / *self }\n+    fn recip(self) -> f64 { 1.0 / self }\n \n     #[inline]\n-    fn powf(&self, n: &f64) -> f64 { unsafe{intrinsics::powf64(*self, *n)} }\n+    fn powf(self, n: f64) -> f64 { unsafe{intrinsics::powf64(self, n)} }\n \n     #[inline]\n-    fn powi(&self, n: i32) -> f64 { unsafe{intrinsics::powif64(*self, n)} }\n+    fn powi(self, n: i32) -> f64 { unsafe{intrinsics::powif64(self, n)} }\n \n     #[inline]\n-    fn sqrt(&self) -> f64 { unsafe{intrinsics::sqrtf64(*self)} }\n+    fn sqrt(self) -> f64 { unsafe{intrinsics::sqrtf64(self)} }\n \n     #[inline]\n-    fn rsqrt(&self) -> f64 { self.sqrt().recip() }\n+    fn rsqrt(self) -> f64 { self.sqrt().recip() }\n \n     #[inline]\n-    fn cbrt(&self) -> f64 { unsafe{cmath::cbrt(*self)} }\n+    fn cbrt(self) -> f64 { unsafe{cmath::cbrt(self)} }\n \n     #[inline]\n-    fn hypot(&self, other: &f64) -> f64 { unsafe{cmath::hypot(*self, *other)} }\n+    fn hypot(self, other: f64) -> f64 { unsafe{cmath::hypot(self, other)} }\n \n     #[inline]\n-    fn sin(&self) -> f64 { unsafe{intrinsics::sinf64(*self)} }\n+    fn sin(self) -> f64 { unsafe{intrinsics::sinf64(self)} }\n \n     #[inline]\n-    fn cos(&self) -> f64 { unsafe{intrinsics::cosf64(*self)} }\n+    fn cos(self) -> f64 { unsafe{intrinsics::cosf64(self)} }\n \n     #[inline]\n-    fn tan(&self) -> f64 { unsafe{cmath::tan(*self)} }\n+    fn tan(self) -> f64 { unsafe{cmath::tan(self)} }\n \n     #[inline]\n-    fn asin(&self) -> f64 { unsafe{cmath::asin(*self)} }\n+    fn asin(self) -> f64 { unsafe{cmath::asin(self)} }\n \n     #[inline]\n-    fn acos(&self) -> f64 { unsafe{cmath::acos(*self)} }\n+    fn acos(self) -> f64 { unsafe{cmath::acos(self)} }\n \n     #[inline]\n-    fn atan(&self) -> f64 { unsafe{cmath::atan(*self)} }\n+    fn atan(self) -> f64 { unsafe{cmath::atan(self)} }\n \n     #[inline]\n-    fn atan2(&self, other: &f64) -> f64 { unsafe{cmath::atan2(*self, *other)} }\n+    fn atan2(self, other: f64) -> f64 { unsafe{cmath::atan2(self, other)} }\n \n     /// Simultaneously computes the sine and cosine of the number\n     #[inline]\n-    fn sin_cos(&self) -> (f64, f64) {\n+    fn sin_cos(self) -> (f64, f64) {\n         (self.sin(), self.cos())\n     }\n \n     /// Returns the exponential of the number\n     #[inline]\n-    fn exp(&self) -> f64 { unsafe{intrinsics::expf64(*self)} }\n+    fn exp(self) -> f64 { unsafe{intrinsics::expf64(self)} }\n \n     /// Returns 2 raised to the power of the number\n     #[inline]\n-    fn exp2(&self) -> f64 { unsafe{intrinsics::exp2f64(*self)} }\n+    fn exp2(self) -> f64 { unsafe{intrinsics::exp2f64(self)} }\n \n     /// Returns the natural logarithm of the number\n     #[inline]\n-    fn ln(&self) -> f64 { unsafe{intrinsics::logf64(*self)} }\n+    fn ln(self) -> f64 { unsafe{intrinsics::logf64(self)} }\n \n     /// Returns the logarithm of the number with respect to an arbitrary base\n     #[inline]\n-    fn log(&self, base: &f64) -> f64 { self.ln() / base.ln() }\n+    fn log(self, base: f64) -> f64 { self.ln() / base.ln() }\n \n     /// Returns the base 2 logarithm of the number\n     #[inline]\n-    fn log2(&self) -> f64 { unsafe{intrinsics::log2f64(*self)} }\n+    fn log2(self) -> f64 { unsafe{intrinsics::log2f64(self)} }\n \n     /// Returns the base 10 logarithm of the number\n     #[inline]\n-    fn log10(&self) -> f64 { unsafe{intrinsics::log10f64(*self)} }\n+    fn log10(self) -> f64 { unsafe{intrinsics::log10f64(self)} }\n \n     #[inline]\n-    fn sinh(&self) -> f64 { unsafe{cmath::sinh(*self)} }\n+    fn sinh(self) -> f64 { unsafe{cmath::sinh(self)} }\n \n     #[inline]\n-    fn cosh(&self) -> f64 { unsafe{cmath::cosh(*self)} }\n+    fn cosh(self) -> f64 { unsafe{cmath::cosh(self)} }\n \n     #[inline]\n-    fn tanh(&self) -> f64 { unsafe{cmath::tanh(*self)} }\n+    fn tanh(self) -> f64 { unsafe{cmath::tanh(self)} }\n \n     /// Inverse hyperbolic sine\n     ///\n@@ -576,8 +576,8 @@ impl Float for f64 {\n     /// - `self` if `self` is `0.0`, `-0.0`, `INFINITY`, or `NEG_INFINITY`\n     /// - `NAN` if `self` is `NAN`\n     #[inline]\n-    fn asinh(&self) -> f64 {\n-        match *self {\n+    fn asinh(self) -> f64 {\n+        match self {\n             NEG_INFINITY => NEG_INFINITY,\n             x => (x + ((x * x) + 1.0).sqrt()).ln(),\n         }\n@@ -591,8 +591,8 @@ impl Float for f64 {\n     /// - `INFINITY` if `self` is `INFINITY`\n     /// - `NAN` if `self` is `NAN` or `self < 1.0` (including `NEG_INFINITY`)\n     #[inline]\n-    fn acosh(&self) -> f64 {\n-        match *self {\n+    fn acosh(self) -> f64 {\n+        match self {\n             x if x < 1.0 => Float::nan(),\n             x => (x + ((x * x) - 1.0).sqrt()).ln(),\n         }\n@@ -609,19 +609,19 @@ impl Float for f64 {\n     /// - `NAN` if the `self` is `NAN` or outside the domain of `-1.0 <= self <= 1.0`\n     ///   (including `INFINITY` and `NEG_INFINITY`)\n     #[inline]\n-    fn atanh(&self) -> f64 {\n-        0.5 * ((2.0 * *self) / (1.0 - *self)).ln_1p()\n+    fn atanh(self) -> f64 {\n+        0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n     }\n \n     /// Converts to degrees, assuming the number is in radians\n     #[inline]\n-    fn to_degrees(&self) -> f64 { *self * (180.0f64 / Float::pi()) }\n+    fn to_degrees(self) -> f64 { self * (180.0f64 / Float::pi()) }\n \n     /// Converts to radians, assuming the number is in degrees\n     #[inline]\n-    fn to_radians(&self) -> f64 {\n+    fn to_radians(self) -> f64 {\n         let value: f64 = Float::pi();\n-        *self * (value / 180.0)\n+        self * (value / 180.0)\n     }\n }\n \n@@ -1165,7 +1165,7 @@ mod tests {\n     fn test_integer_decode() {\n         assert_eq!(3.14159265359f64.integer_decode(), (7074237752028906u64, -51i16, 1i8));\n         assert_eq!((-8573.5918555f64).integer_decode(), (4713381968463931u64, -39i16, -1i8));\n-        assert_eq!(2f64.powf(&100.0).integer_decode(), (4503599627370496u64, 48i16, 1i8));\n+        assert_eq!(2f64.powf(100.0).integer_decode(), (4503599627370496u64, 48i16, 1i8));\n         assert_eq!(0f64.integer_decode(), (0u64, -1075i16, 1i8));\n         assert_eq!((-0f64).integer_decode(), (0u64, -1075i16, -1i8));\n         assert_eq!(INFINITY.integer_decode(), (4503599627370496u64, 972i16, 1i8));"}, {"sha": "d825b1c2f01b6a167bdc34eb9e5d680b2deda110", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/bed70a42ecf0747f924c813b3b375d5fd364ffc3/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed70a42ecf0747f924c813b3b375d5fd364ffc3/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=bed70a42ecf0747f924c813b3b375d5fd364ffc3", "patch": "@@ -347,19 +347,19 @@ pub trait Float: Signed + Primitive {\n     fn neg_zero() -> Self;\n \n     /// Returns true if this value is NaN and false otherwise.\n-    fn is_nan(&self) -> bool;\n+    fn is_nan(self) -> bool;\n \n     /// Returns true if this value is positive infinity or negative infinity and false otherwise.\n-    fn is_infinite(&self) -> bool;\n+    fn is_infinite(self) -> bool;\n \n     /// Returns true if this number is neither infinite nor NaN.\n-    fn is_finite(&self) -> bool;\n+    fn is_finite(self) -> bool;\n \n     /// Returns true if this number is neither zero, infinite, denormal, or NaN.\n-    fn is_normal(&self) -> bool;\n+    fn is_normal(self) -> bool;\n \n     /// Returns the category that this number falls into.\n-    fn classify(&self) -> FPCategory;\n+    fn classify(self) -> FPCategory;\n \n     /// Returns the number of binary digits of mantissa that this type supports.\n     fn mantissa_digits(unused_self: Option<Self>) -> uint;\n@@ -391,42 +391,42 @@ pub trait Float: Signed + Primitive {\n     ///  * `self = x * pow(2, exp)`\n     ///\n     ///  * `0.5 <= abs(x) < 1.0`\n-    fn frexp(&self) -> (Self, int);\n+    fn frexp(self) -> (Self, int);\n \n     /// Returns the exponential of the number, minus 1, in a way that is accurate even if the\n     /// number is close to zero.\n-    fn exp_m1(&self) -> Self;\n+    fn exp_m1(self) -> Self;\n \n     /// Returns the natural logarithm of the number plus 1 (`ln(1+n)`) more accurately than if the\n     /// operations were performed separately.\n-    fn ln_1p(&self) -> Self;\n+    fn ln_1p(self) -> Self;\n \n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This produces a\n     /// more accurate result with better performance than a separate multiplication operation\n     /// followed by an add.\n-    fn mul_add(&self, a: Self, b: Self) -> Self;\n+    fn mul_add(self, a: Self, b: Self) -> Self;\n \n     /// Returns the next representable floating-point value in the direction of `other`.\n-    fn next_after(&self, other: Self) -> Self;\n+    fn next_after(self, other: Self) -> Self;\n \n     /// Returns the mantissa, exponent and sign as integers, respectively.\n-    fn integer_decode(&self) -> (u64, i16, i8);\n+    fn integer_decode(self) -> (u64, i16, i8);\n \n     /// Return the largest integer less than or equal to a number.\n-    fn floor(&self) -> Self;\n+    fn floor(self) -> Self;\n \n     /// Return the smallest integer greater than or equal to a number.\n-    fn ceil(&self) -> Self;\n+    fn ceil(self) -> Self;\n \n     /// Return the nearest integer to a number. Round half-way cases away from\n     /// `0.0`.\n-    fn round(&self) -> Self;\n+    fn round(self) -> Self;\n \n     /// Return the integer part of a number.\n-    fn trunc(&self) -> Self;\n+    fn trunc(self) -> Self;\n \n     /// Return the fractional part of a number.\n-    fn fract(&self) -> Self;\n+    fn fract(self) -> Self;\n \n     /// Archimedes' constant.\n     fn pi() -> Self;\n@@ -480,81 +480,81 @@ pub trait Float: Signed + Primitive {\n     fn ln_10() -> Self;\n \n     /// Take the reciprocal (inverse) of a number, `1/x`.\n-    fn recip(&self) -> Self;\n+    fn recip(self) -> Self;\n \n     /// Raise a number to a power.\n-    fn powf(&self, n: &Self) -> Self;\n+    fn powf(self, n: Self) -> Self;\n \n     /// Raise a number to an integer power.\n     ///\n     /// Using this function is generally faster than using `powf`\n-    fn powi(&self, n: i32) -> Self;\n+    fn powi(self, n: i32) -> Self;\n \n     /// Take the square root of a number.\n-    fn sqrt(&self) -> Self;\n+    fn sqrt(self) -> Self;\n     /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n-    fn rsqrt(&self) -> Self;\n+    fn rsqrt(self) -> Self;\n     /// Take the cubic root of a number.\n-    fn cbrt(&self) -> Self;\n+    fn cbrt(self) -> Self;\n     /// Calculate the length of the hypotenuse of a right-angle triangle given\n     /// legs of length `x` and `y`.\n-    fn hypot(&self, other: &Self) -> Self;\n+    fn hypot(self, other: Self) -> Self;\n \n     /// Computes the sine of a number (in radians).\n-    fn sin(&self) -> Self;\n+    fn sin(self) -> Self;\n     /// Computes the cosine of a number (in radians).\n-    fn cos(&self) -> Self;\n+    fn cos(self) -> Self;\n     /// Computes the tangent of a number (in radians).\n-    fn tan(&self) -> Self;\n+    fn tan(self) -> Self;\n \n     /// Computes the arcsine of a number. Return value is in radians in\n     /// the range [-pi/2, pi/2] or NaN if the number is outside the range\n     /// [-1, 1].\n-    fn asin(&self) -> Self;\n+    fn asin(self) -> Self;\n     /// Computes the arccosine of a number. Return value is in radians in\n     /// the range [0, pi] or NaN if the number is outside the range\n     /// [-1, 1].\n-    fn acos(&self) -> Self;\n+    fn acos(self) -> Self;\n     /// Computes the arctangent of a number. Return value is in radians in the\n     /// range [-pi/2, pi/2];\n-    fn atan(&self) -> Self;\n+    fn atan(self) -> Self;\n     /// Computes the four quadrant arctangent of a number, `y`, and another\n     /// number `x`. Return value is in radians in the range [-pi, pi].\n-    fn atan2(&self, other: &Self) -> Self;\n+    fn atan2(self, other: Self) -> Self;\n     /// Simultaneously computes the sine and cosine of the number, `x`. Returns\n     /// `(sin(x), cos(x))`.\n-    fn sin_cos(&self) -> (Self, Self);\n+    fn sin_cos(self) -> (Self, Self);\n \n     /// Returns `e^(self)`, (the exponential function).\n-    fn exp(&self) -> Self;\n+    fn exp(self) -> Self;\n     /// Returns 2 raised to the power of the number, `2^(self)`.\n-    fn exp2(&self) -> Self;\n+    fn exp2(self) -> Self;\n     /// Returns the natural logarithm of the number.\n-    fn ln(&self) -> Self;\n+    fn ln(self) -> Self;\n     /// Returns the logarithm of the number with respect to an arbitrary base.\n-    fn log(&self, base: &Self) -> Self;\n+    fn log(self, base: Self) -> Self;\n     /// Returns the base 2 logarithm of the number.\n-    fn log2(&self) -> Self;\n+    fn log2(self) -> Self;\n     /// Returns the base 10 logarithm of the number.\n-    fn log10(&self) -> Self;\n+    fn log10(self) -> Self;\n \n     /// Hyperbolic sine function.\n-    fn sinh(&self) -> Self;\n+    fn sinh(self) -> Self;\n     /// Hyperbolic cosine function.\n-    fn cosh(&self) -> Self;\n+    fn cosh(self) -> Self;\n     /// Hyperbolic tangent function.\n-    fn tanh(&self) -> Self;\n+    fn tanh(self) -> Self;\n     /// Inverse hyperbolic sine function.\n-    fn asinh(&self) -> Self;\n+    fn asinh(self) -> Self;\n     /// Inverse hyperbolic cosine function.\n-    fn acosh(&self) -> Self;\n+    fn acosh(self) -> Self;\n     /// Inverse hyperbolic tangent function.\n-    fn atanh(&self) -> Self;\n+    fn atanh(self) -> Self;\n \n     /// Convert radians to degrees.\n-    fn to_degrees(&self) -> Self;\n+    fn to_degrees(self) -> Self;\n     /// Convert degrees to radians.\n-    fn to_radians(&self) -> Self;\n+    fn to_radians(self) -> Self;\n }\n \n /// A generic trait for converting a value to a number."}, {"sha": "bb2fd2a4e257e2bba68bc3d4243b9c2fea71402b", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bed70a42ecf0747f924c813b3b375d5fd364ffc3/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed70a42ecf0747f924c813b3b375d5fd364ffc3/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=bed70a42ecf0747f924c813b3b375d5fd364ffc3", "patch": "@@ -310,7 +310,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+\n                     ExpNone => unreachable!()\n                 };\n \n-                (num / exp_base.powf(&exp), cast::<T, i32>(exp).unwrap())\n+                (num / exp_base.powf(exp), cast::<T, i32>(exp).unwrap())\n             }\n         }\n     };"}, {"sha": "d55fcc660266b1b69555a70edf0d25b1b7e8b1e0", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bed70a42ecf0747f924c813b3b375d5fd364ffc3/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed70a42ecf0747f924c813b3b375d5fd364ffc3/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=bed70a42ecf0747f924c813b3b375d5fd364ffc3", "patch": "@@ -352,8 +352,8 @@ pub fn write_boxplot(w: &mut io::Writer, s: &Summary,\n     let (q1,q2,q3) = s.quartiles;\n \n     // the .abs() handles the case where numbers are negative\n-    let lomag = (10.0_f64).powf(&(s.min.abs().log10().floor()));\n-    let himag = (10.0_f64).powf(&(s.max.abs().log10().floor()));\n+    let lomag = 10.0_f64.powf(s.min.abs().log10().floor());\n+    let himag = 10.0_f64.powf(s.max.abs().log10().floor());\n \n     // need to consider when the limit is zero\n     let lo = if lomag == 0.0 {"}]}