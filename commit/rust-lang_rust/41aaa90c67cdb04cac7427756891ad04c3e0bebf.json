{"sha": "41aaa90c67cdb04cac7427756891ad04c3e0bebf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxYWFhOTBjNjdjZGIwNGNhYzc0Mjc3NTY4OTFhZDA0YzNlMGJlYmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-28T01:20:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-28T01:20:17Z"}, "message": "Auto merge of #70212 - Amanieu:catch_foreign, r=Mark-Simulacrum\n\nAbort when foreign exceptions are caught by catch_unwind\n\nPrior to this PR, foreign exceptions were not caught by catch_unwind, and instead passed through invisibly. This represented a painful soundness hole in some libraries ([take_mut](https://github.com/Sgeo/take_mut/blob/master/src/lib.rs#L37)), which relied on `catch_unwind` to handle all possible exit paths from a closure.\n\nWith this PR, foreign exceptions are now caught by `catch_unwind` and will trigger an abort since catching foreign exceptions is currently UB according to the latest proposals by the FFI unwind project group.\n\ncc @rust-lang/wg-ffi-unwind", "tree": {"sha": "d7cb34d5fc429af98cde7a794a1ab4eb22eb99cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7cb34d5fc429af98cde7a794a1ab4eb22eb99cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41aaa90c67cdb04cac7427756891ad04c3e0bebf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41aaa90c67cdb04cac7427756891ad04c3e0bebf", "html_url": "https://github.com/rust-lang/rust/commit/41aaa90c67cdb04cac7427756891ad04c3e0bebf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41aaa90c67cdb04cac7427756891ad04c3e0bebf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2aa741a9faf8519d3af98aba610677c8d2bc84a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2aa741a9faf8519d3af98aba610677c8d2bc84a5", "html_url": "https://github.com/rust-lang/rust/commit/2aa741a9faf8519d3af98aba610677c8d2bc84a5"}, {"sha": "239f833ed1842ce7ce5c9989871a9ce9b1ea3546", "url": "https://api.github.com/repos/rust-lang/rust/commits/239f833ed1842ce7ce5c9989871a9ce9b1ea3546", "html_url": "https://github.com/rust-lang/rust/commit/239f833ed1842ce7ce5c9989871a9ce9b1ea3546"}], "stats": {"total": 380, "additions": 275, "deletions": 105}, "files": [{"sha": "8ca25da54a6c8ae7ec7be60e6e7090bd3a17abfd", "filename": "library/panic_abort/src/lib.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/41aaa90c67cdb04cac7427756891ad04c3e0bebf/library%2Fpanic_abort%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41aaa90c67cdb04cac7427756891ad04c3e0bebf/library%2Fpanic_abort%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_abort%2Fsrc%2Flib.rs?ref=41aaa90c67cdb04cac7427756891ad04c3e0bebf", "patch": "@@ -117,6 +117,17 @@ pub mod personalities {\n         1 // `ExceptionContinueSearch`\n     }\n \n+    // Similar to above, this corresponds to the `eh_catch_typeinfo` lang item\n+    // that's only used on Emscripten currently.\n+    //\n+    // Since panics don't generate exceptions and foreign exceptions are\n+    // currently UB with -C panic=abort (although this may be subject to\n+    // change), any catch_unwind calls will never use this typeinfo.\n+    #[rustc_std_internal_symbol]\n+    #[allow(non_upper_case_globals)]\n+    #[cfg(target_os = \"emscripten\")]\n+    static rust_eh_catch_typeinfo: [usize; 2] = [0; 2];\n+\n     // These two are called by our startup objects on i686-pc-windows-gnu, but\n     // they don't need to do anything so the bodies are nops.\n     #[rustc_std_internal_symbol]"}, {"sha": "8ce4dcd2acd9c02f6d4259adfbf0aaef8b223cce", "filename": "library/panic_unwind/src/dwarf/eh.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/41aaa90c67cdb04cac7427756891ad04c3e0bebf/library%2Fpanic_unwind%2Fsrc%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41aaa90c67cdb04cac7427756891ad04c3e0bebf/library%2Fpanic_unwind%2Fsrc%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Fdwarf%2Feh.rs?ref=41aaa90c67cdb04cac7427756891ad04c3e0bebf", "patch": "@@ -51,11 +51,7 @@ pub enum EHAction {\n \n pub const USING_SJLJ_EXCEPTIONS: bool = cfg!(all(target_os = \"ios\", target_arch = \"arm\"));\n \n-pub unsafe fn find_eh_action(\n-    lsda: *const u8,\n-    context: &EHContext<'_>,\n-    foreign_exception: bool,\n-) -> Result<EHAction, ()> {\n+pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext<'_>) -> Result<EHAction, ()> {\n     if lsda.is_null() {\n         return Ok(EHAction::None);\n     }\n@@ -98,7 +94,7 @@ pub unsafe fn find_eh_action(\n                     return Ok(EHAction::None);\n                 } else {\n                     let lpad = lpad_base + cs_lpad;\n-                    return Ok(interpret_cs_action(cs_action, lpad, foreign_exception));\n+                    return Ok(interpret_cs_action(cs_action, lpad));\n                 }\n             }\n         }\n@@ -123,21 +119,17 @@ pub unsafe fn find_eh_action(\n                 // Can never have null landing pad for sjlj -- that would have\n                 // been indicated by a -1 call site index.\n                 let lpad = (cs_lpad + 1) as usize;\n-                return Ok(interpret_cs_action(cs_action, lpad, foreign_exception));\n+                return Ok(interpret_cs_action(cs_action, lpad));\n             }\n         }\n     }\n }\n \n-fn interpret_cs_action(cs_action: u64, lpad: usize, foreign_exception: bool) -> EHAction {\n+fn interpret_cs_action(cs_action: u64, lpad: usize) -> EHAction {\n     if cs_action == 0 {\n         // If cs_action is 0 then this is a cleanup (Drop::drop). We run these\n         // for both Rust panics and foreign exceptions.\n         EHAction::Cleanup(lpad)\n-    } else if foreign_exception {\n-        // catch_unwind should not catch foreign exceptions, only Rust panics.\n-        // Instead just continue unwinding.\n-        EHAction::None\n     } else {\n         // Stop unwinding Rust panics at catch_unwind.\n         EHAction::Catch(lpad)"}, {"sha": "e428f2fdaaa39a6d9db9add819b59ccf50ff7857", "filename": "library/panic_unwind/src/emcc.rs", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/41aaa90c67cdb04cac7427756891ad04c3e0bebf/library%2Fpanic_unwind%2Fsrc%2Femcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41aaa90c67cdb04cac7427756891ad04c3e0bebf/library%2Fpanic_unwind%2Fsrc%2Femcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Femcc.rs?ref=41aaa90c67cdb04cac7427756891ad04c3e0bebf", "patch": "@@ -8,8 +8,10 @@\n \n use alloc::boxed::Box;\n use core::any::Any;\n+use core::intrinsics;\n use core::mem;\n use core::ptr;\n+use core::sync::atomic::{AtomicBool, Ordering};\n use libc::{self, c_int};\n use unwind as uw;\n \n@@ -47,6 +49,11 @@ static EXCEPTION_TYPE_INFO: TypeInfo = TypeInfo {\n };\n \n struct Exception {\n+    // This is necessary because C++ code can capture our execption with\n+    // std::exception_ptr and rethrow it multiple times, possibly even in\n+    // another thread.\n+    caught: AtomicBool,\n+\n     // This needs to be an Option because the object's lifetime follows C++\n     // semantics: when catch_unwind moves the Box out of the exception it must\n     // still leave the exception object in a valid state because its destructor\n@@ -55,11 +62,27 @@ struct Exception {\n }\n \n pub unsafe fn cleanup(ptr: *mut u8) -> Box<dyn Any + Send> {\n-    assert!(!ptr.is_null());\n-    let adjusted_ptr = __cxa_begin_catch(ptr as *mut libc::c_void) as *mut Exception;\n-    let ex = (*adjusted_ptr).data.take();\n+    // intrinsics::try actually gives us a pointer to this structure.\n+    #[repr(C)]\n+    struct CatchData {\n+        ptr: *mut u8,\n+        is_rust_panic: bool,\n+    }\n+    let catch_data = &*(ptr as *mut CatchData);\n+\n+    let adjusted_ptr = __cxa_begin_catch(catch_data.ptr as *mut libc::c_void) as *mut Exception;\n+    let out = if catch_data.is_rust_panic {\n+        let was_caught = (*adjusted_ptr).caught.swap(true, Ordering::SeqCst);\n+        if was_caught {\n+            // Since cleanup() isn't allowed to panic, we just abort instead.\n+            intrinsics::abort();\n+        }\n+        (*adjusted_ptr).data.take().unwrap()\n+    } else {\n+        super::__rust_foreign_exception();\n+    };\n     __cxa_end_catch();\n-    ex.unwrap()\n+    out\n }\n \n pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n@@ -68,25 +91,16 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     if exception.is_null() {\n         return uw::_URC_FATAL_PHASE1_ERROR as u32;\n     }\n-    ptr::write(exception, Exception { data: Some(data) });\n+    ptr::write(exception, Exception { caught: AtomicBool::new(false), data: Some(data) });\n     __cxa_throw(exception as *mut _, &EXCEPTION_TYPE_INFO, exception_cleanup);\n }\n \n-// On WASM and ARM, the destructor returns the pointer to the object.\n-cfg_if::cfg_if! {\n-    if #[cfg(any(target_arch = \"arm\", target_arch = \"wasm32\"))] {\n-        type DestructorRet = *mut libc::c_void;\n-    } else {\n-        type DestructorRet = ();\n-    }\n-}\n-extern \"C\" fn exception_cleanup(ptr: *mut libc::c_void) -> DestructorRet {\n+extern \"C\" fn exception_cleanup(ptr: *mut libc::c_void) -> *mut libc::c_void {\n     unsafe {\n         if let Some(b) = (ptr as *mut Exception).read().data {\n             drop(b);\n             super::__rust_drop_panic();\n         }\n-        #[cfg(any(target_arch = \"arm\", target_arch = \"wasm32\"))]\n         ptr\n     }\n }\n@@ -109,7 +123,7 @@ extern \"C\" {\n     fn __cxa_throw(\n         thrown_exception: *mut libc::c_void,\n         tinfo: *const TypeInfo,\n-        dest: extern \"C\" fn(*mut libc::c_void) -> DestructorRet,\n+        dest: extern \"C\" fn(*mut libc::c_void) -> *mut libc::c_void,\n     ) -> !;\n     fn __gxx_personality_v0(\n         version: c_int,"}, {"sha": "85a2a18947db211345d438824dac13e254f7b2fc", "filename": "library/panic_unwind/src/gcc.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/41aaa90c67cdb04cac7427756891ad04c3e0bebf/library%2Fpanic_unwind%2Fsrc%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41aaa90c67cdb04cac7427756891ad04c3e0bebf/library%2Fpanic_unwind%2Fsrc%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Fgcc.rs?ref=41aaa90c67cdb04cac7427756891ad04c3e0bebf", "patch": "@@ -73,8 +73,14 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n }\n \n pub unsafe fn cleanup(ptr: *mut u8) -> Box<dyn Any + Send> {\n-    let exception = Box::from_raw(ptr as *mut Exception);\n-    exception.cause\n+    let exception = ptr as *mut uw::_Unwind_Exception;\n+    if (*exception).exception_class != rust_exception_class() {\n+        uw::_Unwind_DeleteException(exception);\n+        super::__rust_foreign_exception();\n+    } else {\n+        let exception = Box::from_raw(exception as *mut Exception);\n+        exception.cause\n+    }\n }\n \n // Rust's exception class identifier.  This is used by personality routines to\n@@ -164,9 +170,7 @@ cfg_if::cfg_if! {\n             // _Unwind_Context in our libunwind bindings and fetch the required data from there\n             // directly, bypassing DWARF compatibility functions.\n \n-            let exception_class = (*exception_object).exception_class;\n-            let foreign_exception = exception_class != rust_exception_class();\n-            let eh_action = match find_eh_action(context, foreign_exception) {\n+            let eh_action = match find_eh_action(context) {\n                 Ok(action) => action,\n                 Err(_) => return uw::_URC_FAILURE,\n             };\n@@ -221,15 +225,14 @@ cfg_if::cfg_if! {\n         // and indirectly on Windows x86_64 via SEH.\n         unsafe extern \"C\" fn rust_eh_personality_impl(version: c_int,\n                                                       actions: uw::_Unwind_Action,\n-                                                      exception_class: uw::_Unwind_Exception_Class,\n+                                                      _exception_class: uw::_Unwind_Exception_Class,\n                                                       exception_object: *mut uw::_Unwind_Exception,\n                                                       context: *mut uw::_Unwind_Context)\n                                                       -> uw::_Unwind_Reason_Code {\n             if version != 1 {\n                 return uw::_URC_FATAL_PHASE1_ERROR;\n             }\n-            let foreign_exception = exception_class != rust_exception_class();\n-            let eh_action = match find_eh_action(context, foreign_exception) {\n+            let eh_action = match find_eh_action(context) {\n                 Ok(action) => action,\n                 Err(_) => return uw::_URC_FATAL_PHASE1_ERROR,\n             };\n@@ -293,10 +296,7 @@ cfg_if::cfg_if! {\n     }\n }\n \n-unsafe fn find_eh_action(\n-    context: *mut uw::_Unwind_Context,\n-    foreign_exception: bool,\n-) -> Result<EHAction, ()> {\n+unsafe fn find_eh_action(context: *mut uw::_Unwind_Context) -> Result<EHAction, ()> {\n     let lsda = uw::_Unwind_GetLanguageSpecificData(context) as *const u8;\n     let mut ip_before_instr: c_int = 0;\n     let ip = uw::_Unwind_GetIPInfo(context, &mut ip_before_instr);\n@@ -308,7 +308,7 @@ unsafe fn find_eh_action(\n         get_text_start: &|| uw::_Unwind_GetTextRelBase(context),\n         get_data_start: &|| uw::_Unwind_GetDataRelBase(context),\n     };\n-    eh::find_eh_action(lsda, &eh_context, foreign_exception)\n+    eh::find_eh_action(lsda, &eh_context)\n }\n \n // Frame unwind info registration"}, {"sha": "6f31e6dcae70d7b40f406b2c863034ffbd77a8a2", "filename": "library/panic_unwind/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/41aaa90c67cdb04cac7427756891ad04c3e0bebf/library%2Fpanic_unwind%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41aaa90c67cdb04cac7427756891ad04c3e0bebf/library%2Fpanic_unwind%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Flib.rs?ref=41aaa90c67cdb04cac7427756891ad04c3e0bebf", "patch": "@@ -88,6 +88,9 @@ extern \"C\" {\n     /// Handler in libstd called when a panic object is dropped outside of\n     /// `catch_unwind`.\n     fn __rust_drop_panic() -> !;\n+\n+    /// Handler in libstd called when a foreign exception is caught.\n+    fn __rust_foreign_exception() -> !;\n }\n \n mod dwarf;"}, {"sha": "eca169373f39fbbf09793785ce804b7832bfc23a", "filename": "library/panic_unwind/src/seh.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/41aaa90c67cdb04cac7427756891ad04c3e0bebf/library%2Fpanic_unwind%2Fsrc%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41aaa90c67cdb04cac7427756891ad04c3e0bebf/library%2Fpanic_unwind%2Fsrc%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Fseh.rs?ref=41aaa90c67cdb04cac7427756891ad04c3e0bebf", "patch": "@@ -309,15 +309,21 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n \n     extern \"system\" {\n         #[unwind(allowed)]\n-        pub fn _CxxThrowException(pExceptionObject: *mut c_void, pThrowInfo: *mut u8) -> !;\n+        fn _CxxThrowException(pExceptionObject: *mut c_void, pThrowInfo: *mut u8) -> !;\n     }\n \n     _CxxThrowException(throw_ptr, &mut THROW_INFO as *mut _ as *mut _);\n }\n \n pub unsafe fn cleanup(payload: *mut u8) -> Box<dyn Any + Send> {\n-    let exception = &mut *(payload as *mut Exception);\n-    exception.data.take().unwrap()\n+    // A NULL payload here means that we got here from the catch (...) of\n+    // __rust_try. This happens when a non-Rust foreign exception is caught.\n+    if payload.is_null() {\n+        super::__rust_foreign_exception();\n+    } else {\n+        let exception = &mut *(payload as *mut Exception);\n+        exception.data.take().unwrap()\n+    }\n }\n \n // This is required by the compiler to exist (e.g., it's a lang item), but"}, {"sha": "87493945db6dc804a5b28634c2d1a91f847d02d3", "filename": "library/std/src/panic.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/41aaa90c67cdb04cac7427756891ad04c3e0bebf/library%2Fstd%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41aaa90c67cdb04cac7427756891ad04c3e0bebf/library%2Fstd%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanic.rs?ref=41aaa90c67cdb04cac7427756891ad04c3e0bebf", "patch": "@@ -359,6 +359,9 @@ impl<F: Future> Future for AssertUnwindSafe<F> {\n /// aborting the process as well. This function *only* catches unwinding panics,\n /// not those that abort the process.\n ///\n+/// Also note that unwinding into Rust code with a foreign exception (e.g. a\n+/// an exception thrown from C++ code) is undefined behavior.\n+///\n /// # Examples\n ///\n /// ```"}, {"sha": "8dceb12de87b894793b373df4400589e4d0344f6", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41aaa90c67cdb04cac7427756891ad04c3e0bebf/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41aaa90c67cdb04cac7427756891ad04c3e0bebf/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=41aaa90c67cdb04cac7427756891ad04c3e0bebf", "patch": "@@ -60,6 +60,14 @@ extern \"C\" fn __rust_drop_panic() -> ! {\n     rtabort!(\"Rust panics must be rethrown\");\n }\n \n+/// This function is called by the panic runtime if it catches an exception\n+/// object which does not correspond to a Rust panic.\n+#[cfg(not(test))]\n+#[rustc_std_internal_symbol]\n+extern \"C\" fn __rust_foreign_exception() -> ! {\n+    rtabort!(\"Rust cannot catch foreign exceptions\");\n+}\n+\n #[derive(Copy, Clone)]\n enum Hook {\n     Default,"}, {"sha": "1c51a9df5d884eeb4256a45dccf5282f922eb071", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=41aaa90c67cdb04cac7427756891ad04c3e0bebf", "patch": "@@ -82,6 +82,7 @@ pub struct CodegenCx<'ll, 'tcx> {\n     pub dbg_cx: Option<debuginfo::CrateDebugContext<'ll, 'tcx>>,\n \n     eh_personality: Cell<Option<&'ll Value>>,\n+    eh_catch_typeinfo: Cell<Option<&'ll Value>>,\n     pub rust_try_fn: Cell<Option<&'ll Value>>,\n \n     intrinsics: RefCell<FxHashMap<&'static str, &'ll Value>>,\n@@ -311,6 +312,7 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n             coverage_cx,\n             dbg_cx,\n             eh_personality: Cell::new(None),\n+            eh_catch_typeinfo: Cell::new(None),\n             rust_try_fn: Cell::new(None),\n             intrinsics: Default::default(),\n             local_gen_sym_counter: Cell::new(0),\n@@ -819,6 +821,25 @@ impl CodegenCx<'b, 'tcx> {\n         }\n         None\n     }\n+\n+    crate fn eh_catch_typeinfo(&self) -> &'b Value {\n+        if let Some(eh_catch_typeinfo) = self.eh_catch_typeinfo.get() {\n+            return eh_catch_typeinfo;\n+        }\n+        let tcx = self.tcx;\n+        assert!(self.sess().target.target.options.is_like_emscripten);\n+        let eh_catch_typeinfo = match tcx.lang_items().eh_catch_typeinfo() {\n+            Some(def_id) => self.get_static(def_id),\n+            _ => {\n+                let ty = self\n+                    .type_struct(&[self.type_ptr_to(self.type_isize()), self.type_i8p()], false);\n+                self.declare_global(\"rust_eh_catch_typeinfo\", ty)\n+            }\n+        };\n+        let eh_catch_typeinfo = self.const_bitcast(eh_catch_typeinfo, self.type_i8p());\n+        self.eh_catch_typeinfo.set(Some(eh_catch_typeinfo));\n+        eh_catch_typeinfo\n+    }\n }\n \n impl<'b, 'tcx> CodegenCx<'b, 'tcx> {"}, {"sha": "c1dfb83b1355f2154e3e7825144ba6e2a66e85ed", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 114, "deletions": 22, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=41aaa90c67cdb04cac7427756891ad04c3e0bebf", "patch": "@@ -855,6 +855,8 @@ fn try_intrinsic(\n         bx.store(bx.const_i32(0), dest, ret_align);\n     } else if wants_msvc_seh(bx.sess()) {\n         codegen_msvc_try(bx, try_func, data, catch_func, dest);\n+    } else if bx.sess().target.target.options.is_like_emscripten {\n+        codegen_emcc_try(bx, try_func, data, catch_func, dest);\n     } else {\n         codegen_gnu_try(bx, try_func, data, catch_func, dest);\n     }\n@@ -880,7 +882,8 @@ fn codegen_msvc_try(\n \n         let mut normal = bx.build_sibling_block(\"normal\");\n         let mut catchswitch = bx.build_sibling_block(\"catchswitch\");\n-        let mut catchpad = bx.build_sibling_block(\"catchpad\");\n+        let mut catchpad_rust = bx.build_sibling_block(\"catchpad_rust\");\n+        let mut catchpad_foreign = bx.build_sibling_block(\"catchpad_foreign\");\n         let mut caught = bx.build_sibling_block(\"caught\");\n \n         let try_func = llvm::get_param(bx.llfn(), 0);\n@@ -890,35 +893,38 @@ fn codegen_msvc_try(\n         // We're generating an IR snippet that looks like:\n         //\n         //   declare i32 @rust_try(%try_func, %data, %catch_func) {\n-        //      %slot = alloca u8*\n+        //      %slot = alloca i8*\n         //      invoke %try_func(%data) to label %normal unwind label %catchswitch\n         //\n         //   normal:\n         //      ret i32 0\n         //\n         //   catchswitch:\n-        //      %cs = catchswitch within none [%catchpad] unwind to caller\n+        //      %cs = catchswitch within none [%catchpad_rust, %catchpad_foreign] unwind to caller\n         //\n-        //   catchpad:\n-        //      %tok = catchpad within %cs [%type_descriptor, 0, %slot]\n+        //   catchpad_rust:\n+        //      %tok = catchpad within %cs [%type_descriptor, 8, %slot]\n         //      %ptr = load %slot\n         //      call %catch_func(%data, %ptr)\n         //      catchret from %tok to label %caught\n         //\n+        //   catchpad_foreign:\n+        //      %tok = catchpad within %cs [null, 64, null]\n+        //      call %catch_func(%data, null)\n+        //      catchret from %tok to label %caught\n+        //\n         //   caught:\n         //      ret i32 1\n         //   }\n         //\n         // This structure follows the basic usage of throw/try/catch in LLVM.\n         // For example, compile this C++ snippet to see what LLVM generates:\n         //\n-        //      #include <stdint.h>\n-        //\n         //      struct rust_panic {\n         //          rust_panic(const rust_panic&);\n         //          ~rust_panic();\n         //\n-        //          uint64_t x[2];\n+        //          void* x[2];\n         //      };\n         //\n         //      int __rust_try(\n@@ -932,6 +938,9 @@ fn codegen_msvc_try(\n         //          } catch(rust_panic& a) {\n         //              catch_func(data, &a);\n         //              return 1;\n+        //          } catch(...) {\n+        //              catch_func(data, NULL);\n+        //              return 1;\n         //          }\n         //      }\n         //\n@@ -942,8 +951,9 @@ fn codegen_msvc_try(\n \n         normal.ret(bx.const_i32(0));\n \n-        let cs = catchswitch.catch_switch(None, None, 1);\n-        catchswitch.add_handler(cs, catchpad.llbb());\n+        let cs = catchswitch.catch_switch(None, None, 2);\n+        catchswitch.add_handler(cs, catchpad_rust.llbb());\n+        catchswitch.add_handler(cs, catchpad_foreign.llbb());\n \n         // We can't use the TypeDescriptor defined in libpanic_unwind because it\n         // might be in another DLL and the SEH encoding only supports specifying\n@@ -977,11 +987,17 @@ fn codegen_msvc_try(\n         //\n         // Source: MicrosoftCXXABI::getAddrOfCXXCatchHandlerType in clang\n         let flags = bx.const_i32(8);\n-        let funclet = catchpad.catch_pad(cs, &[tydesc, flags, slot]);\n-        let ptr = catchpad.load(slot, ptr_align);\n-        catchpad.call(catch_func, &[data, ptr], Some(&funclet));\n-\n-        catchpad.catch_ret(&funclet, caught.llbb());\n+        let funclet = catchpad_rust.catch_pad(cs, &[tydesc, flags, slot]);\n+        let ptr = catchpad_rust.load(slot, ptr_align);\n+        catchpad_rust.call(catch_func, &[data, ptr], Some(&funclet));\n+        catchpad_rust.catch_ret(&funclet, caught.llbb());\n+\n+        // The flag value of 64 indicates a \"catch-all\".\n+        let flags = bx.const_i32(64);\n+        let null = bx.const_null(bx.type_i8p());\n+        let funclet = catchpad_foreign.catch_pad(cs, &[null, flags, null]);\n+        catchpad_foreign.call(catch_func, &[data, null], Some(&funclet));\n+        catchpad_foreign.catch_ret(&funclet, caught.llbb());\n \n         caught.ret(bx.const_i32(1));\n     });\n@@ -1044,13 +1060,7 @@ fn codegen_gnu_try(\n         // rust_try ignores the selector.\n         let lpad_ty = bx.type_struct(&[bx.type_i8p(), bx.type_i32()], false);\n         let vals = catch.landing_pad(lpad_ty, bx.eh_personality(), 1);\n-        let tydesc = match bx.tcx().lang_items().eh_catch_typeinfo() {\n-            Some(tydesc) => {\n-                let tydesc = bx.get_static(tydesc);\n-                bx.bitcast(tydesc, bx.type_i8p())\n-            }\n-            None => bx.const_null(bx.type_i8p()),\n-        };\n+        let tydesc = bx.const_null(bx.type_i8p());\n         catch.add_clause(vals, tydesc);\n         let ptr = catch.extract_value(vals, 0);\n         catch.call(catch_func, &[data, ptr], None);\n@@ -1064,6 +1074,88 @@ fn codegen_gnu_try(\n     bx.store(ret, dest, i32_align);\n }\n \n+// Variant of codegen_gnu_try used for emscripten where Rust panics are\n+// implemented using C++ exceptions. Here we use exceptions of a specific type\n+// (`struct rust_panic`) to represent Rust panics.\n+fn codegen_emcc_try(\n+    bx: &mut Builder<'a, 'll, 'tcx>,\n+    try_func: &'ll Value,\n+    data: &'ll Value,\n+    catch_func: &'ll Value,\n+    dest: &'ll Value,\n+) {\n+    let llfn = get_rust_try_fn(bx, &mut |mut bx| {\n+        // Codegens the shims described above:\n+        //\n+        //   bx:\n+        //      invoke %try_func(%data) normal %normal unwind %catch\n+        //\n+        //   normal:\n+        //      ret 0\n+        //\n+        //   catch:\n+        //      (%ptr, %selector) = landingpad\n+        //      %rust_typeid = @llvm.eh.typeid.for(@_ZTI10rust_panic)\n+        //      %is_rust_panic = %selector == %rust_typeid\n+        //      %catch_data = alloca { i8*, i8 }\n+        //      %catch_data[0] = %ptr\n+        //      %catch_data[1] = %is_rust_panic\n+        //      call %catch_func(%data, %catch_data)\n+        //      ret 1\n+\n+        bx.sideeffect();\n+\n+        let mut then = bx.build_sibling_block(\"then\");\n+        let mut catch = bx.build_sibling_block(\"catch\");\n+\n+        let try_func = llvm::get_param(bx.llfn(), 0);\n+        let data = llvm::get_param(bx.llfn(), 1);\n+        let catch_func = llvm::get_param(bx.llfn(), 2);\n+        bx.invoke(try_func, &[data], then.llbb(), catch.llbb(), None);\n+        then.ret(bx.const_i32(0));\n+\n+        // Type indicator for the exception being thrown.\n+        //\n+        // The first value in this tuple is a pointer to the exception object\n+        // being thrown.  The second value is a \"selector\" indicating which of\n+        // the landing pad clauses the exception's type had been matched to.\n+        let tydesc = bx.eh_catch_typeinfo();\n+        let lpad_ty = bx.type_struct(&[bx.type_i8p(), bx.type_i32()], false);\n+        let vals = catch.landing_pad(lpad_ty, bx.eh_personality(), 2);\n+        catch.add_clause(vals, tydesc);\n+        catch.add_clause(vals, bx.const_null(bx.type_i8p()));\n+        let ptr = catch.extract_value(vals, 0);\n+        let selector = catch.extract_value(vals, 1);\n+\n+        // Check if the typeid we got is the one for a Rust panic.\n+        let llvm_eh_typeid_for = bx.get_intrinsic(\"llvm.eh.typeid.for\");\n+        let rust_typeid = catch.call(llvm_eh_typeid_for, &[tydesc], None);\n+        let is_rust_panic = catch.icmp(IntPredicate::IntEQ, selector, rust_typeid);\n+        let is_rust_panic = catch.zext(is_rust_panic, bx.type_bool());\n+\n+        // We need to pass two values to catch_func (ptr and is_rust_panic), so\n+        // create an alloca and pass a pointer to that.\n+        let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n+        let i8_align = bx.tcx().data_layout.i8_align.abi;\n+        let catch_data =\n+            catch.alloca(bx.type_struct(&[bx.type_i8p(), bx.type_bool()], false), ptr_align);\n+        let catch_data_0 = catch.inbounds_gep(catch_data, &[bx.const_usize(0), bx.const_usize(0)]);\n+        catch.store(ptr, catch_data_0, ptr_align);\n+        let catch_data_1 = catch.inbounds_gep(catch_data, &[bx.const_usize(0), bx.const_usize(1)]);\n+        catch.store(is_rust_panic, catch_data_1, i8_align);\n+        let catch_data = catch.bitcast(catch_data, bx.type_i8p());\n+\n+        catch.call(catch_func, &[data, catch_data], None);\n+        catch.ret(bx.const_i32(1));\n+    });\n+\n+    // Note that no invoke is used here because by definition this function\n+    // can't panic (that's what it's catching).\n+    let ret = bx.call(llfn, &[try_func, data, catch_func], None);\n+    let i32_align = bx.tcx().data_layout.i32_align.abi;\n+    bx.store(ret, dest, i32_align);\n+}\n+\n // Helper function to give a Block to a closure to codegen a shim function.\n // This is currently primarily used for the `try` intrinsic functions above.\n fn gen_fn<'ll, 'tcx>("}, {"sha": "129eec7d29efe0d4794e01f444f68c553da23737", "filename": "src/librustc_hir/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Flibrustc_hir%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Flibrustc_hir%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fweak_lang_items.rs?ref=41aaa90c67cdb04cac7427756891ad04c3e0bebf", "patch": "@@ -48,5 +48,6 @@ impl LanguageItems {\n weak_lang_items! {\n     panic_impl,         PanicImpl,          rust_begin_unwind;\n     eh_personality,     EhPersonality,      rust_eh_personality;\n+    eh_catch_typeinfo,  EhCatchTypeinfo,    rust_eh_catch_typeinfo;\n     oom,                Oom,                rust_oom;\n }"}, {"sha": "7194a035e89f6b15278b878ae1314d7029e91d6e", "filename": "src/librustc_middle/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Flibrustc_middle%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Flibrustc_middle%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Flang_items.rs?ref=41aaa90c67cdb04cac7427756891ad04c3e0bebf", "patch": "@@ -53,7 +53,9 @@ pub fn required(tcx: TyCtxt<'_>, lang_item: LangItem) -> bool {\n     // symbols. Other panic runtimes ensure that the relevant symbols are\n     // available to link things together, but they're never exercised.\n     match tcx.sess.panic_strategy() {\n-        PanicStrategy::Abort => lang_item != LangItem::EhPersonality,\n+        PanicStrategy::Abort => {\n+            lang_item != LangItem::EhPersonality && lang_item != LangItem::EhCatchTypeinfo\n+        }\n         PanicStrategy::Unwind => true,\n     }\n }"}, {"sha": "6bc2110bfb3e6df08167fdd22fafa6b0f2cead41", "filename": "src/librustc_passes/weak_lang_items.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Flibrustc_passes%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Flibrustc_passes%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fweak_lang_items.rs?ref=41aaa90c67cdb04cac7427756891ad04c3e0bebf", "patch": "@@ -26,6 +26,9 @@ pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>, items: &mut lang_items::LanguageItem\n     if items.eh_personality().is_none() {\n         items.missing.push(LangItem::EhPersonality);\n     }\n+    if tcx.sess.target.target.options.is_like_emscripten && items.eh_catch_typeinfo().is_none() {\n+        items.missing.push(LangItem::EhCatchTypeinfo);\n+    }\n \n     {\n         let mut cx = Context { tcx, items };"}, {"sha": "5092b945f72c4cb53a21ac635029282a6ee9c82f", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=41aaa90c67cdb04cac7427756891ad04c3e0bebf", "patch": "@@ -876,6 +876,7 @@ symbols! {\n         rust_2015_preview,\n         rust_2018_preview,\n         rust_begin_unwind,\n+        rust_eh_catch_typeinfo,\n         rust_eh_personality,\n         rust_eh_register_frames,\n         rust_eh_unregister_frames,"}, {"sha": "b9ef2f329414e8db0ca087e0bb5fac2c41bd87d9", "filename": "src/test/compile-fail/auxiliary/panic-runtime-lang-items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fpanic-runtime-lang-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fpanic-runtime-lang-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fpanic-runtime-lang-items.rs?ref=41aaa90c67cdb04cac7427756891ad04c3e0bebf", "patch": "@@ -11,3 +11,5 @@ use core::panic::PanicInfo;\n fn panic_impl(info: &PanicInfo) -> ! { loop {} }\n #[lang = \"eh_personality\"]\n fn eh_personality() {}\n+#[lang = \"eh_catch_typeinfo\"]\n+static EH_CATCH_TYPEINFO: u8 = 0;"}, {"sha": "8182021a2cce453996a4389f23ff936d8ae8b971", "filename": "src/test/run-make-fulldeps/foreign-exceptions/foo.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2Ffoo.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2Ffoo.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2Ffoo.cpp?ref=41aaa90c67cdb04cac7427756891ad04c3e0bebf", "patch": "@@ -23,15 +23,15 @@ struct drop_check {\n extern \"C\" {\n     void rust_catch_callback(void (*cb)(), bool* rust_ok);\n \n-    static void callback() {\n+    void throw_cxx_exception() {\n         println(\"throwing C++ exception\");\n         throw exception();\n     }\n \n-    void throw_cxx_exception() {\n+    void test_cxx_exception() {\n         bool rust_ok = false;\n         try {\n-            rust_catch_callback(callback, &rust_ok);\n+            rust_catch_callback(throw_cxx_exception, &rust_ok);\n             assert(false && \"unreachable\");\n         } catch (exception e) {\n             println(\"caught C++ exception\");"}, {"sha": "b5c8c1962a8ecc229af0ca5c8d265518aa4820e9", "filename": "src/test/run-make-fulldeps/foreign-exceptions/foo.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2Ffoo.rs?ref=41aaa90c67cdb04cac7427756891ad04c3e0bebf", "patch": "@@ -1,5 +1,5 @@\n-// Tests that C++ exceptions can unwind through Rust code, run destructors and\n-// are ignored by catch_unwind. Also tests that Rust panics can unwind through\n+// Tests that C++ exceptions can unwind through Rust code run destructors and\n+// are caught by catch_unwind. Also tests that Rust panics can unwind through\n // C++ code.\n \n // For linking libstdc++ on MinGW\n@@ -17,7 +17,7 @@ impl<'a> Drop for DropCheck<'a> {\n }\n \n extern \"C\" {\n-    fn throw_cxx_exception();\n+    fn test_cxx_exception();\n \n     #[unwind(allowed)]\n     fn cxx_catch_callback(cb: extern \"C\" fn(), ok: *mut bool);\n@@ -26,15 +26,12 @@ extern \"C\" {\n #[no_mangle]\n #[unwind(allowed)]\n extern \"C\" fn rust_catch_callback(cb: extern \"C\" fn(), rust_ok: &mut bool) {\n-    let _caught_unwind = catch_unwind(AssertUnwindSafe(|| {\n-        let _drop = DropCheck(rust_ok);\n-        cb();\n-        unreachable!(\"should have unwound instead of returned\");\n-    }));\n-    unreachable!(\"catch_unwind should not have caught foreign exception\");\n+    let _drop = DropCheck(rust_ok);\n+    cb();\n+    unreachable!(\"should have unwound instead of returned\");\n }\n \n-fn throw_rust_panic() {\n+fn test_rust_panic() {\n     #[unwind(allowed)]\n     extern \"C\" fn callback() {\n         println!(\"throwing rust panic\");\n@@ -60,6 +57,6 @@ fn throw_rust_panic() {\n }\n \n fn main() {\n-    unsafe { throw_cxx_exception() };\n-    throw_rust_panic();\n+    unsafe { test_cxx_exception() };\n+    test_rust_panic();\n }"}, {"sha": "7d339c5a5dab456572616eb8e171cde52dde90ce", "filename": "src/test/run-make-fulldeps/issue-69368/a.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Ftest%2Frun-make-fulldeps%2Fissue-69368%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Ftest%2Frun-make-fulldeps%2Fissue-69368%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue-69368%2Fa.rs?ref=41aaa90c67cdb04cac7427756891ad04c3e0bebf", "patch": "@@ -14,3 +14,8 @@ pub fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n extern \"C\" fn __rust_drop_panic() -> ! {\n     loop {}\n }\n+\n+#[no_mangle]\n+extern \"C\" fn __rust_foreign_exception() -> ! {\n+    loop {}\n+}"}, {"sha": "6b03e847def140dbf98864f75a05aaef99254ad9", "filename": "src/test/ui/consts/const-eval/const_panic_libcore_main.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_panic_libcore_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_panic_libcore_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_panic_libcore_main.rs?ref=41aaa90c67cdb04cac7427756891ad04c3e0bebf", "patch": "@@ -17,6 +17,8 @@ const X: () = unimplemented!();\n \n #[lang = \"eh_personality\"]\n fn eh() {}\n+#[lang = \"eh_catch_typeinfo\"]\n+static EH_CATCH_TYPEINFO: u8 = 0;\n \n #[panic_handler]\n fn panic(_info: &PanicInfo) -> ! {"}, {"sha": "dd0cac659fd312a1e4ccc8a96b3ceee10d58ab2a", "filename": "src/test/ui/macros/macro-comma-behavior.core.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Ftest%2Fui%2Fmacros%2Fmacro-comma-behavior.core.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Ftest%2Fui%2Fmacros%2Fmacro-comma-behavior.core.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-comma-behavior.core.stderr?ref=41aaa90c67cdb04cac7427756891ad04c3e0bebf", "patch": "@@ -1,41 +1,41 @@\n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:20:23\n+  --> $DIR/macro-comma-behavior.rs:21:23\n    |\n LL |     assert_eq!(1, 1, \"{}\",);\n    |                       ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:23:23\n+  --> $DIR/macro-comma-behavior.rs:24:23\n    |\n LL |     assert_ne!(1, 2, \"{}\",);\n    |                       ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:29:29\n+  --> $DIR/macro-comma-behavior.rs:30:29\n    |\n LL |     debug_assert_eq!(1, 1, \"{}\",);\n    |                             ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:32:29\n+  --> $DIR/macro-comma-behavior.rs:33:29\n    |\n LL |     debug_assert_ne!(1, 2, \"{}\",);\n    |                             ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:53:19\n+  --> $DIR/macro-comma-behavior.rs:54:19\n    |\n LL |     format_args!(\"{}\",);\n    |                   ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:71:21\n+  --> $DIR/macro-comma-behavior.rs:72:21\n    |\n LL |     unimplemented!(\"{}\",);\n    |                     ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:80:24\n+  --> $DIR/macro-comma-behavior.rs:81:24\n    |\n LL |             write!(f, \"{}\",)?;\n    |                        ^^"}, {"sha": "0bfe06830783278e7a57ce63c7fcf2a1520ca031", "filename": "src/test/ui/macros/macro-comma-behavior.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Ftest%2Fui%2Fmacros%2Fmacro-comma-behavior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Ftest%2Fui%2Fmacros%2Fmacro-comma-behavior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-comma-behavior.rs?ref=41aaa90c67cdb04cac7427756891ad04c3e0bebf", "patch": "@@ -9,6 +9,7 @@\n #[cfg(std)] use std::fmt;\n #[cfg(core)] use core::fmt;\n #[cfg(core)] #[lang = \"eh_personality\"] fn eh_personality() {}\n+#[cfg(core)] #[lang = \"eh_catch_typeinfo\"] static EH_CATCH_TYPEINFO: u8 = 0;\n #[cfg(core)] #[lang = \"panic_impl\"] fn panic_impl(panic: &core::panic::PanicInfo) -> ! { loop {} }\n \n // (see documentation of the similarly-named test in run-pass)"}, {"sha": "4372d89fbf5220170906f086313b8fcdf45ab7c6", "filename": "src/test/ui/macros/macro-comma-behavior.std.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Ftest%2Fui%2Fmacros%2Fmacro-comma-behavior.std.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Ftest%2Fui%2Fmacros%2Fmacro-comma-behavior.std.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-comma-behavior.std.stderr?ref=41aaa90c67cdb04cac7427756891ad04c3e0bebf", "patch": "@@ -1,59 +1,59 @@\n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:20:23\n+  --> $DIR/macro-comma-behavior.rs:21:23\n    |\n LL |     assert_eq!(1, 1, \"{}\",);\n    |                       ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:23:23\n+  --> $DIR/macro-comma-behavior.rs:24:23\n    |\n LL |     assert_ne!(1, 2, \"{}\",);\n    |                       ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:29:29\n+  --> $DIR/macro-comma-behavior.rs:30:29\n    |\n LL |     debug_assert_eq!(1, 1, \"{}\",);\n    |                             ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:32:29\n+  --> $DIR/macro-comma-behavior.rs:33:29\n    |\n LL |     debug_assert_ne!(1, 2, \"{}\",);\n    |                             ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:37:18\n+  --> $DIR/macro-comma-behavior.rs:38:18\n    |\n LL |         eprint!(\"{}\",);\n    |                  ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:49:18\n+  --> $DIR/macro-comma-behavior.rs:50:18\n    |\n LL |         format!(\"{}\",);\n    |                  ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:53:19\n+  --> $DIR/macro-comma-behavior.rs:54:19\n    |\n LL |     format_args!(\"{}\",);\n    |                   ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:60:17\n+  --> $DIR/macro-comma-behavior.rs:61:17\n    |\n LL |         print!(\"{}\",);\n    |                 ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:71:21\n+  --> $DIR/macro-comma-behavior.rs:72:21\n    |\n LL |     unimplemented!(\"{}\",);\n    |                     ^^\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/macro-comma-behavior.rs:80:24\n+  --> $DIR/macro-comma-behavior.rs:81:24\n    |\n LL |             write!(f, \"{}\",)?;\n    |                        ^^"}, {"sha": "bef630d826c0f8aff05af84b0ecb2dd5caeaf3c1", "filename": "src/test/ui/no_owned_box_lang_item.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Ftest%2Fui%2Fno_owned_box_lang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Ftest%2Fui%2Fno_owned_box_lang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno_owned_box_lang_item.rs?ref=41aaa90c67cdb04cac7427756891ad04c3e0bebf", "patch": "@@ -12,4 +12,5 @@ fn main() {\n }\n \n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n+#[lang = \"eh_catch_typeinfo\"] static EH_CATCH_TYPEINFO: u8 = 0;\n #[lang = \"panic_impl\"] fn panic_impl(panic: &PanicInfo) -> ! { loop {} }"}, {"sha": "b9ef2f329414e8db0ca087e0bb5fac2c41bd87d9", "filename": "src/test/ui/panic-runtime/auxiliary/panic-runtime-lang-items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Ftest%2Fui%2Fpanic-runtime%2Fauxiliary%2Fpanic-runtime-lang-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Ftest%2Fui%2Fpanic-runtime%2Fauxiliary%2Fpanic-runtime-lang-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanic-runtime%2Fauxiliary%2Fpanic-runtime-lang-items.rs?ref=41aaa90c67cdb04cac7427756891ad04c3e0bebf", "patch": "@@ -11,3 +11,5 @@ use core::panic::PanicInfo;\n fn panic_impl(info: &PanicInfo) -> ! { loop {} }\n #[lang = \"eh_personality\"]\n fn eh_personality() {}\n+#[lang = \"eh_catch_typeinfo\"]\n+static EH_CATCH_TYPEINFO: u8 = 0;"}, {"sha": "f5d5823e468b0046736739469c926bf4b65e0956", "filename": "src/test/ui/range/issue-54505-no-std.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Ftest%2Fui%2Frange%2Fissue-54505-no-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Ftest%2Fui%2Frange%2Fissue-54505-no-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frange%2Fissue-54505-no-std.rs?ref=41aaa90c67cdb04cac7427756891ad04c3e0bebf", "patch": "@@ -14,6 +14,9 @@ use core::ops::RangeBounds;\n #[cfg(any(not(target_arch = \"wasm32\"), target_os = \"emscripten\"))]\n #[lang = \"eh_personality\"]\n extern fn eh_personality() {}\n+#[cfg(target_os = \"emscripten\")]\n+#[lang = \"eh_catch_typeinfo\"]\n+static EH_CATCH_TYPEINFO: u8 = 0;\n \n \n // take a reference to any built-in range"}, {"sha": "5537ed4576763ebacc98800fbfe726d94241ba92", "filename": "src/test/ui/range/issue-54505-no-std.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Ftest%2Fui%2Frange%2Fissue-54505-no-std.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41aaa90c67cdb04cac7427756891ad04c3e0bebf/src%2Ftest%2Fui%2Frange%2Fissue-54505-no-std.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frange%2Fissue-54505-no-std.stderr?ref=41aaa90c67cdb04cac7427756891ad04c3e0bebf", "patch": "@@ -1,7 +1,7 @@\n error: `#[panic_handler]` function required, but not found\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-54505-no-std.rs:24:16\n+  --> $DIR/issue-54505-no-std.rs:27:16\n    |\n LL |     take_range(0..1);\n    |                ^^^^\n@@ -13,7 +13,7 @@ LL |     take_range(0..1);\n                  found struct `core::ops::Range<{integer}>`\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-54505-no-std.rs:29:16\n+  --> $DIR/issue-54505-no-std.rs:32:16\n    |\n LL |     take_range(1..);\n    |                ^^^\n@@ -25,7 +25,7 @@ LL |     take_range(1..);\n                  found struct `core::ops::RangeFrom<{integer}>`\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-54505-no-std.rs:34:16\n+  --> $DIR/issue-54505-no-std.rs:37:16\n    |\n LL |     take_range(..);\n    |                ^^\n@@ -37,7 +37,7 @@ LL |     take_range(..);\n                  found struct `core::ops::RangeFull`\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-54505-no-std.rs:39:16\n+  --> $DIR/issue-54505-no-std.rs:42:16\n    |\n LL |     take_range(0..=1);\n    |                ^^^^^\n@@ -49,7 +49,7 @@ LL |     take_range(0..=1);\n                  found struct `core::ops::RangeInclusive<{integer}>`\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-54505-no-std.rs:44:16\n+  --> $DIR/issue-54505-no-std.rs:47:16\n    |\n LL |     take_range(..5);\n    |                ^^^\n@@ -61,7 +61,7 @@ LL |     take_range(..5);\n                  found struct `core::ops::RangeTo<{integer}>`\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-54505-no-std.rs:49:16\n+  --> $DIR/issue-54505-no-std.rs:52:16\n    |\n LL |     take_range(..=42);\n    |                ^^^^^"}]}