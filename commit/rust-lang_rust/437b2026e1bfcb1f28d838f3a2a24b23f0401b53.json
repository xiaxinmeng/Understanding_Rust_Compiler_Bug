{"sha": "437b2026e1bfcb1f28d838f3a2a24b23f0401b53", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzN2IyMDI2ZTFiZmNiMWYyOGQ4MzhmM2EyYTI0YjIzZjA0MDFiNTM=", "commit": {"author": {"name": "Taylor Yu", "email": "tlyu@mit.edu", "date": "2021-06-01T17:35:24Z"}, "committer": {"name": "Taylor Yu", "email": "tlyu@mit.edu", "date": "2021-06-18T22:19:09Z"}, "message": "factor out maybe_indirection_for_unsized", "tree": {"sha": "6c6060a77d5ff695f3f80702aeb5551cd26974a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c6060a77d5ff695f3f80702aeb5551cd26974a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/437b2026e1bfcb1f28d838f3a2a24b23f0401b53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/437b2026e1bfcb1f28d838f3a2a24b23f0401b53", "html_url": "https://github.com/rust-lang/rust/commit/437b2026e1bfcb1f28d838f3a2a24b23f0401b53", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/437b2026e1bfcb1f28d838f3a2a24b23f0401b53/comments", "author": {"login": "tlyu", "id": 431873, "node_id": "MDQ6VXNlcjQzMTg3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/431873?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tlyu", "html_url": "https://github.com/tlyu", "followers_url": "https://api.github.com/users/tlyu/followers", "following_url": "https://api.github.com/users/tlyu/following{/other_user}", "gists_url": "https://api.github.com/users/tlyu/gists{/gist_id}", "starred_url": "https://api.github.com/users/tlyu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tlyu/subscriptions", "organizations_url": "https://api.github.com/users/tlyu/orgs", "repos_url": "https://api.github.com/users/tlyu/repos", "events_url": "https://api.github.com/users/tlyu/events{/privacy}", "received_events_url": "https://api.github.com/users/tlyu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tlyu", "id": 431873, "node_id": "MDQ6VXNlcjQzMTg3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/431873?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tlyu", "html_url": "https://github.com/tlyu", "followers_url": "https://api.github.com/users/tlyu/followers", "following_url": "https://api.github.com/users/tlyu/following{/other_user}", "gists_url": "https://api.github.com/users/tlyu/gists{/gist_id}", "starred_url": "https://api.github.com/users/tlyu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tlyu/subscriptions", "organizations_url": "https://api.github.com/users/tlyu/orgs", "repos_url": "https://api.github.com/users/tlyu/repos", "events_url": "https://api.github.com/users/tlyu/events{/privacy}", "received_events_url": "https://api.github.com/users/tlyu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2862f08b79c73233e338a063d7a58e642903c9f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2862f08b79c73233e338a063d7a58e642903c9f5", "html_url": "https://github.com/rust-lang/rust/commit/2862f08b79c73233e338a063d7a58e642903c9f5"}], "stats": {"total": 79, "additions": 47, "deletions": 32}, "files": [{"sha": "4d0e8c50229495d98e030fa43c08892cc5c6c97f", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 47, "deletions": 32, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/437b2026e1bfcb1f28d838f3a2a24b23f0401b53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/437b2026e1bfcb1f28d838f3a2a24b23f0401b53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=437b2026e1bfcb1f28d838f3a2a24b23f0401b53", "patch": "@@ -16,6 +16,8 @@ use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder,\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n+use rustc_hir::GenericParam;\n+use rustc_hir::Item;\n use rustc_hir::Node;\n use rustc_middle::mir::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::error::ExpectedFound;\n@@ -1095,6 +1097,13 @@ trait InferCtxtPrivExt<'tcx> {\n         node: Node<'hir>,\n     );\n \n+    fn maybe_indirection_for_unsized(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        item: &'hir Item<'hir>,\n+        param: &'hir GenericParam<'hir>,\n+    ) -> bool;\n+\n     fn is_recursive_obligation(\n         &self,\n         obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n@@ -1821,38 +1830,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         ..\n                     },\n                 ) => {\n-                    // Suggesting `T: ?Sized` is only valid in an ADT if `T` is only used in a\n-                    // borrow. `struct S<'a, T: ?Sized>(&'a T);` is valid, `struct S<T: ?Sized>(T);`\n-                    // is not.\n-                    let mut visitor = FindTypeParam {\n-                        param: param.name.ident().name,\n-                        invalid_spans: vec![],\n-                        nested: false,\n-                    };\n-                    visitor.visit_item(item);\n-                    if !visitor.invalid_spans.is_empty() {\n-                        let mut multispan: MultiSpan = param.span.into();\n-                        multispan.push_span_label(\n-                            param.span,\n-                            format!(\"this could be changed to `{}: ?Sized`...\", param.name.ident()),\n-                        );\n-                        for sp in visitor.invalid_spans {\n-                            multispan.push_span_label(\n-                                sp,\n-                                format!(\n-                                    \"...if indirection were used here: `Box<{}>`\",\n-                                    param.name.ident(),\n-                                ),\n-                            );\n-                        }\n-                        err.span_help(\n-                            multispan,\n-                            &format!(\n-                                \"you could relax the implicit `Sized` bound on `{T}` if it were \\\n-                                 used through indirection like `&{T}` or `Box<{T}>`\",\n-                                T = param.name.ident(),\n-                            ),\n-                        );\n+                    if self.maybe_indirection_for_unsized(err, item, param) {\n                         return;\n                     }\n                 }\n@@ -1872,6 +1850,43 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn maybe_indirection_for_unsized(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        item: &'hir Item<'hir>,\n+        param: &'hir GenericParam<'hir>,\n+    ) -> bool {\n+        // Suggesting `T: ?Sized` is only valid in an ADT if `T` is only used in a\n+        // borrow. `struct S<'a, T: ?Sized>(&'a T);` is valid, `struct S<T: ?Sized>(T);`\n+        // is not.\n+        let mut visitor =\n+            FindTypeParam { param: param.name.ident().name, invalid_spans: vec![], nested: false };\n+        visitor.visit_item(item);\n+        if !visitor.invalid_spans.is_empty() {\n+            let mut multispan: MultiSpan = param.span.into();\n+            multispan.push_span_label(\n+                param.span,\n+                format!(\"this could be changed to `{}: ?Sized`...\", param.name.ident()),\n+            );\n+            for sp in visitor.invalid_spans {\n+                multispan.push_span_label(\n+                    sp,\n+                    format!(\"...if indirection were used here: `Box<{}>`\", param.name.ident()),\n+                );\n+            }\n+            err.span_help(\n+                multispan,\n+                &format!(\n+                    \"you could relax the implicit `Sized` bound on `{T}` if it were \\\n+                    used through indirection like `&{T}` or `Box<{T}>`\",\n+                    T = param.name.ident(),\n+                ),\n+            );\n+            return true;\n+        }\n+        false\n+    }\n+\n     fn is_recursive_obligation(\n         &self,\n         obligated_types: &mut Vec<&ty::TyS<'tcx>>,"}]}