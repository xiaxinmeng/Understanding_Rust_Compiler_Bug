{"sha": "facd1270c636beb7c2c8153424ffd6dda4179d59", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhY2QxMjcwYzYzNmJlYjdjMmM4MTUzNDI0ZmZkNmRkYTQxNzlkNTk=", "commit": {"author": {"name": "Alan Williams", "email": "mralert@gmail.com", "date": "2014-05-07T18:06:15Z"}, "committer": {"name": "Alan Williams", "email": "mralert@gmail.com", "date": "2014-05-07T18:20:28Z"}, "message": "Move Windows compatibility layer to libnative", "tree": {"sha": "b29d80f2b9677297d62fee4cccd2b1274ff4b921", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b29d80f2b9677297d62fee4cccd2b1274ff4b921"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/facd1270c636beb7c2c8153424ffd6dda4179d59", "comment_count": 13, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/facd1270c636beb7c2c8153424ffd6dda4179d59", "html_url": "https://github.com/rust-lang/rust/commit/facd1270c636beb7c2c8153424ffd6dda4179d59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/facd1270c636beb7c2c8153424ffd6dda4179d59/comments", "author": {"login": "MrAlert", "id": 148235, "node_id": "MDQ6VXNlcjE0ODIzNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/148235?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MrAlert", "html_url": "https://github.com/MrAlert", "followers_url": "https://api.github.com/users/MrAlert/followers", "following_url": "https://api.github.com/users/MrAlert/following{/other_user}", "gists_url": "https://api.github.com/users/MrAlert/gists{/gist_id}", "starred_url": "https://api.github.com/users/MrAlert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MrAlert/subscriptions", "organizations_url": "https://api.github.com/users/MrAlert/orgs", "repos_url": "https://api.github.com/users/MrAlert/repos", "events_url": "https://api.github.com/users/MrAlert/events{/privacy}", "received_events_url": "https://api.github.com/users/MrAlert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "MrAlert", "id": 148235, "node_id": "MDQ6VXNlcjE0ODIzNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/148235?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MrAlert", "html_url": "https://github.com/MrAlert", "followers_url": "https://api.github.com/users/MrAlert/followers", "following_url": "https://api.github.com/users/MrAlert/following{/other_user}", "gists_url": "https://api.github.com/users/MrAlert/gists{/gist_id}", "starred_url": "https://api.github.com/users/MrAlert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MrAlert/subscriptions", "organizations_url": "https://api.github.com/users/MrAlert/orgs", "repos_url": "https://api.github.com/users/MrAlert/repos", "events_url": "https://api.github.com/users/MrAlert/events{/privacy}", "received_events_url": "https://api.github.com/users/MrAlert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8543e1b6ced6547057a07f43c413193deb3f9cb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8543e1b6ced6547057a07f43c413193deb3f9cb1", "html_url": "https://github.com/rust-lang/rust/commit/8543e1b6ced6547057a07f43c413193deb3f9cb1"}], "stats": {"total": 194, "additions": 96, "deletions": 98}, "files": [{"sha": "382746decd2d2e2a9577c40fab9b271beea55a4c", "filename": "src/libnative/io/c_win32.rs", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/facd1270c636beb7c2c8153424ffd6dda4179d59/src%2Flibnative%2Fio%2Fc_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facd1270c636beb7c2c8153424ffd6dda4179d59/src%2Flibnative%2Fio%2Fc_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_win32.rs?ref=facd1270c636beb7c2c8153424ffd6dda4179d59", "patch": "@@ -62,3 +62,96 @@ extern \"system\" {\n \n     pub fn CancelIo(hFile: libc::HANDLE) -> libc::BOOL;\n }\n+\n+pub mod compat {\n+    use std::intrinsics::{atomic_store_relaxed, transmute};\n+    use libc::types::os::arch::extra::{LPCWSTR, HMODULE, LPCSTR, LPVOID};\n+    use std::os::win32::as_utf16_p;\n+\n+    extern \"system\" {\n+        fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;\n+        fn GetProcAddress(hModule: HMODULE, lpProcName: LPCSTR) -> LPVOID;\n+    }\n+\n+    // store_func() is idempotent, so using relaxed ordering for the atomics should be enough.\n+    // This way, calling a function in this compatibility layer (after it's loaded) shouldn't\n+    // be any slower than a regular DLL call.\n+    unsafe fn store_func<T: Copy>(ptr: *mut T, module: &str, symbol: &str, fallback: T) {\n+        as_utf16_p(module, |module| {\n+            symbol.with_c_str(|symbol| {\n+                let handle = GetModuleHandleW(module);\n+                let func: Option<T> = transmute(GetProcAddress(handle, symbol));\n+                atomic_store_relaxed(ptr, func.unwrap_or(fallback))\n+            })\n+        })\n+    }\n+\n+    /// Macro for creating a compatibility fallback for a Windows function\n+    ///\n+    /// # Example\n+    /// ```\n+    /// compat_fn!(adll32::SomeFunctionW(_arg: LPCWSTR) {\n+    ///     // Fallback implementation\n+    /// })\n+    /// ```\n+    ///\n+    /// Note that arguments unused by the fallback implementation should not be called `_` as\n+    /// they are used to be passed to the real function if available.\n+    macro_rules! compat_fn(\n+        ($module:ident::$symbol:ident($($argname:ident: $argtype:ty),*)\n+                                      -> $rettype:ty $fallback:block) => (\n+            #[inline(always)]\n+            pub unsafe fn $symbol($($argname: $argtype),*) -> $rettype {\n+                static mut ptr: extern \"system\" fn($($argname: $argtype),*) -> $rettype = thunk;\n+\n+                extern \"system\" fn thunk($($argname: $argtype),*) -> $rettype {\n+                    unsafe {\n+                        ::io::c::compat::store_func(&mut ptr,\n+                                                             stringify!($module),\n+                                                             stringify!($symbol),\n+                                                             fallback);\n+                        ::std::intrinsics::atomic_load_relaxed(&ptr)($($argname),*)\n+                    }\n+                }\n+\n+                extern \"system\" fn fallback($($argname: $argtype),*) -> $rettype $fallback\n+\n+                ::std::intrinsics::atomic_load_relaxed(&ptr)($($argname),*)\n+            }\n+        );\n+\n+        ($module:ident::$symbol:ident($($argname:ident: $argtype:ty),*) $fallback:block) => (\n+            compat_fn!($module::$symbol($($argname: $argtype),*) -> () $fallback)\n+        )\n+    )\n+\n+    /// Compatibility layer for functions in `kernel32.dll`\n+    ///\n+    /// Latest versions of Windows this is needed for:\n+    ///\n+    /// * `CreateSymbolicLinkW`: Windows XP, Windows Server 2003\n+    /// * `GetFinalPathNameByHandleW`: Windows XP, Windows Server 2003\n+    pub mod kernel32 {\n+        use libc::types::os::arch::extra::{DWORD, LPCWSTR, BOOLEAN, HANDLE};\n+        use libc::consts::os::extra::ERROR_CALL_NOT_IMPLEMENTED;\n+\n+        extern \"system\" {\n+            fn SetLastError(dwErrCode: DWORD);\n+        }\n+\n+        compat_fn!(kernel32::CreateSymbolicLinkW(_lpSymlinkFileName: LPCWSTR,\n+                                                 _lpTargetFileName: LPCWSTR,\n+                                                 _dwFlags: DWORD) -> BOOLEAN {\n+            unsafe { SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); }\n+            0\n+        })\n+\n+        compat_fn!(kernel32::GetFinalPathNameByHandleW(_hFile: HANDLE,\n+                                                       _lpszFilePath: LPCWSTR,\n+                                                       _cchFilePath: DWORD,\n+                                                       _dwFlags: DWORD) -> DWORD {\n+            unsafe { SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); }\n+            0\n+        })\n+    }\n+}"}, {"sha": "1c69392165d9a69bd01f4c8f8986877133db24c6", "filename": "src/libnative/io/file_win32.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/facd1270c636beb7c2c8153424ffd6dda4179d59/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facd1270c636beb7c2c8153424ffd6dda4179d59/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=facd1270c636beb7c2c8153424ffd6dda4179d59", "patch": "@@ -408,7 +408,7 @@ pub fn chown(_p: &CString, _uid: int, _gid: int) -> IoResult<()> {\n \n pub fn readlink(p: &CString) -> IoResult<Path> {\n     // FIXME: I have a feeling that this reads intermediate symlinks as well.\n-    use std::os::win32::compat::kernel32::GetFinalPathNameByHandleW;\n+    use io::c::compat::kernel32::GetFinalPathNameByHandleW;\n     let handle = unsafe {\n         as_utf16_p(p.as_str().unwrap(), |p| {\n             libc::CreateFileW(p,\n@@ -441,7 +441,7 @@ pub fn readlink(p: &CString) -> IoResult<Path> {\n }\n \n pub fn symlink(src: &CString, dst: &CString) -> IoResult<()> {\n-    use std::os::win32::compat::kernel32::CreateSymbolicLinkW;\n+    use io::c::compat::kernel32::CreateSymbolicLinkW;\n     super::mkerr_winbool(as_utf16_p(src.as_str().unwrap(), |src| {\n         as_utf16_p(dst.as_str().unwrap(), |dst| {\n             unsafe { CreateSymbolicLinkW(dst, src, 0) }"}, {"sha": "6309e4df40e60dbd4c67cfeb52fa3a2371fbd034", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/facd1270c636beb7c2c8153424ffd6dda4179d59/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facd1270c636beb7c2c8153424ffd6dda4179d59/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=facd1270c636beb7c2c8153424ffd6dda4179d59", "patch": "@@ -50,6 +50,7 @@\n        html_root_url = \"http://static.rust-lang.org/doc/master\")]\n #![deny(unused_result, unused_must_use)]\n #![allow(non_camel_case_types)]\n+#![feature(macro_rules)]\n \n // NB this crate explicitly does *not* allow glob imports, please seriously\n //    consider whether they're needed before adding that feature here (the"}, {"sha": "071aae974db1ed98d500e5682483567a0186c375", "filename": "src/libstd/os.rs", "status": "modified", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/facd1270c636beb7c2c8153424ffd6dda4179d59/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facd1270c636beb7c2c8153424ffd6dda4179d59/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=facd1270c636beb7c2c8153424ffd6dda4179d59", "patch": "@@ -145,102 +145,6 @@ pub mod win32 {\n         t.push(0u16);\n         f(t.as_ptr())\n     }\n-\n-    pub mod compat {\n-        use kinds::Copy;\n-        use option::Option;\n-        use c_str::ToCStr;\n-        use intrinsics::{atomic_store_relaxed, transmute};\n-        use libc::types::os::arch::extra::{LPCWSTR, HMODULE, LPCSTR, LPVOID};\n-        use os::win32::as_utf16_p;\n-\n-        extern \"system\" {\n-            fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;\n-            fn GetProcAddress(hModule: HMODULE, lpProcName: LPCSTR) -> LPVOID;\n-        }\n-\n-        // store_func() is idempotent, so using relaxed ordering for the atomics should be enough.\n-        // This way, calling a function in this compatibility layer (after it's loaded) shouldn't\n-        // be any slower than a regular DLL call.\n-        unsafe fn store_func<T: Copy>(ptr: *mut T, module: &str, symbol: &str, fallback: T) {\n-            as_utf16_p(module, |module| {\n-                symbol.with_c_str(|symbol| {\n-                    let handle = GetModuleHandleW(module);\n-                    let func: Option<T> = transmute(GetProcAddress(handle, symbol));\n-                    atomic_store_relaxed(ptr, func.unwrap_or(fallback))\n-                })\n-            })\n-        }\n-\n-        /// Macro for creating a compatibility fallback for a Windows function\n-        ///\n-        /// # Example\n-        /// ```\n-        /// compat_fn!(adll32::SomeFunctionW(_arg: LPCWSTR) {\n-        ///     // Fallback implementation\n-        /// })\n-        /// ```\n-        ///\n-        /// Note that arguments unused by the fallback implementation should not be called `_` as\n-        /// they are used to be passed to the real function if available.\n-        macro_rules! compat_fn(\n-            ($module:ident::$symbol:ident($($argname:ident: $argtype:ty),*)\n-                                          -> $rettype:ty $fallback:block) => (\n-                #[inline(always)]\n-                pub unsafe fn $symbol($($argname: $argtype),*) -> $rettype {\n-                    static mut ptr: extern \"system\" fn($($argname: $argtype),*) -> $rettype = thunk;\n-\n-                    extern \"system\" fn thunk($($argname: $argtype),*) -> $rettype {\n-                        unsafe {\n-                            ::os::win32::compat::store_func(&mut ptr,\n-                                                                 stringify!($module),\n-                                                                 stringify!($symbol),\n-                                                                 fallback);\n-                            ::intrinsics::atomic_load_relaxed(&ptr)($($argname),*)\n-                        }\n-                    }\n-\n-                    extern \"system\" fn fallback($($argname: $argtype),*) -> $rettype $fallback\n-\n-                    ::intrinsics::atomic_load_relaxed(&ptr)($($argname),*)\n-                }\n-            );\n-\n-            ($module:ident::$symbol:ident($($argname:ident: $argtype:ty),*) $fallback:block) => (\n-                compat_fn!($module::$symbol($($argname: $argtype),*) -> () $fallback)\n-            )\n-        )\n-\n-        /// Compatibility layer for functions in `kernel32.dll`\n-        ///\n-        /// Latest versions of Windows this is needed for:\n-        ///\n-        /// * `CreateSymbolicLinkW`: Windows XP, Windows Server 2003\n-        /// * `GetFinalPathNameByHandleW`: Windows XP, Windows Server 2003\n-        pub mod kernel32 {\n-            use libc::types::os::arch::extra::{DWORD, LPCWSTR, BOOLEAN, HANDLE};\n-            use libc::consts::os::extra::ERROR_CALL_NOT_IMPLEMENTED;\n-\n-            extern \"system\" {\n-                fn SetLastError(dwErrCode: DWORD);\n-            }\n-\n-            compat_fn!(kernel32::CreateSymbolicLinkW(_lpSymlinkFileName: LPCWSTR,\n-                                                     _lpTargetFileName: LPCWSTR,\n-                                                     _dwFlags: DWORD) -> BOOLEAN {\n-                unsafe { SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); }\n-                0\n-            })\n-\n-            compat_fn!(kernel32::GetFinalPathNameByHandleW(_hFile: HANDLE,\n-                                                           _lpszFilePath: LPCWSTR,\n-                                                           _cchFilePath: DWORD,\n-                                                           _dwFlags: DWORD) -> DWORD {\n-                unsafe { SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); }\n-                0\n-            })\n-        }\n-    }\n }\n \n /*"}]}