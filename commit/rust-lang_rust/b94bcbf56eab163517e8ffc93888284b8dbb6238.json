{"sha": "b94bcbf56eab163517e8ffc93888284b8dbb6238", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5NGJjYmY1NmVhYjE2MzUxN2U4ZmZjOTM4ODgyODRiOGRiYjYyMzg=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-12-30T22:44:26Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-12-30T22:44:26Z"}, "message": "Stabilize cmp\n\nThis patch marks `PartialEq`, `Eq`, `PartialOrd`, and `Ord` as\n`#[stable]`, as well as the majorify of manual implementaitons of these\ntraits. The traits match the [reform\nRFC](https://github.com/rust-lang/rfcs/pull/439).\n\nAlong the way, two changes are made:\n\n* The recently-added type parameters for `Ord` and `Eq` are\n  removed. These were mistakenly added while adding them to `PartialOrd`\n  and `PartialEq`, but they don't make sense given the laws that are\n  required for (and use cases for) `Ord` and `Eq`.\n\n* More explicit laws are added for `PartialEq` and `PartialOrd`,\n  connecting them to their associated mathematical concepts.\n\nIn the future, many of the impls should be generalized; see\nsince generalizing later is not a breaking change.\n\n[breaking-change]", "tree": {"sha": "7a18c863cc94c86dd6ba2d9813af0d0af2b5b512", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a18c863cc94c86dd6ba2d9813af0d0af2b5b512"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b94bcbf56eab163517e8ffc93888284b8dbb6238", "comment_count": 8, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b94bcbf56eab163517e8ffc93888284b8dbb6238", "html_url": "https://github.com/rust-lang/rust/commit/b94bcbf56eab163517e8ffc93888284b8dbb6238", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b94bcbf56eab163517e8ffc93888284b8dbb6238/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84f5ad8679c7fc454473ffbf389030f3e5fee379", "url": "https://api.github.com/repos/rust-lang/rust/commits/84f5ad8679c7fc454473ffbf389030f3e5fee379", "html_url": "https://github.com/rust-lang/rust/commit/84f5ad8679c7fc454473ffbf389030f3e5fee379"}], "stats": {"total": 265, "additions": 182, "deletions": 83}, "files": [{"sha": "f6f83f22f92403fd7ac213713509ddc1e57bba2c", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=b94bcbf56eab163517e8ffc93888284b8dbb6238", "patch": "@@ -458,7 +458,7 @@ impl<T: Sync + Send> Drop for Weak<T> {\n     }\n }\n \n-#[unstable = \"waiting on PartialEq\"]\n+#[stable]\n impl<T: PartialEq> PartialEq for Arc<T> {\n     /// Equality for two `Arc<T>`s.\n     ///\n@@ -490,7 +490,7 @@ impl<T: PartialEq> PartialEq for Arc<T> {\n     /// ```\n     fn ne(&self, other: &Arc<T>) -> bool { *(*self) != *(*other) }\n }\n-#[unstable = \"waiting on PartialOrd\"]\n+#[stable]\n impl<T: PartialOrd> PartialOrd for Arc<T> {\n     /// Partial comparison for two `Arc<T>`s.\n     ///\n@@ -569,11 +569,11 @@ impl<T: PartialOrd> PartialOrd for Arc<T> {\n     /// ```\n     fn ge(&self, other: &Arc<T>) -> bool { *(*self) >= *(*other) }\n }\n-#[unstable = \"waiting on Ord\"]\n+#[stable]\n impl<T: Ord> Ord for Arc<T> {\n     fn cmp(&self, other: &Arc<T>) -> Ordering { (**self).cmp(&**other) }\n }\n-#[unstable = \"waiting on Eq\"]\n+#[stable]\n impl<T: Eq> Eq for Arc<T> {}\n \n impl<T: fmt::Show> fmt::Show for Arc<T> {"}, {"sha": "74f0599e486e1da696f2619ceaa6a0248db948e1", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=b94bcbf56eab163517e8ffc93888284b8dbb6238", "patch": "@@ -72,12 +72,14 @@ impl<T: Clone> Clone for Box<T> {\n     }\n }\n \n+#[stable]\n impl<Sized? T: PartialEq> PartialEq for Box<T> {\n     #[inline]\n     fn eq(&self, other: &Box<T>) -> bool { PartialEq::eq(&**self, &**other) }\n     #[inline]\n     fn ne(&self, other: &Box<T>) -> bool { PartialEq::ne(&**self, &**other) }\n }\n+#[stable]\n impl<Sized? T: PartialOrd> PartialOrd for Box<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Box<T>) -> Option<Ordering> {\n@@ -92,12 +94,14 @@ impl<Sized? T: PartialOrd> PartialOrd for Box<T> {\n     #[inline]\n     fn gt(&self, other: &Box<T>) -> bool { PartialOrd::gt(&**self, &**other) }\n }\n+#[stable]\n impl<Sized? T: Ord> Ord for Box<T> {\n     #[inline]\n     fn cmp(&self, other: &Box<T>) -> Ordering {\n         Ord::cmp(&**self, &**other)\n     }\n-}\n+\n+#[stable]}\n impl<Sized? T: Eq> Eq for Box<T> {}\n \n impl<S: hash::Writer, Sized? T: Hash<S>> Hash<S> for Box<T> {"}, {"sha": "75d4342083b983f06505480ecf5dff78040f9dc7", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=b94bcbf56eab163517e8ffc93888284b8dbb6238", "patch": "@@ -452,7 +452,7 @@ impl<T: Default> Default for Rc<T> {\n     }\n }\n \n-#[unstable = \"PartialEq is unstable.\"]\n+#[stable]\n impl<T: PartialEq> PartialEq for Rc<T> {\n     /// Equality for two `Rc<T>`s.\n     ///\n@@ -487,10 +487,10 @@ impl<T: PartialEq> PartialEq for Rc<T> {\n     fn ne(&self, other: &Rc<T>) -> bool { **self != **other }\n }\n \n-#[unstable = \"Eq is unstable.\"]\n+#[stable]\n impl<T: Eq> Eq for Rc<T> {}\n \n-#[unstable = \"PartialOrd is unstable.\"]\n+#[stable]\n impl<T: PartialOrd> PartialOrd for Rc<T> {\n     /// Partial comparison for two `Rc<T>`s.\n     ///\n@@ -575,7 +575,7 @@ impl<T: PartialOrd> PartialOrd for Rc<T> {\n     fn ge(&self, other: &Rc<T>) -> bool { **self >= **other }\n }\n \n-#[unstable = \"Ord is unstable.\"]\n+#[stable]\n impl<T: Ord> Ord for Rc<T> {\n     /// Comparison for two `Rc<T>`s.\n     ///"}, {"sha": "08d12151efd3dd9c100b33c534bfc59486a31561", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=b94bcbf56eab163517e8ffc93888284b8dbb6238", "patch": "@@ -965,13 +965,15 @@ impl Clone for Bitv {\n     }\n }\n \n+#[stable]\n impl PartialOrd for Bitv {\n     #[inline]\n     fn partial_cmp(&self, other: &Bitv) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n+#[stable]\n impl Ord for Bitv {\n     #[inline]\n     fn cmp(&self, other: &Bitv) -> Ordering {\n@@ -997,6 +999,7 @@ impl<S: hash::Writer> hash::Hash<S> for Bitv {\n     }\n }\n \n+#[stable]\n impl cmp::PartialEq for Bitv {\n     #[inline]\n     fn eq(&self, other: &Bitv) -> bool {\n@@ -1007,6 +1010,7 @@ impl cmp::PartialEq for Bitv {\n     }\n }\n \n+#[stable]\n impl cmp::Eq for Bitv {}\n \n /// An iterator for `Bitv`.\n@@ -1129,6 +1133,7 @@ impl Extend<uint> for BitvSet {\n     }\n }\n \n+#[stable]\n impl PartialOrd for BitvSet {\n     #[inline]\n     fn partial_cmp(&self, other: &BitvSet) -> Option<Ordering> {\n@@ -1137,6 +1142,7 @@ impl PartialOrd for BitvSet {\n     }\n }\n \n+#[stable]\n impl Ord for BitvSet {\n     #[inline]\n     fn cmp(&self, other: &BitvSet) -> Ordering {\n@@ -1145,6 +1151,7 @@ impl Ord for BitvSet {\n     }\n }\n \n+#[stable]\n impl cmp::PartialEq for BitvSet {\n     #[inline]\n     fn eq(&self, other: &BitvSet) -> bool {\n@@ -1153,6 +1160,7 @@ impl cmp::PartialEq for BitvSet {\n     }\n }\n \n+#[stable]\n impl cmp::Eq for BitvSet {}\n \n impl BitvSet {"}, {"sha": "a3dff3e870658d54dfbc6c5add62e59f03e666e5", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=b94bcbf56eab163517e8ffc93888284b8dbb6238", "patch": "@@ -843,22 +843,26 @@ impl<K: Ord, V> Default for BTreeMap<K, V> {\n     }\n }\n \n+#[stable]\n impl<K: PartialEq, V: PartialEq> PartialEq for BTreeMap<K, V> {\n     fn eq(&self, other: &BTreeMap<K, V>) -> bool {\n         self.len() == other.len() &&\n             self.iter().zip(other.iter()).all(|(a, b)| a == b)\n     }\n }\n \n+#[stable]\n impl<K: Eq, V: Eq> Eq for BTreeMap<K, V> {}\n \n+#[stable]\n impl<K: PartialOrd, V: PartialOrd> PartialOrd for BTreeMap<K, V> {\n     #[inline]\n     fn partial_cmp(&self, other: &BTreeMap<K, V>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n+#[stable]\n impl<K: Ord, V: Ord> Ord for BTreeMap<K, V> {\n     #[inline]\n     fn cmp(&self, other: &BTreeMap<K, V>) -> Ordering {"}, {"sha": "9f2dcda92c02524c1ab1a420e5ce1bd02f0f1893", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=b94bcbf56eab163517e8ffc93888284b8dbb6238", "patch": "@@ -770,6 +770,7 @@ impl<A> Extend<A> for DList<A> {\n     }\n }\n \n+#[stable]\n impl<A: PartialEq> PartialEq for DList<A> {\n     fn eq(&self, other: &DList<A>) -> bool {\n         self.len() == other.len() &&\n@@ -782,14 +783,17 @@ impl<A: PartialEq> PartialEq for DList<A> {\n     }\n }\n \n+#[stable]\n impl<A: Eq> Eq for DList<A> {}\n \n+#[stable]\n impl<A: PartialOrd> PartialOrd for DList<A> {\n     fn partial_cmp(&self, other: &DList<A>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n+#[stable]\n impl<A: Ord> Ord for DList<A> {\n     #[inline]\n     fn cmp(&self, other: &DList<A>) -> Ordering {"}, {"sha": "c8d21761ac088a784bed1f53677ba2295958caaf", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=b94bcbf56eab163517e8ffc93888284b8dbb6238", "patch": "@@ -1290,21 +1290,25 @@ impl<'a, T: 'a> DoubleEndedIterator<T> for Drain<'a, T> {\n \n impl<'a, T: 'a> ExactSizeIterator<T> for Drain<'a, T> {}\n \n+#[stable]\n impl<A: PartialEq> PartialEq for RingBuf<A> {\n     fn eq(&self, other: &RingBuf<A>) -> bool {\n         self.len() == other.len() &&\n             self.iter().zip(other.iter()).all(|(a, b)| a.eq(b))\n     }\n }\n \n+#[stable]\n impl<A: Eq> Eq for RingBuf<A> {}\n \n+#[stable]\n impl<A: PartialOrd> PartialOrd for RingBuf<A> {\n     fn partial_cmp(&self, other: &RingBuf<A>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n+#[stable]\n impl<A: Ord> Ord for RingBuf<A> {\n     #[inline]\n     fn cmp(&self, other: &RingBuf<A>) -> Ordering {"}, {"sha": "0969f0fcfcc474c24d4006de9d244a5693de4a90", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=b94bcbf56eab163517e8ffc93888284b8dbb6238", "patch": "@@ -815,6 +815,7 @@ impl<'a> Extend<&'a str> for String {\n     }\n }\n \n+#[stable]\n impl PartialEq for String {\n     #[inline]\n     fn eq(&self, other: &String) -> bool { PartialEq::eq(&**self, &**other) }\n@@ -824,13 +825,15 @@ impl PartialEq for String {\n \n macro_rules! impl_eq {\n     ($lhs:ty, $rhs: ty) => {\n+        #[stable]\n         impl<'a> PartialEq<$rhs> for $lhs {\n             #[inline]\n             fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n             #[inline]\n             fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n         }\n \n+        #[stable]\n         impl<'a> PartialEq<$lhs> for $rhs {\n             #[inline]\n             fn eq(&self, other: &$lhs) -> bool { PartialEq::eq(&**self, &**other) }\n@@ -844,13 +847,15 @@ macro_rules! impl_eq {\n impl_eq! { String, &'a str }\n impl_eq! { CowString<'a>, String }\n \n+#[stable]\n impl<'a, 'b> PartialEq<&'b str> for CowString<'a> {\n     #[inline]\n     fn eq(&self, other: &&'b str) -> bool { PartialEq::eq(&**self, &**other) }\n     #[inline]\n     fn ne(&self, other: &&'b str) -> bool { PartialEq::ne(&**self, &**other) }\n }\n \n+#[stable]\n impl<'a, 'b> PartialEq<CowString<'a>> for &'b str {\n     #[inline]\n     fn eq(&self, other: &CowString<'a>) -> bool { PartialEq::eq(&**self, &**other) }"}, {"sha": "e2a9d2f8f63c6a16293305fc3b5afce84c65f861", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=b94bcbf56eab163517e8ffc93888284b8dbb6238", "patch": "@@ -588,6 +588,7 @@ impl<T> Extend<T> for Vec<T> {\n     }\n }\n \n+#[stable]\n impl<A, B> PartialEq<Vec<B>> for Vec<A> where A: PartialEq<B> {\n     #[inline]\n     fn eq(&self, other: &Vec<B>) -> bool { PartialEq::eq(&**self, &**other) }\n@@ -597,13 +598,15 @@ impl<A, B> PartialEq<Vec<B>> for Vec<A> where A: PartialEq<B> {\n \n macro_rules! impl_eq {\n     ($lhs:ty, $rhs:ty) => {\n+        #[stable]\n         impl<'b, A, B> PartialEq<$rhs> for $lhs where A: PartialEq<B> {\n             #[inline]\n             fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n             #[inline]\n             fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n         }\n \n+        #[stable]\n         impl<'b, A, B> PartialEq<$lhs> for $rhs where B: PartialEq<A> {\n             #[inline]\n             fn eq(&self, other: &$lhs) -> bool { PartialEq::eq(&**self, &**other) }\n@@ -616,13 +619,15 @@ macro_rules! impl_eq {\n impl_eq! { Vec<A>, &'b [B] }\n impl_eq! { Vec<A>, &'b mut [B] }\n \n+#[stable]\n impl<'a, A, B> PartialEq<Vec<B>> for CowVec<'a, A> where A: PartialEq<B> + Clone {\n     #[inline]\n     fn eq(&self, other: &Vec<B>) -> bool { PartialEq::eq(&**self, &**other) }\n     #[inline]\n     fn ne(&self, other: &Vec<B>) -> bool { PartialEq::ne(&**self, &**other) }\n }\n \n+#[stable]\n impl<'a, A, B> PartialEq<CowVec<'a, A>> for Vec<B> where A: Clone, B: PartialEq<A> {\n     #[inline]\n     fn eq(&self, other: &CowVec<'a, A>) -> bool { PartialEq::eq(&**self, &**other) }\n@@ -632,13 +637,15 @@ impl<'a, A, B> PartialEq<CowVec<'a, A>> for Vec<B> where A: Clone, B: PartialEq<\n \n macro_rules! impl_eq_for_cowvec {\n     ($rhs:ty) => {\n+        #[stable]\n         impl<'a, 'b, A, B> PartialEq<$rhs> for CowVec<'a, A> where A: PartialEq<B> + Clone {\n             #[inline]\n             fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n             #[inline]\n             fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n         }\n \n+        #[stable]\n         impl<'a, 'b, A, B> PartialEq<CowVec<'a, A>> for $rhs where A: Clone, B: PartialEq<A> {\n             #[inline]\n             fn eq(&self, other: &CowVec<'a, A>) -> bool { PartialEq::eq(&**self, &**other) }\n@@ -651,15 +658,15 @@ macro_rules! impl_eq_for_cowvec {\n impl_eq_for_cowvec! { &'b [B] }\n impl_eq_for_cowvec! { &'b mut [B] }\n \n-#[unstable = \"waiting on PartialOrd stability\"]\n+#[stable]\n impl<T: PartialOrd> PartialOrd for Vec<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> {\n         self.as_slice().partial_cmp(other.as_slice())\n     }\n }\n \n-#[unstable = \"waiting on Eq stability\"]\n+#[stable]\n impl<T: Eq> Eq for Vec<T> {}\n \n #[allow(deprecated)]\n@@ -669,7 +676,7 @@ impl<T: PartialEq, Sized? V: AsSlice<T>> Equiv<V> for Vec<T> {\n     fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n }\n \n-#[unstable = \"waiting on Ord stability\"]\n+#[stable]\n impl<T: Ord> Ord for Vec<T> {\n     #[inline]\n     fn cmp(&self, other: &Vec<T>) -> Ordering {"}, {"sha": "750f1458a42425a67b36aada19abe0c1cb0ea357", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=b94bcbf56eab163517e8ffc93888284b8dbb6238", "patch": "@@ -537,21 +537,26 @@ impl<V:Clone> VecMap<V> {\n     }\n }\n \n+\n+#[stable]\n impl<V: PartialEq> PartialEq for VecMap<V> {\n     fn eq(&self, other: &VecMap<V>) -> bool {\n         iter::order::eq(self.iter(), other.iter())\n     }\n }\n \n+#[stable]\n impl<V: Eq> Eq for VecMap<V> {}\n \n+#[stable]\n impl<V: PartialOrd> PartialOrd for VecMap<V> {\n     #[inline]\n     fn partial_cmp(&self, other: &VecMap<V>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n+#[stable]\n impl<V: Ord> Ord for VecMap<V> {\n     #[inline]\n     fn cmp(&self, other: &VecMap<V>) -> Ordering {"}, {"sha": "88e23377046f12419cfd1c93c52f4f7600fc4ad4", "filename": "src/libcore/array.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=b94bcbf56eab163517e8ffc93888284b8dbb6238", "patch": "@@ -39,7 +39,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[unstable = \"waiting for PartialEq to stabilize\"]\n+            #[stable]\n             impl<A, B> PartialEq<[B, ..$N]> for [A, ..$N] where A: PartialEq<B> {\n                 #[inline]\n                 fn eq(&self, other: &[B, ..$N]) -> bool {\n@@ -51,6 +51,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n+            #[stable]\n             impl<'a, A, B, Rhs> PartialEq<Rhs> for [A, ..$N] where\n                 A: PartialEq<B>,\n                 Rhs: Deref<[B]>,\n@@ -61,6 +62,7 @@ macro_rules! array_impls {\n                 fn ne(&self, other: &Rhs) -> bool { PartialEq::ne(self[], &**other) }\n             }\n \n+            #[stable]\n             impl<'a, A, B, Lhs> PartialEq<[B, ..$N]> for Lhs where\n                 A: PartialEq<B>,\n                 Lhs: Deref<[A]>\n@@ -71,10 +73,10 @@ macro_rules! array_impls {\n                 fn ne(&self, other: &[B, ..$N]) -> bool { PartialEq::ne(&**self, other[]) }\n             }\n \n-            #[unstable = \"waiting for Eq to stabilize\"]\n+            #[stable]\n             impl<T:Eq> Eq for [T, ..$N] { }\n \n-            #[unstable = \"waiting for PartialOrd to stabilize\"]\n+            #[stable]\n             impl<T:PartialOrd> PartialOrd for [T, ..$N] {\n                 #[inline]\n                 fn partial_cmp(&self, other: &[T, ..$N]) -> Option<Ordering> {\n@@ -98,7 +100,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[unstable = \"waiting for Ord to stabilize\"]\n+            #[stable]\n             impl<T:Ord> Ord for [T, ..$N] {\n                 #[inline]\n                 fn cmp(&self, other: &[T, ..$N]) -> Ordering {"}, {"sha": "3a2cb8ea7d9848e0f1bdb5cafa51b7f84b4287c1", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=b94bcbf56eab163517e8ffc93888284b8dbb6238", "patch": "@@ -200,15 +200,18 @@ impl<'a, T, Sized? B> Deref<B> for Cow<'a, T, B> where B: ToOwned<T>  {\n     }\n }\n \n+#[stable]\n impl<'a, T, Sized? B> Eq for Cow<'a, T, B> where B: Eq + ToOwned<T> {}\n \n+#[stable]\n impl<'a, T, Sized? B> Ord for Cow<'a, T, B> where B: Ord + ToOwned<T> {\n     #[inline]\n     fn cmp(&self, other: &Cow<'a, T, B>) -> Ordering {\n         Ord::cmp(&**self, &**other)\n     }\n }\n \n+#[stable]\n impl<'a, 'b, T, U, Sized? B, Sized? C> PartialEq<Cow<'b, U, C>> for Cow<'a, T, B> where\n     B: PartialEq<C> + ToOwned<T>,\n     C: ToOwned<U>,\n@@ -219,6 +222,7 @@ impl<'a, 'b, T, U, Sized? B, Sized? C> PartialEq<Cow<'b, U, C>> for Cow<'a, T, B\n     }\n }\n \n+#[stable]\n impl<'a, T, Sized? B> PartialOrd for Cow<'a, T, B> where B: PartialOrd + ToOwned<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Cow<'a, T, B>) -> Option<Ordering> {"}, {"sha": "6249f7600cd22ac34d733272caacde357dfa3728", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=b94bcbf56eab163517e8ffc93888284b8dbb6238", "patch": "@@ -224,7 +224,7 @@ impl<T:Default + Copy> Default for Cell<T> {\n     }\n }\n \n-#[unstable = \"waiting for `PartialEq` trait to become stable\"]\n+#[stable]\n impl<T:PartialEq + Copy> PartialEq for Cell<T> {\n     fn eq(&self, other: &Cell<T>) -> bool {\n         self.get() == other.get()\n@@ -358,7 +358,7 @@ impl<T:Default> Default for RefCell<T> {\n     }\n }\n \n-#[unstable = \"waiting for `PartialEq` to become stable\"]\n+#[stable]\n impl<T: PartialEq> PartialEq for RefCell<T> {\n     fn eq(&self, other: &RefCell<T>) -> bool {\n         *self.borrow() == *other.borrow()"}, {"sha": "367c794e84bb647b9687c05bbc41b339c9f73561", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 91, "deletions": 57, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=b94bcbf56eab163517e8ffc93888284b8dbb6238", "patch": "@@ -46,27 +46,37 @@ use self::Ordering::*;\n use kinds::Sized;\n use option::Option::{mod, Some, None};\n \n-/// Trait for values that can be compared for equality and inequality.\n+/// Trait for equality comparisons which are [partial equivalence relations](\n+/// http://en.wikipedia.org/wiki/Partial_equivalence_relation).\n ///\n-/// This trait allows for partial equality, for types that do not have an\n+/// This trait allows for partial equality, for types that do not have a full\n /// equivalence relation. For example, in floating point numbers `NaN != NaN`,\n /// so floating point types implement `PartialEq` but not `Eq`.\n ///\n+/// Formally, the equality must be (for all `a`, `b` and `c`):\n+///\n+/// - symmetric: `a == b` implies `b == a`; and\n+/// - transitive: `a == b` and `b == c` implies `a == c`.\n+///\n+/// Note that these requirements mean that the trait itself must be\n+/// implemented symmetrically and transitively: if `T: PartialEq<U>`\n+/// and `U: PartialEq<V>` then `U: PartialEq<T>` and `T:\n+/// PartialEq<V>`.\n+///\n /// PartialEq only requires the `eq` method to be implemented; `ne` is defined\n /// in terms of it by default. Any manual implementation of `ne` *must* respect\n /// the rule that `eq` is a strict inverse of `ne`; that is, `!(a == b)` if and\n /// only if `a != b`.\n-///\n-/// Eventually, this will be implemented by default for types that implement\n-/// `Eq`.\n #[lang=\"eq\"]\n-#[unstable = \"Definition may change slightly after trait reform\"]\n+#[stable]\n pub trait PartialEq<Sized? Rhs = Self> for Sized? {\n     /// This method tests for `self` and `other` values to be equal, and is used by `==`.\n+    #[stable]\n     fn eq(&self, other: &Rhs) -> bool;\n \n     /// This method tests for `!=`.\n     #[inline]\n+    #[stable]\n     fn ne(&self, other: &Rhs) -> bool { !self.eq(other) }\n }\n \n@@ -79,8 +89,8 @@ pub trait PartialEq<Sized? Rhs = Self> for Sized? {\n /// - reflexive: `a == a`;\n /// - symmetric: `a == b` implies `b == a`; and\n /// - transitive: `a == b` and `b == c` implies `a == c`.\n-#[unstable = \"Definition may change slightly after trait reform\"]\n-pub trait Eq<Sized? Rhs = Self> for Sized?: PartialEq<Rhs> {\n+#[stable]\n+pub trait Eq for Sized?: PartialEq<Self> {\n     // FIXME #13101: this method is used solely by #[deriving] to\n     // assert that every component of a type implements #[deriving]\n     // itself, the current deriving infrastructure means doing this\n@@ -97,12 +107,15 @@ pub trait Eq<Sized? Rhs = Self> for Sized?: PartialEq<Rhs> {\n #[deriving(Clone, Copy, PartialEq, Show)]\n #[stable]\n pub enum Ordering {\n-   /// An ordering where a compared value is less [than another].\n-   Less = -1i,\n-   /// An ordering where a compared value is equal [to another].\n-   Equal = 0i,\n-   /// An ordering where a compared value is greater [than another].\n-   Greater = 1i,\n+    /// An ordering where a compared value is less [than another].\n+    #[stable]\n+    Less = -1i,\n+    /// An ordering where a compared value is equal [to another].\n+    #[stable]\n+    Equal = 0i,\n+    /// An ordering where a compared value is greater [than another].\n+    #[stable]\n+    Greater = 1i,\n }\n \n impl Ordering {\n@@ -126,7 +139,7 @@ impl Ordering {\n     /// assert!(data == b);\n     /// ```\n     #[inline]\n-    #[experimental]\n+    #[stable]\n     pub fn reverse(self) -> Ordering {\n         unsafe {\n             // this compiles really nicely (to a single instruction);\n@@ -149,8 +162,8 @@ impl Ordering {\n ///   true; and\n /// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for\n ///   both `==` and `>`.\n-#[unstable = \"Definition may change slightly after trait reform\"]\n-pub trait Ord<Sized? Rhs = Self> for Sized?: Eq<Rhs> + PartialOrd<Rhs> {\n+#[stable]\n+pub trait Ord for Sized?: Eq + PartialOrd<Self> {\n     /// This method returns an ordering between `self` and `other` values.\n     ///\n     /// By convention, `self.cmp(&other)` returns the ordering matching\n@@ -161,30 +174,44 @@ pub trait Ord<Sized? Rhs = Self> for Sized?: Eq<Rhs> + PartialOrd<Rhs> {\n     /// assert_eq!(10u.cmp(&5),  Greater);  // because 10 > 5\n     /// assert_eq!( 5u.cmp(&5),  Equal);    // because 5 == 5\n     /// ```\n-    fn cmp(&self, other: &Rhs) -> Ordering;\n+    #[stable]\n+    fn cmp(&self, other: &Self) -> Ordering;\n }\n \n-#[unstable = \"Trait is unstable.\"]\n+#[stable]\n impl Eq for Ordering {}\n \n-#[unstable = \"Trait is unstable.\"]\n+#[stable]\n impl Ord for Ordering {\n     #[inline]\n+    #[stable]\n     fn cmp(&self, other: &Ordering) -> Ordering {\n         (*self as int).cmp(&(*other as int))\n     }\n }\n \n-#[unstable = \"Trait is unstable.\"]\n+#[stable]\n impl PartialOrd for Ordering {\n     #[inline]\n+    #[stable]\n     fn partial_cmp(&self, other: &Ordering) -> Option<Ordering> {\n         (*self as int).partial_cmp(&(*other as int))\n     }\n }\n \n /// Trait for values that can be compared for a sort-order.\n ///\n+/// The comparison must satisfy, for all `a`, `b` and `c`:\n+///\n+/// - antisymmetry: if `a < b` then `!(a > b)` and vice versa; and\n+/// - transitivity: `a < b` and `b < c` implies `a < c`. The same must hold for\n+///   both `==` and `>`.\n+///\n+/// Note that these requirements mean that the trait itself must be\n+/// implemented symmetrically and transitively: if `T: PartialOrd<U>`\n+/// and `U: PartialOrd<V>` then `U: PartialOrd<T>` and `T:\n+/// PartialOrd<V>`.\n+///\n /// PartialOrd only requires implementation of the `partial_cmp` method,\n /// with the others generated from default implementations.\n ///\n@@ -193,14 +220,16 @@ impl PartialOrd for Ordering {\n /// `NaN < 0 == false` and `NaN >= 0 == false` (cf. IEEE 754-2008 section\n /// 5.11).\n #[lang=\"ord\"]\n-#[unstable = \"Definition may change slightly after trait reform\"]\n+#[stable]\n pub trait PartialOrd<Sized? Rhs = Self> for Sized?: PartialEq<Rhs> {\n     /// This method returns an ordering between `self` and `other` values\n     /// if one exists.\n+    #[stable]\n     fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;\n \n     /// This method tests less than (for `self` and `other`) and is used by the `<` operator.\n     #[inline]\n+    #[stable]\n     fn lt(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n             Some(Less) => true,\n@@ -210,6 +239,7 @@ pub trait PartialOrd<Sized? Rhs = Self> for Sized?: PartialEq<Rhs> {\n \n     /// This method tests less than or equal to (`<=`).\n     #[inline]\n+    #[stable]\n     fn le(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n             Some(Less) | Some(Equal) => true,\n@@ -219,6 +249,7 @@ pub trait PartialOrd<Sized? Rhs = Self> for Sized?: PartialEq<Rhs> {\n \n     /// This method tests greater than (`>`).\n     #[inline]\n+    #[stable]\n     fn gt(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n             Some(Greater) => true,\n@@ -228,6 +259,7 @@ pub trait PartialOrd<Sized? Rhs = Self> for Sized?: PartialEq<Rhs> {\n \n     /// This method tests greater than or equal to (`>=`).\n     #[inline]\n+    #[stable]\n     fn ge(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n             Some(Greater) | Some(Equal) => true,\n@@ -296,7 +328,7 @@ mod impls {\n \n     macro_rules! partial_eq_impl {\n         ($($t:ty)*) => ($(\n-            #[unstable = \"Trait is unstable.\"]\n+            #[stable]\n             impl PartialEq for $t {\n                 #[inline]\n                 fn eq(&self, other: &$t) -> bool { (*self) == (*other) }\n@@ -306,7 +338,7 @@ mod impls {\n         )*)\n     }\n \n-    #[unstable = \"Trait is unstable.\"]\n+    #[stable]\n     impl PartialEq for () {\n         #[inline]\n         fn eq(&self, _other: &()) -> bool { true }\n@@ -320,7 +352,7 @@ mod impls {\n \n     macro_rules! eq_impl {\n         ($($t:ty)*) => ($(\n-            #[unstable = \"Trait is unstable.\"]\n+            #[stable]\n             impl Eq for $t {}\n         )*)\n     }\n@@ -329,7 +361,7 @@ mod impls {\n \n     macro_rules! partial_ord_impl {\n         ($($t:ty)*) => ($(\n-            #[unstable = \"Trait is unstable.\"]\n+            #[stable]\n             impl PartialOrd for $t {\n                 #[inline]\n                 fn partial_cmp(&self, other: &$t) -> Option<Ordering> {\n@@ -352,15 +384,15 @@ mod impls {\n         )*)\n     }\n \n-    #[unstable = \"Trait is unstable.\"]\n+    #[stable]\n     impl PartialOrd for () {\n         #[inline]\n         fn partial_cmp(&self, _: &()) -> Option<Ordering> {\n             Some(Equal)\n         }\n     }\n \n-    #[unstable = \"Trait is unstable.\"]\n+    #[stable]\n     impl PartialOrd for bool {\n         #[inline]\n         fn partial_cmp(&self, other: &bool) -> Option<Ordering> {\n@@ -372,7 +404,7 @@ mod impls {\n \n     macro_rules! ord_impl {\n         ($($t:ty)*) => ($(\n-            #[unstable = \"Trait is unstable.\"]\n+            #[stable]\n             impl Ord for $t {\n                 #[inline]\n                 fn cmp(&self, other: &$t) -> Ordering {\n@@ -384,13 +416,13 @@ mod impls {\n         )*)\n     }\n \n-    #[unstable = \"Trait is unstable.\"]\n+    #[stable]\n     impl Ord for () {\n         #[inline]\n         fn cmp(&self, _other: &()) -> Ordering { Equal }\n     }\n \n-    #[unstable = \"Trait is unstable.\"]\n+    #[stable]\n     impl Ord for bool {\n         #[inline]\n         fn cmp(&self, other: &bool) -> Ordering {\n@@ -402,75 +434,77 @@ mod impls {\n \n     // & pointers\n \n-    #[unstable = \"Trait is unstable.\"]\n+    #[stable]\n     impl<'a, 'b, Sized? A, Sized? B> PartialEq<&'b B> for &'a A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: & &'b B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: & &'b B) -> bool { PartialEq::ne(*self, *other) }\n     }\n-    #[unstable = \"Trait is unstable.\"]\n-    impl<'a, Sized? T: PartialOrd> PartialOrd for &'a T {\n+    #[stable]\n+    impl<'a, 'b, Sized? A, Sized? B> PartialOrd<&'b B> for &'a A where A: PartialOrd<B> {\n         #[inline]\n-        fn partial_cmp(&self, other: &&'a T) -> Option<Ordering> {\n+        fn partial_cmp(&self, other: &&'b B) -> Option<Ordering> {\n             PartialOrd::partial_cmp(*self, *other)\n         }\n         #[inline]\n-        fn lt(&self, other: & &'a T) -> bool { PartialOrd::lt(*self, *other) }\n+        fn lt(&self, other: & &'b B) -> bool { PartialOrd::lt(*self, *other) }\n         #[inline]\n-        fn le(&self, other: & &'a T) -> bool { PartialOrd::le(*self, *other) }\n+        fn le(&self, other: & &'b B) -> bool { PartialOrd::le(*self, *other) }\n         #[inline]\n-        fn ge(&self, other: & &'a T) -> bool { PartialOrd::ge(*self, *other) }\n+        fn ge(&self, other: & &'b B) -> bool { PartialOrd::ge(*self, *other) }\n         #[inline]\n-        fn gt(&self, other: & &'a T) -> bool { PartialOrd::gt(*self, *other) }\n+        fn gt(&self, other: & &'b B) -> bool { PartialOrd::gt(*self, *other) }\n     }\n-    #[unstable = \"Trait is unstable.\"]\n-    impl<'a, Sized? T: Ord> Ord for &'a T {\n+    #[stable]\n+    impl<'a, Sized? A> Ord for &'a A where A: Ord {\n         #[inline]\n-        fn cmp(&self, other: & &'a T) -> Ordering { Ord::cmp(*self, *other) }\n+        fn cmp(&self, other: & &'a A) -> Ordering { Ord::cmp(*self, *other) }\n     }\n-    #[unstable = \"Trait is unstable.\"]\n-    impl<'a, Sized? T: Eq> Eq for &'a T {}\n+    #[stable]\n+    impl<'a, Sized? A> Eq for &'a A where A: Eq {}\n \n     // &mut pointers\n \n-    #[unstable = \"Trait is unstable.\"]\n+    #[stable]\n     impl<'a, 'b, Sized? A, Sized? B> PartialEq<&'b mut B> for &'a mut A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n     }\n-    #[unstable = \"Trait is unstable.\"]\n-    impl<'a, Sized? T: PartialOrd> PartialOrd for &'a mut T {\n+    #[stable]\n+    impl<'a, 'b, Sized? A, Sized? B> PartialOrd<&'b mut B> for &'a mut A where A: PartialOrd<B> {\n         #[inline]\n-        fn partial_cmp(&self, other: &&'a mut T) -> Option<Ordering> {\n+        fn partial_cmp(&self, other: &&'b mut B) -> Option<Ordering> {\n             PartialOrd::partial_cmp(*self, *other)\n         }\n         #[inline]\n-        fn lt(&self, other: &&'a mut T) -> bool { PartialOrd::lt(*self, *other) }\n+        fn lt(&self, other: &&'b mut B) -> bool { PartialOrd::lt(*self, *other) }\n         #[inline]\n-        fn le(&self, other: &&'a mut T) -> bool { PartialOrd::le(*self, *other) }\n+        fn le(&self, other: &&'b mut B) -> bool { PartialOrd::le(*self, *other) }\n         #[inline]\n-        fn ge(&self, other: &&'a mut T) -> bool { PartialOrd::ge(*self, *other) }\n+        fn ge(&self, other: &&'b mut B) -> bool { PartialOrd::ge(*self, *other) }\n         #[inline]\n-        fn gt(&self, other: &&'a mut T) -> bool { PartialOrd::gt(*self, *other) }\n+        fn gt(&self, other: &&'b mut B) -> bool { PartialOrd::gt(*self, *other) }\n     }\n-    #[unstable = \"Trait is unstable.\"]\n-    impl<'a, Sized? T: Ord> Ord for &'a mut T {\n+    #[stable]\n+    impl<'a, Sized? A> Ord for &'a mut A where A: Ord {\n         #[inline]\n-        fn cmp(&self, other: &&'a mut T) -> Ordering { Ord::cmp(*self, *other) }\n+        fn cmp(&self, other: &&'a mut A) -> Ordering { Ord::cmp(*self, *other) }\n     }\n-    #[unstable = \"Trait is unstable.\"]\n-    impl<'a, Sized? T: Eq> Eq for &'a mut T {}\n+    #[stable]\n+    impl<'a, Sized? A> Eq for &'a mut A where A: Eq {}\n \n+    #[stable]\n     impl<'a, 'b, Sized? A, Sized? B> PartialEq<&'b mut B> for &'a A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n     }\n \n+    #[stable]\n     impl<'a, 'b, Sized? A, Sized? B> PartialEq<&'b B> for &'a mut A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: &&'b B) -> bool { PartialEq::eq(*self, *other) }"}, {"sha": "faf1d781465c76457b4d08ef731a0cd58fcec2c3", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=b94bcbf56eab163517e8ffc93888284b8dbb6238", "patch": "@@ -379,6 +379,7 @@ impl<T> MutPtrExt<T> for *mut T {\n }\n \n // Equality for pointers\n+#[stable]\n impl<T> PartialEq for *const T {\n     #[inline]\n     fn eq(&self, other: &*const T) -> bool {\n@@ -388,8 +389,10 @@ impl<T> PartialEq for *const T {\n     fn ne(&self, other: &*const T) -> bool { !self.eq(other) }\n }\n \n+#[stable]\n impl<T> Eq for *const T {}\n \n+#[stable]\n impl<T> PartialEq for *mut T {\n     #[inline]\n     fn eq(&self, other: &*mut T) -> bool {\n@@ -399,6 +402,7 @@ impl<T> PartialEq for *mut T {\n     fn ne(&self, other: &*mut T) -> bool { !self.eq(other) }\n }\n \n+#[stable]\n impl<T> Eq for *mut T {}\n \n // Equivalence for pointers\n@@ -439,6 +443,7 @@ mod externfnpointers {\n     use mem;\n     use cmp::PartialEq;\n \n+    #[stable]\n     impl<_R> PartialEq for extern \"C\" fn() -> _R {\n         #[inline]\n         fn eq(&self, other: &extern \"C\" fn() -> _R) -> bool {\n@@ -449,6 +454,7 @@ mod externfnpointers {\n     }\n     macro_rules! fnptreq {\n         ($($p:ident),*) => {\n+            #[stable]\n             impl<_R,$($p),*> PartialEq for extern \"C\" fn($($p),*) -> _R {\n                 #[inline]\n                 fn eq(&self, other: &extern \"C\" fn($($p),*) -> _R) -> bool {\n@@ -468,6 +474,7 @@ mod externfnpointers {\n }\n \n // Comparison for pointers\n+#[stable]\n impl<T> Ord for *const T {\n     #[inline]\n     fn cmp(&self, other: &*const T) -> Ordering {\n@@ -481,6 +488,7 @@ impl<T> Ord for *const T {\n     }\n }\n \n+#[stable]\n impl<T> PartialOrd for *const T {\n     #[inline]\n     fn partial_cmp(&self, other: &*const T) -> Option<Ordering> {\n@@ -500,6 +508,7 @@ impl<T> PartialOrd for *const T {\n     fn ge(&self, other: &*const T) -> bool { *self >= *other }\n }\n \n+#[stable]\n impl<T> Ord for *mut T {\n     #[inline]\n     fn cmp(&self, other: &*mut T) -> Ordering {\n@@ -513,6 +522,7 @@ impl<T> Ord for *mut T {\n     }\n }\n \n+#[stable]\n impl<T> PartialOrd for *mut T {\n     #[inline]\n     fn partial_cmp(&self, other: &*mut T) -> Option<Ordering> {"}, {"sha": "77bb5cc2499c881e696a81775c629f74fbac151f", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=b94bcbf56eab163517e8ffc93888284b8dbb6238", "patch": "@@ -1437,7 +1437,7 @@ pub mod bytes {\n // Boilerplate traits\n //\n \n-#[unstable = \"waiting for DST\"]\n+#[stable]\n impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> {\n     fn eq(&self, other: &[B]) -> bool {\n         self.len() == other.len() &&\n@@ -1449,7 +1449,7 @@ impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> {\n     }\n }\n \n-#[unstable = \"waiting for DST\"]\n+#[stable]\n impl<T: Eq> Eq for [T] {}\n \n #[allow(deprecated)]\n@@ -1466,14 +1466,14 @@ impl<'a,T:PartialEq, Sized? V: AsSlice<T>> Equiv<V> for &'a mut [T] {\n     fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n }\n \n-#[unstable = \"waiting for DST\"]\n+#[stable]\n impl<T: Ord> Ord for [T] {\n     fn cmp(&self, other: &[T]) -> Ordering {\n         order::cmp(self.iter(), other.iter())\n     }\n }\n \n-#[unstable = \"waiting for DST\"]\n+#[stable]\n impl<T: PartialOrd> PartialOrd for [T] {\n     #[inline]\n     fn partial_cmp(&self, other: &[T]) -> Option<Ordering> {"}, {"sha": "59cf79408b100acb837ee39cae95012a366d0250", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=b94bcbf56eab163517e8ffc93888284b8dbb6238", "patch": "@@ -1143,6 +1143,7 @@ pub mod traits {\n     use ops;\n     use str::{Str, StrExt, eq_slice};\n \n+    #[stable]\n     impl Ord for str {\n         #[inline]\n         fn cmp(&self, other: &str) -> Ordering {\n@@ -1158,6 +1159,7 @@ pub mod traits {\n         }\n     }\n \n+    #[stable]\n     impl PartialEq for str {\n         #[inline]\n         fn eq(&self, other: &str) -> bool {\n@@ -1167,8 +1169,10 @@ pub mod traits {\n         fn ne(&self, other: &str) -> bool { !(*self).eq(other) }\n     }\n \n+    #[stable]\n     impl Eq for str {}\n \n+    #[stable]\n     impl PartialOrd for str {\n         #[inline]\n         fn partial_cmp(&self, other: &str) -> Option<Ordering> {"}, {"sha": "576989fabe77c92a573e6d348b5ff411c3ee6e31", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=b94bcbf56eab163517e8ffc93888284b8dbb6238", "patch": "@@ -132,7 +132,7 @@ macro_rules! tuple_impls {\n                 }\n             }\n \n-            #[unstable = \"waiting for PartialEq to stabilize\"]\n+            #[stable]\n             impl<$($T:PartialEq),+> PartialEq for ($($T,)+) {\n                 #[inline]\n                 fn eq(&self, other: &($($T,)+)) -> bool {\n@@ -144,10 +144,10 @@ macro_rules! tuple_impls {\n                 }\n             }\n \n-            #[unstable = \"waiting for Eq to stabilize\"]\n+            #[stable]\n             impl<$($T:Eq),+> Eq for ($($T,)+) {}\n \n-            #[unstable = \"waiting for PartialOrd to stabilize\"]\n+            #[stable]\n             impl<$($T:PartialOrd + PartialEq),+> PartialOrd for ($($T,)+) {\n                 #[inline]\n                 fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n@@ -171,7 +171,7 @@ macro_rules! tuple_impls {\n                 }\n             }\n \n-            #[unstable = \"waiting for Ord to stabilize\"]\n+            #[stable]\n             impl<$($T:Ord),+> Ord for ($($T,)+) {\n                 #[inline]\n                 fn cmp(&self, other: &($($T,)+)) -> Ordering {"}, {"sha": "b473a665c76b1af969d66864a952c5b6808abb15", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=b94bcbf56eab163517e8ffc93888284b8dbb6238", "patch": "@@ -1261,6 +1261,7 @@ impl<K: Eq + Hash<S>, V: Clone, S, H: Hasher<S>> HashMap<K, V, H> {\n     }\n }\n \n+#[stable]\n impl<K: Eq + Hash<S>, V: PartialEq, S, H: Hasher<S>> PartialEq for HashMap<K, V, H> {\n     fn eq(&self, other: &HashMap<K, V, H>) -> bool {\n         if self.len() != other.len() { return false; }\n@@ -1271,6 +1272,7 @@ impl<K: Eq + Hash<S>, V: PartialEq, S, H: Hasher<S>> PartialEq for HashMap<K, V,\n     }\n }\n \n+#[stable]\n impl<K: Eq + Hash<S>, V: Eq, S, H: Hasher<S>> Eq for HashMap<K, V, H> {}\n \n impl<K: Eq + Hash<S> + Show, V: Show, S, H: Hasher<S>> Show for HashMap<K, V, H> {"}, {"sha": "93f6895f6885b519dc8311076cd6c986e9f7cf23", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94bcbf56eab163517e8ffc93888284b8dbb6238/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=b94bcbf56eab163517e8ffc93888284b8dbb6238", "patch": "@@ -572,6 +572,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     }\n }\n \n+#[stable]\n impl<T: Eq + Hash<S>, S, H: Hasher<S>> PartialEq for HashSet<T, H> {\n     fn eq(&self, other: &HashSet<T, H>) -> bool {\n         if self.len() != other.len() { return false; }\n@@ -580,6 +581,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> PartialEq for HashSet<T, H> {\n     }\n }\n \n+#[stable]\n impl<T: Eq + Hash<S>, S, H: Hasher<S>> Eq for HashSet<T, H> {}\n \n impl<T: Eq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {"}]}