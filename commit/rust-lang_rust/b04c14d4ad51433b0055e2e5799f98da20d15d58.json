{"sha": "b04c14d4ad51433b0055e2e5799f98da20d15d58", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwNGMxNGQ0YWQ1MTQzM2IwMDU1ZTJlNTc5OWY5OGRhMjBkMTVkNTg=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-03T16:46:30Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-03T16:46:30Z"}, "message": "dispatch acros roots", "tree": {"sha": "18bd67e27c515d48be6725230b274b2eb55c740d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18bd67e27c515d48be6725230b274b2eb55c740d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b04c14d4ad51433b0055e2e5799f98da20d15d58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b04c14d4ad51433b0055e2e5799f98da20d15d58", "html_url": "https://github.com/rust-lang/rust/commit/b04c14d4ad51433b0055e2e5799f98da20d15d58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b04c14d4ad51433b0055e2e5799f98da20d15d58/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f2feef9afe8f1c75f743a56f945a1560ca85af4", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f2feef9afe8f1c75f743a56f945a1560ca85af4", "html_url": "https://github.com/rust-lang/rust/commit/2f2feef9afe8f1c75f743a56f945a1560ca85af4"}], "stats": {"total": 255, "additions": 180, "deletions": 75}, "files": [{"sha": "c1e144025b48424d140e2d522353777b1367cc17", "filename": "crates/libanalysis/src/imp.rs", "status": "modified", "additions": 44, "deletions": 21, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/b04c14d4ad51433b0055e2e5799f98da20d15d58/crates%2Flibanalysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04c14d4ad51433b0055e2e5799f98da20d15d58/crates%2Flibanalysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fimp.rs?ref=b04c14d4ad51433b0055e2e5799f98da20d15d58", "patch": "@@ -17,8 +17,8 @@ use libsyntax2::{\n use {\n     FileId, FileResolver, Query, Diagnostic, SourceChange, SourceFileEdit, Position, FileSystemEdit,\n     JobToken, CrateGraph, CrateId,\n-    module_map::Problem,\n-    roots::SourceRoot,\n+    module_map::{ModuleMap, Problem},\n+    roots::{SourceRoot, ReadonlySourceRoot, WritableSourceRoot},\n };\n \n #[derive(Debug)]\n@@ -57,6 +57,10 @@ impl AnalysisHostImpl {\n         }\n         self.data_mut().crate_graph = graph;\n     }\n+    pub fn set_libraries(&mut self, libs: impl Iterator<Item=impl Iterator<Item=(FileId, String)>>) {\n+        let libs = libs.map(ReadonlySourceRoot::new).collect::<Vec<_>>();\n+        self.data_mut().libs = Arc::new(libs);\n+    }\n     fn data_mut(&mut self) -> &mut WorldData {\n         Arc::make_mut(&mut self.data)\n     }\n@@ -85,19 +89,33 @@ impl Clone for AnalysisImpl {\n }\n \n impl AnalysisImpl {\n+    fn root(&self, file_id: FileId) -> &SourceRoot {\n+        if self.data.root.contains(file_id) {\n+            return &self.data.root;\n+        }\n+        self.data.libs.iter().find(|it| it.contains(file_id)).unwrap()\n+    }\n     pub fn file_syntax(&self, file_id: FileId) -> &File {\n-        self.data.root.syntax(file_id)\n+        self.root(file_id).syntax(file_id)\n     }\n     pub fn file_line_index(&self, file_id: FileId) -> &LineIndex {\n-        self.data.root.lines(file_id)\n+        self.root(file_id).lines(file_id)\n     }\n-    pub fn world_symbols(&self,  query: Query, token: &JobToken) -> Vec<(FileId, FileSymbol)> {\n+    pub fn world_symbols(&self, query: Query, token: &JobToken) -> Vec<(FileId, FileSymbol)> {\n         self.reindex();\n-        query.search(&self.data.root.symbols(), token)\n+        let mut buf = Vec::new();\n+        if query.libs {\n+            self.data.libs.iter()\n+                .for_each(|it| it.symbols(&mut buf));\n+        } else {\n+            self.data.root.symbols(&mut buf);\n+        }\n+        query.search(&buf, token)\n+\n     }\n-    pub fn parent_module(&self, id: FileId) -> Vec<(FileId, FileSymbol)> {\n-        let module_map = self.data.root.module_map();\n-        let id = module_map.file2module(id);\n+    pub fn parent_module(&self, file_id: FileId) -> Vec<(FileId, FileSymbol)> {\n+        let module_map = self.root(file_id).module_map();\n+        let id = module_map.file2module(file_id);\n         module_map\n             .parent_modules(\n                 id,\n@@ -117,12 +135,12 @@ impl AnalysisImpl {\n             .collect()\n     }\n \n-    pub fn crate_for(&self, id: FileId) -> Vec<CrateId> {\n-        let module_map = self.data.root.module_map();\n+    pub fn crate_for(&self, file_id: FileId) -> Vec<CrateId> {\n+        let module_map = self.root(file_id).module_map();\n         let crate_graph = &self.data.crate_graph;\n         let mut res = Vec::new();\n         let mut work = VecDeque::new();\n-        work.push_back(id);\n+        work.push_back(file_id);\n         let mut visited = HashSet::new();\n         while let Some(id) = work.pop_front() {\n             if let Some(crate_id) = crate_graph.crate_id_for_crate_root(id) {\n@@ -148,19 +166,21 @@ impl AnalysisImpl {\n     }\n     pub fn approximately_resolve_symbol(\n         &self,\n-        id: FileId,\n+        file_id: FileId,\n         offset: TextUnit,\n         token: &JobToken,\n     ) -> Vec<(FileId, FileSymbol)> {\n-        let file = self.file_syntax(id);\n+        let root = self.root(file_id);\n+        let module_map = root.module_map();\n+        let file = root.syntax(file_id);\n         let syntax = file.syntax();\n         if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(syntax, offset) {\n             return self.index_resolve(name_ref, token);\n         }\n         if let Some(name) = find_node_at_offset::<ast::Name>(syntax, offset) {\n             if let Some(module) = name.syntax().parent().and_then(ast::Module::cast) {\n                 if module.has_semi() {\n-                    let file_ids = self.resolve_module(id, module);\n+                    let file_ids = self.resolve_module(module_map, file_id, module);\n \n                     let res = file_ids.into_iter().map(|id| {\n                         let name = module.name()\n@@ -182,13 +202,16 @@ impl AnalysisImpl {\n     }\n \n     pub fn diagnostics(&self, file_id: FileId) -> Vec<Diagnostic> {\n-        let syntax = self.file_syntax(file_id);\n+        let root = self.root(file_id);\n+        let module_map = root.module_map();\n+        let syntax = root.syntax(file_id);\n+\n         let mut res = libeditor::diagnostics(&syntax)\n             .into_iter()\n             .map(|d| Diagnostic { range: d.range, message: d.msg, fix: None })\n             .collect::<Vec<_>>();\n \n-        self.data.root.module_map().problems(\n+        module_map.problems(\n             file_id,\n             &*self.file_resolver,\n             &|file_id| self.file_syntax(file_id),\n@@ -257,13 +280,12 @@ impl AnalysisImpl {\n         self.world_symbols(query, token)\n     }\n \n-    fn resolve_module(&self, id: FileId, module: ast::Module) -> Vec<FileId> {\n+    fn resolve_module(&self, module_map: &ModuleMap, file_id: FileId, module: ast::Module) -> Vec<FileId> {\n         let name = match module.name() {\n             Some(name) => name.text(),\n             None => return Vec::new(),\n         };\n-        let module_map = self.data.root.module_map();\n-        let id = module_map.file2module(id);\n+        let id = module_map.file2module(file_id);\n         module_map\n             .child_module_by_name(\n                 id, name.as_str(),\n@@ -285,7 +307,8 @@ impl AnalysisImpl {\n #[derive(Clone, Default, Debug)]\n struct WorldData {\n     crate_graph: CrateGraph,\n-    root: SourceRoot,\n+    root: WritableSourceRoot,\n+    libs: Arc<Vec<ReadonlySourceRoot>>,\n }\n \n impl SourceChange {"}, {"sha": "9ae87d46cf253671005ca0fba428de7dcb5b8f29", "filename": "crates/libanalysis/src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b04c14d4ad51433b0055e2e5799f98da20d15d58/crates%2Flibanalysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04c14d4ad51433b0055e2e5799f98da20d15d58/crates%2Flibanalysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Flib.rs?ref=b04c14d4ad51433b0055e2e5799f98da20d15d58", "patch": "@@ -68,6 +68,9 @@ impl AnalysisHost {\n     pub fn set_crate_graph(&mut self, graph: CrateGraph) {\n         self.imp.set_crate_graph(graph)\n     }\n+    pub fn set_libraries(&mut self, libs: impl Iterator<Item=impl Iterator<Item=(FileId, String)>>) {\n+        self.imp.set_libraries(libs)\n+    }\n }\n \n #[derive(Debug)]\n@@ -114,6 +117,7 @@ pub struct Query {\n     query: String,\n     lowercased: String,\n     only_types: bool,\n+    libs: bool,\n     exact: bool,\n     limit: usize,\n }\n@@ -125,13 +129,17 @@ impl Query {\n             query,\n             lowercased,\n             only_types: false,\n+            libs: false,\n             exact: false,\n             limit: usize::max_value()\n         }\n     }\n     pub fn only_types(&mut self) {\n         self.only_types = true;\n     }\n+    pub fn libs(&mut self) {\n+        self.libs = true;\n+    }\n     pub fn exact(&mut self) {\n         self.exact = true;\n     }"}, {"sha": "1b225eceedb352b19dc32ec3e36947e6498a0a86", "filename": "crates/libanalysis/src/module_map.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b04c14d4ad51433b0055e2e5799f98da20d15d58/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04c14d4ad51433b0055e2e5799f98da20d15d58/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs?ref=b04c14d4ad51433b0055e2e5799f98da20d15d58", "patch": "@@ -56,6 +56,10 @@ pub enum Problem {\n }\n \n impl ModuleMap {\n+    pub fn new() -> ModuleMap {\n+        Default::default()\n+    }\n+\n     pub fn update_file(&mut self, file: FileId, change_kind: ChangeKind) {\n         self.state.get_mut().changes.push((file, change_kind));\n     }"}, {"sha": "a65668c9b863be349f0d050fa772eb7b98e3e97c", "filename": "crates/libanalysis/src/roots.rs", "status": "modified", "additions": 103, "deletions": 40, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/b04c14d4ad51433b0055e2e5799f98da20d15d58/crates%2Flibanalysis%2Fsrc%2Froots.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04c14d4ad51433b0055e2e5799f98da20d15d58/crates%2Flibanalysis%2Fsrc%2Froots.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Froots.rs?ref=b04c14d4ad51433b0055e2e5799f98da20d15d58", "patch": "@@ -13,16 +13,24 @@ use libsyntax2::File;\n use {\n     FileId,\n     module_map::{ModuleMap, ChangeKind},\n-    symbol_index::FileSymbols,\n+    symbol_index::SymbolIndex,\n };\n \n+pub(crate) trait SourceRoot {\n+    fn contains(&self, file_id: FileId) -> bool;\n+    fn module_map(&self) -> &ModuleMap;\n+    fn lines(&self, file_id: FileId) -> &LineIndex;\n+    fn syntax(&self, file_id: FileId) -> &File;\n+    fn symbols<'a>(&'a self, acc: &mut Vec<&'a SymbolIndex>);\n+}\n+\n #[derive(Clone, Default, Debug)]\n-pub(crate) struct SourceRoot {\n-    file_map: HashMap<FileId, Arc<(FileData, OnceCell<FileSymbols>)>>,\n+pub(crate) struct WritableSourceRoot {\n+    file_map: HashMap<FileId, Arc<(FileData, OnceCell<SymbolIndex>)>>,\n     module_map: ModuleMap,\n }\n \n-impl SourceRoot {\n+impl WritableSourceRoot {\n     pub fn update(&mut self, file_id: FileId, text: Option<String>) {\n         let change_kind = if self.file_map.remove(&file_id).is_some() {\n             if text.is_some() {\n@@ -40,31 +48,6 @@ impl SourceRoot {\n             self.file_map.insert(file_id, Arc::new((file_data, Default::default())));\n         }\n     }\n-    pub fn module_map(&self) -> &ModuleMap {\n-        &self.module_map\n-    }\n-    pub fn lines(&self, file_id: FileId) -> &LineIndex {\n-        let data = self.data(file_id);\n-        data.lines.get_or_init(|| LineIndex::new(&data.text))\n-    }\n-    pub fn syntax(&self, file_id: FileId) -> &File {\n-        let data = self.data(file_id);\n-        let text = &data.text;\n-        let syntax = &data.syntax;\n-        match panic::catch_unwind(panic::AssertUnwindSafe(|| syntax.get_or_init(|| File::parse(text)))) {\n-            Ok(file) => file,\n-            Err(err) => {\n-                error!(\"Parser paniced on:\\n------\\n{}\\n------\\n\", &data.text);\n-                panic::resume_unwind(err)\n-            }\n-        }\n-    }\n-    pub(crate) fn symbols(&self) -> Vec<&FileSymbols> {\n-        self.file_map\n-            .iter()\n-            .map(|(&file_id, data)| symbols(file_id, data))\n-            .collect()\n-    }\n     pub fn reindex(&self) {\n         let now = Instant::now();\n         self.file_map\n@@ -83,9 +66,31 @@ impl SourceRoot {\n     }\n }\n \n-fn symbols(file_id: FileId, (data, symbols): &(FileData, OnceCell<FileSymbols>)) -> &FileSymbols {\n+impl SourceRoot for WritableSourceRoot {\n+    fn contains(&self, file_id: FileId) -> bool {\n+        self.file_map.contains_key(&file_id)\n+    }\n+    fn module_map(&self) -> &ModuleMap {\n+        &self.module_map\n+    }\n+    fn lines(&self, file_id: FileId) -> &LineIndex {\n+        self.data(file_id).lines()\n+    }\n+    fn syntax(&self, file_id: FileId) -> &File {\n+        self.data(file_id).syntax()\n+    }\n+    fn symbols<'a>(&'a self, acc: &mut Vec<&'a SymbolIndex>) {\n+        acc.extend(\n+            self.file_map\n+                .iter()\n+                .map(|(&file_id, data)| symbols(file_id, data))\n+        )\n+    }\n+}\n+\n+fn symbols(file_id: FileId, (data, symbols): &(FileData, OnceCell<SymbolIndex>)) -> &SymbolIndex {\n     let syntax = data.syntax_transient();\n-    symbols.get_or_init(|| FileSymbols::new(file_id, &syntax))\n+    symbols.get_or_init(|| SymbolIndex::for_file(file_id, syntax))\n }\n \n #[derive(Debug)]\n@@ -103,19 +108,77 @@ impl FileData {\n             lines: OnceCell::new(),\n         }\n     }\n+    fn lines(&self) -> &LineIndex {\n+        self.lines.get_or_init(|| LineIndex::new(&self.text))\n+    }\n+    fn syntax(&self) -> &File {\n+        let text = &self.text;\n+        let syntax = &self.syntax;\n+        match panic::catch_unwind(panic::AssertUnwindSafe(|| syntax.get_or_init(|| File::parse(text)))) {\n+            Ok(file) => file,\n+            Err(err) => {\n+                error!(\"Parser paniced on:\\n------\\n{}\\n------\\n\", text);\n+                panic::resume_unwind(err)\n+            }\n+        }\n+    }\n     fn syntax_transient(&self) -> File {\n         self.syntax.get().map(|s| s.clone())\n             .unwrap_or_else(|| File::parse(&self.text))\n     }\n }\n \n-// #[derive(Clone, Default, Debug)]\n-// pub(crate) struct ReadonlySourceRoot {\n-//     data: Arc<ReadonlySourceRoot>\n-// }\n+#[derive(Debug)]\n+pub(crate) struct ReadonlySourceRoot {\n+    symbol_index: SymbolIndex,\n+    file_map: HashMap<FileId, FileData>,\n+    module_map: ModuleMap,\n+}\n \n-// #[derive(Clone, Default, Debug)]\n-// pub(crate) struct ReadonlySourceRootInner {\n-//     file_map: HashMap<FileId, FileData>,\n-//     module_map: ModuleMap,\n-// }\n+impl ReadonlySourceRoot {\n+    pub fn new(files: impl Iterator<Item=(FileId, String)>) -> ReadonlySourceRoot {\n+        let mut module_map = ModuleMap::new();\n+        let file_map: HashMap<FileId, FileData> = files\n+            .map(|(id, text)| {\n+                module_map.update_file(id, ChangeKind::Insert);\n+                (id, FileData::new(text))\n+            })\n+            .collect();\n+        let symbol_index = SymbolIndex::for_files(\n+            file_map.par_iter().map(|(&file_id, file_data)| {\n+                (file_id, file_data.syntax_transient())\n+            })\n+        );\n+\n+        ReadonlySourceRoot {\n+            symbol_index,\n+            file_map,\n+            module_map,\n+        }\n+    }\n+\n+    fn data(&self, file_id: FileId) -> &FileData {\n+        match self.file_map.get(&file_id) {\n+            Some(data) => data,\n+            None => panic!(\"unknown file: {:?}\", file_id),\n+        }\n+    }\n+}\n+\n+impl SourceRoot for ReadonlySourceRoot {\n+    fn contains(&self, file_id: FileId) -> bool {\n+        self.file_map.contains_key(&file_id)\n+    }\n+    fn module_map(&self) -> &ModuleMap {\n+        &self.module_map\n+    }\n+    fn lines(&self, file_id: FileId) -> &LineIndex {\n+        self.data(file_id).lines()\n+    }\n+    fn syntax(&self, file_id: FileId) -> &File {\n+        self.data(file_id).syntax()\n+    }\n+    fn symbols<'a>(&'a self, acc: &mut Vec<&'a SymbolIndex>) {\n+        acc.push(&self.symbol_index)\n+    }\n+}"}, {"sha": "8fef326ab87fc5011aba745ffc92b00127578ca2", "filename": "crates/libanalysis/src/symbol_index.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b04c14d4ad51433b0055e2e5799f98da20d15d58/crates%2Flibanalysis%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04c14d4ad51433b0055e2e5799f98da20d15d58/crates%2Flibanalysis%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fsymbol_index.rs?ref=b04c14d4ad51433b0055e2e5799f98da20d15d58", "patch": "@@ -4,39 +4,46 @@ use libsyntax2::{\n     SyntaxKind::{self, *},\n };\n use fst::{self, Streamer};\n+use rayon::prelude::*;\n use {Query, FileId, JobToken};\n \n #[derive(Debug)]\n-pub(crate) struct FileSymbols {\n+pub(crate) struct SymbolIndex {\n     symbols: Vec<(FileId, FileSymbol)>,\n     map: fst::Map,\n }\n \n-impl FileSymbols {\n-    pub(crate) fn new(file_id: FileId, file: &File) -> FileSymbols {\n-        let mut symbols = file_symbols(file)\n-            .into_iter()\n-            .map(|s| (s.name.as_str().to_lowercase(), s))\n+impl SymbolIndex {\n+    pub(crate) fn for_files(files: impl ParallelIterator<Item=(FileId, File)>) -> SymbolIndex {\n+        let mut symbols = files\n+            .flat_map(|(file_id, file)| {\n+                file_symbols(&file)\n+                    .into_iter()\n+                    .map(move |symbol| {\n+                        (symbol.name.as_str().to_lowercase(), (file_id, symbol))\n+                    })\n+                    .collect::<Vec<_>>()\n+            })\n             .collect::<Vec<_>>();\n-\n-        symbols.sort_by(|s1, s2| s1.0.cmp(&s2.0));\n+        symbols.par_sort_by(|s1, s2| s1.0.cmp(&s2.0));\n         symbols.dedup_by(|s1, s2| s1.0 == s2.0);\n         let (names, symbols): (Vec<String>, Vec<(FileId, FileSymbol)>) =\n-            symbols.into_iter()\n-                .map(|(name, symbol)| (name, (file_id, symbol)))\n-                .unzip();\n-\n+            symbols.into_iter().unzip();\n         let map = fst::Map::from_iter(\n             names.into_iter().zip(0u64..)\n         ).unwrap();\n-        FileSymbols { symbols, map }\n+        SymbolIndex { symbols, map }\n+    }\n+\n+    pub(crate) fn for_file(file_id: FileId, file: File) -> SymbolIndex {\n+        SymbolIndex::for_files(::rayon::iter::once((file_id, file)))\n     }\n }\n \n impl Query {\n     pub(crate) fn search(\n         mut self,\n-        indices: &[&FileSymbols],\n+        indices: &[&SymbolIndex],\n         token: &JobToken,\n     ) -> Vec<(FileId, FileSymbol)> {\n "}]}