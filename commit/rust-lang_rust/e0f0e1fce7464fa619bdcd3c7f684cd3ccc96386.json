{"sha": "e0f0e1fce7464fa619bdcd3c7f684cd3ccc96386", "node_id": "C_kwDOAAsO6NoAKGUwZjBlMWZjZTc0NjRmYTYxOWJkY2QzYzdmNjg0Y2QzY2NjOTYzODY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-22T16:21:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-22T16:21:11Z"}, "message": "Auto merge of #2503 - RalfJung:tls-dtor-order, r=RalfJung\n\nnotes on TLS dtor order\n\nFixes https://github.com/rust-lang/miri/issues/2486", "tree": {"sha": "5839fde482cbc32ec8a4d4f0646050bf5fcb2a61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5839fde482cbc32ec8a4d4f0646050bf5fcb2a61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0f0e1fce7464fa619bdcd3c7f684cd3ccc96386", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0f0e1fce7464fa619bdcd3c7f684cd3ccc96386", "html_url": "https://github.com/rust-lang/rust/commit/e0f0e1fce7464fa619bdcd3c7f684cd3ccc96386", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0f0e1fce7464fa619bdcd3c7f684cd3ccc96386/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a109994f2271736388bba619c08f794189ebb328", "url": "https://api.github.com/repos/rust-lang/rust/commits/a109994f2271736388bba619c08f794189ebb328", "html_url": "https://github.com/rust-lang/rust/commit/a109994f2271736388bba619c08f794189ebb328"}, {"sha": "afacf62cf0421e032e6e001b6f4ba49f508b14c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/afacf62cf0421e032e6e001b6f4ba49f508b14c8", "html_url": "https://github.com/rust-lang/rust/commit/afacf62cf0421e032e6e001b6f4ba49f508b14c8"}], "stats": {"total": 228, "additions": 24, "deletions": 204}, "files": [{"sha": "f0f1d0e52bdb978f5dc385c8f837ac37e900ac1a", "filename": "src/shims/tls.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e0f0e1fce7464fa619bdcd3c7f684cd3ccc96386/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f0e1fce7464fa619bdcd3c7f684cd3ccc96386/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=e0f0e1fce7464fa619bdcd3c7f684cd3ccc96386", "patch": "@@ -165,8 +165,8 @@ impl<'tcx> TlsData<'tcx> {\n     /// and the thread has a non-NULL value associated with that key,\n     /// the value of the key is set to NULL, and then the function pointed\n     /// to is called with the previously associated value as its sole argument.\n-    /// The order of destructor calls is unspecified if more than one destructor\n-    /// exists for a thread when it exits.\n+    /// **The order of destructor calls is unspecified if more than one destructor\n+    /// exists for a thread when it exits.**\n     ///\n     /// If, after all the destructors have been called for all non-NULL values\n     /// with associated destructors, there are still some non-NULL values with\n@@ -188,6 +188,13 @@ impl<'tcx> TlsData<'tcx> {\n             Some(key) => Excluded(key),\n             None => Unbounded,\n         };\n+        // We interpret the documentaion above (taken from POSIX) as saying that we need to iterate\n+        // over all keys and run each destructor at least once before running any destructor a 2nd\n+        // time. That's why we have `key` to indicate how far we got in the current iteration. If we\n+        // return `None`, `schedule_next_pthread_tls_dtor` will re-try with `ket` set to `None` to\n+        // start the next round.\n+        // TODO: In the future, we might consider randomizing destructor order, but we still have to\n+        // uphold this requirement.\n         for (&key, TlsEntry { data, dtor }) in thread_local.range_mut((start, Unbounded)) {\n             match data.entry(thread_id) {\n                 BTreeEntry::Occupied(entry) => {"}, {"sha": "04e89ec361b74dcc5718e603120f84a51ff2e35f", "filename": "tests/pass/concurrency/tls_lib_drop.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0f0e1fce7464fa619bdcd3c7f684cd3ccc96386/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f0e1fce7464fa619bdcd3c7f684cd3ccc96386/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop.rs?ref=e0f0e1fce7464fa619bdcd3c7f684cd3ccc96386", "patch": "@@ -1,5 +1,3 @@\n-//@ignore-target-windows: TLS destructor order is different on Windows.\n-\n use std::cell::RefCell;\n use std::thread;\n \n@@ -24,14 +22,18 @@ thread_local! {\n /// Check that destructors of the library thread locals are executed immediately\n /// after a thread terminates.\n fn check_destructors() {\n+    // We use the same value for both of them, since destructor order differs between Miri on Linux\n+    // (which uses `register_dtor_fallback`, in the end using a single pthread_key to manage a\n+    // thread-local linked list of dtors to call), real Linux rustc (which uses\n+    // `__cxa_thread_atexit_impl`), and Miri on Windows.\n     thread::spawn(|| {\n         A.with(|f| {\n             assert_eq!(*f.value.borrow(), 0);\n-            *f.value.borrow_mut() = 5;\n+            *f.value.borrow_mut() = 8;\n         });\n         A_CONST.with(|f| {\n             assert_eq!(*f.value.borrow(), 10);\n-            *f.value.borrow_mut() = 15;\n+            *f.value.borrow_mut() = 8;\n         });\n     })\n     .join()"}, {"sha": "b7877820a0ca9760b42136ff92decd1fa7fd57db", "filename": "tests/pass/concurrency/tls_lib_drop.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0f0e1fce7464fa619bdcd3c7f684cd3ccc96386/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/e0f0e1fce7464fa619bdcd3c7f684cd3ccc96386/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop.stdout?ref=e0f0e1fce7464fa619bdcd3c7f684cd3ccc96386", "patch": "@@ -1,5 +1,5 @@\n-Dropping: 5 (should be before 'Continue main 1').\n-Dropping: 15 (should be before 'Continue main 1').\n+Dropping: 8 (should be before 'Continue main 1').\n+Dropping: 8 (should be before 'Continue main 1').\n Continue main 1.\n Joining: 7 (should be before 'Continue main 2').\n Continue main 2."}, {"sha": "e8c6538e701d3bb0feab1ffa46ece63ec1bf355c", "filename": "tests/pass/concurrency/tls_lib_drop_windows.rs", "status": "removed", "additions": 0, "deletions": 191, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/a109994f2271736388bba619c08f794189ebb328/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a109994f2271736388bba619c08f794189ebb328/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop_windows.rs?ref=a109994f2271736388bba619c08f794189ebb328", "patch": "@@ -1,191 +0,0 @@\n-//@only-target-windows: TLS destructor order is different on Windows.\n-\n-use std::cell::RefCell;\n-use std::thread;\n-\n-struct TestCell {\n-    value: RefCell<u8>,\n-}\n-\n-impl Drop for TestCell {\n-    fn drop(&mut self) {\n-        for _ in 0..10 {\n-            thread::yield_now();\n-        }\n-        println!(\"Dropping: {} (should be before 'Continue main 1').\", *self.value.borrow())\n-    }\n-}\n-\n-thread_local! {\n-    static A: TestCell = TestCell { value: RefCell::new(0) };\n-    static A_CONST: TestCell = const { TestCell { value: RefCell::new(10) } };\n-}\n-\n-/// Check that destructors of the library thread locals are executed immediately\n-/// after a thread terminates.\n-fn check_destructors() {\n-    thread::spawn(|| {\n-        A.with(|f| {\n-            assert_eq!(*f.value.borrow(), 0);\n-            *f.value.borrow_mut() = 5;\n-        });\n-        A_CONST.with(|f| {\n-            assert_eq!(*f.value.borrow(), 10);\n-            *f.value.borrow_mut() = 15;\n-        });\n-    })\n-    .join()\n-    .unwrap();\n-    println!(\"Continue main 1.\")\n-}\n-\n-struct JoinCell {\n-    value: RefCell<Option<thread::JoinHandle<u8>>>,\n-}\n-\n-impl Drop for JoinCell {\n-    fn drop(&mut self) {\n-        for _ in 0..10 {\n-            thread::yield_now();\n-        }\n-        let join_handle = self.value.borrow_mut().take().unwrap();\n-        println!(\"Joining: {} (should be before 'Continue main 2').\", join_handle.join().unwrap());\n-    }\n-}\n-\n-thread_local! {\n-    static B: JoinCell = JoinCell { value: RefCell::new(None) };\n-}\n-\n-/// Check that the destructor can be blocked joining another thread.\n-fn check_blocking() {\n-    thread::spawn(|| {\n-        B.with(|f| {\n-            assert!(f.value.borrow().is_none());\n-            let handle = thread::spawn(|| 7);\n-            *f.value.borrow_mut() = Some(handle);\n-        });\n-    })\n-    .join()\n-    .unwrap();\n-    println!(\"Continue main 2.\");\n-    // Preempt the main thread so that the destructor gets executed and can join\n-    // the thread.\n-    thread::yield_now();\n-    thread::yield_now();\n-}\n-\n-// This test tests that TLS destructors have run before the thread joins. The\n-// test has no false positives (meaning: if the test fails, there's actually\n-// an ordering problem). It may have false negatives, where the test passes but\n-// join is not guaranteed to be after the TLS destructors. However, false\n-// negatives should be exceedingly rare due to judicious use of\n-// thread::yield_now and running the test several times.\n-fn join_orders_after_tls_destructors() {\n-    use std::sync::atomic::{AtomicU8, Ordering};\n-\n-    // We emulate a synchronous MPSC rendezvous channel using only atomics and\n-    // thread::yield_now. We can't use std::mpsc as the implementation itself\n-    // may rely on thread locals.\n-    //\n-    // The basic state machine for an SPSC rendezvous channel is:\n-    //           FRESH -> THREAD1_WAITING -> MAIN_THREAD_RENDEZVOUS\n-    // where the first transition is done by the \u201creceiving\u201d thread and the 2nd\n-    // transition is done by the \u201csending\u201d thread.\n-    //\n-    // We add an additional state `THREAD2_LAUNCHED` between `FRESH` and\n-    // `THREAD1_WAITING` to block until all threads are actually running.\n-    //\n-    // A thread that joins on the \u201creceiving\u201d thread completion should never\n-    // observe the channel in the `THREAD1_WAITING` state. If this does occur,\n-    // we switch to the \u201cpoison\u201d state `THREAD2_JOINED` and panic all around.\n-    // (This is equivalent to \u201csending\u201d from an alternate producer thread.)\n-    const FRESH: u8 = 0;\n-    const THREAD2_LAUNCHED: u8 = 1;\n-    const THREAD1_WAITING: u8 = 2;\n-    const MAIN_THREAD_RENDEZVOUS: u8 = 3;\n-    const THREAD2_JOINED: u8 = 4;\n-    static SYNC_STATE: AtomicU8 = AtomicU8::new(FRESH);\n-\n-    for _ in 0..10 {\n-        SYNC_STATE.store(FRESH, Ordering::SeqCst);\n-\n-        let jh = thread::Builder::new()\n-            .name(\"thread1\".into())\n-            .spawn(move || {\n-                struct TlDrop;\n-\n-                impl Drop for TlDrop {\n-                    fn drop(&mut self) {\n-                        let mut sync_state = SYNC_STATE.swap(THREAD1_WAITING, Ordering::SeqCst);\n-                        loop {\n-                            match sync_state {\n-                                THREAD2_LAUNCHED | THREAD1_WAITING => thread::yield_now(),\n-                                MAIN_THREAD_RENDEZVOUS => break,\n-                                THREAD2_JOINED =>\n-                                    panic!(\n-                                        \"Thread 1 still running after thread 2 joined on thread 1\"\n-                                    ),\n-                                v => unreachable!(\"sync state: {}\", v),\n-                            }\n-                            sync_state = SYNC_STATE.load(Ordering::SeqCst);\n-                        }\n-                    }\n-                }\n-\n-                thread_local! {\n-                    static TL_DROP: TlDrop = TlDrop;\n-                }\n-\n-                TL_DROP.with(|_| {});\n-\n-                loop {\n-                    match SYNC_STATE.load(Ordering::SeqCst) {\n-                        FRESH => thread::yield_now(),\n-                        THREAD2_LAUNCHED => break,\n-                        v => unreachable!(\"sync state: {}\", v),\n-                    }\n-                }\n-            })\n-            .unwrap();\n-\n-        let jh2 = thread::Builder::new()\n-            .name(\"thread2\".into())\n-            .spawn(move || {\n-                assert_eq!(SYNC_STATE.swap(THREAD2_LAUNCHED, Ordering::SeqCst), FRESH);\n-                jh.join().unwrap();\n-                match SYNC_STATE.swap(THREAD2_JOINED, Ordering::SeqCst) {\n-                    MAIN_THREAD_RENDEZVOUS => return,\n-                    THREAD2_LAUNCHED | THREAD1_WAITING => {\n-                        panic!(\"Thread 2 running after thread 1 join before main thread rendezvous\")\n-                    }\n-                    v => unreachable!(\"sync state: {:?}\", v),\n-                }\n-            })\n-            .unwrap();\n-\n-        loop {\n-            match SYNC_STATE.compare_exchange(\n-                THREAD1_WAITING,\n-                MAIN_THREAD_RENDEZVOUS,\n-                Ordering::SeqCst,\n-                Ordering::SeqCst,\n-            ) {\n-                Ok(_) => break,\n-                Err(FRESH) => thread::yield_now(),\n-                Err(THREAD2_LAUNCHED) => thread::yield_now(),\n-                Err(THREAD2_JOINED) => {\n-                    panic!(\"Main thread rendezvous after thread 2 joined thread 1\")\n-                }\n-                v => unreachable!(\"sync state: {:?}\", v),\n-            }\n-        }\n-        jh2.join().unwrap();\n-    }\n-}\n-\n-fn main() {\n-    check_destructors();\n-    check_blocking();\n-    join_orders_after_tls_destructors();\n-}"}, {"sha": "e5b8efcaf5fac8efe605d242be67dbd4d27995d9", "filename": "tests/pass/concurrency/tls_lib_drop_windows.stdout", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a109994f2271736388bba619c08f794189ebb328/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop_windows.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/a109994f2271736388bba619c08f794189ebb328/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop_windows.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop_windows.stdout?ref=a109994f2271736388bba619c08f794189ebb328", "patch": "@@ -1,5 +0,0 @@\n-Dropping: 15 (should be before 'Continue main 1').\n-Dropping: 5 (should be before 'Continue main 1').\n-Continue main 1.\n-Joining: 7 (should be before 'Continue main 2').\n-Continue main 2."}, {"sha": "6516396ac54047e2fc521e5bd6c1169c356a8a20", "filename": "tests/pass/concurrency/tls_pthread_drop_order.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e0f0e1fce7464fa619bdcd3c7f684cd3ccc96386/tests%2Fpass%2Fconcurrency%2Ftls_pthread_drop_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f0e1fce7464fa619bdcd3c7f684cd3ccc96386/tests%2Fpass%2Fconcurrency%2Ftls_pthread_drop_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Ftls_pthread_drop_order.rs?ref=e0f0e1fce7464fa619bdcd3c7f684cd3ccc96386", "patch": "@@ -1,4 +1,9 @@\n //@ignore-target-windows: No libc on Windows\n+//! Test that pthread_key destructors are run in the right order.\n+//! Note that these are *not* used by actual `thread_local!` on Linux! Those use\n+//! `thread_local_dtor::register_dtor` from the stdlib instead. In Miri this hits the fallback path\n+//! in `register_dtor_fallback`, which uses a *single* pthread_key to manage a thread-local list of\n+//! dtors to call.\n \n use std::mem;\n use std::ptr;\n@@ -44,6 +49,8 @@ unsafe extern \"C\" fn dtor(ptr: *mut u64) {\n     // If the record is wrong, the cannary will never get cleared, leading to a leak -> test fails.\n     // If the record is incomplete (i.e., more dtor calls happen), the check at the beginning of this function will fail -> test fails.\n     // The correct sequence is: First key 0, then key 1, then key 0.\n+    // Note that this relies on dtor order, which is not specified by POSIX, but seems to be\n+    // consistent between Miri and Linux currently (as of Aug 2022).\n     if RECORD == 0_1_0 {\n         drop(Box::from_raw(CANNARY));\n         CANNARY = ptr::null_mut();"}]}