{"sha": "c2d8a4df35a0a22d64d7d15ccd5fe25a495a2bc1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyZDhhNGRmMzVhMGEyMmQ2NGQ3ZDE1Y2NkNWZlMjVhNDk1YTJiYzE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-17T23:50:49Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-18T20:09:49Z"}, "message": "Continue transition to an ivec-only main\n\nOnly generate a single main function. Rename rust_start_ivec to rust_start,\nleaving a transitional rust_start_ivec in place.", "tree": {"sha": "efb0e83b03126a0fadd2b2d240e3217a860fcc92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efb0e83b03126a0fadd2b2d240e3217a860fcc92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2d8a4df35a0a22d64d7d15ccd5fe25a495a2bc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2d8a4df35a0a22d64d7d15ccd5fe25a495a2bc1", "html_url": "https://github.com/rust-lang/rust/commit/c2d8a4df35a0a22d64d7d15ccd5fe25a495a2bc1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2d8a4df35a0a22d64d7d15ccd5fe25a495a2bc1/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53eb4a30255fc6b3d6be700c10eb7248b0bad3a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/53eb4a30255fc6b3d6be700c10eb7248b0bad3a9", "html_url": "https://github.com/rust-lang/rust/commit/53eb4a30255fc6b3d6be700c10eb7248b0bad3a9"}], "stats": {"total": 164, "additions": 41, "deletions": 123}, "files": [{"sha": "6cfdf80a0f940760e02f782b1e12fa5642ac08d4", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 19, "deletions": 75, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/c2d8a4df35a0a22d64d7d15ccd5fe25a495a2bc1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d8a4df35a0a22d64d7d15ccd5fe25a495a2bc1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=c2d8a4df35a0a22d64d7d15ccd5fe25a495a2bc1", "patch": "@@ -6385,84 +6385,20 @@ fn create_main_wrapper(ccx: &@crate_ctxt, sp: &span,\n         ccx.sess.span_fatal(sp, \"multiple 'main' functions\");\n     }\n \n-    tag main_mode {\n-        mm_nil;\n-        mm_vec;\n-        mm_ivec;\n-    };\n-\n-    let main_mode = alt ty::struct(ccx.tcx, main_node_type) {\n+    let main_takes_ivec = alt ty::struct(ccx.tcx, main_node_type) {\n       ty::ty_fn(_, args, _ ,_ ,_) {\n-        if std::vec::len(args) == 0u {\n-            mm_nil\n-        } else {\n-            alt ty::struct(ccx.tcx, args.(0).ty) {\n-              ty::ty_ivec(_) { mm_ivec }\n-              ty::ty_vec(_) { mm_vec }\n-            }\n-        }\n+        std::vec::len(args) != 0u\n       }\n     };\n \n-    // Have to create two different main functions depending on whether\n-    // main was declared to take vec or ivec\n-    let llfn_vec = create_main_wrapper_vec(ccx, sp, main_llfn, main_mode);\n-    let llfn_ivec = create_main_wrapper_ivec(ccx, sp, main_llfn, main_mode);\n-    let takes_ivec = main_mode == mm_ivec;\n-    // Create a global to tell main.ll which main we want to use\n-    create_main_type_indicator(ccx, takes_ivec);\n-    ccx.main_fn = takes_ivec ? some(llfn_ivec) : some(llfn_vec);\n-\n-    fn create_main_wrapper_vec(ccx: &@crate_ctxt,\n-                               sp: &span,\n-                               main_llfn: ValueRef,\n-                               main_mode: main_mode) -> ValueRef {\n-\n-        let vecarg = {\n-            mode: ty::mo_val,\n-            ty: ty::mk_vec(ccx.tcx, {\n-                ty: ty::mk_str(ccx.tcx),\n-                mut: ast::imm\n-            })\n-        };\n-        let llfty = type_of_fn(ccx, sp,\n-                               ast::proto_fn,\n-                               ~[vecarg],\n-                               ty::mk_nil(ccx.tcx),\n-                               0u);\n-        let llfdecl = decl_fastcall_fn(ccx.llmod, \"_rust_main\", llfty);\n-\n-        let fcx = new_fn_ctxt(new_local_ctxt(ccx), sp, llfdecl);\n-        let bcx = new_top_block_ctxt(fcx);\n-\n-        if main_mode != mm_ivec {\n-            let lloutputarg = llvm::LLVMGetParam(llfdecl, 0u);\n-            let lltaskarg = llvm::LLVMGetParam(llfdecl, 1u);\n-            let llenvarg = llvm::LLVMGetParam(llfdecl, 2u);\n-            let llargvarg = llvm::LLVMGetParam(llfdecl, 3u);\n-            let args = alt main_mode {\n-              mm_nil. { ~[lloutputarg,\n-                          lltaskarg,\n-                          llenvarg] }\n-              mm_vec. { ~[lloutputarg,\n-                          lltaskarg,\n-                          llenvarg,\n-                          llargvarg] }\n-            };\n-            bcx.build.FastCall(main_llfn, args);\n-        }\n-        build_return(bcx);\n-\n-        let lltop = bcx.llbb;\n-        finish_fn(fcx, lltop);\n+    let llfn = create_main(ccx, sp, main_llfn, main_takes_ivec);\n+    create_main_type_indicator(ccx, main_takes_ivec);\n+    ccx.main_fn = some(llfn);\n \n-        ret llfdecl;\n-    }\n-\n-    fn create_main_wrapper_ivec(ccx: &@crate_ctxt,\n-                                sp: &span,\n-                                main_llfn: ValueRef,\n-                                main_mode: main_mode) -> ValueRef {\n+    fn create_main(ccx: &@crate_ctxt,\n+                   sp: &span,\n+                   main_llfn: ValueRef,\n+                   takes_ivec: bool) -> ValueRef {\n         let ivecarg = {\n             mode: ty::mo_val,\n             ty: ty::mk_ivec(ccx.tcx, {\n@@ -6475,12 +6411,12 @@ fn create_main_wrapper(ccx: &@crate_ctxt, sp: &span,\n                                ~[ivecarg],\n                                ty::mk_nil(ccx.tcx),\n                                0u);\n-        let llfdecl = decl_fastcall_fn(ccx.llmod, \"_rust_main_ivec\", llfty);\n+        let llfdecl = decl_fastcall_fn(ccx.llmod, \"_rust_main\", llfty);\n \n         let fcx = new_fn_ctxt(new_local_ctxt(ccx), sp, llfdecl);\n         let bcx = new_top_block_ctxt(fcx);\n \n-        if main_mode == mm_ivec {\n+        if takes_ivec {\n             let lloutputarg = llvm::LLVMGetParam(llfdecl, 0u);\n             let lltaskarg = llvm::LLVMGetParam(llfdecl, 1u);\n             let llenvarg = llvm::LLVMGetParam(llfdecl, 2u);\n@@ -6490,6 +6426,14 @@ fn create_main_wrapper(ccx: &@crate_ctxt, sp: &span,\n                          llenvarg,\n                          llargvarg];\n             bcx.build.FastCall(main_llfn, args);\n+        } else {\n+            let lloutputarg = llvm::LLVMGetParam(llfdecl, 0u);\n+            let lltaskarg = llvm::LLVMGetParam(llfdecl, 1u);\n+            let llenvarg = llvm::LLVMGetParam(llfdecl, 2u);\n+            let args = ~[lloutputarg,\n+                         lltaskarg,\n+                         llenvarg];\n+            bcx.build.FastCall(main_llfn, args);\n         }\n         build_return(bcx);\n "}, {"sha": "c13e167d3c6ebf05c6603c4e6a0852aaefef0826", "filename": "src/rt/main.ll.in", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c2d8a4df35a0a22d64d7d15ccd5fe25a495a2bc1/src%2Frt%2Fmain.ll.in", "raw_url": "https://github.com/rust-lang/rust/raw/c2d8a4df35a0a22d64d7d15ccd5fe25a495a2bc1/src%2Frt%2Fmain.ll.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmain.ll.in?ref=c2d8a4df35a0a22d64d7d15ccd5fe25a495a2bc1", "patch": "@@ -17,37 +17,20 @@\n ; FIXME: Remove after main takes only ivec\n @_rust_main_is_ivec = external global i32\n \n-declare i32 @rust_start(i32, i32, i32, i32)\n+declare i32 @rust_start(i32, i32, i32, i32, i32)\n \n-declare external fastcc void @_rust_main(i1* nocapture, %task*, %2* nocapture, %5*);\n+declare external fastcc void @_rust_main(i1* nocapture, %task*, %2* nocapture, %ivec)\n \n-define void @_rust_main_wrap(i1* nocapture, %task *, %2* nocapture, %5 *)\n-{\n-  tail call fastcc void @_rust_main(i1* %0, %task *%1, %2* nocapture %2, %5 *%3)\n-  ret void\n-}\n-\n-declare i32 @rust_start_ivec(i32, i32, i32, i32, i32)\n-\n-declare external fastcc void @_rust_main_ivec(i1* nocapture, %task*, %2* nocapture, %ivec)\n-\n-define void @_rust_main_wrap_ivec(i1* nocapture, %task *, %2* nocapture, %ivec *)\n+define void @_rust_main_wrap(i1* nocapture, %task *, %2* nocapture, %ivec *)\n {\n   %ivec = load %ivec *%3\n-  tail call fastcc void @_rust_main_ivec(i1* %0, %task *%1, %2* nocapture %2, %ivec %ivec)\n+  tail call fastcc void @_rust_main(i1* %0, %task *%1, %2* nocapture %2, %ivec %ivec)\n   ret void\n }\n \n define i32 @\"MAIN\"(i32, i32) {\n   %is_ivec = load i32 *@_rust_main_is_ivec\n-  %is_ivec1 = trunc i32 %is_ivec to i1\n-  br i1 %is_ivec1, label %ivec, label %evec\n \n-evec:\n-  %3 = tail call i32 @rust_start(i32 ptrtoint (void (i1*, %task*, %2*, %5*)* @_rust_main_wrap to i32), i32 %0, i32 %1, i32 ptrtoint (%0* @_rust_crate_map_toplevel to i32))\n+  %3 = tail call i32 @rust_start(i32 ptrtoint (void (i1*, %task*, %2*, %ivec*)* @_rust_main_wrap to i32), i32 %0, i32 %1, i32 ptrtoint (%0* @_rust_crate_map_toplevel to i32), i32 %is_ivec)\n   ret i32 %3\n-\n-ivec:\n-  %4 = tail call i32 @rust_start_ivec(i32 ptrtoint (void (i1*, %task*, %2*, %ivec*)* @_rust_main_wrap_ivec to i32), i32 %0, i32 %1, i32 ptrtoint (%0* @_rust_crate_map_toplevel to i32), i32 %is_ivec)\n-  ret i32 %4\n }"}, {"sha": "908d3dca80b9f93a06c21d574519a7236bdf2e14", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c2d8a4df35a0a22d64d7d15ccd5fe25a495a2bc1/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/c2d8a4df35a0a22d64d7d15ccd5fe25a495a2bc1/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=c2d8a4df35a0a22d64d7d15ccd5fe25a495a2bc1", "patch": "@@ -59,31 +59,27 @@ command_line_args : public kernel_owned<command_line_args>\n         // array here to ensure it survives to program-shutdown.\n         args->ref();\n \n+        size_t ivec_interior_sz =\n+            sizeof(size_t) * 2 + sizeof(rust_str *) * 4;\n+        args_ivec = (rust_ivec *)\n+            kernel->malloc(ivec_interior_sz,\n+                           \"command line arg interior\");\n+        args_ivec->fill = 0;\n+        size_t ivec_exterior_sz = sizeof(rust_str *) * argc;\n+        args_ivec->alloc = ivec_exterior_sz;\n         if (main_is_ivec) {\n-            size_t ivec_interior_sz =\n-                sizeof(size_t) * 2 + sizeof(rust_str *) * 4;\n-            args_ivec = (rust_ivec *)\n-                kernel->malloc(ivec_interior_sz,\n-                               \"command line arg interior\");\n-            args_ivec->fill = 0;\n-            size_t ivec_exterior_sz = sizeof(rust_str *) * argc;\n-            args_ivec->alloc = ivec_exterior_sz;\n             // NB: This is freed by some ivec machinery, probably the drop\n             // glue in main, so we don't free it ourselves\n             args_ivec->payload.ptr = (rust_ivec_heap *)\n                 kernel->malloc(ivec_exterior_sz + sizeof(size_t),\n                                \"command line arg exterior\");\n             args_ivec->payload.ptr->fill = ivec_exterior_sz;\n             memcpy(&args_ivec->payload.ptr->data, strs, ivec_exterior_sz);\n-        } else {\n-            args_ivec = NULL;\n         }\n     }\n \n     ~command_line_args() {\n-        if (args_ivec) {\n-            kernel->free(args_ivec);\n-        }\n+        kernel->free(args_ivec);\n         if (args) {\n             // Drop the args we've had pinned here.\n             rust_str **strs = (rust_str**) &args->data[0];\n@@ -110,8 +106,8 @@ command_line_args : public kernel_owned<command_line_args>\n int check_claims = 0;\n \n extern \"C\" CDECL int\n-rust_start_ivec(uintptr_t main_fn, int argc, char **argv,\n-                void* crate_map, int main_is_ivec) {\n+rust_start(uintptr_t main_fn, int argc, char **argv,\n+           void* crate_map, int main_takes_ivec) {\n \n     rust_env *env = load_env();\n \n@@ -126,21 +122,15 @@ rust_start_ivec(uintptr_t main_fn, int argc, char **argv,\n     rust_scheduler *sched = root_task->sched;\n     command_line_args *args\n         = new (kernel, \"main command line args\")\n-        command_line_args(root_task, argc, argv, main_is_ivec);\n+        command_line_args(root_task, argc, argv, main_takes_ivec);\n \n     DLOG(sched, dom, \"startup: %d args in 0x%\" PRIxPTR,\n              args->argc, (uintptr_t)args->args);\n     for (int i = 0; i < args->argc; i++) {\n         DLOG(sched, dom, \"startup: arg[%d] = '%s'\", i, args->argv[i]);\n     }\n \n-    if (main_is_ivec) {\n-        DLOG(sched, dom, \"main takes ivec\");\n-        root_task->start(main_fn, (uintptr_t)args->args_ivec);\n-    } else {\n-        DLOG(sched, dom, \"main takes vec\");\n-        root_task->start(main_fn, (uintptr_t)args->args);\n-    }\n+    root_task->start(main_fn, (uintptr_t)args->args_ivec);\n     root_task->deref();\n     root_task = NULL;\n \n@@ -160,10 +150,11 @@ rust_start_ivec(uintptr_t main_fn, int argc, char **argv,\n     return ret;\n }\n \n+// FIXME: Transitional. Please remove.\n extern \"C\" CDECL int\n-rust_start(uintptr_t main_fn, int argc, char **argv,\n-           void* crate_map) {\n-    return rust_start_ivec(main_fn, argc, argv, crate_map, 0);\n+rust_start_ivec(uintptr_t main_fn, int argc, char **argv,\n+                void* crate_map, int main_takes_ivec) {\n+    return rust_start(main_fn, argc, argv, crate_map, main_takes_ivec);\n }\n \n "}]}