{"sha": "62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda", "node_id": "C_kwDOAAsO6NoAKDYyYjI3MmQyNWM1YmI4YjZiYjhhYzczNzk3ZDgyYjhiOWExZWFiZGE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-21T19:43:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-21T19:43:21Z"}, "message": "Auto merge of #99501 - lcnr:check-regions-infcx, r=oli-obk\n\nmove `considering_regions` to the infcx\n\nit seems weird to prove some obligations which constrain inference vars while ignoring regions  in a context which considers regions. This is especially weird because even for a fulfillment context with ignored regions, we still added region outlives bounds when directly relating regions.\n\ntbh our handling of regions is still very weird, but at least this is a step in the right direction imo.\n\nr? rust-lang/types", "tree": {"sha": "6b2810a6c553461f1e65eab6fb007e0fd533e94e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b2810a6c553461f1e65eab6fb007e0fd533e94e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda", "html_url": "https://github.com/rust-lang/rust/commit/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af7ab3447079fddc51c6c7749b160d24769f7c16", "url": "https://api.github.com/repos/rust-lang/rust/commits/af7ab3447079fddc51c6c7749b160d24769f7c16", "html_url": "https://github.com/rust-lang/rust/commit/af7ab3447079fddc51c6c7749b160d24769f7c16"}, {"sha": "43ccacf89b704f74e3ff61ba015c0dddcedfe068", "url": "https://api.github.com/repos/rust-lang/rust/commits/43ccacf89b704f74e3ff61ba015c0dddcedfe068", "html_url": "https://github.com/rust-lang/rust/commit/43ccacf89b704f74e3ff61ba015c0dddcedfe068"}], "stats": {"total": 204, "additions": 82, "deletions": 122}, "files": [{"sha": "854625579ee7be4e01225aebf1f15ba5debf04a7", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda", "patch": "@@ -559,7 +559,7 @@ E0790: include_str!(\"./error_codes/E0790.md\"),\n //  E0273, // on_unimplemented #1\n //  E0274, // on_unimplemented #2\n //  E0278, // requirement is not satisfied\n-    E0279, // requirement is not satisfied\n+//  E0279,\n     E0280, // requirement is not satisfied\n //  E0285, // overflow evaluation builtin bounds\n //  E0296, // replaced with a generic attribute input check"}, {"sha": "130214a653f7c1c84cc846415fb583df800b58bf", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda", "patch": "@@ -65,6 +65,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         Self {\n             tcx: self.tcx,\n             defining_use_anchor: self.defining_use_anchor,\n+            considering_regions: self.considering_regions,\n             in_progress_typeck_results: self.in_progress_typeck_results,\n             inner: self.inner.clone(),\n             skip_leak_check: self.skip_leak_check.clone(),"}, {"sha": "85692e109be4a32d0b1cb5bb3f9eb70cd7952964", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda", "patch": "@@ -265,6 +265,11 @@ pub struct InferCtxt<'a, 'tcx> {\n     /// might come up during inference or typeck.\n     pub defining_use_anchor: DefiningAnchor,\n \n+    /// Whether this inference context should care about region obligations in\n+    /// the root universe. Most notably, this is used during hir typeck as region\n+    /// solving is left to borrowck instead.\n+    pub considering_regions: bool,\n+\n     /// During type-checking/inference of a body, `in_progress_typeck_results`\n     /// contains a reference to the typeck results being built up, which are\n     /// used for reading closure kinds/signatures as they are inferred,\n@@ -539,8 +544,9 @@ impl<'tcx> fmt::Display for FixupError<'tcx> {\n /// without using `Rc` or something similar.\n pub struct InferCtxtBuilder<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    fresh_typeck_results: Option<RefCell<ty::TypeckResults<'tcx>>>,\n     defining_use_anchor: DefiningAnchor,\n+    considering_regions: bool,\n+    fresh_typeck_results: Option<RefCell<ty::TypeckResults<'tcx>>>,\n }\n \n pub trait TyCtxtInferExt<'tcx> {\n@@ -552,6 +558,7 @@ impl<'tcx> TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {\n         InferCtxtBuilder {\n             tcx: self,\n             defining_use_anchor: DefiningAnchor::Error,\n+            considering_regions: true,\n             fresh_typeck_results: None,\n         }\n     }\n@@ -577,6 +584,11 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n         self\n     }\n \n+    pub fn ignoring_regions(mut self) -> Self {\n+        self.considering_regions = false;\n+        self\n+    }\n+\n     /// Given a canonical value `C` as a starting point, create an\n     /// inference context that contains each of the bound values\n     /// within instantiated as a fresh variable. The `f` closure is\n@@ -601,11 +613,17 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n     }\n \n     pub fn enter<R>(&mut self, f: impl for<'a> FnOnce(InferCtxt<'a, 'tcx>) -> R) -> R {\n-        let InferCtxtBuilder { tcx, defining_use_anchor, ref fresh_typeck_results } = *self;\n+        let InferCtxtBuilder {\n+            tcx,\n+            defining_use_anchor,\n+            considering_regions,\n+            ref fresh_typeck_results,\n+        } = *self;\n         let in_progress_typeck_results = fresh_typeck_results.as_ref();\n         f(InferCtxt {\n             tcx,\n             defining_use_anchor,\n+            considering_regions,\n             in_progress_typeck_results,\n             inner: RefCell::new(InferCtxtInner::new()),\n             lexical_region_resolutions: RefCell::new(None),\n@@ -1043,16 +1061,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         cause: &traits::ObligationCause<'tcx>,\n         predicate: ty::PolyRegionOutlivesPredicate<'tcx>,\n-    ) -> UnitResult<'tcx> {\n-        self.commit_if_ok(|_snapshot| {\n-            let ty::OutlivesPredicate(r_a, r_b) =\n-                self.replace_bound_vars_with_placeholders(predicate);\n-            let origin = SubregionOrigin::from_obligation_cause(cause, || {\n-                RelateRegionParamBound(cause.span)\n-            });\n-            self.sub_regions(origin, r_b, r_a); // `b : a` ==> `a <= b`\n-            Ok(())\n-        })\n+    ) {\n+        let ty::OutlivesPredicate(r_a, r_b) = self.replace_bound_vars_with_placeholders(predicate);\n+        let origin =\n+            SubregionOrigin::from_obligation_cause(cause, || RelateRegionParamBound(cause.span));\n+        self.sub_regions(origin, r_b, r_a); // `b : a` ==> `a <= b`\n     }\n \n     /// Number of type variables created so far."}, {"sha": "5763e6d1b559ed78de22923792b0ba4f16629cbd", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda", "patch": "@@ -793,9 +793,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                 }\n                 ty::PredicateKind::RegionOutlives(binder) => {\n                     let binder = bound_predicate.rebind(binder);\n-                    if select.infcx().region_outlives_predicate(&dummy_cause, binder).is_err() {\n-                        return false;\n-                    }\n+                    select.infcx().region_outlives_predicate(&dummy_cause, binder)\n                 }\n                 ty::PredicateKind::TypeOutlives(binder) => {\n                     let binder = bound_predicate.rebind(binder);"}, {"sha": "5fcaa52d41747ad2124cc701f54b9dec3ccc9646", "filename": "compiler/rustc_trait_selection/src/traits/codegen.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs?ref=62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda", "patch": "@@ -30,7 +30,9 @@ pub fn codegen_fulfill_obligation<'tcx>(\n \n     // Do the initial selection for the obligation. This yields the\n     // shallow result we are looking for -- that is, what specific impl.\n-    tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).enter(|infcx| {\n+    let mut infcx_builder =\n+        tcx.infer_ctxt().ignoring_regions().with_opaque_type_inference(DefiningAnchor::Bubble);\n+    infcx_builder.enter(|infcx| {\n         //~^ HACK `Bubble` is required for\n         // this test to pass: type-alias-impl-trait/assoc-projection-ice.rs\n         let mut selcx = SelectionContext::new(&infcx);"}, {"sha": "6c177f6388704a943548eb824a97e5df6ab2b46d", "filename": "compiler/rustc_trait_selection/src/traits/engine.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs?ref=62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda", "patch": "@@ -15,8 +15,6 @@ use rustc_middle::ty::{self, Ty, TyCtxt};\n \n pub trait TraitEngineExt<'tcx> {\n     fn new(tcx: TyCtxt<'tcx>) -> Box<Self>;\n-\n-    fn new_ignoring_regions(tcx: TyCtxt<'tcx>) -> Box<Self>;\n }\n \n impl<'tcx> TraitEngineExt<'tcx> for dyn TraitEngine<'tcx> {\n@@ -27,14 +25,6 @@ impl<'tcx> TraitEngineExt<'tcx> for dyn TraitEngine<'tcx> {\n             Box::new(FulfillmentContext::new())\n         }\n     }\n-\n-    fn new_ignoring_regions(tcx: TyCtxt<'tcx>) -> Box<Self> {\n-        if tcx.sess.opts.unstable_opts.chalk {\n-            Box::new(ChalkFulfillmentContext::new())\n-        } else {\n-            Box::new(FulfillmentContext::new_ignoring_regions())\n-        }\n-    }\n }\n \n /// Used if you want to have pleasant experience when dealing"}, {"sha": "eb2c3c9601943c6e73f3e51d05fe8a7e0c6c8550", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda", "patch": "@@ -789,24 +789,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         span_bug!(span, \"coerce requirement gave wrong error: `{:?}`\", predicate)\n                     }\n \n-                    ty::PredicateKind::RegionOutlives(predicate) => {\n-                        let predicate = bound_predicate.rebind(predicate);\n-                        let predicate = self.resolve_vars_if_possible(predicate);\n-                        let err = self\n-                            .region_outlives_predicate(&obligation.cause, predicate)\n-                            .err()\n-                            .unwrap();\n-                        struct_span_err!(\n-                            self.tcx.sess,\n-                            span,\n-                            E0279,\n-                            \"the requirement `{}` is not satisfied (`{}`)\",\n-                            predicate,\n-                            err,\n-                        )\n-                    }\n-\n-                    ty::PredicateKind::Projection(..) | ty::PredicateKind::TypeOutlives(..) => {\n+                    ty::PredicateKind::RegionOutlives(..)\n+                    | ty::PredicateKind::Projection(..)\n+                    | ty::PredicateKind::TypeOutlives(..) => {\n                         let predicate = self.resolve_vars_if_possible(obligation.predicate);\n                         struct_span_err!(\n                             self.tcx.sess,"}, {"sha": "556ef466cd11aad35bfb521bcb48e57026c92773", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 8, "deletions": 38, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda", "patch": "@@ -58,19 +58,6 @@ pub struct FulfillmentContext<'tcx> {\n \n     relationships: FxHashMap<ty::TyVid, ty::FoundRelationships>,\n \n-    // Should this fulfillment context register type-lives-for-region\n-    // obligations on its parent infcx? In some cases, region\n-    // obligations are either already known to hold (normalization) or\n-    // hopefully verified elsewhere (type-impls-bound), and therefore\n-    // should not be checked.\n-    //\n-    // Note that if we are normalizing a type that we already\n-    // know is well-formed, there should be no harm setting this\n-    // to true - all the region variables should be determinable\n-    // using the RFC 447 rules, which don't depend on\n-    // type-lives-for-region constraints, and because the type\n-    // is well-formed, the constraints should hold.\n-    register_region_obligations: bool,\n     // Is it OK to register obligations into this infcx inside\n     // an infcx snapshot?\n     //\n@@ -103,7 +90,6 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n             relationships: FxHashMap::default(),\n-            register_region_obligations: true,\n             usable_in_snapshot: false,\n         }\n     }\n@@ -112,30 +98,18 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n             relationships: FxHashMap::default(),\n-            register_region_obligations: true,\n             usable_in_snapshot: true,\n         }\n     }\n \n-    pub fn new_ignoring_regions() -> FulfillmentContext<'tcx> {\n-        FulfillmentContext {\n-            predicates: ObligationForest::new(),\n-            relationships: FxHashMap::default(),\n-            register_region_obligations: false,\n-            usable_in_snapshot: false,\n-        }\n-    }\n-\n     /// Attempts to select obligations using `selcx`.\n     fn select(&mut self, selcx: &mut SelectionContext<'a, 'tcx>) -> Vec<FulfillmentError<'tcx>> {\n         let span = debug_span!(\"select\", obligation_forest_size = ?self.predicates.len());\n         let _enter = span.enter();\n \n         // Process pending obligations.\n-        let outcome: Outcome<_, _> = self.predicates.process_obligations(&mut FulfillProcessor {\n-            selcx,\n-            register_region_obligations: self.register_region_obligations,\n-        });\n+        let outcome: Outcome<_, _> =\n+            self.predicates.process_obligations(&mut FulfillProcessor { selcx });\n \n         // FIXME: if we kept the original cache key, we could mark projection\n         // obligations as complete for the projection cache here.\n@@ -239,7 +213,6 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n \n struct FulfillProcessor<'a, 'b, 'tcx> {\n     selcx: &'a mut SelectionContext<'b, 'tcx>,\n-    register_region_obligations: bool,\n }\n \n fn mk_pending(os: Vec<PredicateObligation<'_>>) -> Vec<PendingPredicateObligation<'_>> {\n@@ -385,19 +358,16 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n \n                 ty::PredicateKind::RegionOutlives(data) => {\n-                    match infcx.region_outlives_predicate(&obligation.cause, Binder::dummy(data)) {\n-                        Ok(()) => ProcessResult::Changed(vec![]),\n-                        Err(_) => ProcessResult::Error(CodeSelectionError(Unimplemented)),\n+                    if infcx.considering_regions || data.has_placeholders() {\n+                        infcx.region_outlives_predicate(&obligation.cause, Binder::dummy(data));\n                     }\n+\n+                    ProcessResult::Changed(vec![])\n                 }\n \n                 ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(t_a, r_b)) => {\n-                    if self.register_region_obligations {\n-                        self.selcx.infcx().register_region_obligation_with_cause(\n-                            t_a,\n-                            r_b,\n-                            &obligation.cause,\n-                        );\n+                    if infcx.considering_regions {\n+                        infcx.register_region_obligation_with_cause(t_a, r_b, &obligation.cause);\n                     }\n                     ProcessResult::Changed(vec![])\n                 }"}, {"sha": "3ef51b0c27abd9e8273509cda48459690cc12cba", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda", "patch": "@@ -163,7 +163,7 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'tcx>(\n         // The handling of regions in this area of the code is terrible,\n         // see issue #29149. We should be able to improve on this with\n         // NLL.\n-        let mut fulfill_cx = FulfillmentContext::new_ignoring_regions();\n+        let mut fulfill_cx = FulfillmentContext::new();\n \n         // We can use a dummy node-id here because we won't pay any mind\n         // to region obligations that arise (there shouldn't really be any\n@@ -207,21 +207,21 @@ fn do_normalize_predicates<'tcx>(\n     predicates: Vec<ty::Predicate<'tcx>>,\n ) -> Result<Vec<ty::Predicate<'tcx>>, ErrorGuaranteed> {\n     let span = cause.span;\n-    tcx.infer_ctxt().enter(|infcx| {\n-        // FIXME. We should really... do something with these region\n-        // obligations. But this call just continues the older\n-        // behavior (i.e., doesn't cause any new bugs), and it would\n-        // take some further refactoring to actually solve them. In\n-        // particular, we would have to handle implied bounds\n-        // properly, and that code is currently largely confined to\n-        // regionck (though I made some efforts to extract it\n-        // out). -nmatsakis\n-        //\n-        // @arielby: In any case, these obligations are checked\n-        // by wfcheck anyway, so I'm not sure we have to check\n-        // them here too, and we will remove this function when\n-        // we move over to lazy normalization *anyway*.\n-        let fulfill_cx = FulfillmentContext::new_ignoring_regions();\n+    // FIXME. We should really... do something with these region\n+    // obligations. But this call just continues the older\n+    // behavior (i.e., doesn't cause any new bugs), and it would\n+    // take some further refactoring to actually solve them. In\n+    // particular, we would have to handle implied bounds\n+    // properly, and that code is currently largely confined to\n+    // regionck (though I made some efforts to extract it\n+    // out). -nmatsakis\n+    //\n+    // @arielby: In any case, these obligations are checked\n+    // by wfcheck anyway, so I'm not sure we have to check\n+    // them here too, and we will remove this function when\n+    // we move over to lazy normalization *anyway*.\n+    tcx.infer_ctxt().ignoring_regions().enter(|infcx| {\n+        let fulfill_cx = FulfillmentContext::new();\n         let predicates =\n             match fully_normalize(&infcx, fulfill_cx, cause, elaborated_env, predicates) {\n                 Ok(predicates) => predicates,"}, {"sha": "5f77aae6f221fd4ee74007a960164a5e4c060f5e", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda", "patch": "@@ -207,18 +207,7 @@ fn fulfill_implication<'a, 'tcx>(\n     // (which are packed up in penv)\n \n     infcx.save_and_restore_in_snapshot_flag(|infcx| {\n-        // If we came from `translate_substs`, we already know that the\n-        // predicates for our impl hold (after all, we know that a more\n-        // specialized impl holds, so our impl must hold too), and\n-        // we only want to process the projections to determine the\n-        // the types in our substs using RFC 447, so we can safely\n-        // ignore region obligations, which allows us to avoid threading\n-        // a node-id to assign them with.\n-        //\n-        // If we came from specialization graph construction, then\n-        // we already make a mockery out of the region system, so\n-        // why not ignore them a bit earlier?\n-        let mut fulfill_cx = FulfillmentContext::new_ignoring_regions();\n+        let mut fulfill_cx = FulfillmentContext::new();\n         for oblig in obligations.chain(more_obligations) {\n             fulfill_cx.register_predicate_obligation(&infcx, oblig);\n         }"}, {"sha": "2f841fc277ded364f3d9b4203ea3f17099d65ae6", "filename": "compiler/rustc_typeck/src/check/inherited.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs?ref=62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda", "patch": "@@ -86,7 +86,10 @@ impl<'tcx> Inherited<'_, 'tcx> {\n         let hir_owner = tcx.hir().local_def_id_to_hir_id(def_id).owner;\n \n         InheritedBuilder {\n-            infcx: tcx.infer_ctxt().with_fresh_in_progress_typeck_results(hir_owner),\n+            infcx: tcx\n+                .infer_ctxt()\n+                .ignoring_regions()\n+                .with_fresh_in_progress_typeck_results(hir_owner),\n             def_id,\n         }\n     }\n@@ -113,7 +116,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n                 maybe_typeck_results: infcx.in_progress_typeck_results,\n             },\n             infcx,\n-            fulfillment_cx: RefCell::new(<dyn TraitEngine<'_>>::new_ignoring_regions(tcx)),\n+            fulfillment_cx: RefCell::new(<dyn TraitEngine<'_>>::new(tcx)),\n             locals: RefCell::new(Default::default()),\n             deferred_sized_obligations: RefCell::new(Vec::new()),\n             deferred_call_resolutions: RefCell::new(Default::default()),"}, {"sha": "b088fc9eddb85a14a3e84ef89fdc80824e2f1b0c", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda", "patch": "@@ -87,10 +87,10 @@ mod op;\n mod pat;\n mod place_op;\n mod region;\n-mod regionck;\n+pub mod regionck;\n pub mod rvalue_scopes;\n mod upvar;\n-mod wfcheck;\n+pub mod wfcheck;\n pub mod writeback;\n \n use check::{check_abi, check_fn, check_mod_item_types};"}, {"sha": "1b80e4edca91086ea154a26531a00ace1c22abe8", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda", "patch": "@@ -1913,7 +1913,7 @@ impl<'a, 'tcx> WfCheckingCtxt<'a, 'tcx> {\n     }\n }\n \n-pub(super) fn impl_implied_bounds<'tcx>(\n+pub fn impl_implied_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     impl_def_id: LocalDefId,"}, {"sha": "d8e42729ff31d5ac53356b068534d1955a41dc34", "filename": "compiler/rustc_typeck/src/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda", "patch": "@@ -116,8 +116,8 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n                 // why this field does not implement Copy. This is useful because sometimes\n                 // it is not immediately clear why Copy is not implemented for a field, since\n                 // all we point at is the field itself.\n-                tcx.infer_ctxt().enter(|infcx| {\n-                    let mut fulfill_cx = traits::FulfillmentContext::new_ignoring_regions();\n+                tcx.infer_ctxt().ignoring_regions().enter(|infcx| {\n+                    let mut fulfill_cx = traits::FulfillmentContext::new();\n                     fulfill_cx.register_bound(\n                         &infcx,\n                         param_env,"}, {"sha": "f16888345e9d509d35551101ce82dca5c7387b8f", "filename": "compiler/rustc_typeck/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda", "patch": "@@ -65,6 +65,8 @@\n //! cause use after frees with purely safe code in the same way as specializing\n //! on traits with methods can.\n \n+use crate::check::regionck::OutlivesEnvironmentExt;\n+use crate::check::wfcheck::impl_implied_bounds;\n use crate::constrained_generic_params as cgp;\n use crate::errors::SubstsOnOverriddenImpl;\n \n@@ -148,8 +150,15 @@ fn get_impl_substs<'tcx>(\n     let impl2_substs =\n         translate_substs(infcx, param_env, impl1_def_id.to_def_id(), impl1_substs, impl2_node);\n \n-    // Conservatively use an empty `ParamEnv`.\n-    let outlives_env = OutlivesEnvironment::new(ty::ParamEnv::empty());\n+    let mut outlives_env = OutlivesEnvironment::new(param_env);\n+    let implied_bounds =\n+        impl_implied_bounds(infcx.tcx, param_env, impl1_def_id, tcx.def_span(impl1_def_id));\n+    outlives_env.add_implied_bounds(\n+        infcx,\n+        implied_bounds,\n+        tcx.hir().local_def_id_to_hir_id(impl1_def_id),\n+    );\n+    infcx.process_registered_region_obligations(outlives_env.region_bound_pairs(), param_env);\n     infcx.resolve_regions_and_report_errors(impl1_def_id, &outlives_env);\n     let Ok(impl2_substs) = infcx.fully_resolve(impl2_substs) else {\n         let span = tcx.def_span(impl1_def_id);"}, {"sha": "f0054a1c1c9bb331541950a0c4221dc7dc076f37", "filename": "src/tools/tidy/src/error_codes_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs?ref=62b272d25c5bb8b6bb8ac73797d82b8b9a1eabda", "patch": "@@ -10,8 +10,8 @@ use regex::Regex;\n \n // A few of those error codes can't be tested but all the others can and *should* be tested!\n const EXEMPTED_FROM_TEST: &[&str] = &[\n-    \"E0279\", \"E0313\", \"E0377\", \"E0461\", \"E0462\", \"E0465\", \"E0476\", \"E0490\", \"E0514\", \"E0519\",\n-    \"E0523\", \"E0554\", \"E0640\", \"E0717\", \"E0729\", \"E0789\",\n+    \"E0313\", \"E0377\", \"E0461\", \"E0462\", \"E0465\", \"E0476\", \"E0490\", \"E0514\", \"E0519\", \"E0523\",\n+    \"E0554\", \"E0640\", \"E0717\", \"E0729\", \"E0789\",\n ];\n \n // Some error codes don't have any tests apparently..."}]}