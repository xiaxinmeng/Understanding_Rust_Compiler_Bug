{"sha": "c35ce3ff170333d11ccf89e75dc87c49f44a570a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzNWNlM2ZmMTcwMzMzZDExY2NmODllNzVkYzg3YzQ5ZjQ0YTU3MGE=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-09-16T17:31:20Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-09-16T17:31:20Z"}, "message": "Don't generate bootstrap usage unless it's needed\n\nPreviously, `x.py` would unconditionally run `x.py build` to get the\nhelp message. After https://github.com/rust-lang/rust/issues/76165,\nwhen checking the CI stage was moved into `Config`, that would cause an\nassertion failure (but only only in CI!):\n\n```\nthread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `2`', src/bootstrap/config.rs:619:49\n```\n\nThis changes bootstrap to only generate a help message when it needs\nto (when someone passes `--help`).", "tree": {"sha": "40bc3e2fad717c4a0db872ca3a7b80cf43651a61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40bc3e2fad717c4a0db872ca3a7b80cf43651a61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c35ce3ff170333d11ccf89e75dc87c49f44a570a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c35ce3ff170333d11ccf89e75dc87c49f44a570a", "html_url": "https://github.com/rust-lang/rust/commit/c35ce3ff170333d11ccf89e75dc87c49f44a570a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c35ce3ff170333d11ccf89e75dc87c49f44a570a/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fae56971d8487088c0099c82c0a5ce1638b5f62", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fae56971d8487088c0099c82c0a5ce1638b5f62", "html_url": "https://github.com/rust-lang/rust/commit/5fae56971d8487088c0099c82c0a5ce1638b5f62"}], "stats": {"total": 62, "additions": 32, "deletions": 30}, "files": [{"sha": "842c84a3e5cd6dcd82220e36c49133be5da00db2", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/c35ce3ff170333d11ccf89e75dc87c49f44a570a/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35ce3ff170333d11ccf89e75dc87c49f44a570a/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=c35ce3ff170333d11ccf89e75dc87c49f44a570a", "patch": "@@ -98,7 +98,6 @@ impl Default for Subcommand {\n \n impl Flags {\n     pub fn parse(args: &[String]) -> Flags {\n-        let mut extra_help = String::new();\n         let mut subcommand_help = String::from(\n             \"\\\n Usage: x.py <subcommand> [options] [<paths>...]\n@@ -170,16 +169,6 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n             \"VALUE\",\n         );\n \n-        // fn usage()\n-        let usage =\n-            |exit_code: i32, opts: &Options, subcommand_help: &str, extra_help: &str| -> ! {\n-                println!(\"{}\", opts.usage(subcommand_help));\n-                if !extra_help.is_empty() {\n-                    println!(\"{}\", extra_help);\n-                }\n-                process::exit(exit_code);\n-            };\n-\n         // We can't use getopt to parse the options until we have completed specifying which\n         // options are valid, but under the current implementation, some options are conditional on\n         // the subcommand. Therefore we must manually identify the subcommand first, so that we can\n@@ -263,12 +252,38 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n             _ => {}\n         };\n \n+        // fn usage()\n+        let usage = |exit_code: i32, opts: &Options, verbose: bool, subcommand_help: &str| -> ! {\n+            let mut extra_help = String::new();\n+\n+            // All subcommands except `clean` can have an optional \"Available paths\" section\n+            if verbose {\n+                let config = Config::parse(&[\"build\".to_string()]);\n+                let build = Build::new(config);\n+\n+                let maybe_rules_help = Builder::get_help(&build, subcommand.as_str());\n+                extra_help.push_str(maybe_rules_help.unwrap_or_default().as_str());\n+            } else if !(subcommand.as_str() == \"clean\" || subcommand.as_str() == \"fmt\") {\n+                extra_help.push_str(\n+                    format!(\"Run `./x.py {} -h -v` to see a list of available paths.\", subcommand)\n+                        .as_str(),\n+                );\n+            }\n+\n+            println!(\"{}\", opts.usage(subcommand_help));\n+            if !extra_help.is_empty() {\n+                println!(\"{}\", extra_help);\n+            }\n+            process::exit(exit_code);\n+        };\n+\n         // Done specifying what options are possible, so do the getopts parsing\n         let matches = opts.parse(&args[..]).unwrap_or_else(|e| {\n             // Invalid argument/option format\n             println!(\"\\n{}\\n\", e);\n-            usage(1, &opts, &subcommand_help, &extra_help);\n+            usage(1, &opts, false, &subcommand_help);\n         });\n+\n         // Extra sanity check to make sure we didn't hit this crazy corner case:\n         //\n         //     ./x.py --frobulate clean build\n@@ -436,24 +451,11 @@ Arguments:\n         let paths = matches.free[1..].iter().map(|p| p.into()).collect::<Vec<PathBuf>>();\n \n         let cfg_file = env::var_os(\"BOOTSTRAP_CONFIG\").map(PathBuf::from);\n-\n-        // All subcommands except `clean` can have an optional \"Available paths\" section\n-        if matches.opt_present(\"verbose\") {\n-            let config = Config::parse(&[\"build\".to_string()]);\n-            let build = Build::new(config);\n-\n-            let maybe_rules_help = Builder::get_help(&build, subcommand.as_str());\n-            extra_help.push_str(maybe_rules_help.unwrap_or_default().as_str());\n-        } else if !(subcommand.as_str() == \"clean\" || subcommand.as_str() == \"fmt\") {\n-            extra_help.push_str(\n-                format!(\"Run `./x.py {} -h -v` to see a list of available paths.\", subcommand)\n-                    .as_str(),\n-            );\n-        }\n+        let verbose = matches.opt_present(\"verbose\");\n \n         // User passed in -h/--help?\n         if matches.opt_present(\"help\") {\n-            usage(0, &opts, &subcommand_help, &extra_help);\n+            usage(0, &opts, verbose, &subcommand_help);\n         }\n \n         let cmd = match subcommand.as_str() {\n@@ -483,7 +485,7 @@ Arguments:\n             \"clean\" => {\n                 if !paths.is_empty() {\n                     println!(\"\\nclean does not take a path argument\\n\");\n-                    usage(1, &opts, &subcommand_help, &extra_help);\n+                    usage(1, &opts, verbose, &subcommand_help);\n                 }\n \n                 Subcommand::Clean { all: matches.opt_present(\"all\") }\n@@ -494,12 +496,12 @@ Arguments:\n             \"run\" | \"r\" => {\n                 if paths.is_empty() {\n                     println!(\"\\nrun requires at least a path!\\n\");\n-                    usage(1, &opts, &subcommand_help, &extra_help);\n+                    usage(1, &opts, verbose, &subcommand_help);\n                 }\n                 Subcommand::Run { paths }\n             }\n             _ => {\n-                usage(1, &opts, &subcommand_help, &extra_help);\n+                usage(1, &opts, verbose, &subcommand_help);\n             }\n         };\n "}]}