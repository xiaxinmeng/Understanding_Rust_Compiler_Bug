{"sha": "41fa24cef89c71430040332b42036f4ec839c4e0", "node_id": "C_kwDOAAsO6NoAKDQxZmEyNGNlZjg5YzcxNDMwMDQwMzMyYjQyMDM2ZjRlYzgzOWM0ZTA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-07T13:35:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-07T13:35:07Z"}, "message": "Auto merge of #10415 - schubart:collection_is_never_read, r=llogiq\n\nAdd `collection_is_never_read`\n\nFixes #9267\n\n`@flip1995` and `@llogiq,` I talked with you about this one at Rust Nation in London last week. :-)\n\nThis is my first contribution to Clippy, so lots of feedback would be greatly appreciated.\n\n- \\[ ] Followed [lint naming conventions][lint_naming]\n- \\[x] Added passing UI tests (including committed `.stderr` file)\n- \\[x] `cargo test` passes locally\n- \\[x] Executed `cargo dev update_lints`\n- \\[x] Added lint documentation\n- \\[x] Run `cargo dev fmt`\n\n`dogfood` found one true positive (see #9509) and no false positives.\n\n`lintcheck` found no (true or false) positives, even when running on an extended set of crates.\n\n---\n\nchangelog: new lint [`collection_is_never_read`]\n[#10415](https://github.com/rust-lang/rust-clippy/pull/10415)\n<!-- changelog_checked -->", "tree": {"sha": "064e949cf2388fa4ebc9f75d9ff3d042aa1bcf0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/064e949cf2388fa4ebc9f75d9ff3d042aa1bcf0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41fa24cef89c71430040332b42036f4ec839c4e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41fa24cef89c71430040332b42036f4ec839c4e0", "html_url": "https://github.com/rust-lang/rust/commit/41fa24cef89c71430040332b42036f4ec839c4e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41fa24cef89c71430040332b42036f4ec839c4e0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "903595801e86c1d6bf8bd8aeeeb9127b04f19036", "url": "https://api.github.com/repos/rust-lang/rust/commits/903595801e86c1d6bf8bd8aeeeb9127b04f19036", "html_url": "https://github.com/rust-lang/rust/commit/903595801e86c1d6bf8bd8aeeeb9127b04f19036"}, {"sha": "4ee65535a708d6493b1a1d6276e6d06f8e156e14", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ee65535a708d6493b1a1d6276e6d06f8e156e14", "html_url": "https://github.com/rust-lang/rust/commit/4ee65535a708d6493b1a1d6276e6d06f8e156e14"}], "stats": {"total": 343, "additions": 343, "deletions": 0}, "files": [{"sha": "9508ab57cb87300028577243ac28dacd97d25dd2", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41fa24cef89c71430040332b42036f4ec839c4e0/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/41fa24cef89c71430040332b42036f4ec839c4e0/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=41fa24cef89c71430040332b42036f4ec839c4e0", "patch": "@@ -4452,6 +4452,7 @@ Released 2018-09-13\n [`collapsible_if`]: https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\n [`collapsible_match`]: https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_match\n [`collapsible_str_replace`]: https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_str_replace\n+[`collection_is_never_read`]: https://rust-lang.github.io/rust-clippy/master/index.html#collection_is_never_read\n [`comparison_chain`]: https://rust-lang.github.io/rust-clippy/master/index.html#comparison_chain\n [`comparison_to_empty`]: https://rust-lang.github.io/rust-clippy/master/index.html#comparison_to_empty\n [`const_static_lifetime`]: https://rust-lang.github.io/rust-clippy/master/index.html#const_static_lifetime"}, {"sha": "10f2bef268a24b2159f887a794dca9669d06a2d2", "filename": "clippy_lints/src/collection_is_never_read.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/41fa24cef89c71430040332b42036f4ec839c4e0/clippy_lints%2Fsrc%2Fcollection_is_never_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41fa24cef89c71430040332b42036f4ec839c4e0/clippy_lints%2Fsrc%2Fcollection_is_never_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollection_is_never_read.rs?ref=41fa24cef89c71430040332b42036f4ec839c4e0", "patch": "@@ -0,0 +1,122 @@\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::visitors::for_each_expr_with_closures;\n+use clippy_utils::{get_enclosing_block, get_parent_node, path_to_local_id};\n+use core::ops::ControlFlow;\n+use rustc_hir::{Block, ExprKind, HirId, Local, Node, PatKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::sym;\n+use rustc_span::Symbol;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for collections that are never queried.\n+    ///\n+    /// ### Why is this bad?\n+    /// Putting effort into constructing a collection but then never querying it might indicate that\n+    /// the author forgot to do whatever they intended to do with the collection. Example: Clone\n+    /// a vector, sort it for iteration, but then mistakenly iterate the original vector\n+    /// instead.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let samples = vec![3, 1, 2];\n+    /// let mut sorted_samples = samples.clone();\n+    /// sorted_samples.sort();\n+    /// for sample in &samples { // Oops, meant to use `sorted_samples`.\n+    ///     println!(\"{sample}\");\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # let samples = vec![3, 1, 2];\n+    /// let mut sorted_samples = samples.clone();\n+    /// sorted_samples.sort();\n+    /// for sample in &sorted_samples {\n+    ///     println!(\"{sample}\");\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.69.0\"]\n+    pub COLLECTION_IS_NEVER_READ,\n+    nursery,\n+    \"a collection is never queried\"\n+}\n+declare_lint_pass!(CollectionIsNeverRead => [COLLECTION_IS_NEVER_READ]);\n+\n+static COLLECTIONS: [Symbol; 10] = [\n+    sym::BTreeMap,\n+    sym::BTreeSet,\n+    sym::BinaryHeap,\n+    sym::HashMap,\n+    sym::HashSet,\n+    sym::LinkedList,\n+    sym::Option,\n+    sym::String,\n+    sym::Vec,\n+    sym::VecDeque,\n+];\n+\n+impl<'tcx> LateLintPass<'tcx> for CollectionIsNeverRead {\n+    fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'tcx>) {\n+        // Look for local variables whose type is a container. Search surrounding bock for read access.\n+        let ty = cx.typeck_results().pat_ty(local.pat);\n+        if COLLECTIONS.iter().any(|&sym| is_type_diagnostic_item(cx, ty, sym))\n+            && let PatKind::Binding(_, local_id, _, _) = local.pat.kind\n+            && let Some(enclosing_block) = get_enclosing_block(cx, local.hir_id)\n+            && has_no_read_access(cx, local_id, enclosing_block)\n+        {\n+            span_lint(cx, COLLECTION_IS_NEVER_READ, local.span, \"collection is never read\");\n+        }\n+    }\n+}\n+\n+fn has_no_read_access<'tcx>(cx: &LateContext<'tcx>, id: HirId, block: &'tcx Block<'tcx>) -> bool {\n+    let mut has_access = false;\n+    let mut has_read_access = false;\n+\n+    // Inspect all expressions and sub-expressions in the block.\n+    for_each_expr_with_closures(cx, block, |expr| {\n+        // Ignore expressions that are not simply `id`.\n+        if !path_to_local_id(expr, id) {\n+            return ControlFlow::Continue(());\n+        }\n+\n+        // `id` is being accessed. Investigate if it's a read access.\n+        has_access = true;\n+\n+        // `id` appearing in the left-hand side of an assignment is not a read access:\n+        //\n+        // id = ...; // Not reading `id`.\n+        if let Some(Node::Expr(parent)) = get_parent_node(cx.tcx, expr.hir_id)\n+            && let ExprKind::Assign(lhs, ..) = parent.kind\n+            && path_to_local_id(lhs, id)\n+        {\n+            return ControlFlow::Continue(());\n+        }\n+\n+        // Method call on `id` in a statement ignores any return value, so it's not a read access:\n+        //\n+        // id.foo(...); // Not reading `id`.\n+        //\n+        // Only assuming this for \"official\" methods defined on the type. For methods defined in extension\n+        // traits (identified as local, based on the orphan rule), pessimistically assume that they might\n+        // have side effects, so consider them a read.\n+        if let Some(Node::Expr(parent)) = get_parent_node(cx.tcx, expr.hir_id)\n+            && let ExprKind::MethodCall(_, receiver, _, _) = parent.kind\n+            && path_to_local_id(receiver, id)\n+            && let Some(Node::Stmt(..)) = get_parent_node(cx.tcx, parent.hir_id)\n+            && let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(parent.hir_id)\n+            && !method_def_id.is_local()\n+        {\n+            return ControlFlow::Continue(());\n+        }\n+\n+        // Any other access to `id` is a read access. Stop searching.\n+        has_read_access = true;\n+        ControlFlow::Break(())\n+    });\n+\n+    // Ignore collections that have no access at all. Other lints should catch them.\n+    has_access && !has_read_access\n+}"}, {"sha": "470a2e79e4796ec113af0c1d5b04042264809ff6", "filename": "clippy_lints/src/declared_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41fa24cef89c71430040332b42036f4ec839c4e0/clippy_lints%2Fsrc%2Fdeclared_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41fa24cef89c71430040332b42036f4ec839c4e0/clippy_lints%2Fsrc%2Fdeclared_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdeclared_lints.rs?ref=41fa24cef89c71430040332b42036f4ec839c4e0", "patch": "@@ -92,6 +92,7 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::cognitive_complexity::COGNITIVE_COMPLEXITY_INFO,\n     crate::collapsible_if::COLLAPSIBLE_ELSE_IF_INFO,\n     crate::collapsible_if::COLLAPSIBLE_IF_INFO,\n+    crate::collection_is_never_read::COLLECTION_IS_NEVER_READ_INFO,\n     crate::comparison_chain::COMPARISON_CHAIN_INFO,\n     crate::copies::BRANCHES_SHARING_CODE_INFO,\n     crate::copies::IFS_SAME_COND_INFO,"}, {"sha": "ae7fdd6be26b8cb7dee5c3648164e2440cded845", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41fa24cef89c71430040332b42036f4ec839c4e0/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41fa24cef89c71430040332b42036f4ec839c4e0/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=41fa24cef89c71430040332b42036f4ec839c4e0", "patch": "@@ -87,6 +87,7 @@ mod casts;\n mod checked_conversions;\n mod cognitive_complexity;\n mod collapsible_if;\n+mod collection_is_never_read;\n mod comparison_chain;\n mod copies;\n mod copy_iterator;\n@@ -924,6 +925,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         ))\n     });\n     store.register_late_pass(|_| Box::new(no_mangle_with_rust_abi::NoMangleWithRustAbi));\n+    store.register_late_pass(|_| Box::new(collection_is_never_read::CollectionIsNeverRead));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n "}, {"sha": "068a49486cf8a06b39a8513cdd313bd7e532878d", "filename": "tests/ui/collection_is_never_read.rs", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/41fa24cef89c71430040332b42036f4ec839c4e0/tests%2Fui%2Fcollection_is_never_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41fa24cef89c71430040332b42036f4ec839c4e0/tests%2Fui%2Fcollection_is_never_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollection_is_never_read.rs?ref=41fa24cef89c71430040332b42036f4ec839c4e0", "patch": "@@ -0,0 +1,165 @@\n+#![allow(unused)]\n+#![warn(clippy::collection_is_never_read)]\n+\n+use std::collections::{HashMap, HashSet};\n+\n+fn main() {}\n+\n+fn not_a_collection() {\n+    // TODO: Expand `collection_is_never_read` beyond collections?\n+    let mut x = 10; // Ok\n+    x += 1;\n+}\n+\n+fn no_access_at_all() {\n+    // Other lints should catch this.\n+    let x = vec![1, 2, 3]; // Ok\n+}\n+\n+fn write_without_read() {\n+    // The main use case for `collection_is_never_read`.\n+    let mut x = HashMap::new(); // WARNING\n+    x.insert(1, 2);\n+}\n+\n+fn read_without_write() {\n+    let mut x = vec![1, 2, 3]; // Ok\n+    let _ = x.len();\n+}\n+\n+fn write_and_read() {\n+    let mut x = vec![1, 2, 3]; // Ok\n+    x.push(4);\n+    let _ = x.len();\n+}\n+\n+fn write_after_read() {\n+    // TODO: Warn here, but this requires more extensive data flow analysis.\n+    let mut x = vec![1, 2, 3]; // Ok\n+    let _ = x.len();\n+    x.push(4); // Pointless\n+}\n+\n+fn write_before_reassign() {\n+    // TODO: Warn here, but this requires more extensive data flow analysis.\n+    let mut x = HashMap::new(); // Ok\n+    x.insert(1, 2); // Pointless\n+    x = HashMap::new();\n+    let _ = x.len();\n+}\n+\n+fn read_in_closure() {\n+    let mut x = HashMap::new(); // Ok\n+    x.insert(1, 2);\n+    let _ = || {\n+        let _ = x.len();\n+    };\n+}\n+\n+fn write_in_closure() {\n+    let mut x = vec![1, 2, 3]; // WARNING\n+    let _ = || {\n+        x.push(4);\n+    };\n+}\n+\n+fn read_in_format() {\n+    let mut x = HashMap::new(); // Ok\n+    x.insert(1, 2);\n+    format!(\"{x:?}\");\n+}\n+\n+fn shadowing_1() {\n+    let x = HashMap::<usize, usize>::new(); // Ok\n+    let _ = x.len();\n+    let mut x = HashMap::new(); // WARNING\n+    x.insert(1, 2);\n+}\n+\n+fn shadowing_2() {\n+    let mut x = HashMap::new(); // WARNING\n+    x.insert(1, 2);\n+    let x = HashMap::<usize, usize>::new(); // Ok\n+    let _ = x.len();\n+}\n+\n+#[allow(clippy::let_unit_value)]\n+fn fake_read() {\n+    let mut x = vec![1, 2, 3]; // Ok\n+    x.reverse();\n+    // `collection_is_never_read` gets fooled, but other lints should catch this.\n+    let _: () = x.clear();\n+}\n+\n+fn assignment() {\n+    let mut x = vec![1, 2, 3]; // WARNING\n+    let y = vec![4, 5, 6]; // Ok\n+    x = y;\n+}\n+\n+#[allow(clippy::self_assignment)]\n+fn self_assignment() {\n+    let mut x = vec![1, 2, 3]; // WARNING\n+    x = x;\n+}\n+\n+fn method_argument_but_not_target() {\n+    struct MyStruct;\n+    impl MyStruct {\n+        fn my_method(&self, _argument: &[usize]) {}\n+    }\n+    let my_struct = MyStruct;\n+\n+    let mut x = vec![1, 2, 3]; // Ok\n+    x.reverse();\n+    my_struct.my_method(&x);\n+}\n+\n+fn insert_is_not_a_read() {\n+    let mut x = HashSet::new(); // WARNING\n+    x.insert(5);\n+}\n+\n+fn insert_is_a_read() {\n+    let mut x = HashSet::new(); // Ok\n+    if x.insert(5) {\n+        println!(\"5 was inserted\");\n+    }\n+}\n+\n+fn not_read_if_return_value_not_used() {\n+    // `is_empty` does not modify the set, so it's a query. But since the return value is not used, the\n+    // lint does not consider it a read here.\n+    let x = vec![1, 2, 3]; // WARNING\n+    x.is_empty();\n+}\n+\n+fn extension_traits() {\n+    trait VecExt<T> {\n+        fn method_with_side_effect(&self);\n+        fn method_without_side_effect(&self);\n+    }\n+\n+    impl<T> VecExt<T> for Vec<T> {\n+        fn method_with_side_effect(&self) {\n+            println!(\"my length: {}\", self.len());\n+        }\n+        fn method_without_side_effect(&self) {}\n+    }\n+\n+    let x = vec![1, 2, 3]; // Ok\n+    x.method_with_side_effect();\n+\n+    let y = vec![1, 2, 3]; // Ok (false negative)\n+    y.method_without_side_effect();\n+}\n+\n+fn function_argument() {\n+    #[allow(clippy::ptr_arg)]\n+    fn foo<T>(v: &Vec<T>) -> usize {\n+        v.len()\n+    }\n+\n+    let x = vec![1, 2, 3]; // Ok\n+    foo(&x);\n+}"}, {"sha": "7654b74be3d176f4dc4999e4842cad40e11045e7", "filename": "tests/ui/collection_is_never_read.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/41fa24cef89c71430040332b42036f4ec839c4e0/tests%2Fui%2Fcollection_is_never_read.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41fa24cef89c71430040332b42036f4ec839c4e0/tests%2Fui%2Fcollection_is_never_read.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollection_is_never_read.stderr?ref=41fa24cef89c71430040332b42036f4ec839c4e0", "patch": "@@ -0,0 +1,52 @@\n+error: collection is never read\n+  --> $DIR/collection_is_never_read.rs:21:5\n+   |\n+LL |     let mut x = HashMap::new(); // WARNING\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::collection-is-never-read` implied by `-D warnings`\n+\n+error: collection is never read\n+  --> $DIR/collection_is_never_read.rs:60:5\n+   |\n+LL |     let mut x = vec![1, 2, 3]; // WARNING\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: collection is never read\n+  --> $DIR/collection_is_never_read.rs:75:5\n+   |\n+LL |     let mut x = HashMap::new(); // WARNING\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: collection is never read\n+  --> $DIR/collection_is_never_read.rs:80:5\n+   |\n+LL |     let mut x = HashMap::new(); // WARNING\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: collection is never read\n+  --> $DIR/collection_is_never_read.rs:95:5\n+   |\n+LL |     let mut x = vec![1, 2, 3]; // WARNING\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: collection is never read\n+  --> $DIR/collection_is_never_read.rs:102:5\n+   |\n+LL |     let mut x = vec![1, 2, 3]; // WARNING\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: collection is never read\n+  --> $DIR/collection_is_never_read.rs:119:5\n+   |\n+LL |     let mut x = HashSet::new(); // WARNING\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: collection is never read\n+  --> $DIR/collection_is_never_read.rs:133:5\n+   |\n+LL |     let x = vec![1, 2, 3]; // WARNING\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 8 previous errors\n+"}]}