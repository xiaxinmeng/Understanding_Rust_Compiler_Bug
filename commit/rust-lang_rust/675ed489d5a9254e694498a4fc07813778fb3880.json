{"sha": "675ed489d5a9254e694498a4fc07813778fb3880", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3NWVkNDg5ZDVhOTI1NGU2OTQ0OThhNGZjMDc4MTM3NzhmYjM4ODA=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-09-30T17:46:41Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-10-02T11:49:11Z"}, "message": "Remove inline annotations from dep_node", "tree": {"sha": "6a8cbbfdebd7e41d4437af2ffa13eedec1f04a6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a8cbbfdebd7e41d4437af2ffa13eedec1f04a6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/675ed489d5a9254e694498a4fc07813778fb3880", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/675ed489d5a9254e694498a4fc07813778fb3880", "html_url": "https://github.com/rust-lang/rust/commit/675ed489d5a9254e694498a4fc07813778fb3880", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/675ed489d5a9254e694498a4fc07813778fb3880/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22bc9e1d9ca49ee4f5cd953088ab09c238a6dd26", "url": "https://api.github.com/repos/rust-lang/rust/commits/22bc9e1d9ca49ee4f5cd953088ab09c238a6dd26", "html_url": "https://github.com/rust-lang/rust/commit/22bc9e1d9ca49ee4f5cd953088ab09c238a6dd26"}], "stats": {"total": 40, "additions": 18, "deletions": 22}, "files": [{"sha": "0686bec0621f450c4e02f95fef3b51cda870adaf", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/675ed489d5a9254e694498a4fc07813778fb3880/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675ed489d5a9254e694498a4fc07813778fb3880/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=675ed489d5a9254e694498a4fc07813778fb3880", "patch": "@@ -114,7 +114,6 @@ macro_rules! define_dep_nodes {\n \n         impl DepKind {\n             #[allow(unreachable_code)]\n-            #[inline]\n             pub fn can_reconstruct_query_key<$tcx>(&self) -> bool {\n                 match *self {\n                     $(\n@@ -150,7 +149,6 @@ macro_rules! define_dep_nodes {\n                 }\n             }\n \n-            #[inline(always)]\n             pub fn is_eval_always(&self) -> bool {\n                 match *self {\n                     $(\n@@ -199,7 +197,6 @@ macro_rules! define_dep_nodes {\n \n         impl DepNode {\n             #[allow(unreachable_code, non_snake_case)]\n-            #[inline(always)]\n             pub fn new<'tcx>(tcx: TyCtxt<'tcx>,\n                                        dep: DepConstructor<'tcx>)\n                                        -> DepNode\n@@ -219,14 +216,16 @@ macro_rules! define_dep_nodes {\n                                     hash\n                                 };\n \n-                                if cfg!(debug_assertions) &&\n-                                   !dep_node.kind.can_reconstruct_query_key() &&\n-                                   (tcx.sess.opts.debugging_opts.incremental_info ||\n-                                    tcx.sess.opts.debugging_opts.query_dep_graph)\n+                                #[cfg(debug_assertions)]\n                                 {\n-                                    tcx.dep_graph.register_dep_node_debug_str(dep_node, || {\n-                                        arg.to_debug_str(tcx)\n-                                    });\n+                                    if !dep_node.kind.can_reconstruct_query_key() &&\n+                                    (tcx.sess.opts.debugging_opts.incremental_info ||\n+                                        tcx.sess.opts.debugging_opts.query_dep_graph)\n+                                    {\n+                                        tcx.dep_graph.register_dep_node_debug_str(dep_node, || {\n+                                            arg.to_debug_str(tcx)\n+                                        });\n+                                    }\n                                 }\n \n                                 return dep_node;\n@@ -242,14 +241,16 @@ macro_rules! define_dep_nodes {\n                                     hash\n                                 };\n \n-                                if cfg!(debug_assertions) &&\n-                                   !dep_node.kind.can_reconstruct_query_key() &&\n-                                   (tcx.sess.opts.debugging_opts.incremental_info ||\n-                                    tcx.sess.opts.debugging_opts.query_dep_graph)\n+                                #[cfg(debug_assertions)]\n                                 {\n-                                    tcx.dep_graph.register_dep_node_debug_str(dep_node, || {\n-                                        tupled_args.to_debug_str(tcx)\n-                                    });\n+                                    if !dep_node.kind.can_reconstruct_query_key() &&\n+                                    (tcx.sess.opts.debugging_opts.incremental_info ||\n+                                        tcx.sess.opts.debugging_opts.query_dep_graph)\n+                                    {\n+                                        tcx.dep_graph.register_dep_node_debug_str(dep_node, || {\n+                                            tupled_args.to_debug_str(tcx)\n+                                        });\n+                                    }\n                                 }\n \n                                 return dep_node;\n@@ -267,7 +268,6 @@ macro_rules! define_dep_nodes {\n             /// Construct a DepNode from the given DepKind and DefPathHash. This\n             /// method will assert that the given DepKind actually requires a\n             /// single DefId/DefPathHash parameter.\n-            #[inline(always)]\n             pub fn from_def_path_hash(kind: DepKind,\n                                       def_path_hash: DefPathHash)\n                                       -> DepNode {\n@@ -281,7 +281,6 @@ macro_rules! define_dep_nodes {\n             /// Creates a new, parameterless DepNode. This method will assert\n             /// that the DepNode corresponding to the given DepKind actually\n             /// does not require any parameters.\n-            #[inline(always)]\n             pub fn new_no_params(kind: DepKind) -> DepNode {\n                 debug_assert!(!kind.has_params());\n                 DepNode {\n@@ -300,7 +299,6 @@ macro_rules! define_dep_nodes {\n             /// DepNode. Condition (2) might not be fulfilled if a DepNode\n             /// refers to something from the previous compilation session that\n             /// has been removed.\n-            #[inline]\n             pub fn extract_def_id(&self, tcx: TyCtxt<'_>) -> Option<DefId> {\n                 if self.kind.can_reconstruct_query_key() {\n                     let def_path_hash = DefPathHash(self.hash);\n@@ -386,14 +384,12 @@ impl fmt::Debug for DepNode {\n \n \n impl DefPathHash {\n-    #[inline(always)]\n     pub fn to_dep_node(self, kind: DepKind) -> DepNode {\n         DepNode::from_def_path_hash(kind, self)\n     }\n }\n \n impl DefId {\n-    #[inline(always)]\n     pub fn to_dep_node(self, tcx: TyCtxt<'_>, kind: DepKind) -> DepNode {\n         DepNode::from_def_path_hash(kind, tcx.def_path_hash(self))\n     }"}]}