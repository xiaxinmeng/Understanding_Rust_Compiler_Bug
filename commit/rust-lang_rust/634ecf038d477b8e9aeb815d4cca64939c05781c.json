{"sha": "634ecf038d477b8e9aeb815d4cca64939c05781c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzNGVjZjAzOGQ0NzdiOGU5YWViODE1ZDRjY2E2NDkzOWMwNTc4MWM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-16T06:45:03Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-27T06:43:43Z"}, "message": "Merge `ModuleData` and `ModuleS`.", "tree": {"sha": "57df3bb2e61da153d2c4023c1a0a4ca876f9065b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57df3bb2e61da153d2c4023c1a0a4ca876f9065b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/634ecf038d477b8e9aeb815d4cca64939c05781c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/634ecf038d477b8e9aeb815d4cca64939c05781c", "html_url": "https://github.com/rust-lang/rust/commit/634ecf038d477b8e9aeb815d4cca64939c05781c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/634ecf038d477b8e9aeb815d4cca64939c05781c/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3a81ee8448b93182e6f4d2bc6cf327c6af4ecd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3a81ee8448b93182e6f4d2bc6cf327c6af4ecd2", "html_url": "https://github.com/rust-lang/rust/commit/b3a81ee8448b93182e6f4d2bc6cf327c6af4ecd2"}], "stats": {"total": 239, "additions": 80, "deletions": 159}, "files": [{"sha": "55bf5dcf1cff0e692c7fce657bb473c0eb1b24d7", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 57, "deletions": 6, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/634ecf038d477b8e9aeb815d4cca64939c05781c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/634ecf038d477b8e9aeb815d4cca64939c05781c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=634ecf038d477b8e9aeb815d4cca64939c05781c", "patch": "@@ -20,12 +20,14 @@ use {NameBinding, NameBindingKind, ToNameBinding};\n use Resolver;\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n+use rustc::middle::cstore::LoadedMacro;\n use rustc::hir::def::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::hir::map::DefPathData;\n use rustc::ty;\n \n use std::cell::Cell;\n+use std::rc::Rc;\n \n use syntax::ast::Name;\n use syntax::attr;\n@@ -34,6 +36,9 @@ use syntax::parse::token;\n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind};\n use syntax::ast::{Mutability, StmtKind, TraitItem, TraitItemKind};\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n+use syntax::ext::base::{MultiItemModifier, Resolver as SyntaxResolver};\n+use syntax::ext::hygiene::Mark;\n+use syntax::feature_gate::{self, emit_feature_err};\n use syntax::parse::token::keywords;\n use syntax::visit::{self, Visitor};\n \n@@ -73,8 +78,6 @@ impl<'b> Resolver<'b> {\n \n     /// Constructs the reduced graph for one item.\n     fn build_reduced_graph_for_item(&mut self, item: &Item) {\n-        self.crate_loader.process_item(item, &self.definitions);\n-\n         let parent = self.current_module;\n         let name = item.ident.name;\n         let sp = item.span;\n@@ -182,8 +185,20 @@ impl<'b> Resolver<'b> {\n             }\n \n             ItemKind::ExternCrate(_) => {\n-                // n.b. we don't need to look at the path option here, because cstore already\n-                // did\n+                // We need to error on `#[macro_use] extern crate` when it isn't at the\n+                // crate root, because `$crate` won't work properly.\n+                let is_crate_root = self.current_module.parent.is_none();\n+                for def in self.crate_loader.load_macros(item, is_crate_root) {\n+                    match def {\n+                        LoadedMacro::Def(def) => self.add_macro(Mark::root(), def),\n+                        LoadedMacro::CustomDerive(name, ext) => {\n+                            self.insert_custom_derive(&name, ext, item.span);\n+                        }\n+                    }\n+                }\n+                self.crate_loader.process_item(item, &self.definitions);\n+\n+                // n.b. we don't need to look at the path option here, because cstore already did\n                 if let Some(crate_id) = self.session.cstore.extern_mod_stmt_cnum(item.id) {\n                     let def_id = DefId {\n                         krate: crate_id,\n@@ -209,6 +224,7 @@ impl<'b> Resolver<'b> {\n                         attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n                     },\n                     normal_ancestor_id: Some(item.id),\n+                    macros_escape: self.contains_macro_use(&item.attrs),\n                     ..ModuleS::new(Some(parent), ModuleKind::Def(def, name))\n                 });\n                 self.define(parent, name, TypeNS, (module, sp, vis));\n@@ -218,7 +234,7 @@ impl<'b> Resolver<'b> {\n                 self.current_module = module;\n             }\n \n-            ItemKind::ForeignMod(..) => {}\n+            ItemKind::ForeignMod(..) => self.crate_loader.process_item(item, &self.definitions),\n \n             // These items live in the value namespace.\n             ItemKind::Static(_, m, _) => {\n@@ -472,6 +488,41 @@ impl<'b> Resolver<'b> {\n         }\n         module.populated.set(true)\n     }\n+\n+    // does this attribute list contain \"macro_use\"?\n+    fn contains_macro_use(&mut self, attrs: &[ast::Attribute]) -> bool {\n+        for attr in attrs {\n+            if attr.check_name(\"macro_escape\") {\n+                let msg = \"macro_escape is a deprecated synonym for macro_use\";\n+                let mut err = self.session.struct_span_warn(attr.span, msg);\n+                if let ast::AttrStyle::Inner = attr.node.style {\n+                    err.help(\"consider an outer attribute, #[macro_use] mod ...\").emit();\n+                } else {\n+                    err.emit();\n+                }\n+            } else if !attr.check_name(\"macro_use\") {\n+                continue;\n+            }\n+\n+            if !attr.is_word() {\n+                self.session.span_err(attr.span, \"arguments to macro_use are not allowed here\");\n+            }\n+            return true;\n+        }\n+\n+        false\n+    }\n+\n+    fn insert_custom_derive(&mut self, name: &str, ext: Rc<MultiItemModifier>, sp: Span) {\n+        if !self.session.features.borrow().rustc_macro {\n+            let sess = &self.session.parse_sess;\n+            let msg = \"loading custom derive macro crates is experimentally supported\";\n+            emit_feature_err(sess, \"rustc_macro\", sp, feature_gate::GateIssue::Language, msg);\n+        }\n+        if self.derive_modes.insert(token::intern(name), ext).is_some() {\n+            self.session.span_err(sp, &format!(\"cannot shadow existing derive mode `{}`\", name));\n+        }\n+    }\n }\n \n pub struct BuildReducedGraphVisitor<'a, 'b: 'a> {\n@@ -480,7 +531,7 @@ pub struct BuildReducedGraphVisitor<'a, 'b: 'a> {\n \n impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_invoc(&mut self, id: ast::NodeId) {\n-        self.resolver.expansion_data.get_mut(&id.as_u32()).unwrap().module2 =\n+        self.resolver.expansion_data.get_mut(&id.as_u32()).unwrap().module =\n             self.resolver.current_module;\n     }\n }"}, {"sha": "4e949e3259c45873710c59ed38dab7a247788a5a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/634ecf038d477b8e9aeb815d4cca64939c05781c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/634ecf038d477b8e9aeb815d4cca64939c05781c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=634ecf038d477b8e9aeb815d4cca64939c05781c", "patch": "@@ -57,6 +57,7 @@ use syntax::ext::base::MultiItemModifier;\n use syntax::ext::hygiene::Mark;\n use syntax::ast::{self, FloatTy};\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, IntTy, UintTy};\n+use syntax::ext::base::SyntaxExtension;\n use syntax::parse::token::{self, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n@@ -72,9 +73,9 @@ use syntax_pos::{Span, DUMMY_SP};\n use errors::DiagnosticBuilder;\n \n use std::cell::{Cell, RefCell};\n-use std::rc::Rc;\n use std::fmt;\n use std::mem::replace;\n+use std::rc::Rc;\n \n use resolve_imports::{ImportDirective, NameResolution};\n \n@@ -786,6 +787,9 @@ pub struct ModuleS<'a> {\n     // access the children must be preceded with a\n     // `populate_module_if_necessary` call.\n     populated: Cell<bool>,\n+\n+    macros: RefCell<FnvHashMap<Name, Rc<SyntaxExtension>>>,\n+    macros_escape: bool,\n }\n \n pub type Module<'a> = &'a ModuleS<'a>;\n@@ -803,6 +807,8 @@ impl<'a> ModuleS<'a> {\n             globs: RefCell::new((Vec::new())),\n             traits: RefCell::new(None),\n             populated: Cell::new(true),\n+            macros: RefCell::new(FnvHashMap()),\n+            macros_escape: false,\n         }\n     }\n "}, {"sha": "fad563218a05775ec445df697f03a96af1fbc94f", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 16, "deletions": 152, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/634ecf038d477b8e9aeb815d4cca64939c05781c/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/634ecf038d477b8e9aeb815d4cca64939c05781c/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=634ecf038d477b8e9aeb815d4cca64939c05781c", "patch": "@@ -12,63 +12,41 @@ use {Module, Resolver};\n use build_reduced_graph::BuildReducedGraphVisitor;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefIndex};\n use rustc::hir::map::DefCollector;\n-use rustc::middle::cstore::LoadedMacro;\n-use rustc::util::nodemap::FnvHashMap;\n-use std::cell::RefCell;\n-use std::mem;\n use std::rc::Rc;\n-use syntax::ast::{self, Name};\n+use syntax::ast;\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, MultiModifier, MultiDecorator, MultiItemModifier};\n-use syntax::ext::base::{NormalTT, Resolver as SyntaxResolver, SyntaxExtension};\n+use syntax::ext::base::{NormalTT, SyntaxExtension};\n use syntax::ext::expand::{Expansion, Invocation, InvocationKind};\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n-use syntax::feature_gate::{self, emit_feature_err};\n-use syntax::parse::token::{self, intern};\n+use syntax::parse::token::intern;\n use syntax::util::lev_distance::find_best_match_for_name;\n-use syntax::visit::{self, Visitor};\n-use syntax_pos::Span;\n \n #[derive(Clone)]\n pub struct ExpansionData<'a> {\n-    module: Rc<ModuleData>,\n+    pub module: Module<'a>,\n     def_index: DefIndex,\n-    pub module2: Module<'a>,\n }\n \n impl<'a> ExpansionData<'a> {\n     pub fn root(graph_root: Module<'a>) -> Self {\n         ExpansionData {\n-            module: Default::default(),\n+            module: graph_root,\n             def_index: CRATE_DEF_INDEX,\n-            module2: graph_root,\n         }\n     }\n }\n \n-// FIXME(jseyfried): merge with `::ModuleS`.\n-#[derive(Default)]\n-struct ModuleData {\n-    parent: Option<Rc<ModuleData>>,\n-    macros: RefCell<FnvHashMap<Name, Rc<SyntaxExtension>>>,\n-    macros_escape: bool,\n-}\n-\n impl<'a> base::Resolver for Resolver<'a> {\n     fn next_node_id(&mut self) -> ast::NodeId {\n         self.session.next_node_id()\n     }\n \n     fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion) {\n-        let expansion_data = self.expansion_data[&mark.as_u32()].clone();\n-        self.current_module = expansion_data.module2;\n-        let mut visitor =\n-            ExpansionVisitor { current_module: expansion_data.module, resolver: self };\n-\n-        visitor.collect_def_ids(mark, expansion);\n-        expansion.visit_with(&mut visitor);\n-        expansion.visit_with(&mut BuildReducedGraphVisitor { resolver: visitor.resolver });\n+        self.collect_def_ids(mark, expansion);\n+        self.current_module = self.expansion_data[&mark.as_u32()].module;\n+        expansion.visit_with(&mut BuildReducedGraphVisitor { resolver: self });\n     }\n \n     fn add_macro(&mut self, scope: Mark, mut def: ast::MacroDef) {\n@@ -90,9 +68,9 @@ impl<'a> base::Resolver for Resolver<'a> {\n             self.macro_names.insert(ident.name);\n         }\n \n-        let mut module = self.expansion_data[&scope.as_u32()].module.clone();\n+        let mut module = self.expansion_data[&scope.as_u32()].module;\n         while module.macros_escape {\n-            module = module.parent.clone().unwrap();\n+            module = module.parent.unwrap();\n         }\n         module.macros.borrow_mut().insert(ident.name, ext);\n     }\n@@ -132,12 +110,12 @@ impl<'a> base::Resolver for Resolver<'a> {\n             InvocationKind::Attr { ref attr, .. } => (intern(&*attr.name()), attr.span),\n         };\n \n-        let mut module = self.expansion_data[&scope.as_u32()].module.clone();\n+        let mut module = self.expansion_data[&scope.as_u32()].module;\n         loop {\n             if let Some(ext) = module.macros.borrow().get(&name) {\n                 return Some(ext.clone());\n             }\n-            match module.parent.clone() {\n+            match module.parent {\n                 Some(parent) => module = parent,\n                 None => break,\n             }\n@@ -166,133 +144,19 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn insert_custom_derive(&mut self, name: &str, ext: Rc<MultiItemModifier>, sp: Span) {\n-        if !self.session.features.borrow().rustc_macro {\n-            let sess = &self.session.parse_sess;\n-            let msg = \"loading custom derive macro crates is experimentally supported\";\n-            emit_feature_err(sess, \"rustc_macro\", sp, feature_gate::GateIssue::Language, msg);\n-        }\n-        if self.derive_modes.insert(token::intern(name), ext).is_some() {\n-            self.session.span_err(sp, &format!(\"cannot shadow existing derive mode `{}`\", name));\n-        }\n-    }\n-}\n-\n-struct ExpansionVisitor<'b, 'a: 'b> {\n-    resolver: &'b mut Resolver<'a>,\n-    current_module: Rc<ModuleData>,\n-}\n-\n-impl<'a, 'b> ExpansionVisitor<'a, 'b> {\n-    fn visit_invoc(&mut self, id: ast::NodeId) {\n-        self.resolver.expansion_data.get_mut(&id.as_u32()).unwrap().module =\n-            self.current_module.clone();\n-    }\n-\n-    // does this attribute list contain \"macro_use\"?\n-    fn contains_macro_use(&mut self, attrs: &[ast::Attribute]) -> bool {\n-        for attr in attrs {\n-            if attr.check_name(\"macro_escape\") {\n-                let msg = \"macro_escape is a deprecated synonym for macro_use\";\n-                let mut err = self.resolver.session.struct_span_warn(attr.span, msg);\n-                if let ast::AttrStyle::Inner = attr.node.style {\n-                    err.help(\"consider an outer attribute, #[macro_use] mod ...\").emit();\n-                } else {\n-                    err.emit();\n-                }\n-            } else if !attr.check_name(\"macro_use\") {\n-                continue;\n-            }\n-\n-            if !attr.is_word() {\n-                self.resolver.session.span_err(attr.span,\n-                                               \"arguments to macro_use are not allowed here\");\n-            }\n-            return true;\n-        }\n-\n-        false\n-    }\n-\n     fn collect_def_ids(&mut self, mark: Mark, expansion: &Expansion) {\n-        let expansion_data = &mut self.resolver.expansion_data;\n-        let module = &self.current_module;\n-        let module2 = self.resolver.current_module;\n+        let expansion_data = &mut self.expansion_data;\n+        let module = self.current_module;\n         let def_index = expansion_data[&mark.as_u32()].def_index;\n         let visit_macro_invoc = &mut |id: ast::NodeId, def_index| {\n             expansion_data.insert(id.as_u32(), ExpansionData {\n                 def_index: def_index,\n-                module: module.clone(),\n-                module2: module2,\n+                module: module,\n             });\n         };\n \n-        let mut def_collector = DefCollector::new(&mut self.resolver.definitions);\n+        let mut def_collector = DefCollector::new(&mut self.definitions);\n         def_collector.visit_macro_invoc = Some(visit_macro_invoc);\n         def_collector.with_parent(def_index, |def_collector| expansion.visit_with(def_collector));\n     }\n }\n-\n-macro_rules! method {\n-    ($visit:ident: $ty:ty, $invoc:path, $walk:ident) => {\n-        fn $visit(&mut self, node: &$ty) {\n-            match node.node {\n-                $invoc(..) => self.visit_invoc(node.id),\n-                _ => visit::$walk(self, node),\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'b> Visitor for ExpansionVisitor<'a, 'b>  {\n-    method!(visit_trait_item: ast::TraitItem, ast::TraitItemKind::Macro, walk_trait_item);\n-    method!(visit_impl_item:  ast::ImplItem,  ast::ImplItemKind::Macro,  walk_impl_item);\n-    method!(visit_stmt:       ast::Stmt,      ast::StmtKind::Mac,        walk_stmt);\n-    method!(visit_expr:       ast::Expr,      ast::ExprKind::Mac,        walk_expr);\n-    method!(visit_pat:        ast::Pat,       ast::PatKind::Mac,         walk_pat);\n-    method!(visit_ty:         ast::Ty,        ast::TyKind::Mac,          walk_ty);\n-\n-    fn visit_item(&mut self, item: &ast::Item) {\n-        match item.node {\n-            ast::ItemKind::Mac(..) if item.id == ast::DUMMY_NODE_ID => {} // Scope placeholder\n-            ast::ItemKind::Mac(..) => self.visit_invoc(item.id),\n-            ast::ItemKind::Mod(..) => {\n-                let module_data = ModuleData {\n-                    parent: Some(self.current_module.clone()),\n-                    macros: RefCell::new(FnvHashMap()),\n-                    macros_escape: self.contains_macro_use(&item.attrs),\n-                };\n-                let orig_module = mem::replace(&mut self.current_module, Rc::new(module_data));\n-                visit::walk_item(self, item);\n-                self.current_module = orig_module;\n-            }\n-            ast::ItemKind::ExternCrate(..) => {\n-                // We need to error on `#[macro_use] extern crate` when it isn't at the\n-                // crate root, because `$crate` won't work properly.\n-                // FIXME(jseyfried): This will be nicer once `ModuleData` is merged with `ModuleS`.\n-                let is_crate_root = self.current_module.parent.as_ref().unwrap().parent.is_none();\n-                for def in self.resolver.crate_loader.load_macros(item, is_crate_root) {\n-                    match def {\n-                        LoadedMacro::Def(def) => self.resolver.add_macro(Mark::root(), def),\n-                        LoadedMacro::CustomDerive(name, ext) => {\n-                            self.resolver.insert_custom_derive(&name, ext, item.span);\n-                        }\n-                    }\n-                }\n-                visit::walk_item(self, item);\n-            }\n-            _ => visit::walk_item(self, item),\n-        }\n-    }\n-\n-    fn visit_block(&mut self, block: &ast::Block) {\n-        let module_data = ModuleData {\n-            parent: Some(self.current_module.clone()),\n-            macros: RefCell::new(FnvHashMap()),\n-            macros_escape: false,\n-        };\n-        let orig_module = mem::replace(&mut self.current_module, Rc::new(module_data));\n-        visit::walk_block(self, block);\n-        self.current_module = orig_module;\n-    }\n-}"}]}