{"sha": "38713126dd8502e283aa8ec7c6b678a4c43f8c3b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4NzEzMTI2ZGQ4NTAyZTI4M2FhOGVjN2M2YjY3OGE0YzQzZjhjM2I=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2017-03-22T17:11:51Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2017-04-09T15:55:47Z"}, "message": "Move away from the ad-hoc NoDrop unions", "tree": {"sha": "056061a894cfc9846ab8a23c4c011f8645be737d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/056061a894cfc9846ab8a23c4c011f8645be737d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38713126dd8502e283aa8ec7c6b678a4c43f8c3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38713126dd8502e283aa8ec7c6b678a4c43f8c3b", "html_url": "https://github.com/rust-lang/rust/commit/38713126dd8502e283aa8ec7c6b678a4c43f8c3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38713126dd8502e283aa8ec7c6b678a4c43f8c3b/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6e566185eaa4675cf2791ee69e63eb20ea01edb", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6e566185eaa4675cf2791ee69e63eb20ea01edb", "html_url": "https://github.com/rust-lang/rust/commit/f6e566185eaa4675cf2791ee69e63eb20ea01edb"}], "stats": {"total": 81, "additions": 25, "deletions": 56}, "files": [{"sha": "b474bd5d91af171888b0a2e8fd35cc2421f3c556", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38713126dd8502e283aa8ec7c6b678a4c43f8c3b/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38713126dd8502e283aa8ec7c6b678a4c43f8c3b/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=38713126dd8502e283aa8ec7c6b678a4c43f8c3b", "patch": "@@ -44,6 +44,7 @@\n #![feature(heap_api)]\n #![feature(inclusive_range)]\n #![feature(lang_items)]\n+#![feature(manually_drop)]\n #![feature(nonzero)]\n #![feature(pattern)]\n #![feature(placement_in)]"}, {"sha": "3069adb12e92cd127c5bd29d03d266da23d49df4", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/38713126dd8502e283aa8ec7c6b678a4c43f8c3b/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38713126dd8502e283aa8ec7c6b678a4c43f8c3b/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=38713126dd8502e283aa8ec7c6b678a4c43f8c3b", "patch": "@@ -1558,7 +1558,7 @@ fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n             //    performance than with the 2nd method.\n             //\n             // All methods were benchmarked, and the 3rd showed best results. So we chose that one.\n-            let mut tmp = NoDrop { value: ptr::read(&v[0]) };\n+            let mut tmp = mem::ManuallyDrop::new(ptr::read(&v[0]));\n \n             // Intermediate state of the insertion process is always tracked by `hole`, which\n             // serves two purposes:\n@@ -1571,13 +1571,13 @@ fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n             // fill the hole in `v` with `tmp`, thus ensuring that `v` still holds every object it\n             // initially held exactly once.\n             let mut hole = InsertionHole {\n-                src: &mut tmp.value,\n+                src: &mut *tmp,\n                 dest: &mut v[1],\n             };\n             ptr::copy_nonoverlapping(&v[1], &mut v[0], 1);\n \n             for i in 2..v.len() {\n-                if !is_less(&v[i], &tmp.value) {\n+                if !is_less(&v[i], &*tmp) {\n                     break;\n                 }\n                 ptr::copy_nonoverlapping(&v[i], &mut v[i - 1], 1);\n@@ -1587,12 +1587,6 @@ fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n         }\n     }\n \n-    // Holds a value, but never drops it.\n-    #[allow(unions_with_drop_fields)]\n-    union NoDrop<T> {\n-        value: T\n-    }\n-\n     // When dropped, copies from `src` into `dest`.\n     struct InsertionHole<T> {\n         src: *mut T,"}, {"sha": "6f9f2915dfe102c1fe6022d660816e69279152ed", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/38713126dd8502e283aa8ec7c6b678a4c43f8c3b/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38713126dd8502e283aa8ec7c6b678a4c43f8c3b/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=38713126dd8502e283aa8ec7c6b678a4c43f8c3b", "patch": "@@ -20,12 +20,6 @@ use cmp;\n use mem;\n use ptr;\n \n-/// Holds a value, but never drops it.\n-#[allow(unions_with_drop_fields)]\n-union NoDrop<T> {\n-    value: T\n-}\n-\n /// When dropped, copies from `src` into `dest`.\n struct CopyOnDrop<T> {\n     src: *mut T,\n@@ -49,15 +43,15 @@ fn shift_head<T, F>(v: &mut [T], is_less: &mut F)\n             // Read the first element into a stack-allocated variable. If a following comparison\n             // operation panics, `hole` will get dropped and automatically write the element back\n             // into the slice.\n-            let mut tmp = NoDrop { value: ptr::read(v.get_unchecked(0)) };\n+            let mut tmp = mem::ManuallyDrop::new(ptr::read(v.get_unchecked(0)));\n             let mut hole = CopyOnDrop {\n-                src: &mut tmp.value,\n+                src: &mut *tmp,\n                 dest: v.get_unchecked_mut(1),\n             };\n             ptr::copy_nonoverlapping(v.get_unchecked(1), v.get_unchecked_mut(0), 1);\n \n             for i in 2..len {\n-                if !is_less(v.get_unchecked(i), &tmp.value) {\n+                if !is_less(v.get_unchecked(i), &*tmp) {\n                     break;\n                 }\n \n@@ -81,15 +75,15 @@ fn shift_tail<T, F>(v: &mut [T], is_less: &mut F)\n             // Read the last element into a stack-allocated variable. If a following comparison\n             // operation panics, `hole` will get dropped and automatically write the element back\n             // into the slice.\n-            let mut tmp = NoDrop { value: ptr::read(v.get_unchecked(len - 1)) };\n+            let mut tmp = mem::ManuallyDrop::new(ptr::read(v.get_unchecked(len - 1)));\n             let mut hole = CopyOnDrop {\n-                src: &mut tmp.value,\n+                src: &mut *tmp,\n                 dest: v.get_unchecked_mut(len - 2),\n             };\n             ptr::copy_nonoverlapping(v.get_unchecked(len - 2), v.get_unchecked_mut(len - 1), 1);\n \n             for i in (0..len-2).rev() {\n-                if !is_less(&tmp.value, v.get_unchecked(i)) {\n+                if !is_less(&*tmp, v.get_unchecked(i)) {\n                     break;\n                 }\n \n@@ -403,12 +397,12 @@ fn partition<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> (usize, bool)\n \n         // Read the pivot into a stack-allocated variable for efficiency. If a following comparison\n         // operation panics, the pivot will be automatically written back into the slice.\n-        let mut tmp = NoDrop { value: unsafe { ptr::read(pivot) } };\n+        let mut tmp = mem::ManuallyDrop::new(unsafe { ptr::read(pivot) });\n         let _pivot_guard = CopyOnDrop {\n-            src: unsafe { &mut tmp.value },\n+            src: &mut *tmp,\n             dest: pivot,\n         };\n-        let pivot = unsafe { &tmp.value };\n+        let pivot = &*tmp;\n \n         // Find the first pair of out-of-order elements.\n         let mut l = 0;\n@@ -452,12 +446,12 @@ fn partition_equal<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> usize\n \n     // Read the pivot into a stack-allocated variable for efficiency. If a following comparison\n     // operation panics, the pivot will be automatically written back into the slice.\n-    let mut tmp = NoDrop { value: unsafe { ptr::read(pivot) } };\n+    let mut tmp = mem::ManuallyDrop::new(unsafe { ptr::read(pivot) });\n     let _pivot_guard = CopyOnDrop {\n-        src: unsafe { &mut tmp.value },\n+        src: &mut *tmp,\n         dest: pivot,\n     };\n-    let pivot = unsafe { &tmp.value };\n+    let pivot = &*tmp;\n \n     // Now partition the slice.\n     let mut l = 0;"}, {"sha": "adb22197226023fcb80731626f1ecc97255275f7", "filename": "src/librustc_data_structures/array_vec.rs", "status": "modified", "additions": 8, "deletions": 29, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/38713126dd8502e283aa8ec7c6b678a4c43f8c3b/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38713126dd8502e283aa8ec7c6b678a4c43f8c3b/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=38713126dd8502e283aa8ec7c6b678a4c43f8c3b", "patch": "@@ -20,10 +20,11 @@ use std::fmt;\n use std::mem;\n use std::collections::range::RangeArgument;\n use std::collections::Bound::{Excluded, Included, Unbounded};\n+use std::mem::ManuallyDrop;\n \n pub unsafe trait Array {\n     type Element;\n-    type PartialStorage: Default + Unsize<[ManuallyDrop<Self::Element>]>;\n+    type PartialStorage: Unsize<[ManuallyDrop<Self::Element>]>;\n     const LEN: usize;\n }\n \n@@ -66,7 +67,7 @@ impl<A: Array> ArrayVec<A> {\n     pub fn new() -> Self {\n         ArrayVec {\n             count: 0,\n-            values: Default::default(),\n+            values: unsafe { ::std::mem::uninitialized() },\n         }\n     }\n \n@@ -81,7 +82,7 @@ impl<A: Array> ArrayVec<A> {\n     /// Panics when the stack vector is full.\n     pub fn push(&mut self, el: A::Element) {\n         let arr = &mut self.values as &mut [ManuallyDrop<_>];\n-        arr[self.count] = ManuallyDrop { value: el };\n+        arr[self.count] = ManuallyDrop::new(el);\n         self.count += 1;\n     }\n \n@@ -90,8 +91,8 @@ impl<A: Array> ArrayVec<A> {\n             let arr = &mut self.values as &mut [ManuallyDrop<_>];\n             self.count -= 1;\n             unsafe {\n-                let value = ptr::read(&arr[self.count]);\n-                Some(value.value)\n+                let value = ptr::read(&*arr[self.count]);\n+                Some(value)\n             }\n         } else {\n             None\n@@ -210,7 +211,7 @@ impl<A: Array> Iterator for Iter<A> {\n     fn next(&mut self) -> Option<A::Element> {\n         let arr = &self.store as &[ManuallyDrop<_>];\n         unsafe {\n-            self.indices.next().map(|i| ptr::read(&arr[i]).value)\n+            self.indices.next().map(|i| ptr::read(&*arr[i]))\n         }\n     }\n \n@@ -233,7 +234,7 @@ impl<'a, A: Array> Iterator for Drain<'a, A> {\n \n     #[inline]\n     fn next(&mut self) -> Option<A::Element> {\n-        self.iter.next().map(|elt| unsafe { ptr::read(elt as *const ManuallyDrop<_>).value })\n+        self.iter.next().map(|elt| unsafe { ptr::read(&**elt) })\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n@@ -295,25 +296,3 @@ impl<'a, A: Array> IntoIterator for &'a mut ArrayVec<A> {\n         self.iter_mut()\n     }\n }\n-\n-// FIXME: This should use repr(transparent) from rust-lang/rfcs#1758.\n-#[allow(unions_with_drop_fields)]\n-pub union ManuallyDrop<T> {\n-    value: T,\n-    #[allow(dead_code)]\n-    empty: (),\n-}\n-\n-impl<T> ManuallyDrop<T> {\n-    fn new() -> ManuallyDrop<T> {\n-        ManuallyDrop {\n-            empty: ()\n-        }\n-    }\n-}\n-\n-impl<T> Default for ManuallyDrop<T> {\n-    fn default() -> Self {\n-        ManuallyDrop::new()\n-    }\n-}"}, {"sha": "72c533a74618b8185eae1cb22807539ef56cdb4f", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38713126dd8502e283aa8ec7c6b678a4c43f8c3b/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38713126dd8502e283aa8ec7c6b678a4c43f8c3b/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=38713126dd8502e283aa8ec7c6b678a4c43f8c3b", "patch": "@@ -39,6 +39,7 @@\n #![feature(conservative_impl_trait)]\n #![feature(discriminant_value)]\n #![feature(specialization)]\n+#![feature(manually_drop)]\n \n #![cfg_attr(unix, feature(libc))]\n #![cfg_attr(test, feature(test))]"}]}