{"sha": "b6e03c464a0020f44a9e89af9e043fdb47889bfc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2ZTAzYzQ2NGEwMDIwZjQ0YTllODlhZjllMDQzZmRiNDc4ODliZmM=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-25T16:30:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-25T16:30:24Z"}, "message": "Rollup merge of #69813 - thomcc:nonzero-bitor, r=Amanieu\n\nImplement BitOr and BitOrAssign for the NonZero integer types\n\nThis provides overloaded operators for `NonZero$Int | NonZero$Int`, `NonZero$Int | $Int`, and `$Int | NonZero$Int`. It also provides `BitOrAssign` where `self` is `NonZero$Int`, for symmetry.\n\nIt's a pretty small conceptual addition, but is good becasue but avoids a case where the operation is obviously sound, but you'd otherwise need unsafe to do it.\n\nIn crates trying to minimize `unsafe` usage, this is unfortunate and makes working with `NonZero` types often not worth it, even if the operations you're doing are clearly sound.\n\nI've marked these as stable as I've been told in the past that trait impls are automatically stable. I'm happy to change it to unstable if this wasn't correct information.\n\nI'm not entirely confident what version I should have put down, so I followed https://www.whatrustisit.com. Hopefully it's correct for this.\n\nApologies in advance if this has come up before, but I couldn't find it.", "tree": {"sha": "51740d3595330dc18a17a76d8c4ee19dd6eef89d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51740d3595330dc18a17a76d8c4ee19dd6eef89d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6e03c464a0020f44a9e89af9e043fdb47889bfc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJepGWgCRBK7hj4Ov3rIwAAdHIIACNADYMQNw46f2W1TrCxiw5h\nQqCcKbWM7puvfXyLSgOJL+dYlgir42j0Q0MYrw4FEDZbEmVO29vTv0wBkp02hKVZ\nE36UVPbFOZBigdF3fo8e7tHEC/BV1nxV0uJvkw04GDPamjXFbG2VB3izQEvCMMrp\nEKImSYeEPriOnvsCbvtZN15GpZDx/Z0aXLijQPFHuagWSx/SHURGJeTn3qVfsWXd\n5+ccpatNRSGU4w18fF3DINZjtoEeqEWiPeCJ/2nTdB01mPf7M4LpyjxqawMnTQvX\ndJjH+RXtE+69eSX9iYQOp1l2NbmiQUkmQjLV68qe5JRNWZAehyQCgjid2DBIvUY=\n=2udu\n-----END PGP SIGNATURE-----\n", "payload": "tree 51740d3595330dc18a17a76d8c4ee19dd6eef89d\nparent 7b7c63cb7732e5ad5eace294b1c7c2f92beef4a2\nparent 6cdb8257dd5b567589e56ed2ddf3655fe7f4f4e3\nauthor Dylan DPC <dylan.dpc@gmail.com> 1587832224 +0200\ncommitter GitHub <noreply@github.com> 1587832224 +0200\n\nRollup merge of #69813 - thomcc:nonzero-bitor, r=Amanieu\n\nImplement BitOr and BitOrAssign for the NonZero integer types\n\nThis provides overloaded operators for `NonZero$Int | NonZero$Int`, `NonZero$Int | $Int`, and `$Int | NonZero$Int`. It also provides `BitOrAssign` where `self` is `NonZero$Int`, for symmetry.\n\nIt's a pretty small conceptual addition, but is good becasue but avoids a case where the operation is obviously sound, but you'd otherwise need unsafe to do it.\n\nIn crates trying to minimize `unsafe` usage, this is unfortunate and makes working with `NonZero` types often not worth it, even if the operations you're doing are clearly sound.\n\nI've marked these as stable as I've been told in the past that trait impls are automatically stable. I'm happy to change it to unstable if this wasn't correct information.\n\nI'm not entirely confident what version I should have put down, so I followed https://www.whatrustisit.com. Hopefully it's correct for this.\n\nApologies in advance if this has come up before, but I couldn't find it.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6e03c464a0020f44a9e89af9e043fdb47889bfc", "html_url": "https://github.com/rust-lang/rust/commit/b6e03c464a0020f44a9e89af9e043fdb47889bfc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6e03c464a0020f44a9e89af9e043fdb47889bfc/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b7c63cb7732e5ad5eace294b1c7c2f92beef4a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b7c63cb7732e5ad5eace294b1c7c2f92beef4a2", "html_url": "https://github.com/rust-lang/rust/commit/7b7c63cb7732e5ad5eace294b1c7c2f92beef4a2"}, {"sha": "6cdb8257dd5b567589e56ed2ddf3655fe7f4f4e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cdb8257dd5b567589e56ed2ddf3655fe7f4f4e3", "html_url": "https://github.com/rust-lang/rust/commit/6cdb8257dd5b567589e56ed2ddf3655fe7f4f4e3"}], "stats": {"total": 87, "additions": 87, "deletions": 0}, "files": [{"sha": "0349678b07b22a8f4629a3851fbd53789c744ea7", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b6e03c464a0020f44a9e89af9e043fdb47889bfc/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e03c464a0020f44a9e89af9e043fdb47889bfc/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=b6e03c464a0020f44a9e89af9e043fdb47889bfc", "patch": "@@ -8,6 +8,7 @@ use crate::convert::Infallible;\n use crate::fmt;\n use crate::intrinsics;\n use crate::mem;\n+use crate::ops::{BitOr, BitOrAssign};\n use crate::str::FromStr;\n \n // Used because the `?` operator is not allowed in a const context.\n@@ -110,6 +111,57 @@ assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", s\n                 }\n             }\n \n+            #[stable(feature = \"nonzero_bitor\", since = \"1.43.0\")]\n+            impl BitOr for $Ty {\n+                type Output = Self;\n+                #[inline]\n+                fn bitor(self, rhs: Self) -> Self::Output {\n+                    // Safety: since `self` and `rhs` are both nonzero, the\n+                    // result of the bitwise-or will be nonzero.\n+                    unsafe { $Ty::new_unchecked(self.get() | rhs.get()) }\n+                }\n+            }\n+\n+            #[stable(feature = \"nonzero_bitor\", since = \"1.43.0\")]\n+            impl BitOr<$Int> for $Ty {\n+                type Output = Self;\n+                #[inline]\n+                fn bitor(self, rhs: $Int) -> Self::Output {\n+                    // Safety: since `self` is nonzero, the result of the\n+                    // bitwise-or will be nonzero regardless of the value of\n+                    // `rhs`.\n+                    unsafe { $Ty::new_unchecked(self.get() | rhs) }\n+                }\n+            }\n+\n+            #[stable(feature = \"nonzero_bitor\", since = \"1.43.0\")]\n+            impl BitOr<$Ty> for $Int {\n+                type Output = $Ty;\n+                #[inline]\n+                fn bitor(self, rhs: $Ty) -> Self::Output {\n+                    // Safety: since `rhs` is nonzero, the result of the\n+                    // bitwise-or will be nonzero regardless of the value of\n+                    // `self`.\n+                    unsafe { $Ty::new_unchecked(self | rhs.get()) }\n+                }\n+            }\n+\n+            #[stable(feature = \"nonzero_bitor\", since = \"1.43.0\")]\n+            impl BitOrAssign for $Ty {\n+                #[inline]\n+                fn bitor_assign(&mut self, rhs: Self) {\n+                    *self = *self | rhs;\n+                }\n+            }\n+\n+            #[stable(feature = \"nonzero_bitor\", since = \"1.43.0\")]\n+            impl BitOrAssign<$Int> for $Ty {\n+                #[inline]\n+                fn bitor_assign(&mut self, rhs: $Int) {\n+                    *self = *self | rhs;\n+                }\n+            }\n+\n             impl_nonzero_fmt! {\n                 #[$stability] (Debug, Display, Binary, Octal, LowerHex, UpperHex) for $Ty\n             }"}, {"sha": "0227a66b8633a704137287e33ca8486b01dcade7", "filename": "src/libcore/tests/nonzero.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b6e03c464a0020f44a9e89af9e043fdb47889bfc/src%2Flibcore%2Ftests%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e03c464a0020f44a9e89af9e043fdb47889bfc/src%2Flibcore%2Ftests%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnonzero.rs?ref=b6e03c464a0020f44a9e89af9e043fdb47889bfc", "patch": "@@ -141,3 +141,38 @@ fn test_from_str() {\n         Some(IntErrorKind::Overflow)\n     );\n }\n+\n+#[test]\n+fn test_nonzero_bitor() {\n+    let nz_alt = NonZeroU8::new(0b1010_1010).unwrap();\n+    let nz_low = NonZeroU8::new(0b0000_1111).unwrap();\n+\n+    let both_nz: NonZeroU8 = nz_alt | nz_low;\n+    assert_eq!(both_nz.get(), 0b1010_1111);\n+\n+    let rhs_int: NonZeroU8 = nz_low | 0b1100_0000u8;\n+    assert_eq!(rhs_int.get(), 0b1100_1111);\n+\n+    let rhs_zero: NonZeroU8 = nz_alt | 0u8;\n+    assert_eq!(rhs_zero.get(), 0b1010_1010);\n+\n+    let lhs_int: NonZeroU8 = 0b0110_0110u8 | nz_alt;\n+    assert_eq!(lhs_int.get(), 0b1110_1110);\n+\n+    let lhs_zero: NonZeroU8 = 0u8 | nz_low;\n+    assert_eq!(lhs_zero.get(), 0b0000_1111);\n+}\n+\n+#[test]\n+fn test_nonzero_bitor_assign() {\n+    let mut target = NonZeroU8::new(0b1010_1010).unwrap();\n+\n+    target |= NonZeroU8::new(0b0000_1111).unwrap();\n+    assert_eq!(target.get(), 0b1010_1111);\n+\n+    target |= 0b0001_0000;\n+    assert_eq!(target.get(), 0b1011_1111);\n+\n+    target |= 0;\n+    assert_eq!(target.get(), 0b1011_1111);\n+}"}]}