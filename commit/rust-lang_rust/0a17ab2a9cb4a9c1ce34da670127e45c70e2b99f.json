{"sha": "0a17ab2a9cb4a9c1ce34da670127e45c70e2b99f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhMTdhYjJhOWNiNGE5YzFjZTM0ZGE2NzAxMjdlNDVjNzBlMmI5OWY=", "commit": {"author": {"name": "Andrew Paseltiner", "email": "apaseltiner@gmail.com", "date": "2013-01-07T19:30:34Z"}, "committer": {"name": "Andrew Paseltiner", "email": "apaseltiner@gmail.com", "date": "2013-01-07T22:22:01Z"}, "message": "fmt: replace parse_* structural records with struct Parsed<T>", "tree": {"sha": "2e85df46a0b09c20f00994c1db16846cab96f5f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e85df46a0b09c20f00994c1db16846cab96f5f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a17ab2a9cb4a9c1ce34da670127e45c70e2b99f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a17ab2a9cb4a9c1ce34da670127e45c70e2b99f", "html_url": "https://github.com/rust-lang/rust/commit/0a17ab2a9cb4a9c1ce34da670127e45c70e2b99f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a17ab2a9cb4a9c1ce34da670127e45c70e2b99f/comments", "author": {"login": "apasel422", "id": 8644784, "node_id": "MDQ6VXNlcjg2NDQ3ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/8644784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apasel422", "html_url": "https://github.com/apasel422", "followers_url": "https://api.github.com/users/apasel422/followers", "following_url": "https://api.github.com/users/apasel422/following{/other_user}", "gists_url": "https://api.github.com/users/apasel422/gists{/gist_id}", "starred_url": "https://api.github.com/users/apasel422/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apasel422/subscriptions", "organizations_url": "https://api.github.com/users/apasel422/orgs", "repos_url": "https://api.github.com/users/apasel422/repos", "events_url": "https://api.github.com/users/apasel422/events{/privacy}", "received_events_url": "https://api.github.com/users/apasel422/received_events", "type": "User", "site_admin": false}, "committer": {"login": "apasel422", "id": 8644784, "node_id": "MDQ6VXNlcjg2NDQ3ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/8644784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apasel422", "html_url": "https://github.com/apasel422", "followers_url": "https://api.github.com/users/apasel422/followers", "following_url": "https://api.github.com/users/apasel422/following{/other_user}", "gists_url": "https://api.github.com/users/apasel422/gists{/gist_id}", "starred_url": "https://api.github.com/users/apasel422/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apasel422/subscriptions", "organizations_url": "https://api.github.com/users/apasel422/orgs", "repos_url": "https://api.github.com/users/apasel422/repos", "events_url": "https://api.github.com/users/apasel422/events{/privacy}", "received_events_url": "https://api.github.com/users/apasel422/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a2a8975bc92b0ebae90d7d9a0cfffec08ec5cf4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a2a8975bc92b0ebae90d7d9a0cfffec08ec5cf4", "html_url": "https://github.com/rust-lang/rust/commit/1a2a8975bc92b0ebae90d7d9a0cfffec08ec5cf4"}], "stats": {"total": 91, "additions": 51, "deletions": 40}, "files": [{"sha": "98cd9910f50a009adaf52aef2a1a94b7a0a2187e", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 51, "deletions": 40, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/0a17ab2a9cb4a9c1ce34da670127e45c70e2b99f/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a17ab2a9cb4a9c1ce34da670127e45c70e2b99f/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=0a17ab2a9cb4a9c1ce34da670127e45c70e2b99f", "patch": "@@ -129,6 +129,17 @@ pub mod ct {\n         CountImplied,\n     }\n \n+    struct Parsed<T> {\n+        val: T,\n+        next: uint\n+    }\n+\n+    impl<T> Parsed<T> {\n+        static pure fn new(val: T, next: uint) -> Parsed<T> {\n+            Parsed { val: val, next: next }\n+        }\n+    }\n+\n     // A formatted conversion from an expression to a string\n     pub struct Conv\n         {param: Option<uint>,\n@@ -169,7 +180,7 @@ pub mod ct {\n                 } else {\n                     buf = flush_buf(move buf, &mut pieces);\n                     let rs = parse_conversion(s, i, lim, err);\n-                    pieces.push(copy rs.piece);\n+                    pieces.push(copy rs.val);\n                     i = rs.next;\n                 }\n             } else { buf += curr; i += size; }\n@@ -178,7 +189,7 @@ pub mod ct {\n         move pieces\n     }\n     pub fn peek_num(s: &str, i: uint, lim: uint) ->\n-       Option<{num: uint, next: uint}> {\n+       Option<Parsed<uint>> {\n         let mut j = i;\n         let mut accum = 0u;\n         let mut found = false;\n@@ -194,54 +205,54 @@ pub mod ct {\n             }\n         }\n         if found {\n-            Some({num: accum, next: j})\n+            Some(Parsed::new(accum, j))\n         } else {\n             None\n         }\n     }\n     pub fn parse_conversion(s: &str, i: uint, lim: uint,\n                             err: ErrorFn) ->\n-       {piece: Piece, next: uint} {\n+       Parsed<Piece> {\n         let parm = parse_parameter(s, i, lim);\n         let flags = parse_flags(s, parm.next, lim);\n         let width = parse_count(s, flags.next, lim);\n         let prec = parse_precision(s, width.next, lim);\n         let ty = parse_type(s, prec.next, lim, err);\n-        return {piece:\n-                 PieceConv(Conv {param: parm.param,\n-                             flags: copy flags.flags,\n-                             width: width.count,\n-                             precision: prec.count,\n-                             ty: ty.ty}),\n-             next: ty.next};\n+        return Parsed::new(\n+                 PieceConv(Conv {param: parm.val,\n+                             flags: copy flags.val,\n+                             width: width.val,\n+                             precision: prec.val,\n+                             ty: ty.val}),\n+             ty.next);\n     }\n     pub fn parse_parameter(s: &str, i: uint, lim: uint) ->\n-       {param: Option<uint>, next: uint} {\n-        if i >= lim { return {param: None, next: i}; }\n+       Parsed<Option<uint>> {\n+        if i >= lim { return Parsed::new(None, i); }\n         let num = peek_num(s, i, lim);\n         return match num {\n-              None => {param: None, next: i},\n+              None => Parsed::new(None, i),\n               Some(t) => {\n-                let n = t.num;\n+                let n = t.val;\n                 let j = t.next;\n                 if j < lim && s[j] == '$' as u8 {\n-                    {param: Some(n), next: j + 1}\n-                } else { {param: None, next: i} }\n+                    Parsed::new(Some(n), j + 1)\n+                } else { Parsed::new(None, i) }\n               }\n             };\n     }\n     pub fn parse_flags(s: &str, i: uint, lim: uint) ->\n-       {flags: ~[Flag], next: uint} {\n+       Parsed<~[Flag]> {\n         let noflags: ~[Flag] = ~[];\n-        if i >= lim { return {flags: move noflags, next: i}; }\n+        if i >= lim { return Parsed::new(move noflags, i); }\n \n         fn more(f: Flag, s: &str, i: uint, lim: uint) ->\n-           {flags: ~[Flag], next: uint} {\n+           Parsed<~[Flag]> {\n             let next = parse_flags(s, i + 1u, lim);\n-            let rest = copy next.flags;\n+            let rest = copy next.val;\n             let j = next.next;\n             let curr: ~[Flag] = ~[f];\n-            return {flags: vec::append(move curr, rest), next: j};\n+            return Parsed::new(vec::append(move curr, rest), j);\n         }\n         // Unfortunate, but because s is borrowed, can't use a closure\n      //   fn more(f: Flag, s: &str) { more_(f, s, i, lim); }\n@@ -256,48 +267,48 @@ pub mod ct {\n                 more(FlagSignAlways, s, i, lim)\n             } else if f == '#' as u8 {\n                 more(FlagAlternate, s, i, lim)\n-            } else { {flags: move noflags, next: i} };\n+            } else { Parsed::new(move noflags, i) };\n     }\n         pub fn parse_count(s: &str, i: uint, lim: uint)\n-        -> {count: Count, next: uint} {\n+        -> Parsed<Count> {\n         return if i >= lim {\n-                {count: CountImplied, next: i}\n+                Parsed::new(CountImplied, i)\n             } else if s[i] == '*' as u8 {\n                 let param = parse_parameter(s, i + 1, lim);\n                 let j = param.next;\n-                match param.param {\n-                  None => {count: CountIsNextParam, next: j},\n-                  Some(n) => {count: CountIsParam(n), next: j}\n+                match param.val {\n+                  None => Parsed::new(CountIsNextParam, j),\n+                  Some(n) => Parsed::new(CountIsParam(n), j)\n                 }\n             } else {\n                 let num = peek_num(s, i, lim);\n                 match num {\n-                  None => {count: CountImplied, next: i},\n-                  Some(num) => {\n-                    count: CountIs(num.num),\n-                    next: num.next\n-                  }\n+                  None => Parsed::new(CountImplied, i),\n+                  Some(num) => Parsed::new(\n+                    CountIs(num.val),\n+                    num.next\n+                  )\n                 }\n             };\n     }\n     pub fn parse_precision(s: &str, i: uint, lim: uint) ->\n-       {count: Count, next: uint} {\n+       Parsed<Count> {\n         return if i >= lim {\n-                {count: CountImplied, next: i}\n+                Parsed::new(CountImplied, i)\n             } else if s[i] == '.' as u8 {\n                 let count = parse_count(s, i + 1u, lim);\n \n \n                 // If there were no digits specified, i.e. the precision\n                 // was \".\", then the precision is 0\n-                match count.count {\n-                  CountImplied => {count: CountIs(0), next: count.next},\n+                match count.val {\n+                  CountImplied => Parsed::new(CountIs(0), count.next),\n                   _ => count\n                 }\n-            } else { {count: CountImplied, next: i} };\n+            } else { Parsed::new(CountImplied, i) };\n     }\n     pub fn parse_type(s: &str, i: uint, lim: uint, err: ErrorFn) ->\n-       {ty: Ty, next: uint} {\n+       Parsed<Ty> {\n         if i >= lim { err(~\"missing type in conversion\"); }\n         let tstr = str::slice(s, i, i+1u);\n         // FIXME (#2249): Do we really want two signed types here?\n@@ -326,7 +337,7 @@ pub mod ct {\n             } else if tstr == ~\"?\" {\n                 TyPoly\n             } else { err(~\"unknown type in conversion: \" + tstr) };\n-        return {ty: t, next: i + 1u};\n+        return Parsed::new(t, i + 1u);\n     }\n }\n "}]}