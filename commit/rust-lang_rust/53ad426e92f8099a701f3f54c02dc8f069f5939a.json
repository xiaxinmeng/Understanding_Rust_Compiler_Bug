{"sha": "53ad426e92f8099a701f3f54c02dc8f069f5939a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzYWQ0MjZlOTJmODA5OWE3MDFmM2Y1NGMwMmRjOGYwNjlmNTkzOWE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-16T07:16:13Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-11T16:11:40Z"}, "message": "syntax: Move the AST from @T to Gc<T>", "tree": {"sha": "cef835fc4f6319f12bf1c47c90682bdbcf17afac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cef835fc4f6319f12bf1c47c90682bdbcf17afac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53ad426e92f8099a701f3f54c02dc8f069f5939a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53ad426e92f8099a701f3f54c02dc8f069f5939a", "html_url": "https://github.com/rust-lang/rust/commit/53ad426e92f8099a701f3f54c02dc8f069f5939a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53ad426e92f8099a701f3f54c02dc8f069f5939a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "531ed3d599000de2517cba102c83fe44a1f1e252", "url": "https://api.github.com/repos/rust-lang/rust/commits/531ed3d599000de2517cba102c83fe44a1f1e252", "html_url": "https://github.com/rust-lang/rust/commit/531ed3d599000de2517cba102c83fe44a1f1e252"}], "stats": {"total": 2445, "additions": 1278, "deletions": 1167}, "files": [{"sha": "7c1e82a2a6f7272ddcf68bec50661e84ddee7ad3", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 74, "deletions": 73, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -21,15 +21,16 @@ use std::fmt;\n use std::fmt::Show;\n use std::option::Option;\n use std::rc::Rc;\n+use std::gc::Gc;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n /// A pointer abstraction. FIXME(eddyb) #10676 use Rc<T> in the future.\n-pub type P<T> = @T;\n+pub type P<T> = Gc<T>;\n \n #[allow(non_snake_case_functions)]\n /// Construct a P<T> from a T value.\n pub fn P<T: 'static>(value: T) -> P<T> {\n-    @value\n+    box(GC) value\n }\n \n // FIXME #6993: in librustc, uses of \"ident\" should be replaced\n@@ -217,7 +218,7 @@ pub enum DefRegion {\n \n // The set of MetaItems that define the compilation environment of the crate,\n // used to drive conditional compilation\n-pub type CrateConfig = Vec<@MetaItem> ;\n+pub type CrateConfig = Vec<Gc<MetaItem>>;\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Crate {\n@@ -232,7 +233,7 @@ pub type MetaItem = Spanned<MetaItem_>;\n #[deriving(Clone, Encodable, Decodable, Eq, Hash)]\n pub enum MetaItem_ {\n     MetaWord(InternedString),\n-    MetaList(InternedString, Vec<@MetaItem> ),\n+    MetaList(InternedString, Vec<Gc<MetaItem>>),\n     MetaNameValue(InternedString, Lit),\n }\n \n@@ -264,8 +265,8 @@ impl PartialEq for MetaItem_ {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Block {\n     pub view_items: Vec<ViewItem>,\n-    pub stmts: Vec<@Stmt>,\n-    pub expr: Option<@Expr>,\n+    pub stmts: Vec<Gc<Stmt>>,\n+    pub expr: Option<Gc<Expr>>,\n     pub id: NodeId,\n     pub rules: BlockCheckMode,\n     pub span: Span,\n@@ -281,7 +282,7 @@ pub struct Pat {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct FieldPat {\n     pub ident: Ident,\n-    pub pat: @Pat,\n+    pub pat: Gc<Pat>,\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n@@ -301,18 +302,18 @@ pub enum Pat_ {\n     // which it is. The resolver determines this, and\n     // records this pattern's NodeId in an auxiliary\n     // set (of \"pat_idents that refer to nullary enums\")\n-    PatIdent(BindingMode, Path, Option<@Pat>),\n-    PatEnum(Path, Option<Vec<@Pat> >), /* \"none\" means a * pattern where\n+    PatIdent(BindingMode, Path, Option<Gc<Pat>>),\n+    PatEnum(Path, Option<Vec<Gc<Pat>>>), /* \"none\" means a * pattern where\n                                      * we don't bind the fields to names */\n-    PatStruct(Path, Vec<FieldPat> , bool),\n-    PatTup(Vec<@Pat> ),\n-    PatBox(@Pat),\n-    PatRegion(@Pat), // reference pattern\n-    PatLit(@Expr),\n-    PatRange(@Expr, @Expr),\n+    PatStruct(Path, Vec<FieldPat>, bool),\n+    PatTup(Vec<Gc<Pat>>),\n+    PatBox(Gc<Pat>),\n+    PatRegion(Gc<Pat>), // reference pattern\n+    PatLit(Gc<Expr>),\n+    PatRange(Gc<Expr>, Gc<Expr>),\n     // [a, b, ..i, y, z] is represented as\n     // PatVec(~[a, b], Some(i), ~[y, z])\n-    PatVec(Vec<@Pat> , Option<@Pat>, Vec<@Pat> ),\n+    PatVec(Vec<Gc<Pat>>, Option<Gc<Pat>>, Vec<Gc<Pat>>),\n     PatMac(Mac),\n }\n \n@@ -365,13 +366,13 @@ pub type Stmt = Spanned<Stmt_>;\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum Stmt_ {\n     // could be an item or a local (let) binding:\n-    StmtDecl(@Decl, NodeId),\n+    StmtDecl(Gc<Decl>, NodeId),\n \n     // expr without trailing semi-colon (must have unit type):\n-    StmtExpr(@Expr, NodeId),\n+    StmtExpr(Gc<Expr>, NodeId),\n \n     // expr with trailing semi-colon (may have any type):\n-    StmtSemi(@Expr, NodeId),\n+    StmtSemi(Gc<Expr>, NodeId),\n \n     // bool: is there a trailing sem-colon?\n     StmtMac(Mac, bool),\n@@ -391,8 +392,8 @@ pub enum LocalSource {\n #[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Local {\n     pub ty: P<Ty>,\n-    pub pat: @Pat,\n-    pub init: Option<@Expr>,\n+    pub pat: Gc<Pat>,\n+    pub init: Option<Gc<Expr>>,\n     pub id: NodeId,\n     pub span: Span,\n     pub source: LocalSource,\n@@ -403,23 +404,23 @@ pub type Decl = Spanned<Decl_>;\n #[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum Decl_ {\n     // a local (let) binding:\n-    DeclLocal(@Local),\n+    DeclLocal(Gc<Local>),\n     // an item binding:\n-    DeclItem(@Item),\n+    DeclItem(Gc<Item>),\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Arm {\n     pub attrs: Vec<Attribute>,\n-    pub pats: Vec<@Pat>,\n-    pub guard: Option<@Expr>,\n-    pub body: @Expr,\n+    pub pats: Vec<Gc<Pat>>,\n+    pub guard: Option<Gc<Expr>>,\n+    pub body: Gc<Expr>,\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Field {\n     pub ident: SpannedIdent,\n-    pub expr: @Expr,\n+    pub expr: Gc<Expr>,\n     pub span: Span,\n }\n \n@@ -446,56 +447,56 @@ pub struct Expr {\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum Expr_ {\n-    ExprVstore(@Expr, ExprVstore),\n+    ExprVstore(Gc<Expr>, ExprVstore),\n     // First expr is the place; second expr is the value.\n-    ExprBox(@Expr, @Expr),\n-    ExprVec(Vec<@Expr>),\n-    ExprCall(@Expr, Vec<@Expr>),\n-    ExprMethodCall(SpannedIdent, Vec<P<Ty>>, Vec<@Expr>),\n-    ExprTup(Vec<@Expr>),\n-    ExprBinary(BinOp, @Expr, @Expr),\n-    ExprUnary(UnOp, @Expr),\n-    ExprLit(@Lit),\n-    ExprCast(@Expr, P<Ty>),\n-    ExprIf(@Expr, P<Block>, Option<@Expr>),\n-    ExprWhile(@Expr, P<Block>),\n+    ExprBox(Gc<Expr>, Gc<Expr>),\n+    ExprVec(Vec<Gc<Expr>>),\n+    ExprCall(Gc<Expr>, Vec<Gc<Expr>>),\n+    ExprMethodCall(SpannedIdent, Vec<P<Ty>>, Vec<Gc<Expr>>),\n+    ExprTup(Vec<Gc<Expr>>),\n+    ExprBinary(BinOp, Gc<Expr>, Gc<Expr>),\n+    ExprUnary(UnOp, Gc<Expr>),\n+    ExprLit(Gc<Lit>),\n+    ExprCast(Gc<Expr>, P<Ty>),\n+    ExprIf(Gc<Expr>, P<Block>, Option<Gc<Expr>>),\n+    ExprWhile(Gc<Expr>, P<Block>),\n     // FIXME #6993: change to Option<Name>\n-    ExprForLoop(@Pat, @Expr, P<Block>, Option<Ident>),\n+    ExprForLoop(Gc<Pat>, Gc<Expr>, P<Block>, Option<Ident>),\n     // Conditionless loop (can be exited with break, cont, or ret)\n     // FIXME #6993: change to Option<Name>\n     ExprLoop(P<Block>, Option<Ident>),\n-    ExprMatch(@Expr, Vec<Arm>),\n+    ExprMatch(Gc<Expr>, Vec<Arm>),\n     ExprFnBlock(P<FnDecl>, P<Block>),\n     ExprProc(P<FnDecl>, P<Block>),\n     ExprBlock(P<Block>),\n \n-    ExprAssign(@Expr, @Expr),\n-    ExprAssignOp(BinOp, @Expr, @Expr),\n-    ExprField(@Expr, Ident, Vec<P<Ty>>),\n-    ExprIndex(@Expr, @Expr),\n+    ExprAssign(Gc<Expr>, Gc<Expr>),\n+    ExprAssignOp(BinOp, Gc<Expr>, Gc<Expr>),\n+    ExprField(Gc<Expr>, Ident, Vec<P<Ty>>),\n+    ExprIndex(Gc<Expr>, Gc<Expr>),\n \n     /// Expression that looks like a \"name\". For example,\n     /// `std::slice::from_elem::<uint>` is an ExprPath that's the \"name\" part\n     /// of a function call.\n     ExprPath(Path),\n \n-    ExprAddrOf(Mutability, @Expr),\n+    ExprAddrOf(Mutability, Gc<Expr>),\n     ExprBreak(Option<Ident>),\n     ExprAgain(Option<Ident>),\n-    ExprRet(Option<@Expr>),\n+    ExprRet(Option<Gc<Expr>>),\n \n     ExprInlineAsm(InlineAsm),\n \n     ExprMac(Mac),\n \n     // A struct literal expression.\n-    ExprStruct(Path, Vec<Field> , Option<@Expr> /* base */),\n+    ExprStruct(Path, Vec<Field> , Option<Gc<Expr>> /* base */),\n \n     // A vector literal constructed from one repeated element.\n-    ExprRepeat(@Expr /* element */, @Expr /* count */),\n+    ExprRepeat(Gc<Expr> /* element */, Gc<Expr> /* count */),\n \n     // No-op: used solely so we can pretty-print faithfully\n-    ExprParen(@Expr)\n+    ExprParen(Gc<Expr>)\n }\n \n // When the main rust parser encounters a syntax-extension invocation, it\n@@ -667,7 +668,7 @@ pub struct TypeMethod {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum TraitMethod {\n     Required(TypeMethod),\n-    Provided(@Method),\n+    Provided(Gc<Method>),\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n@@ -782,16 +783,16 @@ pub enum Ty_ {\n     TyBox(P<Ty>),\n     TyUniq(P<Ty>),\n     TyVec(P<Ty>),\n-    TyFixedLengthVec(P<Ty>, @Expr),\n+    TyFixedLengthVec(P<Ty>, Gc<Expr>),\n     TyPtr(MutTy),\n     TyRptr(Option<Lifetime>, MutTy),\n-    TyClosure(@ClosureTy, Option<Lifetime>),\n-    TyProc(@ClosureTy),\n-    TyBareFn(@BareFnTy),\n-    TyUnboxedFn(@UnboxedFnTy),\n+    TyClosure(Gc<ClosureTy>, Option<Lifetime>),\n+    TyProc(Gc<ClosureTy>),\n+    TyBareFn(Gc<BareFnTy>),\n+    TyUnboxedFn(Gc<UnboxedFnTy>),\n     TyTup(Vec<P<Ty>> ),\n     TyPath(Path, Option<OwnedSlice<TyParamBound>>, NodeId), // for #7264; see above\n-    TyTypeof(@Expr),\n+    TyTypeof(Gc<Expr>),\n     // TyInfer means the type should be inferred instead of it having been\n     // specified. This can appear anywhere in a type.\n     TyInfer,\n@@ -808,8 +809,8 @@ pub struct InlineAsm {\n     pub asm: InternedString,\n     pub asm_str_style: StrStyle,\n     pub clobbers: InternedString,\n-    pub inputs: Vec<(InternedString, @Expr)>,\n-    pub outputs: Vec<(InternedString, @Expr)>,\n+    pub inputs: Vec<(InternedString, Gc<Expr>)>,\n+    pub outputs: Vec<(InternedString, Gc<Expr>)>,\n     pub volatile: bool,\n     pub alignstack: bool,\n     pub dialect: AsmDialect\n@@ -818,7 +819,7 @@ pub struct InlineAsm {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Arg {\n     pub ty: P<Ty>,\n-    pub pat: @Pat,\n+    pub pat: Gc<Pat>,\n     pub id: NodeId,\n }\n \n@@ -832,7 +833,7 @@ impl Arg {\n                 node: TyInfer,\n                 span: DUMMY_SP,\n             }),\n-            pat: @Pat {\n+            pat: box(GC) Pat {\n                 id: DUMMY_NODE_ID,\n                 node: PatIdent(BindByValue(mutability), path, None),\n                 span: span\n@@ -903,14 +904,14 @@ pub struct Mod {\n     /// to the last token in the external file.\n     pub inner: Span,\n     pub view_items: Vec<ViewItem>,\n-    pub items: Vec<@Item>,\n+    pub items: Vec<Gc<Item>>,\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct ForeignMod {\n     pub abi: Abi,\n     pub view_items: Vec<ViewItem>,\n-    pub items: Vec<@ForeignItem>,\n+    pub items: Vec<Gc<ForeignItem>>,\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n@@ -922,7 +923,7 @@ pub struct VariantArg {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum VariantKind {\n     TupleVariantKind(Vec<VariantArg>),\n-    StructVariantKind(@StructDef),\n+    StructVariantKind(Gc<StructDef>),\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n@@ -936,7 +937,7 @@ pub struct Variant_ {\n     pub attrs: Vec<Attribute>,\n     pub kind: VariantKind,\n     pub id: NodeId,\n-    pub disr_expr: Option<@Expr>,\n+    pub disr_expr: Option<Gc<Expr>>,\n     pub vis: Visibility,\n }\n \n@@ -984,7 +985,7 @@ pub enum ViewItem_ {\n     // (containing arbitrary characters) from which to fetch the crate sources\n     // For example, extern crate whatever = \"github.com/mozilla/rust\"\n     ViewItemExternCrate(Ident, Option<(InternedString,StrStyle)>, NodeId),\n-    ViewItemUse(@ViewPath),\n+    ViewItemUse(Gc<ViewPath>),\n }\n \n // Meta-data associated with an item\n@@ -1007,7 +1008,7 @@ pub struct AttrId(pub uint);\n pub struct Attribute_ {\n     pub id: AttrId,\n     pub style: AttrStyle,\n-    pub value: @MetaItem,\n+    pub value: Gc<MetaItem>,\n     pub is_sugared_doc: bool,\n }\n \n@@ -1105,18 +1106,18 @@ pub struct Item {\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum Item_ {\n-    ItemStatic(P<Ty>, Mutability, @Expr),\n+    ItemStatic(P<Ty>, Mutability, Gc<Expr>),\n     ItemFn(P<FnDecl>, FnStyle, Abi, Generics, P<Block>),\n     ItemMod(Mod),\n     ItemForeignMod(ForeignMod),\n     ItemTy(P<Ty>, Generics),\n     ItemEnum(EnumDef, Generics),\n-    ItemStruct(@StructDef, Generics),\n+    ItemStruct(Gc<StructDef>, Generics),\n     ItemTrait(Generics, Sized, Vec<TraitRef> , Vec<TraitMethod> ),\n     ItemImpl(Generics,\n              Option<TraitRef>, // (optional) trait this impl implements\n              P<Ty>, // self\n-             Vec<@Method> ),\n+             Vec<Gc<Method>>),\n     // a macro invocation (which includes macro definition)\n     ItemMac(Mac),\n }\n@@ -1142,9 +1143,9 @@ pub enum ForeignItem_ {\n // that we trans.\n #[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum InlinedItem {\n-    IIItem(@Item),\n-    IIMethod(DefId /* impl id */, bool /* is provided */, @Method),\n-    IIForeign(@ForeignItem),\n+    IIItem(Gc<Item>),\n+    IIMethod(DefId /* impl id */, bool /* is provided */, Gc<Method>),\n+    IIForeign(Gc<ForeignItem>),\n }\n \n #[cfg(test)]"}, {"sha": "d78c9c2edc34a671d0d859d4840173c02452f717", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 56, "deletions": 55, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -20,9 +20,9 @@ use util::small_vector::SmallVector;\n \n use std::cell::RefCell;\n use std::fmt;\n+use std::gc::Gc;\n use std::iter;\n use std::slice;\n-use std::string::String;\n \n #[deriving(Clone, PartialEq)]\n pub enum PathElem {\n@@ -94,22 +94,22 @@ pub fn path_to_str<PI: Iterator<PathElem>>(mut path: PI) -> String {\n \n #[deriving(Clone)]\n pub enum Node {\n-    NodeItem(@Item),\n-    NodeForeignItem(@ForeignItem),\n-    NodeTraitMethod(@TraitMethod),\n-    NodeMethod(@Method),\n+    NodeItem(Gc<Item>),\n+    NodeForeignItem(Gc<ForeignItem>),\n+    NodeTraitMethod(Gc<TraitMethod>),\n+    NodeMethod(Gc<Method>),\n     NodeVariant(P<Variant>),\n-    NodeExpr(@Expr),\n-    NodeStmt(@Stmt),\n-    NodeArg(@Pat),\n-    NodeLocal(@Pat),\n-    NodePat(@Pat),\n+    NodeExpr(Gc<Expr>),\n+    NodeStmt(Gc<Stmt>),\n+    NodeArg(Gc<Pat>),\n+    NodeLocal(Gc<Pat>),\n+    NodePat(Gc<Pat>),\n     NodeBlock(P<Block>),\n \n     /// NodeStructCtor represents a tuple struct.\n-    NodeStructCtor(@StructDef),\n+    NodeStructCtor(Gc<StructDef>),\n \n-    NodeLifetime(@Lifetime),\n+    NodeLifetime(Gc<Lifetime>),\n }\n \n // The odd layout is to bring down the total size.\n@@ -119,19 +119,19 @@ enum MapEntry {\n     NotPresent,\n \n     // All the node types, with a parent ID.\n-    EntryItem(NodeId, @Item),\n-    EntryForeignItem(NodeId, @ForeignItem),\n-    EntryTraitMethod(NodeId, @TraitMethod),\n-    EntryMethod(NodeId, @Method),\n+    EntryItem(NodeId, Gc<Item>),\n+    EntryForeignItem(NodeId, Gc<ForeignItem>),\n+    EntryTraitMethod(NodeId, Gc<TraitMethod>),\n+    EntryMethod(NodeId, Gc<Method>),\n     EntryVariant(NodeId, P<Variant>),\n-    EntryExpr(NodeId, @Expr),\n-    EntryStmt(NodeId, @Stmt),\n-    EntryArg(NodeId, @Pat),\n-    EntryLocal(NodeId, @Pat),\n-    EntryPat(NodeId, @Pat),\n+    EntryExpr(NodeId, Gc<Expr>),\n+    EntryStmt(NodeId, Gc<Stmt>),\n+    EntryArg(NodeId, Gc<Pat>),\n+    EntryLocal(NodeId, Gc<Pat>),\n+    EntryPat(NodeId, Gc<Pat>),\n     EntryBlock(NodeId, P<Block>),\n-    EntryStructCtor(NodeId, @StructDef),\n-    EntryLifetime(NodeId, @Lifetime),\n+    EntryStructCtor(NodeId, Gc<StructDef>),\n+    EntryLifetime(NodeId, Gc<Lifetime>),\n \n     // Roots for node trees.\n     RootCrate,\n@@ -262,14 +262,14 @@ impl Map {\n         }\n     }\n \n-    pub fn expect_item(&self, id: NodeId) -> @Item {\n+    pub fn expect_item(&self, id: NodeId) -> Gc<Item> {\n         match self.find(id) {\n             Some(NodeItem(item)) => item,\n             _ => fail!(\"expected item, found {}\", self.node_to_str(id))\n         }\n     }\n \n-    pub fn expect_struct(&self, id: NodeId) -> @StructDef {\n+    pub fn expect_struct(&self, id: NodeId) -> Gc<StructDef> {\n         match self.find(id) {\n             Some(NodeItem(i)) => {\n                 match i.node {\n@@ -294,7 +294,7 @@ impl Map {\n         }\n     }\n \n-    pub fn expect_foreign_item(&self, id: NodeId) -> @ForeignItem {\n+    pub fn expect_foreign_item(&self, id: NodeId) -> Gc<ForeignItem> {\n         match self.find(id) {\n             Some(NodeForeignItem(item)) => item,\n             _ => fail!(\"expected foreign item, found {}\", self.node_to_str(id))\n@@ -457,11 +457,11 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n         self.fold_ops.new_span(span)\n     }\n \n-    fn fold_item(&mut self, i: @Item) -> SmallVector<@Item> {\n+    fn fold_item(&mut self, i: Gc<Item>) -> SmallVector<Gc<Item>> {\n         let parent = self.parent;\n         self.parent = DUMMY_NODE_ID;\n \n-        let i = fold::noop_fold_item(i, self).expect_one(\"expected one item\");\n+        let i = fold::noop_fold_item(&*i, self).expect_one(\"expected one item\");\n         assert_eq!(self.parent, i.id);\n \n         match i.node {\n@@ -476,16 +476,17 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n                 }\n             }\n             ItemForeignMod(ref nm) => {\n-                for &nitem in nm.items.iter() {\n-                    self.insert(nitem.id, EntryForeignItem(self.parent, nitem));\n+                for nitem in nm.items.iter() {\n+                    self.insert(nitem.id, EntryForeignItem(self.parent,\n+                                                           nitem.clone()));\n                 }\n             }\n-            ItemStruct(struct_def, _) => {\n+            ItemStruct(ref struct_def, _) => {\n                 // If this is a tuple-like struct, register the constructor.\n                 match struct_def.ctor_id {\n                     Some(ctor_id) => {\n                         self.insert(ctor_id, EntryStructCtor(self.parent,\n-                                                             struct_def));\n+                                                             struct_def.clone()));\n                     }\n                     None => {}\n                 }\n@@ -499,11 +500,11 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n                     match *tm {\n                         Required(ref m) => {\n                             self.insert(m.id, EntryTraitMethod(self.parent,\n-                                                               @(*tm).clone()));\n+                                                               box(GC) (*tm).clone()));\n                         }\n                         Provided(m) => {\n                             self.insert(m.id, EntryTraitMethod(self.parent,\n-                                                               @Provided(m)));\n+                                                               box(GC) Provided(m)));\n                         }\n                     }\n                 }\n@@ -517,7 +518,7 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n         SmallVector::one(i)\n     }\n \n-    fn fold_pat(&mut self, pat: @Pat) -> @Pat {\n+    fn fold_pat(&mut self, pat: Gc<Pat>) -> Gc<Pat> {\n         let pat = fold::noop_fold_pat(pat, self);\n         match pat.node {\n             PatIdent(..) => {\n@@ -532,17 +533,17 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n         pat\n     }\n \n-    fn fold_expr(&mut self, expr: @Expr) -> @Expr {\n+    fn fold_expr(&mut self, expr: Gc<Expr>) -> Gc<Expr> {\n         let expr = fold::noop_fold_expr(expr, self);\n \n         self.insert(expr.id, EntryExpr(self.parent, expr));\n \n         expr\n     }\n \n-    fn fold_stmt(&mut self, stmt: &Stmt) -> SmallVector<@Stmt> {\n+    fn fold_stmt(&mut self, stmt: &Stmt) -> SmallVector<Gc<Stmt>> {\n         let stmt = fold::noop_fold_stmt(stmt, self).expect_one(\"expected one statement\");\n-        self.insert(ast_util::stmt_id(stmt), EntryStmt(self.parent, stmt));\n+        self.insert(ast_util::stmt_id(&*stmt), EntryStmt(self.parent, stmt));\n         SmallVector::one(stmt)\n     }\n \n@@ -555,10 +556,10 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n         m\n     }\n \n-    fn fold_method(&mut self, m: @Method) -> @Method {\n+    fn fold_method(&mut self, m: Gc<Method>) -> Gc<Method> {\n         let parent = self.parent;\n         self.parent = DUMMY_NODE_ID;\n-        let m = fold::noop_fold_method(m, self);\n+        let m = fold::noop_fold_method(&*m, self);\n         assert_eq!(self.parent, m.id);\n         self.parent = parent;\n         m\n@@ -580,7 +581,7 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n \n     fn fold_lifetime(&mut self, lifetime: &Lifetime) -> Lifetime {\n         let lifetime = fold::noop_fold_lifetime(lifetime, self);\n-        self.insert(lifetime.id, EntryLifetime(self.parent, @lifetime));\n+        self.insert(lifetime.id, EntryLifetime(self.parent, box(GC) lifetime));\n         lifetime\n     }\n }\n@@ -643,7 +644,7 @@ pub fn map_decoded_item<F: FoldOps>(map: &Map,\n         IIItem(_) => {}\n         IIMethod(impl_did, is_provided, m) => {\n             let entry = if is_provided {\n-                EntryTraitMethod(cx.parent, @Provided(m))\n+                EntryTraitMethod(cx.parent, box(GC) Provided(m))\n             } else {\n                 EntryMethod(cx.parent, m)\n             };\n@@ -701,36 +702,36 @@ fn node_id_to_str(map: &Map, id: NodeId) -> String {\n                     token::get_ident(variant.node.name),\n                     map.path_to_str(id), id)).to_string()\n         }\n-        Some(NodeExpr(expr)) => {\n+        Some(NodeExpr(ref expr)) => {\n             (format!(\"expr {} (id={})\",\n-                    pprust::expr_to_str(expr), id)).to_string()\n+                    pprust::expr_to_str(&**expr), id)).to_string()\n         }\n-        Some(NodeStmt(stmt)) => {\n+        Some(NodeStmt(ref stmt)) => {\n             (format!(\"stmt {} (id={})\",\n-                    pprust::stmt_to_str(stmt), id)).to_string()\n+                    pprust::stmt_to_str(&**stmt), id)).to_string()\n         }\n-        Some(NodeArg(pat)) => {\n+        Some(NodeArg(ref pat)) => {\n             (format!(\"arg {} (id={})\",\n-                    pprust::pat_to_str(pat), id)).to_string()\n+                    pprust::pat_to_str(&**pat), id)).to_string()\n         }\n-        Some(NodeLocal(pat)) => {\n+        Some(NodeLocal(ref pat)) => {\n             (format!(\"local {} (id={})\",\n-                    pprust::pat_to_str(pat), id)).to_string()\n+                    pprust::pat_to_str(&**pat), id)).to_string()\n         }\n-        Some(NodePat(pat)) => {\n-            (format!(\"pat {} (id={})\", pprust::pat_to_str(pat), id)).to_string()\n+        Some(NodePat(ref pat)) => {\n+            (format!(\"pat {} (id={})\", pprust::pat_to_str(&**pat), id)).to_string()\n         }\n-        Some(NodeBlock(block)) => {\n+        Some(NodeBlock(ref block)) => {\n             (format!(\"block {} (id={})\",\n-                    pprust::block_to_str(block), id)).to_string()\n+                    pprust::block_to_str(&**block), id)).to_string()\n         }\n         Some(NodeStructCtor(_)) => {\n             (format!(\"struct_ctor {} (id={})\",\n                     map.path_to_str(id), id)).to_string()\n         }\n         Some(NodeLifetime(ref l)) => {\n             (format!(\"lifetime {} (id={})\",\n-                    pprust::lifetime_to_str(*l), id)).to_string()\n+                    pprust::lifetime_to_str(&**l), id)).to_string()\n         }\n         None => {\n             (format!(\"unknown node (id={})\", id)).to_string()"}, {"sha": "fcddbfa9a89b957b499f3830cb7e7cd77b3fcb23", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -21,7 +21,7 @@ use visit;\n \n use std::cell::Cell;\n use std::cmp;\n-use std::string::String;\n+use std::gc::Gc;\n use std::u32;\n \n pub fn path_name_i(idents: &[Ident]) -> String {\n@@ -93,15 +93,15 @@ pub fn is_shift_binop(b: BinOp) -> bool {\n \n pub fn unop_to_str(op: UnOp) -> &'static str {\n     match op {\n-      UnBox => \"@\",\n+      UnBox => \"box(GC) \",\n       UnUniq => \"box() \",\n       UnDeref => \"*\",\n       UnNot => \"!\",\n       UnNeg => \"-\",\n     }\n }\n \n-pub fn is_path(e: @Expr) -> bool {\n+pub fn is_path(e: Gc<Expr>) -> bool {\n     return match e.node { ExprPath(_) => true, _ => false };\n }\n \n@@ -181,11 +181,11 @@ pub fn float_ty_to_str(t: FloatTy) -> String {\n     }\n }\n \n-pub fn is_call_expr(e: @Expr) -> bool {\n+pub fn is_call_expr(e: Gc<Expr>) -> bool {\n     match e.node { ExprCall(..) => true, _ => false }\n }\n \n-pub fn block_from_expr(e: @Expr) -> P<Block> {\n+pub fn block_from_expr(e: Gc<Expr>) -> P<Block> {\n     P(Block {\n         view_items: Vec::new(),\n         stmts: Vec::new(),\n@@ -210,8 +210,8 @@ pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n     }\n }\n \n-pub fn ident_to_pat(id: NodeId, s: Span, i: Ident) -> @Pat {\n-    @ast::Pat { id: id,\n+pub fn ident_to_pat(id: NodeId, s: Span, i: Ident) -> Gc<Pat> {\n+    box(GC) ast::Pat { id: id,\n                 node: PatIdent(BindByValue(MutImmutable), ident_to_path(s, i), None),\n                 span: s }\n }\n@@ -229,7 +229,7 @@ pub fn is_unguarded(a: &Arm) -> bool {\n     }\n }\n \n-pub fn unguarded_pat(a: &Arm) -> Option<Vec<@Pat> > {\n+pub fn unguarded_pat(a: &Arm) -> Option<Vec<Gc<Pat>>> {\n     if is_unguarded(a) {\n         Some(/* FIXME (#2543) */ a.pats.clone())\n     } else {\n@@ -254,7 +254,7 @@ pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: &Ty) -> Ident {\n     token::gensym_ident(pretty.as_slice())\n }\n \n-pub fn public_methods(ms: Vec<@Method> ) -> Vec<@Method> {\n+pub fn public_methods(ms: Vec<Gc<Method>> ) -> Vec<Gc<Method>> {\n     ms.move_iter().filter(|m| {\n         match m.vis {\n             Public => true,\n@@ -285,7 +285,7 @@ pub fn trait_method_to_ty_method(method: &TraitMethod) -> TypeMethod {\n }\n \n pub fn split_trait_methods(trait_methods: &[TraitMethod])\n-    -> (Vec<TypeMethod> , Vec<@Method> ) {\n+    -> (Vec<TypeMethod> , Vec<Gc<Method>> ) {\n     let mut reqd = Vec::new();\n     let mut provd = Vec::new();\n     for trt_method in trait_methods.iter() {\n@@ -610,7 +610,7 @@ pub fn compute_id_range_for_fn_body(fk: &visit::FnKind,\n     visitor.result.get()\n }\n \n-pub fn is_item_impl(item: @ast::Item) -> bool {\n+pub fn is_item_impl(item: Gc<ast::Item>) -> bool {\n     match item.node {\n         ItemImpl(..) => true,\n         _            => false\n@@ -623,20 +623,20 @@ pub fn walk_pat(pat: &Pat, it: |&Pat| -> bool) -> bool {\n     }\n \n     match pat.node {\n-        PatIdent(_, _, Some(p)) => walk_pat(p, it),\n+        PatIdent(_, _, Some(ref p)) => walk_pat(&**p, it),\n         PatStruct(_, ref fields, _) => {\n-            fields.iter().advance(|f| walk_pat(f.pat, |p| it(p)))\n+            fields.iter().advance(|f| walk_pat(&*f.pat, |p| it(p)))\n         }\n         PatEnum(_, Some(ref s)) | PatTup(ref s) => {\n-            s.iter().advance(|&p| walk_pat(p, |p| it(p)))\n+            s.iter().advance(|p| walk_pat(&**p, |p| it(p)))\n         }\n-        PatBox(s) | PatRegion(s) => {\n-            walk_pat(s, it)\n+        PatBox(ref s) | PatRegion(ref s) => {\n+            walk_pat(&**s, it)\n         }\n         PatVec(ref before, ref slice, ref after) => {\n-            before.iter().advance(|&p| walk_pat(p, |p| it(p))) &&\n-                slice.iter().advance(|&p| walk_pat(p, |p| it(p))) &&\n-                after.iter().advance(|&p| walk_pat(p, |p| it(p)))\n+            before.iter().advance(|p| walk_pat(&**p, |p| it(p))) &&\n+                slice.iter().advance(|p| walk_pat(&**p, |p| it(p))) &&\n+                after.iter().advance(|p| walk_pat(&**p, |p| it(p)))\n         }\n         PatMac(_) => fail!(\"attempted to analyze unexpanded pattern\"),\n         PatWild | PatWildMulti | PatLit(_) | PatRange(_, _) | PatIdent(_, _, _) |\n@@ -685,7 +685,7 @@ pub fn struct_def_is_tuple_like(struct_def: &ast::StructDef) -> bool {\n \n /// Returns true if the given pattern consists solely of an identifier\n /// and false otherwise.\n-pub fn pat_is_ident(pat: @ast::Pat) -> bool {\n+pub fn pat_is_ident(pat: Gc<ast::Pat>) -> bool {\n     match pat.node {\n         ast::PatIdent(..) => true,\n         _ => false,\n@@ -720,7 +720,7 @@ pub fn segments_name_eq(a : &[ast::PathSegment], b : &[ast::PathSegment]) -> boo\n }\n \n // Returns true if this literal is a string and false otherwise.\n-pub fn lit_is_str(lit: @Lit) -> bool {\n+pub fn lit_is_str(lit: Gc<Lit>) -> bool {\n     match lit.node {\n         LitStr(..) => true,\n         _ => false,"}, {"sha": "83f1326c656213b47fe95bbf6348016b68a34947", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -22,6 +22,7 @@ use crateid::CrateId;\n \n use std::collections::HashSet;\n use std::collections::BitvSet;\n+use std::gc::Gc;\n \n local_data_key!(used_attrs: BitvSet)\n \n@@ -52,7 +53,7 @@ pub trait AttrMetaMethods {\n      */\n     fn value_str(&self) -> Option<InternedString>;\n     /// Gets a list of inner meta items from a list MetaItem type.\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [@MetaItem]>;\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [Gc<MetaItem>]>;\n }\n \n impl AttrMetaMethods for Attribute {\n@@ -67,7 +68,7 @@ impl AttrMetaMethods for Attribute {\n     fn value_str(&self) -> Option<InternedString> {\n         self.meta().value_str()\n     }\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [@MetaItem]> {\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [Gc<MetaItem>]> {\n         self.node.value.meta_item_list()\n     }\n }\n@@ -93,7 +94,7 @@ impl AttrMetaMethods for MetaItem {\n         }\n     }\n \n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [@MetaItem]> {\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [Gc<MetaItem>]> {\n         match self.node {\n             MetaList(_, ref l) => Some(l.as_slice()),\n             _ => None\n@@ -102,23 +103,23 @@ impl AttrMetaMethods for MetaItem {\n }\n \n // Annoying, but required to get test_cfg to work\n-impl AttrMetaMethods for @MetaItem {\n+impl AttrMetaMethods for Gc<MetaItem> {\n     fn name(&self) -> InternedString { (**self).name() }\n     fn value_str(&self) -> Option<InternedString> { (**self).value_str() }\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [@MetaItem]> {\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [Gc<MetaItem>]> {\n         (**self).meta_item_list()\n     }\n }\n \n \n pub trait AttributeMethods {\n-    fn meta(&self) -> @MetaItem;\n+    fn meta(&self) -> Gc<MetaItem>;\n     fn desugar_doc(&self) -> Attribute;\n }\n \n impl AttributeMethods for Attribute {\n     /// Extract the MetaItem from inside this Attribute.\n-    fn meta(&self) -> @MetaItem {\n+    fn meta(&self) -> Gc<MetaItem> {\n         self.node.value\n     }\n \n@@ -146,22 +147,23 @@ impl AttributeMethods for Attribute {\n /* Constructors */\n \n pub fn mk_name_value_item_str(name: InternedString, value: InternedString)\n-                              -> @MetaItem {\n+                              -> Gc<MetaItem> {\n     let value_lit = dummy_spanned(ast::LitStr(value, ast::CookedStr));\n     mk_name_value_item(name, value_lit)\n }\n \n pub fn mk_name_value_item(name: InternedString, value: ast::Lit)\n-                          -> @MetaItem {\n-    @dummy_spanned(MetaNameValue(name, value))\n+                          -> Gc<MetaItem> {\n+    box(GC) dummy_spanned(MetaNameValue(name, value))\n }\n \n-pub fn mk_list_item(name: InternedString, items: Vec<@MetaItem> ) -> @MetaItem {\n-    @dummy_spanned(MetaList(name, items))\n+pub fn mk_list_item(name: InternedString,\n+                    items: Vec<Gc<MetaItem>>) -> Gc<MetaItem> {\n+    box(GC) dummy_spanned(MetaList(name, items))\n }\n \n-pub fn mk_word_item(name: InternedString) -> @MetaItem {\n-    @dummy_spanned(MetaWord(name))\n+pub fn mk_word_item(name: InternedString) -> Gc<MetaItem> {\n+    box(GC) dummy_spanned(MetaWord(name))\n }\n \n local_data_key!(next_attr_id: uint)\n@@ -173,7 +175,7 @@ pub fn mk_attr_id() -> AttrId {\n }\n \n /// Returns an inner attribute with the given value.\n-pub fn mk_attr_inner(id: AttrId, item: @MetaItem) -> Attribute {\n+pub fn mk_attr_inner(id: AttrId, item: Gc<MetaItem>) -> Attribute {\n     dummy_spanned(Attribute_ {\n         id: id,\n         style: ast::AttrInner,\n@@ -183,7 +185,7 @@ pub fn mk_attr_inner(id: AttrId, item: @MetaItem) -> Attribute {\n }\n \n /// Returns an outer attribute with the given value.\n-pub fn mk_attr_outer(id: AttrId, item: @MetaItem) -> Attribute {\n+pub fn mk_attr_outer(id: AttrId, item: Gc<MetaItem>) -> Attribute {\n     dummy_spanned(Attribute_ {\n         id: id,\n         style: ast::AttrOuter,\n@@ -200,7 +202,7 @@ pub fn mk_sugared_doc_attr(id: AttrId, text: InternedString, lo: BytePos,\n     let attr = Attribute_ {\n         id: id,\n         style: style,\n-        value: @spanned(lo, hi, MetaNameValue(InternedString::new(\"doc\"),\n+        value: box(GC) spanned(lo, hi, MetaNameValue(InternedString::new(\"doc\"),\n                                               lit)),\n         is_sugared_doc: true\n     };\n@@ -211,8 +213,8 @@ pub fn mk_sugared_doc_attr(id: AttrId, text: InternedString, lo: BytePos,\n /// Check if `needle` occurs in `haystack` by a structural\n /// comparison. This is slightly subtle, and relies on ignoring the\n /// span included in the `==` comparison a plain MetaItem.\n-pub fn contains(haystack: &[@ast::MetaItem],\n-                needle: @ast::MetaItem) -> bool {\n+pub fn contains(haystack: &[Gc<ast::MetaItem>],\n+                needle: Gc<ast::MetaItem>) -> bool {\n     debug!(\"attr::contains (name={})\", needle.name());\n     haystack.iter().any(|item| {\n         debug!(\"  testing: {}\", item.name());\n@@ -235,7 +237,7 @@ pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str)\n         .and_then(|at| at.value_str())\n }\n \n-pub fn last_meta_item_value_str_by_name(items: &[@MetaItem], name: &str)\n+pub fn last_meta_item_value_str_by_name(items: &[Gc<MetaItem>], name: &str)\n                                      -> Option<InternedString> {\n     items.iter()\n          .rev()\n@@ -245,20 +247,20 @@ pub fn last_meta_item_value_str_by_name(items: &[@MetaItem], name: &str)\n \n /* Higher-level applications */\n \n-pub fn sort_meta_items(items: &[@MetaItem]) -> Vec<@MetaItem> {\n+pub fn sort_meta_items(items: &[Gc<MetaItem>]) -> Vec<Gc<MetaItem>> {\n     // This is sort of stupid here, but we need to sort by\n     // human-readable strings.\n     let mut v = items.iter()\n         .map(|&mi| (mi.name(), mi))\n-        .collect::<Vec<(InternedString, @MetaItem)> >();\n+        .collect::<Vec<(InternedString, Gc<MetaItem>)> >();\n \n     v.sort_by(|&(ref a, _), &(ref b, _)| a.cmp(b));\n \n     // There doesn't seem to be a more optimal way to do this\n     v.move_iter().map(|(_, m)| {\n         match m.node {\n             MetaList(ref n, ref mis) => {\n-                @Spanned {\n+                box(GC) Spanned {\n                     node: MetaList((*n).clone(),\n                                    sort_meta_items(mis.as_slice())),\n                     .. /*bad*/ (*m).clone()\n@@ -273,7 +275,7 @@ pub fn sort_meta_items(items: &[@MetaItem]) -> Vec<@MetaItem> {\n  * From a list of crate attributes get only the meta_items that affect crate\n  * linkage\n  */\n-pub fn find_linkage_metas(attrs: &[Attribute]) -> Vec<@MetaItem> {\n+pub fn find_linkage_metas(attrs: &[Attribute]) -> Vec<Gc<MetaItem>> {\n     let mut result = Vec::new();\n     for attr in attrs.iter().filter(|at| at.check_name(\"link\")) {\n         match attr.meta().node {\n@@ -330,7 +332,7 @@ pub fn find_inline_attr(attrs: &[Attribute]) -> InlineAttr {\n /// test_cfg(`[foo=\"a\", bar]`, `[cfg(bar, foo=\"a\")]`) == true\n /// test_cfg(`[foo=\"a\", bar]`, `[cfg(bar, foo=\"b\")]`) == false\n pub fn test_cfg<AM: AttrMetaMethods, It: Iterator<AM>>\n-    (cfg: &[@MetaItem], mut metas: It) -> bool {\n+    (cfg: &[Gc<MetaItem>], mut metas: It) -> bool {\n     // having no #[cfg(...)] attributes counts as matching.\n     let mut no_cfgs = true;\n \n@@ -422,7 +424,7 @@ pub fn find_stability(attrs: &[Attribute]) -> Option<Stability> {\n     })\n }\n \n-pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[@MetaItem]) {\n+pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[Gc<MetaItem>]) {\n     let mut set = HashSet::new();\n     for meta in metas.iter() {\n         let name = meta.name();"}, {"sha": "d9e3e4e941d2b208ed64f207c3bb40a827c59257", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -23,8 +23,8 @@ source code snippets, etc.\n \n use serialize::{Encodable, Decodable, Encoder, Decoder};\n use std::cell::RefCell;\n+use std::gc::Gc;\n use std::rc::Rc;\n-use std::string::String;\n \n pub trait Pos {\n     fn from_uint(n: uint) -> Self;\n@@ -91,7 +91,7 @@ pub struct Span {\n     pub hi: BytePos,\n     /// Information about where the macro came from, if this piece of\n     /// code was created by a macro expansion.\n-    pub expn_info: Option<@ExpnInfo>\n+    pub expn_info: Option<Gc<ExpnInfo>>\n }\n \n pub static DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), expn_info: None };"}, {"sha": "665d9da664d6409cdfa0f35984f1fc82162ce5e1", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -20,7 +20,6 @@ use parse;\n use parse::token::InternedString;\n use parse::token;\n \n-\n enum State {\n     Asm,\n     Outputs,\n@@ -214,7 +213,7 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                                                  out));\n     }\n \n-    MacExpr::new(@ast::Expr {\n+    MacExpr::new(box(GC) ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprInlineAsm(ast::InlineAsm {\n             asm: token::intern_and_get_ident(asm.get()),"}, {"sha": "f9a9e276eb02036df5d865744169c7470eb55872", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -20,6 +20,7 @@ use parse::token::{InternedString, intern, str_to_ident};\n use util::small_vector::SmallVector;\n \n use std::collections::HashMap;\n+use std::gc::Gc;\n \n // new-style macro! tt code:\n //\n@@ -35,10 +36,10 @@ pub struct MacroDef {\n }\n \n pub type ItemDecorator =\n-    fn(&mut ExtCtxt, Span, @ast::MetaItem, @ast::Item, |@ast::Item|);\n+    fn(&mut ExtCtxt, Span, Gc<ast::MetaItem>, Gc<ast::Item>, |Gc<ast::Item>|);\n \n pub type ItemModifier =\n-    fn(&mut ExtCtxt, Span, @ast::MetaItem, @ast::Item) -> @ast::Item;\n+    fn(&mut ExtCtxt, Span, Gc<ast::MetaItem>, Gc<ast::Item>) -> Gc<ast::Item>;\n \n pub struct BasicMacroExpander {\n     pub expander: MacroExpanderFn,\n@@ -104,11 +105,11 @@ pub trait MacResult {\n         None\n     }\n     /// Create an expression.\n-    fn make_expr(&self) -> Option<@ast::Expr> {\n+    fn make_expr(&self) -> Option<Gc<ast::Expr>> {\n         None\n     }\n     /// Create zero or more items.\n-    fn make_items(&self) -> Option<SmallVector<@ast::Item>> {\n+    fn make_items(&self) -> Option<SmallVector<Gc<ast::Item>>> {\n         None\n     }\n     /// Create a pattern.\n@@ -120,23 +121,23 @@ pub trait MacResult {\n     ///\n     /// By default this attempts to create an expression statement,\n     /// returning None if that fails.\n-    fn make_stmt(&self) -> Option<@ast::Stmt> {\n+    fn make_stmt(&self) -> Option<Gc<ast::Stmt>> {\n         self.make_expr()\n-            .map(|e| @codemap::respan(e.span, ast::StmtExpr(e, ast::DUMMY_NODE_ID)))\n+            .map(|e| box(GC) codemap::respan(e.span, ast::StmtExpr(e, ast::DUMMY_NODE_ID)))\n     }\n }\n \n /// A convenience type for macros that return a single expression.\n pub struct MacExpr {\n-    e: @ast::Expr\n+    e: Gc<ast::Expr>,\n }\n impl MacExpr {\n-    pub fn new(e: @ast::Expr) -> Box<MacResult> {\n+    pub fn new(e: Gc<ast::Expr>) -> Box<MacResult> {\n         box MacExpr { e: e } as Box<MacResult>\n     }\n }\n impl MacResult for MacExpr {\n-    fn make_expr(&self) -> Option<@ast::Expr> {\n+    fn make_expr(&self) -> Option<Gc<ast::Expr>> {\n         Some(self.e)\n     }\n }\n@@ -156,22 +157,22 @@ impl MacResult for MacPat {\n }\n /// A convenience type for macros that return a single item.\n pub struct MacItem {\n-    i: @ast::Item\n+    i: Gc<ast::Item>\n }\n impl MacItem {\n-    pub fn new(i: @ast::Item) -> Box<MacResult> {\n+    pub fn new(i: Gc<ast::Item>) -> Box<MacResult> {\n         box MacItem { i: i } as Box<MacResult>\n     }\n }\n impl MacResult for MacItem {\n-    fn make_items(&self) -> Option<SmallVector<@ast::Item>> {\n+    fn make_items(&self) -> Option<SmallVector<Gc<ast::Item>>> {\n         Some(SmallVector::one(self.i))\n     }\n-    fn make_stmt(&self) -> Option<@ast::Stmt> {\n-        Some(@codemap::respan(\n+    fn make_stmt(&self) -> Option<Gc<ast::Stmt>> {\n+        Some(box(GC) codemap::respan(\n             self.i.span,\n             ast::StmtDecl(\n-                @codemap::respan(self.i.span, ast::DeclItem(self.i)),\n+                box(GC) codemap::respan(self.i.span, ast::DeclItem(self.i)),\n                 ast::DUMMY_NODE_ID)))\n     }\n }\n@@ -202,10 +203,10 @@ impl DummyResult {\n     }\n \n     /// A plain dummy expression.\n-    pub fn raw_expr(sp: Span) -> @ast::Expr {\n-        @ast::Expr {\n+    pub fn raw_expr(sp: Span) -> Gc<ast::Expr> {\n+        box(GC) ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n-            node: ast::ExprLit(@codemap::respan(sp, ast::LitNil)),\n+            node: ast::ExprLit(box(GC) codemap::respan(sp, ast::LitNil)),\n             span: sp,\n         }\n     }\n@@ -221,21 +222,21 @@ impl DummyResult {\n }\n \n impl MacResult for DummyResult {\n-    fn make_expr(&self) -> Option<@ast::Expr> {\n+    fn make_expr(&self) -> Option<Gc<ast::Expr>> {\n         Some(DummyResult::raw_expr(self.span))\n     }\n-    fn make_pat(&self) -> Option<@ast::Pat> {\n+    fn make_pat(&self) -> Option<Gc<ast::Pat>> {\n         Some(DummyResult::raw_pat(self.span))\n     }\n-    fn make_items(&self) -> Option<SmallVector<@ast::Item>> {\n+    fn make_items(&self) -> Option<SmallVector<Gc<ast::Item>>> {\n         if self.expr_only {\n             None\n         } else {\n             Some(SmallVector::zero())\n         }\n     }\n-    fn make_stmt(&self) -> Option<@ast::Stmt> {\n-        Some(@codemap::respan(self.span,\n+    fn make_stmt(&self) -> Option<Gc<ast::Stmt>> {\n+        Some(box(GC) codemap::respan(self.span,\n                               ast::StmtExpr(DummyResult::raw_expr(self.span),\n                                             ast::DUMMY_NODE_ID)))\n     }\n@@ -397,7 +398,7 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n pub struct ExtCtxt<'a> {\n     pub parse_sess: &'a parse::ParseSess,\n     pub cfg: ast::CrateConfig,\n-    pub backtrace: Option<@ExpnInfo>,\n+    pub backtrace: Option<Gc<ExpnInfo>>,\n     pub ecfg: expand::ExpansionConfig,\n \n     pub mod_path: Vec<ast::Ident> ,\n@@ -417,7 +418,7 @@ impl<'a> ExtCtxt<'a> {\n         }\n     }\n \n-    pub fn expand_expr(&mut self, mut e: @ast::Expr) -> @ast::Expr {\n+    pub fn expand_expr(&mut self, mut e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         loop {\n             match e.node {\n                 ast::ExprMac(..) => {\n@@ -442,7 +443,7 @@ impl<'a> ExtCtxt<'a> {\n         }\n     }\n     pub fn print_backtrace(&self) { }\n-    pub fn backtrace(&self) -> Option<@ExpnInfo> { self.backtrace }\n+    pub fn backtrace(&self) -> Option<Gc<ExpnInfo>> { self.backtrace }\n     pub fn mod_push(&mut self, i: ast::Ident) { self.mod_path.push(i); }\n     pub fn mod_pop(&mut self) { self.mod_path.pop().unwrap(); }\n     pub fn mod_path(&self) -> Vec<ast::Ident> {\n@@ -455,9 +456,9 @@ impl<'a> ExtCtxt<'a> {\n         match ei {\n             ExpnInfo {call_site: cs, callee: ref callee} => {\n                 self.backtrace =\n-                    Some(@ExpnInfo {\n+                    Some(box(GC) ExpnInfo {\n                         call_site: Span {lo: cs.lo, hi: cs.hi,\n-                                         expn_info: self.backtrace},\n+                                         expn_info: self.backtrace.clone()},\n                         callee: (*callee).clone()\n                     });\n             }\n@@ -528,7 +529,7 @@ impl<'a> ExtCtxt<'a> {\n /// Extract a string literal from the macro expanded version of `expr`,\n /// emitting `err_msg` if `expr` is not a string literal. This does not stop\n /// compilation on error, merely emits a non-fatal error and returns None.\n-pub fn expr_to_str(cx: &mut ExtCtxt, expr: @ast::Expr, err_msg: &str)\n+pub fn expr_to_str(cx: &mut ExtCtxt, expr: Gc<ast::Expr>, err_msg: &str)\n                    -> Option<(InternedString, ast::StrStyle)> {\n     // we want to be able to handle e.g. concat(\"foo\", \"bar\")\n     let expr = cx.expand_expr(expr);\n@@ -584,7 +585,7 @@ pub fn get_single_str_from_tts(cx: &ExtCtxt,\n /// parsing error, emit a non-fatal error and return None.\n pub fn get_exprs_from_tts(cx: &mut ExtCtxt,\n                           sp: Span,\n-                          tts: &[ast::TokenTree]) -> Option<Vec<@ast::Expr> > {\n+                          tts: &[ast::TokenTree]) -> Option<Vec<Gc<ast::Expr>>> {\n     let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n                                            cx.cfg(),\n                                            tts.iter()"}, {"sha": "148b653b61cb95019600262a8db90ba4637d2bfc", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 223, "deletions": 195, "changes": 418, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -21,6 +21,8 @@ use parse::token::special_idents;\n use parse::token::InternedString;\n use parse::token;\n \n+use std::gc::Gc;\n+\n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {\n     pub use ext;\n@@ -73,115 +75,129 @@ pub trait AstBuilder {\n     fn lifetime(&self, span: Span, ident: ast::Name) -> ast::Lifetime;\n \n     // statements\n-    fn stmt_expr(&self, expr: @ast::Expr) -> @ast::Stmt;\n-    fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident, ex: @ast::Expr) -> @ast::Stmt;\n+    fn stmt_expr(&self, expr: Gc<ast::Expr>) -> Gc<ast::Stmt>;\n+    fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident,\n+                ex: Gc<ast::Expr>) -> Gc<ast::Stmt>;\n     fn stmt_let_typed(&self,\n                       sp: Span,\n                       mutbl: bool,\n                       ident: ast::Ident,\n                       typ: P<ast::Ty>,\n-                      ex: @ast::Expr)\n-                      -> @ast::Stmt;\n+                      ex: Gc<ast::Expr>)\n+                      -> Gc<ast::Stmt>;\n \n     // blocks\n-    fn block(&self, span: Span, stmts: Vec<@ast::Stmt> , expr: Option<@ast::Expr>) -> P<ast::Block>;\n-    fn block_expr(&self, expr: @ast::Expr) -> P<ast::Block>;\n+    fn block(&self, span: Span, stmts: Vec<Gc<ast::Stmt>>,\n+             expr: Option<Gc<ast::Expr>>) -> P<ast::Block>;\n+    fn block_expr(&self, expr: Gc<ast::Expr>) -> P<ast::Block>;\n     fn block_all(&self, span: Span,\n                  view_items: Vec<ast::ViewItem> ,\n-                 stmts: Vec<@ast::Stmt> ,\n-                 expr: Option<@ast::Expr>) -> P<ast::Block>;\n+                 stmts: Vec<Gc<ast::Stmt>> ,\n+                 expr: Option<Gc<ast::Expr>>) -> P<ast::Block>;\n \n     // expressions\n-    fn expr(&self, span: Span, node: ast::Expr_) -> @ast::Expr;\n-    fn expr_path(&self, path: ast::Path) -> @ast::Expr;\n-    fn expr_ident(&self, span: Span, id: ast::Ident) -> @ast::Expr;\n+    fn expr(&self, span: Span, node: ast::Expr_) -> Gc<ast::Expr>;\n+    fn expr_path(&self, path: ast::Path) -> Gc<ast::Expr>;\n+    fn expr_ident(&self, span: Span, id: ast::Ident) -> Gc<ast::Expr>;\n \n-    fn expr_self(&self, span: Span) -> @ast::Expr;\n+    fn expr_self(&self, span: Span) -> Gc<ast::Expr>;\n     fn expr_binary(&self, sp: Span, op: ast::BinOp,\n-                   lhs: @ast::Expr, rhs: @ast::Expr) -> @ast::Expr;\n-    fn expr_deref(&self, sp: Span, e: @ast::Expr) -> @ast::Expr;\n-    fn expr_unary(&self, sp: Span, op: ast::UnOp, e: @ast::Expr) -> @ast::Expr;\n-\n-    fn expr_managed(&self, sp: Span, e: @ast::Expr) -> @ast::Expr;\n-    fn expr_addr_of(&self, sp: Span, e: @ast::Expr) -> @ast::Expr;\n-    fn expr_mut_addr_of(&self, sp: Span, e: @ast::Expr) -> @ast::Expr;\n-    fn expr_field_access(&self, span: Span, expr: @ast::Expr, ident: ast::Ident) -> @ast::Expr;\n-    fn expr_call(&self, span: Span, expr: @ast::Expr, args: Vec<@ast::Expr> ) -> @ast::Expr;\n-    fn expr_call_ident(&self, span: Span, id: ast::Ident, args: Vec<@ast::Expr> ) -> @ast::Expr;\n+                   lhs: Gc<ast::Expr>, rhs: Gc<ast::Expr>) -> Gc<ast::Expr>;\n+    fn expr_deref(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr>;\n+    fn expr_unary(&self, sp: Span, op: ast::UnOp, e: Gc<ast::Expr>) -> Gc<ast::Expr>;\n+\n+    fn expr_managed(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr>;\n+    fn expr_addr_of(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr>;\n+    fn expr_mut_addr_of(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr>;\n+    fn expr_field_access(&self, span: Span, expr: Gc<ast::Expr>,\n+                         ident: ast::Ident) -> Gc<ast::Expr>;\n+    fn expr_call(&self, span: Span, expr: Gc<ast::Expr>,\n+                 args: Vec<Gc<ast::Expr>>) -> Gc<ast::Expr>;\n+    fn expr_call_ident(&self, span: Span, id: ast::Ident,\n+                       args: Vec<Gc<ast::Expr>>) -> Gc<ast::Expr>;\n     fn expr_call_global(&self, sp: Span, fn_path: Vec<ast::Ident> ,\n-                        args: Vec<@ast::Expr> ) -> @ast::Expr;\n+                        args: Vec<Gc<ast::Expr>>) -> Gc<ast::Expr>;\n     fn expr_method_call(&self, span: Span,\n-                        expr: @ast::Expr, ident: ast::Ident,\n-                        args: Vec<@ast::Expr> ) -> @ast::Expr;\n-    fn expr_block(&self, b: P<ast::Block>) -> @ast::Expr;\n-    fn expr_cast(&self, sp: Span, expr: @ast::Expr, ty: P<ast::Ty>) -> @ast::Expr;\n-\n-    fn field_imm(&self, span: Span, name: Ident, e: @ast::Expr) -> ast::Field;\n-    fn expr_struct(&self, span: Span, path: ast::Path, fields: Vec<ast::Field> ) -> @ast::Expr;\n-    fn expr_struct_ident(&self, span: Span, id: ast::Ident, fields: Vec<ast::Field> ) -> @ast::Expr;\n-\n-    fn expr_lit(&self, sp: Span, lit: ast::Lit_) -> @ast::Expr;\n-\n-    fn expr_uint(&self, span: Span, i: uint) -> @ast::Expr;\n-    fn expr_int(&self, sp: Span, i: int) -> @ast::Expr;\n-    fn expr_u8(&self, sp: Span, u: u8) -> @ast::Expr;\n-    fn expr_bool(&self, sp: Span, value: bool) -> @ast::Expr;\n-\n-    fn expr_vstore(&self, sp: Span, expr: @ast::Expr, vst: ast::ExprVstore) -> @ast::Expr;\n-    fn expr_vec(&self, sp: Span, exprs: Vec<@ast::Expr> ) -> @ast::Expr;\n-    fn expr_vec_ng(&self, sp: Span) -> @ast::Expr;\n-    fn expr_vec_slice(&self, sp: Span, exprs: Vec<@ast::Expr> ) -> @ast::Expr;\n-    fn expr_str(&self, sp: Span, s: InternedString) -> @ast::Expr;\n-    fn expr_str_uniq(&self, sp: Span, s: InternedString) -> @ast::Expr;\n-\n-    fn expr_some(&self, sp: Span, expr: @ast::Expr) -> @ast::Expr;\n-    fn expr_none(&self, sp: Span) -> @ast::Expr;\n-\n-    fn expr_fail(&self, span: Span, msg: InternedString) -> @ast::Expr;\n-    fn expr_unreachable(&self, span: Span) -> @ast::Expr;\n-\n-    fn expr_ok(&self, span: Span, expr: @ast::Expr) -> @ast::Expr;\n-    fn expr_err(&self, span: Span, expr: @ast::Expr) -> @ast::Expr;\n-    fn expr_try(&self, span: Span, head: @ast::Expr) -> @ast::Expr;\n-\n-    fn pat(&self, span: Span, pat: ast::Pat_) -> @ast::Pat;\n-    fn pat_wild(&self, span: Span) -> @ast::Pat;\n-    fn pat_lit(&self, span: Span, expr: @ast::Expr) -> @ast::Pat;\n-    fn pat_ident(&self, span: Span, ident: ast::Ident) -> @ast::Pat;\n+                        expr: Gc<ast::Expr>, ident: ast::Ident,\n+                        args: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr>;\n+    fn expr_block(&self, b: P<ast::Block>) -> Gc<ast::Expr>;\n+    fn expr_cast(&self, sp: Span, expr: Gc<ast::Expr>,\n+                 ty: P<ast::Ty>) -> Gc<ast::Expr>;\n+\n+    fn field_imm(&self, span: Span, name: Ident, e: Gc<ast::Expr>) -> ast::Field;\n+    fn expr_struct(&self, span: Span, path: ast::Path,\n+                   fields: Vec<ast::Field> ) -> Gc<ast::Expr>;\n+    fn expr_struct_ident(&self, span: Span, id: ast::Ident,\n+                         fields: Vec<ast::Field> ) -> Gc<ast::Expr>;\n+\n+    fn expr_lit(&self, sp: Span, lit: ast::Lit_) -> Gc<ast::Expr>;\n+\n+    fn expr_uint(&self, span: Span, i: uint) -> Gc<ast::Expr>;\n+    fn expr_int(&self, sp: Span, i: int) -> Gc<ast::Expr>;\n+    fn expr_u8(&self, sp: Span, u: u8) -> Gc<ast::Expr>;\n+    fn expr_bool(&self, sp: Span, value: bool) -> Gc<ast::Expr>;\n+\n+    fn expr_vstore(&self, sp: Span, expr: Gc<ast::Expr>, vst: ast::ExprVstore) -> Gc<ast::Expr>;\n+    fn expr_vec(&self, sp: Span, exprs: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr>;\n+    fn expr_vec_ng(&self, sp: Span) -> Gc<ast::Expr>;\n+    fn expr_vec_slice(&self, sp: Span, exprs: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr>;\n+    fn expr_str(&self, sp: Span, s: InternedString) -> Gc<ast::Expr>;\n+    fn expr_str_uniq(&self, sp: Span, s: InternedString) -> Gc<ast::Expr>;\n+\n+    fn expr_some(&self, sp: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr>;\n+    fn expr_none(&self, sp: Span) -> Gc<ast::Expr>;\n+\n+    fn expr_fail(&self, span: Span, msg: InternedString) -> Gc<ast::Expr>;\n+    fn expr_unreachable(&self, span: Span) -> Gc<ast::Expr>;\n+\n+    fn expr_ok(&self, span: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr>;\n+    fn expr_err(&self, span: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr>;\n+    fn expr_try(&self, span: Span, head: Gc<ast::Expr>) -> Gc<ast::Expr>;\n+\n+    fn pat(&self, span: Span, pat: ast::Pat_) -> Gc<ast::Pat>;\n+    fn pat_wild(&self, span: Span) -> Gc<ast::Pat>;\n+    fn pat_lit(&self, span: Span, expr: Gc<ast::Expr>) -> Gc<ast::Pat>;\n+    fn pat_ident(&self, span: Span, ident: ast::Ident) -> Gc<ast::Pat>;\n \n     fn pat_ident_binding_mode(&self,\n                               span: Span,\n                               ident: ast::Ident,\n-                              bm: ast::BindingMode) -> @ast::Pat;\n-    fn pat_enum(&self, span: Span, path: ast::Path, subpats: Vec<@ast::Pat> ) -> @ast::Pat;\n+                              bm: ast::BindingMode) -> Gc<ast::Pat>;\n+    fn pat_enum(&self, span: Span, path: ast::Path,\n+                subpats: Vec<Gc<ast::Pat>>) -> Gc<ast::Pat>;\n     fn pat_struct(&self, span: Span,\n-                  path: ast::Path, field_pats: Vec<ast::FieldPat> ) -> @ast::Pat;\n+                  path: ast::Path, field_pats: Vec<ast::FieldPat> ) -> Gc<ast::Pat>;\n \n-    fn arm(&self, span: Span, pats: Vec<@ast::Pat> , expr: @ast::Expr) -> ast::Arm;\n+    fn arm(&self, span: Span, pats: Vec<Gc<ast::Pat>> , expr: Gc<ast::Expr>) -> ast::Arm;\n     fn arm_unreachable(&self, span: Span) -> ast::Arm;\n \n-    fn expr_match(&self, span: Span, arg: @ast::Expr, arms: Vec<ast::Arm> ) -> @ast::Expr;\n+    fn expr_match(&self, span: Span, arg: Gc<ast::Expr>, arms: Vec<ast::Arm> ) -> Gc<ast::Expr>;\n     fn expr_if(&self, span: Span,\n-               cond: @ast::Expr, then: @ast::Expr, els: Option<@ast::Expr>) -> @ast::Expr;\n+               cond: Gc<ast::Expr>, then: Gc<ast::Expr>,\n+               els: Option<Gc<ast::Expr>>) -> Gc<ast::Expr>;\n \n     fn lambda_fn_decl(&self, span: Span,\n-                      fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> @ast::Expr;\n+                      fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> Gc<ast::Expr>;\n \n-    fn lambda(&self, span: Span, ids: Vec<ast::Ident> , blk: P<ast::Block>) -> @ast::Expr;\n-    fn lambda0(&self, span: Span, blk: P<ast::Block>) -> @ast::Expr;\n-    fn lambda1(&self, span: Span, blk: P<ast::Block>, ident: ast::Ident) -> @ast::Expr;\n+    fn lambda(&self, span: Span, ids: Vec<ast::Ident> , blk: P<ast::Block>) -> Gc<ast::Expr>;\n+    fn lambda0(&self, span: Span, blk: P<ast::Block>) -> Gc<ast::Expr>;\n+    fn lambda1(&self, span: Span, blk: P<ast::Block>, ident: ast::Ident) -> Gc<ast::Expr>;\n \n-    fn lambda_expr(&self, span: Span, ids: Vec<ast::Ident> , blk: @ast::Expr) -> @ast::Expr;\n-    fn lambda_expr_0(&self, span: Span, expr: @ast::Expr) -> @ast::Expr;\n-    fn lambda_expr_1(&self, span: Span, expr: @ast::Expr, ident: ast::Ident) -> @ast::Expr;\n+    fn lambda_expr(&self, span: Span, ids: Vec<ast::Ident> , blk: Gc<ast::Expr>) -> Gc<ast::Expr>;\n+    fn lambda_expr_0(&self, span: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr>;\n+    fn lambda_expr_1(&self, span: Span, expr: Gc<ast::Expr>, ident: ast::Ident) -> Gc<ast::Expr>;\n \n-    fn lambda_stmts(&self, span: Span, ids: Vec<ast::Ident> , blk: Vec<@ast::Stmt> ) -> @ast::Expr;\n-    fn lambda_stmts_0(&self, span: Span, stmts: Vec<@ast::Stmt> ) -> @ast::Expr;\n-    fn lambda_stmts_1(&self, span: Span, stmts: Vec<@ast::Stmt> , ident: ast::Ident) -> @ast::Expr;\n+    fn lambda_stmts(&self, span: Span, ids: Vec<ast::Ident>,\n+                    blk: Vec<Gc<ast::Stmt>>) -> Gc<ast::Expr>;\n+    fn lambda_stmts_0(&self, span: Span,\n+                      stmts: Vec<Gc<ast::Stmt>>) -> Gc<ast::Expr>;\n+    fn lambda_stmts_1(&self, span: Span,\n+                      stmts: Vec<Gc<ast::Stmt>>, ident: ast::Ident) -> Gc<ast::Expr>;\n \n     // items\n     fn item(&self, span: Span,\n-            name: Ident, attrs: Vec<ast::Attribute> , node: ast::Item_) -> @ast::Item;\n+            name: Ident, attrs: Vec<ast::Attribute>,\n+            node: ast::Item_) -> Gc<ast::Item>;\n \n     fn arg(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::Arg;\n     // FIXME unused self\n@@ -193,56 +209,59 @@ pub trait AstBuilder {\n                     inputs: Vec<ast::Arg> ,\n                     output: P<ast::Ty>,\n                     generics: Generics,\n-                    body: P<ast::Block>) -> @ast::Item;\n+                    body: P<ast::Block>) -> Gc<ast::Item>;\n     fn item_fn(&self,\n                span: Span,\n                name: Ident,\n                inputs: Vec<ast::Arg> ,\n                output: P<ast::Ty>,\n-               body: P<ast::Block>) -> @ast::Item;\n+               body: P<ast::Block>) -> Gc<ast::Item>;\n \n     fn variant(&self, span: Span, name: Ident, tys: Vec<P<ast::Ty>> ) -> ast::Variant;\n     fn item_enum_poly(&self,\n                       span: Span,\n                       name: Ident,\n                       enum_definition: ast::EnumDef,\n-                      generics: Generics) -> @ast::Item;\n-    fn item_enum(&self, span: Span, name: Ident, enum_def: ast::EnumDef) -> @ast::Item;\n+                      generics: Generics) -> Gc<ast::Item>;\n+    fn item_enum(&self, span: Span, name: Ident,\n+                 enum_def: ast::EnumDef) -> Gc<ast::Item>;\n \n     fn item_struct_poly(&self,\n                         span: Span,\n                         name: Ident,\n                         struct_def: ast::StructDef,\n-                        generics: Generics) -> @ast::Item;\n-    fn item_struct(&self, span: Span, name: Ident, struct_def: ast::StructDef) -> @ast::Item;\n+                        generics: Generics) -> Gc<ast::Item>;\n+    fn item_struct(&self, span: Span, name: Ident,\n+                   struct_def: ast::StructDef) -> Gc<ast::Item>;\n \n     fn item_mod(&self, span: Span, inner_span: Span,\n-                name: Ident, attrs: Vec<ast::Attribute> ,\n-                vi: Vec<ast::ViewItem> , items: Vec<@ast::Item> ) -> @ast::Item;\n+                name: Ident, attrs: Vec<ast::Attribute>,\n+                vi: Vec<ast::ViewItem>,\n+                items: Vec<Gc<ast::Item>>) -> Gc<ast::Item>;\n \n     fn item_ty_poly(&self,\n                     span: Span,\n                     name: Ident,\n                     ty: P<ast::Ty>,\n-                    generics: Generics) -> @ast::Item;\n-    fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> @ast::Item;\n+                    generics: Generics) -> Gc<ast::Item>;\n+    fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> Gc<ast::Item>;\n \n-    fn attribute(&self, sp: Span, mi: @ast::MetaItem) -> ast::Attribute;\n+    fn attribute(&self, sp: Span, mi: Gc<ast::MetaItem>) -> ast::Attribute;\n \n-    fn meta_word(&self, sp: Span, w: InternedString) -> @ast::MetaItem;\n+    fn meta_word(&self, sp: Span, w: InternedString) -> Gc<ast::MetaItem>;\n     fn meta_list(&self,\n                  sp: Span,\n                  name: InternedString,\n-                 mis: Vec<@ast::MetaItem> )\n-                 -> @ast::MetaItem;\n+                 mis: Vec<Gc<ast::MetaItem>>)\n+                 -> Gc<ast::MetaItem>;\n     fn meta_name_value(&self,\n                        sp: Span,\n                        name: InternedString,\n                        value: ast::Lit_)\n-                       -> @ast::MetaItem;\n+                       -> Gc<ast::MetaItem>;\n \n     fn view_use(&self, sp: Span,\n-                vis: ast::Visibility, vp: @ast::ViewPath) -> ast::ViewItem;\n+                vis: ast::Visibility, vp: Gc<ast::ViewPath>) -> ast::ViewItem;\n     fn view_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> ast::ViewItem;\n     fn view_use_simple_(&self, sp: Span, vis: ast::Visibility,\n                         ident: ast::Ident, path: ast::Path) -> ast::ViewItem;\n@@ -418,17 +437,18 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         ast::Lifetime { id: ast::DUMMY_NODE_ID, span: span, name: name }\n     }\n \n-    fn stmt_expr(&self, expr: @ast::Expr) -> @ast::Stmt {\n-        @respan(expr.span, ast::StmtSemi(expr, ast::DUMMY_NODE_ID))\n+    fn stmt_expr(&self, expr: Gc<ast::Expr>) -> Gc<ast::Stmt> {\n+        box(GC) respan(expr.span, ast::StmtSemi(expr, ast::DUMMY_NODE_ID))\n     }\n \n-    fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident, ex: @ast::Expr) -> @ast::Stmt {\n+    fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident,\n+                ex: Gc<ast::Expr>) -> Gc<ast::Stmt> {\n         let pat = if mutbl {\n             self.pat_ident_binding_mode(sp, ident, ast::BindByValue(ast::MutMutable))\n         } else {\n             self.pat_ident(sp, ident)\n         };\n-        let local = @ast::Local {\n+        let local = box(GC) ast::Local {\n             ty: self.ty_infer(sp),\n             pat: pat,\n             init: Some(ex),\n@@ -437,22 +457,22 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             source: ast::LocalLet,\n         };\n         let decl = respan(sp, ast::DeclLocal(local));\n-        @respan(sp, ast::StmtDecl(@decl, ast::DUMMY_NODE_ID))\n+        box(GC) respan(sp, ast::StmtDecl(box(GC) decl, ast::DUMMY_NODE_ID))\n     }\n \n     fn stmt_let_typed(&self,\n                       sp: Span,\n                       mutbl: bool,\n                       ident: ast::Ident,\n                       typ: P<ast::Ty>,\n-                      ex: @ast::Expr)\n-                      -> @ast::Stmt {\n+                      ex: Gc<ast::Expr>)\n+                      -> Gc<ast::Stmt> {\n         let pat = if mutbl {\n             self.pat_ident_binding_mode(sp, ident, ast::BindByValue(ast::MutMutable))\n         } else {\n             self.pat_ident(sp, ident)\n         };\n-        let local = @ast::Local {\n+        let local = box(GC) ast::Local {\n             ty: typ,\n             pat: pat,\n             init: Some(ex),\n@@ -461,21 +481,22 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             source: ast::LocalLet,\n         };\n         let decl = respan(sp, ast::DeclLocal(local));\n-        @respan(sp, ast::StmtDecl(@decl, ast::DUMMY_NODE_ID))\n+        box(GC) respan(sp, ast::StmtDecl(box(GC) decl, ast::DUMMY_NODE_ID))\n     }\n \n-    fn block(&self, span: Span, stmts: Vec<@ast::Stmt> , expr: Option<@Expr>) -> P<ast::Block> {\n+    fn block(&self, span: Span, stmts: Vec<Gc<ast::Stmt>>,\n+             expr: Option<Gc<Expr>>) -> P<ast::Block> {\n         self.block_all(span, Vec::new(), stmts, expr)\n     }\n \n-    fn block_expr(&self, expr: @ast::Expr) -> P<ast::Block> {\n+    fn block_expr(&self, expr: Gc<ast::Expr>) -> P<ast::Block> {\n         self.block_all(expr.span, Vec::new(), Vec::new(), Some(expr))\n     }\n     fn block_all(&self,\n                  span: Span,\n                  view_items: Vec<ast::ViewItem> ,\n-                 stmts: Vec<@ast::Stmt> ,\n-                 expr: Option<@ast::Expr>) -> P<ast::Block> {\n+                 stmts: Vec<Gc<ast::Stmt>>,\n+                 expr: Option<Gc<ast::Expr>>) -> P<ast::Block> {\n             P(ast::Block {\n                view_items: view_items,\n                stmts: stmts,\n@@ -486,147 +507,149 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             })\n     }\n \n-    fn expr(&self, span: Span, node: ast::Expr_) -> @ast::Expr {\n-        @ast::Expr {\n+    fn expr(&self, span: Span, node: ast::Expr_) -> Gc<ast::Expr> {\n+        box(GC) ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n             span: span,\n         }\n     }\n \n-    fn expr_path(&self, path: ast::Path) -> @ast::Expr {\n+    fn expr_path(&self, path: ast::Path) -> Gc<ast::Expr> {\n         self.expr(path.span, ast::ExprPath(path))\n     }\n \n-    fn expr_ident(&self, span: Span, id: ast::Ident) -> @ast::Expr {\n+    fn expr_ident(&self, span: Span, id: ast::Ident) -> Gc<ast::Expr> {\n         self.expr_path(self.path_ident(span, id))\n     }\n-    fn expr_self(&self, span: Span) -> @ast::Expr {\n+    fn expr_self(&self, span: Span) -> Gc<ast::Expr> {\n         self.expr_ident(span, special_idents::self_)\n     }\n \n     fn expr_binary(&self, sp: Span, op: ast::BinOp,\n-                   lhs: @ast::Expr, rhs: @ast::Expr) -> @ast::Expr {\n+                   lhs: Gc<ast::Expr>, rhs: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         self.expr(sp, ast::ExprBinary(op, lhs, rhs))\n     }\n \n-    fn expr_deref(&self, sp: Span, e: @ast::Expr) -> @ast::Expr {\n+    fn expr_deref(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         self.expr_unary(sp, ast::UnDeref, e)\n     }\n-    fn expr_unary(&self, sp: Span, op: ast::UnOp, e: @ast::Expr) -> @ast::Expr {\n+    fn expr_unary(&self, sp: Span, op: ast::UnOp, e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         self.expr(sp, ast::ExprUnary(op, e))\n     }\n \n-    fn expr_managed(&self, sp: Span, e: @ast::Expr) -> @ast::Expr {\n+    fn expr_managed(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         self.expr_unary(sp, ast::UnBox, e)\n     }\n \n-    fn expr_field_access(&self, sp: Span, expr: @ast::Expr, ident: ast::Ident) -> @ast::Expr {\n+    fn expr_field_access(&self, sp: Span, expr: Gc<ast::Expr>, ident: ast::Ident) -> Gc<ast::Expr> {\n         self.expr(sp, ast::ExprField(expr, ident, Vec::new()))\n     }\n-    fn expr_addr_of(&self, sp: Span, e: @ast::Expr) -> @ast::Expr {\n+    fn expr_addr_of(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         self.expr(sp, ast::ExprAddrOf(ast::MutImmutable, e))\n     }\n-    fn expr_mut_addr_of(&self, sp: Span, e: @ast::Expr) -> @ast::Expr {\n+    fn expr_mut_addr_of(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         self.expr(sp, ast::ExprAddrOf(ast::MutMutable, e))\n     }\n \n-    fn expr_call(&self, span: Span, expr: @ast::Expr, args: Vec<@ast::Expr> ) -> @ast::Expr {\n+    fn expr_call(&self, span: Span, expr: Gc<ast::Expr>,\n+                 args: Vec<Gc<ast::Expr>>) -> Gc<ast::Expr> {\n         self.expr(span, ast::ExprCall(expr, args))\n     }\n-    fn expr_call_ident(&self, span: Span, id: ast::Ident, args: Vec<@ast::Expr> ) -> @ast::Expr {\n+    fn expr_call_ident(&self, span: Span, id: ast::Ident,\n+                       args: Vec<Gc<ast::Expr>>) -> Gc<ast::Expr> {\n         self.expr(span, ast::ExprCall(self.expr_ident(span, id), args))\n     }\n     fn expr_call_global(&self, sp: Span, fn_path: Vec<ast::Ident> ,\n-                      args: Vec<@ast::Expr> ) -> @ast::Expr {\n+                      args: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr> {\n         let pathexpr = self.expr_path(self.path_global(sp, fn_path));\n         self.expr_call(sp, pathexpr, args)\n     }\n     fn expr_method_call(&self, span: Span,\n-                        expr: @ast::Expr,\n+                        expr: Gc<ast::Expr>,\n                         ident: ast::Ident,\n-                        mut args: Vec<@ast::Expr> ) -> @ast::Expr {\n+                        mut args: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr> {\n         let id = Spanned { node: ident, span: span };\n         args.unshift(expr);\n         self.expr(span, ast::ExprMethodCall(id, Vec::new(), args))\n     }\n-    fn expr_block(&self, b: P<ast::Block>) -> @ast::Expr {\n+    fn expr_block(&self, b: P<ast::Block>) -> Gc<ast::Expr> {\n         self.expr(b.span, ast::ExprBlock(b))\n     }\n-    fn field_imm(&self, span: Span, name: Ident, e: @ast::Expr) -> ast::Field {\n+    fn field_imm(&self, span: Span, name: Ident, e: Gc<ast::Expr>) -> ast::Field {\n         ast::Field { ident: respan(span, name), expr: e, span: span }\n     }\n-    fn expr_struct(&self, span: Span, path: ast::Path, fields: Vec<ast::Field> ) -> @ast::Expr {\n+    fn expr_struct(&self, span: Span, path: ast::Path, fields: Vec<ast::Field> ) -> Gc<ast::Expr> {\n         self.expr(span, ast::ExprStruct(path, fields, None))\n     }\n     fn expr_struct_ident(&self, span: Span,\n-                         id: ast::Ident, fields: Vec<ast::Field> ) -> @ast::Expr {\n+                         id: ast::Ident, fields: Vec<ast::Field> ) -> Gc<ast::Expr> {\n         self.expr_struct(span, self.path_ident(span, id), fields)\n     }\n \n-    fn expr_lit(&self, sp: Span, lit: ast::Lit_) -> @ast::Expr {\n-        self.expr(sp, ast::ExprLit(@respan(sp, lit)))\n+    fn expr_lit(&self, sp: Span, lit: ast::Lit_) -> Gc<ast::Expr> {\n+        self.expr(sp, ast::ExprLit(box(GC) respan(sp, lit)))\n     }\n-    fn expr_uint(&self, span: Span, i: uint) -> @ast::Expr {\n+    fn expr_uint(&self, span: Span, i: uint) -> Gc<ast::Expr> {\n         self.expr_lit(span, ast::LitUint(i as u64, ast::TyU))\n     }\n-    fn expr_int(&self, sp: Span, i: int) -> @ast::Expr {\n+    fn expr_int(&self, sp: Span, i: int) -> Gc<ast::Expr> {\n         self.expr_lit(sp, ast::LitInt(i as i64, ast::TyI))\n     }\n-    fn expr_u8(&self, sp: Span, u: u8) -> @ast::Expr {\n+    fn expr_u8(&self, sp: Span, u: u8) -> Gc<ast::Expr> {\n         self.expr_lit(sp, ast::LitUint(u as u64, ast::TyU8))\n     }\n-    fn expr_bool(&self, sp: Span, value: bool) -> @ast::Expr {\n+    fn expr_bool(&self, sp: Span, value: bool) -> Gc<ast::Expr> {\n         self.expr_lit(sp, ast::LitBool(value))\n     }\n \n-    fn expr_vstore(&self, sp: Span, expr: @ast::Expr, vst: ast::ExprVstore) -> @ast::Expr {\n+    fn expr_vstore(&self, sp: Span, expr: Gc<ast::Expr>, vst: ast::ExprVstore) -> Gc<ast::Expr> {\n         self.expr(sp, ast::ExprVstore(expr, vst))\n     }\n-    fn expr_vec(&self, sp: Span, exprs: Vec<@ast::Expr> ) -> @ast::Expr {\n+    fn expr_vec(&self, sp: Span, exprs: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr> {\n         self.expr(sp, ast::ExprVec(exprs))\n     }\n-    fn expr_vec_ng(&self, sp: Span) -> @ast::Expr {\n+    fn expr_vec_ng(&self, sp: Span) -> Gc<ast::Expr> {\n         self.expr_call_global(sp,\n                               vec!(self.ident_of(\"std\"),\n                                    self.ident_of(\"vec\"),\n                                    self.ident_of(\"Vec\"),\n                                    self.ident_of(\"new\")),\n                               Vec::new())\n     }\n-    fn expr_vec_slice(&self, sp: Span, exprs: Vec<@ast::Expr> ) -> @ast::Expr {\n+    fn expr_vec_slice(&self, sp: Span, exprs: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr> {\n         self.expr_vstore(sp, self.expr_vec(sp, exprs), ast::ExprVstoreSlice)\n     }\n-    fn expr_str(&self, sp: Span, s: InternedString) -> @ast::Expr {\n+    fn expr_str(&self, sp: Span, s: InternedString) -> Gc<ast::Expr> {\n         self.expr_lit(sp, ast::LitStr(s, ast::CookedStr))\n     }\n-    fn expr_str_uniq(&self, sp: Span, s: InternedString) -> @ast::Expr {\n+    fn expr_str_uniq(&self, sp: Span, s: InternedString) -> Gc<ast::Expr> {\n         self.expr_vstore(sp, self.expr_str(sp, s), ast::ExprVstoreUniq)\n     }\n \n \n-    fn expr_cast(&self, sp: Span, expr: @ast::Expr, ty: P<ast::Ty>) -> @ast::Expr {\n+    fn expr_cast(&self, sp: Span, expr: Gc<ast::Expr>, ty: P<ast::Ty>) -> Gc<ast::Expr> {\n         self.expr(sp, ast::ExprCast(expr, ty))\n     }\n \n \n-    fn expr_some(&self, sp: Span, expr: @ast::Expr) -> @ast::Expr {\n+    fn expr_some(&self, sp: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         let some = vec!(\n             self.ident_of(\"std\"),\n             self.ident_of(\"option\"),\n             self.ident_of(\"Some\"));\n         self.expr_call_global(sp, some, vec!(expr))\n     }\n \n-    fn expr_none(&self, sp: Span) -> @ast::Expr {\n+    fn expr_none(&self, sp: Span) -> Gc<ast::Expr> {\n         let none = self.path_global(sp, vec!(\n             self.ident_of(\"std\"),\n             self.ident_of(\"option\"),\n             self.ident_of(\"None\")));\n         self.expr_path(none)\n     }\n \n-    fn expr_fail(&self, span: Span, msg: InternedString) -> @ast::Expr {\n+    fn expr_fail(&self, span: Span, msg: InternedString) -> Gc<ast::Expr> {\n         let loc = self.codemap().lookup_char_pos(span.lo);\n         self.expr_call_global(\n             span,\n@@ -643,29 +666,29 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 self.expr_uint(span, loc.line)))\n     }\n \n-    fn expr_unreachable(&self, span: Span) -> @ast::Expr {\n+    fn expr_unreachable(&self, span: Span) -> Gc<ast::Expr> {\n         self.expr_fail(span,\n                        InternedString::new(\n                            \"internal error: entered unreachable code\"))\n     }\n \n-    fn expr_ok(&self, sp: Span, expr: @ast::Expr) -> @ast::Expr {\n+    fn expr_ok(&self, sp: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         let ok = vec!(\n             self.ident_of(\"std\"),\n             self.ident_of(\"result\"),\n             self.ident_of(\"Ok\"));\n         self.expr_call_global(sp, ok, vec!(expr))\n     }\n \n-    fn expr_err(&self, sp: Span, expr: @ast::Expr) -> @ast::Expr {\n+    fn expr_err(&self, sp: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         let err = vec!(\n             self.ident_of(\"std\"),\n             self.ident_of(\"result\"),\n             self.ident_of(\"Err\"));\n         self.expr_call_global(sp, err, vec!(expr))\n     }\n \n-    fn expr_try(&self, sp: Span, head: @ast::Expr) -> @ast::Expr {\n+    fn expr_try(&self, sp: Span, head: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         let ok = self.ident_of(\"Ok\");\n         let ok_path = self.path_ident(sp, ok);\n         let err = self.ident_of(\"Err\");\n@@ -694,38 +717,38 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n \n-    fn pat(&self, span: Span, pat: ast::Pat_) -> @ast::Pat {\n-        @ast::Pat { id: ast::DUMMY_NODE_ID, node: pat, span: span }\n+    fn pat(&self, span: Span, pat: ast::Pat_) -> Gc<ast::Pat> {\n+        box(GC) ast::Pat { id: ast::DUMMY_NODE_ID, node: pat, span: span }\n     }\n-    fn pat_wild(&self, span: Span) -> @ast::Pat {\n+    fn pat_wild(&self, span: Span) -> Gc<ast::Pat> {\n         self.pat(span, ast::PatWild)\n     }\n-    fn pat_lit(&self, span: Span, expr: @ast::Expr) -> @ast::Pat {\n+    fn pat_lit(&self, span: Span, expr: Gc<ast::Expr>) -> Gc<ast::Pat> {\n         self.pat(span, ast::PatLit(expr))\n     }\n-    fn pat_ident(&self, span: Span, ident: ast::Ident) -> @ast::Pat {\n+    fn pat_ident(&self, span: Span, ident: ast::Ident) -> Gc<ast::Pat> {\n         self.pat_ident_binding_mode(span, ident, ast::BindByValue(ast::MutImmutable))\n     }\n \n     fn pat_ident_binding_mode(&self,\n                               span: Span,\n                               ident: ast::Ident,\n-                              bm: ast::BindingMode) -> @ast::Pat {\n+                              bm: ast::BindingMode) -> Gc<ast::Pat> {\n         let path = self.path_ident(span, ident);\n         let pat = ast::PatIdent(bm, path, None);\n         self.pat(span, pat)\n     }\n-    fn pat_enum(&self, span: Span, path: ast::Path, subpats: Vec<@ast::Pat> ) -> @ast::Pat {\n+    fn pat_enum(&self, span: Span, path: ast::Path, subpats: Vec<Gc<ast::Pat>> ) -> Gc<ast::Pat> {\n         let pat = ast::PatEnum(path, Some(subpats));\n         self.pat(span, pat)\n     }\n     fn pat_struct(&self, span: Span,\n-                  path: ast::Path, field_pats: Vec<ast::FieldPat> ) -> @ast::Pat {\n+                  path: ast::Path, field_pats: Vec<ast::FieldPat> ) -> Gc<ast::Pat> {\n         let pat = ast::PatStruct(path, field_pats, false);\n         self.pat(span, pat)\n     }\n \n-    fn arm(&self, _span: Span, pats: Vec<@ast::Pat> , expr: @ast::Expr) -> ast::Arm {\n+    fn arm(&self, _span: Span, pats: Vec<Gc<ast::Pat>> , expr: Gc<ast::Expr>) -> ast::Arm {\n         ast::Arm {\n             attrs: vec!(),\n             pats: pats,\n@@ -738,56 +761,60 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.arm(span, vec!(self.pat_wild(span)), self.expr_unreachable(span))\n     }\n \n-    fn expr_match(&self, span: Span, arg: @ast::Expr, arms: Vec<ast::Arm> ) -> @Expr {\n+    fn expr_match(&self, span: Span, arg: Gc<ast::Expr>,\n+                  arms: Vec<ast::Arm>) -> Gc<Expr> {\n         self.expr(span, ast::ExprMatch(arg, arms))\n     }\n \n     fn expr_if(&self, span: Span,\n-               cond: @ast::Expr, then: @ast::Expr, els: Option<@ast::Expr>) -> @ast::Expr {\n+               cond: Gc<ast::Expr>, then: Gc<ast::Expr>,\n+               els: Option<Gc<ast::Expr>>) -> Gc<ast::Expr> {\n         let els = els.map(|x| self.expr_block(self.block_expr(x)));\n         self.expr(span, ast::ExprIf(cond, self.block_expr(then), els))\n     }\n \n     fn lambda_fn_decl(&self, span: Span,\n-                      fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> @ast::Expr {\n+                      fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> Gc<ast::Expr> {\n         self.expr(span, ast::ExprFnBlock(fn_decl, blk))\n     }\n-    fn lambda(&self, span: Span, ids: Vec<ast::Ident> , blk: P<ast::Block>) -> @ast::Expr {\n+    fn lambda(&self, span: Span, ids: Vec<ast::Ident> , blk: P<ast::Block>) -> Gc<ast::Expr> {\n         let fn_decl = self.fn_decl(\n             ids.iter().map(|id| self.arg(span, *id, self.ty_infer(span))).collect(),\n             self.ty_infer(span));\n \n         self.expr(span, ast::ExprFnBlock(fn_decl, blk))\n     }\n-    fn lambda0(&self, span: Span, blk: P<ast::Block>) -> @ast::Expr {\n+    fn lambda0(&self, span: Span, blk: P<ast::Block>) -> Gc<ast::Expr> {\n         self.lambda(span, Vec::new(), blk)\n     }\n \n-    fn lambda1(&self, span: Span, blk: P<ast::Block>, ident: ast::Ident) -> @ast::Expr {\n+    fn lambda1(&self, span: Span, blk: P<ast::Block>, ident: ast::Ident) -> Gc<ast::Expr> {\n         self.lambda(span, vec!(ident), blk)\n     }\n \n-    fn lambda_expr(&self, span: Span, ids: Vec<ast::Ident> , expr: @ast::Expr) -> @ast::Expr {\n+    fn lambda_expr(&self, span: Span, ids: Vec<ast::Ident> , expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         self.lambda(span, ids, self.block_expr(expr))\n     }\n-    fn lambda_expr_0(&self, span: Span, expr: @ast::Expr) -> @ast::Expr {\n+    fn lambda_expr_0(&self, span: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         self.lambda0(span, self.block_expr(expr))\n     }\n-    fn lambda_expr_1(&self, span: Span, expr: @ast::Expr, ident: ast::Ident) -> @ast::Expr {\n+    fn lambda_expr_1(&self, span: Span, expr: Gc<ast::Expr>, ident: ast::Ident) -> Gc<ast::Expr> {\n         self.lambda1(span, self.block_expr(expr), ident)\n     }\n \n     fn lambda_stmts(&self,\n                     span: Span,\n                     ids: Vec<ast::Ident>,\n-                    stmts: Vec<@ast::Stmt>)\n-                    -> @ast::Expr {\n+                    stmts: Vec<Gc<ast::Stmt>>)\n+                    -> Gc<ast::Expr> {\n         self.lambda(span, ids, self.block(span, stmts, None))\n     }\n-    fn lambda_stmts_0(&self, span: Span, stmts: Vec<@ast::Stmt> ) -> @ast::Expr {\n+    fn lambda_stmts_0(&self, span: Span,\n+                      stmts: Vec<Gc<ast::Stmt>>) -> Gc<ast::Expr> {\n         self.lambda0(span, self.block(span, stmts, None))\n     }\n-    fn lambda_stmts_1(&self, span: Span, stmts: Vec<@ast::Stmt> , ident: ast::Ident) -> @ast::Expr {\n+    fn lambda_stmts_1(&self, span: Span, stmts: Vec<Gc<ast::Stmt>>,\n+                      ident: ast::Ident) -> Gc<ast::Expr> {\n         self.lambda1(span, self.block(span, stmts, None), ident)\n     }\n \n@@ -811,10 +838,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn item(&self, span: Span,\n-            name: Ident, attrs: Vec<ast::Attribute> , node: ast::Item_) -> @ast::Item {\n+            name: Ident, attrs: Vec<ast::Attribute>,\n+            node: ast::Item_) -> Gc<ast::Item> {\n         // FIXME: Would be nice if our generated code didn't violate\n         // Rust coding conventions\n-        @ast::Item { ident: name,\n+        box(GC) ast::Item { ident: name,\n                     attrs: attrs,\n                     id: ast::DUMMY_NODE_ID,\n                     node: node,\n@@ -828,7 +856,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                     inputs: Vec<ast::Arg> ,\n                     output: P<ast::Ty>,\n                     generics: Generics,\n-                    body: P<ast::Block>) -> @ast::Item {\n+                    body: P<ast::Block>) -> Gc<ast::Item> {\n         self.item(span,\n                   name,\n                   Vec::new(),\n@@ -845,7 +873,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                inputs: Vec<ast::Arg> ,\n                output: P<ast::Ty>,\n                body: P<ast::Block>\n-              ) -> @ast::Item {\n+              ) -> Gc<ast::Item> {\n         self.item_fn_poly(\n             span,\n             name,\n@@ -873,18 +901,18 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn item_enum_poly(&self, span: Span, name: Ident,\n                       enum_definition: ast::EnumDef,\n-                      generics: Generics) -> @ast::Item {\n+                      generics: Generics) -> Gc<ast::Item> {\n         self.item(span, name, Vec::new(), ast::ItemEnum(enum_definition, generics))\n     }\n \n     fn item_enum(&self, span: Span, name: Ident,\n-                 enum_definition: ast::EnumDef) -> @ast::Item {\n+                 enum_definition: ast::EnumDef) -> Gc<ast::Item> {\n         self.item_enum_poly(span, name, enum_definition,\n                             ast_util::empty_generics())\n     }\n \n     fn item_struct(&self, span: Span, name: Ident,\n-                   struct_def: ast::StructDef) -> @ast::Item {\n+                   struct_def: ast::StructDef) -> Gc<ast::Item> {\n         self.item_struct_poly(\n             span,\n             name,\n@@ -894,14 +922,14 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn item_struct_poly(&self, span: Span, name: Ident,\n-        struct_def: ast::StructDef, generics: Generics) -> @ast::Item {\n-        self.item(span, name, Vec::new(), ast::ItemStruct(@struct_def, generics))\n+        struct_def: ast::StructDef, generics: Generics) -> Gc<ast::Item> {\n+        self.item(span, name, Vec::new(), ast::ItemStruct(box(GC) struct_def, generics))\n     }\n \n     fn item_mod(&self, span: Span, inner_span: Span, name: Ident,\n                 attrs: Vec<ast::Attribute> ,\n                 vi: Vec<ast::ViewItem> ,\n-                items: Vec<@ast::Item> ) -> @ast::Item {\n+                items: Vec<Gc<ast::Item>>) -> Gc<ast::Item> {\n         self.item(\n             span,\n             name,\n@@ -915,15 +943,15 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn item_ty_poly(&self, span: Span, name: Ident, ty: P<ast::Ty>,\n-                    generics: Generics) -> @ast::Item {\n+                    generics: Generics) -> Gc<ast::Item> {\n         self.item(span, name, Vec::new(), ast::ItemTy(ty, generics))\n     }\n \n-    fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> @ast::Item {\n+    fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> Gc<ast::Item> {\n         self.item_ty_poly(span, name, ty, ast_util::empty_generics())\n     }\n \n-    fn attribute(&self, sp: Span, mi: @ast::MetaItem) -> ast::Attribute {\n+    fn attribute(&self, sp: Span, mi: Gc<ast::MetaItem>) -> ast::Attribute {\n         respan(sp, ast::Attribute_ {\n             id: attr::mk_attr_id(),\n             style: ast::AttrOuter,\n@@ -932,26 +960,26 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         })\n     }\n \n-    fn meta_word(&self, sp: Span, w: InternedString) -> @ast::MetaItem {\n-        @respan(sp, ast::MetaWord(w))\n+    fn meta_word(&self, sp: Span, w: InternedString) -> Gc<ast::MetaItem> {\n+        box(GC) respan(sp, ast::MetaWord(w))\n     }\n     fn meta_list(&self,\n                  sp: Span,\n                  name: InternedString,\n-                 mis: Vec<@ast::MetaItem> )\n-                 -> @ast::MetaItem {\n-        @respan(sp, ast::MetaList(name, mis))\n+                 mis: Vec<Gc<ast::MetaItem>> )\n+                 -> Gc<ast::MetaItem> {\n+        box(GC) respan(sp, ast::MetaList(name, mis))\n     }\n     fn meta_name_value(&self,\n                        sp: Span,\n                        name: InternedString,\n                        value: ast::Lit_)\n-                       -> @ast::MetaItem {\n-        @respan(sp, ast::MetaNameValue(name, respan(sp, value)))\n+                       -> Gc<ast::MetaItem> {\n+        box(GC) respan(sp, ast::MetaNameValue(name, respan(sp, value)))\n     }\n \n     fn view_use(&self, sp: Span,\n-                vis: ast::Visibility, vp: @ast::ViewPath) -> ast::ViewItem {\n+                vis: ast::Visibility, vp: Gc<ast::ViewPath>) -> ast::ViewItem {\n         ast::ViewItem {\n             node: ast::ViewItemUse(vp),\n             attrs: Vec::new(),\n@@ -968,7 +996,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn view_use_simple_(&self, sp: Span, vis: ast::Visibility,\n                         ident: ast::Ident, path: ast::Path) -> ast::ViewItem {\n         self.view_use(sp, vis,\n-                      @respan(sp,\n+                      box(GC) respan(sp,\n                            ast::ViewPathSimple(ident,\n                                                path,\n                                                ast::DUMMY_NODE_ID)))\n@@ -981,7 +1009,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         }).collect();\n \n         self.view_use(sp, vis,\n-                      @respan(sp,\n+                      box(GC) respan(sp,\n                            ast::ViewPathList(self.path(sp, path),\n                                              imports,\n                                              ast::DUMMY_NODE_ID)))\n@@ -990,7 +1018,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn view_use_glob(&self, sp: Span,\n                      vis: ast::Visibility, path: Vec<ast::Ident> ) -> ast::ViewItem {\n         self.view_use(sp, vis,\n-                      @respan(sp,\n+                      box(GC) respan(sp,\n                            ast::ViewPathGlob(self.path(sp, path), ast::DUMMY_NODE_ID)))\n     }\n }\n@@ -1013,8 +1041,8 @@ pub trait Duplicate {\n     fn duplicate(&self, cx: &ExtCtxt) -> Self;\n }\n \n-impl Duplicate for @ast::Expr {\n-    fn duplicate(&self, _: &ExtCtxt) -> @ast::Expr {\n+impl Duplicate for Gc<ast::Expr> {\n+    fn duplicate(&self, _: &ExtCtxt) -> Gc<ast::Expr> {\n         let mut folder = Duplicator;\n         folder.fold_expr(*self)\n     }"}, {"sha": "3522095ed70049e691f9424a51d8e795a0caeb30", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -44,7 +44,7 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     }\n     let res = str_to_ident(res_str.as_slice());\n \n-    let e = @ast::Expr {\n+    let e = box(GC) ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprPath(\n             ast::Path {"}, {"sha": "fac9f37c462cca8328c69458eb6ed93210a2b735", "filename": "src/libsyntax/ext/deriving/bounds.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -14,11 +14,13 @@ use ext::base::ExtCtxt;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n \n+use std::gc::Gc;\n+\n pub fn expand_deriving_bound(cx: &mut ExtCtxt,\n                              span: Span,\n-                             mitem: @MetaItem,\n-                             item: @Item,\n-                             push: |@Item|) {\n+                             mitem: Gc<MetaItem>,\n+                             item: Gc<Item>,\n+                             push: |Gc<Item>|) {\n \n     let name = match mitem.node {\n         MetaWord(ref tname) => {"}, {"sha": "93e4920bc1de43f5df09cda2be599d4018d10e3c", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -16,11 +16,13 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n \n+use std::gc::Gc;\n+\n pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n                              span: Span,\n-                             mitem: @MetaItem,\n-                             item: @Item,\n-                             push: |@Item|) {\n+                             mitem: Gc<MetaItem>,\n+                             item: Gc<Item>,\n+                             push: |Gc<Item>|) {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {\n@@ -51,7 +53,7 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n fn cs_clone(\n     name: &str,\n     cx: &mut ExtCtxt, trait_span: Span,\n-    substr: &Substructure) -> @Expr {\n+    substr: &Substructure) -> Gc<Expr> {\n     let clone_ident = substr.method_ident;\n     let ctor_ident;\n     let all_fields;"}, {"sha": "ef8d477a98e678f83e9ecd3108c5ca5cf3c44857", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -16,18 +16,20 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n \n+use std::gc::Gc;\n+\n pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                           span: Span,\n-                          mitem: @MetaItem,\n-                          item: @Item,\n-                          push: |@Item|) {\n+                          mitem: Gc<MetaItem>,\n+                          item: Gc<Item>,\n+                          push: |Gc<Item>|) {\n     // structures are equal if all fields are equal, and non equal, if\n     // any fields are not equal or if the enum variants are different\n-    fn cs_eq(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+    fn cs_eq(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> Gc<Expr> {\n         cs_and(|cx, span, _, _| cx.expr_bool(span, false),\n                                  cx, span, substr)\n     }\n-    fn cs_ne(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+    fn cs_ne(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> Gc<Expr> {\n         cs_or(|cx, span, _, _| cx.expr_bool(span, true),\n               cx, span, substr)\n     }"}, {"sha": "88ebe8a60faff5370bfacb7a1b5e025099d8add5", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -17,11 +17,13 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n \n+use std::gc::Gc;\n+\n pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n                            span: Span,\n-                           mitem: @MetaItem,\n-                           item: @Item,\n-                           push: |@Item|) {\n+                           mitem: Gc<MetaItem>,\n+                           item: Gc<Item>,\n+                           push: |Gc<Item>|) {\n     macro_rules! md (\n         ($name:expr, $op:expr, $equal:expr) => { {\n             let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n@@ -58,7 +60,8 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n }\n \n /// Strict inequality.\n-fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt, span: Span,\n+         substr: &Substructure) -> Gc<Expr> {\n     let op = if less {ast::BiLt} else {ast::BiGt};\n     cs_fold(\n         false, // need foldr,"}, {"sha": "8b1e0498d253c43907b43ce5dc0ae37c2b0ae89d", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -16,12 +16,15 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n \n+use std::gc::Gc;\n+\n pub fn expand_deriving_totaleq(cx: &mut ExtCtxt,\n                                span: Span,\n-                               mitem: @MetaItem,\n-                               item: @Item,\n-                               push: |@Item|) {\n-    fn cs_total_eq_assert(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+                               mitem: Gc<MetaItem>,\n+                               item: Gc<Item>,\n+                               push: |Gc<Item>|) {\n+    fn cs_total_eq_assert(cx: &mut ExtCtxt, span: Span,\n+                          substr: &Substructure) -> Gc<Expr> {\n         cs_same_method(|cx, span, exprs| {\n             // create `a.<method>(); b.<method>(); c.<method>(); ...`\n             // (where method is `assert_receiver_is_total_eq`)"}, {"sha": "271aa90cd24a4f5ea1114745a08fdedd16cbc3c7", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -18,12 +18,13 @@ use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n \n use std::cmp::{Ordering, Equal, Less, Greater};\n+use std::gc::Gc;\n \n pub fn expand_deriving_totalord(cx: &mut ExtCtxt,\n                                 span: Span,\n-                                mitem: @MetaItem,\n-                                item: @Item,\n-                                push: |@Item|) {\n+                                mitem: Gc<MetaItem>,\n+                                item: Gc<Item>,\n+                                push: |Gc<Item>|) {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {\n@@ -65,7 +66,7 @@ pub fn ordering_const(cx: &mut ExtCtxt, span: Span, cnst: Ordering) -> ast::Path\n }\n \n pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n-              substr: &Substructure) -> @Expr {\n+              substr: &Substructure) -> Gc<Expr> {\n     let test_id = cx.ident_of(\"__test\");\n     let equals_path = ordering_const(cx, span, Equal);\n "}, {"sha": "0c23d65fde046e788da842b10c50008c0160d1b1", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -23,11 +23,13 @@ use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n use parse::token;\n \n+use std::gc::Gc;\n+\n pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n                                  span: Span,\n-                                 mitem: @MetaItem,\n-                                 item: @Item,\n-                                 push: |@Item|) {\n+                                 mitem: Gc<MetaItem>,\n+                                 item: Gc<Item>,\n+                                 push: |Gc<Item>|) {\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n@@ -64,7 +66,7 @@ pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n }\n \n fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n-                          substr: &Substructure) -> @Expr {\n+                          substr: &Substructure) -> Gc<Expr> {\n     let decoder = substr.nonself_args[0];\n     let recurse = vec!(cx.ident_of(\"serialize\"),\n                     cx.ident_of(\"Decodable\"),\n@@ -159,8 +161,8 @@ fn decode_static_fields(cx: &mut ExtCtxt,\n                         trait_span: Span,\n                         outer_pat_ident: Ident,\n                         fields: &StaticFields,\n-                        getarg: |&mut ExtCtxt, Span, InternedString, uint| -> @Expr)\n-                        -> @Expr {\n+                        getarg: |&mut ExtCtxt, Span, InternedString, uint| -> Gc<Expr>)\n+                        -> Gc<Expr> {\n     match *fields {\n         Unnamed(ref fields) => {\n             if fields.is_empty() {"}, {"sha": "dfebc0f5e642111a25a1015b857e67cbd66faf43", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -16,11 +16,13 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n \n+use std::gc::Gc;\n+\n pub fn expand_deriving_default(cx: &mut ExtCtxt,\n                             span: Span,\n-                            mitem: @MetaItem,\n-                            item: @Item,\n-                            push: |@Item|) {\n+                            mitem: Gc<MetaItem>,\n+                            item: Gc<Item>,\n+                            push: |Gc<Item>|) {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {\n@@ -46,7 +48,8 @@ pub fn expand_deriving_default(cx: &mut ExtCtxt,\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-fn default_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n+fn default_substructure(cx: &mut ExtCtxt, trait_span: Span,\n+                        substr: &Substructure) -> Gc<Expr> {\n     let default_ident = vec!(\n         cx.ident_of(\"std\"),\n         cx.ident_of(\"default\"),"}, {"sha": "f57670af1999b3c90be860f84f67907ba012f91a", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -91,11 +91,13 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token;\n \n+use std::gc::Gc;\n+\n pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n                                  span: Span,\n-                                 mitem: @MetaItem,\n-                                 item: @Item,\n-                                 push: |@Item|) {\n+                                 mitem: Gc<MetaItem>,\n+                                 item: Gc<Item>,\n+                                 push: |Gc<Item>|) {\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n@@ -134,7 +136,7 @@ pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n }\n \n fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n-                          substr: &Substructure) -> @Expr {\n+                          substr: &Substructure) -> Gc<Expr> {\n     let encoder = substr.nonself_args[0];\n     // throw an underscore in front to suppress unused variable warnings\n     let blkarg = cx.ident_of(\"_e\");"}, {"sha": "251eae75ee551eeba93094c26fbb2e98e07487dc", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 72, "deletions": 69, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -178,6 +178,7 @@ StaticEnum(<ast::EnumDef of C>, ~[(<ident of C0>, <span of C0>, Unnamed(~[<span\n */\n \n use std::cell::RefCell;\n+use std::gc::Gc;\n \n use ast;\n use ast::{P, EnumDef, Expr, Ident, Generics, StructDef};\n@@ -248,9 +249,9 @@ pub struct Substructure<'a> {\n     /// ident of the method\n     pub method_ident: Ident,\n     /// dereferenced access to any Self or Ptr(Self, _) arguments\n-    pub self_args: &'a [@Expr],\n+    pub self_args: &'a [Gc<Expr>],\n     /// verbatim access to any other arguments\n-    pub nonself_args: &'a [@Expr],\n+    pub nonself_args: &'a [Gc<Expr>],\n     pub fields: &'a SubstructureFields<'a>\n }\n \n@@ -262,42 +263,43 @@ pub struct FieldInfo {\n     pub name: Option<Ident>,\n     /// The expression corresponding to this field of `self`\n     /// (specifically, a reference to it).\n-    pub self_: @Expr,\n+    pub self_: Gc<Expr>,\n     /// The expressions corresponding to references to this field in\n     /// the other Self arguments.\n-    pub other: Vec<@Expr>,\n+    pub other: Vec<Gc<Expr>>,\n }\n \n /// Fields for a static method\n pub enum StaticFields {\n     /// Tuple structs/enum variants like this\n-    Unnamed(Vec<Span> ),\n+    Unnamed(Vec<Span>),\n     /// Normal structs/struct variants.\n-    Named(Vec<(Ident, Span)> )\n+    Named(Vec<(Ident, Span)>),\n }\n \n /// A summary of the possible sets of fields. See above for details\n /// and examples\n pub enum SubstructureFields<'a> {\n-    Struct(Vec<FieldInfo> ),\n+    Struct(Vec<FieldInfo>),\n     /**\n     Matching variants of the enum: variant index, ast::Variant,\n     fields: the field name is only non-`None` in the case of a struct\n     variant.\n     */\n-    EnumMatching(uint, &'a ast::Variant, Vec<FieldInfo> ),\n+    EnumMatching(uint, &'a ast::Variant, Vec<FieldInfo>),\n \n     /**\n     non-matching variants of the enum, [(variant index, ast::Variant,\n     [field span, field ident, fields])] \\(i.e. all fields for self are in the\n     first tuple, for other1 are in the second tuple, etc.)\n     */\n-    EnumNonMatching(&'a [(uint, P<ast::Variant>, Vec<(Span, Option<Ident>, @Expr)> )]),\n+    EnumNonMatching(&'a [(uint, P<ast::Variant>,\n+                          Vec<(Span, Option<Ident>, Gc<Expr>)>)]),\n \n     /// A static method where Self is a struct.\n     StaticStruct(&'a ast::StructDef, StaticFields),\n     /// A static method where Self is an enum.\n-    StaticEnum(&'a ast::EnumDef, Vec<(Ident, Span, StaticFields)> )\n+    StaticEnum(&'a ast::EnumDef, Vec<(Ident, Span, StaticFields)>),\n }\n \n \n@@ -307,7 +309,7 @@ Combine the values of all the fields together. The last argument is\n all the fields of all the structures, see above for details.\n */\n pub type CombineSubstructureFunc<'a> =\n-    |&mut ExtCtxt, Span, &Substructure|: 'a -> @Expr;\n+    |&mut ExtCtxt, Span, &Substructure|: 'a -> Gc<Expr>;\n \n /**\n Deal with non-matching enum variants, the arguments are a list\n@@ -317,9 +319,9 @@ representing each variant: (variant index, ast::Variant instance,\n pub type EnumNonMatchFunc<'a> =\n     |&mut ExtCtxt,\n            Span,\n-           &[(uint, P<ast::Variant>, Vec<(Span, Option<Ident>, @Expr)> )],\n-           &[@Expr]|: 'a\n-           -> @Expr;\n+           &[(uint, P<ast::Variant>, Vec<(Span, Option<Ident>, Gc<Expr>)>)],\n+           &[Gc<Expr>]|: 'a\n+           -> Gc<Expr>;\n \n pub fn combine_substructure<'a>(f: CombineSubstructureFunc<'a>)\n     -> RefCell<CombineSubstructureFunc<'a>> {\n@@ -330,13 +332,13 @@ pub fn combine_substructure<'a>(f: CombineSubstructureFunc<'a>)\n impl<'a> TraitDef<'a> {\n     pub fn expand(&self,\n                   cx: &mut ExtCtxt,\n-                  _mitem: @ast::MetaItem,\n-                  item: @ast::Item,\n-                  push: |@ast::Item|) {\n+                  _mitem: Gc<ast::MetaItem>,\n+                  item: Gc<ast::Item>,\n+                  push: |Gc<ast::Item>|) {\n         let newitem = match item.node {\n-            ast::ItemStruct(struct_def, ref generics) => {\n+            ast::ItemStruct(ref struct_def, ref generics) => {\n                 self.expand_struct_def(cx,\n-                                       struct_def,\n+                                       &**struct_def,\n                                        item.ident,\n                                        generics)\n             }\n@@ -357,7 +359,7 @@ impl<'a> TraitDef<'a> {\n                 _ => false,\n             }\n         }).map(|a| a.clone()));\n-        push(@ast::Item {\n+        push(box(GC) ast::Item {\n             attrs: attrs,\n             ..(*newitem).clone()\n         })\n@@ -379,7 +381,7 @@ impl<'a> TraitDef<'a> {\n                            cx: &mut ExtCtxt,\n                            type_ident: Ident,\n                            generics: &Generics,\n-                           methods: Vec<@ast::Method> ) -> @ast::Item {\n+                           methods: Vec<Gc<ast::Method>> ) -> Gc<ast::Item> {\n         let trait_path = self.path.to_path(cx, self.span, type_ident, generics);\n \n         let Generics { mut lifetimes, ty_params } =\n@@ -435,7 +437,7 @@ impl<'a> TraitDef<'a> {\n         // Just mark it now since we know that it'll end up used downstream\n         attr::mark_used(&attr);\n         let opt_trait_ref = Some(trait_ref);\n-        let ident = ast_util::impl_pretty_name(&opt_trait_ref, self_type);\n+        let ident = ast_util::impl_pretty_name(&opt_trait_ref, &*self_type);\n         cx.item(\n             self.span,\n             ident,\n@@ -448,7 +450,7 @@ impl<'a> TraitDef<'a> {\n                          cx: &mut ExtCtxt,\n                          struct_def: &StructDef,\n                          type_ident: Ident,\n-                         generics: &Generics) -> @ast::Item {\n+                         generics: &Generics) -> Gc<ast::Item> {\n         let methods = self.methods.iter().map(|method_def| {\n             let (explicit_self, self_args, nonself_args, tys) =\n                 method_def.split_self_nonself_args(\n@@ -484,7 +486,7 @@ impl<'a> TraitDef<'a> {\n                        cx: &mut ExtCtxt,\n                        enum_def: &EnumDef,\n                        type_ident: Ident,\n-                       generics: &Generics) -> @ast::Item {\n+                       generics: &Generics) -> Gc<ast::Item> {\n         let methods = self.methods.iter().map(|method_def| {\n             let (explicit_self, self_args, nonself_args, tys) =\n                 method_def.split_self_nonself_args(cx, self,\n@@ -522,10 +524,10 @@ impl<'a> MethodDef<'a> {\n                                 cx: &mut ExtCtxt,\n                                 trait_: &TraitDef,\n                                 type_ident: Ident,\n-                                self_args: &[@Expr],\n-                                nonself_args: &[@Expr],\n+                                self_args: &[Gc<Expr>],\n+                                nonself_args: &[Gc<Expr>],\n                                 fields: &SubstructureFields)\n-        -> @Expr {\n+        -> Gc<Expr> {\n         let substructure = Substructure {\n             type_ident: type_ident,\n             method_ident: cx.ident_of(self.name),\n@@ -556,7 +558,8 @@ impl<'a> MethodDef<'a> {\n                                trait_: &TraitDef,\n                                type_ident: Ident,\n                                generics: &Generics)\n-        -> (ast::ExplicitSelf, Vec<@Expr> , Vec<@Expr> , Vec<(Ident, P<ast::Ty>)> ) {\n+        -> (ast::ExplicitSelf, Vec<Gc<Expr>>, Vec<Gc<Expr>>,\n+            Vec<(Ident, P<ast::Ty>)>) {\n \n         let mut self_args = Vec::new();\n         let mut nonself_args = Vec::new();\n@@ -608,7 +611,7 @@ impl<'a> MethodDef<'a> {\n                      generics: &Generics,\n                      explicit_self: ast::ExplicitSelf,\n                      arg_types: Vec<(Ident, P<ast::Ty>)> ,\n-                     body: @Expr) -> @ast::Method {\n+                     body: Gc<Expr>) -> Gc<ast::Method> {\n         // create the generics that aren't for Self\n         let fn_generics = self.generics.to_generics(cx, trait_.span, type_ident, generics);\n \n@@ -630,7 +633,7 @@ impl<'a> MethodDef<'a> {\n         let body_block = cx.block_expr(body);\n \n         // Create the method.\n-        @ast::Method {\n+        box(GC) ast::Method {\n             ident: method_ident,\n             attrs: self.attributes.clone(),\n             generics: fn_generics,\n@@ -670,9 +673,9 @@ impl<'a> MethodDef<'a> {\n                                  trait_: &TraitDef,\n                                  struct_def: &StructDef,\n                                  type_ident: Ident,\n-                                 self_args: &[@Expr],\n-                                 nonself_args: &[@Expr])\n-        -> @Expr {\n+                                 self_args: &[Gc<Expr>],\n+                                 nonself_args: &[Gc<Expr>])\n+        -> Gc<Expr> {\n \n         let mut raw_fields = Vec::new(); // ~[[fields of self],\n                                  // [fields of next Self arg], [etc]]\n@@ -737,9 +740,9 @@ impl<'a> MethodDef<'a> {\n                                         trait_: &TraitDef,\n                                         struct_def: &StructDef,\n                                         type_ident: Ident,\n-                                        self_args: &[@Expr],\n-                                        nonself_args: &[@Expr])\n-        -> @Expr {\n+                                        self_args: &[Gc<Expr>],\n+                                        nonself_args: &[Gc<Expr>])\n+        -> Gc<Expr> {\n         let summary = trait_.summarise_struct(cx, struct_def);\n \n         self.call_substructure_method(cx,\n@@ -780,9 +783,9 @@ impl<'a> MethodDef<'a> {\n                                trait_: &TraitDef,\n                                enum_def: &EnumDef,\n                                type_ident: Ident,\n-                               self_args: &[@Expr],\n-                               nonself_args: &[@Expr])\n-                               -> @Expr {\n+                               self_args: &[Gc<Expr>],\n+                               nonself_args: &[Gc<Expr>])\n+                               -> Gc<Expr> {\n         let mut matches = Vec::new();\n         self.build_enum_match(cx, trait_, enum_def, type_ident,\n                               self_args, nonself_args,\n@@ -816,12 +819,12 @@ impl<'a> MethodDef<'a> {\n                         trait_: &TraitDef,\n                         enum_def: &EnumDef,\n                         type_ident: Ident,\n-                        self_args: &[@Expr],\n-                        nonself_args: &[@Expr],\n+                        self_args: &[Gc<Expr>],\n+                        nonself_args: &[Gc<Expr>],\n                         matching: Option<uint>,\n                         matches_so_far: &mut Vec<(uint, P<ast::Variant>,\n-                                              Vec<(Span, Option<Ident>, @Expr)> )> ,\n-                        match_count: uint) -> @Expr {\n+                                              Vec<(Span, Option<Ident>, Gc<Expr>)>)> ,\n+                        match_count: uint) -> Gc<Expr> {\n         if match_count == self_args.len() {\n             // we've matched against all arguments, so make the final\n             // expression at the bottom of the match tree\n@@ -871,7 +874,7 @@ impl<'a> MethodDef<'a> {\n                             other: (*other).clone()\n                         }\n                     }).collect();\n-                    EnumMatching(variant_index, variant, field_tuples)\n+                    EnumMatching(variant_index, &*variant, field_tuples)\n                 }\n                 None => {\n                     EnumNonMatching(matches_so_far.as_slice())\n@@ -905,7 +908,7 @@ impl<'a> MethodDef<'a> {\n                 let variant = *enum_def.variants.get(index);\n                 let (pattern, idents) = trait_.create_enum_variant_pattern(\n                     cx,\n-                    variant,\n+                    &*variant,\n                     current_match_str.as_slice(),\n                     ast::MutImmutable);\n \n@@ -938,7 +941,7 @@ impl<'a> MethodDef<'a> {\n                     let (pattern, idents) =\n                         trait_.create_enum_variant_pattern(\n                             cx,\n-                            variant,\n+                            &*variant,\n                             current_match_str.as_slice(),\n                             ast::MutImmutable);\n \n@@ -974,17 +977,17 @@ impl<'a> MethodDef<'a> {\n                                       trait_: &TraitDef,\n                                       enum_def: &EnumDef,\n                                       type_ident: Ident,\n-                                      self_args: &[@Expr],\n-                                      nonself_args: &[@Expr])\n-        -> @Expr {\n+                                      self_args: &[Gc<Expr>],\n+                                      nonself_args: &[Gc<Expr>])\n+        -> Gc<Expr> {\n         let summary = enum_def.variants.iter().map(|v| {\n             let ident = v.node.name;\n             let summary = match v.node.kind {\n                 ast::TupleVariantKind(ref args) => {\n                     Unnamed(args.iter().map(|va| trait_.set_expn_info(cx, va.ty.span)).collect())\n                 }\n-                ast::StructVariantKind(struct_def) => {\n-                    trait_.summarise_struct(cx, struct_def)\n+                ast::StructVariantKind(ref struct_def) => {\n+                    trait_.summarise_struct(cx, &**struct_def)\n                 }\n             };\n             (ident, v.span, summary)\n@@ -1009,7 +1012,7 @@ impl<'a> TraitDef<'a> {\n             None => cx.span_bug(self.span, \"trait with empty path in generic `deriving`\"),\n             Some(name) => *name\n         };\n-        to_set.expn_info = Some(@codemap::ExpnInfo {\n+        to_set.expn_info = Some(box(GC) codemap::ExpnInfo {\n             call_site: to_set,\n             callee: codemap::NameAndSpan {\n                 name: format!(\"deriving({})\", trait_name).to_string(),\n@@ -1048,7 +1051,7 @@ impl<'a> TraitDef<'a> {\n                           cx: &mut ExtCtxt,\n                           field_paths: Vec<ast::Path> ,\n                           mutbl: ast::Mutability)\n-                          -> Vec<@ast::Pat> {\n+                          -> Vec<Gc<ast::Pat>> {\n         field_paths.iter().map(|path| {\n             cx.pat(path.span,\n                         ast::PatIdent(ast::BindByRef(mutbl), (*path).clone(), None))\n@@ -1061,7 +1064,7 @@ impl<'a> TraitDef<'a> {\n                              struct_def: &StructDef,\n                              prefix: &str,\n                              mutbl: ast::Mutability)\n-                             -> (@ast::Pat, Vec<(Span, Option<Ident>, @Expr)> ) {\n+                             -> (Gc<ast::Pat>, Vec<(Span, Option<Ident>, Gc<Expr>)>) {\n         if struct_def.fields.is_empty() {\n             return (\n                 cx.pat_ident_binding_mode(\n@@ -1126,7 +1129,7 @@ impl<'a> TraitDef<'a> {\n                                    variant: &ast::Variant,\n                                    prefix: &str,\n                                    mutbl: ast::Mutability)\n-        -> (@ast::Pat, Vec<(Span, Option<Ident>, @Expr)> ) {\n+        -> (Gc<ast::Pat>, Vec<(Span, Option<Ident>, Gc<Expr>)> ) {\n         let variant_ident = variant.node.name;\n         match variant.node.kind {\n             ast::TupleVariantKind(ref variant_args) => {\n@@ -1159,8 +1162,8 @@ impl<'a> TraitDef<'a> {\n                 (cx.pat_enum(variant.span, matching_path, subpats),\n                  ident_expr)\n             }\n-            ast::StructVariantKind(struct_def) => {\n-                self.create_struct_pattern(cx, variant_ident, struct_def,\n+            ast::StructVariantKind(ref struct_def) => {\n+                self.create_struct_pattern(cx, variant_ident, &**struct_def,\n                                            prefix, mutbl)\n             }\n         }\n@@ -1174,13 +1177,13 @@ Fold the fields. `use_foldl` controls whether this is done\n left-to-right (`true`) or right-to-left (`false`).\n */\n pub fn cs_fold(use_foldl: bool,\n-               f: |&mut ExtCtxt, Span, @Expr, @Expr, &[@Expr]| -> @Expr,\n-               base: @Expr,\n+               f: |&mut ExtCtxt, Span, Gc<Expr>, Gc<Expr>, &[Gc<Expr>]| -> Gc<Expr>,\n+               base: Gc<Expr>,\n                enum_nonmatch_f: EnumNonMatchFunc,\n                cx: &mut ExtCtxt,\n                trait_span: Span,\n                substructure: &Substructure)\n-               -> @Expr {\n+               -> Gc<Expr> {\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             if use_foldl {\n@@ -1221,12 +1224,12 @@ f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n ~~~\n */\n #[inline]\n-pub fn cs_same_method(f: |&mut ExtCtxt, Span, Vec<@Expr> | -> @Expr,\n+pub fn cs_same_method(f: |&mut ExtCtxt, Span, Vec<Gc<Expr>>| -> Gc<Expr>,\n                       enum_nonmatch_f: EnumNonMatchFunc,\n                       cx: &mut ExtCtxt,\n                       trait_span: Span,\n                       substructure: &Substructure)\n-                      -> @Expr {\n+                      -> Gc<Expr> {\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             // call self_n.method(other_1_n, other_2_n, ...)\n@@ -1257,13 +1260,13 @@ fields. `use_foldl` controls whether this is done left-to-right\n */\n #[inline]\n pub fn cs_same_method_fold(use_foldl: bool,\n-                           f: |&mut ExtCtxt, Span, @Expr, @Expr| -> @Expr,\n-                           base: @Expr,\n+                           f: |&mut ExtCtxt, Span, Gc<Expr>, Gc<Expr>| -> Gc<Expr>,\n+                           base: Gc<Expr>,\n                            enum_nonmatch_f: EnumNonMatchFunc,\n                            cx: &mut ExtCtxt,\n                            trait_span: Span,\n                            substructure: &Substructure)\n-                           -> @Expr {\n+                           -> Gc<Expr> {\n     cs_same_method(\n         |cx, span, vals| {\n             if use_foldl {\n@@ -1285,10 +1288,10 @@ Use a given binop to combine the result of calling the derived method\n on all the fields.\n */\n #[inline]\n-pub fn cs_binop(binop: ast::BinOp, base: @Expr,\n+pub fn cs_binop(binop: ast::BinOp, base: Gc<Expr>,\n                 enum_nonmatch_f: EnumNonMatchFunc,\n                 cx: &mut ExtCtxt, trait_span: Span,\n-                substructure: &Substructure) -> @Expr {\n+                substructure: &Substructure) -> Gc<Expr> {\n     cs_same_method_fold(\n         true, // foldl is good enough\n         |cx, span, old, new| {\n@@ -1306,7 +1309,7 @@ pub fn cs_binop(binop: ast::BinOp, base: @Expr,\n #[inline]\n pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n              cx: &mut ExtCtxt, span: Span,\n-             substructure: &Substructure) -> @Expr {\n+             substructure: &Substructure) -> Gc<Expr> {\n     cs_binop(ast::BiOr, cx.expr_bool(span, false),\n              enum_nonmatch_f,\n              cx, span, substructure)\n@@ -1316,7 +1319,7 @@ pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n #[inline]\n pub fn cs_and(enum_nonmatch_f: EnumNonMatchFunc,\n               cx: &mut ExtCtxt, span: Span,\n-              substructure: &Substructure) -> @Expr {\n+              substructure: &Substructure) -> Gc<Expr> {\n     cs_binop(ast::BiAnd, cx.expr_bool(span, true),\n              enum_nonmatch_f,\n              cx, span, substructure)"}, {"sha": "7501b950770c2e0c96f603d7d536a612792265c3", "filename": "src/libsyntax/ext/deriving/generic/ty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -20,6 +20,7 @@ use ext::build::AstBuilder;\n use codemap::{Span,respan};\n use owned_slice::OwnedSlice;\n \n+use std::gc::Gc;\n \n /// The types of pointers\n pub enum PtrTy<'a> {\n@@ -81,7 +82,7 @@ impl<'a> Path<'a> {\n /// A type. Supports pointers (except for *), Self, and literals\n pub enum Ty<'a> {\n     Self,\n-    // &/Box/@ Ty\n+    // &/Box/ Ty\n     Ptr(Box<Ty<'a>>, PtrTy<'a>),\n     // mod::mod::Type<[lifetime], [Params...]>, including a plain type\n     // parameter, and things like `int`\n@@ -244,7 +245,7 @@ impl<'a> LifetimeBounds<'a> {\n \n \n pub fn get_explicit_self(cx: &ExtCtxt, span: Span, self_ptr: &Option<PtrTy>)\n-    -> (@Expr, ast::ExplicitSelf) {\n+    -> (Gc<Expr>, ast::ExplicitSelf) {\n     let self_path = cx.expr_self(span);\n     match *self_ptr {\n         None => {"}, {"sha": "77fb013b269a222331a368e933bdedbb83e2946b", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -17,11 +17,13 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n \n+use std::gc::Gc;\n+\n pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n                             span: Span,\n-                            mitem: @MetaItem,\n-                            item: @Item,\n-                            push: |@Item|) {\n+                            mitem: Gc<MetaItem>,\n+                            item: Gc<Item>,\n+                            push: |Gc<Item>|) {\n \n     let (path, generics, args) = if cx.ecfg.deriving_hash_type_parameter {\n         (Path::new_(vec!(\"std\", \"hash\", \"Hash\"), None,\n@@ -64,7 +66,8 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n     hash_trait_def.expand(cx, mitem, item, push);\n }\n \n-fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n+fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span,\n+                     substr: &Substructure) -> Gc<Expr> {\n     let state_expr = match substr.nonself_args {\n         [state_expr] => state_expr,\n         _ => cx.span_bug(trait_span, \"incorrect number of arguments in `deriving(Hash)`\")"}, {"sha": "1833e56dbfb0895f0c6bebf547b70c44bbe8e19f", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -22,6 +22,8 @@ use ast::{Item, MetaItem, MetaList, MetaNameValue, MetaWord};\n use ext::base::ExtCtxt;\n use codemap::Span;\n \n+use std::gc::Gc;\n+\n pub mod bounds;\n pub mod clone;\n pub mod encodable;\n@@ -47,9 +49,9 @@ pub mod generic;\n \n pub fn expand_meta_deriving(cx: &mut ExtCtxt,\n                             _span: Span,\n-                            mitem: @MetaItem,\n-                            item: @Item,\n-                            push: |@Item|) {\n+                            mitem: Gc<MetaItem>,\n+                            item: Gc<Item>,\n+                            push: |Gc<Item>|) {\n     match mitem.node {\n         MetaNameValue(_, ref l) => {\n             cx.span_err(l.span, \"unexpected value in `deriving`\");"}, {"sha": "735497d9a2cf6ccfd6d50e9473d4545851cda2d5", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -17,11 +17,13 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n \n+use std::gc::Gc;\n+\n pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n                                       span: Span,\n-                                      mitem: @MetaItem,\n-                                      item: @Item,\n-                                      push: |@Item|) {\n+                                      mitem: Gc<MetaItem>,\n+                                      item: Gc<Item>,\n+                                      push: |Gc<Item>|) {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {\n@@ -70,7 +72,8 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n+fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span,\n+           substr: &Substructure) -> Gc<Expr> {\n     let n = match substr.nonself_args {\n         [n] => n,\n         _ => cx.span_bug(trait_span, \"incorrect number of arguments in `deriving(FromPrimitive)`\")"}, {"sha": "f6a15ea917e187c74910ce9563da32f02e07e655", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -16,11 +16,13 @@ use ext::build::{AstBuilder};\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n \n+use std::gc::Gc;\n+\n pub fn expand_deriving_rand(cx: &mut ExtCtxt,\n                             span: Span,\n-                            mitem: @MetaItem,\n-                            item: @Item,\n-                            push: |@Item|) {\n+                            mitem: Gc<MetaItem>,\n+                            item: Gc<Item>,\n+                            push: |Gc<Item>|) {\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n@@ -53,7 +55,8 @@ pub fn expand_deriving_rand(cx: &mut ExtCtxt,\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n+fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span,\n+                     substr: &Substructure) -> Gc<Expr> {\n     let rng = match substr.nonself_args {\n         [rng] => vec!( rng ),\n         _ => cx.bug(\"Incorrect number of arguments to `rand` in `deriving(Rand)`\")\n@@ -134,8 +137,8 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n                   trait_span: Span,\n                   ctor_ident: Ident,\n                   summary: &StaticFields,\n-                  rand_call: |&mut ExtCtxt, Span| -> @Expr)\n-                  -> @Expr {\n+                  rand_call: |&mut ExtCtxt, Span| -> Gc<Expr>)\n+                  -> Gc<Expr> {\n         match *summary {\n             Unnamed(ref fields) => {\n                 if fields.is_empty() {"}, {"sha": "9c5e41c8f60fa35ebab18a511c7a9cbe3f08f80d", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -20,12 +20,13 @@ use parse::token;\n \n use std::collections::HashMap;\n use std::string::String;\n+use std::gc::Gc;\n \n pub fn expand_deriving_show(cx: &mut ExtCtxt,\n                             span: Span,\n-                            mitem: @MetaItem,\n-                            item: @Item,\n-                            push: |@Item|) {\n+                            mitem: Gc<MetaItem>,\n+                            item: Gc<Item>,\n+                            push: |Gc<Item>|) {\n     // &mut ::std::fmt::Formatter\n     let fmtr = Ptr(box Literal(Path::new(vec!(\"std\", \"fmt\", \"Formatter\"))),\n                    Borrowed(None, ast::MutMutable));\n@@ -57,7 +58,7 @@ pub fn expand_deriving_show(cx: &mut ExtCtxt,\n // we construct a format string and then defer to std::fmt, since that\n // knows what's up with formatting at so on.\n fn show_substructure(cx: &mut ExtCtxt, span: Span,\n-                     substr: &Substructure) -> @Expr {\n+                     substr: &Substructure) -> Gc<Expr> {\n     // build `<name>`, `<name>({}, {}, ...)` or `<name> { <field>: {},\n     // <field>: {}, ... }` based on the \"shape\".\n     //"}, {"sha": "93947251223fd18eacc5a2e6f6d3eab521f48f88", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -16,11 +16,13 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n \n+use std::gc::Gc;\n+\n pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n                             span: Span,\n-                            mitem: @MetaItem,\n-                            item: @Item,\n-                            push: |@Item|) {\n+                            mitem: Gc<MetaItem>,\n+                            item: Gc<Item>,\n+                            push: |Gc<Item>|) {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {\n@@ -63,7 +65,8 @@ pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-fn zero_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n+fn zero_substructure(cx: &mut ExtCtxt, trait_span: Span,\n+                     substr: &Substructure) -> Gc<Expr> {\n     let zero_ident = vec!(\n         cx.ident_of(\"std\"),\n         cx.ident_of(\"num\"),"}, {"sha": "9efcb81e844e433fa14d5fea5f047a33cb13299a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 40, "deletions": 38, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -29,7 +29,9 @@ use visit;\n use visit::Visitor;\n use util::small_vector::SmallVector;\n \n-pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n+use std::gc::Gc;\n+\n+pub fn expand_expr(e: Gc<ast::Expr>, fld: &mut MacroExpander) -> Gc<ast::Expr> {\n     match e.node {\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n@@ -115,7 +117,7 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n                         fld.fold_expr(marked_after).node.clone();\n                     fld.cx.bt_pop();\n \n-                    @ast::Expr {\n+                    box(GC) ast::Expr {\n                         id: ast::DUMMY_NODE_ID,\n                         node: fully_expanded,\n                         span: e.span,\n@@ -256,7 +258,7 @@ fn expand_loop_block(loop_block: P<Block>,\n             // in a block enclosed by loop head.\n             fld.extsbox.push_frame();\n             fld.extsbox.info().pending_renames.push(rename);\n-            let expanded_block = expand_block_elts(loop_block, fld);\n+            let expanded_block = expand_block_elts(&*loop_block, fld);\n             fld.extsbox.pop_frame();\n \n             (expanded_block, Some(renamed_ident))\n@@ -277,8 +279,8 @@ macro_rules! with_exts_frame (\n )\n \n // When we enter a module, record it, for the sake of `module!`\n-pub fn expand_item(it: @ast::Item, fld: &mut MacroExpander)\n-                   -> SmallVector<@ast::Item> {\n+pub fn expand_item(it: Gc<ast::Item>, fld: &mut MacroExpander)\n+                   -> SmallVector<Gc<ast::Item>> {\n     let it = expand_item_modifiers(it, fld);\n \n     let mut decorator_items = SmallVector::zero();\n@@ -301,7 +303,7 @@ pub fn expand_item(it: @ast::Item, fld: &mut MacroExpander)\n \n                 // we'd ideally decorator_items.push_all(expand_item(item, fld)),\n                 // but that double-mut-borrows fld\n-                let mut items: SmallVector<@ast::Item> = SmallVector::zero();\n+                let mut items: SmallVector<Gc<ast::Item>> = SmallVector::zero();\n                 dec_fn(fld.cx, attr.span, attr.node.value, it,\n                        |item| items.push(item));\n                 decorator_items.extend(items.move_iter()\n@@ -320,34 +322,34 @@ pub fn expand_item(it: @ast::Item, fld: &mut MacroExpander)\n             let macro_escape = contains_macro_escape(new_attrs.as_slice());\n             let result = with_exts_frame!(fld.extsbox,\n                                           macro_escape,\n-                                          noop_fold_item(it, fld));\n+                                          noop_fold_item(&*it, fld));\n             fld.cx.mod_pop();\n             result\n         },\n         _ => {\n-            let it = @ast::Item {\n+            let it = box(GC) ast::Item {\n                 attrs: new_attrs,\n                 ..(*it).clone()\n \n             };\n-            noop_fold_item(it, fld)\n+            noop_fold_item(&*it, fld)\n         }\n     };\n \n     new_items.push_all(decorator_items);\n     new_items\n }\n \n-fn expand_item_modifiers(mut it: @ast::Item, fld: &mut MacroExpander)\n-                         -> @ast::Item {\n+fn expand_item_modifiers(mut it: Gc<ast::Item>, fld: &mut MacroExpander)\n+                         -> Gc<ast::Item> {\n     let (modifiers, attrs) = it.attrs.partitioned(|attr| {\n         match fld.extsbox.find(&intern(attr.name().get())) {\n             Some(&ItemModifier(_)) => true,\n             _ => false\n         }\n     });\n \n-    it = @ast::Item {\n+    it = box(GC) ast::Item {\n         attrs: attrs,\n         ..(*it).clone()\n     };\n@@ -388,8 +390,8 @@ pub fn contains_macro_escape(attrs: &[ast::Attribute]) -> bool {\n \n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n-pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n-                       -> SmallVector<@ast::Item> {\n+pub fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n+                       -> SmallVector<Gc<ast::Item>> {\n     let (pth, tts) = match it.node {\n         ItemMac(codemap::Spanned {\n             node: MacInvocTT(ref pth, ref tts, _),\n@@ -494,7 +496,7 @@ pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n }\n \n // expand a stmt\n-pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n+pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<Gc<Stmt>> {\n     // why the copying here and not in expand_expr?\n     // looks like classic changed-in-only-one-place\n     let (pth, tts, semi) = match s.node {\n@@ -550,7 +552,7 @@ pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n                 }\n             };\n \n-            mark_stmt(expanded,fm)\n+            mark_stmt(&*expanded,fm)\n         }\n \n         _ => {\n@@ -561,20 +563,20 @@ pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n     };\n \n     // Keep going, outside-in.\n-    let fully_expanded = fld.fold_stmt(marked_after);\n+    let fully_expanded = fld.fold_stmt(&*marked_after);\n     if fully_expanded.is_empty() {\n         fld.cx.span_err(pth.span, \"macro didn't expand to a statement\");\n         return SmallVector::zero();\n     }\n     fld.cx.bt_pop();\n-    let fully_expanded: SmallVector<@Stmt> = fully_expanded.move_iter()\n-            .map(|s| @Spanned { span: s.span, node: s.node.clone() })\n+    let fully_expanded: SmallVector<Gc<Stmt>> = fully_expanded.move_iter()\n+            .map(|s| box(GC) Spanned { span: s.span, node: s.node.clone() })\n             .collect();\n \n     fully_expanded.move_iter().map(|s| {\n         match s.node {\n             StmtExpr(e, stmt_id) if semi => {\n-                @Spanned {\n+                box(GC) Spanned {\n                     span: s.span,\n                     node: StmtSemi(e, stmt_id)\n                 }\n@@ -587,7 +589,7 @@ pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n // expand a non-macro stmt. this is essentially the fallthrough for\n // expand_stmt, above.\n fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n-                         -> SmallVector<@Stmt> {\n+                         -> SmallVector<Gc<Stmt>> {\n     // is it a let?\n     match s.node {\n         StmtDecl(decl, node_id) => {\n@@ -612,7 +614,7 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n                     // names, as well... but that should be okay, as long as\n                     // the new names are gensyms for the old ones.\n                     let mut name_finder = new_name_finder(Vec::new());\n-                    name_finder.visit_pat(expanded_pat,());\n+                    name_finder.visit_pat(&*expanded_pat,());\n                     // generate fresh names, push them to a new pending list\n                     let mut new_pending_renames = Vec::new();\n                     for ident in name_finder.ident_accumulator.iter() {\n@@ -631,16 +633,16 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n                     // also, don't forget to expand the init:\n                     let new_init_opt = init.map(|e| fld.fold_expr(e));\n                     let rewritten_local =\n-                        @Local {\n+                        box(GC) Local {\n                             ty: local.ty,\n                             pat: rewritten_pat,\n                             init: new_init_opt,\n                             id: id,\n                             span: span,\n                             source: source\n                         };\n-                    SmallVector::one(@Spanned {\n-                        node: StmtDecl(@Spanned {\n+                    SmallVector::one(box(GC) Spanned {\n+                        node: StmtDecl(box(GC) Spanned {\n                                 node: DeclLocal(rewritten_local),\n                                 span: stmt_span\n                             },\n@@ -687,7 +689,7 @@ impl Visitor<()> for NewNameFinderContext {\n                 }\n                 // visit optional subpattern of pat_ident:\n                 for subpat in inner.iter() {\n-                    self.visit_pat(*subpat, ())\n+                    self.visit_pat(&**subpat, ())\n                 }\n             }\n             // use the default traversal for non-pat_idents\n@@ -725,9 +727,9 @@ pub fn expand_block_elts(b: &Block, fld: &mut MacroExpander) -> P<Block> {\n             let renamed_stmt = {\n                 let pending_renames = &mut fld.extsbox.info().pending_renames;\n                 let mut rename_fld = renames_to_fold(pending_renames);\n-                rename_fld.fold_stmt(*x).expect_one(\"rename_fold didn't return one value\")\n+                rename_fld.fold_stmt(&**x).expect_one(\"rename_fold didn't return one value\")\n             };\n-            fld.fold_stmt(renamed_stmt).move_iter()\n+            fld.fold_stmt(&*renamed_stmt).move_iter()\n         }).collect();\n     let new_expr = b.expr.map(|x| {\n         let expr = {\n@@ -863,24 +865,24 @@ pub struct MacroExpander<'a, 'b> {\n }\n \n impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n-    fn fold_expr(&mut self, expr: @ast::Expr) -> @ast::Expr {\n+    fn fold_expr(&mut self, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         expand_expr(expr, self)\n     }\n \n-    fn fold_pat(&mut self, pat: @ast::Pat) -> @ast::Pat {\n+    fn fold_pat(&mut self, pat: Gc<ast::Pat>) -> Gc<ast::Pat> {\n         expand_pat(pat, self)\n     }\n \n-    fn fold_item(&mut self, item: @ast::Item) -> SmallVector<@ast::Item> {\n+    fn fold_item(&mut self, item: Gc<ast::Item>) -> SmallVector<Gc<ast::Item>> {\n         expand_item(item, self)\n     }\n \n-    fn fold_stmt(&mut self, stmt: &ast::Stmt) -> SmallVector<@ast::Stmt> {\n+    fn fold_stmt(&mut self, stmt: &ast::Stmt) -> SmallVector<Gc<ast::Stmt>> {\n         expand_stmt(stmt, self)\n     }\n \n     fn fold_block(&mut self, block: P<Block>) -> P<Block> {\n-        expand_block(block, self)\n+        expand_block(&*block, self)\n     }\n \n     fn new_span(&mut self, span: Span) -> Span {\n@@ -976,7 +978,7 @@ fn mark_tts(tts: &[TokenTree], m: Mrk) -> Vec<TokenTree> {\n }\n \n // apply a given mark to the given expr. Used following the expansion of a macro.\n-fn mark_expr(expr: @ast::Expr, m: Mrk) -> @ast::Expr {\n+fn mark_expr(expr: Gc<ast::Expr>, m: Mrk) -> Gc<ast::Expr> {\n     new_mark_folder(m).fold_expr(expr)\n }\n \n@@ -986,17 +988,17 @@ fn mark_pat(pat: @ast::Pat, m: Mrk) -> @ast::Pat {\n }\n \n // apply a given mark to the given stmt. Used following the expansion of a macro.\n-fn mark_stmt(expr: &ast::Stmt, m: Mrk) -> @ast::Stmt {\n+fn mark_stmt(expr: &ast::Stmt, m: Mrk) -> Gc<ast::Stmt> {\n     new_mark_folder(m).fold_stmt(expr)\n             .expect_one(\"marking a stmt didn't return a stmt\")\n }\n \n // apply a given mark to the given item. Used following the expansion of a macro.\n-fn mark_item(expr: @ast::Item, m: Mrk) -> SmallVector<@ast::Item> {\n+fn mark_item(expr: Gc<ast::Item>, m: Mrk) -> SmallVector<Gc<ast::Item>> {\n     new_mark_folder(m).fold_item(expr)\n }\n \n-fn original_span(cx: &ExtCtxt) -> @codemap::ExpnInfo {\n+fn original_span(cx: &ExtCtxt) -> Gc<codemap::ExpnInfo> {\n     let mut relevant_info = cx.backtrace();\n     let mut einfo = relevant_info.unwrap();\n     loop {\n@@ -1134,7 +1136,7 @@ mod test {\n             node: Attribute_ {\n                 id: attr::mk_attr_id(),\n                 style: AttrOuter,\n-                value: @Spanned {\n+                value: box(GC) Spanned {\n                     node: MetaWord(token::intern_and_get_ident(s)),\n                     span: codemap::DUMMY_SP,\n                 },"}, {"sha": "8cf290b826b9ab740b4afb0c1731b25fde6ee499", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -20,6 +20,7 @@ use rsparse = parse;\n \n use parse = fmt_macros;\n use std::collections::{HashMap, HashSet};\n+use std::gc::Gc;\n \n #[deriving(PartialEq)]\n enum ArgumentType {\n@@ -39,29 +40,29 @@ struct Context<'a, 'b> {\n \n     // Parsed argument expressions and the types that we've found so far for\n     // them.\n-    args: Vec<@ast::Expr>,\n+    args: Vec<Gc<ast::Expr>>,\n     arg_types: Vec<Option<ArgumentType>>,\n     // Parsed named expressions and the types that we've found for them so far.\n     // Note that we keep a side-array of the ordering of the named arguments\n     // found to be sure that we can translate them in the same order that they\n     // were declared in.\n-    names: HashMap<String, @ast::Expr>,\n+    names: HashMap<String, Gc<ast::Expr>>,\n     name_types: HashMap<String, ArgumentType>,\n     name_ordering: Vec<String>,\n \n     // Collection of the compiled `rt::Piece` structures\n-    pieces: Vec<@ast::Expr> ,\n+    pieces: Vec<Gc<ast::Expr>>,\n     name_positions: HashMap<String, uint>,\n-    method_statics: Vec<@ast::Item> ,\n+    method_statics: Vec<Gc<ast::Item>>,\n \n     // Updated as arguments are consumed or methods are entered\n     nest_level: uint,\n     next_arg: uint,\n }\n \n pub enum Invocation {\n-    Call(@ast::Expr),\n-    MethodCall(@ast::Expr, ast::Ident),\n+    Call(Gc<ast::Expr>),\n+    MethodCall(Gc<ast::Expr>, ast::Ident),\n }\n \n /// Parses the arguments from the given list of tokens, returning None\n@@ -74,10 +75,10 @@ pub enum Invocation {\n ///           named arguments))\n fn parse_args(ecx: &mut ExtCtxt, sp: Span, allow_method: bool,\n               tts: &[ast::TokenTree])\n-    -> (Invocation, Option<(@ast::Expr, Vec<@ast::Expr>, Vec<String>,\n-                            HashMap<String, @ast::Expr>)>) {\n+    -> (Invocation, Option<(Gc<ast::Expr>, Vec<Gc<ast::Expr>>, Vec<String>,\n+                            HashMap<String, Gc<ast::Expr>>)>) {\n     let mut args = Vec::new();\n-    let mut names = HashMap::<String, @ast::Expr>::new();\n+    let mut names = HashMap::<String, Gc<ast::Expr>>::new();\n     let mut order = Vec::new();\n \n     let mut p = rsparse::new_parser_from_tts(ecx.parse_sess(),\n@@ -399,15 +400,15 @@ impl<'a, 'b> Context<'a, 'b> {\n           self.ecx.ident_of(\"rt\"), self.ecx.ident_of(s))\n     }\n \n-    fn none(&self) -> @ast::Expr {\n+    fn none(&self) -> Gc<ast::Expr> {\n         let none = self.ecx.path_global(self.fmtsp, vec!(\n                 self.ecx.ident_of(\"std\"),\n                 self.ecx.ident_of(\"option\"),\n                 self.ecx.ident_of(\"None\")));\n         self.ecx.expr_path(none)\n     }\n \n-    fn some(&self, e: @ast::Expr) -> @ast::Expr {\n+    fn some(&self, e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         let p = self.ecx.path_global(self.fmtsp, vec!(\n                 self.ecx.ident_of(\"std\"),\n                 self.ecx.ident_of(\"option\"),\n@@ -416,7 +417,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         self.ecx.expr_call(self.fmtsp, p, vec!(e))\n     }\n \n-    fn trans_count(&self, c: parse::Count) -> @ast::Expr {\n+    fn trans_count(&self, c: parse::Count) -> Gc<ast::Expr> {\n         let sp = self.fmtsp;\n         match c {\n             parse::CountIs(i) => {\n@@ -447,7 +448,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n-    fn trans_method(&mut self, method: &parse::Method) -> @ast::Expr {\n+    fn trans_method(&mut self, method: &parse::Method) -> Gc<ast::Expr> {\n         let sp = self.fmtsp;\n         let method = match *method {\n             parse::Select(ref arms, ref default) => {\n@@ -528,7 +529,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     }\n \n     /// Translate a `parse::Piece` to a static `rt::Piece`\n-    fn trans_piece(&mut self, piece: &parse::Piece) -> @ast::Expr {\n+    fn trans_piece(&mut self, piece: &parse::Piece) -> Gc<ast::Expr> {\n         let sp = self.fmtsp;\n         match *piece {\n             parse::String(s) => {\n@@ -615,7 +616,7 @@ impl<'a, 'b> Context<'a, 'b> {\n \n     /// Actually builds the expression which the iformat! block will be expanded\n     /// to\n-    fn to_expr(&self, invocation: Invocation) -> @ast::Expr {\n+    fn to_expr(&self, invocation: Invocation) -> Gc<ast::Expr> {\n         let mut lets = Vec::new();\n         let mut locals = Vec::new();\n         let mut names = Vec::from_fn(self.name_positions.len(), |_| None);\n@@ -625,8 +626,8 @@ impl<'a, 'b> Context<'a, 'b> {\n         // First, declare all of our methods that are statics\n         for &method in self.method_statics.iter() {\n             let decl = respan(self.fmtsp, ast::DeclItem(method));\n-            lets.push(@respan(self.fmtsp,\n-                              ast::StmtDecl(@decl, ast::DUMMY_NODE_ID)));\n+            lets.push(box(GC) respan(self.fmtsp,\n+                              ast::StmtDecl(box(GC) decl, ast::DUMMY_NODE_ID)));\n         }\n \n         // Next, build up the static array which will become our precompiled\n@@ -653,7 +654,8 @@ impl<'a, 'b> Context<'a, 'b> {\n         let item = self.ecx.item(self.fmtsp, static_name,\n                                  self.static_attrs(), st);\n         let decl = respan(self.fmtsp, ast::DeclItem(item));\n-        lets.push(@respan(self.fmtsp, ast::StmtDecl(@decl, ast::DUMMY_NODE_ID)));\n+        lets.push(box(GC) respan(self.fmtsp,\n+                                 ast::StmtDecl(box(GC) decl, ast::DUMMY_NODE_ID)));\n \n         // Right now there is a bug such that for the expression:\n         //      foo(bar(&1))\n@@ -766,8 +768,8 @@ impl<'a, 'b> Context<'a, 'b> {\n         self.ecx.expr_match(self.fmtsp, head, vec!(arm))\n     }\n \n-    fn format_arg(&self, sp: Span, argno: Position, arg: @ast::Expr)\n-                  -> @ast::Expr {\n+    fn format_arg(&self, sp: Span, argno: Position, arg: Gc<ast::Expr>)\n+                  -> Gc<ast::Expr> {\n         let ty = match argno {\n             Exact(ref i) => self.arg_types.get(*i).get_ref(),\n             Named(ref s) => self.name_types.get(s)\n@@ -854,9 +856,12 @@ pub fn expand_format_args_method(ecx: &mut ExtCtxt, sp: Span,\n /// expression.\n pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n                                     invocation: Invocation,\n-                                    efmt: @ast::Expr, args: Vec<@ast::Expr>,\n+                                    efmt: Gc<ast::Expr>,\n+                                    args: Vec<Gc<ast::Expr>>,\n                                     name_ordering: Vec<String>,\n-                                    names: HashMap<String, @ast::Expr>) -> @ast::Expr {\n+                                    names: HashMap<String, Gc<ast::Expr>>)\n+    -> Gc<ast::Expr>\n+{\n     let arg_types = Vec::from_fn(args.len(), |_| None);\n     let mut cx = Context {\n         ecx: ecx,"}, {"sha": "5906f480d42b0a16f236b0894ad3d7c6f437ca34", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -17,6 +17,7 @@ use parse::token::*;\n use parse::token;\n use parse;\n \n+use std::gc::Gc;\n \n /**\n *\n@@ -50,6 +51,8 @@ pub mod rt {\n     pub use parse::new_parser_from_tts;\n     pub use codemap::{BytePos, Span, dummy_spanned};\n \n+    use std::gc::Gc;\n+\n     pub trait ToTokens {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> ;\n     }\n@@ -85,13 +88,13 @@ pub mod rt {\n         }\n     }\n \n-    impl ToSource for @ast::Item {\n+    impl ToSource for Gc<ast::Item> {\n         fn to_source(&self) -> String {\n             pprust::item_to_str(*self)\n         }\n     }\n \n-    impl<'a> ToSource for &'a [@ast::Item] {\n+    impl<'a> ToSource for &'a [Gc<ast::Item>] {\n         fn to_source(&self) -> String {\n             self.iter()\n                 .map(|i| i.to_source())\n@@ -123,7 +126,7 @@ pub mod rt {\n         }\n     }\n \n-    impl ToSource for @ast::Expr {\n+    impl ToSource for Gc<ast::Expr> {\n         fn to_source(&self) -> String {\n             pprust::expr_to_str(*self)\n         }\n@@ -263,12 +266,12 @@ pub mod rt {\n     )\n \n     impl_to_tokens!(ast::Ident)\n-    impl_to_tokens!(@ast::Item)\n-    impl_to_tokens_self!(&'a [@ast::Item])\n+    impl_to_tokens!(Gc<ast::Item>)\n+    impl_to_tokens_self!(&'a [Gc<ast::Item>])\n     impl_to_tokens!(ast::Ty)\n     impl_to_tokens_self!(&'a [ast::Ty])\n     impl_to_tokens!(Generics)\n-    impl_to_tokens!(@ast::Expr)\n+    impl_to_tokens!(Gc<ast::Expr>)\n     impl_to_tokens!(ast::Block)\n     impl_to_tokens!(ast::Arg)\n     impl_to_tokens_self!(&'a str)\n@@ -287,15 +290,15 @@ pub mod rt {\n     impl_to_tokens!(u64)\n \n     pub trait ExtParseUtils {\n-        fn parse_item(&self, s: String) -> @ast::Item;\n-        fn parse_expr(&self, s: String) -> @ast::Expr;\n-        fn parse_stmt(&self, s: String) -> @ast::Stmt;\n+        fn parse_item(&self, s: String) -> Gc<ast::Item>;\n+        fn parse_expr(&self, s: String) -> Gc<ast::Expr>;\n+        fn parse_stmt(&self, s: String) -> Gc<ast::Stmt>;\n         fn parse_tts(&self, s: String) -> Vec<ast::TokenTree> ;\n     }\n \n     impl<'a> ExtParseUtils for ExtCtxt<'a> {\n \n-        fn parse_item(&self, s: String) -> @ast::Item {\n+        fn parse_item(&self, s: String) -> Gc<ast::Item> {\n             let res = parse::parse_item_from_source_str(\n                 \"<quote expansion>\".to_string(),\n                 s,\n@@ -310,15 +313,15 @@ pub mod rt {\n             }\n         }\n \n-        fn parse_stmt(&self, s: String) -> @ast::Stmt {\n+        fn parse_stmt(&self, s: String) -> Gc<ast::Stmt> {\n             parse::parse_stmt_from_source_str(\"<quote expansion>\".to_string(),\n                                               s,\n                                               self.cfg(),\n                                               Vec::new(),\n                                               self.parse_sess())\n         }\n \n-        fn parse_expr(&self, s: String) -> @ast::Expr {\n+        fn parse_expr(&self, s: String) -> Gc<ast::Expr> {\n             parse::parse_expr_from_source_str(\"<quote expansion>\".to_string(),\n                                               s,\n                                               self.cfg(),\n@@ -400,25 +403,25 @@ fn id_ext(str: &str) -> ast::Ident {\n }\n \n // Lift an ident to the expr that evaluates to that ident.\n-fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> @ast::Expr {\n+fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> Gc<ast::Expr> {\n     let e_str = cx.expr_str(sp, token::get_ident(ident));\n     cx.expr_method_call(sp,\n                         cx.expr_ident(sp, id_ext(\"ext_cx\")),\n                         id_ext(\"ident_of\"),\n                         vec!(e_str))\n }\n \n-fn mk_ast_path(cx: &ExtCtxt, sp: Span, name: &str) -> @ast::Expr {\n+fn mk_ast_path(cx: &ExtCtxt, sp: Span, name: &str) -> Gc<ast::Expr> {\n     let idents = vec!(id_ext(\"syntax\"), id_ext(\"ast\"), id_ext(name));\n     cx.expr_path(cx.path_global(sp, idents))\n }\n \n-fn mk_token_path(cx: &ExtCtxt, sp: Span, name: &str) -> @ast::Expr {\n+fn mk_token_path(cx: &ExtCtxt, sp: Span, name: &str) -> Gc<ast::Expr> {\n     let idents = vec!(id_ext(\"syntax\"), id_ext(\"parse\"), id_ext(\"token\"), id_ext(name));\n     cx.expr_path(cx.path_global(sp, idents))\n }\n \n-fn mk_binop(cx: &ExtCtxt, sp: Span, bop: token::BinOp) -> @ast::Expr {\n+fn mk_binop(cx: &ExtCtxt, sp: Span, bop: token::BinOp) -> Gc<ast::Expr> {\n     let name = match bop {\n         PLUS => \"PLUS\",\n         MINUS => \"MINUS\",\n@@ -434,7 +437,7 @@ fn mk_binop(cx: &ExtCtxt, sp: Span, bop: token::BinOp) -> @ast::Expr {\n     mk_token_path(cx, sp, name)\n }\n \n-fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n+fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> Gc<ast::Expr> {\n \n     match *tok {\n         BINOP(binop) => {\n@@ -565,7 +568,8 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n     mk_token_path(cx, sp, name)\n }\n \n-fn mk_tt(cx: &ExtCtxt, sp: Span, tt: &ast::TokenTree) -> Vec<@ast::Stmt> {\n+\n+fn mk_tt(cx: &ExtCtxt, sp: Span, tt: &ast::TokenTree) -> Vec<Gc<ast::Stmt>> {\n     match *tt {\n         ast::TTTok(sp, ref tok) => {\n             let e_sp = cx.expr_ident(sp, id_ext(\"_sp\"));\n@@ -605,7 +609,7 @@ fn mk_tt(cx: &ExtCtxt, sp: Span, tt: &ast::TokenTree) -> Vec<@ast::Stmt> {\n }\n \n fn mk_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> Vec<@ast::Stmt> {\n+    -> Vec<Gc<ast::Stmt>> {\n     let mut ss = Vec::new();\n     for tt in tts.iter() {\n         ss.push_all_move(mk_tt(cx, sp, tt));\n@@ -614,7 +618,7 @@ fn mk_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n }\n \n fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-              -> (@ast::Expr, @ast::Expr) {\n+              -> (Gc<ast::Expr>, Gc<ast::Expr>) {\n     // NB: It appears that the main parser loses its mind if we consider\n     // $foo as a TTNonterminal during the main parse, so we have to re-parse\n     // under quote_depth > 0. This is silly and should go away; the _guess_ is\n@@ -686,8 +690,8 @@ fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n fn expand_wrapper(cx: &ExtCtxt,\n                   sp: Span,\n-                  cx_expr: @ast::Expr,\n-                  expr: @ast::Expr) -> @ast::Expr {\n+                  cx_expr: Gc<ast::Expr>,\n+                  expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n     let uses = [\n         &[\"syntax\", \"ext\", \"quote\", \"rt\"],\n     ].iter().map(|path| {\n@@ -703,8 +707,8 @@ fn expand_wrapper(cx: &ExtCtxt,\n fn expand_parse_call(cx: &ExtCtxt,\n                      sp: Span,\n                      parse_method: &str,\n-                     arg_exprs: Vec<@ast::Expr> ,\n-                     tts: &[ast::TokenTree]) -> @ast::Expr {\n+                     arg_exprs: Vec<Gc<ast::Expr>>,\n+                     tts: &[ast::TokenTree]) -> Gc<ast::Expr> {\n     let (cx_expr, tts_expr) = expand_tts(cx, sp, tts);\n \n     let cfg_call = || cx.expr_method_call("}, {"sha": "915fc16c15660a05368690c7e770dc05a0bcb81c", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -19,6 +19,7 @@ use parse;\n use parse::token;\n use print::pprust;\n \n+use std::gc::Gc;\n use std::io::File;\n use std::rc::Rc;\n use std::str;\n@@ -163,7 +164,7 @@ pub fn expand_include_bin(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n }\n \n // recur along an ExpnInfo chain to find the original expression\n-fn topmost_expn_info(expn_info: @codemap::ExpnInfo) -> @codemap::ExpnInfo {\n+fn topmost_expn_info(expn_info: Gc<codemap::ExpnInfo>) -> Gc<codemap::ExpnInfo> {\n     match *expn_info {\n         ExpnInfo { call_site: ref call_site, .. } => {\n             match call_site.expn_info {"}, {"sha": "85035a8d38e43a58b31c5c9ae2a838f10c2e464a", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -452,7 +452,7 @@ pub fn parse_nt(p: &mut Parser, name: &str) -> Nonterminal {\n       \"meta\" => token::NtMeta(p.parse_meta_item()),\n       \"tt\" => {\n         p.quote_depth += 1u; //but in theory, non-quoted tts might be useful\n-        let res = token::NtTT(@p.parse_token_tree());\n+        let res = token::NtTT(box(GC) p.parse_token_tree());\n         p.quote_depth -= 1u;\n         res\n       }"}, {"sha": "6607b6451c02a45fa8302e8acd99d2521a582f92", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -29,6 +29,7 @@ use util::small_vector::SmallVector;\n \n use std::cell::RefCell;\n use std::rc::Rc;\n+use std::gc::Gc;\n \n struct ParserAnyMacro<'a> {\n     parser: RefCell<Parser<'a>>,\n@@ -58,17 +59,17 @@ impl<'a> ParserAnyMacro<'a> {\n }\n \n impl<'a> MacResult for ParserAnyMacro<'a> {\n-    fn make_expr(&self) -> Option<@ast::Expr> {\n+    fn make_expr(&self) -> Option<Gc<ast::Expr>> {\n         let ret = self.parser.borrow_mut().parse_expr();\n         self.ensure_complete_parse(true);\n         Some(ret)\n     }\n-    fn make_pat(&self) -> Option<@ast::Pat> {\n+    fn make_pat(&self) -> Option<Gc<ast::Pat>> {\n         let ret = self.parser.borrow_mut().parse_pat();\n         self.ensure_complete_parse(false);\n         Some(ret)\n     }\n-    fn make_items(&self) -> Option<SmallVector<@ast::Item>> {\n+    fn make_items(&self) -> Option<SmallVector<Gc<ast::Item>>> {\n         let mut ret = SmallVector::zero();\n         loop {\n             let mut parser = self.parser.borrow_mut();\n@@ -81,7 +82,7 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n         self.ensure_complete_parse(false);\n         Some(ret)\n     }\n-    fn make_stmt(&self) -> Option<@ast::Stmt> {\n+    fn make_stmt(&self) -> Option<Gc<ast::Stmt>> {\n         let attrs = self.parser.borrow_mut().parse_outer_attributes();\n         let ret = self.parser.borrow_mut().parse_stmt(attrs);\n         self.ensure_complete_parse(true);"}, {"sha": "c20d1b70996dd578d2fe4792666d7e7929bdb469", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 59, "deletions": 51, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -17,18 +17,19 @@ use owned_slice::OwnedSlice;\n use util::small_vector::SmallVector;\n \n use std::rc::Rc;\n+use std::gc::Gc;\n \n // We may eventually want to be able to fold over type parameters, too.\n pub trait Folder {\n     fn fold_crate(&mut self, c: Crate) -> Crate {\n         noop_fold_crate(c, self)\n     }\n \n-    fn fold_meta_items(&mut self, meta_items: &[@MetaItem]) -> Vec<@MetaItem> {\n+    fn fold_meta_items(&mut self, meta_items: &[Gc<MetaItem>]) -> Vec<Gc<MetaItem>> {\n         meta_items.iter().map(|x| fold_meta_item_(*x, self)).collect()\n     }\n \n-    fn fold_view_path(&mut self, view_path: @ViewPath) -> @ViewPath {\n+    fn fold_view_path(&mut self, view_path: Gc<ViewPath>) -> Gc<ViewPath> {\n         let inner_view_path = match view_path.node {\n             ViewPathSimple(ref ident, ref path, node_id) => {\n                 let id = self.new_id(node_id);\n@@ -60,7 +61,7 @@ pub trait Folder {\n                              id)\n             }\n         };\n-        @Spanned {\n+        box(GC) Spanned {\n             node: inner_view_path,\n             span: self.new_span(view_path.span),\n         }\n@@ -70,12 +71,12 @@ pub trait Folder {\n         noop_fold_view_item(vi, self)\n     }\n \n-    fn fold_foreign_item(&mut self, ni: @ForeignItem) -> @ForeignItem {\n-        noop_fold_foreign_item(ni, self)\n+    fn fold_foreign_item(&mut self, ni: Gc<ForeignItem>) -> Gc<ForeignItem> {\n+        noop_fold_foreign_item(&*ni, self)\n     }\n \n-    fn fold_item(&mut self, i: @Item) -> SmallVector<@Item> {\n-        noop_fold_item(i, self)\n+    fn fold_item(&mut self, i: Gc<Item>) -> SmallVector<Gc<Item>> {\n+        noop_fold_item(&*i, self)\n     }\n \n     fn fold_struct_field(&mut self, sf: &StructField) -> StructField {\n@@ -103,15 +104,15 @@ pub trait Folder {\n         noop_fold_type_method(m, self)\n     }\n \n-    fn fold_method(&mut self, m: @Method) -> @Method {\n-        noop_fold_method(m, self)\n+    fn fold_method(&mut self, m: Gc<Method>) -> Gc<Method>  {\n+        noop_fold_method(&*m, self)\n     }\n \n     fn fold_block(&mut self, b: P<Block>) -> P<Block> {\n         noop_fold_block(b, self)\n     }\n \n-    fn fold_stmt(&mut self, s: &Stmt) -> SmallVector<@Stmt> {\n+    fn fold_stmt(&mut self, s: &Stmt) -> SmallVector<Gc<Stmt>> {\n         noop_fold_stmt(s, self)\n     }\n \n@@ -124,11 +125,11 @@ pub trait Folder {\n         }\n     }\n \n-    fn fold_pat(&mut self, p: @Pat) -> @Pat {\n+    fn fold_pat(&mut self, p: Gc<Pat>) -> Gc<Pat> {\n         noop_fold_pat(p, self)\n     }\n \n-    fn fold_decl(&mut self, d: @Decl) -> SmallVector<@Decl> {\n+    fn fold_decl(&mut self, d: Gc<Decl>) -> SmallVector<Gc<Decl>> {\n         let node = match d.node {\n             DeclLocal(ref l) => SmallVector::one(DeclLocal(self.fold_local(*l))),\n             DeclItem(it) => {\n@@ -137,14 +138,14 @@ pub trait Folder {\n         };\n \n         node.move_iter().map(|node| {\n-            @Spanned {\n+            box(GC) Spanned {\n                 node: node,\n                 span: self.new_span(d.span),\n             }\n         }).collect()\n     }\n \n-    fn fold_expr(&mut self, e: @Expr) -> @Expr {\n+    fn fold_expr(&mut self, e: Gc<Expr>) -> Gc<Expr> {\n         noop_fold_expr(e, self)\n     }\n \n@@ -160,29 +161,29 @@ pub trait Folder {\n                 TyRptr(fold_opt_lifetime(region, self), fold_mt(mt, self))\n             }\n             TyClosure(ref f, ref region) => {\n-                TyClosure(@ClosureTy {\n+                TyClosure(box(GC) ClosureTy {\n                     fn_style: f.fn_style,\n                     onceness: f.onceness,\n                     bounds: fold_opt_bounds(&f.bounds, self),\n-                    decl: self.fold_fn_decl(f.decl),\n+                    decl: self.fold_fn_decl(&*f.decl),\n                     lifetimes: f.lifetimes.iter().map(|l| self.fold_lifetime(l)).collect(),\n                 }, fold_opt_lifetime(region, self))\n             }\n             TyProc(ref f) => {\n-                TyProc(@ClosureTy {\n+                TyProc(box(GC) ClosureTy {\n                     fn_style: f.fn_style,\n                     onceness: f.onceness,\n                     bounds: fold_opt_bounds(&f.bounds, self),\n-                    decl: self.fold_fn_decl(f.decl),\n+                    decl: self.fold_fn_decl(&*f.decl),\n                     lifetimes: f.lifetimes.iter().map(|l| self.fold_lifetime(l)).collect(),\n                 })\n             }\n             TyBareFn(ref f) => {\n-                TyBareFn(@BareFnTy {\n+                TyBareFn(box(GC) BareFnTy {\n                     lifetimes: f.lifetimes.iter().map(|l| self.fold_lifetime(l)).collect(),\n                     fn_style: f.fn_style,\n                     abi: f.abi,\n-                    decl: self.fold_fn_decl(f.decl)\n+                    decl: self.fold_fn_decl(&*f.decl)\n                 })\n             }\n             TyUnboxedFn(ref f) => {\n@@ -236,7 +237,7 @@ pub trait Folder {\n                     fold_variant_arg_(x, self)).collect())\n             }\n             StructVariantKind(ref struct_def) => {\n-                kind = StructVariantKind(@ast::StructDef {\n+                kind = StructVariantKind(box(GC) ast::StructDef {\n                     fields: struct_def.fields.iter()\n                         .map(|f| self.fold_struct_field(f)).collect(),\n                     ctor_id: struct_def.ctor_id.map(|c| self.new_id(c)),\n@@ -285,9 +286,9 @@ pub trait Folder {\n         }\n     }\n \n-    fn fold_local(&mut self, l: @Local) -> @Local {\n+    fn fold_local(&mut self, l: Gc<Local>) -> Gc<Local> {\n         let id = self.new_id(l.id); // Needs to be first, for ast_map.\n-        @Local {\n+        box(GC) Local {\n             id: id,\n             ty: self.fold_ty(l.ty),\n             pat: self.fold_pat(l.pat),\n@@ -310,7 +311,8 @@ pub trait Folder {\n         }\n     }\n \n-    fn map_exprs(&self, f: |@Expr| -> @Expr, es: &[@Expr]) -> Vec<@Expr> {\n+    fn map_exprs(&self, f: |Gc<Expr>| -> Gc<Expr>,\n+                 es: &[Gc<Expr>]) -> Vec<Gc<Expr>> {\n         es.iter().map(|x| f(*x)).collect()\n     }\n \n@@ -346,8 +348,8 @@ pub trait Folder {\n /* some little folds that probably aren't useful to have in Folder itself*/\n \n //used in noop_fold_item and noop_fold_crate and noop_fold_crate_directive\n-fn fold_meta_item_<T: Folder>(mi: @MetaItem, fld: &mut T) -> @MetaItem {\n-    @Spanned {\n+fn fold_meta_item_<T: Folder>(mi: Gc<MetaItem>, fld: &mut T) -> Gc<MetaItem> {\n+    box(GC) Spanned {\n         node:\n             match mi.node {\n                 MetaWord(ref id) => MetaWord((*id).clone()),\n@@ -495,8 +497,9 @@ pub fn fold_generics<T: Folder>(generics: &Generics, fld: &mut T) -> Generics {\n               lifetimes: fold_lifetimes(&generics.lifetimes, fld)}\n }\n \n-fn fold_struct_def<T: Folder>(struct_def: @StructDef, fld: &mut T) -> @StructDef {\n-    @ast::StructDef {\n+fn fold_struct_def<T: Folder>(struct_def: Gc<StructDef>,\n+                              fld: &mut T) -> Gc<StructDef> {\n+    box(GC) ast::StructDef {\n         fields: struct_def.fields.iter().map(|f| fold_struct_field(f, fld)).collect(),\n         ctor_id: struct_def.ctor_id.map(|cid| fld.new_id(cid)),\n         super_struct: match struct_def.super_struct {\n@@ -583,7 +586,7 @@ pub fn noop_fold_view_item<T: Folder>(vi: &ViewItem, folder: &mut T)\n pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n     let id = folder.new_id(b.id); // Needs to be first, for ast_map.\n     let view_items = b.view_items.iter().map(|x| folder.fold_view_item(x)).collect();\n-    let stmts = b.stmts.iter().flat_map(|s| folder.fold_stmt(*s).move_iter()).collect();\n+    let stmts = b.stmts.iter().flat_map(|s| folder.fold_stmt(&**s).move_iter()).collect();\n     P(Block {\n         id: id,\n         view_items: view_items,\n@@ -601,7 +604,7 @@ pub fn noop_fold_item_underscore<T: Folder>(i: &Item_, folder: &mut T) -> Item_\n         }\n         ItemFn(decl, fn_style, abi, ref generics, body) => {\n             ItemFn(\n-                folder.fold_fn_decl(decl),\n+                folder.fold_fn_decl(&*decl),\n                 fn_style,\n                 abi,\n                 fold_generics(generics, folder),\n@@ -617,7 +620,7 @@ pub fn noop_fold_item_underscore<T: Folder>(i: &Item_, folder: &mut T) -> Item_\n             ItemEnum(\n                 ast::EnumDef {\n                     variants: enum_definition.variants.iter().map(|&x| {\n-                        folder.fold_variant(x)\n+                        folder.fold_variant(&*x)\n                     }).collect(),\n                 },\n                 fold_generics(generics, folder))\n@@ -656,7 +659,7 @@ pub fn noop_fold_type_method<T: Folder>(m: &TypeMethod, fld: &mut T) -> TypeMeth\n         ident: fld.fold_ident(m.ident),\n         attrs: m.attrs.iter().map(|a| fold_attribute_(*a, fld)).collect(),\n         fn_style: m.fn_style,\n-        decl: fld.fold_fn_decl(m.decl),\n+        decl: fld.fold_fn_decl(&*m.decl),\n         generics: fold_generics(&m.generics, fld),\n         explicit_self: fld.fold_explicit_self(&m.explicit_self),\n         span: fld.new_span(m.span),\n@@ -683,18 +686,19 @@ pub fn noop_fold_crate<T: Folder>(c: Crate, folder: &mut T) -> Crate {\n     }\n }\n \n-pub fn noop_fold_item<T: Folder>(i: &Item, folder: &mut T) -> SmallVector<@Item> {\n+pub fn noop_fold_item<T: Folder>(i: &Item,\n+                                 folder: &mut T) -> SmallVector<Gc<Item>> {\n     let id = folder.new_id(i.id); // Needs to be first, for ast_map.\n     let node = folder.fold_item_underscore(&i.node);\n     let ident = match node {\n         // The node may have changed, recompute the \"pretty\" impl name.\n         ItemImpl(_, ref maybe_trait, ty, _) => {\n-            ast_util::impl_pretty_name(maybe_trait, ty)\n+            ast_util::impl_pretty_name(maybe_trait, &*ty)\n         }\n         _ => i.ident\n     };\n \n-    SmallVector::one(@Item {\n+    SmallVector::one(box(GC) Item {\n         id: id,\n         ident: folder.fold_ident(ident),\n         attrs: i.attrs.iter().map(|e| fold_attribute_(*e, folder)).collect(),\n@@ -704,9 +708,10 @@ pub fn noop_fold_item<T: Folder>(i: &Item, folder: &mut T) -> SmallVector<@Item>\n     })\n }\n \n-pub fn noop_fold_foreign_item<T: Folder>(ni: &ForeignItem, folder: &mut T) -> @ForeignItem {\n+pub fn noop_fold_foreign_item<T: Folder>(ni: &ForeignItem,\n+                                         folder: &mut T) -> Gc<ForeignItem> {\n     let id = folder.new_id(ni.id); // Needs to be first, for ast_map.\n-    @ForeignItem {\n+    box(GC) ForeignItem {\n         id: id,\n         ident: folder.fold_ident(ni.ident),\n         attrs: ni.attrs.iter().map(|x| fold_attribute_(*x, folder)).collect(),\n@@ -728,23 +733,23 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: &ForeignItem, folder: &mut T) -> @F\n     }\n }\n \n-pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> @Method {\n+pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> Gc<Method> {\n     let id = folder.new_id(m.id); // Needs to be first, for ast_map.\n-    @Method {\n+    box(GC) Method {\n         id: id,\n         ident: folder.fold_ident(m.ident),\n         attrs: m.attrs.iter().map(|a| fold_attribute_(*a, folder)).collect(),\n         generics: fold_generics(&m.generics, folder),\n         explicit_self: folder.fold_explicit_self(&m.explicit_self),\n         fn_style: m.fn_style,\n-        decl: folder.fold_fn_decl(m.decl),\n+        decl: folder.fold_fn_decl(&*m.decl),\n         body: folder.fold_block(m.body),\n         span: folder.new_span(m.span),\n         vis: m.vis\n     }\n }\n \n-pub fn noop_fold_pat<T: Folder>(p: @Pat, folder: &mut T) -> @Pat {\n+pub fn noop_fold_pat<T: Folder>(p: Gc<Pat>, folder: &mut T) -> Gc<Pat> {\n     let id = folder.new_id(p.id);\n     let node = match p.node {\n         PatWild => PatWild,\n@@ -783,14 +788,14 @@ pub fn noop_fold_pat<T: Folder>(p: @Pat, folder: &mut T) -> @Pat {\n         PatMac(ref mac) => PatMac(folder.fold_mac(mac)),\n     };\n \n-    @Pat {\n+    box(GC) Pat {\n         id: id,\n         span: folder.new_span(p.span),\n         node: node,\n     }\n }\n \n-pub fn noop_fold_expr<T: Folder>(e: @Expr, folder: &mut T) -> @Expr {\n+pub fn noop_fold_expr<T: Folder>(e: Gc<Expr>, folder: &mut T) -> Gc<Expr> {\n     let id = folder.new_id(e.id);\n     let node = match e.node {\n         ExprVstore(e, v) => {\n@@ -851,13 +856,15 @@ pub fn noop_fold_expr<T: Folder>(e: @Expr, folder: &mut T) -> @Expr {\n             ExprMatch(folder.fold_expr(expr),\n                       arms.iter().map(|x| folder.fold_arm(x)).collect())\n         }\n-        ExprFnBlock(decl, body) => {\n-            ExprFnBlock(folder.fold_fn_decl(decl), folder.fold_block(body))\n+        ExprFnBlock(ref decl, ref body) => {\n+            ExprFnBlock(folder.fold_fn_decl(&**decl),\n+                        folder.fold_block(body.clone()))\n         }\n-        ExprProc(decl, body) => {\n-            ExprProc(folder.fold_fn_decl(decl), folder.fold_block(body))\n+        ExprProc(ref decl, ref body) => {\n+            ExprProc(folder.fold_fn_decl(&**decl),\n+                     folder.fold_block(body.clone()))\n         }\n-        ExprBlock(blk) => ExprBlock(folder.fold_block(blk)),\n+        ExprBlock(ref blk) => ExprBlock(folder.fold_block(blk.clone())),\n         ExprAssign(el, er) => {\n             ExprAssign(folder.fold_expr(el), folder.fold_expr(er))\n         }\n@@ -900,14 +907,15 @@ pub fn noop_fold_expr<T: Folder>(e: @Expr, folder: &mut T) -> @Expr {\n         ExprParen(ex) => ExprParen(folder.fold_expr(ex))\n     };\n \n-    @Expr {\n+    box(GC) Expr {\n         id: id,\n         node: node,\n         span: folder.new_span(e.span),\n     }\n }\n \n-pub fn noop_fold_stmt<T: Folder>(s: &Stmt, folder: &mut T) -> SmallVector<@Stmt> {\n+pub fn noop_fold_stmt<T: Folder>(s: &Stmt,\n+                                 folder: &mut T) -> SmallVector<Gc<Stmt>> {\n     let nodes = match s.node {\n         StmtDecl(d, id) => {\n             let id = folder.new_id(id);\n@@ -926,7 +934,7 @@ pub fn noop_fold_stmt<T: Folder>(s: &Stmt, folder: &mut T) -> SmallVector<@Stmt>\n         StmtMac(ref mac, semi) => SmallVector::one(StmtMac(folder.fold_mac(mac), semi))\n     };\n \n-    nodes.move_iter().map(|node| @Spanned {\n+    nodes.move_iter().map(|node| box(GC) Spanned {\n         node: node,\n         span: folder.new_span(s.span),\n     }).collect()"}, {"sha": "64766b5013cbb74c0fc386a9c59b6cab5a65341e", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -16,15 +16,17 @@ use parse::token;\n use parse::parser::Parser;\n use parse::token::INTERPOLATED;\n \n+use std::gc::Gc;\n+\n // a parser that can parse attributes.\n pub trait ParserAttr {\n-    fn parse_outer_attributes(&mut self) -> Vec<ast::Attribute> ;\n+    fn parse_outer_attributes(&mut self) -> Vec<ast::Attribute>;\n     fn parse_attribute(&mut self, permit_inner: bool) -> ast::Attribute;\n     fn parse_inner_attrs_and_next(&mut self)\n-                                  -> (Vec<ast::Attribute> , Vec<ast::Attribute> );\n-    fn parse_meta_item(&mut self) -> @ast::MetaItem;\n-    fn parse_meta_seq(&mut self) -> Vec<@ast::MetaItem> ;\n-    fn parse_optional_meta(&mut self) -> Vec<@ast::MetaItem> ;\n+                                  -> (Vec<ast::Attribute>, Vec<ast::Attribute>);\n+    fn parse_meta_item(&mut self) -> Gc<ast::MetaItem>;\n+    fn parse_meta_seq(&mut self) -> Vec<Gc<ast::MetaItem>>;\n+    fn parse_optional_meta(&mut self) -> Vec<Gc<ast::MetaItem>>;\n }\n \n impl<'a> ParserAttr for Parser<'a> {\n@@ -157,7 +159,7 @@ impl<'a> ParserAttr for Parser<'a> {\n     // matches meta_item = IDENT\n     // | IDENT = lit\n     // | IDENT meta_seq\n-    fn parse_meta_item(&mut self) -> @ast::MetaItem {\n+    fn parse_meta_item(&mut self) -> Gc<ast::MetaItem> {\n         match self.token {\n             token::INTERPOLATED(token::NtMeta(e)) => {\n                 self.bump();\n@@ -184,29 +186,29 @@ impl<'a> ParserAttr for Parser<'a> {\n                     }\n                 }\n                 let hi = self.span.hi;\n-                @spanned(lo, hi, ast::MetaNameValue(name, lit))\n+                box(GC) spanned(lo, hi, ast::MetaNameValue(name, lit))\n             }\n             token::LPAREN => {\n                 let inner_items = self.parse_meta_seq();\n                 let hi = self.span.hi;\n-                @spanned(lo, hi, ast::MetaList(name, inner_items))\n+                box(GC) spanned(lo, hi, ast::MetaList(name, inner_items))\n             }\n             _ => {\n                 let hi = self.last_span.hi;\n-                @spanned(lo, hi, ast::MetaWord(name))\n+                box(GC) spanned(lo, hi, ast::MetaWord(name))\n             }\n         }\n     }\n \n     // matches meta_seq = ( COMMASEP(meta_item) )\n-    fn parse_meta_seq(&mut self) -> Vec<@ast::MetaItem> {\n+    fn parse_meta_seq(&mut self) -> Vec<Gc<ast::MetaItem>> {\n         self.parse_seq(&token::LPAREN,\n                        &token::RPAREN,\n                        seq_sep_trailing_disallowed(token::COMMA),\n                        |p| p.parse_meta_item()).node\n     }\n \n-    fn parse_optional_meta(&mut self) -> Vec<@ast::MetaItem> {\n+    fn parse_optional_meta(&mut self) -> Vec<Gc<ast::MetaItem>> {\n         match self.token {\n             token::LPAREN => self.parse_meta_seq(),\n             _ => Vec::new()"}, {"sha": "8d9cc305c26e815d8c65393e5af4fa96623707f8", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -13,6 +13,7 @@\n // Predicates on exprs and stmts that the pretty-printer and parser use\n \n use ast;\n+use std::gc::Gc;\n \n // does this expression require a semicolon to be treated\n // as a statement? The negation of this: 'can this expression\n@@ -21,7 +22,7 @@ use ast;\n // 'if true {...} else {...}\n //  |x| 5 '\n // isn't parsed as (if true {...} else {...} | x) | 5\n-pub fn expr_requires_semi_to_be_stmt(e: @ast::Expr) -> bool {\n+pub fn expr_requires_semi_to_be_stmt(e: Gc<ast::Expr>) -> bool {\n     match e.node {\n         ast::ExprIf(..)\n         | ast::ExprMatch(..)\n@@ -33,7 +34,7 @@ pub fn expr_requires_semi_to_be_stmt(e: @ast::Expr) -> bool {\n     }\n }\n \n-pub fn expr_is_simple_block(e: @ast::Expr) -> bool {\n+pub fn expr_is_simple_block(e: Gc<ast::Expr>) -> bool {\n     match e.node {\n         ast::ExprBlock(block) => block.rules == ast::DefaultBlock,\n       _ => false"}, {"sha": "88746d145b6fcffceb919b189024c099138aa535", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -18,6 +18,7 @@ use parse::attr::ParserAttr;\n use parse::parser::Parser;\n \n use std::cell::RefCell;\n+use std::gc::Gc;\n use std::io::File;\n use std::rc::Rc;\n use std::str;\n@@ -105,7 +106,7 @@ pub fn parse_expr_from_source_str(name: String,\n                                   source: String,\n                                   cfg: ast::CrateConfig,\n                                   sess: &ParseSess)\n-                                  -> @ast::Expr {\n+                                  -> Gc<ast::Expr> {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     maybe_aborted(p.parse_expr(), p)\n }\n@@ -114,7 +115,7 @@ pub fn parse_item_from_source_str(name: String,\n                                   source: String,\n                                   cfg: ast::CrateConfig,\n                                   sess: &ParseSess)\n-                                  -> Option<@ast::Item> {\n+                                  -> Option<Gc<ast::Item>> {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     let attrs = p.parse_outer_attributes();\n     maybe_aborted(p.parse_item(attrs),p)\n@@ -124,7 +125,7 @@ pub fn parse_meta_from_source_str(name: String,\n                                   source: String,\n                                   cfg: ast::CrateConfig,\n                                   sess: &ParseSess)\n-                                  -> @ast::MetaItem {\n+                                  -> Gc<ast::MetaItem> {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     maybe_aborted(p.parse_meta_item(),p)\n }\n@@ -134,7 +135,7 @@ pub fn parse_stmt_from_source_str(name: String,\n                                   cfg: ast::CrateConfig,\n                                   attrs: Vec<ast::Attribute> ,\n                                   sess: &ParseSess)\n-                                  -> @ast::Stmt {\n+                                  -> Gc<ast::Stmt> {\n     let mut p = new_parser_from_source_str(\n         sess,\n         cfg,\n@@ -306,7 +307,7 @@ mod test {\n \n     #[test] fn path_exprs_1() {\n         assert!(string_to_expr(\"a\".to_string()) ==\n-                   @ast::Expr{\n+                   box(GC) ast::Expr{\n                     id: ast::DUMMY_NODE_ID,\n                     node: ast::ExprPath(ast::Path {\n                         span: sp(0, 1),\n@@ -325,7 +326,7 @@ mod test {\n \n     #[test] fn path_exprs_2 () {\n         assert!(string_to_expr(\"::a::b\".to_string()) ==\n-                   @ast::Expr {\n+                   box(GC) ast::Expr {\n                     id: ast::DUMMY_NODE_ID,\n                     node: ast::ExprPath(ast::Path {\n                             span: sp(0, 6),\n@@ -537,9 +538,9 @@ mod test {\n \n     #[test] fn ret_expr() {\n         assert!(string_to_expr(\"return d\".to_string()) ==\n-                   @ast::Expr{\n+                   box(GC) ast::Expr{\n                     id: ast::DUMMY_NODE_ID,\n-                    node:ast::ExprRet(Some(@ast::Expr{\n+                    node:ast::ExprRet(Some(box(GC) ast::Expr{\n                         id: ast::DUMMY_NODE_ID,\n                         node:ast::ExprPath(ast::Path{\n                             span: sp(7, 8),\n@@ -560,8 +561,8 @@ mod test {\n \n     #[test] fn parse_stmt_1 () {\n         assert!(string_to_stmt(\"b;\".to_string()) ==\n-                   @Spanned{\n-                       node: ast::StmtExpr(@ast::Expr {\n+                   box(GC) Spanned{\n+                       node: ast::StmtExpr(box(GC) ast::Expr {\n                            id: ast::DUMMY_NODE_ID,\n                            node: ast::ExprPath(ast::Path {\n                                span:sp(0,1),\n@@ -588,7 +589,7 @@ mod test {\n         let sess = new_parse_sess();\n         let mut parser = string_to_parser(&sess, \"b\".to_string());\n         assert!(parser.parse_pat() ==\n-                   @ast::Pat{id: ast::DUMMY_NODE_ID,\n+                   box(GC) ast::Pat{id: ast::DUMMY_NODE_ID,\n                              node: ast::PatIdent(\n                                 ast::BindByValue(ast::MutImmutable),\n                                 ast::Path {\n@@ -612,7 +613,7 @@ mod test {\n         // this test depends on the intern order of \"fn\" and \"int\"\n         assert!(string_to_item(\"fn a (b : int) { b; }\".to_string()) ==\n                   Some(\n-                      @ast::Item{ident:str_to_ident(\"a\"),\n+                      box(GC) ast::Item{ident:str_to_ident(\"a\"),\n                             attrs:Vec::new(),\n                             id: ast::DUMMY_NODE_ID,\n                             node: ast::ItemFn(ast::P(ast::FnDecl {\n@@ -632,7 +633,7 @@ mod test {\n                                         }, None, ast::DUMMY_NODE_ID),\n                                         span:sp(10,13)\n                                     }),\n-                                    pat: @ast::Pat {\n+                                    pat: box(GC) ast::Pat {\n                                         id: ast::DUMMY_NODE_ID,\n                                         node: ast::PatIdent(\n                                             ast::BindByValue(ast::MutImmutable),\n@@ -668,8 +669,8 @@ mod test {\n                                     },\n                                     ast::P(ast::Block {\n                                         view_items: Vec::new(),\n-                                        stmts: vec!(@Spanned{\n-                                            node: ast::StmtSemi(@ast::Expr{\n+                                        stmts: vec!(box(GC) Spanned{\n+                                            node: ast::StmtSemi(box(GC) ast::Expr{\n                                                 id: ast::DUMMY_NODE_ID,\n                                                 node: ast::ExprPath(\n                                                       ast::Path{\n@@ -703,12 +704,12 @@ mod test {\n     #[test] fn parse_exprs () {\n         // just make sure that they parse....\n         string_to_expr(\"3 + 4\".to_string());\n-        string_to_expr(\"a::z.froob(b,@(987+3))\".to_string());\n+        string_to_expr(\"a::z.froob(b,box(GC)(987+3))\".to_string());\n     }\n \n     #[test] fn attrs_fix_bug () {\n         string_to_item(\"pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n-                   -> Result<@Writer, String> {\n+                   -> Result<Gc<Writer>, String> {\n     #[cfg(windows)]\n     fn wb() -> c_int {\n       (O_WRONLY | libc::consts::os::extra::O_BINARY) as c_int"}, {"sha": "9706176ca8babbe9e26a4d7b567a187a5c5737a7", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -22,6 +22,8 @@ use codemap::{Span, respan};\n use parse::parser;\n use parse::token;\n \n+use std::gc::Gc;\n+\n /// The specific types of unsupported syntax\n #[deriving(PartialEq, Eq, Hash)]\n pub enum ObsoleteSyntax {\n@@ -35,7 +37,7 @@ pub trait ParserObsoleteMethods {\n     fn obsolete(&mut self, sp: Span, kind: ObsoleteSyntax);\n     // Reports an obsolete syntax non-fatal error, and returns\n     // a placeholder expression\n-    fn obsolete_expr(&mut self, sp: Span, kind: ObsoleteSyntax) -> @Expr;\n+    fn obsolete_expr(&mut self, sp: Span, kind: ObsoleteSyntax) -> Gc<Expr>;\n     fn report(&mut self,\n               sp: Span,\n               kind: ObsoleteSyntax,\n@@ -68,9 +70,9 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n \n     // Reports an obsolete syntax non-fatal error, and returns\n     // a placeholder expression\n-    fn obsolete_expr(&mut self, sp: Span, kind: ObsoleteSyntax) -> @Expr {\n+    fn obsolete_expr(&mut self, sp: Span, kind: ObsoleteSyntax) -> Gc<Expr> {\n         self.obsolete(sp, kind);\n-        self.mk_expr(sp.lo, sp.hi, ExprLit(@respan(sp, LitNil)))\n+        self.mk_expr(sp.lo, sp.hi, ExprLit(box(GC) respan(sp, LitNil)))\n     }\n \n     fn report(&mut self,"}, {"sha": "fad75ef92785c8a05cdbf59df354aec70f89bb94", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 124, "deletions": 117, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -79,7 +79,7 @@ use owned_slice::OwnedSlice;\n use std::collections::HashSet;\n use std::mem::replace;\n use std::rc::Rc;\n-use std::string::String;\n+use std::gc::Gc;\n \n #[allow(non_camel_case_types)]\n #[deriving(PartialEq)]\n@@ -119,9 +119,9 @@ pub struct PathAndBounds {\n enum ItemOrViewItem {\n     // Indicates a failure to parse any kind of item. The attributes are\n     // returned.\n-    IoviNone(Vec<Attribute> ),\n-    IoviItem(@Item),\n-    IoviForeignItem(@ForeignItem),\n+    IoviNone(Vec<Attribute>),\n+    IoviItem(Gc<Item>),\n+    IoviForeignItem(Gc<ForeignItem>),\n     IoviViewItem(ViewItem)\n }\n \n@@ -275,9 +275,9 @@ fn maybe_append(lhs: Vec<Attribute> , rhs: Option<Vec<Attribute> >)\n \n \n struct ParsedItemsAndViewItems {\n-    attrs_remaining: Vec<Attribute> ,\n-    view_items: Vec<ViewItem> ,\n-    items: Vec<@Item> ,\n+    attrs_remaining: Vec<Attribute>,\n+    view_items: Vec<ViewItem>,\n+    items: Vec<@Item>,\n     foreign_items: Vec<@ForeignItem>\n }\n \n@@ -454,7 +454,8 @@ impl<'a> Parser<'a> {\n     // Commit to parsing a complete expression `e` expected to be\n     // followed by some token from the set edible + inedible.  Recover\n     // from anticipated input errors, discarding erroneous characters.\n-    pub fn commit_expr(&mut self, e: @Expr, edible: &[token::Token], inedible: &[token::Token]) {\n+    pub fn commit_expr(&mut self, e: Gc<Expr>, edible: &[token::Token],\n+                       inedible: &[token::Token]) {\n         debug!(\"commit_expr {:?}\", e);\n         match e.node {\n             ExprPath(..) => {\n@@ -469,14 +470,15 @@ impl<'a> Parser<'a> {\n         self.expect_one_of(edible, inedible)\n     }\n \n-    pub fn commit_expr_expecting(&mut self, e: @Expr, edible: token::Token) {\n+    pub fn commit_expr_expecting(&mut self, e: Gc<Expr>, edible: token::Token) {\n         self.commit_expr(e, &[edible], &[])\n     }\n \n     // Commit to parsing a complete statement `s`, which expects to be\n     // followed by some token from the set edible + inedible.  Check\n     // for recoverable input errors, discarding erroneous characters.\n-    pub fn commit_stmt(&mut self, s: @Stmt, edible: &[token::Token], inedible: &[token::Token]) {\n+    pub fn commit_stmt(&mut self, s: Gc<Stmt>, edible: &[token::Token],\n+                       inedible: &[token::Token]) {\n         debug!(\"commit_stmt {:?}\", s);\n         let _s = s; // unused, but future checks might want to inspect `s`.\n         if self.last_token.as_ref().map_or(false, |t| is_ident_or_path(*t)) {\n@@ -488,7 +490,7 @@ impl<'a> Parser<'a> {\n         self.expect_one_of(edible, inedible)\n     }\n \n-    pub fn commit_stmt_expecting(&mut self, s: @Stmt, edible: token::Token) {\n+    pub fn commit_stmt_expecting(&mut self, s: Gc<Stmt>, edible: token::Token) {\n         self.commit_stmt(s, &[edible], &[])\n     }\n \n@@ -980,7 +982,7 @@ impl<'a> Parser<'a> {\n \n         self.expect_keyword(keywords::Fn);\n         let (decl, lifetimes) = self.parse_ty_fn_decl(true);\n-        return TyBareFn(@BareFnTy {\n+        return TyBareFn(box(GC) BareFnTy {\n             abi: abi,\n             fn_style: fn_style,\n             lifetimes: lifetimes,\n@@ -1021,7 +1023,7 @@ impl<'a> Parser<'a> {\n             cf: ret_style,\n             variadic: variadic\n         });\n-        TyProc(@ClosureTy {\n+        TyProc(box(GC) ClosureTy {\n             fn_style: NormalFn,\n             onceness: Once,\n             bounds: bounds,\n@@ -1092,11 +1094,11 @@ impl<'a> Parser<'a> {\n         });\n \n         if is_unboxed {\n-            TyUnboxedFn(@UnboxedFnTy {\n+            TyUnboxedFn(box(GC) UnboxedFnTy {\n                 decl: decl,\n             })\n         } else {\n-            TyClosure(@ClosureTy {\n+            TyClosure(box(GC) ClosureTy {\n                 fn_style: fn_style,\n                 onceness: onceness,\n                 bounds: bounds,\n@@ -1192,7 +1194,7 @@ impl<'a> Parser<'a> {\n                 let (inner_attrs, body) =\n                     p.parse_inner_attrs_and_block();\n                 let attrs = attrs.append(inner_attrs.as_slice());\n-                Provided(@ast::Method {\n+                Provided(box(GC) ast::Method {\n                     ident: ident,\n                     attrs: attrs,\n                     generics: generics,\n@@ -1465,7 +1467,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn maybe_parse_fixed_vstore(&mut self) -> Option<@ast::Expr> {\n+    pub fn maybe_parse_fixed_vstore(&mut self) -> Option<Gc<ast::Expr>> {\n         if self.token == token::COMMA &&\n                 self.look_ahead(1, |t| *t == token::DOTDOT) {\n             self.bump();\n@@ -1516,12 +1518,12 @@ impl<'a> Parser<'a> {\n     }\n \n     // matches '-' lit | lit\n-    pub fn parse_literal_maybe_minus(&mut self) -> @Expr {\n+    pub fn parse_literal_maybe_minus(&mut self) -> Gc<Expr> {\n         let minus_lo = self.span.lo;\n         let minus_present = self.eat(&token::BINOP(token::MINUS));\n \n         let lo = self.span.lo;\n-        let literal = @self.parse_lit();\n+        let literal = box(GC) self.parse_lit();\n         let hi = self.span.hi;\n         let expr = self.mk_expr(lo, hi, ExprLit(literal));\n \n@@ -1723,62 +1725,65 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn mk_expr(&mut self, lo: BytePos, hi: BytePos, node: Expr_) -> @Expr {\n-        @Expr {\n+    pub fn mk_expr(&mut self, lo: BytePos, hi: BytePos, node: Expr_) -> Gc<Expr> {\n+        box(GC) Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n             span: mk_sp(lo, hi),\n         }\n     }\n \n-    pub fn mk_unary(&mut self, unop: ast::UnOp, expr: @Expr) -> ast::Expr_ {\n+    pub fn mk_unary(&mut self, unop: ast::UnOp, expr: Gc<Expr>) -> ast::Expr_ {\n         ExprUnary(unop, expr)\n     }\n \n-    pub fn mk_binary(&mut self, binop: ast::BinOp, lhs: @Expr, rhs: @Expr) -> ast::Expr_ {\n+    pub fn mk_binary(&mut self, binop: ast::BinOp,\n+                     lhs: Gc<Expr>, rhs: Gc<Expr>) -> ast::Expr_ {\n         ExprBinary(binop, lhs, rhs)\n     }\n \n-    pub fn mk_call(&mut self, f: @Expr, args: Vec<@Expr> ) -> ast::Expr_ {\n+    pub fn mk_call(&mut self, f: Gc<Expr>, args: Vec<Gc<Expr>>) -> ast::Expr_ {\n         ExprCall(f, args)\n     }\n \n     fn mk_method_call(&mut self,\n                       ident: ast::SpannedIdent,\n                       tps: Vec<P<Ty>>,\n-                      args: Vec<@Expr>)\n+                      args: Vec<Gc<Expr>>)\n                       -> ast::Expr_ {\n         ExprMethodCall(ident, tps, args)\n     }\n \n-    pub fn mk_index(&mut self, expr: @Expr, idx: @Expr) -> ast::Expr_ {\n+    pub fn mk_index(&mut self, expr: Gc<Expr>, idx: Gc<Expr>) -> ast::Expr_ {\n         ExprIndex(expr, idx)\n     }\n \n-    pub fn mk_field(&mut self, expr: @Expr, ident: Ident, tys: Vec<P<Ty>> ) -> ast::Expr_ {\n+    pub fn mk_field(&mut self, expr: Gc<Expr>, ident: Ident,\n+                    tys: Vec<P<Ty>>) -> ast::Expr_ {\n         ExprField(expr, ident, tys)\n     }\n \n-    pub fn mk_assign_op(&mut self, binop: ast::BinOp, lhs: @Expr, rhs: @Expr) -> ast::Expr_ {\n+    pub fn mk_assign_op(&mut self, binop: ast::BinOp,\n+                        lhs: Gc<Expr>, rhs: Gc<Expr>) -> ast::Expr_ {\n         ExprAssignOp(binop, lhs, rhs)\n     }\n \n-    pub fn mk_mac_expr(&mut self, lo: BytePos, hi: BytePos, m: Mac_) -> @Expr {\n-        @Expr {\n+    pub fn mk_mac_expr(&mut self, lo: BytePos, hi: BytePos, m: Mac_) -> Gc<Expr> {\n+        box(GC) Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: ExprMac(codemap::Spanned {node: m, span: mk_sp(lo, hi)}),\n             span: mk_sp(lo, hi),\n         }\n     }\n \n-    pub fn mk_lit_u32(&mut self, i: u32) -> @Expr {\n+    pub fn mk_lit_u32(&mut self, i: u32) -> Gc<Expr> {\n         let span = &self.span;\n-        let lv_lit = @codemap::Spanned {\n+        let lv_lit = box(GC) codemap::Spanned {\n             node: LitUint(i as u64, TyU32),\n             span: *span\n         };\n \n-        @Expr {\n+        box(GC) Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: ExprLit(lv_lit),\n             span: *span,\n@@ -1788,7 +1793,7 @@ impl<'a> Parser<'a> {\n     // at the bottom (top?) of the precedence hierarchy,\n     // parse things like parenthesized exprs,\n     // macros, return, etc.\n-    pub fn parse_bottom_expr(&mut self) -> @Expr {\n+    pub fn parse_bottom_expr(&mut self) -> Gc<Expr> {\n         maybe_whole_expr!(self);\n \n         let lo = self.span.lo;\n@@ -1804,7 +1809,7 @@ impl<'a> Parser<'a> {\n             if self.token == token::RPAREN {\n                 hi = self.span.hi;\n                 self.bump();\n-                let lit = @spanned(lo, hi, LitNil);\n+                let lit = box(GC) spanned(lo, hi, LitNil);\n                 return self.mk_expr(lo, hi, ExprLit(lit));\n             }\n             let mut es = vec!(self.parse_expr());\n@@ -1991,27 +1996,27 @@ impl<'a> Parser<'a> {\n             // other literal expression\n             let lit = self.parse_lit();\n             hi = lit.span.hi;\n-            ex = ExprLit(@lit);\n+            ex = ExprLit(box(GC) lit);\n         }\n \n         return self.mk_expr(lo, hi, ex);\n     }\n \n     // parse a block or unsafe block\n     pub fn parse_block_expr(&mut self, lo: BytePos, blk_mode: BlockCheckMode)\n-                            -> @Expr {\n+                            -> Gc<Expr> {\n         self.expect(&token::LBRACE);\n         let blk = self.parse_block_tail(lo, blk_mode);\n         return self.mk_expr(blk.span.lo, blk.span.hi, ExprBlock(blk));\n     }\n \n     // parse a.b or a(13) or a[4] or just a\n-    pub fn parse_dot_or_call_expr(&mut self) -> @Expr {\n+    pub fn parse_dot_or_call_expr(&mut self) -> Gc<Expr> {\n         let b = self.parse_bottom_expr();\n         self.parse_dot_or_call_expr_with(b)\n     }\n \n-    pub fn parse_dot_or_call_expr_with(&mut self, e0: @Expr) -> @Expr {\n+    pub fn parse_dot_or_call_expr_with(&mut self, e0: Gc<Expr>) -> Gc<Expr> {\n         let mut e = e0;\n         let lo = e.span.lo;\n         let mut hi;\n@@ -2282,7 +2287,7 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse a prefix-operator expr\n-    pub fn parse_prefix_expr(&mut self) -> @Expr {\n+    pub fn parse_prefix_expr(&mut self) -> Gc<Expr> {\n         let lo = self.span.lo;\n         let hi;\n \n@@ -2384,13 +2389,14 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse an expression of binops\n-    pub fn parse_binops(&mut self) -> @Expr {\n+    pub fn parse_binops(&mut self) -> Gc<Expr> {\n         let prefix_expr = self.parse_prefix_expr();\n         self.parse_more_binops(prefix_expr, 0)\n     }\n \n     // parse an expression of binops of at least min_prec precedence\n-    pub fn parse_more_binops(&mut self, lhs: @Expr, min_prec: uint) -> @Expr {\n+    pub fn parse_more_binops(&mut self, lhs: Gc<Expr>,\n+                             min_prec: uint) -> Gc<Expr> {\n         if self.expr_is_complete(lhs) { return lhs; }\n \n         // Prevent dynamic borrow errors later on by limiting the\n@@ -2439,7 +2445,7 @@ impl<'a> Parser<'a> {\n     // parse an assignment expression....\n     // actually, this seems to be the main entry point for\n     // parsing an arbitrary expression.\n-    pub fn parse_assign_expr(&mut self) -> @Expr {\n+    pub fn parse_assign_expr(&mut self) -> Gc<Expr> {\n         let lo = self.span.lo;\n         let lhs = self.parse_binops();\n         match self.token {\n@@ -2473,11 +2479,11 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse an 'if' expression ('if' token already eaten)\n-    pub fn parse_if_expr(&mut self) -> @Expr {\n+    pub fn parse_if_expr(&mut self) -> Gc<Expr> {\n         let lo = self.last_span.lo;\n         let cond = self.parse_expr();\n         let thn = self.parse_block();\n-        let mut els: Option<@Expr> = None;\n+        let mut els: Option<Gc<Expr>> = None;\n         let mut hi = thn.span.hi;\n         if self.eat_keyword(keywords::Else) {\n             let elexpr = self.parse_else_expr();\n@@ -2488,7 +2494,7 @@ impl<'a> Parser<'a> {\n     }\n \n     // `|args| { ... }` or `{ ...}` like in `do` expressions\n-    pub fn parse_lambda_block_expr(&mut self) -> @Expr {\n+    pub fn parse_lambda_block_expr(&mut self) -> Gc<Expr> {\n         self.parse_lambda_expr_(\n             |p| {\n                 match p.token {\n@@ -2517,7 +2523,7 @@ impl<'a> Parser<'a> {\n     }\n \n     // `|args| expr`\n-    pub fn parse_lambda_expr(&mut self) -> @Expr {\n+    pub fn parse_lambda_expr(&mut self) -> Gc<Expr> {\n         self.parse_lambda_expr_(|p| p.parse_fn_block_decl(),\n                                 |p| p.parse_expr())\n     }\n@@ -2527,8 +2533,8 @@ impl<'a> Parser<'a> {\n     // and in parsing a block expr as e.g. in for...\n     pub fn parse_lambda_expr_(&mut self,\n                               parse_decl: |&mut Parser| -> P<FnDecl>,\n-                              parse_body: |&mut Parser| -> @Expr)\n-                              -> @Expr {\n+                              parse_body: |&mut Parser| -> Gc<Expr>)\n+                              -> Gc<Expr> {\n         let lo = self.span.lo;\n         let decl = parse_decl(self);\n         let body = parse_body(self);\n@@ -2544,7 +2550,7 @@ impl<'a> Parser<'a> {\n         return self.mk_expr(lo, body.span.hi, ExprFnBlock(decl, fakeblock));\n     }\n \n-    pub fn parse_else_expr(&mut self) -> @Expr {\n+    pub fn parse_else_expr(&mut self) -> Gc<Expr> {\n         if self.eat_keyword(keywords::If) {\n             return self.parse_if_expr();\n         } else {\n@@ -2554,7 +2560,7 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse a 'for' .. 'in' expression ('for' token already eaten)\n-    pub fn parse_for_expr(&mut self, opt_ident: Option<ast::Ident>) -> @Expr {\n+    pub fn parse_for_expr(&mut self, opt_ident: Option<ast::Ident>) -> Gc<Expr> {\n         // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n \n         let lo = self.last_span.lo;\n@@ -2567,15 +2573,15 @@ impl<'a> Parser<'a> {\n         self.mk_expr(lo, hi, ExprForLoop(pat, expr, loop_block, opt_ident))\n     }\n \n-    pub fn parse_while_expr(&mut self) -> @Expr {\n+    pub fn parse_while_expr(&mut self) -> Gc<Expr> {\n         let lo = self.last_span.lo;\n         let cond = self.parse_expr();\n         let body = self.parse_block();\n         let hi = body.span.hi;\n         return self.mk_expr(lo, hi, ExprWhile(cond, body));\n     }\n \n-    pub fn parse_loop_expr(&mut self, opt_ident: Option<ast::Ident>) -> @Expr {\n+    pub fn parse_loop_expr(&mut self, opt_ident: Option<ast::Ident>) -> Gc<Expr> {\n         let lo = self.last_span.lo;\n         let body = self.parse_block();\n         let hi = body.span.hi;\n@@ -2590,7 +2596,7 @@ impl<'a> Parser<'a> {\n          || self.look_ahead(1, |t| *t == token::DOTDOT))\n     }\n \n-    fn parse_match_expr(&mut self) -> @Expr {\n+    fn parse_match_expr(&mut self) -> Gc<Expr> {\n         let lo = self.last_span.lo;\n         let discriminant = self.parse_expr();\n         self.commit_expr_expecting(discriminant, token::LBRACE);\n@@ -2628,12 +2634,12 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse an expression\n-    pub fn parse_expr(&mut self) -> @Expr {\n+    pub fn parse_expr(&mut self) -> Gc<Expr> {\n         return self.parse_expr_res(UNRESTRICTED);\n     }\n \n     // parse an expression, subject to the given restriction\n-    fn parse_expr_res(&mut self, r: restriction) -> @Expr {\n+    fn parse_expr_res(&mut self, r: restriction) -> Gc<Expr> {\n         let old = self.restriction;\n         self.restriction = r;\n         let e = self.parse_assign_expr();\n@@ -2642,7 +2648,7 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse the RHS of a local variable declaration (e.g. '= 14;')\n-    fn parse_initializer(&mut self) -> Option<@Expr> {\n+    fn parse_initializer(&mut self) -> Option<Gc<Expr>> {\n         if self.token == token::EQ {\n             self.bump();\n             Some(self.parse_expr())\n@@ -2652,7 +2658,7 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse patterns, separated by '|' s\n-    fn parse_pats(&mut self) -> Vec<@Pat> {\n+    fn parse_pats(&mut self) -> Vec<Gc<Pat>> {\n         let mut pats = Vec::new();\n         loop {\n             pats.push(self.parse_pat());\n@@ -2663,7 +2669,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_pat_vec_elements(\n         &mut self,\n-    ) -> (Vec<@Pat> , Option<@Pat>, Vec<@Pat> ) {\n+    ) -> (Vec<Gc<Pat>> , Option<Gc<Pat>>, Vec<Gc<Pat>> ) {\n         let mut before = Vec::new();\n         let mut slice = None;\n         let mut after = Vec::new();\n@@ -2685,7 +2691,7 @@ impl<'a> Parser<'a> {\n \n             if is_slice {\n                 if self.token == token::COMMA || self.token == token::RBRACKET {\n-                    slice = Some(@ast::Pat {\n+                    slice = Some(box(GC) ast::Pat {\n                         id: ast::DUMMY_NODE_ID,\n                         node: PatWildMulti,\n                         span: self.span,\n@@ -2764,7 +2770,7 @@ impl<'a> Parser<'a> {\n             } else {\n                 let fieldpath = ast_util::ident_to_path(self.last_span,\n                                                         fieldname);\n-                @ast::Pat {\n+                box(GC) ast::Pat {\n                     id: ast::DUMMY_NODE_ID,\n                     node: PatIdent(bind_type, fieldpath, None),\n                     span: self.last_span\n@@ -2776,7 +2782,7 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse a pattern.\n-    pub fn parse_pat(&mut self) -> @Pat {\n+    pub fn parse_pat(&mut self) -> Gc<Pat> {\n         maybe_whole!(self, NtPat);\n \n         let lo = self.span.lo;\n@@ -2788,7 +2794,7 @@ impl<'a> Parser<'a> {\n             self.bump();\n             pat = PatWild;\n             hi = self.last_span.hi;\n-            return @ast::Pat {\n+            return box(GC) ast::Pat {\n                 id: ast::DUMMY_NODE_ID,\n                 node: pat,\n                 span: mk_sp(lo, hi)\n@@ -2801,7 +2807,7 @@ impl<'a> Parser<'a> {\n             pat = PatBox(sub);\n             hi = self.last_span.hi;\n             self.obsolete(self.last_span, ObsoleteOwnedPattern);\n-            return @ast::Pat {\n+            return box(GC) ast::Pat {\n                 id: ast::DUMMY_NODE_ID,\n                 node: pat,\n                 span: mk_sp(lo, hi)\n@@ -2814,7 +2820,7 @@ impl<'a> Parser<'a> {\n             let sub = self.parse_pat();\n             pat = PatRegion(sub);\n             hi = self.last_span.hi;\n-            return @ast::Pat {\n+            return box(GC) ast::Pat {\n                 id: ast::DUMMY_NODE_ID,\n                 node: pat,\n                 span: mk_sp(lo, hi)\n@@ -2826,7 +2832,7 @@ impl<'a> Parser<'a> {\n             if self.token == token::RPAREN {\n                 hi = self.span.hi;\n                 self.bump();\n-                let lit = @codemap::Spanned {\n+                let lit = box(GC) codemap::Spanned {\n                     node: LitNil,\n                     span: mk_sp(lo, hi)};\n                 let expr = self.mk_expr(lo, hi, ExprLit(lit));\n@@ -2845,7 +2851,7 @@ impl<'a> Parser<'a> {\n                 pat = PatTup(fields);\n             }\n             hi = self.last_span.hi;\n-            return @ast::Pat {\n+            return box(GC) ast::Pat {\n                 id: ast::DUMMY_NODE_ID,\n                 node: pat,\n                 span: mk_sp(lo, hi)\n@@ -2860,7 +2866,7 @@ impl<'a> Parser<'a> {\n             self.expect(&token::RBRACKET);\n             pat = ast::PatVec(before, slice, after);\n             hi = self.last_span.hi;\n-            return @ast::Pat {\n+            return box(GC) ast::Pat {\n                 id: ast::DUMMY_NODE_ID,\n                 node: pat,\n                 span: mk_sp(lo, hi)\n@@ -2904,7 +2910,7 @@ impl<'a> Parser<'a> {\n             let sub = self.parse_pat();\n             pat = PatBox(sub);\n             hi = self.last_span.hi;\n-            return @ast::Pat {\n+            return box(GC) ast::Pat {\n                 id: ast::DUMMY_NODE_ID,\n                 node: pat,\n                 span: mk_sp(lo, hi)\n@@ -2960,7 +2966,7 @@ impl<'a> Parser<'a> {\n                         pat = PatStruct(enum_path, fields, etc);\n                     }\n                     _ => {\n-                        let mut args: Vec<@Pat> = Vec::new();\n+                        let mut args: Vec<Gc<Pat>> = Vec::new();\n                         match self.token {\n                           token::LPAREN => {\n                             let is_dotdot = self.look_ahead(1, |t| {\n@@ -3003,7 +3009,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n         hi = self.last_span.hi;\n-        @ast::Pat {\n+        box(GC) ast::Pat {\n             id: ast::DUMMY_NODE_ID,\n             node: pat,\n             span: mk_sp(lo, hi),\n@@ -3044,7 +3050,7 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse a local variable declaration\n-    fn parse_local(&mut self) -> @Local {\n+    fn parse_local(&mut self) -> Gc<Local> {\n         let lo = self.span.lo;\n         let pat = self.parse_pat();\n \n@@ -3055,7 +3061,7 @@ impl<'a> Parser<'a> {\n         });\n         if self.eat(&token::COLON) { ty = self.parse_ty(false); }\n         let init = self.parse_initializer();\n-        @ast::Local {\n+        box(GC) ast::Local {\n             ty: ty,\n             pat: pat,\n             init: init,\n@@ -3066,10 +3072,10 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse a \"let\" stmt\n-    fn parse_let(&mut self) -> @Decl {\n+    fn parse_let(&mut self) -> Gc<Decl> {\n         let lo = self.span.lo;\n         let local = self.parse_local();\n-        return @spanned(lo, self.last_span.hi, DeclLocal(local));\n+        box(GC) spanned(lo, self.last_span.hi, DeclLocal(local))\n     }\n \n     // parse a structure field\n@@ -3092,7 +3098,7 @@ impl<'a> Parser<'a> {\n \n     // parse a statement. may include decl.\n     // precondition: any attributes are parsed already\n-    pub fn parse_stmt(&mut self, item_attrs: Vec<Attribute> ) -> @Stmt {\n+    pub fn parse_stmt(&mut self, item_attrs: Vec<Attribute>) -> Gc<Stmt> {\n         maybe_whole!(self, NtStmt);\n \n         fn check_expected_item(p: &mut Parser, found_attrs: bool) {\n@@ -3107,7 +3113,7 @@ impl<'a> Parser<'a> {\n             check_expected_item(self, !item_attrs.is_empty());\n             self.expect_keyword(keywords::Let);\n             let decl = self.parse_let();\n-            return @spanned(lo, decl.span.hi, StmtDecl(decl, ast::DUMMY_NODE_ID));\n+            return box(GC) spanned(lo, decl.span.hi, StmtDecl(decl, ast::DUMMY_NODE_ID));\n         } else if is_ident(&self.token)\n             && !token::is_any_keyword(&self.token)\n             && self.look_ahead(1, |t| *t == token::NOT) {\n@@ -3166,12 +3172,12 @@ impl<'a> Parser<'a> {\n             let hi = self.span.hi;\n \n             if id == token::special_idents::invalid {\n-                return @spanned(lo, hi, StmtMac(\n+                return box(GC) spanned(lo, hi, StmtMac(\n                     spanned(lo, hi, MacInvocTT(pth, tts, EMPTY_CTXT)), false));\n             } else {\n                 // if it has a special ident, it's definitely an item\n-                return @spanned(lo, hi, StmtDecl(\n-                    @spanned(lo, hi, DeclItem(\n+                return box(GC) spanned(lo, hi, StmtDecl(\n+                    box(GC) spanned(lo, hi, DeclItem(\n                         self.mk_item(\n                             lo, hi, id /*id is good here*/,\n                             ItemMac(spanned(lo, hi, MacInvocTT(pth, tts, EMPTY_CTXT))),\n@@ -3184,8 +3190,8 @@ impl<'a> Parser<'a> {\n             match self.parse_item_or_view_item(item_attrs, false) {\n                 IoviItem(i) => {\n                     let hi = i.span.hi;\n-                    let decl = @spanned(lo, hi, DeclItem(i));\n-                    return @spanned(lo, hi, StmtDecl(decl, ast::DUMMY_NODE_ID));\n+                    let decl = box(GC) spanned(lo, hi, DeclItem(i));\n+                    return box(GC) spanned(lo, hi, StmtDecl(decl, ast::DUMMY_NODE_ID));\n                 }\n                 IoviViewItem(vi) => {\n                     self.span_fatal(vi.span,\n@@ -3201,12 +3207,12 @@ impl<'a> Parser<'a> {\n \n             // Remainder are line-expr stmts.\n             let e = self.parse_expr_res(RESTRICT_STMT_EXPR);\n-            return @spanned(lo, e.span.hi, StmtExpr(e, ast::DUMMY_NODE_ID));\n+            return box(GC) spanned(lo, e.span.hi, StmtExpr(e, ast::DUMMY_NODE_ID));\n         }\n     }\n \n     // is this expression a successfully-parsed statement?\n-    fn expr_is_complete(&mut self, e: @Expr) -> bool {\n+    fn expr_is_complete(&mut self, e: Gc<Expr>) -> bool {\n         return self.restriction == RESTRICT_STMT_EXPR &&\n             !classify::expr_requires_semi_to_be_stmt(e);\n     }\n@@ -3258,8 +3264,8 @@ impl<'a> Parser<'a> {\n                                             false, false);\n \n         for item in items.iter() {\n-            let decl = @spanned(item.span.lo, item.span.hi, DeclItem(*item));\n-            stmts.push(@spanned(item.span.lo, item.span.hi,\n+            let decl = box(GC) spanned(item.span.lo, item.span.hi, DeclItem(*item));\n+            stmts.push(box(GC) spanned(item.span.lo, item.span.hi,\n                                 StmtDecl(decl, ast::DUMMY_NODE_ID)));\n         }\n \n@@ -3286,7 +3292,7 @@ impl<'a> Parser<'a> {\n                     match stmt.node {\n                         StmtExpr(e, stmt_id) => {\n                             // expression without semicolon\n-                            if classify::stmt_ends_with_semi(stmt) {\n+                            if classify::stmt_ends_with_semi(&*stmt) {\n                                 // Just check for errors and recover; do not eat semicolon yet.\n                                 self.commit_stmt(stmt, &[], &[token::SEMI, token::RBRACE]);\n                             }\n@@ -3299,7 +3305,7 @@ impl<'a> Parser<'a> {\n                                         hi: self.last_span.hi,\n                                         expn_info: stmt.span.expn_info,\n                                     };\n-                                    stmts.push(@codemap::Spanned {\n+                                    stmts.push(box(GC) codemap::Spanned {\n                                         node: StmtSemi(e, stmt_id),\n                                         span: span_with_semi,\n                                     });\n@@ -3317,7 +3323,7 @@ impl<'a> Parser<'a> {\n                             match self.token {\n                                 token::SEMI => {\n                                     self.bump();\n-                                    stmts.push(@codemap::Spanned {\n+                                    stmts.push(box(GC) codemap::Spanned {\n                                         node: StmtMac((*m).clone(), true),\n                                         span: stmt.span,\n                                     });\n@@ -3336,9 +3342,9 @@ impl<'a> Parser<'a> {\n                             }\n                         }\n                         _ => { // all other kinds of statements:\n-                            stmts.push(stmt);\n+                            stmts.push(stmt.clone());\n \n-                            if classify::stmt_ends_with_semi(stmt) {\n+                            if classify::stmt_ends_with_semi(&*stmt) {\n                                 self.commit_stmt_expecting(stmt, token::SEMI);\n                             }\n                         }\n@@ -3827,8 +3833,8 @@ impl<'a> Parser<'a> {\n \n     fn mk_item(&mut self, lo: BytePos, hi: BytePos, ident: Ident,\n                node: Item_, vis: Visibility,\n-               attrs: Vec<Attribute> ) -> @Item {\n-        @Item {\n+               attrs: Vec<Attribute>) -> Gc<Item> {\n+        box(GC) Item {\n             ident: ident,\n             attrs: attrs,\n             id: ast::DUMMY_NODE_ID,\n@@ -3847,7 +3853,8 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse a method in a trait impl, starting with `attrs` attributes.\n-    fn parse_method(&mut self, already_parsed_attrs: Option<Vec<Attribute> >) -> @Method {\n+    fn parse_method(&mut self,\n+                    already_parsed_attrs: Option<Vec<Attribute>>) -> Gc<Method> {\n         let next_attrs = self.parse_outer_attributes();\n         let attrs = match already_parsed_attrs {\n             Some(mut a) => { a.push_all_move(next_attrs); a }\n@@ -3867,7 +3874,7 @@ impl<'a> Parser<'a> {\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n         let hi = body.span.hi;\n         let attrs = attrs.append(inner_attrs.as_slice());\n-        @ast::Method {\n+        box(GC) ast::Method {\n             ident: ident,\n             attrs: attrs,\n             generics: generics,\n@@ -3950,7 +3957,7 @@ impl<'a> Parser<'a> {\n             method_attrs = None;\n         }\n \n-        let ident = ast_util::impl_pretty_name(&opt_trait, ty);\n+        let ident = ast_util::impl_pretty_name(&opt_trait, &*ty);\n \n         (ident, ItemImpl(generics, opt_trait, ty, meths), Some(inner_attrs))\n     }\n@@ -4041,7 +4048,7 @@ impl<'a> Parser<'a> {\n         let _ = ast::DUMMY_NODE_ID;  // FIXME: Workaround for crazy bug.\n         let new_id = ast::DUMMY_NODE_ID;\n         (class_name,\n-         ItemStruct(@ast::StructDef {\n+         ItemStruct(box(GC) ast::StructDef {\n              fields: fields,\n              ctor_id: if is_tuple_like { Some(new_id) } else { None },\n              super_struct: super_struct,\n@@ -4121,7 +4128,7 @@ impl<'a> Parser<'a> {\n             items: starting_items,\n             ..\n         } = self.parse_items_and_view_items(first_item_attrs, true, true);\n-        let mut items: Vec<@Item> = starting_items;\n+        let mut items: Vec<Gc<Item>> = starting_items;\n         let attrs_remaining_len = attrs_remaining.len();\n \n         // don't think this other loop is even necessary....\n@@ -4322,25 +4329,25 @@ impl<'a> Parser<'a> {\n \n     // parse a function declaration from a foreign module\n     fn parse_item_foreign_fn(&mut self, vis: ast::Visibility,\n-                             attrs: Vec<Attribute> ) -> @ForeignItem {\n+                             attrs: Vec<Attribute>) -> Gc<ForeignItem> {\n         let lo = self.span.lo;\n         self.expect_keyword(keywords::Fn);\n \n         let (ident, generics) = self.parse_fn_header();\n         let decl = self.parse_fn_decl(true);\n         let hi = self.span.hi;\n         self.expect(&token::SEMI);\n-        @ast::ForeignItem { ident: ident,\n-                            attrs: attrs,\n-                            node: ForeignItemFn(decl, generics),\n-                            id: ast::DUMMY_NODE_ID,\n-                            span: mk_sp(lo, hi),\n-                            vis: vis }\n+        box(GC) ast::ForeignItem { ident: ident,\n+                                   attrs: attrs,\n+                                   node: ForeignItemFn(decl, generics),\n+                                   id: ast::DUMMY_NODE_ID,\n+                                   span: mk_sp(lo, hi),\n+                                   vis: vis }\n     }\n \n     // parse a static item from a foreign module\n     fn parse_item_foreign_static(&mut self, vis: ast::Visibility,\n-                                 attrs: Vec<Attribute> ) -> @ForeignItem {\n+                                 attrs: Vec<Attribute> ) -> Gc<ForeignItem> {\n         let lo = self.span.lo;\n \n         self.expect_keyword(keywords::Static);\n@@ -4351,7 +4358,7 @@ impl<'a> Parser<'a> {\n         let ty = self.parse_ty(false);\n         let hi = self.span.hi;\n         self.expect(&token::SEMI);\n-        @ast::ForeignItem {\n+        box(GC) ast::ForeignItem {\n             ident: ident,\n             attrs: attrs,\n             node: ForeignItemStatic(ty, mutbl),\n@@ -4483,14 +4490,14 @@ impl<'a> Parser<'a> {\n \n     // parse a structure-like enum variant definition\n     // this should probably be renamed or refactored...\n-    fn parse_struct_def(&mut self) -> @StructDef {\n+    fn parse_struct_def(&mut self) -> Gc<StructDef> {\n         let mut fields: Vec<StructField> = Vec::new();\n         while self.token != token::RBRACE {\n             fields.push(self.parse_struct_decl_field());\n         }\n         self.bump();\n \n-        return @ast::StructDef {\n+        return box(GC) ast::StructDef {\n             fields: fields,\n             ctor_id: None,\n             super_struct: None,\n@@ -4617,7 +4624,7 @@ impl<'a> Parser<'a> {\n             INTERPOLATED(token::NtItem(item)) => {\n                 self.bump();\n                 let new_attrs = attrs.append(item.attrs.as_slice());\n-                return IoviItem(@Item {\n+                return IoviItem(box(GC) Item {\n                     attrs: new_attrs,\n                     ..(*item).clone()\n                 });\n@@ -4892,7 +4899,7 @@ impl<'a> Parser<'a> {\n         return IoviNone(attrs);\n     }\n \n-    pub fn parse_item(&mut self, attrs: Vec<Attribute> ) -> Option<@Item> {\n+    pub fn parse_item(&mut self, attrs: Vec<Attribute> ) -> Option<Gc<Item>> {\n         match self.parse_item_or_view_item(attrs, true) {\n             IoviNone(_) => None,\n             IoviViewItem(_) =>\n@@ -4914,7 +4921,7 @@ impl<'a> Parser<'a> {\n     // | MOD? non_global_path MOD_SEP LBRACE ident_seq RBRACE\n     // | MOD? non_global_path MOD_SEP STAR\n     // | MOD? non_global_path\n-    fn parse_view_path(&mut self) -> @ViewPath {\n+    fn parse_view_path(&mut self) -> Gc<ViewPath> {\n         let lo = self.span.lo;\n \n         if self.token == token::LBRACE {\n@@ -4928,7 +4935,7 @@ impl<'a> Parser<'a> {\n                 global: false,\n                 segments: Vec::new()\n             };\n-            return @spanned(lo, self.span.hi,\n+            return box(GC) spanned(lo, self.span.hi,\n                             ViewPathList(path, idents, ast::DUMMY_NODE_ID));\n         }\n \n@@ -4956,7 +4963,7 @@ impl<'a> Parser<'a> {\n                     }\n                 }).collect()\n             };\n-            return @spanned(lo, self.span.hi,\n+            return box(GC) spanned(lo, self.span.hi,\n                             ViewPathSimple(first_ident, path,\n                                            ast::DUMMY_NODE_ID));\n           }\n@@ -4991,7 +4998,7 @@ impl<'a> Parser<'a> {\n                             }\n                         }).collect()\n                     };\n-                    return @spanned(lo, self.span.hi,\n+                    return box(GC) spanned(lo, self.span.hi,\n                                     ViewPathList(path, idents, ast::DUMMY_NODE_ID));\n                   }\n \n@@ -5009,7 +5016,7 @@ impl<'a> Parser<'a> {\n                             }\n                         }).collect()\n                     };\n-                    return @spanned(lo, self.span.hi,\n+                    return box(GC) spanned(lo, self.span.hi,\n                                     ViewPathGlob(path, ast::DUMMY_NODE_ID));\n                   }\n \n@@ -5031,7 +5038,7 @@ impl<'a> Parser<'a> {\n                 }\n             }).collect()\n         };\n-        return @spanned(lo,\n+        return box(GC) spanned(lo,\n                         self.last_span.hi,\n                         ViewPathSimple(last, path, ast::DUMMY_NODE_ID));\n     }"}, {"sha": "fa70261a7d7119c44c551f2d3ba8cfa4609e33d4", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -18,10 +18,10 @@ use util::interner;\n \n use serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::fmt;\n-use std::path::BytesContainer;\n+use std::gc::Gc;\n use std::mem;\n+use std::path::BytesContainer;\n use std::rc::Rc;\n-use std::string::String;\n \n #[allow(non_camel_case_types)]\n #[deriving(Clone, Encodable, Decodable, PartialEq, Eq, Hash, Show)]\n@@ -105,16 +105,16 @@ pub enum Token {\n #[deriving(Clone, Encodable, Decodable, PartialEq, Eq, Hash)]\n /// For interpolation during macro expansion.\n pub enum Nonterminal {\n-    NtItem(@ast::Item),\n+    NtItem(Gc<ast::Item>),\n     NtBlock(P<ast::Block>),\n-    NtStmt(@ast::Stmt),\n-    NtPat( @ast::Pat),\n-    NtExpr(@ast::Expr),\n+    NtStmt(Gc<ast::Stmt>),\n+    NtPat( Gc<ast::Pat>),\n+    NtExpr(Gc<ast::Expr>),\n     NtTy(  P<ast::Ty>),\n     NtIdent(Box<ast::Ident>, bool),\n-    NtMeta(@ast::MetaItem), // stuff inside brackets for attributes\n+    NtMeta(Gc<ast::MetaItem>), // stuff inside brackets for attributes\n     NtPath(Box<ast::Path>),\n-    NtTT(  @ast::TokenTree), // needs @ed to break a circularity\n+    NtTT(  Gc<ast::TokenTree>), // needs @ed to break a circularity\n     NtMatchers(Vec<ast::Matcher> )\n }\n \n@@ -241,8 +241,8 @@ pub fn to_str(t: &Token) -> String {\n       EOF => \"<eof>\".to_string(),\n       INTERPOLATED(ref nt) => {\n         match nt {\n-            &NtExpr(e) => ::print::pprust::expr_to_str(e),\n-            &NtMeta(e) => ::print::pprust::meta_item_to_str(e),\n+            &NtExpr(ref e) => ::print::pprust::expr_to_str(&**e),\n+            &NtMeta(ref e) => ::print::pprust::meta_item_to_str(&**e),\n             _ => {\n                 let mut s = \"an interpolated \".to_string();\n                 match *nt {"}, {"sha": "82d74ff07f3aec3357005a7e5d0630462fb2a8a9", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 193, "deletions": 189, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -26,11 +26,11 @@ use print::pp::{break_offset, word, space, zerobreak, hardbreak};\n use print::pp::{Breaks, Consistent, Inconsistent, eof};\n use print::pp;\n \n+use std::gc::Gc;\n use std::io::{IoResult, MemWriter};\n use std::io;\n use std::mem;\n use std::str;\n-use std::string::String;\n \n pub enum AnnNode<'a> {\n     NodeBlock(&'a ast::Block),\n@@ -421,8 +421,8 @@ impl<'a> State<'a> {\n     }\n \n     pub fn commasep_exprs(&mut self, b: Breaks,\n-                          exprs: &[@ast::Expr]) -> IoResult<()> {\n-        self.commasep_cmnt(b, exprs, |s, &e| s.print_expr(e), |e| e.span)\n+                          exprs: &[Gc<ast::Expr>]) -> IoResult<()> {\n+        self.commasep_cmnt(b, exprs, |s, e| s.print_expr(&**e), |e| e.span)\n     }\n \n     pub fn print_mod(&mut self, _mod: &ast::Mod,\n@@ -432,7 +432,7 @@ impl<'a> State<'a> {\n             try!(self.print_view_item(vitem));\n         }\n         for item in _mod.items.iter() {\n-            try!(self.print_item(*item));\n+            try!(self.print_item(&**item));\n         }\n         Ok(())\n     }\n@@ -444,7 +444,7 @@ impl<'a> State<'a> {\n             try!(self.print_view_item(vitem));\n         }\n         for item in nmod.items.iter() {\n-            try!(self.print_foreign_item(*item));\n+            try!(self.print_foreign_item(&**item));\n         }\n         Ok(())\n     }\n@@ -464,17 +464,17 @@ impl<'a> State<'a> {\n         match ty.node {\n             ast::TyNil => try!(word(&mut self.s, \"()\")),\n             ast::TyBot => try!(word(&mut self.s, \"!\")),\n-            ast::TyBox(ty) => {\n+            ast::TyBox(ref ty) => {\n                 try!(word(&mut self.s, \"@\"));\n-                try!(self.print_type(ty));\n+                try!(self.print_type(&**ty));\n             }\n-            ast::TyUniq(ty) => {\n+            ast::TyUniq(ref ty) => {\n                 try!(word(&mut self.s, \"~\"));\n-                try!(self.print_type(ty));\n+                try!(self.print_type(&**ty));\n             }\n-            ast::TyVec(ty) => {\n+            ast::TyVec(ref ty) => {\n                 try!(word(&mut self.s, \"[\"));\n-                try!(self.print_type(ty));\n+                try!(self.print_type(&**ty));\n                 try!(word(&mut self.s, \"]\"));\n             }\n             ast::TyPtr(ref mt) => {\n@@ -505,7 +505,7 @@ impl<'a> State<'a> {\n                                       &None,\n                                       f.fn_style,\n                                       ast::Many,\n-                                      f.decl,\n+                                      &*f.decl,\n                                       None,\n                                       &None,\n                                       Some(&generics),\n@@ -522,14 +522,14 @@ impl<'a> State<'a> {\n                                       region,\n                                       f.fn_style,\n                                       f.onceness,\n-                                      f.decl,\n+                                      &*f.decl,\n                                       None,\n                                       &f.bounds,\n                                       Some(&generics),\n                                       None,\n                                       false));\n             }\n-            ast::TyProc(f) => {\n+            ast::TyProc(ref f) => {\n                 let generics = ast::Generics {\n                     lifetimes: f.lifetimes.clone(),\n                     ty_params: OwnedSlice::empty()\n@@ -539,7 +539,7 @@ impl<'a> State<'a> {\n                                       &None,\n                                       f.fn_style,\n                                       f.onceness,\n-                                      f.decl,\n+                                      &*f.decl,\n                                       None,\n                                       &f.bounds,\n                                       Some(&generics),\n@@ -552,7 +552,7 @@ impl<'a> State<'a> {\n                                       &None,\n                                       ast::NormalFn,\n                                       ast::Many,\n-                                      f.decl,\n+                                      &*f.decl,\n                                       None,\n                                       &None,\n                                       None,\n@@ -562,16 +562,16 @@ impl<'a> State<'a> {\n             ast::TyPath(ref path, ref bounds, _) => {\n                 try!(self.print_bounded_path(path, bounds));\n             }\n-            ast::TyFixedLengthVec(ty, v) => {\n+            ast::TyFixedLengthVec(ref ty, ref v) => {\n                 try!(word(&mut self.s, \"[\"));\n-                try!(self.print_type(ty));\n+                try!(self.print_type(&**ty));\n                 try!(word(&mut self.s, \", ..\"));\n-                try!(self.print_expr(v));\n+                try!(self.print_expr(&**v));\n                 try!(word(&mut self.s, \"]\"));\n             }\n-            ast::TyTypeof(e) => {\n+            ast::TyTypeof(ref e) => {\n                 try!(word(&mut self.s, \"typeof(\"));\n-                try!(self.print_expr(e));\n+                try!(self.print_expr(&**e));\n                 try!(word(&mut self.s, \")\"));\n             }\n             ast::TyInfer => {\n@@ -582,7 +582,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_type_ref(&mut self, ty: &P<ast::Ty>) -> IoResult<()> {\n-        self.print_type(*ty)\n+        self.print_type(&**ty)\n     }\n \n     pub fn print_foreign_item(&mut self,\n@@ -591,22 +591,22 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(item.span.lo));\n         try!(self.print_outer_attributes(item.attrs.as_slice()));\n         match item.node {\n-            ast::ForeignItemFn(decl, ref generics) => {\n-                try!(self.print_fn(decl, None, abi::Rust, item.ident, generics,\n-                None, item.vis));\n+            ast::ForeignItemFn(ref decl, ref generics) => {\n+                try!(self.print_fn(&**decl, None, abi::Rust, item.ident, generics,\n+                                   None, item.vis));\n                 try!(self.end()); // end head-ibox\n                 try!(word(&mut self.s, \";\"));\n                 self.end() // end the outer fn box\n             }\n-            ast::ForeignItemStatic(t, m) => {\n+            ast::ForeignItemStatic(ref t, m) => {\n                 try!(self.head(visibility_qualified(item.vis,\n                                                     \"static\").as_slice()));\n                 if m {\n                     try!(self.word_space(\"mut\"));\n                 }\n                 try!(self.print_ident(item.ident));\n                 try!(self.word_space(\":\"));\n-                try!(self.print_type(t));\n+                try!(self.print_type(&**t));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the head-ibox\n                 self.end() // end the outer cbox\n@@ -620,26 +620,26 @@ impl<'a> State<'a> {\n         try!(self.print_outer_attributes(item.attrs.as_slice()));\n         try!(self.ann.pre(self, NodeItem(item)));\n         match item.node {\n-            ast::ItemStatic(ty, m, expr) => {\n+            ast::ItemStatic(ref ty, m, ref expr) => {\n                 try!(self.head(visibility_qualified(item.vis,\n                                                     \"static\").as_slice()));\n                 if m == ast::MutMutable {\n                     try!(self.word_space(\"mut\"));\n                 }\n                 try!(self.print_ident(item.ident));\n                 try!(self.word_space(\":\"));\n-                try!(self.print_type(ty));\n+                try!(self.print_type(&**ty));\n                 try!(space(&mut self.s));\n                 try!(self.end()); // end the head-ibox\n \n                 try!(self.word_space(\"=\"));\n-                try!(self.print_expr(expr));\n+                try!(self.print_expr(&**expr));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer cbox\n             }\n-            ast::ItemFn(decl, fn_style, abi, ref typarams, body) => {\n+            ast::ItemFn(ref decl, fn_style, abi, ref typarams, ref body) => {\n                 try!(self.print_fn(\n-                    decl,\n+                    &**decl,\n                     Some(fn_style),\n                     abi,\n                     item.ident,\n@@ -648,7 +648,7 @@ impl<'a> State<'a> {\n                     item.vis\n                 ));\n                 try!(word(&mut self.s, \" \"));\n-                try!(self.print_block_with_attrs(body, item.attrs.as_slice()));\n+                try!(self.print_block_with_attrs(&**body, item.attrs.as_slice()));\n             }\n             ast::ItemMod(ref _mod) => {\n                 try!(self.head(visibility_qualified(item.vis,\n@@ -666,7 +666,7 @@ impl<'a> State<'a> {\n                 try!(self.print_foreign_mod(nmod, item.attrs.as_slice()));\n                 try!(self.bclose(item.span));\n             }\n-            ast::ItemTy(ty, ref params) => {\n+            ast::ItemTy(ref ty, ref params) => {\n                 try!(self.ibox(indent_unit));\n                 try!(self.ibox(0u));\n                 try!(self.word_nbsp(visibility_qualified(item.vis,\n@@ -677,7 +677,7 @@ impl<'a> State<'a> {\n \n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n-                try!(self.print_type(ty));\n+                try!(self.print_type(&**ty));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer ibox\n             }\n@@ -690,16 +690,17 @@ impl<'a> State<'a> {\n                     item.vis\n                 ));\n             }\n-            ast::ItemStruct(struct_def, ref generics) => {\n+            ast::ItemStruct(ref struct_def, ref generics) => {\n                 if struct_def.is_virtual {\n                     try!(self.word_space(\"virtual\"));\n                 }\n                 try!(self.head(visibility_qualified(item.vis,\n                                                     \"struct\").as_slice()));\n-                try!(self.print_struct(struct_def, generics, item.ident, item.span));\n+                try!(self.print_struct(&**struct_def, generics, item.ident,\n+                                       item.span));\n             }\n \n-            ast::ItemImpl(ref generics, ref opt_trait, ty, ref methods) => {\n+            ast::ItemImpl(ref generics, ref opt_trait, ref ty, ref methods) => {\n                 try!(self.head(visibility_qualified(item.vis,\n                                                     \"impl\").as_slice()));\n                 if generics.is_parameterized() {\n@@ -716,13 +717,13 @@ impl<'a> State<'a> {\n                     &None => {}\n                 }\n \n-                try!(self.print_type(ty));\n+                try!(self.print_type(&**ty));\n \n                 try!(space(&mut self.s));\n                 try!(self.bopen());\n                 try!(self.print_inner_attributes(item.attrs.as_slice()));\n                 for meth in methods.iter() {\n-                    try!(self.print_method(*meth));\n+                    try!(self.print_method(&**meth));\n                 }\n                 try!(self.bclose(item.span));\n             }\n@@ -788,12 +789,12 @@ impl<'a> State<'a> {\n                           variants: &[P<ast::Variant>],\n                           span: codemap::Span) -> IoResult<()> {\n         try!(self.bopen());\n-        for &v in variants.iter() {\n+        for v in variants.iter() {\n             try!(self.space_if_not_bol());\n             try!(self.maybe_print_comment(v.span.lo));\n             try!(self.print_outer_attributes(v.node.attrs.as_slice()));\n             try!(self.ibox(indent_unit));\n-            try!(self.print_variant(v));\n+            try!(self.print_variant(&**v));\n             try!(word(&mut self.s, \",\"));\n             try!(self.end());\n             try!(self.maybe_print_trailing_comment(v.span, None));\n@@ -816,9 +817,9 @@ impl<'a> State<'a> {\n         try!(self.print_ident(ident));\n         try!(self.print_generics(generics));\n         match struct_def.super_struct {\n-            Some(t) => {\n+            Some(ref t) => {\n                 try!(self.word_space(\":\"));\n-                try!(self.print_type(t));\n+                try!(self.print_type(&**t));\n             },\n             None => {},\n         }\n@@ -833,7 +834,7 @@ impl<'a> State<'a> {\n                             ast::UnnamedField(vis) => {\n                                 try!(s.print_visibility(vis));\n                                 try!(s.maybe_print_comment(field.span.lo));\n-                                s.print_type(field.node.ty)\n+                                s.print_type(&*field.node.ty)\n                             }\n                         }\n                     }\n@@ -858,7 +859,7 @@ impl<'a> State<'a> {\n                         try!(self.print_visibility(visibility));\n                         try!(self.print_ident(ident));\n                         try!(self.word_nbsp(\":\"));\n-                        try!(self.print_type(field.node.ty));\n+                        try!(self.print_type(&*field.node.ty));\n                         try!(word(&mut self.s, \",\"));\n                     }\n                 }\n@@ -929,21 +930,21 @@ impl<'a> State<'a> {\n                     try!(self.popen());\n                     try!(self.commasep(Consistent,\n                                        args.as_slice(),\n-                                       |s, arg| s.print_type(arg.ty)));\n+                                       |s, arg| s.print_type(&*arg.ty)));\n                     try!(self.pclose());\n                 }\n             }\n-            ast::StructVariantKind(struct_def) => {\n+            ast::StructVariantKind(ref struct_def) => {\n                 try!(self.head(\"\"));\n                 let generics = ast_util::empty_generics();\n-                try!(self.print_struct(struct_def, &generics, v.node.name, v.span));\n+                try!(self.print_struct(&**struct_def, &generics, v.node.name, v.span));\n             }\n         }\n         match v.node.disr_expr {\n-            Some(d) => {\n+            Some(ref d) => {\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n-                self.print_expr(d)\n+                self.print_expr(&**d)\n             }\n             _ => Ok(())\n         }\n@@ -958,7 +959,7 @@ impl<'a> State<'a> {\n                               &None,\n                               m.fn_style,\n                               ast::Many,\n-                              m.decl,\n+                              &*m.decl,\n                               Some(m.ident),\n                               &None,\n                               Some(&m.generics),\n@@ -971,19 +972,19 @@ impl<'a> State<'a> {\n                               m: &ast::TraitMethod) -> IoResult<()> {\n         match *m {\n             Required(ref ty_m) => self.print_ty_method(ty_m),\n-            Provided(m) => self.print_method(m)\n+            Provided(ref m) => self.print_method(&**m)\n         }\n     }\n \n     pub fn print_method(&mut self, meth: &ast::Method) -> IoResult<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(meth.span.lo));\n         try!(self.print_outer_attributes(meth.attrs.as_slice()));\n-        try!(self.print_fn(meth.decl, Some(meth.fn_style), abi::Rust,\n+        try!(self.print_fn(&*meth.decl, Some(meth.fn_style), abi::Rust,\n                         meth.ident, &meth.generics, Some(meth.explicit_self.node),\n                         meth.vis));\n         try!(word(&mut self.s, \" \"));\n-        self.print_block_with_attrs(meth.body, meth.attrs.as_slice())\n+        self.print_block_with_attrs(&*meth.body, meth.attrs.as_slice())\n     }\n \n     pub fn print_outer_attributes(&mut self,\n@@ -1032,7 +1033,7 @@ impl<'a> State<'a> {\n                 ast::AttrInner => try!(word(&mut self.s, \"#![\")),\n                 ast::AttrOuter => try!(word(&mut self.s, \"#[\")),\n             }\n-            try!(self.print_meta_item(attr.meta()));\n+            try!(self.print_meta_item(&*attr.meta()));\n             word(&mut self.s, \"]\")\n         }\n     }\n@@ -1041,16 +1042,16 @@ impl<'a> State<'a> {\n     pub fn print_stmt(&mut self, st: &ast::Stmt) -> IoResult<()> {\n         try!(self.maybe_print_comment(st.span.lo));\n         match st.node {\n-            ast::StmtDecl(decl, _) => {\n-                try!(self.print_decl(decl));\n+            ast::StmtDecl(ref decl, _) => {\n+                try!(self.print_decl(&**decl));\n             }\n-            ast::StmtExpr(expr, _) => {\n+            ast::StmtExpr(ref expr, _) => {\n                 try!(self.space_if_not_bol());\n-                try!(self.print_expr(expr));\n+                try!(self.print_expr(&**expr));\n             }\n-            ast::StmtSemi(expr, _) => {\n+            ast::StmtSemi(ref expr, _) => {\n                 try!(self.space_if_not_bol());\n-                try!(self.print_expr(expr));\n+                try!(self.print_expr(&**expr));\n                 try!(word(&mut self.s, \";\"));\n             }\n             ast::StmtMac(ref mac, semi) => {\n@@ -1105,12 +1106,12 @@ impl<'a> State<'a> {\n             try!(self.print_view_item(vi));\n         }\n         for st in blk.stmts.iter() {\n-            try!(self.print_stmt(*st));\n+            try!(self.print_stmt(&**st));\n         }\n         match blk.expr {\n-            Some(expr) => {\n+            Some(ref expr) => {\n                 try!(self.space_if_not_bol());\n-                try!(self.print_expr(expr));\n+                try!(self.print_expr(&**expr));\n                 try!(self.maybe_print_trailing_comment(expr.span, Some(blk.span.hi)));\n             }\n             _ => ()\n@@ -1119,26 +1120,26 @@ impl<'a> State<'a> {\n         self.ann.post(self, NodeBlock(blk))\n     }\n \n-    fn print_else(&mut self, els: Option<@ast::Expr>) -> IoResult<()> {\n+    fn print_else(&mut self, els: Option<Gc<ast::Expr>>) -> IoResult<()> {\n         match els {\n             Some(_else) => {\n                 match _else.node {\n                     // \"another else-if\"\n-                    ast::ExprIf(i, t, e) => {\n+                    ast::ExprIf(ref i, ref t, e) => {\n                         try!(self.cbox(indent_unit - 1u));\n                         try!(self.ibox(0u));\n                         try!(word(&mut self.s, \" else if \"));\n-                        try!(self.print_expr(i));\n+                        try!(self.print_expr(&**i));\n                         try!(space(&mut self.s));\n-                        try!(self.print_block(t));\n+                        try!(self.print_block(&**t));\n                         self.print_else(e)\n                     }\n                     // \"final else\"\n-                    ast::ExprBlock(b) => {\n+                    ast::ExprBlock(ref b) => {\n                         try!(self.cbox(indent_unit - 1u));\n                         try!(self.ibox(0u));\n                         try!(word(&mut self.s, \" else \"));\n-                        self.print_block(b)\n+                        self.print_block(&**b)\n                     }\n                     // BLEAH, constraints would be great here\n                     _ => {\n@@ -1151,7 +1152,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_if(&mut self, test: &ast::Expr, blk: &ast::Block,\n-                    elseopt: Option<@ast::Expr>, chk: bool) -> IoResult<()> {\n+                    elseopt: Option<Gc<ast::Expr>>, chk: bool) -> IoResult<()> {\n         try!(self.head(\"if\"));\n         if chk { try!(self.word_nbsp(\"check\")); }\n         try!(self.print_expr(test));\n@@ -1184,7 +1185,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    fn print_call_post(&mut self, args: &[@ast::Expr]) -> IoResult<()> {\n+    fn print_call_post(&mut self, args: &[Gc<ast::Expr>]) -> IoResult<()> {\n         try!(self.popen());\n         try!(self.commasep_exprs(Inconsistent, args));\n         self.pclose()\n@@ -1207,16 +1208,16 @@ impl<'a> State<'a> {\n         try!(self.ibox(indent_unit));\n         try!(self.ann.pre(self, NodeExpr(expr)));\n         match expr.node {\n-            ast::ExprVstore(e, v) => {\n+            ast::ExprVstore(ref e, v) => {\n                 try!(self.print_expr_vstore(v));\n-                try!(self.print_expr(e));\n+                try!(self.print_expr(&**e));\n             },\n-            ast::ExprBox(p, e) => {\n+            ast::ExprBox(ref p, ref e) => {\n                 try!(word(&mut self.s, \"box\"));\n                 try!(word(&mut self.s, \"(\"));\n-                try!(self.print_expr(p));\n+                try!(self.print_expr(&**p));\n                 try!(self.word_space(\")\"));\n-                try!(self.print_expr(e));\n+                try!(self.print_expr(&**e));\n             }\n             ast::ExprVec(ref exprs) => {\n                 try!(self.ibox(indent_unit));\n@@ -1226,13 +1227,13 @@ impl<'a> State<'a> {\n                 try!(self.end());\n             }\n \n-            ast::ExprRepeat(element, count) => {\n+            ast::ExprRepeat(ref element, ref count) => {\n                 try!(self.ibox(indent_unit));\n                 try!(word(&mut self.s, \"[\"));\n-                try!(self.print_expr(element));\n+                try!(self.print_expr(&**element));\n                 try!(word(&mut self.s, \",\"));\n                 try!(word(&mut self.s, \"..\"));\n-                try!(self.print_expr(count));\n+                try!(self.print_expr(&**count));\n                 try!(word(&mut self.s, \"]\"));\n                 try!(self.end());\n             }\n@@ -1247,19 +1248,19 @@ impl<'a> State<'a> {\n                         try!(s.ibox(indent_unit));\n                         try!(s.print_ident(field.ident.node));\n                         try!(s.word_space(\":\"));\n-                        try!(s.print_expr(field.expr));\n+                        try!(s.print_expr(&*field.expr));\n                         s.end()\n                     },\n                     |f| f.span));\n                 match wth {\n-                    Some(expr) => {\n+                    Some(ref expr) => {\n                         try!(self.ibox(indent_unit));\n                         if !fields.is_empty() {\n                             try!(word(&mut self.s, \",\"));\n                             try!(space(&mut self.s));\n                         }\n                         try!(word(&mut self.s, \"..\"));\n-                        try!(self.print_expr(expr));\n+                        try!(self.print_expr(&**expr));\n                         try!(self.end());\n                     }\n                     _ => try!(word(&mut self.s, \",\"))\n@@ -1274,13 +1275,13 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.pclose());\n             }\n-            ast::ExprCall(func, ref args) => {\n-                try!(self.print_expr_maybe_paren(func));\n+            ast::ExprCall(ref func, ref args) => {\n+                try!(self.print_expr_maybe_paren(&**func));\n                 try!(self.print_call_post(args.as_slice()));\n             }\n             ast::ExprMethodCall(ident, ref tys, ref args) => {\n                 let base_args = args.slice_from(1);\n-                try!(self.print_expr(*args.get(0)));\n+                try!(self.print_expr(&**args.get(0)));\n                 try!(word(&mut self.s, \".\"));\n                 try!(self.print_ident(ident.node));\n                 if tys.len() > 0u {\n@@ -1291,66 +1292,66 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.print_call_post(base_args));\n             }\n-            ast::ExprBinary(op, lhs, rhs) => {\n-                try!(self.print_expr(lhs));\n+            ast::ExprBinary(op, ref lhs, ref rhs) => {\n+                try!(self.print_expr(&**lhs));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(ast_util::binop_to_str(op)));\n-                try!(self.print_expr(rhs));\n+                try!(self.print_expr(&**rhs));\n             }\n-            ast::ExprUnary(op, expr) => {\n+            ast::ExprUnary(op, ref expr) => {\n                 try!(word(&mut self.s, ast_util::unop_to_str(op)));\n-                try!(self.print_expr_maybe_paren(expr));\n+                try!(self.print_expr_maybe_paren(&**expr));\n             }\n-            ast::ExprAddrOf(m, expr) => {\n+            ast::ExprAddrOf(m, ref expr) => {\n                 try!(word(&mut self.s, \"&\"));\n                 try!(self.print_mutability(m));\n-                try!(self.print_expr_maybe_paren(expr));\n+                try!(self.print_expr_maybe_paren(&**expr));\n             }\n-            ast::ExprLit(lit) => try!(self.print_literal(lit)),\n-            ast::ExprCast(expr, ty) => {\n-                try!(self.print_expr(expr));\n+            ast::ExprLit(ref lit) => try!(self.print_literal(&**lit)),\n+            ast::ExprCast(ref expr, ref ty) => {\n+                try!(self.print_expr(&**expr));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"as\"));\n-                try!(self.print_type(ty));\n+                try!(self.print_type(&**ty));\n             }\n-            ast::ExprIf(test, blk, elseopt) => {\n-                try!(self.print_if(test, blk, elseopt, false));\n+            ast::ExprIf(ref test, ref blk, elseopt) => {\n+                try!(self.print_if(&**test, &**blk, elseopt, false));\n             }\n-            ast::ExprWhile(test, blk) => {\n+            ast::ExprWhile(ref test, ref blk) => {\n                 try!(self.head(\"while\"));\n-                try!(self.print_expr(test));\n+                try!(self.print_expr(&**test));\n                 try!(space(&mut self.s));\n-                try!(self.print_block(blk));\n+                try!(self.print_block(&**blk));\n             }\n-            ast::ExprForLoop(pat, iter, blk, opt_ident) => {\n+            ast::ExprForLoop(ref pat, ref iter, ref blk, opt_ident) => {\n                 for ident in opt_ident.iter() {\n                     try!(word(&mut self.s, \"'\"));\n                     try!(self.print_ident(*ident));\n                     try!(self.word_space(\":\"));\n                 }\n                 try!(self.head(\"for\"));\n-                try!(self.print_pat(pat));\n+                try!(self.print_pat(&**pat));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"in\"));\n-                try!(self.print_expr(iter));\n+                try!(self.print_expr(&**iter));\n                 try!(space(&mut self.s));\n-                try!(self.print_block(blk));\n+                try!(self.print_block(&**blk));\n             }\n-            ast::ExprLoop(blk, opt_ident) => {\n+            ast::ExprLoop(ref blk, opt_ident) => {\n                 for ident in opt_ident.iter() {\n                     try!(word(&mut self.s, \"'\"));\n                     try!(self.print_ident(*ident));\n                     try!(self.word_space(\":\"));\n                 }\n                 try!(self.head(\"loop\"));\n                 try!(space(&mut self.s));\n-                try!(self.print_block(blk));\n+                try!(self.print_block(&**blk));\n             }\n-            ast::ExprMatch(expr, ref arms) => {\n+            ast::ExprMatch(ref expr, ref arms) => {\n                 try!(self.cbox(indent_unit));\n                 try!(self.ibox(4));\n                 try!(self.word_nbsp(\"match\"));\n-                try!(self.print_expr(expr));\n+                try!(self.print_expr(&**expr));\n                 try!(space(&mut self.s));\n                 try!(self.bopen());\n                 let len = arms.len();\n@@ -1371,58 +1372,59 @@ impl<'a> State<'a> {\n                             try!(space(&mut self.s));\n                             try!(self.word_space(\"|\"));\n                         }\n-                        try!(self.print_pat(*p));\n+                        try!(self.print_pat(&**p));\n                     }\n                     try!(space(&mut self.s));\n                     match arm.guard {\n-                        Some(e) => {\n+                        Some(ref e) => {\n                             try!(self.word_space(\"if\"));\n-                            try!(self.print_expr(e));\n+                            try!(self.print_expr(&**e));\n                             try!(space(&mut self.s));\n                         }\n                         None => ()\n                     }\n                     try!(self.word_space(\"=>\"));\n \n                     match arm.body.node {\n-                        ast::ExprBlock(blk) => {\n+                        ast::ExprBlock(ref blk) => {\n                             // the block will close the pattern's ibox\n-                            try!(self.print_block_unclosed_indent(blk, indent_unit));\n+                            try!(self.print_block_unclosed_indent(&**blk,\n+                                                                  indent_unit));\n                         }\n                         _ => {\n                             try!(self.end()); // close the ibox for the pattern\n-                            try!(self.print_expr(arm.body));\n+                            try!(self.print_expr(&*arm.body));\n                         }\n                     }\n-                    if !expr_is_simple_block(expr)\n+                    if !expr_is_simple_block(expr.clone())\n                         && i < len - 1 {\n                         try!(word(&mut self.s, \",\"));\n                     }\n                     try!(self.end()); // close enclosing cbox\n                 }\n                 try!(self.bclose_(expr.span, indent_unit));\n             }\n-            ast::ExprFnBlock(decl, body) => {\n+            ast::ExprFnBlock(ref decl, ref body) => {\n                 // in do/for blocks we don't want to show an empty\n                 // argument list, but at this point we don't know which\n                 // we are inside.\n                 //\n                 // if !decl.inputs.is_empty() {\n-                try!(self.print_fn_block_args(decl));\n+                try!(self.print_fn_block_args(&**decl));\n                 try!(space(&mut self.s));\n                 // }\n \n                 if !body.stmts.is_empty() || !body.expr.is_some() {\n-                    try!(self.print_block_unclosed(body));\n+                    try!(self.print_block_unclosed(&**body));\n                 } else {\n                     // we extract the block, so as not to create another set of boxes\n                     match body.expr.unwrap().node {\n-                        ast::ExprBlock(blk) => {\n-                            try!(self.print_block_unclosed(blk));\n+                        ast::ExprBlock(ref blk) => {\n+                            try!(self.print_block_unclosed(&**blk));\n                         }\n                         _ => {\n                             // this is a bare expression\n-                            try!(self.print_expr(body.expr.unwrap()));\n+                            try!(self.print_expr(&*body.expr.unwrap()));\n                             try!(self.end()); // need to close a box\n                         }\n                     }\n@@ -1432,25 +1434,25 @@ impl<'a> State<'a> {\n                 // empty box to satisfy the close.\n                 try!(self.ibox(0));\n             }\n-            ast::ExprProc(decl, body) => {\n+            ast::ExprProc(ref decl, ref body) => {\n                 // in do/for blocks we don't want to show an empty\n                 // argument list, but at this point we don't know which\n                 // we are inside.\n                 //\n                 // if !decl.inputs.is_empty() {\n-                try!(self.print_proc_args(decl));\n+                try!(self.print_proc_args(&**decl));\n                 try!(space(&mut self.s));\n                 // }\n                 assert!(body.stmts.is_empty());\n                 assert!(body.expr.is_some());\n                 // we extract the block, so as not to create another set of boxes\n                 match body.expr.unwrap().node {\n-                    ast::ExprBlock(blk) => {\n-                        try!(self.print_block_unclosed(blk));\n+                    ast::ExprBlock(ref blk) => {\n+                        try!(self.print_block_unclosed(&**blk));\n                     }\n                     _ => {\n                         // this is a bare expression\n-                        try!(self.print_expr(body.expr.unwrap()));\n+                        try!(self.print_expr(&*body.expr.unwrap()));\n                         try!(self.end()); // need to close a box\n                     }\n                 }\n@@ -1459,28 +1461,28 @@ impl<'a> State<'a> {\n                 // empty box to satisfy the close.\n                 try!(self.ibox(0));\n             }\n-            ast::ExprBlock(blk) => {\n+            ast::ExprBlock(ref blk) => {\n                 // containing cbox, will be closed by print-block at }\n                 try!(self.cbox(indent_unit));\n                 // head-box, will be closed by print-block after {\n                 try!(self.ibox(0u));\n-                try!(self.print_block(blk));\n+                try!(self.print_block(&**blk));\n             }\n-            ast::ExprAssign(lhs, rhs) => {\n-                try!(self.print_expr(lhs));\n+            ast::ExprAssign(ref lhs, ref rhs) => {\n+                try!(self.print_expr(&**lhs));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n-                try!(self.print_expr(rhs));\n+                try!(self.print_expr(&**rhs));\n             }\n-            ast::ExprAssignOp(op, lhs, rhs) => {\n-                try!(self.print_expr(lhs));\n+            ast::ExprAssignOp(op, ref lhs, ref rhs) => {\n+                try!(self.print_expr(&**lhs));\n                 try!(space(&mut self.s));\n                 try!(word(&mut self.s, ast_util::binop_to_str(op)));\n                 try!(self.word_space(\"=\"));\n-                try!(self.print_expr(rhs));\n+                try!(self.print_expr(&**rhs));\n             }\n-            ast::ExprField(expr, id, ref tys) => {\n-                try!(self.print_expr(expr));\n+            ast::ExprField(ref expr, id, ref tys) => {\n+                try!(self.print_expr(&**expr));\n                 try!(word(&mut self.s, \".\"));\n                 try!(self.print_ident(id));\n                 if tys.len() > 0u {\n@@ -1491,10 +1493,10 @@ impl<'a> State<'a> {\n                     try!(word(&mut self.s, \">\"));\n                 }\n             }\n-            ast::ExprIndex(expr, index) => {\n-                try!(self.print_expr(expr));\n+            ast::ExprIndex(ref expr, ref index) => {\n+                try!(self.print_expr(&**expr));\n                 try!(word(&mut self.s, \"[\"));\n-                try!(self.print_expr(index));\n+                try!(self.print_expr(&**index));\n                 try!(word(&mut self.s, \"]\"));\n             }\n             ast::ExprPath(ref path) => try!(self.print_path(path, true)),\n@@ -1516,12 +1518,12 @@ impl<'a> State<'a> {\n                     try!(space(&mut self.s))\n                 }\n             }\n-            ast::ExprRet(result) => {\n+            ast::ExprRet(ref result) => {\n                 try!(word(&mut self.s, \"return\"));\n-                match result {\n-                    Some(expr) => {\n+                match *result {\n+                    Some(ref expr) => {\n                         try!(word(&mut self.s, \" \"));\n-                        try!(self.print_expr(expr));\n+                        try!(self.print_expr(&**expr));\n                     }\n                     _ => ()\n                 }\n@@ -1536,20 +1538,22 @@ impl<'a> State<'a> {\n                 try!(self.print_string(a.asm.get(), a.asm_str_style));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent, a.outputs.as_slice(), |s, &(ref co, o)| {\n+                try!(self.commasep(Inconsistent, a.outputs.as_slice(),\n+                                   |s, &(ref co, ref o)| {\n                     try!(s.print_string(co.get(), ast::CookedStr));\n                     try!(s.popen());\n-                    try!(s.print_expr(o));\n+                    try!(s.print_expr(&**o));\n                     try!(s.pclose());\n                     Ok(())\n                 }));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent, a.inputs.as_slice(), |s, &(ref co, o)| {\n+                try!(self.commasep(Inconsistent, a.inputs.as_slice(),\n+                                   |s, &(ref co, ref o)| {\n                     try!(s.print_string(co.get(), ast::CookedStr));\n                     try!(s.popen());\n-                    try!(s.print_expr(o));\n+                    try!(s.print_expr(&**o));\n                     try!(s.pclose());\n                     Ok(())\n                 }));\n@@ -1560,9 +1564,9 @@ impl<'a> State<'a> {\n                 try!(self.pclose());\n             }\n             ast::ExprMac(ref m) => try!(self.print_mac(m)),\n-            ast::ExprParen(e) => {\n+            ast::ExprParen(ref e) => {\n                 try!(self.popen());\n-                try!(self.print_expr(e));\n+                try!(self.print_expr(&**e));\n                 try!(self.pclose());\n             }\n         }\n@@ -1571,38 +1575,38 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_local_decl(&mut self, loc: &ast::Local) -> IoResult<()> {\n-        try!(self.print_pat(loc.pat));\n+        try!(self.print_pat(&*loc.pat));\n         match loc.ty.node {\n             ast::TyInfer => Ok(()),\n             _ => {\n                 try!(self.word_space(\":\"));\n-                self.print_type(loc.ty)\n+                self.print_type(&*loc.ty)\n             }\n         }\n     }\n \n     pub fn print_decl(&mut self, decl: &ast::Decl) -> IoResult<()> {\n         try!(self.maybe_print_comment(decl.span.lo));\n         match decl.node {\n-            ast::DeclLocal(loc) => {\n+            ast::DeclLocal(ref loc) => {\n                 try!(self.space_if_not_bol());\n                 try!(self.ibox(indent_unit));\n                 try!(self.word_nbsp(\"let\"));\n \n                 try!(self.ibox(indent_unit));\n-                try!(self.print_local_decl(loc));\n+                try!(self.print_local_decl(&**loc));\n                 try!(self.end());\n                 match loc.init {\n-                    Some(init) => {\n+                    Some(ref init) => {\n                         try!(self.nbsp());\n                         try!(self.word_space(\"=\"));\n-                        try!(self.print_expr(init));\n+                        try!(self.print_expr(&**init));\n                     }\n                     _ => {}\n                 }\n                 self.end()\n             }\n-            ast::DeclItem(item) => self.print_item(item)\n+            ast::DeclItem(ref item) => self.print_item(&**item)\n         }\n     }\n \n@@ -1709,9 +1713,9 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.print_path(path, true));\n                 match sub {\n-                    Some(p) => {\n+                    Some(ref p) => {\n                         try!(word(&mut self.s, \"@\"));\n-                        try!(self.print_pat(p));\n+                        try!(self.print_pat(&**p));\n                     }\n                     None => ()\n                 }\n@@ -1724,7 +1728,7 @@ impl<'a> State<'a> {\n                         if !args.is_empty() {\n                             try!(self.popen());\n                             try!(self.commasep(Inconsistent, args.as_slice(),\n-                                              |s, &p| s.print_pat(p)));\n+                                              |s, p| s.print_pat(&**p)));\n                             try!(self.pclose());\n                         }\n                     }\n@@ -1739,7 +1743,7 @@ impl<'a> State<'a> {\n                         try!(s.cbox(indent_unit));\n                         try!(s.print_ident(f.ident));\n                         try!(s.word_space(\":\"));\n-                        try!(s.print_pat(f.pat));\n+                        try!(s.print_pat(&*f.pat));\n                         s.end()\n                     },\n                     |f| f.pat.span));\n@@ -1753,46 +1757,46 @@ impl<'a> State<'a> {\n                 try!(self.popen());\n                 try!(self.commasep(Inconsistent,\n                                    elts.as_slice(),\n-                                   |s, &p| s.print_pat(p)));\n+                                   |s, p| s.print_pat(&**p)));\n                 if elts.len() == 1 {\n                     try!(word(&mut self.s, \",\"));\n                 }\n                 try!(self.pclose());\n             }\n-            ast::PatBox(inner) => {\n+            ast::PatBox(ref inner) => {\n                 try!(word(&mut self.s, \"box \"));\n-                try!(self.print_pat(inner));\n+                try!(self.print_pat(&**inner));\n             }\n-            ast::PatRegion(inner) => {\n+            ast::PatRegion(ref inner) => {\n                 try!(word(&mut self.s, \"&\"));\n-                try!(self.print_pat(inner));\n+                try!(self.print_pat(&**inner));\n             }\n-            ast::PatLit(e) => try!(self.print_expr(e)),\n-            ast::PatRange(begin, end) => {\n-                try!(self.print_expr(begin));\n+            ast::PatLit(ref e) => try!(self.print_expr(&**e)),\n+            ast::PatRange(ref begin, ref end) => {\n+                try!(self.print_expr(&**begin));\n                 try!(space(&mut self.s));\n                 try!(word(&mut self.s, \"..\"));\n-                try!(self.print_expr(end));\n+                try!(self.print_expr(&**end));\n             }\n             ast::PatVec(ref before, slice, ref after) => {\n                 try!(word(&mut self.s, \"[\"));\n                 try!(self.commasep(Inconsistent,\n                                    before.as_slice(),\n-                                   |s, &p| s.print_pat(p)));\n-                for &p in slice.iter() {\n+                                   |s, p| s.print_pat(&**p)));\n+                for p in slice.iter() {\n                     if !before.is_empty() { try!(self.word_space(\",\")); }\n-                    match *p {\n+                    match **p {\n                         ast::Pat { node: ast::PatWildMulti, .. } => {\n                             // this case is handled by print_pat\n                         }\n                         _ => try!(word(&mut self.s, \"..\")),\n                     }\n-                    try!(self.print_pat(p));\n+                    try!(self.print_pat(&**p));\n                     if !after.is_empty() { try!(self.word_space(\",\")); }\n                 }\n                 try!(self.commasep(Inconsistent,\n                                    after.as_slice(),\n-                                   |s, &p| s.print_pat(p)));\n+                                   |s, p| s.print_pat(&**p)));\n                 try!(word(&mut self.s, \"]\"));\n             }\n             ast::PatMac(ref m) => try!(self.print_mac(m)),\n@@ -1888,7 +1892,7 @@ impl<'a> State<'a> {\n             _ => {\n                 try!(self.space_if_not_bol());\n                 try!(self.word_space(\"->\"));\n-                self.print_type(decl.output)\n+                self.print_type(&*decl.output)\n             }\n         }\n     }\n@@ -1904,7 +1908,7 @@ impl<'a> State<'a> {\n             _ => {\n                 try!(self.space_if_not_bol());\n                 try!(self.word_space(\"->\"));\n-                try!(self.print_type(decl.output));\n+                try!(self.print_type(&*decl.output));\n             }\n         }\n \n@@ -1922,7 +1926,7 @@ impl<'a> State<'a> {\n             _ => {\n                 try!(self.space_if_not_bol());\n                 try!(self.word_space(\"->\"));\n-                try!(self.print_type(decl.output));\n+                try!(self.print_type(&*decl.output));\n             }\n         }\n \n@@ -2014,10 +2018,10 @@ impl<'a> State<'a> {\n                         try!(s.print_ident(param.ident));\n                         try!(s.print_bounds(&None, &param.bounds, false));\n                         match param.default {\n-                            Some(default) => {\n+                            Some(ref default) => {\n                                 try!(space(&mut s.s));\n                                 try!(s.word_space(\"=\"));\n-                                s.print_type(default)\n+                                s.print_type(&**default)\n                             }\n                             _ => Ok(())\n                         }\n@@ -2045,7 +2049,7 @@ impl<'a> State<'a> {\n                 try!(self.popen());\n                 try!(self.commasep(Consistent,\n                                    items.as_slice(),\n-                                   |s, &i| s.print_meta_item(i)));\n+                                   |s, i| s.print_meta_item(&**i)));\n                 try!(self.pclose());\n             }\n         }\n@@ -2103,7 +2107,7 @@ impl<'a> State<'a> {\n \n             ast::ViewItemUse(ref vp) => {\n                 try!(self.head(\"use\"));\n-                try!(self.print_view_path(*vp));\n+                try!(self.print_view_path(&**vp));\n             }\n         }\n         try!(word(&mut self.s, \";\"));\n@@ -2121,13 +2125,13 @@ impl<'a> State<'a> {\n \n     pub fn print_mt(&mut self, mt: &ast::MutTy) -> IoResult<()> {\n         try!(self.print_mutability(mt.mutbl));\n-        self.print_type(mt.ty)\n+        self.print_type(&*mt.ty)\n     }\n \n     pub fn print_arg(&mut self, input: &ast::Arg) -> IoResult<()> {\n         try!(self.ibox(indent_unit));\n         match input.ty.node {\n-            ast::TyInfer => try!(self.print_pat(input.pat)),\n+            ast::TyInfer => try!(self.print_pat(&*input.pat)),\n             _ => {\n                 match input.pat.node {\n                     ast::PatIdent(_, ref path, _) if\n@@ -2137,12 +2141,12 @@ impl<'a> State<'a> {\n                         // Do nothing.\n                     }\n                     _ => {\n-                        try!(self.print_pat(input.pat));\n+                        try!(self.print_pat(&*input.pat));\n                         try!(word(&mut self.s, \":\"));\n                         try!(space(&mut self.s));\n                     }\n                 }\n-                try!(self.print_type(input.ty));\n+                try!(self.print_type(&*input.ty));\n             }\n         }\n         self.end()\n@@ -2229,7 +2233,7 @@ impl<'a> State<'a> {\n                 if decl.cf == ast::NoReturn {\n                     try!(self.word_nbsp(\"!\"));\n                 } else {\n-                    try!(self.print_type(decl.output));\n+                    try!(self.print_type(&*decl.output));\n                 }\n                 try!(self.end());\n             }"}, {"sha": "40f237d3267a9ccab15764af7bd153bccaf35c65", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 140, "deletions": 138, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ad426e92f8099a701f3f54c02dc8f069f5939a/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=53ad426e92f8099a701f3f54c02dc8f069f5939a", "patch": "@@ -15,6 +15,8 @@ use codemap::Span;\n use parse;\n use owned_slice::OwnedSlice;\n \n+use std::gc::Gc;\n+\n // Context-passing AST walker. Each overridden visit method has full control\n // over what happens with its node, it can do its own traversal of the node's\n // children (potentially passing in different contexts to each), call\n@@ -135,9 +137,9 @@ pub fn walk_inlined_item<E: Clone, V: Visitor<E>>(visitor: &mut V,\n                                                   item: &ast::InlinedItem,\n                                                   env: E) {\n     match *item {\n-        IIItem(i) => visitor.visit_item(i, env),\n-        IIForeign(i) => visitor.visit_foreign_item(i, env),\n-        IIMethod(_, _, m) => walk_method_helper(visitor, m, env),\n+        IIItem(i) => visitor.visit_item(&*i, env),\n+        IIForeign(i) => visitor.visit_foreign_item(&*i, env),\n+        IIMethod(_, _, m) => walk_method_helper(visitor, &*m, env),\n     }\n }\n \n@@ -155,7 +157,7 @@ pub fn walk_mod<E: Clone, V: Visitor<E>>(visitor: &mut V, module: &Mod, env: E)\n     }\n \n     for item in module.items.iter() {\n-        visitor.visit_item(*item, env.clone())\n+        visitor.visit_item(&**item, env.clone())\n     }\n }\n \n@@ -188,11 +190,11 @@ pub fn walk_view_item<E: Clone, V: Visitor<E>>(visitor: &mut V, vi: &ViewItem, e\n }\n \n pub fn walk_local<E: Clone, V: Visitor<E>>(visitor: &mut V, local: &Local, env: E) {\n-    visitor.visit_pat(local.pat, env.clone());\n-    visitor.visit_ty(local.ty, env.clone());\n+    visitor.visit_pat(&*local.pat, env.clone());\n+    visitor.visit_ty(&*local.ty, env.clone());\n     match local.init {\n         None => {}\n-        Some(initializer) => visitor.visit_expr(initializer, env),\n+        Some(initializer) => visitor.visit_expr(&*initializer, env),\n     }\n }\n \n@@ -219,13 +221,13 @@ pub fn walk_item<E: Clone, V: Visitor<E>>(visitor: &mut V, item: &Item, env: E)\n     visitor.visit_ident(item.span, item.ident, env.clone());\n     match item.node {\n         ItemStatic(typ, _, expr) => {\n-            visitor.visit_ty(typ, env.clone());\n-            visitor.visit_expr(expr, env.clone());\n+            visitor.visit_ty(&*typ, env.clone());\n+            visitor.visit_expr(&*expr, env);\n         }\n         ItemFn(declaration, fn_style, abi, ref generics, body) => {\n             visitor.visit_fn(&FkItemFn(item.ident, generics, fn_style, abi),\n-                             declaration,\n-                             body,\n+                             &*declaration,\n+                             &*body,\n                              item.span,\n                              item.id,\n                              env.clone())\n@@ -238,12 +240,12 @@ pub fn walk_item<E: Clone, V: Visitor<E>>(visitor: &mut V, item: &Item, env: E)\n                 visitor.visit_view_item(view_item, env.clone())\n             }\n             for foreign_item in foreign_module.items.iter() {\n-                visitor.visit_foreign_item(*foreign_item, env.clone())\n+                visitor.visit_foreign_item(&**foreign_item, env.clone())\n             }\n         }\n         ItemTy(typ, ref type_parameters) => {\n-            visitor.visit_ty(typ, env.clone());\n-            visitor.visit_generics(type_parameters, env.clone())\n+            visitor.visit_ty(&*typ, env.clone());\n+            visitor.visit_generics(type_parameters, env)\n         }\n         ItemEnum(ref enum_definition, ref type_parameters) => {\n             visitor.visit_generics(type_parameters, env.clone());\n@@ -259,14 +261,14 @@ pub fn walk_item<E: Clone, V: Visitor<E>>(visitor: &mut V, item: &Item, env: E)\n                                                                    trait_reference, env.clone()),\n                 None => ()\n             }\n-            visitor.visit_ty(typ, env.clone());\n+            visitor.visit_ty(&*typ, env.clone());\n             for method in methods.iter() {\n-                walk_method_helper(visitor, *method, env.clone())\n+                walk_method_helper(visitor, &**method, env.clone())\n             }\n         }\n-        ItemStruct(struct_definition, ref generics) => {\n+        ItemStruct(ref struct_definition, ref generics) => {\n             visitor.visit_generics(generics, env.clone());\n-            visitor.visit_struct_def(struct_definition,\n+            visitor.visit_struct_def(&**struct_definition,\n                                      item.ident,\n                                      generics,\n                                      item.id,\n@@ -295,7 +297,7 @@ pub fn walk_enum_def<E: Clone, V:Visitor<E>>(visitor: &mut V,\n                                              generics: &Generics,\n                                              env: E) {\n     for &variant in enum_definition.variants.iter() {\n-        visitor.visit_variant(variant, generics, env.clone());\n+        visitor.visit_variant(&*variant, generics, env.clone());\n     }\n }\n \n@@ -308,19 +310,19 @@ pub fn walk_variant<E: Clone, V: Visitor<E>>(visitor: &mut V,\n     match variant.node.kind {\n         TupleVariantKind(ref variant_arguments) => {\n             for variant_argument in variant_arguments.iter() {\n-                visitor.visit_ty(variant_argument.ty, env.clone())\n+                visitor.visit_ty(&*variant_argument.ty, env.clone())\n             }\n         }\n-        StructVariantKind(struct_definition) => {\n-            visitor.visit_struct_def(struct_definition,\n+        StructVariantKind(ref struct_definition) => {\n+            visitor.visit_struct_def(&**struct_definition,\n                                      variant.node.name,\n                                      generics,\n                                      variant.node.id,\n                                      env.clone())\n         }\n     }\n     match variant.node.disr_expr {\n-        Some(expr) => visitor.visit_expr(expr, env.clone()),\n+        Some(ref expr) => visitor.visit_expr(&**expr, env.clone()),\n         None => ()\n     }\n     for attr in variant.node.attrs.iter() {\n@@ -335,25 +337,25 @@ pub fn skip_ty<E, V: Visitor<E>>(_: &mut V, _: &Ty, _: E) {\n pub fn walk_ty<E: Clone, V: Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n     match typ.node {\n         TyUniq(ty) | TyVec(ty) | TyBox(ty) => {\n-            visitor.visit_ty(ty, env)\n+            visitor.visit_ty(&*ty, env)\n         }\n         TyPtr(ref mutable_type) => {\n-            visitor.visit_ty(mutable_type.ty, env)\n+            visitor.visit_ty(&*mutable_type.ty, env)\n         }\n         TyRptr(ref lifetime, ref mutable_type) => {\n             visitor.visit_opt_lifetime_ref(typ.span, lifetime, env.clone());\n-            visitor.visit_ty(mutable_type.ty, env)\n+            visitor.visit_ty(&*mutable_type.ty, env)\n         }\n         TyTup(ref tuple_element_types) => {\n             for &tuple_element_type in tuple_element_types.iter() {\n-                visitor.visit_ty(tuple_element_type, env.clone())\n+                visitor.visit_ty(&*tuple_element_type, env.clone())\n             }\n         }\n         TyClosure(ref function_declaration, ref region) => {\n             for argument in function_declaration.decl.inputs.iter() {\n-                visitor.visit_ty(argument.ty, env.clone())\n+                visitor.visit_ty(&*argument.ty, env.clone())\n             }\n-            visitor.visit_ty(function_declaration.decl.output, env.clone());\n+            visitor.visit_ty(&*function_declaration.decl.output, env.clone());\n             for bounds in function_declaration.bounds.iter() {\n                 walk_ty_param_bounds(visitor, bounds, env.clone())\n             }\n@@ -366,9 +368,9 @@ pub fn walk_ty<E: Clone, V: Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n         }\n         TyProc(ref function_declaration) => {\n             for argument in function_declaration.decl.inputs.iter() {\n-                visitor.visit_ty(argument.ty, env.clone())\n+                visitor.visit_ty(&*argument.ty, env.clone())\n             }\n-            visitor.visit_ty(function_declaration.decl.output, env.clone());\n+            visitor.visit_ty(&*function_declaration.decl.output, env.clone());\n             for bounds in function_declaration.bounds.iter() {\n                 walk_ty_param_bounds(visitor, bounds, env.clone())\n             }\n@@ -377,9 +379,9 @@ pub fn walk_ty<E: Clone, V: Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n         }\n         TyBareFn(ref function_declaration) => {\n             for argument in function_declaration.decl.inputs.iter() {\n-                visitor.visit_ty(argument.ty, env.clone())\n+                visitor.visit_ty(&*argument.ty, env.clone())\n             }\n-            visitor.visit_ty(function_declaration.decl.output, env.clone());\n+            visitor.visit_ty(&*function_declaration.decl.output, env.clone());\n             walk_lifetime_decls(visitor, &function_declaration.lifetimes,\n                                 env.clone());\n         }\n@@ -395,12 +397,12 @@ pub fn walk_ty<E: Clone, V: Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n                 walk_ty_param_bounds(visitor, bounds, env.clone())\n             }\n         }\n-        TyFixedLengthVec(ty, expression) => {\n-            visitor.visit_ty(ty, env.clone());\n-            visitor.visit_expr(expression, env)\n+        TyFixedLengthVec(ref ty, ref expression) => {\n+            visitor.visit_ty(&**ty, env.clone());\n+            visitor.visit_expr(&**expression, env)\n         }\n-        TyTypeof(expression) => {\n-            visitor.visit_expr(expression, env)\n+        TyTypeof(ref expression) => {\n+            visitor.visit_expr(&**expression, env)\n         }\n         TyNil | TyBot | TyInfer => {}\n     }\n@@ -418,8 +420,8 @@ pub fn walk_path<E: Clone, V: Visitor<E>>(visitor: &mut V, path: &Path, env: E)\n     for segment in path.segments.iter() {\n         visitor.visit_ident(path.span, segment.identifier, env.clone());\n \n-        for &typ in segment.types.iter() {\n-            visitor.visit_ty(typ, env.clone());\n+        for typ in segment.types.iter() {\n+            visitor.visit_ty(&**typ, env.clone());\n         }\n         for lifetime in segment.lifetimes.iter() {\n             visitor.visit_lifetime_ref(lifetime, env.clone());\n@@ -433,47 +435,47 @@ pub fn walk_pat<E: Clone, V: Visitor<E>>(visitor: &mut V, pattern: &Pat, env: E)\n             visitor.visit_path(path, pattern.id, env.clone());\n             for children in children.iter() {\n                 for child in children.iter() {\n-                    visitor.visit_pat(*child, env.clone())\n+                    visitor.visit_pat(&**child, env.clone())\n                 }\n             }\n         }\n         PatStruct(ref path, ref fields, _) => {\n             visitor.visit_path(path, pattern.id, env.clone());\n             for field in fields.iter() {\n-                visitor.visit_pat(field.pat, env.clone())\n+                visitor.visit_pat(&*field.pat, env.clone())\n             }\n         }\n         PatTup(ref tuple_elements) => {\n             for tuple_element in tuple_elements.iter() {\n-                visitor.visit_pat(*tuple_element, env.clone())\n+                visitor.visit_pat(&**tuple_element, env.clone())\n             }\n         }\n-        PatBox(subpattern) |\n-        PatRegion(subpattern) => {\n-            visitor.visit_pat(subpattern, env)\n+        PatBox(ref subpattern) |\n+        PatRegion(ref subpattern) => {\n+            visitor.visit_pat(&**subpattern, env)\n         }\n         PatIdent(_, ref path, ref optional_subpattern) => {\n             visitor.visit_path(path, pattern.id, env.clone());\n             match *optional_subpattern {\n                 None => {}\n-                Some(subpattern) => visitor.visit_pat(subpattern, env),\n+                Some(ref subpattern) => visitor.visit_pat(&**subpattern, env),\n             }\n         }\n-        PatLit(expression) => visitor.visit_expr(expression, env),\n-        PatRange(lower_bound, upper_bound) => {\n-            visitor.visit_expr(lower_bound, env.clone());\n-            visitor.visit_expr(upper_bound, env)\n+        PatLit(ref expression) => visitor.visit_expr(&**expression, env),\n+        PatRange(ref lower_bound, ref upper_bound) => {\n+            visitor.visit_expr(&**lower_bound, env.clone());\n+            visitor.visit_expr(&**upper_bound, env)\n         }\n         PatWild | PatWildMulti => (),\n         PatVec(ref prepattern, ref slice_pattern, ref postpatterns) => {\n             for prepattern in prepattern.iter() {\n-                visitor.visit_pat(*prepattern, env.clone())\n+                visitor.visit_pat(&**prepattern, env.clone())\n             }\n             for slice_pattern in slice_pattern.iter() {\n-                visitor.visit_pat(*slice_pattern, env.clone())\n+                visitor.visit_pat(&**slice_pattern, env.clone())\n             }\n             for postpattern in postpatterns.iter() {\n-                visitor.visit_pat(*postpattern, env.clone())\n+                visitor.visit_pat(&**postpattern, env.clone())\n             }\n         }\n         PatMac(ref macro) => visitor.visit_mac(macro, env),\n@@ -486,8 +488,8 @@ pub fn walk_foreign_item<E: Clone, V: Visitor<E>>(visitor: &mut V,\n     visitor.visit_ident(foreign_item.span, foreign_item.ident, env.clone());\n \n     match foreign_item.node {\n-        ForeignItemFn(function_declaration, ref generics) => {\n-            walk_fn_decl(visitor, function_declaration, env.clone());\n+        ForeignItemFn(ref function_declaration, ref generics) => {\n+            walk_fn_decl(visitor, &**function_declaration, env.clone());\n             visitor.visit_generics(generics, env.clone())\n         }\n         ForeignItemStatic(typ, _) => visitor.visit_ty(typ, env.clone()),\n@@ -525,7 +527,7 @@ pub fn walk_generics<E: Clone, V: Visitor<E>>(visitor: &mut V,\n     for type_parameter in generics.ty_params.iter() {\n         walk_ty_param_bounds(visitor, &type_parameter.bounds, env.clone());\n         match type_parameter.default {\n-            Some(ty) => visitor.visit_ty(ty, env.clone()),\n+            Some(ref ty) => visitor.visit_ty(&**ty, env.clone()),\n             None => {}\n         }\n     }\n@@ -536,10 +538,10 @@ pub fn walk_fn_decl<E: Clone, V: Visitor<E>>(visitor: &mut V,\n                                              function_declaration: &FnDecl,\n                                              env: E) {\n     for argument in function_declaration.inputs.iter() {\n-        visitor.visit_pat(argument.pat, env.clone());\n-        visitor.visit_ty(argument.ty, env.clone())\n+        visitor.visit_pat(&*argument.pat, env.clone());\n+        visitor.visit_ty(&*argument.ty, env.clone())\n     }\n-    visitor.visit_ty(function_declaration.output, env)\n+    visitor.visit_ty(&*function_declaration.output, env)\n }\n \n // Note: there is no visit_method() method in the visitor, instead override\n@@ -551,8 +553,8 @@ pub fn walk_method_helper<E: Clone, V: Visitor<E>>(visitor: &mut V,\n                                                    env: E) {\n     visitor.visit_ident(method.span, method.ident, env.clone());\n     visitor.visit_fn(&FkMethod(method.ident, &method.generics, method),\n-                     method.decl,\n-                     method.body,\n+                     &*method.decl,\n+                     &*method.body,\n                      method.span,\n                      method.id,\n                      env.clone());\n@@ -590,7 +592,7 @@ pub fn walk_ty_method<E: Clone, V: Visitor<E>>(visitor: &mut V,\n     visitor.visit_ident(method_type.span, method_type.ident, env.clone());\n     visitor.visit_explicit_self(&method_type.explicit_self, env.clone());\n     for argument_type in method_type.decl.inputs.iter() {\n-        visitor.visit_ty(argument_type.ty, env.clone())\n+        visitor.visit_ty(&*argument_type.ty, env.clone())\n     }\n     visitor.visit_generics(&method_type.generics, env.clone());\n     visitor.visit_ty(method_type.decl.output, env.clone());\n@@ -606,15 +608,15 @@ pub fn walk_trait_method<E: Clone, V: Visitor<E>>(visitor: &mut V,\n         Required(ref method_type) => {\n             visitor.visit_ty_method(method_type, env)\n         }\n-        Provided(method) => walk_method_helper(visitor, method, env),\n+        Provided(ref method) => walk_method_helper(visitor, &**method, env),\n     }\n }\n \n pub fn walk_struct_def<E: Clone, V: Visitor<E>>(visitor: &mut V,\n                                                 struct_definition: &StructDef,\n                                                 env: E) {\n     match struct_definition.super_struct {\n-        Some(t) => visitor.visit_ty(t, env.clone()),\n+        Some(ref t) => visitor.visit_ty(&**t, env.clone()),\n         None => {},\n     }\n     for field in struct_definition.fields.iter() {\n@@ -644,42 +646,42 @@ pub fn walk_block<E: Clone, V: Visitor<E>>(visitor: &mut V, block: &Block, env:\n         visitor.visit_view_item(view_item, env.clone())\n     }\n     for statement in block.stmts.iter() {\n-        visitor.visit_stmt(*statement, env.clone())\n+        visitor.visit_stmt(&**statement, env.clone())\n     }\n     walk_expr_opt(visitor, block.expr, env)\n }\n \n pub fn walk_stmt<E: Clone, V: Visitor<E>>(visitor: &mut V, statement: &Stmt, env: E) {\n     match statement.node {\n-        StmtDecl(declaration, _) => visitor.visit_decl(declaration, env),\n-        StmtExpr(expression, _) | StmtSemi(expression, _) => {\n-            visitor.visit_expr(expression, env)\n+        StmtDecl(ref declaration, _) => visitor.visit_decl(&**declaration, env),\n+        StmtExpr(ref expression, _) | StmtSemi(ref expression, _) => {\n+            visitor.visit_expr(&**expression, env)\n         }\n         StmtMac(ref macro, _) => visitor.visit_mac(macro, env),\n     }\n }\n \n pub fn walk_decl<E: Clone, V: Visitor<E>>(visitor: &mut V, declaration: &Decl, env: E) {\n     match declaration.node {\n-        DeclLocal(ref local) => visitor.visit_local(*local, env),\n-        DeclItem(item) => visitor.visit_item(item, env),\n+        DeclLocal(ref local) => visitor.visit_local(&**local, env),\n+        DeclItem(ref item) => visitor.visit_item(&**item, env),\n     }\n }\n \n pub fn walk_expr_opt<E: Clone, V: Visitor<E>>(visitor: &mut V,\n-                                              optional_expression: Option<@Expr>,\n+                                              optional_expression: Option<Gc<Expr>>,\n                                               env: E) {\n     match optional_expression {\n         None => {}\n-        Some(expression) => visitor.visit_expr(expression, env),\n+        Some(ref expression) => visitor.visit_expr(&**expression, env),\n     }\n }\n \n pub fn walk_exprs<E: Clone, V: Visitor<E>>(visitor: &mut V,\n-                                           expressions: &[@Expr],\n+                                           expressions: &[Gc<Expr>],\n                                            env: E) {\n     for expression in expressions.iter() {\n-        visitor.visit_expr(*expression, env.clone())\n+        visitor.visit_expr(&**expression, env.clone())\n     }\n }\n \n@@ -689,111 +691,111 @@ pub fn walk_mac<E, V: Visitor<E>>(_: &mut V, _: &Mac, _: E) {\n \n pub fn walk_expr<E: Clone, V: Visitor<E>>(visitor: &mut V, expression: &Expr, env: E) {\n     match expression.node {\n-        ExprVstore(subexpression, _) => {\n-            visitor.visit_expr(subexpression, env.clone())\n+        ExprVstore(ref subexpression, _) => {\n+            visitor.visit_expr(&**subexpression, env.clone())\n         }\n-        ExprBox(place, subexpression) => {\n-            visitor.visit_expr(place, env.clone());\n-            visitor.visit_expr(subexpression, env.clone())\n+        ExprBox(ref place, ref subexpression) => {\n+            visitor.visit_expr(&**place, env.clone());\n+            visitor.visit_expr(&**subexpression, env.clone())\n         }\n         ExprVec(ref subexpressions) => {\n             walk_exprs(visitor, subexpressions.as_slice(), env.clone())\n         }\n-        ExprRepeat(element, count) => {\n-            visitor.visit_expr(element, env.clone());\n-            visitor.visit_expr(count, env.clone())\n+        ExprRepeat(ref element, ref count) => {\n+            visitor.visit_expr(&**element, env.clone());\n+            visitor.visit_expr(&**count, env.clone())\n         }\n         ExprStruct(ref path, ref fields, optional_base) => {\n             visitor.visit_path(path, expression.id, env.clone());\n             for field in fields.iter() {\n-                visitor.visit_expr(field.expr, env.clone())\n+                visitor.visit_expr(&*field.expr, env.clone())\n             }\n             walk_expr_opt(visitor, optional_base, env.clone())\n         }\n         ExprTup(ref subexpressions) => {\n             for subexpression in subexpressions.iter() {\n-                visitor.visit_expr(*subexpression, env.clone())\n+                visitor.visit_expr(&**subexpression, env.clone())\n             }\n         }\n-        ExprCall(callee_expression, ref arguments) => {\n+        ExprCall(ref callee_expression, ref arguments) => {\n             for argument in arguments.iter() {\n-                visitor.visit_expr(*argument, env.clone())\n+                visitor.visit_expr(&**argument, env.clone())\n             }\n-            visitor.visit_expr(callee_expression, env.clone())\n+            visitor.visit_expr(&**callee_expression, env.clone())\n         }\n         ExprMethodCall(_, ref types, ref arguments) => {\n             walk_exprs(visitor, arguments.as_slice(), env.clone());\n-            for &typ in types.iter() {\n-                visitor.visit_ty(typ, env.clone())\n+            for typ in types.iter() {\n+                visitor.visit_ty(&**typ, env.clone())\n             }\n         }\n-        ExprBinary(_, left_expression, right_expression) => {\n-            visitor.visit_expr(left_expression, env.clone());\n-            visitor.visit_expr(right_expression, env.clone())\n+        ExprBinary(_, ref left_expression, ref right_expression) => {\n+            visitor.visit_expr(&**left_expression, env.clone());\n+            visitor.visit_expr(&**right_expression, env.clone())\n         }\n-        ExprAddrOf(_, subexpression) | ExprUnary(_, subexpression) => {\n-            visitor.visit_expr(subexpression, env.clone())\n+        ExprAddrOf(_, ref subexpression) | ExprUnary(_, ref subexpression) => {\n+            visitor.visit_expr(&**subexpression, env.clone())\n         }\n         ExprLit(_) => {}\n-        ExprCast(subexpression, typ) => {\n-            visitor.visit_expr(subexpression, env.clone());\n-            visitor.visit_ty(typ, env.clone())\n+        ExprCast(ref subexpression, ref typ) => {\n+            visitor.visit_expr(&**subexpression, env.clone());\n+            visitor.visit_ty(&**typ, env.clone())\n         }\n-        ExprIf(head_expression, if_block, optional_else) => {\n-            visitor.visit_expr(head_expression, env.clone());\n-            visitor.visit_block(if_block, env.clone());\n+        ExprIf(ref head_expression, ref if_block, optional_else) => {\n+            visitor.visit_expr(&**head_expression, env.clone());\n+            visitor.visit_block(&**if_block, env.clone());\n             walk_expr_opt(visitor, optional_else, env.clone())\n         }\n-        ExprWhile(subexpression, block) => {\n-            visitor.visit_expr(subexpression, env.clone());\n-            visitor.visit_block(block, env.clone())\n+        ExprWhile(ref subexpression, ref block) => {\n+            visitor.visit_expr(&**subexpression, env.clone());\n+            visitor.visit_block(&**block, env.clone())\n         }\n-        ExprForLoop(pattern, subexpression, block, _) => {\n-            visitor.visit_pat(pattern, env.clone());\n-            visitor.visit_expr(subexpression, env.clone());\n-            visitor.visit_block(block, env.clone())\n+        ExprForLoop(ref pattern, ref subexpression, ref block, _) => {\n+            visitor.visit_pat(&**pattern, env.clone());\n+            visitor.visit_expr(&**subexpression, env.clone());\n+            visitor.visit_block(&**block, env.clone())\n         }\n-        ExprLoop(block, _) => visitor.visit_block(block, env.clone()),\n-        ExprMatch(subexpression, ref arms) => {\n-            visitor.visit_expr(subexpression, env.clone());\n+        ExprLoop(ref block, _) => visitor.visit_block(&**block, env.clone()),\n+        ExprMatch(ref subexpression, ref arms) => {\n+            visitor.visit_expr(&**subexpression, env.clone());\n             for arm in arms.iter() {\n                 visitor.visit_arm(arm, env.clone())\n             }\n         }\n-        ExprFnBlock(function_declaration, body) => {\n+        ExprFnBlock(ref function_declaration, ref body) => {\n             visitor.visit_fn(&FkFnBlock,\n-                             function_declaration,\n-                             body,\n+                             &**function_declaration,\n+                             &**body,\n                              expression.span,\n                              expression.id,\n                              env.clone())\n         }\n-        ExprProc(function_declaration, body) => {\n+        ExprProc(ref function_declaration, ref body) => {\n             visitor.visit_fn(&FkFnBlock,\n-                             function_declaration,\n-                             body,\n+                             &**function_declaration,\n+                             &**body,\n                              expression.span,\n                              expression.id,\n                              env.clone())\n         }\n-        ExprBlock(block) => visitor.visit_block(block, env.clone()),\n-        ExprAssign(left_hand_expression, right_hand_expression) => {\n-            visitor.visit_expr(right_hand_expression, env.clone());\n-            visitor.visit_expr(left_hand_expression, env.clone())\n+        ExprBlock(ref block) => visitor.visit_block(&**block, env.clone()),\n+        ExprAssign(ref left_hand_expression, ref right_hand_expression) => {\n+            visitor.visit_expr(&**right_hand_expression, env.clone());\n+            visitor.visit_expr(&**left_hand_expression, env.clone())\n         }\n-        ExprAssignOp(_, left_expression, right_expression) => {\n-            visitor.visit_expr(right_expression, env.clone());\n-            visitor.visit_expr(left_expression, env.clone())\n+        ExprAssignOp(_, ref left_expression, ref right_expression) => {\n+            visitor.visit_expr(&**right_expression, env.clone());\n+            visitor.visit_expr(&**left_expression, env.clone())\n         }\n-        ExprField(subexpression, _, ref types) => {\n-            visitor.visit_expr(subexpression, env.clone());\n-            for &typ in types.iter() {\n-                visitor.visit_ty(typ, env.clone())\n+        ExprField(ref subexpression, _, ref types) => {\n+            visitor.visit_expr(&**subexpression, env.clone());\n+            for typ in types.iter() {\n+                visitor.visit_ty(&**typ, env.clone())\n             }\n         }\n-        ExprIndex(main_expression, index_expression) => {\n-            visitor.visit_expr(main_expression, env.clone());\n-            visitor.visit_expr(index_expression, env.clone())\n+        ExprIndex(ref main_expression, ref index_expression) => {\n+            visitor.visit_expr(&**main_expression, env.clone());\n+            visitor.visit_expr(&**index_expression, env.clone())\n         }\n         ExprPath(ref path) => {\n             visitor.visit_path(path, expression.id, env.clone())\n@@ -803,15 +805,15 @@ pub fn walk_expr<E: Clone, V: Visitor<E>>(visitor: &mut V, expression: &Expr, en\n             walk_expr_opt(visitor, optional_expression, env.clone())\n         }\n         ExprMac(ref macro) => visitor.visit_mac(macro, env.clone()),\n-        ExprParen(subexpression) => {\n-            visitor.visit_expr(subexpression, env.clone())\n+        ExprParen(ref subexpression) => {\n+            visitor.visit_expr(&**subexpression, env.clone())\n         }\n         ExprInlineAsm(ref assembler) => {\n-            for &(_, input) in assembler.inputs.iter() {\n-                visitor.visit_expr(input, env.clone())\n+            for &(_, ref input) in assembler.inputs.iter() {\n+                visitor.visit_expr(&**input, env.clone())\n             }\n-            for &(_, output) in assembler.outputs.iter() {\n-                visitor.visit_expr(output, env.clone())\n+            for &(_, ref output) in assembler.outputs.iter() {\n+                visitor.visit_expr(&**output, env.clone())\n             }\n         }\n     }\n@@ -821,7 +823,7 @@ pub fn walk_expr<E: Clone, V: Visitor<E>>(visitor: &mut V, expression: &Expr, en\n \n pub fn walk_arm<E: Clone, V: Visitor<E>>(visitor: &mut V, arm: &Arm, env: E) {\n     for pattern in arm.pats.iter() {\n-        visitor.visit_pat(*pattern, env.clone())\n+        visitor.visit_pat(&**pattern, env.clone())\n     }\n     walk_expr_opt(visitor, arm.guard, env.clone());\n     visitor.visit_expr(arm.body, env.clone());"}]}