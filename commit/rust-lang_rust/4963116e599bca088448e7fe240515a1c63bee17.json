{"sha": "4963116e599bca088448e7fe240515a1c63bee17", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5NjMxMTZlNTk5YmNhMDg4NDQ4ZTdmZTI0MDUxNWExYzYzYmVlMTc=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2019-11-11T21:46:36Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2019-11-14T12:05:56Z"}, "message": "Remove unused error_codes.rs files", "tree": {"sha": "7f095fdda4fe90338842e55cb11830148ef41435", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f095fdda4fe90338842e55cb11830148ef41435"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4963116e599bca088448e7fe240515a1c63bee17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4963116e599bca088448e7fe240515a1c63bee17", "html_url": "https://github.com/rust-lang/rust/commit/4963116e599bca088448e7fe240515a1c63bee17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4963116e599bca088448e7fe240515a1c63bee17/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "798e389e578a0199f734c79424fa39e440910979", "url": "https://api.github.com/repos/rust-lang/rust/commits/798e389e578a0199f734c79424fa39e440910979", "html_url": "https://github.com/rust-lang/rust/commit/798e389e578a0199f734c79424fa39e440910979"}], "stats": {"total": 13818, "additions": 0, "deletions": 13818}, "files": [{"sha": "d5c2db5fb970532a0ad078d9c042cf6647a048ba", "filename": "src/librustc/error_codes.rs", "status": "removed", "additions": 0, "deletions": 2394, "changes": 2394, "blob_url": "https://github.com/rust-lang/rust/blob/798e389e578a0199f734c79424fa39e440910979/src%2Flibrustc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/798e389e578a0199f734c79424fa39e440910979/src%2Flibrustc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ferror_codes.rs?ref=798e389e578a0199f734c79424fa39e440910979", "patch": "@@ -1,2394 +0,0 @@\n-// Error messages for EXXXX errors.\n-// Each message should start and end with a new line, and be wrapped to 80\n-// characters.  In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use\n-// `:set tw=0` to disable.\n-syntax::register_diagnostics! {\n-E0038: r##\"\n-Trait objects like `Box<Trait>` can only be constructed when certain\n-requirements are satisfied by the trait in question.\n-\n-Trait objects are a form of dynamic dispatch and use a dynamically sized type\n-for the inner type. So, for a given trait `Trait`, when `Trait` is treated as a\n-type, as in `Box<Trait>`, the inner type is 'unsized'. In such cases the boxed\n-pointer is a 'fat pointer' that contains an extra pointer to a table of methods\n-(among other things) for dynamic dispatch. This design mandates some\n-restrictions on the types of traits that are allowed to be used in trait\n-objects, which are collectively termed as 'object safety' rules.\n-\n-Attempting to create a trait object for a non object-safe trait will trigger\n-this error.\n-\n-There are various rules:\n-\n-### The trait cannot require `Self: Sized`\n-\n-When `Trait` is treated as a type, the type does not implement the special\n-`Sized` trait, because the type does not have a known size at compile time and\n-can only be accessed behind a pointer. Thus, if we have a trait like the\n-following:\n-\n-```\n-trait Foo where Self: Sized {\n-\n-}\n-```\n-\n-We cannot create an object of type `Box<Foo>` or `&Foo` since in this case\n-`Self` would not be `Sized`.\n-\n-Generally, `Self: Sized` is used to indicate that the trait should not be used\n-as a trait object. If the trait comes from your own crate, consider removing\n-this restriction.\n-\n-### Method references the `Self` type in its parameters or return type\n-\n-This happens when a trait has a method like the following:\n-\n-```\n-trait Trait {\n-    fn foo(&self) -> Self;\n-}\n-\n-impl Trait for String {\n-    fn foo(&self) -> Self {\n-        \"hi\".to_owned()\n-    }\n-}\n-\n-impl Trait for u8 {\n-    fn foo(&self) -> Self {\n-        1\n-    }\n-}\n-```\n-\n-(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\n-cause this problem.)\n-\n-In such a case, the compiler cannot predict the return type of `foo()` in a\n-situation like the following:\n-\n-```compile_fail\n-trait Trait {\n-    fn foo(&self) -> Self;\n-}\n-\n-fn call_foo(x: Box<Trait>) {\n-    let y = x.foo(); // What type is y?\n-    // ...\n-}\n-```\n-\n-If only some methods aren't object-safe, you can add a `where Self: Sized` bound\n-on them to mark them as explicitly unavailable to trait objects. The\n-functionality will still be available to all other implementers, including\n-`Box<Trait>` which is itself sized (assuming you `impl Trait for Box<Trait>`).\n-\n-```\n-trait Trait {\n-    fn foo(&self) -> Self where Self: Sized;\n-    // more functions\n-}\n-```\n-\n-Now, `foo()` can no longer be called on a trait object, but you will now be\n-allowed to make a trait object, and that will be able to call any object-safe\n-methods. With such a bound, one can still call `foo()` on types implementing\n-that trait that aren't behind trait objects.\n-\n-### Method has generic type parameters\n-\n-As mentioned before, trait objects contain pointers to method tables. So, if we\n-have:\n-\n-```\n-trait Trait {\n-    fn foo(&self);\n-}\n-\n-impl Trait for String {\n-    fn foo(&self) {\n-        // implementation 1\n-    }\n-}\n-\n-impl Trait for u8 {\n-    fn foo(&self) {\n-        // implementation 2\n-    }\n-}\n-// ...\n-```\n-\n-At compile time each implementation of `Trait` will produce a table containing\n-the various methods (and other items) related to the implementation.\n-\n-This works fine, but when the method gains generic parameters, we can have a\n-problem.\n-\n-Usually, generic parameters get _monomorphized_. For example, if I have\n-\n-```\n-fn foo<T>(x: T) {\n-    // ...\n-}\n-```\n-\n-The machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\n-other type substitution is different. Hence the compiler generates the\n-implementation on-demand. If you call `foo()` with a `bool` parameter, the\n-compiler will only generate code for `foo::<bool>()`. When we have additional\n-type parameters, the number of monomorphized implementations the compiler\n-generates does not grow drastically, since the compiler will only generate an\n-implementation if the function is called with unparametrized substitutions\n-(i.e., substitutions where none of the substituted types are themselves\n-parametrized).\n-\n-However, with trait objects we have to make a table containing _every_ object\n-that implements the trait. Now, if it has type parameters, we need to add\n-implementations for every type that implements the trait, and there could\n-theoretically be an infinite number of types.\n-\n-For example, with:\n-\n-```\n-trait Trait {\n-    fn foo<T>(&self, on: T);\n-    // more methods\n-}\n-\n-impl Trait for String {\n-    fn foo<T>(&self, on: T) {\n-        // implementation 1\n-    }\n-}\n-\n-impl Trait for u8 {\n-    fn foo<T>(&self, on: T) {\n-        // implementation 2\n-    }\n-}\n-\n-// 8 more implementations\n-```\n-\n-Now, if we have the following code:\n-\n-```compile_fail,E0038\n-# trait Trait { fn foo<T>(&self, on: T); }\n-# impl Trait for String { fn foo<T>(&self, on: T) {} }\n-# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n-# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n-# // etc.\n-fn call_foo(thing: Box<Trait>) {\n-    thing.foo(true); // this could be any one of the 8 types above\n-    thing.foo(1);\n-    thing.foo(\"hello\");\n-}\n-```\n-\n-We don't just need to create a table of all implementations of all methods of\n-`Trait`, we need to create such a table, for each different type fed to\n-`foo()`. In this case this turns out to be (10 types implementing `Trait`)*(3\n-types being fed to `foo()`) = 30 implementations!\n-\n-With real world traits these numbers can grow drastically.\n-\n-To fix this, it is suggested to use a `where Self: Sized` bound similar to the\n-fix for the sub-error above if you do not intend to call the method with type\n-parameters:\n-\n-```\n-trait Trait {\n-    fn foo<T>(&self, on: T) where Self: Sized;\n-    // more methods\n-}\n-```\n-\n-If this is not an option, consider replacing the type parameter with another\n-trait object (e.g., if `T: OtherTrait`, use `on: Box<OtherTrait>`). If the\n-number of types you intend to feed to this method is limited, consider manually\n-listing out the methods of different types.\n-\n-### Method has no receiver\n-\n-Methods that do not take a `self` parameter can't be called since there won't be\n-a way to get a pointer to the method table for them.\n-\n-```\n-trait Foo {\n-    fn foo() -> u8;\n-}\n-```\n-\n-This could be called as `<Foo as Foo>::foo()`, which would not be able to pick\n-an implementation.\n-\n-Adding a `Self: Sized` bound to these methods will generally make this compile.\n-\n-```\n-trait Foo {\n-    fn foo() -> u8 where Self: Sized;\n-}\n-```\n-\n-### The trait cannot contain associated constants\n-\n-Just like static functions, associated constants aren't stored on the method\n-table. If the trait or any subtrait contain an associated constant, they cannot\n-be made into an object.\n-\n-```compile_fail,E0038\n-trait Foo {\n-    const X: i32;\n-}\n-\n-impl Foo {}\n-```\n-\n-A simple workaround is to use a helper method instead:\n-\n-```\n-trait Foo {\n-    fn x(&self) -> i32;\n-}\n-```\n-\n-### The trait cannot use `Self` as a type parameter in the supertrait listing\n-\n-This is similar to the second sub-error, but subtler. It happens in situations\n-like the following:\n-\n-```compile_fail,E0038\n-trait Super<A: ?Sized> {}\n-\n-trait Trait: Super<Self> {\n-}\n-\n-struct Foo;\n-\n-impl Super<Foo> for Foo{}\n-\n-impl Trait for Foo {}\n-\n-fn main() {\n-    let x: Box<dyn Trait>;\n-}\n-```\n-\n-Here, the supertrait might have methods as follows:\n-\n-```\n-trait Super<A: ?Sized> {\n-    fn get_a(&self) -> &A; // note that this is object safe!\n-}\n-```\n-\n-If the trait `Trait` was deriving from something like `Super<String>` or\n-`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n-`get_a()` will definitely return an object of that type.\n-\n-However, if it derives from `Super<Self>`, even though `Super` is object safe,\n-the method `get_a()` would return an object of unknown type when called on the\n-function. `Self` type parameters let us make object safe traits no longer safe,\n-so they are forbidden when specifying supertraits.\n-\n-There's no easy fix for this, generally code will need to be refactored so that\n-you no longer need to derive from `Super<Self>`.\n-\"##,\n-\n-E0072: r##\"\n-When defining a recursive struct or enum, any use of the type being defined\n-from inside the definition must occur behind a pointer (like `Box` or `&`).\n-This is because structs and enums must have a well-defined size, and without\n-the pointer, the size of the type would need to be unbounded.\n-\n-Consider the following erroneous definition of a type for a list of bytes:\n-\n-```compile_fail,E0072\n-// error, invalid recursive struct type\n-struct ListNode {\n-    head: u8,\n-    tail: Option<ListNode>,\n-}\n-```\n-\n-This type cannot have a well-defined size, because it needs to be arbitrarily\n-large (since we would be able to nest `ListNode`s to any depth). Specifically,\n-\n-```plain\n-size of `ListNode` = 1 byte for `head`\n-                   + 1 byte for the discriminant of the `Option`\n-                   + size of `ListNode`\n-```\n-\n-One way to fix this is by wrapping `ListNode` in a `Box`, like so:\n-\n-```\n-struct ListNode {\n-    head: u8,\n-    tail: Option<Box<ListNode>>,\n-}\n-```\n-\n-This works because `Box` is a pointer, so its size is well-known.\n-\"##,\n-\n-E0080: r##\"\n-This error indicates that the compiler was unable to sensibly evaluate a\n-constant expression that had to be evaluated. Attempting to divide by 0\n-or causing integer overflow are two ways to induce this error. For example:\n-\n-```compile_fail,E0080\n-enum Enum {\n-    X = (1 << 500),\n-    Y = (1 / 0)\n-}\n-```\n-\n-Ensure that the expressions given can be evaluated as the desired integer type.\n-See the FFI section of the Reference for more information about using a custom\n-integer type:\n-\n-https://doc.rust-lang.org/reference.html#ffi-attributes\n-\"##,\n-\n-E0106: r##\"\n-This error indicates that a lifetime is missing from a type. If it is an error\n-inside a function signature, the problem may be with failing to adhere to the\n-lifetime elision rules (see below).\n-\n-Here are some simple examples of where you'll run into this error:\n-\n-```compile_fail,E0106\n-struct Foo1 { x: &bool }\n-              // ^ expected lifetime parameter\n-struct Foo2<'a> { x: &'a bool } // correct\n-\n-struct Bar1 { x: Foo2 }\n-              // ^^^^ expected lifetime parameter\n-struct Bar2<'a> { x: Foo2<'a> } // correct\n-\n-enum Baz1 { A(u8), B(&bool), }\n-                  // ^ expected lifetime parameter\n-enum Baz2<'a> { A(u8), B(&'a bool), } // correct\n-\n-type MyStr1 = &str;\n-           // ^ expected lifetime parameter\n-type MyStr2<'a> = &'a str; // correct\n-```\n-\n-Lifetime elision is a special, limited kind of inference for lifetimes in\n-function signatures which allows you to leave out lifetimes in certain cases.\n-For more background on lifetime elision see [the book][book-le].\n-\n-The lifetime elision rules require that any function signature with an elided\n-output lifetime must either have\n-\n- - exactly one input lifetime\n- - or, multiple input lifetimes, but the function must also be a method with a\n-   `&self` or `&mut self` receiver\n-\n-In the first case, the output lifetime is inferred to be the same as the unique\n-input lifetime. In the second case, the lifetime is instead inferred to be the\n-same as the lifetime on `&self` or `&mut self`.\n-\n-Here are some examples of elision errors:\n-\n-```compile_fail,E0106\n-// error, no input lifetimes\n-fn foo() -> &str { }\n-\n-// error, `x` and `y` have distinct lifetimes inferred\n-fn bar(x: &str, y: &str) -> &str { }\n-\n-// error, `y`'s lifetime is inferred to be distinct from `x`'s\n-fn baz<'a>(x: &'a str, y: &str) -> &str { }\n-```\n-\n-[book-le]: https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision\n-\"##,\n-\n-E0119: r##\"\n-There are conflicting trait implementations for the same type.\n-Example of erroneous code:\n-\n-```compile_fail,E0119\n-trait MyTrait {\n-    fn get(&self) -> usize;\n-}\n-\n-impl<T> MyTrait for T {\n-    fn get(&self) -> usize { 0 }\n-}\n-\n-struct Foo {\n-    value: usize\n-}\n-\n-impl MyTrait for Foo { // error: conflicting implementations of trait\n-                       //        `MyTrait` for type `Foo`\n-    fn get(&self) -> usize { self.value }\n-}\n-```\n-\n-When looking for the implementation for the trait, the compiler finds\n-both the `impl<T> MyTrait for T` where T is all types and the `impl\n-MyTrait for Foo`. Since a trait cannot be implemented multiple times,\n-this is an error. So, when you write:\n-\n-```\n-trait MyTrait {\n-    fn get(&self) -> usize;\n-}\n-\n-impl<T> MyTrait for T {\n-    fn get(&self) -> usize { 0 }\n-}\n-```\n-\n-This makes the trait implemented on all types in the scope. So if you\n-try to implement it on another one after that, the implementations will\n-conflict. Example:\n-\n-```\n-trait MyTrait {\n-    fn get(&self) -> usize;\n-}\n-\n-impl<T> MyTrait for T {\n-    fn get(&self) -> usize { 0 }\n-}\n-\n-struct Foo;\n-\n-fn main() {\n-    let f = Foo;\n-\n-    f.get(); // the trait is implemented so we can use it\n-}\n-```\n-\"##,\n-\n-E0139: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-There are various restrictions on transmuting between types in Rust; for example\n-types being transmuted must have the same size. To apply all these restrictions,\n-the compiler must know the exact types that may be transmuted. When type\n-parameters are involved, this cannot always be done.\n-\n-So, for example, the following is not allowed:\n-\n-```\n-use std::mem::transmute;\n-\n-struct Foo<T>(Vec<T>);\n-\n-fn foo<T>(x: Vec<T>) {\n-    // we are transmuting between Vec<T> and Foo<F> here\n-    let y: Foo<T> = unsafe { transmute(x) };\n-    // do something with y\n-}\n-```\n-\n-In this specific case there's a good chance that the transmute is harmless (but\n-this is not guaranteed by Rust). However, when alignment and enum optimizations\n-come into the picture, it's quite likely that the sizes may or may not match\n-with different type parameter substitutions. It's not possible to check this for\n-_all_ possible types, so `transmute()` simply only accepts types without any\n-unsubstituted type parameters.\n-\n-If you need this, there's a good chance you're doing something wrong. Keep in\n-mind that Rust doesn't guarantee much about the layout of different structs\n-(even two structs with identical declarations may have different layouts). If\n-there is a solution that avoids the transmute entirely, try it instead.\n-\n-If it's possible, hand-monomorphize the code by writing the function for each\n-possible type substitution. It's possible to use traits to do this cleanly,\n-for example:\n-\n-```\n-use std::mem::transmute;\n-\n-struct Foo<T>(Vec<T>);\n-\n-trait MyTransmutableType: Sized {\n-    fn transmute(_: Vec<Self>) -> Foo<Self>;\n-}\n-\n-impl MyTransmutableType for u8 {\n-    fn transmute(x: Vec<u8>) -> Foo<u8> {\n-        unsafe { transmute(x) }\n-    }\n-}\n-\n-impl MyTransmutableType for String {\n-    fn transmute(x: Vec<String>) -> Foo<String> {\n-        unsafe { transmute(x) }\n-    }\n-}\n-\n-// ... more impls for the types you intend to transmute\n-\n-fn foo<T: MyTransmutableType>(x: Vec<T>) {\n-    let y: Foo<T> = <T as MyTransmutableType>::transmute(x);\n-    // do something with y\n-}\n-```\n-\n-Each impl will be checked for a size match in the transmute as usual, and since\n-there are no unbound type parameters involved, this should compile unless there\n-is a size mismatch in one of the impls.\n-\n-It is also possible to manually transmute:\n-\n-```\n-# use std::ptr;\n-# let v = Some(\"value\");\n-# type SomeType = &'static [u8];\n-unsafe {\n-    ptr::read(&v as *const _ as *const SomeType) // `v` transmuted to `SomeType`\n-}\n-# ;\n-```\n-\n-Note that this does not move `v` (unlike `transmute`), and may need a\n-call to `mem::forget(v)` in case you want to avoid destructors being called.\n-\"##,\n-\n-E0152: r##\"\n-A lang item was redefined.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0152\n-#![feature(lang_items)]\n-\n-#[lang = \"arc\"]\n-struct Foo; // error: duplicate lang item found: `arc`\n-```\n-\n-Lang items are already implemented in the standard library. Unless you are\n-writing a free-standing application (e.g., a kernel), you do not need to provide\n-them yourself.\n-\n-You can build a free-standing crate by adding `#![no_std]` to the crate\n-attributes:\n-\n-```ignore (only-for-syntax-highlight)\n-#![no_std]\n-```\n-\n-See also the [unstable book][1].\n-\n-[1]: https://doc.rust-lang.org/unstable-book/language-features/lang-items.html#writing-an-executable-without-stdlib\n-\"##,\n-\n-E0214: r##\"\n-A generic type was described using parentheses rather than angle brackets.\n-For example:\n-\n-```compile_fail,E0214\n-fn main() {\n-    let v: Vec(&str) = vec![\"foo\"];\n-}\n-```\n-\n-This is not currently supported: `v` should be defined as `Vec<&str>`.\n-Parentheses are currently only used with generic types when defining parameters\n-for `Fn`-family traits.\n-\"##,\n-\n-E0230: r##\"\n-The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n-message for when a particular trait isn't implemented on a type placed in a\n-position that needs that trait. For example, when the following code is\n-compiled:\n-\n-```compile_fail\n-#![feature(rustc_attrs)]\n-\n-fn foo<T: Index<u8>>(x: T){}\n-\n-#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n-trait Index<Idx> { /* ... */ }\n-\n-foo(true); // `bool` does not implement `Index<u8>`\n-```\n-\n-There will be an error about `bool` not implementing `Index<u8>`, followed by a\n-note saying \"the type `bool` cannot be indexed by `u8`\".\n-\n-As you can see, you can specify type parameters in curly braces for\n-substitution with the actual types (using the regular format string syntax) in\n-a given situation. Furthermore, `{Self}` will substitute to the type (in this\n-case, `bool`) that we tried to use.\n-\n-This error appears when the curly braces contain an identifier which doesn't\n-match with any of the type parameters or the string `Self`. This might happen\n-if you misspelled a type parameter, or if you intended to use literal curly\n-braces. If it is the latter, escape the curly braces with a second curly brace\n-of the same type; e.g., a literal `{` is `{{`.\n-\"##,\n-\n-E0231: r##\"\n-The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n-message for when a particular trait isn't implemented on a type placed in a\n-position that needs that trait. For example, when the following code is\n-compiled:\n-\n-```compile_fail\n-#![feature(rustc_attrs)]\n-\n-fn foo<T: Index<u8>>(x: T){}\n-\n-#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n-trait Index<Idx> { /* ... */ }\n-\n-foo(true); // `bool` does not implement `Index<u8>`\n-```\n-\n-there will be an error about `bool` not implementing `Index<u8>`, followed by a\n-note saying \"the type `bool` cannot be indexed by `u8`\".\n-\n-As you can see, you can specify type parameters in curly braces for\n-substitution with the actual types (using the regular format string syntax) in\n-a given situation. Furthermore, `{Self}` will substitute to the type (in this\n-case, `bool`) that we tried to use.\n-\n-This error appears when the curly braces do not contain an identifier. Please\n-add one of the same name as a type parameter. If you intended to use literal\n-braces, use `{{` and `}}` to escape them.\n-\"##,\n-\n-E0232: r##\"\n-The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n-message for when a particular trait isn't implemented on a type placed in a\n-position that needs that trait. For example, when the following code is\n-compiled:\n-\n-```compile_fail\n-#![feature(rustc_attrs)]\n-\n-fn foo<T: Index<u8>>(x: T){}\n-\n-#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n-trait Index<Idx> { /* ... */ }\n-\n-foo(true); // `bool` does not implement `Index<u8>`\n-```\n-\n-there will be an error about `bool` not implementing `Index<u8>`, followed by a\n-note saying \"the type `bool` cannot be indexed by `u8`\".\n-\n-For this to work, some note must be specified. An empty attribute will not do\n-anything, please remove the attribute or add some helpful note for users of the\n-trait.\n-\"##,\n-\n-E0261: r##\"\n-When using a lifetime like `'a` in a type, it must be declared before being\n-used.\n-\n-These two examples illustrate the problem:\n-\n-```compile_fail,E0261\n-// error, use of undeclared lifetime name `'a`\n-fn foo(x: &'a str) { }\n-\n-struct Foo {\n-    // error, use of undeclared lifetime name `'a`\n-    x: &'a str,\n-}\n-```\n-\n-These can be fixed by declaring lifetime parameters:\n-\n-```\n-struct Foo<'a> {\n-    x: &'a str,\n-}\n-\n-fn foo<'a>(x: &'a str) {}\n-```\n-\n-Impl blocks declare lifetime parameters separately. You need to add lifetime\n-parameters to an impl block if you're implementing a type that has a lifetime\n-parameter of its own.\n-For example:\n-\n-```compile_fail,E0261\n-struct Foo<'a> {\n-    x: &'a str,\n-}\n-\n-// error,  use of undeclared lifetime name `'a`\n-impl Foo<'a> {\n-    fn foo<'a>(x: &'a str) {}\n-}\n-```\n-\n-This is fixed by declaring the impl block like this:\n-\n-```\n-struct Foo<'a> {\n-    x: &'a str,\n-}\n-\n-// correct\n-impl<'a> Foo<'a> {\n-    fn foo(x: &'a str) {}\n-}\n-```\n-\"##,\n-\n-E0262: r##\"\n-Declaring certain lifetime names in parameters is disallowed. For example,\n-because the `'static` lifetime is a special built-in lifetime name denoting\n-the lifetime of the entire program, this is an error:\n-\n-```compile_fail,E0262\n-// error, invalid lifetime parameter name `'static`\n-fn foo<'static>(x: &'static str) { }\n-```\n-\"##,\n-\n-E0263: r##\"\n-A lifetime name cannot be declared more than once in the same scope. For\n-example:\n-\n-```compile_fail,E0263\n-// error, lifetime name `'a` declared twice in the same scope\n-fn foo<'a, 'b, 'a>(x: &'a str, y: &'b str) { }\n-```\n-\"##,\n-\n-E0264: r##\"\n-An unknown external lang item was used. Erroneous code example:\n-\n-```compile_fail,E0264\n-#![feature(lang_items)]\n-\n-extern \"C\" {\n-    #[lang = \"cake\"] // error: unknown external lang item: `cake`\n-    fn cake();\n-}\n-```\n-\n-A list of available external lang items is available in\n-`src/librustc/middle/weak_lang_items.rs`. Example:\n-\n-```\n-#![feature(lang_items)]\n-\n-extern \"C\" {\n-    #[lang = \"panic_impl\"] // ok!\n-    fn cake();\n-}\n-```\n-\"##,\n-\n-E0271: r##\"\n-This is because of a type mismatch between the associated type of some\n-trait (e.g., `T::Bar`, where `T` implements `trait Quux { type Bar; }`)\n-and another type `U` that is required to be equal to `T::Bar`, but is not.\n-Examples follow.\n-\n-Here is a basic example:\n-\n-```compile_fail,E0271\n-trait Trait { type AssociatedType; }\n-\n-fn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n-    println!(\"in foo\");\n-}\n-\n-impl Trait for i8 { type AssociatedType = &'static str; }\n-\n-foo(3_i8);\n-```\n-\n-Here is that same example again, with some explanatory comments:\n-\n-```compile_fail,E0271\n-trait Trait { type AssociatedType; }\n-\n-fn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n-//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n-//                        |            |\n-//         This says `foo` can         |\n-//           only be used with         |\n-//              some type that         |\n-//         implements `Trait`.         |\n-//                                     |\n-//                             This says not only must\n-//                             `T` be an impl of `Trait`\n-//                             but also that the impl\n-//                             must assign the type `u32`\n-//                             to the associated type.\n-    println!(\"in foo\");\n-}\n-\n-impl Trait for i8 { type AssociatedType = &'static str; }\n-//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-//      |                             |\n-// `i8` does have                     |\n-// implementation                     |\n-// of `Trait`...                      |\n-//                     ... but it is an implementation\n-//                     that assigns `&'static str` to\n-//                     the associated type.\n-\n-foo(3_i8);\n-// Here, we invoke `foo` with an `i8`, which does not satisfy\n-// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n-// therefore the type-checker complains with this error code.\n-```\n-\n-To avoid those issues, you have to make the types match correctly.\n-So we can fix the previous examples like this:\n-\n-```\n-// Basic Example:\n-trait Trait { type AssociatedType; }\n-\n-fn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n-    println!(\"in foo\");\n-}\n-\n-impl Trait for i8 { type AssociatedType = &'static str; }\n-\n-foo(3_i8);\n-\n-// For-Loop Example:\n-let vs = vec![1, 2, 3, 4];\n-for v in &vs {\n-    match v {\n-        &1 => {}\n-        _ => {}\n-    }\n-}\n-```\n-\"##,\n-\n-\n-E0275: r##\"\n-This error occurs when there was a recursive trait requirement that overflowed\n-before it could be evaluated. Often this means that there is unbounded\n-recursion in resolving some type bounds.\n-\n-For example, in the following code:\n-\n-```compile_fail,E0275\n-trait Foo {}\n-\n-struct Bar<T>(T);\n-\n-impl<T> Foo for T where Bar<T>: Foo {}\n-```\n-\n-To determine if a `T` is `Foo`, we need to check if `Bar<T>` is `Foo`. However,\n-to do this check, we need to determine that `Bar<Bar<T>>` is `Foo`. To\n-determine this, we check if `Bar<Bar<Bar<T>>>` is `Foo`, and so on. This is\n-clearly a recursive requirement that can't be resolved directly.\n-\n-Consider changing your trait bounds so that they're less self-referential.\n-\"##,\n-\n-E0276: r##\"\n-This error occurs when a bound in an implementation of a trait does not match\n-the bounds specified in the original trait. For example:\n-\n-```compile_fail,E0276\n-trait Foo {\n-    fn foo<T>(x: T);\n-}\n-\n-impl Foo for bool {\n-    fn foo<T>(x: T) where T: Copy {}\n-}\n-```\n-\n-Here, all types implementing `Foo` must have a method `foo<T>(x: T)` which can\n-take any type `T`. However, in the `impl` for `bool`, we have added an extra\n-bound that `T` is `Copy`, which isn't compatible with the original trait.\n-\n-Consider removing the bound from the method or adding the bound to the original\n-method definition in the trait.\n-\"##,\n-\n-E0277: r##\"\n-You tried to use a type which doesn't implement some trait in a place which\n-expected that trait. Erroneous code example:\n-\n-```compile_fail,E0277\n-// here we declare the Foo trait with a bar method\n-trait Foo {\n-    fn bar(&self);\n-}\n-\n-// we now declare a function which takes an object implementing the Foo trait\n-fn some_func<T: Foo>(foo: T) {\n-    foo.bar();\n-}\n-\n-fn main() {\n-    // we now call the method with the i32 type, which doesn't implement\n-    // the Foo trait\n-    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n-}\n-```\n-\n-In order to fix this error, verify that the type you're using does implement\n-the trait. Example:\n-\n-```\n-trait Foo {\n-    fn bar(&self);\n-}\n-\n-fn some_func<T: Foo>(foo: T) {\n-    foo.bar(); // we can now use this method since i32 implements the\n-               // Foo trait\n-}\n-\n-// we implement the trait on the i32 type\n-impl Foo for i32 {\n-    fn bar(&self) {}\n-}\n-\n-fn main() {\n-    some_func(5i32); // ok!\n-}\n-```\n-\n-Or in a generic context, an erroneous code example would look like:\n-\n-```compile_fail,E0277\n-fn some_func<T>(foo: T) {\n-    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n-                           //        implemented for the type `T`\n-}\n-\n-fn main() {\n-    // We now call the method with the i32 type,\n-    // which *does* implement the Debug trait.\n-    some_func(5i32);\n-}\n-```\n-\n-Note that the error here is in the definition of the generic function: Although\n-we only call it with a parameter that does implement `Debug`, the compiler\n-still rejects the function: It must work with all possible input types. In\n-order to make this example compile, we need to restrict the generic type we're\n-accepting:\n-\n-```\n-use std::fmt;\n-\n-// Restrict the input type to types that implement Debug.\n-fn some_func<T: fmt::Debug>(foo: T) {\n-    println!(\"{:?}\", foo);\n-}\n-\n-fn main() {\n-    // Calling the method is still fine, as i32 implements Debug.\n-    some_func(5i32);\n-\n-    // This would fail to compile now:\n-    // struct WithoutDebug;\n-    // some_func(WithoutDebug);\n-}\n-```\n-\n-Rust only looks at the signature of the called function, as such it must\n-already specify all requirements that will be used for every type parameter.\n-\"##,\n-\n-E0281: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-You tried to supply a type which doesn't implement some trait in a location\n-which expected that trait. This error typically occurs when working with\n-`Fn`-based types. Erroneous code example:\n-\n-```compile-fail\n-fn foo<F: Fn(usize)>(x: F) { }\n-\n-fn main() {\n-    // type mismatch: ... implements the trait `core::ops::Fn<(String,)>`,\n-    // but the trait `core::ops::Fn<(usize,)>` is required\n-    // [E0281]\n-    foo(|y: String| { });\n-}\n-```\n-\n-The issue in this case is that `foo` is defined as accepting a `Fn` with one\n-argument of type `String`, but the closure we attempted to pass to it requires\n-one arguments of type `usize`.\n-\"##,\n-\n-E0282: r##\"\n-This error indicates that type inference did not result in one unique possible\n-type, and extra information is required. In most cases this can be provided\n-by adding a type annotation. Sometimes you need to specify a generic type\n-parameter manually.\n-\n-A common example is the `collect` method on `Iterator`. It has a generic type\n-parameter with a `FromIterator` bound, which for a `char` iterator is\n-implemented by `Vec` and `String` among others. Consider the following snippet\n-that reverses the characters of a string:\n-\n-```compile_fail,E0282\n-let x = \"hello\".chars().rev().collect();\n-```\n-\n-In this case, the compiler cannot infer what the type of `x` should be:\n-`Vec<char>` and `String` are both suitable candidates. To specify which type to\n-use, you can use a type annotation on `x`:\n-\n-```\n-let x: Vec<char> = \"hello\".chars().rev().collect();\n-```\n-\n-It is not necessary to annotate the full type. Once the ambiguity is resolved,\n-the compiler can infer the rest:\n-\n-```\n-let x: Vec<_> = \"hello\".chars().rev().collect();\n-```\n-\n-Another way to provide the compiler with enough information, is to specify the\n-generic type parameter:\n-\n-```\n-let x = \"hello\".chars().rev().collect::<Vec<char>>();\n-```\n-\n-Again, you need not specify the full type if the compiler can infer it:\n-\n-```\n-let x = \"hello\".chars().rev().collect::<Vec<_>>();\n-```\n-\n-Apart from a method or function with a generic type parameter, this error can\n-occur when a type parameter of a struct or trait cannot be inferred. In that\n-case it is not always possible to use a type annotation, because all candidates\n-have the same return type. For instance:\n-\n-```compile_fail,E0282\n-struct Foo<T> {\n-    num: T,\n-}\n-\n-impl<T> Foo<T> {\n-    fn bar() -> i32 {\n-        0\n-    }\n-\n-    fn baz() {\n-        let number = Foo::bar();\n-    }\n-}\n-```\n-\n-This will fail because the compiler does not know which instance of `Foo` to\n-call `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n-\"##,\n-\n-E0283: r##\"\n-This error occurs when the compiler doesn't have enough information\n-to unambiguously choose an implementation.\n-\n-For example:\n-\n-```compile_fail,E0283\n-trait Generator {\n-    fn create() -> u32;\n-}\n-\n-struct Impl;\n-\n-impl Generator for Impl {\n-    fn create() -> u32 { 1 }\n-}\n-\n-struct AnotherImpl;\n-\n-impl Generator for AnotherImpl {\n-    fn create() -> u32 { 2 }\n-}\n-\n-fn main() {\n-    let cont: u32 = Generator::create();\n-    // error, impossible to choose one of Generator trait implementation\n-    // Should it be Impl or AnotherImpl, maybe something else?\n-}\n-```\n-\n-To resolve this error use the concrete type:\n-\n-```\n-trait Generator {\n-    fn create() -> u32;\n-}\n-\n-struct AnotherImpl;\n-\n-impl Generator for AnotherImpl {\n-    fn create() -> u32 { 2 }\n-}\n-\n-fn main() {\n-    let gen1 = AnotherImpl::create();\n-\n-    // if there are multiple methods with same name (different traits)\n-    let gen2 = <AnotherImpl as Generator>::create();\n-}\n-```\n-\"##,\n-\n-E0284: r##\"\n-This error occurs when the compiler is unable to unambiguously infer the\n-return type of a function or method which is generic on return type, such\n-as the `collect` method for `Iterator`s.\n-\n-For example:\n-\n-```compile_fail,E0284\n-fn foo() -> Result<bool, ()> {\n-    let results = [Ok(true), Ok(false), Err(())].iter().cloned();\n-    let v: Vec<bool> = results.collect()?;\n-    // Do things with v...\n-    Ok(true)\n-}\n-```\n-\n-Here we have an iterator `results` over `Result<bool, ()>`.\n-Hence, `results.collect()` can return any type implementing\n-`FromIterator<Result<bool, ()>>`. On the other hand, the\n-`?` operator can accept any type implementing `Try`.\n-\n-The author of this code probably wants `collect()` to return a\n-`Result<Vec<bool>, ()>`, but the compiler can't be sure\n-that there isn't another type `T` implementing both `Try` and\n-`FromIterator<Result<bool, ()>>` in scope such that\n-`T::Ok == Vec<bool>`. Hence, this code is ambiguous and an error\n-is returned.\n-\n-To resolve this error, use a concrete type for the intermediate expression:\n-\n-```\n-fn foo() -> Result<bool, ()> {\n-    let results = [Ok(true), Ok(false), Err(())].iter().cloned();\n-    let v = {\n-        let temp: Result<Vec<bool>, ()> = results.collect();\n-        temp?\n-    };\n-    // Do things with v...\n-    Ok(true)\n-}\n-```\n-\n-Note that the type of `v` can now be inferred from the type of `temp`.\n-\"##,\n-\n-E0308: r##\"\n-This error occurs when the compiler was unable to infer the concrete type of a\n-variable. It can occur for several cases, the most common of which is a\n-mismatch in the expected type that the compiler inferred for a variable's\n-initializing expression, and the actual type explicitly assigned to the\n-variable.\n-\n-For example:\n-\n-```compile_fail,E0308\n-let x: i32 = \"I am not a number!\";\n-//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n-//      |             |\n-//      |    initializing expression;\n-//      |    compiler infers type `&str`\n-//      |\n-//    type `i32` assigned to variable `x`\n-```\n-\"##,\n-\n-E0309: r##\"\n-The type definition contains some field whose type\n-requires an outlives annotation. Outlives annotations\n-(e.g., `T: 'a`) are used to guarantee that all the data in T is valid\n-for at least the lifetime `'a`. This scenario most commonly\n-arises when the type contains an associated type reference\n-like `<T as SomeTrait<'a>>::Output`, as shown in this example:\n-\n-```compile_fail,E0309\n-// This won't compile because the applicable impl of\n-// `SomeTrait` (below) requires that `T: 'a`, but the struct does\n-// not have a matching where-clause.\n-struct Foo<'a, T> {\n-    foo: <T as SomeTrait<'a>>::Output,\n-}\n-\n-trait SomeTrait<'a> {\n-    type Output;\n-}\n-\n-impl<'a, T> SomeTrait<'a> for T\n-where\n-    T: 'a,\n-{\n-    type Output = u32;\n-}\n-```\n-\n-Here, the where clause `T: 'a` that appears on the impl is not known to be\n-satisfied on the struct. To make this example compile, you have to add\n-a where-clause like `T: 'a` to the struct definition:\n-\n-```\n-struct Foo<'a, T>\n-where\n-    T: 'a,\n-{\n-    foo: <T as SomeTrait<'a>>::Output\n-}\n-\n-trait SomeTrait<'a> {\n-    type Output;\n-}\n-\n-impl<'a, T> SomeTrait<'a> for T\n-where\n-    T: 'a,\n-{\n-    type Output = u32;\n-}\n-```\n-\"##,\n-\n-E0310: r##\"\n-Types in type definitions have lifetimes associated with them that represent\n-how long the data stored within them is guaranteed to be live. This lifetime\n-must be as long as the data needs to be alive, and missing the constraint that\n-denotes this will cause this error.\n-\n-```compile_fail,E0310\n-// This won't compile because T is not constrained to the static lifetime\n-// the reference needs\n-struct Foo<T> {\n-    foo: &'static T\n-}\n-```\n-\n-This will compile, because it has the constraint on the type parameter:\n-\n-```\n-struct Foo<T: 'static> {\n-    foo: &'static T\n-}\n-```\n-\"##,\n-\n-E0312: r##\"\n-Reference's lifetime of borrowed content doesn't match the expected lifetime.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0312\n-pub fn opt_str<'a>(maybestr: &'a Option<String>) -> &'static str {\n-    if maybestr.is_none() {\n-        \"(none)\"\n-    } else {\n-        let s: &'a str = maybestr.as_ref().unwrap();\n-        s  // Invalid lifetime!\n-    }\n-}\n-```\n-\n-To fix this error, either lessen the expected lifetime or find a way to not have\n-to use this reference outside of its current scope (by running the code directly\n-in the same block for example?):\n-\n-```\n-// In this case, we can fix the issue by switching from \"static\" lifetime to 'a\n-pub fn opt_str<'a>(maybestr: &'a Option<String>) -> &'a str {\n-    if maybestr.is_none() {\n-        \"(none)\"\n-    } else {\n-        let s: &'a str = maybestr.as_ref().unwrap();\n-        s  // Ok!\n-    }\n-}\n-```\n-\"##,\n-\n-E0317: r##\"\n-This error occurs when an `if` expression without an `else` block is used in a\n-context where a type other than `()` is expected, for example a `let`\n-expression:\n-\n-```compile_fail,E0317\n-fn main() {\n-    let x = 5;\n-    let a = if x == 5 { 1 };\n-}\n-```\n-\n-An `if` expression without an `else` block has the type `()`, so this is a type\n-error. To resolve it, add an `else` block having the same type as the `if`\n-block.\n-\"##,\n-\n-E0391: r##\"\n-This error indicates that some types or traits depend on each other\n-and therefore cannot be constructed.\n-\n-The following example contains a circular dependency between two traits:\n-\n-```compile_fail,E0391\n-trait FirstTrait : SecondTrait {\n-\n-}\n-\n-trait SecondTrait : FirstTrait {\n-\n-}\n-```\n-\"##,\n-\n-E0398: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-In Rust 1.3, the default object lifetime bounds are expected to change, as\n-described in [RFC 1156]. You are getting a warning because the compiler\n-thinks it is possible that this change will cause a compilation error in your\n-code. It is possible, though unlikely, that this is a false alarm.\n-\n-The heart of the change is that where `&'a Box<SomeTrait>` used to default to\n-`&'a Box<SomeTrait+'a>`, it now defaults to `&'a Box<SomeTrait+'static>` (here,\n-`SomeTrait` is the name of some trait type). Note that the only types which are\n-affected are references to boxes, like `&Box<SomeTrait>` or\n-`&[Box<SomeTrait>]`. More common types like `&SomeTrait` or `Box<SomeTrait>`\n-are unaffected.\n-\n-To silence this warning, edit your code to use an explicit bound. Most of the\n-time, this means that you will want to change the signature of a function that\n-you are calling. For example, if the error is reported on a call like `foo(x)`,\n-and `foo` is defined as follows:\n-\n-```\n-# trait SomeTrait {}\n-fn foo(arg: &Box<SomeTrait>) { /* ... */ }\n-```\n-\n-You might change it to:\n-\n-```\n-# trait SomeTrait {}\n-fn foo<'a>(arg: &'a Box<SomeTrait+'a>) { /* ... */ }\n-```\n-\n-This explicitly states that you expect the trait object `SomeTrait` to contain\n-references (with a maximum lifetime of `'a`).\n-\n-[RFC 1156]: https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md\n-\"##,\n-\n-E0452: r##\"\n-An invalid lint attribute has been given. Erroneous code example:\n-\n-```compile_fail,E0452\n-#![allow(foo = \"\")] // error: malformed lint attribute\n-```\n-\n-Lint attributes only accept a list of identifiers (where each identifier is a\n-lint name). Ensure the attribute is of this form:\n-\n-```\n-#![allow(foo)] // ok!\n-// or:\n-#![allow(foo, foo2)] // ok!\n-```\n-\"##,\n-\n-E0453: r##\"\n-A lint check attribute was overruled by a `forbid` directive set as an\n-attribute on an enclosing scope, or on the command line with the `-F` option.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0453\n-#![forbid(non_snake_case)]\n-\n-#[allow(non_snake_case)]\n-fn main() {\n-    let MyNumber = 2; // error: allow(non_snake_case) overruled by outer\n-                      //        forbid(non_snake_case)\n-}\n-```\n-\n-The `forbid` lint setting, like `deny`, turns the corresponding compiler\n-warning into a hard error. Unlike `deny`, `forbid` prevents itself from being\n-overridden by inner attributes.\n-\n-If you're sure you want to override the lint check, you can change `forbid` to\n-`deny` (or use `-D` instead of `-F` if the `forbid` setting was given as a\n-command-line option) to allow the inner lint check attribute:\n-\n-```\n-#![deny(non_snake_case)]\n-\n-#[allow(non_snake_case)]\n-fn main() {\n-    let MyNumber = 2; // ok!\n-}\n-```\n-\n-Otherwise, edit the code to pass the lint check, and remove the overruled\n-attribute:\n-\n-```\n-#![forbid(non_snake_case)]\n-\n-fn main() {\n-    let my_number = 2;\n-}\n-```\n-\"##,\n-\n-E0478: r##\"\n-A lifetime bound was not satisfied.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0478\n-// Check that the explicit lifetime bound (`'SnowWhite`, in this example) must\n-// outlive all the superbounds from the trait (`'kiss`, in this example).\n-\n-trait Wedding<'t>: 't { }\n-\n-struct Prince<'kiss, 'SnowWhite> {\n-    child: Box<Wedding<'kiss> + 'SnowWhite>,\n-    // error: lifetime bound not satisfied\n-}\n-```\n-\n-In this example, the `'SnowWhite` lifetime is supposed to outlive the `'kiss`\n-lifetime but the declaration of the `Prince` struct doesn't enforce it. To fix\n-this issue, you need to specify it:\n-\n-```\n-trait Wedding<'t>: 't { }\n-\n-struct Prince<'kiss, 'SnowWhite: 'kiss> { // You say here that 'kiss must live\n-                                          // longer than 'SnowWhite.\n-    child: Box<Wedding<'kiss> + 'SnowWhite>, // And now it's all good!\n-}\n-```\n-\"##,\n-\n-E0491: r##\"\n-A reference has a longer lifetime than the data it references.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0491\n-trait SomeTrait<'a> {\n-    type Output;\n-}\n-\n-impl<'a, T> SomeTrait<'a> for T {\n-    type Output = &'a T; // compile error E0491\n-}\n-```\n-\n-Here, the problem is that a reference type like `&'a T` is only valid\n-if all the data in T outlives the lifetime `'a`. But this impl as written\n-is applicable to any lifetime `'a` and any type `T` -- we have no guarantee\n-that `T` outlives `'a`. To fix this, you can add a where clause like\n-`where T: 'a`.\n-\n-```\n-trait SomeTrait<'a> {\n-    type Output;\n-}\n-\n-impl<'a, T> SomeTrait<'a> for T\n-where\n-    T: 'a,\n-{\n-    type Output = &'a T; // compile error E0491\n-}\n-```\n-\"##,\n-\n-E0495: r##\"\n-A lifetime cannot be determined in the given situation.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0495\n-fn transmute_lifetime<'a, 'b, T>(t: &'a (T,)) -> &'b T {\n-    match (&t,) { // error!\n-        ((u,),) => u,\n-    }\n-}\n-\n-let y = Box::new((42,));\n-let x = transmute_lifetime(&y);\n-```\n-\n-In this code, you have two ways to solve this issue:\n- 1. Enforce that `'a` lives at least as long as `'b`.\n- 2. Use the same lifetime requirement for both input and output values.\n-\n-So for the first solution, you can do it by replacing `'a` with `'a: 'b`:\n-\n-```\n-fn transmute_lifetime<'a: 'b, 'b, T>(t: &'a (T,)) -> &'b T {\n-    match (&t,) { // ok!\n-        ((u,),) => u,\n-    }\n-}\n-```\n-\n-In the second you can do it by simply removing `'b` so they both use `'a`:\n-\n-```\n-fn transmute_lifetime<'a, T>(t: &'a (T,)) -> &'a T {\n-    match (&t,) { // ok!\n-        ((u,),) => u,\n-    }\n-}\n-```\n-\"##,\n-\n-E0496: r##\"\n-A lifetime name is shadowing another lifetime name.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0496\n-struct Foo<'a> {\n-    a: &'a i32,\n-}\n-\n-impl<'a> Foo<'a> {\n-    fn f<'a>(x: &'a i32) { // error: lifetime name `'a` shadows a lifetime\n-                           //        name that is already in scope\n-    }\n-}\n-```\n-\n-Please change the name of one of the lifetimes to remove this error. Example:\n-\n-```\n-struct Foo<'a> {\n-    a: &'a i32,\n-}\n-\n-impl<'a> Foo<'a> {\n-    fn f<'b>(x: &'b i32) { // ok!\n-    }\n-}\n-\n-fn main() {\n-}\n-```\n-\"##,\n-\n-E0497: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-A stability attribute was used outside of the standard library.\n-\n-Erroneous code example:\n-\n-```compile_fail\n-#[stable] // error: stability attributes may not be used outside of the\n-          //        standard library\n-fn foo() {}\n-```\n-\n-It is not possible to use stability attributes outside of the standard library.\n-Also, for now, it is not possible to write deprecation messages either.\n-\"##,\n-\n-E0517: r##\"\n-This error indicates that a `#[repr(..)]` attribute was placed on an\n-unsupported item.\n-\n-Examples of erroneous code:\n-\n-```compile_fail,E0517\n-#[repr(C)]\n-type Foo = u8;\n-\n-#[repr(packed)]\n-enum Foo {Bar, Baz}\n-\n-#[repr(u8)]\n-struct Foo {bar: bool, baz: bool}\n-\n-#[repr(C)]\n-impl Foo {\n-    // ...\n-}\n-```\n-\n-* The `#[repr(C)]` attribute can only be placed on structs and enums.\n-* The `#[repr(packed)]` and `#[repr(simd)]` attributes only work on structs.\n-* The `#[repr(u8)]`, `#[repr(i16)]`, etc attributes only work on enums.\n-\n-These attributes do not work on typedefs, since typedefs are just aliases.\n-\n-Representations like `#[repr(u8)]`, `#[repr(i64)]` are for selecting the\n-discriminant size for enums with no data fields on any of the variants, e.g.\n-`enum Color {Red, Blue, Green}`, effectively setting the size of the enum to\n-the size of the provided type. Such an enum can be cast to a value of the same\n-type as well. In short, `#[repr(u8)]` makes the enum behave like an integer\n-with a constrained set of allowed values.\n-\n-Only field-less enums can be cast to numerical primitives, so this attribute\n-will not apply to structs.\n-\n-`#[repr(packed)]` reduces padding to make the struct size smaller. The\n-representation of enums isn't strictly defined in Rust, and this attribute\n-won't work on enums.\n-\n-`#[repr(simd)]` will give a struct consisting of a homogeneous series of machine\n-types (i.e., `u8`, `i32`, etc) a representation that permits vectorization via\n-SIMD. This doesn't make much sense for enums since they don't consist of a\n-single list of data.\n-\"##,\n-\n-E0518: r##\"\n-This error indicates that an `#[inline(..)]` attribute was incorrectly placed\n-on something other than a function or method.\n-\n-Examples of erroneous code:\n-\n-```compile_fail,E0518\n-#[inline(always)]\n-struct Foo;\n-\n-#[inline(never)]\n-impl Foo {\n-    // ...\n-}\n-```\n-\n-`#[inline]` hints the compiler whether or not to attempt to inline a method or\n-function. By default, the compiler does a pretty good job of figuring this out\n-itself, but if you feel the need for annotations, `#[inline(always)]` and\n-`#[inline(never)]` can override or force the compiler's decision.\n-\n-If you wish to apply this attribute to all methods in an impl, manually annotate\n-each method; it is not possible to annotate the entire impl with an `#[inline]`\n-attribute.\n-\"##,\n-\n-E0522: r##\"\n-The lang attribute is intended for marking special items that are built-in to\n-Rust itself. This includes special traits (like `Copy` and `Sized`) that affect\n-how the compiler behaves, as well as special functions that may be automatically\n-invoked (such as the handler for out-of-bounds accesses when indexing a slice).\n-Erroneous code example:\n-\n-```compile_fail,E0522\n-#![feature(lang_items)]\n-\n-#[lang = \"cookie\"]\n-fn cookie() -> ! { // error: definition of an unknown language item: `cookie`\n-    loop {}\n-}\n-```\n-\"##,\n-\n-E0525: r##\"\n-A closure was used but didn't implement the expected trait.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0525\n-struct X;\n-\n-fn foo<T>(_: T) {}\n-fn bar<T: Fn(u32)>(_: T) {}\n-\n-fn main() {\n-    let x = X;\n-    let closure = |_| foo(x); // error: expected a closure that implements\n-                              //        the `Fn` trait, but this closure only\n-                              //        implements `FnOnce`\n-    bar(closure);\n-}\n-```\n-\n-In the example above, `closure` is an `FnOnce` closure whereas the `bar`\n-function expected an `Fn` closure. In this case, it's simple to fix the issue,\n-you just have to implement `Copy` and `Clone` traits on `struct X` and it'll\n-be ok:\n-\n-```\n-#[derive(Clone, Copy)] // We implement `Clone` and `Copy` traits.\n-struct X;\n-\n-fn foo<T>(_: T) {}\n-fn bar<T: Fn(u32)>(_: T) {}\n-\n-fn main() {\n-    let x = X;\n-    let closure = |_| foo(x);\n-    bar(closure); // ok!\n-}\n-```\n-\n-To understand better how closures work in Rust, read:\n-https://doc.rust-lang.org/book/ch13-01-closures.html\n-\"##,\n-\n-E0566: r##\"\n-Conflicting representation hints have been used on a same item.\n-\n-Erroneous code example:\n-\n-```\n-#[repr(u32, u64)] // warning!\n-enum Repr { A }\n-```\n-\n-In most cases (if not all), using just one representation hint is more than\n-enough. If you want to have a representation hint depending on the current\n-architecture, use `cfg_attr`. Example:\n-\n-```\n-#[cfg_attr(linux, repr(u32))]\n-#[cfg_attr(not(linux), repr(u64))]\n-enum Repr { A }\n-```\n-\"##,\n-\n-E0580: r##\"\n-The `main` function was incorrectly declared.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0580\n-fn main(x: i32) { // error: main function has wrong type\n-    println!(\"{}\", x);\n-}\n-```\n-\n-The `main` function prototype should never take arguments.\n-Example:\n-\n-```\n-fn main() {\n-    // your code\n-}\n-```\n-\n-If you want to get command-line arguments, use `std::env::args`. To exit with a\n-specified exit code, use `std::process::exit`.\n-\"##,\n-\n-E0562: r##\"\n-Abstract return types (written `impl Trait` for some trait `Trait`) are only\n-allowed as function and inherent impl return types.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0562\n-fn main() {\n-    let count_to_ten: impl Iterator<Item=usize> = 0..10;\n-    // error: `impl Trait` not allowed outside of function and inherent method\n-    //        return types\n-    for i in count_to_ten {\n-        println!(\"{}\", i);\n-    }\n-}\n-```\n-\n-Make sure `impl Trait` only appears in return-type position.\n-\n-```\n-fn count_to_n(n: usize) -> impl Iterator<Item=usize> {\n-    0..n\n-}\n-\n-fn main() {\n-    for i in count_to_n(10) {  // ok!\n-        println!(\"{}\", i);\n-    }\n-}\n-```\n-\n-See [RFC 1522] for more details.\n-\n-[RFC 1522]: https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md\n-\"##,\n-\n-E0593: r##\"\n-You tried to supply an `Fn`-based type with an incorrect number of arguments\n-than what was expected.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0593\n-fn foo<F: Fn()>(x: F) { }\n-\n-fn main() {\n-    // [E0593] closure takes 1 argument but 0 arguments are required\n-    foo(|y| { });\n-}\n-```\n-\"##,\n-\n-E0602: r##\"\n-An unknown lint was used on the command line.\n-\n-Erroneous example:\n-\n-```sh\n-rustc -D bogus omse_file.rs\n-```\n-\n-Maybe you just misspelled the lint name or the lint doesn't exist anymore.\n-Either way, try to update/remove it in order to fix the error.\n-\"##,\n-\n-E0621: r##\"\n-This error code indicates a mismatch between the lifetimes appearing in the\n-function signature (i.e., the parameter types and the return type) and the\n-data-flow found in the function body.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0621\n-fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 { // error: explicit lifetime\n-                                             //        required in the type of\n-                                             //        `y`\n-    if x > y { x } else { y }\n-}\n-```\n-\n-In the code above, the function is returning data borrowed from either `x` or\n-`y`, but the `'a` annotation indicates that it is returning data only from `x`.\n-To fix the error, the signature and the body must be made to match. Typically,\n-this is done by updating the function signature. So, in this case, we change\n-the type of `y` to `&'a i32`, like so:\n-\n-```\n-fn foo<'a>(x: &'a i32, y: &'a i32) -> &'a i32 {\n-    if x > y { x } else { y }\n-}\n-```\n-\n-Now the signature indicates that the function data borrowed from either `x` or\n-`y`. Alternatively, you could change the body to not return data from `y`:\n-\n-```\n-fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n-    x\n-}\n-```\n-\"##,\n-\n-E0623: r##\"\n-A lifetime didn't match what was expected.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0623\n-struct Foo<'a> {\n-    x: &'a isize,\n-}\n-\n-fn bar<'short, 'long>(c: Foo<'short>, l: &'long isize) {\n-    let _: Foo<'long> = c; // error!\n-}\n-```\n-\n-In this example, we tried to set a value with an incompatible lifetime to\n-another one (`'long` is unrelated to `'short`). We can solve this issue in\n-two different ways:\n-\n-Either we make `'short` live at least as long as `'long`:\n-\n-```\n-struct Foo<'a> {\n-    x: &'a isize,\n-}\n-\n-// we set 'short to live at least as long as 'long\n-fn bar<'short: 'long, 'long>(c: Foo<'short>, l: &'long isize) {\n-    let _: Foo<'long> = c; // ok!\n-}\n-```\n-\n-Or we use only one lifetime:\n-\n-```\n-struct Foo<'a> {\n-    x: &'a isize,\n-}\n-\n-fn bar<'short>(c: Foo<'short>, l: &'short isize) {\n-    let _: Foo<'short> = c; // ok!\n-}\n-```\n-\"##,\n-\n-E0635: r##\"\n-The `#![feature]` attribute specified an unknown feature.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0635\n-#![feature(nonexistent_rust_feature)] // error: unknown feature\n-```\n-\n-\"##,\n-\n-E0636: r##\"\n-A `#![feature]` attribute was declared multiple times.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0636\n-#![allow(stable_features)]\n-#![feature(rust1)]\n-#![feature(rust1)] // error: the feature `rust1` has already been declared\n-```\n-\n-\"##,\n-\n-E0644: r##\"\n-A closure or generator was constructed that references its own type.\n-\n-Erroneous example:\n-\n-```compile-fail,E0644\n-fn fix<F>(f: &F)\n-  where F: Fn(&F)\n-{\n-  f(&f);\n-}\n-\n-fn main() {\n-  fix(&|y| {\n-    // Here, when `x` is called, the parameter `y` is equal to `x`.\n-  });\n-}\n-```\n-\n-Rust does not permit a closure to directly reference its own type,\n-either through an argument (as in the example above) or by capturing\n-itself through its environment. This restriction helps keep closure\n-inference tractable.\n-\n-The easiest fix is to rewrite your closure into a top-level function,\n-or into a method. In some cases, you may also be able to have your\n-closure call itself by capturing a `&Fn()` object or `fn()` pointer\n-that refers to itself. That is permitting, since the closure would be\n-invoking itself via a virtual call, and hence does not directly\n-reference its own *type*.\n-\n-\"##,\n-\n-E0692: r##\"\n-A `repr(transparent)` type was also annotated with other, incompatible\n-representation hints.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0692\n-#[repr(transparent, C)] // error: incompatible representation hints\n-struct Grams(f32);\n-```\n-\n-A type annotated as `repr(transparent)` delegates all representation concerns to\n-another type, so adding more representation hints is contradictory. Remove\n-either the `transparent` hint or the other hints, like this:\n-\n-```\n-#[repr(transparent)]\n-struct Grams(f32);\n-```\n-\n-Alternatively, move the other attributes to the contained type:\n-\n-```\n-#[repr(C)]\n-struct Foo {\n-    x: i32,\n-    // ...\n-}\n-\n-#[repr(transparent)]\n-struct FooWrapper(Foo);\n-```\n-\n-Note that introducing another `struct` just to have a place for the other\n-attributes may have unintended side effects on the representation:\n-\n-```\n-#[repr(transparent)]\n-struct Grams(f32);\n-\n-#[repr(C)]\n-struct Float(f32);\n-\n-#[repr(transparent)]\n-struct Grams2(Float); // this is not equivalent to `Grams` above\n-```\n-\n-Here, `Grams2` is a not equivalent to `Grams` -- the former transparently wraps\n-a (non-transparent) struct containing a single float, while `Grams` is a\n-transparent wrapper around a float. This can make a difference for the ABI.\n-\"##,\n-\n-E0697: r##\"\n-A closure has been used as `static`.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0697\n-fn main() {\n-    static || {}; // used as `static`\n-}\n-```\n-\n-Closures cannot be used as `static`. They \"save\" the environment,\n-and as such a static closure would save only a static environment\n-which would consist only of variables with a static lifetime. Given\n-this it would be better to use a proper function. The easiest fix\n-is to remove the `static` keyword.\n-\"##,\n-\n-E0698: r##\"\n-When using generators (or async) all type variables must be bound so a\n-generator can be constructed.\n-\n-Erroneous code example:\n-\n-```edition2018,compile-fail,E0698\n-async fn bar<T>() -> () {}\n-\n-async fn foo() {\n-    bar().await; // error: cannot infer type for `T`\n-}\n-```\n-\n-In the above example `T` is unknowable by the compiler.\n-To fix this you must bind `T` to a concrete type such as `String`\n-so that a generator can then be constructed:\n-\n-```edition2018\n-async fn bar<T>() -> () {}\n-\n-async fn foo() {\n-    bar::<String>().await;\n-    //   ^^^^^^^^ specify type explicitly\n-}\n-```\n-\"##,\n-\n-E0700: r##\"\n-The `impl Trait` return type captures lifetime parameters that do not\n-appear within the `impl Trait` itself.\n-\n-Erroneous code example:\n-\n-```compile-fail,E0700\n-use std::cell::Cell;\n-\n-trait Trait<'a> { }\n-\n-impl<'a, 'b> Trait<'b> for Cell<&'a u32> { }\n-\n-fn foo<'x, 'y>(x: Cell<&'x u32>) -> impl Trait<'y>\n-where 'x: 'y\n-{\n-    x\n-}\n-```\n-\n-Here, the function `foo` returns a value of type `Cell<&'x u32>`,\n-which references the lifetime `'x`. However, the return type is\n-declared as `impl Trait<'y>` -- this indicates that `foo` returns\n-\"some type that implements `Trait<'y>`\", but it also indicates that\n-the return type **only captures data referencing the lifetime `'y`**.\n-In this case, though, we are referencing data with lifetime `'x`, so\n-this function is in error.\n-\n-To fix this, you must reference the lifetime `'x` from the return\n-type. For example, changing the return type to `impl Trait<'y> + 'x`\n-would work:\n-\n-```\n-use std::cell::Cell;\n-\n-trait Trait<'a> { }\n-\n-impl<'a,'b> Trait<'b> for Cell<&'a u32> { }\n-\n-fn foo<'x, 'y>(x: Cell<&'x u32>) -> impl Trait<'y> + 'x\n-where 'x: 'y\n-{\n-    x\n-}\n-```\n-\"##,\n-\n-E0701: r##\"\n-This error indicates that a `#[non_exhaustive]` attribute was incorrectly placed\n-on something other than a struct or enum.\n-\n-Examples of erroneous code:\n-\n-```compile_fail,E0701\n-#[non_exhaustive]\n-trait Foo { }\n-```\n-\"##,\n-\n-E0718: r##\"\n-This error indicates that a `#[lang = \"..\"]` attribute was placed\n-on the wrong type of item.\n-\n-Examples of erroneous code:\n-\n-```compile_fail,E0718\n-#![feature(lang_items)]\n-\n-#[lang = \"arc\"]\n-static X: u32 = 42;\n-```\n-\"##,\n-\n-E0728: r##\"\n-[`await`] has been used outside [`async`] function or block.\n-\n-Erroneous code examples:\n-\n-```edition2018,compile_fail,E0728\n-# use std::pin::Pin;\n-# use std::future::Future;\n-# use std::task::{Context, Poll};\n-#\n-# struct WakeOnceThenComplete(bool);\n-#\n-# fn wake_and_yield_once() -> WakeOnceThenComplete {\n-#     WakeOnceThenComplete(false)\n-# }\n-#\n-# impl Future for WakeOnceThenComplete {\n-#     type Output = ();\n-#     fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {\n-#         if self.0 {\n-#             Poll::Ready(())\n-#         } else {\n-#             cx.waker().wake_by_ref();\n-#             self.0 = true;\n-#             Poll::Pending\n-#         }\n-#     }\n-# }\n-#\n-fn foo() {\n-    wake_and_yield_once().await // `await` is used outside `async` context\n-}\n-```\n-\n-[`await`] is used to suspend the current computation until the given\n-future is ready to produce a value. So it is legal only within\n-an [`async`] context, like an `async fn` or an `async` block.\n-\n-```edition2018\n-# use std::pin::Pin;\n-# use std::future::Future;\n-# use std::task::{Context, Poll};\n-#\n-# struct WakeOnceThenComplete(bool);\n-#\n-# fn wake_and_yield_once() -> WakeOnceThenComplete {\n-#     WakeOnceThenComplete(false)\n-# }\n-#\n-# impl Future for WakeOnceThenComplete {\n-#     type Output = ();\n-#     fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {\n-#         if self.0 {\n-#             Poll::Ready(())\n-#         } else {\n-#             cx.waker().wake_by_ref();\n-#             self.0 = true;\n-#             Poll::Pending\n-#         }\n-#     }\n-# }\n-#\n-async fn foo() {\n-    wake_and_yield_once().await // `await` is used within `async` function\n-}\n-\n-fn bar(x: u8) -> impl Future<Output = u8> {\n-    async move {\n-        wake_and_yield_once().await; // `await` is used within `async` block\n-        x\n-    }\n-}\n-```\n-\n-[`async`]: https://doc.rust-lang.org/std/keyword.async.html\n-[`await`]: https://doc.rust-lang.org/std/keyword.await.html\n-\"##,\n-\n-E0734: r##\"\n-A stability attribute has been used outside of the standard library.\n-\n-Erroneous code examples:\n-\n-```compile_fail,E0734\n-#[rustc_deprecated(since = \"b\", reason = \"text\")] // invalid\n-#[stable(feature = \"a\", since = \"b\")] // invalid\n-#[unstable(feature = \"b\", issue = \"0\")] // invalid\n-fn foo(){}\n-```\n-\n-These attributes are meant to only be used by the standard library and are\n-rejected in your own crates.\n-\"##,\n-\n-E0736: r##\"\n-`#[track_caller]` and `#[naked]` cannot both be applied to the same function.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0736\n-#![feature(track_caller)]\n-\n-#[naked]\n-#[track_caller]\n-fn foo() {}\n-```\n-\n-This is primarily due to ABI incompatibilities between the two attributes.\n-See [RFC 2091] for details on this and other limitations.\n-\n-[RFC 2091]: https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md\n-\"##,\n-\n-E0738: r##\"\n-`#[track_caller]` cannot be used in traits yet. This is due to limitations in\n-the compiler which are likely to be temporary. See [RFC 2091] for details on\n-this and other restrictions.\n-\n-Erroneous example with a trait method implementation:\n-\n-```compile_fail,E0738\n-#![feature(track_caller)]\n-\n-trait Foo {\n-    fn bar(&self);\n-}\n-\n-impl Foo for u64 {\n-    #[track_caller]\n-    fn bar(&self) {}\n-}\n-```\n-\n-Erroneous example with a blanket trait method implementation:\n-\n-```compile_fail,E0738\n-#![feature(track_caller)]\n-\n-trait Foo {\n-    #[track_caller]\n-    fn bar(&self) {}\n-    fn baz(&self);\n-}\n-```\n-\n-Erroneous example with a trait method declaration:\n-\n-```compile_fail,E0738\n-#![feature(track_caller)]\n-\n-trait Foo {\n-    fn bar(&self) {}\n-\n-    #[track_caller]\n-    fn baz(&self);\n-}\n-```\n-\n-Note that while the compiler may be able to support the attribute in traits in\n-the future, [RFC 2091] prohibits their implementation without a follow-up RFC.\n-\n-[RFC 2091]: https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md\n-\"##,\n-\n-;\n-//  E0006, // merged with E0005\n-//  E0101, // replaced with E0282\n-//  E0102, // replaced with E0282\n-//  E0134,\n-//  E0135,\n-//  E0272, // on_unimplemented #0\n-//  E0273, // on_unimplemented #1\n-//  E0274, // on_unimplemented #2\n-//  E0278, // requirement is not satisfied\n-    E0279, // requirement is not satisfied\n-    E0280, // requirement is not satisfied\n-//  E0285, // overflow evaluation builtin bounds\n-//  E0296, // replaced with a generic attribute input check\n-//  E0300, // unexpanded macro\n-//  E0304, // expected signed integer constant\n-//  E0305, // expected constant\n-    E0311, // thing may not live long enough\n-    E0313, // lifetime of borrowed pointer outlives lifetime of captured\n-           // variable\n-    E0314, // closure outlives stack frame\n-    E0315, // cannot invoke closure outside of its lifetime\n-    E0316, // nested quantification of lifetimes\n-    E0320, // recursive overflow during dropck\n-    E0473, // dereference of reference outside its lifetime\n-    E0474, // captured variable `..` does not outlive the enclosing closure\n-    E0475, // index of slice outside its lifetime\n-    E0476, // lifetime of the source pointer does not outlive lifetime bound...\n-    E0477, // the type `..` does not fulfill the required lifetime...\n-    E0479, // the type `..` (provided as the value of a type parameter) is...\n-    E0480, // lifetime of method receiver does not outlive the method call\n-    E0481, // lifetime of function argument does not outlive the function call\n-    E0482, // lifetime of return value does not outlive the function call\n-    E0483, // lifetime of operand does not outlive the operation\n-    E0484, // reference is not valid at the time of borrow\n-    E0485, // automatically reference is not valid at the time of borrow\n-    E0486, // type of expression contains references that are not valid during..\n-    E0487, // unsafe use of destructor: destructor might be called while...\n-    E0488, // lifetime of variable does not enclose its declaration\n-    E0489, // type/lifetime parameter not in scope here\n-    E0490, // a value of type `..` is borrowed for too long\n-    E0628, // generators cannot have explicit parameters\n-    E0631, // type mismatch in closure arguments\n-    E0637, // \"'_\" is not a valid lifetime bound\n-    E0657, // `impl Trait` can only capture lifetimes bound at the fn level\n-    E0687, // in-band lifetimes cannot be used in `fn`/`Fn` syntax\n-    E0688, // in-band lifetimes cannot be mixed with explicit lifetime binders\n-    E0703, // invalid ABI\n-//  E0707, // multiple elided lifetimes used in arguments of `async fn`\n-    E0708, // `async` non-`move` closures with parameters are not currently\n-           // supported\n-//  E0709, // multiple different lifetimes used in arguments of `async fn`\n-    E0710, // an unknown tool name found in scoped lint\n-    E0711, // a feature has been declared with conflicting stability attributes\n-//  E0702, // replaced with a generic attribute input check\n-    E0726, // non-explicit (not `'_`) elided lifetime in unsupported position\n-    E0727, // `async` generators are not yet supported\n-    E0739, // invalid track_caller application/syntax\n-}"}, {"sha": "02e26d8f6ecf0f9bebb552fc5dbb11b3717c7120", "filename": "src/librustc_codegen_ssa/error_codes.rs", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/798e389e578a0199f734c79424fa39e440910979/src%2Flibrustc_codegen_ssa%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/798e389e578a0199f734c79424fa39e440910979/src%2Flibrustc_codegen_ssa%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ferror_codes.rs?ref=798e389e578a0199f734c79424fa39e440910979", "patch": "@@ -1,71 +0,0 @@\n-syntax::register_diagnostics! {\n-\n-E0511: r##\"\n-Invalid monomorphization of an intrinsic function was used. Erroneous code\n-example:\n-\n-```ignore (error-emitted-at-codegen-which-cannot-be-handled-by-compile_fail)\n-#![feature(platform_intrinsics)]\n-\n-extern \"platform-intrinsic\" {\n-    fn simd_add<T>(a: T, b: T) -> T;\n-}\n-\n-fn main() {\n-    unsafe { simd_add(0, 1); }\n-    // error: invalid monomorphization of `simd_add` intrinsic\n-}\n-```\n-\n-The generic type has to be a SIMD type. Example:\n-\n-```\n-#![feature(repr_simd)]\n-#![feature(platform_intrinsics)]\n-\n-#[repr(simd)]\n-#[derive(Copy, Clone)]\n-struct i32x2(i32, i32);\n-\n-extern \"platform-intrinsic\" {\n-    fn simd_add<T>(a: T, b: T) -> T;\n-}\n-\n-unsafe { simd_add(i32x2(0, 0), i32x2(1, 2)); } // ok!\n-```\n-\"##,\n-\n-E0668: r##\"\n-Malformed inline assembly rejected by LLVM.\n-\n-LLVM checks the validity of the constraints and the assembly string passed to\n-it. This error implies that LLVM seems something wrong with the inline\n-assembly call.\n-\n-In particular, it can happen if you forgot the closing bracket of a register\n-constraint (see issue #51430):\n-```ignore (error-emitted-at-codegen-which-cannot-be-handled-by-compile_fail)\n-#![feature(asm)]\n-\n-fn main() {\n-    let rax: u64;\n-    unsafe {\n-        asm!(\"\" :\"={rax\"(rax));\n-        println!(\"Accumulator is: {}\", rax);\n-    }\n-}\n-```\n-\"##,\n-\n-E0669: r##\"\n-Cannot convert inline assembly operand to a single LLVM value.\n-\n-This error usually happens when trying to pass in a value to an input inline\n-assembly operand that is actually a pair of values. In particular, this can\n-happen when trying to pass in a slice, for instance a `&str`. In Rust, these\n-values are represented internally as a pair of values, the pointer and its\n-length. When passed as an input operand, this pair of values can not be\n-coerced into a register and thus we must fail with an error.\n-\"##,\n-\n-}"}, {"sha": "2edc8fadf45684dae76eb1bce80429c4b97e548a", "filename": "src/librustc_lint/error_codes.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/798e389e578a0199f734c79424fa39e440910979/src%2Flibrustc_lint%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/798e389e578a0199f734c79424fa39e440910979/src%2Flibrustc_lint%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ferror_codes.rs?ref=798e389e578a0199f734c79424fa39e440910979", "patch": "@@ -1,4 +0,0 @@\n-syntax::register_diagnostics! {\n-;\n-//  E0721, // `await` keyword\n-}"}, {"sha": "cd8e95e6c3a1101786cd08bc55fba6b8bc0c7a37", "filename": "src/librustc_metadata/error_codes.rs", "status": "removed", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/798e389e578a0199f734c79424fa39e440910979/src%2Flibrustc_metadata%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/798e389e578a0199f734c79424fa39e440910979/src%2Flibrustc_metadata%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ferror_codes.rs?ref=798e389e578a0199f734c79424fa39e440910979", "patch": "@@ -1,97 +0,0 @@\n-syntax::register_diagnostics! {\n-E0454: r##\"\n-A link name was given with an empty name. Erroneous code example:\n-\n-```ignore (cannot-test-this-because-rustdoc-stops-compile-fail-before-codegen)\n-#[link(name = \"\")] extern {}\n-// error: `#[link(name = \"\")]` given with empty name\n-```\n-\n-The rust compiler cannot link to an external library if you don't give it its\n-name. Example:\n-\n-```no_run\n-#[link(name = \"some_lib\")] extern {} // ok!\n-```\n-\"##,\n-\n-E0455: r##\"\n-Linking with `kind=framework` is only supported when targeting macOS,\n-as frameworks are specific to that operating system.\n-\n-Erroneous code example:\n-\n-```ignore (should-compile_fail-but-cannot-doctest-conditionally-without-macos)\n-#[link(name = \"FooCoreServices\", kind = \"framework\")] extern {}\n-// OS used to compile is Linux for example\n-```\n-\n-To solve this error you can use conditional compilation:\n-\n-```\n-#[cfg_attr(target=\"macos\", link(name = \"FooCoreServices\", kind = \"framework\"))]\n-extern {}\n-```\n-\n-See more:\n-https://doc.rust-lang.org/reference/attributes.html#conditional-compilation\n-\"##,\n-\n-E0458: r##\"\n-An unknown \"kind\" was specified for a link attribute. Erroneous code example:\n-\n-```ignore (cannot-test-this-because-rustdoc-stops-compile-fail-before-codegen)\n-#[link(kind = \"wonderful_unicorn\")] extern {}\n-// error: unknown kind: `wonderful_unicorn`\n-```\n-\n-Please specify a valid \"kind\" value, from one of the following:\n-\n-* static\n-* dylib\n-* framework\n-\n-\"##,\n-\n-E0459: r##\"\n-A link was used without a name parameter. Erroneous code example:\n-\n-```ignore (cannot-test-this-because-rustdoc-stops-compile-fail-before-codegen)\n-#[link(kind = \"dylib\")] extern {}\n-// error: `#[link(...)]` specified without `name = \"foo\"`\n-```\n-\n-Please add the name parameter to allow the rust compiler to find the library\n-you want. Example:\n-\n-```no_run\n-#[link(kind = \"dylib\", name = \"some_lib\")] extern {} // ok!\n-```\n-\"##,\n-\n-E0463: r##\"\n-A plugin/crate was declared but cannot be found. Erroneous code example:\n-\n-```compile_fail,E0463\n-#![feature(plugin)]\n-#![plugin(cookie_monster)] // error: can't find crate for `cookie_monster`\n-extern crate cake_is_a_lie; // error: can't find crate for `cake_is_a_lie`\n-```\n-\n-You need to link your code to the relevant crate in order to be able to use it\n-(through Cargo or the `-L` option of rustc example). Plugins are crates as\n-well, and you link to them the same way.\n-\"##,\n-;\n-    E0456, // plugin `..` is not available for triple `..`\n-    E0457, // plugin `..` only found in rlib format, but must be available...\n-    E0514, // metadata version mismatch\n-    E0460, // found possibly newer version of crate `..`\n-    E0461, // couldn't find crate `..` with expected target triple ..\n-    E0462, // found staticlib `..` instead of rlib or dylib\n-    E0464, // multiple matching crates for `..`\n-    E0465, // multiple .. candidates for `..` found\n-    E0519, // local crate and dependency have same (crate-name, disambiguator)\n-    // two dependencies have same (crate-name, disambiguator) but different SVH\n-    E0523,\n-}"}, {"sha": "c119ca536fb524fee9de6768b63fa7d83e3c8786", "filename": "src/librustc_mir/error_codes.rs", "status": "removed", "additions": 0, "deletions": 2552, "changes": 2552, "blob_url": "https://github.com/rust-lang/rust/blob/798e389e578a0199f734c79424fa39e440910979/src%2Flibrustc_mir%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/798e389e578a0199f734c79424fa39e440910979/src%2Flibrustc_mir%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ferror_codes.rs?ref=798e389e578a0199f734c79424fa39e440910979", "patch": "@@ -1,2552 +0,0 @@\n-syntax::register_diagnostics! {\n-\n-\n-E0001: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-This error suggests that the expression arm corresponding to the noted pattern\n-will never be reached as for all possible values of the expression being\n-matched, one of the preceding patterns will match.\n-\n-This means that perhaps some of the preceding patterns are too general, this\n-one is too specific or the ordering is incorrect.\n-\n-For example, the following `match` block has too many arms:\n-\n-```\n-match Some(0) {\n-    Some(bar) => {/* ... */}\n-    x => {/* ... */} // This handles the `None` case\n-    _ => {/* ... */} // All possible cases have already been handled\n-}\n-```\n-\n-`match` blocks have their patterns matched in order, so, for example, putting\n-a wildcard arm above a more specific arm will make the latter arm irrelevant.\n-\n-Ensure the ordering of the match arm is correct and remove any superfluous\n-arms.\n-\"##,\n-\n-E0002: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-This error indicates that an empty match expression is invalid because the type\n-it is matching on is non-empty (there exist values of this type). In safe code\n-it is impossible to create an instance of an empty type, so empty match\n-expressions are almost never desired. This error is typically fixed by adding\n-one or more cases to the match expression.\n-\n-An example of an empty type is `enum Empty { }`. So, the following will work:\n-\n-```\n-enum Empty {}\n-\n-fn foo(x: Empty) {\n-    match x {\n-        // empty\n-    }\n-}\n-```\n-\n-However, this won't:\n-\n-```compile_fail\n-fn foo(x: Option<String>) {\n-    match x {\n-        // empty\n-    }\n-}\n-```\n-\"##,\n-\n-E0004: r##\"\n-This error indicates that the compiler cannot guarantee a matching pattern for\n-one or more possible inputs to a match expression. Guaranteed matches are\n-required in order to assign values to match expressions, or alternatively,\n-determine the flow of execution.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0004\n-enum Terminator {\n-    HastaLaVistaBaby,\n-    TalkToMyHand,\n-}\n-\n-let x = Terminator::HastaLaVistaBaby;\n-\n-match x { // error: non-exhaustive patterns: `HastaLaVistaBaby` not covered\n-    Terminator::TalkToMyHand => {}\n-}\n-```\n-\n-If you encounter this error you must alter your patterns so that every possible\n-value of the input type is matched. For types with a small number of variants\n-(like enums) you should probably cover all cases explicitly. Alternatively, the\n-underscore `_` wildcard pattern can be added after all other patterns to match\n-\"anything else\". Example:\n-\n-```\n-enum Terminator {\n-    HastaLaVistaBaby,\n-    TalkToMyHand,\n-}\n-\n-let x = Terminator::HastaLaVistaBaby;\n-\n-match x {\n-    Terminator::TalkToMyHand => {}\n-    Terminator::HastaLaVistaBaby => {}\n-}\n-\n-// or:\n-\n-match x {\n-    Terminator::TalkToMyHand => {}\n-    _ => {}\n-}\n-```\n-\"##,\n-\n-E0005: r##\"\n-Patterns used to bind names must be irrefutable, that is, they must guarantee\n-that a name will be extracted in all cases.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0005\n-let x = Some(1);\n-let Some(y) = x;\n-// error: refutable pattern in local binding: `None` not covered\n-```\n-\n-If you encounter this error you probably need to use a `match` or `if let` to\n-deal with the possibility of failure. Example:\n-\n-```\n-let x = Some(1);\n-\n-match x {\n-    Some(y) => {\n-        // do something\n-    },\n-    None => {}\n-}\n-\n-// or:\n-\n-if let Some(y) = x {\n-    // do something\n-}\n-```\n-\"##,\n-\n-E0007: r##\"\n-This error indicates that the bindings in a match arm would require a value to\n-be moved into more than one location, thus violating unique ownership. Code\n-like the following is invalid as it requires the entire `Option<String>` to be\n-moved into a variable called `op_string` while simultaneously requiring the\n-inner `String` to be moved into a variable called `s`.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0007\n-let x = Some(\"s\".to_string());\n-\n-match x {\n-    op_string @ Some(s) => {}, // error: cannot bind by-move with sub-bindings\n-    None => {},\n-}\n-```\n-\n-See also the error E0303.\n-\"##,\n-\n-E0009: r##\"\n-In a pattern, all values that don't implement the `Copy` trait have to be bound\n-the same way. The goal here is to avoid binding simultaneously by-move and\n-by-ref.\n-\n-This limitation may be removed in a future version of Rust.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0009\n-struct X { x: (), }\n-\n-let x = Some((X { x: () }, X { x: () }));\n-match x {\n-    Some((y, ref z)) => {}, // error: cannot bind by-move and by-ref in the\n-                            //        same pattern\n-    None => panic!()\n-}\n-```\n-\n-You have two solutions:\n-\n-Solution #1: Bind the pattern's values the same way.\n-\n-```\n-struct X { x: (), }\n-\n-let x = Some((X { x: () }, X { x: () }));\n-match x {\n-    Some((ref y, ref z)) => {},\n-    // or Some((y, z)) => {}\n-    None => panic!()\n-}\n-```\n-\n-Solution #2: Implement the `Copy` trait for the `X` structure.\n-\n-However, please keep in mind that the first solution should be preferred.\n-\n-```\n-#[derive(Clone, Copy)]\n-struct X { x: (), }\n-\n-let x = Some((X { x: () }, X { x: () }));\n-match x {\n-    Some((y, ref z)) => {},\n-    None => panic!()\n-}\n-```\n-\"##,\n-\n-E0010: r##\"\n-The value of statics and constants must be known at compile time, and they live\n-for the entire lifetime of a program. Creating a boxed value allocates memory on\n-the heap at runtime, and therefore cannot be done at compile time.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0010\n-#![feature(box_syntax)]\n-\n-const CON : Box<i32> = box 0;\n-```\n-\"##,\n-\n-E0013: r##\"\n-Static and const variables can refer to other const variables. But a const\n-variable cannot refer to a static variable.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0013\n-static X: i32 = 42;\n-const Y: i32 = X;\n-```\n-\n-In this example, `Y` cannot refer to `X` here. To fix this, the value can be\n-extracted as a const and then used:\n-\n-```\n-const A: i32 = 42;\n-static X: i32 = A;\n-const Y: i32 = A;\n-```\n-\"##,\n-\n-// FIXME(#57563) Change the language here when const fn stabilizes\n-E0015: r##\"\n-The only functions that can be called in static or constant expressions are\n-`const` functions, and struct/enum constructors. `const` functions are only\n-available on a nightly compiler. Rust currently does not support more general\n-compile-time function execution.\n-\n-```\n-const FOO: Option<u8> = Some(1); // enum constructor\n-struct Bar {x: u8}\n-const BAR: Bar = Bar {x: 1}; // struct constructor\n-```\n-\n-See [RFC 911] for more details on the design of `const fn`s.\n-\n-[RFC 911]: https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md\n-\"##,\n-\n-E0017: r##\"\n-References in statics and constants may only refer to immutable values.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0017\n-static X: i32 = 1;\n-const C: i32 = 2;\n-\n-// these three are not allowed:\n-const CR: &mut i32 = &mut C;\n-static STATIC_REF: &'static mut i32 = &mut X;\n-static CONST_REF: &'static mut i32 = &mut C;\n-```\n-\n-Statics are shared everywhere, and if they refer to mutable data one might\n-violate memory safety since holding multiple mutable references to shared data\n-is not allowed.\n-\n-If you really want global mutable state, try using `static mut` or a global\n-`UnsafeCell`.\n-\"##,\n-\n-E0019: r##\"\n-A function call isn't allowed in the const's initialization expression\n-because the expression's value must be known at compile-time.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0019\n-#![feature(box_syntax)]\n-\n-fn main() {\n-    struct MyOwned;\n-\n-    static STATIC11: Box<MyOwned> = box MyOwned; // error!\n-}\n-```\n-\n-Remember: you can't use a function call inside a const's initialization\n-expression! However, you can totally use it anywhere else:\n-\n-```\n-enum Test {\n-    V1\n-}\n-\n-impl Test {\n-    fn func(&self) -> i32 {\n-        12\n-    }\n-}\n-\n-fn main() {\n-    const FOO: Test = Test::V1;\n-\n-    FOO.func(); // here is good\n-    let x = FOO.func(); // or even here!\n-}\n-```\n-\"##,\n-\n-E0030: r##\"\n-When matching against a range, the compiler verifies that the range is\n-non-empty. Range patterns include both end-points, so this is equivalent to\n-requiring the start of the range to be less than or equal to the end of the\n-range.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0030\n-match 5u32 {\n-    // This range is ok, albeit pointless.\n-    1 ..= 1 => {}\n-    // This range is empty, and the compiler can tell.\n-    1000 ..= 5 => {}\n-}\n-```\n-\"##,\n-\n-E0133: r##\"\n-Unsafe code was used outside of an unsafe function or block.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0133\n-unsafe fn f() { return; } // This is the unsafe code\n-\n-fn main() {\n-    f(); // error: call to unsafe function requires unsafe function or block\n-}\n-```\n-\n-Using unsafe functionality is potentially dangerous and disallowed by safety\n-checks. Examples:\n-\n-* Dereferencing raw pointers\n-* Calling functions via FFI\n-* Calling functions marked unsafe\n-\n-These safety checks can be relaxed for a section of the code by wrapping the\n-unsafe instructions with an `unsafe` block. For instance:\n-\n-```\n-unsafe fn f() { return; }\n-\n-fn main() {\n-    unsafe { f(); } // ok!\n-}\n-```\n-\n-See also https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n-\"##,\n-\n-E0158: r##\"\n-An associated const has been referenced in a pattern.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0158\n-enum EFoo { A, B, C, D }\n-\n-trait Foo {\n-    const X: EFoo;\n-}\n-\n-fn test<A: Foo>(arg: EFoo) {\n-    match arg {\n-        A::X => { // error!\n-            println!(\"A::X\");\n-        }\n-    }\n-}\n-```\n-\n-`const` and `static` mean different things. A `const` is a compile-time\n-constant, an alias for a literal value. This property means you can match it\n-directly within a pattern.\n-\n-The `static` keyword, on the other hand, guarantees a fixed location in memory.\n-This does not always mean that the value is constant. For example, a global\n-mutex can be declared `static` as well.\n-\n-If you want to match against a `static`, consider using a guard instead:\n-\n-```\n-static FORTY_TWO: i32 = 42;\n-\n-match Some(42) {\n-    Some(x) if x == FORTY_TWO => {}\n-    _ => {}\n-}\n-```\n-\"##,\n-\n-E0161: r##\"\n-A value was moved. However, its size was not known at compile time, and only\n-values of a known size can be moved.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0161\n-#![feature(box_syntax)]\n-\n-fn main() {\n-    let array: &[isize] = &[1, 2, 3];\n-    let _x: Box<[isize]> = box *array;\n-    // error: cannot move a value of type [isize]: the size of [isize] cannot\n-    //        be statically determined\n-}\n-```\n-\n-In Rust, you can only move a value when its size is known at compile time.\n-\n-To work around this restriction, consider \"hiding\" the value behind a reference:\n-either `&x` or `&mut x`. Since a reference has a fixed size, this lets you move\n-it around as usual. Example:\n-\n-```\n-#![feature(box_syntax)]\n-\n-fn main() {\n-    let array: &[isize] = &[1, 2, 3];\n-    let _x: Box<&[isize]> = box array; // ok!\n-}\n-```\n-\"##,\n-\n-E0162: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-An if-let pattern attempts to match the pattern, and enters the body if the\n-match was successful. If the match is irrefutable (when it cannot fail to\n-match), use a regular `let`-binding instead. For instance:\n-\n-```\n-struct Irrefutable(i32);\n-let irr = Irrefutable(0);\n-\n-// This fails to compile because the match is irrefutable.\n-if let Irrefutable(x) = irr {\n-    // This body will always be executed.\n-    // ...\n-}\n-```\n-\n-Try this instead:\n-\n-```\n-struct Irrefutable(i32);\n-let irr = Irrefutable(0);\n-\n-let Irrefutable(x) = irr;\n-println!(\"{}\", x);\n-```\n-\"##,\n-\n-E0165: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-A while-let pattern attempts to match the pattern, and enters the body if the\n-match was successful. If the match is irrefutable (when it cannot fail to\n-match), use a regular `let`-binding inside a `loop` instead. For instance:\n-\n-```no_run\n-struct Irrefutable(i32);\n-let irr = Irrefutable(0);\n-\n-// This fails to compile because the match is irrefutable.\n-while let Irrefutable(x) = irr {\n-    // ...\n-}\n-```\n-\n-Try this instead:\n-\n-```no_run\n-struct Irrefutable(i32);\n-let irr = Irrefutable(0);\n-\n-loop {\n-    let Irrefutable(x) = irr;\n-    // ...\n-}\n-```\n-\"##,\n-\n-E0170: r##\"\n-Enum variants are qualified by default. For example, given this type:\n-\n-```\n-enum Method {\n-    GET,\n-    POST,\n-}\n-```\n-\n-You would match it using:\n-\n-```\n-enum Method {\n-    GET,\n-    POST,\n-}\n-\n-let m = Method::GET;\n-\n-match m {\n-    Method::GET => {},\n-    Method::POST => {},\n-}\n-```\n-\n-If you don't qualify the names, the code will bind new variables named \"GET\" and\n-\"POST\" instead. This behavior is likely not what you want, so `rustc` warns when\n-that happens.\n-\n-Qualified names are good practice, and most code works well with them. But if\n-you prefer them unqualified, you can import the variants into scope:\n-\n-```\n-use Method::*;\n-enum Method { GET, POST }\n-# fn main() {}\n-```\n-\n-If you want others to be able to import variants from your module directly, use\n-`pub use`:\n-\n-```\n-pub use Method::*;\n-pub enum Method { GET, POST }\n-# fn main() {}\n-```\n-\"##,\n-\n-\n-E0297: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-Patterns used to bind names must be irrefutable. That is, they must guarantee\n-that a name will be extracted in all cases. Instead of pattern matching the\n-loop variable, consider using a `match` or `if let` inside the loop body. For\n-instance:\n-\n-```compile_fail,E0005\n-let xs : Vec<Option<i32>> = vec![Some(1), None];\n-\n-// This fails because `None` is not covered.\n-for Some(x) in xs {\n-    // ...\n-}\n-```\n-\n-Match inside the loop instead:\n-\n-```\n-let xs : Vec<Option<i32>> = vec![Some(1), None];\n-\n-for item in xs {\n-    match item {\n-        Some(x) => {},\n-        None => {},\n-    }\n-}\n-```\n-\n-Or use `if let`:\n-\n-```\n-let xs : Vec<Option<i32>> = vec![Some(1), None];\n-\n-for item in xs {\n-    if let Some(x) = item {\n-        // ...\n-    }\n-}\n-```\n-\"##,\n-\n-E0301: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-Mutable borrows are not allowed in pattern guards, because matching cannot have\n-side effects. Side effects could alter the matched object or the environment\n-on which the match depends in such a way, that the match would not be\n-exhaustive. For instance, the following would not match any arm if mutable\n-borrows were allowed:\n-\n-```compile_fail,E0596\n-match Some(()) {\n-    None => { },\n-    option if option.take().is_none() => {\n-        /* impossible, option is `Some` */\n-    },\n-    Some(_) => { } // When the previous match failed, the option became `None`.\n-}\n-```\n-\"##,\n-\n-E0302: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-Assignments are not allowed in pattern guards, because matching cannot have\n-side effects. Side effects could alter the matched object or the environment\n-on which the match depends in such a way, that the match would not be\n-exhaustive. For instance, the following would not match any arm if assignments\n-were allowed:\n-\n-```compile_fail,E0594\n-match Some(()) {\n-    None => { },\n-    option if { option = None; false } => { },\n-    Some(_) => { } // When the previous match failed, the option became `None`.\n-}\n-```\n-\"##,\n-\n-E0303: r##\"\n-In certain cases it is possible for sub-bindings to violate memory safety.\n-Updates to the borrow checker in a future version of Rust may remove this\n-restriction, but for now patterns must be rewritten without sub-bindings.\n-\n-Before:\n-\n-```compile_fail,E0303\n-match Some(\"hi\".to_string()) {\n-    ref op_string_ref @ Some(s) => {},\n-    None => {},\n-}\n-```\n-\n-After:\n-\n-```\n-match Some(\"hi\".to_string()) {\n-    Some(ref s) => {\n-        let op_string_ref = &Some(s);\n-        // ...\n-    },\n-    None => {},\n-}\n-```\n-\n-The `op_string_ref` binding has type `&Option<&String>` in both cases.\n-\n-See also https://github.com/rust-lang/rust/issues/14587\n-\"##,\n-\n-E0373: r##\"\n-This error occurs when an attempt is made to use data captured by a closure,\n-when that data may no longer exist. It's most commonly seen when attempting to\n-return a closure:\n-\n-```compile_fail,E0373\n-fn foo() -> Box<Fn(u32) -> u32> {\n-    let x = 0u32;\n-    Box::new(|y| x + y)\n-}\n-```\n-\n-Notice that `x` is stack-allocated by `foo()`. By default, Rust captures\n-closed-over data by reference. This means that once `foo()` returns, `x` no\n-longer exists. An attempt to access `x` within the closure would thus be\n-unsafe.\n-\n-Another situation where this might be encountered is when spawning threads:\n-\n-```compile_fail,E0373\n-fn foo() {\n-    let x = 0u32;\n-    let y = 1u32;\n-\n-    let thr = std::thread::spawn(|| {\n-        x + y\n-    });\n-}\n-```\n-\n-Since our new thread runs in parallel, the stack frame containing `x` and `y`\n-may well have disappeared by the time we try to use them. Even if we call\n-`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\n-stack frame won't disappear), we will not succeed: the compiler cannot prove\n-that this behaviour is safe, and so won't let us do it.\n-\n-The solution to this problem is usually to switch to using a `move` closure.\n-This approach moves (or copies, where possible) data into the closure, rather\n-than taking references to it. For example:\n-\n-```\n-fn foo() -> Box<Fn(u32) -> u32> {\n-    let x = 0u32;\n-    Box::new(move |y| x + y)\n-}\n-```\n-\n-Now that the closure has its own copy of the data, there's no need to worry\n-about safety.\n-\"##,\n-\n-E0381: r##\"\n-It is not allowed to use or capture an uninitialized variable.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0381\n-fn main() {\n-    let x: i32;\n-    let y = x; // error, use of possibly-uninitialized variable\n-}\n-```\n-\n-To fix this, ensure that any declared variables are initialized before being\n-used. Example:\n-\n-```\n-fn main() {\n-    let x: i32 = 0;\n-    let y = x; // ok!\n-}\n-```\n-\"##,\n-\n-E0382: r##\"\n-This error occurs when an attempt is made to use a variable after its contents\n-have been moved elsewhere.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0382\n-struct MyStruct { s: u32 }\n-\n-fn main() {\n-    let mut x = MyStruct{ s: 5u32 };\n-    let y = x;\n-    x.s = 6;\n-    println!(\"{}\", x.s);\n-}\n-```\n-\n-Since `MyStruct` is a type that is not marked `Copy`, the data gets moved out\n-of `x` when we set `y`. This is fundamental to Rust's ownership system: outside\n-of workarounds like `Rc`, a value cannot be owned by more than one variable.\n-\n-Sometimes we don't need to move the value. Using a reference, we can let another\n-function borrow the value without changing its ownership. In the example below,\n-we don't actually have to move our string to `calculate_length`, we can give it\n-a reference to it with `&` instead.\n-\n-```\n-fn main() {\n-    let s1 = String::from(\"hello\");\n-\n-    let len = calculate_length(&s1);\n-\n-    println!(\"The length of '{}' is {}.\", s1, len);\n-}\n-\n-fn calculate_length(s: &String) -> usize {\n-    s.len()\n-}\n-```\n-\n-A mutable reference can be created with `&mut`.\n-\n-Sometimes we don't want a reference, but a duplicate. All types marked `Clone`\n-can be duplicated by calling `.clone()`. Subsequent changes to a clone do not\n-affect the original variable.\n-\n-Most types in the standard library are marked `Clone`. The example below\n-demonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\n-copied to `s2`. Then the first character of `s1` is removed, without affecting\n-`s2`. \"any many\" is printed to the console.\n-\n-```\n-fn main() {\n-    let mut s1 = String::from(\"many\");\n-    let s2 = s1.clone();\n-    s1.remove(0);\n-    println!(\"{} {}\", s1, s2);\n-}\n-```\n-\n-If we control the definition of a type, we can implement `Clone` on it ourselves\n-with `#[derive(Clone)]`.\n-\n-Some types have no ownership semantics at all and are trivial to duplicate. An\n-example is `i32` and the other number types. We don't have to call `.clone()` to\n-clone them, because they are marked `Copy` in addition to `Clone`.  Implicit\n-cloning is more convenient in this case. We can mark our own types `Copy` if\n-all their members also are marked `Copy`.\n-\n-In the example below, we implement a `Point` type. Because it only stores two\n-integers, we opt-out of ownership semantics with `Copy`. Then we can\n-`let p2 = p1` without `p1` being moved.\n-\n-```\n-#[derive(Copy, Clone)]\n-struct Point { x: i32, y: i32 }\n-\n-fn main() {\n-    let mut p1 = Point{ x: -1, y: 2 };\n-    let p2 = p1;\n-    p1.x = 1;\n-    println!(\"p1: {}, {}\", p1.x, p1.y);\n-    println!(\"p2: {}, {}\", p2.x, p2.y);\n-}\n-```\n-\n-Alternatively, if we don't control the struct's definition, or mutable shared\n-ownership is truly required, we can use `Rc` and `RefCell`:\n-\n-```\n-use std::cell::RefCell;\n-use std::rc::Rc;\n-\n-struct MyStruct { s: u32 }\n-\n-fn main() {\n-    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n-    let y = x.clone();\n-    x.borrow_mut().s = 6;\n-    println!(\"{}\", x.borrow().s);\n-}\n-```\n-\n-With this approach, x and y share ownership of the data via the `Rc` (reference\n-count type). `RefCell` essentially performs runtime borrow checking: ensuring\n-that at most one writer or multiple readers can access the data at any one time.\n-\n-If you wish to learn more about ownership in Rust, start with the chapter in the\n-Book:\n-\n-https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html\n-\"##,\n-\n-E0383: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-This error occurs when an attempt is made to partially reinitialize a\n-structure that is currently uninitialized.\n-\n-For example, this can happen when a drop has taken place:\n-\n-```compile_fail\n-struct Foo {\n-    a: u32,\n-}\n-impl Drop for Foo {\n-    fn drop(&mut self) { /* ... */ }\n-}\n-\n-let mut x = Foo { a: 1 };\n-drop(x); // `x` is now uninitialized\n-x.a = 2; // error, partial reinitialization of uninitialized structure `t`\n-```\n-\n-This error can be fixed by fully reinitializing the structure in question:\n-\n-```\n-struct Foo {\n-    a: u32,\n-}\n-impl Drop for Foo {\n-    fn drop(&mut self) { /* ... */ }\n-}\n-\n-let mut x = Foo { a: 1 };\n-drop(x);\n-x = Foo { a: 2 };\n-```\n-\"##,\n-\n-E0384: r##\"\n-This error occurs when an attempt is made to reassign an immutable variable.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0384\n-fn main() {\n-    let x = 3;\n-    x = 5; // error, reassignment of immutable variable\n-}\n-```\n-\n-By default, variables in Rust are immutable. To fix this error, add the keyword\n-`mut` after the keyword `let` when declaring the variable. For example:\n-\n-```\n-fn main() {\n-    let mut x = 3;\n-    x = 5;\n-}\n-```\n-\"##,\n-\n-E0386: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-This error occurs when an attempt is made to mutate the target of a mutable\n-reference stored inside an immutable container.\n-\n-For example, this can happen when storing a `&mut` inside an immutable `Box`:\n-\n-```\n-let mut x: i64 = 1;\n-let y: Box<_> = Box::new(&mut x);\n-**y = 2; // error, cannot assign to data in an immutable container\n-```\n-\n-This error can be fixed by making the container mutable:\n-\n-```\n-let mut x: i64 = 1;\n-let mut y: Box<_> = Box::new(&mut x);\n-**y = 2;\n-```\n-\n-It can also be fixed by using a type with interior mutability, such as `Cell`\n-or `RefCell`:\n-\n-```\n-use std::cell::Cell;\n-\n-let x: i64 = 1;\n-let y: Box<Cell<_>> = Box::new(Cell::new(x));\n-y.set(2);\n-```\n-\"##,\n-\n-E0387: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-This error occurs when an attempt is made to mutate or mutably reference data\n-that a closure has captured immutably.\n-\n-Erroneous code example:\n-\n-```compile_fail\n-// Accepts a function or a closure that captures its environment immutably.\n-// Closures passed to foo will not be able to mutate their closed-over state.\n-fn foo<F: Fn()>(f: F) { }\n-\n-// Attempts to mutate closed-over data. Error message reads:\n-// `cannot assign to data in a captured outer variable...`\n-fn mutable() {\n-    let mut x = 0u32;\n-    foo(|| x = 2);\n-}\n-\n-// Attempts to take a mutable reference to closed-over data.  Error message\n-// reads: `cannot borrow data mutably in a captured outer variable...`\n-fn mut_addr() {\n-    let mut x = 0u32;\n-    foo(|| { let y = &mut x; });\n-}\n-```\n-\n-The problem here is that foo is defined as accepting a parameter of type `Fn`.\n-Closures passed into foo will thus be inferred to be of type `Fn`, meaning that\n-they capture their context immutably.\n-\n-If the definition of `foo` is under your control, the simplest solution is to\n-capture the data mutably. This can be done by defining `foo` to take FnMut\n-rather than Fn:\n-\n-```\n-fn foo<F: FnMut()>(f: F) { }\n-```\n-\n-Alternatively, we can consider using the `Cell` and `RefCell` types to achieve\n-interior mutability through a shared reference. Our example's `mutable`\n-function could be redefined as below:\n-\n-```\n-use std::cell::Cell;\n-\n-fn foo<F: Fn()>(f: F) { }\n-\n-fn mutable() {\n-    let x = Cell::new(0u32);\n-    foo(|| x.set(2));\n-}\n-```\n-\n-You can read more about cell types in the API documentation:\n-\n-https://doc.rust-lang.org/std/cell/\n-\"##,\n-\n-E0388: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\"##,\n-\n-E0389: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-An attempt was made to mutate data using a non-mutable reference. This\n-commonly occurs when attempting to assign to a non-mutable reference of a\n-mutable reference (`&(&mut T)`).\n-\n-Erroneous code example:\n-\n-```compile_fail\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy = FancyNum{ num: 5 };\n-    let fancy_ref = &(&mut fancy);\n-    fancy_ref.num = 6; // error: cannot assign to data in a `&` reference\n-    println!(\"{}\", fancy_ref.num);\n-}\n-```\n-\n-Here, `&mut fancy` is mutable, but `&(&mut fancy)` is not. Creating an\n-immutable reference to a value borrows it immutably. There can be multiple\n-references of type `&(&mut T)` that point to the same value, so they must be\n-immutable to prevent multiple mutable references to the same value.\n-\n-To fix this, either remove the outer reference:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy = FancyNum{ num: 5 };\n-\n-    let fancy_ref = &mut fancy;\n-    // `fancy_ref` is now &mut FancyNum, rather than &(&mut FancyNum)\n-\n-    fancy_ref.num = 6; // No error!\n-\n-    println!(\"{}\", fancy_ref.num);\n-}\n-```\n-\n-Or make the outer reference mutable:\n-\n-```\n-struct FancyNum {\n-    num: u8\n-}\n-\n-fn main() {\n-    let mut fancy = FancyNum{ num: 5 };\n-\n-    let fancy_ref = &mut (&mut fancy);\n-    // `fancy_ref` is now &mut(&mut FancyNum), rather than &(&mut FancyNum)\n-\n-    fancy_ref.num = 6; // No error!\n-\n-    println!(\"{}\", fancy_ref.num);\n-}\n-```\n-\"##,\n-\n-E0492: r##\"\n-A borrow of a constant containing interior mutability was attempted.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0492\n-use std::sync::atomic::AtomicUsize;\n-\n-const A: AtomicUsize = AtomicUsize::new(0);\n-static B: &'static AtomicUsize = &A;\n-// error: cannot borrow a constant which may contain interior mutability,\n-//        create a static instead\n-```\n-\n-A `const` represents a constant value that should never change. If one takes\n-a `&` reference to the constant, then one is taking a pointer to some memory\n-location containing the value. Normally this is perfectly fine: most values\n-can't be changed via a shared `&` pointer, but interior mutability would allow\n-it. That is, a constant value could be mutated. On the other hand, a `static` is\n-explicitly a single memory location, which can be mutated at will.\n-\n-So, in order to solve this error, either use statics which are `Sync`:\n-\n-```\n-use std::sync::atomic::AtomicUsize;\n-\n-static A: AtomicUsize = AtomicUsize::new(0);\n-static B: &'static AtomicUsize = &A; // ok!\n-```\n-\n-You can also have this error while using a cell type:\n-\n-```compile_fail,E0492\n-use std::cell::Cell;\n-\n-const A: Cell<usize> = Cell::new(1);\n-const B: &Cell<usize> = &A;\n-// error: cannot borrow a constant which may contain interior mutability,\n-//        create a static instead\n-\n-// or:\n-struct C { a: Cell<usize> }\n-\n-const D: C = C { a: Cell::new(1) };\n-const E: &Cell<usize> = &D.a; // error\n-\n-// or:\n-const F: &C = &D; // error\n-```\n-\n-This is because cell types do operations that are not thread-safe. Due to this,\n-they don't implement Sync and thus can't be placed in statics.\n-\n-However, if you still wish to use these types, you can achieve this by an unsafe\n-wrapper:\n-\n-```\n-use std::cell::Cell;\n-use std::marker::Sync;\n-\n-struct NotThreadSafe<T> {\n-    value: Cell<T>,\n-}\n-\n-unsafe impl<T> Sync for NotThreadSafe<T> {}\n-\n-static A: NotThreadSafe<usize> = NotThreadSafe { value : Cell::new(1) };\n-static B: &'static NotThreadSafe<usize> = &A; // ok!\n-```\n-\n-Remember this solution is unsafe! You will have to ensure that accesses to the\n-cell are synchronized.\n-\"##,\n-\n-E0493: r##\"\n-A type with a `Drop` implementation was destructured when trying to initialize\n-a static item.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0493\n-enum DropType {\n-    A,\n-}\n-\n-impl Drop for DropType {\n-    fn drop(&mut self) {}\n-}\n-\n-struct Foo {\n-    field1: DropType,\n-}\n-\n-static FOO: Foo = Foo { ..Foo { field1: DropType::A } }; // error!\n-```\n-\n-The problem here is that if the given type or one of its fields implements the\n-`Drop` trait, this `Drop` implementation cannot be called during the static\n-type initialization which might cause a memory leak. To prevent this issue,\n-you need to instantiate all the static type's fields by hand.\n-\n-```\n-enum DropType {\n-    A,\n-}\n-\n-impl Drop for DropType {\n-    fn drop(&mut self) {}\n-}\n-\n-struct Foo {\n-    field1: DropType,\n-}\n-\n-static FOO: Foo = Foo { field1: DropType::A }; // We initialize all fields\n-                                               // by hand.\n-```\n-\"##,\n-\n-E0499: r##\"\n-A variable was borrowed as mutable more than once.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0499\n-let mut i = 0;\n-let mut x = &mut i;\n-let mut a = &mut i;\n-x;\n-// error: cannot borrow `i` as mutable more than once at a time\n-```\n-\n-Please note that in rust, you can either have many immutable references, or one\n-mutable reference. Take a look at\n-https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html for more\n-information. Example:\n-\n-\n-```\n-let mut i = 0;\n-let mut x = &mut i; // ok!\n-\n-// or:\n-let mut i = 0;\n-let a = &i; // ok!\n-let b = &i; // still ok!\n-let c = &i; // still ok!\n-b;\n-a;\n-```\n-\"##,\n-\n-E0500: r##\"\n-A borrowed variable was used by a closure.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0500\n-fn you_know_nothing(jon_snow: &mut i32) {\n-    let nights_watch = &jon_snow;\n-    let starks = || {\n-        *jon_snow = 3; // error: closure requires unique access to `jon_snow`\n-                       //        but it is already borrowed\n-    };\n-    println!(\"{}\", nights_watch);\n-}\n-```\n-\n-In here, `jon_snow` is already borrowed by the `nights_watch` reference, so it\n-cannot be borrowed by the `starks` closure at the same time. To fix this issue,\n-you can create the closure after the borrow has ended:\n-\n-```\n-fn you_know_nothing(jon_snow: &mut i32) {\n-    let nights_watch = &jon_snow;\n-    println!(\"{}\", nights_watch);\n-    let starks = || {\n-        *jon_snow = 3;\n-    };\n-}\n-```\n-\n-Or, if the type implements the `Clone` trait, you can clone it between\n-closures:\n-\n-```\n-fn you_know_nothing(jon_snow: &mut i32) {\n-    let mut jon_copy = jon_snow.clone();\n-    let starks = || {\n-        *jon_snow = 3;\n-    };\n-    println!(\"{}\", jon_copy);\n-}\n-```\n-\"##,\n-\n-E0501: r##\"\n-This error indicates that a mutable variable is being used while it is still\n-captured by a closure. Because the closure has borrowed the variable, it is not\n-available for use until the closure goes out of scope.\n-\n-Note that a capture will either move or borrow a variable, but in this\n-situation, the closure is borrowing the variable. Take a look at\n-http://rustbyexample.com/fn/closures/capture.html for more information about\n-capturing.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0501\n-fn inside_closure(x: &mut i32) {\n-    // Actions which require unique access\n-}\n-\n-fn outside_closure(x: &mut i32) {\n-    // Actions which require unique access\n-}\n-\n-fn foo(a: &mut i32) {\n-    let mut bar = || {\n-        inside_closure(a)\n-    };\n-    outside_closure(a); // error: cannot borrow `*a` as mutable because previous\n-                        //        closure requires unique access.\n-    bar();\n-}\n-```\n-\n-To fix this error, you can finish using the closure before using the captured\n-variable:\n-\n-```\n-fn inside_closure(x: &mut i32) {}\n-fn outside_closure(x: &mut i32) {}\n-\n-fn foo(a: &mut i32) {\n-    let mut bar = || {\n-        inside_closure(a)\n-    };\n-    bar();\n-    // borrow on `a` ends.\n-    outside_closure(a); // ok!\n-}\n-```\n-\n-Or you can pass the variable as a parameter to the closure:\n-\n-```\n-fn inside_closure(x: &mut i32) {}\n-fn outside_closure(x: &mut i32) {}\n-\n-fn foo(a: &mut i32) {\n-    let mut bar = |s: &mut i32| {\n-        inside_closure(s)\n-    };\n-    outside_closure(a);\n-    bar(a);\n-}\n-```\n-\n-It may be possible to define the closure later:\n-\n-```\n-fn inside_closure(x: &mut i32) {}\n-fn outside_closure(x: &mut i32) {}\n-\n-fn foo(a: &mut i32) {\n-    outside_closure(a);\n-    let mut bar = || {\n-        inside_closure(a)\n-    };\n-    bar();\n-}\n-```\n-\"##,\n-\n-E0502: r##\"\n-This error indicates that you are trying to borrow a variable as mutable when it\n-has already been borrowed as immutable.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0502\n-fn bar(x: &mut i32) {}\n-fn foo(a: &mut i32) {\n-    let ref y = a; // a is borrowed as immutable.\n-    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n-            //        as immutable\n-    println!(\"{}\", y);\n-}\n-```\n-\n-To fix this error, ensure that you don't have any other references to the\n-variable before trying to access it mutably:\n-\n-```\n-fn bar(x: &mut i32) {}\n-fn foo(a: &mut i32) {\n-    bar(a);\n-    let ref y = a; // ok!\n-    println!(\"{}\", y);\n-}\n-```\n-\n-For more information on the rust ownership system, take a look at\n-https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html.\n-\"##,\n-\n-E0503: r##\"\n-A value was used after it was mutably borrowed.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0503\n-fn main() {\n-    let mut value = 3;\n-    // Create a mutable borrow of `value`.\n-    let borrow = &mut value;\n-    let _sum = value + 1; // error: cannot use `value` because\n-                          //        it was mutably borrowed\n-    println!(\"{}\", borrow);\n-}\n-```\n-\n-In this example, `value` is mutably borrowed by `borrow` and cannot be\n-used to calculate `sum`. This is not possible because this would violate\n-Rust's mutability rules.\n-\n-You can fix this error by finishing using the borrow before the next use of\n-the value:\n-\n-```\n-fn main() {\n-    let mut value = 3;\n-    let borrow = &mut value;\n-    println!(\"{}\", borrow);\n-    // The block has ended and with it the borrow.\n-    // You can now use `value` again.\n-    let _sum = value + 1;\n-}\n-```\n-\n-Or by cloning `value` before borrowing it:\n-\n-```\n-fn main() {\n-    let mut value = 3;\n-    // We clone `value`, creating a copy.\n-    let value_cloned = value.clone();\n-    // The mutable borrow is a reference to `value` and\n-    // not to `value_cloned`...\n-    let borrow = &mut value;\n-    // ... which means we can still use `value_cloned`,\n-    let _sum = value_cloned + 1;\n-    // even though the borrow only ends here.\n-    println!(\"{}\", borrow);\n-}\n-```\n-\n-You can find more information about borrowing in the rust-book:\n-http://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n-\"##,\n-\n-E0504: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-This error occurs when an attempt is made to move a borrowed variable into a\n-closure.\n-\n-Erroneous code example:\n-\n-```compile_fail\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let fancy_num = FancyNum { num: 5 };\n-    let fancy_ref = &fancy_num;\n-\n-    let x = move || {\n-        println!(\"child function: {}\", fancy_num.num);\n-        // error: cannot move `fancy_num` into closure because it is borrowed\n-    };\n-\n-    x();\n-    println!(\"main function: {}\", fancy_ref.num);\n-}\n-```\n-\n-Here, `fancy_num` is borrowed by `fancy_ref` and so cannot be moved into\n-the closure `x`. There is no way to move a value into a closure while it is\n-borrowed, as that would invalidate the borrow.\n-\n-If the closure can't outlive the value being moved, try using a reference\n-rather than moving:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let fancy_num = FancyNum { num: 5 };\n-    let fancy_ref = &fancy_num;\n-\n-    let x = move || {\n-        // fancy_ref is usable here because it doesn't move `fancy_num`\n-        println!(\"child function: {}\", fancy_ref.num);\n-    };\n-\n-    x();\n-\n-    println!(\"main function: {}\", fancy_num.num);\n-}\n-```\n-\n-If the value has to be borrowed and then moved, try limiting the lifetime of\n-the borrow using a scoped block:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let fancy_num = FancyNum { num: 5 };\n-\n-    {\n-        let fancy_ref = &fancy_num;\n-        println!(\"main function: {}\", fancy_ref.num);\n-        // `fancy_ref` goes out of scope here\n-    }\n-\n-    let x = move || {\n-        // `fancy_num` can be moved now (no more references exist)\n-        println!(\"child function: {}\", fancy_num.num);\n-    };\n-\n-    x();\n-}\n-```\n-\n-If the lifetime of a reference isn't enough, such as in the case of threading,\n-consider using an `Arc` to create a reference-counted value:\n-\n-```\n-use std::sync::Arc;\n-use std::thread;\n-\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let fancy_ref1 = Arc::new(FancyNum { num: 5 });\n-    let fancy_ref2 = fancy_ref1.clone();\n-\n-    let x = thread::spawn(move || {\n-        // `fancy_ref1` can be moved and has a `'static` lifetime\n-        println!(\"child thread: {}\", fancy_ref1.num);\n-    });\n-\n-    x.join().expect(\"child thread should finish\");\n-    println!(\"main thread: {}\", fancy_ref2.num);\n-}\n-```\n-\"##,\n-\n-E0505: r##\"\n-A value was moved out while it was still borrowed.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0505\n-struct Value {}\n-\n-fn borrow(val: &Value) {}\n-\n-fn eat(val: Value) {}\n-\n-fn main() {\n-    let x = Value{};\n-    let _ref_to_val: &Value = &x;\n-    eat(x);\n-    borrow(_ref_to_val);\n-}\n-```\n-\n-Here, the function `eat` takes ownership of `x`. However,\n-`x` cannot be moved because the borrow to `_ref_to_val`\n-needs to last till the function `borrow`.\n-To fix that you can do a few different things:\n-\n-* Try to avoid moving the variable.\n-* Release borrow before move.\n-* Implement the `Copy` trait on the type.\n-\n-Examples:\n-\n-```\n-struct Value {}\n-\n-fn borrow(val: &Value) {}\n-\n-fn eat(val: &Value) {}\n-\n-fn main() {\n-    let x = Value{};\n-\n-    let ref_to_val: &Value = &x;\n-    eat(&x); // pass by reference, if it's possible\n-    borrow(ref_to_val);\n-}\n-```\n-\n-Or:\n-\n-```\n-struct Value {}\n-\n-fn borrow(val: &Value) {}\n-\n-fn eat(val: Value) {}\n-\n-fn main() {\n-    let x = Value{};\n-\n-    let ref_to_val: &Value = &x;\n-    borrow(ref_to_val);\n-    // ref_to_val is no longer used.\n-    eat(x);\n-}\n-```\n-\n-Or:\n-\n-```\n-#[derive(Clone, Copy)] // implement Copy trait\n-struct Value {}\n-\n-fn borrow(val: &Value) {}\n-\n-fn eat(val: Value) {}\n-\n-fn main() {\n-    let x = Value{};\n-    let ref_to_val: &Value = &x;\n-    eat(x); // it will be copied here.\n-    borrow(ref_to_val);\n-}\n-```\n-\n-You can find more information about borrowing in the rust-book:\n-http://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n-\"##,\n-\n-E0506: r##\"\n-This error occurs when an attempt is made to assign to a borrowed value.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0506\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy_num = FancyNum { num: 5 };\n-    let fancy_ref = &fancy_num;\n-    fancy_num = FancyNum { num: 6 };\n-    // error: cannot assign to `fancy_num` because it is borrowed\n-\n-    println!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n-}\n-```\n-\n-Because `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\n-be assigned to a new value as it would invalidate the reference.\n-\n-Alternatively, we can move out of `fancy_num` into a second `fancy_num`:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy_num = FancyNum { num: 5 };\n-    let moved_num = fancy_num;\n-    fancy_num = FancyNum { num: 6 };\n-\n-    println!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n-}\n-```\n-\n-If the value has to be borrowed, try limiting the lifetime of the borrow using\n-a scoped block:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy_num = FancyNum { num: 5 };\n-\n-    {\n-        let fancy_ref = &fancy_num;\n-        println!(\"Ref: {}\", fancy_ref.num);\n-    }\n-\n-    // Works because `fancy_ref` is no longer in scope\n-    fancy_num = FancyNum { num: 6 };\n-    println!(\"Num: {}\", fancy_num.num);\n-}\n-```\n-\n-Or by moving the reference into a function:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy_num = FancyNum { num: 5 };\n-\n-    print_fancy_ref(&fancy_num);\n-\n-    // Works because function borrow has ended\n-    fancy_num = FancyNum { num: 6 };\n-    println!(\"Num: {}\", fancy_num.num);\n-}\n-\n-fn print_fancy_ref(fancy_ref: &FancyNum){\n-    println!(\"Ref: {}\", fancy_ref.num);\n-}\n-```\n-\"##,\n-\n-E0507: r##\"\n-You tried to move out of a value which was borrowed.\n-\n-This can also happen when using a type implementing `Fn` or `FnMut`, as neither\n-allows moving out of them (they usually represent closures which can be called\n-more than once). Much of the text following applies equally well to non-`FnOnce`\n-closure bodies.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0507\n-use std::cell::RefCell;\n-\n-struct TheDarkKnight;\n-\n-impl TheDarkKnight {\n-    fn nothing_is_true(self) {}\n-}\n-\n-fn main() {\n-    let x = RefCell::new(TheDarkKnight);\n-\n-    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content\n-}\n-```\n-\n-Here, the `nothing_is_true` method takes the ownership of `self`. However,\n-`self` cannot be moved because `.borrow()` only provides an `&TheDarkKnight`,\n-which is a borrow of the content owned by the `RefCell`. To fix this error,\n-you have three choices:\n-\n-* Try to avoid moving the variable.\n-* Somehow reclaim the ownership.\n-* Implement the `Copy` trait on the type.\n-\n-Examples:\n-\n-```\n-use std::cell::RefCell;\n-\n-struct TheDarkKnight;\n-\n-impl TheDarkKnight {\n-    fn nothing_is_true(&self) {} // First case, we don't take ownership\n-}\n-\n-fn main() {\n-    let x = RefCell::new(TheDarkKnight);\n-\n-    x.borrow().nothing_is_true(); // ok!\n-}\n-```\n-\n-Or:\n-\n-```\n-use std::cell::RefCell;\n-\n-struct TheDarkKnight;\n-\n-impl TheDarkKnight {\n-    fn nothing_is_true(self) {}\n-}\n-\n-fn main() {\n-    let x = RefCell::new(TheDarkKnight);\n-    let x = x.into_inner(); // we get back ownership\n-\n-    x.nothing_is_true(); // ok!\n-}\n-```\n-\n-Or:\n-\n-```\n-use std::cell::RefCell;\n-\n-#[derive(Clone, Copy)] // we implement the Copy trait\n-struct TheDarkKnight;\n-\n-impl TheDarkKnight {\n-    fn nothing_is_true(self) {}\n-}\n-\n-fn main() {\n-    let x = RefCell::new(TheDarkKnight);\n-\n-    x.borrow().nothing_is_true(); // ok!\n-}\n-```\n-\n-Moving a member out of a mutably borrowed struct will also cause E0507 error:\n-\n-```compile_fail,E0507\n-struct TheDarkKnight;\n-\n-impl TheDarkKnight {\n-    fn nothing_is_true(self) {}\n-}\n-\n-struct Batcave {\n-    knight: TheDarkKnight\n-}\n-\n-fn main() {\n-    let mut cave = Batcave {\n-        knight: TheDarkKnight\n-    };\n-    let borrowed = &mut cave;\n-\n-    borrowed.knight.nothing_is_true(); // E0507\n-}\n-```\n-\n-It is fine only if you put something back. `mem::replace` can be used for that:\n-\n-```\n-# struct TheDarkKnight;\n-# impl TheDarkKnight { fn nothing_is_true(self) {} }\n-# struct Batcave { knight: TheDarkKnight }\n-use std::mem;\n-\n-let mut cave = Batcave {\n-    knight: TheDarkKnight\n-};\n-let borrowed = &mut cave;\n-\n-mem::replace(&mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!\n-```\n-\n-You can find more information about borrowing in the rust-book:\n-http://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n-\"##,\n-\n-E0508: r##\"\n-A value was moved out of a non-copy fixed-size array.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0508\n-struct NonCopy;\n-\n-fn main() {\n-    let array = [NonCopy; 1];\n-    let _value = array[0]; // error: cannot move out of type `[NonCopy; 1]`,\n-                           //        a non-copy fixed-size array\n-}\n-```\n-\n-The first element was moved out of the array, but this is not\n-possible because `NonCopy` does not implement the `Copy` trait.\n-\n-Consider borrowing the element instead of moving it:\n-\n-```\n-struct NonCopy;\n-\n-fn main() {\n-    let array = [NonCopy; 1];\n-    let _value = &array[0]; // Borrowing is allowed, unlike moving.\n-}\n-```\n-\n-Alternatively, if your type implements `Clone` and you need to own the value,\n-consider borrowing and then cloning:\n-\n-```\n-#[derive(Clone)]\n-struct NonCopy;\n-\n-fn main() {\n-    let array = [NonCopy; 1];\n-    // Now you can clone the array element.\n-    let _value = array[0].clone();\n-}\n-```\n-\"##,\n-\n-E0509: r##\"\n-This error occurs when an attempt is made to move out of a value whose type\n-implements the `Drop` trait.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0509\n-struct FancyNum {\n-    num: usize\n-}\n-\n-struct DropStruct {\n-    fancy: FancyNum\n-}\n-\n-impl Drop for DropStruct {\n-    fn drop(&mut self) {\n-        // Destruct DropStruct, possibly using FancyNum\n-    }\n-}\n-\n-fn main() {\n-    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};\n-    let fancy_field = drop_struct.fancy; // Error E0509\n-    println!(\"Fancy: {}\", fancy_field.num);\n-    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope\n-}\n-```\n-\n-Here, we tried to move a field out of a struct of type `DropStruct` which\n-implements the `Drop` trait. However, a struct cannot be dropped if one or\n-more of its fields have been moved.\n-\n-Structs implementing the `Drop` trait have an implicit destructor that gets\n-called when they go out of scope. This destructor may use the fields of the\n-struct, so moving out of the struct could make it impossible to run the\n-destructor. Therefore, we must think of all values whose type implements the\n-`Drop` trait as single units whose fields cannot be moved.\n-\n-This error can be fixed by creating a reference to the fields of a struct,\n-enum, or tuple using the `ref` keyword:\n-\n-```\n-struct FancyNum {\n-    num: usize\n-}\n-\n-struct DropStruct {\n-    fancy: FancyNum\n-}\n-\n-impl Drop for DropStruct {\n-    fn drop(&mut self) {\n-        // Destruct DropStruct, possibly using FancyNum\n-    }\n-}\n-\n-fn main() {\n-    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};\n-    let ref fancy_field = drop_struct.fancy; // No more errors!\n-    println!(\"Fancy: {}\", fancy_field.num);\n-    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope\n-}\n-```\n-\n-Note that this technique can also be used in the arms of a match expression:\n-\n-```\n-struct FancyNum {\n-    num: usize\n-}\n-\n-enum DropEnum {\n-    Fancy(FancyNum)\n-}\n-\n-impl Drop for DropEnum {\n-    fn drop(&mut self) {\n-        // Destruct DropEnum, possibly using FancyNum\n-    }\n-}\n-\n-fn main() {\n-    // Creates and enum of type `DropEnum`, which implements `Drop`\n-    let drop_enum = DropEnum::Fancy(FancyNum{num: 10});\n-    match drop_enum {\n-        // Creates a reference to the inside of `DropEnum::Fancy`\n-        DropEnum::Fancy(ref fancy_field) => // No error!\n-            println!(\"It was fancy-- {}!\", fancy_field.num),\n-    }\n-    // implicit call to `drop_enum.drop()` as drop_enum goes out of scope\n-}\n-```\n-\"##,\n-\n-E0510: r##\"\n-Cannot mutate place in this match guard.\n-\n-When matching on a variable it cannot be mutated in the match guards, as this\n-could cause the match to be non-exhaustive:\n-\n-```compile_fail,E0510\n-let mut x = Some(0);\n-match x {\n-    None => (),\n-    Some(_) if { x = None; false } => (),\n-    Some(v) => (), // No longer matches\n-}\n-```\n-\n-Here executing `x = None` would modify the value being matched and require us\n-to go \"back in time\" to the `None` arm.\n-\"##,\n-\n-E0515: r##\"\n-Cannot return value that references local variable\n-\n-Local variables, function parameters and temporaries are all dropped before the\n-end of the function body. So a reference to them cannot be returned.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0515\n-fn get_dangling_reference() -> &'static i32 {\n-    let x = 0;\n-    &x\n-}\n-```\n-\n-```compile_fail,E0515\n-use std::slice::Iter;\n-fn get_dangling_iterator<'a>() -> Iter<'a, i32> {\n-    let v = vec![1, 2, 3];\n-    v.iter()\n-}\n-```\n-\n-Consider returning an owned value instead:\n-\n-```\n-use std::vec::IntoIter;\n-\n-fn get_integer() -> i32 {\n-    let x = 0;\n-    x\n-}\n-\n-fn get_owned_iterator() -> IntoIter<i32> {\n-    let v = vec![1, 2, 3];\n-    v.into_iter()\n-}\n-```\n-\"##,\n-\n-E0524: r##\"\n-A variable which requires unique access is being used in more than one closure\n-at the same time.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0524\n-fn set(x: &mut isize) {\n-    *x += 4;\n-}\n-\n-fn dragoooon(x: &mut isize) {\n-    let mut c1 = || set(x);\n-    let mut c2 = || set(x); // error!\n-\n-    c2();\n-    c1();\n-}\n-```\n-\n-To solve this issue, multiple solutions are available. First, is it required\n-for this variable to be used in more than one closure at a time? If it is the\n-case, use reference counted types such as `Rc` (or `Arc` if it runs\n-concurrently):\n-\n-```\n-use std::rc::Rc;\n-use std::cell::RefCell;\n-\n-fn set(x: &mut isize) {\n-    *x += 4;\n-}\n-\n-fn dragoooon(x: &mut isize) {\n-    let x = Rc::new(RefCell::new(x));\n-    let y = Rc::clone(&x);\n-    let mut c1 = || { let mut x2 = x.borrow_mut(); set(&mut x2); };\n-    let mut c2 = || { let mut x2 = y.borrow_mut(); set(&mut x2); }; // ok!\n-\n-    c2();\n-    c1();\n-}\n-```\n-\n-If not, just run closures one at a time:\n-\n-```\n-fn set(x: &mut isize) {\n-    *x += 4;\n-}\n-\n-fn dragoooon(x: &mut isize) {\n-    { // This block isn't necessary since non-lexical lifetimes, it's just to\n-      // make it more clear.\n-        let mut c1 = || set(&mut *x);\n-        c1();\n-    } // `c1` has been dropped here so we're free to use `x` again!\n-    let mut c2 = || set(&mut *x);\n-    c2();\n-}\n-```\n-\"##,\n-\n-E0579: r##\"\n-When matching against an exclusive range, the compiler verifies that the range\n-is non-empty. Exclusive range patterns include the start point but not the end\n-point, so this is equivalent to requiring the start of the range to be less\n-than the end of the range.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0579\n-#![feature(exclusive_range_pattern)]\n-\n-fn main() {\n-    match 5u32 {\n-        // This range is ok, albeit pointless.\n-        1 .. 2 => {}\n-        // This range is empty, and the compiler can tell.\n-        5 .. 5 => {} // error!\n-    }\n-}\n-```\n-\"##,\n-\n-E0595: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-Closures cannot mutate immutable captured variables.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0594\n-let x = 3; // error: closure cannot assign to immutable local variable `x`\n-let mut c = || { x += 1 };\n-```\n-\n-Make the variable binding mutable:\n-\n-```\n-let mut x = 3; // ok!\n-let mut c = || { x += 1 };\n-```\n-\"##,\n-\n-E0596: r##\"\n-This error occurs because you tried to mutably borrow a non-mutable variable.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0596\n-let x = 1;\n-let y = &mut x; // error: cannot borrow mutably\n-```\n-\n-In here, `x` isn't mutable, so when we try to mutably borrow it in `y`, it\n-fails. To fix this error, you need to make `x` mutable:\n-\n-```\n-let mut x = 1;\n-let y = &mut x; // ok!\n-```\n-\"##,\n-\n-E0597: r##\"\n-This error occurs because a value was dropped while it was still borrowed\n-\n-Erroneous code example:\n-\n-```compile_fail,E0597\n-struct Foo<'a> {\n-    x: Option<&'a u32>,\n-}\n-\n-let mut x = Foo { x: None };\n-{\n-    let y = 0;\n-    x.x = Some(&y); // error: `y` does not live long enough\n-}\n-println!(\"{:?}\", x.x);\n-```\n-\n-In here, `y` is dropped at the end of the inner scope, but it is borrowed by\n-`x` until the `println`. To fix the previous example, just remove the scope\n-so that `y` isn't dropped until after the println\n-\n-```\n-struct Foo<'a> {\n-    x: Option<&'a u32>,\n-}\n-\n-let mut x = Foo { x: None };\n-\n-let y = 0;\n-x.x = Some(&y);\n-\n-println!(\"{:?}\", x.x);\n-```\n-\"##,\n-\n-E0626: r##\"\n-This error occurs because a borrow in a generator persists across a\n-yield point.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0626\n-# #![feature(generators, generator_trait, pin)]\n-# use std::ops::Generator;\n-# use std::pin::Pin;\n-let mut b = || {\n-    let a = &String::new(); // <-- This borrow...\n-    yield (); // ...is still in scope here, when the yield occurs.\n-    println!(\"{}\", a);\n-};\n-Pin::new(&mut b).resume();\n-```\n-\n-At present, it is not permitted to have a yield that occurs while a\n-borrow is still in scope. To resolve this error, the borrow must\n-either be \"contained\" to a smaller scope that does not overlap the\n-yield or else eliminated in another way. So, for example, we might\n-resolve the previous example by removing the borrow and just storing\n-the integer by value:\n-\n-```\n-# #![feature(generators, generator_trait, pin)]\n-# use std::ops::Generator;\n-# use std::pin::Pin;\n-let mut b = || {\n-    let a = 3;\n-    yield ();\n-    println!(\"{}\", a);\n-};\n-Pin::new(&mut b).resume();\n-```\n-\n-This is a very simple case, of course. In more complex cases, we may\n-wish to have more than one reference to the value that was borrowed --\n-in those cases, something like the `Rc` or `Arc` types may be useful.\n-\n-This error also frequently arises with iteration:\n-\n-```compile_fail,E0626\n-# #![feature(generators, generator_trait, pin)]\n-# use std::ops::Generator;\n-# use std::pin::Pin;\n-let mut b = || {\n-  let v = vec![1,2,3];\n-  for &x in &v { // <-- borrow of `v` is still in scope...\n-    yield x; // ...when this yield occurs.\n-  }\n-};\n-Pin::new(&mut b).resume();\n-```\n-\n-Such cases can sometimes be resolved by iterating \"by value\" (or using\n-`into_iter()`) to avoid borrowing:\n-\n-```\n-# #![feature(generators, generator_trait, pin)]\n-# use std::ops::Generator;\n-# use std::pin::Pin;\n-let mut b = || {\n-  let v = vec![1,2,3];\n-  for x in v { // <-- Take ownership of the values instead!\n-    yield x; // <-- Now yield is OK.\n-  }\n-};\n-Pin::new(&mut b).resume();\n-```\n-\n-If taking ownership is not an option, using indices can work too:\n-\n-```\n-# #![feature(generators, generator_trait, pin)]\n-# use std::ops::Generator;\n-# use std::pin::Pin;\n-let mut b = || {\n-  let v = vec![1,2,3];\n-  let len = v.len(); // (*)\n-  for i in 0..len {\n-    let x = v[i]; // (*)\n-    yield x; // <-- Now yield is OK.\n-  }\n-};\n-Pin::new(&mut b).resume();\n-\n-// (*) -- Unfortunately, these temporaries are currently required.\n-// See <https://github.com/rust-lang/rust/issues/43122>.\n-```\n-\"##,\n-\n-E0712: r##\"\n-This error occurs because a borrow of a thread-local variable was made inside a\n-function which outlived the lifetime of the function.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0712\n-#![feature(thread_local)]\n-\n-#[thread_local]\n-static FOO: u8 = 3;\n-\n-fn main() {\n-    let a = &FOO; // error: thread-local variable borrowed past end of function\n-\n-    std::thread::spawn(move || {\n-        println!(\"{}\", a);\n-    });\n-}\n-```\n-\"##,\n-\n-E0713: r##\"\n-This error occurs when an attempt is made to borrow state past the end of the\n-lifetime of a type that implements the `Drop` trait.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0713\n-#![feature(nll)]\n-\n-pub struct S<'a> { data: &'a mut String }\n-\n-impl<'a> Drop for S<'a> {\n-    fn drop(&mut self) { self.data.push_str(\"being dropped\"); }\n-}\n-\n-fn demo<'a>(s: S<'a>) -> &'a mut String { let p = &mut *s.data; p }\n-```\n-\n-Here, `demo` tries to borrow the string data held within its\n-argument `s` and then return that borrow. However, `S` is\n-declared as implementing `Drop`.\n-\n-Structs implementing the `Drop` trait have an implicit destructor that\n-gets called when they go out of scope. This destructor gets exclusive\n-access to the fields of the struct when it runs.\n-\n-This means that when `s` reaches the end of `demo`, its destructor\n-gets exclusive access to its `&mut`-borrowed string data.  allowing\n-another borrow of that string data (`p`), to exist across the drop of\n-`s` would be a violation of the principle that `&mut`-borrows have\n-exclusive, unaliased access to their referenced data.\n-\n-This error can be fixed by changing `demo` so that the destructor does\n-not run while the string-data is borrowed; for example by taking `S`\n-by reference:\n-\n-```\n-pub struct S<'a> { data: &'a mut String }\n-\n-impl<'a> Drop for S<'a> {\n-    fn drop(&mut self) { self.data.push_str(\"being dropped\"); }\n-}\n-\n-fn demo<'a>(s: &'a mut S<'a>) -> &'a mut String { let p = &mut *(*s).data; p }\n-```\n-\n-Note that this approach needs a reference to S with lifetime `'a`.\n-Nothing shorter than `'a` will suffice: a shorter lifetime would imply\n-that after `demo` finishes executing, something else (such as the\n-destructor!) could access `s.data` after the end of that shorter\n-lifetime, which would again violate the `&mut`-borrow's exclusive\n-access.\n-\"##,\n-\n-E0716: r##\"\n-This error indicates that a temporary value is being dropped\n-while a borrow is still in active use.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0716\n-fn foo() -> i32 { 22 }\n-fn bar(x: &i32) -> &i32 { x }\n-let p = bar(&foo());\n-         // ------ creates a temporary\n-let q = *p;\n-```\n-\n-Here, the expression `&foo()` is borrowing the expression\n-`foo()`. As `foo()` is a call to a function, and not the name of\n-a variable, this creates a **temporary** -- that temporary stores\n-the return value from `foo()` so that it can be borrowed.\n-You could imagine that `let p = bar(&foo());` is equivalent\n-to this:\n-\n-```compile_fail,E0597\n-# fn foo() -> i32 { 22 }\n-# fn bar(x: &i32) -> &i32 { x }\n-let p = {\n-  let tmp = foo(); // the temporary\n-  bar(&tmp)\n-}; // <-- tmp is freed as we exit this block\n-let q = p;\n-```\n-\n-Whenever a temporary is created, it is automatically dropped (freed)\n-according to fixed rules. Ordinarily, the temporary is dropped\n-at the end of the enclosing statement -- in this case, after the `let`.\n-This is illustrated in the example above by showing that `tmp` would\n-be freed as we exit the block.\n-\n-To fix this problem, you need to create a local variable\n-to store the value in rather than relying on a temporary.\n-For example, you might change the original program to\n-the following:\n-\n-```\n-fn foo() -> i32 { 22 }\n-fn bar(x: &i32) -> &i32 { x }\n-let value = foo(); // dropped at the end of the enclosing block\n-let p = bar(&value);\n-let q = *p;\n-```\n-\n-By introducing the explicit `let value`, we allocate storage\n-that will last until the end of the enclosing block (when `value`\n-goes out of scope). When we borrow `&value`, we are borrowing a\n-local variable that already exists, and hence no temporary is created.\n-\n-Temporaries are not always dropped at the end of the enclosing\n-statement. In simple cases where the `&` expression is immediately\n-stored into a variable, the compiler will automatically extend\n-the lifetime of the temporary until the end of the enclosing\n-block. Therefore, an alternative way to fix the original\n-program is to write `let tmp = &foo()` and not `let tmp = foo()`:\n-\n-```\n-fn foo() -> i32 { 22 }\n-fn bar(x: &i32) -> &i32 { x }\n-let value = &foo();\n-let p = bar(value);\n-let q = *p;\n-```\n-\n-Here, we are still borrowing `foo()`, but as the borrow is assigned\n-directly into a variable, the temporary will not be dropped until\n-the end of the enclosing block. Similar rules apply when temporaries\n-are stored into aggregate structures like a tuple or struct:\n-\n-```\n-// Here, two temporaries are created, but\n-// as they are stored directly into `value`,\n-// they are not dropped until the end of the\n-// enclosing block.\n-fn foo() -> i32 { 22 }\n-let value = (&foo(), &foo());\n-```\n-\"##,\n-\n-E0723: r##\"\n-An feature unstable in `const` contexts was used.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0723\n-trait T {}\n-\n-impl T for () {}\n-\n-const fn foo() -> impl T { // error: `impl Trait` in const fn is unstable\n-    ()\n-}\n-```\n-\n-To enable this feature on a nightly version of rustc, add the `const_fn`\n-feature flag:\n-\n-```\n-#![feature(const_fn)]\n-\n-trait T {}\n-\n-impl T for () {}\n-\n-const fn foo() -> impl T {\n-    ()\n-}\n-```\n-\"##,\n-\n-E0729: r##\"\n-Support for Non-Lexical Lifetimes (NLL) has been included in the Rust compiler\n-since 1.31, and has been enabled on the 2015 edition since 1.36. The new borrow\n-checker for NLL uncovered some bugs in the old borrow checker, which in some\n-cases allowed unsound code to compile, resulting in memory safety issues.\n-\n-### What do I do?\n-\n-Change your code so the warning does no longer trigger. For backwards\n-compatibility, this unsound code may still compile (with a warning) right now.\n-However, at some point in the future, the compiler will no longer accept this\n-code and will throw a hard error.\n-\n-### Shouldn't you fix the old borrow checker?\n-\n-The old borrow checker has known soundness issues that are basically impossible\n-to fix. The new NLL-based borrow checker is the fix.\n-\n-### Can I turn these warnings into errors by denying a lint?\n-\n-No.\n-\n-### When are these warnings going to turn into errors?\n-\n-No formal timeline for turning the warnings into errors has been set. See\n-[GitHub issue 58781](https://github.com/rust-lang/rust/issues/58781) for more\n-information.\n-\n-### Why do I get this message with code that doesn't involve borrowing?\n-\n-There are some known bugs that trigger this message.\n-\"##,\n-\n-;\n-\n-//  E0008, // cannot bind by-move into a pattern guard\n-//  E0298, // cannot compare constants\n-//  E0299, // mismatched types between arms\n-//  E0471, // constant evaluation error (in pattern)\n-//  E0385, // {} in an aliasable location\n-    E0521, // borrowed data escapes outside of closure\n-//  E0526, // shuffle indices are not constant\n-    E0594, // cannot assign to {}\n-//  E0598, // lifetime of {} is too short to guarantee its contents can be...\n-    E0625, // thread-local statics cannot be accessed at compile-time\n-}"}, {"sha": "cf74e09a3772d3d567108cf67bbe89671934f2f4", "filename": "src/librustc_parse/error_codes.rs", "status": "removed", "additions": 0, "deletions": 174, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/798e389e578a0199f734c79424fa39e440910979/src%2Flibrustc_parse%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/798e389e578a0199f734c79424fa39e440910979/src%2Flibrustc_parse%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Ferror_codes.rs?ref=798e389e578a0199f734c79424fa39e440910979", "patch": "@@ -1,174 +0,0 @@\n-// Error messages for EXXXX errors.\n-// Each message should start and end with a new line, and be wrapped to 80\n-// characters.  In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use\n-// `:set tw=0` to disable.\n-syntax::register_diagnostics! {\n-\n-E0178: r##\"\n-In types, the `+` type operator has low precedence, so it is often necessary\n-to use parentheses.\n-\n-For example:\n-\n-```compile_fail,E0178\n-trait Foo {}\n-\n-struct Bar<'a> {\n-    w: &'a Foo + Copy,   // error, use &'a (Foo + Copy)\n-    x: &'a Foo + 'a,     // error, use &'a (Foo + 'a)\n-    y: &'a mut Foo + 'a, // error, use &'a mut (Foo + 'a)\n-    z: fn() -> Foo + 'a, // error, use fn() -> (Foo + 'a)\n-}\n-```\n-\n-More details can be found in [RFC 438].\n-\n-[RFC 438]: https://github.com/rust-lang/rfcs/pull/438\n-\"##,\n-\n-E0583: r##\"\n-A file wasn't found for an out-of-line module.\n-\n-Erroneous code example:\n-\n-```ignore (compile_fail not working here; see Issue #43707)\n-mod file_that_doesnt_exist; // error: file not found for module\n-\n-fn main() {}\n-```\n-\n-Please be sure that a file corresponding to the module exists. If you\n-want to use a module named `file_that_doesnt_exist`, you need to have a file\n-named `file_that_doesnt_exist.rs` or `file_that_doesnt_exist/mod.rs` in the\n-same directory.\n-\"##,\n-\n-E0584: r##\"\n-A doc comment that is not attached to anything has been encountered.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0584\n-trait Island {\n-    fn lost();\n-\n-    /// I'm lost!\n-}\n-```\n-\n-A little reminder: a doc comment has to be placed before the item it's supposed\n-to document. So if you want to document the `Island` trait, you need to put a\n-doc comment before it, not inside it. Same goes for the `lost` method: the doc\n-comment needs to be before it:\n-\n-```\n-/// I'm THE island!\n-trait Island {\n-    /// I'm lost!\n-    fn lost();\n-}\n-```\n-\"##,\n-\n-E0585: r##\"\n-A documentation comment that doesn't document anything was found.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0585\n-fn main() {\n-    // The following doc comment will fail:\n-    /// This is a useless doc comment!\n-}\n-```\n-\n-Documentation comments need to be followed by items, including functions,\n-types, modules, etc. Examples:\n-\n-```\n-/// I'm documenting the following struct:\n-struct Foo;\n-\n-/// I'm documenting the following function:\n-fn foo() {}\n-```\n-\"##,\n-\n-E0586: r##\"\n-An inclusive range was used with no end.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0586\n-fn main() {\n-    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n-    let x = &tmp[1..=]; // error: inclusive range was used with no end\n-}\n-```\n-\n-An inclusive range needs an end in order to *include* it. If you just need a\n-start and no end, use a non-inclusive range (with `..`):\n-\n-```\n-fn main() {\n-    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n-    let x = &tmp[1..]; // ok!\n-}\n-```\n-\n-Or put an end to your inclusive range:\n-\n-```\n-fn main() {\n-    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n-    let x = &tmp[1..=3]; // ok!\n-}\n-```\n-\"##,\n-\n-E0704: r##\"\n-This error indicates that a incorrect visibility restriction was specified.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0704\n-mod foo {\n-    pub(foo) struct Bar {\n-        x: i32\n-    }\n-}\n-```\n-\n-To make struct `Bar` only visible in module `foo` the `in` keyword should be\n-used:\n-```\n-mod foo {\n-    pub(in crate::foo) struct Bar {\n-        x: i32\n-    }\n-}\n-# fn main() {}\n-```\n-\n-For more information see the Rust Reference on [Visibility].\n-\n-[Visibility]: https://doc.rust-lang.org/reference/visibility-and-privacy.html\n-\"##,\n-\n-E0743: r##\"\n-C-variadic has been used on a non-foreign function.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0743\n-fn foo2(x: u8, ...) {} // error!\n-```\n-\n-Only foreign functions can use C-variadic (`...`). It is used to give an\n-undefined number of parameters to a given function (like `printf` in C). The\n-equivalent in Rust would be to use macros directly.\n-\"##,\n-\n-;\n-\n-}"}, {"sha": "72cf0c7ed77c8c0ac7603d9c1ba701b5b2fc33ee", "filename": "src/librustc_passes/error_codes.rs", "status": "removed", "additions": 0, "deletions": 657, "changes": 657, "blob_url": "https://github.com/rust-lang/rust/blob/798e389e578a0199f734c79424fa39e440910979/src%2Flibrustc_passes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/798e389e578a0199f734c79424fa39e440910979/src%2Flibrustc_passes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Ferror_codes.rs?ref=798e389e578a0199f734c79424fa39e440910979", "patch": "@@ -1,657 +0,0 @@\n-syntax::register_diagnostics! {\n-E0014: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-Constants can only be initialized by a constant value or, in a future\n-version of Rust, a call to a const function. This error indicates the use\n-of a path (like a::b, or x) denoting something other than one of these\n-allowed items.\n-\n-Erroneous code example:\n-\n-```\n-const FOO: i32 = { let x = 0; x }; // 'x' isn't a constant nor a function!\n-```\n-\n-To avoid it, you have to replace the non-constant value:\n-\n-```\n-const FOO: i32 = { const X : i32 = 0; X };\n-// or even:\n-const FOO2: i32 = { 0 }; // but brackets are useless here\n-```\n-\"##,\n-\n-E0130: r##\"\n-You declared a pattern as an argument in a foreign function declaration.\n-\n-Erroneous code example:\n-\n-```compile_fail\n-extern {\n-    fn foo((a, b): (u32, u32)); // error: patterns aren't allowed in foreign\n-                                //        function declarations\n-}\n-```\n-\n-Please replace the pattern argument with a regular one. Example:\n-\n-```\n-struct SomeStruct {\n-    a: u32,\n-    b: u32,\n-}\n-\n-extern {\n-    fn foo(s: SomeStruct); // ok!\n-}\n-```\n-\n-Or:\n-\n-```\n-extern {\n-    fn foo(a: (u32, u32)); // ok!\n-}\n-```\n-\"##,\n-\n-// This shouldn't really ever trigger since the repeated value error comes first\n-E0136: r##\"\n-A binary can only have one entry point, and by default that entry point is the\n-function `main()`. If there are multiple such functions, please rename one.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0136\n-fn main() {\n-    // ...\n-}\n-\n-// ...\n-\n-fn main() { // error!\n-    // ...\n-}\n-```\n-\"##,\n-\n-E0137: r##\"\n-More than one function was declared with the `#[main]` attribute.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0137\n-#![feature(main)]\n-\n-#[main]\n-fn foo() {}\n-\n-#[main]\n-fn f() {} // error: multiple functions with a `#[main]` attribute\n-```\n-\n-This error indicates that the compiler found multiple functions with the\n-`#[main]` attribute. This is an error because there must be a unique entry\n-point into a Rust program. Example:\n-\n-```\n-#![feature(main)]\n-\n-#[main]\n-fn f() {} // ok!\n-```\n-\"##,\n-\n-E0138: r##\"\n-More than one function was declared with the `#[start]` attribute.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0138\n-#![feature(start)]\n-\n-#[start]\n-fn foo(argc: isize, argv: *const *const u8) -> isize {}\n-\n-#[start]\n-fn f(argc: isize, argv: *const *const u8) -> isize {}\n-// error: multiple 'start' functions\n-```\n-\n-This error indicates that the compiler found multiple functions with the\n-`#[start]` attribute. This is an error because there must be a unique entry\n-point into a Rust program. Example:\n-\n-```\n-#![feature(start)]\n-\n-#[start]\n-fn foo(argc: isize, argv: *const *const u8) -> isize { 0 } // ok!\n-```\n-\"##,\n-\n-E0197: r##\"\n-Inherent implementations (one that do not implement a trait but provide\n-methods associated with a type) are always safe because they are not\n-implementing an unsafe trait. Removing the `unsafe` keyword from the inherent\n-implementation will resolve this error.\n-\n-```compile_fail,E0197\n-struct Foo;\n-\n-// this will cause this error\n-unsafe impl Foo { }\n-// converting it to this will fix it\n-impl Foo { }\n-```\n-\"##,\n-\n-E0198: r##\"\n-A negative implementation is one that excludes a type from implementing a\n-particular trait. Not being able to use a trait is always a safe operation,\n-so negative implementations are always safe and never need to be marked as\n-unsafe.\n-\n-```compile_fail\n-#![feature(optin_builtin_traits)]\n-\n-struct Foo;\n-\n-// unsafe is unnecessary\n-unsafe impl !Clone for Foo { }\n-```\n-\n-This will compile:\n-\n-```ignore (ignore auto_trait future compatibility warning)\n-#![feature(optin_builtin_traits)]\n-\n-struct Foo;\n-\n-auto trait Enterprise {}\n-\n-impl !Enterprise for Foo { }\n-```\n-\n-Please note that negative impls are only allowed for auto traits.\n-\"##,\n-\n-E0267: r##\"\n-This error indicates the use of a loop keyword (`break` or `continue`) inside a\n-closure but outside of any loop. Erroneous code example:\n-\n-```compile_fail,E0267\n-let w = || { break; }; // error: `break` inside of a closure\n-```\n-\n-`break` and `continue` keywords can be used as normal inside closures as long as\n-they are also contained within a loop. To halt the execution of a closure you\n-should instead use a return statement. Example:\n-\n-```\n-let w = || {\n-    for _ in 0..10 {\n-        break;\n-    }\n-};\n-\n-w();\n-```\n-\"##,\n-\n-E0268: r##\"\n-This error indicates the use of a loop keyword (`break` or `continue`) outside\n-of a loop. Without a loop to break out of or continue in, no sensible action can\n-be taken. Erroneous code example:\n-\n-```compile_fail,E0268\n-fn some_func() {\n-    break; // error: `break` outside of a loop\n-}\n-```\n-\n-Please verify that you are using `break` and `continue` only in loops. Example:\n-\n-```\n-fn some_func() {\n-    for _ in 0..10 {\n-        break; // ok!\n-    }\n-}\n-```\n-\"##,\n-\n-E0379: r##\"\n-Trait methods cannot be declared `const` by design. For more information, see\n-[RFC 911].\n-\n-[RFC 911]: https://github.com/rust-lang/rfcs/pull/911\n-\"##,\n-\n-E0380: r##\"\n-Auto traits cannot have methods or associated items.\n-For more information see the [opt-in builtin traits RFC][RFC 19].\n-\n-[RFC 19]: https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md\n-\"##,\n-\n-E0449: r##\"\n-A visibility qualifier was used when it was unnecessary. Erroneous code\n-examples:\n-\n-```compile_fail,E0449\n-struct Bar;\n-\n-trait Foo {\n-    fn foo();\n-}\n-\n-pub impl Bar {} // error: unnecessary visibility qualifier\n-\n-pub impl Foo for Bar { // error: unnecessary visibility qualifier\n-    pub fn foo() {} // error: unnecessary visibility qualifier\n-}\n-```\n-\n-To fix this error, please remove the visibility qualifier when it is not\n-required. Example:\n-\n-```\n-struct Bar;\n-\n-trait Foo {\n-    fn foo();\n-}\n-\n-// Directly implemented methods share the visibility of the type itself,\n-// so `pub` is unnecessary here\n-impl Bar {}\n-\n-// Trait methods share the visibility of the trait, so `pub` is\n-// unnecessary in either case\n-impl Foo for Bar {\n-    fn foo() {}\n-}\n-```\n-\"##,\n-\n-E0512: r##\"\n-Transmute with two differently sized types was attempted. Erroneous code\n-example:\n-\n-```compile_fail,E0512\n-fn takes_u8(_: u8) {}\n-\n-fn main() {\n-    unsafe { takes_u8(::std::mem::transmute(0u16)); }\n-    // error: cannot transmute between types of different sizes,\n-    //        or dependently-sized types\n-}\n-```\n-\n-Please use types with same size or use the expected type directly. Example:\n-\n-```\n-fn takes_u8(_: u8) {}\n-\n-fn main() {\n-    unsafe { takes_u8(::std::mem::transmute(0i8)); } // ok!\n-    // or:\n-    unsafe { takes_u8(0u8); } // ok!\n-}\n-```\n-\"##,\n-\n-E0561: r##\"\n-A non-ident or non-wildcard pattern has been used as a parameter of a function\n-pointer type.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0561\n-type A1 = fn(mut param: u8); // error!\n-type A2 = fn(&param: u32); // error!\n-```\n-\n-When using an alias over a function type, you cannot e.g. denote a parameter as\n-being mutable.\n-\n-To fix the issue, remove patterns (`_` is allowed though). Example:\n-\n-```\n-type A1 = fn(param: u8); // ok!\n-type A2 = fn(_: u32); // ok!\n-```\n-\n-You can also omit the parameter name:\n-\n-```\n-type A3 = fn(i16); // ok!\n-```\n-\"##,\n-\n-E0567: r##\"\n-Generics have been used on an auto trait.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0567\n-#![feature(optin_builtin_traits)]\n-\n-auto trait Generic<T> {} // error!\n-\n-fn main() {}\n-```\n-\n-Since an auto trait is implemented on all existing types, the\n-compiler would not be able to infer the types of the trait's generic\n-parameters.\n-\n-To fix this issue, just remove the generics:\n-\n-```\n-#![feature(optin_builtin_traits)]\n-\n-auto trait Generic {} // ok!\n-\n-fn main() {}\n-```\n-\"##,\n-\n-E0568: r##\"\n-A super trait has been added to an auto trait.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0568\n-#![feature(optin_builtin_traits)]\n-\n-auto trait Bound : Copy {} // error!\n-\n-fn main() {}\n-```\n-\n-Since an auto trait is implemented on all existing types, adding a super trait\n-would filter out a lot of those types. In the current example, almost none of\n-all the existing types could implement `Bound` because very few of them have the\n-`Copy` trait.\n-\n-To fix this issue, just remove the super trait:\n-\n-```\n-#![feature(optin_builtin_traits)]\n-\n-auto trait Bound {} // ok!\n-\n-fn main() {}\n-```\n-\"##,\n-\n-E0571: r##\"\n-A `break` statement with an argument appeared in a non-`loop` loop.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0571\n-# let mut i = 1;\n-# fn satisfied(n: usize) -> bool { n % 23 == 0 }\n-let result = while true {\n-    if satisfied(i) {\n-        break 2*i; // error: `break` with value from a `while` loop\n-    }\n-    i += 1;\n-};\n-```\n-\n-The `break` statement can take an argument (which will be the value of the loop\n-expression if the `break` statement is executed) in `loop` loops, but not\n-`for`, `while`, or `while let` loops.\n-\n-Make sure `break value;` statements only occur in `loop` loops:\n-\n-```\n-# let mut i = 1;\n-# fn satisfied(n: usize) -> bool { n % 23 == 0 }\n-let result = loop { // ok!\n-    if satisfied(i) {\n-        break 2*i;\n-    }\n-    i += 1;\n-};\n-```\n-\"##,\n-\n-E0590: r##\"\n-`break` or `continue` must include a label when used in the condition of a\n-`while` loop.\n-\n-Example of erroneous code:\n-\n-```compile_fail\n-while break {}\n-```\n-\n-To fix this, add a label specifying which loop is being broken out of:\n-```\n-'foo: while break 'foo {}\n-```\n-\"##,\n-\n-E0591: r##\"\n-Per [RFC 401][rfc401], if you have a function declaration `foo`:\n-\n-```\n-// For the purposes of this explanation, all of these\n-// different kinds of `fn` declarations are equivalent:\n-struct S;\n-fn foo(x: S) { /* ... */ }\n-# #[cfg(for_demonstration_only)]\n-extern \"C\" { fn foo(x: S); }\n-# #[cfg(for_demonstration_only)]\n-impl S { fn foo(self) { /* ... */ } }\n-```\n-\n-the type of `foo` is **not** `fn(S)`, as one might expect.\n-Rather, it is a unique, zero-sized marker type written here as `typeof(foo)`.\n-However, `typeof(foo)` can be _coerced_ to a function pointer `fn(S)`,\n-so you rarely notice this:\n-\n-```\n-# struct S;\n-# fn foo(_: S) {}\n-let x: fn(S) = foo; // OK, coerces\n-```\n-\n-The reason that this matter is that the type `fn(S)` is not specific to\n-any particular function: it's a function _pointer_. So calling `x()` results\n-in a virtual call, whereas `foo()` is statically dispatched, because the type\n-of `foo` tells us precisely what function is being called.\n-\n-As noted above, coercions mean that most code doesn't have to be\n-concerned with this distinction. However, you can tell the difference\n-when using **transmute** to convert a fn item into a fn pointer.\n-\n-This is sometimes done as part of an FFI:\n-\n-```compile_fail,E0591\n-extern \"C\" fn foo(userdata: Box<i32>) {\n-    /* ... */\n-}\n-\n-# fn callback(_: extern \"C\" fn(*mut i32)) {}\n-# use std::mem::transmute;\n-# unsafe {\n-let f: extern \"C\" fn(*mut i32) = transmute(foo);\n-callback(f);\n-# }\n-```\n-\n-Here, transmute is being used to convert the types of the fn arguments.\n-This pattern is incorrect because, because the type of `foo` is a function\n-**item** (`typeof(foo)`), which is zero-sized, and the target type (`fn()`)\n-is a function pointer, which is not zero-sized.\n-This pattern should be rewritten. There are a few possible ways to do this:\n-\n-- change the original fn declaration to match the expected signature,\n-  and do the cast in the fn body (the preferred option)\n-- cast the fn item fo a fn pointer before calling transmute, as shown here:\n-\n-    ```\n-    # extern \"C\" fn foo(_: Box<i32>) {}\n-    # use std::mem::transmute;\n-    # unsafe {\n-    let f: extern \"C\" fn(*mut i32) = transmute(foo as extern \"C\" fn(_));\n-    let f: extern \"C\" fn(*mut i32) = transmute(foo as usize); // works too\n-    # }\n-    ```\n-\n-The same applies to transmutes to `*mut fn()`, which were observed in practice.\n-Note though that use of this type is generally incorrect.\n-The intention is typically to describe a function pointer, but just `fn()`\n-alone suffices for that. `*mut fn()` is a pointer to a fn pointer.\n-(Since these values are typically just passed to C code, however, this rarely\n-makes a difference in practice.)\n-\n-[rfc401]: https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md\n-\"##,\n-\n-E0601: r##\"\n-No `main` function was found in a binary crate. To fix this error, add a\n-`main` function. For example:\n-\n-```\n-fn main() {\n-    // Your program will start here.\n-    println!(\"Hello world!\");\n-}\n-```\n-\n-If you don't know the basics of Rust, you can go look to the Rust Book to get\n-started: https://doc.rust-lang.org/book/\n-\"##,\n-\n-E0642: r##\"\n-Trait methods currently cannot take patterns as arguments.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0642\n-trait Foo {\n-    fn foo((x, y): (i32, i32)); // error: patterns aren't allowed\n-                                //        in trait methods\n-}\n-```\n-\n-You can instead use a single name for the argument:\n-\n-```\n-trait Foo {\n-    fn foo(x_and_y: (i32, i32)); // ok!\n-}\n-```\n-\"##,\n-\n-E0666: r##\"\n-`impl Trait` types cannot appear nested in the\n-generic arguments of other `impl Trait` types.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0666\n-trait MyGenericTrait<T> {}\n-trait MyInnerTrait {}\n-\n-fn foo(bar: impl MyGenericTrait<impl MyInnerTrait>) {}\n-```\n-\n-Type parameters for `impl Trait` types must be\n-explicitly defined as named generic parameters:\n-\n-```\n-trait MyGenericTrait<T> {}\n-trait MyInnerTrait {}\n-\n-fn foo<T: MyInnerTrait>(bar: impl MyGenericTrait<T>) {}\n-```\n-\"##,\n-\n-E0695: r##\"\n-A `break` statement without a label appeared inside a labeled block.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0695\n-# #![feature(label_break_value)]\n-loop {\n-    'a: {\n-        break;\n-    }\n-}\n-```\n-\n-Make sure to always label the `break`:\n-\n-```\n-# #![feature(label_break_value)]\n-'l: loop {\n-    'a: {\n-        break 'l;\n-    }\n-}\n-```\n-\n-Or if you want to `break` the labeled block:\n-\n-```\n-# #![feature(label_break_value)]\n-loop {\n-    'a: {\n-        break 'a;\n-    }\n-    break;\n-}\n-```\n-\"##,\n-\n-E0670: r##\"\n-Rust 2015 does not permit the use of `async fn`.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0670\n-async fn foo() {}\n-```\n-\n-Switch to the Rust 2018 edition to use `async fn`.\n-\"##,\n-\n-E0744: r##\"\n-Control-flow expressions are not allowed inside a const context.\n-\n-At the moment, `if` and `match`, as well as the looping constructs `for`,\n-`while`, and `loop`, are forbidden inside a `const`, `static`, or `const fn`.\n-\n-```compile_fail,E0744\n-const _: i32 = {\n-    let mut x = 0;\n-    loop {\n-        x += 1;\n-        if x == 4 {\n-            break;\n-        }\n-    }\n-\n-    x\n-};\n-```\n-\n-\"##,\n-\n-;\n-    E0226, // only a single explicit lifetime bound is permitted\n-    E0472, // asm! is unsupported on this target\n-    E0667, // `impl Trait` in projections\n-    E0696, // `continue` pointing to a labeled block\n-    E0706, // `async fn` in trait\n-}"}, {"sha": "7b3f01c0ee11144b6cea496836470e049e398462", "filename": "src/librustc_plugin/error_codes.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/798e389e578a0199f734c79424fa39e440910979/src%2Flibrustc_plugin%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/798e389e578a0199f734c79424fa39e440910979/src%2Flibrustc_plugin%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Ferror_codes.rs?ref=798e389e578a0199f734c79424fa39e440910979", "patch": "@@ -1,4 +0,0 @@\n-syntax::register_diagnostics! {\n-;\n-    E0498,  // malformed plugin attribute\n-}"}, {"sha": "03afb547d3a226a54faa166b91bf8673bb20b2ad", "filename": "src/librustc_privacy/error_codes.rs", "status": "removed", "additions": 0, "deletions": 169, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/798e389e578a0199f734c79424fa39e440910979/src%2Flibrustc_privacy%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/798e389e578a0199f734c79424fa39e440910979/src%2Flibrustc_privacy%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Ferror_codes.rs?ref=798e389e578a0199f734c79424fa39e440910979", "patch": "@@ -1,169 +0,0 @@\n-syntax::register_diagnostics! {\n-\n-E0445: r##\"\n-A private trait was used on a public type parameter bound.\n-\n-Erroneous code examples:\n-\n-```compile_fail,E0445\n-#![deny(private_in_public)]\n-\n-trait Foo {\n-    fn dummy(&self) { }\n-}\n-\n-pub trait Bar : Foo {} // error: private trait in public interface\n-pub struct Bar2<T: Foo>(pub T); // same error\n-pub fn foo<T: Foo> (t: T) {} // same error\n-```\n-\n-To solve this error, please ensure that the trait is also public. The trait\n-can be made inaccessible if necessary by placing it into a private inner\n-module, but it still has to be marked with `pub`. Example:\n-\n-```\n-pub trait Foo { // we set the Foo trait public\n-    fn dummy(&self) { }\n-}\n-\n-pub trait Bar : Foo {} // ok!\n-pub struct Bar2<T: Foo>(pub T); // ok!\n-pub fn foo<T: Foo> (t: T) {} // ok!\n-```\n-\"##,\n-\n-E0446: r##\"\n-A private type was used in a public type signature.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0446\n-#![deny(private_in_public)]\n-\n-mod Foo {\n-    struct Bar(u32);\n-\n-    pub fn bar() -> Bar { // error: private type in public interface\n-        Bar(0)\n-    }\n-}\n-```\n-\n-To solve this error, please ensure that the type is also public. The type\n-can be made inaccessible if necessary by placing it into a private inner\n-module, but it still has to be marked with `pub`.\n-Example:\n-\n-```\n-mod Foo {\n-    pub struct Bar(u32); // we set the Bar type public\n-\n-    pub fn bar() -> Bar { // ok!\n-        Bar(0)\n-    }\n-}\n-```\n-\"##,\n-\n-E0447: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-The `pub` keyword was used inside a function.\n-\n-Erroneous code example:\n-\n-```\n-fn foo() {\n-    pub struct Bar; // error: visibility has no effect inside functions\n-}\n-```\n-\n-Since we cannot access items defined inside a function, the visibility of its\n-items does not impact outer code. So using the `pub` keyword in this context\n-is invalid.\n-\"##,\n-\n-E0448: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-The `pub` keyword was used inside a public enum.\n-\n-Erroneous code example:\n-\n-```compile_fail\n-pub enum Foo {\n-    pub Bar, // error: unnecessary `pub` visibility\n-}\n-```\n-\n-Since the enum is already public, adding `pub` on one its elements is\n-unnecessary. Example:\n-\n-```compile_fail\n-enum Foo {\n-    pub Bar, // not ok!\n-}\n-```\n-\n-This is the correct syntax:\n-\n-```\n-pub enum Foo {\n-    Bar, // ok!\n-}\n-```\n-\"##,\n-\n-E0451: r##\"\n-A struct constructor with private fields was invoked.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0451\n-mod Bar {\n-    pub struct Foo {\n-        pub a: isize,\n-        b: isize,\n-    }\n-}\n-\n-let f = Bar::Foo{ a: 0, b: 0 }; // error: field `b` of struct `Bar::Foo`\n-                                //        is private\n-```\n-\n-To fix this error, please ensure that all the fields of the struct are public,\n-or implement a function for easy instantiation. Examples:\n-\n-```\n-mod Bar {\n-    pub struct Foo {\n-        pub a: isize,\n-        pub b: isize, // we set `b` field public\n-    }\n-}\n-\n-let f = Bar::Foo{ a: 0, b: 0 }; // ok!\n-```\n-\n-Or:\n-\n-```\n-mod Bar {\n-    pub struct Foo {\n-        pub a: isize,\n-        b: isize, // still private\n-    }\n-\n-    impl Foo {\n-        pub fn new() -> Foo { // we create a method to instantiate `Foo`\n-            Foo { a: 0, b: 0 }\n-        }\n-    }\n-}\n-\n-let f = Bar::Foo::new(); // ok!\n-```\n-\"##,\n-\n-//  E0450, moved into resolve\n-}"}, {"sha": "c59959ae4f4c541c2f7f2eafcb786d076afbba45", "filename": "src/librustc_resolve/error_codes.rs", "status": "removed", "additions": 0, "deletions": 2048, "changes": 2048, "blob_url": "https://github.com/rust-lang/rust/blob/798e389e578a0199f734c79424fa39e440910979/src%2Flibrustc_resolve%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/798e389e578a0199f734c79424fa39e440910979/src%2Flibrustc_resolve%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_codes.rs?ref=798e389e578a0199f734c79424fa39e440910979", "patch": "@@ -1,2048 +0,0 @@\n-// Error messages for EXXXX errors.  Each message should start and end with a\n-// new line, and be wrapped to 80 characters.  In vim you can `:set tw=80` and\n-// use `gq` to wrap paragraphs. Use `:set tw=0` to disable.\n-syntax::register_diagnostics! {\n-\n-E0128: r##\"\n-Type parameter defaults can only use parameters that occur before them.\n-Erroneous code example:\n-\n-```compile_fail,E0128\n-struct Foo<T = U, U = ()> {\n-    field1: T,\n-    field2: U,\n-}\n-// error: type parameters with a default cannot use forward declared\n-// identifiers\n-```\n-\n-Since type parameters are evaluated in-order, you may be able to fix this issue\n-by doing:\n-\n-```\n-struct Foo<U = (), T = U> {\n-    field1: T,\n-    field2: U,\n-}\n-```\n-\n-Please also verify that this wasn't because of a name-clash and rename the type\n-parameter if so.\n-\"##,\n-\n-E0154: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-Imports (`use` statements) are not allowed after non-item statements, such as\n-variable declarations and expression statements.\n-\n-Here is an example that demonstrates the error:\n-\n-```\n-fn f() {\n-    // Variable declaration before import\n-    let x = 0;\n-    use std::io::Read;\n-    // ...\n-}\n-```\n-\n-The solution is to declare the imports at the top of the block, function, or\n-file.\n-\n-Here is the previous example again, with the correct order:\n-\n-```\n-fn f() {\n-    use std::io::Read;\n-    let x = 0;\n-    // ...\n-}\n-```\n-\n-See the Declaration Statements section of the reference for more information\n-about what constitutes an Item declaration and what does not:\n-\n-https://doc.rust-lang.org/reference.html#statements\n-\"##,\n-\n-E0251: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-Two items of the same name cannot be imported without rebinding one of the\n-items under a new local name.\n-\n-An example of this error:\n-\n-```\n-use foo::baz;\n-use bar::*; // error, do `use foo::baz as quux` instead on the previous line\n-\n-fn main() {}\n-\n-mod foo {\n-    pub struct baz;\n-}\n-\n-mod bar {\n-    pub mod baz {}\n-}\n-```\n-\"##,\n-\n-E0252: r##\"\n-Two items of the same name cannot be imported without rebinding one of the\n-items under a new local name.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0252\n-use foo::baz;\n-use bar::baz; // error, do `use bar::baz as quux` instead\n-\n-fn main() {}\n-\n-mod foo {\n-    pub struct baz;\n-}\n-\n-mod bar {\n-    pub mod baz {}\n-}\n-```\n-\n-You can use aliases in order to fix this error. Example:\n-\n-```\n-use foo::baz as foo_baz;\n-use bar::baz; // ok!\n-\n-fn main() {}\n-\n-mod foo {\n-    pub struct baz;\n-}\n-\n-mod bar {\n-    pub mod baz {}\n-}\n-```\n-\n-Or you can reference the item with its parent:\n-\n-```\n-use bar::baz;\n-\n-fn main() {\n-    let x = foo::baz; // ok!\n-}\n-\n-mod foo {\n-    pub struct baz;\n-}\n-\n-mod bar {\n-    pub mod baz {}\n-}\n-```\n-\"##,\n-\n-E0253: r##\"\n-Attempt was made to import an unimportable value. This can happen when trying\n-to import a method from a trait.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0253\n-mod foo {\n-    pub trait MyTrait {\n-        fn do_something();\n-    }\n-}\n-\n-use foo::MyTrait::do_something;\n-// error: `do_something` is not directly importable\n-\n-fn main() {}\n-```\n-\n-It's invalid to directly import methods belonging to a trait or concrete type.\n-\"##,\n-\n-E0254: r##\"\n-Attempt was made to import an item whereas an extern crate with this name has\n-already been imported.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0254\n-extern crate core;\n-\n-mod foo {\n-    pub trait core {\n-        fn do_something();\n-    }\n-}\n-\n-use foo::core;  // error: an extern crate named `core` has already\n-                //        been imported in this module\n-\n-fn main() {}\n-```\n-\n-To fix this issue, you have to rename at least one of the two imports.\n-Example:\n-\n-```\n-extern crate core as libcore; // ok!\n-\n-mod foo {\n-    pub trait core {\n-        fn do_something();\n-    }\n-}\n-\n-use foo::core;\n-\n-fn main() {}\n-```\n-\"##,\n-\n-E0255: r##\"\n-You can't import a value whose name is the same as another value defined in the\n-module.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0255\n-use bar::foo; // error: an item named `foo` is already in scope\n-\n-fn foo() {}\n-\n-mod bar {\n-     pub fn foo() {}\n-}\n-\n-fn main() {}\n-```\n-\n-You can use aliases in order to fix this error. Example:\n-\n-```\n-use bar::foo as bar_foo; // ok!\n-\n-fn foo() {}\n-\n-mod bar {\n-     pub fn foo() {}\n-}\n-\n-fn main() {}\n-```\n-\n-Or you can reference the item with its parent:\n-\n-```\n-fn foo() {}\n-\n-mod bar {\n-     pub fn foo() {}\n-}\n-\n-fn main() {\n-    bar::foo(); // we get the item by referring to its parent\n-}\n-```\n-\"##,\n-\n-E0256: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-You can't import a type or module when the name of the item being imported is\n-the same as another type or submodule defined in the module.\n-\n-An example of this error:\n-\n-```compile_fail\n-use foo::Bar; // error\n-\n-type Bar = u32;\n-\n-mod foo {\n-    pub mod Bar { }\n-}\n-\n-fn main() {}\n-```\n-\"##,\n-\n-E0259: r##\"\n-The name chosen for an external crate conflicts with another external crate\n-that has been imported into the current module.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0259\n-extern crate core;\n-extern crate std as core;\n-\n-fn main() {}\n-```\n-\n-The solution is to choose a different name that doesn't conflict with any\n-external crate imported into the current module.\n-\n-Correct example:\n-\n-```\n-extern crate core;\n-extern crate std as other_name;\n-\n-fn main() {}\n-```\n-\"##,\n-\n-E0260: r##\"\n-The name for an item declaration conflicts with an external crate's name.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0260\n-extern crate core;\n-\n-struct core;\n-\n-fn main() {}\n-```\n-\n-There are two possible solutions:\n-\n-Solution #1: Rename the item.\n-\n-```\n-extern crate core;\n-\n-struct xyz;\n-```\n-\n-Solution #2: Import the crate with a different name.\n-\n-```\n-extern crate core as xyz;\n-\n-struct abc;\n-```\n-\n-See the Declaration Statements section of the reference for more information\n-about what constitutes an Item declaration and what does not:\n-\n-https://doc.rust-lang.org/reference.html#statements\n-\"##,\n-\n-E0364: r##\"\n-Private items cannot be publicly re-exported. This error indicates that you\n-attempted to `pub use` a type or value that was not itself public.\n-\n-Erroneous code example:\n-\n-```compile_fail\n-mod foo {\n-    const X: u32 = 1;\n-}\n-\n-pub use foo::X;\n-\n-fn main() {}\n-```\n-\n-The solution to this problem is to ensure that the items that you are\n-re-exporting are themselves marked with `pub`:\n-\n-```\n-mod foo {\n-    pub const X: u32 = 1;\n-}\n-\n-pub use foo::X;\n-\n-fn main() {}\n-```\n-\n-See the 'Use Declarations' section of the reference for more information on\n-this topic:\n-\n-https://doc.rust-lang.org/reference.html#use-declarations\n-\"##,\n-\n-E0365: r##\"\n-Private modules cannot be publicly re-exported. This error indicates that you\n-attempted to `pub use` a module that was not itself public.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0365\n-mod foo {\n-    pub const X: u32 = 1;\n-}\n-\n-pub use foo as foo2;\n-\n-fn main() {}\n-```\n-\n-The solution to this problem is to ensure that the module that you are\n-re-exporting is itself marked with `pub`:\n-\n-```\n-pub mod foo {\n-    pub const X: u32 = 1;\n-}\n-\n-pub use foo as foo2;\n-\n-fn main() {}\n-```\n-\n-See the 'Use Declarations' section of the reference for more information\n-on this topic:\n-\n-https://doc.rust-lang.org/reference.html#use-declarations\n-\"##,\n-\n-E0401: r##\"\n-Inner items do not inherit type or const parameters from the functions\n-they are embedded in.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0401\n-fn foo<T>(x: T) {\n-    fn bar(y: T) { // T is defined in the \"outer\" function\n-        // ..\n-    }\n-    bar(x);\n-}\n-```\n-\n-Nor will this:\n-\n-```compile_fail,E0401\n-fn foo<T>(x: T) {\n-    type MaybeT = Option<T>;\n-    // ...\n-}\n-```\n-\n-Or this:\n-\n-```compile_fail,E0401\n-fn foo<T>(x: T) {\n-    struct Foo {\n-        x: T,\n-    }\n-    // ...\n-}\n-```\n-\n-Items inside functions are basically just like top-level items, except\n-that they can only be used from the function they are in.\n-\n-There are a couple of solutions for this.\n-\n-If the item is a function, you may use a closure:\n-\n-```\n-fn foo<T>(x: T) {\n-    let bar = |y: T| { // explicit type annotation may not be necessary\n-        // ..\n-    };\n-    bar(x);\n-}\n-```\n-\n-For a generic item, you can copy over the parameters:\n-\n-```\n-fn foo<T>(x: T) {\n-    fn bar<T>(y: T) {\n-        // ..\n-    }\n-    bar(x);\n-}\n-```\n-\n-```\n-fn foo<T>(x: T) {\n-    type MaybeT<T> = Option<T>;\n-}\n-```\n-\n-Be sure to copy over any bounds as well:\n-\n-```\n-fn foo<T: Copy>(x: T) {\n-    fn bar<T: Copy>(y: T) {\n-        // ..\n-    }\n-    bar(x);\n-}\n-```\n-\n-```\n-fn foo<T: Copy>(x: T) {\n-    struct Foo<T: Copy> {\n-        x: T,\n-    }\n-}\n-```\n-\n-This may require additional type hints in the function body.\n-\n-In case the item is a function inside an `impl`, defining a private helper\n-function might be easier:\n-\n-```\n-# struct Foo<T>(T);\n-impl<T> Foo<T> {\n-    pub fn foo(&self, x: T) {\n-        self.bar(x);\n-    }\n-\n-    fn bar(&self, y: T) {\n-        // ..\n-    }\n-}\n-```\n-\n-For default impls in traits, the private helper solution won't work, however\n-closures or copying the parameters should still work.\n-\"##,\n-\n-E0403: r##\"\n-Some type parameters have the same name.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0403\n-fn f<T, T>(s: T, u: T) {} // error: the name `T` is already used for a generic\n-                          //        parameter in this item's generic parameters\n-```\n-\n-Please verify that none of the type parameters are misspelled, and rename any\n-clashing parameters. Example:\n-\n-```\n-fn f<T, Y>(s: T, u: Y) {} // ok!\n-```\n-\n-Type parameters in an associated item also cannot shadow parameters from the\n-containing item:\n-\n-```compile_fail,E0403\n-trait Foo<T> {\n-    fn do_something(&self) -> T;\n-    fn do_something_else<T: Clone>(&self, bar: T);\n-}\n-```\n-\"##,\n-\n-E0404: r##\"\n-You tried to use something which is not a trait in a trait position, such as\n-a bound or `impl`.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0404\n-struct Foo;\n-struct Bar;\n-\n-impl Foo for Bar {} // error: `Foo` is not a trait\n-```\n-\n-Another erroneous code example:\n-\n-```compile_fail,E0404\n-struct Foo;\n-\n-fn bar<T: Foo>(t: T) {} // error: `Foo` is not a trait\n-```\n-\n-Please verify that you didn't misspell the trait's name or otherwise use the\n-wrong identifier. Example:\n-\n-```\n-trait Foo {\n-    // some functions\n-}\n-struct Bar;\n-\n-impl Foo for Bar { // ok!\n-    // functions implementation\n-}\n-```\n-\n-or\n-\n-```\n-trait Foo {\n-    // some functions\n-}\n-\n-fn bar<T: Foo>(t: T) {} // ok!\n-```\n-\n-\"##,\n-\n-E0405: r##\"\n-The code refers to a trait that is not in scope.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0405\n-struct Foo;\n-\n-impl SomeTrait for Foo {} // error: trait `SomeTrait` is not in scope\n-```\n-\n-Please verify that the name of the trait wasn't misspelled and ensure that it\n-was imported. Example:\n-\n-```\n-# #[cfg(for_demonstration_only)]\n-// solution 1:\n-use some_file::SomeTrait;\n-\n-// solution 2:\n-trait SomeTrait {\n-    // some functions\n-}\n-\n-struct Foo;\n-\n-impl SomeTrait for Foo { // ok!\n-    // implements functions\n-}\n-```\n-\"##,\n-\n-E0407: r##\"\n-A definition of a method not in the implemented trait was given in a trait\n-implementation.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0407\n-trait Foo {\n-    fn a();\n-}\n-\n-struct Bar;\n-\n-impl Foo for Bar {\n-    fn a() {}\n-    fn b() {} // error: method `b` is not a member of trait `Foo`\n-}\n-```\n-\n-Please verify you didn't misspell the method name and you used the correct\n-trait. First example:\n-\n-```\n-trait Foo {\n-    fn a();\n-    fn b();\n-}\n-\n-struct Bar;\n-\n-impl Foo for Bar {\n-    fn a() {}\n-    fn b() {} // ok!\n-}\n-```\n-\n-Second example:\n-\n-```\n-trait Foo {\n-    fn a();\n-}\n-\n-struct Bar;\n-\n-impl Foo for Bar {\n-    fn a() {}\n-}\n-\n-impl Bar {\n-    fn b() {}\n-}\n-```\n-\"##,\n-\n-E0408: r##\"\n-An \"or\" pattern was used where the variable bindings are not consistently bound\n-across patterns.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0408\n-match x {\n-    Some(y) | None => { /* use y */ } // error: variable `y` from pattern #1 is\n-                                      //        not bound in pattern #2\n-    _ => ()\n-}\n-```\n-\n-Here, `y` is bound to the contents of the `Some` and can be used within the\n-block corresponding to the match arm. However, in case `x` is `None`, we have\n-not specified what `y` is, and the block will use a nonexistent variable.\n-\n-To fix this error, either split into multiple match arms:\n-\n-```\n-let x = Some(1);\n-match x {\n-    Some(y) => { /* use y */ }\n-    None => { /* ... */ }\n-}\n-```\n-\n-or, bind the variable to a field of the same type in all sub-patterns of the\n-or pattern:\n-\n-```\n-let x = (0, 2);\n-match x {\n-    (0, y) | (y, 0) => { /* use y */}\n-    _ => {}\n-}\n-```\n-\n-In this example, if `x` matches the pattern `(0, _)`, the second field is set\n-to `y`. If it matches `(_, 0)`, the first field is set to `y`; so in all\n-cases `y` is set to some value.\n-\"##,\n-\n-E0409: r##\"\n-An \"or\" pattern was used where the variable bindings are not consistently bound\n-across patterns.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0409\n-let x = (0, 2);\n-match x {\n-    (0, ref y) | (y, 0) => { /* use y */} // error: variable `y` is bound with\n-                                          //        different mode in pattern #2\n-                                          //        than in pattern #1\n-    _ => ()\n-}\n-```\n-\n-Here, `y` is bound by-value in one case and by-reference in the other.\n-\n-To fix this error, just use the same mode in both cases.\n-Generally using `ref` or `ref mut` where not already used will fix this:\n-\n-```\n-let x = (0, 2);\n-match x {\n-    (0, ref y) | (ref y, 0) => { /* use y */}\n-    _ => ()\n-}\n-```\n-\n-Alternatively, split the pattern:\n-\n-```\n-let x = (0, 2);\n-match x {\n-    (y, 0) => { /* use y */ }\n-    (0, ref y) => { /* use y */}\n-    _ => ()\n-}\n-```\n-\"##,\n-\n-E0411: r##\"\n-The `Self` keyword was used outside an impl, trait, or type definition.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0411\n-<Self>::foo; // error: use of `Self` outside of an impl, trait, or type\n-             // definition\n-```\n-\n-The `Self` keyword represents the current type, which explains why it can only\n-be used inside an impl, trait, or type definition. It gives access to the\n-associated items of a type:\n-\n-```\n-trait Foo {\n-    type Bar;\n-}\n-\n-trait Baz : Foo {\n-    fn bar() -> Self::Bar; // like this\n-}\n-```\n-\n-However, be careful when two types have a common associated type:\n-\n-```compile_fail\n-trait Foo {\n-    type Bar;\n-}\n-\n-trait Foo2 {\n-    type Bar;\n-}\n-\n-trait Baz : Foo + Foo2 {\n-    fn bar() -> Self::Bar;\n-    // error: ambiguous associated type `Bar` in bounds of `Self`\n-}\n-```\n-\n-This problem can be solved by specifying from which trait we want to use the\n-`Bar` type:\n-\n-```\n-trait Foo {\n-    type Bar;\n-}\n-\n-trait Foo2 {\n-    type Bar;\n-}\n-\n-trait Baz : Foo + Foo2 {\n-    fn bar() -> <Self as Foo>::Bar; // ok!\n-}\n-```\n-\"##,\n-\n-E0412: r##\"\n-The type name used is not in scope.\n-\n-Erroneous code examples:\n-\n-```compile_fail,E0412\n-impl Something {} // error: type name `Something` is not in scope\n-\n-// or:\n-\n-trait Foo {\n-    fn bar(N); // error: type name `N` is not in scope\n-}\n-\n-// or:\n-\n-fn foo(x: T) {} // type name `T` is not in scope\n-```\n-\n-To fix this error, please verify you didn't misspell the type name, you did\n-declare it or imported it into the scope. Examples:\n-\n-```\n-struct Something;\n-\n-impl Something {} // ok!\n-\n-// or:\n-\n-trait Foo {\n-    type N;\n-\n-    fn bar(_: Self::N); // ok!\n-}\n-\n-// or:\n-\n-fn foo<T>(x: T) {} // ok!\n-```\n-\n-Another case that causes this error is when a type is imported into a parent\n-module. To fix this, you can follow the suggestion and use File directly or\n-`use super::File;` which will import the types from the parent namespace. An\n-example that causes this error is below:\n-\n-```compile_fail,E0412\n-use std::fs::File;\n-\n-mod foo {\n-    fn some_function(f: File) {}\n-}\n-```\n-\n-```\n-use std::fs::File;\n-\n-mod foo {\n-    // either\n-    use super::File;\n-    // or\n-    // use std::fs::File;\n-    fn foo(f: File) {}\n-}\n-# fn main() {} // don't insert it for us; that'll break imports\n-```\n-\"##,\n-\n-E0415: r##\"\n-More than one function parameter have the same name.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0415\n-fn foo(f: i32, f: i32) {} // error: identifier `f` is bound more than\n-                          //        once in this parameter list\n-```\n-\n-Please verify you didn't misspell parameters' name. Example:\n-\n-```\n-fn foo(f: i32, g: i32) {} // ok!\n-```\n-\"##,\n-\n-E0416: r##\"\n-An identifier is bound more than once in a pattern.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0416\n-match (1, 2) {\n-    (x, x) => {} // error: identifier `x` is bound more than once in the\n-                 //        same pattern\n-}\n-```\n-\n-Please verify you didn't misspell identifiers' name. Example:\n-\n-```\n-match (1, 2) {\n-    (x, y) => {} // ok!\n-}\n-```\n-\n-Or maybe did you mean to unify? Consider using a guard:\n-\n-```\n-# let (A, B, C) = (1, 2, 3);\n-match (A, B, C) {\n-    (x, x2, see) if x == x2 => { /* A and B are equal, do one thing */ }\n-    (y, z, see) => { /* A and B unequal; do another thing */ }\n-}\n-```\n-\"##,\n-\n-E0422: r##\"\n-You are trying to use an identifier that is either undefined or not a struct.\n-Erroneous code example:\n-\n-```compile_fail,E0422\n-fn main () {\n-    let x = Foo { x: 1, y: 2 };\n-}\n-```\n-\n-In this case, `Foo` is undefined, so it inherently isn't anything, and\n-definitely not a struct.\n-\n-```compile_fail\n-fn main () {\n-    let foo = 1;\n-    let x = foo { x: 1, y: 2 };\n-}\n-```\n-\n-In this case, `foo` is defined, but is not a struct, so Rust can't use it as\n-one.\n-\"##,\n-\n-E0423: r##\"\n-An identifier was used like a function name or a value was expected and the\n-identifier exists but it belongs to a different namespace.\n-\n-For (an erroneous) example, here a `struct` variant name were used as a\n-function:\n-\n-```compile_fail,E0423\n-struct Foo { a: bool };\n-\n-let f = Foo();\n-// error: expected function, tuple struct or tuple variant, found `Foo`\n-// `Foo` is a struct name, but this expression uses it like a function name\n-```\n-\n-Please verify you didn't misspell the name of what you actually wanted to use\n-here. Example:\n-\n-```\n-fn Foo() -> u32 { 0 }\n-\n-let f = Foo(); // ok!\n-```\n-\n-It is common to forget the trailing `!` on macro invocations, which would also\n-yield this error:\n-\n-```compile_fail,E0423\n-println(\"\");\n-// error: expected function, tuple struct or tuple variant,\n-// found macro `println`\n-// did you mean `println!(...)`? (notice the trailing `!`)\n-```\n-\n-Another case where this error is emitted is when a value is expected, but\n-something else is found:\n-\n-```compile_fail,E0423\n-pub mod a {\n-    pub const I: i32 = 1;\n-}\n-\n-fn h1() -> i32 {\n-    a.I\n-    //~^ ERROR expected value, found module `a`\n-    // did you mean `a::I`?\n-}\n-```\n-\"##,\n-\n-E0424: r##\"\n-The `self` keyword was used inside of an associated function without a \"`self`\n-receiver\" parameter.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0424\n-struct Foo;\n-\n-impl Foo {\n-    // `bar` is a method, because it has a receiver parameter.\n-    fn bar(&self) {}\n-\n-    // `foo` is not a method, because it has no receiver parameter.\n-    fn foo() {\n-        self.bar(); // error: `self` value is a keyword only available in\n-                    //        methods with a `self` parameter\n-    }\n-}\n-```\n-\n-The `self` keyword can only be used inside methods, which are associated\n-functions (functions defined inside of a `trait` or `impl` block) that have a\n-`self` receiver as its first parameter, like `self`, `&self`, `&mut self` or\n-`self: &mut Pin<Self>` (this last one is an example of an [\"abitrary `self`\n-type\"](https://github.com/rust-lang/rust/issues/44874)).\n-\n-Check if the associated function's parameter list should have contained a `self`\n-receiver for it to be a method, and add it if so. Example:\n-\n-```\n-struct Foo;\n-\n-impl Foo {\n-    fn bar(&self) {}\n-\n-    fn foo(self) { // `foo` is now a method.\n-        self.bar(); // ok!\n-    }\n-}\n-```\n-\"##,\n-\n-E0425: r##\"\n-An unresolved name was used.\n-\n-Erroneous code examples:\n-\n-```compile_fail,E0425\n-something_that_doesnt_exist::foo;\n-// error: unresolved name `something_that_doesnt_exist::foo`\n-\n-// or:\n-\n-trait Foo {\n-    fn bar() {\n-        Self; // error: unresolved name `Self`\n-    }\n-}\n-\n-// or:\n-\n-let x = unknown_variable;  // error: unresolved name `unknown_variable`\n-```\n-\n-Please verify that the name wasn't misspelled and ensure that the\n-identifier being referred to is valid for the given situation. Example:\n-\n-```\n-enum something_that_does_exist {\n-    Foo,\n-}\n-```\n-\n-Or:\n-\n-```\n-mod something_that_does_exist {\n-    pub static foo : i32 = 0i32;\n-}\n-\n-something_that_does_exist::foo; // ok!\n-```\n-\n-Or:\n-\n-```\n-let unknown_variable = 12u32;\n-let x = unknown_variable; // ok!\n-```\n-\n-If the item is not defined in the current module, it must be imported using a\n-`use` statement, like so:\n-\n-```\n-# mod foo { pub fn bar() {} }\n-# fn main() {\n-use foo::bar;\n-bar();\n-# }\n-```\n-\n-If the item you are importing is not defined in some super-module of the\n-current module, then it must also be declared as public (e.g., `pub fn`).\n-\"##,\n-\n-E0426: r##\"\n-An undeclared label was used.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0426\n-loop {\n-    break 'a; // error: use of undeclared label `'a`\n-}\n-```\n-\n-Please verify you spelt or declare the label correctly. Example:\n-\n-```\n-'a: loop {\n-    break 'a; // ok!\n-}\n-```\n-\"##,\n-\n-E0428: r##\"\n-A type or module has been defined more than once.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0428\n-struct Bar;\n-struct Bar; // error: duplicate definition of value `Bar`\n-```\n-\n-Please verify you didn't misspell the type/module's name or remove/rename the\n-duplicated one. Example:\n-\n-```\n-struct Bar;\n-struct Bar2; // ok!\n-```\n-\"##,\n-\n-E0429: r##\"\n-The `self` keyword cannot appear alone as the last segment in a `use`\n-declaration.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0429\n-use std::fmt::self; // error: `self` imports are only allowed within a { } list\n-```\n-\n-To use a namespace itself in addition to some of its members, `self` may appear\n-as part of a brace-enclosed list of imports:\n-\n-```\n-use std::fmt::{self, Debug};\n-```\n-\n-If you only want to import the namespace, do so directly:\n-\n-```\n-use std::fmt;\n-```\n-\"##,\n-\n-E0430: r##\"\n-The `self` import appears more than once in the list.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0430\n-use something::{self, self}; // error: `self` import can only appear once in\n-                             //        the list\n-```\n-\n-Please verify you didn't misspell the import name or remove the duplicated\n-`self` import. Example:\n-\n-```\n-# mod something {}\n-# fn main() {\n-use something::{self}; // ok!\n-# }\n-```\n-\"##,\n-\n-E0431: r##\"\n-An invalid `self` import was made.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0431\n-use {self}; // error: `self` import can only appear in an import list with a\n-            //        non-empty prefix\n-```\n-\n-You cannot import the current module into itself, please remove this import\n-or verify you didn't misspell it.\n-\"##,\n-\n-E0432: r##\"\n-An import was unresolved.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0432\n-use something::Foo; // error: unresolved import `something::Foo`.\n-```\n-\n-Paths in `use` statements are relative to the crate root. To import items\n-relative to the current and parent modules, use the `self::` and `super::`\n-prefixes, respectively. Also verify that you didn't misspell the import\n-name and that the import exists in the module from where you tried to\n-import it. Example:\n-\n-```\n-use self::something::Foo; // ok!\n-\n-mod something {\n-    pub struct Foo;\n-}\n-# fn main() {}\n-```\n-\n-Or, if you tried to use a module from an external crate, you may have missed\n-the `extern crate` declaration (which is usually placed in the crate root):\n-\n-```\n-extern crate core; // Required to use the `core` crate\n-\n-use core::any;\n-# fn main() {}\n-```\n-\"##,\n-\n-E0433: r##\"\n-An undeclared type or module was used.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0433\n-let map = HashMap::new();\n-// error: failed to resolve: use of undeclared type or module `HashMap`\n-```\n-\n-Please verify you didn't misspell the type/module's name or that you didn't\n-forget to import it:\n-\n-\n-```\n-use std::collections::HashMap; // HashMap has been imported.\n-let map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n-```\n-\"##,\n-\n-E0434: r##\"\n-This error indicates that a variable usage inside an inner function is invalid\n-because the variable comes from a dynamic environment. Inner functions do not\n-have access to their containing environment.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0434\n-fn foo() {\n-    let y = 5;\n-    fn bar() -> u32 {\n-        y // error: can't capture dynamic environment in a fn item; use the\n-          //        || { ... } closure form instead.\n-    }\n-}\n-```\n-\n-Functions do not capture local variables. To fix this error, you can replace the\n-function with a closure:\n-\n-```\n-fn foo() {\n-    let y = 5;\n-    let bar = || {\n-        y\n-    };\n-}\n-```\n-\n-or replace the captured variable with a constant or a static item:\n-\n-```\n-fn foo() {\n-    static mut X: u32 = 4;\n-    const Y: u32 = 5;\n-    fn bar() -> u32 {\n-        unsafe {\n-            X = 3;\n-        }\n-        Y\n-    }\n-}\n-```\n-\"##,\n-\n-E0435: r##\"\n-A non-constant value was used in a constant expression.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0435\n-let foo = 42;\n-let a: [u8; foo]; // error: attempt to use a non-constant value in a constant\n-```\n-\n-To fix this error, please replace the value with a constant. Example:\n-\n-```\n-let a: [u8; 42]; // ok!\n-```\n-\n-Or:\n-\n-```\n-const FOO: usize = 42;\n-let a: [u8; FOO]; // ok!\n-```\n-\"##,\n-\n-E0437: r##\"\n-Trait implementations can only implement associated types that are members of\n-the trait in question. This error indicates that you attempted to implement\n-an associated type whose name does not match the name of any associated type\n-in the trait.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0437\n-trait Foo {}\n-\n-impl Foo for i32 {\n-    type Bar = bool;\n-}\n-```\n-\n-The solution to this problem is to remove the extraneous associated type:\n-\n-```\n-trait Foo {}\n-\n-impl Foo for i32 {}\n-```\n-\"##,\n-\n-E0438: r##\"\n-Trait implementations can only implement associated constants that are\n-members of the trait in question. This error indicates that you\n-attempted to implement an associated constant whose name does not\n-match the name of any associated constant in the trait.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0438\n-trait Foo {}\n-\n-impl Foo for i32 {\n-    const BAR: bool = true;\n-}\n-```\n-\n-The solution to this problem is to remove the extraneous associated constant:\n-\n-```\n-trait Foo {}\n-\n-impl Foo for i32 {}\n-```\n-\"##,\n-\n-E0466: r##\"\n-Macro import declarations were malformed.\n-\n-Erroneous code examples:\n-\n-```compile_fail,E0466\n-#[macro_use(a_macro(another_macro))] // error: invalid import declaration\n-extern crate core as some_crate;\n-\n-#[macro_use(i_want = \"some_macros\")] // error: invalid import declaration\n-extern crate core as another_crate;\n-```\n-\n-This is a syntax error at the level of attribute declarations. The proper\n-syntax for macro imports is the following:\n-\n-```ignore (cannot-doctest-multicrate-project)\n-// In some_crate:\n-#[macro_export]\n-macro_rules! get_tacos {\n-    ...\n-}\n-\n-#[macro_export]\n-macro_rules! get_pimientos {\n-    ...\n-}\n-\n-// In your crate:\n-#[macro_use(get_tacos, get_pimientos)] // It imports `get_tacos` and\n-extern crate some_crate;               // `get_pimientos` macros from some_crate\n-```\n-\n-If you would like to import all exported macros, write `macro_use` with no\n-arguments.\n-\"##,\n-\n-E0468: r##\"\n-A non-root module attempts to import macros from another crate.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0468\n-mod foo {\n-    #[macro_use(debug_assert)]  // error: must be at crate root to import\n-    extern crate core;          //        macros from another crate\n-    fn run_macro() { debug_assert!(true); }\n-}\n-```\n-\n-Only `extern crate` imports at the crate root level are allowed to import\n-macros.\n-\n-Either move the macro import to crate root or do without the foreign macros.\n-This will work:\n-\n-```\n-#[macro_use(debug_assert)]\n-extern crate core;\n-\n-mod foo {\n-    fn run_macro() { debug_assert!(true); }\n-}\n-# fn main() {}\n-```\n-\"##,\n-\n-E0469: r##\"\n-A macro listed for import was not found.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0469\n-#[macro_use(drink, be_merry)] // error: imported macro not found\n-extern crate alloc;\n-\n-fn main() {\n-    // ...\n-}\n-```\n-\n-Either the listed macro is not contained in the imported crate, or it is not\n-exported from the given crate.\n-\n-This could be caused by a typo. Did you misspell the macro's name?\n-\n-Double-check the names of the macros listed for import, and that the crate\n-in question exports them.\n-\n-A working version would be:\n-\n-```ignore (cannot-doctest-multicrate-project)\n-// In some_crate crate:\n-#[macro_export]\n-macro_rules! eat {\n-    ...\n-}\n-\n-#[macro_export]\n-macro_rules! drink {\n-    ...\n-}\n-\n-// In your crate:\n-#[macro_use(eat, drink)]\n-extern crate some_crate; //ok!\n-```\n-\"##,\n-\n-E0530: r##\"\n-A binding shadowed something it shouldn't.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0530\n-static TEST: i32 = 0;\n-\n-let r: (i32, i32) = (0, 0);\n-match r {\n-    TEST => {} // error: match bindings cannot shadow statics\n-}\n-```\n-\n-To fix this error, just change the binding's name in order to avoid shadowing\n-one of the following:\n-\n-* struct name\n-* struct/enum variant\n-* static\n-* const\n-* associated const\n-\n-Fixed example:\n-\n-```\n-static TEST: i32 = 0;\n-\n-let r: (i32, i32) = (0, 0);\n-match r {\n-    something => {} // ok!\n-}\n-```\n-\"##,\n-\n-E0531: r##\"\n-An unknown tuple struct/variant has been used.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0531\n-let Type(x) = Type(12); // error!\n-match Bar(12) {\n-    Bar(x) => {} // error!\n-    _ => {}\n-}\n-```\n-\n-In most cases, it's either a forgotten import or a typo. However, let's look at\n-how you can have such a type:\n-\n-```edition2018\n-struct Type(u32); // this is a tuple struct\n-\n-enum Foo {\n-    Bar(u32), // this is a tuple variant\n-}\n-\n-use Foo::*; // To use Foo's variant directly, we need to import them in\n-            // the scope.\n-```\n-\n-Either way, it should work fine with our previous code:\n-\n-```edition2018\n-struct Type(u32);\n-\n-enum Foo {\n-    Bar(u32),\n-}\n-use Foo::*;\n-\n-let Type(x) = Type(12); // ok!\n-match Type(12) {\n-    Type(x) => {} // ok!\n-    _ => {}\n-}\n-```\n-\"##,\n-\n-E0532: r##\"\n-Pattern arm did not match expected kind.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0532\n-enum State {\n-    Succeeded,\n-    Failed(String),\n-}\n-\n-fn print_on_failure(state: &State) {\n-    match *state {\n-        // error: expected unit struct, unit variant or constant, found tuple\n-        //        variant `State::Failed`\n-        State::Failed => println!(\"Failed\"),\n-        _ => ()\n-    }\n-}\n-```\n-\n-To fix this error, ensure the match arm kind is the same as the expression\n-matched.\n-\n-Fixed example:\n-\n-```\n-enum State {\n-    Succeeded,\n-    Failed(String),\n-}\n-\n-fn print_on_failure(state: &State) {\n-    match *state {\n-        State::Failed(ref msg) => println!(\"Failed with {}\", msg),\n-        _ => ()\n-    }\n-}\n-```\n-\"##,\n-\n-E0573: r##\"\n-Something other than a type has been used when one was expected.\n-\n-Erroneous code examples:\n-\n-```compile_fail,E0573\n-enum Dragon {\n-    Born,\n-}\n-\n-fn oblivion() -> Dragon::Born { // error!\n-    Dragon::Born\n-}\n-\n-const HOBBIT: u32 = 2;\n-impl HOBBIT {} // error!\n-\n-enum Wizard {\n-    Gandalf,\n-    Saruman,\n-}\n-\n-trait Isengard {\n-    fn wizard(_: Wizard::Saruman); // error!\n-}\n-```\n-\n-In all these errors, a type was expected. For example, in the first error, if\n-we want to return the `Born` variant from the `Dragon` enum, we must set the\n-function to return the enum and not its variant:\n-\n-```\n-enum Dragon {\n-    Born,\n-}\n-\n-fn oblivion() -> Dragon { // ok!\n-    Dragon::Born\n-}\n-```\n-\n-In the second error, you can't implement something on an item, only on types.\n-We would need to create a new type if we wanted to do something similar:\n-\n-```\n-struct Hobbit(u32); // we create a new type\n-\n-const HOBBIT: Hobbit = Hobbit(2);\n-impl Hobbit {} // ok!\n-```\n-\n-In the third case, we tried to only expect one variant of the `Wizard` enum,\n-which is not possible. To make this work, we need to using pattern matching\n-over the `Wizard` enum:\n-\n-```\n-enum Wizard {\n-    Gandalf,\n-    Saruman,\n-}\n-\n-trait Isengard {\n-    fn wizard(w: Wizard) { // ok!\n-        match w {\n-            Wizard::Saruman => {\n-                // do something\n-            }\n-            _ => {} // ignore everything else\n-        }\n-    }\n-}\n-```\n-\"##,\n-\n-E0574: r##\"\n-Something other than a struct, variant or union has been used when one was\n-expected.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0574\n-mod Mordor {}\n-\n-let sauron = Mordor { x: () }; // error!\n-\n-enum Jak {\n-    Daxter { i: isize },\n-}\n-\n-let eco = Jak::Daxter { i: 1 };\n-match eco {\n-    Jak { i } => {} // error!\n-}\n-```\n-\n-In all these errors, a type was expected. For example, in the first error,\n-we tried to instantiate the `Mordor` module, which is impossible. If you want\n-to instantiate a type inside a module, you can do it as follow:\n-\n-```\n-mod Mordor {\n-    pub struct TheRing {\n-        pub x: usize,\n-    }\n-}\n-\n-let sauron = Mordor::TheRing { x: 1 }; // ok!\n-```\n-\n-In the second error, we tried to bind the `Jak` enum directly, which is not\n-possible: you can only bind one of its variants. To do so:\n-\n-```\n-enum Jak {\n-    Daxter { i: isize },\n-}\n-\n-let eco = Jak::Daxter { i: 1 };\n-match eco {\n-    Jak::Daxter { i } => {} // ok!\n-}\n-```\n-\"##,\n-\n-E0575: r##\"\n-Something other than a type or an associated type was given.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0575\n-enum Rick { Morty }\n-\n-let _: <u8 as Rick>::Morty; // error!\n-\n-trait Age {\n-    type Empire;\n-    fn Mythology() {}\n-}\n-\n-impl Age for u8 {\n-    type Empire = u16;\n-}\n-\n-let _: <u8 as Age>::Mythology; // error!\n-```\n-\n-In both cases, we're declaring a variable (called `_`) and we're giving it a\n-type. However, `<u8 as Rick>::Morty` and `<u8 as Age>::Mythology` aren't types,\n-therefore the compiler throws an error.\n-\n-`<u8 as Rick>::Morty` is an enum variant, you cannot use a variant as a type,\n-you have to use the enum directly:\n-\n-```\n-enum Rick { Morty }\n-\n-let _: Rick; // ok!\n-```\n-\n-`<u8 as Age>::Mythology` is a trait method, which is definitely not a type.\n-However, the `Age` trait provides an associated type `Empire` which can be\n-used as a type:\n-\n-```\n-trait Age {\n-    type Empire;\n-    fn Mythology() {}\n-}\n-\n-impl Age for u8 {\n-    type Empire = u16;\n-}\n-\n-let _: <u8 as Age>::Empire; // ok!\n-```\n-\"##,\n-\n-E0576: r##\"\n-An associated item wasn't found in the given type.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0576\n-trait Hello {\n-    type Who;\n-\n-    fn hello() -> <Self as Hello>::You; // error!\n-}\n-```\n-\n-In this example, we tried to use the non-existent associated type `You` of the\n-`Hello` trait. To fix this error, use an existing associated type:\n-\n-```\n-trait Hello {\n-    type Who;\n-\n-    fn hello() -> <Self as Hello>::Who; // ok!\n-}\n-```\n-\"##,\n-\n-E0577: r##\"\n-Something other than a module was found in visibility scope.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0577,edition2018\n-pub struct Sea;\n-\n-pub (in crate::Sea) struct Shark; // error!\n-\n-fn main() {}\n-```\n-\n-`Sea` is not a module, therefore it is invalid to use it in a visibility path.\n-To fix this error we need to ensure `Sea` is a module.\n-\n-Please note that the visibility scope can only be applied on ancestors!\n-\n-```edition2018\n-pub mod Sea {\n-    pub (in crate::Sea) struct Shark; // ok!\n-}\n-\n-fn main() {}\n-```\n-\"##,\n-\n-E0578: r##\"\n-A module cannot be found and therefore, the visibility cannot be determined.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0578,edition2018\n-foo!();\n-\n-pub (in ::Sea) struct Shark; // error!\n-\n-fn main() {}\n-```\n-\n-Because of the call to the `foo` macro, the compiler guesses that the missing\n-module could be inside it and fails because the macro definition cannot be\n-found.\n-\n-To fix this error, please be sure that the module is in scope:\n-\n-```edition2018\n-pub mod Sea {\n-    pub (in crate::Sea) struct Shark;\n-}\n-\n-fn main() {}\n-```\n-\"##,\n-\n-E0603: r##\"\n-A private item was used outside its scope.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0603\n-mod SomeModule {\n-    const PRIVATE: u32 = 0x_a_bad_1dea_u32; // This const is private, so we\n-                                            // can't use it outside of the\n-                                            // `SomeModule` module.\n-}\n-\n-println!(\"const value: {}\", SomeModule::PRIVATE); // error: constant `PRIVATE`\n-                                                  //        is private\n-```\n-\n-In order to fix this error, you need to make the item public by using the `pub`\n-keyword. Example:\n-\n-```\n-mod SomeModule {\n-    pub const PRIVATE: u32 = 0x_a_bad_1dea_u32; // We set it public by using the\n-                                                // `pub` keyword.\n-}\n-\n-println!(\"const value: {}\", SomeModule::PRIVATE); // ok!\n-```\n-\"##,\n-\n-E0659: r##\"\n-An item usage is ambiguous.\n-\n-Erroneous code example:\n-\n-```compile_fail,edition2018,E0659\n-pub mod moon {\n-    pub fn foo() {}\n-}\n-\n-pub mod earth {\n-    pub fn foo() {}\n-}\n-\n-mod collider {\n-    pub use crate::moon::*;\n-    pub use crate::earth::*;\n-}\n-\n-fn main() {\n-    crate::collider::foo(); // ERROR: `foo` is ambiguous\n-}\n-```\n-\n-This error generally appears when two items with the same name are imported into\n-a module. Here, the `foo` functions are imported and reexported from the\n-`collider` module and therefore, when we're using `collider::foo()`, both\n-functions collide.\n-\n-To solve this error, the best solution is generally to keep the path before the\n-item when using it. Example:\n-\n-```edition2018\n-pub mod moon {\n-    pub fn foo() {}\n-}\n-\n-pub mod earth {\n-    pub fn foo() {}\n-}\n-\n-mod collider {\n-    pub use crate::moon;\n-    pub use crate::earth;\n-}\n-\n-fn main() {\n-    crate::collider::moon::foo(); // ok!\n-    crate::collider::earth::foo(); // ok!\n-}\n-```\n-\"##,\n-\n-E0671: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-Const parameters cannot depend on type parameters.\n-The following is therefore invalid:\n-\n-```compile_fail,E0741\n-#![feature(const_generics)]\n-\n-fn const_id<T, const N: T>() -> T { // error\n-    N\n-}\n-```\n-\"##,\n-\n-E0735: r##\"\n-Type parameter defaults cannot use `Self` on structs, enums, or unions.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0735\n-struct Foo<X = Box<Self>> {\n-    field1: Option<X>,\n-    field2: Option<X>,\n-}\n-// error: type parameters cannot use `Self` in their defaults.\n-```\n-\"##,\n-\n-E0742: r##\"\n-Visibility is restricted to a module which isn't an ancestor of the current\n-item.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0742,edition2018\n-pub mod Sea {}\n-\n-pub (in crate::Sea) struct Shark; // error!\n-\n-fn main() {}\n-```\n-\n-To fix this error, we need to move the `Shark` struct inside the `Sea` module:\n-\n-```edition2018\n-pub mod Sea {\n-    pub (in crate::Sea) struct Shark; // ok!\n-}\n-\n-fn main() {}\n-```\n-\n-Of course, you can do it as long as the module you're referring to is an\n-ancestor:\n-\n-```edition2018\n-pub mod Earth {\n-    pub mod Sea {\n-        pub (in crate::Earth) struct Shark; // ok!\n-    }\n-}\n-\n-fn main() {}\n-```\n-\"##,\n-\n-;\n-//  E0153, unused error code\n-//  E0157, unused error code\n-//  E0257,\n-//  E0258,\n-//  E0402, // cannot use an outer type parameter in this context\n-//  E0406, merged into 420\n-//  E0410, merged into 408\n-//  E0413, merged into 530\n-//  E0414, merged into 530\n-//  E0417, merged into 532\n-//  E0418, merged into 532\n-//  E0419, merged into 531\n-//  E0420, merged into 532\n-//  E0421, merged into 531\n-//  E0427, merged into 530\n-//  E0467, removed\n-//  E0470, removed\n-}"}, {"sha": "02783f65df537550cc09bc23276e2ec627a83a8d", "filename": "src/librustc_typeck/error_codes.rs", "status": "removed", "additions": 0, "deletions": 5149, "changes": 5149, "blob_url": "https://github.com/rust-lang/rust/blob/798e389e578a0199f734c79424fa39e440910979/src%2Flibrustc_typeck%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/798e389e578a0199f734c79424fa39e440910979/src%2Flibrustc_typeck%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Ferror_codes.rs?ref=798e389e578a0199f734c79424fa39e440910979"}, {"sha": "0e81de7d4a770621e80d9e0e8a3a5046e8682191", "filename": "src/libsyntax/error_codes.rs", "status": "removed", "additions": 0, "deletions": 379, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/798e389e578a0199f734c79424fa39e440910979/src%2Flibsyntax%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/798e389e578a0199f734c79424fa39e440910979/src%2Flibsyntax%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferror_codes.rs?ref=798e389e578a0199f734c79424fa39e440910979", "patch": "@@ -1,379 +0,0 @@\n-// Error messages for EXXXX errors.\n-// Each message should start and end with a new line, and be wrapped to 80\n-// characters.  In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use\n-// `:set tw=0` to disable.\n-register_diagnostics! {\n-\n-E0536: r##\"\n-The `not` cfg-predicate was malformed.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0536\n-#[cfg(not())] // error: expected 1 cfg-pattern\n-pub fn something() {}\n-\n-pub fn main() {}\n-```\n-\n-The `not` predicate expects one cfg-pattern. Example:\n-\n-```\n-#[cfg(not(target_os = \"linux\"))] // ok!\n-pub fn something() {}\n-\n-pub fn main() {}\n-```\n-\n-For more information about the cfg attribute, read:\n-https://doc.rust-lang.org/reference.html#conditional-compilation\n-\"##,\n-\n-E0537: r##\"\n-An unknown predicate was used inside the `cfg` attribute.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0537\n-#[cfg(unknown())] // error: invalid predicate `unknown`\n-pub fn something() {}\n-\n-pub fn main() {}\n-```\n-\n-The `cfg` attribute supports only three kinds of predicates:\n-\n- * any\n- * all\n- * not\n-\n-Example:\n-\n-```\n-#[cfg(not(target_os = \"linux\"))] // ok!\n-pub fn something() {}\n-\n-pub fn main() {}\n-```\n-\n-For more information about the cfg attribute, read:\n-https://doc.rust-lang.org/reference.html#conditional-compilation\n-\"##,\n-\n-E0538: r##\"\n-Attribute contains same meta item more than once.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0538\n-#[deprecated(\n-    since=\"1.0.0\",\n-    note=\"First deprecation note.\",\n-    note=\"Second deprecation note.\" // error: multiple same meta item\n-)]\n-fn deprecated_function() {}\n-```\n-\n-Meta items are the key-value pairs inside of an attribute. Each key may only be\n-used once in each attribute.\n-\n-To fix the problem, remove all but one of the meta items with the same key.\n-\n-Example:\n-\n-```\n-#[deprecated(\n-    since=\"1.0.0\",\n-    note=\"First deprecation note.\"\n-)]\n-fn deprecated_function() {}\n-```\n-\"##,\n-\n-E0541: r##\"\n-An unknown meta item was used.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0541\n-#[deprecated(\n-    since=\"1.0.0\",\n-    // error: unknown meta item\n-    reason=\"Example invalid meta item. Should be 'note'\")\n-]\n-fn deprecated_function() {}\n-```\n-\n-Meta items are the key-value pairs inside of an attribute. The keys provided\n-must be one of the valid keys for the specified attribute.\n-\n-To fix the problem, either remove the unknown meta item, or rename it if you\n-provided the wrong name.\n-\n-In the erroneous code example above, the wrong name was provided, so changing\n-to a correct one it will fix the error. Example:\n-\n-```\n-#[deprecated(\n-    since=\"1.0.0\",\n-    note=\"This is a valid meta item for the deprecated attribute.\"\n-)]\n-fn deprecated_function() {}\n-```\n-\"##,\n-\n-E0550: r##\"\n-More than one `deprecated` attribute has been put on an item.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0550\n-#[deprecated(note = \"because why not?\")]\n-#[deprecated(note = \"right?\")] // error!\n-fn the_banished() {}\n-```\n-\n-The `deprecated` attribute can only be present **once** on an item.\n-\n-```\n-#[deprecated(note = \"because why not, right?\")]\n-fn the_banished() {} // ok!\n-```\n-\"##,\n-\n-E0551: r##\"\n-An invalid meta-item was used inside an attribute.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0551\n-#[deprecated(note)] // error!\n-fn i_am_deprecated() {}\n-```\n-\n-Meta items are the key-value pairs inside of an attribute. To fix this issue,\n-you need to give a value to the `note` key. Example:\n-\n-```\n-#[deprecated(note = \"because\")] // ok!\n-fn i_am_deprecated() {}\n-```\n-\"##,\n-\n-E0552: r##\"\n-A unrecognized representation attribute was used.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0552\n-#[repr(D)] // error: unrecognized representation hint\n-struct MyStruct {\n-    my_field: usize\n-}\n-```\n-\n-You can use a `repr` attribute to tell the compiler how you want a struct or\n-enum to be laid out in memory.\n-\n-Make sure you're using one of the supported options:\n-\n-```\n-#[repr(C)] // ok!\n-struct MyStruct {\n-    my_field: usize\n-}\n-```\n-\n-For more information about specifying representations, see the [\"Alternative\n-Representations\" section] of the Rustonomicon.\n-\n-[\"Alternative Representations\" section]: https://doc.rust-lang.org/nomicon/other-reprs.html\n-\"##,\n-\n-E0554: r##\"\n-Feature attributes are only allowed on the nightly release channel. Stable or\n-beta compilers will not comply.\n-\n-Example of erroneous code (on a stable compiler):\n-\n-```ignore (depends on release channel)\n-#![feature(non_ascii_idents)] // error: `#![feature]` may not be used on the\n-                              //        stable release channel\n-```\n-\n-If you need the feature, make sure to use a nightly release of the compiler\n-(but be warned that the feature may be removed or altered in the future).\n-\"##,\n-\n-E0556: r##\"\n-The `feature` attribute was badly formed.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0556\n-#![feature(foo_bar_baz, foo(bar), foo = \"baz\", foo)] // error!\n-#![feature] // error!\n-#![feature = \"foo\"] // error!\n-```\n-\n-The `feature` attribute only accept a \"feature flag\" and can only be used on\n-nightly. Example:\n-\n-```ignore (only works in nightly)\n-#![feature(flag)]\n-```\n-\"##,\n-\n-E0557: r##\"\n-A feature attribute named a feature that has been removed.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0557\n-#![feature(managed_boxes)] // error: feature has been removed\n-```\n-\n-Delete the offending feature attribute.\n-\"##,\n-\n-E0565: r##\"\n-A literal was used in a built-in attribute that doesn't support literals.\n-\n-Erroneous code example:\n-\n-```ignore (compile_fail not working here; see Issue #43707)\n-#[inline(\"always\")] // error: unsupported literal\n-pub fn something() {}\n-```\n-\n-Literals in attributes are new and largely unsupported in built-in attributes.\n-Work to support literals where appropriate is ongoing. Try using an unquoted\n-name instead:\n-\n-```\n-#[inline(always)]\n-pub fn something() {}\n-```\n-\"##,\n-\n-E0589: r##\"\n-The value of `N` that was specified for `repr(align(N))` was not a power\n-of two, or was greater than 2^29.\n-\n-```compile_fail,E0589\n-#[repr(align(15))] // error: invalid `repr(align)` attribute: not a power of two\n-enum Foo {\n-    Bar(u64),\n-}\n-```\n-\"##,\n-\n-E0658: r##\"\n-An unstable feature was used.\n-\n-Erroneous code example:\n-\n-```compile_fail,E658\n-#[repr(u128)] // error: use of unstable library feature 'repr128'\n-enum Foo {\n-    Bar(u64),\n-}\n-```\n-\n-If you're using a stable or a beta version of rustc, you won't be able to use\n-any unstable features. In order to do so, please switch to a nightly version of\n-rustc (by using rustup).\n-\n-If you're using a nightly version of rustc, just add the corresponding feature\n-to be able to use it:\n-\n-```\n-#![feature(repr128)]\n-\n-#[repr(u128)] // ok!\n-enum Foo {\n-    Bar(u64),\n-}\n-```\n-\"##,\n-\n-E0633: r##\"\n-The `unwind` attribute was malformed.\n-\n-Erroneous code example:\n-\n-```ignore (compile_fail not working here; see Issue #43707)\n-#[unwind()] // error: expected one argument\n-pub extern fn something() {}\n-\n-fn main() {}\n-```\n-\n-The `#[unwind]` attribute should be used as follows:\n-\n-- `#[unwind(aborts)]` -- specifies that if a non-Rust ABI function\n-  should abort the process if it attempts to unwind. This is the safer\n-  and preferred option.\n-\n-- `#[unwind(allowed)]` -- specifies that a non-Rust ABI function\n-  should be allowed to unwind. This can easily result in Undefined\n-  Behavior (UB), so be careful.\n-\n-NB. The default behavior here is \"allowed\", but this is unspecified\n-and likely to change in the future.\n-\n-\"##,\n-\n-E0705: r##\"\n-A `#![feature]` attribute was declared for a feature that is stable in\n-the current edition, but not in all editions.\n-\n-Erroneous code example:\n-\n-```ignore (limited to a warning during 2018 edition development)\n-#![feature(rust_2018_preview)]\n-#![feature(test_2018_feature)] // error: the feature\n-                               // `test_2018_feature` is\n-                               // included in the Rust 2018 edition\n-```\n-\"##,\n-\n-E0725: r##\"\n-A feature attribute named a feature that was disallowed in the compiler\n-command line flags.\n-\n-Erroneous code example:\n-\n-```ignore (can't specify compiler flags from doctests)\n-#![feature(never_type)] // error: the feature `never_type` is not in\n-                        // the list of allowed features\n-```\n-\n-Delete the offending feature attribute, or add it to the list of allowed\n-features in the `-Z allow_features` flag.\n-\"##,\n-\n-;\n-\n-    E0539, // incorrect meta item\n-    E0540, // multiple rustc_deprecated attributes\n-    E0542, // missing 'since'\n-    E0543, // missing 'reason'\n-    E0544, // multiple stability levels\n-    E0545, // incorrect 'issue'\n-    E0546, // missing 'feature'\n-    E0547, // missing 'issue'\n-//  E0548, // replaced with a generic attribute input check\n-    // rustc_deprecated attribute must be paired with either stable or unstable\n-    // attribute\n-    E0549,\n-    E0553, // multiple rustc_const_unstable attributes\n-//  E0555, // replaced with a generic attribute input check\n-    E0629, // missing 'feature' (rustc_const_unstable)\n-    // rustc_const_unstable attribute must be paired with stable/unstable\n-    // attribute\n-    E0630,\n-    E0693, // incorrect `repr(align)` attribute format\n-//  E0694, // an unknown tool name found in scoped attributes\n-    E0717, // rustc_promotable without stability attribute\n-}"}, {"sha": "2bc990574f7a878a838bec630a98415978506f96", "filename": "src/libsyntax_ext/error_codes.rs", "status": "removed", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/798e389e578a0199f734c79424fa39e440910979/src%2Flibsyntax_ext%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/798e389e578a0199f734c79424fa39e440910979/src%2Flibsyntax_ext%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ferror_codes.rs?ref=798e389e578a0199f734c79424fa39e440910979", "patch": "@@ -1,120 +0,0 @@\n-// Error messages for EXXXX errors.\n-// Each message should start and end with a new line, and be wrapped to 80\n-// characters.  In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use\n-// `:set tw=0` to disable.\n-syntax::register_diagnostics! {\n-E0660: r##\"\n-The argument to the `asm` macro is not well-formed.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0660\n-asm!(\"nop\" \"nop\");\n-```\n-\n-Considering that this would be a long explanation, we instead recommend you to\n-take a look at the unstable book:\n-https://doc.rust-lang.org/unstable-book/language-features/asm.html\n-\"##,\n-\n-E0661: r##\"\n-An invalid syntax was passed to the second argument of an `asm` macro line.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0661\n-let a;\n-asm!(\"nop\" : \"r\"(a));\n-```\n-\n-Considering that this would be a long explanation, we instead recommend you to\n-take a look at the unstable book:\n-https://doc.rust-lang.org/unstable-book/language-features/asm.html\n-\"##,\n-\n-E0662: r##\"\n-An invalid input operand constraint was passed to the `asm` macro (third line).\n-\n-Erroneous code example:\n-\n-```compile_fail,E0662\n-asm!(\"xor %eax, %eax\"\n-     :\n-     : \"=test\"(\"a\")\n-    );\n-```\n-\n-Considering that this would be a long explanation, we instead recommend you to\n-take a look at the unstable book:\n-https://doc.rust-lang.org/unstable-book/language-features/asm.html\n-\"##,\n-\n-E0663: r##\"\n-An invalid input operand constraint was passed to the `asm` macro (third line).\n-\n-Erroneous code example:\n-\n-```compile_fail,E0663\n-asm!(\"xor %eax, %eax\"\n-     :\n-     : \"+test\"(\"a\")\n-    );\n-```\n-\n-Considering that this would be a long explanation, we instead recommend you to\n-take a look at the unstable book:\n-https://doc.rust-lang.org/unstable-book/language-features/asm.html\n-\"##,\n-\n-E0664: r##\"\n-A clobber was surrounded by braces in the `asm` macro.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0664\n-asm!(\"mov $$0x200, %eax\"\n-     :\n-     :\n-     : \"{eax}\"\n-    );\n-```\n-\n-Considering that this would be a long explanation, we instead recommend you to\n-take a look at the unstable book:\n-https://doc.rust-lang.org/unstable-book/language-features/asm.html\n-\"##,\n-\n-E0665: r##\"\n-The `Default` trait was derived on an enum.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0665\n-#[derive(Default)]\n-enum Food {\n-    Sweet,\n-    Salty,\n-}\n-```\n-\n-The `Default` cannot be derived on an enum for the simple reason that the\n-compiler doesn't know which value to pick by default whereas it can for a\n-struct as long as all its fields implement the `Default` trait as well.\n-\n-If you still want to implement `Default` on your enum, you'll have to do it \"by\n-hand\":\n-\n-```\n-enum Food {\n-    Sweet,\n-    Salty,\n-}\n-\n-impl Default for Food {\n-    fn default() -> Food {\n-        Food::Sweet\n-    }\n-}\n-```\n-\"##,\n-}"}]}