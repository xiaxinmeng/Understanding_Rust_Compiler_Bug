{"sha": "a1486af7c124deb3fe70f5d591218495c53d230c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExNDg2YWY3YzEyNGRlYjNmZTcwZjVkNTkxMjE4NDk1YzUzZDIzMGM=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2018-04-08T06:57:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-04-08T06:57:24Z"}, "message": "Merge pull request #2630 from estk/fix-2613\n\nAdd rules for write!() / writeln!() similar to those in print!() / println!()", "tree": {"sha": "287fa4fcae09d062db79efae3b6db385e79c9b4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/287fa4fcae09d062db79efae3b6db385e79c9b4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1486af7c124deb3fe70f5d591218495c53d230c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJayb1UCRBK7hj4Ov3rIwAAdHIIABnSUfkqexHMmhCUt7bPGNUe\nBRji9Bs+5HR1Llql1JXuqQ3J2Zv6puxnRu+Z7N1GrKT/XTZOar/7YsPPEZ63SyRJ\nv+5lmQ3mG1vwlSIobnlvut+DNflYV1Zly/KTfMgCjSzkvK97IbKAaVf9gybgct7e\nJyQWs+UlsasqitRx+g3KGjFfkXOqDOICriJa+gEPeJHYEzJrbC7k6Da4H2JtYTYX\nnBVFo1cO/2JszSHgkBw/MrW8HJWH5krZPqRt5/W8S3Xg9w0oAYfXioIZM1pVDoKl\nuoGdicMlBN+yvrQ7lVumblZiOBSy9B07Ot88TdCy6RLm3g5r5J+da8zOKiWWZSI=\n=x9G0\n-----END PGP SIGNATURE-----\n", "payload": "tree 287fa4fcae09d062db79efae3b6db385e79c9b4c\nparent 22df45f1ac5e7574c3afa655a370f603c8c0cdf1\nparent d7129919172d3f4df4e985d377b5ade41a345e9f\nauthor Oliver Schneider <oli-obk@users.noreply.github.com> 1523170644 +0200\ncommitter GitHub <noreply@github.com> 1523170644 +0200\n\nMerge pull request #2630 from estk/fix-2613\n\nAdd rules for write!() / writeln!() similar to those in print!() / println!()"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1486af7c124deb3fe70f5d591218495c53d230c", "html_url": "https://github.com/rust-lang/rust/commit/a1486af7c124deb3fe70f5d591218495c53d230c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1486af7c124deb3fe70f5d591218495c53d230c/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22df45f1ac5e7574c3afa655a370f603c8c0cdf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/22df45f1ac5e7574c3afa655a370f603c8c0cdf1", "html_url": "https://github.com/rust-lang/rust/commit/22df45f1ac5e7574c3afa655a370f603c8c0cdf1"}, {"sha": "d7129919172d3f4df4e985d377b5ade41a345e9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7129919172d3f4df4e985d377b5ade41a345e9f", "html_url": "https://github.com/rust-lang/rust/commit/d7129919172d3f4df4e985d377b5ade41a345e9f"}], "stats": {"total": 967, "additions": 663, "deletions": 304}, "files": [{"sha": "64661b1f545be11a3d60601880288d52dd44b06b", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a1486af7c124deb3fe70f5d591218495c53d230c/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1486af7c124deb3fe70f5d591218495c53d230c/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=a1486af7c124deb3fe70f5d591218495c53d230c", "patch": "@@ -10,7 +10,6 @@\n #![feature(macro_vis_matcher)]\n #![allow(unknown_lints, indexing_slicing, shadow_reuse, missing_docs_in_private_items)]\n #![recursion_limit = \"256\"]\n-\n // FIXME(mark-i-m) remove after i128 stablization merges\n #![allow(stable_features)]\n #![feature(i128, i128_type)]\n@@ -172,7 +171,6 @@ pub mod overflow_check_conditional;\n pub mod panic;\n pub mod partialeq_ne_impl;\n pub mod precedence;\n-pub mod print;\n pub mod ptr;\n pub mod question_mark;\n pub mod ranges;\n@@ -195,6 +193,7 @@ pub mod unused_io_amount;\n pub mod unused_label;\n pub mod use_self;\n pub mod vec;\n+pub mod write;\n pub mod zero_div_zero;\n // end lints modules, do not remove this comment, it\u2019s used in `update_lints`\n \n@@ -343,7 +342,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box strings::StringLitAsBytes);\n     reg.register_late_lint_pass(box derive::Derive);\n     reg.register_late_lint_pass(box types::CharLitAsU8);\n-    reg.register_late_lint_pass(box print::Pass);\n+    reg.register_late_lint_pass(box write::Pass);\n     reg.register_late_lint_pass(box vec::Pass);\n     reg.register_early_lint_pass(box non_expressive_names::NonExpressiveNames {\n         single_char_binding_names_threshold: conf.single_char_binding_names_threshold,\n@@ -418,8 +417,8 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         methods::WRONG_PUB_SELF_CONVENTION,\n         misc::FLOAT_CMP_CONST,\n         missing_doc::MISSING_DOCS_IN_PRIVATE_ITEMS,\n-        print::PRINT_STDOUT,\n-        print::USE_DEBUG,\n+        write::PRINT_STDOUT,\n+        write::USE_DEBUG,\n         shadow::SHADOW_REUSE,\n         shadow::SHADOW_SAME,\n         shadow::SHADOW_UNRELATED,\n@@ -610,9 +609,9 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         panic::PANIC_PARAMS,\n         partialeq_ne_impl::PARTIALEQ_NE_IMPL,\n         precedence::PRECEDENCE,\n-        print::PRINT_LITERAL,\n-        print::PRINT_WITH_NEWLINE,\n-        print::PRINTLN_EMPTY_STRING,\n+        write::PRINT_LITERAL,\n+        write::PRINT_WITH_NEWLINE,\n+        write::PRINTLN_EMPTY_STRING,\n         ptr::CMP_NULL,\n         ptr::MUT_FROM_REF,\n         ptr::PTR_ARG,\n@@ -724,9 +723,9 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         non_expressive_names::MANY_SINGLE_CHAR_NAMES,\n         ok_if_let::IF_LET_SOME_RESULT,\n         panic::PANIC_PARAMS,\n-        print::PRINT_LITERAL,\n-        print::PRINT_WITH_NEWLINE,\n-        print::PRINTLN_EMPTY_STRING,\n+        write::PRINT_LITERAL,\n+        write::PRINT_WITH_NEWLINE,\n+        write::PRINTLN_EMPTY_STRING,\n         ptr::CMP_NULL,\n         ptr::PTR_ARG,\n         question_mark::QUESTION_MARK,"}, {"sha": "ddfe6d68f4a0591180f627d9edc4536226566278", "filename": "clippy_lints/src/print.rs", "status": "removed", "additions": 0, "deletions": 292, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/22df45f1ac5e7574c3afa655a370f603c8c0cdf1/clippy_lints%2Fsrc%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22df45f1ac5e7574c3afa655a370f603c8c0cdf1/clippy_lints%2Fsrc%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprint.rs?ref=22df45f1ac5e7574c3afa655a370f603c8c0cdf1", "patch": "@@ -1,292 +0,0 @@\n-use std::ops::Deref;\n-use rustc::hir::*;\n-use rustc::hir::map::Node::{NodeImplItem, NodeItem};\n-use rustc::lint::*;\n-use syntax::ast::LitKind;\n-use syntax::symbol::InternedString;\n-use syntax_pos::Span;\n-use utils::{is_expn_of, match_def_path, match_path, resolve_node, span_lint, span_lint_and_sugg};\n-use utils::{opt_def_id, paths};\n-\n-/// **What it does:** This lint warns when you use `println!(\"\")` to\n-/// print a newline.\n-///\n-/// **Why is this bad?** You should use `println!()`, which is simpler.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// println!(\"\");\n-/// ```\n-declare_clippy_lint! {\n-    pub PRINTLN_EMPTY_STRING,\n-    style,\n-    \"using `println!(\\\"\\\")` with an empty string\"\n-}\n-\n-/// **What it does:** This lint warns when you use `print!()` with a format\n-/// string that\n-/// ends in a newline.\n-///\n-/// **Why is this bad?** You should use `println!()` instead, which appends the\n-/// newline.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// print!(\"Hello {}!\\n\", name);\n-/// ```\n-declare_clippy_lint! {\n-    pub PRINT_WITH_NEWLINE,\n-    style,\n-    \"using `print!()` with a format string that ends in a newline\"\n-}\n-\n-/// **What it does:** Checks for printing on *stdout*. The purpose of this lint\n-/// is to catch debugging remnants.\n-///\n-/// **Why is this bad?** People often print on *stdout* while debugging an\n-/// application and might forget to remove those prints afterward.\n-///\n-/// **Known problems:** Only catches `print!` and `println!` calls.\n-///\n-/// **Example:**\n-/// ```rust\n-/// println!(\"Hello world!\");\n-/// ```\n-declare_clippy_lint! {\n-    pub PRINT_STDOUT,\n-    restriction,\n-    \"printing on stdout\"\n-}\n-\n-/// **What it does:** Checks for use of `Debug` formatting. The purpose of this\n-/// lint is to catch debugging remnants.\n-///\n-/// **Why is this bad?** The purpose of the `Debug` trait is to facilitate\n-/// debugging Rust code. It should not be used in in user-facing output.\n-///\n-/// **Example:**\n-/// ```rust\n-/// println!(\"{:?}\", foo);\n-/// ```\n-declare_clippy_lint! {\n-    pub USE_DEBUG,\n-    restriction,\n-    \"use of `Debug`-based formatting\"\n-}\n-\n-/// **What it does:** This lint warns about the use of literals as `print!`/`println!` args.\n-///\n-/// **Why is this bad?** Using literals as `println!` args is inefficient\n-/// (c.f., https://github.com/matthiaskrgr/rust-str-bench) and unnecessary\n-/// (i.e., just put the literal in the format string)\n-///\n-/// **Known problems:** Will also warn with macro calls as arguments that expand to literals\n-/// -- e.g., `println!(\"{}\", env!(\"FOO\"))`.\n-///\n-/// **Example:**\n-/// ```rust\n-/// println!(\"{}\", \"foo\");\n-/// ```\n-declare_clippy_lint! {\n-    pub PRINT_LITERAL,\n-    style,\n-    \"printing a literal with a format string\"\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub struct Pass;\n-\n-impl LintPass for Pass {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(PRINT_WITH_NEWLINE, PRINTLN_EMPTY_STRING, PRINT_STDOUT, USE_DEBUG, PRINT_LITERAL)\n-    }\n-}\n-\n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if_chain! {\n-            if let ExprCall(ref fun, ref args) = expr.node;\n-            if let ExprPath(ref qpath) = fun.node;\n-            if let Some(fun_id) = opt_def_id(resolve_node(cx, qpath, fun.hir_id));\n-            then {\n-\n-                // Search for `std::io::_print(..)` which is unique in a\n-                // `print!` expansion.\n-                if match_def_path(cx.tcx, fun_id, &paths::IO_PRINT) {\n-                    if let Some(span) = is_expn_of(expr.span, \"print\") {\n-                        // `println!` uses `print!`.\n-                        let (span, name) = match is_expn_of(span, \"println\") {\n-                            Some(span) => (span, \"println\"),\n-                            None => (span, \"print\"),\n-                        };\n-\n-                        span_lint(cx, PRINT_STDOUT, span, &format!(\"use of `{}!`\", name));\n-\n-                        // Check for literals in the print!/println! args\n-                        // Also, ensure the format string is `{}` with no special options, like `{:X}`\n-                        check_print_args_for_literal(cx, args);\n-\n-                        if_chain! {\n-                            // ensure we're calling Arguments::new_v1\n-                            if args.len() == 1;\n-                            if let ExprCall(ref args_fun, ref args_args) = args[0].node;\n-                            if let ExprPath(ref qpath) = args_fun.node;\n-                            if let Some(const_def_id) = opt_def_id(resolve_node(cx, qpath, args_fun.hir_id));\n-                            if match_def_path(cx.tcx, const_def_id, &paths::FMT_ARGUMENTS_NEWV1);\n-                            if args_args.len() == 2;\n-                            if let ExprAddrOf(_, ref match_expr) = args_args[1].node;\n-                            if let ExprMatch(ref args, _, _) = match_expr.node;\n-                            if let ExprTup(ref args) = args.node;\n-                            if let Some((fmtstr, fmtlen)) = get_argument_fmtstr_parts(&args_args[0]);\n-                            then {\n-                                match name {\n-                                    \"print\" => check_print(cx, span, args, fmtstr, fmtlen),\n-                                    \"println\" => check_println(cx, span, fmtstr, fmtlen),\n-                                    _ => (),\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                // Search for something like\n-                // `::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Debug::fmt)`\n-                else if args.len() == 2 && match_def_path(cx.tcx, fun_id, &paths::FMT_ARGUMENTV1_NEW) {\n-                    if let ExprPath(ref qpath) = args[1].node {\n-                        if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, args[1].hir_id)) {\n-                            if match_def_path(cx.tcx, def_id, &paths::DEBUG_FMT_METHOD)\n-                                    && !is_in_debug_impl(cx, expr) && is_expn_of(expr.span, \"panic\").is_none() {\n-                                span_lint(cx, USE_DEBUG, args[0].span, \"use of `Debug`-based formatting\");\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-// Check for literals in print!/println! args\n-// ensuring the format string for the literal is `DISPLAY_FMT_METHOD`\n-// e.g., `println!(\"... {} ...\", \"foo\")`\n-//                                ^ literal in `println!`\n-fn check_print_args_for_literal<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    args: &HirVec<Expr>\n-) {\n-    if_chain! {\n-        if args.len() == 1;\n-        if let ExprCall(_, ref args_args) = args[0].node;\n-        if args_args.len() > 1;\n-        if let ExprAddrOf(_, ref match_expr) = args_args[1].node;\n-        if let ExprMatch(ref matchee, ref arms, _) = match_expr.node;\n-        if let ExprTup(ref tup) = matchee.node;\n-        if arms.len() == 1;\n-        if let ExprArray(ref arm_body_exprs) = arms[0].body.node;\n-        then {\n-            // it doesn't matter how many args there are in the `print!`/`println!`,\n-            // if there's one literal, we should warn the user\n-            for (idx, tup_arg) in tup.iter().enumerate() {\n-                if_chain! {\n-                    // first, make sure we're dealing with a literal (i.e., an ExprLit)\n-                    if let ExprAddrOf(_, ref tup_val) = tup_arg.node;\n-                    if let ExprLit(_) = tup_val.node;\n-\n-                    // next, check the corresponding match arm body to ensure\n-                    // this is \"{}\", or DISPLAY_FMT_METHOD\n-                    if let ExprCall(_, ref body_args) = arm_body_exprs[idx].node;\n-                    if body_args.len() == 2;\n-                    if let ExprPath(ref body_qpath) = body_args[1].node;\n-                    if let Some(fun_def_id) = opt_def_id(resolve_node(cx, body_qpath, body_args[1].hir_id));\n-                    if match_def_path(cx.tcx, fun_def_id, &paths::DISPLAY_FMT_METHOD) ||\n-                       match_def_path(cx.tcx, fun_def_id, &paths::DEBUG_FMT_METHOD);\n-                    then {\n-                        span_lint(cx, PRINT_LITERAL, tup_val.span, \"printing a literal with an empty format string\");\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-// Check for print!(\"... \\n\", ...).\n-fn check_print<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    span: Span,\n-    args: &HirVec<Expr>,\n-    fmtstr: InternedString,\n-    fmtlen: usize,\n-) {\n-    if_chain! {\n-        // check the final format string part\n-        if let Some('\\n') = fmtstr.chars().last();\n-\n-        // \"foo{}bar\" is made into two strings + one argument,\n-        // if the format string starts with `{}` (eg. \"{}foo\"),\n-        // the string array is prepended an empty string \"\".\n-        // We only want to check the last string after any `{}`:\n-        if args.len() < fmtlen;\n-        then {\n-            span_lint(cx, PRINT_WITH_NEWLINE, span,\n-                      \"using `print!()` with a format string that ends in a \\\n-                       newline, consider using `println!()` instead\");\n-        }\n-    }\n-}\n-\n-/// Check for println!(\"\")\n-fn check_println<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, span: Span, fmtstr: InternedString, fmtlen: usize) {\n-    if_chain! {\n-        // check that the string is empty\n-        if fmtlen == 1;\n-        if fmtstr.deref() == \"\\n\";\n-\n-        // check the presence of that string\n-        if let Ok(snippet) = cx.sess().codemap().span_to_snippet(span);\n-        if snippet.contains(\"\\\"\\\"\");\n-        then {\n-            span_lint_and_sugg(\n-                cx,\n-                PRINT_WITH_NEWLINE,\n-                span,\n-                \"using `println!(\\\"\\\")`\",\n-                \"replace it with\",\n-                \"println!()\".to_string(),\n-            );\n-         }\n-    }\n-}\n-\n-fn is_in_debug_impl(cx: &LateContext, expr: &Expr) -> bool {\n-    let map = &cx.tcx.hir;\n-\n-    // `fmt` method\n-    if let Some(NodeImplItem(item)) = map.find(map.get_parent(expr.id)) {\n-        // `Debug` impl\n-        if let Some(NodeItem(item)) = map.find(map.get_parent(item.id)) {\n-            if let ItemImpl(_, _, _, _, Some(ref tr), _, _) = item.node {\n-                return match_path(&tr.path, &[\"Debug\"]);\n-            }\n-        }\n-    }\n-\n-    false\n-}\n-\n-/// Returns the slice of format string parts in an `Arguments::new_v1` call.\n-fn get_argument_fmtstr_parts(expr: &Expr) -> Option<(InternedString, usize)> {\n-    if_chain! {\n-        if let ExprAddrOf(_, ref expr) = expr.node; // &[\"\u2026\", \"\u2026\", \u2026]\n-        if let ExprArray(ref exprs) = expr.node;\n-        if let Some(expr) = exprs.last();\n-        if let ExprLit(ref lit) = expr.node;\n-        if let LitKind::Str(ref lit, _) = lit.node;\n-        then {\n-            return Some((lit.as_str(), exprs.len()));\n-        }\n-    }\n-    None\n-}"}, {"sha": "8f823c12cf328fe8901be46c9737e9fcbff0a74d", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1486af7c124deb3fe70f5d591218495c53d230c/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1486af7c124deb3fe70f5d591218495c53d230c/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=a1486af7c124deb3fe70f5d591218495c53d230c", "patch": "@@ -26,6 +26,7 @@ pub const DISPLAY_FMT_METHOD: [&str; 4] = [\"core\", \"fmt\", \"Display\", \"fmt\"];\n pub const DOUBLE_ENDED_ITERATOR: [&str; 4] = [\"core\", \"iter\", \"traits\", \"DoubleEndedIterator\"];\n pub const DROP: [&str; 3] = [\"core\", \"mem\", \"drop\"];\n pub const FMT_ARGUMENTS_NEWV1: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1\"];\n+pub const FMT_ARGUMENTS_NEWV1FORMATTED: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1_formatted\"];\n pub const FMT_ARGUMENTV1_NEW: [&str; 4] = [\"core\", \"fmt\", \"ArgumentV1\", \"new\"];\n pub const FROM_FROM: [&str; 4] = [\"core\", \"convert\", \"From\", \"from\"];\n pub const FROM_TRAIT: [&str; 3] = [\"core\", \"convert\", \"From\"];"}, {"sha": "0531c14cba8b0f527eac06c9abf6801eee6ad799", "filename": "clippy_lints/src/write.rs", "status": "added", "additions": 437, "deletions": 0, "changes": 437, "blob_url": "https://github.com/rust-lang/rust/blob/a1486af7c124deb3fe70f5d591218495c53d230c/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1486af7c124deb3fe70f5d591218495c53d230c/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=a1486af7c124deb3fe70f5d591218495c53d230c", "patch": "@@ -0,0 +1,437 @@\n+use rustc::hir::map::Node::{NodeImplItem, NodeItem};\n+use rustc::hir::*;\n+use rustc::lint::*;\n+use std::ops::Deref;\n+use syntax::ast::LitKind;\n+use syntax::ptr;\n+use syntax::symbol::InternedString;\n+use syntax_pos::Span;\n+use utils::{is_expn_of, match_def_path, match_path, resolve_node, span_lint, span_lint_and_sugg};\n+use utils::{opt_def_id, paths};\n+\n+/// **What it does:** This lint warns when you use `println!(\"\")` to\n+/// print a newline.\n+///\n+/// **Why is this bad?** You should use `println!()`, which is simpler.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// println!(\"\");\n+/// ```\n+declare_clippy_lint! {\n+    pub PRINTLN_EMPTY_STRING,\n+    style,\n+    \"using `println!(\\\"\\\")` with an empty string\"\n+}\n+\n+/// **What it does:** This lint warns when you use `print!()` with a format\n+/// string that\n+/// ends in a newline.\n+///\n+/// **Why is this bad?** You should use `println!()` instead, which appends the\n+/// newline.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// print!(\"Hello {}!\\n\", name);\n+/// ```\n+declare_clippy_lint! {\n+    pub PRINT_WITH_NEWLINE,\n+    style,\n+    \"using `print!()` with a format string that ends in a newline\"\n+}\n+\n+/// **What it does:** Checks for printing on *stdout*. The purpose of this lint\n+/// is to catch debugging remnants.\n+///\n+/// **Why is this bad?** People often print on *stdout* while debugging an\n+/// application and might forget to remove those prints afterward.\n+///\n+/// **Known problems:** Only catches `print!` and `println!` calls.\n+///\n+/// **Example:**\n+/// ```rust\n+/// println!(\"Hello world!\");\n+/// ```\n+declare_clippy_lint! {\n+    pub PRINT_STDOUT,\n+    restriction,\n+    \"printing on stdout\"\n+}\n+\n+/// **What it does:** Checks for use of `Debug` formatting. The purpose of this\n+/// lint is to catch debugging remnants.\n+///\n+/// **Why is this bad?** The purpose of the `Debug` trait is to facilitate\n+/// debugging Rust code. It should not be used in in user-facing output.\n+///\n+/// **Example:**\n+/// ```rust\n+/// println!(\"{:?}\", foo);\n+/// ```\n+declare_clippy_lint! {\n+    pub USE_DEBUG,\n+    restriction,\n+    \"use of `Debug`-based formatting\"\n+}\n+\n+/// **What it does:** This lint warns about the use of literals as `print!`/`println!` args.\n+///\n+/// **Why is this bad?** Using literals as `println!` args is inefficient\n+/// (c.f., https://github.com/matthiaskrgr/rust-str-bench) and unnecessary\n+/// (i.e., just put the literal in the format string)\n+///\n+/// **Known problems:** Will also warn with macro calls as arguments that expand to literals\n+/// -- e.g., `println!(\"{}\", env!(\"FOO\"))`.\n+///\n+/// **Example:**\n+/// ```rust\n+/// println!(\"{}\", \"foo\");\n+/// ```\n+declare_clippy_lint! {\n+    pub PRINT_LITERAL,\n+    style,\n+    \"printing a literal with a format string\"\n+}\n+\n+/// **What it does:** This lint warns when you use `writeln!(buf, \"\")` to\n+/// print a newline.\n+///\n+/// **Why is this bad?** You should use `writeln!(buf)`, which is simpler.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// writeln!(\"\");\n+/// ```\n+declare_clippy_lint! {\n+    pub WRITELN_EMPTY_STRING,\n+    style,\n+    \"using `writeln!(\\\"\\\")` with an empty string\"\n+}\n+\n+/// **What it does:** This lint warns when you use `write!()` with a format\n+/// string that\n+/// ends in a newline.\n+///\n+/// **Why is this bad?** You should use `writeln!()` instead, which appends the\n+/// newline.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// write!(buf, \"Hello {}!\\n\", name);\n+/// ```\n+declare_clippy_lint! {\n+    pub WRITE_WITH_NEWLINE,\n+    style,\n+    \"using `write!()` with a format string that ends in a newline\"\n+}\n+\n+/// **What it does:** This lint warns about the use of literals as `write!`/`writeln!` args.\n+///\n+/// **Why is this bad?** Using literals as `writeln!` args is inefficient\n+/// (c.f., https://github.com/matthiaskrgr/rust-str-bench) and unnecessary\n+/// (i.e., just put the literal in the format string)\n+///\n+/// **Known problems:** Will also warn with macro calls as arguments that expand to literals\n+/// -- e.g., `writeln!(buf, \"{}\", env!(\"FOO\"))`.\n+///\n+/// **Example:**\n+/// ```rust\n+/// writeln!(buf, \"{}\", \"foo\");\n+/// ```\n+declare_clippy_lint! {\n+    pub WRITE_LITERAL,\n+    style,\n+    \"writing a literal with a format string\"\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct Pass;\n+\n+impl LintPass for Pass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(\n+            PRINT_WITH_NEWLINE,\n+            PRINTLN_EMPTY_STRING,\n+            PRINT_STDOUT,\n+            USE_DEBUG,\n+            PRINT_LITERAL,\n+            WRITE_WITH_NEWLINE,\n+            WRITELN_EMPTY_STRING,\n+            WRITE_LITERAL\n+        )\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+        match expr.node {\n+            // print!()\n+            ExprCall(ref fun, ref args) => {\n+                if_chain! {\n+                    if let ExprPath(ref qpath) = fun.node;\n+                    if let Some(fun_id) = opt_def_id(resolve_node(cx, qpath, fun.hir_id));\n+                    then {\n+                        check_print_variants(cx, expr, fun_id, args);\n+                    }\n+                }\n+            },\n+            // write!()\n+            ExprMethodCall(ref fun, _, ref args) => {\n+                if fun.name == \"write_fmt\" {\n+                    check_write_variants(cx, expr, args);\n+                }\n+            },\n+            _ => (),\n+        }\n+    }\n+}\n+\n+fn check_write_variants<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, write_args: &ptr::P<[Expr]>) {\n+    // `writeln!` uses `write!`.\n+    if let Some(span) = is_expn_of(expr.span, \"write\") {\n+        let (span, name) = match is_expn_of(span, \"writeln\") {\n+            Some(span) => (span, \"writeln\"),\n+            None => (span, \"write\"),\n+        };\n+\n+        if_chain! {\n+            // ensure we're calling Arguments::new_v1 or Arguments::new_v1_formatted\n+            if write_args.len() == 2;\n+            if let ExprCall(ref args_fun, ref args_args) = write_args[1].node;\n+            if let ExprPath(ref qpath) = args_fun.node;\n+            if let Some(const_def_id) = opt_def_id(resolve_node(cx, qpath, args_fun.hir_id));\n+            if match_def_path(cx.tcx, const_def_id, &paths::FMT_ARGUMENTS_NEWV1) ||\n+               match_def_path(cx.tcx, const_def_id, &paths::FMT_ARGUMENTS_NEWV1FORMATTED);\n+            then {\n+                // Check for literals in the write!/writeln! args\n+                check_fmt_args_for_literal(cx, args_args, |span| {\n+                    span_lint(cx, WRITE_LITERAL, span, \"writing a literal with an empty format string\");\n+                });\n+\n+                if_chain! {\n+                    if args_args.len() >= 2;\n+                    if let ExprAddrOf(_, ref match_expr) = args_args[1].node;\n+                    if let ExprMatch(ref args, _, _) = match_expr.node;\n+                    if let ExprTup(ref args) = args.node;\n+                    if let Some((fmtstr, fmtlen)) = get_argument_fmtstr_parts(&args_args[0]);\n+                    then {\n+                        match name {\n+                            \"write\" => if has_newline_end(args, fmtstr, fmtlen) {\n+                                span_lint(cx, WRITE_WITH_NEWLINE, span,\n+                                        \"using `write!()` with a format string that ends in a \\\n+                                        newline, consider using `writeln!()` instead\");\n+                            },\n+                            \"writeln\" => if has_empty_arg(cx, span, fmtstr, fmtlen) {\n+                                span_lint_and_sugg(\n+                                    cx,\n+                                    WRITE_WITH_NEWLINE,\n+                                    span,\n+                                    \"using `writeln!(v, \\\"\\\")`\",\n+                                    \"replace it with\",\n+                                    \"writeln!(v)\".to_string(),\n+                                );\n+                            },\n+                            _ => (),\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn check_print_variants<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &'tcx Expr,\n+    fun_id: def_id::DefId,\n+    args: &ptr::P<[Expr]>,\n+) {\n+    // Search for `std::io::_print(..)` which is unique in a\n+    // `print!` expansion.\n+    if match_def_path(cx.tcx, fun_id, &paths::IO_PRINT) {\n+        if let Some(span) = is_expn_of(expr.span, \"print\") {\n+            // `println!` uses `print!`.\n+            let (span, name) = match is_expn_of(span, \"println\") {\n+                Some(span) => (span, \"println\"),\n+                None => (span, \"print\"),\n+            };\n+\n+            span_lint(cx, PRINT_STDOUT, span, &format!(\"use of `{}!`\", name));\n+\n+            if_chain! {\n+                // ensure we're calling Arguments::new_v1\n+                if args.len() == 1;\n+                if let ExprCall(ref args_fun, ref args_args) = args[0].node;\n+                then {\n+                    // Check for literals in the print!/println! args\n+                    check_fmt_args_for_literal(cx, args_args, |span| {\n+                        span_lint(cx, PRINT_LITERAL, span, \"printing a literal with an empty format string\");\n+                    });\n+\n+                    if_chain! {\n+                        if let ExprPath(ref qpath) = args_fun.node;\n+                        if let Some(const_def_id) = opt_def_id(resolve_node(cx, qpath, args_fun.hir_id));\n+                        if match_def_path(cx.tcx, const_def_id, &paths::FMT_ARGUMENTS_NEWV1);\n+                        if args_args.len() == 2;\n+                        if let ExprAddrOf(_, ref match_expr) = args_args[1].node;\n+                        if let ExprMatch(ref args, _, _) = match_expr.node;\n+                        if let ExprTup(ref args) = args.node;\n+                        if let Some((fmtstr, fmtlen)) = get_argument_fmtstr_parts(&args_args[0]);\n+                        then {\n+                            match name {\n+                                \"print\" =>\n+                                    if has_newline_end(args, fmtstr, fmtlen) {\n+                                        span_lint(cx, PRINT_WITH_NEWLINE, span,\n+                                                \"using `print!()` with a format string that ends in a \\\n+                                                newline, consider using `println!()` instead\");\n+                                    },\n+                                \"println\" =>\n+                                    if has_empty_arg(cx, span, fmtstr, fmtlen) {\n+                                        span_lint_and_sugg(\n+                                            cx,\n+                                            PRINT_WITH_NEWLINE,\n+                                            span,\n+                                            \"using `println!(\\\"\\\")`\",\n+                                            \"replace it with\",\n+                                            \"println!()\".to_string(),\n+                                        );\n+                                    },\n+                                _ => (),\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    // Search for something like\n+    // `::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Debug::fmt)`\n+    else if args.len() == 2 && match_def_path(cx.tcx, fun_id, &paths::FMT_ARGUMENTV1_NEW) {\n+        if let ExprPath(ref qpath) = args[1].node {\n+            if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, args[1].hir_id)) {\n+                if match_def_path(cx.tcx, def_id, &paths::DEBUG_FMT_METHOD) && !is_in_debug_impl(cx, expr)\n+                    && is_expn_of(expr.span, \"panic\").is_none()\n+                {\n+                    span_lint(cx, USE_DEBUG, args[0].span, \"use of `Debug`-based formatting\");\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// Check for literals in write!/writeln! and print!/println! args\n+// ensuring the format string for the literal is `DISPLAY_FMT_METHOD`\n+// e.g., `writeln!(buf, \"... {} ...\", \"foo\")`\n+//                                    ^ literal in `writeln!`\n+// e.g., `println!(\"... {} ...\", \"foo\")`\n+//                                ^ literal in `println!`\n+fn check_fmt_args_for_literal<'a, 'tcx, F>(cx: &LateContext<'a, 'tcx>, args: &HirVec<Expr>, lint_fn: F)\n+where\n+    F: Fn(Span),\n+{\n+    if_chain! {\n+        if args.len() > 1;\n+        if let ExprAddrOf(_, ref match_expr) = args[1].node;\n+        if let ExprMatch(ref matchee, ref arms, _) = match_expr.node;\n+        if let ExprTup(ref tup) = matchee.node;\n+        if arms.len() == 1;\n+        if let ExprArray(ref arm_body_exprs) = arms[0].body.node;\n+        then {\n+            // it doesn't matter how many args there are in the `write!`/`writeln!`,\n+            // if there's one literal, we should warn the user\n+            for (idx, tup_arg) in tup.iter().enumerate() {\n+                if_chain! {\n+                    // first, make sure we're dealing with a literal (i.e., an ExprLit)\n+                    if let ExprAddrOf(_, ref tup_val) = tup_arg.node;\n+                    if let ExprLit(_) = tup_val.node;\n+\n+                    // next, check the corresponding match arm body to ensure\n+                    // this is \"{}\", or DISPLAY_FMT_METHOD\n+                    if let ExprCall(_, ref body_args) = arm_body_exprs[idx].node;\n+                    if body_args.len() == 2;\n+                    if let ExprPath(ref body_qpath) = body_args[1].node;\n+                    if let Some(fun_def_id) = opt_def_id(resolve_node(cx, body_qpath, body_args[1].hir_id));\n+                    if match_def_path(cx.tcx, fun_def_id, &paths::DISPLAY_FMT_METHOD) ||\n+                       match_def_path(cx.tcx, fun_def_id, &paths::DEBUG_FMT_METHOD);\n+                    then {\n+                        lint_fn(tup_val.span);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Check for fmtstr = \"... \\n\"\n+fn has_newline_end(args: &HirVec<Expr>, fmtstr: InternedString, fmtlen: usize) -> bool {\n+    if_chain! {\n+        // check the final format string part\n+        if let Some('\\n') = fmtstr.chars().last();\n+\n+        // \"foo{}bar\" is made into two strings + one argument,\n+        // if the format string starts with `{}` (eg. \"{}foo\"),\n+        // the string array is prepended an empty string \"\".\n+        // We only want to check the last string after any `{}`:\n+        if args.len() < fmtlen;\n+        then {\n+            return true\n+        }\n+    }\n+    false\n+}\n+\n+/// Check for writeln!(v, \"\") / println!(\"\")\n+fn has_empty_arg<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, span: Span, fmtstr: InternedString, fmtlen: usize) -> bool {\n+    if_chain! {\n+        // check that the string is empty\n+        if fmtlen == 1;\n+        if fmtstr.deref() == \"\\n\";\n+\n+        // check the presence of that string\n+        if let Ok(snippet) = cx.sess().codemap().span_to_snippet(span);\n+        if snippet.contains(\"\\\"\\\"\");\n+        then {\n+            return true\n+        }\n+    }\n+    false\n+}\n+\n+/// Returns the slice of format string parts in an `Arguments::new_v1` call.\n+fn get_argument_fmtstr_parts(expr: &Expr) -> Option<(InternedString, usize)> {\n+    if_chain! {\n+        if let ExprAddrOf(_, ref expr) = expr.node; // &[\"\u2026\", \"\u2026\", \u2026]\n+        if let ExprArray(ref exprs) = expr.node;\n+        if let Some(expr) = exprs.last();\n+        if let ExprLit(ref lit) = expr.node;\n+        if let LitKind::Str(ref lit, _) = lit.node;\n+        then {\n+            return Some((lit.as_str(), exprs.len()));\n+        }\n+    }\n+    None\n+}\n+\n+fn is_in_debug_impl(cx: &LateContext, expr: &Expr) -> bool {\n+    let map = &cx.tcx.hir;\n+\n+    // `fmt` method\n+    if let Some(NodeImplItem(item)) = map.find(map.get_parent(expr.id)) {\n+        // `Debug` impl\n+        if let Some(NodeItem(item)) = map.find(map.get_parent(item.id)) {\n+            if let ItemImpl(_, _, _, _, Some(ref tr), _, _) = item.node {\n+                return match_path(&tr.path, &[\"Debug\"]);\n+            }\n+        }\n+    }\n+    false\n+}"}, {"sha": "8719a691d43538958991539fc4acbf98185cdb58", "filename": "tests/ui/print.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1486af7c124deb3fe70f5d591218495c53d230c/tests%2Fui%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1486af7c124deb3fe70f5d591218495c53d230c/tests%2Fui%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint.rs?ref=a1486af7c124deb3fe70f5d591218495c53d230c", "patch": "@@ -1,6 +1,6 @@\n \n \n-#![allow(print_literal)]\n+#![allow(print_literal, write_literal)]\n #![warn(print_stdout, use_debug)]\n \n use std::fmt::{Debug, Display, Formatter, Result};"}, {"sha": "dd3a869eb4eb73464b678280f004ea887a3e84fd", "filename": "tests/ui/write_literal.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a1486af7c124deb3fe70f5d591218495c53d230c/tests%2Fui%2Fwrite_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1486af7c124deb3fe70f5d591218495c53d230c/tests%2Fui%2Fwrite_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_literal.rs?ref=a1486af7c124deb3fe70f5d591218495c53d230c", "patch": "@@ -0,0 +1,35 @@\n+#![allow(unused_must_use)]\n+#![warn(write_literal)]\n+\n+use std::io::Write;\n+\n+fn main() {\n+    let mut v = Vec::new();\n+\n+    // These should be fine\n+    write!(&mut v, \"Hello\");\n+    writeln!(&mut v, \"Hello\");\n+    let world = \"world\";\n+    writeln!(&mut v, \"Hello {}\", world);\n+    writeln!(&mut v, \"3 in hex is {:X}\", 3);\n+\n+    // These should throw warnings\n+    write!(&mut v, \"Hello {}\", \"world\");\n+    writeln!(&mut v, \"Hello {} {}\", world, \"world\");\n+    writeln!(&mut v, \"Hello {}\", \"world\");\n+    writeln!(&mut v, \"10 / 4 is {}\", 2.5);\n+    writeln!(&mut v, \"2 + 1 = {}\", 3);\n+    writeln!(&mut v, \"2 + 1 = {:.4}\", 3);\n+    writeln!(&mut v, \"2 + 1 = {:5.4}\", 3);\n+    writeln!(&mut v, \"Debug test {:?}\", \"hello, world\");\n+\n+    // positional args don't change the fact\n+    // that we're using a literal -- this should\n+    // throw a warning\n+    writeln!(&mut v, \"{0} {1}\", \"hello\", \"world\");\n+    writeln!(&mut v, \"{1} {0}\", \"hello\", \"world\");\n+\n+    // named args shouldn't change anything either\n+    writeln!(&mut v, \"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n+    writeln!(&mut v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n+}"}, {"sha": "9c068f1332d4be89d07f83e9730ea7f9a9d04063", "filename": "tests/ui/write_literal.stderr", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/a1486af7c124deb3fe70f5d591218495c53d230c/tests%2Fui%2Fwrite_literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1486af7c124deb3fe70f5d591218495c53d230c/tests%2Fui%2Fwrite_literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_literal.stderr?ref=a1486af7c124deb3fe70f5d591218495c53d230c", "patch": "@@ -0,0 +1,100 @@\n+error: writing a literal with an empty format string\n+  --> $DIR/write_literal.rs:17:32\n+   |\n+17 |     write!(&mut v, \"Hello {}\", \"world\");\n+   |                                ^^^^^^^\n+   |\n+   = note: `-D write-literal` implied by `-D warnings`\n+\n+error: writing a literal with an empty format string\n+  --> $DIR/write_literal.rs:18:44\n+   |\n+18 |     writeln!(&mut v, \"Hello {} {}\", world, \"world\");\n+   |                                            ^^^^^^^\n+\n+error: writing a literal with an empty format string\n+  --> $DIR/write_literal.rs:19:34\n+   |\n+19 |     writeln!(&mut v, \"Hello {}\", \"world\");\n+   |                                  ^^^^^^^\n+\n+error: writing a literal with an empty format string\n+  --> $DIR/write_literal.rs:20:38\n+   |\n+20 |     writeln!(&mut v, \"10 / 4 is {}\", 2.5);\n+   |                                      ^^^\n+\n+error: writing a literal with an empty format string\n+  --> $DIR/write_literal.rs:21:36\n+   |\n+21 |     writeln!(&mut v, \"2 + 1 = {}\", 3);\n+   |                                    ^\n+\n+error: writing a literal with an empty format string\n+  --> $DIR/write_literal.rs:22:39\n+   |\n+22 |     writeln!(&mut v, \"2 + 1 = {:.4}\", 3);\n+   |                                       ^\n+\n+error: writing a literal with an empty format string\n+  --> $DIR/write_literal.rs:23:40\n+   |\n+23 |     writeln!(&mut v, \"2 + 1 = {:5.4}\", 3);\n+   |                                        ^\n+\n+error: writing a literal with an empty format string\n+  --> $DIR/write_literal.rs:24:41\n+   |\n+24 |     writeln!(&mut v, \"Debug test {:?}\", \"hello, world\");\n+   |                                         ^^^^^^^^^^^^^^\n+\n+error: writing a literal with an empty format string\n+  --> $DIR/write_literal.rs:29:33\n+   |\n+29 |     writeln!(&mut v, \"{0} {1}\", \"hello\", \"world\");\n+   |                                 ^^^^^^^\n+\n+error: writing a literal with an empty format string\n+  --> $DIR/write_literal.rs:29:42\n+   |\n+29 |     writeln!(&mut v, \"{0} {1}\", \"hello\", \"world\");\n+   |                                          ^^^^^^^\n+\n+error: writing a literal with an empty format string\n+  --> $DIR/write_literal.rs:30:33\n+   |\n+30 |     writeln!(&mut v, \"{1} {0}\", \"hello\", \"world\");\n+   |                                 ^^^^^^^\n+\n+error: writing a literal with an empty format string\n+  --> $DIR/write_literal.rs:30:42\n+   |\n+30 |     writeln!(&mut v, \"{1} {0}\", \"hello\", \"world\");\n+   |                                          ^^^^^^^\n+\n+error: writing a literal with an empty format string\n+  --> $DIR/write_literal.rs:33:43\n+   |\n+33 |     writeln!(&mut v, \"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n+   |                                           ^^^^^^^\n+\n+error: writing a literal with an empty format string\n+  --> $DIR/write_literal.rs:33:58\n+   |\n+33 |     writeln!(&mut v, \"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n+   |                                                          ^^^^^^^\n+\n+error: writing a literal with an empty format string\n+  --> $DIR/write_literal.rs:34:43\n+   |\n+34 |     writeln!(&mut v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n+   |                                           ^^^^^^^\n+\n+error: writing a literal with an empty format string\n+  --> $DIR/write_literal.rs:34:58\n+   |\n+34 |     writeln!(&mut v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n+   |                                                          ^^^^^^^\n+\n+error: aborting due to 16 previous errors\n+"}, {"sha": "0427bd3ec04a6cadb84f1ab7745da5789afd6380", "filename": "tests/ui/write_with_newline.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a1486af7c124deb3fe70f5d591218495c53d230c/tests%2Fui%2Fwrite_with_newline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1486af7c124deb3fe70f5d591218495c53d230c/tests%2Fui%2Fwrite_with_newline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_with_newline.rs?ref=a1486af7c124deb3fe70f5d591218495c53d230c", "patch": "@@ -0,0 +1,25 @@\n+#![allow(write_literal)]\n+#![warn(write_with_newline)]\n+\n+use std::io::Write;\n+\n+fn main() {\n+    let mut v = Vec::new();\n+\n+    // These should fail\n+    write!(&mut v, \"Hello\\n\");\n+    write!(&mut v, \"Hello {}\\n\", \"world\");\n+    write!(&mut v, \"Hello {} {}\\n\\n\", \"world\", \"#2\");\n+    write!(&mut v, \"{}\\n\", 1265);\n+\n+    // These should be fine\n+    write!(&mut v, \"\");\n+    write!(&mut v, \"Hello\");\n+    writeln!(&mut v, \"Hello\");\n+    writeln!(&mut v, \"Hello\\n\");\n+    writeln!(&mut v, \"Hello {}\\n\", \"world\");\n+    write!(&mut v, \"Issue\\n{}\", 1265);\n+    write!(&mut v, \"{}\", 1265);\n+    write!(&mut v, \"\\n{}\", 1275);\n+\n+}"}, {"sha": "37f03afb016b62621fe122c9f353af69dcbe0aa6", "filename": "tests/ui/write_with_newline.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a1486af7c124deb3fe70f5d591218495c53d230c/tests%2Fui%2Fwrite_with_newline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1486af7c124deb3fe70f5d591218495c53d230c/tests%2Fui%2Fwrite_with_newline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_with_newline.stderr?ref=a1486af7c124deb3fe70f5d591218495c53d230c", "patch": "@@ -0,0 +1,28 @@\n+error: using `write!()` with a format string that ends in a newline, consider using `writeln!()` instead\n+  --> $DIR/write_with_newline.rs:10:5\n+   |\n+10 |     write!(&mut v, \"Hello/n\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D write-with-newline` implied by `-D warnings`\n+\n+error: using `write!()` with a format string that ends in a newline, consider using `writeln!()` instead\n+  --> $DIR/write_with_newline.rs:11:5\n+   |\n+11 |     write!(&mut v, \"Hello {}/n\", \"world\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: using `write!()` with a format string that ends in a newline, consider using `writeln!()` instead\n+  --> $DIR/write_with_newline.rs:12:5\n+   |\n+12 |     write!(&mut v, \"Hello {} {}/n/n\", \"world\", \"#2\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: using `write!()` with a format string that ends in a newline, consider using `writeln!()` instead\n+  --> $DIR/write_with_newline.rs:13:5\n+   |\n+13 |     write!(&mut v, \"{}/n\", 1265);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "c7092eb8c4b00fbdaf6df8131558856a4dc3cf69", "filename": "tests/ui/writeln_empty_string.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a1486af7c124deb3fe70f5d591218495c53d230c/tests%2Fui%2Fwriteln_empty_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1486af7c124deb3fe70f5d591218495c53d230c/tests%2Fui%2Fwriteln_empty_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwriteln_empty_string.rs?ref=a1486af7c124deb3fe70f5d591218495c53d230c", "patch": "@@ -0,0 +1,16 @@\n+#![allow(unused_must_use)]\n+#![warn(writeln_empty_string)]\n+use std::io::Write;\n+\n+fn main() {\n+    let mut v = Vec::new();\n+\n+    // This should fail\n+    writeln!(&mut v, \"\");\n+\n+    // These should be fine\n+    writeln!(&mut v);\n+    writeln!(&mut v, \" \");\n+    write!(&mut v, \"\");\n+\n+}"}, {"sha": "e20aad779d93f870e5cee0a8e956fb52693df494", "filename": "tests/ui/writeln_empty_string.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a1486af7c124deb3fe70f5d591218495c53d230c/tests%2Fui%2Fwriteln_empty_string.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1486af7c124deb3fe70f5d591218495c53d230c/tests%2Fui%2Fwriteln_empty_string.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwriteln_empty_string.stderr?ref=a1486af7c124deb3fe70f5d591218495c53d230c", "patch": "@@ -0,0 +1,10 @@\n+error: using `writeln!(v, \"\")`\n+ --> $DIR/writeln_empty_string.rs:9:5\n+  |\n+9 |     writeln!(&mut v, \"\");\n+  |     ^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `writeln!(v)`\n+  |\n+  = note: `-D write-with-newline` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}]}