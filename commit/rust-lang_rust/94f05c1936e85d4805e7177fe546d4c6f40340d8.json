{"sha": "94f05c1936e85d4805e7177fe546d4c6f40340d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0ZjA1YzE5MzZlODVkNDgwNWU3MTc3ZmU1NDZkNGM2ZjQwMzQwZDg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-01T22:08:36Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-01T22:10:41Z"}, "message": "rustc: Stop overwriting trait static method types when checking generic trait refs. Closes #3903. rs=blocking-burg", "tree": {"sha": "06d3875f263ce585c99a3e031c2e284a8533fa28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06d3875f263ce585c99a3e031c2e284a8533fa28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94f05c1936e85d4805e7177fe546d4c6f40340d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94f05c1936e85d4805e7177fe546d4c6f40340d8", "html_url": "https://github.com/rust-lang/rust/commit/94f05c1936e85d4805e7177fe546d4c6f40340d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94f05c1936e85d4805e7177fe546d4c6f40340d8/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d8df9947fae1c55a1de9b461ae142059c1edcac", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d8df9947fae1c55a1de9b461ae142059c1edcac", "html_url": "https://github.com/rust-lang/rust/commit/3d8df9947fae1c55a1de9b461ae142059c1edcac"}], "stats": {"total": 72, "additions": 66, "deletions": 6}, "files": [{"sha": "bfd6d5a44e8fb1698d6029f4ac324812b719d2a5", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/94f05c1936e85d4805e7177fe546d4c6f40340d8/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f05c1936e85d4805e7177fe546d4c6f40340d8/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=94f05c1936e85d4805e7177fe546d4c6f40340d8", "patch": "@@ -100,6 +100,10 @@ fn lookup_vtable_covariant(fcx: @fn_ctxt,\n                            allow_unsafe: bool,\n                            is_early: bool)\n                         -> Option<vtable_origin> {\n+\tdebug!(\"lookup_vtable_covariant(ty: %s, trait_ty=%s)\",\n+\t\t   fcx.infcx().ty_to_str(ty),\n+\t\t   fcx.infcx().ty_to_str(trait_ty));\n+\n     let worklist = dvec::DVec();\n     worklist.push(trait_ty);\n     while worklist.len() > 0 {\n@@ -475,9 +479,16 @@ fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n       ast::expr_path(*) => {\n         match fcx.opt_node_ty_substs(ex.id) {\n           Some(ref substs) => {\n-            let did = ast_util::def_id_of_def(cx.tcx.def_map.get(ex.id));\n+\t\t  \tlet def = cx.tcx.def_map.get(ex.id);\n+            let did = ast_util::def_id_of_def(def);\n+\t\t\tdebug!(\"early resolve expr: def %?\", def);\n             let item_ty = ty::lookup_item_type(cx.tcx, did);\n             if has_trait_bounds(*item_ty.bounds) {\n+\t\t\t\tfor item_ty.bounds.each |bounds| {\n+\t\t\t\t\tdebug!(\"early_resolve_expr: looking up vtables for bound \\\n+\t\t\t\t\t\t\t%s\",\n+\t\t\t\t\t\t   ty::param_bounds_to_str(fcx.tcx(), *bounds));\n+\t\t\t\t}\n                 let vtbls = lookup_vtables(fcx, ex, item_ty.bounds,\n                                            substs, false, is_early);\n                 if !is_early { cx.vtable_map.insert(ex.id, vtbls); }"}, {"sha": "ca12e355636a3eba40f424971cab0226f34b2431", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/94f05c1936e85d4805e7177fe546d4c6f40340d8/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f05c1936e85d4805e7177fe546d4c6f40340d8/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=94f05c1936e85d4805e7177fe546d4c6f40340d8", "patch": "@@ -231,10 +231,11 @@ fn ensure_trait_methods(ccx: @crate_ctxt, id: ast::node_id, trait_ty: ty::t) {\n             let trait_bounds = ty_param_bounds(ccx, params);\n             let ty_m = trait_method_to_ty_method(*m);\n             let method_ty = ty_of_ty_method(ccx, ty_m, region_paramd, def_id);\n-            if ty_m.self_ty.node == ast::sty_static {\n-                make_static_method_ty(ccx, ty_m, region_paramd,\n-                                      method_ty, trait_ty, trait_bounds);\n-            }\n+\t\t\tif ty_m.self_ty.node == ast::sty_static {\n+\t\t\t\tmake_static_method_ty(ccx, ty_m, region_paramd,\n+\t\t\t\t\t\t\t\t\t  method_ty, trait_ty,\n+\t\t\t\t\t\t\t\t\t  trait_bounds);\n+\t\t\t}\n             method_ty\n         });\n       }\n@@ -420,9 +421,25 @@ fn check_methods_against_trait(ccx: @crate_ctxt,\n \n     let tcx = ccx.tcx;\n     let (did, tpt) = instantiate_trait_ref(ccx, a_trait_ty, rp);\n+\n     if did.crate == ast::local_crate {\n-        ensure_trait_methods(ccx, did.node, tpt.ty);\n+\t\t// NB: This is subtle. We need to do this on the type of the trait\n+\t\t// item *itself*, not on the type that includes the parameter\n+\t\t// substitutions provided by the programmer at this particular\n+\t\t// trait ref. Otherwise, we will potentially overwrite the types of\n+\t\t// the methods within the trait with bogus results. (See issue #3903.)\n+\n+\t\tmatch tcx.items.find(did.node) {\n+\t\t\tSome(ast_map::node_item(item, _)) => {\n+\t\t\t\tlet tpt = ty_of_item(ccx, item);\n+\t\t\t\tensure_trait_methods(ccx, did.node, tpt.ty);\n+\t\t\t}\n+\t\t\t_ => {\n+\t\t\t\ttcx.sess.bug(~\"trait ref didn't resolve to trait\");\n+\t\t\t}\n+\t\t}\n     }\n+\n     for vec::each(*ty::trait_methods(tcx, did)) |trait_m| {\n         match vec::find(impl_ms, |impl_m| trait_m.ident == impl_m.mty.ident) {\n             Some(ref cm) => {"}, {"sha": "a47e27d245196add722642085639cca0f63bfe88", "filename": "src/test/run-pass/trait-static-method-overwriting.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/94f05c1936e85d4805e7177fe546d4c6f40340d8/src%2Ftest%2Frun-pass%2Ftrait-static-method-overwriting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f05c1936e85d4805e7177fe546d4c6f40340d8/src%2Ftest%2Frun-pass%2Ftrait-static-method-overwriting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-static-method-overwriting.rs?ref=94f05c1936e85d4805e7177fe546d4c6f40340d8", "patch": "@@ -0,0 +1,32 @@\n+mod base {\n+    pub trait HasNew<T> {\n+        static pure fn new() -> T;\n+    }\n+\n+    pub struct Foo {\n+        dummy: (),\n+    }\n+\n+    pub impl Foo : base::HasNew<Foo> {\n+        static pure fn new() -> Foo {\n+\t\t\tunsafe { io::println(\"Foo\"); }\n+            Foo { dummy: () }\n+        }\n+    }\n+\n+    pub struct Bar {\n+        dummy: (),\n+    }\n+\n+    pub impl Bar : base::HasNew<Bar> {\n+        static pure fn new() -> Bar {\n+\t\t\tunsafe { io::println(\"Bar\"); }\n+            Bar { dummy: () }\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let f: base::Foo = base::new::<base::Foo, base::Foo>();\n+\tlet b: base::Bar = base::new::<base::Bar, base::Bar>();\n+}"}]}