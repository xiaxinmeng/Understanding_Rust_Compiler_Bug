{"sha": "3a54117ffcb4ac496ebcc53a3b52bf26656775fd", "node_id": "C_kwDOAAsO6NoAKDNhNTQxMTdmZmNiNGFjNDk2ZWJjYzUzYTNiNTJiZjI2NjU2Nzc1ZmQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-19T16:11:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-19T16:11:48Z"}, "message": "Auto merge of #8804 - Jarcho:in_recursion, r=Alexendoo\n\nRework `only_used_in_recursion`\n\nfixes #8782\nfixes #8629\nfixes #8560\nfixes #8556\n\nThis is a complete rewrite of the lint. This loses some capabilities of the old implementation. Namely the ability to track through tuple and slice patterns, as well as the ability to trace through assignments.\n\nThe two reported bugs are fixed with this. One was caused by using the name of the method rather than resolving to the `DefId` of the called method. The second was cause by using the existence of a cycle in the dependency graph to determine whether the parameter was used in recursion even though there were other ways to create a cycle in the graph.\n\nImplementation wise this switches from using a visitor to walking up the tree from every use of each parameter until it has been determined the parameter is used for something other than recursion. This is likely to perform better as it avoids walking the entire function a second time, and it is unlikely to walk up the HIR tree very much. Some cases would perform worse though.\n\ncc `@buttercrab`\n\nchangelog: Scale back `only_used_in_recursion` to fix false positives\nchangelog: Move `only_used_in_recursion` back to `complexity`", "tree": {"sha": "e0fcc0f724234c2d36f0f18f80e37101aa9a740c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0fcc0f724234c2d36f0f18f80e37101aa9a740c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a54117ffcb4ac496ebcc53a3b52bf26656775fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a54117ffcb4ac496ebcc53a3b52bf26656775fd", "html_url": "https://github.com/rust-lang/rust/commit/3a54117ffcb4ac496ebcc53a3b52bf26656775fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a54117ffcb4ac496ebcc53a3b52bf26656775fd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e594de8ec79f89415c610f32c4f1b05a9e393b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e594de8ec79f89415c610f32c4f1b05a9e393b8", "html_url": "https://github.com/rust-lang/rust/commit/3e594de8ec79f89415c610f32c4f1b05a9e393b8"}, {"sha": "39f4bee98e2ad69bb247b57b6d5bc8df0b4f1090", "url": "https://api.github.com/repos/rust-lang/rust/commits/39f4bee98e2ad69bb247b57b6d5bc8df0b4f1090", "html_url": "https://github.com/rust-lang/rust/commit/39f4bee98e2ad69bb247b57b6d5bc8df0b4f1090"}], "stats": {"total": 1327, "additions": 664, "deletions": 663}, "files": [{"sha": "fefac7632d8ef8d3b1613db32b407f00752e8cd1", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a54117ffcb4ac496ebcc53a3b52bf26656775fd/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a54117ffcb4ac496ebcc53a3b52bf26656775fd/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=3a54117ffcb4ac496ebcc53a3b52bf26656775fd", "patch": "@@ -252,6 +252,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(non_expressive_names::JUST_UNDERSCORES_AND_DIGITS),\n     LintId::of(non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS),\n     LintId::of(octal_escapes::OCTAL_ESCAPES),\n+    LintId::of(only_used_in_recursion::ONLY_USED_IN_RECURSION),\n     LintId::of(operators::ABSURD_EXTREME_COMPARISONS),\n     LintId::of(operators::ASSIGN_OP_PATTERN),\n     LintId::of(operators::BAD_BIT_MASK),"}, {"sha": "aa247352f88fb653ccbc6572c45bb74caedc63c7", "filename": "clippy_lints/src/lib.register_complexity.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a54117ffcb4ac496ebcc53a3b52bf26656775fd/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a54117ffcb4ac496ebcc53a3b52bf26656775fd/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=3a54117ffcb4ac496ebcc53a3b52bf26656775fd", "patch": "@@ -72,6 +72,7 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD),\n     LintId::of(no_effect::NO_EFFECT),\n     LintId::of(no_effect::UNNECESSARY_OPERATION),\n+    LintId::of(only_used_in_recursion::ONLY_USED_IN_RECURSION),\n     LintId::of(operators::DOUBLE_COMPARISONS),\n     LintId::of(operators::DURATION_SUBSEC),\n     LintId::of(operators::IDENTITY_OP),"}, {"sha": "7171c655ccc8d67657114a6a326a290ea1c02a68", "filename": "clippy_lints/src/lib.register_nursery.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a54117ffcb4ac496ebcc53a3b52bf26656775fd/clippy_lints%2Fsrc%2Flib.register_nursery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a54117ffcb4ac496ebcc53a3b52bf26656775fd/clippy_lints%2Fsrc%2Flib.register_nursery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_nursery.rs?ref=3a54117ffcb4ac496ebcc53a3b52bf26656775fd", "patch": "@@ -24,7 +24,6 @@ store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n     LintId::of(mutex_atomic::MUTEX_INTEGER),\n     LintId::of(non_send_fields_in_send_ty::NON_SEND_FIELDS_IN_SEND_TY),\n     LintId::of(nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES),\n-    LintId::of(only_used_in_recursion::ONLY_USED_IN_RECURSION),\n     LintId::of(option_if_let_else::OPTION_IF_LET_ELSE),\n     LintId::of(redundant_pub_crate::REDUNDANT_PUB_CRATE),\n     LintId::of(regex::TRIVIAL_REGEX),"}, {"sha": "467051cfa6884035fea61136e674bfcd8b02f4ca", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a54117ffcb4ac496ebcc53a3b52bf26656775fd/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a54117ffcb4ac496ebcc53a3b52bf26656775fd/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=3a54117ffcb4ac496ebcc53a3b52bf26656775fd", "patch": "@@ -860,7 +860,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || Box::new(manual_bits::ManualBits::new(msrv)));\n     store.register_late_pass(|| Box::new(default_union_representation::DefaultUnionRepresentation));\n     store.register_early_pass(|| Box::new(doc_link_with_quotes::DocLinkWithQuotes));\n-    store.register_late_pass(|| Box::new(only_used_in_recursion::OnlyUsedInRecursion));\n+    store.register_late_pass(|| Box::new(only_used_in_recursion::OnlyUsedInRecursion::default()));\n     let allow_dbg_in_tests = conf.allow_dbg_in_tests;\n     store.register_late_pass(move || Box::new(dbg_macro::DbgMacro::new(allow_dbg_in_tests)));\n     let cargo_ignore_publish = conf.cargo_ignore_publish;"}, {"sha": "774a3540d1e0c41bef19b00f44b955664de5c743", "filename": "clippy_lints/src/only_used_in_recursion.rs", "status": "modified", "additions": 286, "deletions": 544, "changes": 830, "blob_url": "https://github.com/rust-lang/rust/blob/3a54117ffcb4ac496ebcc53a3b52bf26656775fd/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a54117ffcb4ac496ebcc53a3b52bf26656775fd/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs?ref=3a54117ffcb4ac496ebcc53a3b52bf26656775fd", "patch": "@@ -1,25 +1,16 @@\n-use std::collections::VecDeque;\n-\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::is_lint_allowed;\n-use itertools::{izip, Itertools};\n-use rustc_ast::{walk_list, Label, Mutability};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::{get_expr_use_or_unification_node, get_parent_node, path_def_id, path_to_local, path_to_local_id};\n+use core::cell::Cell;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n-use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::definitions::{DefPathData, DisambiguatedDefPathData};\n-use rustc_hir::intravisit::{walk_expr, walk_stmt, FnKind, Visitor};\n-use rustc_hir::{\n-    Arm, Block, Body, Closure, Expr, ExprKind, Guard, HirId, ImplicitSelfKind, Let, Local, Pat, PatKind, Path,\n-    PathSegment, QPath, Stmt, StmtKind, TyKind, UnOp,\n-};\n+use rustc_hir::hir_id::HirIdMap;\n+use rustc_hir::{Body, Expr, ExprKind, HirId, ImplItem, ImplItemKind, Node, PatKind, TraitItem, TraitItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n-use rustc_middle::ty::{Ty, TyCtxt, TypeckResults};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::symbol::kw;\n-use rustc_span::symbol::Ident;\n+use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n+use rustc_middle::ty::{self, ConstKind};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::symbol::{kw, Ident};\n use rustc_span::Span;\n \n declare_clippy_lint! {\n@@ -89,572 +80,323 @@ declare_clippy_lint! {\n     /// ```\n     #[clippy::version = \"1.61.0\"]\n     pub ONLY_USED_IN_RECURSION,\n-    nursery,\n+    complexity,\n     \"arguments that is only used in recursion can be removed\"\n }\n-declare_lint_pass!(OnlyUsedInRecursion => [ONLY_USED_IN_RECURSION]);\n-\n-impl<'tcx> LateLintPass<'tcx> for OnlyUsedInRecursion {\n-    fn check_fn(\n-        &mut self,\n-        cx: &LateContext<'tcx>,\n-        kind: FnKind<'tcx>,\n-        decl: &'tcx rustc_hir::FnDecl<'tcx>,\n-        body: &'tcx Body<'tcx>,\n-        _: Span,\n-        id: HirId,\n-    ) {\n-        if is_lint_allowed(cx, ONLY_USED_IN_RECURSION, id) {\n-            return;\n-        }\n-        if let FnKind::ItemFn(ident, ..) | FnKind::Method(ident, ..) = kind {\n-            let def_id = id.owner.to_def_id();\n-            let data = cx.tcx.def_path(def_id).data;\n-\n-            if data.len() > 1 {\n-                match data.get(data.len() - 2) {\n-                    Some(DisambiguatedDefPathData {\n-                        data: DefPathData::Impl,\n-                        disambiguator,\n-                    }) if *disambiguator != 0 => return,\n-                    _ => {},\n-                }\n-            }\n-\n-            let has_self = !matches!(decl.implicit_self, ImplicitSelfKind::None);\n-\n-            let ty_res = cx.typeck_results();\n-            let param_span = body\n-                .params\n-                .iter()\n-                .flat_map(|param| {\n-                    let mut v = Vec::new();\n-                    param.pat.each_binding(|_, hir_id, span, ident| {\n-                        v.push((hir_id, span, ident));\n-                    });\n-                    v\n-                })\n-                .skip(if has_self { 1 } else { 0 })\n-                .filter(|(_, _, ident)| !ident.name.as_str().starts_with('_'))\n-                .collect_vec();\n-\n-            let params = body.params.iter().map(|param| param.pat).collect();\n-\n-            let mut visitor = SideEffectVisit {\n-                graph: FxHashMap::default(),\n-                has_side_effect: FxHashSet::default(),\n-                ret_vars: Vec::new(),\n-                contains_side_effect: false,\n-                break_vars: FxHashMap::default(),\n-                params,\n-                fn_ident: ident,\n-                fn_def_id: def_id,\n-                is_method: matches!(kind, FnKind::Method(..)),\n-                has_self,\n-                ty_res,\n-                tcx: cx.tcx,\n-                visited_exprs: FxHashSet::default(),\n-            };\n-\n-            visitor.visit_expr(&body.value);\n-            let vars = std::mem::take(&mut visitor.ret_vars);\n-            // this would set the return variables to side effect\n-            visitor.add_side_effect(vars);\n-\n-            let mut queue = visitor.has_side_effect.iter().copied().collect::<VecDeque<_>>();\n-\n-            // a simple BFS to check all the variables that have side effect\n-            while let Some(id) = queue.pop_front() {\n-                if let Some(next) = visitor.graph.get(&id) {\n-                    for i in next {\n-                        if !visitor.has_side_effect.contains(i) {\n-                            visitor.has_side_effect.insert(*i);\n-                            queue.push_back(*i);\n-                        }\n-                    }\n-                }\n-            }\n-\n-            for (id, span, ident) in param_span {\n-                // if the variable is not used in recursion, it would be marked as unused\n-                if !visitor.has_side_effect.contains(&id) {\n-                    let mut queue = VecDeque::new();\n-                    let mut visited = FxHashSet::default();\n-\n-                    queue.push_back(id);\n-\n-                    // a simple BFS to check the graph can reach to itself\n-                    // if it can't, it means the variable is never used in recursion\n-                    while let Some(id) = queue.pop_front() {\n-                        if let Some(next) = visitor.graph.get(&id) {\n-                            for i in next {\n-                                if !visited.contains(i) {\n-                                    visited.insert(id);\n-                                    queue.push_back(*i);\n-                                }\n-                            }\n-                        }\n-                    }\n+impl_lint_pass!(OnlyUsedInRecursion => [ONLY_USED_IN_RECURSION]);\n+\n+#[derive(Clone, Copy)]\n+enum FnKind {\n+    Fn,\n+    TraitFn,\n+    // This is a hack. Ideally we would store a `SubstsRef<'tcx>` type here, but a lint pass must be `'static`.\n+    // Substitutions are, however, interned. This allows us to store the pointer as a `usize` when comparing for\n+    // equality.\n+    ImplTraitFn(usize),\n+}\n \n-                    if visited.contains(&id) {\n-                        span_lint_and_sugg(\n-                            cx,\n-                            ONLY_USED_IN_RECURSION,\n-                            span,\n-                            \"parameter is only used in recursion\",\n-                            \"if this is intentional, prefix with an underscore\",\n-                            format!(\"_{}\", ident.name.as_str()),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                }\n-            }\n+struct Param {\n+    /// The function this is a parameter for.\n+    fn_id: DefId,\n+    fn_kind: FnKind,\n+    /// The index of this parameter.\n+    idx: usize,\n+    ident: Ident,\n+    /// Whether this parameter should be linted. Set by `Params::flag_for_linting`.\n+    apply_lint: Cell<bool>,\n+    /// All the uses of this parameter.\n+    uses: Vec<Usage>,\n+}\n+impl Param {\n+    fn new(fn_id: DefId, fn_kind: FnKind, idx: usize, ident: Ident) -> Self {\n+        Self {\n+            fn_id,\n+            fn_kind,\n+            idx,\n+            ident,\n+            apply_lint: Cell::new(true),\n+            uses: Vec::new(),\n         }\n     }\n }\n \n-pub fn is_primitive(ty: Ty<'_>) -> bool {\n-    let ty = ty.peel_refs();\n-    ty.is_primitive() || ty.is_str()\n+#[derive(Debug)]\n+struct Usage {\n+    span: Span,\n+    idx: usize,\n }\n-\n-pub fn is_array(ty: Ty<'_>) -> bool {\n-    let ty = ty.peel_refs();\n-    ty.is_array() || ty.is_array_slice()\n+impl Usage {\n+    fn new(span: Span, idx: usize) -> Self {\n+        Self { span, idx }\n+    }\n }\n \n-/// This builds the graph of side effect.\n-/// The edge `a -> b` means if `a` has side effect, `b` will have side effect.\n-///\n-/// There are some example in following code:\n-/// ```rust, ignore\n-/// let b = 1;\n-/// let a = b; // a -> b\n-/// let (c, d) = (a, b); // c -> b, d -> b\n-///\n-/// let e = if a == 0 { // e -> a\n-///     c // e -> c\n-/// } else {\n-///     d // e -> d\n-/// };\n-/// ```\n-pub struct SideEffectVisit<'tcx> {\n-    graph: FxHashMap<HirId, FxHashSet<HirId>>,\n-    has_side_effect: FxHashSet<HirId>,\n-    // bool for if the variable was dereferenced from mutable reference\n-    ret_vars: Vec<(HirId, bool)>,\n-    contains_side_effect: bool,\n-    // break label\n-    break_vars: FxHashMap<Ident, Vec<(HirId, bool)>>,\n-    params: Vec<&'tcx Pat<'tcx>>,\n-    fn_ident: Ident,\n-    fn_def_id: DefId,\n-    is_method: bool,\n-    has_self: bool,\n-    ty_res: &'tcx TypeckResults<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n-    visited_exprs: FxHashSet<HirId>,\n+/// The parameters being checked by the lint, indexed by both the parameter's `HirId` and the\n+/// `DefId` of the function paired with the parameter's index.\n+#[derive(Default)]\n+struct Params {\n+    params: Vec<Param>,\n+    by_id: HirIdMap<usize>,\n+    by_fn: FxHashMap<(DefId, usize), usize>,\n }\n-\n-impl<'tcx> Visitor<'tcx> for SideEffectVisit<'tcx> {\n-    fn visit_stmt(&mut self, s: &'tcx Stmt<'tcx>) {\n-        match s.kind {\n-            StmtKind::Local(Local {\n-                pat, init: Some(init), ..\n-            }) => {\n-                self.visit_pat_expr(pat, init, false);\n-            },\n-            StmtKind::Item(_) | StmtKind::Expr(_) | StmtKind::Semi(_) => {\n-                walk_stmt(self, s);\n-            },\n-            StmtKind::Local(_) => {},\n-        }\n-        self.ret_vars.clear();\n+impl Params {\n+    fn insert(&mut self, param: Param, id: HirId) {\n+        let idx = self.params.len();\n+        self.by_id.insert(id, idx);\n+        self.by_fn.insert((param.fn_id, param.idx), idx);\n+        self.params.push(param);\n     }\n \n-    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n-        if !self.visited_exprs.insert(ex.hir_id) {\n-            return;\n-        }\n-        match ex.kind {\n-            ExprKind::Array(exprs) | ExprKind::Tup(exprs) => {\n-                self.ret_vars = exprs\n-                    .iter()\n-                    .flat_map(|expr| {\n-                        self.visit_expr(expr);\n-                        std::mem::take(&mut self.ret_vars)\n-                    })\n-                    .collect();\n-            },\n-            ExprKind::Call(callee, args) => self.visit_fn(callee, args),\n-            ExprKind::MethodCall(path, args, _) => self.visit_method_call(path, args),\n-            ExprKind::Binary(_, lhs, rhs) => {\n-                self.visit_bin_op(lhs, rhs);\n-            },\n-            ExprKind::Unary(op, expr) => self.visit_un_op(op, expr),\n-            ExprKind::Let(Let { pat, init, .. }) => self.visit_pat_expr(pat, init, false),\n-            ExprKind::If(bind, then_expr, else_expr) => {\n-                self.visit_if(bind, then_expr, else_expr);\n-            },\n-            ExprKind::Match(expr, arms, _) => self.visit_match(expr, arms),\n-            // since analysing the closure is not easy, just set all variables in it to side-effect\n-            ExprKind::Closure(&Closure { body, .. }) => {\n-                let body = self.tcx.hir().body(body);\n-                self.visit_body(body);\n-                let vars = std::mem::take(&mut self.ret_vars);\n-                self.add_side_effect(vars);\n-            },\n-            ExprKind::Loop(block, label, _, _) | ExprKind::Block(block, label) => {\n-                self.visit_block_label(block, label);\n-            },\n-            ExprKind::Assign(bind, expr, _) => {\n-                self.visit_assign(bind, expr);\n-            },\n-            ExprKind::AssignOp(_, bind, expr) => {\n-                self.visit_assign(bind, expr);\n-                self.visit_bin_op(bind, expr);\n-            },\n-            ExprKind::Field(expr, _) => {\n-                self.visit_expr(expr);\n-                if matches!(self.ty_res.expr_ty(expr).kind(), ty::Ref(_, _, Mutability::Mut)) {\n-                    self.ret_vars.iter_mut().for_each(|(_, b)| *b = true);\n-                }\n-            },\n-            ExprKind::Index(expr, index) => {\n-                self.visit_expr(expr);\n-                let mut vars = std::mem::take(&mut self.ret_vars);\n-                self.visit_expr(index);\n-                self.ret_vars.append(&mut vars);\n-\n-                if !is_array(self.ty_res.expr_ty(expr)) {\n-                    self.add_side_effect(self.ret_vars.clone());\n-                } else if matches!(self.ty_res.expr_ty(expr).kind(), ty::Ref(_, _, Mutability::Mut)) {\n-                    self.ret_vars.iter_mut().for_each(|(_, b)| *b = true);\n-                }\n-            },\n-            ExprKind::Break(dest, Some(expr)) => {\n-                self.visit_expr(expr);\n-                if let Some(label) = dest.label {\n-                    self.break_vars\n-                        .entry(label.ident)\n-                        .or_insert(Vec::new())\n-                        .append(&mut self.ret_vars);\n-                }\n-                self.contains_side_effect = true;\n-            },\n-            ExprKind::Ret(Some(expr)) => {\n-                self.visit_expr(expr);\n-                let vars = std::mem::take(&mut self.ret_vars);\n-                self.add_side_effect(vars);\n-                self.contains_side_effect = true;\n-            },\n-            ExprKind::Break(_, None) | ExprKind::Continue(_) | ExprKind::Ret(None) => {\n-                self.contains_side_effect = true;\n-            },\n-            ExprKind::Struct(_, exprs, expr) => {\n-                let mut ret_vars = exprs\n-                    .iter()\n-                    .flat_map(|field| {\n-                        self.visit_expr(field.expr);\n-                        std::mem::take(&mut self.ret_vars)\n-                    })\n-                    .collect();\n-\n-                walk_list!(self, visit_expr, expr);\n-                self.ret_vars.append(&mut ret_vars);\n-            },\n-            _ => walk_expr(self, ex),\n+    fn remove_by_id(&mut self, id: HirId) {\n+        if let Some(param) = self.get_by_id_mut(id) {\n+            param.uses = Vec::new();\n+            let key = (param.fn_id, param.idx);\n+            self.by_fn.remove(&key);\n+            self.by_id.remove(&id);\n         }\n     }\n \n-    fn visit_path(&mut self, path: &'tcx Path<'tcx>, _id: HirId) {\n-        if let Res::Local(id) = path.res {\n-            self.ret_vars.push((id, false));\n-        }\n+    fn get_by_id_mut(&mut self, id: HirId) -> Option<&mut Param> {\n+        self.params.get_mut(*self.by_id.get(&id)?)\n     }\n-}\n \n-impl<'tcx> SideEffectVisit<'tcx> {\n-    fn visit_assign(&mut self, lhs: &'tcx Expr<'tcx>, rhs: &'tcx Expr<'tcx>) {\n-        // Just support array and tuple unwrapping for now.\n-        //\n-        // ex) `(a, b) = (c, d);`\n-        // The graph would look like this:\n-        //   a -> c\n-        //   b -> d\n-        //\n-        // This would minimize the connection of the side-effect graph.\n-        match (&lhs.kind, &rhs.kind) {\n-            (ExprKind::Array(lhs), ExprKind::Array(rhs)) | (ExprKind::Tup(lhs), ExprKind::Tup(rhs)) => {\n-                // if not, it is a compile error\n-                debug_assert!(lhs.len() == rhs.len());\n-                izip!(*lhs, *rhs).for_each(|(lhs, rhs)| self.visit_assign(lhs, rhs));\n-            },\n-            // in other assigns, we have to connect all each other\n-            // because they can be connected somehow\n-            _ => {\n-                self.visit_expr(lhs);\n-                let lhs_vars = std::mem::take(&mut self.ret_vars);\n-                self.visit_expr(rhs);\n-                let rhs_vars = std::mem::take(&mut self.ret_vars);\n-                self.connect_assign(&lhs_vars, &rhs_vars, false);\n-            },\n-        }\n+    fn get_by_fn(&self, id: DefId, idx: usize) -> Option<&Param> {\n+        self.params.get(*self.by_fn.get(&(id, idx))?)\n     }\n \n-    fn visit_block_label(&mut self, block: &'tcx Block<'tcx>, label: Option<Label>) {\n-        self.visit_block(block);\n-        let _ = label.and_then(|label| {\n-            self.break_vars\n-                .remove(&label.ident)\n-                .map(|mut break_vars| self.ret_vars.append(&mut break_vars))\n-        });\n-    }\n-\n-    fn visit_bin_op(&mut self, lhs: &'tcx Expr<'tcx>, rhs: &'tcx Expr<'tcx>) {\n-        self.visit_expr(lhs);\n-        let mut ret_vars = std::mem::take(&mut self.ret_vars);\n-        self.visit_expr(rhs);\n-        self.ret_vars.append(&mut ret_vars);\n-\n-        // the binary operation between non primitive values are overloaded operators\n-        // so they can have side-effects\n-        if !is_primitive(self.ty_res.expr_ty(lhs)) || !is_primitive(self.ty_res.expr_ty(rhs)) {\n-            self.ret_vars.iter().for_each(|id| {\n-                self.has_side_effect.insert(id.0);\n-            });\n-            self.contains_side_effect = true;\n-        }\n+    fn clear(&mut self) {\n+        self.params.clear();\n+        self.by_id.clear();\n+        self.by_fn.clear();\n     }\n \n-    fn visit_un_op(&mut self, op: UnOp, expr: &'tcx Expr<'tcx>) {\n-        self.visit_expr(expr);\n-        let ty = self.ty_res.expr_ty(expr);\n-        // dereferencing a reference has no side-effect\n-        if !is_primitive(ty) && !matches!((op, ty.kind()), (UnOp::Deref, ty::Ref(..))) {\n-            self.add_side_effect(self.ret_vars.clone());\n-        }\n-\n-        if matches!((op, ty.kind()), (UnOp::Deref, ty::Ref(_, _, Mutability::Mut))) {\n-            self.ret_vars.iter_mut().for_each(|(_, b)| *b = true);\n+    /// Sets the `apply_lint` flag on each parameter.\n+    fn flag_for_linting(&mut self) {\n+        // Stores the list of parameters currently being resolved. Needed to avoid cycles.\n+        let mut eval_stack = Vec::new();\n+        for param in &self.params {\n+            self.try_disable_lint_for_param(param, &mut eval_stack);\n         }\n     }\n \n-    fn visit_pat_expr(&mut self, pat: &'tcx Pat<'tcx>, expr: &'tcx Expr<'tcx>, connect_self: bool) {\n-        match (&pat.kind, &expr.kind) {\n-            (PatKind::Tuple(pats, _), ExprKind::Tup(exprs)) => {\n-                self.ret_vars = izip!(*pats, *exprs)\n-                    .flat_map(|(pat, expr)| {\n-                        self.visit_pat_expr(pat, expr, connect_self);\n-                        std::mem::take(&mut self.ret_vars)\n-                    })\n-                    .collect();\n-            },\n-            (PatKind::Slice(front_exprs, _, back_exprs), ExprKind::Array(exprs)) => {\n-                let mut vars = izip!(*front_exprs, *exprs)\n-                    .flat_map(|(pat, expr)| {\n-                        self.visit_pat_expr(pat, expr, connect_self);\n-                        std::mem::take(&mut self.ret_vars)\n-                    })\n-                    .collect();\n-                self.ret_vars = izip!(back_exprs.iter().rev(), exprs.iter().rev())\n-                    .flat_map(|(pat, expr)| {\n-                        self.visit_pat_expr(pat, expr, connect_self);\n-                        std::mem::take(&mut self.ret_vars)\n-                    })\n-                    .collect();\n-                self.ret_vars.append(&mut vars);\n-            },\n-            _ => {\n-                let mut lhs_vars = Vec::new();\n-                pat.each_binding(|_, id, _, _| lhs_vars.push((id, false)));\n-                self.visit_expr(expr);\n-                let rhs_vars = std::mem::take(&mut self.ret_vars);\n-                self.connect_assign(&lhs_vars, &rhs_vars, connect_self);\n-                self.ret_vars = rhs_vars;\n-            },\n+    // Use by calling `flag_for_linting`.\n+    fn try_disable_lint_for_param(&self, param: &Param, eval_stack: &mut Vec<usize>) -> bool {\n+        if !param.apply_lint.get() {\n+            true\n+        } else if param.uses.is_empty() {\n+            // Don't lint on unused parameters.\n+            param.apply_lint.set(false);\n+            true\n+        } else if eval_stack.contains(&param.idx) {\n+            // Already on the evaluation stack. Returning false will continue to evaluate other dependencies.\n+            false\n+        } else {\n+            eval_stack.push(param.idx);\n+            // Check all cases when used at a different parameter index.\n+            // Needed to catch cases like: `fn f(x: u32, y: u32) { f(y, x) }`\n+            for usage in param.uses.iter().filter(|u| u.idx != param.idx) {\n+                if self\n+                    .get_by_fn(param.fn_id, usage.idx)\n+                    // If the parameter can't be found, then it's used for more than just recursion.\n+                    .map_or(true, |p| self.try_disable_lint_for_param(p, eval_stack))\n+                {\n+                    param.apply_lint.set(false);\n+                    eval_stack.pop();\n+                    return true;\n+                }\n+            }\n+            eval_stack.pop();\n+            false\n         }\n     }\n+}\n \n-    fn visit_fn(&mut self, callee: &'tcx Expr<'tcx>, args: &'tcx [Expr<'tcx>]) {\n-        self.visit_expr(callee);\n-        let mut ret_vars = std::mem::take(&mut self.ret_vars);\n-        self.add_side_effect(ret_vars.clone());\n-\n-        let mut is_recursive = false;\n-\n-        if_chain! {\n-            if !self.has_self;\n-            if let ExprKind::Path(QPath::Resolved(_, path)) = callee.kind;\n-            if let Res::Def(DefKind::Fn, def_id) = path.res;\n-            if self.fn_def_id == def_id;\n-            then {\n-                is_recursive = true;\n-            }\n-        }\n+#[derive(Default)]\n+pub struct OnlyUsedInRecursion {\n+    /// Track the top-level body entered. Needed to delay reporting when entering nested bodies.\n+    entered_body: Option<HirId>,\n+    params: Params,\n+}\n \n-        if_chain! {\n-            if !self.has_self && self.is_method;\n-            if let ExprKind::Path(QPath::TypeRelative(ty, segment)) = callee.kind;\n-            if segment.ident == self.fn_ident;\n-            if let TyKind::Path(QPath::Resolved(_, path)) = ty.kind;\n-            if let Res::SelfTy{ .. } = path.res;\n-            then {\n-                is_recursive = true;\n-            }\n+impl<'tcx> LateLintPass<'tcx> for OnlyUsedInRecursion {\n+    fn check_body(&mut self, cx: &LateContext<'tcx>, body: &'tcx Body<'tcx>) {\n+        if body.value.span.from_expansion() {\n+            return;\n         }\n-\n-        if is_recursive {\n-            izip!(self.params.clone(), args).for_each(|(pat, expr)| {\n-                self.visit_pat_expr(pat, expr, true);\n-                self.ret_vars.clear();\n-            });\n-        } else {\n-            // This would set arguments used in closure that does not have side-effect.\n-            // Closure itself can be detected whether there is a side-effect, but the\n-            // value of variable that is holding closure can change.\n-            // So, we just check the variables.\n-            self.ret_vars = args\n-                .iter()\n-                .flat_map(|expr| {\n-                    self.visit_expr(expr);\n-                    std::mem::take(&mut self.ret_vars)\n-                })\n-                .collect_vec()\n-                .into_iter()\n-                .map(|id| {\n-                    self.has_side_effect.insert(id.0);\n-                    id\n-                })\n-                .collect();\n-            self.contains_side_effect = true;\n+        // `skip_params` is either `0` or `1` to skip the `self` parameter in trait functions.\n+        // It can't be renamed, and it can't be removed without removing it from multiple functions.\n+        let (fn_id, fn_kind, skip_params) = match get_parent_node(cx.tcx, body.value.hir_id) {\n+            Some(Node::Item(i)) => (i.def_id.to_def_id(), FnKind::Fn, 0),\n+            Some(Node::TraitItem(&TraitItem {\n+                kind: TraitItemKind::Fn(ref sig, _),\n+                def_id,\n+                ..\n+            })) => (\n+                def_id.to_def_id(),\n+                FnKind::TraitFn,\n+                if sig.decl.implicit_self.has_implicit_self() {\n+                    1\n+                } else {\n+                    0\n+                },\n+            ),\n+            Some(Node::ImplItem(&ImplItem {\n+                kind: ImplItemKind::Fn(ref sig, _),\n+                def_id,\n+                ..\n+            })) => {\n+                #[allow(trivial_casts)]\n+                if let Some(Node::Item(item)) = get_parent_node(cx.tcx, cx.tcx.hir().local_def_id_to_hir_id(def_id))\n+                    && let Some(trait_ref) = cx.tcx.impl_trait_ref(item.def_id)\n+                    && let Some(trait_item_id) = cx.tcx.associated_item(def_id).trait_item_def_id\n+                {\n+                    (\n+                        trait_item_id,\n+                        FnKind::ImplTraitFn(cx.tcx.erase_regions(trait_ref.substs) as *const _ as usize),\n+                        if sig.decl.implicit_self.has_implicit_self() {\n+                            1\n+                        } else {\n+                            0\n+                        },\n+                    )\n+                } else {\n+                    (def_id.to_def_id(), FnKind::Fn, 0)\n+                }\n+            },\n+            _ => return,\n+        };\n+        body.params\n+            .iter()\n+            .enumerate()\n+            .skip(skip_params)\n+            .filter_map(|(idx, p)| match p.pat.kind {\n+                PatKind::Binding(_, id, ident, None) if !ident.as_str().starts_with('_') => {\n+                    Some((id, Param::new(fn_id, fn_kind, idx, ident)))\n+                },\n+                _ => None,\n+            })\n+            .for_each(|(id, param)| self.params.insert(param, id));\n+        if self.entered_body.is_none() {\n+            self.entered_body = Some(body.value.hir_id);\n         }\n-\n-        self.ret_vars.append(&mut ret_vars);\n     }\n \n-    fn visit_method_call(&mut self, path: &'tcx PathSegment<'tcx>, args: &'tcx [Expr<'tcx>]) {\n-        if_chain! {\n-            if self.is_method;\n-            if path.ident == self.fn_ident;\n-            if let ExprKind::Path(QPath::Resolved(_, path)) = args.first().unwrap().kind;\n-            if let Res::Local(..) = path.res;\n-            let ident = path.segments.last().unwrap().ident;\n-            if ident.name == kw::SelfLower;\n-            then {\n-                izip!(self.params.clone(), args.iter())\n-                    .for_each(|(pat, expr)| {\n-                        self.visit_pat_expr(pat, expr, true);\n-                        self.ret_vars.clear();\n-                    });\n-            } else {\n-                self.ret_vars = args\n-                    .iter()\n-                    .flat_map(|expr| {\n-                        self.visit_expr(expr);\n-                        std::mem::take(&mut self.ret_vars)\n-                    })\n-                    .collect_vec()\n-                    .into_iter()\n-                    .map(|a| {\n-                        self.has_side_effect.insert(a.0);\n-                        a\n-                    })\n-                    .collect();\n-                self.contains_side_effect = true;\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'tcx>) {\n+        if let Some(id) = path_to_local(e)\n+            && let Some(param) = self.params.get_by_id_mut(id)\n+        {\n+            let typeck = cx.typeck_results();\n+            let span = e.span;\n+            let mut e = e;\n+            loop {\n+                match get_expr_use_or_unification_node(cx.tcx, e) {\n+                    None | Some((Node::Stmt(_), _)) => return,\n+                    Some((Node::Expr(parent), child_id)) => match parent.kind {\n+                        // Recursive call. Track which index the parameter is used in.\n+                        ExprKind::Call(callee, args)\n+                            if path_def_id(cx, callee).map_or(false, |id| {\n+                                id == param.fn_id\n+                                    && has_matching_substs(param.fn_kind, typeck.node_substs(callee.hir_id))\n+                            }) =>\n+                        {\n+                            if let Some(idx) = args.iter().position(|arg| arg.hir_id == child_id) {\n+                                param.uses.push(Usage::new(span, idx));\n+                            }\n+                            return;\n+                        },\n+                        ExprKind::MethodCall(_, args, _)\n+                            if typeck.type_dependent_def_id(parent.hir_id).map_or(false, |id| {\n+                                id == param.fn_id\n+                                    && has_matching_substs(param.fn_kind, typeck.node_substs(parent.hir_id))\n+                            }) =>\n+                        {\n+                            if let Some(idx) = args.iter().position(|arg| arg.hir_id == child_id) {\n+                                param.uses.push(Usage::new(span, idx));\n+                            }\n+                            return;\n+                        },\n+                        // Assignment to a parameter is fine.\n+                        ExprKind::Assign(lhs, _, _) | ExprKind::AssignOp(_, lhs, _) if lhs.hir_id == child_id => {\n+                            return;\n+                        },\n+                        // Parameter update e.g. `x = x + 1`\n+                        ExprKind::Assign(lhs, rhs, _) | ExprKind::AssignOp(_, lhs, rhs)\n+                            if rhs.hir_id == child_id && path_to_local_id(lhs, id) =>\n+                        {\n+                            return;\n+                        },\n+                        // Side-effect free expressions. Walk to the parent expression.\n+                        ExprKind::Binary(_, lhs, rhs)\n+                            if typeck.expr_ty(lhs).is_primitive() && typeck.expr_ty(rhs).is_primitive() =>\n+                        {\n+                            e = parent;\n+                            continue;\n+                        },\n+                        ExprKind::Unary(_, arg) if typeck.expr_ty(arg).is_primitive() => {\n+                            e = parent;\n+                            continue;\n+                        },\n+                        ExprKind::AddrOf(..) | ExprKind::Cast(..) => {\n+                            e = parent;\n+                            continue;\n+                        },\n+                        // Only allow field accesses without auto-deref\n+                        ExprKind::Field(..) if typeck.adjustments().get(child_id).is_none() => {\n+                            e = parent;\n+                            continue\n+                        }\n+                        _ => (),\n+                    },\n+                    _ => (),\n+                }\n+                self.params.remove_by_id(id);\n+                return;\n             }\n         }\n     }\n \n-    fn visit_if(&mut self, bind: &'tcx Expr<'tcx>, then_expr: &'tcx Expr<'tcx>, else_expr: Option<&'tcx Expr<'tcx>>) {\n-        let contains_side_effect = self.contains_side_effect;\n-        self.contains_side_effect = false;\n-        self.visit_expr(bind);\n-        let mut vars = std::mem::take(&mut self.ret_vars);\n-        self.visit_expr(then_expr);\n-        let mut then_vars = std::mem::take(&mut self.ret_vars);\n-        walk_list!(self, visit_expr, else_expr);\n-        if self.contains_side_effect {\n-            self.add_side_effect(vars.clone());\n-        }\n-        self.contains_side_effect |= contains_side_effect;\n-        self.ret_vars.append(&mut vars);\n-        self.ret_vars.append(&mut then_vars);\n-    }\n-\n-    fn visit_match(&mut self, expr: &'tcx Expr<'tcx>, arms: &'tcx [Arm<'tcx>]) {\n-        self.visit_expr(expr);\n-        let mut expr_vars = std::mem::take(&mut self.ret_vars);\n-        self.ret_vars = arms\n-            .iter()\n-            .flat_map(|arm| {\n-                let contains_side_effect = self.contains_side_effect;\n-                self.contains_side_effect = false;\n-                // this would visit `expr` multiple times\n-                // but couldn't think of a better way\n-                self.visit_pat_expr(arm.pat, expr, false);\n-                let mut vars = std::mem::take(&mut self.ret_vars);\n-                let _ = arm.guard.as_ref().map(|guard| {\n-                    self.visit_expr(match guard {\n-                        Guard::If(expr) | Guard::IfLet(Let { init: expr, .. }) => expr,\n-                    });\n-                    vars.append(&mut self.ret_vars);\n-                });\n-                self.visit_expr(arm.body);\n-                if self.contains_side_effect {\n-                    self.add_side_effect(vars.clone());\n-                    self.add_side_effect(expr_vars.clone());\n+    fn check_body_post(&mut self, cx: &LateContext<'tcx>, body: &'tcx Body<'tcx>) {\n+        if self.entered_body == Some(body.value.hir_id) {\n+            self.entered_body = None;\n+            self.params.flag_for_linting();\n+            for param in &self.params.params {\n+                if param.apply_lint.get() {\n+                    span_lint_and_then(\n+                        cx,\n+                        ONLY_USED_IN_RECURSION,\n+                        param.ident.span,\n+                        \"parameter is only used in recursion\",\n+                        |diag| {\n+                            if param.ident.name != kw::SelfLower {\n+                                diag.span_suggestion(\n+                                    param.ident.span,\n+                                    \"if this is intentional, prefix it with an underscore\",\n+                                    format!(\"_{}\", param.ident.name),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            }\n+                            diag.span_note(\n+                                param.uses.iter().map(|x| x.span).collect::<Vec<_>>(),\n+                                \"parameter used here\",\n+                            );\n+                        },\n+                    );\n                 }\n-                self.contains_side_effect |= contains_side_effect;\n-                vars.append(&mut self.ret_vars);\n-                vars\n-            })\n-            .collect();\n-        self.ret_vars.append(&mut expr_vars);\n-    }\n-\n-    fn connect_assign(&mut self, lhs: &[(HirId, bool)], rhs: &[(HirId, bool)], connect_self: bool) {\n-        // if mutable dereference is on assignment it can have side-effect\n-        // (this can lead to parameter mutable dereference and change the original value)\n-        // too hard to detect whether this value is from parameter, so this would all\n-        // check mutable dereference assignment to side effect\n-        lhs.iter().filter(|(_, b)| *b).for_each(|(id, _)| {\n-            self.has_side_effect.insert(*id);\n-            self.contains_side_effect = true;\n-        });\n-\n-        // there is no connection\n-        if lhs.is_empty() || rhs.is_empty() {\n-            return;\n-        }\n-\n-        // by connected rhs in cycle, the connections would decrease\n-        // from `n * m` to `n + m`\n-        // where `n` and `m` are length of `lhs` and `rhs`.\n-\n-        // unwrap is possible since rhs is not empty\n-        let rhs_first = rhs.first().unwrap();\n-        for (id, _) in lhs.iter() {\n-            if connect_self || *id != rhs_first.0 {\n-                self.graph\n-                    .entry(*id)\n-                    .or_insert_with(FxHashSet::default)\n-                    .insert(rhs_first.0);\n             }\n+            self.params.clear();\n         }\n-\n-        let rhs = rhs.iter();\n-        izip!(rhs.clone().cycle().skip(1), rhs).for_each(|(from, to)| {\n-            if connect_self || from.0 != to.0 {\n-                self.graph.entry(from.0).or_insert_with(FxHashSet::default).insert(to.0);\n-            }\n-        });\n     }\n+}\n \n-    fn add_side_effect(&mut self, v: Vec<(HirId, bool)>) {\n-        for (id, _) in v {\n-            self.has_side_effect.insert(id);\n-            self.contains_side_effect = true;\n-        }\n+fn has_matching_substs(kind: FnKind, substs: SubstsRef<'_>) -> bool {\n+    match kind {\n+        FnKind::Fn => true,\n+        FnKind::TraitFn => substs.iter().enumerate().all(|(idx, subst)| match subst.unpack() {\n+            GenericArgKind::Lifetime(_) => true,\n+            GenericArgKind::Type(ty) => matches!(*ty.kind(), ty::Param(ty) if ty.index as usize == idx),\n+            GenericArgKind::Const(c) => matches!(c.kind(), ConstKind::Param(c) if c.index as usize == idx),\n+        }),\n+        #[allow(trivial_casts)]\n+        FnKind::ImplTraitFn(expected_substs) => substs as *const _ as usize == expected_substs,\n     }\n }"}, {"sha": "2d751c274679f9b64eef70d1b8af54d45bd7aad6", "filename": "clippy_lints/src/redundant_static_lifetimes.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3a54117ffcb4ac496ebcc53a3b52bf26656775fd/clippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a54117ffcb4ac496ebcc53a3b52bf26656775fd/clippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs?ref=3a54117ffcb4ac496ebcc53a3b52bf26656775fd", "patch": "@@ -48,15 +48,15 @@ impl_lint_pass!(RedundantStaticLifetimes => [REDUNDANT_STATIC_LIFETIMES]);\n \n impl RedundantStaticLifetimes {\n     // Recursively visit types\n-    fn visit_type(&mut self, ty: &Ty, cx: &EarlyContext<'_>, reason: &str) {\n+    fn visit_type(ty: &Ty, cx: &EarlyContext<'_>, reason: &str) {\n         match ty.kind {\n             // Be careful of nested structures (arrays and tuples)\n             TyKind::Array(ref ty, _) | TyKind::Slice(ref ty) => {\n-                self.visit_type(ty, cx, reason);\n+                Self::visit_type(ty, cx, reason);\n             },\n             TyKind::Tup(ref tup) => {\n                 for tup_ty in tup {\n-                    self.visit_type(tup_ty, cx, reason);\n+                    Self::visit_type(tup_ty, cx, reason);\n                 }\n             },\n             // This is what we are looking for !\n@@ -87,7 +87,7 @@ impl RedundantStaticLifetimes {\n                         _ => {},\n                     }\n                 }\n-                self.visit_type(&borrow_type.ty, cx, reason);\n+                Self::visit_type(&borrow_type.ty, cx, reason);\n             },\n             _ => {},\n         }\n@@ -102,13 +102,13 @@ impl EarlyLintPass for RedundantStaticLifetimes {\n \n         if !item.span.from_expansion() {\n             if let ItemKind::Const(_, ref var_type, _) = item.kind {\n-                self.visit_type(var_type, cx, \"constants have by default a `'static` lifetime\");\n+                Self::visit_type(var_type, cx, \"constants have by default a `'static` lifetime\");\n                 // Don't check associated consts because `'static` cannot be elided on those (issue\n                 // #2438)\n             }\n \n             if let ItemKind::Static(ref var_type, _, _) = item.kind {\n-                self.visit_type(var_type, cx, \"statics have by default a `'static` lifetime\");\n+                Self::visit_type(var_type, cx, \"statics have by default a `'static` lifetime\");\n             }\n         }\n     }"}, {"sha": "f71e8ead5195ea27653bbfd7f24869490ffcc41b", "filename": "tests/ui/only_used_in_recursion.rs", "status": "modified", "additions": 62, "deletions": 71, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/3a54117ffcb4ac496ebcc53a3b52bf26656775fd/tests%2Fui%2Fonly_used_in_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a54117ffcb4ac496ebcc53a3b52bf26656775fd/tests%2Fui%2Fonly_used_in_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fonly_used_in_recursion.rs?ref=3a54117ffcb4ac496ebcc53a3b52bf26656775fd", "patch": "@@ -1,122 +1,113 @@\n #![warn(clippy::only_used_in_recursion)]\n \n-fn simple(a: usize, b: usize) -> usize {\n-    if a == 0 { 1 } else { simple(a - 1, b) }\n+fn _simple(x: u32) -> u32 {\n+    x\n }\n \n-fn with_calc(a: usize, b: isize) -> usize {\n-    if a == 0 { 1 } else { with_calc(a - 1, -b + 1) }\n+fn _simple2(x: u32) -> u32 {\n+    _simple(x)\n }\n \n-fn tuple((a, b): (usize, usize)) -> usize {\n-    if a == 0 { 1 } else { tuple((a - 1, b + 1)) }\n+fn _one_unused(flag: u32, a: usize) -> usize {\n+    if flag == 0 { 0 } else { _one_unused(flag - 1, a) }\n }\n \n-fn let_tuple(a: usize, b: usize) -> usize {\n-    let (c, d) = (a, b);\n-    if c == 0 { 1 } else { let_tuple(c - 1, d + 1) }\n+fn _two_unused(flag: u32, a: u32, b: i32) -> usize {\n+    if flag == 0 { 0 } else { _two_unused(flag - 1, a, b) }\n }\n \n-fn array([a, b]: [usize; 2]) -> usize {\n-    if a == 0 { 1 } else { array([a - 1, b + 1]) }\n-}\n-\n-fn index(a: usize, mut b: &[usize], c: usize) -> usize {\n-    if a == 0 { 1 } else { index(a - 1, b, c + b[0]) }\n-}\n-\n-fn break_(a: usize, mut b: usize, mut c: usize) -> usize {\n-    let c = loop {\n-        b += 1;\n-        c += 1;\n-        if c == 10 {\n-            break b;\n-        }\n-    };\n-\n-    if a == 0 { 1 } else { break_(a - 1, c, c) }\n+fn _with_calc(flag: u32, a: i64) -> usize {\n+    if flag == 0 {\n+        0\n+    } else {\n+        _with_calc(flag - 1, (-a + 10) * 5)\n+    }\n }\n \n-// this has a side effect\n-fn mut_ref(a: usize, b: &mut usize) -> usize {\n-    *b = 1;\n-    if a == 0 { 1 } else { mut_ref(a - 1, b) }\n+// Don't lint\n+fn _used_with_flag(flag: u32, a: u32) -> usize {\n+    if flag == 0 { 0 } else { _used_with_flag(flag ^ a, a - 1) }\n }\n \n-fn mut_ref2(a: usize, b: &mut usize) -> usize {\n-    let mut c = *b;\n-    if a == 0 { 1 } else { mut_ref2(a - 1, &mut c) }\n+fn _used_with_unused(flag: u32, a: i32, b: i32) -> usize {\n+    if flag == 0 {\n+        0\n+    } else {\n+        _used_with_unused(flag - 1, -a, a + b)\n+    }\n }\n \n-fn not_primitive(a: usize, b: String) -> usize {\n-    if a == 0 { 1 } else { not_primitive(a - 1, b) }\n+fn _codependent_unused(flag: u32, a: i32, b: i32) -> usize {\n+    if flag == 0 {\n+        0\n+    } else {\n+        _codependent_unused(flag - 1, a * b, a + b)\n+    }\n }\n \n-// this doesn't have a side effect,\n-// but `String` is not primitive.\n-fn not_primitive_op(a: usize, b: String, c: &str) -> usize {\n-    if a == 1 { 1 } else { not_primitive_op(a, b + c, c) }\n+fn _not_primitive(flag: u32, b: String) -> usize {\n+    if flag == 0 { 0 } else { _not_primitive(flag - 1, b) }\n }\n \n struct A;\n \n impl A {\n-    fn method(a: usize, b: usize) -> usize {\n-        if a == 0 { 1 } else { A::method(a - 1, b - 1) }\n+    fn _method(flag: usize, a: usize) -> usize {\n+        if flag == 0 { 0 } else { Self::_method(flag - 1, a) }\n     }\n \n-    fn method2(&self, a: usize, b: usize) -> usize {\n-        if a == 0 { 1 } else { self.method2(a - 1, b + 1) }\n+    fn _method_self(&self, flag: usize, a: usize) -> usize {\n+        if flag == 0 { 0 } else { self._method_self(flag - 1, a) }\n     }\n }\n \n trait B {\n-    fn hello(a: usize, b: usize) -> usize;\n-\n-    fn hello2(&self, a: usize, b: usize) -> usize;\n+    fn method(flag: u32, a: usize) -> usize;\n+    fn method_self(&self, flag: u32, a: usize) -> usize;\n }\n \n impl B for A {\n-    fn hello(a: usize, b: usize) -> usize {\n-        if a == 0 { 1 } else { A::hello(a - 1, b + 1) }\n+    fn method(flag: u32, a: usize) -> usize {\n+        if flag == 0 { 0 } else { Self::method(flag - 1, a) }\n     }\n \n-    fn hello2(&self, a: usize, b: usize) -> usize {\n-        if a == 0 { 1 } else { self.hello2(a - 1, b + 1) }\n+    fn method_self(&self, flag: u32, a: usize) -> usize {\n+        if flag == 0 { 0 } else { self.method_self(flag - 1, a) }\n     }\n }\n \n-trait C {\n-    fn hello(a: usize, b: usize) -> usize {\n-        if a == 0 { 1 } else { Self::hello(a - 1, b + 1) }\n+impl B for () {\n+    fn method(flag: u32, a: usize) -> usize {\n+        if flag == 0 { 0 } else { a }\n     }\n \n-    fn hello2(&self, a: usize, b: usize) -> usize {\n-        if a == 0 { 1 } else { self.hello2(a - 1, b + 1) }\n+    fn method_self(&self, flag: u32, a: usize) -> usize {\n+        if flag == 0 { 0 } else { a }\n     }\n }\n \n-fn ignore(a: usize, _: usize) -> usize {\n-    if a == 1 { 1 } else { ignore(a - 1, 0) }\n-}\n+impl B for u32 {\n+    fn method(flag: u32, a: usize) -> usize {\n+        if flag == 0 { 0 } else { <() as B>::method(flag, a) }\n+    }\n \n-fn ignore2(a: usize, _b: usize) -> usize {\n-    if a == 1 { 1 } else { ignore2(a - 1, _b) }\n+    fn method_self(&self, flag: u32, a: usize) -> usize {\n+        if flag == 0 { 0 } else { ().method_self(flag, a) }\n+    }\n }\n \n-fn f1(a: u32) -> u32 {\n-    a\n-}\n+trait C {\n+    fn method(flag: u32, a: usize) -> usize {\n+        if flag == 0 { 0 } else { Self::method(flag - 1, a) }\n+    }\n \n-fn f2(a: u32) -> u32 {\n-    f1(a)\n+    fn method_self(&self, flag: u32, a: usize) -> usize {\n+        if flag == 0 { 0 } else { self.method_self(flag - 1, a) }\n+    }\n }\n \n-fn inner_fn(a: u32) -> u32 {\n-    fn inner_fn(a: u32) -> u32 {\n-        a\n-    }\n-    inner_fn(a)\n+fn _ignore(flag: usize, _a: usize) -> usize {\n+    if flag == 0 { 0 } else { _ignore(flag - 1, _a) }\n }\n \n fn main() {}"}, {"sha": "74057ddcfda4c2cca6e77a64c43313539fe5066c", "filename": "tests/ui/only_used_in_recursion.stderr", "status": "modified", "additions": 153, "deletions": 40, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/3a54117ffcb4ac496ebcc53a3b52bf26656775fd/tests%2Fui%2Fonly_used_in_recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a54117ffcb4ac496ebcc53a3b52bf26656775fd/tests%2Fui%2Fonly_used_in_recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fonly_used_in_recursion.stderr?ref=3a54117ffcb4ac496ebcc53a3b52bf26656775fd", "patch": "@@ -1,82 +1,195 @@\n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:3:21\n+  --> $DIR/only_used_in_recursion.rs:11:27\n    |\n-LL | fn simple(a: usize, b: usize) -> usize {\n-   |                     ^ help: if this is intentional, prefix with an underscore: `_b`\n+LL | fn _one_unused(flag: u32, a: usize) -> usize {\n+   |                           ^ help: if this is intentional, prefix it with an underscore: `_a`\n    |\n    = note: `-D clippy::only-used-in-recursion` implied by `-D warnings`\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:12:53\n+   |\n+LL |     if flag == 0 { 0 } else { _one_unused(flag - 1, a) }\n+   |                                                     ^\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:15:27\n+   |\n+LL | fn _two_unused(flag: u32, a: u32, b: i32) -> usize {\n+   |                           ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:16:53\n+   |\n+LL |     if flag == 0 { 0 } else { _two_unused(flag - 1, a, b) }\n+   |                                                     ^\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:15:35\n+   |\n+LL | fn _two_unused(flag: u32, a: u32, b: i32) -> usize {\n+   |                                   ^ help: if this is intentional, prefix it with an underscore: `_b`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:16:56\n+   |\n+LL |     if flag == 0 { 0 } else { _two_unused(flag - 1, a, b) }\n+   |                                                        ^\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:19:26\n+   |\n+LL | fn _with_calc(flag: u32, a: i64) -> usize {\n+   |                          ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:23:32\n+   |\n+LL |         _with_calc(flag - 1, (-a + 10) * 5)\n+   |                                ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:7:24\n+  --> $DIR/only_used_in_recursion.rs:32:33\n+   |\n+LL | fn _used_with_unused(flag: u32, a: i32, b: i32) -> usize {\n+   |                                 ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:36:38\n    |\n-LL | fn with_calc(a: usize, b: isize) -> usize {\n-   |                        ^ help: if this is intentional, prefix with an underscore: `_b`\n+LL |         _used_with_unused(flag - 1, -a, a + b)\n+   |                                      ^  ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:11:14\n+  --> $DIR/only_used_in_recursion.rs:32:41\n+   |\n+LL | fn _used_with_unused(flag: u32, a: i32, b: i32) -> usize {\n+   |                                         ^ help: if this is intentional, prefix it with an underscore: `_b`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:36:45\n    |\n-LL | fn tuple((a, b): (usize, usize)) -> usize {\n-   |              ^ help: if this is intentional, prefix with an underscore: `_b`\n+LL |         _used_with_unused(flag - 1, -a, a + b)\n+   |                                             ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:15:24\n+  --> $DIR/only_used_in_recursion.rs:40:35\n    |\n-LL | fn let_tuple(a: usize, b: usize) -> usize {\n-   |                        ^ help: if this is intentional, prefix with an underscore: `_b`\n+LL | fn _codependent_unused(flag: u32, a: i32, b: i32) -> usize {\n+   |                                   ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:44:39\n+   |\n+LL |         _codependent_unused(flag - 1, a * b, a + b)\n+   |                                       ^      ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:20:14\n+  --> $DIR/only_used_in_recursion.rs:40:43\n+   |\n+LL | fn _codependent_unused(flag: u32, a: i32, b: i32) -> usize {\n+   |                                           ^ help: if this is intentional, prefix it with an underscore: `_b`\n    |\n-LL | fn array([a, b]: [usize; 2]) -> usize {\n-   |              ^ help: if this is intentional, prefix with an underscore: `_b`\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:44:43\n+   |\n+LL |         _codependent_unused(flag - 1, a * b, a + b)\n+   |                                           ^      ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:24:20\n+  --> $DIR/only_used_in_recursion.rs:48:30\n+   |\n+LL | fn _not_primitive(flag: u32, b: String) -> usize {\n+   |                              ^ help: if this is intentional, prefix it with an underscore: `_b`\n    |\n-LL | fn index(a: usize, mut b: &[usize], c: usize) -> usize {\n-   |                    ^^^^^ help: if this is intentional, prefix with an underscore: `_b`\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:49:56\n+   |\n+LL |     if flag == 0 { 0 } else { _not_primitive(flag - 1, b) }\n+   |                                                        ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:24:37\n+  --> $DIR/only_used_in_recursion.rs:55:29\n+   |\n+LL |     fn _method(flag: usize, a: usize) -> usize {\n+   |                             ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:56:59\n    |\n-LL | fn index(a: usize, mut b: &[usize], c: usize) -> usize {\n-   |                                     ^ help: if this is intentional, prefix with an underscore: `_c`\n+LL |         if flag == 0 { 0 } else { Self::_method(flag - 1, a) }\n+   |                                                           ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:28:21\n+  --> $DIR/only_used_in_recursion.rs:59:22\n+   |\n+LL |     fn _method_self(&self, flag: usize, a: usize) -> usize {\n+   |                      ^^^^\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:60:35\n    |\n-LL | fn break_(a: usize, mut b: usize, mut c: usize) -> usize {\n-   |                     ^^^^^ help: if this is intentional, prefix with an underscore: `_b`\n+LL |         if flag == 0 { 0 } else { self._method_self(flag - 1, a) }\n+   |                                   ^^^^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:46:23\n+  --> $DIR/only_used_in_recursion.rs:59:41\n    |\n-LL | fn mut_ref2(a: usize, b: &mut usize) -> usize {\n-   |                       ^ help: if this is intentional, prefix with an underscore: `_b`\n+LL |     fn _method_self(&self, flag: usize, a: usize) -> usize {\n+   |                                         ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:60:63\n+   |\n+LL |         if flag == 0 { 0 } else { self._method_self(flag - 1, a) }\n+   |                                                               ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:51:28\n+  --> $DIR/only_used_in_recursion.rs:70:26\n+   |\n+LL |     fn method(flag: u32, a: usize) -> usize {\n+   |                          ^ help: if this is intentional, prefix it with an underscore: `_a`\n    |\n-LL | fn not_primitive(a: usize, b: String) -> usize {\n-   |                            ^ help: if this is intentional, prefix with an underscore: `_b`\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:71:58\n+   |\n+LL |         if flag == 0 { 0 } else { Self::method(flag - 1, a) }\n+   |                                                          ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:68:33\n+  --> $DIR/only_used_in_recursion.rs:74:38\n+   |\n+LL |     fn method_self(&self, flag: u32, a: usize) -> usize {\n+   |                                      ^ help: if this is intentional, prefix it with an underscore: `_a`\n    |\n-LL |     fn method2(&self, a: usize, b: usize) -> usize {\n-   |                                 ^ help: if this is intentional, prefix with an underscore: `_b`\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:75:62\n+   |\n+LL |         if flag == 0 { 0 } else { self.method_self(flag - 1, a) }\n+   |                                                              ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:90:24\n+  --> $DIR/only_used_in_recursion.rs:100:26\n+   |\n+LL |     fn method(flag: u32, a: usize) -> usize {\n+   |                          ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:101:58\n    |\n-LL |     fn hello(a: usize, b: usize) -> usize {\n-   |                        ^ help: if this is intentional, prefix with an underscore: `_b`\n+LL |         if flag == 0 { 0 } else { Self::method(flag - 1, a) }\n+   |                                                          ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:94:32\n+  --> $DIR/only_used_in_recursion.rs:104:38\n+   |\n+LL |     fn method_self(&self, flag: u32, a: usize) -> usize {\n+   |                                      ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:105:62\n    |\n-LL |     fn hello2(&self, a: usize, b: usize) -> usize {\n-   |                                ^ help: if this is intentional, prefix with an underscore: `_b`\n+LL |         if flag == 0 { 0 } else { self.method_self(flag - 1, a) }\n+   |                                                              ^\n \n-error: aborting due to 13 previous errors\n+error: aborting due to 16 previous errors\n "}, {"sha": "45dd0553f58acb31b9c15119db4e4f2d066564a2", "filename": "tests/ui/only_used_in_recursion2.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/3a54117ffcb4ac496ebcc53a3b52bf26656775fd/tests%2Fui%2Fonly_used_in_recursion2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a54117ffcb4ac496ebcc53a3b52bf26656775fd/tests%2Fui%2Fonly_used_in_recursion2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fonly_used_in_recursion2.rs?ref=3a54117ffcb4ac496ebcc53a3b52bf26656775fd", "patch": "@@ -0,0 +1,91 @@\n+#![warn(clippy::only_used_in_recursion)]\n+\n+fn _with_inner(flag: u32, a: u32, b: u32) -> usize {\n+    fn inner(flag: u32, a: u32) -> u32 {\n+        if flag == 0 { 0 } else { inner(flag, a) }\n+    }\n+\n+    let x = inner(flag, a);\n+    if flag == 0 { 0 } else { _with_inner(flag, a, b + x) }\n+}\n+\n+fn _with_closure(a: Option<u32>, b: u32, f: impl Fn(u32, u32) -> Option<u32>) -> u32 {\n+    if let Some(x) = a.and_then(|x| f(x, x)) {\n+        _with_closure(Some(x), b, f)\n+    } else {\n+        0\n+    }\n+}\n+\n+// Issue #8560\n+trait D {\n+    fn foo(&mut self, arg: u32) -> u32;\n+}\n+\n+mod m {\n+    pub struct S(u32);\n+    impl S {\n+        pub fn foo(&mut self, arg: u32) -> u32 {\n+            arg + self.0\n+        }\n+    }\n+}\n+\n+impl D for m::S {\n+    fn foo(&mut self, arg: u32) -> u32 {\n+        self.foo(arg)\n+    }\n+}\n+\n+// Issue #8782\n+fn only_let(x: u32) {\n+    let y = 10u32;\n+    let _z = x * y;\n+}\n+\n+trait E<T: E<()>> {\n+    fn method(flag: u32, a: usize) -> usize {\n+        if flag == 0 {\n+            0\n+        } else {\n+            <T as E<()>>::method(flag - 1, a)\n+        }\n+    }\n+}\n+\n+impl E<()> for () {\n+    fn method(flag: u32, a: usize) -> usize {\n+        if flag == 0 { 0 } else { a }\n+    }\n+}\n+\n+fn overwritten_param(flag: u32, mut a: usize) -> usize {\n+    if flag == 0 {\n+        return 0;\n+    } else if flag > 5 {\n+        a += flag as usize;\n+    } else {\n+        a = 5;\n+    }\n+    overwritten_param(flag, a)\n+}\n+\n+fn field_direct(flag: u32, mut a: (usize,)) -> usize {\n+    if flag == 0 {\n+        0\n+    } else {\n+        a.0 += 5;\n+        field_direct(flag - 1, a)\n+    }\n+}\n+\n+fn field_deref(flag: u32, a: &mut Box<(usize,)>) -> usize {\n+    if flag == 0 {\n+        0\n+    } else {\n+        a.0 += 5;\n+        field_deref(flag - 1, a)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "23f6ffd30c9763de2033510ee3083f84f808874b", "filename": "tests/ui/only_used_in_recursion2.stderr", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/3a54117ffcb4ac496ebcc53a3b52bf26656775fd/tests%2Fui%2Fonly_used_in_recursion2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a54117ffcb4ac496ebcc53a3b52bf26656775fd/tests%2Fui%2Fonly_used_in_recursion2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fonly_used_in_recursion2.stderr?ref=3a54117ffcb4ac496ebcc53a3b52bf26656775fd", "patch": "@@ -0,0 +1,63 @@\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion2.rs:3:35\n+   |\n+LL | fn _with_inner(flag: u32, a: u32, b: u32) -> usize {\n+   |                                   ^ help: if this is intentional, prefix it with an underscore: `_b`\n+   |\n+   = note: `-D clippy::only-used-in-recursion` implied by `-D warnings`\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion2.rs:9:52\n+   |\n+LL |     if flag == 0 { 0 } else { _with_inner(flag, a, b + x) }\n+   |                                                    ^\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion2.rs:4:25\n+   |\n+LL |     fn inner(flag: u32, a: u32) -> u32 {\n+   |                         ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion2.rs:5:47\n+   |\n+LL |         if flag == 0 { 0 } else { inner(flag, a) }\n+   |                                               ^\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion2.rs:12:34\n+   |\n+LL | fn _with_closure(a: Option<u32>, b: u32, f: impl Fn(u32, u32) -> Option<u32>) -> u32 {\n+   |                                  ^ help: if this is intentional, prefix it with an underscore: `_b`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion2.rs:14:32\n+   |\n+LL |         _with_closure(Some(x), b, f)\n+   |                                ^\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion2.rs:62:37\n+   |\n+LL | fn overwritten_param(flag: u32, mut a: usize) -> usize {\n+   |                                     ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion2.rs:70:29\n+   |\n+LL |     overwritten_param(flag, a)\n+   |                             ^\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion2.rs:73:32\n+   |\n+LL | fn field_direct(flag: u32, mut a: (usize,)) -> usize {\n+   |                                ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion2.rs:78:32\n+   |\n+LL |         field_direct(flag - 1, a)\n+   |                                ^\n+\n+error: aborting due to 5 previous errors\n+"}]}