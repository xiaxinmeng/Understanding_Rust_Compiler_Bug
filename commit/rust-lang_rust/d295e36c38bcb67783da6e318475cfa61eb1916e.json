{"sha": "d295e36c38bcb67783da6e318475cfa61eb1916e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyOTVlMzZjMzhiY2I2Nzc4M2RhNmUzMTg0NzVjZmE2MWViMTkxNmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-04T07:17:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-04T07:17:12Z"}, "message": "Auto merge of #88538 - bjorn3:no_session_in_crate_loader, r=petrochenkov\n\nCrateLocator refactorings\n\nThis makes the `CrateLocator` a lot cleaner IMHO and much more self-contained. The last commit removes `extra_filename` from the crate metadata. This is an **insta-stable** change as it allows a crate like `libfoo-abc.rlib` to be used as dependency and then be renamed as `libfoo-bcd.rlib` while still being found as indirect dependency. This may reduce performance when there are a lot of versions of the same crate available as the extra filename won't be used to do an early rejection of crates before trying to load metadata, but it makes the logic to find the right filename a lot cleaner.", "tree": {"sha": "27dfe86963d4f6903b3cbdadaa94e1478ea22c46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27dfe86963d4f6903b3cbdadaa94e1478ea22c46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d295e36c38bcb67783da6e318475cfa61eb1916e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d295e36c38bcb67783da6e318475cfa61eb1916e", "html_url": "https://github.com/rust-lang/rust/commit/d295e36c38bcb67783da6e318475cfa61eb1916e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d295e36c38bcb67783da6e318475cfa61eb1916e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "065a3720b80fde1bd04c3ca8a1268b5d6eb0c985", "url": "https://api.github.com/repos/rust-lang/rust/commits/065a3720b80fde1bd04c3ca8a1268b5d6eb0c985", "html_url": "https://github.com/rust-lang/rust/commit/065a3720b80fde1bd04c3ca8a1268b5d6eb0c985"}, {"sha": "ff98cb64089469fb87f48a52e0eccde531ccbd4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff98cb64089469fb87f48a52e0eccde531ccbd4f", "html_url": "https://github.com/rust-lang/rust/commit/ff98cb64089469fb87f48a52e0eccde531ccbd4f"}], "stats": {"total": 171, "additions": 77, "deletions": 94}, "files": [{"sha": "99030febb7380210e25fbf2bedecada294f7d3bf", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d295e36c38bcb67783da6e318475cfa61eb1916e/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d295e36c38bcb67783da6e318475cfa61eb1916e/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=d295e36c38bcb67783da6e318475cfa61eb1916e", "patch": "@@ -450,6 +450,7 @@ impl<'a> CrateLoader<'a> {\n         &self,\n         locator: &mut CrateLocator<'b>,\n         path_kind: PathKind,\n+        host_hash: Option<Svh>,\n     ) -> Result<Option<(LoadResult, Option<Library>)>, CrateError>\n     where\n         'a: 'b,\n@@ -459,7 +460,7 @@ impl<'a> CrateLoader<'a> {\n         let mut proc_macro_locator = locator.clone();\n \n         // Try to load a proc macro\n-        proc_macro_locator.is_proc_macro = Some(true);\n+        proc_macro_locator.is_proc_macro = true;\n \n         // Load the proc macro crate for the target\n         let (locator, target_result) = if self.sess.opts.debugging_opts.dual_proc_macros {\n@@ -471,7 +472,7 @@ impl<'a> CrateLoader<'a> {\n                 Some(LoadResult::Loaded(library)) => Some(LoadResult::Loaded(library)),\n                 None => return Ok(None),\n             };\n-            locator.hash = locator.host_hash;\n+            locator.hash = host_hash;\n             // Use the locator when looking for the host proc macro crate, as that is required\n             // so we want it to affect the error message\n             (locator, result)\n@@ -482,7 +483,7 @@ impl<'a> CrateLoader<'a> {\n         // Load the proc macro crate for the host\n \n         locator.reset();\n-        locator.is_proc_macro = Some(true);\n+        locator.is_proc_macro = true;\n         locator.target = &self.sess.host;\n         locator.triple = TargetTriple::from_triple(config::host_triple());\n         locator.filesearch = self.sess.host_filesearch(path_kind);\n@@ -510,12 +511,9 @@ impl<'a> CrateLoader<'a> {\n         name: Symbol,\n         span: Span,\n         dep_kind: CrateDepKind,\n-        dep: Option<(&'b CratePaths, &'b CrateDep)>,\n     ) -> CrateNum {\n-        if dep.is_none() {\n-            self.used_extern_options.insert(name);\n-        }\n-        self.maybe_resolve_crate(name, dep_kind, dep).unwrap_or_else(|err| {\n+        self.used_extern_options.insert(name);\n+        self.maybe_resolve_crate(name, dep_kind, None).unwrap_or_else(|err| {\n             let missing_core =\n                 self.maybe_resolve_crate(sym::core, CrateDepKind::Explicit, None).is_err();\n             err.report(&self.sess, span, missing_core)\n@@ -551,21 +549,18 @@ impl<'a> CrateLoader<'a> {\n                 &*self.metadata_loader,\n                 name,\n                 hash,\n-                host_hash,\n                 extra_filename,\n                 false, // is_host\n                 path_kind,\n-                root,\n-                Some(false), // is_proc_macro\n             );\n \n             match self.load(&mut locator)? {\n                 Some(res) => (res, None),\n                 None => {\n                     dep_kind = CrateDepKind::MacrosOnly;\n-                    match self.load_proc_macro(&mut locator, path_kind)? {\n+                    match self.load_proc_macro(&mut locator, path_kind, host_hash)? {\n                         Some(res) => res,\n-                        None => return Err(locator.into_error()),\n+                        None => return Err(locator.into_error(root.cloned())),\n                     }\n                 }\n             }\n@@ -605,7 +600,7 @@ impl<'a> CrateLoader<'a> {\n         // FIXME: why is this condition necessary? It was adding in #33625 but I\n         // don't know why and the original author doesn't remember ...\n         let can_reuse_cratenum =\n-            locator.triple == self.sess.opts.target_triple || locator.is_proc_macro == Some(true);\n+            locator.triple == self.sess.opts.target_triple || locator.is_proc_macro;\n         Ok(Some(if can_reuse_cratenum {\n             let mut result = LoadResult::Loaded(library);\n             self.cstore.iter_crate_data(|cnum, data| {\n@@ -755,7 +750,7 @@ impl<'a> CrateLoader<'a> {\n         };\n         info!(\"panic runtime not found -- loading {}\", name);\n \n-        let cnum = self.resolve_crate(name, DUMMY_SP, CrateDepKind::Implicit, None);\n+        let cnum = self.resolve_crate(name, DUMMY_SP, CrateDepKind::Implicit);\n         let data = self.cstore.get_crate_data(cnum);\n \n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n@@ -795,7 +790,7 @@ impl<'a> CrateLoader<'a> {\n             );\n         }\n \n-        let cnum = self.resolve_crate(name, DUMMY_SP, CrateDepKind::Implicit, None);\n+        let cnum = self.resolve_crate(name, DUMMY_SP, CrateDepKind::Implicit);\n         let data = self.cstore.get_crate_data(cnum);\n \n         // Sanity check the loaded crate to ensure it is indeed a profiler runtime\n@@ -1015,7 +1010,7 @@ impl<'a> CrateLoader<'a> {\n                     CrateDepKind::Explicit\n                 };\n \n-                let cnum = self.resolve_crate(name, item.span, dep_kind, None);\n+                let cnum = self.resolve_crate(name, item.span, dep_kind);\n \n                 let path_len = definitions.def_path(def_id).data.len();\n                 self.update_extern_crate(\n@@ -1034,7 +1029,7 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     pub fn process_path_extern(&mut self, name: Symbol, span: Span) -> CrateNum {\n-        let cnum = self.resolve_crate(name, span, CrateDepKind::Explicit, None);\n+        let cnum = self.resolve_crate(name, span, CrateDepKind::Explicit);\n \n         self.update_extern_crate(\n             cnum,"}, {"sha": "d3512b6cf579e18e1d0cd4d70914ae7c7d1f1231", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 64, "deletions": 76, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/d295e36c38bcb67783da6e318475cfa61eb1916e/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d295e36c38bcb67783da6e318475cfa61eb1916e/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=d295e36c38bcb67783da6e318475cfa61eb1916e", "patch": "@@ -240,27 +240,22 @@ use tracing::{debug, info, warn};\n #[derive(Clone)]\n crate struct CrateLocator<'a> {\n     // Immutable per-session configuration.\n-    sess: &'a Session,\n+    only_needs_metadata: bool,\n+    sysroot: &'a Path,\n     metadata_loader: &'a dyn MetadataLoader,\n \n     // Immutable per-search configuration.\n     crate_name: Symbol,\n     exact_paths: Vec<CanonicalizedPath>,\n     pub hash: Option<Svh>,\n-    pub host_hash: Option<Svh>,\n     extra_filename: Option<&'a str>,\n     pub target: &'a Target,\n     pub triple: TargetTriple,\n     pub filesearch: FileSearch<'a>,\n-    root: Option<&'a CratePaths>,\n-    pub is_proc_macro: Option<bool>,\n+    pub is_proc_macro: bool,\n \n     // Mutable in-progress state or output.\n-    rejected_via_hash: Vec<CrateMismatch>,\n-    rejected_via_triple: Vec<CrateMismatch>,\n-    rejected_via_kind: Vec<CrateMismatch>,\n-    rejected_via_version: Vec<CrateMismatch>,\n-    rejected_via_filename: Vec<CrateMismatch>,\n+    crate_rejections: CrateRejections,\n }\n \n #[derive(Clone)]\n@@ -298,15 +293,22 @@ impl<'a> CrateLocator<'a> {\n         metadata_loader: &'a dyn MetadataLoader,\n         crate_name: Symbol,\n         hash: Option<Svh>,\n-        host_hash: Option<Svh>,\n         extra_filename: Option<&'a str>,\n         is_host: bool,\n         path_kind: PathKind,\n-        root: Option<&'a CratePaths>,\n-        is_proc_macro: Option<bool>,\n     ) -> CrateLocator<'a> {\n+        // The all loop is because `--crate-type=rlib --crate-type=rlib` is\n+        // legal and produces both inside this type.\n+        let is_rlib = sess.crate_types().iter().all(|c| *c == CrateType::Rlib);\n+        let needs_object_code = sess.opts.output_types.should_codegen();\n+        // If we're producing an rlib, then we don't need object code.\n+        // Or, if we're not producing object code, then we don't need it either\n+        // (e.g., if we're a cdylib but emitting just metadata).\n+        let only_needs_metadata = is_rlib || !needs_object_code;\n+\n         CrateLocator {\n-            sess,\n+            only_needs_metadata,\n+            sysroot: &sess.sysroot,\n             metadata_loader,\n             crate_name,\n             exact_paths: if hash.is_none() {\n@@ -324,7 +326,6 @@ impl<'a> CrateLocator<'a> {\n                 Vec::new()\n             },\n             hash,\n-            host_hash,\n             extra_filename,\n             target: if is_host { &sess.host } else { &sess.target },\n             triple: if is_host {\n@@ -337,22 +338,17 @@ impl<'a> CrateLocator<'a> {\n             } else {\n                 sess.target_filesearch(path_kind)\n             },\n-            root,\n-            is_proc_macro,\n-            rejected_via_hash: Vec::new(),\n-            rejected_via_triple: Vec::new(),\n-            rejected_via_kind: Vec::new(),\n-            rejected_via_version: Vec::new(),\n-            rejected_via_filename: Vec::new(),\n+            is_proc_macro: false,\n+            crate_rejections: CrateRejections::default(),\n         }\n     }\n \n     crate fn reset(&mut self) {\n-        self.rejected_via_hash.clear();\n-        self.rejected_via_triple.clear();\n-        self.rejected_via_kind.clear();\n-        self.rejected_via_version.clear();\n-        self.rejected_via_filename.clear();\n+        self.crate_rejections.via_hash.clear();\n+        self.crate_rejections.via_triple.clear();\n+        self.crate_rejections.via_kind.clear();\n+        self.crate_rejections.via_version.clear();\n+        self.crate_rejections.via_filename.clear();\n     }\n \n     crate fn maybe_load_library_crate(&mut self) -> Result<Option<Library>, CrateError> {\n@@ -435,7 +431,7 @@ impl<'a> CrateLocator<'a> {\n             };\n             FileMatches\n         });\n-        self.rejected_via_kind.extend(staticlibs);\n+        self.crate_rejections.via_kind.extend(staticlibs);\n \n         // We have now collected all known libraries into a set of candidates\n         // keyed of the filename hash listed. For each filename, we also have a\n@@ -480,18 +476,11 @@ impl<'a> CrateLocator<'a> {\n     }\n \n     fn needs_crate_flavor(&self, flavor: CrateFlavor) -> bool {\n-        if flavor == CrateFlavor::Dylib && self.is_proc_macro == Some(true) {\n+        if flavor == CrateFlavor::Dylib && self.is_proc_macro {\n             return true;\n         }\n \n-        // The all loop is because `--crate-type=rlib --crate-type=rlib` is\n-        // legal and produces both inside this type.\n-        let is_rlib = self.sess.crate_types().iter().all(|c| *c == CrateType::Rlib);\n-        let needs_object_code = self.sess.opts.output_types.should_codegen();\n-        // If we're producing an rlib, then we don't need object code.\n-        // Or, if we're not producing object code, then we don't need it either\n-        // (e.g., if we're a cdylib but emitting just metadata).\n-        if is_rlib || !needs_object_code {\n+        if self.only_needs_metadata {\n             flavor == CrateFlavor::Rmeta\n         } else {\n             // we need all flavors (perhaps not true, but what we do for now)\n@@ -591,7 +580,7 @@ impl<'a> CrateLocator<'a> {\n             // candidates are all canonicalized, so we canonicalize the sysroot\n             // as well.\n             if let Some((prev, _)) = &ret {\n-                let sysroot = &self.sess.sysroot;\n+                let sysroot = self.sysroot;\n                 let sysroot = sysroot.canonicalize().unwrap_or_else(|_| sysroot.to_path_buf());\n                 if prev.starts_with(&sysroot) {\n                     continue;\n@@ -613,21 +602,20 @@ impl<'a> CrateLocator<'a> {\n         let found_version = metadata.get_rustc_version();\n         if found_version != rustc_version {\n             info!(\"Rejecting via version: expected {} got {}\", rustc_version, found_version);\n-            self.rejected_via_version\n+            self.crate_rejections\n+                .via_version\n                 .push(CrateMismatch { path: libpath.to_path_buf(), got: found_version });\n             return None;\n         }\n \n         let root = metadata.get_root();\n-        if let Some(expected_is_proc_macro) = self.is_proc_macro {\n-            let is_proc_macro = root.is_proc_macro_crate();\n-            if is_proc_macro != expected_is_proc_macro {\n-                info!(\n-                    \"Rejecting via proc macro: expected {} got {}\",\n-                    expected_is_proc_macro, is_proc_macro\n-                );\n-                return None;\n-            }\n+        if root.is_proc_macro_crate() != self.is_proc_macro {\n+            info!(\n+                \"Rejecting via proc macro: expected {} got {}\",\n+                self.is_proc_macro,\n+                root.is_proc_macro_crate(),\n+            );\n+            return None;\n         }\n \n         if self.exact_paths.is_empty() && self.crate_name != root.name() {\n@@ -637,7 +625,7 @@ impl<'a> CrateLocator<'a> {\n \n         if root.triple() != &self.triple {\n             info!(\"Rejecting via crate triple: expected {} got {}\", self.triple, root.triple());\n-            self.rejected_via_triple.push(CrateMismatch {\n+            self.crate_rejections.via_triple.push(CrateMismatch {\n                 path: libpath.to_path_buf(),\n                 got: root.triple().to_string(),\n             });\n@@ -648,7 +636,8 @@ impl<'a> CrateLocator<'a> {\n         if let Some(expected_hash) = self.hash {\n             if hash != expected_hash {\n                 info!(\"Rejecting via hash: expected {} got {}\", expected_hash, hash);\n-                self.rejected_via_hash\n+                self.crate_rejections\n+                    .via_hash\n                     .push(CrateMismatch { path: libpath.to_path_buf(), got: hash.to_string() });\n                 return None;\n             }\n@@ -702,7 +691,8 @@ impl<'a> CrateLocator<'a> {\n                     dylibs.insert(loc_canon, PathKind::ExternFlag);\n                 }\n             } else {\n-                self.rejected_via_filename\n+                self.crate_rejections\n+                    .via_filename\n                     .push(CrateMismatch { path: loc.original().clone(), got: String::new() });\n             }\n         }\n@@ -711,18 +701,14 @@ impl<'a> CrateLocator<'a> {\n         Ok(self.extract_lib(rlibs, rmetas, dylibs)?.map(|(_, lib)| lib))\n     }\n \n-    crate fn into_error(self) -> CrateError {\n+    crate fn into_error(self, root: Option<CratePaths>) -> CrateError {\n         CrateError::LocatorCombined(CombinedLocatorError {\n             crate_name: self.crate_name,\n-            root: self.root.cloned(),\n+            root,\n             triple: self.triple,\n             dll_prefix: self.target.dll_prefix.clone(),\n             dll_suffix: self.target.dll_suffix.clone(),\n-            rejected_via_hash: self.rejected_via_hash,\n-            rejected_via_triple: self.rejected_via_triple,\n-            rejected_via_kind: self.rejected_via_kind,\n-            rejected_via_version: self.rejected_via_version,\n-            rejected_via_filename: self.rejected_via_filename,\n+            crate_rejections: self.crate_rejections,\n         })\n     }\n }\n@@ -806,20 +792,17 @@ fn find_plugin_registrar_impl<'a>(\n         metadata_loader,\n         name,\n         None, // hash\n-        None, // host_hash\n         None, // extra_filename\n         true, // is_host\n         PathKind::Crate,\n-        None, // root\n-        None, // is_proc_macro\n     );\n \n     match locator.maybe_load_library_crate()? {\n         Some(library) => match library.source.dylib {\n             Some(dylib) => Ok(dylib.0),\n             None => Err(CrateError::NonDylibPlugin(name)),\n         },\n-        None => Err(locator.into_error()),\n+        None => Err(locator.into_error(None)),\n     }\n }\n \n@@ -852,6 +835,15 @@ struct CrateMismatch {\n     got: String,\n }\n \n+#[derive(Clone, Default)]\n+struct CrateRejections {\n+    via_hash: Vec<CrateMismatch>,\n+    via_triple: Vec<CrateMismatch>,\n+    via_kind: Vec<CrateMismatch>,\n+    via_version: Vec<CrateMismatch>,\n+    via_filename: Vec<CrateMismatch>,\n+}\n+\n /// Candidate rejection reasons collected during crate search.\n /// If no candidate is accepted, then these reasons are presented to the user,\n /// otherwise they are ignored.\n@@ -861,11 +853,7 @@ crate struct CombinedLocatorError {\n     triple: TargetTriple,\n     dll_prefix: String,\n     dll_suffix: String,\n-    rejected_via_hash: Vec<CrateMismatch>,\n-    rejected_via_triple: Vec<CrateMismatch>,\n-    rejected_via_kind: Vec<CrateMismatch>,\n-    rejected_via_version: Vec<CrateMismatch>,\n-    rejected_via_filename: Vec<CrateMismatch>,\n+    crate_rejections: CrateRejections,\n }\n \n crate enum CrateError {\n@@ -974,7 +962,7 @@ impl CrateError {\n                     Some(r) => format!(\" which `{}` depends on\", r.name),\n                 };\n                 let mut msg = \"the following crate versions were found:\".to_string();\n-                let mut err = if !locator.rejected_via_hash.is_empty() {\n+                let mut err = if !locator.crate_rejections.via_hash.is_empty() {\n                     let mut err = struct_span_err!(\n                         sess,\n                         span,\n@@ -984,7 +972,7 @@ impl CrateError {\n                         add,\n                     );\n                     err.note(\"perhaps that crate needs to be recompiled?\");\n-                    let mismatches = locator.rejected_via_hash.iter();\n+                    let mismatches = locator.crate_rejections.via_hash.iter();\n                     for CrateMismatch { path, .. } in mismatches {\n                         msg.push_str(&format!(\"\\ncrate `{}`: {}\", crate_name, path.display()));\n                     }\n@@ -995,7 +983,7 @@ impl CrateError {\n                     }\n                     err.note(&msg);\n                     err\n-                } else if !locator.rejected_via_triple.is_empty() {\n+                } else if !locator.crate_rejections.via_triple.is_empty() {\n                     let mut err = struct_span_err!(\n                         sess,\n                         span,\n@@ -1005,7 +993,7 @@ impl CrateError {\n                         locator.triple,\n                         add,\n                     );\n-                    let mismatches = locator.rejected_via_triple.iter();\n+                    let mismatches = locator.crate_rejections.via_triple.iter();\n                     for CrateMismatch { path, got } in mismatches {\n                         msg.push_str(&format!(\n                             \"\\ncrate `{}`, target triple {}: {}\",\n@@ -1016,7 +1004,7 @@ impl CrateError {\n                     }\n                     err.note(&msg);\n                     err\n-                } else if !locator.rejected_via_kind.is_empty() {\n+                } else if !locator.crate_rejections.via_kind.is_empty() {\n                     let mut err = struct_span_err!(\n                         sess,\n                         span,\n@@ -1026,13 +1014,13 @@ impl CrateError {\n                         add,\n                     );\n                     err.help(\"please recompile that crate using --crate-type lib\");\n-                    let mismatches = locator.rejected_via_kind.iter();\n+                    let mismatches = locator.crate_rejections.via_kind.iter();\n                     for CrateMismatch { path, .. } in mismatches {\n                         msg.push_str(&format!(\"\\ncrate `{}`: {}\", crate_name, path.display()));\n                     }\n                     err.note(&msg);\n                     err\n-                } else if !locator.rejected_via_version.is_empty() {\n+                } else if !locator.crate_rejections.via_version.is_empty() {\n                     let mut err = struct_span_err!(\n                         sess,\n                         span,\n@@ -1045,7 +1033,7 @@ impl CrateError {\n                         \"please recompile that crate using this compiler ({})\",\n                         rustc_version(),\n                     ));\n-                    let mismatches = locator.rejected_via_version.iter();\n+                    let mismatches = locator.crate_rejections.via_version.iter();\n                     for CrateMismatch { path, got } in mismatches {\n                         msg.push_str(&format!(\n                             \"\\ncrate `{}` compiled by {}: {}\",\n@@ -1112,8 +1100,8 @@ impl CrateError {\n                     err\n                 };\n \n-                if !locator.rejected_via_filename.is_empty() {\n-                    let mismatches = locator.rejected_via_filename.iter();\n+                if !locator.crate_rejections.via_filename.is_empty() {\n+                    let mismatches = locator.crate_rejections.via_filename.iter();\n                     for CrateMismatch { path, .. } in mismatches {\n                         err.note(&format!(\n                             \"extern location for {} is of an unknown type: {}\","}]}