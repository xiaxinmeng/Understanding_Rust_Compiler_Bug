{"sha": "78bccb3540ae8082d34e45be5abb19ed720e9a32", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4YmNjYjM1NDBhZTgwODJkMzRlNDViZTVhYmIxOWVkNzIwZTlhMzI=", "commit": {"author": {"name": "Cl\u00e9ment Renault", "email": "renault.cle@gmail.com", "date": "2018-09-08T13:33:02Z"}, "committer": {"name": "Cl\u00e9ment Renault", "email": "renault.cle@gmail.com", "date": "2018-09-23T07:09:54Z"}, "message": "Introduce the partition_dedup/by/by_key methods for slices", "tree": {"sha": "384e206e5c633028144a17864810bfdf96fe0270", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/384e206e5c633028144a17864810bfdf96fe0270"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78bccb3540ae8082d34e45be5abb19ed720e9a32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78bccb3540ae8082d34e45be5abb19ed720e9a32", "html_url": "https://github.com/rust-lang/rust/commit/78bccb3540ae8082d34e45be5abb19ed720e9a32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78bccb3540ae8082d34e45be5abb19ed720e9a32/comments", "author": {"login": "Kerollmops", "id": 3610253, "node_id": "MDQ6VXNlcjM2MTAyNTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3610253?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kerollmops", "html_url": "https://github.com/Kerollmops", "followers_url": "https://api.github.com/users/Kerollmops/followers", "following_url": "https://api.github.com/users/Kerollmops/following{/other_user}", "gists_url": "https://api.github.com/users/Kerollmops/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kerollmops/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kerollmops/subscriptions", "organizations_url": "https://api.github.com/users/Kerollmops/orgs", "repos_url": "https://api.github.com/users/Kerollmops/repos", "events_url": "https://api.github.com/users/Kerollmops/events{/privacy}", "received_events_url": "https://api.github.com/users/Kerollmops/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kerollmops", "id": 3610253, "node_id": "MDQ6VXNlcjM2MTAyNTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3610253?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kerollmops", "html_url": "https://github.com/Kerollmops", "followers_url": "https://api.github.com/users/Kerollmops/followers", "following_url": "https://api.github.com/users/Kerollmops/following{/other_user}", "gists_url": "https://api.github.com/users/Kerollmops/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kerollmops/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kerollmops/subscriptions", "organizations_url": "https://api.github.com/users/Kerollmops/orgs", "repos_url": "https://api.github.com/users/Kerollmops/repos", "events_url": "https://api.github.com/users/Kerollmops/events{/privacy}", "received_events_url": "https://api.github.com/users/Kerollmops/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7714c430ae1f771001fc0a1b083752485baba56e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7714c430ae1f771001fc0a1b083752485baba56e", "html_url": "https://github.com/rust-lang/rust/commit/7714c430ae1f771001fc0a1b083752485baba56e"}], "stats": {"total": 242, "additions": 237, "deletions": 5}, "files": [{"sha": "3f49d99989de9c2e34d118a88df1f9ff7954c4ad", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/78bccb3540ae8082d34e45be5abb19ed720e9a32/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78bccb3540ae8082d34e45be5abb19ed720e9a32/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=78bccb3540ae8082d34e45be5abb19ed720e9a32", "patch": "@@ -947,10 +947,9 @@ impl<T> Vec<T> {\n     /// Removes all but the first of consecutive elements in the vector satisfying a given equality\n     /// relation.\n     ///\n-    /// The `same_bucket` function is passed references to two elements from the vector, and\n-    /// returns `true` if the elements compare equal, or `false` if they do not. The elements are\n-    /// passed in opposite order from their order in the vector, so if `same_bucket(a, b)` returns\n-    /// `true`, `a` is removed.\n+    /// The `same_bucket` function is passed references to two elements from the vector and\n+    /// must determine if the elements compare equal. The elements are passed in opposite order\n+    /// from their order in the slice, so if `same_bucket(a, b)` returns `true`, `a` is removed.\n     ///\n     /// If the vector is sorted, this removes all duplicates.\n     ///\n@@ -1533,7 +1532,8 @@ impl<'a> Drop for SetLenOnDrop<'a> {\n }\n \n impl<T: PartialEq> Vec<T> {\n-    /// Removes consecutive repeated elements in the vector.\n+    /// Removes consecutive repeated elements in the vector according to the\n+    /// [`PartialEq`] trait implementation.\n     ///\n     /// If the vector is sorted, this removes all duplicates.\n     ///"}, {"sha": "97aada385553eb6c962300889bb98c2f518a6896", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/78bccb3540ae8082d34e45be5abb19ed720e9a32/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78bccb3540ae8082d34e45be5abb19ed720e9a32/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=78bccb3540ae8082d34e45be5abb19ed720e9a32", "patch": "@@ -1402,6 +1402,178 @@ impl<T> [T] {\n         sort::quicksort(self, |a, b| f(a).lt(&f(b)));\n     }\n \n+    /// Moves all consecutive repeated elements to the end of the slice according to the\n+    /// [`PartialEq`] trait implementation.\n+    ///\n+    /// Returns two slices. The first contains no consecutive repeated elements.\n+    /// The second contains all the duplicates in no specified order.\n+    ///\n+    /// If the slice is sorted, the first returned slice contains no duplicates.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_partition_dedup)]\n+    ///\n+    /// let mut slice = [1, 2, 2, 3, 3, 2, 1, 1];\n+    ///\n+    /// let (dedup, duplicates) = slice.partition_dedup();\n+    ///\n+    /// assert_eq!(dedup, [1, 2, 3, 2, 1]);\n+    /// assert_eq!(duplicates, [2, 3, 1]);\n+    /// ```\n+    #[unstable(feature = \"slice_partition_dedup\", issue = \"54279\")]\n+    #[inline]\n+    pub fn partition_dedup(&mut self) -> (&mut [T], &mut [T])\n+        where T: PartialEq\n+    {\n+        self.partition_dedup_by(|a, b| a == b)\n+    }\n+\n+    /// Moves all but the first of consecutive elements to the end of the slice satisfying\n+    /// a given equality relation.\n+    ///\n+    /// Returns two slices. The first contains no consecutive repeated elements.\n+    /// The second contains all the duplicates in no specified order.\n+    ///\n+    /// The `same_bucket` function is passed references to two elements from the slice and\n+    /// must determine if the elements compare equal. The elements are passed in opposite order\n+    /// from their order in the slice, so if `same_bucket(a, b)` returns `true`, `a` is moved\n+    /// at the end of the slice.\n+    ///\n+    /// If the slice is sorted, the first returned slice contains no duplicates.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_partition_dedup)]\n+    ///\n+    /// let mut slice = [\"foo\", \"Foo\", \"BAZ\", \"Bar\", \"bar\", \"baz\", \"BAZ\"];\n+    ///\n+    /// let (dedup, duplicates) = slice.partition_dedup_by(|a, b| a.eq_ignore_ascii_case(b));\n+    ///\n+    /// assert_eq!(dedup, [\"foo\", \"BAZ\", \"Bar\", \"baz\"]);\n+    /// assert_eq!(duplicates, [\"bar\", \"Foo\", \"BAZ\"]);\n+    /// ```\n+    #[unstable(feature = \"slice_partition_dedup\", issue = \"54279\")]\n+    #[inline]\n+    pub fn partition_dedup_by<F>(&mut self, mut same_bucket: F) -> (&mut [T], &mut [T])\n+        where F: FnMut(&mut T, &mut T) -> bool\n+    {\n+        // Although we have a mutable reference to `self`, we cannot make\n+        // *arbitrary* changes. The `same_bucket` calls could panic, so we\n+        // must ensure that the slice is in a valid state at all times.\n+        //\n+        // The way that we handle this is by using swaps; we iterate\n+        // over all the elements, swapping as we go so that at the end\n+        // the elements we wish to keep are in the front, and those we\n+        // wish to reject are at the back. We can then split the slice.\n+        // This operation is still O(n).\n+        //\n+        // Example: We start in this state, where `r` represents \"next\n+        // read\" and `w` represents \"next_write`.\n+        //\n+        //           r\n+        //     +---+---+---+---+---+---+\n+        //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+        //     +---+---+---+---+---+---+\n+        //           w\n+        //\n+        // Comparing self[r] against self[w-1], this is not a duplicate, so\n+        // we swap self[r] and self[w] (no effect as r==w) and then increment both\n+        // r and w, leaving us with:\n+        //\n+        //               r\n+        //     +---+---+---+---+---+---+\n+        //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+        //     +---+---+---+---+---+---+\n+        //               w\n+        //\n+        // Comparing self[r] against self[w-1], this value is a duplicate,\n+        // so we increment `r` but leave everything else unchanged:\n+        //\n+        //                   r\n+        //     +---+---+---+---+---+---+\n+        //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+        //     +---+---+---+---+---+---+\n+        //               w\n+        //\n+        // Comparing self[r] against self[w-1], this is not a duplicate,\n+        // so swap self[r] and self[w] and advance r and w:\n+        //\n+        //                       r\n+        //     +---+---+---+---+---+---+\n+        //     | 0 | 1 | 2 | 1 | 3 | 3 |\n+        //     +---+---+---+---+---+---+\n+        //                   w\n+        //\n+        // Not a duplicate, repeat:\n+        //\n+        //                           r\n+        //     +---+---+---+---+---+---+\n+        //     | 0 | 1 | 2 | 3 | 1 | 3 |\n+        //     +---+---+---+---+---+---+\n+        //                       w\n+        //\n+        // Duplicate, advance r. End of slice. Split at w.\n+\n+        let len = self.len();\n+        if len <= 1 {\n+            return (self, &mut [])\n+        }\n+\n+        let ptr = self.as_mut_ptr();\n+        let mut next_read: usize = 1;\n+        let mut next_write: usize = 1;\n+\n+        unsafe {\n+            // Avoid bounds checks by using raw pointers.\n+            while next_read < len {\n+                let ptr_read = ptr.add(next_read);\n+                let prev_ptr_write = ptr.add(next_write - 1);\n+                if !same_bucket(&mut *ptr_read, &mut *prev_ptr_write) {\n+                    if next_read != next_write {\n+                        let ptr_write = prev_ptr_write.offset(1);\n+                        mem::swap(&mut *ptr_read, &mut *ptr_write);\n+                    }\n+                    next_write += 1;\n+                }\n+                next_read += 1;\n+            }\n+        }\n+\n+        self.split_at_mut(next_write)\n+    }\n+\n+    /// Moves all but the first of consecutive elements to the end of the slice that resolve\n+    /// to the same key.\n+    ///\n+    /// Returns two slices. The first contains no consecutive repeated elements.\n+    /// The second contains all the duplicates in no specified order.\n+    ///\n+    /// If the slice is sorted, the first returned slice contains no duplicates.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_partition_dedup)]\n+    ///\n+    /// let mut slice = [10, 20, 21, 30, 30, 20, 11, 13];\n+    ///\n+    /// let (dedup, duplicates) = slice.partition_dedup_by_key(|i| *i / 10);\n+    ///\n+    /// assert_eq!(dedup, [10, 20, 30, 20, 11]);\n+    /// assert_eq!(duplicates, [21, 30, 13]);\n+    /// ```\n+    #[unstable(feature = \"slice_partition_dedup\", issue = \"54279\")]\n+    #[inline]\n+    pub fn partition_dedup_by_key<K, F>(&mut self, mut key: F) -> (&mut [T], &mut [T])\n+        where F: FnMut(&mut T) -> K,\n+              K: PartialEq,\n+    {\n+        self.partition_dedup_by(|a, b| key(a) == key(b))\n+    }\n+\n     /// Rotates the slice in-place such that the first `mid` elements of the\n     /// slice move to the end while the last `self.len() - mid` elements move to\n     /// the front. After calling `rotate_left`, the element previously at index"}, {"sha": "d05f6e07331c941d4f090865d8c1211e06cdfea6", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/78bccb3540ae8082d34e45be5abb19ed720e9a32/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78bccb3540ae8082d34e45be5abb19ed720e9a32/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=78bccb3540ae8082d34e45be5abb19ed720e9a32", "patch": "@@ -39,6 +39,7 @@\n #![feature(inner_deref)]\n #![feature(slice_internals)]\n #![feature(option_replace)]\n+#![feature(slice_partition_dedup)]\n #![feature(copy_within)]\n \n extern crate core;"}, {"sha": "6f11880eb72dbb8bf3e19cdf974411d44667d1d1", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/78bccb3540ae8082d34e45be5abb19ed720e9a32/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78bccb3540ae8082d34e45be5abb19ed720e9a32/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=78bccb3540ae8082d34e45be5abb19ed720e9a32", "patch": "@@ -1001,6 +1001,65 @@ fn test_align_to_empty_mid() {\n     }\n }\n \n+#[test]\n+fn test_slice_partition_dedup_by() {\n+    let mut slice: [i32; 9] = [1, -1, 2, 3, 1, -5, 5, -2, 2];\n+\n+    let (dedup, duplicates) = slice.partition_dedup_by(|a, b| a.abs() == b.abs());\n+\n+    assert_eq!(dedup, [1, 2, 3, 1, -5, -2]);\n+    assert_eq!(duplicates, [5, -1, 2]);\n+}\n+\n+#[test]\n+fn test_slice_partition_dedup_empty() {\n+    let mut slice: [i32; 0] = [];\n+\n+    let (dedup, duplicates) = slice.partition_dedup();\n+\n+    assert_eq!(dedup, []);\n+    assert_eq!(duplicates, []);\n+}\n+\n+#[test]\n+fn test_slice_partition_dedup_one() {\n+    let mut slice = [12];\n+\n+    let (dedup, duplicates) = slice.partition_dedup();\n+\n+    assert_eq!(dedup, [12]);\n+    assert_eq!(duplicates, []);\n+}\n+\n+#[test]\n+fn test_slice_partition_dedup_multiple_ident() {\n+    let mut slice = [12, 12, 12, 12, 12, 11, 11, 11, 11, 11, 11];\n+\n+    let (dedup, duplicates) = slice.partition_dedup();\n+\n+    assert_eq!(dedup, [12, 11]);\n+    assert_eq!(duplicates, [12, 12, 12, 12, 11, 11, 11, 11, 11]);\n+}\n+\n+#[test]\n+fn test_slice_partition_dedup_partialeq() {\n+    #[derive(Debug)]\n+    struct Foo(i32, i32);\n+\n+    impl PartialEq for Foo {\n+        fn eq(&self, other: &Foo) -> bool {\n+            self.0 == other.0\n+        }\n+    }\n+\n+    let mut slice = [Foo(0, 1), Foo(0, 5), Foo(1, 7), Foo(1, 9)];\n+\n+    let (dedup, duplicates) = slice.partition_dedup();\n+\n+    assert_eq!(dedup, [Foo(0, 1), Foo(1, 7)]);\n+    assert_eq!(duplicates, [Foo(0, 5), Foo(1, 9)]);\n+}\n+\n #[test]\n fn test_copy_within() {\n     // Start to end, with a RangeTo."}]}