{"sha": "553c27c515876990f4e3362d3f6bcab984fcd8f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1M2MyN2M1MTU4NzY5OTBmNGUzMzYyZDNmNmJjYWI5ODRmY2Q4Zjk=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-02-21T19:57:20Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-02-21T23:45:55Z"}, "message": "librustc: De-mut some of trans", "tree": {"sha": "093877208315d05fc5f230060bb944a8cb1de8d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/093877208315d05fc5f230060bb944a8cb1de8d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/553c27c515876990f4e3362d3f6bcab984fcd8f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/553c27c515876990f4e3362d3f6bcab984fcd8f9", "html_url": "https://github.com/rust-lang/rust/commit/553c27c515876990f4e3362d3f6bcab984fcd8f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/553c27c515876990f4e3362d3f6bcab984fcd8f9/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdd6f38220ae4b6d6b84524fa4b8f684898bad55", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdd6f38220ae4b6d6b84524fa4b8f684898bad55", "html_url": "https://github.com/rust-lang/rust/commit/cdd6f38220ae4b6d6b84524fa4b8f684898bad55"}], "stats": {"total": 150, "additions": 82, "deletions": 68}, "files": [{"sha": "499cbda4118acdf103c5f10e89cbecdafc9dc04c", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 42, "deletions": 30, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/553c27c515876990f4e3362d3f6bcab984fcd8f9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553c27c515876990f4e3362d3f6bcab984fcd8f9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=553c27c515876990f4e3362d3f6bcab984fcd8f9", "patch": "@@ -866,8 +866,8 @@ pub fn need_invoke(bcx: block) -> bool {\n     // Walk the scopes to look for cleanups\n     let mut cur = bcx;\n     loop {\n-        match cur.kind {\n-          block_scope(ref inf) => {\n+        match *cur.kind {\n+          block_scope(ref mut inf) => {\n             for vec::each((*inf).cleanups) |cleanup| {\n                 match *cleanup {\n                   clean(_, cleanup_type) | clean_temp(_, _, cleanup_type) => {\n@@ -898,16 +898,21 @@ pub fn have_cached_lpad(bcx: block) -> bool {\n     return res;\n }\n \n-pub fn in_lpad_scope_cx(bcx: block, f: fn(scope_info)) {\n+pub fn in_lpad_scope_cx(bcx: block, f: fn(&mut scope_info)) {\n     let mut bcx = bcx;\n     loop {\n-        match bcx.kind {\n-          block_scope(ref inf) => {\n-            if (*inf).cleanups.len() > 0u || bcx.parent.is_none() {\n-                f((*inf)); return;\n+        {\n+            // XXX: Borrow check bug workaround.\n+            let kind: &mut block_kind = &mut *bcx.kind;\n+            match *kind {\n+                block_scope(ref mut inf) => {\n+                    if inf.cleanups.len() > 0u || bcx.parent.is_none() {\n+                        f(inf);\n+                        return;\n+                    }\n+                }\n+                _ => ()\n             }\n-          }\n-          _ => ()\n         }\n         bcx = block_parent(bcx);\n     }\n@@ -1198,9 +1203,9 @@ pub fn simple_block_scope() -> block_kind {\n     block_scope(scope_info {\n         loop_break: None,\n         loop_label: None,\n-        mut cleanups: ~[],\n-        mut cleanup_paths: ~[],\n-        mut landing_pad: None\n+        cleanups: ~[],\n+        cleanup_paths: ~[],\n+        landing_pad: None\n     })\n }\n \n@@ -1226,9 +1231,9 @@ pub fn loop_scope_block(bcx: block,\n     return new_block(bcx.fcx, Some(bcx), block_scope(scope_info {\n         loop_break: Some(loop_break),\n         loop_label: loop_label,\n-        mut cleanups: ~[],\n-        mut cleanup_paths: ~[],\n-        mut landing_pad: None\n+        cleanups: ~[],\n+        cleanup_paths: ~[],\n+        landing_pad: None\n     }), bcx.is_lpad, n, opt_node_info);\n }\n \n@@ -1301,23 +1306,30 @@ pub fn cleanup_and_leave(bcx: block,\n                 @fmt!(\"cleanup_and_leave(%s)\", cur.to_str()));\n         }\n \n-        match cur.kind {\n-          block_scope(ref inf) if !inf.cleanups.is_empty() => {\n-            for vec::find((*inf).cleanup_paths,\n-                          |cp| cp.target == leave).each |cp| {\n-                Br(bcx, cp.dest);\n-                return;\n+        {\n+            // XXX: Borrow check bug workaround.\n+            let kind: &mut block_kind = &mut *cur.kind;\n+            match *kind {\n+              block_scope(ref mut inf) if !inf.cleanups.is_empty() => {\n+                for vec::find((*inf).cleanup_paths,\n+                              |cp| cp.target == leave).each |cp| {\n+                    Br(bcx, cp.dest);\n+                    return;\n+                }\n+                let sub_cx = sub_block(bcx, ~\"cleanup\");\n+                Br(bcx, sub_cx.llbb);\n+                inf.cleanup_paths.push(cleanup_path {\n+                    target: leave,\n+                    dest: sub_cx.llbb\n+                });\n+                bcx = trans_block_cleanups_(sub_cx,\n+                                            block_cleanups(cur),\n+                                            is_lpad);\n+              }\n+              _ => ()\n             }\n-            let sub_cx = sub_block(bcx, ~\"cleanup\");\n-            Br(bcx, sub_cx.llbb);\n-            (*inf).cleanup_paths.push(cleanup_path {\n-                target: leave,\n-                dest: sub_cx.llbb\n-            });\n-            bcx = trans_block_cleanups_(sub_cx, block_cleanups(cur), is_lpad);\n-          }\n-          _ => ()\n         }\n+\n         match upto {\n           Some(bb) => { if cur.llbb == bb { break; } }\n           _ => ()"}, {"sha": "a69e51c666c6fb437fe8e085f46caa0e0f2768bc", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/553c27c515876990f4e3362d3f6bcab984fcd8f9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553c27c515876990f4e3362d3f6bcab984fcd8f9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=553c27c515876990f4e3362d3f6bcab984fcd8f9", "patch": "@@ -355,7 +355,7 @@ pub struct cleanup_path {\n     dest: BasicBlockRef\n }\n \n-pub fn scope_clean_changed(scope_info: scope_info) {\n+pub fn scope_clean_changed(scope_info: &mut scope_info) {\n     if scope_info.cleanup_paths.len() > 0u { scope_info.cleanup_paths = ~[]; }\n     scope_info.landing_pad = None;\n }\n@@ -498,9 +498,9 @@ pub fn revoke_clean(cx: block, val: ValueRef) {\n }\n \n pub fn block_cleanups(bcx: block) -> ~[cleanup] {\n-    match bcx.kind {\n+    match *bcx.kind {\n        block_non_scope  => ~[],\n-       block_scope(ref inf) => /*bad*/copy inf.cleanups\n+       block_scope(ref mut inf) => /*bad*/copy inf.cleanups\n     }\n }\n \n@@ -524,12 +524,12 @@ pub struct scope_info {\n     // A list of functions that must be run at when leaving this\n     // block, cleaning up any variables that were introduced in the\n     // block.\n-    mut cleanups: ~[cleanup],\n+    cleanups: ~[cleanup],\n     // Existing cleanup paths that may be reused, indexed by destination and\n     // cleared when the set of cleanups changes.\n-    mut cleanup_paths: ~[cleanup_path],\n+    cleanup_paths: ~[cleanup_path],\n     // Unwinding landing pad. Also cleared when cleanups change.\n-    mut landing_pad: Option<BasicBlockRef>,\n+    landing_pad: Option<BasicBlockRef>,\n }\n \n pub trait get_node_info {\n@@ -574,11 +574,11 @@ pub struct block_ {\n     // instructions into that block by way of this block context.\n     // The block pointing to this one in the function's digraph.\n     llbb: BasicBlockRef,\n-    mut terminated: bool,\n-    mut unreachable: bool,\n+    terminated: bool,\n+    unreachable: bool,\n     parent: Option<block>,\n     // The 'kind' of basic block this is.\n-    kind: block_kind,\n+    kind: @mut block_kind,\n     // Is this block part of a landing pad?\n     is_lpad: bool,\n     // info about the AST node this block originated from, if any\n@@ -597,21 +597,19 @@ pub fn block_(llbb: BasicBlockRef, parent: Option<block>, -kind: block_kind,\n         terminated: false,\n         unreachable: false,\n         parent: parent,\n-        kind: kind,\n+        kind: @mut kind,\n         is_lpad: is_lpad,\n         node_info: node_info,\n         fcx: fcx\n     }\n }\n \n-/* This must be enum and not type, or trans goes into an infinite loop (#2572)\n- */\n-pub enum block = @block_;\n+pub type block = @mut block_;\n \n pub fn mk_block(llbb: BasicBlockRef, parent: Option<block>, -kind: block_kind,\n             is_lpad: bool, node_info: Option<NodeInfo>, fcx: fn_ctxt)\n     -> block {\n-    block(@block_(llbb, parent, kind, is_lpad, node_info, fcx))\n+    @mut block_(llbb, parent, kind, is_lpad, node_info, fcx)\n }\n \n // First two args are retptr, env\n@@ -660,17 +658,21 @@ pub fn struct_elt(llstructty: TypeRef, n: uint) -> TypeRef {\n     }\n }\n \n-pub fn in_scope_cx(cx: block, f: fn(scope_info)) {\n+pub fn in_scope_cx(cx: block, f: &fn(&mut scope_info)) {\n     let mut cur = cx;\n     loop {\n-        match cur.kind {\n-          block_scope(ref inf) => {\n-              debug!(\"in_scope_cx: selected cur=%s (cx=%s)\",\n-                     cur.to_str(), cx.to_str());\n-              f((*inf));\n-              return;\n-          }\n-          _ => ()\n+        {\n+            // XXX: Borrow check bug workaround.\n+            let kind: &mut block_kind = &mut *cur.kind;\n+            match *kind {\n+              block_scope(ref mut inf) => {\n+                  debug!(\"in_scope_cx: selected cur=%s (cx=%s)\",\n+                         cur.to_str(), cx.to_str());\n+                  f(inf);\n+                  return;\n+              }\n+              _ => ()\n+            }\n         }\n         cur = block_parent(cur);\n     }"}, {"sha": "4cf12576a78ee7a4634c2b47b71582b4615e6477", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/553c27c515876990f4e3362d3f6bcab984fcd8f9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553c27c515876990f4e3362d3f6bcab984fcd8f9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=553c27c515876990f4e3362d3f6bcab984fcd8f9", "patch": "@@ -237,7 +237,7 @@ pub fn trans_break_cont(bcx: block,\n     let mut unwind = bcx;\n     let mut target;\n     loop {\n-        match unwind.kind {\n+        match *unwind.kind {\n           block_scope(scope_info {\n             loop_break: Some(brk),\n             loop_label: l,"}, {"sha": "eb92b23c9d7e73d8516e0bd1f7dc843af734f274", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/553c27c515876990f4e3362d3f6bcab984fcd8f9/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553c27c515876990f4e3362d3f6bcab984fcd8f9/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=553c27c515876990f4e3362d3f6bcab984fcd8f9", "patch": "@@ -196,7 +196,7 @@ pub fn mk_ctxt(parse_sess: @mut parse::ParseSess,\n     struct CtxtRepr {\n         parse_sess: @mut parse::ParseSess,\n         cfg: ast::crate_cfg,\n-        backtrace: Option<@ExpnInfo>,\n+        backtrace: @mut Option<@ExpnInfo>,\n         mod_path: ~[ast::ident],\n         trace_mac: bool\n     }\n@@ -205,33 +205,33 @@ pub fn mk_ctxt(parse_sess: @mut parse::ParseSess,\n         fn parse_sess(@mut self) -> @mut parse::ParseSess { self.parse_sess }\n         fn cfg(@mut self) -> ast::crate_cfg { self.cfg }\n         fn call_site(@mut self) -> span {\n-            match self.backtrace {\n+            match *self.backtrace {\n                 Some(@ExpandedFrom(CallInfo {call_site: cs, _})) => cs,\n                 None => self.bug(~\"missing top span\")\n             }\n         }\n         fn print_backtrace(@mut self) { }\n-        fn backtrace(@mut self) -> Option<@ExpnInfo> { self.backtrace }\n+        fn backtrace(@mut self) -> Option<@ExpnInfo> { *self.backtrace }\n         fn mod_push(@mut self, i: ast::ident) { self.mod_path.push(i); }\n         fn mod_pop(@mut self) { self.mod_path.pop(); }\n         fn mod_path(@mut self) -> ~[ast::ident] { return self.mod_path; }\n         fn bt_push(@mut self, ei: codemap::ExpnInfo) {\n             match ei {\n               ExpandedFrom(CallInfo {call_site: cs, callee: ref callee}) => {\n-                self.backtrace =\n+                *self.backtrace =\n                     Some(@ExpandedFrom(CallInfo {\n                         call_site: span {lo: cs.lo, hi: cs.hi,\n-                                         expn_info: self.backtrace},\n+                                         expn_info: *self.backtrace},\n                         callee: (*callee)}));\n               }\n             }\n         }\n         fn bt_pop(@mut self) {\n-            match self.backtrace {\n+            match *self.backtrace {\n               Some(@ExpandedFrom(CallInfo {\n                   call_site: span {expn_info: prev, _}, _\n               })) => {\n-                self.backtrace = prev\n+                *self.backtrace = prev\n               }\n               _ => self.bug(~\"tried to pop without a push\")\n             }\n@@ -280,7 +280,7 @@ pub fn mk_ctxt(parse_sess: @mut parse::ParseSess,\n     let imp: @mut CtxtRepr = @mut CtxtRepr {\n         parse_sess: parse_sess,\n         cfg: cfg,\n-        backtrace: None,\n+        backtrace: @mut None,\n         mod_path: ~[],\n         trace_mac: false\n     };"}, {"sha": "3817f89b8173fc66ac96c9eeb545c15c7dc6557a", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/553c27c515876990f4e3362d3f6bcab984fcd8f9/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553c27c515876990f4e3362d3f6bcab984fcd8f9/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=553c27c515876990f4e3362d3f6bcab984fcd8f9", "patch": "@@ -28,7 +28,7 @@ use std::oldmap::HashMap;\n    `~` */\n ///an unzipping of `token_tree`s\n struct TtFrame {\n-    readme: ~[ast::token_tree],\n+    readme: @mut ~[ast::token_tree],\n     idx: uint,\n     dotdotdoted: bool,\n     sep: Option<Token>,\n@@ -60,7 +60,7 @@ pub fn new_tt_reader(sp_diag: span_handler,\n         sp_diag: sp_diag,\n         interner: itr,\n         mut cur: @mut TtFrame {\n-            readme: src,\n+            readme: @mut src,\n             idx: 0u,\n             dotdotdoted: false,\n             sep: None,\n@@ -82,7 +82,7 @@ pub fn new_tt_reader(sp_diag: span_handler,\n \n pure fn dup_tt_frame(f: @mut TtFrame) -> @mut TtFrame {\n     @mut TtFrame {\n-        readme: f.readme,\n+        readme: @mut (copy *f.readme),\n         idx: f.idx,\n         dotdotdoted: f.dotdotdoted,\n         sep: f.sep,\n@@ -199,9 +199,9 @@ pub fn tt_next_token(r: @mut TtReader) -> TokenAndSpan {\n     loop { /* because it's easiest, this handles `tt_delim` not starting\n     with a `tt_tok`, even though it won't happen */\n         match r.cur.readme[r.cur.idx] {\n-          tt_delim(copy tts) => {\n+          tt_delim(tts) => {\n             r.cur = @mut TtFrame {\n-                readme: tts,\n+                readme: @mut copy tts,\n                 idx: 0u,\n                 dotdotdoted: false,\n                 sep: None,\n@@ -242,7 +242,7 @@ pub fn tt_next_token(r: @mut TtReader) -> TokenAndSpan {\n                     r.repeat_len.push(len);\n                     r.repeat_idx.push(0u);\n                     r.cur = @mut TtFrame {\n-                        readme: tts,\n+                        readme: @mut copy tts,\n                         idx: 0u,\n                         dotdotdoted: true,\n                         sep: sep,"}]}