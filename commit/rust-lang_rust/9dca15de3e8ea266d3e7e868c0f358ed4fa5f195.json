{"sha": "9dca15de3e8ea266d3e7e868c0f358ed4fa5f195", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkY2ExNWRlM2U4ZWEyNjZkM2U3ZTg2OGMwZjM1OGVkNGZhNWYxOTU=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-12-19T13:32:06Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-12-19T13:32:06Z"}, "message": "Merge pull request #499 from devonhollowood/underscore_binding\n\nAdd used_underscore_binding lint", "tree": {"sha": "e351e3bdc0fb05d4a50e74a0aa9c338adab0d349", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e351e3bdc0fb05d4a50e74a0aa9c338adab0d349"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9dca15de3e8ea266d3e7e868c0f358ed4fa5f195", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9dca15de3e8ea266d3e7e868c0f358ed4fa5f195", "html_url": "https://github.com/rust-lang/rust/commit/9dca15de3e8ea266d3e7e868c0f358ed4fa5f195", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9dca15de3e8ea266d3e7e868c0f358ed4fa5f195/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b900e889106bd33b0b0ad84d6f8500ef958e0b18", "url": "https://api.github.com/repos/rust-lang/rust/commits/b900e889106bd33b0b0ad84d6f8500ef958e0b18", "html_url": "https://github.com/rust-lang/rust/commit/b900e889106bd33b0b0ad84d6f8500ef958e0b18"}, {"sha": "bd82c082cb7734f037116d38f949ca354b597a29", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd82c082cb7734f037116d38f949ca354b597a29", "html_url": "https://github.com/rust-lang/rust/commit/bd82c082cb7734f037116d38f949ca354b597a29"}], "stats": {"total": 167, "additions": 159, "deletions": 8}, "files": [{"sha": "015a7d9adf26759b74cb610c276117540d049327", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9dca15de3e8ea266d3e7e868c0f358ed4fa5f195/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/9dca15de3e8ea266d3e7e868c0f358ed4fa5f195/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=9dca15de3e8ea266d3e7e868c0f358ed4fa5f195", "patch": "@@ -6,7 +6,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 83 lints included in this crate:\n+There are 84 lints included in this crate:\n \n name                                                                                                     | default | meaning\n ---------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -86,6 +86,7 @@ name\n [unstable_as_slice](https://github.com/Manishearth/rust-clippy/wiki#unstable_as_slice)                   | warn    | as_slice is not stable and can be replaced by & v[..]see https://github.com/rust-lang/rust/issues/27729\n [unused_collect](https://github.com/Manishearth/rust-clippy/wiki#unused_collect)                         | warn    | `collect()`ing an iterator without using the result; this is usually better written as a for loop\n [unused_lifetimes](https://github.com/Manishearth/rust-clippy/wiki#unused_lifetimes)                     | warn    | unused lifetimes in function definitions\n+[used_underscore_binding](https://github.com/Manishearth/rust-clippy/wiki#used_underscore_binding)       | warn    | using a binding which is prefixed with an underscore\n [useless_transmute](https://github.com/Manishearth/rust-clippy/wiki#useless_transmute)                   | warn    | transmutes that have the same to and from types\n [while_let_loop](https://github.com/Manishearth/rust-clippy/wiki#while_let_loop)                         | warn    | `loop { if let { ... } else break }` can be written as a `while let` loop\n [while_let_on_iterator](https://github.com/Manishearth/rust-clippy/wiki#while_let_on_iterator)           | warn    | using a while-let loop instead of a for loop on an iterator"}, {"sha": "05181e69b2cec940f06fe30217f7af5abe30c62a", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9dca15de3e8ea266d3e7e868c0f358ed4fa5f195/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dca15de3e8ea266d3e7e868c0f358ed4fa5f195/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=9dca15de3e8ea266d3e7e868c0f358ed4fa5f195", "patch": "@@ -120,6 +120,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box cyclomatic_complexity::CyclomaticComplexity::new(25));\n     reg.register_late_lint_pass(box escape::EscapePass);\n     reg.register_early_lint_pass(box misc_early::MiscEarly);\n+    reg.register_late_lint_pass(box misc::UsedUnderscoreBinding);\n \n     reg.register_lint_group(\"clippy_pedantic\", vec![\n         methods::OPTION_UNWRAP_USED,\n@@ -184,6 +185,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         misc::MODULO_ONE,\n         misc::REDUNDANT_PATTERN,\n         misc::TOPLEVEL_REF_ARG,\n+        misc::USED_UNDERSCORE_BINDING,\n         misc_early::UNNEEDED_FIELD_PATTERN,\n         mut_reference::UNNECESSARY_MUT_PASSED,\n         mutex_atomic::MUTEX_ATOMIC,"}, {"sha": "44d044a4384c2c482cfce6440282003e2dc03474", "filename": "src/misc.rs", "status": "modified", "additions": 68, "deletions": 1, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/9dca15de3e8ea266d3e7e868c0f358ed4fa5f195/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dca15de3e8ea266d3e7e868c0f358ed4fa5f195/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=9dca15de3e8ea266d3e7e868c0f358ed4fa5f195", "patch": "@@ -10,7 +10,8 @@ use rustc::middle::const_eval::ConstVal::Float;\n use rustc::middle::const_eval::eval_const_expr_partial;\n use rustc::middle::const_eval::EvalHint::ExprTypeChecked;\n \n-use utils::{get_item_name, match_path, snippet, span_lint, walk_ptrs_ty, is_integer_literal};\n+use utils::{get_item_name, match_path, snippet, get_parent_expr, span_lint, walk_ptrs_ty,\n+            is_integer_literal};\n use utils::span_help_and_lint;\n \n /// **What it does:** This lint checks for function arguments and let bindings denoted as `ref`. It is `Warn` by default.\n@@ -316,3 +317,69 @@ impl LateLintPass for PatternPass {\n         }\n     }\n }\n+\n+\n+/// **What it does:** This lint checks for the use of bindings with a single leading underscore\n+///\n+/// **Why is this bad?** A single leading underscore is usually used to indicate that a binding\n+/// will not be used. Using such a binding breaks this expectation.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example**:\n+/// ```\n+/// let _x = 0;\n+/// let y = _x + 1; // Here we are using `_x`, even though it has a leading underscore.\n+///                 // We should rename `_x` to `x`\n+/// ```\n+declare_lint!(pub USED_UNDERSCORE_BINDING, Warn,\n+              \"using a binding which is prefixed with an underscore\");\n+\n+#[derive(Copy, Clone)]\n+pub struct UsedUnderscoreBinding;\n+\n+impl LintPass for UsedUnderscoreBinding {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(USED_UNDERSCORE_BINDING)\n+    }\n+}\n+\n+impl LateLintPass for UsedUnderscoreBinding {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+        let needs_lint = match expr.node {\n+            ExprPath(_, ref path) => {\n+                let ident = path.segments.last()\n+                                .expect(\"path should always have at least one segment\")\n+                                .identifier;\n+                ident.name.as_str().chars().next() == Some('_') //starts with '_'\n+                && ident.name.as_str().chars().skip(1).next() != Some('_') //doesn't start with \"__\"\n+                && ident.name != ident.unhygienic_name //not in macro\n+                && is_used(cx, expr)\n+            },\n+            ExprField(_, spanned) => {\n+                let name = spanned.node.as_str();\n+                name.chars().next() == Some('_')\n+                && name.chars().skip(1).next() != Some('_')\n+            },\n+            _ => false\n+        };\n+        if needs_lint {\n+            cx.span_lint(USED_UNDERSCORE_BINDING, expr.span,\n+                         \"used binding which is prefixed with an underscore. A leading underscore \\\n+                          signals that a binding will not be used.\");\n+        }\n+    }\n+}\n+\n+fn is_used(cx: &LateContext, expr: &Expr) -> bool {\n+    if let Some(ref parent) = get_parent_expr(cx, expr) {\n+        match parent.node {\n+            ExprAssign(_, ref rhs) => **rhs == *expr,\n+            ExprAssignOp(_, _, ref rhs) => **rhs == *expr,\n+            _ => is_used(cx, &parent)\n+        }\n+    }\n+    else {\n+        true\n+    }\n+}"}, {"sha": "f1c1adf6cc890088a0e4500c72a637188b0596c2", "filename": "tests/compile-fail/for_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9dca15de3e8ea266d3e7e868c0f358ed4fa5f195/tests%2Fcompile-fail%2Ffor_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dca15de3e8ea266d3e7e868c0f358ed4fa5f195/tests%2Fcompile-fail%2Ffor_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffor_loop.rs?ref=9dca15de3e8ea266d3e7e868c0f358ed4fa5f195", "patch": "@@ -179,8 +179,8 @@ fn main() {\n     if false { _index = 0 };\n     for _v in &vec { _index += 1 }\n \n-    let mut _index = 0;\n-    { let mut _x = &mut _index; }\n+    let mut index = 0;\n+    { let mut _x = &mut index; }\n     for _v in &vec { _index += 1 }\n \n     let mut index = 0;"}, {"sha": "064d9f551732659e1893e0261ffa3fd59c62c263", "filename": "tests/compile-fail/range.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9dca15de3e8ea266d3e7e868c0f358ed4fa5f195/tests%2Fcompile-fail%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dca15de3e8ea266d3e7e868c0f358ed4fa5f195/tests%2Fcompile-fail%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Frange.rs?ref=9dca15de3e8ea266d3e7e868c0f358ed4fa5f195", "patch": "@@ -22,8 +22,8 @@ fn main() {\n     let y = NotARange;\n     y.step_by(0);\n \n-    let _v1 = vec![1,2,3];\n-    let _v2 = vec![4,5];\n-    let _x = _v1.iter().zip(0.._v1.len()); //~ERROR It is more idiomatic to use _v1.iter().enumerate()\n-    let _y = _v1.iter().zip(0.._v2.len()); // No error\n+    let v1 = vec![1,2,3];\n+    let v2 = vec![4,5];\n+    let _x = v1.iter().zip(0..v1.len()); //~ERROR It is more idiomatic to use v1.iter().enumerate()\n+    let _y = v1.iter().zip(0..v2.len()); // No error\n }"}, {"sha": "39a33c96876ea6bced24c8f24cbfbce45004988d", "filename": "tests/compile-fail/used_underscore_binding.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/9dca15de3e8ea266d3e7e868c0f358ed4fa5f195/tests%2Fcompile-fail%2Fused_underscore_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dca15de3e8ea266d3e7e868c0f358ed4fa5f195/tests%2Fcompile-fail%2Fused_underscore_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fused_underscore_binding.rs?ref=9dca15de3e8ea266d3e7e868c0f358ed4fa5f195", "patch": "@@ -0,0 +1,81 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+#![deny(clippy)]\n+\n+/// Test that we lint if we use a binding with a single leading underscore\n+fn prefix_underscore(_foo: u32) -> u32 {\n+    _foo + 1 //~ ERROR used binding which is prefixed with an underscore\n+}\n+\n+/// Test that we lint even if the use is within a macro expansion\n+fn in_macro(_foo: u32) {\n+    println!(\"{}\", _foo); //~ ERROR used binding which is prefixed with an underscore\n+}\n+\n+// Struct for testing use of fields prefixed with an underscore\n+struct StructFieldTest {\n+    _underscore_field: u32,\n+}\n+\n+/// Test that we lint the use of a struct field which is prefixed with an underscore\n+fn in_struct_field() {\n+    let mut s = StructFieldTest { _underscore_field: 0 };\n+    s._underscore_field += 1; //~ Error used binding which is prefixed with an underscore\n+}\n+\n+/// Test that we do not lint if the underscore is not a prefix\n+fn non_prefix_underscore(some_foo: u32) -> u32 {\n+    some_foo + 1\n+}\n+\n+/// Test that we do not lint if we do not use the binding (simple case)\n+fn unused_underscore_simple(_foo: u32) -> u32 {\n+    1\n+}\n+\n+/// Test that we do not lint if we do not use the binding (complex case). This checks for\n+/// compatibility with the built-in `unused_variables` lint.\n+fn unused_underscore_complex(mut _foo: u32) -> u32 {\n+    _foo += 1;\n+    _foo = 2;\n+    1\n+}\n+\n+///Test that we do not lint for multiple underscores\n+fn multiple_underscores(__foo: u32) -> u32 {\n+    __foo + 1\n+}\n+\n+// Non-variable bindings with preceding underscore\n+fn _fn_test() {}\n+struct _StructTest;\n+enum _EnumTest {\n+    _FieldA,\n+    _FieldB(_StructTest)\n+}\n+\n+/// Test that we do not lint for non-variable bindings\n+fn non_variables() {\n+    _fn_test();\n+    let _s = _StructTest;\n+    let _e = match _EnumTest::_FieldB(_StructTest) {\n+        _EnumTest::_FieldA => 0,\n+        _EnumTest::_FieldB(_st) => 1,\n+    };\n+    let f = _fn_test;\n+    f();\n+}\n+\n+fn main() {\n+    let foo = 0u32;\n+    // tests of unused_underscore lint\n+    let _ = prefix_underscore(foo);\n+    in_macro(foo);\n+    in_struct_field();\n+    // possible false positives\n+    let _ = non_prefix_underscore(foo);\n+    let _ = unused_underscore_simple(foo);\n+    let _ = unused_underscore_complex(foo);\n+    let _ = multiple_underscores(foo);\n+    non_variables();\n+}"}]}